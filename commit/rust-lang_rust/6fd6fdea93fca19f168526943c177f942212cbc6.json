{"sha": "6fd6fdea93fca19f168526943c177f942212cbc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmZDZmZGVhOTNmY2ExOWYxNjg1MjY5NDNjMTc3Zjk0MjIxMmNiYzY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-05T09:48:19Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-05T13:57:21Z"}, "message": "Move everything syntax-related to syntax/, break deps on rest of compiler\n\nsrc/comp/syntax is currently just a sub-module of rustc, but it will,\nin the near future, be its own crate. This includes:\n\n - The AST data structure\n - The parser\n - The pretty-printer\n - Visit, walk, and fold\n - The syntax extension system\n - Some utility stuff that should be in the stdlib*\n\n*) Stdlib extensions currently require a snapshot before they can be\n   used, and the win build is very broken right now. This is temporary\n   and will be cleaned up when one of those problems goes away.\n\nA lot of code was moved by this patch, mostly towards a more organized\nlayout. Some package paths did get longer, and I guess the new layout\nwill take some getting used to. Sorry about that!\n\nPlease try not to re-introduce any dependencies in syntax/ on any of\nthe other src/comp/ subdirs.", "tree": {"sha": "967778dac7798a33628a4e7992f2d26492e9d71f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/967778dac7798a33628a4e7992f2d26492e9d71f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fd6fdea93fca19f168526943c177f942212cbc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fd6fdea93fca19f168526943c177f942212cbc6", "html_url": "https://github.com/rust-lang/rust/commit/6fd6fdea93fca19f168526943c177f942212cbc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fd6fdea93fca19f168526943c177f942212cbc6/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c59ebf0f018b748011fc9b23ce0bab3dcfcfe733", "url": "https://api.github.com/repos/rust-lang/rust/commits/c59ebf0f018b748011fc9b23ce0bab3dcfcfe733", "html_url": "https://github.com/rust-lang/rust/commit/c59ebf0f018b748011fc9b23ce0bab3dcfcfe733"}], "stats": {"total": 2457, "additions": 1254, "deletions": 1203}, "files": [{"sha": "47168a3dd8c536b09cbeaf8c56f46152663bd50f", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -13,7 +13,7 @@ import option::none;\n import std::sha1::sha1;\n import std::sort;\n import trans::crate_ctxt;\n-import front::ast;\n+import syntax::ast;\n import lib::llvm::llvm::ModuleRef;\n import lib::llvm::llvm::ValueRef;\n import lib::llvm::mk_pass_manager;\n@@ -436,7 +436,7 @@ fn mangle_exported_name(&@crate_ctxt ccx, &vec[str] path, &ty::t t) -> str {\n \n fn mangle_internal_name_by_type_only(&@crate_ctxt ccx, &ty::t t, &str name) ->\n    str {\n-    auto s = pretty::ppaux::ty_to_short_str(ccx.tcx, t);\n+    auto s = util::ppaux::ty_to_short_str(ccx.tcx, t);\n     auto hash = get_symbol_hash(ccx, t);\n     ret mangle([name, s, hash]);\n }"}, {"sha": "018c99e153a7029e3435d74f5811591ba9e579f9", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -4,7 +4,7 @@ import lib::llvm::llvm::ModuleRef;\n import std::str;\n import std::vec;\n import std::os::target_os;\n-import util::common::istr;\n+import syntax::_std::istr;\n \n fn get_module_asm() -> str { ret \"\"; }\n "}, {"sha": "9ad42103a9013498c279f7fe9e748410b9b9b1e4", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -2,19 +2,19 @@\n \n // -*- rust -*-\n import metadata::creader;\n-import front::parser;\n-import front::token;\n-import front::eval;\n-import front::ast;\n+import syntax::parse::parser;\n+import syntax::parse::token;\n+import syntax::ast;\n+import syntax::codemap;\n import front::attr;\n import middle::trans;\n import middle::resolve;\n import middle::ty;\n import middle::typeck;\n import middle::tstate::ck;\n-import pretty::pp;\n-import pretty::pprust;\n-import pretty::ppaux;\n+import syntax::print::pp;\n+import syntax::print::pprust;\n+import util::ppaux;\n import back::link;\n import lib::llvm;\n import util::common;\n@@ -76,12 +76,14 @@ fn parse_cfgspecs(&vec[str] cfgspecs) -> ast::crate_cfg {\n     ret vec::map(to_meta_word, cfgspecs);\n }\n \n-fn parse_input(session::session sess, parser::parser p, str input) ->\n-   @ast::crate {\n+fn parse_input(session::session sess, &ast::crate_cfg cfg, str input)\n+    -> @ast::crate {\n     ret if (str::ends_with(input, \".rc\")) {\n-            parser::parse_crate_from_crate_file(p)\n+            parser::parse_crate_from_crate_file\n+                (input, cfg, sess.get_codemap())\n         } else if (str::ends_with(input, \".rs\")) {\n-            parser::parse_crate_from_source_file(p)\n+            parser::parse_crate_from_source_file\n+                (input, cfg, sess.get_codemap())\n         } else { sess.fatal(\"unknown input file type: \" + input); fail };\n }\n \n@@ -99,9 +101,8 @@ fn time[T](bool do_it, str what, fn() -> T  thunk) -> T {\n fn compile_input(session::session sess, ast::crate_cfg cfg, str input,\n                  str output) {\n     auto time_passes = sess.get_opts().time_passes;\n-    auto p = parser::new_parser(sess, cfg, input, 0u, 0);\n     auto crate =\n-        time(time_passes, \"parsing\", bind parse_input(sess, p, input));\n+        time(time_passes, \"parsing\", bind parse_input(sess, cfg, input));\n     if (sess.get_opts().output_type == link::output_type_none) { ret; }\n     crate = time(time_passes, \"configuration\",\n                  bind front::config::strip_unconfigured_items(crate));\n@@ -129,17 +130,17 @@ fn compile_input(session::session sess, ast::crate_cfg cfg, str input,\n \n fn pretty_print_input(session::session sess, ast::crate_cfg cfg,\n                       str input, pp_mode ppm) {\n-    fn ann_paren_for_expr(&ppaux::ann_node node) {\n+    fn ann_paren_for_expr(&pprust::ann_node node) {\n         alt (node) {\n-            case (ppaux::node_expr(?s, ?expr)) {\n+            case (pprust::node_expr(?s, ?expr)) {\n                 pprust::popen(s);\n             }\n             case (_) {}\n         }\n     }\n-    fn ann_typed_post(&ty::ctxt tcx, &ppaux::ann_node node) {\n+    fn ann_typed_post(&ty::ctxt tcx, &pprust::ann_node node) {\n         alt (node) {\n-            case (ppaux::node_expr(?s, ?expr)) {\n+            case (pprust::node_expr(?s, ?expr)) {\n                 pp::space(s.s);\n                 pp::word(s.s, \"as\");\n                 pp::space(s.s);\n@@ -149,18 +150,18 @@ fn pretty_print_input(session::session sess, ast::crate_cfg cfg,\n             case (_) {}\n         }\n     }\n-    fn ann_identified_post(&ppaux::ann_node node) {\n+    fn ann_identified_post(&pprust::ann_node node) {\n         alt (node) {\n-            case (ppaux::node_item(?s, ?item)) {\n+            case (pprust::node_item(?s, ?item)) {\n                 pp::space(s.s);\n                 pprust::synth_comment(s, int::to_str(item.id, 10u));\n             }\n-            case (ppaux::node_block(?s, ?blk)) {\n+            case (pprust::node_block(?s, ?blk)) {\n                 pp::space(s.s);\n                 pprust::synth_comment(s, \"block \" +\n                                       int::to_str(blk.node.id, 10u));\n             }\n-            case (ppaux::node_expr(?s, ?expr)) {\n+            case (pprust::node_expr(?s, ?expr)) {\n                 pp::space(s.s);\n                 pprust::synth_comment(s, int::to_str(expr.id, 10u));\n                 pprust::pclose(s);\n@@ -169,8 +170,7 @@ fn pretty_print_input(session::session sess, ast::crate_cfg cfg,\n         }\n     }\n \n-    auto p = front::parser::new_parser(sess, cfg, input, 0u, 0);\n-    auto crate = parse_input(sess, p, input);\n+    auto crate = parse_input(sess, cfg, input);\n     auto ann;\n     alt (ppm) {\n         case (ppm_typed) {\n@@ -186,10 +186,11 @@ fn pretty_print_input(session::session sess, ast::crate_cfg cfg,\n                       post=ann_identified_post);\n         }\n         case (ppm_normal) {\n-            ann = ppaux::no_ann();\n+            ann = pprust::no_ann();\n         }\n     }\n-    pprust::print_crate(sess, crate, input, std::io::stdout(), ann);\n+    pprust::print_crate(sess.get_codemap(), crate, input,\n+                        std::io::stdout(), ann);\n }\n \n fn version(str argv0) {\n@@ -268,9 +269,9 @@ fn build_target_config() -> @session::config {\n     let @session::config target_cfg =\n         @rec(os=get_os(triple),\n              arch=get_arch(triple),\n-             int_type=common::ty_i32,\n-             uint_type=common::ty_u32,\n-             float_type=common::ty_f64);\n+             int_type=ast::ty_i32,\n+             uint_type=ast::ty_u32,\n+             float_type=ast::ty_f64);\n     ret target_cfg;\n }\n \n@@ -342,11 +343,11 @@ fn build_session_options(str binary, getopts::match match, str binary_dir) ->\n \n fn build_session(@session::options sopts) -> session::session {\n     auto target_cfg = build_target_config();\n-    auto crate_cache = common::new_int_hash[session::crate_metadata]();\n+    auto crate_cache = syntax::_std::new_int_hash[session::crate_metadata]();\n     auto target_crate_num = 0;\n     auto sess =\n         session::session(target_crate_num, target_cfg, sopts, crate_cache, [],\n-                         [], [], front::codemap::new_codemap(), 0u);\n+                         [], [], codemap::new_codemap(), 0u);\n     ret sess;\n }\n "}, {"sha": "8ef558f2fdebb5217036c2e05e3d5fae19b530ad", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 15, "deletions": 41, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,10 +1,9 @@\n \n-import front::ast;\n-import front::codemap;\n-import util::common::span;\n-import util::common::ty_mach;\n+import syntax::ast;\n+import syntax::codemap;\n+import codemap::span;\n+import syntax::ast::ty_mach;\n import std::uint;\n-import std::term;\n import std::io;\n import std::map;\n import std::option;\n@@ -42,30 +41,6 @@ type options =\n \n type crate_metadata = rec(str name, vec[u8] data);\n \n-fn span_to_str(span sp, codemap::codemap cm) -> str {\n-    auto lo = codemap::lookup_pos(cm, sp.lo);\n-    auto hi = codemap::lookup_pos(cm, sp.hi);\n-    ret #fmt(\"%s:%u:%u:%u:%u\", lo.filename, lo.line, lo.col, hi.line, hi.col);\n-}\n-\n-fn emit_diagnostic(option::t[span] sp, str msg, str kind, u8 color,\n-                   codemap::codemap cm) {\n-    auto ss = \"<input>:0:0:0:0\";\n-    alt (sp) {\n-        case (some(?ssp)) { ss = span_to_str(ssp, cm); }\n-        case (none) { }\n-    }\n-    io::stdout().write_str(ss + \": \");\n-    if (term::color_supported()) {\n-        term::fg(io::stdout().get_buf_writer(), color);\n-    }\n-    io::stdout().write_str(#fmt(\"%s:\", kind));\n-    if (term::color_supported()) {\n-        term::reset(io::stdout().get_buf_writer());\n-    }\n-    io::stdout().write_str(#fmt(\" %s\\n\", msg));\n-}\n-\n obj session(ast::crate_num cnum,\n             @config targ_cfg,\n             @options opts,\n@@ -80,20 +55,19 @@ obj session(ast::crate_num cnum,\n     fn get_targ_crate_num() -> ast::crate_num { ret cnum; }\n     fn span_fatal(span sp, str msg) -> ! {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-\n-        emit_diagnostic(some(sp), msg, \"error\", 9u8, cm);\n+        codemap::emit_error(some(sp), msg, cm);\n         fail;\n     }\n     fn fatal(str msg) -> ! {\n-        emit_diagnostic(none[span], msg, \"error\", 9u8, cm);\n+        codemap::emit_error(none, msg, cm);\n         fail;\n     }\n     fn span_err(span sp, str msg) {\n-        emit_diagnostic(some(sp), msg, \"error\", 9u8, cm);\n+        codemap::emit_error(some(sp), msg, cm);\n         err_count += 1u;\n     }\n     fn err(str msg) {\n-        emit_diagnostic(none, msg, \"error\", 9u8, cm);\n+        codemap::emit_error(none, msg, cm);\n         err_count += 1u;\n     }\n     fn abort_if_errors() {\n@@ -103,19 +77,17 @@ obj session(ast::crate_num cnum,\n     }\n     fn span_warn(span sp, str msg) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-\n-        emit_diagnostic(some(sp), msg, \"warning\", 11u8, cm);\n+        codemap::emit_warning(some(sp), msg, cm);\n     }\n     fn warn(str msg) {\n-        emit_diagnostic(none[span], msg, \"warning\", 11u8, cm);\n+        codemap::emit_warning(none, msg, cm);\n     }\n     fn span_note(span sp, str msg) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-\n-        emit_diagnostic(some(sp), msg, \"note\", 10u8, cm);\n+        codemap::emit_note(some(sp), msg, cm);\n     }\n     fn note(str msg) {\n-        emit_diagnostic(none, msg, \"note\", 10u8, cm);\n+        codemap::emit_note(none, msg, cm);\n     }\n     fn span_bug(span sp, str msg) -> ! {\n         self.span_fatal(sp, #fmt(\"internal compiler error %s\", msg));\n@@ -172,7 +144,9 @@ obj session(ast::crate_num cnum,\n     fn lookup_pos(uint pos) -> codemap::loc {\n         ret codemap::lookup_pos(cm, pos);\n     }\n-    fn span_str(span sp) -> str { ret span_to_str(sp, self.get_codemap()); }\n+    fn span_str(span sp) -> str {\n+        ret codemap::span_to_str(sp, self.get_codemap());\n+    }\n }\n // Local Variables:\n // fill-column: 78;"}, {"sha": "00e64e33f6bbdc39cbdd976af8d471f19afb042e", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -2,7 +2,7 @@\n \n import std::vec;\n import std::option;\n-import front::ast;\n+import syntax::ast;\n import util::common;\n \n export attr_metas;\n@@ -105,9 +105,11 @@ fn eq(@ast::meta_item a, @ast::meta_item b) -> bool {\n }\n \n fn contains(&vec[@ast::meta_item] haystack, @ast::meta_item needle) -> bool {\n-    log #fmt(\"looking for %s\", pretty::pprust::meta_item_to_str(*needle));\n+    log #fmt(\"looking for %s\",\n+             syntax::print::pprust::meta_item_to_str(*needle));\n     for (@ast::meta_item item in haystack) {\n-        log #fmt(\"looking in %s\", pretty::pprust::meta_item_to_str(*item));\n+        log #fmt(\"looking in %s\",\n+                 syntax::print::pprust::meta_item_to_str(*item));\n         if (eq(item, needle)) {\n             log \"found it!\";\n             ret true;\n@@ -166,7 +168,7 @@ fn remove_meta_items_by_name(&vec[@ast::meta_item] items,\n     ret vec::filter_map(filter, items);\n }\n \n-fn span[T](&T item) -> common::spanned[T] {\n+fn span[T](&T item) -> ast::spanned[T] {\n     ret rec(node=item, span=rec(lo=0u, hi=0u));\n }\n "}, {"sha": "3e1aa3c59400b62f6e0b6e0d6832424ec1b04464", "filename": "src/comp/front/codemap.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c59ebf0f018b748011fc9b23ce0bab3dcfcfe733/src%2Fcomp%2Ffront%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ebf0f018b748011fc9b23ce0bab3dcfcfe733/src%2Fcomp%2Ffront%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcodemap.rs?ref=c59ebf0f018b748011fc9b23ce0bab3dcfcfe733", "patch": "@@ -1,52 +0,0 @@\n-\n-import std::vec;\n-\n-\n-/* A codemap is a thing that maps uints to file/line/column positions\n- * in a crate. This to make it possible to represent the positions\n- * with single-word things, rather than passing records all over the\n- * compiler.\n- */\n-type filemap = @rec(str name, uint start_pos, mutable vec[uint] lines);\n-\n-type codemap = @rec(mutable vec[filemap] files);\n-\n-type loc = rec(str filename, uint line, uint col);\n-\n-fn new_codemap() -> codemap {\n-    let vec[filemap] files = [];\n-    ret @rec(mutable files=files);\n-}\n-\n-fn new_filemap(str filename, uint start_pos) -> filemap {\n-    ret @rec(name=filename, start_pos=start_pos, mutable lines=[0u]);\n-}\n-\n-fn next_line(filemap file, uint pos) { vec::push[uint](file.lines, pos); }\n-\n-fn lookup_pos(codemap map, uint pos) -> loc {\n-    auto a = 0u;\n-    auto b = vec::len[filemap](map.files);\n-    while (b - a > 1u) {\n-        auto m = (a + b) / 2u;\n-        if (map.files.(m).start_pos > pos) { b = m; } else { a = m; }\n-    }\n-    auto f = map.files.(a);\n-    a = 0u;\n-    b = vec::len[uint](f.lines);\n-    while (b - a > 1u) {\n-        auto m = (a + b) / 2u;\n-        if (f.lines.(m) > pos) { b = m; } else { a = m; }\n-    }\n-    ret rec(filename=f.name, line=a + 1u, col=pos - f.lines.(a));\n-}\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//"}, {"sha": "63646ffca69d86430b2fa5845d5e0fd0795f049e", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,7 +1,7 @@\n import std::option;\n import std::vec;\n-import ast;\n-import fold;\n+import syntax::ast;\n+import syntax::fold;\n import attr;\n \n export strip_unconfigured_items;"}, {"sha": "8a9c5aa58570b73a98d16f10b6a5becf19abcab4", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1457,7 +1457,7 @@ state obj type_names(std::map::hashmap[TypeRef, str] type_names,\n }\n \n fn mk_type_names() -> type_names {\n-    auto nt = util::common::new_str_hash[TypeRef]();\n+    auto nt = syntax::_std::new_str_hash[TypeRef]();\n \n     fn hash(&TypeRef t) -> uint {\n         ret t as uint;\n@@ -1519,7 +1519,7 @@ fn type_to_str_inner(type_names names,\n         case (6) { ret \"Label\"; }\n \n         case (7) {\n-            ret \"i\" + util::common::istr(llvm::LLVMGetIntTypeWidth(ty)\n+            ret \"i\" + syntax::_std::istr(llvm::LLVMGetIntTypeWidth(ty)\n                                          as int);\n         }\n \n@@ -1558,7 +1558,7 @@ fn type_to_str_inner(type_names names,\n                 i += 1u;\n                 if (tout as int == ty as int) {\n                     let uint n = vec::len[TypeRef](outer0) - i;\n-                    ret \"*\\\\\" + util::common::istr(n as int);\n+                    ret \"*\\\\\" + syntax::_std::istr(n as int);\n                 }\n             }\n             ret \"*\" + type_to_str_inner(names, outer,"}, {"sha": "5ef08cfd02d06cd45cb6af21d2c8081677a76419", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,14 +1,15 @@\n // Extracting metadata from crate files\n \n import driver::session;\n-import front::ast;\n+import syntax::ast;\n import lib::llvm::False;\n import lib::llvm::llvm;\n import lib::llvm::mk_object_file;\n import lib::llvm::mk_section_iter;\n import front::attr;\n import middle::resolve;\n-import middle::walk;\n+import syntax::walk;\n+import syntax::codemap::span;\n import back::x86;\n import util::common;\n import std::str;\n@@ -20,7 +21,7 @@ import std::option;\n import std::option::none;\n import std::option::some;\n import std::map::hashmap;\n-import pretty::pprust;\n+import syntax::print::pprust;\n import tags::*;\n \n export read_crates;\n@@ -129,7 +130,7 @@ fn get_metadata_section(str filename) -> option::t[vec[u8]] {\n     ret option::none[vec[u8]];\n }\n \n-fn load_library_crate(&session::session sess, common::span span, int cnum,\n+fn load_library_crate(&session::session sess, span span, int cnum,\n                       &ast::ident ident, vec[@ast::meta_item] metas,\n                       &vec[str] library_search_paths) {\n     alt (find_library_crate(sess, ident, metas, library_search_paths)) {\n@@ -202,7 +203,7 @@ fn read_crates(session::session sess, resolve::crate_map crate_map,\n     auto e =\n         @rec(sess=sess,\n              crate_map=crate_map,\n-             crate_cache=@common::new_str_hash[int](),\n+             crate_cache=@syntax::_std::new_str_hash[int](),\n              library_search_paths=sess.get_opts().library_search_paths,\n              mutable next_crate_num=1);\n     auto v ="}, {"sha": "3c1875d07d4be401542fb156ac7928c34d165a3e", "filename": "src/comp/metadata/cwriter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmetadata%2Fcwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmetadata%2Fcwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcwriter.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -2,7 +2,7 @@\n \n import std::str;\n import middle::trans;\n-import front::ast::crate;\n+import syntax::ast::crate;\n import back::x86;\n import lib::llvm::llvm;\n import lib::llvm::llvm::ValueRef;"}, {"sha": "14d4035185f0b4dde922ae8aba54af890d71844b", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -6,15 +6,15 @@ import std::vec;\n import std::str;\n import std::io;\n import std::map::hashmap;\n-import front::ast;\n+import syntax::ast;\n import front::attr;\n import middle::ty;\n import tags::*;\n import tydecode::parse_def_id;\n import tydecode::parse_ty_data;\n import driver::session;\n import util::common;\n-import pretty::pprust;\n+import syntax::print::pprust;\n \n export get_symbol;\n export get_tag_variants;"}, {"sha": "4526e515f7987dce61cd6c70f8ea598fd56bf86d", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -8,7 +8,7 @@ import std::option;\n import std::option::some;\n import std::option::none;\n import std::ebml;\n-import front::ast::*;\n+import syntax::ast::*;\n import tags::*;\n import middle::trans::crate_ctxt;\n import middle::trans::node_id_type;"}, {"sha": "b40a84ec30551a384fc6ef06705d66487837944f", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -6,12 +6,9 @@ import std::uint;\n import std::option;\n import std::option::none;\n import std::option::some;\n-import front::ast;\n+import syntax::ast;\n+import ast::respan;\n import middle::ty;\n-import util::common;\n-import util::common::respan;\n-import util::common::a_ty;\n-import util::common::a_bang;\n \n export parse_def_id;\n export parse_ty_data;\n@@ -26,7 +23,7 @@ type str_def = fn(str) -> ast::def_id ;\n type pstate =\n     rec(vec[u8] data, int crate, mutable uint pos, uint len, ty::ctxt tcx);\n \n-type ty_or_bang = util::common::ty_or_bang[ty::t];\n+tag ty_or_bang { a_ty(ty::t); a_bang; }\n \n fn peek(@pstate st) -> u8 { ret st.data.(st.pos); }\n \n@@ -63,8 +60,8 @@ fn parse_ty_data(vec[u8] data, int crate_num, uint pos, uint len, str_def sd,\n \n fn parse_ty_or_bang(@pstate st, str_def sd) -> ty_or_bang {\n     alt (peek(st) as char) {\n-        case ('!') { next(st); ret a_bang[ty::t]; }\n-        case (_) { ret a_ty[ty::t](parse_ty(st, sd)); }\n+        case ('!') { next(st); ret a_bang; }\n+        case (_) { ret a_ty(parse_ty(st, sd)); }\n     }\n }\n \n@@ -154,16 +151,16 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         case ('l') { ret ty::mk_float(st.tcx); }\n         case ('M') {\n             alt (next(st) as char) {\n-                case ('b') { ret ty::mk_mach(st.tcx, common::ty_u8); }\n-                case ('w') { ret ty::mk_mach(st.tcx, common::ty_u16); }\n-                case ('l') { ret ty::mk_mach(st.tcx, common::ty_u32); }\n-                case ('d') { ret ty::mk_mach(st.tcx, common::ty_u64); }\n-                case ('B') { ret ty::mk_mach(st.tcx, common::ty_i8); }\n-                case ('W') { ret ty::mk_mach(st.tcx, common::ty_i16); }\n-                case ('L') { ret ty::mk_mach(st.tcx, common::ty_i32); }\n-                case ('D') { ret ty::mk_mach(st.tcx, common::ty_i64); }\n-                case ('f') { ret ty::mk_mach(st.tcx, common::ty_f32); }\n-                case ('F') { ret ty::mk_mach(st.tcx, common::ty_f64); }\n+                case ('b') { ret ty::mk_mach(st.tcx, ast::ty_u8); }\n+                case ('w') { ret ty::mk_mach(st.tcx, ast::ty_u16); }\n+                case ('l') { ret ty::mk_mach(st.tcx, ast::ty_u32); }\n+                case ('d') { ret ty::mk_mach(st.tcx, ast::ty_u64); }\n+                case ('B') { ret ty::mk_mach(st.tcx, ast::ty_i8); }\n+                case ('W') { ret ty::mk_mach(st.tcx, ast::ty_i16); }\n+                case ('L') { ret ty::mk_mach(st.tcx, ast::ty_i32); }\n+                case ('D') { ret ty::mk_mach(st.tcx, ast::ty_i64); }\n+                case ('f') { ret ty::mk_mach(st.tcx, ast::ty_f32); }\n+                case ('F') { ret ty::mk_mach(st.tcx, ast::ty_f64); }\n             }\n         }\n         case ('c') { ret ty::mk_char(st.tcx); }"}, {"sha": "af7f3f67118cb384ec296a87004261c8ba586437", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -5,9 +5,9 @@ import std::map::hashmap;\n import std::option::some;\n import std::option::none;\n import std::uint;\n-import front::ast::*;\n+import syntax::ast::*;\n import middle::ty;\n-import pretty::ppaux::lit_to_str;\n+import syntax::print::pprust::lit_to_str;\n import util::common;\n \n export ctxt;\n@@ -105,16 +105,16 @@ fn enc_sty(&io::writer w, &@ctxt cx, &ty::sty st) {\n         case (ty::ty_float) { w.write_char('l'); }\n         case (ty::ty_machine(?mach)) {\n             alt (mach) {\n-                case (common::ty_u8) { w.write_str(\"Mb\"); }\n-                case (common::ty_u16) { w.write_str(\"Mw\"); }\n-                case (common::ty_u32) { w.write_str(\"Ml\"); }\n-                case (common::ty_u64) { w.write_str(\"Md\"); }\n-                case (common::ty_i8) { w.write_str(\"MB\"); }\n-                case (common::ty_i16) { w.write_str(\"MW\"); }\n-                case (common::ty_i32) { w.write_str(\"ML\"); }\n-                case (common::ty_i64) { w.write_str(\"MD\"); }\n-                case (common::ty_f32) { w.write_str(\"Mf\"); }\n-                case (common::ty_f64) { w.write_str(\"MF\"); }\n+                case (ty_u8) { w.write_str(\"Mb\"); }\n+                case (ty_u16) { w.write_str(\"Mw\"); }\n+                case (ty_u32) { w.write_str(\"Ml\"); }\n+                case (ty_u64) { w.write_str(\"Md\"); }\n+                case (ty_i8) { w.write_str(\"MB\"); }\n+                case (ty_i16) { w.write_str(\"MW\"); }\n+                case (ty_i32) { w.write_str(\"ML\"); }\n+                case (ty_i64) { w.write_str(\"MD\"); }\n+                case (ty_f32) { w.write_str(\"Mf\"); }\n+                case (ty_f64) { w.write_str(\"MF\"); }\n             }\n         }\n         case (ty::ty_char) { w.write_char('c'); }\n@@ -182,7 +182,7 @@ fn enc_sty(&io::writer w, &@ctxt cx, &ty::sty st) {\n         }\n         case (ty::ty_var(?id)) {\n             w.write_char('X');\n-            w.write_str(common::istr(id));\n+            w.write_str(syntax::_std::istr(id));\n         }\n         case (ty::ty_native(?def)) {\n             w.write_char('E');\n@@ -191,7 +191,7 @@ fn enc_sty(&io::writer w, &@ctxt cx, &ty::sty st) {\n         }\n         case (ty::ty_param(?id)) {\n             w.write_char('p');\n-            w.write_str(common::uistr(id));\n+            w.write_str(syntax::_std::uistr(id));\n         }\n         case (ty::ty_type) { w.write_char('Y'); }\n         case (ty::ty_task) { w.write_char('a'); }"}, {"sha": "e419426c969187b44f6fb62f4ac88e3fd3be132c", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,10 +1,11 @@\n \n-import front::ast;\n-import front::ast::ident;\n-import front::ast::fn_ident;\n-import front::ast::node_id;\n-import front::ast::def_id;\n-import util::common::span;\n+import syntax::ast;\n+import ast::ident;\n+import ast::fn_ident;\n+import ast::node_id;\n+import ast::def_id;\n+import syntax::codemap::span;\n+import syntax::visit;\n import visit::vt;\n import std::vec;\n import std::str;\n@@ -44,7 +45,7 @@ fn check_crate(@ty::ctxt tcx, &@ast::crate crate) {\n \n              // Stores information about object fields and function\n              // arguments that's otherwise not easily available.\n-             local_map=util::common::new_int_hash());\n+             local_map=syntax::_std::new_int_hash());\n     auto v =\n         @rec(visit_fn=bind visit_fn(cx, _, _, _, _, _, _, _),\n              visit_item=bind visit_item(cx, _, _, _),\n@@ -348,7 +349,7 @@ fn check_for(&ctx cx, &@ast::local local, &@ast::expr seq, &ast::block block,\n         case (ty::ty_istr) { /* no-op */ }\n         case (_) {\n             cx.tcx.sess.span_unimpl(seq.span, \"unknown seq type \" +\n-                                    pretty::ppaux::ty_to_str(*cx.tcx, seq_t));\n+                                    util::ppaux::ty_to_str(*cx.tcx, seq_t));\n         }\n     }\n     auto new_sc ="}, {"sha": "9b19e6a9970d35d4dc6c5a7378344507fd94ce6c", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,6 +1,7 @@\n import std::smallintmap;\n import std::option;\n-import front::ast::*;\n+import syntax::ast::*;\n+import syntax::visit;\n import visit::vt;\n \n tag ast_node {"}, {"sha": "2e3ed81290053db58ee76ddcd181617ac9813025", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,21 +1,22 @@\n \n-import front::ast;\n-import front::ast::ident;\n-import front::ast::fn_ident;\n-import front::ast::def;\n-import front::ast::def_id;\n-import front::ast::node_id;\n-import front::ast::local_def;\n+import syntax::ast;\n+import ast::ident;\n+import ast::fn_ident;\n+import ast::def;\n+import ast::def_id;\n+import ast::node_id;\n+import ast::local_def;\n \n import metadata::creader;\n import metadata::decoder;\n import driver::session::session;\n import util::common::new_def_hash;\n-import util::common::new_int_hash;\n-import util::common::new_str_hash;\n-import util::common::span;\n-import util::common::respan;\n+import syntax::_std::new_int_hash;\n+import syntax::_std::new_str_hash;\n+import syntax::codemap::span;\n+import syntax::ast::respan;\n import middle::ty::constr_table;\n+import syntax::visit;\n import visit::vt;\n import std::map::hashmap;\n import std::list;"}, {"sha": "f2c00abd6f101af9c2e5c818e927c1e3873e2a3b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 46, "deletions": 44, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -24,22 +24,24 @@ import std::option;\n import std::option::some;\n import std::option::none;\n import std::fs;\n-import front::ast;\n+import syntax::ast;\n+import syntax::walk;\n import driver::session;\n import middle::ty;\n import back::link;\n import back::x86;\n import back::abi;\n import back::upcall;\n import middle::ty::pat_ty;\n+import syntax::visit;\n import visit::vt;\n import util::common;\n-import util::common::istr;\n+import syntax::_std::istr;\n import util::common::new_def_hash;\n-import util::common::new_int_hash;\n-import util::common::new_str_hash;\n+import syntax::_std::new_int_hash;\n+import syntax::_std::new_str_hash;\n import util::common::local_rhs_span;\n-import util::common::span;\n+import syntax::codemap::span;\n import lib::llvm::llvm;\n import lib::llvm::builder;\n import lib::llvm::target_data;\n@@ -65,10 +67,10 @@ import link::mangle_exported_name;\n import metadata::tyencode;\n import metadata::creader;\n import metadata::decoder;\n-import pretty::ppaux::ty_to_str;\n-import pretty::ppaux::ty_to_short_str;\n-import pretty::pprust::expr_to_str;\n-import pretty::pprust::path_to_str;\n+import util::ppaux::ty_to_str;\n+import util::ppaux::ty_to_short_str;\n+import syntax::print::pprust::expr_to_str;\n+import syntax::print::pprust::path_to_str;\n \n obj namegen(mutable int i) {\n     fn next(str prefix) -> str { i += 1; ret prefix + istr(i); }\n@@ -795,16 +797,16 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n         case (ty::ty_uint) { llty = T_int(); }\n         case (ty::ty_machine(?tm)) {\n             alt (tm) {\n-                case (common::ty_i8) { llty = T_i8(); }\n-                case (common::ty_u8) { llty = T_i8(); }\n-                case (common::ty_i16) { llty = T_i16(); }\n-                case (common::ty_u16) { llty = T_i16(); }\n-                case (common::ty_i32) { llty = T_i32(); }\n-                case (common::ty_u32) { llty = T_i32(); }\n-                case (common::ty_i64) { llty = T_i64(); }\n-                case (common::ty_u64) { llty = T_i64(); }\n-                case (common::ty_f32) { llty = T_f32(); }\n-                case (common::ty_f64) { llty = T_f64(); }\n+                case (ast::ty_i8) { llty = T_i8(); }\n+                case (ast::ty_u8) { llty = T_i8(); }\n+                case (ast::ty_i16) { llty = T_i16(); }\n+                case (ast::ty_u16) { llty = T_i16(); }\n+                case (ast::ty_i32) { llty = T_i32(); }\n+                case (ast::ty_u32) { llty = T_i32(); }\n+                case (ast::ty_i64) { llty = T_i64(); }\n+                case (ast::ty_u64) { llty = T_i64(); }\n+                case (ast::ty_f32) { llty = T_f32(); }\n+                case (ast::ty_f64) { llty = T_f64(); }\n             }\n         }\n         case (ty::ty_char) { llty = T_char(); }\n@@ -2363,7 +2365,7 @@ fn make_cmp_glue(&@block_ctxt cx, ValueRef lhs0, ValueRef rhs0, &ty::t t,\n     } else {\n         // FIXME: compare obj, fn by pointer?\n \n-        trans_fail(cx, none[common::span],\n+        trans_fail(cx, none[span],\n                    \"attempt to compare values of type \" +\n                        ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n     }\n@@ -2402,7 +2404,7 @@ fn compare_scalar_types(@block_ctxt cx, ValueRef lhs, ValueRef rhs, &ty::t t,\n         }\n         case (ty::ty_char) { ret f(unsigned_int); }\n         case (ty::ty_type) {\n-            trans_fail(cx, none[common::span],\n+            trans_fail(cx, none[span],\n                        \"attempt to compare values of type type\");\n \n             // This is a bit lame, because we return a dummy block to the\n@@ -2412,7 +2414,7 @@ fn compare_scalar_types(@block_ctxt cx, ValueRef lhs, ValueRef rhs, &ty::t t,\n                      C_bool(false));\n         }\n         case (ty::ty_native(_)) {\n-            trans_fail(cx, none[common::span],\n+            trans_fail(cx, none[span],\n                        \"attempt to compare values of type native\");\n             ret rslt(new_sub_block_ctxt(cx, \"after_fail_dummy\"),\n                      C_bool(false));\n@@ -2752,7 +2754,7 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n             ret iter_ivec(cx, av, bv, unit_tm.ty, f);\n         }\n         case (ty::ty_istr) {\n-            auto unit_ty = ty::mk_mach(cx.fcx.lcx.ccx.tcx, common::ty_u8);\n+            auto unit_ty = ty::mk_mach(cx.fcx.lcx.ccx.tcx, ast::ty_u8);\n             ret iter_ivec(cx, av, bv, unit_ty, f);\n         }\n         case (_) {\n@@ -2858,14 +2860,14 @@ fn iter_sequence(@block_ctxt cx, ValueRef v, &ty::t t, &val_and_ty_fn f) ->\n             ret iter_sequence_body(cx, v, elt.ty, f, false, false);\n         }\n         case (ty::ty_str) {\n-            auto et = ty::mk_mach(cx.fcx.lcx.ccx.tcx, common::ty_u8);\n+            auto et = ty::mk_mach(cx.fcx.lcx.ccx.tcx, ast::ty_u8);\n             ret iter_sequence_body(cx, v, et, f, true, false);\n         }\n         case (ty::ty_ivec(?elt)) {\n             ret iter_sequence_body(cx, v, elt.ty, f, false, true);\n         }\n         case (ty::ty_istr) {\n-            auto et = ty::mk_mach(cx.fcx.lcx.ccx.tcx, common::ty_u8);\n+            auto et = ty::mk_mach(cx.fcx.lcx.ccx.tcx, ast::ty_u8);\n             ret iter_sequence_body(cx, v, et, f, true, true);\n         }\n         case (_) {\n@@ -3179,7 +3181,7 @@ fn duplicate_heap_parts_if_necessary(&@block_ctxt cx, ValueRef vptr,\n       }\n       case (ty::ty_istr) {\n         ret ivec::duplicate_heap_part(cx, vptr,\n-            ty::mk_mach(cx.fcx.lcx.ccx.tcx, common::ty_u8));\n+            ty::mk_mach(cx.fcx.lcx.ccx.tcx, ast::ty_u8));\n       }\n       case (_) { ret rslt(cx, C_nil()); }\n     }\n@@ -3276,23 +3278,23 @@ fn trans_lit(&@crate_ctxt cx, &ast::lit lit, ast::node_id id) -> ValueRef {\n             auto t = T_int();\n             auto s = True;\n             alt (tm) {\n-                case (common::ty_u8) { t = T_i8(); s = False; }\n-                case (common::ty_u16) { t = T_i16(); s = False; }\n-                case (common::ty_u32) { t = T_i32(); s = False; }\n-                case (common::ty_u64) { t = T_i64(); s = False; }\n-                case (common::ty_i8) { t = T_i8(); }\n-                case (common::ty_i16) { t = T_i16(); }\n-                case (common::ty_i32) { t = T_i32(); }\n-                case (common::ty_i64) { t = T_i64(); }\n+                case (ast::ty_u8) { t = T_i8(); s = False; }\n+                case (ast::ty_u16) { t = T_i16(); s = False; }\n+                case (ast::ty_u32) { t = T_i32(); s = False; }\n+                case (ast::ty_u64) { t = T_i64(); s = False; }\n+                case (ast::ty_i8) { t = T_i8(); }\n+                case (ast::ty_i16) { t = T_i16(); }\n+                case (ast::ty_i32) { t = T_i32(); }\n+                case (ast::ty_i64) { t = T_i64(); }\n             }\n             ret C_integral(t, i as uint, s);\n         }\n         case (ast::lit_float(?fs)) { ret C_float(fs); }\n         case (ast::lit_mach_float(?tm, ?s)) {\n             auto t = T_float();\n             alt (tm) {\n-                case (common::ty_f32) { t = T_f32(); }\n-                case (common::ty_f64) { t = T_f64(); }\n+                case (ast::ty_f32) { t = T_f32(); }\n+                case (ast::ty_f64) { t = T_f64(); }\n             }\n             ret C_floating(s, t);\n         }\n@@ -4768,7 +4770,7 @@ fn trans_alt(&@block_ctxt cx, &@ast::expr expr, &vec[ast::arm] arms,\n         this_cx = next_cx;\n     }\n     auto default_cx = this_cx;\n-    trans_fail(default_cx, some[common::span](expr.span),\n+    trans_fail(default_cx, some[span](expr.span),\n                \"non-exhaustive match failure\");\n     ret rslt(join_branches(cx, arm_results), C_nil());\n }\n@@ -5028,7 +5030,7 @@ fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base, &@ast::expr idx,\n     bcx.build.CondBr(bounds_check, next_cx.llbb, fail_cx.llbb);\n     // fail: bad bounds check.\n \n-    trans_fail(fail_cx, some[common::span](sp), \"bounds check\");\n+    trans_fail(fail_cx, some[span](sp), \"bounds check\");\n     auto body;\n     alt (interior_len_and_data) {\n         case (some(?lad)) { body = lad._1; }\n@@ -6313,11 +6315,11 @@ fn trans_log(int lvl, &@block_ctxt cx, &@ast::expr e) -> result {\n         let TypeRef tr;\n         let bool is32bit = false;\n         alt (ty::struct(cx.fcx.lcx.ccx.tcx, e_ty)) {\n-            case (ty::ty_machine(util::common::ty_f32)) {\n+            case (ty::ty_machine(ast::ty_f32)) {\n                 tr = T_f32();\n                 is32bit = true;\n             }\n-            case (ty::ty_machine(util::common::ty_f64)) { tr = T_f64(); }\n+            case (ty::ty_machine(ast::ty_f64)) { tr = T_f64(); }\n             case (_) { tr = T_float(); }\n         }\n         if (is32bit) {\n@@ -6366,13 +6368,13 @@ fn trans_check_expr(&@block_ctxt cx, &@ast::expr e, &str s) -> result {\n     auto cond_res = trans_expr(cx, e);\n     auto expr_str = s + \" \" + expr_to_str(e) + \" failed\";\n     auto fail_cx = new_sub_block_ctxt(cx, \"fail\");\n-    trans_fail(fail_cx, some[common::span](e.span), expr_str);\n+    trans_fail(fail_cx, some[span](e.span), expr_str);\n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n     cond_res.bcx.build.CondBr(cond_res.val, next_cx.llbb, fail_cx.llbb);\n     ret rslt(next_cx, C_nil());\n }\n \n-fn trans_fail_expr(&@block_ctxt cx, &option::t[common::span] sp_opt,\n+fn trans_fail_expr(&@block_ctxt cx, &option::t[span] sp_opt,\n                    &option::t[@ast::expr] fail_expr)\n         -> result {\n     auto bcx = cx;\n@@ -6399,13 +6401,13 @@ fn trans_fail_expr(&@block_ctxt cx, &option::t[common::span] sp_opt,\n     }\n }\n  \n-fn trans_fail(&@block_ctxt cx, &option::t[common::span] sp_opt, &str fail_str)\n+fn trans_fail(&@block_ctxt cx, &option::t[span] sp_opt, &str fail_str)\n    -> result {\n     auto V_fail_str = C_cstr(cx.fcx.lcx.ccx, fail_str);\n     ret trans_fail_value(cx, sp_opt, V_fail_str);\n }\n \n-fn trans_fail_value(&@block_ctxt cx, &option::t[common::span] sp_opt,\n+fn trans_fail_value(&@block_ctxt cx, &option::t[span] sp_opt,\n                     &ValueRef V_fail_str)\n         -> result {\n     auto V_filename;"}, {"sha": "aa9267656e4517f41537038c02391b1d7a0491b9", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,5 +1,4 @@\n \n-import front::ast::ident;\n import std::vec;\n import tritv::*;\n "}, {"sha": "abffc3a97e35719eb67354d89a13abcfd0b0006b", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -3,11 +3,12 @@ import std::vec;\n import std::option;\n import std::option::some;\n import std::option::none;\n-import front::ast::*;\n-import util::common::istr;\n-import util::common::uistr;\n-import util::common::span;\n-import util::common::new_str_hash;\n+import syntax::ast::*;\n+import syntax::walk;\n+import syntax::codemap::span;\n+import syntax::_std::istr;\n+import syntax::_std::uistr;\n+import syntax::_std::new_str_hash;\n import util::common::log_expr_err;\n import util::common::log_block_err;\n import util::common::log_item_err;"}, {"sha": "123f51e7a7022b896adb8fb72105d08217754187", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -7,20 +7,17 @@ import std::option;\n import std::option::none;\n import std::option::some;\n import std::option::maybe;\n-import front::ast;\n-import front::ast::*;\n+import syntax::ast::*;\n+import syntax::codemap::span;\n import util::common;\n-import util::common::span;\n-import util::common::spanned;\n-import util::common::respan;\n import util::common::log_block;\n-import util::common::new_int_hash;\n-import util::common::new_uint_hash;\n+import syntax::_std::new_int_hash;\n+import syntax::_std::new_uint_hash;\n import util::common::log_expr_err;\n-import util::common::istr;\n-import util::common::uistr;\n+import syntax::_std::istr;\n+import syntax::_std::uistr;\n import util::common::lit_eq;\n-import pretty::pprust::path_to_str;\n+import syntax::print::pprust::path_to_str;\n import tstate::ann::pre_and_post;\n import tstate::ann::pre_and_post_state;\n import tstate::ann::empty_ann;\n@@ -42,8 +39,8 @@ import tstate::ann::clear_in_poststate;\n import tstate::ann::clear_in_poststate_;\n import tritv::*;\n \n-import pretty::ppaux::constr_args_to_str;\n-import pretty::ppaux::lit_to_str;\n+import syntax::print::pprust::constr_args_to_str;\n+import syntax::print::pprust::lit_to_str;\n \n \n /* logging funs */\n@@ -188,10 +185,10 @@ same predicate are collapsed into one entry in the table, makes it\n easier to look up a specific instance.\n \n Both types are in constrast with the constraint type defined in\n-front::ast, which is for predicate constraints only, and is what\n+syntax::ast, which is for predicate constraints only, and is what\n gets generated by the parser. aux and ast share the same type\n to represent predicate *arguments* however. This type\n-(constr_arg_general) is parameterized (see comments in front::ast).\n+(constr_arg_general) is parameterized (see comments in syntax::ast).\n \n Both types store an ident and span, for error-logging purposes.\n */\n@@ -507,7 +504,7 @@ fn constraints(&fn_ctxt fcx) -> vec[norm_constraint] {\n fn match_args(&fn_ctxt fcx, vec[pred_desc] occs, vec[@constr_arg_use] occ) ->\n    uint {\n     log \"match_args: looking at \" +\n-        pretty::ppaux::constr_args_to_str(std::util::fst[ident, def_id], occ);\n+        constr_args_to_str(std::util::fst[ident, def_id], occ);\n     for (pred_desc pd in occs) {\n         log \"match_args: candidate \" + pred_desc_to_str(pd);\n         fn eq(&tup(ident, def_id) p, &tup(ident, def_id) q) -> bool {\n@@ -594,8 +591,7 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n \n fn pred_desc_to_str(&pred_desc p) -> str {\n     ret \"<\" + uistr(p.node.bit_num) + \", \" +\n-        pretty::ppaux::constr_args_to_str(std::util::fst[ident, def_id],\n-                                          p.node.args) + \">\";\n+        constr_args_to_str(std::util::fst[ident, def_id], p.node.args) + \">\";\n }\n \n fn substitute_constr_args(&ty::ctxt cx, &vec[@expr] actuals,\n@@ -609,7 +605,7 @@ fn substitute_constr_args(&ty::ctxt cx, &vec[@expr] actuals,\n \n type subst = vec[tup(arg, @expr)];\n \n-fn substitute_arg(&ty::ctxt cx, &vec[@expr] actuals, @ast::constr_arg a) ->\n+fn substitute_arg(&ty::ctxt cx, &vec[@expr] actuals, @constr_arg a) ->\n    @constr_arg_use {\n     auto num_actuals = vec::len(actuals);\n     alt (a.node) {"}, {"sha": "3dea3cef30dccd55d549d75edc6ffcb822cbc8b5", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,5 +1,6 @@\n \n-import front::ast::*;\n+import syntax::ast::*;\n+import syntax::walk;\n import std::option::*;\n import std::vec;\n import std::vec::len;"}, {"sha": "084a11aa5fd48f6fdacd59f4c58e44d76804c56f", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,25 +1,26 @@\n \n-import front::ast;\n-import front::ast::method;\n-import front::ast::item;\n-import front::ast::item_fn;\n-import front::ast::_fn;\n-import front::ast::obj_field;\n-import front::ast::_obj;\n-import front::ast::stmt;\n-import front::ast::ident;\n-import front::ast::fn_ident;\n-import front::ast::node_id;\n-import front::ast::def_id;\n-import front::ast::local_def;\n-import front::ast::ty_param;\n-import front::ast::crate;\n-import front::ast::return;\n-import front::ast::noreturn;\n-import front::ast::expr;\n+import syntax::ast;\n+import ast::method;\n+import ast::item;\n+import ast::item_fn;\n+import ast::_fn;\n+import ast::obj_field;\n+import ast::_obj;\n+import ast::stmt;\n+import ast::ident;\n+import ast::fn_ident;\n+import ast::node_id;\n+import ast::def_id;\n+import ast::local_def;\n+import ast::ty_param;\n+import ast::crate;\n+import ast::return;\n+import ast::noreturn;\n+import ast::expr;\n+import syntax::walk;\n+import syntax::codemap::span;\n import middle::ty::type_is_nil;\n import middle::ty::ret_ty_of_fn;\n-import util::common::span;\n import tstate::ann::ts_ann;\n import tstate::ann::empty_poststate;\n import tstate::ann::true_precond;\n@@ -43,7 +44,7 @@ import std::option::t;\n import std::option::some;\n import std::option::none;\n import aux::*;\n-import pretty::pprust::ty_to_str;\n+import syntax::print::pprust::ty_to_str;\n import util::common::log_stmt_err;\n import bitvectors::promises;\n import annotate::annotate_crate;\n@@ -86,7 +87,7 @@ fn check_states_expr(&fn_ctxt fcx, &@expr e) {\n         s +=\n             \"Unsatisfied precondition constraint (for example, \" + diff +\n                 \") for expression:\\n\";\n-        s += pretty::pprust::expr_to_str(e);\n+        s += syntax::print::pprust::expr_to_str(e);\n         s += \"\\nPrecondition:\\n\";\n         s += tritv_to_str(fcx, prec);\n         s += \"\\nPrestate:\\n\";\n@@ -115,7 +116,7 @@ fn check_states_stmt(&fn_ctxt fcx, &@stmt s) {\n         ss +=\n             \"Unsatisfied precondition constraint (for example, \" + diff +\n                 \") for statement:\\n\";\n-        ss += pretty::pprust::stmt_to_str(*s);\n+        ss += syntax::print::pprust::stmt_to_str(*s);\n         ss += \"\\nPrecondition:\\n\";\n         ss += tritv_to_str(fcx, prec);\n         ss += \"\\nPrestate: \\n\";"}, {"sha": "e3b4f0421d40938616aa6e3cc37f0d76206a6ba6", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,13 +1,14 @@\n \n import std::vec;\n import std::vec::plus_option;\n-import front::ast;\n-import front::ast::*;\n-import pretty::ppaux::fn_ident_to_string;\n+import syntax::ast::*;\n+import util::ppaux::fn_ident_to_string;\n import std::option::*;\n-import middle::walk::walk_crate;\n-import middle::walk::walk_fn;\n-import middle::walk::ast_visitor;\n+import syntax::walk;\n+import syntax::visit;\n+import walk::walk_crate;\n+import walk::walk_fn;\n+import walk::ast_visitor;\n import aux::cinit;\n import aux::ninit;\n import aux::npred;\n@@ -20,11 +21,11 @@ import aux::constr_map;\n import aux::expr_to_constr;\n import aux::constraints_expr;\n import aux::node_id_to_def_strict;\n-import util::common::new_int_hash;\n+import syntax::_std::new_int_hash;\n import util::common::new_def_hash;\n-import util::common::uistr;\n-import util::common::span;\n-import util::common::respan;\n+import syntax::_std::uistr;\n+import syntax::codemap::span;\n+import syntax::ast::respan;\n \n type ctxt = rec(@mutable vec[aux::constr] cs, ty::ctxt tcx);\n \n@@ -64,7 +65,7 @@ fn do_nothing(&_fn f, &vec[ty_param] tp, &span sp, &fn_ident i,\n               node_id iid, &ctxt cx, &visit::vt[ctxt] v) {\n }\n  \n-fn find_locals(&ty::ctxt tcx, &_fn f, &vec[ast::ty_param] tps,\n+fn find_locals(&ty::ctxt tcx, &_fn f, &vec[ty_param] tps,\n                &span sp, &fn_ident i, node_id id)\n     -> ctxt {\n     let ctxt cx = rec(cs=@mutable vec::alloc(0u), tcx=tcx);\n@@ -81,7 +82,7 @@ fn find_locals(&ty::ctxt tcx, &_fn f, &vec[ast::ty_param] tps,\n \n fn add_constraint(&ty::ctxt tcx, aux::constr c, uint next, constr_map tbl) ->\n    uint {\n-    log aux::constraint_to_str(tcx, c) + \" |-> \" + util::common::uistr(next);\n+    log aux::constraint_to_str(tcx, c) + \" |-> \" + uistr(next);\n     alt (c.node.c) {\n         case (ninit(?i)) { tbl.insert(c.node.id, cinit(next, c.span, i)); }\n         case (npred(?p, ?args)) {\n@@ -115,7 +116,7 @@ fn add_constraint(&ty::ctxt tcx, aux::constr c, uint next, constr_map tbl) ->\n \n /* builds a table mapping each local var defined in f\n    to a bit number in the precondition/postcondition vectors */\n-fn mk_fn_info(&crate_ctxt ccx, &_fn f, &vec[ast::ty_param] tp,\n+fn mk_fn_info(&crate_ctxt ccx, &_fn f, &vec[ty_param] tp,\n               &span f_sp, &fn_ident f_name,\n               node_id id) {\n     auto res_map = @new_int_hash[constraint]();"}, {"sha": "9ce0d7ce5eb7253af546e86317398dc962625932", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -65,10 +65,11 @@ import bitvectors::declare_var;\n import bitvectors::gen_poststate;\n import bitvectors::relax_precond_block;\n import bitvectors::gen;\n-import front::ast::*;\n-import util::common::new_int_hash;\n+import syntax::ast::*;\n+import syntax::_std::new_int_hash;\n import util::common::new_def_hash;\n-import util::common::uistr;\n+import syntax::_std::istr;\n+import syntax::_std::uistr;\n import util::common::log_expr;\n import util::common::log_fn;\n import util::common::elt_exprs;\n@@ -79,9 +80,8 @@ import util::common::log_stmt_err;\n import util::common::log_expr_err;\n import util::common::log_block_err;\n import util::common::log_block;\n-import util::common::span;\n-import util::common::istr;\n-import pretty::ppaux::fn_ident_to_string;\n+import syntax::codemap::span;\n+import util::ppaux::fn_ident_to_string;\n \n fn find_pre_post_mod(&_mod m) -> _mod {\n     log \"implement find_pre_post_mod!\";"}, {"sha": "ff999c1aa1c6947b7ebb9552075cb0e0cdf26e75", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -75,13 +75,12 @@ import bitvectors::gen_poststate;\n import bitvectors::kill_poststate;\n import bitvectors::clear_in_poststate_ident;\n import bitvectors::intersect_states;\n-import front::ast;\n-import front::ast::*;\n+import syntax::ast::*;\n import middle::ty::expr_ty;\n import middle::ty::type_is_nil;\n import middle::ty::type_is_bot;\n import util::common::new_def_hash;\n-import util::common::uistr;\n+import syntax::_std::uistr;\n import util::common::log_expr;\n import util::common::log_block;\n import util::common::log_block_err;\n@@ -171,7 +170,7 @@ fn find_pre_post_state_call(&fn_ctxt fcx, &prestate pres, &@expr a,\n           expr_poststate(fcx.ccx, a), id, bs, cf) || changed;\n }\n \n-fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres, ast::node_id id,\n+fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres, node_id id,\n                              &vec[@expr] es, controlflow cf) -> bool {\n     auto rs = seq_states(fcx, pres, es);\n     auto changed = rs._0 | set_prestate_ann(fcx.ccx, id, pres);\n@@ -229,7 +228,7 @@ fn gen_if_local(&fn_ctxt fcx, &poststate p, &@expr e) -> bool {\n }\n \n fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n-                  &option::t[@expr] maybe_alt, ast::node_id id, &if_ty chk,\n+                  &option::t[@expr] maybe_alt, node_id id, &if_ty chk,\n                   &prestate pres) -> bool {\n     auto changed = set_prestate_ann(fcx.ccx, id, pres) |\n         find_pre_post_state_expr(fcx, pres, antec);"}, {"sha": "760a9b2fa949311706e3144b857b56388993f4de", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 70, "deletions": 68, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -13,18 +13,20 @@ import std::option::none;\n import std::option::some;\n import std::smallintmap;\n import driver::session;\n-import front::ast;\n-import front::ast::def_id;\n-import front::ast::constr_arg_general;\n-import front::ast::mutability;\n-import front::ast::controlflow;\n-import front::ast::path_to_str;\n+import syntax::ast;\n+import ast::def_id;\n+import ast::constr_arg_general;\n+import ast::mutability;\n+import ast::controlflow;\n+import ast::path_to_str;\n+import ast::spanned;\n+import syntax::codemap::span;\n import metadata::creader;\n import metadata::decoder;\n import util::common::*;\n-import util::data::interner;\n-import pretty::ppaux::ty_to_str;\n-import pretty::ppaux::mode_str_1;\n+import syntax::util::interner;\n+import util::ppaux::ty_to_str;\n+import util::ppaux::mode_str_1;\n \n \n export node_id_to_monotype;\n@@ -251,7 +253,7 @@ tag sty {\n     ty_int;\n     ty_float;\n     ty_uint;\n-    ty_machine(ty_mach);\n+    ty_machine(ast::ty_mach);\n     ty_char;\n     ty_str;\n     ty_istr;\n@@ -360,16 +362,16 @@ fn populate_type_store(&ctxt cx) {\n     intern(cx, ty_int, none[str]);\n     intern(cx, ty_float, none[str]);\n     intern(cx, ty_uint, none[str]);\n-    intern(cx, ty_machine(ty_i8), none[str]);\n-    intern(cx, ty_machine(ty_i16), none[str]);\n-    intern(cx, ty_machine(ty_i32), none[str]);\n-    intern(cx, ty_machine(ty_i64), none[str]);\n-    intern(cx, ty_machine(ty_u8), none[str]);\n-    intern(cx, ty_machine(ty_u16), none[str]);\n-    intern(cx, ty_machine(ty_u32), none[str]);\n-    intern(cx, ty_machine(ty_u64), none[str]);\n-    intern(cx, ty_machine(ty_f32), none[str]);\n-    intern(cx, ty_machine(ty_f64), none[str]);\n+    intern(cx, ty_machine(ast::ty_i8), none[str]);\n+    intern(cx, ty_machine(ast::ty_i16), none[str]);\n+    intern(cx, ty_machine(ast::ty_i32), none[str]);\n+    intern(cx, ty_machine(ast::ty_i64), none[str]);\n+    intern(cx, ty_machine(ast::ty_u8), none[str]);\n+    intern(cx, ty_machine(ast::ty_u16), none[str]);\n+    intern(cx, ty_machine(ast::ty_u32), none[str]);\n+    intern(cx, ty_machine(ast::ty_u64), none[str]);\n+    intern(cx, ty_machine(ast::ty_f32), none[str]);\n+    intern(cx, ty_machine(ast::ty_f64), none[str]);\n     intern(cx, ty_char, none[str]);\n     intern(cx, ty_str, none[str]);\n     intern(cx, ty_istr, none[str]);\n@@ -534,18 +536,18 @@ fn mk_float(&ctxt cx) -> t { ret idx_float; }\n \n fn mk_uint(&ctxt cx) -> t { ret idx_uint; }\n \n-fn mk_mach(&ctxt cx, &ty_mach tm) -> t {\n+fn mk_mach(&ctxt cx, &ast::ty_mach tm) -> t {\n     alt (tm) {\n-        case (ty_u8) { ret idx_u8; }\n-        case (ty_u16) { ret idx_u16; }\n-        case (ty_u32) { ret idx_u32; }\n-        case (ty_u64) { ret idx_u64; }\n-        case (ty_i8) { ret idx_i8; }\n-        case (ty_i16) { ret idx_i16; }\n-        case (ty_i32) { ret idx_i32; }\n-        case (ty_i64) { ret idx_i64; }\n-        case (ty_f32) { ret idx_f32; }\n-        case (ty_f64) { ret idx_f64; }\n+        case (ast::ty_u8) { ret idx_u8; }\n+        case (ast::ty_u16) { ret idx_u16; }\n+        case (ast::ty_u32) { ret idx_u32; }\n+        case (ast::ty_u64) { ret idx_u64; }\n+        case (ast::ty_i8) { ret idx_i8; }\n+        case (ast::ty_i16) { ret idx_i16; }\n+        case (ast::ty_i32) { ret idx_i32; }\n+        case (ast::ty_i64) { ret idx_i64; }\n+        case (ast::ty_f32) { ret idx_f32; }\n+        case (ast::ty_f64) { ret idx_f64; }\n     }\n }\n \n@@ -938,8 +940,8 @@ fn sequence_is_interior(&ctxt cx, &t ty) -> bool {\n \n fn sequence_element_type(&ctxt cx, &t ty) -> t {\n     alt (struct(cx, ty)) {\n-        case (ty_str) { ret mk_mach(cx, ty_u8); }\n-        case (ty_istr) { ret mk_mach(cx, ty_u8); }\n+        case (ty_str) { ret mk_mach(cx, ast::ty_u8); }\n+        case (ty_istr) { ret mk_mach(cx, ast::ty_u8); }\n         case (ty_vec(?mt)) { ret mt.ty; }\n         case (ty_ivec(?mt)) { ret mt.ty; }\n         case (_) {\n@@ -1135,14 +1137,14 @@ fn type_is_integral(&ctxt cx, &t ty) -> bool {\n         case (ty_uint) { ret true; }\n         case (ty_machine(?m)) {\n             alt (m) {\n-                case (ty_i8) { ret true; }\n-                case (ty_i16) { ret true; }\n-                case (ty_i32) { ret true; }\n-                case (ty_i64) { ret true; }\n-                case (ty_u8) { ret true; }\n-                case (ty_u16) { ret true; }\n-                case (ty_u32) { ret true; }\n-                case (ty_u64) { ret true; }\n+                case (ast::ty_i8) { ret true; }\n+                case (ast::ty_i16) { ret true; }\n+                case (ast::ty_i32) { ret true; }\n+                case (ast::ty_i64) { ret true; }\n+                case (ast::ty_u8) { ret true; }\n+                case (ast::ty_u16) { ret true; }\n+                case (ast::ty_u32) { ret true; }\n+                case (ast::ty_u64) { ret true; }\n                 case (_) { ret false; }\n             }\n         }\n@@ -1155,8 +1157,8 @@ fn type_is_fp(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_machine(?tm)) {\n             alt (tm) {\n-                case (ty_f32) { ret true; }\n-                case (ty_f64) { ret true; }\n+                case (ast::ty_f32) { ret true; }\n+                case (ast::ty_f64) { ret true; }\n                 case (_) { ret false; }\n             }\n         }\n@@ -1170,10 +1172,10 @@ fn type_is_signed(&ctxt cx, &t ty) -> bool {\n         case (ty_int) { ret true; }\n         case (ty_machine(?tm)) {\n             alt (tm) {\n-                case (ty_i8) { ret true; }\n-                case (ty_i16) { ret true; }\n-                case (ty_i32) { ret true; }\n-                case (ty_i64) { ret true; }\n+                case (ast::ty_i8) { ret true; }\n+                case (ast::ty_i16) { ret true; }\n+                case (ast::ty_i32) { ret true; }\n+                case (ast::ty_i64) { ret true; }\n                 case (_) { ret false; }\n             }\n         }\n@@ -1322,16 +1324,16 @@ fn hash_type_structure(&sty st) -> uint {\n         case (ty_uint) { ret 4u; }\n         case (ty_machine(?tm)) {\n             alt (tm) {\n-                case (ty_i8) { ret 5u; }\n-                case (ty_i16) { ret 6u; }\n-                case (ty_i32) { ret 7u; }\n-                case (ty_i64) { ret 8u; }\n-                case (ty_u8) { ret 9u; }\n-                case (ty_u16) { ret 10u; }\n-                case (ty_u32) { ret 11u; }\n-                case (ty_u64) { ret 12u; }\n-                case (ty_f32) { ret 13u; }\n-                case (ty_f64) { ret 14u; }\n+                case (ast::ty_i8) { ret 5u; }\n+                case (ast::ty_i16) { ret 6u; }\n+                case (ast::ty_i32) { ret 7u; }\n+                case (ast::ty_i64) { ret 8u; }\n+                case (ast::ty_u8) { ret 9u; }\n+                case (ast::ty_u16) { ret 10u; }\n+                case (ast::ty_u32) { ret 11u; }\n+                case (ast::ty_u64) { ret 12u; }\n+                case (ast::ty_f32) { ret 13u; }\n+                case (ast::ty_f64) { ret 14u; }\n             }\n         }\n         case (ty_char) { ret 15u; }\n@@ -2644,7 +2646,7 @@ mod unify {\n             alt (smallintmap::find[t](vb.types, i)) {\n                 case (none[t]) { typespec = \"\"; }\n                 case (some[t](?typ)) {\n-                    typespec = \" =\" + pretty::ppaux::ty_to_str(tcx, typ);\n+                    typespec = \" =\" + ty_to_str(tcx, typ);\n                 }\n             }\n             log_err #fmt(\"set %u:%s%s\", i, typespec, sets);\n@@ -2948,17 +2950,17 @@ fn is_binopable(&ctxt cx, t ty, ast::binop op) -> bool {\n             case (ty_bool) { tycat_bool }\n             case (ty_int) { tycat_int }\n             case (ty_uint) { tycat_int }\n-            case (ty_machine(ty_i8)) { tycat_int }\n-            case (ty_machine(ty_i16)) { tycat_int }\n-            case (ty_machine(ty_i32)) { tycat_int }\n-            case (ty_machine(ty_i64)) { tycat_int }\n-            case (ty_machine(ty_u8)) { tycat_int }\n-            case (ty_machine(ty_u16)) { tycat_int }\n-            case (ty_machine(ty_u32)) { tycat_int }\n-            case (ty_machine(ty_u64)) { tycat_int }\n+            case (ty_machine(ast::ty_i8)) { tycat_int }\n+            case (ty_machine(ast::ty_i16)) { tycat_int }\n+            case (ty_machine(ast::ty_i32)) { tycat_int }\n+            case (ty_machine(ast::ty_i64)) { tycat_int }\n+            case (ty_machine(ast::ty_u8)) { tycat_int }\n+            case (ty_machine(ast::ty_u16)) { tycat_int }\n+            case (ty_machine(ast::ty_u32)) { tycat_int }\n+            case (ty_machine(ast::ty_u64)) { tycat_int }\n             case (ty_float) { tycat_float }\n-            case (ty_machine(ty_f32)) { tycat_float }\n-            case (ty_machine(ty_f64)) { tycat_float }\n+            case (ty_machine(ast::ty_f32)) { tycat_float }\n+            case (ty_machine(ast::ty_f64)) { tycat_float }\n             case (ty_char) { tycat_int }\n             case (ty_ptr(_)) { tycat_int }\n             case (ty_str) { tycat_str }"}, {"sha": "5c4e4f1572b19a71448485abf6f4ea44294cf6e0", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,14 +1,15 @@\n \n-import front::ast;\n-import front::ast::mutability;\n-import front::ast::local_def;\n-import front::ast::path_to_str;\n+import syntax::ast;\n+import ast::mutability;\n+import ast::local_def;\n+import ast::path_to_str;\n+import ast::respan;\n+import syntax::walk;\n import metadata::decoder;\n import driver::session;\n import util::common;\n-import util::common::span;\n-import util::common::respan;\n-import util::common::new_int_hash;\n+import syntax::codemap::span;\n+import syntax::_std::new_int_hash;\n import util::common::new_def_hash;\n import util::common::log_expr_err;\n import middle::ty;\n@@ -24,7 +25,7 @@ import middle::ty::mo_alias;\n import middle::ty::node_type_table;\n import middle::ty::pat_ty;\n import middle::ty::ty_param_substs_opt_and_ty;\n-import pretty::ppaux::ty_to_str;\n+import util::ppaux::ty_to_str;\n import middle::ty::ty_param_count_and_ty;\n import middle::ty::ty_nil;\n import middle::ty::unify::ures_ok;\n@@ -537,7 +538,7 @@ mod collect {\n             }\n             case (_) {\n                 cx.tcx.sess.fatal(\"internal error \" +\n-                                  util::common::istr(id._1));\n+                                  syntax::_std::istr(id._1));\n             }\n         }\n         ret tpt;\n@@ -1375,7 +1376,7 @@ fn require_pure_call(@crate_ctxt ccx, &ast::purity caller_purity,\n \n fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n     // fcx.ccx.tcx.sess.span_warn(expr.span, \"typechecking expr \" +\n-    //                                pretty::pprust::expr_to_str(expr));\n+    //                            syntax::print::pprust::expr_to_str(expr));\n \n     // A generic function to factor out common logic from call and bind\n     // expressions.\n@@ -1545,7 +1546,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n     }\n \n     // Checks the compatibility \n-    fn check_binop_type_compat(&@fn_ctxt fcx, common::span span,\n+    fn check_binop_type_compat(&@fn_ctxt fcx, span span,\n                                ty::t ty, ast::binop binop) {\n         auto resolved_t = resolve_type_vars_if_possible(fcx, ty);\n         if (!ty::is_binopable(fcx.ccx.tcx, resolved_t, binop)) {\n@@ -1794,11 +1795,11 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             alt (structure_of(fcx, expr.span, ety)) {\n                 case (ty::ty_vec(?vec_elt_ty)) { elt_ty = vec_elt_ty.ty; }\n                 case (ty::ty_str) {\n-                    elt_ty = ty::mk_mach(fcx.ccx.tcx, util::common::ty_u8);\n+                    elt_ty = ty::mk_mach(fcx.ccx.tcx, ast::ty_u8);\n                 }\n                 case (ty::ty_ivec(?vec_elt_ty)) { elt_ty = vec_elt_ty.ty; }\n                 case (ty::ty_istr) {\n-                    elt_ty = ty::mk_mach(fcx.ccx.tcx, util::common::ty_u8);\n+                    elt_ty = ty::mk_mach(fcx.ccx.tcx, ast::ty_u8);\n                 }\n                 case (_) {\n                     fcx.ccx.tcx.sess.span_fatal(expr.span,\n@@ -2150,11 +2151,11 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     write::ty_only_fixup(fcx, id, mt.ty);\n                 }\n                 case (ty::ty_str) {\n-                    auto typ = ty::mk_mach(fcx.ccx.tcx, common::ty_u8);\n+                    auto typ = ty::mk_mach(fcx.ccx.tcx, ast::ty_u8);\n                     write::ty_only_fixup(fcx, id, typ);\n                 }\n                 case (ty::ty_istr) {\n-                    auto typ = ty::mk_mach(fcx.ccx.tcx, common::ty_u8);\n+                    auto typ = ty::mk_mach(fcx.ccx.tcx, ast::ty_u8);\n                     write::ty_only_fixup(fcx, id, typ);\n                 }\n                 case (_) {"}, {"sha": "ea4136182ba8438b3fb8a0a46edb08f58a64a1ae", "filename": "src/comp/pretty/ppaux.rs", "status": "removed", "additions": 0, "deletions": 433, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/c59ebf0f018b748011fc9b23ce0bab3dcfcfe733/src%2Fcomp%2Fpretty%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ebf0f018b748011fc9b23ce0bab3dcfcfe733/src%2Fcomp%2Fpretty%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fppaux.rs?ref=c59ebf0f018b748011fc9b23ce0bab3dcfcfe733", "patch": "@@ -1,433 +0,0 @@\n-\n-import std::io;\n-import std::vec;\n-import std::str;\n-import std::option;\n-import std::option::none;\n-import std::option::some;\n-import middle::ty;\n-import middle::ty::*;\n-import front::lexer;\n-import front::ast;\n-import pp::word;\n-import pp::eof;\n-import pp::zerobreak;\n-import pp::hardbreak;\n-import front::codemap;\n-import front::codemap::codemap;\n-import util::common::istr;\n-import util::common::uistr;\n-import util::common::ty_mach_to_str;\n-\n-fn mode_str(&ty::mode m) -> str {\n-    alt (m) {\n-        case (mo_val) { \"\" }\n-        case (mo_alias(false)) { \"&\" }\n-        case (mo_alias(true)) { \"&mutable \" }\n-    }\n-}\n-\n-fn mode_str_1(&ty::mode m) -> str {\n-    alt (m) {\n-        case (mo_val) { \"val\" }\n-        case (_)      { mode_str(m) }\n-    }\n-}\n-\n-fn fn_ident_to_string(ast::node_id id, &ast::fn_ident i) -> str {\n-    ret alt (i) {\n-        case (none) { \"anon\" + istr(id) }\n-        case (some(?s)) { s }\n-    };\n-}\n-\n-fn ty_to_str(&ctxt cx, &t typ) -> str {\n-    fn fn_input_to_str(&ctxt cx, &rec(middle::ty::mode mode, t ty) input) ->\n-       str {\n-        auto s = mode_str(input.mode);\n-        ret s + ty_to_str(cx, input.ty);\n-    }\n-    fn fn_to_str(&ctxt cx, ast::proto proto, option::t[ast::ident] ident,\n-                 &arg[] inputs, t output, ast::controlflow cf,\n-                 &vec[@constr_def] constrs) -> str {\n-        auto s;\n-        alt (proto) {\n-            case (ast::proto_iter) { s = \"iter\"; }\n-            case (ast::proto_fn) { s = \"fn\"; }\n-        }\n-        alt (ident) { case (some(?i)) { s += \" \"; s += i; } case (_) { } }\n-        s += \"(\";\n-        auto strs = [];\n-        for (arg a in inputs) { strs += [fn_input_to_str(cx, a)]; }\n-        s += str::connect(strs, \", \");\n-        s += \")\";\n-        if (struct(cx, output) != ty_nil) {\n-            alt (cf) {\n-                case (ast::noreturn) { s += \" -> !\"; }\n-                case (ast::return) { s += \" -> \" + ty_to_str(cx, output); }\n-            }\n-        }\n-        s += constrs_str(constrs);\n-        ret s;\n-    }\n-    fn method_to_str(&ctxt cx, &method m) -> str {\n-        ret fn_to_str(cx, m.proto, some[ast::ident](m.ident), m.inputs,\n-                      m.output, m.cf, m.constrs) + \";\";\n-    }\n-    fn field_to_str(&ctxt cx, &field f) -> str {\n-        ret mt_to_str(cx, f.mt) + \" \" + f.ident;\n-    }\n-    fn mt_to_str(&ctxt cx, &mt m) -> str {\n-        auto mstr;\n-        alt (m.mut) {\n-            case (ast::mut) { mstr = \"mutable \"; }\n-            case (ast::imm) { mstr = \"\"; }\n-            case (ast::maybe_mut) { mstr = \"mutable? \"; }\n-        }\n-        ret mstr + ty_to_str(cx, m.ty);\n-    }\n-    alt (cname(cx, typ)) { case (some(?cs)) { ret cs; } case (_) { } }\n-    auto s = \"\";\n-    alt (struct(cx, typ)) {\n-        case (ty_native(_)) { s += \"native\"; }\n-        case (ty_nil) { s += \"()\"; }\n-        case (ty_bot) { s += \"_|_\"; }\n-        case (ty_bool) { s += \"bool\"; }\n-        case (ty_int) { s += \"int\"; }\n-        case (ty_float) { s += \"float\"; }\n-        case (ty_uint) { s += \"uint\"; }\n-        case (ty_machine(?tm)) { s += ty_mach_to_str(tm); }\n-        case (ty_char) { s += \"char\"; }\n-        case (ty_str) { s += \"str\"; }\n-        case (ty_istr) { s += \"istr\"; }\n-        case (ty_box(?tm)) { s += \"@\" + mt_to_str(cx, tm); }\n-        case (ty_vec(?tm)) { s += \"vec[\" + mt_to_str(cx, tm) + \"]\"; }\n-        case (ty_ivec(?tm)) { s += \"ivec[\" + mt_to_str(cx, tm) + \"]\"; }\n-        case (ty_port(?t)) { s += \"port[\" + ty_to_str(cx, t) + \"]\"; }\n-        case (ty_chan(?t)) { s += \"chan[\" + ty_to_str(cx, t) + \"]\"; }\n-        case (ty_type) { s += \"type\"; }\n-        case (ty_task) { s += \"task\"; }\n-        case (ty_tup(?elems)) {\n-            let vec[str] strs = [];\n-            for (mt tm in elems) { strs += [mt_to_str(cx, tm)]; }\n-            s += \"tup(\" + str::connect(strs, \",\") + \")\";\n-        }\n-        case (ty_rec(?elems)) {\n-            let vec[str] strs = [];\n-            for (field fld in elems) { strs += [field_to_str(cx, fld)]; }\n-            s += \"rec(\" + str::connect(strs, \",\") + \")\";\n-        }\n-        case (ty_tag(?id, ?tps)) {\n-            // The user should never see this if the cname is set properly!\n-\n-            s += \"<tag#\" + istr(id._0) + \":\" + istr(id._1) + \">\";\n-            if (vec::len[t](tps) > 0u) {\n-                auto f = bind ty_to_str(cx, _);\n-                auto strs = vec::map[t, str](f, tps);\n-                s += \"[\" + str::connect(strs, \",\") + \"]\";\n-            }\n-        }\n-        case (ty_fn(?proto, ?inputs, ?output, ?cf, ?constrs)) {\n-            s += fn_to_str(cx, proto, none, inputs, output, cf, constrs);\n-        }\n-        case (ty_native_fn(_, ?inputs, ?output)) {\n-            s += fn_to_str(cx, ast::proto_fn, none, inputs, output,\n-                           ast::return, []);\n-        }\n-        case (ty_obj(?meths)) {\n-            auto f = bind method_to_str(cx, _);\n-            auto m = vec::map[method, str](f, meths);\n-            s += \"obj {\\n\\t\" + str::connect(m, \"\\n\\t\") + \"\\n}\";\n-        }\n-        case (ty_res(?id, _, _)) {\n-            s += \"<resource#\" + istr(id._0) + \":\" + istr(id._1) + \">\";\n-        }\n-        case (ty_var(?v)) { s += \"<T\" + istr(v) + \">\"; }\n-        case (ty_param(?id)) {\n-            s += \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)]);\n-        }\n-        case (_) { s += ty_to_short_str(cx, typ); }\n-    }\n-    ret s;\n-}\n-\n-fn ty_to_short_str(&ctxt cx, t typ) -> str {\n-    auto f = def_to_str;\n-    auto ecx = @rec(ds=f, tcx=cx, abbrevs=metadata::tyencode::ac_no_abbrevs);\n-    auto s = metadata::tyencode::ty_str(ecx, typ);\n-    if (str::byte_len(s) >= 32u) { s = str::substr(s, 0u, 32u); }\n-    ret s;\n-}\n-\n-fn constr_arg_to_str[T](fn(&T) -> str  f, &ast::constr_arg_general_[T] c) ->\n-   str {\n-    alt (c) {\n-        case (ast::carg_base) { ret \"*\"; }\n-        case (ast::carg_ident(?i)) { ret f(i); }\n-        case (ast::carg_lit(?l)) { ret lit_to_str(l); }\n-    }\n-}\n-\n-fn constr_arg_to_str_1(&front::ast::constr_arg_general_[str] c) -> str {\n-    alt (c) {\n-        case (ast::carg_base) { ret \"*\"; }\n-        case (ast::carg_ident(?i)) { ret i; }\n-        case (ast::carg_lit(?l)) { ret lit_to_str(l); }\n-    }\n-}\n-\n-fn constr_args_to_str[T](fn(&T) -> str  f,\n-                         &vec[@ast::constr_arg_general[T]] args) -> str {\n-    auto comma = false;\n-    auto s = \"(\";\n-    for (@ast::constr_arg_general[T] a in args) {\n-        if (comma) { s += \", \"; } else { comma = true; }\n-        s += constr_arg_to_str[T](f, a.node);\n-    }\n-    s += \")\";\n-    ret s;\n-}\n-\n-fn print_literal(&ps s, &@front::ast::lit lit) {\n-    maybe_print_comment(s, lit.span.lo);\n-    alt (next_lit(s)) {\n-        case (some(?lt)) {\n-            if (lt.pos == lit.span.lo) {\n-                word(s.s, lt.lit);\n-                s.cur_lit += 1u;\n-                ret;\n-            }\n-        }\n-        case (_) { }\n-    }\n-    alt (lit.node) {\n-        case (ast::lit_str(?st, ?kind)) {\n-            if (kind == ast::sk_unique) { word(s.s, \"~\"); }\n-            print_string(s, st);\n-        }\n-        case (ast::lit_char(?ch)) {\n-            word(s.s,\n-                 \"'\" + escape_str(str::from_bytes([ch as u8]), '\\'') + \"'\");\n-        }\n-        case (ast::lit_int(?val)) { word(s.s, istr(val)); }\n-        case (ast::lit_uint(?val)) { word(s.s, uistr(val) + \"u\"); }\n-        case (ast::lit_float(?fstr)) { word(s.s, fstr); }\n-        case (ast::lit_mach_int(?mach, ?val)) {\n-            word(s.s, istr(val as int));\n-            word(s.s, ty_mach_to_str(mach));\n-        }\n-        case (ast::lit_mach_float(?mach, ?val)) {\n-            // val is already a str\n-\n-            word(s.s, val);\n-            word(s.s, ty_mach_to_str(mach));\n-        }\n-        case (ast::lit_nil) { word(s.s, \"()\"); }\n-        case (ast::lit_bool(?val)) {\n-            if (val) { word(s.s, \"true\"); } else { word(s.s, \"false\"); }\n-        }\n-    }\n-}\n-\n-fn lit_to_str(&@front::ast::lit l) -> str { be to_str(l, print_literal); }\n-\n-fn next_lit(&ps s) -> option::t[lexer::lit] {\n-    alt (s.literals) {\n-        case (some(?lits)) {\n-            if (s.cur_lit < vec::len(lits)) {\n-                ret some(lits.(s.cur_lit));\n-            } else { ret none[lexer::lit]; }\n-        }\n-        case (_) { ret none[lexer::lit]; }\n-    }\n-}\n-\n-fn maybe_print_comment(&ps s, uint pos) {\n-    while (true) {\n-        alt (next_comment(s)) {\n-            case (some(?cmnt)) {\n-                if (cmnt.pos < pos) {\n-                    print_comment(s, cmnt);\n-                    s.cur_cmnt += 1u;\n-                } else { break; }\n-            }\n-            case (_) { break; }\n-        }\n-    }\n-}\n-\n-fn print_comment(&ps s, lexer::cmnt cmnt) {\n-    alt (cmnt.style) {\n-        case (lexer::mixed) {\n-            assert (vec::len(cmnt.lines) == 1u);\n-            zerobreak(s.s);\n-            word(s.s, cmnt.lines.(0));\n-            zerobreak(s.s);\n-        }\n-        case (lexer::isolated) {\n-            pprust::hardbreak_if_not_bol(s);\n-            for (str line in cmnt.lines) { word(s.s, line); hardbreak(s.s); }\n-        }\n-        case (lexer::trailing) {\n-            word(s.s, \" \");\n-            if (vec::len(cmnt.lines) == 1u) {\n-                word(s.s, cmnt.lines.(0));\n-                hardbreak(s.s);\n-            } else {\n-                ibox(s, 0u);\n-                for (str line in cmnt.lines) {\n-                    word(s.s, line);\n-                    hardbreak(s.s);\n-                }\n-                end(s);\n-            }\n-        }\n-        case (lexer::blank_line) {\n-            // We need to do at least one, possibly two hardbreaks.\n-            pprust::hardbreak_if_not_bol(s);\n-            hardbreak(s.s);\n-        }\n-    }\n-}\n-\n-fn print_string(&ps s, &str st) {\n-    word(s.s, \"\\\"\");\n-    word(s.s, escape_str(st, '\"'));\n-    word(s.s, \"\\\"\");\n-}\n-\n-fn escape_str(str st, char to_escape) -> str {\n-    let str out = \"\";\n-    auto len = str::byte_len(st);\n-    auto i = 0u;\n-    while (i < len) {\n-        alt (st.(i) as char) {\n-            case ('\\n') { out += \"\\\\n\"; }\n-            case ('\\t') { out += \"\\\\t\"; }\n-            case ('\\r') { out += \"\\\\r\"; }\n-            case ('\\\\') { out += \"\\\\\\\\\"; }\n-            case (?cur) {\n-                if (cur == to_escape) { out += \"\\\\\"; }\n-                // FIXME some (or all?) non-ascii things should be escaped\n-\n-                str::push_char(out, cur);\n-            }\n-        }\n-        i += 1u;\n-    }\n-    ret out;\n-}\n-\n-fn to_str[T](&T t, fn(&ps, &T)  f) -> str {\n-    auto writer = io::string_writer();\n-    auto s = rust_printer(writer.get_writer());\n-    f(s, t);\n-    eof(s.s);\n-    ret writer.get_str();\n-}\n-\n-fn next_comment(&ps s) -> option::t[lexer::cmnt] {\n-    alt (s.comments) {\n-        case (some(?cmnts)) {\n-            if (s.cur_cmnt < vec::len(cmnts)) {\n-                ret some(cmnts.(s.cur_cmnt));\n-            } else { ret none[lexer::cmnt]; }\n-        }\n-        case (_) { ret none[lexer::cmnt]; }\n-    }\n-}\n-\n-// The ps is stored here to prevent recursive type.\n-// FIXME use a nominal tag instead\n-tag ann_node {\n-    node_block(ps, ast::block);\n-    node_item(ps, @ast::item);\n-    node_expr(ps, @ast::expr);\n-    node_pat(ps, @ast::pat);\n-}\n-type pp_ann = rec(fn(&ann_node node) pre,\n-                  fn(&ann_node node) post);\n-\n-fn no_ann() -> pp_ann {\n-    fn ignore(&ann_node node) {}\n-    ret rec(pre=ignore, post=ignore);\n-}\n-\n-type ps =\n-    @rec(pp::printer s,\n-         option::t[codemap] cm,\n-         option::t[vec[lexer::cmnt]] comments,\n-         option::t[vec[lexer::lit]] literals,\n-         mutable uint cur_cmnt,\n-         mutable uint cur_lit,\n-         mutable vec[pp::breaks] boxes,\n-         pp_ann ann);\n-\n-fn ibox(&ps s, uint u) {\n-    vec::push(s.boxes, pp::inconsistent);\n-    pp::ibox(s.s, u);\n-}\n-\n-fn end(&ps s) { vec::pop(s.boxes); pp::end(s.s); }\n-\n-fn rust_printer(io::writer writer) -> ps {\n-    let vec[pp::breaks] boxes = [];\n-    ret @rec(s=pp::mk_printer(writer, default_columns),\n-             cm=none[codemap],\n-             comments=none[vec[lexer::cmnt]],\n-             literals=none[vec[lexer::lit]],\n-             mutable cur_cmnt=0u,\n-             mutable cur_lit=0u,\n-             mutable boxes=boxes,\n-             ann=no_ann());\n-}\n-\n-const uint indent_unit = 4u;\n-\n-const uint default_columns = 78u;\n-\n-\n-// needed b/c constr_args_to_str needs\n-// something that takes an alias\n-// (argh)\n-fn uint_to_str(&uint i) -> str { ret uistr(i); }\n-\n-fn constr_to_str(&@constr_def c) -> str {\n-    ret ast::path_to_str(c.node.path) +\n-            constr_args_to_str(uint_to_str, c.node.args);\n-}\n-\n-fn ast_constr_to_str(&@front::ast::constr c) -> str {\n-    ret ast::path_to_str(c.node.path) +\n-            constr_args_to_str(uint_to_str, c.node.args);\n-}\n-\n-fn constrs_str(&vec[@constr_def] constrs) -> str {\n-    auto s = \"\";\n-    auto colon = true;\n-    for (@constr_def c in constrs) {\n-        if (colon) { s += \" : \"; colon = false; } else { s += \", \"; }\n-        s += constr_to_str(c);\n-    }\n-    ret s;\n-}\n-\n-fn ast_constrs_str(&vec[@ast::constr] constrs) -> str {\n-    auto s = \"\";\n-    auto colon = true;\n-    for (@ast::constr c in constrs) {\n-        if (colon) { s += \" : \"; colon = false; } else { s += \", \"; }\n-        s += ast_constr_to_str(c);\n-    }\n-    ret s;\n-}\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//"}, {"sha": "d79c221013a01202dedb8f11d8aed290adbba950", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -17,8 +17,6 @@ use std (name = \"std\",\n mod middle {\n     mod trans;\n     mod ty;\n-    mod walk;\n-    mod visit;\n     mod ast_map;\n     mod resolve;\n     mod typeck;\n@@ -38,25 +36,36 @@ mod middle {\n }\n \n \n-mod pretty {\n-    mod pprust;\n-    mod pp;\n-    mod ppaux;\n+mod syntax {\n+    mod _std; // FIXME remove\n+    mod ast;\n+    mod fold;\n+    mod walk;\n+    mod visit;\n+    mod codemap;\n+    mod parse {\n+        mod lexer;\n+        mod parser;\n+        mod token;\n+        mod eval;\n+    }\n+    mod ext {\n+        mod base;\n+        mod fmt;\n+        mod env;\n+        mod simplext;\n+    }\n+    mod print {\n+        mod pprust;\n+        mod pp;\n+    }\n+    mod util {\n+        mod interner;\n+    }\n }\n \n mod front {\n-    mod ast;\n     mod attr;\n-    mod ext;\n-    mod extfmt;\n-    mod extenv;\n-    mod extsimplext;\n-    mod fold;\n-    mod codemap;\n-    mod lexer;\n-    mod parser;\n-    mod token;\n-    mod eval;\n     mod config;\n }\n \n@@ -88,11 +97,9 @@ mod driver {\n \n mod util {\n     mod common;\n-    mod data;\n+    mod ppaux;\n }\n \n-auth front::creader::load_crate = unsafe;\n-auth front::creader::get_metadata_section = unsafe;\n auth middle::metadata = unsafe;\n auth middle::trans = unsafe;\n auth lib::llvm = unsafe;"}, {"sha": "fb4d1449a99d7454c7ef5eaa0e118029474e60ca", "filename": "src/comp/syntax/_std.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2F_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2F_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2F_std.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -0,0 +1,29 @@\n+// FIXME all this stuff should be in the standard lib, and in fact is,\n+// but due to the way our snapshots currently work, rustc can't use it\n+// until after the next snapshot.\n+\n+fn new_str_hash[V]() -> std::map::hashmap[str, V] {\n+    let std::map::hashfn[str] hasher = std::str::hash;\n+    let std::map::eqfn[str] eqer = std::str::eq;\n+    ret std::map::mk_hashmap[str, V](hasher, eqer);\n+}\n+\n+fn new_int_hash[V]() -> std::map::hashmap[int, V] {\n+    fn hash_int(&int x) -> uint { ret x as uint; }\n+    fn eq_int(&int a, &int b) -> bool { ret a == b; }\n+    auto hasher = hash_int;\n+    auto eqer = eq_int;\n+    ret std::map::mk_hashmap[int, V](hasher, eqer);\n+}\n+\n+fn new_uint_hash[V]() -> std::map::hashmap[uint, V] {\n+    fn hash_uint(&uint x) -> uint { ret x; }\n+    fn eq_uint(&uint a, &uint b) -> bool { ret a == b; }\n+    auto hasher = hash_uint;\n+    auto eqer = eq_uint;\n+    ret std::map::mk_hashmap[uint, V](hasher, eqer);\n+}\n+\n+fn istr(int i) -> str { ret std::int::to_str(i, 10u); }\n+\n+fn uistr(uint i) -> str { ret std::uint::to_str(i, 10u); }"}, {"sha": "0b05d2122d58437ca4a5111c6cee714197cfbe6b", "filename": "src/comp/syntax/ast.rs", "status": "renamed", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -2,10 +2,11 @@\n import std::option;\n import std::str;\n import std::vec;\n-import util::common::span;\n-import util::common::spanned;\n-import util::common::ty_mach;\n-import util::common::filename;\n+import codemap::span;\n+import codemap::filename;\n+\n+type spanned[T] = rec(T node, span span);\n+fn respan[T](&span sp, &T t) -> spanned[T] { ret rec(node=t, span=sp); }\n \n type ident = str;\n // Functions may or may not have names.\n@@ -342,6 +343,34 @@ type ty_arg = spanned[ty_arg_];\n \n type ty_method = spanned[ty_method_];\n \n+tag ty_mach {\n+    ty_i8;\n+    ty_i16;\n+    ty_i32;\n+    ty_i64;\n+    ty_u8;\n+    ty_u16;\n+    ty_u32;\n+    ty_u64;\n+    ty_f32;\n+    ty_f64;\n+}\n+\n+fn ty_mach_to_str(ty_mach tm) -> str {\n+    alt (tm) {\n+        case (ty_u8) { ret \"u8\"; }\n+        case (ty_u16) { ret \"u16\"; }\n+        case (ty_u32) { ret \"u32\"; }\n+        case (ty_u64) { ret \"u64\"; }\n+        case (ty_i8) { ret \"i8\"; }\n+        case (ty_i16) { ret \"i16\"; }\n+        case (ty_i32) { ret \"i32\"; }\n+        case (ty_i64) { ret \"i64\"; }\n+        case (ty_f32) { ret \"f32\"; }\n+        case (ty_f64) { ret \"f64\"; }\n+    }\n+}\n+\n type ty = spanned[ty_];\n \n tag ty_ {\n@@ -357,7 +386,7 @@ tag ty_ {\n     ty_int;\n     ty_uint;\n     ty_float;\n-    ty_machine(util::common::ty_mach);\n+    ty_machine(ty_mach);\n     ty_char;\n     ty_str;\n     ty_istr; // interior string\n@@ -604,7 +633,7 @@ fn ternary_to_if(&@expr e) -> @ast::expr {\n fn path_to_str(&ast::path pth) -> str {\n     auto result = str::connect(pth.node.idents, \"::\");\n     if (vec::len[@ast::ty](pth.node.types) > 0u) {\n-        fn f(&@ast::ty t) -> str { ret pretty::pprust::ty_to_str(*t); }\n+        fn f(&@ast::ty t) -> str { ret print::pprust::ty_to_str(*t); }\n         result += \"[\";\n         result += str::connect(vec::map(f, pth.node.types), \",\");\n         result += \"]\";", "previous_filename": "src/comp/front/ast.rs"}, {"sha": "b1f0e7ea5fdf2c1f9b6a3668cc3aa6a02ab1950b", "filename": "src/comp/syntax/codemap.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -0,0 +1,96 @@\n+\n+import std::vec;\n+import std::term;\n+import std::io;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n+\n+type filename = str;\n+\n+/* A codemap is a thing that maps uints to file/line/column positions\n+ * in a crate. This to make it possible to represent the positions\n+ * with single-word things, rather than passing records all over the\n+ * compiler.\n+ */\n+type filemap = @rec(filename name, uint start_pos, mutable vec[uint] lines);\n+\n+type codemap = @rec(mutable vec[filemap] files);\n+\n+type loc = rec(filename filename, uint line, uint col);\n+\n+fn new_codemap() -> codemap {\n+    let vec[filemap] files = [];\n+    ret @rec(mutable files=files);\n+}\n+\n+fn new_filemap(filename filename, uint start_pos) -> filemap {\n+    ret @rec(name=filename, start_pos=start_pos, mutable lines=[0u]);\n+}\n+\n+fn next_line(filemap file, uint pos) { vec::push[uint](file.lines, pos); }\n+\n+fn lookup_pos(codemap map, uint pos) -> loc {\n+    auto a = 0u;\n+    auto b = vec::len[filemap](map.files);\n+    while (b - a > 1u) {\n+        auto m = (a + b) / 2u;\n+        if (map.files.(m).start_pos > pos) { b = m; } else { a = m; }\n+    }\n+    auto f = map.files.(a);\n+    a = 0u;\n+    b = vec::len[uint](f.lines);\n+    while (b - a > 1u) {\n+        auto m = (a + b) / 2u;\n+        if (f.lines.(m) > pos) { b = m; } else { a = m; }\n+    }\n+    ret rec(filename=f.name, line=a + 1u, col=pos - f.lines.(a));\n+}\n+\n+type span = rec(uint lo, uint hi);\n+\n+fn span_to_str(&span sp, &codemap cm) -> str {\n+    auto lo = lookup_pos(cm, sp.lo);\n+    auto hi = lookup_pos(cm, sp.hi);\n+    ret #fmt(\"%s:%u:%u:%u:%u\", lo.filename, lo.line, lo.col, hi.line, hi.col);\n+}\n+\n+fn emit_diagnostic(&option::t[span] sp, &str msg, &str kind, u8 color,\n+                   &codemap cm) {\n+    auto ss = \"<input>:0:0:0:0\";\n+    alt (sp) {\n+        case (some(?ssp)) { ss = span_to_str(ssp, cm); }\n+        case (none) { }\n+    }\n+    io::stdout().write_str(ss + \": \");\n+    if (term::color_supported()) {\n+        term::fg(io::stdout().get_buf_writer(), color);\n+    }\n+    io::stdout().write_str(#fmt(\"%s:\", kind));\n+    if (term::color_supported()) {\n+        term::reset(io::stdout().get_buf_writer());\n+    }\n+    io::stdout().write_str(#fmt(\" %s\\n\", msg));\n+}\n+\n+fn emit_warning(&option::t[span] sp, &str msg, &codemap cm) {\n+    emit_diagnostic(sp, msg, \"warning\", 11u8, cm);\n+}\n+fn emit_error(&option::t[span] sp, &str msg, &codemap cm) {\n+    emit_diagnostic(sp, msg, \"error\", 9u8, cm);\n+}\n+fn emit_note(&option::t[span] sp, &str msg, &codemap cm) {\n+    emit_diagnostic(sp, msg, \"note\", 10u8, cm);\n+}\n+\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "719e96f5fe6ef8b8944d7fbd5d0186d87524bc52", "filename": "src/comp/syntax/ext/base.rs", "status": "renamed", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,10 +1,10 @@\n import std::vec;\n import std::option;\n import std::map::hashmap;\n-import driver::session::session;\n-import front::parser::parser;\n-import util::common::span;\n-import util::common::new_str_hash;\n+import parse::parser::parse_sess;\n+import codemap::span;\n+import syntax::_std::new_str_hash;\n+import codemap;\n \n type syntax_expander = \n     fn(&ext_ctxt, span, &vec[@ast::expr], option::t[str]) -> @ast::expr;\n@@ -20,10 +20,10 @@ tag syntax_extension {\n // AST nodes into full ASTs\n fn syntax_expander_table() -> hashmap[str, syntax_extension] {\n     auto syntax_expanders = new_str_hash[syntax_extension]();\n-    syntax_expanders.insert(\"fmt\", normal(extfmt::expand_syntax_ext));\n-    syntax_expanders.insert(\"env\", normal(extenv::expand_syntax_ext));\n+    syntax_expanders.insert(\"fmt\", normal(ext::fmt::expand_syntax_ext));\n+    syntax_expanders.insert(\"env\", normal(ext::env::expand_syntax_ext));\n     syntax_expanders.insert(\"macro\",    \n-                            macro_defining(extsimplext::add_new_extension));\n+                            macro_defining(ext::simplext::add_new_extension));\n     ret syntax_expanders;\n }\n \n@@ -39,18 +39,18 @@ type ext_ctxt =\n         span_msg_fn span_unimpl,\n         next_id_fn next_id);\n \n-fn mk_ctxt(parser parser) -> ext_ctxt {\n-    auto sess = parser.get_session();\n-    fn ext_span_fatal_(session sess, span sp, str msg) -> ! {\n-        sess.span_fatal(sp, msg);\n+fn mk_ctxt(&parse_sess sess) -> ext_ctxt {\n+    fn ext_span_fatal_(&codemap::codemap cm, span sp, str msg) -> ! {\n+        codemap::emit_error(option::some(sp), msg, cm);\n+        fail;\n     }\n-    auto ext_span_fatal = bind ext_span_fatal_(sess, _, _);\n-    fn ext_span_unimpl_(session sess, span sp, str msg) -> ! {\n-        sess.span_unimpl(sp, msg);\n+    auto ext_span_fatal = bind ext_span_fatal_(sess.cm, _, _);\n+    fn ext_span_unimpl_(&codemap::codemap cm, span sp, str msg) -> ! {\n+        codemap::emit_error(option::some(sp), \"unimplemented \" + msg, cm);\n+        fail;\n     }\n-    auto ext_span_unimpl = bind ext_span_unimpl_(sess, _, _);\n-    fn ext_next_id_(parser parser) -> ast::node_id { parser.get_id() }\n-    auto ext_next_id = bind ext_next_id_(parser);\n+    auto ext_span_unimpl = bind ext_span_unimpl_(sess.cm, _, _);\n+    auto ext_next_id = bind parse::parser::next_node_id(sess);\n     ret rec(span_fatal=ext_span_fatal,\n             span_unimpl=ext_span_unimpl,\n             next_id=ext_next_id);", "previous_filename": "src/comp/front/ext.rs"}, {"sha": "7b12c04589801dd4a1a756da018f56a338c82337", "filename": "src/comp/syntax/ext/env.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -5,15 +5,14 @@\n  * should all get sucked into either the compiler syntax extension plugin\n  * interface.\n  */\n-import util::common;\n import std::str;\n import std::vec;\n import std::option;\n import std::generic_os;\n-import ext::*;\n+import base::*;\n export expand_syntax_ext;\n \n-fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n+fn expand_syntax_ext(&ext_ctxt cx, codemap::span sp, &vec[@ast::expr] args,\n                      option::t[str] body) -> @ast::expr {\n     if (vec::len[@ast::expr](args) != 1u) {\n         cx.span_fatal(sp, \"malformed #env call\");\n@@ -28,12 +27,12 @@ fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n     }\n }\n \n-fn make_new_lit(&ext_ctxt cx, common::span sp, ast::lit_ lit) -> @ast::expr {\n+fn make_new_lit(&ext_ctxt cx, codemap::span sp, ast::lit_ lit) -> @ast::expr {\n     auto sp_lit = @rec(node=lit, span=sp);\n     ret @rec(id=cx.next_id(), node=ast::expr_lit(sp_lit), span=sp);\n }\n \n-fn make_new_str(&ext_ctxt cx, common::span sp, str s) -> @ast::expr {\n+fn make_new_str(&ext_ctxt cx, codemap::span sp, str s) -> @ast::expr {\n     ret make_new_lit(cx, sp, ast::lit_str(s, ast::sk_rc));\n }\n //", "previous_filename": "src/comp/front/extenv.rs"}, {"sha": "1ea2d6943744a58268ad809cb33673b32445049d", "filename": "src/comp/syntax/ext/fmt.rs", "status": "renamed", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -5,17 +5,17 @@\n  * should all get sucked into either the standard library extfmt module or the\n  * compiler syntax extension plugin interface.\n  */\n-import util::common;\n import std::str;\n import std::vec;\n import std::option;\n import std::option::none;\n import std::option::some;\n import std::extfmt::ct::*;\n-import ext::*;\n+import base::*;\n+import codemap::span;\n export expand_syntax_ext;\n \n-fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n+fn expand_syntax_ext(&ext_ctxt cx, span sp, &vec[@ast::expr] args,\n                      option::t[str] body) -> @ast::expr {\n     if (vec::len[@ast::expr](args) == 0u) {\n         cx.span_fatal(sp, \"#fmt requires a format string\");\n@@ -25,7 +25,7 @@ fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n     auto fmtspan = args.(0).span;\n     log \"Format string:\";\n     log fmt;\n-    fn parse_fmt_err_(&ext_ctxt cx, common::span sp, str msg) -> ! {\n+    fn parse_fmt_err_(&ext_ctxt cx, span sp, str msg) -> ! {\n         cx.span_fatal(sp, msg);\n     }\n     auto parse_fmt_err = bind parse_fmt_err_(cx, fmtspan, _);\n@@ -36,50 +36,50 @@ fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n // FIXME: A lot of these functions for producing expressions can probably\n // be factored out in common with other code that builds expressions.\n // FIXME: Cleanup the naming of these functions\n-fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n+fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n                   vec[@ast::expr] args) -> @ast::expr {\n-    fn make_new_lit(&ext_ctxt cx, common::span sp, ast::lit_ lit) ->\n+    fn make_new_lit(&ext_ctxt cx, span sp, ast::lit_ lit) ->\n        @ast::expr {\n         auto sp_lit = @rec(node=lit, span=sp);\n         ret @rec(id=cx.next_id(), node=ast::expr_lit(sp_lit), span=sp);\n     }\n-    fn make_new_str(&ext_ctxt cx, common::span sp, str s) -> @ast::expr {\n+    fn make_new_str(&ext_ctxt cx, span sp, str s) -> @ast::expr {\n         auto lit = ast::lit_str(s, ast::sk_rc);\n         ret make_new_lit(cx, sp, lit);\n     }\n-    fn make_new_int(&ext_ctxt cx, common::span sp, int i) -> @ast::expr {\n+    fn make_new_int(&ext_ctxt cx, span sp, int i) -> @ast::expr {\n         auto lit = ast::lit_int(i);\n         ret make_new_lit(cx, sp, lit);\n     }\n-    fn make_new_uint(&ext_ctxt cx, common::span sp, uint u) -> @ast::expr {\n+    fn make_new_uint(&ext_ctxt cx, span sp, uint u) -> @ast::expr {\n         auto lit = ast::lit_uint(u);\n         ret make_new_lit(cx, sp, lit);\n     }\n-    fn make_add_expr(&ext_ctxt cx, common::span sp, @ast::expr lhs,\n+    fn make_add_expr(&ext_ctxt cx, span sp, @ast::expr lhs,\n                      @ast::expr rhs) -> @ast::expr {\n         auto binexpr = ast::expr_binary(ast::add, lhs, rhs);\n         ret @rec(id=cx.next_id(), node=binexpr, span=sp);\n     }\n-    fn make_path_expr(&ext_ctxt cx, common::span sp, vec[ast::ident] idents)\n+    fn make_path_expr(&ext_ctxt cx, span sp, vec[ast::ident] idents)\n        -> @ast::expr {\n         let vec[@ast::ty] types = [];\n         auto path = rec(idents=idents, types=types);\n         auto sp_path = rec(node=path, span=sp);\n         auto pathexpr = ast::expr_path(sp_path);\n         ret @rec(id=cx.next_id(), node=pathexpr, span=sp);\n     }\n-    fn make_vec_expr(&ext_ctxt cx, common::span sp, vec[@ast::expr] exprs) ->\n+    fn make_vec_expr(&ext_ctxt cx, span sp, vec[@ast::expr] exprs) ->\n        @ast::expr {\n         auto vecexpr = ast::expr_vec(exprs, ast::imm, ast::sk_rc);\n         ret @rec(id=cx.next_id(), node=vecexpr, span=sp);\n     }\n-    fn make_call(&ext_ctxt cx, common::span sp, vec[ast::ident] fn_path,\n+    fn make_call(&ext_ctxt cx, span sp, vec[ast::ident] fn_path,\n                  vec[@ast::expr] args) -> @ast::expr {\n         auto pathexpr = make_path_expr(cx, sp, fn_path);\n         auto callexpr = ast::expr_call(pathexpr, args);\n         ret @rec(id=cx.next_id(), node=callexpr, span=sp);\n     }\n-    fn make_rec_expr(&ext_ctxt cx, common::span sp,\n+    fn make_rec_expr(&ext_ctxt cx, span sp,\n                      vec[tup(ast::ident, @ast::expr)] fields) -> @ast::expr {\n         let vec[ast::field] astfields = [];\n         for (tup(ast::ident, @ast::expr) field in fields) {\n@@ -98,17 +98,17 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n \n         ret [\"std\", \"extfmt\", \"rt\", ident];\n     }\n-    fn make_rt_path_expr(&ext_ctxt cx, common::span sp, str ident) ->\n+    fn make_rt_path_expr(&ext_ctxt cx, span sp, str ident) ->\n        @ast::expr {\n         auto path = make_path_vec(ident);\n         ret make_path_expr(cx, sp, path);\n     }\n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n \n-    fn make_rt_conv_expr(&ext_ctxt cx, common::span sp, &conv cnv) ->\n+    fn make_rt_conv_expr(&ext_ctxt cx, span sp, &conv cnv) ->\n        @ast::expr {\n-        fn make_flags(&ext_ctxt cx, common::span sp, vec[flag] flags) ->\n+        fn make_flags(&ext_ctxt cx, span sp, vec[flag] flags) ->\n            @ast::expr {\n             let vec[@ast::expr] flagexprs = [];\n             for (flag f in flags) {\n@@ -133,7 +133,7 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n             }\n             ret make_vec_expr(cx, sp, flagexprs);\n         }\n-        fn make_count(&ext_ctxt cx, common::span sp, &count cnt) ->\n+        fn make_count(&ext_ctxt cx, span sp, &count cnt) ->\n            @ast::expr {\n             alt (cnt) {\n                 case (count_implied) {\n@@ -150,7 +150,7 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n                 }\n             }\n         }\n-        fn make_ty(&ext_ctxt cx, common::span sp, &ty t) -> @ast::expr {\n+        fn make_ty(&ext_ctxt cx, span sp, &ty t) -> @ast::expr {\n             auto rt_type;\n             alt (t) {\n                 case (ty_hex(?c)) {\n@@ -165,7 +165,7 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n             }\n             ret make_rt_path_expr(cx, sp, rt_type);\n         }\n-        fn make_conv_rec(&ext_ctxt cx, common::span sp, @ast::expr flags_expr,\n+        fn make_conv_rec(&ext_ctxt cx, span sp, @ast::expr flags_expr,\n                          @ast::expr width_expr, @ast::expr precision_expr,\n                          @ast::expr ty_expr) -> @ast::expr {\n             ret make_rec_expr(cx, sp,\n@@ -181,15 +181,15 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n         ret make_conv_rec(cx, sp, rt_conv_flags, rt_conv_width,\n                           rt_conv_precision, rt_conv_ty);\n     }\n-    fn make_conv_call(&ext_ctxt cx, common::span sp, str conv_type, &conv cnv,\n+    fn make_conv_call(&ext_ctxt cx, span sp, str conv_type, &conv cnv,\n                       @ast::expr arg) -> @ast::expr {\n         auto fname = \"conv_\" + conv_type;\n         auto path = make_path_vec(fname);\n         auto cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         auto args = [cnv_expr, arg];\n         ret make_call(cx, arg.span, path, args);\n     }\n-    fn make_new_conv(&ext_ctxt cx, common::span sp, conv cnv, @ast::expr arg)\n+    fn make_new_conv(&ext_ctxt cx, span sp, conv cnv, @ast::expr arg)\n        -> @ast::expr {\n         // FIXME: Extract all this validation into extfmt::ct\n ", "previous_filename": "src/comp/front/extfmt.rs"}, {"sha": "e214524f0b799066227839c67ea12b7ca681b272", "filename": "src/comp/syntax/ext/simplext.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,18 +1,18 @@\n use std;\n \n-import util::common::span;\n+import codemap::span;\n import std::vec;\n import std::option;\n import vec::map;\n import vec::len;\n import option::some;\n import option::none;\n \n-import ext::syntax_extension;\n-import ext::ext_ctxt;\n-import ext::normal;\n-import ext::expr_to_str;\n-import ext::expr_to_ident;\n+import base::syntax_extension;\n+import base::ext_ctxt;\n+import base::normal;\n+import base::expr_to_str;\n+import base::expr_to_ident;\n \n import fold::*;\n import ast::ident;", "previous_filename": "src/comp/front/extsimplext.rs"}, {"sha": "5cf447a862c444af7d33cd6bec97b7be1b9f9fac", "filename": "src/comp/syntax/fold.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,4 +1,4 @@\n-import util::common::span;\n+import syntax::codemap::span;\n import ast::*;\n \n import std::vec;", "previous_filename": "src/comp/front/fold.rs"}, {"sha": "89f6ac536c34373def8aa248a470c18db479603f", "filename": "src/comp/syntax/parse/eval.rs", "status": "renamed", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -4,11 +4,12 @@ import std::str;\n import std::option;\n import std::option::some;\n import std::option::none;\n-import driver::session;\n-import front::parser::parser;\n-import front::parser::new_parser;\n-import front::parser::parse_inner_attrs_and_next;\n-import front::parser::parse_mod_items;\n+import syntax::ast;\n+import syntax::parse::token;\n+import syntax::parse::parser::parser;\n+import syntax::parse::parser::new_parser;\n+import syntax::parse::parser::parse_inner_attrs_and_next;\n+import syntax::parse::parser::parse_mod_items;\n \n export eval_crate_directives_to_mod;\n export mode_parse;\n@@ -19,9 +20,8 @@ type ctx =\n     @rec(parser p,\n          eval_mode mode,\n          mutable vec[str] deps,\n-         session::session sess,\n+         parser::parse_sess sess,\n          mutable uint chpos,\n-         mutable int next_id,\n          ast::crate_cfg cfg);\n \n fn eval_crate_directives(ctx cx, vec[@ast::crate_directive] cdirs,\n@@ -50,8 +50,9 @@ fn eval_crate_directive_block(ctx cx, &ast::block blk, str prefix,\n                 eval_crate_directive(cx, cdir, prefix, view_items, items);\n             }\n             case (_) {\n-                cx.sess.span_fatal(s.span,\n-                                 \"unsupported stmt in crate-directive block\");\n+                codemap::emit_warning\n+                   (some(s.span), \"unsupported stmt in crate-directive block\",\n+                    cx.sess.cm);\n             }\n         }\n     }\n@@ -74,19 +75,17 @@ fn eval_crate_directive(ctx cx, @ast::crate_directive cdir, str prefix,\n             };\n             if (cx.mode == mode_depend) { cx.deps += [full_path]; ret; }\n             auto p0 =\n-                new_parser(cx.sess, cx.cfg, full_path, cx.chpos,\n-                           cx.next_id);\n+                new_parser(cx.sess, cx.cfg, full_path, cx.chpos);\n             auto inner_attrs = parse_inner_attrs_and_next(p0);\n             auto mod_attrs = attrs + inner_attrs._0;\n             auto first_item_outer_attrs = inner_attrs._1;\n             auto m0 = parse_mod_items(p0, token::EOF, first_item_outer_attrs);\n \n-            auto i = front::parser::mk_item(p0, cdir.span.lo, cdir.span.hi,\n-                                            id, ast::item_mod(m0),\n-                                            mod_attrs);\n+            auto i = syntax::parse::parser::mk_item\n+                (p0, cdir.span.lo, cdir.span.hi, id, ast::item_mod(m0),\n+                 mod_attrs);\n             // Thread defids and chpos through the parsers\n             cx.chpos = p0.get_chpos();\n-            cx.next_id = p0.next_id();\n             vec::push[@ast::item](items, i);\n         }\n         case (ast::cdir_dir_mod(?id, ?dir_opt, ?cdirs, ?attrs)) {\n@@ -100,10 +99,10 @@ fn eval_crate_directive(ctx cx, @ast::crate_directive cdir, str prefix,\n             auto m0 = eval_crate_directives_to_mod(cx, cdirs, full_path);\n             auto i = @rec(ident=id,\n                           attrs=attrs,\n-                          id=cx.next_id,\n+                          id=cx.sess.next_id,\n                           node=ast::item_mod(m0),\n                           span=cdir.span);\n-            cx.next_id += 1;\n+            cx.sess.next_id += 1;\n             vec::push[@ast::item](items, i);\n         }\n         case (ast::cdir_view_item(?vi)) {", "previous_filename": "src/comp/front/eval.rs"}, {"sha": "ffc83bcbbea4a605bf5e0e7b84d3508e2294bc1c", "filename": "src/comp/syntax/parse/lexer.rs", "status": "renamed", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -8,11 +8,9 @@ import std::map::hashmap;\n import std::option;\n import std::option::some;\n import std::option::none;\n-import driver::session::session;\n-import util::common;\n-import util::common::*;\n-import util::data::interner;\n-import util::data::interner::intern;\n+import util::interner;\n+import util::interner::intern;\n+import codemap;\n \n type reader =\n     obj {\n@@ -31,9 +29,9 @@ type reader =\n         fn err(str) ;\n     };\n \n-fn new_reader(session sess, io::reader rdr, codemap::filemap filemap,\n+fn new_reader(&codemap::codemap cm, io::reader rdr, codemap::filemap filemap,\n               @interner::interner[str] itr) -> reader {\n-    obj reader(session sess,\n+    obj reader(codemap::codemap cm,\n                str file,\n                uint len,\n                mutable uint col,\n@@ -75,12 +73,14 @@ fn new_reader(session sess, io::reader rdr, codemap::filemap filemap,\n         fn get_interner() -> @interner::interner[str] { ret itr; }\n         fn get_col() -> uint { ret col; }\n         fn get_filemap() -> codemap::filemap { ret fm; }\n-        fn err(str m) { sess.span_fatal(rec(lo=chpos, hi=chpos), m); }\n+        fn err(str m) {\n+            codemap::emit_error(some(rec(lo=chpos, hi=chpos)), m, cm);\n+        }\n     }\n     auto file = str::unsafe_from_bytes(rdr.read_whole_stream());\n     let vec[str] strs = [];\n     auto rd =\n-        reader(sess, file, str::byte_len(file), 0u, 0u, -1 as char,\n+        reader(cm, file, str::byte_len(file), 0u, 0u, -1 as char,\n                filemap.start_pos, filemap.start_pos, strs, filemap, itr);\n     rd.init();\n     ret rd;\n@@ -101,6 +101,25 @@ fn is_whitespace(char c) -> bool {\n     ret c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n }\n \n+fn may_begin_ident(char c) -> bool { ret is_alpha(c) || c == '_'; }\n+\n+fn in_range(char c, char lo, char hi) -> bool { ret lo <= c && c <= hi; }\n+\n+fn is_alpha(char c) -> bool {\n+    ret in_range(c, 'a', 'z') || in_range(c, 'A', 'Z');\n+}\n+\n+fn is_dec_digit(char c) -> bool { ret in_range(c, '0', '9'); }\n+\n+fn is_alnum(char c) -> bool { ret is_alpha(c) || is_dec_digit(c); }\n+\n+fn is_hex_digit(char c) -> bool {\n+    ret in_range(c, '0', '9') || in_range(c, 'a', 'f') ||\n+            in_range(c, 'A', 'F');\n+}\n+\n+fn is_bin_digit(char c) -> bool { ret c == '0' || c == '1'; }\n+\n fn consume_whitespace_and_comments(&reader rdr) {\n     while (is_whitespace(rdr.curr())) { rdr.bump(); }\n     be consume_any_line_comment(rdr);\n@@ -218,30 +237,30 @@ fn scan_number(char c, &reader rdr) -> token::token {\n         if (c == '8') {\n             rdr.bump();\n             if (signed) {\n-                ret token::LIT_MACH_INT(common::ty_i8, accum_int);\n-            } else { ret token::LIT_MACH_INT(common::ty_u8, accum_int); }\n+                ret token::LIT_MACH_INT(ast::ty_i8, accum_int);\n+            } else { ret token::LIT_MACH_INT(ast::ty_u8, accum_int); }\n         }\n         n = rdr.next();\n         if (c == '1' && n == '6') {\n             rdr.bump();\n             rdr.bump();\n             if (signed) {\n-                ret token::LIT_MACH_INT(common::ty_i16, accum_int);\n-            } else { ret token::LIT_MACH_INT(common::ty_u16, accum_int); }\n+                ret token::LIT_MACH_INT(ast::ty_i16, accum_int);\n+            } else { ret token::LIT_MACH_INT(ast::ty_u16, accum_int); }\n         }\n         if (c == '3' && n == '2') {\n             rdr.bump();\n             rdr.bump();\n             if (signed) {\n-                ret token::LIT_MACH_INT(common::ty_i32, accum_int);\n-            } else { ret token::LIT_MACH_INT(common::ty_u32, accum_int); }\n+                ret token::LIT_MACH_INT(ast::ty_i32, accum_int);\n+            } else { ret token::LIT_MACH_INT(ast::ty_u32, accum_int); }\n         }\n         if (c == '6' && n == '4') {\n             rdr.bump();\n             rdr.bump();\n             if (signed) {\n-                ret token::LIT_MACH_INT(common::ty_i64, accum_int);\n-            } else { ret token::LIT_MACH_INT(common::ty_u64, accum_int); }\n+                ret token::LIT_MACH_INT(ast::ty_i64, accum_int);\n+            } else { ret token::LIT_MACH_INT(ast::ty_u64, accum_int); }\n         }\n         if (signed) {\n             ret token::LIT_INT(accum_int);\n@@ -272,13 +291,13 @@ fn scan_number(char c, &reader rdr) -> token::token {\n             if (c == '3' && n == '2') {\n                 rdr.bump();\n                 rdr.bump();\n-                ret token::LIT_MACH_FLOAT(util::common::ty_f32,\n+                ret token::LIT_MACH_FLOAT(ast::ty_f32,\n                                           intern(*rdr.get_interner(),\n                                                  float_str));\n             } else if (c == '6' && n == '4') {\n                 rdr.bump();\n                 rdr.bump();\n-                ret token::LIT_MACH_FLOAT(util::common::ty_f64,\n+                ret token::LIT_MACH_FLOAT(ast::ty_f64,\n                                           intern(*rdr.get_interner(),\n                                                  float_str));\n                 /* FIXME: if this is out of range for either a 32-bit or\n@@ -694,11 +713,11 @@ fn is_lit(&token::token t) -> bool {\n \n type lit = rec(str lit, uint pos);\n \n-fn gather_comments_and_literals(session sess, str path) ->\n+fn gather_comments_and_literals(&codemap::codemap cm, str path) ->\n    rec(vec[cmnt] cmnts, vec[lit] lits) {\n     auto srdr = io::file_reader(path);\n     auto itr = @interner::mk[str](str::hash, str::eq);\n-    auto rdr = new_reader(sess, srdr, codemap::new_filemap(path, 0u), itr);\n+    auto rdr = new_reader(cm, srdr, codemap::new_filemap(path, 0u), itr);\n     let vec[cmnt] comments = [];\n     let vec[lit] literals = [];\n     let bool first_read = true;", "previous_filename": "src/comp/front/lexer.rs"}, {"sha": "48213c1f1acd0e2dfefcdf055604ed35f9ec20a6", "filename": "src/comp/syntax/parse/parser.rs", "status": "renamed", "additions": 76, "deletions": 73, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -10,32 +10,37 @@ import std::either::left;\n import std::either::right;\n import std::map::hashmap;\n import token::can_begin_expr;\n-import driver::session;\n-import util::common;\n-import util::common::filename;\n-import util::common::span;\n-import util::common::new_str_hash;\n-import util::data::interner;\n-import util::common::a_bang;\n-import util::common::a_ty;\n+import ex=ext::base;\n+import codemap::span;\n+import _std::new_str_hash;\n+import util::interner;\n \n tag restriction { UNRESTRICTED; RESTRICT_NO_CALL_EXPRS; }\n \n tag file_type { CRATE_FILE; SOURCE_FILE; }\n \n-type ty_or_bang = util::common::ty_or_bang[@ast::ty];\n+tag ty_or_bang { a_ty(@ast::ty); a_bang; }\n+\n+type parse_sess = @rec(codemap::codemap cm,\n+                       mutable ast::node_id next_id);\n+\n+fn next_node_id(&parse_sess sess) -> ast::node_id {\n+    auto rv = sess.next_id;\n+    sess.next_id += 1;\n+    ret rv;\n+}\n \n type parser =\n     obj {\n         fn peek() -> token::token ;\n         fn bump() ;\n         fn fatal(str) -> !  ;\n+        fn warn(str);\n         fn restrict(restriction) ;\n         fn get_restriction() -> restriction ;\n         fn get_file_type() -> file_type ;\n         fn get_cfg() -> ast::crate_cfg;\n-        fn get_session() -> session::session ;\n-        fn get_span() -> common::span ;\n+        fn get_span() -> span ;\n         fn get_lo_pos() -> uint ;\n         fn get_hi_pos() -> uint ;\n         fn get_last_lo_pos() -> uint ;\n@@ -44,15 +49,15 @@ type parser =\n         fn get_reader() -> lexer::reader ;\n         fn get_filemap() -> codemap::filemap ;\n         fn get_bad_expr_words() -> hashmap[str, ()] ;\n-        fn get_syntax_expanders() -> hashmap[str, ext::syntax_extension] ;\n+        fn get_syntax_expanders() -> hashmap[str, ex::syntax_extension] ;\n         fn get_chpos() -> uint ;\n         fn get_id() -> ast::node_id ;\n-        fn next_id() -> ast::node_id ;\n+        fn get_sess() -> parse_sess;\n     };\n \n-fn new_parser(session::session sess, ast::crate_cfg cfg,\n-              str path, uint pos, ast::node_id next_id) -> parser {\n-    obj stdio_parser(session::session sess,\n+fn new_parser(parse_sess sess, ast::crate_cfg cfg,\n+              str path, uint pos) -> parser {\n+    obj stdio_parser(parse_sess sess,\n                      ast::crate_cfg cfg,\n                      file_type ftype,\n                      mutable token::token tok,\n@@ -62,9 +67,8 @@ fn new_parser(session::session sess, ast::crate_cfg cfg,\n                      mutable restriction restr,\n                      lexer::reader rdr,\n                      vec[op_spec] precs,\n-                     mutable ast::node_id next_id_var,\n                      hashmap[str, ()] bad_words,\n-                     hashmap[str, ext::syntax_extension] syntax_expanders) {\n+                     hashmap[str, ex::syntax_extension] syntax_expanders) {\n         fn peek() -> token::token { ret tok; }\n         fn bump() {\n             // log rdr.get_filename()\n@@ -75,11 +79,16 @@ fn new_parser(session::session sess, ast::crate_cfg cfg,\n             lo = rdr.get_mark_chpos();\n             hi = rdr.get_chpos();\n         }\n-        fn fatal(str m) -> ! { sess.span_fatal(rec(lo=lo, hi=hi), m); }\n+        fn fatal(str m) -> ! {\n+            codemap::emit_error(some(self.get_span()), m, sess.cm);\n+            fail;\n+        }\n+        fn warn(str m) {\n+            codemap::emit_warning(some(self.get_span()), m, sess.cm);\n+        }\n         fn restrict(restriction r) { restr = r; }\n         fn get_restriction() -> restriction { ret restr; }\n-        fn get_session() -> session::session { ret sess; }\n-        fn get_span() -> common::span { ret rec(lo=lo, hi=hi); }\n+        fn get_span() -> span { ret rec(lo=lo, hi=hi); }\n         fn get_lo_pos() -> uint { ret lo; }\n         fn get_hi_pos() -> uint { ret hi; }\n         fn get_last_lo_pos() -> uint { ret last_lo; }\n@@ -92,33 +101,29 @@ fn new_parser(session::session sess, ast::crate_cfg cfg,\n         fn get_reader() -> lexer::reader { ret rdr; }\n         fn get_filemap() -> codemap::filemap { ret rdr.get_filemap(); }\n         fn get_bad_expr_words() -> hashmap[str, ()] { ret bad_words; }\n-        fn get_syntax_expanders() -> hashmap[str, ext::syntax_extension] {\n+        fn get_syntax_expanders() -> hashmap[str, ex::syntax_extension] {\n             ret syntax_expanders;\n         }\n         fn get_chpos() -> uint { ret rdr.get_chpos(); }\n-        fn get_id() -> ast::node_id {\n-            auto rv = next_id_var;\n-            next_id_var += 1;\n-            ret rv;\n-        }\n-        fn next_id() -> ast::node_id { ret next_id_var; }\n+        fn get_id() -> ast::node_id { ret next_node_id(sess); }\n+        fn get_sess() -> parse_sess { ret sess; }\n     }\n \n     auto ftype = SOURCE_FILE;\n     if (str::ends_with(path, \".rc\")) { ftype = CRATE_FILE; }\n     auto srdr = io::file_reader(path);\n     auto filemap = codemap::new_filemap(path, pos);\n-    vec::push(sess.get_codemap().files, filemap);\n+    vec::push(sess.cm.files, filemap);\n     auto itr = @interner::mk(str::hash, str::eq);\n-    auto rdr = lexer::new_reader(sess, srdr, filemap, itr);\n+    auto rdr = lexer::new_reader(sess.cm, srdr, filemap, itr);\n     // Make sure npos points at first actual token:\n \n     lexer::consume_whitespace_and_comments(rdr);\n     auto npos = rdr.get_chpos();\n     ret stdio_parser(sess, cfg, ftype, lexer::next_token(rdr),\n                      npos, npos, npos, UNRESTRICTED, rdr,\n-                     prec_table(), next_id, bad_expr_word_table(),\n-                     ext::syntax_expander_table());\n+                     prec_table(), bad_expr_word_table(),\n+                     ex::syntax_expander_table());\n }\n \n // These are the words that shouldn't be allowed as value identifiers,\n@@ -181,7 +186,7 @@ fn expect(&parser p, token::token t) {\n     }\n }\n \n-fn spanned[T](uint lo, uint hi, &T node) -> common::spanned[T] {\n+fn spanned[T](uint lo, uint hi, &T node) -> ast::spanned[T] {\n     ret rec(node=node, span=rec(lo=lo, hi=hi));\n }\n \n@@ -326,8 +331,7 @@ fn parse_ty_field(&parser p) -> ast::ty_field {\n fn ident_index(&parser p, &vec[ast::arg] args, &ast::ident i) -> uint {\n     auto j = 0u;\n     for (ast::arg a in args) { if (a.ident == i) { ret j; } j += 1u; }\n-    p.get_session().span_fatal(p.get_span(),\n-                             \"Unbound variable \" + i + \" in constraint arg\");\n+    p.fatal(\"Unbound variable \" + i + \" in constraint arg\");\n }\n \n fn parse_constr_arg(vec[ast::arg] args, &parser p) -> @ast::constr_arg {\n@@ -359,7 +363,7 @@ fn parse_ty_constr(&vec[ast::arg] fn_args, &parser p) -> @ast::constr {\n // mentioned in a constraint to an arg index.\n // Seems weird to do this in the parser, but I'm not sure how else to.\n fn parse_constrs(&vec[ast::arg] args, &parser p) ->\n-   common::spanned[vec[@ast::constr]] {\n+    ast::spanned[vec[@ast::constr]] {\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n     let vec[@ast::constr] constrs = [];\n@@ -431,7 +435,7 @@ fn parse_ty_postfix(@ast::ty orig_t, &parser p) -> @ast::ty {\n \n fn parse_ty_or_bang(&parser p) -> ty_or_bang {\n     alt (p.peek()) {\n-        case (token::NOT) { p.bump(); ret a_bang[@ast::ty]; }\n+        case (token::NOT) { p.bump(); ret a_bang; }\n         case (_) { ret a_ty(parse_ty(p)); }\n     }\n }\n@@ -460,25 +464,25 @@ fn parse_ty(&parser p) -> @ast::ty {\n     } else if (eat_word(p, \"task\")) {\n         t = ast::ty_task;\n     } else if (eat_word(p, \"i8\")) {\n-        t = ast::ty_machine(common::ty_i8);\n+        t = ast::ty_machine(ast::ty_i8);\n     } else if (eat_word(p, \"i16\")) {\n-        t = ast::ty_machine(common::ty_i16);\n+        t = ast::ty_machine(ast::ty_i16);\n     } else if (eat_word(p, \"i32\")) {\n-        t = ast::ty_machine(common::ty_i32);\n+        t = ast::ty_machine(ast::ty_i32);\n     } else if (eat_word(p, \"i64\")) {\n-        t = ast::ty_machine(common::ty_i64);\n+        t = ast::ty_machine(ast::ty_i64);\n     } else if (eat_word(p, \"u8\")) {\n-        t = ast::ty_machine(common::ty_u8);\n+        t = ast::ty_machine(ast::ty_u8);\n     } else if (eat_word(p, \"u16\")) {\n-        t = ast::ty_machine(common::ty_u16);\n+        t = ast::ty_machine(ast::ty_u16);\n     } else if (eat_word(p, \"u32\")) {\n-        t = ast::ty_machine(common::ty_u32);\n+        t = ast::ty_machine(ast::ty_u32);\n     } else if (eat_word(p, \"u64\")) {\n-        t = ast::ty_machine(common::ty_u64);\n+        t = ast::ty_machine(ast::ty_u64);\n     } else if (eat_word(p, \"f32\")) {\n-        t = ast::ty_machine(common::ty_f32);\n+        t = ast::ty_machine(ast::ty_f32);\n     } else if (eat_word(p, \"f64\")) {\n-        t = ast::ty_machine(common::ty_f64);\n+        t = ast::ty_machine(ast::ty_f64);\n     } else if (p.peek() == token::LPAREN) {\n         p.bump();\n         alt (p.peek()) {\n@@ -541,9 +545,7 @@ fn parse_ty(&parser p) -> @ast::ty {\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACKET);\n     } else if (eat_word(p, \"mutable\")) {\n-        p.get_session().span_warn(p.get_span(),\n-                                  \"ignoring deprecated 'mutable'\"\n-                                  + \" type constructor\");\n+        p.warn(\"ignoring deprecated 'mutable' type constructor\");\n         auto typ = parse_ty(p);\n         t = typ.node;\n         hi = typ.span.hi;\n@@ -585,7 +587,7 @@ fn parse_seq_to_end[T](token::token ket, option::t[token::token] sep,\n \n fn parse_seq[T](token::token bra, token::token ket,\n                 option::t[token::token] sep, fn(&parser) -> T  f, &parser p)\n-   -> util::common::spanned[vec[T]] {\n+   -> ast::spanned[vec[T]] {\n     auto lo = p.get_lo_pos();\n     expect(p, bra);\n     auto result = parse_seq_to_end[T](ket, sep, f, p);\n@@ -764,8 +766,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n                 ex = ast::expr_lit(lit);\n             }\n             case (_) {\n-                p.get_session().span_unimpl(p.get_span(),\n-                                            \"unique pointer creation\");\n+                p.fatal(\"unimplemented: unique pointer creation\");\n             }\n         }\n     } else if (eat_word(p, \"obj\")) {\n@@ -971,21 +972,21 @@ fn parse_syntax_ext_naked(&parser p, uint lo) -> @ast::expr {\n  * wish to use while bootstrapping. The eventual aim is to permit\n  * loading rust crates to process extensions.\n  */\n-fn expand_syntax_ext(&parser p, common::span sp, &ast::path path,\n+fn expand_syntax_ext(&parser p, span sp, &ast::path path,\n                      vec[@ast::expr] args, option::t[str] body) ->\n    ast::expr_ {\n     assert (vec::len(path.node.idents) > 0u);\n     auto extname = path.node.idents.(0);\n     alt (p.get_syntax_expanders().find(extname)) {\n         case (none) { p.fatal(\"unknown syntax expander: '\" + extname + \"'\"); }\n-        case (some(ext::normal(?ext))) {\n-            auto ext_cx = ext::mk_ctxt(p);\n+        case (some(ex::normal(?ext))) {\n+            auto ext_cx = ex::mk_ctxt(p.get_sess());\n             ret ast::expr_ext(path, args, body, ext(ext_cx, sp, args, body));\n         }\n         // because we have expansion inside parsing, new macros are only\n         // visible further down the file\n-        case (some(ext::macro_defining(?ext))) {\n-            auto ext_cx = ext::mk_ctxt(p);\n+        case (some(ex::macro_defining(?ext))) {\n+            auto ext_cx = ex::mk_ctxt(p.get_sess());\n             auto name_and_extension = ext(ext_cx, sp, args, body);\n             p.get_syntax_expanders().insert(name_and_extension._0,\n                                             name_and_extension._1);\n@@ -1049,9 +1050,7 @@ fn parse_dot_or_call_expr_with(&parser p, @ast::expr e) -> @ast::expr {\n \n fn parse_prefix_expr(&parser p) -> @ast::expr {\n     if (eat_word(p, \"mutable\")) {\n-        p.get_session().span_warn(p.get_span(),\n-                                  \"ignoring deprecated 'mutable'\"\n-                                  + \" prefix operator\");\n+        p.warn(\"ignoring deprecated 'mutable' prefix operator\");\n     }\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n@@ -1676,7 +1675,7 @@ fn parse_ty_params(&parser p) -> vec[ast::ty_param] {\n }\n \n fn parse_fn_decl(&parser p, ast::purity purity) -> ast::fn_decl {\n-    let util::common::spanned[vec[ast::arg]] inputs =\n+    let ast::spanned[vec[ast::arg]] inputs =\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA), parse_arg,\n                   p);\n     let ty_or_bang rslt;\n@@ -1784,7 +1783,7 @@ fn parse_item_obj(&parser p, ast::layer lyr, vec[ast::attribute] attrs) ->\n     auto lo = p.get_last_lo_pos();\n     auto ident = parse_value_ident(p);\n     auto ty_params = parse_ty_params(p);\n-    let util::common::spanned[vec[ast::obj_field]] fields =\n+    let ast::spanned[vec[ast::obj_field]] fields =\n         parse_seq[ast::obj_field](token::LPAREN, token::RPAREN,\n                                   some(token::COMMA), parse_obj_field, p);\n     let vec[@ast::method] meths = [];\n@@ -2320,7 +2319,10 @@ fn parse_native_view(&parser p) -> vec[@ast::view_item] {\n     ret items;\n }\n \n-fn parse_crate_from_source_file(&parser p) -> @ast::crate {\n+fn parse_crate_from_source_file(&str input, &ast::crate_cfg cfg,\n+                                &codemap::codemap cm) -> @ast::crate {\n+    auto sess = @rec(cm=cm, mutable next_id=0);\n+    auto p = new_parser(sess, cfg, input, 0u);\n     auto lo = p.get_lo_pos();\n     auto crate_attrs = parse_inner_attrs_and_next(p);\n     auto first_item_outer_attrs = crate_attrs._1;\n@@ -2428,22 +2430,23 @@ fn parse_crate_directives(&parser p, token::token term,\n     ret cdirs;\n }\n \n-fn parse_crate_from_crate_file(&parser p) -> @ast::crate {\n+fn parse_crate_from_crate_file(&str input, &ast::crate_cfg cfg,\n+                               &codemap::codemap cm) -> @ast::crate {\n+    auto sess = @rec(cm=cm, mutable next_id=0);\n+    auto p = new_parser(sess, cfg, input, 0u);\n     auto lo = p.get_lo_pos();\n     auto prefix = std::fs::dirname(p.get_filemap().name);\n     auto leading_attrs = parse_inner_attrs_and_next(p);\n     auto crate_attrs = leading_attrs._0;\n     auto first_cdir_attr = leading_attrs._1;\n     auto cdirs = parse_crate_directives(p, token::EOF, first_cdir_attr);\n     let vec[str] deps = [];\n-    auto cx =\n-        @rec(p=p,\n-             mode=eval::mode_parse,\n-             mutable deps=deps,\n-             sess=p.get_session(),\n-             mutable chpos=p.get_chpos(),\n-             mutable next_id=p.next_id(),\n-             cfg = p.get_cfg());\n+    auto cx = @rec(p=p,\n+                   mode=eval::mode_parse,\n+                   mutable deps=deps,\n+                   sess=sess,\n+                   mutable chpos=p.get_chpos(),\n+                   cfg = p.get_cfg());\n     auto m =\n         eval::eval_crate_directives_to_mod(cx, cdirs, prefix);\n     auto hi = p.get_hi_pos();", "previous_filename": "src/comp/front/parser.rs"}, {"sha": "b8ea07d50db17f64ab7e9407419bc5eb38bf8dc0", "filename": "src/comp/syntax/parse/token.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,8 +1,8 @@\n \n-import util::common::ty_mach;\n-import util::common::ty_mach_to_str;\n-import util::common::new_str_hash;\n-import util::data::interner;\n+import ast::ty_mach;\n+import ast::ty_mach_to_str;\n+import _std::new_str_hash;\n+import util::interner;\n import std::int;\n import std::uint;\n import std::str;", "previous_filename": "src/comp/front/token.rs"}, {"sha": "ef3a87585c4069548520188811489659c4a29a05", "filename": "src/comp/syntax/print/pp.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "previous_filename": "src/comp/pretty/pp.rs"}, {"sha": "b146d703471e9a939699a1f430a0cd0cd320114e", "filename": "src/comp/syntax/print/pprust.rs", "status": "renamed", "additions": 265, "deletions": 25, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -5,12 +5,11 @@ import std::vec;\n import std::str;\n import std::io;\n import std::option;\n-import driver::session::session;\n-import front::lexer;\n-import front::codemap;\n-import front::codemap::codemap;\n-import front::ast;\n-import util::common;\n+import parse::lexer;\n+import syntax::codemap::codemap;\n+import ast;\n+import _std::istr;\n+import _std::uistr;\n import option::some;\n import option::none;\n import pp::printer;\n@@ -25,15 +24,63 @@ import pp::breaks;\n import pp::consistent;\n import pp::inconsistent;\n import pp::eof;\n-import ppaux::*;\n \n-fn print_crate(session sess, @ast::crate crate, str filename,\n+// The ps is stored here to prevent recursive type.\n+// FIXME use a nominal tag instead\n+tag ann_node {\n+    node_block(ps, ast::block);\n+    node_item(ps, @ast::item);\n+    node_expr(ps, @ast::expr);\n+    node_pat(ps, @ast::pat);\n+}\n+type pp_ann = rec(fn(&ann_node node) pre,\n+                  fn(&ann_node node) post);\n+\n+fn no_ann() -> pp_ann {\n+    fn ignore(&ann_node node) {}\n+    ret rec(pre=ignore, post=ignore);\n+}\n+\n+type ps =\n+    @rec(pp::printer s,\n+         option::t[codemap] cm,\n+         option::t[vec[lexer::cmnt]] comments,\n+         option::t[vec[lexer::lit]] literals,\n+         mutable uint cur_cmnt,\n+         mutable uint cur_lit,\n+         mutable vec[pp::breaks] boxes,\n+         pp_ann ann);\n+\n+fn ibox(&ps s, uint u) {\n+    vec::push(s.boxes, pp::inconsistent);\n+    pp::ibox(s.s, u);\n+}\n+\n+fn end(&ps s) { vec::pop(s.boxes); pp::end(s.s); }\n+\n+fn rust_printer(io::writer writer) -> ps {\n+    let vec[pp::breaks] boxes = [];\n+    ret @rec(s=pp::mk_printer(writer, default_columns),\n+             cm=none[codemap],\n+             comments=none[vec[lexer::cmnt]],\n+             literals=none[vec[lexer::lit]],\n+             mutable cur_cmnt=0u,\n+             mutable cur_lit=0u,\n+             mutable boxes=boxes,\n+             ann=no_ann());\n+}\n+\n+const uint indent_unit = 4u;\n+\n+const uint default_columns = 78u;\n+\n+fn print_crate(&codemap cm, @ast::crate crate, str filename,\n                io::writer out, &pp_ann ann) {\n     let vec[pp::breaks] boxes = [];\n-    auto r = lexer::gather_comments_and_literals(sess, filename);\n+    auto r = lexer::gather_comments_and_literals(cm, filename);\n     auto s =\n         @rec(s=pp::mk_printer(out, default_columns),\n-             cm=some(sess.get_codemap()),\n+             cm=some(cm),\n              comments=some(r.cmnts),\n              literals=some(r.lits),\n              mutable cur_cmnt=0u,\n@@ -119,7 +166,7 @@ fn bopen(&ps s) {\n \n }\n \n-fn bclose(&ps s, common::span span) {\n+fn bclose(&ps s, codemap::span span) {\n     maybe_print_comment(s, span.hi);\n     break_offset(s.s, 1u, -(indent_unit as int));\n     word(s.s, \"}\");\n@@ -161,7 +208,7 @@ fn commasep[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN)  op) {\n }\n \n fn commasep_cmnt[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN)  op,\n-                     fn(&IN) -> common::span  get_span) {\n+                     fn(&IN) -> codemap::span  get_span) {\n     box(s, 0u, b);\n     auto len = vec::len[IN](elts);\n     auto i = 0u;\n@@ -180,7 +227,7 @@ fn commasep_cmnt[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN)  op,\n }\n \n fn commasep_exprs(&ps s, breaks b, vec[@ast::expr] exprs) {\n-    fn expr_span(&@ast::expr expr) -> common::span { ret expr.span; }\n+    fn expr_span(&@ast::expr expr) -> codemap::span { ret expr.span; }\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n@@ -208,7 +255,7 @@ fn print_type(&ps s, &ast::ty ty) {\n         case (ast::ty_int) { word(s.s, \"int\"); }\n         case (ast::ty_uint) { word(s.s, \"uint\"); }\n         case (ast::ty_float) { word(s.s, \"float\"); }\n-        case (ast::ty_machine(?tm)) { word(s.s, common::ty_mach_to_str(tm)); }\n+        case (ast::ty_machine(?tm)) { word(s.s, ast::ty_mach_to_str(tm)); }\n         case (ast::ty_char) { word(s.s, \"char\"); }\n         case (ast::ty_str) { word(s.s, \"str\"); }\n         case (ast::ty_istr) { word(s.s, \"istr\"); }\n@@ -257,7 +304,7 @@ fn print_type(&ps s, &ast::ty ty) {\n                 word(s.s, f.node.ident);\n                 end(s);\n             }\n-            fn get_span(&ast::ty_field f) -> common::span { ret f.span; }\n+            fn get_span(&ast::ty_field f) -> codemap::span { ret f.span; }\n             commasep_cmnt(s, consistent, fields, print_field, get_span);\n             pclose(s);\n         }\n@@ -435,7 +482,7 @@ fn print_item(&ps s, &@ast::item item) {\n                 word(s.s, field.ident);\n                 end(s);\n             }\n-            fn get_span(&ast::obj_field f) -> common::span { ret f.ty.span; }\n+            fn get_span(&ast::obj_field f) -> codemap::span { ret f.ty.span; }\n             commasep_cmnt(s, consistent, _obj.fields, print_field, get_span);\n             pclose(s);\n             space(s.s);\n@@ -517,7 +564,7 @@ fn print_stmt(&ps s, &ast::stmt st) {\n             print_expr(s, expr);\n         }\n     }\n-    if (front::parser::stmt_ends_with_semi(st)) { word(s.s, \";\"); }\n+    if (parse::parser::stmt_ends_with_semi(st)) { word(s.s, \";\"); }\n     maybe_print_trailing_comment(s, st.span, none[uint]);\n }\n \n@@ -605,7 +652,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n                 print_expr(s, elt.expr);\n                 end(s);\n             }\n-            fn get_span(&ast::elt elt) -> common::span { ret elt.expr.span; }\n+            fn get_span(&ast::elt elt) -> codemap::span { ret elt.expr.span; }\n             word(s.s, \"tup\");\n             popen(s);\n             commasep_cmnt(s, inconsistent, exprs, printElt, get_span);\n@@ -620,7 +667,9 @@ fn print_expr(&ps s, &@ast::expr expr) {\n                 print_expr(s, field.node.expr);\n                 end(s);\n             }\n-            fn get_span(&ast::field field) -> common::span { ret field.span; }\n+            fn get_span(&ast::field field) -> codemap::span {\n+                ret field.span;\n+            }\n             word(s.s, \"rec\");\n             popen(s);\n             commasep_cmnt(s, consistent, fields, print_field, get_span);\n@@ -675,11 +724,11 @@ fn print_expr(&ps s, &@ast::expr expr) {\n         }\n         case (ast::expr_unary(?op, ?expr)) {\n             word(s.s, ast::unop_to_str(op));\n-            print_maybe_parens(s, expr, front::parser::unop_prec);\n+            print_maybe_parens(s, expr, parse::parser::unop_prec);\n         }\n         case (ast::expr_lit(?lit)) { print_literal(s, lit); }\n         case (ast::expr_cast(?expr, ?ty)) {\n-            print_maybe_parens(s, expr, front::parser::as_prec);\n+            print_maybe_parens(s, expr, parse::parser::as_prec);\n             space(s.s);\n             word_space(s, \"as\");\n             print_type(s, *ty);\n@@ -1114,7 +1163,7 @@ fn print_view_item(&ps s, &@ast::view_item item) {\n // FIXME: The fact that this builds up the table anew for every call is\n // not good. Eventually, table should be a const.\n fn operator_prec(ast::binop op) -> int {\n-    for (front::parser::op_spec spec in front::parser::prec_table()) {\n+    for (parse::parser::op_spec spec in parse::parser::prec_table()) {\n         if (spec.op == op) { ret spec.prec; }\n     }\n     fail;\n@@ -1127,10 +1176,10 @@ fn print_maybe_parens(&ps s, &@ast::expr expr, int outer_prec) {\n             add_them = operator_prec(op) < outer_prec;\n         }\n         case (ast::expr_cast(_, _)) {\n-            add_them = front::parser::as_prec < outer_prec;\n+            add_them = parse::parser::as_prec < outer_prec;\n         }\n         case (ast::expr_ternary(_, _, _)) {\n-            add_them = front::parser::ternary_prec < outer_prec;\n+            add_them = parse::parser::ternary_prec < outer_prec;\n         }\n         case (_) { add_them = false; }\n     }\n@@ -1186,7 +1235,7 @@ fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n     end(s);\n }\n \n-fn maybe_print_trailing_comment(&ps s, common::span span,\n+fn maybe_print_trailing_comment(&ps s, codemap::span span,\n                                 option::t[uint] next_pos) {\n     auto cm;\n     alt (s.cm) { case (some(?ccm)) { cm = ccm; } case (_) { ret; } }\n@@ -1221,6 +1270,197 @@ fn in_cbox(&ps s) -> bool {\n     if (len == 0u) { ret false; }\n     ret s.boxes.(len - 1u) == pp::consistent;\n }\n+\n+fn print_literal(&ps s, &@ast::lit lit) {\n+    maybe_print_comment(s, lit.span.lo);\n+    alt (next_lit(s)) {\n+        case (some(?lt)) {\n+            if (lt.pos == lit.span.lo) {\n+                word(s.s, lt.lit);\n+                s.cur_lit += 1u;\n+                ret;\n+            }\n+        }\n+        case (_) { }\n+    }\n+    alt (lit.node) {\n+        case (ast::lit_str(?st, ?kind)) {\n+            if (kind == ast::sk_unique) { word(s.s, \"~\"); }\n+            print_string(s, st);\n+        }\n+        case (ast::lit_char(?ch)) {\n+            word(s.s,\n+                 \"'\" + escape_str(str::from_bytes([ch as u8]), '\\'') + \"'\");\n+        }\n+        case (ast::lit_int(?val)) { word(s.s, istr(val)); }\n+        case (ast::lit_uint(?val)) { word(s.s, uistr(val) + \"u\"); }\n+        case (ast::lit_float(?fstr)) { word(s.s, fstr); }\n+        case (ast::lit_mach_int(?mach, ?val)) {\n+            word(s.s, istr(val as int));\n+            word(s.s, ast::ty_mach_to_str(mach));\n+        }\n+        case (ast::lit_mach_float(?mach, ?val)) {\n+            // val is already a str\n+            word(s.s, val);\n+            word(s.s, ast::ty_mach_to_str(mach));\n+        }\n+        case (ast::lit_nil) { word(s.s, \"()\"); }\n+        case (ast::lit_bool(?val)) {\n+            if (val) { word(s.s, \"true\"); } else { word(s.s, \"false\"); }\n+        }\n+    }\n+}\n+\n+fn lit_to_str(&@ast::lit l) -> str { be to_str(l, print_literal); }\n+\n+fn next_lit(&ps s) -> option::t[lexer::lit] {\n+    alt (s.literals) {\n+        case (some(?lits)) {\n+            if (s.cur_lit < vec::len(lits)) {\n+                ret some(lits.(s.cur_lit));\n+            } else { ret none[lexer::lit]; }\n+        }\n+        case (_) { ret none[lexer::lit]; }\n+    }\n+}\n+\n+fn maybe_print_comment(&ps s, uint pos) {\n+    while (true) {\n+        alt (next_comment(s)) {\n+            case (some(?cmnt)) {\n+                if (cmnt.pos < pos) {\n+                    print_comment(s, cmnt);\n+                    s.cur_cmnt += 1u;\n+                } else { break; }\n+            }\n+            case (_) { break; }\n+        }\n+    }\n+}\n+\n+fn print_comment(&ps s, lexer::cmnt cmnt) {\n+    alt (cmnt.style) {\n+        case (lexer::mixed) {\n+            assert (vec::len(cmnt.lines) == 1u);\n+            zerobreak(s.s);\n+            word(s.s, cmnt.lines.(0));\n+            zerobreak(s.s);\n+        }\n+        case (lexer::isolated) {\n+            pprust::hardbreak_if_not_bol(s);\n+            for (str line in cmnt.lines) { word(s.s, line); hardbreak(s.s); }\n+        }\n+        case (lexer::trailing) {\n+            word(s.s, \" \");\n+            if (vec::len(cmnt.lines) == 1u) {\n+                word(s.s, cmnt.lines.(0));\n+                hardbreak(s.s);\n+            } else {\n+                ibox(s, 0u);\n+                for (str line in cmnt.lines) {\n+                    word(s.s, line);\n+                    hardbreak(s.s);\n+                }\n+                end(s);\n+            }\n+        }\n+        case (lexer::blank_line) {\n+            // We need to do at least one, possibly two hardbreaks.\n+            pprust::hardbreak_if_not_bol(s);\n+            hardbreak(s.s);\n+        }\n+    }\n+}\n+\n+fn print_string(&ps s, &str st) {\n+    word(s.s, \"\\\"\");\n+    word(s.s, escape_str(st, '\"'));\n+    word(s.s, \"\\\"\");\n+}\n+\n+fn escape_str(str st, char to_escape) -> str {\n+    let str out = \"\";\n+    auto len = str::byte_len(st);\n+    auto i = 0u;\n+    while (i < len) {\n+        alt (st.(i) as char) {\n+            case ('\\n') { out += \"\\\\n\"; }\n+            case ('\\t') { out += \"\\\\t\"; }\n+            case ('\\r') { out += \"\\\\r\"; }\n+            case ('\\\\') { out += \"\\\\\\\\\"; }\n+            case (?cur) {\n+                if (cur == to_escape) { out += \"\\\\\"; }\n+                // FIXME some (or all?) non-ascii things should be escaped\n+\n+                str::push_char(out, cur);\n+            }\n+        }\n+        i += 1u;\n+    }\n+    ret out;\n+}\n+\n+fn to_str[T](&T t, fn(&ps, &T)  f) -> str {\n+    auto writer = io::string_writer();\n+    auto s = rust_printer(writer.get_writer());\n+    f(s, t);\n+    eof(s.s);\n+    ret writer.get_str();\n+}\n+\n+fn next_comment(&ps s) -> option::t[lexer::cmnt] {\n+    alt (s.comments) {\n+        case (some(?cmnts)) {\n+            if (s.cur_cmnt < vec::len(cmnts)) {\n+                ret some(cmnts.(s.cur_cmnt));\n+            } else { ret none[lexer::cmnt]; }\n+        }\n+        case (_) { ret none[lexer::cmnt]; }\n+    }\n+}\n+\n+\n+fn constr_args_to_str[T](fn(&T) -> str  f,\n+                         &vec[@ast::constr_arg_general[T]] args) -> str {\n+    auto comma = false;\n+    auto s = \"(\";\n+    for (@ast::constr_arg_general[T] a in args) {\n+        if (comma) { s += \", \"; } else { comma = true; }\n+        s += constr_arg_to_str[T](f, a.node);\n+    }\n+    s += \")\";\n+    ret s;\n+}\n+\n+fn constr_arg_to_str[T](fn(&T) -> str  f, &ast::constr_arg_general_[T] c) ->\n+   str {\n+    alt (c) {\n+        case (ast::carg_base) { ret \"*\"; }\n+        case (ast::carg_ident(?i)) { ret f(i); }\n+        case (ast::carg_lit(?l)) { ret lit_to_str(l); }\n+    }\n+}\n+\n+// needed b/c constr_args_to_str needs\n+// something that takes an alias\n+// (argh)\n+fn uint_to_str(&uint i) -> str { ret uistr(i); }\n+\n+fn ast_constr_to_str(&@ast::constr c) -> str {\n+    ret ast::path_to_str(c.node.path) +\n+            constr_args_to_str(uint_to_str, c.node.args);\n+}\n+\n+fn ast_constrs_str(&vec[@ast::constr] constrs) -> str {\n+    auto s = \"\";\n+    auto colon = true;\n+    for (@ast::constr c in constrs) {\n+        if (colon) { s += \" : \"; colon = false; } else { s += \", \"; }\n+        s += ast_constr_to_str(c);\n+    }\n+    ret s;\n+}\n+\n //\n // Local Variables:\n // mode: rust", "previous_filename": "src/comp/pretty/pprust.rs"}, {"sha": "e096b953a8915096b473f1771d6c0664ccd8698c", "filename": "src/comp/syntax/util/interner.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -0,0 +1,35 @@\n+// An \"interner\" is a data structure that associates values with uint tags and\n+// allows bidirectional lookup; i.e. given a value, one can easily find the\n+// type, and vice versa.\n+import std::vec;\n+import std::map;\n+import std::map::hashmap;\n+import std::map::hashfn;\n+import std::map::eqfn;\n+import std::option;\n+import std::option::none;\n+import std::option::some;\n+\n+type interner[T] =\n+    rec(hashmap[T, uint] map,\n+        mutable vec[T] vect,\n+        hashfn[T] hasher,\n+        eqfn[T] eqer);\n+\n+fn mk[T](hashfn[T] hasher, eqfn[T] eqer) -> interner[T] {\n+    auto m = map::mk_hashmap[T, uint](hasher, eqer);\n+    let vec[T] vect = [];\n+    ret rec(map=m, mutable vect=vect, hasher=hasher, eqer=eqer);\n+}\n+fn intern[T](&interner[T] itr, &T val) -> uint {\n+    alt (itr.map.find(val)) {\n+        case (some(?idx)) { ret idx; }\n+        case (none) {\n+            auto new_idx = vec::len[T](itr.vect);\n+            itr.map.insert(val, new_idx);\n+            itr.vect += [val];\n+            ret new_idx;\n+        }\n+    }\n+}\n+fn get[T](&interner[T] itr, uint idx) -> T { ret itr.vect.(idx); }"}, {"sha": "a709814a9a32a37ceb22c8ff79c38865f6d8f123", "filename": "src/comp/syntax/visit.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,10 +1,9 @@\n \n-import front::ast::*;\n+import ast::*;\n import std::option;\n import std::option::some;\n import std::option::none;\n-import util::common::span;\n-import util::common::respan;\n+import codemap::span;\n \n \n // Context-passing AST walker. Each overridden visit method has full control", "previous_filename": "src/comp/middle/visit.rs"}, {"sha": "79e8ca6dca6b1cd9ace4643bf22239f7e1e9c53d", "filename": "src/comp/syntax/walk.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Fsyntax%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fwalk.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,11 +1,11 @@\n \n-import front::ast;\n-import middle::ty::ty_param;\n+import ast;\n+import ast::ty_param;\n+import ast::respan;\n import std::option;\n import std::option::some;\n import std::option::none;\n-import util::common::span;\n-import util::common::respan;\n+import codemap::span;\n \n type ast_visitor =\n     rec(fn() -> bool  keep_going,", "previous_filename": "src/comp/middle/walk.rs"}, {"sha": "cf50c2fbc7333d738b697874d878ce55b7cdce15", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 29, "deletions": 110, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -7,70 +7,30 @@ import std::vec;\n import std::option;\n import std::option::none;\n import std::option::some;\n-import front::ast;\n-import front::ast::ty;\n-import front::ast::pat;\n-import front::codemap::codemap;\n-import front::ast::lit;\n-import front::ast::path;\n-import middle::walk;\n+import syntax::ast;\n+import ast::ty;\n+import ast::pat;\n+import syntax::codemap::codemap;\n+import syntax::codemap::span;\n+import ast::lit;\n+import ast::path;\n+import syntax::walk;\n import std::io::stdout;\n import std::io::str_writer;\n import std::io::string_writer;\n-import pretty::pprust::print_block;\n-import pretty::pprust::print_item;\n-import pretty::pprust::print_expr;\n-import pretty::pprust::print_path;\n-import pretty::pprust::print_decl;\n-import pretty::pprust::print_fn;\n-import pretty::pprust::print_type;\n-import pretty::ppaux::print_literal;\n-import pretty::pp::mk_printer;\n-\n-type filename = str;\n-\n-type span = rec(uint lo, uint hi);\n-\n-type spanned[T] = rec(T node, span span);\n+import syntax::print;\n+import print::pprust::print_block;\n+import print::pprust::print_item;\n+import print::pprust::print_expr;\n+import print::pprust::print_path;\n+import print::pprust::print_decl;\n+import print::pprust::print_fn;\n+import print::pprust::print_type;\n+import print::pprust::print_literal;\n+import print::pp::mk_printer;\n \n type flag = hashmap[str, ()];\n \n-tag ty_mach {\n-    ty_i8;\n-    ty_i16;\n-    ty_i32;\n-    ty_i64;\n-    ty_u8;\n-    ty_u16;\n-    ty_u32;\n-    ty_u64;\n-    ty_f32;\n-    ty_f64;\n-}\n-\n-tag ty_or_bang[T] { a_ty(T); a_bang; }\n-\n-fn ty_mach_to_str(ty_mach tm) -> str {\n-    alt (tm) {\n-        case (ty_u8) { ret \"u8\"; }\n-        case (ty_u16) { ret \"u16\"; }\n-        case (ty_u32) { ret \"u32\"; }\n-        case (ty_u64) { ret \"u64\"; }\n-        case (ty_i8) { ret \"i8\"; }\n-        case (ty_i16) { ret \"i16\"; }\n-        case (ty_i32) { ret \"i32\"; }\n-        case (ty_i64) { ret \"i64\"; }\n-        case (ty_f32) { ret \"f32\"; }\n-        case (ty_f64) { ret \"f64\"; }\n-    }\n-}\n-\n-fn new_str_hash[V]() -> std::map::hashmap[str, V] {\n-    let std::map::hashfn[str] hasher = std::str::hash;\n-    let std::map::eqfn[str] eqer = std::str::eq;\n-    ret std::map::mk_hashmap[str, V](hasher, eqer);\n-}\n-\n fn def_eq(&ast::def_id a, &ast::def_id b) -> bool {\n     ret a._0 == b._0 && a._1 == b._1;\n }\n@@ -88,26 +48,6 @@ fn new_def_hash[V]() -> std::map::hashmap[ast::def_id, V] {\n     ret std::map::mk_hashmap[ast::def_id, V](hasher, eqer);\n }\n \n-fn new_int_hash[V]() -> std::map::hashmap[int, V] {\n-    fn hash_int(&int x) -> uint { ret x as uint; }\n-    fn eq_int(&int a, &int b) -> bool { ret a == b; }\n-    auto hasher = hash_int;\n-    auto eqer = eq_int;\n-    ret std::map::mk_hashmap[int, V](hasher, eqer);\n-}\n-\n-fn new_uint_hash[V]() -> std::map::hashmap[uint, V] {\n-    fn hash_uint(&uint x) -> uint { ret x; }\n-    fn eq_uint(&uint a, &uint b) -> bool { ret a == b; }\n-    auto hasher = hash_uint;\n-    auto eqer = eq_uint;\n-    ret std::map::mk_hashmap[uint, V](hasher, eqer);\n-}\n-\n-fn istr(int i) -> str { ret int::to_str(i, 10u); }\n-\n-fn uistr(uint i) -> str { ret uint::to_str(i, 10u); }\n-\n fn elt_expr(&ast::elt e) -> @ast::expr { ret e.expr; }\n \n fn elt_exprs(&vec[ast::elt] elts) -> vec[@ast::expr] {\n@@ -122,31 +62,31 @@ fn field_exprs(vec[ast::field] fields) -> vec[@ast::expr] {\n     ret vec::map[ast::field, @ast::expr](f, fields);\n }\n \n-fn log_expr(&ast::expr e) { log pretty::pprust::expr_to_str(@e); }\n+fn log_expr(&ast::expr e) { log print::pprust::expr_to_str(@e); }\n \n-fn log_expr_err(&ast::expr e) { log_err pretty::pprust::expr_to_str(@e); }\n+fn log_expr_err(&ast::expr e) { log_err print::pprust::expr_to_str(@e); }\n \n-fn log_ty_err(&ty t) { log_err pretty::pprust::ty_to_str(t); }\n+fn log_ty_err(&ty t) { log_err print::pprust::ty_to_str(t); }\n \n-fn log_pat_err(&@pat p) { log_err pretty::pprust::pat_to_str(p); }\n+fn log_pat_err(&@pat p) { log_err print::pprust::pat_to_str(p); }\n \n-fn log_block(&ast::block b) { log pretty::pprust::block_to_str(b); }\n+fn log_block(&ast::block b) { log print::pprust::block_to_str(b); }\n \n-fn log_block_err(&ast::block b) { log_err pretty::pprust::block_to_str(b); }\n+fn log_block_err(&ast::block b) { log_err print::pprust::block_to_str(b); }\n \n-fn log_item_err(&@ast::item i) { log_err pretty::pprust::item_to_str(i); }\n+fn log_item_err(&@ast::item i) { log_err print::pprust::item_to_str(i); }\n \n fn log_fn(&ast::_fn f, str name, vec[ast::ty_param] params) {\n-    log pretty::pprust::fun_to_str(f, name, params);\n+    log print::pprust::fun_to_str(f, name, params);\n }\n \n fn log_fn_err(&ast::_fn f, str name, vec[ast::ty_param] params) {\n-    log_err pretty::pprust::fun_to_str(f, name, params);\n+    log_err print::pprust::fun_to_str(f, name, params);\n }\n \n-fn log_stmt(&ast::stmt st) { log pretty::pprust::stmt_to_str(st); }\n+fn log_stmt(&ast::stmt st) { log print::pprust::stmt_to_str(st); }\n \n-fn log_stmt_err(&ast::stmt st) { log_err pretty::pprust::stmt_to_str(st); }\n+fn log_stmt_err(&ast::stmt st) { log_err print::pprust::stmt_to_str(st); }\n \n fn has_nonlocal_exits(&ast::block b) -> bool {\n     auto has_exits = @mutable false;\n@@ -232,27 +172,6 @@ fn lit_eq(&@ast::lit l, &@ast::lit m) -> bool {\n     }\n }\n \n-fn respan[T](&span sp, &T t) -> spanned[T] { ret rec(node=t, span=sp); }\n-\n-fn may_begin_ident(char c) -> bool { ret is_alpha(c) || c == '_'; }\n-\n-fn in_range(char c, char lo, char hi) -> bool { ret lo <= c && c <= hi; }\n-\n-fn is_alpha(char c) -> bool {\n-    ret in_range(c, 'a', 'z') || in_range(c, 'A', 'Z');\n-}\n-\n-fn is_dec_digit(char c) -> bool { ret in_range(c, '0', '9'); }\n-\n-fn is_alnum(char c) -> bool { ret is_alpha(c) || is_dec_digit(c); }\n-\n-fn is_hex_digit(char c) -> bool {\n-    ret in_range(c, '0', '9') || in_range(c, 'a', 'f') ||\n-            in_range(c, 'A', 'F');\n-}\n-\n-fn is_bin_digit(char c) -> bool { ret c == '0' || c == '1'; }\n-\n // FIXME move to vec\n fn any[T](&fn(&T) -> bool f, &vec[T] v) -> bool {\n     for (T t in v) {"}, {"sha": "5ff3cf686780929fd8ae0d6b6fb5d9a73984f681", "filename": "src/comp/util/data.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c59ebf0f018b748011fc9b23ce0bab3dcfcfe733/src%2Fcomp%2Futil%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ebf0f018b748011fc9b23ce0bab3dcfcfe733/src%2Fcomp%2Futil%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fdata.rs?ref=c59ebf0f018b748011fc9b23ce0bab3dcfcfe733", "patch": "@@ -1,39 +0,0 @@\n-\n-\n-// An \"interner\" is a data structure that associates values with uint tags and\n-// allows bidirectional lookup; i.e. given a value, one can easily find the\n-// type, and vice versa.\n-import std::vec;\n-import std::map;\n-import std::map::hashmap;\n-import std::map::hashfn;\n-import std::map::eqfn;\n-import std::option;\n-import std::option::none;\n-import std::option::some;\n-\n-mod interner {\n-    type interner[T] =\n-        rec(hashmap[T, uint] map,\n-            mutable vec[T] vect,\n-            hashfn[T] hasher,\n-            eqfn[T] eqer);\n-\n-    fn mk[T](hashfn[T] hasher, eqfn[T] eqer) -> interner[T] {\n-        auto m = map::mk_hashmap[T, uint](hasher, eqer);\n-        let vec[T] vect = [];\n-        ret rec(map=m, mutable vect=vect, hasher=hasher, eqer=eqer);\n-    }\n-    fn intern[T](&interner[T] itr, &T val) -> uint {\n-        alt (itr.map.find(val)) {\n-            case (some(?idx)) { ret idx; }\n-            case (none) {\n-                auto new_idx = vec::len[T](itr.vect);\n-                itr.map.insert(val, new_idx);\n-                itr.vect += [val];\n-                ret new_idx;\n-            }\n-        }\n-    }\n-    fn get[T](&interner[T] itr, uint idx) -> T { ret itr.vect.(idx); }\n-}"}, {"sha": "4adc6c437db7cb1eb1ecfe9c956346b753bf839d", "filename": "src/comp/util/ppaux.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -0,0 +1,182 @@\n+import std::io;\n+import std::vec;\n+import std::str;\n+import std::option;\n+import std::option::none;\n+import std::option::some;\n+import middle::ty;\n+import middle::ty::*;\n+import syntax::print::pp;\n+import syntax::print::pprust;\n+import pp::word;\n+import pp::eof;\n+import pp::zerobreak;\n+import pp::hardbreak;\n+import syntax::_std::istr;\n+import syntax::_std::uistr;\n+import ast::ty_mach_to_str;\n+import syntax::ast;\n+\n+fn mode_str(&ty::mode m) -> str {\n+    alt (m) {\n+        case (mo_val) { \"\" }\n+        case (mo_alias(false)) { \"&\" }\n+        case (mo_alias(true)) { \"&mutable \" }\n+    }\n+}\n+\n+fn mode_str_1(&ty::mode m) -> str {\n+    alt (m) {\n+        case (mo_val) { \"val\" }\n+        case (_)      { mode_str(m) }\n+    }\n+}\n+\n+fn fn_ident_to_string(ast::node_id id, &ast::fn_ident i) -> str {\n+    ret alt (i) {\n+        case (none) { \"anon\" + istr(id) }\n+        case (some(?s)) { s }\n+    };\n+}\n+\n+fn ty_to_str(&ctxt cx, &t typ) -> str {\n+    fn fn_input_to_str(&ctxt cx, &rec(middle::ty::mode mode, t ty) input) ->\n+       str {\n+        auto s = mode_str(input.mode);\n+        ret s + ty_to_str(cx, input.ty);\n+    }\n+    fn fn_to_str(&ctxt cx, ast::proto proto, option::t[ast::ident] ident,\n+                 &arg[] inputs, t output, ast::controlflow cf,\n+                 &vec[@constr_def] constrs) -> str {\n+        auto s;\n+        alt (proto) {\n+            case (ast::proto_iter) { s = \"iter\"; }\n+            case (ast::proto_fn) { s = \"fn\"; }\n+        }\n+        alt (ident) { case (some(?i)) { s += \" \"; s += i; } case (_) { } }\n+        s += \"(\";\n+        auto strs = [];\n+        for (arg a in inputs) { strs += [fn_input_to_str(cx, a)]; }\n+        s += str::connect(strs, \", \");\n+        s += \")\";\n+        if (struct(cx, output) != ty_nil) {\n+            alt (cf) {\n+                case (ast::noreturn) { s += \" -> !\"; }\n+                case (ast::return) { s += \" -> \" + ty_to_str(cx, output); }\n+            }\n+        }\n+        s += constrs_str(constrs);\n+        ret s;\n+    }\n+    fn method_to_str(&ctxt cx, &method m) -> str {\n+        ret fn_to_str(cx, m.proto, some[ast::ident](m.ident), m.inputs,\n+                      m.output, m.cf, m.constrs) + \";\";\n+    }\n+    fn field_to_str(&ctxt cx, &field f) -> str {\n+        ret mt_to_str(cx, f.mt) + \" \" + f.ident;\n+    }\n+    fn mt_to_str(&ctxt cx, &mt m) -> str {\n+        auto mstr;\n+        alt (m.mut) {\n+            case (ast::mut) { mstr = \"mutable \"; }\n+            case (ast::imm) { mstr = \"\"; }\n+            case (ast::maybe_mut) { mstr = \"mutable? \"; }\n+        }\n+        ret mstr + ty_to_str(cx, m.ty);\n+    }\n+    alt (cname(cx, typ)) { case (some(?cs)) { ret cs; } case (_) { } }\n+    auto s = \"\";\n+    alt (struct(cx, typ)) {\n+        case (ty_native(_)) { s += \"native\"; }\n+        case (ty_nil) { s += \"()\"; }\n+        case (ty_bot) { s += \"_|_\"; }\n+        case (ty_bool) { s += \"bool\"; }\n+        case (ty_int) { s += \"int\"; }\n+        case (ty_float) { s += \"float\"; }\n+        case (ty_uint) { s += \"uint\"; }\n+        case (ty_machine(?tm)) { s += ty_mach_to_str(tm); }\n+        case (ty_char) { s += \"char\"; }\n+        case (ty_str) { s += \"str\"; }\n+        case (ty_istr) { s += \"istr\"; }\n+        case (ty_box(?tm)) { s += \"@\" + mt_to_str(cx, tm); }\n+        case (ty_vec(?tm)) { s += \"vec[\" + mt_to_str(cx, tm) + \"]\"; }\n+        case (ty_ivec(?tm)) { s += \"ivec[\" + mt_to_str(cx, tm) + \"]\"; }\n+        case (ty_port(?t)) { s += \"port[\" + ty_to_str(cx, t) + \"]\"; }\n+        case (ty_chan(?t)) { s += \"chan[\" + ty_to_str(cx, t) + \"]\"; }\n+        case (ty_type) { s += \"type\"; }\n+        case (ty_task) { s += \"task\"; }\n+        case (ty_tup(?elems)) {\n+            let vec[str] strs = [];\n+            for (mt tm in elems) { strs += [mt_to_str(cx, tm)]; }\n+            s += \"tup(\" + str::connect(strs, \",\") + \")\";\n+        }\n+        case (ty_rec(?elems)) {\n+            let vec[str] strs = [];\n+            for (field fld in elems) { strs += [field_to_str(cx, fld)]; }\n+            s += \"rec(\" + str::connect(strs, \",\") + \")\";\n+        }\n+        case (ty_tag(?id, ?tps)) {\n+            // The user should never see this if the cname is set properly!\n+\n+            s += \"<tag#\" + istr(id._0) + \":\" + istr(id._1) + \">\";\n+            if (vec::len[t](tps) > 0u) {\n+                auto f = bind ty_to_str(cx, _);\n+                auto strs = vec::map[t, str](f, tps);\n+                s += \"[\" + str::connect(strs, \",\") + \"]\";\n+            }\n+        }\n+        case (ty_fn(?proto, ?inputs, ?output, ?cf, ?constrs)) {\n+            s += fn_to_str(cx, proto, none, inputs, output, cf, constrs);\n+        }\n+        case (ty_native_fn(_, ?inputs, ?output)) {\n+            s += fn_to_str(cx, ast::proto_fn, none, inputs, output,\n+                           ast::return, []);\n+        }\n+        case (ty_obj(?meths)) {\n+            auto f = bind method_to_str(cx, _);\n+            auto m = vec::map[method, str](f, meths);\n+            s += \"obj {\\n\\t\" + str::connect(m, \"\\n\\t\") + \"\\n}\";\n+        }\n+        case (ty_res(?id, _, _)) {\n+            s += \"<resource#\" + istr(id._0) + \":\" + istr(id._1) + \">\";\n+        }\n+        case (ty_var(?v)) { s += \"<T\" + istr(v) + \">\"; }\n+        case (ty_param(?id)) {\n+            s += \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)]);\n+        }\n+        case (_) { s += ty_to_short_str(cx, typ); }\n+    }\n+    ret s;\n+}\n+\n+fn ty_to_short_str(&ctxt cx, t typ) -> str {\n+    auto f = def_to_str;\n+    auto ecx = @rec(ds=f, tcx=cx, abbrevs=metadata::tyencode::ac_no_abbrevs);\n+    auto s = metadata::tyencode::ty_str(ecx, typ);\n+    if (str::byte_len(s) >= 32u) { s = str::substr(s, 0u, 32u); }\n+    ret s;\n+}\n+\n+fn constr_to_str(&@constr_def c) -> str {\n+    ret ast::path_to_str(c.node.path) +\n+        pprust::constr_args_to_str(pprust::uint_to_str, c.node.args);\n+}\n+\n+fn constrs_str(&vec[@constr_def] constrs) -> str {\n+    auto s = \"\";\n+    auto colon = true;\n+    for (@constr_def c in constrs) {\n+        if (colon) { s += \" : \"; colon = false; } else { s += \", \"; }\n+        s += constr_to_str(c);\n+    }\n+    ret s;\n+}\n+\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "af2403cd4b01d6eed5341b1b45bf10ca7b842723", "filename": "src/lib/int.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Flib%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Flib%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fint.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -47,6 +47,7 @@ fn to_str(int n, uint radix) -> str {\n             \"-\" + uint::to_str(-n as uint, radix)\n         } else { uint::to_str(n as uint, radix) };\n }\n+fn str(int i) -> str { ret to_str(i, 10u); }\n \n fn pow(int base, uint exponent) -> int {\n     ret if (exponent == 0u) {"}, {"sha": "95214bcbf26256848b51b8c7d6d7be38a6911b08", "filename": "src/lib/map.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -1,6 +1,3 @@\n-\n-\n-\n /**\n  * At the moment, this is a partial hashmap implementation, not yet fit for\n  * use, but useful as a stress test for rustboot.\n@@ -196,6 +193,31 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n     let vec[mutable bucket[K, V]] bkts = make_buckets[K, V](initial_capacity);\n     ret hashmap[K, V](hasher, eqer, bkts, initial_capacity, 0u, load_factor);\n }\n+\n+// Hash map constructors for basic types\n+\n+fn new_str_hash[V]() -> hashmap[str, V] {\n+    let hashfn[str] hasher = str::hash;\n+    let eqfn[str] eqer = str::eq;\n+    ret mk_hashmap[str, V](hasher, eqer);\n+}\n+\n+fn new_int_hash[V]() -> hashmap[int, V] {\n+    fn hash_int(&int x) -> uint { ret x as uint; }\n+    fn eq_int(&int a, &int b) -> bool { ret a == b; }\n+    auto hasher = hash_int;\n+    auto eqer = eq_int;\n+    ret mk_hashmap[int, V](hasher, eqer);\n+}\n+\n+fn new_uint_hash[V]() -> hashmap[uint, V] {\n+    fn hash_uint(&uint x) -> uint { ret x; }\n+    fn eq_uint(&uint a, &uint b) -> bool { ret a == b; }\n+    auto hasher = hash_uint;\n+    auto eqer = eq_uint;\n+    ret mk_hashmap[uint, V](hasher, eqer);\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "6908aa6342a6261d16553a4d2179653f1bf3dcaf", "filename": "src/lib/uint.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -92,6 +92,8 @@ fn to_str(uint num, uint radix) -> str {\n     while (len != 0u) { len -= 1u; s1 += str::unsafe_from_byte(s.(len)); }\n     ret s1;\n }\n+fn str(uint i) -> str { ret to_str(i, 10u); }\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "2a0754779376e93c917812bd72c4e8c5261353dd", "filename": "src/lib/vec.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd6fdea93fca19f168526943c177f942212cbc6/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=6fd6fdea93fca19f168526943c177f942212cbc6", "patch": "@@ -301,6 +301,19 @@ fn or(&vec[bool] v) -> bool {\n     ret vec::foldl[bool, bool](f, false, v);\n }\n \n+fn any[T](&fn(&T) -> bool f, &vec[T] v) -> bool {\n+    for (T t in v) {\n+        if (f(t)) { ret true; } \n+    }\n+    ret false;\n+}\n+fn all[T](&fn(&T) -> bool f, &vec[T] v) -> bool {\n+    for (T t in v) {\n+        if (!f(t)) { ret false; } \n+    }\n+    ret true;\n+}\n+\n fn clone[T](&vec[T] v) -> vec[T] { ret slice[T](v, 0u, len[T](v)); }\n \n fn plus_option[T](&mutable vec[T] v, &option::t[T] o) {"}]}