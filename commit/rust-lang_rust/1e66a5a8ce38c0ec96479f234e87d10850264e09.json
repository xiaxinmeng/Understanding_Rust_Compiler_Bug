{"sha": "1e66a5a8ce38c0ec96479f234e87d10850264e09", "node_id": "C_kwDOAAsO6NoAKDFlNjZhNWE4Y2UzOGMwZWM5NjQ3OWYyMzRlODdkMTA4NTAyNjRlMDk", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-09-01T12:30:57Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-09-01T12:41:38Z"}, "message": "Diagnose incorrect continue expressions", "tree": {"sha": "b859118f610f117832954ce6ce399c2be08e32d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b859118f610f117832954ce6ce399c2be08e32d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e66a5a8ce38c0ec96479f234e87d10850264e09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e66a5a8ce38c0ec96479f234e87d10850264e09", "html_url": "https://github.com/rust-lang/rust/commit/1e66a5a8ce38c0ec96479f234e87d10850264e09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e66a5a8ce38c0ec96479f234e87d10850264e09/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6fc4a9ea6dc062b7ee37a25f20a1309e493e8a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6fc4a9ea6dc062b7ee37a25f20a1309e493e8a1", "html_url": "https://github.com/rust-lang/rust/commit/d6fc4a9ea6dc062b7ee37a25f20a1309e493e8a1"}], "stats": {"total": 79, "additions": 48, "deletions": 31}, "files": [{"sha": "f41c4afaf56550134de151dc36213b6c8fb9092e", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e66a5a8ce38c0ec96479f234e87d10850264e09/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e66a5a8ce38c0ec96479f234e87d10850264e09/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=1e66a5a8ce38c0ec96479f234e87d10850264e09", "patch": "@@ -182,7 +182,7 @@ pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum InferenceDiagnostic {\n     NoSuchField { expr: ExprId },\n-    BreakOutsideOfLoop { expr: ExprId },\n+    BreakOutsideOfLoop { expr: ExprId, is_break: bool },\n     MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n }\n "}, {"sha": "09d83202522d7c64ce5cea8c8618c0450915f758", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1e66a5a8ce38c0ec96479f234e87d10850264e09/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e66a5a8ce38c0ec96479f234e87d10850264e09/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=1e66a5a8ce38c0ec96479f234e87d10850264e09", "patch": "@@ -120,19 +120,16 @@ impl<'a> InferenceContext<'a> {\n                 let ty = match label {\n                     Some(_) => {\n                         let break_ty = self.table.new_type_var();\n-                        let (ctx, ty) = self.with_breakable_ctx(break_ty.clone(), *label, |this| {\n-                            this.infer_block(\n-                                tgt_expr,\n-                                statements,\n-                                *tail,\n-                                &Expectation::has_type(break_ty),\n-                            )\n-                        });\n-                        if ctx.may_break {\n-                            ctx.coerce.complete()\n-                        } else {\n-                            ty\n-                        }\n+                        let (breaks, ty) =\n+                            self.with_breakable_ctx(break_ty.clone(), *label, |this| {\n+                                this.infer_block(\n+                                    tgt_expr,\n+                                    statements,\n+                                    *tail,\n+                                    &Expectation::has_type(break_ty),\n+                                )\n+                            });\n+                        breaks.unwrap_or(ty)\n                     }\n                     None => self.infer_block(tgt_expr, statements, *tail, expected),\n                 };\n@@ -164,15 +161,16 @@ impl<'a> InferenceContext<'a> {\n             }\n             &Expr::Loop { body, label } => {\n                 let ty = self.table.new_type_var();\n-                let (ctx, ()) = self.with_breakable_ctx(ty, label, |this| {\n+                let (breaks, ()) = self.with_breakable_ctx(ty, label, |this| {\n                     this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n                 });\n \n-                if ctx.may_break {\n-                    self.diverges = Diverges::Maybe;\n-                    ctx.coerce.complete()\n-                } else {\n-                    TyKind::Never.intern(Interner)\n+                match breaks {\n+                    Some(breaks) => {\n+                        self.diverges = Diverges::Maybe;\n+                        breaks\n+                    }\n+                    None => TyKind::Never.intern(Interner),\n                 }\n             }\n             &Expr::While { condition, body, label } => {\n@@ -194,7 +192,7 @@ impl<'a> InferenceContext<'a> {\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n                 self.infer_pat(pat, &pat_ty, BindingMode::default());\n-                let (_ctx, ()) = self.with_breakable_ctx(self.err_ty(), label, |this| {\n+                self.with_breakable_ctx(self.err_ty(), label, |this| {\n                     this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n                 });\n \n@@ -356,7 +354,15 @@ impl<'a> InferenceContext<'a> {\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, tgt_expr);\n                 self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or_else(|| self.err_ty())\n             }\n-            Expr::Continue { .. } => TyKind::Never.intern(Interner),\n+            Expr::Continue { label } => {\n+                if let None = find_breakable(&mut self.breakables, label.as_ref()) {\n+                    self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n+                        expr: tgt_expr,\n+                        is_break: false,\n+                    });\n+                };\n+                TyKind::Never.intern(Interner)\n+            }\n             Expr::Break { expr, label } => {\n                 let mut coerce = match find_breakable(&mut self.breakables, label.as_ref()) {\n                     Some(ctxt) => {\n@@ -384,6 +390,7 @@ impl<'a> InferenceContext<'a> {\n                 } else {\n                     self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                         expr: tgt_expr,\n+                        is_break: true,\n                     });\n                 };\n \n@@ -1462,13 +1469,13 @@ impl<'a> InferenceContext<'a> {\n         ty: Ty,\n         label: Option<LabelId>,\n         cb: impl FnOnce(&mut Self) -> T,\n-    ) -> (BreakableContext, T) {\n+    ) -> (Option<Ty>, T) {\n         self.breakables.push({\n             let label = label.map(|label| self.body[label].name.clone());\n             BreakableContext { may_break: false, coerce: CoerceMany::new(ty), label }\n         });\n         let res = cb(self);\n         let ctx = self.breakables.pop().expect(\"breakable stack broken\");\n-        (ctx, res)\n+        (ctx.may_break.then(|| ctx.coerce.complete()), res)\n     }\n }"}, {"sha": "5edc16d8bce9060262914d14060b4bfd1cb3e6d2", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e66a5a8ce38c0ec96479f234e87d10850264e09/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e66a5a8ce38c0ec96479f234e87d10850264e09/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=1e66a5a8ce38c0ec96479f234e87d10850264e09", "patch": "@@ -124,6 +124,7 @@ pub struct NoSuchField {\n #[derive(Debug)]\n pub struct BreakOutsideOfLoop {\n     pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub is_break: bool,\n }\n \n #[derive(Debug)]"}, {"sha": "e4bb63a864719956e4b31b76e8994852f3b3ca55", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e66a5a8ce38c0ec96479f234e87d10850264e09/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e66a5a8ce38c0ec96479f234e87d10850264e09/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=1e66a5a8ce38c0ec96479f234e87d10850264e09", "patch": "@@ -1216,11 +1216,11 @@ impl DefWithBody {\n                     let field = source_map.field_syntax(*expr);\n                     acc.push(NoSuchField { field }.into())\n                 }\n-                hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr } => {\n+                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr, is_break } => {\n                     let expr = source_map\n-                        .expr_syntax(*expr)\n+                        .expr_syntax(expr)\n                         .expect(\"break outside of loop in synthetic syntax\");\n-                    acc.push(BreakOutsideOfLoop { expr }.into())\n+                    acc.push(BreakOutsideOfLoop { expr, is_break }.into())\n                 }\n                 hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n                     match source_map.expr_syntax(*call_expr) {"}, {"sha": "59203106efa5efd8d1704c0876968bc2883dbfac", "filename": "crates/ide-diagnostics/src/handlers/break_outside_of_loop.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1e66a5a8ce38c0ec96479f234e87d10850264e09/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e66a5a8ce38c0ec96479f234e87d10850264e09/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs?ref=1e66a5a8ce38c0ec96479f234e87d10850264e09", "patch": "@@ -7,9 +7,10 @@ pub(crate) fn break_outside_of_loop(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::BreakOutsideOfLoop,\n ) -> Diagnostic {\n+    let construct = if d.is_break { \"break\" } else { \"continue\" };\n     Diagnostic::new(\n         \"break-outside-of-loop\",\n-        \"break outside of loop\",\n+        format!(\"{construct} outside of loop\"),\n         ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n     )\n }\n@@ -19,11 +20,19 @@ mod tests {\n     use crate::tests::check_diagnostics;\n \n     #[test]\n-    fn break_outside_of_loop() {\n+    fn outside_of_loop() {\n         check_diagnostics(\n             r#\"\n-fn foo() { break; }\n-         //^^^^^ error: break outside of loop\n+fn foo() {\n+    break;\n+  //^^^^^ error: break outside of loop\n+    break 'a;\n+  //^^^^^^^^ error: break outside of loop\n+    continue;\n+  //^^^^^^^^ error: continue outside of loop\n+    continue 'a;\n+  //^^^^^^^^^^^ error: continue outside of loop\n+}\n \"#,\n         );\n     }"}]}