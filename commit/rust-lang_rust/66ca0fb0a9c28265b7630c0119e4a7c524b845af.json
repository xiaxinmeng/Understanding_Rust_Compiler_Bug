{"sha": "66ca0fb0a9c28265b7630c0119e4a7c524b845af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2Y2EwZmIwYTljMjgyNjViNzYzMGMwMTE5ZTRhN2M1MjRiODQ1YWY=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-08-15T07:24:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-08-15T07:24:01Z"}, "message": "Merge pull request #431 from RalfJung/packed\n\nAllow remainder on pointers, reenable packed-structs test", "tree": {"sha": "fd2bbc6d35fcfceb60ee98a206de154956aa038c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd2bbc6d35fcfceb60ee98a206de154956aa038c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66ca0fb0a9c28265b7630c0119e4a7c524b845af", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbc9URCRBK7hj4Ov3rIwAAdHIIACFuYx2LosXpnFyTYpy6x1eQ\ngAZTis9dzi6xAXRI0szFI2MmTyKVgt2utV4k/lkht2269uvrlQVz9dAiQ7aQt6Q6\n8DNG9Ma3qiTbmGpUcNhx8lLkxntR4mMxXqKF3qVB3SZe9EjesO6xIpxGiZ3ufxVt\n+nMJ7EsNB6NTzrXaA3tHh+MwjYNafaQEyCG3bqXQwZKPFwar6bq9cORAJ1RFnt7W\nEaIWtsYs+RNvz+zAQHz4TKovUZ1L+NTxKSlFCUkCuxbITdcoGmQra7aeMUAIpM5h\nauirFqTXypclNSjRltK5isPZ1mRT744e5GfBP60xWp5ZmkUIhzcowEpkvarbU6Y=\n=yI0e\n-----END PGP SIGNATURE-----\n", "payload": "tree fd2bbc6d35fcfceb60ee98a206de154956aa038c\nparent 65357faef8b926a7fc61ceaa2e4db79d431c80fb\nparent 51dbb5aa29f2ba8f0e694291299be1c22c5e6419\nauthor Oliver Schneider <github35764891676564198441@oli-obk.de> 1534317841 +0200\ncommitter GitHub <noreply@github.com> 1534317841 +0200\n\nMerge pull request #431 from RalfJung/packed\n\nAllow remainder on pointers, reenable packed-structs test"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66ca0fb0a9c28265b7630c0119e4a7c524b845af", "html_url": "https://github.com/rust-lang/rust/commit/66ca0fb0a9c28265b7630c0119e4a7c524b845af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66ca0fb0a9c28265b7630c0119e4a7c524b845af/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65357faef8b926a7fc61ceaa2e4db79d431c80fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/65357faef8b926a7fc61ceaa2e4db79d431c80fb", "html_url": "https://github.com/rust-lang/rust/commit/65357faef8b926a7fc61ceaa2e4db79d431c80fb"}, {"sha": "51dbb5aa29f2ba8f0e694291299be1c22c5e6419", "url": "https://api.github.com/repos/rust-lang/rust/commits/51dbb5aa29f2ba8f0e694291299be1c22c5e6419", "html_url": "https://github.com/rust-lang/rust/commit/51dbb5aa29f2ba8f0e694291299be1c22c5e6419"}], "stats": {"total": 151, "additions": 130, "deletions": 21}, "files": [{"sha": "3f7aabe03ce27bf2fa049975c25773b4e51bd1e4", "filename": "Cargo.toml", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66ca0fb0a9c28265b7630c0119e4a7c524b845af/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66ca0fb0a9c28265b7630c0119e4a7c524b845af/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=66ca0fb0a9c28265b7630c0119e4a7c524b845af", "patch": "@@ -10,15 +10,19 @@ version = \"0.1.0\"\n build = \"build.rs\"\n default-run = \"miri\"\n \n+[lib]\n+test = true # we have unit tests\n+doctest = false # but no doc tests\n+\n [[bin]]\n-doc = false\n name = \"miri\"\n-path = \"src/bin/miri.rs\"\n+test = false # we have no unit tests\n+doctest = false # and no doc tests\n \n [[bin]]\n-doc = false\n name = \"cargo-miri\"\n-path = \"src/bin/cargo-miri.rs\"\n+test = false # we have no unit tests\n+doctest = false # and no doc tests\n required-features = [\"cargo_miri\"]\n \n [dependencies]"}, {"sha": "078cbc12369f34d64590cf30e26cbfbf35fe8030", "filename": "src/operator.rs", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/66ca0fb0a9c28265b7630c0119e4a7c524b845af/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ca0fb0a9c28265b7630c0119e4a7c524b845af/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=66ca0fb0a9c28265b7630c0119e4a7c524b845af", "patch": "@@ -20,7 +20,7 @@ pub trait EvalContextExt<'tcx> {\n         &self,\n         bin_op: mir::BinOp,\n         left: Pointer,\n-        right: i128,\n+        right: u128,\n         signed: bool,\n     ) -> EvalResult<'tcx, (Scalar, bool)>;\n }\n@@ -130,26 +130,27 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     err!(InvalidPointerMath)\n                 }\n             }\n-            // These work if one operand is a pointer, the other an integer\n-            Add | BitAnd | Sub\n+            // These work if the left operand is a pointer, the right an integer\n+            Add | BitAnd | Sub | Rem\n                 if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n                        left.is_ptr() && right.is_bits() => {\n                 // Cast to i128 is fine as we checked the kind to be ptr-sized\n                 self.ptr_int_arithmetic(\n                     bin_op,\n                     left.to_ptr()?,\n-                    right.to_bits(self.memory.pointer_size())? as i128,\n+                    right.to_bits(self.memory.pointer_size())?,\n                     left_kind == isize,\n                 ).map(Some)\n             }\n+            // Commutative operators also work if the integer is on the left\n             Add | BitAnd\n                 if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n                        left.is_bits() && right.is_ptr() => {\n                 // This is a commutative operation, just swap the operands\n                 self.ptr_int_arithmetic(\n                     bin_op,\n                     right.to_ptr()?,\n-                    left.to_bits(self.memory.pointer_size())? as i128,\n+                    left.to_bits(self.memory.pointer_size())?,\n                     left_kind == isize,\n                 ).map(Some)\n             }\n@@ -161,7 +162,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         &self,\n         bin_op: mir::BinOp,\n         left: Pointer,\n-        right: i128,\n+        right: u128,\n         signed: bool,\n     ) -> EvalResult<'tcx, (Scalar, bool)> {\n         use rustc::mir::BinOp::*;\n@@ -173,22 +174,49 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         Ok(match bin_op {\n             Sub =>\n                 // The only way this can overflow is by underflowing, so signdeness of the right operands does not matter\n-                map_to_primval(left.overflowing_signed_offset(-right, self)),\n+                map_to_primval(left.overflowing_signed_offset(-(right as i128), self)),\n             Add if signed =>\n-                map_to_primval(left.overflowing_signed_offset(right, self)),\n+                map_to_primval(left.overflowing_signed_offset(right as i128, self)),\n             Add if !signed =>\n                 map_to_primval(left.overflowing_offset(Size::from_bytes(right as u64), self)),\n \n             BitAnd if !signed => {\n-                let base_mask : u64 = !(self.memory.get(left.alloc_id)?.align.abi() - 1);\n-                let right = right as u64;\n+                let ptr_base_align = self.memory.get(left.alloc_id)?.align.abi();\n+                let base_mask = {\n+                    // FIXME: Use interpret::truncate, once that takes a Size instead of a Layout\n+                    let shift = 128 - self.memory.pointer_size().bits();\n+                    let value = !(ptr_base_align as u128 - 1);\n+                    // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n+                    (value << shift) >> shift\n+                };\n                 let ptr_size = self.memory.pointer_size().bytes() as u8;\n+                trace!(\"Ptr BitAnd, align {}, operand {:#010x}, base_mask {:#010x}\",\n+                    ptr_base_align, right, base_mask);\n                 if right & base_mask == base_mask {\n                     // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n-                    (Scalar::Ptr(Pointer::new(left.alloc_id, Size::from_bytes(left.offset.bytes() & right))), false)\n+                    let offset = (left.offset.bytes() as u128 & right) as u64;\n+                    (Scalar::Ptr(Pointer::new(left.alloc_id, Size::from_bytes(offset))), false)\n                 } else if right & base_mask == 0 {\n                     // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n-                    (Scalar::Bits { bits: (left.offset.bytes() & right) as u128, size: ptr_size }, false)\n+                    (Scalar::Bits { bits: (left.offset.bytes() as u128) & right, size: ptr_size }, false)\n+                } else {\n+                    return err!(ReadPointerAsBytes);\n+                }\n+            }\n+\n+            Rem if !signed => {\n+                // Doing modulo a divisor of the alignment is allowed.\n+                // (Intuition: Modulo a divisor leaks less information.)\n+                let ptr_base_align = self.memory.get(left.alloc_id)?.align.abi();\n+                let right = right as u64;\n+                let ptr_size = self.memory.pointer_size().bytes() as u8;\n+                if right == 1 {\n+                    // modulo 1 is always 0\n+                    (Scalar::Bits { bits: 0, size: ptr_size }, false)\n+                } else if ptr_base_align % right == 0 {\n+                    // the base address would be cancelled out by the modulo operation, so we can\n+                    // just take the modulo of the offset\n+                    (Scalar::Bits { bits: (left.offset.bytes() % right) as u128, size: ptr_size }, false)\n                 } else {\n                     return err!(ReadPointerAsBytes);\n                 }"}, {"sha": "4cfdfb62e27f541f04c90d512c1dc0fea2cbc5cd", "filename": "tests/compile-fail/pointer_byte_read_1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs?ref=66ca0fb0a9c28265b7630c0119e4a7c524b845af", "patch": "@@ -3,6 +3,6 @@ fn main() {\n     let y = &x;\n     let z = &y as *const &i32 as *const usize;\n     let ptr_bytes = unsafe { *z }; // the actual deref is fine, because we read the entire pointer at once\n-    let _ = ptr_bytes % 432; //~ ERROR constant evaluation error\n+    let _ = ptr_bytes / 432; //~ ERROR constant evaluation error\n     //~^ NOTE tried to access part of a pointer value as raw bytes\n }"}, {"sha": "233c9a733c999d740984c7dfccd095e1e15e2f7c", "filename": "tests/compile-fail/ptr_bitops2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Fcompile-fail%2Fptr_bitops2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Fcompile-fail%2Fptr_bitops2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_bitops2.rs?ref=66ca0fb0a9c28265b7630c0119e4a7c524b845af", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let val = 13usize;\n+    let addr = &val as *const _ as usize;\n+    let _ = addr & 13; //~ ERROR access part of a pointer value as raw bytes\n+}"}, {"sha": "8a3665872f7cb4a0ff41342844c0040259bfe2c6", "filename": "tests/compile-fail/ptr_rem.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Fcompile-fail%2Fptr_rem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Fcompile-fail%2Fptr_rem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_rem.rs?ref=66ca0fb0a9c28265b7630c0119e4a7c524b845af", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let val = 13usize;\n+    let addr = &val as *const _ as usize;\n+    let _ = addr % 16; //~ ERROR access part of a pointer value as raw bytes\n+}"}, {"sha": "0820614ab5c810a6535ca30ec36b768ec5b72228", "filename": "tests/run-pass/dst-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Frun-pass%2Fdst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Frun-pass%2Fdst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdst-struct.rs?ref=66ca0fb0a9c28265b7630c0119e4a7c524b845af", "patch": "@@ -65,9 +65,9 @@ impl ToBar for Bar {\n \n pub fn main() {\n     // With a vec of ints.\n-    let f1 = Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    let f1 : Fat<[isize; 3]> = Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n     foo(&f1);\n-    let f2 = &f1;\n+    let f2 : &Fat<[isize; 3]> = &f1;\n     foo(f2);\n     let f3: &Fat<[isize]> = f2;\n     foo(f3);"}, {"sha": null, "filename": "tests/run-pass/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Frun-pass%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Frun-pass%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fintrinsics.rs?ref=66ca0fb0a9c28265b7630c0119e4a7c524b845af"}, {"sha": "e10781e656058abb9b5076e3d0fffc0d90c038d4", "filename": "tests/run-pass/packed_struct.rs", "status": "renamed", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Frun-pass%2Fpacked_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Frun-pass%2Fpacked_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpacked_struct.rs?ref=66ca0fb0a9c28265b7630c0119e4a7c524b845af", "patch": "@@ -1,5 +1,3 @@\n-// FIXME: We have to disable this, force_allocation fails.\n-// TODO: I think this can be triggered even without validation.\n // compile-flags: -Zmir-emit-validate=0\n #![allow(dead_code)]\n #![feature(unsize, coerce_unsized)]\n@@ -47,6 +45,43 @@ fn test_unsizing() {\n     let _unused = &arr_unaligned; // forcing an allocation, which could also yield \"unaligned write\"-errors\n }\n \n+fn test_drop() {\n+    struct Wrap(u32);\n+    impl Drop for Wrap {\n+        fn drop(&mut self) {\n+            // Do an (aligned) load\n+            let _test = self.0;\n+            // For the fun of it, test alignment\n+            assert_eq!(&self.0 as *const _ as usize % std::mem::align_of::<u32>(), 0);\n+        }\n+    }\n+\n+    #[repr(packed,C)]\n+    struct Packed<T> {\n+        f1: u8, // this should move the second field to something not very aligned\n+        f2: T,\n+    }\n+\n+    let p = Packed { f1: 42, f2: Wrap(23) };\n+    drop(p);\n+}\n+\n+fn test_inner_packed() {\n+    // Even if just the inner struct is packed, accesses to the outer field can get unaligned.\n+    // Make sure that works.\n+    #[repr(packed)]\n+    #[derive(Clone,Copy)]\n+    struct Inner(u32);\n+\n+    #[derive(Clone,Copy)]\n+    struct Outer(u8, Inner);\n+\n+    let o = Outer(0, Inner(42));\n+    let _x = o.1;\n+    let _y = (o.1).0;\n+    let _o2 = o.clone();\n+}\n+\n fn main() {\n     let mut x = S {\n         a: 42,\n@@ -66,4 +101,6 @@ fn main() {\n     test(Test2 { x: 0, other: &Test1 { x: 0, other: &42 }});\n \n     test_unsizing();\n+    test_drop();\n+    test_inner_packed();\n }", "previous_filename": "tests/run-pass/packed_struct.rs_broken"}, {"sha": "9a29c2d30837d5bcea93399f410add26082d7b0e", "filename": "tests/run-pass/ptr_int_ops.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Frun-pass%2Fptr_int_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Frun-pass%2Fptr_int_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_int_ops.rs?ref=66ca0fb0a9c28265b7630c0119e4a7c524b845af", "patch": "@@ -0,0 +1,20 @@\n+fn main() {\n+    let v = [1i16, 2];\n+    let x = &v[1] as *const i16 as usize;\n+    // arithmetic\n+    let _y = x + 4;\n+    let _y = 4 + x;\n+    let _y = x - 2;\n+    // bit-operations, covered by alignment\n+    assert_eq!(x & 1, 0);\n+    assert_eq!(x & 0, 0);\n+    assert_eq!(1 & (x+1), 1);\n+    let _y = !1 & x;\n+    let _y = !0 & x;\n+    let _y = x & !1;\n+    // remainder, covered by alignment\n+    assert_eq!(x % 2, 0);\n+    assert_eq!((x+1) % 2, 1);\n+    // remainder with 1 is always 0\n+    assert_eq!(x % 1, 0);\n+}"}, {"sha": "ec887902d0542f7a0895a51a9b99d8abe5535fbe", "filename": "tests/run-pass/transmute_fat.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Frun-pass%2Ftransmute_fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ca0fb0a9c28265b7630c0119e4a7c524b845af/tests%2Frun-pass%2Ftransmute_fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftransmute_fat.rs?ref=66ca0fb0a9c28265b7630c0119e4a7c524b845af", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    // If we are careful, we can exploit data layout...\n+    let raw = unsafe {\n+        std::mem::transmute::<&[u8], [usize; 2]>(&[42])\n+    };\n+    let ptr = raw[0] + raw[1];\n+    let ptr = ptr as *const u8;\n+    // The pointer is one-past-the end, but we decrement it into bounds before using it\n+    assert_eq!(unsafe { *ptr.offset(-1) }, 42);\n+}"}]}