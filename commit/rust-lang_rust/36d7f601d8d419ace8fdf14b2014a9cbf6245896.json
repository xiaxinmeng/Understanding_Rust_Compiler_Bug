{"sha": "36d7f601d8d419ace8fdf14b2014a9cbf6245896", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ZDdmNjAxZDhkNDE5YWNlOGZkZjE0YjIwMTRhOWNiZjYyNDU4OTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-27T00:37:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-27T00:37:29Z"}, "message": "auto merge of #7354 : bblum/rust/trait-bounds, r=pcwalton\n\nr? @nikomatsakis", "tree": {"sha": "47f511bde18a704513fb3b6b74f4b4b434c3cd73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47f511bde18a704513fb3b6b74f4b4b434c3cd73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36d7f601d8d419ace8fdf14b2014a9cbf6245896", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36d7f601d8d419ace8fdf14b2014a9cbf6245896", "html_url": "https://github.com/rust-lang/rust/commit/36d7f601d8d419ace8fdf14b2014a9cbf6245896", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36d7f601d8d419ace8fdf14b2014a9cbf6245896/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32adc0e730636f04d72d31e24fbf1101a495ccb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/32adc0e730636f04d72d31e24fbf1101a495ccb7", "html_url": "https://github.com/rust-lang/rust/commit/32adc0e730636f04d72d31e24fbf1101a495ccb7"}, {"sha": "c37ccac9313b52a8f4299b370fe33b0fbe202db4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c37ccac9313b52a8f4299b370fe33b0fbe202db4", "html_url": "https://github.com/rust-lang/rust/commit/c37ccac9313b52a8f4299b370fe33b0fbe202db4"}], "stats": {"total": 507, "additions": 362, "deletions": 145}, "files": [{"sha": "11dea1c3a708105cd37dcc2b559d3ce7c909127a", "filename": "src/libextra/io_util.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibextra%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibextra%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fio_util.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -10,6 +10,7 @@\n \n use core::io::{Reader, BytesReader};\n use core::io;\n+use core::cast;\n \n /// An implementation of the io::Reader interface which reads a buffer of bytes\n pub struct BufReader {\n@@ -29,10 +30,13 @@ impl BufReader {\n     }\n \n     fn as_bytes_reader<A>(&self, f: &fn(&BytesReader) -> A) -> A {\n+        // XXX FIXME(#5723)\n+        let bytes = ::core::util::id::<&[u8]>(self.buf);\n+        let bytes: &'static [u8] = unsafe { cast::transmute(bytes) };\n         // Recreating the BytesReader state every call since\n         // I can't get the borrowing to work correctly\n         let bytes_reader = BytesReader {\n-            bytes: ::core::util::id::<&[u8]>(self.buf),\n+            bytes: bytes,\n             pos: @mut *self.pos\n         };\n "}, {"sha": "ee0d3649467bf6b47669129e8cd553d3d0046fd6", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -423,7 +423,7 @@ type MonitorMsg = (TestDesc, TestResult);\n \n fn run_tests(opts: &TestOpts,\n              tests: ~[TestDescAndFn],\n-             callback: @fn(e: TestEvent)) {\n+             callback: &fn(e: TestEvent)) {\n \n     let filtered_tests = filter_tests(opts, tests);\n     let filtered_descs = filtered_tests.map(|t| copy t.desc);"}, {"sha": "cb47c88d3d4fc843d82839223c57eeb9204fadff", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -959,7 +959,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(ebml_w, item.attrs);\n         match ty.node {\n             ast::ty_path(path, bounds, _) if path.idents.len() == 1 => {\n-                assert!(bounds.is_empty());\n+                assert!(bounds.is_none());\n                 encode_impl_type_basename(ecx, ebml_w,\n                                           ast_util::path_to_ident(path));\n             }"}, {"sha": "a1f595fc8969ff10e2000894f887c1a7d266d9e2", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -128,7 +128,7 @@ fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n                             // Yes, it's a destructor.\n                             match self_type.node {\n                                 ty_path(_, bounds, path_node_id) => {\n-                                    assert!(bounds.is_empty());\n+                                    assert!(bounds.is_none());\n                                     let struct_def = cx.tcx.def_map.get_copy(\n                                         &path_node_id);\n                                     let struct_did =\n@@ -169,10 +169,6 @@ fn with_appropriate_checker(cx: Context, id: node_id,\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n \n-        // FIXME(#3569): Once closure capabilities are restricted based on their\n-        // incoming bounds, make this check conditional based on the bounds.\n-        if !check_owned(cx, var_t, fv.span) { return; }\n-\n         // check that only immutable variables are implicitly copied in\n         check_imm_free_var(cx, fv.def, fv.span);\n \n@@ -184,10 +180,6 @@ fn with_appropriate_checker(cx: Context, id: node_id,\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n \n-        // FIXME(#3569): Once closure capabilities are restricted based on their\n-        // incoming bounds, make this check conditional based on the bounds.\n-        if !check_durable(cx.tcx, var_t, fv.span) { return; }\n-\n         // check that only immutable variables are implicitly copied in\n         check_imm_free_var(cx, fv.def, fv.span);\n \n@@ -293,9 +285,9 @@ pub fn check_expr(e: @expr, (cx, v): (Context, visit::vt<Context>)) {\n         expr_cast(source, _) => {\n             check_cast_for_escaping_regions(cx, source, e);\n             match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n-                ty::ty_trait(_, _, store, _, bounds) => {\n+                ty::ty_trait(_, _, _, _, bounds) => {\n                     let source_ty = ty::expr_ty(cx.tcx, source);\n-                    check_trait_cast_bounds(cx, e.span, source_ty, bounds, store)\n+                    check_trait_cast_bounds(cx, e.span, source_ty, bounds)\n                 }\n                 _ => { }\n             }\n@@ -391,19 +383,14 @@ pub fn check_freevar_bounds(cx: Context, sp: span, ty: ty::t,\n }\n \n pub fn check_trait_cast_bounds(cx: Context, sp: span, ty: ty::t,\n-                               bounds: ty::BuiltinBounds, store: ty::TraitStore) {\n+                               bounds: ty::BuiltinBounds) {\n     do check_builtin_bounds(cx, ty, bounds) |missing| {\n         cx.tcx.sess.span_err(sp,\n             fmt!(\"cannot pack type `%s`, which does not fulfill \\\n                   `%s`, as a trait bounded by %s\",\n                  ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx),\n                  bounds.user_string(cx.tcx)));\n     }\n-    // FIXME(#3569): Remove this check when the corresponding restriction\n-    // is made with type contents.\n-    if store == ty::UniqTraitStore && !ty::type_is_owned(cx.tcx, ty) {\n-        cx.tcx.sess.span_err(sp, \"uniquely-owned trait objects must be sendable\");\n-    }\n }\n \n fn is_nullary_variant(cx: Context, ex: @expr) -> bool {"}, {"sha": "e06fd8f971791796f7e7f405a271d47beb756e9e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -4195,15 +4195,19 @@ impl Resolver {\n                     }\n                 }\n \n-                for bounds.iter().advance |bound| {\n-                    self.resolve_type_parameter_bound(bound, visitor);\n-                }\n+                do bounds.map |bound_vec| {\n+                    for bound_vec.iter().advance |bound| {\n+                        self.resolve_type_parameter_bound(bound, visitor);\n+                    }\n+                };\n             }\n \n             ty_closure(c) => {\n-                for c.bounds.iter().advance |bound| {\n-                    self.resolve_type_parameter_bound(bound, visitor);\n-                }\n+                do c.bounds.map |bounds| {\n+                    for bounds.iter().advance |bound| {\n+                        self.resolve_type_parameter_bound(bound, visitor);\n+                    }\n+                };\n                 visit_ty(ty, ((), visitor));\n             }\n "}, {"sha": "4cea4c949724097ad882d1eca2237a9ddbb1cc43", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 48, "deletions": 22, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -2063,20 +2063,8 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 TC_MANAGED + statically_sized(nonowned(tc_mt(cx, mt, cache)))\n             }\n \n-            ty_trait(_, _, UniqTraitStore, _, _bounds) => {\n-                // FIXME(#3569): Make this conditional on the trait's bounds.\n-                TC_NONCOPY_TRAIT + TC_OWNED_POINTER\n-            }\n-\n-            ty_trait(_, _, BoxTraitStore, mutbl, _bounds) => {\n-                match mutbl {\n-                    ast::m_mutbl => TC_MANAGED + TC_MUTABLE,\n-                    _ => TC_MANAGED\n-                }\n-            }\n-\n-            ty_trait(_, _, RegionTraitStore(r), mutbl, _bounds) => {\n-                borrowed_contents(r, mutbl)\n+            ty_trait(_, _, store, mutbl, bounds) => {\n+                trait_contents(store, mutbl, bounds)\n             }\n \n             ty_rptr(r, mt) => {\n@@ -2261,23 +2249,59 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n     }\n \n     fn closure_contents(cty: &ClosureTy) -> TypeContents {\n+        // Closure contents are just like trait contents, but with potentially\n+        // even more stuff.\n         let st = match cty.sigil {\n-            ast::BorrowedSigil => TC_BORROWED_POINTER,\n-            ast::ManagedSigil => TC_MANAGED,\n-            ast::OwnedSigil => if cty.bounds.contains_elem(BoundCopy) {\n-                TC_OWNED_POINTER\n-            } else {\n-                TC_OWNED_POINTER + TC_NONCOPY_TRAIT\n-            }\n+            ast::BorrowedSigil =>\n+                trait_contents(RegionTraitStore(cty.region), m_imm, cty.bounds)\n+                    + TC_BORROWED_POINTER, // might be an env packet even if static\n+            ast::ManagedSigil =>\n+                trait_contents(BoxTraitStore, m_imm, cty.bounds),\n+            ast::OwnedSigil =>\n+                trait_contents(UniqTraitStore, m_imm, cty.bounds),\n         };\n+        // FIXME(#3569): This borrowed_contents call should be taken care of in\n+        // trait_contents, after ~Traits and @Traits can have region bounds too.\n+        // This one here is redundant for &fns but important for ~fns and @fns.\n         let rt = borrowed_contents(cty.region, m_imm);\n+        // This also prohibits \"@once fn\" from being copied, which allows it to\n+        // be called. Neither way really makes much sense.\n         let ot = match cty.onceness {\n             ast::Once => TC_ONCE_CLOSURE,\n             ast::Many => TC_NONE\n         };\n         st + rt + ot\n     }\n \n+    fn trait_contents(store: TraitStore, mutbl: ast::mutability,\n+                      bounds: BuiltinBounds) -> TypeContents {\n+        let st = match store {\n+            UniqTraitStore      => TC_OWNED_POINTER,\n+            BoxTraitStore       => TC_MANAGED,\n+            RegionTraitStore(r) => borrowed_contents(r, mutbl),\n+        };\n+        let mt = match mutbl { ast::m_mutbl => TC_MUTABLE, _ => TC_NONE };\n+        // We get additional \"special type contents\" for each bound that *isn't*\n+        // on the trait. So iterate over the inverse of the bounds that are set.\n+        // This is like with typarams below, but less \"pessimistic\" and also\n+        // dependent on the trait store.\n+        let mut bt = TC_NONE;\n+        for (AllBuiltinBounds() - bounds).each |bound| {\n+            bt = bt + match bound {\n+                BoundCopy if store == UniqTraitStore\n+                            => TC_NONCOPY_TRAIT,\n+                BoundCopy   => TC_NONE, // @Trait/&Trait are copyable either way\n+                BoundStatic if bounds.contains_elem(BoundOwned)\n+                            => TC_NONE, // Owned bound implies static bound.\n+                BoundStatic => TC_BORROWED_POINTER, // Useful for \"@Trait:'static\"\n+                BoundOwned  => TC_NON_OWNED,\n+                BoundConst  => TC_MUTABLE,\n+                BoundSized  => TC_NONE, // don't care if interior is sized\n+            };\n+        }\n+        st + mt + bt\n+    }\n+\n     fn type_param_def_to_contents(cx: ctxt,\n                                   type_param_def: &TypeParameterDef) -> TypeContents\n     {\n@@ -4497,7 +4521,9 @@ pub fn visitor_object_ty(tcx: ctxt) -> (@TraitRef, t) {\n     };\n     let trait_lang_item = tcx.lang_items.ty_visitor();\n     let trait_ref = @TraitRef { def_id: trait_lang_item, substs: substs };\n+    let mut static_trait_bound = EmptyBuiltinBounds();\n+    static_trait_bound.add(BoundStatic);\n     (trait_ref,\n      mk_trait(tcx, trait_ref.def_id, copy trait_ref.substs,\n-              BoxTraitStore, ast::m_imm, EmptyBuiltinBounds()))\n+              BoxTraitStore, ast::m_imm, static_trait_bound))\n }"}, {"sha": "997061a61ba636f30b73b3be783d6788f0f27a6d", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 50, "deletions": 25, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -303,7 +303,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                                 ty::BoxTraitStore\n                             }\n                         };\n-                        let bounds = conv_builtin_bounds(this.tcx(), bounds);\n+                        let bounds = conv_builtin_bounds(this.tcx(), bounds, trait_store);\n                         return ty::mk_trait(tcx,\n                                             result.def_id,\n                                             copy result.substs,\n@@ -386,7 +386,13 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                                             bf.abis, &bf.lifetimes, &bf.decl))\n       }\n       ast::ty_closure(ref f) => {\n-          let bounds = conv_builtin_bounds(this.tcx(), &f.bounds);\n+          let bounds = conv_builtin_bounds(this.tcx(), &f.bounds, match f.sigil {\n+              // Use corresponding trait store to figure out default bounds\n+              // if none were specified.\n+              ast::BorrowedSigil => ty::RegionTraitStore(ty::re_empty), // dummy region\n+              ast::OwnedSigil    => ty::UniqTraitStore,\n+              ast::ManagedSigil  => ty::BoxTraitStore,\n+          });\n           let fn_decl = ty_of_closure(this,\n                                       rscope,\n                                       f.sigil,\n@@ -411,7 +417,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n         match a_def {\n             // But don't emit the error if the user meant to do a trait anyway.\n             ast::def_trait(*) => { },\n-            _ if !bounds.is_empty() =>\n+            _ if bounds.is_some() =>\n                 tcx.sess.span_err(ast_ty.span,\n                     \"kind bounds can only be used on trait types\"),\n             _ => { },\n@@ -741,41 +747,60 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n     }\n }\n \n-fn conv_builtin_bounds(tcx: ty::ctxt,\n-                       ast_bounds: &OptVec<ast::TyParamBound>)\n+fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBound>>,\n+                       store: ty::TraitStore)\n                        -> ty::BuiltinBounds {\n     //! Converts a list of bounds from the AST into a `BuiltinBounds`\n     //! struct. Reports an error if any of the bounds that appear\n     //! in the AST refer to general traits and not the built-in traits\n     //! like `Copy` or `Owned`. Used to translate the bounds that\n     //! appear in closure and trait types, where only builtin bounds are\n     //! legal.\n-\n-    let mut builtin_bounds = ty::EmptyBuiltinBounds();\n-    for ast_bounds.iter().advance |ast_bound| {\n-        match *ast_bound {\n-            ast::TraitTyParamBound(b) => {\n-                match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n-                    ast::def_trait(trait_did) => {\n-                        if try_add_builtin_trait(tcx,\n-                                                 trait_did,\n-                                                 &mut builtin_bounds) {\n-                            loop; // success\n+    //! If no bounds were specified, we choose a \"default\" bound based on\n+    //! the allocation type of the fn/trait, as per issue #7264. The user can\n+    //! override this with an empty bounds list, e.g. \"~fn:()\" or \"~Trait:\".\n+\n+    match (ast_bounds, store) {\n+        (&Some(ref bound_vec), _) => {\n+            let mut builtin_bounds = ty::EmptyBuiltinBounds();\n+            for bound_vec.iter().advance |ast_bound| {\n+                match *ast_bound {\n+                    ast::TraitTyParamBound(b) => {\n+                        match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n+                            ast::def_trait(trait_did) => {\n+                                if try_add_builtin_trait(tcx,\n+                                                         trait_did,\n+                                                         &mut builtin_bounds) {\n+                                    loop; // success\n+                                }\n+                            }\n+                            _ => { }\n                         }\n+                        tcx.sess.span_fatal(\n+                            b.path.span,\n+                            fmt!(\"only the builtin traits can be used \\\n+                                  as closure or object bounds\"));\n+                    }\n+                    ast::RegionTyParamBound => {\n+                        builtin_bounds.add(ty::BoundStatic);\n                     }\n-                    _ => { }\n                 }\n-                tcx.sess.span_fatal(\n-                    b.path.span,\n-                    fmt!(\"only the builtin traits can be used \\\n-                          as closure or object bounds\"));\n-            }\n-            ast::RegionTyParamBound => {\n-                builtin_bounds.add(ty::BoundStatic);\n             }\n+            builtin_bounds\n+        },\n+        // ~Trait is sugar for ~Trait:Owned.\n+        (&None, ty::UniqTraitStore) => {\n+            let mut set = ty::EmptyBuiltinBounds(); set.add(ty::BoundOwned); set\n+        }\n+        // @Trait is sugar for @Trait:'static.\n+        // &'static Trait is sugar for &'static Trait:'static.\n+        (&None, ty::BoxTraitStore) |\n+        (&None, ty::RegionTraitStore(ty::re_static)) => {\n+            let mut set = ty::EmptyBuiltinBounds(); set.add(ty::BoundStatic); set\n         }\n+        // &'r Trait is sugar for &'r Trait:<no-bounds>.\n+        (&None, ty::RegionTraitStore(*)) => ty::EmptyBuiltinBounds(),\n     }\n-    builtin_bounds\n }\n \n pub fn try_add_builtin_trait(tcx: ty::ctxt,"}, {"sha": "a78be9c8b2b1d2f7e1902a6ed939ae2b48e61811", "filename": "src/libstd/io.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -1042,12 +1042,14 @@ pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n \n \n // Byte readers\n-pub struct BytesReader<'self> {\n-    bytes: &'self [u8],\n+pub struct BytesReader {\n+    // FIXME(#5723) see other FIXME below\n+    // FIXME(#7268) this should also be parameterized over <'self>\n+    bytes: &'static [u8],\n     pos: @mut uint\n }\n \n-impl<'self> Reader for BytesReader<'self> {\n+impl Reader for BytesReader {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         let count = uint::min(len, self.bytes.len() - *self.pos);\n \n@@ -1084,13 +1086,18 @@ impl<'self> Reader for BytesReader<'self> {\n }\n \n pub fn with_bytes_reader<T>(bytes: &[u8], f: &fn(@Reader) -> T) -> T {\n+    // XXX XXX XXX this is glaringly unsound\n+    // FIXME(#5723) Use a &Reader for the callback's argument. Should be:\n+    // fn with_bytes_reader<'r, T>(bytes: &'r [u8], f: &fn(&'r Reader) -> T) -> T\n+    let bytes: &'static [u8] = unsafe { cast::transmute(bytes) };\n     f(@BytesReader {\n         bytes: bytes,\n         pos: @mut 0\n     } as @Reader)\n }\n \n pub fn with_str_reader<T>(s: &str, f: &fn(@Reader) -> T) -> T {\n+    // FIXME(#5723): As above.\n     with_bytes_reader(s.as_bytes(), f)\n }\n "}, {"sha": "1a7094acf7e4ec279ef701f49d4db5996747d21d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -771,7 +771,11 @@ pub struct TyClosure {\n     purity: purity,\n     onceness: Onceness,\n     decl: fn_decl,\n-    bounds: OptVec<TyParamBound>\n+    // Optional optvec distinguishes between \"fn()\" and \"fn:()\" so we can\n+    // implement issue #7264. None means \"fn()\", which means infer a default\n+    // bound based on pointer sigil during typeck. Some(Empty) means \"fn:()\",\n+    // which means use no bounds (e.g., not even Owned on a ~fn()).\n+    bounds: Option<OptVec<TyParamBound>>,\n }\n \n #[deriving(Eq, Encodable, Decodable)]\n@@ -795,7 +799,7 @@ pub enum ty_ {\n     ty_closure(@TyClosure),\n     ty_bare_fn(@TyBareFn),\n     ty_tup(~[@Ty]),\n-    ty_path(@Path, @OptVec<TyParamBound>, node_id),\n+    ty_path(@Path, @Option<OptVec<TyParamBound>>, node_id), // for #7264; see above\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not"}, {"sha": "2c1b4cfc59155bec02f42ed2a5f1402c999c4cf3", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -46,7 +46,7 @@ pub trait AstBuilder {\n     fn ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt;\n \n     fn ty(&self, span: span, ty: ast::ty_) -> @ast::Ty;\n-    fn ty_path(&self, @ast::Path, @OptVec<ast::TyParamBound>) -> @ast::Ty;\n+    fn ty_path(&self, @ast::Path, @Option<OptVec<ast::TyParamBound>>) -> @ast::Ty;\n     fn ty_ident(&self, span: span, idents: ast::ident) -> @ast::Ty;\n \n     fn ty_rptr(&self, span: span,\n@@ -265,7 +265,7 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn ty_path(&self, path: @ast::Path, bounds: @OptVec<ast::TyParamBound>)\n+    fn ty_path(&self, path: @ast::Path, bounds: @Option<OptVec<ast::TyParamBound>>)\n               -> @ast::Ty {\n         self.ty(path.span,\n                 ast::ty_path(path, bounds, self.next_id()))\n@@ -275,7 +275,7 @@ impl AstBuilder for @ExtCtxt {\n     // to generate a bounded existential trait type.\n     fn ty_ident(&self, span: span, ident: ast::ident)\n         -> @ast::Ty {\n-        self.ty_path(self.path_ident(span, ident), @opt_vec::Empty)\n+        self.ty_path(self.path_ident(span, ident), @None)\n     }\n \n     fn ty_rptr(&self,\n@@ -306,7 +306,7 @@ impl AstBuilder for @ExtCtxt {\n                           ],\n                           None,\n                           ~[ ty ]),\n-            @opt_vec::Empty)\n+            @None)\n     }\n \n     fn ty_field_imm(&self, span: span, name: ident, ty: @ast::Ty) -> ast::ty_field {\n@@ -344,7 +344,7 @@ impl AstBuilder for @ExtCtxt {\n     fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_path(\n-                self.path_global(dummy_sp(), ~[p.ident]), @opt_vec::Empty)))\n+                self.path_global(dummy_sp(), ~[p.ident]), @None)))\n     }\n \n     fn strip_bounds(&self, generics: &Generics) -> Generics {"}, {"sha": "10d9f878bc45187234357d598d4ffbbbf94ce662", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -357,7 +357,7 @@ impl<'self> TraitDef<'self> {\n         // Create the type of `self`.\n         let self_type = cx.ty_path(cx.path_all(span, false, ~[ type_ident ], self_lifetime,\n                                                opt_vec::take_vec(self_ty_params)),\n-                                   @opt_vec::Empty);\n+                                   @None);\n \n         let doc_attr = cx.attribute(\n             span,"}, {"sha": "2f21eba11d7e2b172f917f4a76fe2530d5ed7f3a", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -63,7 +63,7 @@ impl<'self> Path<'self> {\n                  self_generics: &Generics)\n                  -> @ast::Ty {\n         cx.ty_path(self.to_path(cx, span,\n-                                self_ty, self_generics), @opt_vec::Empty)\n+                                self_ty, self_generics), @None)\n     }\n     pub fn to_path(&self,\n                    cx: @ExtCtxt,\n@@ -143,7 +143,7 @@ impl<'self> Ty<'self> {\n             Literal(ref p) => { p.to_ty(cx, span, self_ty, self_generics) }\n             Self  => {\n                 cx.ty_path(self.to_path(cx, span, self_ty, self_generics),\n-                           @opt_vec::Empty)\n+                           @None)\n             }\n             Tuple(ref fields) => {\n                 let ty = if fields.is_empty() {"}, {"sha": "2c5ec0909d9514416155fc3660054f10040be52f", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -59,7 +59,7 @@ impl gen_send for message {\n \n             let pipe_ty = cx.ty_path(\n                 path(~[this.data_name()], span)\n-                .add_tys(cx.ty_vars(&this.generics.ty_params)), @opt_vec::Empty);\n+                .add_tys(cx.ty_vars(&this.generics.ty_params)), @None);\n             let args_ast = vec::append(\n                 ~[cx.arg(span, cx.ident_of(\"pipe\"), pipe_ty)],\n                 args_ast);\n@@ -115,7 +115,7 @@ impl gen_send for message {\n \n             let mut rty = cx.ty_path(path(~[next.data_name()],\n                                           span)\n-                                     .add_tys(copy next_state.tys), @opt_vec::Empty);\n+                                     .add_tys(copy next_state.tys), @None);\n             if try {\n                 rty = cx.ty_option(rty);\n             }\n@@ -144,7 +144,7 @@ impl gen_send for message {\n                              cx.ty_path(\n                                  path(~[this.data_name()], span)\n                                  .add_tys(cx.ty_vars(\n-                                     &this.generics.ty_params)), @opt_vec::Empty))],\n+                                     &this.generics.ty_params)), @None))],\n                     args_ast);\n \n                 let message_args = if arg_names.len() == 0 {\n@@ -190,7 +190,7 @@ impl gen_send for message {\n \n     fn to_ty(&mut self, cx: @ExtCtxt) -> @ast::Ty {\n         cx.ty_path(path(~[cx.ident_of(self.name())], self.span())\n-          .add_tys(cx.ty_vars(&self.get_generics().ty_params)), @opt_vec::Empty)\n+          .add_tys(cx.ty_vars(&self.get_generics().ty_params)), @None)\n     }\n }\n \n@@ -224,7 +224,7 @@ impl to_type_decls for state {\n                                 cx.ty_path(\n                                     path(~[cx.ident_of(dir),\n                                            cx.ident_of(next_name)], span)\n-                                    .add_tys(copy next_state.tys), @opt_vec::Empty))\n+                                    .add_tys(copy next_state.tys), @None))\n               }\n               None => tys\n             };\n@@ -277,8 +277,8 @@ impl to_type_decls for state {\n                                    self.data_name()],\n                                  dummy_sp())\n                             .add_tys(cx.ty_vars(\n-                                &self.generics.ty_params)), @opt_vec::Empty)),\n-                        @opt_vec::Empty),\n+                                &self.generics.ty_params)), @None)),\n+                        @None),\n                     cx.strip_bounds(&self.generics)));\n         }\n         else {\n@@ -297,8 +297,8 @@ impl to_type_decls for state {\n                                    self.data_name()],\n                                         dummy_sp())\n                             .add_tys(cx.ty_vars_global(\n-                                &self.generics.ty_params)), @opt_vec::Empty),\n-                                   self.proto.buffer_ty_path(cx)]), @opt_vec::Empty),\n+                                &self.generics.ty_params)), @None),\n+                                   self.proto.buffer_ty_path(cx)]), @None),\n                     cx.strip_bounds(&self.generics)));\n         };\n         items\n@@ -383,7 +383,7 @@ impl gen_init for protocol {\n         cx.ty_path(path(~[cx.ident_of(\"super\"),\n                           cx.ident_of(\"__Buffer\")],\n                         copy self.span)\n-                   .add_tys(cx.ty_vars_global(&params)), @opt_vec::Empty)\n+                   .add_tys(cx.ty_vars_global(&params)), @None)\n     }\n \n     fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item {"}, {"sha": "0525c6664780e4b7ba457fef1fd62261e936eec0", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -13,7 +13,6 @@ use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::pipes::ast_builder::{append_types, path};\n-use opt_vec;\n \n #[deriving(Eq)]\n pub enum direction { send, recv }\n@@ -100,7 +99,7 @@ impl state_ {\n     pub fn to_ty(&self, cx: @ExtCtxt) -> @ast::Ty {\n         cx.ty_path\n             (path(~[cx.ident_of(self.name)],self.span).add_tys(\n-                cx.ty_vars(&self.generics.ty_params)), @opt_vec::Empty)\n+                cx.ty_vars(&self.generics.ty_params)), @None)\n     }\n \n     /// Iterate over the states that can be reached in one message"}, {"sha": "2fc111da453cf1023a5059dc470c2ce2186db59d", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -651,6 +651,12 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n             span: fld.new_span(f.span),\n         }\n     }\n+    fn fold_opt_bounds(b: &Option<OptVec<TyParamBound>>, fld: @ast_fold)\n+                        -> Option<OptVec<TyParamBound>> {\n+        do b.map |bounds| {\n+            do bounds.map |bound| { fold_ty_param_bound(bound, fld) }\n+        }\n+    }\n     match *t {\n         ty_nil | ty_bot | ty_infer => copy *t,\n         ty_box(ref mt) => ty_box(fold_mt(mt, fld)),\n@@ -664,7 +670,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n                 purity: f.purity,\n                 region: f.region,\n                 onceness: f.onceness,\n-                bounds: f.bounds.map(|x| fold_ty_param_bound(x, fld)),\n+                bounds: fold_opt_bounds(&f.bounds, fld),\n                 decl: fold_fn_decl(&f.decl, fld),\n                 lifetimes: copy f.lifetimes,\n             })\n@@ -679,8 +685,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n         }\n         ty_tup(ref tys) => ty_tup(tys.map(|ty| fld.fold_ty(*ty))),\n         ty_path(path, bounds, id) =>\n-            ty_path(fld.fold_path(path),\n-                    @bounds.map(|x| fold_ty_param_bound(x, fld)), fld.new_id(id)),\n+            ty_path(fld.fold_path(path), @fold_opt_bounds(bounds, fld), fld.new_id(id)),\n         ty_fixed_length_vec(ref mt, e) => {\n             ty_fixed_length_vec(\n                 fold_mt(mt, fld),"}, {"sha": "6dd8d4880e3f0d69fb80b8fc0de85d8539263d4e", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -490,7 +490,7 @@ mod test {\n                                         idents:~[str_to_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n-                                                       @opt_vec::Empty, 2),\n+                                                       @None, 2),\n                                     span:sp(4,7)},\n                        pat: @ast::pat{id:1,\n                                       node: ast::pat_ident(ast::bind_infer,\n@@ -526,7 +526,7 @@ mod test {\n                                         idents:~[str_to_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n-                                                       @opt_vec::Empty, 2),\n+                                                       @None, 2),\n                                                 span:sp(10,13)},\n                                     pat: @ast::pat{id:1, // fixme\n                                                    node: ast::pat_ident("}, {"sha": "d67771fc43547dac4cb01956c3d8d9f604ac35d5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -1047,8 +1047,8 @@ impl Parser {\n \n     // Like the above, but can also parse kind bounds in the case of a\n     // path to be used as a type that might be a trait.\n-    pub fn parse_type_path(&self) -> (@ast::Path, OptVec<TyParamBound>) {\n-        let mut bounds = opt_vec::Empty;\n+    pub fn parse_type_path(&self) -> (@ast::Path, Option<OptVec<TyParamBound>>) {\n+        let mut bounds = None;\n         let path = self.parse_bounded_path_with_tps(false, Some(|| {\n             // Note: this closure might not even get called in the case of a\n             // macro-generated path. But that's the macro parser's job.\n@@ -2884,9 +2884,13 @@ impl Parser {\n     // matches optbounds = ( ( : ( boundseq )? )? )\n     // where   boundseq  = ( bound + boundseq ) | bound\n     // and     bound     = 'static | ty\n-    fn parse_optional_ty_param_bounds(&self) -> OptVec<TyParamBound> {\n+    // Returns \"None\" if there's no colon (e.g. \"T\");\n+    // Returns \"Some(Empty)\" if there's a colon but nothing after (e.g. \"T:\")\n+    // Returns \"Some(stuff)\" otherwise (e.g. \"T:stuff\").\n+    // NB: The None/Some distinction is important for issue #7264.\n+    fn parse_optional_ty_param_bounds(&self) -> Option<OptVec<TyParamBound>> {\n         if !self.eat(&token::COLON) {\n-            return opt_vec::Empty;\n+            return None;\n         }\n \n         let mut result = opt_vec::Empty;\n@@ -2935,13 +2939,15 @@ impl Parser {\n             }\n         }\n \n-        return result;\n+        return Some(result);\n     }\n \n     // matches typaram = IDENT optbounds\n     fn parse_ty_param(&self) -> TyParam {\n         let ident = self.parse_ident();\n-        let bounds = @self.parse_optional_ty_param_bounds();\n+        let opt_bounds = self.parse_optional_ty_param_bounds();\n+        // For typarams we don't care about the difference b/w \"<T>\" and \"<T:>\".\n+        let bounds = @opt_bounds.get_or_default(opt_vec::Empty);\n         ast::TyParam { ident: ident, id: self.get_id(), bounds: bounds }\n     }\n \n@@ -3288,7 +3294,7 @@ impl Parser {\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n             // New-style trait. Reinterpret the type as a trait.\n             let opt_trait_ref = match ty.node {\n-                ty_path(path, @opt_vec::Empty, node_id) => {\n+                ty_path(path, @None, node_id) => {\n                     Some(@trait_ref {\n                         path: path,\n                         ref_id: node_id"}, {"sha": "728a5a3d32af221788f6f5949e7c444632dc9ab0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -410,14 +410,14 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n           let generics = ast::Generics {lifetimes: copy f.lifetimes,\n                                         ty_params: opt_vec::Empty};\n           print_ty_fn(s, Some(f.abis), None, None,\n-                      f.purity, ast::Many, &f.decl, None,\n+                      f.purity, ast::Many, &f.decl, None, &None,\n                       Some(&generics), None);\n       }\n       ast::ty_closure(f) => {\n           let generics = ast::Generics {lifetimes: copy f.lifetimes,\n                                         ty_params: opt_vec::Empty};\n           print_ty_fn(s, None, Some(f.sigil), f.region,\n-                      f.purity, f.onceness, &f.decl, None,\n+                      f.purity, f.onceness, &f.decl, None, &f.bounds,\n                       Some(&generics), None);\n       }\n       ast::ty_path(path, bounds, _) => print_bounded_path(s, path, bounds),\n@@ -806,7 +806,7 @@ pub fn print_ty_method(s: @ps, m: &ast::ty_method) {\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n     print_ty_fn(s, None, None, None, m.purity, ast::Many,\n-                &m.decl, Some(m.ident), Some(&m.generics),\n+                &m.decl, Some(m.ident), &None, Some(&m.generics),\n                 Some(/*bad*/ copy m.explicit_self.node));\n     word(s.s, \";\");\n }\n@@ -1488,16 +1488,16 @@ pub fn print_for_decl(s: @ps, loc: @ast::local, coll: @ast::expr) {\n }\n \n fn print_path_(s: @ps, path: @ast::Path, colons_before_params: bool,\n-               opt_bounds: Option<@OptVec<ast::TyParamBound>>) {\n+               opt_bounds: &Option<OptVec<ast::TyParamBound>>) {\n     maybe_print_comment(s, path.span.lo);\n     if path.global { word(s.s, \"::\"); }\n     let mut first = true;\n     for path.idents.iter().advance |id| {\n         if first { first = false; } else { word(s.s, \"::\"); }\n         print_ident(s, *id);\n     }\n-    do opt_bounds.map_consume |bounds| {\n-        print_bounds(s, bounds);\n+    do opt_bounds.map |bounds| {\n+        print_bounds(s, bounds, true);\n     };\n     if path.rp.is_some() || !path.types.is_empty() {\n         if colons_before_params { word(s.s, \"::\"); }\n@@ -1520,12 +1520,12 @@ fn print_path_(s: @ps, path: @ast::Path, colons_before_params: bool,\n }\n \n pub fn print_path(s: @ps, path: @ast::Path, colons_before_params: bool) {\n-    print_path_(s, path, colons_before_params, None)\n+    print_path_(s, path, colons_before_params, &None)\n }\n \n pub fn print_bounded_path(s: @ps, path: @ast::Path,\n-                          bounds: @OptVec<ast::TyParamBound>) {\n-    print_path_(s, path, false, Some(bounds))\n+                          bounds: &Option<OptVec<ast::TyParamBound>>) {\n+    print_path_(s, path, false, bounds)\n }\n \n pub fn print_irrefutable_pat(s: @ps, pat: @ast::pat) {\n@@ -1737,7 +1737,8 @@ pub fn print_fn_block_args(s: @ps, decl: &ast::fn_decl) {\n     maybe_print_comment(s, decl.output.span.lo);\n }\n \n-pub fn print_bounds(s: @ps, bounds: @OptVec<ast::TyParamBound>) {\n+pub fn print_bounds(s: @ps, bounds: &OptVec<ast::TyParamBound>,\n+                    print_colon_anyway: bool) {\n     if !bounds.is_empty() {\n         word(s.s, \":\");\n         let mut first = true;\n@@ -1754,6 +1755,8 @@ pub fn print_bounds(s: @ps, bounds: @OptVec<ast::TyParamBound>) {\n                 RegionTyParamBound => word(s.s, \"'static\"),\n             }\n         }\n+    } else if print_colon_anyway {\n+        word(s.s, \":\");\n     }\n }\n \n@@ -1774,7 +1777,7 @@ pub fn print_generics(s: @ps, generics: &ast::Generics) {\n                 let idx = idx - generics.lifetimes.len();\n                 let param = generics.ty_params.get(idx);\n                 print_ident(s, param.ident);\n-                print_bounds(s, param.bounds);\n+                print_bounds(s, param.bounds, false);\n             }\n         }\n \n@@ -1917,6 +1920,7 @@ pub fn print_ty_fn(s: @ps,\n                    onceness: ast::Onceness,\n                    decl: &ast::fn_decl,\n                    id: Option<ast::ident>,\n+                   opt_bounds: &Option<OptVec<ast::TyParamBound>>,\n                    generics: Option<&ast::Generics>,\n                    opt_explicit_self: Option<ast::explicit_self_>) {\n     ibox(s, indent_unit);\n@@ -1930,6 +1934,7 @@ pub fn print_ty_fn(s: @ps,\n     print_onceness(s, onceness);\n     word(s.s, \"fn\");\n     match id { Some(id) => { word(s.s, \" \"); print_ident(s, id); } _ => () }\n+    do opt_bounds.map |bounds| { print_bounds(s, bounds, true); };\n     match generics { Some(g) => print_generics(s, g), _ => () }\n     zerobreak(s.s);\n "}, {"sha": "f0a993dbb94233e5693db631ec9f8b5129d4a69b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -246,15 +246,19 @@ pub fn visit_ty<E: Copy>(t: @Ty, (e, v): (E, vt<E>)) {\n         ty_closure(ref f) => {\n             for f.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n             (v.visit_ty)(f.decl.output, (copy e, v));\n-            visit_ty_param_bounds(&f.bounds, (e, v));\n+            do f.bounds.map |bounds| {\n+                visit_ty_param_bounds(bounds, (copy e, v));\n+            };\n         },\n         ty_bare_fn(ref f) => {\n             for f.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n             (v.visit_ty)(f.decl.output, (e, v));\n         },\n         ty_path(p, bounds, _) => {\n             visit_path(p, (copy e, v));\n-            visit_ty_param_bounds(bounds, (e, v));\n+            do bounds.map |bounds| {\n+                visit_ty_param_bounds(bounds, (copy e, v));\n+            };\n         },\n         ty_fixed_length_vec(ref mt, ex) => {\n             (v.visit_ty)(mt.ty, (copy e, v));"}, {"sha": "098a395f017445133027e607346ca1680b52e10c", "filename": "src/test/compile-fail/closure-bounds-cant-promote-superkind-in-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -12,7 +12,7 @@ struct X {\n     field: @fn:Copy(),\n }\n \n-fn foo(blk: @fn()) -> X {\n+fn foo(blk: @fn:()) -> X {\n     return X { field: blk }; //~ ERROR expected bounds `Copy` but found no bounds\n }\n "}, {"sha": "887346e35e5eae27e9352f51d3b933433106111a", "filename": "src/test/compile-fail/closure-bounds-subtype.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -1,5 +1,5 @@\n \n-fn take_any(_: &fn()) {\n+fn take_any(_: &fn:()) {\n }\n \n fn take_copyable(_: &fn:Copy()) {\n@@ -11,7 +11,7 @@ fn take_copyable_owned(_: &fn:Copy+Owned()) {\n fn take_const_owned(_: &fn:Const+Owned()) {\n }\n \n-fn give_any(f: &fn()) {\n+fn give_any(f: &fn:()) {\n     take_any(f);\n     take_copyable(f); //~ ERROR expected bounds `Copy` but found no bounds\n     take_copyable_owned(f); //~ ERROR expected bounds `Copy+Owned` but found no bounds"}, {"sha": "38983a9aca6a0c38ed4635f6fb27edd652bef50f", "filename": "src/test/compile-fail/kindck-nonsendable-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -12,7 +12,7 @@ fn foo(_x: @uint) {}\n \n fn main() {\n     let x = @3u;\n-    let _: ~fn() = || foo(x); //~ ERROR value has non-owned type `@uint`\n-    let _: ~fn() = || foo(x); //~ ERROR value has non-owned type `@uint`\n-    let _: ~fn() = || foo(x); //~ ERROR value has non-owned type `@uint`\n+    let _: ~fn() = || foo(x); //~ ERROR does not fulfill `Owned`\n+    let _: ~fn() = || foo(x); //~ ERROR does not fulfill `Owned`\n+    let _: ~fn() = || foo(x); //~ ERROR does not fulfill `Owned`\n }"}, {"sha": "c2352e35a46e92add4e236393c5ab616a5fd2e1e", "filename": "src/test/compile-fail/kindck-owned-trait.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -11,7 +11,9 @@\n trait foo { fn foo(&self); }\n \n fn to_foo<T:Copy + foo>(t: T) -> @foo {\n-    @t as @foo //~ ERROR value may contain borrowed pointers; add `'static` bound\n+    @t as @foo\n+    //~^ ERROR value may contain borrowed pointers; add `'static` bound\n+    //~^^ ERROR cannot pack type\n }\n \n fn to_foo2<T:Copy + foo + 'static>(t: T) -> @foo {"}, {"sha": "3f859b7dc84e65609f32a78ee4c63ef8f7e280ea", "filename": "src/test/compile-fail/kindck-owned.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n fn copy1<T:Copy>(t: T) -> @fn() -> T {\n-    let result: @fn() -> T = || copy t;\n-    //~^ ERROR value may contain borrowed pointers\n+    let result: @fn() -> T = || copy t; //~ ERROR does not fulfill `'static`\n     result\n }\n "}, {"sha": "605e59d56c893151c8dbf54285d7e605f5820138", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -32,7 +32,7 @@ fn main() {\n     let x = Cell::new(foo(Port(@())));\n \n     do task::spawn {\n-        let y = x.take();   //~ ERROR value has non-owned type\n+        let y = x.take();   //~ ERROR does not fulfill `Owned`\n         error!(y);\n     }\n }"}, {"sha": "adaea1de9bd0f87d13636e89ba6a816481c6794a", "filename": "src/test/compile-fail/trait-bounds-cant-coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -21,7 +21,7 @@ fn c(x: ~Foo:Const+Owned) {\n     b(x); //~ ERROR expected bounds `Copy+Owned`\n }\n \n-fn d(x: ~Foo) {\n+fn d(x: ~Foo:) {\n     a(x); //~ ERROR found no bounds\n }\n "}, {"sha": "8c641f4c850d7c33ff49a66fbdd2c4770412db1e", "filename": "src/test/compile-fail/trait-bounds-sugar.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests for \"default\" bounds inferred for traits with no bounds list.\n+\n+trait Foo {\n+}\n+\n+fn a(_x: ~Foo) { // should be same as ~Foo:Owned\n+}\n+\n+fn b(_x: @Foo) { // should be same as ~Foo:'static\n+}\n+\n+fn c(_x: &'static Foo) { // should be same as &'static Foo:'static\n+}\n+\n+fn d(x: ~Foo:Const) {\n+    a(x); //~ ERROR expected bounds `Owned`\n+}\n+\n+fn e(x: @Foo:Const) {\n+    b(x); //~ ERROR expected bounds `'static`\n+}\n+\n+fn f(x: &'static Foo:Const) {\n+    c(x); //~ ERROR expected bounds `'static`\n+}\n+\n+fn main() { }"}, {"sha": "8c2ae22e8edfcc343e5ac87dc21cd67cf962384e", "filename": "src/test/run-pass/closure-bounds-copyable-squiggle-closure.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Frun-pass%2Fclosure-bounds-copyable-squiggle-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Frun-pass%2Fclosure-bounds-copyable-squiggle-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-copyable-squiggle-closure.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-pretty\n-\n // Tests correct copying of heap closures' environments.\n \n-fn foo(x: ~fn:Copy()) -> (~fn(), ~fn()) {\n+fn foo(x: ~fn:Copy()) -> (~fn:(), ~fn:()) {\n     (copy x, x)\n }\n fn main() {"}, {"sha": "88d474a51e1da03904f64c1ce695d1c6d7f480c6", "filename": "src/test/run-pass/closure-bounds-squiggle-closure-as-copyable-typaram.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Frun-pass%2Fclosure-bounds-squiggle-closure-as-copyable-typaram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Frun-pass%2Fclosure-bounds-squiggle-closure-as-copyable-typaram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-squiggle-closure-as-copyable-typaram.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-pretty\n-\n // Tests correct copying of heap closures' environments.\n \n fn bar<T: Copy>(x: T) -> (T, T) {\n     (copy x, x)\n }\n-fn foo(x: ~fn:Copy()) -> (~fn(), ~fn()) {\n+fn foo(x: ~fn:Copy()) -> (~fn:(), ~fn:()) {\n     bar(x)\n }\n fn main() {"}, {"sha": "e733400527b286353ce159c1d4311fad082846b6", "filename": "src/test/run-pass/kindck-owned-trait-contains-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -14,9 +14,9 @@ impl<A:Copy> repeat<A> for @A {\n     fn get(&self) -> A { copy **self }\n }\n \n-fn repeater<A:Copy>(v: @A) -> @repeat<A> {\n+fn repeater<A:Copy>(v: @A) -> @repeat:<A> {\n     // Note: owned kind is not necessary as A appears in the trait type\n-    @v as @repeat<A> // No\n+    @v as @repeat:<A> // No\n }\n \n pub fn main() {"}, {"sha": "049d5305ca427f68b0cad94024e3c0e4bdb26606", "filename": "src/test/run-pass/regions-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Frun-pass%2Fregions-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Frun-pass%2Fregions-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-trait.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -22,13 +22,13 @@ impl<'self> get_ctxt<'self> for HasCtxt<'self> {\n     }\n }\n \n-fn get_v(gc: @get_ctxt) -> uint {\n+fn get_v(gc: @get_ctxt:) -> uint {\n     gc.get_ctxt().v\n }\n \n pub fn main() {\n     let ctxt = Ctxt { v: 22 };\n     let hc = HasCtxt { c: &ctxt };\n \n-    assert_eq!(get_v(@hc as @get_ctxt), 22);\n+    assert_eq!(get_v(@hc as @get_ctxt:), 22);\n }"}, {"sha": "5bfbf84d8acacb585b5aa7d5151ddb6ab8be8fc5", "filename": "src/test/run-pass/trait-bounds-basic.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -11,7 +11,7 @@\n trait Foo {\n }\n \n-fn a(_x: ~Foo) {\n+fn a(_x: ~Foo:) {\n }\n \n fn b(_x: ~Foo:Owned) {\n@@ -25,4 +25,8 @@ fn d(x: ~Foo:Owned+Copy) {\n     b(x);\n }\n \n+fn e(x: ~Foo) { // sugar for ~Foo:Owned\n+    b(x);\n+}\n+\n fn main() { }"}, {"sha": "585c2185a7eca000d789a9131aed26d3018b8637", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d7f601d8d419ace8fdf14b2014a9cbf6245896/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=36d7f601d8d419ace8fdf14b2014a9cbf6245896", "patch": "@@ -0,0 +1,103 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that a heterogeneous list of existential types can be put inside an ARC\n+// and shared between tasks as long as all types fulfill Const+Owned.\n+\n+// xfail-fast\n+\n+extern mod extra;\n+use extra::arc;\n+use std::comm;\n+use std::task;\n+use std::cell;\n+\n+trait Pet {\n+    fn name(&self, blk: &fn(&str));\n+    fn num_legs(&self) -> uint;\n+    fn of_good_pedigree(&self) -> bool;\n+}\n+\n+struct Catte {\n+    num_whiskers: uint,\n+    name: ~str,\n+}\n+\n+struct Dogge {\n+    bark_decibels: uint,\n+    tricks_known: uint,\n+    name: ~str,\n+}\n+\n+struct Goldfyshe {\n+    swim_speed: uint,\n+    name: ~str,\n+}\n+\n+impl Pet for Catte {\n+    fn name(&self, blk: &fn(&str)) { blk(self.name) }\n+    fn num_legs(&self) -> uint { 4 }\n+    fn of_good_pedigree(&self) -> bool { self.num_whiskers >= 4 }\n+}\n+impl Pet for Dogge {\n+    fn name(&self, blk: &fn(&str)) { blk(self.name) }\n+    fn num_legs(&self) -> uint { 4 }\n+    fn of_good_pedigree(&self) -> bool {\n+        self.bark_decibels < 70 || self.tricks_known > 20\n+    }\n+}\n+impl Pet for Goldfyshe {\n+    fn name(&self, blk: &fn(&str)) { blk(self.name) }\n+    fn num_legs(&self) -> uint { 0 }\n+    fn of_good_pedigree(&self) -> bool { self.swim_speed >= 500 }\n+}\n+\n+fn main() {\n+    let catte = Catte { num_whiskers: 7, name: ~\"alonzo_church\" };\n+    let dogge1 = Dogge { bark_decibels: 100, tricks_known: 42, name: ~\"alan_turing\" };\n+    let dogge2 = Dogge { bark_decibels: 55,  tricks_known: 11, name: ~\"albert_einstein\" };\n+    let fishe = Goldfyshe { swim_speed: 998, name: ~\"alec_guinness\" };\n+    let arc = arc::ARC(~[~catte  as ~Pet:Const+Owned,\n+                         ~dogge1 as ~Pet:Const+Owned,\n+                         ~fishe  as ~Pet:Const+Owned,\n+                         ~dogge2 as ~Pet:Const+Owned]);\n+    let (p1,c1) = comm::stream();\n+    let arc1 = cell::Cell::new(arc.clone());\n+    do task::spawn { check_legs(arc1.take()); c1.send(()); }\n+    let (p2,c2) = comm::stream();\n+    let arc2 = cell::Cell::new(arc.clone());\n+    do task::spawn { check_names(arc2.take()); c2.send(()); }\n+    let (p3,c3) = comm::stream();\n+    let arc3 = cell::Cell::new(arc.clone());\n+    do task::spawn { check_pedigree(arc3.take()); c3.send(()); }\n+    p1.recv();\n+    p2.recv();\n+    p3.recv();\n+}\n+\n+fn check_legs(arc: arc::ARC<~[~Pet:Const+Owned]>) {\n+    let mut legs = 0;\n+    for arc.get().iter().advance |pet| {\n+        legs += pet.num_legs();\n+    }\n+    assert!(legs == 12);\n+}\n+fn check_names(arc: arc::ARC<~[~Pet:Const+Owned]>) {\n+    for arc.get().iter().advance |pet| {\n+        do pet.name |name| {\n+            assert!(name[0] == 'a' as u8 && name[1] == 'l' as u8);\n+        }\n+    }\n+}\n+fn check_pedigree(arc: arc::ARC<~[~Pet:Const+Owned]>) {\n+    for arc.get().iter().advance |pet| {\n+        assert!(pet.of_good_pedigree());\n+    }\n+}"}]}