{"sha": "ff85389344d6fe4a318559b66b97c24b8fddf1e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmODUzODkzNDRkNmZlNGEzMTg1NTliNjZiOTdjMjRiOGZkZGYxZTQ=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-09-18T06:48:56Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-09-19T22:19:20Z"}, "message": "Modernize extra::future API", "tree": {"sha": "da488f7fe5328471c99eb51e128d6997cf053bc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da488f7fe5328471c99eb51e128d6997cf053bc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff85389344d6fe4a318559b66b97c24b8fddf1e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff85389344d6fe4a318559b66b97c24b8fddf1e4", "html_url": "https://github.com/rust-lang/rust/commit/ff85389344d6fe4a318559b66b97c24b8fddf1e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff85389344d6fe4a318559b66b97c24b8fddf1e4/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2df5a13334449c26204333e8b2cdce2dd0cf90eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2df5a13334449c26204333e8b2cdce2dd0cf90eb", "html_url": "https://github.com/rust-lang/rust/commit/2df5a13334449c26204333e8b2cdce2dd0cf90eb"}], "stats": {"total": 158, "additions": 75, "deletions": 83}, "files": [{"sha": "e1f70a19e52e5ad5f7b3480e3f56b000a7e046ac", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff85389344d6fe4a318559b66b97c24b8fddf1e4/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff85389344d6fe4a318559b66b97c24b8fddf1e4/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=ff85389344d6fe4a318559b66b97c24b8fddf1e4", "patch": "@@ -280,7 +280,7 @@ fn fib(n: uint) -> uint {\n     12586269025\n }\n \n-let mut delayed_fib = extra::future::spawn (|| fib(50) );\n+let mut delayed_fib = extra::future::Future::spawn (|| fib(50) );\n make_a_sandwich();\n println(fmt!(\"fib(50) = %?\", delayed_fib.get()))\n ~~~\n@@ -304,7 +304,7 @@ fn partial_sum(start: uint) -> f64 {\n }\n \n fn main() {\n-    let mut futures = vec::from_fn(1000, |ind| do extra::future::spawn { partial_sum(ind) });\n+    let mut futures = vec::from_fn(1000, |ind| do extra::future::Future::spawn { partial_sum(ind) });\n \n     let mut final_res = 0f64;\n     for ft in futures.mut_iter()  {"}, {"sha": "2d68cca4adcd64679ba6ba6e6606011f9a0fefbd", "filename": "src/libextra/future.rs", "status": "modified", "additions": 62, "deletions": 70, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/ff85389344d6fe4a318559b66b97c24b8fddf1e4/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff85389344d6fe4a318559b66b97c24b8fddf1e4/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=ff85389344d6fe4a318559b66b97c24b8fddf1e4", "patch": "@@ -32,7 +32,7 @@ use std::comm::{PortOne, oneshot};\n use std::task;\n use std::util::replace;\n \n-#[doc = \"The future type\"]\n+/// A type encapsulating the result of a computation which may not be complete\n pub struct Future<A> {\n     priv state: FutureState<A>,\n }\n@@ -62,156 +62,148 @@ impl<A> Future<A> {\n             _ => fail!( \"Logic error.\" ),\n         }\n     }\n-}\n \n-impl<A> Future<A> {\n     pub fn get_ref<'a>(&'a mut self) -> &'a A {\n         /*!\n         * Executes the future's closure and then returns a borrowed\n         * pointer to the result.  The borrowed pointer lasts as long as\n         * the future.\n         */\n-        unsafe {\n-            {\n-                match self.state {\n-                    Forced(ref mut v) => { return cast::transmute(v); }\n-                    Evaluating => fail!(\"Recursive forcing of future!\"),\n-                    Pending(_) => {}\n-                }\n-            }\n-            {\n-                let state = replace(&mut self.state, Evaluating);\n-                match state {\n+        match self.state {\n+            Forced(ref v) => return v,\n+            Evaluating => fail!(\"Recursive forcing of future!\"),\n+            Pending(_) => {\n+                match replace(&mut self.state, Evaluating) {\n                     Forced(_) | Evaluating => fail!(\"Logic error.\"),\n                     Pending(f) => {\n                         self.state = Forced(f());\n-                        cast::transmute(self.get_ref())\n+                        self.get_ref()\n                     }\n                 }\n             }\n         }\n     }\n-}\n \n-pub fn from_value<A>(val: A) -> Future<A> {\n-    /*!\n-     * Create a future from a value.\n-     *\n-     * The value is immediately available and calling `get` later will\n-     * not block.\n-     */\n-\n-    Future {state: Forced(val)}\n-}\n+    pub fn from_value(val: A) -> Future<A> {\n+        /*!\n+         * Create a future from a value.\n+         *\n+         * The value is immediately available and calling `get` later will\n+         * not block.\n+         */\n \n-pub fn from_port<A:Send>(port: PortOne<A>) -> Future<A> {\n-    /*!\n-     * Create a future from a port\n-     *\n-     * The first time that the value is requested the task will block\n-     * waiting for the result to be received on the port.\n-     */\n+        Future {state: Forced(val)}\n+    }\n \n-    let port = Cell::new(port);\n-    do from_fn {\n-        port.take().recv()\n+    pub fn from_fn(f: ~fn() -> A) -> Future<A> {\n+        /*!\n+         * Create a future from a function.\n+         *\n+         * The first time that the value is requested it will be retrieved by\n+         * calling the function.  Note that this function is a local\n+         * function. It is not spawned into another task.\n+         */\n+\n+        Future {state: Pending(f)}\n     }\n }\n \n-pub fn from_fn<A>(f: ~fn() -> A) -> Future<A> {\n-    /*!\n-     * Create a future from a function.\n-     *\n-     * The first time that the value is requested it will be retrieved by\n-     * calling the function.  Note that this function is a local\n-     * function. It is not spawned into another task.\n-     */\n+impl<A:Send> Future<A> {\n+    pub fn from_port(port: PortOne<A>) -> Future<A> {\n+        /*!\n+         * Create a future from a port\n+         *\n+         * The first time that the value is requested the task will block\n+         * waiting for the result to be received on the port.\n+         */\n+\n+        let port = Cell::new(port);\n+        do Future::from_fn {\n+            port.take().recv()\n+        }\n+    }\n \n-    Future {state: Pending(f)}\n-}\n+    pub fn spawn(blk: ~fn() -> A) -> Future<A> {\n+        /*!\n+         * Create a future from a unique closure.\n+         *\n+         * The closure will be run in a new task and its result used as the\n+         * value of the future.\n+         */\n \n-pub fn spawn<A:Send>(blk: ~fn() -> A) -> Future<A> {\n-    /*!\n-     * Create a future from a unique closure.\n-     *\n-     * The closure will be run in a new task and its result used as the\n-     * value of the future.\n-     */\n+        let (port, chan) = oneshot();\n \n-    let (port, chan) = oneshot();\n+        do task::spawn_with(chan) |chan| {\n+            chan.send(blk());\n+        }\n \n-    let chan = Cell::new(chan);\n-    do task::spawn {\n-        let chan = chan.take();\n-        chan.send(blk());\n+        Future::from_port(port)\n     }\n-\n-    return from_port(port);\n }\n \n #[cfg(test)]\n mod test {\n-    use future::*;\n+    use future::Future;\n \n     use std::cell::Cell;\n     use std::comm::oneshot;\n     use std::task;\n \n     #[test]\n     fn test_from_value() {\n-        let mut f = from_value(~\"snail\");\n+        let mut f = Future::from_value(~\"snail\");\n         assert_eq!(f.get(), ~\"snail\");\n     }\n \n     #[test]\n     fn test_from_port() {\n         let (po, ch) = oneshot();\n         ch.send(~\"whale\");\n-        let mut f = from_port(po);\n+        let mut f = Future::from_port(po);\n         assert_eq!(f.get(), ~\"whale\");\n     }\n \n     #[test]\n     fn test_from_fn() {\n-        let mut f = from_fn(|| ~\"brail\");\n+        let mut f = Future::from_fn(|| ~\"brail\");\n         assert_eq!(f.get(), ~\"brail\");\n     }\n \n     #[test]\n     fn test_interface_get() {\n-        let mut f = from_value(~\"fail\");\n+        let mut f = Future::from_value(~\"fail\");\n         assert_eq!(f.get(), ~\"fail\");\n     }\n \n     #[test]\n     fn test_interface_unwrap() {\n-        let f = from_value(~\"fail\");\n+        let f = Future::from_value(~\"fail\");\n         assert_eq!(f.unwrap(), ~\"fail\");\n     }\n \n     #[test]\n     fn test_get_ref_method() {\n-        let mut f = from_value(22);\n+        let mut f = Future::from_value(22);\n         assert_eq!(*f.get_ref(), 22);\n     }\n \n     #[test]\n     fn test_spawn() {\n-        let mut f = spawn(|| ~\"bale\");\n+        let mut f = Future::spawn(|| ~\"bale\");\n         assert_eq!(f.get(), ~\"bale\");\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_futurefail() {\n-        let mut f = spawn(|| fail!());\n+        let mut f = Future::spawn(|| fail!());\n         let _x: ~str = f.get();\n     }\n \n     #[test]\n     fn test_sendable_future() {\n         let expected = \"schlorf\";\n-        let f = Cell::new(do spawn { expected });\n+        let f = Cell::new(do Future::spawn { expected });\n         do task::spawn {\n             let mut f = f.take();\n             let actual = f.get();"}, {"sha": "b5514315226966b71614fd53b078474595e8e9aa", "filename": "src/libextra/par.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff85389344d6fe4a318559b66b97c24b8fddf1e4/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff85389344d6fe4a318559b66b97c24b8fddf1e4/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=ff85389344d6fe4a318559b66b97c24b8fddf1e4", "patch": "@@ -14,7 +14,7 @@ use std::num;\n use std::ptr;\n use std::sys;\n use std::vec;\n-use future_spawn = future::spawn;\n+use future::Future;\n \n /**\n  * The maximum number of tasks this module will spawn for a single\n@@ -55,7 +55,7 @@ fn map_slices<A:Clone + Send,B:Clone + Send>(\n             do xs.as_imm_buf |p, _len| {\n                 let f = f();\n                 let base = base;\n-                let f = do future_spawn() || {\n+                let f = do Future::spawn() || {\n                     unsafe {\n                         let len = end - base;\n                         let slice = (ptr::offset(p, base as int),"}, {"sha": "fb58e5c2bf02dfa76396fee61f31659a80e4e178", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff85389344d6fe4a318559b66b97c24b8fddf1e4/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff85389344d6fe4a318559b66b97c24b8fddf1e4/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=ff85389344d6fe4a318559b66b97c24b8fddf1e4", "patch": "@@ -20,7 +20,7 @@ use std::result;\n use std::run;\n use std::str;\n use std::task;\n-use extra::future;\n+use extra::future::Future;\n \n #[deriving(Clone)]\n pub enum WriteInstr {\n@@ -207,10 +207,10 @@ pub fn future_writer_factory(\n     (writer_factory, markdown_po)\n }\n \n-fn future_writer() -> (Writer, future::Future<~str>) {\n+fn future_writer() -> (Writer, Future<~str>) {\n     let (port, chan) = comm::stream();\n     let writer: ~fn(instr: WriteInstr) = |instr| chan.send(instr.clone());\n-    let future = do future::from_fn || {\n+    let future = do Future::from_fn || {\n         let mut res = ~\"\";\n         loop {\n             match port.recv() {"}, {"sha": "b52ba154f435a97e831901337ebc7de56e1340f6", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff85389344d6fe4a318559b66b97c24b8fddf1e4/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff85389344d6fe4a318559b66b97c24b8fddf1e4/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=ff85389344d6fe4a318559b66b97c24b8fddf1e4", "patch": "@@ -18,7 +18,7 @@\n extern mod extra;\n \n use extra::arc;\n-use extra::future;\n+use extra::future::Future;\n use extra::time;\n use std::cell::Cell;\n use std::os;\n@@ -94,7 +94,7 @@ fn main() {\n         let (new_chan, num_port) = init();\n         let num_chan2 = Cell::new(num_chan.take());\n         let num_port = Cell::new(num_port);\n-        let new_future = do future::spawn() {\n+        let new_future = do Future::spawn() {\n             let num_chan = num_chan2.take();\n             let num_port1 = num_port.take();\n             thread_ring(i, msg_per_task, num_chan, num_port1)"}, {"sha": "e3d0b4912f9748c20ea87f71f052a309d89d827a", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff85389344d6fe4a318559b66b97c24b8fddf1e4/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff85389344d6fe4a318559b66b97c24b8fddf1e4/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=ff85389344d6fe4a318559b66b97c24b8fddf1e4", "patch": "@@ -18,7 +18,7 @@\n extern mod extra;\n \n use extra::arc;\n-use extra::future;\n+use extra::future::Future;\n use extra::time;\n use std::cell::Cell;\n use std::os;\n@@ -90,7 +90,7 @@ fn main() {\n         let (new_chan, num_port) = init();\n         let num_chan2 = Cell::new(num_chan.take());\n         let num_port = Cell::new(num_port);\n-        let new_future = do future::spawn {\n+        let new_future = do Future::spawn {\n             let num_chan = num_chan2.take();\n             let num_port1 = num_port.take();\n             thread_ring(i, msg_per_task, num_chan, num_port1)"}, {"sha": "aef5d0f9b04a6412b75223f6a7880b33120a708a", "filename": "src/test/compile-fail/future_not_copyable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff85389344d6fe4a318559b66b97c24b8fddf1e4/src%2Ftest%2Fcompile-fail%2Ffuture_not_copyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff85389344d6fe4a318559b66b97c24b8fddf1e4/src%2Ftest%2Fcompile-fail%2Ffuture_not_copyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffuture_not_copyable.rs?ref=ff85389344d6fe4a318559b66b97c24b8fddf1e4", "patch": "@@ -10,10 +10,10 @@\n \n extern mod extra;\n \n-use extra::future;\n+use extra::future::Future;\n \n fn main() {\n-    let f = future::from_value(());\n+    let f = Future::from_value(());\n     let g = f;\n     f.unwrap(); //~ ERROR use of moved value\n }"}]}