{"sha": "3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d", "node_id": "C_kwDOAAsO6NoAKDNmZTM3YjhjNmUwMmRhYTZhN2MzM2E3MWJiN2Y0NDY4MmU0M2QwOGQ", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2021-03-28T12:24:49Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2022-11-20T16:19:11Z"}, "message": "Add get_many_mut methods to slice", "tree": {"sha": "46e8c1782c521106e89163844385ccda48ba8119", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46e8c1782c521106e89163844385ccda48ba8119"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d", "html_url": "https://github.com/rust-lang/rust/commit/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cdfe03b0601d5328406746a7923a8a4eaa0cf3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cdfe03b0601d5328406746a7923a8a4eaa0cf3c", "html_url": "https://github.com/rust-lang/rust/commit/9cdfe03b0601d5328406746a7923a8a4eaa0cf3c"}], "stats": {"total": 201, "additions": 201, "deletions": 0}, "files": [{"sha": "7152300abcbf3a446cca031d797040d23abb2353", "filename": "library/core/src/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d/library%2Fcore%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d/library%2Fcore%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ferror.rs?ref=3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d", "patch": "@@ -506,3 +506,6 @@ impl Error for crate::ffi::FromBytesWithNulError {\n \n #[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n impl Error for crate::ffi::FromBytesUntilNulError {}\n+\n+#[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+impl<const N: usize> Error for crate::slice::GetManyMutError<N> {}"}, {"sha": "04486ed2d14e31a3c9c977ec9978e692b98b2a52", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d", "patch": "@@ -7,6 +7,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cmp::Ordering::{self, Greater, Less};\n+use crate::fmt;\n use crate::intrinsics::{assert_unsafe_precondition, exact_div};\n use crate::marker::Copy;\n use crate::mem::{self, SizedTypeProperties};\n@@ -4082,6 +4083,88 @@ impl<T> [T] {\n         *self = rem;\n         Some(last)\n     }\n+\n+    /// Returns mutable references to many indices at once, without doing any checks.\n+    ///\n+    /// For a safe alternative see [`get_many_mut`].\n+    ///\n+    /// # Safety\n+    ///\n+    /// Calling this method with overlapping or out-of-bounds indices is *[undefined behavior]*\n+    /// even if the resulting references are not used.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_many_mut)]\n+    ///\n+    /// let x = &mut [1, 2, 4];\n+    ///\n+    /// unsafe {\n+    ///     let [a, b] = x.get_many_unchecked_mut([0, 2]);\n+    ///     *a *= 10;\n+    ///     *b *= 100;\n+    /// }\n+    /// assert_eq!(x, &[10, 2, 400]);\n+    /// ```\n+    ///\n+    /// [`get_many_mut`]: slice::get_many_mut\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    #[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+    #[inline]\n+    pub unsafe fn get_many_unchecked_mut<const N: usize>(\n+        &mut self,\n+        indices: [usize; N],\n+    ) -> [&mut T; N] {\n+        // NB: This implementation is written as it is because any variation of\n+        // `indices.map(|i| self.get_unchecked_mut(i))` would make miri unhappy,\n+        // or generate worse code otherwise. This is also why we need to go\n+        // through a raw pointer here.\n+        let slice: *mut [T] = self;\n+        let mut arr: mem::MaybeUninit<[&mut T; N]> = mem::MaybeUninit::uninit();\n+        let arr_ptr = arr.as_mut_ptr();\n+\n+        // SAFETY: We expect `indices` to contain disjunct values that are\n+        // in bounds of `self`.\n+        unsafe {\n+            for i in 0..N {\n+                let idx = *indices.get_unchecked(i);\n+                *(*arr_ptr).get_unchecked_mut(i) = &mut *slice.get_unchecked_mut(idx);\n+            }\n+            arr.assume_init()\n+        }\n+    }\n+\n+    /// Returns mutable references to many indices at once.\n+    ///\n+    /// Returns an error if any index is out-of-bounds, or if the same index was\n+    /// passed more than once.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_many_mut)]\n+    ///\n+    /// let v = &mut [1, 2, 3];\n+    /// if let Ok([a, b]) = v.get_many_mut([0, 2]) {\n+    ///     *a = 413;\n+    ///     *b = 612;\n+    /// }\n+    /// assert_eq!(v, &[413, 2, 612]);\n+    /// ```\n+    #[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+    #[inline]\n+    pub fn get_many_mut<const N: usize>(\n+        &mut self,\n+        indices: [usize; N],\n+    ) -> Result<[&mut T; N], GetManyMutError<N>> {\n+        if !get_many_check_valid(&indices, self.len()) {\n+            return Err(GetManyMutError { _private: () });\n+        }\n+        // SAFETY: The `get_many_check_valid()` call checked that all indices\n+        // are disjunct and in bounds.\n+        unsafe { Ok(self.get_many_unchecked_mut(indices)) }\n+    }\n }\n \n impl<T, const N: usize> [[T; N]] {\n@@ -4304,3 +4387,56 @@ impl<T, const N: usize> SlicePattern for [T; N] {\n         self\n     }\n }\n+\n+/// This checks every index against each other, and against `len`.\n+///\n+/// This will do `binomial(N + 1, 2) = N * (N + 1) / 2 = 0, 1, 3, 6, 10, ..`\n+/// comparison operations.\n+fn get_many_check_valid<const N: usize>(indices: &[usize; N], len: usize) -> bool {\n+    // NB: The optimzer should inline the loops into a sequence\n+    // of instructions without additional branching.\n+    let mut valid = true;\n+    for (i, &idx) in indices.iter().enumerate() {\n+        valid &= idx < len;\n+        for &idx2 in &indices[..i] {\n+            valid &= idx != idx2;\n+        }\n+    }\n+    valid\n+}\n+\n+/// The error type returned by [`get_many_mut<N>`][`slice::get_many_mut`].\n+///\n+/// It indicates one of two possible errors:\n+/// - An index is out-of-bounds.\n+/// - The same index appeared multiple times in the array.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(get_many_mut)]\n+///\n+/// let v = &mut [1, 2, 3];\n+/// assert!(v.get_many_mut([0, 999]).is_err());\n+/// assert!(v.get_many_mut([1, 1]).is_err());\n+/// ```\n+#[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+// NB: The N here is there to be forward-compatible with adding more details\n+// to the error type at a later point\n+pub struct GetManyMutError<const N: usize> {\n+    _private: (),\n+}\n+\n+#[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+impl<const N: usize> fmt::Debug for GetManyMutError<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"GetManyMutError\").finish_non_exhaustive()\n+    }\n+}\n+\n+#[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+impl<const N: usize> fmt::Display for GetManyMutError<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(\"an index is out of bounds or appeared multiple times in the array\", f)\n+    }\n+}"}, {"sha": "abbad96c4da7569be9ee1fe9ddfe4759224d3e5c", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d", "patch": "@@ -108,6 +108,7 @@\n #![feature(provide_any)]\n #![feature(utf8_chunks)]\n #![feature(is_ascii_octdigit)]\n+#![feature(get_many_mut)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n extern crate test;"}, {"sha": "4e06e0f43988687dc514a36cfe157ffc8b5b5957", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d", "patch": "@@ -2595,3 +2595,63 @@ fn test_flatten_mut_size_overflow() {\n     let x = &mut [[(); usize::MAX]; 2][..];\n     let _ = x.flatten_mut();\n }\n+\n+#[test]\n+fn test_get_many_mut_normal_2() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let [a, b] = v.get_many_mut([3, 0]).unwrap();\n+    *a += 10;\n+    *b += 100;\n+    assert_eq!(v, vec![101, 2, 3, 14, 5]);\n+}\n+\n+#[test]\n+fn test_get_many_mut_normal_3() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let [a, b, c] = v.get_many_mut([0, 4, 2]).unwrap();\n+    *a += 10;\n+    *b += 100;\n+    *c += 1000;\n+    assert_eq!(v, vec![11, 2, 1003, 4, 105]);\n+}\n+\n+#[test]\n+fn test_get_many_mut_empty() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let [] = v.get_many_mut([]).unwrap();\n+    assert_eq!(v, vec![1, 2, 3, 4, 5]);\n+}\n+\n+#[test]\n+fn test_get_many_mut_single_first() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let [a] = v.get_many_mut([0]).unwrap();\n+    *a += 10;\n+    assert_eq!(v, vec![11, 2, 3, 4, 5]);\n+}\n+\n+#[test]\n+fn test_get_many_mut_single_last() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let [a] = v.get_many_mut([4]).unwrap();\n+    *a += 10;\n+    assert_eq!(v, vec![1, 2, 3, 4, 15]);\n+}\n+\n+#[test]\n+fn test_get_many_mut_oob_nonempty() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    assert!(v.get_many_mut([5]).is_err());\n+}\n+\n+#[test]\n+fn test_get_many_mut_oob_empty() {\n+    let mut v: Vec<i32> = vec![];\n+    assert!(v.get_many_mut([0]).is_err());\n+}\n+\n+#[test]\n+fn test_get_many_mut_duplicate() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    assert!(v.get_many_mut([1, 3, 3, 4]).is_err());\n+}"}, {"sha": "63ee6c521d793babfc515a583f9c22086b79eab9", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d", "patch": "@@ -347,6 +347,7 @@\n #![feature(stdsimd)]\n #![feature(test)]\n #![feature(trace_macros)]\n+#![feature(get_many_mut)]\n //\n // Only used in tests/benchmarks:\n //"}]}