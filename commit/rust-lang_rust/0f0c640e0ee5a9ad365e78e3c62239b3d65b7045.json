{"sha": "0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMGM2NDBlMGVlNWE5YWQzNjVlNzhlM2M2MjIzOWIzZDY1YjcwNDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-17T18:38:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-17T18:38:15Z"}, "message": "Auto merge of #66385 - ecstatic-morse:check-only-pass2, r=eddyb\n\nMake dataflow-based const qualification the canonical one\n\nFor over a month, dataflow-based const qualification has been running in parallel with `qualify_consts` to check the bodies of `const` and `static`s. This PR removes the old qualification pass completely in favor of the dataflow-based one.\n\n**edit:**\nThis PR also stops checking `QUALIF_ERROR_BIT` during promotion. This check appears to no longer serve a purpose now that the CTFE engine is more robust.\n\nAs a side-effect, this resolves #66167.\n\nr? @eddyb", "tree": {"sha": "74d5c011c9814ab923ef232e48a85993559755e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74d5c011c9814ab923ef232e48a85993559755e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "html_url": "https://github.com/rust-lang/rust/commit/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8014582b843d8722795b06586ef9c2042094963", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8014582b843d8722795b06586ef9c2042094963", "html_url": "https://github.com/rust-lang/rust/commit/d8014582b843d8722795b06586ef9c2042094963"}, {"sha": "a1135cc9463437ed806876b2406379c25321e7d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1135cc9463437ed806876b2406379c25321e7d3", "html_url": "https://github.com/rust-lang/rust/commit/a1135cc9463437ed806876b2406379c25321e7d3"}], "stats": {"total": 1946, "additions": 296, "deletions": 1650}, "files": [{"sha": "5997e4367bf29397cf439b05e4758f3e23d3cd05", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -2763,6 +2763,17 @@ pub struct BorrowCheckResult<'tcx> {\n     pub used_mut_upvars: SmallVec<[Field; 8]>,\n }\n \n+/// The result of the `mir_const_qualif` query.\n+///\n+/// Each field corresponds to an implementer of the `Qualif` trait in\n+/// `librustc_mir/transform/check_consts/qualifs.rs`. See that file for more information on each\n+/// `Qualif`.\n+#[derive(Clone, Copy, Debug, Default, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct ConstQualifs {\n+    pub has_mut_interior: bool,\n+    pub needs_drop: bool,\n+}\n+\n /// After we borrow check a closure, we are left with various\n /// requirements that we have inferred between the free regions that\n /// appear in the closure's signature or on its field types. These"}, {"sha": "e07726bfa2aa12ca689a9c0afdddc170c894f341", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -91,9 +91,9 @@ rustc_queries! {\n         }\n \n         /// Maps DefId's that have an associated `mir::Body` to the result\n-        /// of the MIR qualify_consts pass. The actual meaning of\n-        /// the value isn't known except to the pass itself.\n-        query mir_const_qualif(key: DefId) -> u8 {\n+        /// of the MIR const-checking pass. This is the set of qualifs in\n+        /// the final value of a `const`.\n+        query mir_const_qualif(key: DefId) -> mir::ConstQualifs {\n             desc { |tcx| \"const checking `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n         }"}, {"sha": "4474b008c79492179a03f9aba2e36a05f095b6ea", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -1373,8 +1373,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"describes how to render the `rendered` field of json diagnostics\"),\n     unleash_the_miri_inside_of_you: bool = (false, parse_bool, [TRACKED],\n         \"take the breaks off const evaluation. NOTE: this is unsound\"),\n-    suppress_const_validation_back_compat_ice: bool = (false, parse_bool, [TRACKED],\n-        \"silence ICE triggered when the new const validator disagrees with the old\"),\n     osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],\n         \"pass `-install_name @rpath/...` to the macOS linker\"),\n     sanitizer: Option<Sanitizer> = (None, parse_sanitizer, [TRACKED],"}, {"sha": "fc0a0010240ad9b165d0598956dfb0c08e3956a8", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -952,12 +952,12 @@ impl<'a, 'tcx> CrateMetadata {\n             .decode((self, tcx))\n     }\n \n-    fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n+    fn mir_const_qualif(&self, id: DefIndex) -> mir::ConstQualifs {\n         match self.kind(id) {\n             EntryKind::Const(qualif, _) |\n             EntryKind::AssocConst(AssocContainer::ImplDefault, qualif, _) |\n             EntryKind::AssocConst(AssocContainer::ImplFinal, qualif, _) => {\n-                qualif.mir\n+                qualif\n             }\n             _ => bug!(),\n         }"}, {"sha": "483915f654dddd59810e95b9a127d8d78133e05e", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -875,7 +875,11 @@ impl EncodeContext<'tcx> {\n                     hir::print::to_string(self.tcx.hir(), |s| s.print_trait_item(ast_item));\n                 let rendered_const = self.lazy(RenderedConst(rendered));\n \n-                EntryKind::AssocConst(container, ConstQualif { mir: 0 }, rendered_const)\n+                EntryKind::AssocConst(\n+                    container,\n+                    Default::default(),\n+                    rendered_const,\n+                )\n             }\n             ty::AssocKind::Method => {\n                 let fn_data = if let hir::TraitItemKind::Method(m_sig, m) = &ast_item.kind {\n@@ -955,10 +959,11 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.kind[def_id] <- match impl_item.kind {\n             ty::AssocKind::Const => {\n                 if let hir::ImplItemKind::Const(_, body_id) = ast_item.kind {\n-                    let mir = self.tcx.at(ast_item.span).mir_const_qualif(def_id);\n+                    let qualifs = self.tcx.at(ast_item.span).mir_const_qualif(def_id);\n \n-                    EntryKind::AssocConst(container,\n-                        ConstQualif { mir },\n+                    EntryKind::AssocConst(\n+                        container,\n+                        qualifs,\n                         self.encode_rendered_const_for_body(body_id))\n                 } else {\n                     bug!()\n@@ -1089,9 +1094,9 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Static(_, hir::Mutability::Mutable, _) => EntryKind::MutStatic,\n             hir::ItemKind::Static(_, hir::Mutability::Immutable, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n-                let mir = self.tcx.at(item.span).mir_const_qualif(def_id);\n+                let qualifs = self.tcx.at(item.span).mir_const_qualif(def_id);\n                 EntryKind::Const(\n-                    ConstQualif { mir },\n+                    qualifs,\n                     self.encode_rendered_const_for_body(body_id)\n                 )\n             }\n@@ -1368,9 +1373,9 @@ impl EncodeContext<'tcx> {\n         let id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n         let body_id = self.tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n-        let mir = self.tcx.mir_const_qualif(def_id);\n+        let qualifs = self.tcx.mir_const_qualif(def_id);\n \n-        record!(self.per_def.kind[def_id] <- EntryKind::Const(ConstQualif { mir }, const_data));\n+        record!(self.per_def.kind[def_id] <- EntryKind::Const(qualifs, const_data));\n         record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n         record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n         self.encode_item_type(def_id);"}, {"sha": "850ee5afbc808479fb8685d2b1d42ae0e9826c43", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -260,7 +260,7 @@ crate struct LazyPerDefTables<'tcx> {\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n enum EntryKind<'tcx> {\n-    Const(ConstQualif, Lazy<RenderedConst>),\n+    Const(mir::ConstQualifs, Lazy<RenderedConst>),\n     ImmStatic,\n     MutStatic,\n     ForeignImmStatic,\n@@ -288,16 +288,10 @@ enum EntryKind<'tcx> {\n     Method(Lazy<MethodData>),\n     AssocType(AssocContainer),\n     AssocOpaqueTy(AssocContainer),\n-    AssocConst(AssocContainer, ConstQualif, Lazy<RenderedConst>),\n+    AssocConst(AssocContainer, mir::ConstQualifs, Lazy<RenderedConst>),\n     TraitAlias,\n }\n \n-/// Additional data for EntryKind::Const and EntryKind::AssocConst\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable)]\n-struct ConstQualif {\n-    mir: u8,\n-}\n-\n /// Contains a constant which has been rendered to a String.\n /// Used by rustdoc.\n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "6d19cd63bc32ea1ef24a9bd83d0b949d75f7ed22", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -32,7 +32,6 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate rustc;\n-#[macro_use] extern crate rustc_data_structures;\n #[macro_use] extern crate syntax;\n \n mod borrow_check;"}, {"sha": "4d00aaf7abc212df6c1c571a7ebf9b986a61253d", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -95,16 +95,6 @@ impl ConstKind {\n             ConstKind::ConstFn | ConstKind::Const => false,\n         }\n     }\n-\n-    /// Returns `true` if the value returned by this item must be `Sync`.\n-    ///\n-    /// This returns false for `StaticMut` since all accesses to one are `unsafe` anyway.\n-    pub fn requires_sync(self) -> bool {\n-        match self {\n-            ConstKind::Static => true,\n-            ConstKind::ConstFn | ConstKind::Const |  ConstKind::StaticMut => false,\n-        }\n-    }\n }\n \n impl fmt::Display for ConstKind {"}, {"sha": "80f2925193a8140a87785e1b8b0a273d6b0ab347", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -138,7 +138,15 @@ impl NonConstOp for HeapAllocation {\n \n #[derive(Debug)]\n pub struct IfOrMatch;\n-impl NonConstOp for IfOrMatch {}\n+impl NonConstOp for IfOrMatch {\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        // This should be caught by the HIR const-checker.\n+        item.tcx.sess.delay_span_bug(\n+            span,\n+            \"complex control flow is forbidden in a const context\",\n+        );\n+    }\n+}\n \n #[derive(Debug)]\n pub struct LiveDrop;\n@@ -154,7 +162,15 @@ impl NonConstOp for LiveDrop {\n \n #[derive(Debug)]\n pub struct Loop;\n-impl NonConstOp for Loop {}\n+impl NonConstOp for Loop {\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        // This should be caught by the HIR const-checker.\n+        item.tcx.sess.delay_span_bug(\n+            span,\n+            \"complex control flow is forbidden in a const context\",\n+        );\n+    }\n+}\n \n #[derive(Debug)]\n pub struct MutBorrow(pub BorrowKind);"}, {"sha": "aad14299c1d94105532ea4004cf4d0e920377a9a", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -6,12 +6,10 @@ use syntax_pos::DUMMY_SP;\n \n use super::{ConstKind, Item as ConstCx};\n \n-#[derive(Clone, Copy)]\n-pub struct QualifSet(u8);\n-\n-impl QualifSet {\n-    fn contains<Q: ?Sized + Qualif>(self) -> bool {\n-        self.0 & (1 << Q::IDX) != 0\n+pub fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> ConstQualifs {\n+    ConstQualifs {\n+        has_mut_interior: HasMutInterior::in_any_value_of_ty(cx, ty),\n+        needs_drop: NeedsDrop::in_any_value_of_ty(cx, ty),\n     }\n }\n \n@@ -22,14 +20,14 @@ impl QualifSet {\n ///\n /// The default implementations proceed structurally.\n pub trait Qualif {\n-    const IDX: usize;\n-\n     /// The name of the file used to debug the dataflow analysis that computes this qualif.\n     const ANALYSIS_NAME: &'static str;\n \n     /// Whether this `Qualif` is cleared when a local is moved from.\n     const IS_CLEARED_ON_MOVE: bool = false;\n \n+    fn in_qualifs(qualifs: &ConstQualifs) -> bool;\n+\n     /// Return the qualification that is (conservatively) correct for any value\n     /// of the type.\n     fn in_any_value_of_ty(_cx: &ConstCx<'_, 'tcx>, _ty: Ty<'tcx>) -> bool;\n@@ -122,9 +120,8 @@ pub trait Qualif {\n                     if cx.tcx.trait_of_item(def_id).is_some() {\n                         Self::in_any_value_of_ty(cx, constant.literal.ty)\n                     } else {\n-                        let bits = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n-\n-                        let qualif = QualifSet(bits).contains::<Self>();\n+                        let qualifs = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n+                        let qualif = Self::in_qualifs(&qualifs);\n \n                         // Just in case the type is more specific than\n                         // the definition, e.g., impl associated const\n@@ -210,9 +207,12 @@ pub trait Qualif {\n pub struct HasMutInterior;\n \n impl Qualif for HasMutInterior {\n-    const IDX: usize = 0;\n     const ANALYSIS_NAME: &'static str = \"flow_has_mut_interior\";\n \n+    fn in_qualifs(qualifs: &ConstQualifs) -> bool {\n+        qualifs.has_mut_interior\n+    }\n+\n     fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n         !ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP)\n     }\n@@ -275,10 +275,13 @@ impl Qualif for HasMutInterior {\n pub struct NeedsDrop;\n \n impl Qualif for NeedsDrop {\n-    const IDX: usize = 1;\n     const ANALYSIS_NAME: &'static str = \"flow_needs_drop\";\n     const IS_CLEARED_ON_MOVE: bool = true;\n \n+    fn in_qualifs(qualifs: &ConstQualifs) -> bool {\n+        qualifs.needs_drop\n+    }\n+\n     fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n         ty.needs_drop(cx.tcx, cx.param_env)\n     }"}, {"sha": "21e7c9ce565f0103d99903f5b85f0ca1775c8e37", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 165, "deletions": 27, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -1,21 +1,25 @@\n //! The `Visitor` responsible for actually checking a `mir::Body` for invalid operations.\n \n+use rustc::hir::HirId;\n+use rustc::middle::lang_items;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::*;\n+use rustc::traits::{self, TraitEngine};\n use rustc::ty::cast::CastTy;\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n use rustc_index::bit_set::BitSet;\n use rustc_target::spec::abi::Abi;\n+use rustc_error_codes::*;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n-use std::fmt;\n+use std::borrow::Cow;\n use std::ops::Deref;\n \n use crate::dataflow::{self as old_dataflow, generic as dataflow};\n use self::old_dataflow::IndirectlyMutableLocals;\n use super::ops::{self, NonConstOp};\n-use super::qualifs::{HasMutInterior, NeedsDrop};\n+use super::qualifs::{self, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n use super::{ConstKind, Item, Qualif, is_lang_panic_fn};\n \n@@ -85,6 +89,19 @@ impl Qualifs<'a, 'mir, 'tcx> {\n             || self.indirectly_mutable(local, location)\n     }\n \n+    /// Returns `true` if `local` is `HasMutInterior` at the given `Location`.\n+    ///\n+    /// Only updates the cursor if absolutely necessary.\n+    fn has_mut_interior_lazy_seek(&mut self, local: Local, location: Location) -> bool {\n+        if !self.has_mut_interior.in_any_value_of_ty.contains(local) {\n+            return false;\n+        }\n+\n+        self.has_mut_interior.cursor.seek_before(location);\n+        self.has_mut_interior.cursor.get().contains(local)\n+            || self.indirectly_mutable(local, location)\n+    }\n+\n     /// Returns `true` if `local` is `HasMutInterior`, but requires the `has_mut_interior` and\n     /// `indirectly_mutable` cursors to be updated beforehand.\n     fn has_mut_interior_eager_seek(&self, local: Local) -> bool {\n@@ -95,6 +112,35 @@ impl Qualifs<'a, 'mir, 'tcx> {\n         self.has_mut_interior.cursor.get().contains(local)\n             || self.indirectly_mutable.get().contains(local)\n     }\n+\n+    fn in_return_place(&mut self, item: &Item<'_, 'tcx>) -> ConstQualifs {\n+        // Find the `Return` terminator if one exists.\n+        //\n+        // If no `Return` terminator exists, this MIR is divergent. Just return the conservative\n+        // qualifs for the return type.\n+        let return_block = item.body\n+            .basic_blocks()\n+            .iter_enumerated()\n+            .find(|(_, block)| {\n+                match block.terminator().kind {\n+                    TerminatorKind::Return => true,\n+                    _ => false,\n+                }\n+            })\n+            .map(|(bb, _)| bb);\n+\n+        let return_block = match return_block {\n+            None => return qualifs::in_any_value_of_ty(item, item.body.return_ty()),\n+            Some(bb) => bb,\n+        };\n+\n+        let return_loc = item.body.terminator_loc(return_block);\n+\n+        ConstQualifs {\n+            needs_drop: self.needs_drop_lazy_seek(RETURN_PLACE, return_loc),\n+            has_mut_interior: self.has_mut_interior_lazy_seek(RETURN_PLACE, return_loc),\n+        }\n+    }\n }\n \n pub struct Validator<'a, 'mir, 'tcx> {\n@@ -114,11 +160,6 @@ pub struct Validator<'a, 'mir, 'tcx> {\n     /// this set is empty. Note that if we start removing locals from\n     /// `derived_from_illegal_borrow`, just checking at the end won't be enough.\n     derived_from_illegal_borrow: BitSet<Local>,\n-\n-    errors: Vec<(Span, String)>,\n-\n-    /// Whether to actually emit errors or just store them in `errors`.\n-    pub(crate) suppress_errors: bool,\n }\n \n impl Deref for Validator<'_, 'mir, 'tcx> {\n@@ -172,21 +213,55 @@ impl Validator<'a, 'mir, 'tcx> {\n             span: item.body.span,\n             item,\n             qualifs,\n-            errors: vec![],\n             derived_from_illegal_borrow: BitSet::new_empty(item.body.local_decls.len()),\n-            suppress_errors: false,\n         }\n     }\n \n-    pub fn take_errors(&mut self) -> Vec<(Span, String)> {\n-        std::mem::replace(&mut self.errors, vec![])\n+    pub fn check_body(&mut self) {\n+        let Item { tcx, body, def_id, const_kind, ..  } = *self.item;\n+\n+        let use_min_const_fn_checks =\n+            tcx.is_min_const_fn(def_id)\n+            && !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n+\n+        if use_min_const_fn_checks {\n+            // Enforce `min_const_fn` for stable `const fn`s.\n+            use crate::transform::qualify_min_const_fn::is_min_const_fn;\n+            if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n+                error_min_const_fn_violation(tcx, span, err);\n+                return;\n+            }\n+        }\n+\n+        check_short_circuiting_in_const_local(self.item);\n+\n+        if body.is_cfg_cyclic() {\n+            // We can't provide a good span for the error here, but this should be caught by the\n+            // HIR const-checker anyways.\n+            self.check_op_spanned(ops::Loop, body.span);\n+        }\n+\n+        self.visit_body(body);\n+\n+        // Ensure that the end result is `Sync` in a non-thread local `static`.\n+        let should_check_for_sync = const_kind == Some(ConstKind::Static)\n+            && !tcx.has_attr(def_id, sym::thread_local);\n+\n+        if should_check_for_sync {\n+            let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+            check_return_ty_is_sync(tcx, body, hir_id);\n+        }\n+    }\n+\n+    pub fn qualifs_in_return_place(&mut self) -> ConstQualifs {\n+        self.qualifs.in_return_place(self.item)\n     }\n \n     /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n     /// context. Returns `Forbidden` if an error was emitted.\n     pub fn check_op_spanned<O>(&mut self, op: O, span: Span) -> CheckOpResult\n     where\n-        O: NonConstOp + fmt::Debug\n+        O: NonConstOp\n     {\n         trace!(\"check_op: op={:?}\", op);\n \n@@ -204,22 +279,37 @@ impl Validator<'a, 'mir, 'tcx> {\n             return CheckOpResult::Unleashed;\n         }\n \n-        if !self.suppress_errors {\n-            op.emit_error(self, span);\n-        }\n-\n-        self.errors.push((span, format!(\"{:?}\", op)));\n+        op.emit_error(self, span);\n         CheckOpResult::Forbidden\n     }\n \n     /// Emits an error if an expression cannot be evaluated in the current context.\n-    pub fn check_op(&mut self, op: impl NonConstOp + fmt::Debug) -> CheckOpResult {\n+    pub fn check_op(&mut self, op: impl NonConstOp) -> CheckOpResult {\n         let span = self.span;\n         self.check_op_spanned(op, span)\n     }\n }\n \n impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n+    fn visit_basic_block_data(\n+        &mut self,\n+        bb: BasicBlock,\n+        block: &BasicBlockData<'tcx>,\n+    ) {\n+        trace!(\"visit_basic_block_data: bb={:?} is_cleanup={:?}\", bb, block.is_cleanup);\n+\n+        // Just as the old checker did, we skip const-checking basic blocks on the unwind path.\n+        // These blocks often drop locals that would otherwise be returned from the function.\n+        //\n+        // FIXME: This shouldn't be unsound since a panic at compile time will cause a compiler\n+        // error anyway, but maybe we should do more here?\n+        if block.is_cleanup {\n+            return;\n+        }\n+\n+        self.super_basic_block_data(bb, block);\n+    }\n+\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         trace!(\"visit_rvalue: rvalue={:?} location={:?}\", rvalue, location);\n \n@@ -451,14 +541,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 self.super_statement(statement, location);\n             }\n             StatementKind::FakeRead(FakeReadCause::ForMatchedPlace, _) => {\n-                // FIXME: make this the `emit_error` impl of `ops::IfOrMatch` once the const\n-                // checker is no longer run in compatability mode.\n-                if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-                    self.tcx.sess.delay_span_bug(\n-                        self.span,\n-                        \"complex control flow is forbidden in a const context\",\n-                    );\n-                }\n+                self.check_op(ops::IfOrMatch);\n             }\n             // FIXME(eddyb) should these really do nothing?\n             StatementKind::FakeRead(..) |\n@@ -564,3 +647,58 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         }\n     }\n }\n+\n+fn error_min_const_fn_violation(tcx: TyCtxt<'_>, span: Span, msg: Cow<'_, str>) {\n+    struct_span_err!(tcx.sess, span, E0723, \"{}\", msg)\n+        .note(\"for more information, see issue https://github.com/rust-lang/rust/issues/57563\")\n+        .help(\"add `#![feature(const_fn)]` to the crate attributes to enable\")\n+        .emit();\n+}\n+\n+fn check_short_circuiting_in_const_local(item: &Item<'_, 'tcx>) {\n+    let body = item.body;\n+\n+    if body.control_flow_destroyed.is_empty() {\n+        return;\n+    }\n+\n+    let mut locals = body.vars_iter();\n+    if let Some(local) = locals.next() {\n+        let span = body.local_decls[local].source_info.span;\n+        let mut error = item.tcx.sess.struct_span_err(\n+            span,\n+            &format!(\n+                \"new features like let bindings are not permitted in {}s \\\n+                which also use short circuiting operators\",\n+                item.const_kind(),\n+            ),\n+        );\n+        for (span, kind) in body.control_flow_destroyed.iter() {\n+            error.span_note(\n+                *span,\n+                &format!(\"use of {} here does not actually short circuit due to \\\n+                the const evaluator presently not being able to do control flow. \\\n+                See https://github.com/rust-lang/rust/issues/49146 for more \\\n+                information.\", kind),\n+            );\n+        }\n+        for local in locals {\n+            let span = body.local_decls[local].source_info.span;\n+            error.span_note(span, \"more locals defined here\");\n+        }\n+        error.emit();\n+    }\n+}\n+\n+fn check_return_ty_is_sync(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, hir_id: HirId) {\n+    let ty = body.return_ty();\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let cause = traits::ObligationCause::new(body.span, hir_id, traits::SharedStatic);\n+        let mut fulfillment_cx = traits::FulfillmentContext::new();\n+        let sync_def_id = tcx.require_lang_item(lang_items::SyncTraitLangItem, Some(body.span));\n+        fulfillment_cx.register_bound(&infcx, ty::ParamEnv::empty(), ty, sync_def_id, cause);\n+        if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n+            infcx.report_fulfillment_errors(&err, None, false);\n+        }\n+    });\n+}"}, {"sha": "897e37858a68edec0f07345321c5bc75a6ca1a03", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -1,8 +1,8 @@\n use crate::{build, shim};\n use rustc_index::vec::IndexVec;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc::mir::{Body, MirPhase, Promoted};\n-use rustc::ty::{TyCtxt, InstanceDef};\n+use rustc::mir::{Body, MirPhase, Promoted, ConstQualifs};\n+use rustc::ty::{TyCtxt, InstanceDef, TypeFoldable};\n use rustc::ty::query::Providers;\n use rustc::ty::steal::Steal;\n use rustc::hir;\n@@ -25,7 +25,6 @@ pub mod rustc_peek;\n pub mod elaborate_drops;\n pub mod add_call_guards;\n pub mod promote_consts;\n-pub mod qualify_consts;\n pub mod qualify_min_const_fn;\n pub mod remove_noop_landing_pads;\n pub mod dump_mir;\n@@ -39,12 +38,12 @@ pub mod uniform_array_move_out;\n pub mod uninhabited_enum_branching;\n \n pub(crate) fn provide(providers: &mut Providers<'_>) {\n-    self::qualify_consts::provide(providers);\n     self::check_unsafety::provide(providers);\n     *providers = Providers {\n         mir_keys,\n         mir_built,\n         mir_const,\n+        mir_const_qualif,\n         mir_validated,\n         optimized_mir,\n         is_mir_available,\n@@ -185,6 +184,41 @@ pub fn run_passes(\n     body.phase = mir_phase;\n }\n \n+fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n+    let const_kind = check_consts::ConstKind::for_item(tcx, def_id);\n+\n+    // No need to const-check a non-const `fn`.\n+    if const_kind.is_none() {\n+        return Default::default();\n+    }\n+\n+    // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n+    // cannot yet be stolen), because `mir_validated()`, which steals\n+    // from `mir_const(), forces this query to execute before\n+    // performing the steal.\n+    let body = &tcx.mir_const(def_id).borrow();\n+\n+    if body.return_ty().references_error() {\n+        tcx.sess.delay_span_bug(body.span, \"mir_const_qualif: MIR had errors\");\n+        return Default::default();\n+    }\n+\n+    let item = check_consts::Item {\n+        body,\n+        tcx,\n+        def_id,\n+        const_kind,\n+        param_env: tcx.param_env(def_id),\n+    };\n+\n+    let mut validator = check_consts::validation::Validator::new(&item);\n+    validator.check_body();\n+\n+    // We return the qualifs in the return place for every MIR body, even though it is only used\n+    // when deciding to promote a reference to a `const` for now.\n+    validator.qualifs_in_return_place().into()\n+}\n+\n fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<Body<'_>> {\n     // Unsafety check uses the raw mir, so make sure it is run\n     let _ = tcx.unsafety_check_result(def_id);\n@@ -203,18 +237,14 @@ fn mir_validated(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n ) -> (&'tcx Steal<Body<'tcx>>, &'tcx Steal<IndexVec<Promoted, Body<'tcx>>>) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind(hir_id) {\n-        // Ensure that we compute the `mir_const_qualif` for constants at\n-        // this point, before we steal the mir-const result.\n-        let _ = tcx.mir_const_qualif(def_id);\n-    }\n+    // Ensure that we compute the `mir_const_qualif` for constants at\n+    // this point, before we steal the mir-const result.\n+    let _ = tcx.mir_const_qualif(def_id);\n \n     let mut body = tcx.mir_const(def_id).steal();\n     let promote_pass = promote_consts::PromoteTemps::default();\n     run_passes(tcx, &mut body, InstanceDef::Item(def_id), None, MirPhase::Validated, &[\n         // What we need to run borrowck etc.\n-        &qualify_consts::QualifyAndPromoteConstants::default(),\n         &promote_pass,\n         &simplify::SimplifyCfg::new(\"qualify-consts\"),\n     ]);"}, {"sha": "c79d382a37480a9c6a5a1787bc458036a570077a", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -582,30 +582,9 @@ impl<'tcx> Validator<'_, 'tcx> {\n             Operand::Copy(place) |\n             Operand::Move(place) => self.validate_place(place.as_ref()),\n \n-            Operand::Constant(constant) => {\n-                if let ty::ConstKind::Unevaluated(def_id, _) = constant.literal.val {\n-                    if self.tcx.trait_of_item(def_id).is_some() {\n-                        // Don't peek inside trait associated constants.\n-                        // (see below what we do for other consts, for now)\n-                    } else {\n-                        // HACK(eddyb) ensure that errors propagate correctly.\n-                        // FIXME(eddyb) remove this once the old promotion logic\n-                        // is gone - we can always promote constants even if they\n-                        // fail to pass const-checking, as compilation would've\n-                        // errored independently and promotion can't change that.\n-                        let bits = self.tcx.at(constant.span).mir_const_qualif(def_id);\n-                        if bits == super::qualify_consts::QUALIF_ERROR_BIT {\n-                            self.tcx.sess.delay_span_bug(\n-                                constant.span,\n-                                \"promote_consts: MIR had errors\",\n-                            );\n-                            return Err(Unpromotable);\n-                        }\n-                    }\n-                }\n-\n-                Ok(())\n-            }\n+            // The qualifs for a constant (e.g. `HasMutInterior`) are checked in\n+            // `validate_rvalue` upon access.\n+            Operand::Constant(_) => Ok(()),\n         }\n     }\n "}, {"sha": "964efdec2b9d227e4016a522ef60c3b47c9624f4", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "removed", "additions": 0, "deletions": 1479, "changes": 1479, "blob_url": "https://github.com/rust-lang/rust/blob/d8014582b843d8722795b06586ef9c2042094963/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8014582b843d8722795b06586ef9c2042094963/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=d8014582b843d8722795b06586ef9c2042094963", "patch": "@@ -1,1479 +0,0 @@\n-//! A pass that qualifies constness of temporaries in constants,\n-//! static initializers and functions and also drives promotion.\n-//!\n-//! The Qualif flags below can be used to also provide better\n-//! diagnostics as to why a constant rvalue wasn't promoted.\n-\n-use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n-use rustc_target::spec::abi::Abi;\n-use rustc::hir;\n-use rustc::hir::def_id::DefId;\n-use rustc::traits::{self, TraitEngine};\n-use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n-use rustc::ty::cast::CastTy;\n-use rustc::ty::query::Providers;\n-use rustc::mir::*;\n-use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n-use rustc::middle::lang_items;\n-use rustc::session::config::nightly_options;\n-use syntax::feature_gate::{emit_feature_err, GateIssue};\n-use syntax::symbol::sym;\n-use syntax_pos::{Span, DUMMY_SP};\n-\n-use std::borrow::Cow;\n-use std::cell::Cell;\n-use std::fmt;\n-use std::ops::{Deref, Index, IndexMut};\n-use std::usize;\n-\n-use rustc::hir::HirId;\n-use crate::transform::{MirPass, MirSource};\n-use crate::transform::check_consts::ops::{self, NonConstOp};\n-\n-use rustc_error_codes::*;\n-\n-/// What kind of item we are in.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-enum Mode {\n-    /// A `static` item.\n-    Static,\n-    /// A `static mut` item.\n-    StaticMut,\n-    /// A `const fn` item.\n-    ConstFn,\n-    /// A `const` item or an anonymous constant (e.g. in array lengths).\n-    Const,\n-    /// Other type of `fn`.\n-    NonConstFn,\n-}\n-\n-impl Mode {\n-    /// Determine whether we have to do full const-checking because syntactically, we\n-    /// are required to be \"const\".\n-    #[inline]\n-    fn requires_const_checking(self) -> bool {\n-        self != Mode::NonConstFn\n-    }\n-}\n-\n-impl fmt::Display for Mode {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            Mode::Const => write!(f, \"constant\"),\n-            Mode::Static | Mode::StaticMut => write!(f, \"static\"),\n-            Mode::ConstFn => write!(f, \"constant function\"),\n-            Mode::NonConstFn => write!(f, \"function\")\n-        }\n-    }\n-}\n-\n-const QUALIF_COUNT: usize = 2;\n-\n-// FIXME(eddyb) once we can use const generics, replace this array with\n-// something like `IndexVec` but for fixed-size arrays (`IndexArray`?).\n-#[derive(Copy, Clone, Default)]\n-struct PerQualif<T>([T; QUALIF_COUNT]);\n-\n-impl<T: Clone> PerQualif<T> {\n-    fn new(x: T) -> Self {\n-        PerQualif([x.clone(), x])\n-    }\n-}\n-\n-impl<T> PerQualif<T> {\n-    fn as_mut(&mut self) -> PerQualif<&mut T> {\n-        let [x0, x1] = &mut self.0;\n-        PerQualif([x0, x1])\n-    }\n-\n-    fn zip<U>(self, other: PerQualif<U>) -> PerQualif<(T, U)> {\n-        let [x0, x1] = self.0;\n-        let [y0, y1] = other.0;\n-        PerQualif([(x0, y0), (x1, y1)])\n-    }\n-}\n-\n-impl PerQualif<bool> {\n-    fn encode_to_bits(self) -> u8 {\n-        self.0.iter().enumerate().fold(0, |bits, (i, &qualif)| {\n-            bits | ((qualif as u8) << i)\n-        })\n-    }\n-\n-    fn decode_from_bits(bits: u8) -> Self {\n-        let mut qualifs = Self::default();\n-        for (i, qualif) in qualifs.0.iter_mut().enumerate() {\n-            *qualif = (bits & (1 << i)) != 0;\n-        }\n-        qualifs\n-    }\n-}\n-\n-impl<Q: Qualif, T> Index<Q> for PerQualif<T> {\n-    type Output = T;\n-\n-    fn index(&self, _: Q) -> &T {\n-        &self.0[Q::IDX]\n-    }\n-}\n-\n-impl<Q: Qualif, T> IndexMut<Q> for PerQualif<T> {\n-    fn index_mut(&mut self, _: Q) -> &mut T {\n-        &mut self.0[Q::IDX]\n-    }\n-}\n-\n-struct ConstCx<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    mode: Mode,\n-    body: &'a Body<'tcx>,\n-\n-    per_local: PerQualif<BitSet<Local>>,\n-}\n-\n-impl<'a, 'tcx> ConstCx<'a, 'tcx> {\n-    fn is_const_panic_fn(&self, def_id: DefId) -> bool {\n-        Some(def_id) == self.tcx.lang_items().panic_fn() ||\n-        Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-enum ValueSource<'a, 'tcx> {\n-    Rvalue(&'a Rvalue<'tcx>),\n-    DropAndReplace(&'a Operand<'tcx>),\n-    Call {\n-        callee: &'a Operand<'tcx>,\n-        args: &'a [Operand<'tcx>],\n-        return_ty: Ty<'tcx>,\n-    },\n-}\n-\n-/// A \"qualif\"(-ication) is a way to look for something \"bad\" in the MIR that would disqualify some\n-/// code for promotion or prevent it from evaluating at compile time. So `return true` means\n-/// \"I found something bad, no reason to go on searching\". `false` is only returned if we\n-/// definitely cannot find anything bad anywhere.\n-///\n-/// The default implementations proceed structurally.\n-trait Qualif {\n-    const IDX: usize;\n-\n-    /// Return the qualification that is (conservatively) correct for any value\n-    /// of the type, or `None` if the qualification is not value/type-based.\n-    fn in_any_value_of_ty(_cx: &ConstCx<'_, 'tcx>, _ty: Ty<'tcx>) -> Option<bool> {\n-        None\n-    }\n-\n-    /// Return a mask for the qualification, given a type. This is `false` iff\n-    /// no value of that type can have the qualification.\n-    fn mask_for_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n-        Self::in_any_value_of_ty(cx, ty).unwrap_or(true)\n-    }\n-\n-    fn in_local(cx: &ConstCx<'_, '_>, local: Local) -> bool {\n-        cx.per_local.0[Self::IDX].contains(local)\n-    }\n-\n-    fn in_static(_cx: &ConstCx<'_, 'tcx>, _static: &Static<'tcx>) -> bool {\n-        // FIXME(eddyb) should we do anything here for value properties?\n-        false\n-    }\n-\n-    fn in_projection_structurally(\n-        cx: &ConstCx<'_, 'tcx>,\n-        place: PlaceRef<'_, 'tcx>,\n-    ) -> bool {\n-        if let [proj_base @ .., elem] = place.projection {\n-            let base_qualif = Self::in_place(cx, PlaceRef {\n-                base: place.base,\n-                projection: proj_base,\n-            });\n-            let qualif = base_qualif && Self::mask_for_ty(\n-                cx,\n-                Place::ty_from(place.base, proj_base, cx.body, cx.tcx)\n-                    .projection_ty(cx.tcx, elem)\n-                    .ty,\n-            );\n-            match elem {\n-                ProjectionElem::Deref |\n-                ProjectionElem::Subslice { .. } |\n-                ProjectionElem::Field(..) |\n-                ProjectionElem::ConstantIndex { .. } |\n-                ProjectionElem::Downcast(..) => qualif,\n-\n-                // FIXME(eddyb) shouldn't this be masked *after* including the\n-                // index local? Then again, it's `usize` which is neither\n-                // `HasMutInterior` nor `NeedsDrop`.\n-                ProjectionElem::Index(local) => qualif || Self::in_local(cx, *local),\n-            }\n-        } else {\n-            bug!(\"This should be called if projection is not empty\");\n-        }\n-    }\n-\n-    fn in_projection(\n-        cx: &ConstCx<'_, 'tcx>,\n-        place: PlaceRef<'_, 'tcx>,\n-    ) -> bool {\n-        Self::in_projection_structurally(cx, place)\n-    }\n-\n-    fn in_place(cx: &ConstCx<'_, 'tcx>, place: PlaceRef<'_, 'tcx>) -> bool {\n-        match place {\n-            PlaceRef {\n-                base: PlaceBase::Local(local),\n-                projection: [],\n-            } => Self::in_local(cx, *local),\n-            PlaceRef {\n-                base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Promoted(..),\n-                    ..\n-                }),\n-                projection: [],\n-            } => bug!(\"qualifying already promoted MIR\"),\n-            PlaceRef {\n-                base: PlaceBase::Static(static_),\n-                projection: [],\n-            } => {\n-                Self::in_static(cx, static_)\n-            },\n-            PlaceRef {\n-                base: _,\n-                projection: [.., _],\n-            } => Self::in_projection(cx, place),\n-        }\n-    }\n-\n-    fn in_operand(cx: &ConstCx<'_, 'tcx>, operand: &Operand<'tcx>) -> bool {\n-        match *operand {\n-            Operand::Copy(ref place) |\n-            Operand::Move(ref place) => Self::in_place(cx, place.as_ref()),\n-\n-            Operand::Constant(ref constant) => {\n-                if let ty::ConstKind::Unevaluated(def_id, _) = constant.literal.val {\n-                    // Don't peek inside trait associated constants.\n-                    if cx.tcx.trait_of_item(def_id).is_some() {\n-                        Self::in_any_value_of_ty(cx, constant.literal.ty).unwrap_or(false)\n-                    } else {\n-                        let bits = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n-\n-                        let qualif = PerQualif::decode_from_bits(bits).0[Self::IDX];\n-\n-                        // Just in case the type is more specific than\n-                        // the definition, e.g., impl associated const\n-                        // with type parameters, take it into account.\n-                        qualif && Self::mask_for_ty(cx, constant.literal.ty)\n-                    }\n-                } else {\n-                    false\n-                }\n-            }\n-        }\n-    }\n-\n-    fn in_rvalue_structurally(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n-        match *rvalue {\n-            Rvalue::NullaryOp(..) => false,\n-\n-            Rvalue::Discriminant(ref place) |\n-            Rvalue::Len(ref place) => Self::in_place(cx, place.as_ref()),\n-\n-            Rvalue::Use(ref operand) |\n-            Rvalue::Repeat(ref operand, _) |\n-            Rvalue::UnaryOp(_, ref operand) |\n-            Rvalue::Cast(_, ref operand, _) => Self::in_operand(cx, operand),\n-\n-            Rvalue::BinaryOp(_, ref lhs, ref rhs) |\n-            Rvalue::CheckedBinaryOp(_, ref lhs, ref rhs) => {\n-                Self::in_operand(cx, lhs) || Self::in_operand(cx, rhs)\n-            }\n-\n-            Rvalue::Ref(_, _, ref place) => {\n-                // Special-case reborrows to be more like a copy of the reference.\n-                if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n-                    if ProjectionElem::Deref == elem {\n-                        let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n-                        if let ty::Ref(..) = base_ty.kind {\n-                            return Self::in_place(cx, PlaceRef {\n-                                base: &place.base,\n-                                projection: proj_base,\n-                            });\n-                        }\n-                    }\n-                }\n-\n-                Self::in_place(cx, place.as_ref())\n-            }\n-\n-            Rvalue::Aggregate(_, ref operands) => {\n-                operands.iter().any(|o| Self::in_operand(cx, o))\n-            }\n-        }\n-    }\n-\n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n-        Self::in_rvalue_structurally(cx, rvalue)\n-    }\n-\n-    fn in_call(\n-        cx: &ConstCx<'_, 'tcx>,\n-        _callee: &Operand<'tcx>,\n-        _args: &[Operand<'tcx>],\n-        return_ty: Ty<'tcx>,\n-    ) -> bool {\n-        // Be conservative about the returned value of a const fn.\n-        Self::in_any_value_of_ty(cx, return_ty).unwrap_or(false)\n-    }\n-\n-    fn in_value(cx: &ConstCx<'_, 'tcx>, source: ValueSource<'_, 'tcx>) -> bool {\n-        match source {\n-            ValueSource::Rvalue(rvalue) => Self::in_rvalue(cx, rvalue),\n-            ValueSource::DropAndReplace(source) => Self::in_operand(cx, source),\n-            ValueSource::Call { callee, args, return_ty } => {\n-                Self::in_call(cx, callee, args, return_ty)\n-            }\n-        }\n-    }\n-}\n-\n-/// Constant containing interior mutability (`UnsafeCell<T>`).\n-/// This must be ruled out to make sure that evaluating the constant at compile-time\n-/// and at *any point* during the run-time would produce the same result. In particular,\n-/// promotion of temporaries must not change program behavior; if the promoted could be\n-/// written to, that would be a problem.\n-struct HasMutInterior;\n-\n-impl Qualif for HasMutInterior {\n-    const IDX: usize = 0;\n-\n-    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> Option<bool> {\n-        Some(!ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP))\n-    }\n-\n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n-        match *rvalue {\n-            // Returning `true` for `Rvalue::Ref` indicates the borrow isn't\n-            // allowed in constants (and the `Checker` will error), and/or it\n-            // won't be promoted, due to `&mut ...` or interior mutability.\n-            Rvalue::Ref(_, kind, ref place) => {\n-                let ty = place.ty(cx.body, cx.tcx).ty;\n-\n-                if let BorrowKind::Mut { .. } = kind {\n-                    // In theory, any zero-sized value could be borrowed\n-                    // mutably without consequences. However, only &mut []\n-                    // is allowed right now, and only in functions.\n-                    if cx.mode == Mode::StaticMut {\n-                        // Inside a `static mut`, &mut [...] is also allowed.\n-                        match ty.kind {\n-                            ty::Array(..) | ty::Slice(_) => {}\n-                            _ => return true,\n-                        }\n-                    } else if let ty::Array(_, len) = ty.kind {\n-                        // FIXME(eddyb) the `cx.mode == Mode::NonConstFn` condition\n-                        // seems unnecessary, given that this is merely a ZST.\n-                        match len.try_eval_usize(cx.tcx, cx.param_env) {\n-                            Some(0) if cx.mode == Mode::NonConstFn => {},\n-                            _ => return true,\n-                        }\n-                    } else {\n-                        return true;\n-                    }\n-                }\n-            }\n-\n-            Rvalue::Aggregate(ref kind, _) => {\n-                if let AggregateKind::Adt(def, ..) = **kind {\n-                    if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {\n-                        let ty = rvalue.ty(cx.body, cx.tcx);\n-                        assert_eq!(Self::in_any_value_of_ty(cx, ty), Some(true));\n-                        return true;\n-                    }\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-\n-        Self::in_rvalue_structurally(cx, rvalue)\n-    }\n-}\n-\n-/// Constant containing an ADT that implements `Drop`.\n-/// This must be ruled out (a) because we cannot run `Drop` during compile-time\n-/// as that might not be a `const fn`, and (b) because implicit promotion would\n-/// remove side-effects that occur as part of dropping that value.\n-struct NeedsDrop;\n-\n-impl Qualif for NeedsDrop {\n-    const IDX: usize = 1;\n-\n-    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> Option<bool> {\n-        Some(ty.needs_drop(cx.tcx, cx.param_env))\n-    }\n-\n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n-        if let Rvalue::Aggregate(ref kind, _) = *rvalue {\n-            if let AggregateKind::Adt(def, ..) = **kind {\n-                if def.has_dtor(cx.tcx) {\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        Self::in_rvalue_structurally(cx, rvalue)\n-    }\n-}\n-\n-// Ensure the `IDX` values are sequential (`0..QUALIF_COUNT`).\n-macro_rules! static_assert_seq_qualifs {\n-    ($i:expr => $first:ident $(, $rest:ident)*) => {\n-        static_assert!({\n-            static_assert_seq_qualifs!($i + 1 => $($rest),*);\n-\n-            $first::IDX == $i\n-        });\n-    };\n-    ($i:expr =>) => {\n-        static_assert!(QUALIF_COUNT == $i);\n-    };\n-}\n-static_assert_seq_qualifs!(\n-    0 => HasMutInterior, NeedsDrop\n-);\n-\n-impl ConstCx<'_, 'tcx> {\n-    fn qualifs_in_any_value_of_ty(&self, ty: Ty<'tcx>) -> PerQualif<bool> {\n-        let mut qualifs = PerQualif::default();\n-        qualifs[HasMutInterior] = HasMutInterior::in_any_value_of_ty(self, ty).unwrap_or(false);\n-        qualifs[NeedsDrop] = NeedsDrop::in_any_value_of_ty(self, ty).unwrap_or(false);\n-        qualifs\n-    }\n-\n-    fn qualifs_in_local(&self, local: Local) -> PerQualif<bool> {\n-        let mut qualifs = PerQualif::default();\n-        qualifs[HasMutInterior] = HasMutInterior::in_local(self, local);\n-        qualifs[NeedsDrop] = NeedsDrop::in_local(self, local);\n-        qualifs\n-    }\n-\n-    fn qualifs_in_value(&self, source: ValueSource<'_, 'tcx>) -> PerQualif<bool> {\n-        let mut qualifs = PerQualif::default();\n-        qualifs[HasMutInterior] = HasMutInterior::in_value(self, source);\n-        qualifs[NeedsDrop] = NeedsDrop::in_value(self, source);\n-        qualifs\n-    }\n-}\n-\n-/// Checks MIR for being admissible as a compile-time constant, using `ConstCx`\n-/// for value qualifications, and accumulates writes of\n-/// rvalue/call results to locals, in `local_qualif`.\n-/// It also records candidates for promotion in `promotion_candidates`,\n-/// both in functions and const/static items.\n-struct Checker<'a, 'tcx> {\n-    cx: ConstCx<'a, 'tcx>,\n-\n-    span: Span,\n-    def_id: DefId,\n-\n-    /// If `true`, do not emit errors to the user, merely collect them in `errors`.\n-    suppress_errors: bool,\n-    errors: Vec<(Span, String)>,\n-}\n-\n-macro_rules! unleash_miri {\n-    ($this:expr) => {{\n-        if $this.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-            if $this.mode.requires_const_checking() && !$this.suppress_errors {\n-                $this.tcx.sess.span_warn($this.span, \"skipping const checks\");\n-            }\n-            return;\n-        }\n-    }}\n-}\n-\n-impl Deref for Checker<'a, 'tcx> {\n-    type Target = ConstCx<'a, 'tcx>;\n-\n-    fn deref(&self) -> &Self::Target {\n-        &self.cx\n-    }\n-}\n-\n-impl<'a, 'tcx> Checker<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>, mode: Mode) -> Self {\n-        assert!(def_id.is_local());\n-\n-        let param_env = tcx.param_env(def_id);\n-\n-        let mut cx = ConstCx {\n-            tcx,\n-            param_env,\n-            mode,\n-            body,\n-            per_local: PerQualif::new(BitSet::new_empty(body.local_decls.len())),\n-        };\n-\n-        for (local, decl) in body.local_decls.iter_enumerated() {\n-            if let LocalKind::Arg = body.local_kind(local) {\n-                let qualifs = cx.qualifs_in_any_value_of_ty(decl.ty);\n-                for (per_local, qualif) in &mut cx.per_local.as_mut().zip(qualifs).0 {\n-                    if *qualif {\n-                        per_local.insert(local);\n-                    }\n-                }\n-            }\n-        }\n-\n-        Checker {\n-            cx,\n-            span: body.span,\n-            def_id,\n-            errors: vec![],\n-            suppress_errors: false,\n-        }\n-    }\n-\n-    // FIXME(eddyb) we could split the errors into meaningful\n-    // categories, but enabling full miri would make that\n-    // slightly pointless (even with feature-gating).\n-    fn not_const(&mut self, op: impl NonConstOp) {\n-        unleash_miri!(self);\n-        if self.mode.requires_const_checking() && !self.suppress_errors {\n-            self.record_error(op);\n-            let mut err = struct_span_err!(\n-                self.tcx.sess,\n-                self.span,\n-                E0019,\n-                \"{} contains unimplemented expression type\",\n-                self.mode\n-            );\n-            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                err.note(\"A function call isn't allowed in the const's initialization expression \\\n-                          because the expression's value must be known at compile-time.\");\n-                err.note(\"Remember: you can't use a function call inside a const's initialization \\\n-                          expression! However, you can use it anywhere else.\");\n-            }\n-            err.emit();\n-        }\n-    }\n-\n-    fn record_error(&mut self, op: impl NonConstOp) {\n-        self.record_error_spanned(op, self.span);\n-    }\n-\n-    fn record_error_spanned(&mut self, op: impl NonConstOp, span: Span) {\n-        self.errors.push((span, format!(\"{:?}\", op)));\n-    }\n-\n-    /// Assigns an rvalue/call qualification to the given destination.\n-    fn assign(&mut self, dest: &Place<'tcx>, source: ValueSource<'_, 'tcx>, location: Location) {\n-        trace!(\"assign: {:?} <- {:?}\", dest, source);\n-\n-        let mut qualifs = self.qualifs_in_value(source);\n-\n-        match source {\n-            ValueSource::Rvalue(&Rvalue::Ref(_, kind, _)) => {\n-                // Getting `true` from `HasMutInterior::in_rvalue` means\n-                // the borrowed place is disallowed from being borrowed,\n-                // due to either a mutable borrow (with some exceptions),\n-                // or an shared borrow of a value with interior mutability.\n-                // Then `HasMutInterior` is cleared\n-                // to avoid duplicate errors (e.g. from reborrowing).\n-                if qualifs[HasMutInterior] {\n-                    qualifs[HasMutInterior] = false;\n-\n-                    debug!(\"suppress_errors: {}\", self.suppress_errors);\n-                    if self.mode.requires_const_checking() && !self.suppress_errors {\n-                        if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-                            self.record_error(ops::MutBorrow(kind));\n-                            if let BorrowKind::Mut { .. } = kind {\n-                                let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n-                                                               \"references in {}s may only refer \\\n-                                                                to immutable values\", self.mode);\n-                                err.span_label(self.span, format!(\"{}s require immutable values\",\n-                                                                    self.mode));\n-                                if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                                    err.note(\"References in statics and constants may only refer \\\n-                                              to immutable values.\\n\\n\\\n-                                              Statics are shared everywhere, and if they refer to \\\n-                                              mutable data one might violate memory safety since \\\n-                                              holding multiple mutable references to shared data \\\n-                                              is not allowed.\\n\\n\\\n-                                              If you really want global mutable state, try using \\\n-                                              static mut or a global UnsafeCell.\");\n-                                }\n-                                err.emit();\n-                            } else {\n-                                span_err!(self.tcx.sess, self.span, E0492,\n-                                          \"cannot borrow a constant which may contain \\\n-                                           interior mutability, create a static instead\");\n-                            }\n-                        }\n-                    }\n-                }\n-            },\n-            _ => {},\n-        }\n-\n-        let mut dest_projection = &dest.projection[..];\n-        let index = loop {\n-            match (&dest.base, dest_projection) {\n-                // We treat all locals equal in constants\n-                (&PlaceBase::Local(index), []) => break index,\n-                // projections are transparent for assignments\n-                // we qualify the entire destination at once, even if just a field would have\n-                // stricter qualification\n-                (base, [proj_base @ .., _]) => {\n-                    // Catch more errors in the destination. `visit_place` also checks various\n-                    // projection rules like union field access and raw pointer deref\n-                    let context = PlaceContext::MutatingUse(MutatingUseContext::Store);\n-                    self.visit_place_base(base, context, location);\n-                    self.visit_projection(base, dest_projection, context, location);\n-                    dest_projection = proj_base;\n-                },\n-                (&PlaceBase::Static(box Static {\n-                    kind: StaticKind::Promoted(..),\n-                    ..\n-                }), []) => bug!(\"promoteds don't exist yet during promotion\"),\n-                (&PlaceBase::Static(box Static{ kind: _, .. }), []) => {\n-                    // Catch more errors in the destination. `visit_place` also checks that we\n-                    // do not try to access statics from constants or try to mutate statics\n-                    let context = PlaceContext::MutatingUse(MutatingUseContext::Store);\n-                    self.visit_place_base(&dest.base, context, location);\n-                    return;\n-                }\n-            }\n-        };\n-\n-        let kind = self.body.local_kind(index);\n-        debug!(\"store to {:?} {:?}\", kind, index);\n-\n-        // this is overly restrictive, because even full assignments do not clear the qualif\n-        // While we could special case full assignments, this would be inconsistent with\n-        // aggregates where we overwrite all fields via assignments, which would not get\n-        // that feature.\n-        for (per_local, qualif) in &mut self.cx.per_local.as_mut().zip(qualifs).0 {\n-            if *qualif {\n-                per_local.insert(index);\n-            }\n-        }\n-    }\n-\n-    /// Check a whole const, static initializer or const fn.\n-    fn check_const(&mut self) -> u8 {\n-        use crate::transform::check_consts as new_checker;\n-\n-        debug!(\"const-checking {} {:?}\", self.mode, self.def_id);\n-\n-        // FIXME: Also use the new validator when features that require it (e.g. `const_if`) are\n-        // enabled.\n-        let use_new_validator = self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n-        if use_new_validator {\n-            debug!(\"Using dataflow-based const validator\");\n-        }\n-\n-        let item = new_checker::Item::new(self.tcx, self.def_id, self.body);\n-        let mut validator = new_checker::validation::Validator::new(&item);\n-\n-        validator.suppress_errors = !use_new_validator;\n-        self.suppress_errors = use_new_validator;\n-\n-        let body = self.body;\n-\n-        let mut seen_blocks = BitSet::new_empty(body.basic_blocks().len());\n-        let mut bb = START_BLOCK;\n-        loop {\n-            seen_blocks.insert(bb.index());\n-\n-            self.visit_basic_block_data(bb, &body[bb]);\n-            validator.visit_basic_block_data(bb, &body[bb]);\n-\n-            let target = match body[bb].terminator().kind {\n-                TerminatorKind::Goto { target } |\n-                TerminatorKind::FalseUnwind { real_target: target, .. } |\n-                TerminatorKind::Drop { target, .. } |\n-                TerminatorKind::DropAndReplace { target, .. } |\n-                TerminatorKind::Assert { target, .. } |\n-                TerminatorKind::Call { destination: Some((_, target)), .. } => {\n-                    Some(target)\n-                }\n-\n-                // Non-terminating calls cannot produce any value.\n-                TerminatorKind::Call { destination: None, .. } => {\n-                    break;\n-                }\n-\n-                TerminatorKind::SwitchInt {..} |\n-                TerminatorKind::Resume |\n-                TerminatorKind::Abort |\n-                TerminatorKind::GeneratorDrop |\n-                TerminatorKind::Yield { .. } |\n-                TerminatorKind::Unreachable |\n-                TerminatorKind::FalseEdges { .. } => None,\n-\n-                TerminatorKind::Return => {\n-                    break;\n-                }\n-            };\n-\n-            match target {\n-                // No loops allowed.\n-                Some(target) if !seen_blocks.contains(target.index()) => {\n-                    bb = target;\n-                }\n-                _ => {\n-                    if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-                        self.tcx.sess.delay_span_bug(\n-                            self.span,\n-                            \"complex control flow is forbidden in a const context\",\n-                        );\n-                    }\n-                    break;\n-                }\n-            }\n-        }\n-\n-        // The new validation pass should agree with the old when running on simple const bodies\n-        // (e.g. no `if` or `loop`).\n-        if !use_new_validator {\n-            let mut new_errors = validator.take_errors();\n-\n-            // FIXME: each checker sometimes emits the same error with the same span twice in a row.\n-            self.errors.dedup();\n-            new_errors.dedup();\n-\n-            if self.errors != new_errors {\n-                validator_mismatch(\n-                    self.tcx,\n-                    body,\n-                    std::mem::replace(&mut self.errors, vec![]),\n-                    new_errors,\n-                );\n-            }\n-        }\n-\n-        self.qualifs_in_local(RETURN_PLACE).encode_to_bits()\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n-    fn visit_place_base(\n-        &mut self,\n-        place_base: &PlaceBase<'tcx>,\n-        context: PlaceContext,\n-        location: Location,\n-    ) {\n-        self.super_place_base(place_base, context, location);\n-        match place_base {\n-            PlaceBase::Local(_) => {}\n-            PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) => {\n-                unreachable!()\n-            }\n-            PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n-                if self.tcx\n-                        .get_attrs(*def_id)\n-                        .iter()\n-                        .any(|attr| attr.check_name(sym::thread_local)) {\n-                    if self.mode.requires_const_checking() && !self.suppress_errors {\n-                        self.record_error(ops::ThreadLocalAccess);\n-                        span_err!(self.tcx.sess, self.span, E0625,\n-                                    \"thread-local statics cannot be \\\n-                                    accessed at compile-time\");\n-                    }\n-                    return;\n-                }\n-\n-                // Only allow statics (not consts) to refer to other statics.\n-                if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n-                    return;\n-                }\n-                unleash_miri!(self);\n-\n-                if self.mode.requires_const_checking() && !self.suppress_errors {\n-                    self.record_error(ops::StaticAccess);\n-                    let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n-                                                    \"{}s cannot refer to statics, use \\\n-                                                    a constant instead\", self.mode);\n-                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                        err.note(\n-                            \"Static and const variables can refer to other const variables. \\\n-                                But a const variable cannot refer to a static variable.\"\n-                        );\n-                        err.help(\n-                            \"To fix this, the value can be extracted as a const and then used.\"\n-                        );\n-                    }\n-                    err.emit()\n-                }\n-            }\n-        }\n-    }\n-\n-    fn visit_projection_elem(\n-        &mut self,\n-        place_base: &PlaceBase<'tcx>,\n-        proj_base: &[PlaceElem<'tcx>],\n-        elem: &PlaceElem<'tcx>,\n-        context: PlaceContext,\n-        location: Location,\n-    ) {\n-        debug!(\n-            \"visit_projection_elem: place_base={:?} proj_base={:?} elem={:?} \\\n-            context={:?} location={:?}\",\n-            place_base,\n-            proj_base,\n-            elem,\n-            context,\n-            location,\n-        );\n-\n-        self.super_projection_elem(place_base, proj_base, elem, context, location);\n-\n-        match elem {\n-            ProjectionElem::Deref => {\n-                if context.is_mutating_use() {\n-                    // `not_const` errors out in const contexts\n-                    self.not_const(ops::MutDeref)\n-                }\n-                let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n-                match self.mode {\n-                    Mode::NonConstFn => {}\n-                    _ if self.suppress_errors => {}\n-                    _ => {\n-                        if let ty::RawPtr(_) = base_ty.kind {\n-                            if !self.tcx.features().const_raw_ptr_deref {\n-                                self.record_error(ops::RawPtrDeref);\n-                                emit_feature_err(\n-                                    &self.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n-                                    self.span, GateIssue::Language,\n-                                    &format!(\n-                                        \"dereferencing raw pointers in {}s is unstable\",\n-                                        self.mode,\n-                                    ),\n-                                );\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            ProjectionElem::ConstantIndex {..} |\n-            ProjectionElem::Subslice {..} |\n-            ProjectionElem::Field(..) |\n-            ProjectionElem::Index(_) => {\n-                let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n-                if let Some(def) = base_ty.ty_adt_def() {\n-                    if def.is_union() {\n-                        match self.mode {\n-                            Mode::ConstFn => {\n-                                if !self.tcx.features().const_fn_union\n-                                    && !self.suppress_errors\n-                                {\n-                                    self.record_error(ops::UnionAccess);\n-                                    emit_feature_err(\n-                                        &self.tcx.sess.parse_sess, sym::const_fn_union,\n-                                        self.span, GateIssue::Language,\n-                                        \"unions in const fn are unstable\",\n-                                    );\n-                                }\n-                            },\n-\n-                            | Mode::NonConstFn\n-                            | Mode::Static\n-                            | Mode::StaticMut\n-                            | Mode::Const\n-                            => {},\n-                        }\n-                    }\n-                }\n-            }\n-\n-            ProjectionElem::Downcast(..) => {\n-                self.not_const(ops::Downcast)\n-            }\n-        }\n-    }\n-\n-    fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n-        debug!(\"visit_operand: operand={:?} location={:?}\", operand, location);\n-        self.super_operand(operand, location);\n-\n-        match *operand {\n-            Operand::Move(ref place) => {\n-                // Mark the consumed locals to indicate later drops are noops.\n-                if let Some(local) = place.as_local() {\n-                    self.cx.per_local[NeedsDrop].remove(local);\n-                }\n-            }\n-            Operand::Copy(_) |\n-            Operand::Constant(_) => {}\n-        }\n-    }\n-\n-    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        debug!(\"visit_rvalue: rvalue={:?} location={:?}\", rvalue, location);\n-\n-        // Check nested operands and places.\n-        if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n-            // Special-case reborrows.\n-            let mut reborrow_place = None;\n-            if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n-                if elem == ProjectionElem::Deref {\n-                    let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n-                    if let ty::Ref(..) = base_ty.kind {\n-                        reborrow_place = Some(proj_base);\n-                    }\n-                }\n-            }\n-\n-            if let Some(proj) = reborrow_place {\n-                let ctx = match kind {\n-                    BorrowKind::Shared => PlaceContext::NonMutatingUse(\n-                        NonMutatingUseContext::SharedBorrow,\n-                    ),\n-                    BorrowKind::Shallow => PlaceContext::NonMutatingUse(\n-                        NonMutatingUseContext::ShallowBorrow,\n-                    ),\n-                    BorrowKind::Unique => PlaceContext::NonMutatingUse(\n-                        NonMutatingUseContext::UniqueBorrow,\n-                    ),\n-                    BorrowKind::Mut { .. } => PlaceContext::MutatingUse(\n-                        MutatingUseContext::Borrow,\n-                    ),\n-                };\n-                self.visit_place_base(&place.base, ctx, location);\n-                self.visit_projection(&place.base, proj, ctx, location);\n-            } else {\n-                self.super_rvalue(rvalue, location);\n-            }\n-        } else {\n-            self.super_rvalue(rvalue, location);\n-        }\n-\n-        match *rvalue {\n-            Rvalue::Use(_) |\n-            Rvalue::Repeat(..) |\n-            Rvalue::UnaryOp(UnOp::Neg, _) |\n-            Rvalue::UnaryOp(UnOp::Not, _) |\n-            Rvalue::NullaryOp(NullOp::SizeOf, _) |\n-            Rvalue::CheckedBinaryOp(..) |\n-            Rvalue::Cast(CastKind::Pointer(_), ..) |\n-            Rvalue::Discriminant(..) |\n-            Rvalue::Len(_) |\n-            Rvalue::Ref(..) |\n-            Rvalue::Aggregate(..) => {}\n-\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = operand.ty(self.body, self.tcx);\n-                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n-                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                match (cast_in, cast_out) {\n-                    (CastTy::Ptr(_), CastTy::Int(_)) |\n-                    (CastTy::FnPtr, CastTy::Int(_)) if self.mode != Mode::NonConstFn => {\n-                        unleash_miri!(self);\n-                        if !self.tcx.features().const_raw_ptr_to_usize_cast\n-                            && !self.suppress_errors\n-                        {\n-                            // in const fn and constants require the feature gate\n-                            // FIXME: make it unsafe inside const fn and constants\n-                            self.record_error(ops::RawPtrToIntCast);\n-                            emit_feature_err(\n-                                &self.tcx.sess.parse_sess, sym::const_raw_ptr_to_usize_cast,\n-                                self.span, GateIssue::Language,\n-                                &format!(\n-                                    \"casting pointers to integers in {}s is unstable\",\n-                                    self.mode,\n-                                ),\n-                            );\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n-                    assert!(op == BinOp::Eq || op == BinOp::Ne ||\n-                            op == BinOp::Le || op == BinOp::Lt ||\n-                            op == BinOp::Ge || op == BinOp::Gt ||\n-                            op == BinOp::Offset);\n-\n-                    unleash_miri!(self);\n-                    if self.mode.requires_const_checking() &&\n-                        !self.tcx.features().const_compare_raw_pointers &&\n-                        !self.suppress_errors\n-                    {\n-                        self.record_error(ops::RawPtrComparison);\n-                        // require the feature gate inside constants and const fn\n-                        // FIXME: make it unsafe to use these operations\n-                        emit_feature_err(\n-                            &self.tcx.sess.parse_sess,\n-                            sym::const_compare_raw_pointers,\n-                            self.span,\n-                            GateIssue::Language,\n-                            &format!(\"comparing raw pointers inside {}\", self.mode),\n-                        );\n-                    }\n-                }\n-            }\n-\n-            Rvalue::NullaryOp(NullOp::Box, _) => {\n-                unleash_miri!(self);\n-                if self.mode.requires_const_checking() && !self.suppress_errors {\n-                    self.record_error(ops::HeapAllocation);\n-                    let mut err = struct_span_err!(self.tcx.sess, self.span, E0010,\n-                                                   \"allocations are not allowed in {}s\", self.mode);\n-                    err.span_label(self.span, format!(\"allocation not allowed in {}s\", self.mode));\n-                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                        err.note(\n-                            \"The value of statics and constants must be known at compile time, \\\n-                             and they live for the entire lifetime of a program. Creating a boxed \\\n-                             value allocates memory on the heap at runtime, and therefore cannot \\\n-                             be done at compile time.\"\n-                        );\n-                    }\n-                    err.emit();\n-                }\n-            }\n-        }\n-    }\n-\n-    fn visit_terminator_kind(&mut self,\n-                             kind: &TerminatorKind<'tcx>,\n-                             location: Location) {\n-        debug!(\"visit_terminator_kind: kind={:?} location={:?}\", kind, location);\n-        if let TerminatorKind::Call { ref func, ref args, ref destination, .. } = *kind {\n-            if let Some((ref dest, _)) = *destination {\n-                self.assign(dest, ValueSource::Call {\n-                    callee: func,\n-                    args,\n-                    return_ty: dest.ty(self.body, self.tcx).ty,\n-                }, location);\n-            }\n-\n-            let fn_ty = func.ty(self.body, self.tcx);\n-            match fn_ty.kind {\n-                ty::FnDef(def_id, _) => {\n-                    match self.tcx.fn_sig(def_id).abi() {\n-                        Abi::RustIntrinsic |\n-                        Abi::PlatformIntrinsic => {\n-                            assert!(!self.tcx.is_const_fn(def_id));\n-                            match &*self.tcx.item_name(def_id).as_str() {\n-                                // special intrinsic that can be called diretly without an intrinsic\n-                                // feature gate needs a language feature gate\n-                                \"transmute\" => {\n-                                    if self.mode.requires_const_checking()\n-                                        && !self.suppress_errors\n-                                    {\n-                                        // const eval transmute calls only with the feature gate\n-                                        if !self.tcx.features().const_transmute {\n-                                            self.record_error(ops::Transmute);\n-                                            emit_feature_err(\n-                                                &self.tcx.sess.parse_sess, sym::const_transmute,\n-                                                self.span, GateIssue::Language,\n-                                                &format!(\"The use of std::mem::transmute() \\\n-                                                is gated in {}s\", self.mode));\n-                                        }\n-                                    }\n-                                }\n-\n-                                // no need to check feature gates, intrinsics are only callable\n-                                // from the libstd or with forever unstable feature gates\n-                                _ => {}\n-                            }\n-                        }\n-                        _ => {\n-                            // In normal functions no calls are feature-gated.\n-                            if self.mode.requires_const_checking() {\n-                                let unleash_miri = self\n-                                    .tcx\n-                                    .sess\n-                                    .opts\n-                                    .debugging_opts\n-                                    .unleash_the_miri_inside_of_you;\n-                                if self.tcx.is_const_fn(def_id)\n-                                    || unleash_miri\n-                                    || self.suppress_errors\n-                                {\n-                                    // stable const fns or unstable const fns\n-                                    // with their feature gate active\n-                                    // FIXME(eddyb) move stability checks from `is_const_fn` here.\n-                                } else if self.is_const_panic_fn(def_id) {\n-                                    // Check the const_panic feature gate.\n-                                    // FIXME: cannot allow this inside `allow_internal_unstable`\n-                                    // because that would make `panic!` insta stable in constants,\n-                                    // since the macro is marked with the attribute.\n-                                    if !self.tcx.features().const_panic {\n-                                        // Don't allow panics in constants without the feature gate.\n-                                        self.record_error(ops::Panic);\n-                                        emit_feature_err(\n-                                            &self.tcx.sess.parse_sess,\n-                                            sym::const_panic,\n-                                            self.span,\n-                                            GateIssue::Language,\n-                                            &format!(\"panicking in {}s is unstable\", self.mode),\n-                                        );\n-                                    }\n-                                } else if let Some(feature)\n-                                              = self.tcx.is_unstable_const_fn(def_id) {\n-                                    // Check `#[unstable]` const fns or `#[rustc_const_unstable]`\n-                                    // functions without the feature gate active in this crate in\n-                                    // order to report a better error message than the one below.\n-                                    if !self.span.allows_unstable(feature) {\n-                                        self.record_error(ops::FnCallUnstable(def_id, feature));\n-                                        let mut err = self.tcx.sess.struct_span_err(self.span,\n-                                            &format!(\"`{}` is not yet stable as a const fn\",\n-                                                    self.tcx.def_path_str(def_id)));\n-                                        if nightly_options::is_nightly_build() {\n-                                            help!(&mut err,\n-                                                  \"add `#![feature({})]` to the \\\n-                                                   crate attributes to enable\",\n-                                                  feature);\n-                                        }\n-                                        err.emit();\n-                                    }\n-                                } else {\n-                                    self.record_error(ops::FnCallNonConst(def_id));\n-                                    let mut err = struct_span_err!(\n-                                        self.tcx.sess,\n-                                        self.span,\n-                                        E0015,\n-                                        \"calls in {}s are limited to constant functions, \\\n-                                         tuple structs and tuple variants\",\n-                                        self.mode,\n-                                    );\n-                                    err.emit();\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                ty::FnPtr(_) => {\n-                    unleash_miri!(self);\n-                    if self.mode.requires_const_checking() && !self.suppress_errors {\n-                        self.record_error(ops::FnCallIndirect);\n-                        let mut err = self.tcx.sess.struct_span_err(\n-                            self.span,\n-                            \"function pointers are not allowed in const fn\"\n-                        );\n-                        err.emit();\n-                    }\n-                }\n-                _ => {\n-                    self.not_const(ops::FnCallOther);\n-                }\n-            }\n-\n-            // Check callee and argument operands.\n-            self.visit_operand(func, location);\n-            for arg in args {\n-                self.visit_operand(arg, location);\n-            }\n-        } else if let TerminatorKind::Drop {\n-            location: ref place, ..\n-        } | TerminatorKind::DropAndReplace {\n-            location: ref place, ..\n-        } = *kind {\n-            match *kind {\n-                TerminatorKind::DropAndReplace { .. } => {}\n-                _ => self.super_terminator_kind(kind, location),\n-            }\n-\n-            // Deny *any* live drops anywhere other than functions.\n-            if self.mode.requires_const_checking() && !self.suppress_errors {\n-                unleash_miri!(self);\n-                // HACK(eddyb): emulate a bit of dataflow analysis,\n-                // conservatively, that drop elaboration will do.\n-                let needs_drop = if let Some(local) = place.as_local() {\n-                    if NeedsDrop::in_local(self, local) {\n-                        Some(self.body.local_decls[local].source_info.span)\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    Some(self.span)\n-                };\n-\n-                if let Some(span) = needs_drop {\n-                    // Double-check the type being dropped, to minimize false positives.\n-                    let ty = place.ty(self.body, self.tcx).ty;\n-                    if ty.needs_drop(self.tcx, self.param_env) {\n-                        self.record_error_spanned(ops::LiveDrop, span);\n-                        struct_span_err!(self.tcx.sess, span, E0493,\n-                                         \"destructors cannot be evaluated at compile-time\")\n-                            .span_label(span, format!(\"{}s cannot evaluate destructors\",\n-                                                      self.mode))\n-                            .emit();\n-                    }\n-                }\n-            }\n-\n-            match *kind {\n-                TerminatorKind::DropAndReplace { ref value, .. } => {\n-                    self.assign(place, ValueSource::DropAndReplace(value), location);\n-                    self.visit_operand(value, location);\n-                }\n-                _ => {}\n-            }\n-        } else {\n-            // Qualify any operands inside other terminators.\n-            self.super_terminator_kind(kind, location);\n-        }\n-    }\n-\n-    fn visit_assign(&mut self,\n-                    dest: &Place<'tcx>,\n-                    rvalue: &Rvalue<'tcx>,\n-                    location: Location) {\n-        debug!(\"visit_assign: dest={:?} rvalue={:?} location={:?}\", dest, rvalue, location);\n-        self.assign(dest, ValueSource::Rvalue(rvalue), location);\n-\n-        self.visit_rvalue(rvalue, location);\n-    }\n-\n-    fn visit_source_info(&mut self, source_info: &SourceInfo) {\n-        debug!(\"visit_source_info: source_info={:?}\", source_info);\n-        self.span = source_info.span;\n-    }\n-\n-    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n-        debug!(\"visit_statement: statement={:?} location={:?}\", statement, location);\n-        match statement.kind {\n-            StatementKind::Assign(..) => {\n-                self.super_statement(statement, location);\n-            }\n-            StatementKind::FakeRead(FakeReadCause::ForMatchedPlace, _) => {\n-                if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-                    self.tcx.sess.delay_span_bug(\n-                        self.span,\n-                        \"complex control flow is forbidden in a const context\",\n-                    );\n-                }\n-            }\n-            // FIXME(eddyb) should these really do nothing?\n-            StatementKind::FakeRead(..) |\n-            StatementKind::SetDiscriminant { .. } |\n-            StatementKind::StorageLive(_) |\n-            StatementKind::StorageDead(_) |\n-            StatementKind::InlineAsm {..} |\n-            StatementKind::Retag { .. } |\n-            StatementKind::AscribeUserType(..) |\n-            StatementKind::Nop => {}\n-        }\n-    }\n-}\n-\n-pub fn provide(providers: &mut Providers<'_>) {\n-    *providers = Providers {\n-        mir_const_qualif,\n-        ..*providers\n-    };\n-}\n-\n-// FIXME(eddyb) this is only left around for the validation logic\n-// in `promote_consts`, see the comment in `validate_operand`.\n-pub(super) const QUALIF_ERROR_BIT: u8 = 1 << 2;\n-\n-fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> u8 {\n-    // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n-    // cannot yet be stolen), because `mir_validated()`, which steals\n-    // from `mir_const(), forces this query to execute before\n-    // performing the steal.\n-    let body = &tcx.mir_const(def_id).borrow();\n-\n-    if body.return_ty().references_error() {\n-        tcx.sess.delay_span_bug(body.span, \"mir_const_qualif: MIR had errors\");\n-        return QUALIF_ERROR_BIT;\n-    }\n-\n-    Checker::new(tcx, def_id, body, Mode::Const).check_const()\n-}\n-\n-pub struct QualifyAndPromoteConstants<'tcx> {\n-    pub promoted: Cell<IndexVec<Promoted, Body<'tcx>>>,\n-}\n-\n-impl<'tcx> Default for QualifyAndPromoteConstants<'tcx> {\n-    fn default() -> Self {\n-        QualifyAndPromoteConstants {\n-            promoted: Cell::new(IndexVec::new()),\n-        }\n-    }\n-}\n-\n-impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants<'tcx> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        // There's not really any point in promoting errorful MIR.\n-        if body.return_ty().references_error() {\n-            tcx.sess.delay_span_bug(body.span, \"QualifyAndPromoteConstants: MIR had errors\");\n-            return;\n-        }\n-\n-        if src.promoted.is_some() {\n-            return;\n-        }\n-\n-        let def_id = src.def_id();\n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-\n-        let mode = determine_mode(tcx, hir_id, def_id);\n-\n-        debug!(\"run_pass: mode={:?}\", mode);\n-        if let Mode::NonConstFn = mode {\n-            // No need to const-check a non-const `fn` now that we don't do promotion here.\n-            return;\n-        } else if let Mode::ConstFn = mode {\n-            let mut checker = Checker::new(tcx, def_id, body, mode);\n-            let use_min_const_fn_checks =\n-                !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you &&\n-                tcx.is_min_const_fn(def_id);\n-            if use_min_const_fn_checks {\n-                // Enforce `min_const_fn` for stable `const fn`s.\n-                use super::qualify_min_const_fn::is_min_const_fn;\n-                if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n-                    error_min_const_fn_violation(tcx, span, err);\n-                    return;\n-                }\n-            }\n-\n-            // `check_const` should not produce any errors, but better safe than sorry\n-            // FIXME(#53819)\n-            // Enforce a constant-like CFG for `const fn`.\n-            checker.check_const();\n-        } else {\n-            check_short_circuiting_in_const_local(tcx, body, mode);\n-\n-            match mode {\n-                Mode::Const => tcx.mir_const_qualif(def_id),\n-                _ => Checker::new(tcx, def_id, body, mode).check_const(),\n-            };\n-        }\n-\n-        if mode == Mode::Static && !tcx.has_attr(def_id, sym::thread_local) {\n-            // `static`s (not `static mut`s) which are not `#[thread_local]` must be `Sync`.\n-            check_static_is_sync(tcx, body, hir_id);\n-        }\n-    }\n-}\n-\n-fn determine_mode(tcx: TyCtxt<'_>, hir_id: HirId, def_id: DefId) -> Mode {\n-    match tcx.hir().body_owner_kind(hir_id) {\n-        hir::BodyOwnerKind::Closure => Mode::NonConstFn,\n-        hir::BodyOwnerKind::Fn if tcx.is_const_fn(def_id) => Mode::ConstFn,\n-        hir::BodyOwnerKind::Fn => Mode::NonConstFn,\n-        hir::BodyOwnerKind::Const => Mode::Const,\n-        hir::BodyOwnerKind::Static(hir::Mutability::Immutable) => Mode::Static,\n-        hir::BodyOwnerKind::Static(hir::Mutability::Mutable) => Mode::StaticMut,\n-    }\n-}\n-\n-fn error_min_const_fn_violation(tcx: TyCtxt<'_>, span: Span, msg: Cow<'_, str>) {\n-    struct_span_err!(tcx.sess, span, E0723, \"{}\", msg)\n-        .note(\"for more information, see issue https://github.com/rust-lang/rust/issues/57563\")\n-        .help(\"add `#![feature(const_fn)]` to the crate attributes to enable\")\n-        .emit();\n-}\n-\n-fn check_short_circuiting_in_const_local(tcx: TyCtxt<'_>, body: &mut Body<'tcx>, mode: Mode) {\n-    if body.control_flow_destroyed.is_empty() {\n-        return;\n-    }\n-\n-    let mut locals = body.vars_iter();\n-    if let Some(local) = locals.next() {\n-        let span = body.local_decls[local].source_info.span;\n-        let mut error = tcx.sess.struct_span_err(\n-            span,\n-            &format!(\n-                \"new features like let bindings are not permitted in {}s \\\n-                which also use short circuiting operators\",\n-                mode,\n-            ),\n-        );\n-        for (span, kind) in body.control_flow_destroyed.iter() {\n-            error.span_note(\n-                *span,\n-                &format!(\"use of {} here does not actually short circuit due to \\\n-                the const evaluator presently not being able to do control flow. \\\n-                See https://github.com/rust-lang/rust/issues/49146 for more \\\n-                information.\", kind),\n-            );\n-        }\n-        for local in locals {\n-            let span = body.local_decls[local].source_info.span;\n-            error.span_note(span, \"more locals defined here\");\n-        }\n-        error.emit();\n-    }\n-}\n-\n-fn check_static_is_sync(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, hir_id: HirId) {\n-    let ty = body.return_ty();\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let cause = traits::ObligationCause::new(body.span, hir_id, traits::SharedStatic);\n-        let mut fulfillment_cx = traits::FulfillmentContext::new();\n-        let sync_def_id = tcx.require_lang_item(lang_items::SyncTraitLangItem, Some(body.span));\n-        fulfillment_cx.register_bound(&infcx, ty::ParamEnv::empty(), ty, sync_def_id, cause);\n-        if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n-            infcx.report_fulfillment_errors(&err, None, false);\n-        }\n-    });\n-}\n-\n-fn validator_mismatch(\n-    tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n-    mut old_errors: Vec<(Span, String)>,\n-    mut new_errors: Vec<(Span, String)>,\n-) {\n-    error!(\"old validator: {:?}\", old_errors);\n-    error!(\"new validator: {:?}\", new_errors);\n-\n-    // ICE on nightly if the validators do not emit exactly the same errors.\n-    // Users can supress this panic with an unstable compiler flag (hopefully after\n-    // filing an issue).\n-    let opts = &tcx.sess.opts;\n-    let strict_validation_enabled = opts.unstable_features.is_nightly_build()\n-        && !opts.debugging_opts.suppress_const_validation_back_compat_ice;\n-\n-    if !strict_validation_enabled {\n-        return;\n-    }\n-\n-    // If this difference would cause a regression from the old to the new or vice versa, trigger\n-    // the ICE.\n-    if old_errors.is_empty() || new_errors.is_empty() {\n-        span_bug!(body.span, \"{}\", VALIDATOR_MISMATCH_ERR);\n-    }\n-\n-    // HACK: Borrows that would allow mutation are forbidden in const contexts, but they cause the\n-    // new validator to be more conservative about when a dropped local has been moved out of.\n-    //\n-    // Supress the mismatch ICE in cases where the validators disagree only on the number of\n-    // `LiveDrop` errors and both observe the same sequence of `MutBorrow`s.\n-\n-    let is_live_drop = |(_, s): &mut (_, String)| s.starts_with(\"LiveDrop\");\n-    let is_mut_borrow = |(_, s): &&(_, String)| s.starts_with(\"MutBorrow\");\n-\n-    let old_live_drops: Vec<_> = old_errors.drain_filter(is_live_drop).collect();\n-    let new_live_drops: Vec<_> = new_errors.drain_filter(is_live_drop).collect();\n-\n-    let only_live_drops_differ = old_live_drops != new_live_drops && old_errors == new_errors;\n-\n-    let old_mut_borrows = old_errors.iter().filter(is_mut_borrow);\n-    let new_mut_borrows = new_errors.iter().filter(is_mut_borrow);\n-\n-    let at_least_one_mut_borrow = old_mut_borrows.clone().next().is_some();\n-\n-    if only_live_drops_differ && at_least_one_mut_borrow && old_mut_borrows.eq(new_mut_borrows) {\n-        return;\n-    }\n-\n-    span_bug!(body.span, \"{}\", VALIDATOR_MISMATCH_ERR);\n-}\n-\n-const VALIDATOR_MISMATCH_ERR: &str =\n-    r\"Disagreement between legacy and dataflow-based const validators.\n-    After filing an issue, use `-Zsuppress-const-validation-back-compat-ice` to compile your code.\";"}, {"sha": "1a4fc72e8178647074a35c253deb89a1bf47baca", "filename": "src/test/compile-fail/consts/const-fn-error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Ftest%2Fcompile-fail%2Fconsts%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Ftest%2Fcompile-fail%2Fconsts%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconsts%2Fconst-fn-error.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -9,6 +9,7 @@ const fn f(x: usize) -> usize {\n         //~| ERROR E0017\n         //~| ERROR E0080\n         //~| ERROR E0744\n+        //~| ERROR E0019\n         sum += i;\n     }\n     sum"}, {"sha": "ee37aaa5e13b943c7b715e3d42f24c47e210454a", "filename": "src/test/compile-fail/issue-52443.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -11,4 +11,5 @@ fn main() {\n     //~| ERROR `for` is not allowed in a `const`\n     //~| ERROR references in constants may only refer to immutable values\n     //~| ERROR evaluation of constant value failed\n+    //~| ERROR constant contains unimplemented expression type\n }"}, {"sha": "b1c058eac9e4bfc213d0c38553bdb9c1dc64dfc8", "filename": "src/test/ui/consts/const-eval/issue-65394.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -1,7 +1,10 @@\n-// Test for absence of validation mismatch ICE in #65394\n+// This test originated from #65394. We conservatively assume that `x` is still `LiveDrop` even\n+// after it has been moved because a mutable reference to it exists at some point in the const body.\n+//\n+// We will likely have to change this behavior before we allow `&mut` in a `const`.\n \n const _: Vec<i32> = {\n-    let mut x = Vec::<i32>::new();\n+    let mut x = Vec::<i32>::new(); //~ ERROR destructors cannot be evaluated at compile-time\n     let r = &mut x; //~ ERROR references in constants may only refer to immutable values\n     let y = x;\n     y"}, {"sha": "acf5cbaede66597b552d4df556447e32495be118", "filename": "src/test/ui/consts/const-eval/issue-65394.stderr", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -1,11 +1,16 @@\n error[E0017]: references in constants may only refer to immutable values\n-  --> $DIR/issue-65394.rs:5:13\n+  --> $DIR/issue-65394.rs:8:13\n    |\n LL |     let r = &mut x;\n    |             ^^^^^^ constants require immutable values\n \n-[ERROR rustc_mir::transform::qualify_consts] old validator: [($DIR/issue-65394.rs:5:13: 5:19, \"MutBorrow(Mut { allow_two_phase_borrow: false })\")]\n-[ERROR rustc_mir::transform::qualify_consts] new validator: [($DIR/issue-65394.rs:5:13: 5:19, \"MutBorrow(Mut { allow_two_phase_borrow: false })\"), ($DIR/issue-65394.rs:4:9: 4:14, \"LiveDrop\")]\n-error: aborting due to previous error\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/issue-65394.rs:7:9\n+   |\n+LL |     let mut x = Vec::<i32>::new();\n+   |         ^^^^^ constants cannot evaluate destructors\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0017`.\n+Some errors have detailed explanations: E0017, E0493.\n+For more information about an error, try `rustc --explain E0017`."}, {"sha": "76d62f069f37890bb45a10a74c09bceb83ed5477", "filename": "src/test/ui/consts/miri_unleashed/enum_discriminants.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fenum_discriminants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0c640e0ee5a9ad365e78e3c62239b3d65b7045/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fenum_discriminants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fenum_discriminants.rs?ref=0f0c640e0ee5a9ad365e78e3c62239b3d65b7045", "patch": "@@ -1,6 +1,9 @@\n-// compile-flags: -Zunleash-the-miri-inside-of-you\n+// compile-flags: -Zunleash-the-miri-inside-of-you -Awarnings\n // run-pass\n \n+// miri unleashed warnings are not useful and change frequently, so they are silenced above.\n+#![feature(const_panic)]\n+\n //! Make sure that we read and write enum discriminants correctly for corner cases caused\n //! by layout optimizations.\n \n@@ -21,7 +24,7 @@ const OVERFLOW: usize = {\n     }\n \n     let x = Foo::B;\n-    match x { //~ WARNING skipping const checks\n+    match x {\n         Foo::B => 0,\n         _ => panic!(),\n     }\n@@ -86,21 +89,17 @@ const MORE_OVERFLOW: usize = {\n     }\n \n     if let E1::V2 { .. } = (E1::V1 { f: true }) {\n-        //~^ WARNING skipping const checks\n         unreachable!()\n     }\n     if let E1::V1 { .. } = (E1::V1 { f: true }) {\n-        //~^ WARNING skipping const checks\n     } else {\n         unreachable!()\n     }\n \n     if let E2::V1 { .. } = E2::V3::<Infallible> {\n-        //~^ WARNING skipping const checks\n         unreachable!()\n     }\n     if let E2::V3 { .. } = E2::V3::<Infallible> {\n-        //~^ WARNING skipping const checks\n     } else {\n         unreachable!()\n     }"}, {"sha": "b7fce223af80a6afc56f94e57a908db85f51d802", "filename": "src/test/ui/consts/miri_unleashed/enum_discriminants.stderr", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d8014582b843d8722795b06586ef9c2042094963/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fenum_discriminants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8014582b843d8722795b06586ef9c2042094963/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fenum_discriminants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fenum_discriminants.stderr?ref=d8014582b843d8722795b06586ef9c2042094963", "patch": "@@ -1,47 +0,0 @@\n-warning: skipping const checks\n-  --> $DIR/enum_discriminants.rs:24:5\n-   |\n-LL | /     match x {\n-LL | |         Foo::B => 0,\n-LL | |         _ => panic!(),\n-LL | |     }\n-   | |_____^\n-\n-warning: skipping const checks\n-  --> $DIR/enum_discriminants.rs:88:5\n-   |\n-LL | /     if let E1::V2 { .. } = (E1::V1 { f: true }) {\n-LL | |\n-LL | |         unreachable!()\n-LL | |     }\n-   | |_____^\n-\n-warning: skipping const checks\n-  --> $DIR/enum_discriminants.rs:92:5\n-   |\n-LL | /     if let E1::V1 { .. } = (E1::V1 { f: true }) {\n-LL | |\n-LL | |     } else {\n-LL | |         unreachable!()\n-LL | |     }\n-   | |_____^\n-\n-warning: skipping const checks\n-  --> $DIR/enum_discriminants.rs:98:5\n-   |\n-LL | /     if let E2::V1 { .. } = E2::V3::<Infallible> {\n-LL | |\n-LL | |         unreachable!()\n-LL | |     }\n-   | |_____^\n-\n-warning: skipping const checks\n-  --> $DIR/enum_discriminants.rs:102:5\n-   |\n-LL | /     if let E2::V3 { .. } = E2::V3::<Infallible> {\n-LL | |\n-LL | |     } else {\n-LL | |         unreachable!()\n-LL | |     }\n-   | |_____^\n-"}]}