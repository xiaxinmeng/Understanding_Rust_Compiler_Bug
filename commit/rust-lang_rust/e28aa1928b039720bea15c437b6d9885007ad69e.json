{"sha": "e28aa1928b039720bea15c437b6d9885007ad69e", "node_id": "C_kwDOAAsO6NoAKGUyOGFhMTkyOGIwMzk3MjBiZWExNWM0MzdiNmQ5ODg1MDA3YWQ2OWU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-03T12:19:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-03T12:19:02Z"}, "message": "Merge #10439\n\n10439: fix: fix insert_use incorrectly merging glob imports r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/6800\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "5f9475fc25ad8e34fddeda2b3c118f277d4eaedc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f9475fc25ad8e34fddeda2b3c118f277d4eaedc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e28aa1928b039720bea15c437b6d9885007ad69e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhWZ+2CRBK7hj4Ov3rIwAA/ccIAI9wVhJ+spvcGa9R1Mbr4FHo\n9OFiuOJmu0R6dXbCmFcG92bGopLJvkyDXYrIRzdn33Re808AlLC6l3wQKtvMtK55\nJeBkwlc6cVe33uSvnZnUIeokDG4FF571H33pc1spxH6uVHj2N4PfYSHITmjSMNTQ\nK/WgGTQl2zLUVT9X2+Q9x4Stgc/PVEu/fLRxkbePXhIuEFA/9qVhS0rNi2FNvjs7\neOaMvMgUyiauGvqJSfN5AGpXum0ez5E1CzEH46JrHuDr+p83x9ICFkIE+gRezkcM\nFj27mkMo6BJ+lHrfyRIoacuu6placseu4kTHK1geQiYy88DwNh0CYfW0lB5rWC8=\n=J0B8\n-----END PGP SIGNATURE-----\n", "payload": "tree 5f9475fc25ad8e34fddeda2b3c118f277d4eaedc\nparent ebe6c38a44ebeebeceed8159b149ce9399d7b883\nparent 5b0c91d11844ee3975476cd2c7bf42af480d7781\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1633263542 +0000\ncommitter GitHub <noreply@github.com> 1633263542 +0000\n\nMerge #10439\n\n10439: fix: fix insert_use incorrectly merging glob imports r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/6800\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e28aa1928b039720bea15c437b6d9885007ad69e", "html_url": "https://github.com/rust-lang/rust/commit/e28aa1928b039720bea15c437b6d9885007ad69e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e28aa1928b039720bea15c437b6d9885007ad69e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebe6c38a44ebeebeceed8159b149ce9399d7b883", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebe6c38a44ebeebeceed8159b149ce9399d7b883", "html_url": "https://github.com/rust-lang/rust/commit/ebe6c38a44ebeebeceed8159b149ce9399d7b883"}, {"sha": "5b0c91d11844ee3975476cd2c7bf42af480d7781", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b0c91d11844ee3975476cd2c7bf42af480d7781", "html_url": "https://github.com/rust-lang/rust/commit/5b0c91d11844ee3975476cd2c7bf42af480d7781"}], "stats": {"total": 195, "additions": 103, "deletions": 92}, "files": [{"sha": "9889dd772ea7f20ec6eb7d59b24cc36b17748f03", "filename": "crates/ide_db/src/helpers/insert_use.rs", "status": "modified", "additions": 76, "deletions": 77, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/e28aa1928b039720bea15c437b6d9885007ad69e/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28aa1928b039720bea15c437b6d9885007ad69e/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs?ref=e28aa1928b039720bea15c437b6d9885007ad69e", "patch": "@@ -1,4 +1,4 @@\n-//! Handle syntactic aspects of inserting a new `use`.\n+//! Handle syntactic aspects of inserting a new `use` item.\n #[cfg(test)]\n mod tests;\n \n@@ -103,81 +103,6 @@ impl ImportScope {\n             ImportScope::Block(block) => ImportScope::Block(block.clone_for_update()),\n         }\n     }\n-\n-    fn guess_granularity_from_scope(&self) -> ImportGranularityGuess {\n-        // The idea is simple, just check each import as well as the import and its precedent together for\n-        // whether they fulfill a granularity criteria.\n-        let use_stmt = |item| match item {\n-            ast::Item::Use(use_) => {\n-                let use_tree = use_.use_tree()?;\n-                Some((use_tree, use_.visibility(), use_.attrs()))\n-            }\n-            _ => None,\n-        };\n-        let mut use_stmts = match self {\n-            ImportScope::File(f) => f.items(),\n-            ImportScope::Module(m) => m.items(),\n-            ImportScope::Block(b) => b.items(),\n-        }\n-        .filter_map(use_stmt);\n-        let mut res = ImportGranularityGuess::Unknown;\n-        let (mut prev, mut prev_vis, mut prev_attrs) = match use_stmts.next() {\n-            Some(it) => it,\n-            None => return res,\n-        };\n-        loop {\n-            if let Some(use_tree_list) = prev.use_tree_list() {\n-                if use_tree_list.use_trees().any(|tree| tree.use_tree_list().is_some()) {\n-                    // Nested tree lists can only occur in crate style, or with no proper style being enforced in the file.\n-                    break ImportGranularityGuess::Crate;\n-                } else {\n-                    // Could still be crate-style so continue looking.\n-                    res = ImportGranularityGuess::CrateOrModule;\n-                }\n-            }\n-\n-            let (curr, curr_vis, curr_attrs) = match use_stmts.next() {\n-                Some(it) => it,\n-                None => break res,\n-            };\n-            if eq_visibility(prev_vis, curr_vis.clone()) && eq_attrs(prev_attrs, curr_attrs.clone())\n-            {\n-                if let Some((prev_path, curr_path)) = prev.path().zip(curr.path()) {\n-                    if let Some((prev_prefix, _)) = common_prefix(&prev_path, &curr_path) {\n-                        if prev.use_tree_list().is_none() && curr.use_tree_list().is_none() {\n-                            let prefix_c = prev_prefix.qualifiers().count();\n-                            let curr_c = curr_path.qualifiers().count() - prefix_c;\n-                            let prev_c = prev_path.qualifiers().count() - prefix_c;\n-                            if curr_c == 1 && prev_c == 1 {\n-                                // Same prefix, only differing in the last segment and no use tree lists so this has to be of item style.\n-                                break ImportGranularityGuess::Item;\n-                            } else {\n-                                // Same prefix and no use tree list but differs in more than one segment at the end. This might be module style still.\n-                                res = ImportGranularityGuess::ModuleOrItem;\n-                            }\n-                        } else {\n-                            // Same prefix with item tree lists, has to be module style as it\n-                            // can't be crate style since the trees wouldn't share a prefix then.\n-                            break ImportGranularityGuess::Module;\n-                        }\n-                    }\n-                }\n-            }\n-            prev = curr;\n-            prev_vis = curr_vis;\n-            prev_attrs = curr_attrs;\n-        }\n-    }\n-}\n-\n-#[derive(PartialEq, PartialOrd, Debug, Clone, Copy)]\n-enum ImportGranularityGuess {\n-    Unknown,\n-    Item,\n-    Module,\n-    ModuleOrItem,\n-    Crate,\n-    CrateOrModule,\n }\n \n /// Insert an import path into the given file/node. A `merge` value of none indicates that no import merging is allowed to occur.\n@@ -189,7 +114,7 @@ pub fn insert_use(scope: &ImportScope, path: ast::Path, cfg: &InsertUseConfig) {\n         ImportGranularity::Item | ImportGranularity::Preserve => None,\n     };\n     if !cfg.enforce_granularity {\n-        let file_granularity = scope.guess_granularity_from_scope();\n+        let file_granularity = guess_granularity_from_scope(scope);\n         mb = match file_granularity {\n             ImportGranularityGuess::Unknown => mb,\n             ImportGranularityGuess::Item => None,\n@@ -271,6 +196,80 @@ impl ImportGroup {\n     }\n }\n \n+#[derive(PartialEq, PartialOrd, Debug, Clone, Copy)]\n+enum ImportGranularityGuess {\n+    Unknown,\n+    Item,\n+    Module,\n+    ModuleOrItem,\n+    Crate,\n+    CrateOrModule,\n+}\n+\n+fn guess_granularity_from_scope(scope: &ImportScope) -> ImportGranularityGuess {\n+    // The idea is simple, just check each import as well as the import and its precedent together for\n+    // whether they fulfill a granularity criteria.\n+    let use_stmt = |item| match item {\n+        ast::Item::Use(use_) => {\n+            let use_tree = use_.use_tree()?;\n+            Some((use_tree, use_.visibility(), use_.attrs()))\n+        }\n+        _ => None,\n+    };\n+    let mut use_stmts = match scope {\n+        ImportScope::File(f) => f.items(),\n+        ImportScope::Module(m) => m.items(),\n+        ImportScope::Block(b) => b.items(),\n+    }\n+    .filter_map(use_stmt);\n+    let mut res = ImportGranularityGuess::Unknown;\n+    let (mut prev, mut prev_vis, mut prev_attrs) = match use_stmts.next() {\n+        Some(it) => it,\n+        None => return res,\n+    };\n+    loop {\n+        if let Some(use_tree_list) = prev.use_tree_list() {\n+            if use_tree_list.use_trees().any(|tree| tree.use_tree_list().is_some()) {\n+                // Nested tree lists can only occur in crate style, or with no proper style being enforced in the file.\n+                break ImportGranularityGuess::Crate;\n+            } else {\n+                // Could still be crate-style so continue looking.\n+                res = ImportGranularityGuess::CrateOrModule;\n+            }\n+        }\n+\n+        let (curr, curr_vis, curr_attrs) = match use_stmts.next() {\n+            Some(it) => it,\n+            None => break res,\n+        };\n+        if eq_visibility(prev_vis, curr_vis.clone()) && eq_attrs(prev_attrs, curr_attrs.clone()) {\n+            if let Some((prev_path, curr_path)) = prev.path().zip(curr.path()) {\n+                if let Some((prev_prefix, _)) = common_prefix(&prev_path, &curr_path) {\n+                    if prev.use_tree_list().is_none() && curr.use_tree_list().is_none() {\n+                        let prefix_c = prev_prefix.qualifiers().count();\n+                        let curr_c = curr_path.qualifiers().count() - prefix_c;\n+                        let prev_c = prev_path.qualifiers().count() - prefix_c;\n+                        if curr_c == 1 && prev_c == 1 {\n+                            // Same prefix, only differing in the last segment and no use tree lists so this has to be of item style.\n+                            break ImportGranularityGuess::Item;\n+                        } else {\n+                            // Same prefix and no use tree list but differs in more than one segment at the end. This might be module style still.\n+                            res = ImportGranularityGuess::ModuleOrItem;\n+                        }\n+                    } else {\n+                        // Same prefix with item tree lists, has to be module style as it\n+                        // can't be crate style since the trees wouldn't share a prefix then.\n+                        break ImportGranularityGuess::Module;\n+                    }\n+                }\n+            }\n+        }\n+        prev = curr;\n+        prev_vis = curr_vis;\n+        prev_attrs = curr_attrs;\n+    }\n+}\n+\n fn insert_use_(\n     scope: &ImportScope,\n     insert_path: &ast::Path,"}, {"sha": "f3b9c7130f42e9640ca53984fb10fcd21cc96ba8", "filename": "crates/ide_db/src/helpers/insert_use/tests.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e28aa1928b039720bea15c437b6d9885007ad69e/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28aa1928b039720bea15c437b6d9885007ad69e/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs?ref=e28aa1928b039720bea15c437b6d9885007ad69e", "patch": "@@ -612,6 +612,7 @@ fn merge_mod_into_glob() {\n \n #[test]\n fn merge_self_glob() {\n+    cov_mark::check!(merge_self_glob);\n     check_with_config(\n         \"self\",\n         r\"use self::*;\",\n@@ -627,6 +628,17 @@ fn merge_self_glob() {\n     // FIXME: have it emit `use {self, *}`?\n }\n \n+#[test]\n+fn merge_glob() {\n+    check_crate(\n+        \"syntax::SyntaxKind\",\n+        r\"\n+use syntax::{SyntaxKind::*};\",\n+        r\"\n+use syntax::{SyntaxKind::{*, self}};\",\n+    )\n+}\n+\n #[test]\n fn merge_glob_nested() {\n     check_crate(\n@@ -931,5 +943,5 @@ fn check_merge_only_fail(ra_fixture0: &str, ra_fixture1: &str, mb: MergeBehavior\n fn check_guess(ra_fixture: &str, expected: ImportGranularityGuess) {\n     let syntax = ast::SourceFile::parse(ra_fixture).tree().syntax().clone();\n     let file = super::ImportScope::from(syntax).unwrap();\n-    assert_eq!(file.guess_granularity_from_scope(), expected);\n+    assert_eq!(super::guess_granularity_from_scope(&file), expected);\n }"}, {"sha": "6a7a9b8f61c689bb8eed7d947c76702e2974339a", "filename": "crates/ide_db/src/helpers/merge_imports.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e28aa1928b039720bea15c437b6d9885007ad69e/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28aa1928b039720bea15c437b6d9885007ad69e/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs?ref=e28aa1928b039720bea15c437b6d9885007ad69e", "patch": "@@ -19,7 +19,6 @@ pub enum MergeBehavior {\n }\n \n impl MergeBehavior {\n-    #[inline]\n     fn is_tree_allowed(&self, tree: &ast::UseTree) -> bool {\n         match self {\n             MergeBehavior::Crate => true,\n@@ -114,7 +113,7 @@ fn recursive_merge(\n                 let rhs_path = rhs_path?;\n                 let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n                 if lhs_prefix == lhs_path && rhs_prefix == rhs_path {\n-                    let tree_is_self = |tree: ast::UseTree| {\n+                    let tree_is_self = |tree: &ast::UseTree| {\n                         tree.path().as_ref().map(path_is_self).unwrap_or(false)\n                     };\n                     // Check if only one of the two trees has a tree list, and\n@@ -123,7 +122,7 @@ fn recursive_merge(\n                     // the list is already included in the other one via `self`.\n                     let tree_contains_self = |tree: &ast::UseTree| {\n                         tree.use_tree_list()\n-                            .map(|tree_list| tree_list.use_trees().any(tree_is_self))\n+                            .map(|tree_list| tree_list.use_trees().any(|it| tree_is_self(&it)))\n                             .unwrap_or(false)\n                     };\n                     match (tree_contains_self(lhs_t), tree_contains_self(&rhs_t)) {\n@@ -141,17 +140,18 @@ fn recursive_merge(\n                     // glob import of said module see the `merge_self_glob` or\n                     // `merge_mod_into_glob` tests.\n                     if lhs_t.star_token().is_some() || rhs_t.star_token().is_some() {\n-                        *lhs_t = make::use_tree(\n-                            make::path_unqualified(make::path_segment_self()),\n-                            None,\n-                            None,\n-                            false,\n-                        );\n-                        use_trees.insert(idx, make::use_tree_glob());\n-                        continue;\n-                    }\n-\n-                    if lhs_t.use_tree_list().is_none() && rhs_t.use_tree_list().is_none() {\n+                        if tree_is_self(lhs_t) || tree_is_self(&rhs_t) {\n+                            cov_mark::hit!(merge_self_glob);\n+                            *lhs_t = make::use_tree(\n+                                make::path_unqualified(make::path_segment_self()),\n+                                None,\n+                                None,\n+                                false,\n+                            );\n+                            use_trees.insert(idx, make::use_tree_glob());\n+                            continue;\n+                        }\n+                    } else if lhs_t.use_tree_list().is_none() && rhs_t.use_tree_list().is_none() {\n                         continue;\n                     }\n                 }"}]}