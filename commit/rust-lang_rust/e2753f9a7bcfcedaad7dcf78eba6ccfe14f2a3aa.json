{"sha": "e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNzUzZjlhN2JjZmNlZGFhZDdkY2Y3OGViYTZjY2ZlMTRmMmEzYWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-16T09:58:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-16T09:58:49Z"}, "message": "Auto merge of #6662 - Y-Nak:default-numeric-fallback, r=flip1995\n\nNew lint: default_numeric_fallback\n\nfixes #6064\nr? `@flip1995`\n\nAs we discussed in [here](https://rust-lang.zulipchat.com/#narrow/stream/257328-clippy/topic/Issue.20.236064/near/224647188) and [here](https://rust-lang.zulipchat.com/#narrow/stream/257328-clippy/topic/Issue.20clippy.236064/near/224746333),   I start implementing this lint from the strictest version.\nIn this PR, I'll allow the below two cases to pass the lint to reduce FPs.\n\n1. Appearances of unsuffixed numeric literals in `Local` if `Local` has a type annotation, for example:\n```rust\n// Good.\nlet x: i32 = 1;\n\n// Also good.\nlet x: (i32, i32) = if cond {\n   (1, 2)\n} else {\n   (2, 3)\n};\n```\n\n2. Appearances of unsuffixed numeric literals in args of `Call` or `MethodCall`  if corresponding arguments of their signature have concrete types, for example:\n```rust\nfn foo_mono(x: i32) -> i32 {\n    x\n}\n\nfn foo_poly<T>(t: T) -> t {\n    t\n}\n\n// Good.\nlet x = foo_mono(13);\n\n// Still bad.\nlet x: i32 = foo_poly(13);\n```\n\nchangelog: Added restriction lint: `default_numeric_fallback`", "tree": {"sha": "a8eff8d034fdb788f305cfd8136667a499d3f145", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8eff8d034fdb788f305cfd8136667a499d3f145"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa", "html_url": "https://github.com/rust-lang/rust/commit/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f28c54cd08b02ba89648f80b67f512f878e9dce2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f28c54cd08b02ba89648f80b67f512f878e9dce2", "html_url": "https://github.com/rust-lang/rust/commit/f28c54cd08b02ba89648f80b67f512f878e9dce2"}, {"sha": "9b0c1ebc183bbf0fab5fbbe5ac8b2f94e5e56b87", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b0c1ebc183bbf0fab5fbbe5ac8b2f94e5e56b87", "html_url": "https://github.com/rust-lang/rust/commit/9b0c1ebc183bbf0fab5fbbe5ac8b2f94e5e56b87"}], "stats": {"total": 525, "additions": 525, "deletions": 0}, "files": [{"sha": "c59eae5d1c2fd12d500b78402abd5606dc15f038", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa", "patch": "@@ -2027,6 +2027,7 @@ Released 2018-09-13\n [`debug_assert_with_mut_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#debug_assert_with_mut_call\n [`decimal_literal_representation`]: https://rust-lang.github.io/rust-clippy/master/index.html#decimal_literal_representation\n [`declare_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#declare_interior_mutable_const\n+[`default_numeric_fallback`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_numeric_fallback\n [`default_trait_access`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_trait_access\n [`deprecated_cfg_attr`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_cfg_attr\n [`deprecated_semver`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_semver"}, {"sha": "6ace9aa6bdfc0d1e06c4bfc1c7906e6b4488a7fc", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa", "patch": "@@ -0,0 +1,237 @@\n+use rustc_ast::ast::{LitFloatType, LitIntType, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_hir::{\n+    intravisit::{walk_expr, walk_stmt, NestedVisitorMap, Visitor},\n+    Body, Expr, ExprKind, HirId, Lit, Stmt, StmtKind,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::{\n+    hir::map::Map,\n+    ty::{self, FloatTy, IntTy, PolyFnSig, Ty},\n+};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{snippet, span_lint_and_sugg};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of unconstrained numeric literals which may cause default numeric fallback in type\n+    /// inference.\n+    ///\n+    /// Default numeric fallback means that if numeric types have not yet been bound to concrete\n+    /// types at the end of type inference, then integer type is bound to `i32`, and similarly\n+    /// floating type is bound to `f64`.\n+    ///\n+    /// See [RFC0212](https://github.com/rust-lang/rfcs/blob/master/text/0212-restore-int-fallback.md) for more information about the fallback.\n+    ///\n+    /// **Why is this bad?** For those who are very careful about types, default numeric fallback\n+    /// can be a pitfall that cause unexpected runtime behavior.\n+    ///\n+    /// **Known problems:** This lint can only be allowed at the function level or above.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let i = 10;\n+    /// let f = 1.23;\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let i = 10i32;\n+    /// let f = 1.23f64;\n+    /// ```\n+    pub DEFAULT_NUMERIC_FALLBACK,\n+    restriction,\n+    \"usage of unconstrained numeric literals which may cause default numeric fallback.\"\n+}\n+\n+declare_lint_pass!(DefaultNumericFallback => [DEFAULT_NUMERIC_FALLBACK]);\n+\n+impl LateLintPass<'_> for DefaultNumericFallback {\n+    fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n+        let mut visitor = NumericFallbackVisitor::new(cx);\n+        visitor.visit_body(body);\n+    }\n+}\n+\n+struct NumericFallbackVisitor<'a, 'tcx> {\n+    /// Stack manages type bound of exprs. The top element holds current expr type.\n+    ty_bounds: Vec<TyBound<'tcx>>,\n+\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> NumericFallbackVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n+        Self {\n+            ty_bounds: vec![TyBound::Nothing],\n+            cx,\n+        }\n+    }\n+\n+    /// Check whether a passed literal has potential to cause fallback or not.\n+    fn check_lit(&self, lit: &Lit, lit_ty: Ty<'tcx>) {\n+        if_chain! {\n+                if let Some(ty_bound) = self.ty_bounds.last();\n+                if matches!(lit.node,\n+                            LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed));\n+                if !ty_bound.is_integral();\n+                then {\n+                    let suffix = match lit_ty.kind() {\n+                        ty::Int(IntTy::I32) => \"i32\",\n+                        ty::Float(FloatTy::F64) => \"f64\",\n+                        // Default numeric fallback never results in other types.\n+                        _ => return,\n+                    };\n+\n+                    let sugg = format!(\"{}_{}\", snippet(self.cx, lit.span, \"\"), suffix);\n+                    span_lint_and_sugg(\n+                        self.cx,\n+                        DEFAULT_NUMERIC_FALLBACK,\n+                        lit.span,\n+                        \"default numeric fallback might occur\",\n+                        \"consider adding suffix\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    #[allow(clippy::too_many_lines)]\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        match &expr.kind {\n+            ExprKind::Call(func, args) => {\n+                if let Some(fn_sig) = fn_sig_opt(self.cx, func.hir_id) {\n+                    for (expr, bound) in args.iter().zip(fn_sig.skip_binder().inputs().iter()) {\n+                        // Push found arg type, then visit arg.\n+                        self.ty_bounds.push(TyBound::Ty(bound));\n+                        self.visit_expr(expr);\n+                        self.ty_bounds.pop();\n+                    }\n+                    return;\n+                }\n+            },\n+\n+            ExprKind::MethodCall(_, _, args, _) => {\n+                if let Some(def_id) = self.cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n+                    let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n+                    for (expr, bound) in args.iter().zip(fn_sig.inputs().iter()) {\n+                        self.ty_bounds.push(TyBound::Ty(bound));\n+                        self.visit_expr(expr);\n+                        self.ty_bounds.pop();\n+                    }\n+                    return;\n+                }\n+            },\n+\n+            ExprKind::Struct(qpath, fields, base) => {\n+                if_chain! {\n+                    if let Some(def_id) = self.cx.qpath_res(qpath, expr.hir_id).opt_def_id();\n+                    let ty = self.cx.tcx.type_of(def_id);\n+                    if let Some(adt_def) = ty.ty_adt_def();\n+                    if adt_def.is_struct();\n+                    if let Some(variant) = adt_def.variants.iter().next();\n+                    then {\n+                        let fields_def = &variant.fields;\n+\n+                        // Push field type then visit each field expr.\n+                        for field in fields.iter() {\n+                            let bound =\n+                                fields_def\n+                                    .iter()\n+                                    .find_map(|f_def| {\n+                                        if f_def.ident == field.ident\n+                                            { Some(self.cx.tcx.type_of(f_def.did)) }\n+                                        else { None }\n+                                    });\n+                            self.ty_bounds.push(bound.into());\n+                            self.visit_expr(field.expr);\n+                            self.ty_bounds.pop();\n+                        }\n+\n+                        // Visit base with no bound.\n+                        if let Some(base) = base {\n+                            self.ty_bounds.push(TyBound::Nothing);\n+                            self.visit_expr(base);\n+                            self.ty_bounds.pop();\n+                        }\n+                        return;\n+                    }\n+                }\n+            },\n+\n+            ExprKind::Lit(lit) => {\n+                let ty = self.cx.typeck_results().expr_ty(expr);\n+                self.check_lit(lit, ty);\n+                return;\n+            },\n+\n+            _ => {},\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n+        match stmt.kind {\n+            StmtKind::Local(local) => {\n+                if local.ty.is_some() {\n+                    self.ty_bounds.push(TyBound::Any)\n+                } else {\n+                    self.ty_bounds.push(TyBound::Nothing)\n+                }\n+            },\n+\n+            _ => self.ty_bounds.push(TyBound::Nothing),\n+        }\n+\n+        walk_stmt(self, stmt);\n+        self.ty_bounds.pop();\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+fn fn_sig_opt<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<PolyFnSig<'tcx>> {\n+    let node_ty = cx.typeck_results().node_type_opt(hir_id)?;\n+    // We can't use `TyS::fn_sig` because it automatically performs substs, this may result in FNs.\n+    match node_ty.kind() {\n+        ty::FnDef(def_id, _) => Some(cx.tcx.fn_sig(*def_id)),\n+        ty::FnPtr(fn_sig) => Some(*fn_sig),\n+        _ => None,\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum TyBound<'tcx> {\n+    Any,\n+    Ty(Ty<'tcx>),\n+    Nothing,\n+}\n+\n+impl<'tcx> TyBound<'tcx> {\n+    fn is_integral(self) -> bool {\n+        match self {\n+            TyBound::Any => true,\n+            TyBound::Ty(t) => t.is_integral(),\n+            TyBound::Nothing => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> From<Option<Ty<'tcx>>> for TyBound<'tcx> {\n+    fn from(v: Option<Ty<'tcx>>) -> Self {\n+        match v {\n+            Some(t) => TyBound::Ty(t),\n+            None => TyBound::Nothing,\n+        }\n+    }\n+}"}, {"sha": "407279806939bfb5a2ab5dbdf60bc53d231acee3", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa", "patch": "@@ -181,6 +181,7 @@ mod copy_iterator;\n mod create_dir;\n mod dbg_macro;\n mod default;\n+mod default_numeric_fallback;\n mod dereference;\n mod derive;\n mod disallowed_method;\n@@ -585,6 +586,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &dbg_macro::DBG_MACRO,\n         &default::DEFAULT_TRAIT_ACCESS,\n         &default::FIELD_REASSIGN_WITH_DEFAULT,\n+        &default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK,\n         &dereference::EXPLICIT_DEREF_METHODS,\n         &derive::DERIVE_HASH_XOR_EQ,\n         &derive::DERIVE_ORD_XOR_PARTIAL_ORD,\n@@ -1031,6 +1033,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box strings::StringAdd);\n     store.register_late_pass(|| box implicit_return::ImplicitReturn);\n     store.register_late_pass(|| box implicit_saturating_sub::ImplicitSaturatingSub);\n+    store.register_late_pass(|| box default_numeric_fallback::DefaultNumericFallback);\n \n     let msrv = conf.msrv.as_ref().and_then(|s| {\n         parse_msrv(s, None, None).or_else(|| {\n@@ -1265,6 +1268,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX),\n         LintId::of(&create_dir::CREATE_DIR),\n         LintId::of(&dbg_macro::DBG_MACRO),\n+        LintId::of(&default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK),\n         LintId::of(&else_if_without_else::ELSE_IF_WITHOUT_ELSE),\n         LintId::of(&exhaustive_items::EXHAUSTIVE_ENUMS),\n         LintId::of(&exhaustive_items::EXHAUSTIVE_STRUCTS),"}, {"sha": "0b3758952ac6d7d80a36c5a24d11efab76292135", "filename": "tests/ui/default_numeric_fallback.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa/tests%2Fui%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa/tests%2Fui%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback.rs?ref=e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa", "patch": "@@ -0,0 +1,135 @@\n+#![warn(clippy::default_numeric_fallback)]\n+#![allow(unused)]\n+#![allow(clippy::never_loop)]\n+#![allow(clippy::no_effect)]\n+#![allow(clippy::unnecessary_operation)]\n+\n+mod basic_expr {\n+    fn test() {\n+        // Should lint unsuffixed literals typed `i32`.\n+        let x = 22;\n+        let x = [1, 2, 3];\n+        let x = if true { (1, 2) } else { (3, 4) };\n+        let x = match 1 {\n+            1 => 1,\n+            _ => 2,\n+        };\n+\n+        // Should lint unsuffixed literals typed `f64`.\n+        let x = 0.12;\n+\n+        // Should NOT lint suffixed literals.\n+        let x = 22_i32;\n+        let x = 0.12_f64;\n+\n+        // Should NOT lint literals in init expr if `Local` has a type annotation.\n+        let x: f64 = 0.1;\n+        let x: [i32; 3] = [1, 2, 3];\n+        let x: (i32, i32) = if true { (1, 2) } else { (3, 4) };\n+        let x: _ = 1;\n+    }\n+}\n+\n+mod nested_local {\n+    fn test() {\n+        let x: _ = {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1\n+        };\n+\n+        let x: _ = if true {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1\n+        } else {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            2\n+        };\n+    }\n+}\n+\n+mod function_def {\n+    fn ret_i32() -> i32 {\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        1\n+    }\n+\n+    fn test() {\n+        // Should lint this because return type is inferred to `i32` and NOT bound to a concrete\n+        // type.\n+        let f = || -> _ { 1 };\n+\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        let f = || -> i32 { 1 };\n+    }\n+}\n+\n+mod function_calls {\n+    fn concrete_arg(x: i32) {}\n+\n+    fn generic_arg<T>(t: T) {}\n+\n+    fn test() {\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        concrete_arg(1);\n+\n+        // Should lint this because the argument type is inferred to `i32` and NOT bound to a concrete type.\n+        generic_arg(1);\n+\n+        // Should lint this because the argument type is inferred to `i32` and NOT bound to a concrete type.\n+        let x: _ = generic_arg(1);\n+    }\n+}\n+\n+mod struct_ctor {\n+    struct ConcreteStruct {\n+        x: i32,\n+    }\n+\n+    struct GenericStruct<T> {\n+        x: T,\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteStruct { x: 1 };\n+\n+        // Should lint this because the field type is inferred to `i32` and NOT bound to a concrete type.\n+        GenericStruct { x: 1 };\n+\n+        // Should lint this because the field type is inferred to `i32` and NOT bound to a concrete type.\n+        let _ = GenericStruct { x: 1 };\n+    }\n+}\n+\n+mod method_calls {\n+    struct StructForMethodCallTest {}\n+\n+    impl StructForMethodCallTest {\n+        fn concrete_arg(&self, x: i32) {}\n+\n+        fn generic_arg<T>(&self, t: T) {}\n+    }\n+\n+    fn test() {\n+        let s = StructForMethodCallTest {};\n+\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        s.concrete_arg(1);\n+\n+        // Should lint this because the argument type is bound to a concrete type.\n+        s.generic_arg(1);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b31aa4ebcf8e4a3efd54ff94ca83a39355fc53ea", "filename": "tests/ui/default_numeric_fallback.stderr", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa/tests%2Fui%2Fdefault_numeric_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa/tests%2Fui%2Fdefault_numeric_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback.stderr?ref=e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa", "patch": "@@ -0,0 +1,148 @@\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:10:17\n+   |\n+LL |         let x = 22;\n+   |                 ^^ help: consider adding suffix: `22_i32`\n+   |\n+   = note: `-D clippy::default-numeric-fallback` implied by `-D warnings`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:11:18\n+   |\n+LL |         let x = [1, 2, 3];\n+   |                  ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:11:21\n+   |\n+LL |         let x = [1, 2, 3];\n+   |                     ^ help: consider adding suffix: `2_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:11:24\n+   |\n+LL |         let x = [1, 2, 3];\n+   |                        ^ help: consider adding suffix: `3_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:12:28\n+   |\n+LL |         let x = if true { (1, 2) } else { (3, 4) };\n+   |                            ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:12:31\n+   |\n+LL |         let x = if true { (1, 2) } else { (3, 4) };\n+   |                               ^ help: consider adding suffix: `2_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:12:44\n+   |\n+LL |         let x = if true { (1, 2) } else { (3, 4) };\n+   |                                            ^ help: consider adding suffix: `3_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:12:47\n+   |\n+LL |         let x = if true { (1, 2) } else { (3, 4) };\n+   |                                               ^ help: consider adding suffix: `4_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:13:23\n+   |\n+LL |         let x = match 1 {\n+   |                       ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:14:13\n+   |\n+LL |             1 => 1,\n+   |             ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:14:18\n+   |\n+LL |             1 => 1,\n+   |                  ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:15:18\n+   |\n+LL |             _ => 2,\n+   |                  ^ help: consider adding suffix: `2_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:19:17\n+   |\n+LL |         let x = 0.12;\n+   |                 ^^^^ help: consider adding suffix: `0.12_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:37:21\n+   |\n+LL |             let y = 1;\n+   |                     ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:45:21\n+   |\n+LL |             let y = 1;\n+   |                     ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:51:21\n+   |\n+LL |             let y = 1;\n+   |                     ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:63:9\n+   |\n+LL |         1\n+   |         ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:69:27\n+   |\n+LL |         let f = || -> _ { 1 };\n+   |                           ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:73:29\n+   |\n+LL |         let f = || -> i32 { 1 };\n+   |                             ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:87:21\n+   |\n+LL |         generic_arg(1);\n+   |                     ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:90:32\n+   |\n+LL |         let x: _ = generic_arg(1);\n+   |                                ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:108:28\n+   |\n+LL |         GenericStruct { x: 1 };\n+   |                            ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:111:36\n+   |\n+LL |         let _ = GenericStruct { x: 1 };\n+   |                                    ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:131:23\n+   |\n+LL |         s.generic_arg(1);\n+   |                       ^ help: consider adding suffix: `1_i32`\n+\n+error: aborting due to 24 previous errors\n+"}]}