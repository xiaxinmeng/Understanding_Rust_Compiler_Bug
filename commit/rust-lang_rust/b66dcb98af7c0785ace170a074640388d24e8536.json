{"sha": "b66dcb98af7c0785ace170a074640388d24e8536", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2NmRjYjk4YWY3YzA3ODVhY2UxNzBhMDc0NjQwMzg4ZDI0ZTg1MzY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-15T21:51:42Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-15T21:51:42Z"}, "message": "explain better that structural pinning is a per-field choice", "tree": {"sha": "0f7ecacb59077c4e320faecd281fb83d9bd84bbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f7ecacb59077c4e320faecd281fb83d9bd84bbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b66dcb98af7c0785ace170a074640388d24e8536", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b66dcb98af7c0785ace170a074640388d24e8536", "html_url": "https://github.com/rust-lang/rust/commit/b66dcb98af7c0785ace170a074640388d24e8536", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b66dcb98af7c0785ace170a074640388d24e8536/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc550d4295a654f9e7c621d957d81fbf1426c70b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc550d4295a654f9e7c621d957d81fbf1426c70b", "html_url": "https://github.com/rust-lang/rust/commit/fc550d4295a654f9e7c621d957d81fbf1426c70b"}], "stats": {"total": 131, "additions": 102, "deletions": 29}, "files": [{"sha": "e6fdfb8af5ff37d40dede239f2a16808be6a9182", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 102, "deletions": 29, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/b66dcb98af7c0785ace170a074640388d24e8536/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b66dcb98af7c0785ace170a074640388d24e8536/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=b66dcb98af7c0785ace170a074640388d24e8536", "patch": "@@ -166,55 +166,118 @@\n //! implementation as well: if an element of your type could have been pinned,\n //! you must treat Drop as implicitly taking `Pin<&mut Self>`.\n //!\n-//! In particular, if your type is `#[repr(packed)]`, the compiler will automatically\n+//! For example, you could implement `Drop` as follows:\n+//! ```rust,ignore\n+//! impl Drop for Type {\n+//!     fn drop(&mut self) {\n+//!         // `new_unchecked` is okay because we know this value is never used\n+//!         // again after being dropped.\n+//!         inner_drop(unsafe { Pin::new_unchecked(self)});\n+//!         fn inner_drop(this: Pin<&mut Type>) {\n+//!             // Actual drop code goes here.\n+//!         }\n+//!     }\n+//! }\n+//! ```\n+//! `inner_drop` has the type that `drop` *should* have, so this makes sure that\n+//! you do not accidentally use `self`/`this` in a way that is in conflict with pinning.\n+//!\n+//! Moreover, if your type is `#[repr(packed)]`, the compiler will automatically\n //! move fields around to be able to drop them. As a consequence, you cannot use\n //! pinning with a `#[repr(packed)]` type.\n //!\n //! # Projections and Structural Pinning\n //!\n-//! One interesting question arises when considering the interaction of pinning\n-//! and the fields of a struct. When can a struct have a \"pinning projection\",\n-//! i.e., an operation with type `fn(Pin<&Struct>) -> Pin<&Field>`?  In a\n-//! similar vein, when can a generic wrapper type (such as `Vec<T>`, `Box<T>`,\n-//! or `RefCell<T>`) have an operation with type `fn(Pin<&Wrapper<T>>) ->\n-//! Pin<&T>`?\n+//! When working with pinned structs, the question arises how one can access the\n+//! fields of that struct in a method that takes just `Pin<&mut Struct>`.\n+//! The usual approach is to write helper methods (so called *projections*)\n+//! that turn `Pin<&mut Struct>` into a reference to the field, but what\n+//! type should that reference have? Is it `Pin<&mut Field>` or `&mut Field`?\n+//! The same question arises with the fields of an enum, and also when considering\n+//! container/wrapper types such as `Vec<T>`, `Box<T>`, or `RefCell<T>`.\n+//! Also, this question arises for both mutable and shared references, we just\n+//! use the more common case of mutable references here for illustration.\n+//!\n+//! It turns out that it is actually up to the author of the data structure\n+//! to decide whether the pinned projection for a particular field turns\n+//! `Pin<&mut Struct>` into `Pin<&mut Field>` or `&mut Field`. There are some\n+//! constraints though, and the most important constraint is *consistency*:\n+//! every field can be *either* projected to a pinned reference, *or* have\n+//! pinning removed as part of the projection. If both are done for the same field,\n+//! that will likely be unsound!\n+//!\n+//! Basically, as the author of a data structure you get to decide for each field whether pinning\n+//! \"propagates\" to this field or not. Pinning that propagates is also called \"structural\",\n+//! because it follows the structure of the type.\n+//! In the following, we describe the considerations that have to be made for either choice.\n+//!\n+//! ## Pinning *is not* structural for `field`\n+//!\n+//! It may seem counter-intuitive that the field of a pinned struct is not pinned,\n+//! but that is actually the easiest choice: if a `Pin<&mut Field>` is never created,\n+//! nothing can go wrong! So, if you decide that some field does not have structural pinning,\n+//! all you have to ensure is that you never create a pinned reference to that field.\n+//!\n+//! Then you may add a projection method that turns `Pin<&mut Struct>` into `Pin<&mut Field>`:\n+//! ```rust,ignore\n+//! impl Struct {\n+//!     fn get_field<'a>(self: Pin<&'a mut Self>) -> &'a mut Field {\n+//!         // This is okay because `field` is never considered pinned.\n+//!         unsafe { &mut self.get_unchecked_mut().field }\n+//!     }\n+//! }\n+//! ```\n //!\n-//! Note: For the entirety of this discussion, the same applies for mutable references as it\n-//! does for shared references.\n+//! You may also make make `Struct: Unpin` *even if* the type of `field`\n+//! is not `Unpin`.  What that type thinks about pinning is just not relevant\n+//! when no `Pin<&mut Field>` is ever created.\n //!\n-//! Having a pinning projection for some field means that pinning is \"structural\":\n-//! when the wrapper is pinned, the field must be considered pinned, too.\n-//! After all, the pinning projection lets us get a `Pin<&Field>`.\n+//! ## Pinning *is* structural for `field`\n //!\n-//! However, structural pinning comes with a few extra requirements, so not all\n-//! wrappers can be structural and hence not all wrappers can offer pinning projections:\n+//! The other option is to decide that pinning is \"structural\" for `field`,\n+//! meaning that if the struct is pinned then so is the field.\n //!\n-//! 1.  The wrapper must only be [`Unpin`] if all the structural fields are\n-//!     `Unpin`. This is the default, but `Unpin` is a safe trait, so as the author of\n-//!     the wrapper it is your responsibility *not* to add something like\n-//!     `impl<T> Unpin for Wrapper<T>`. (Notice that adding a projection operation\n+//! This allows writing a projection that creates a `Pin<&mut Field>`, thus\n+//! witnessing that the field is pinned:\n+//! ```rust,ignore\n+//! impl Struct {\n+//!     fn get_field<'a>(self: Pin<&'a mut Self>) -> Pin<&'a mut Field> {\n+//!         // This is okay because `field` is pinned when `self` is.\n+//!         unsafe { self.map_unchecked_mut(|s| &mut s.field) }\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! However, structural pinning comes with a few extra requirements:\n+//!\n+//! 1.  The struct must only be [`Unpin`] if all the structural fields are\n+//!     `Unpin`. This is the default, but `Unpin` is a safe trait, so it is your\n+//!     responsibility as the author of the struct *not* to add something like\n+//!     `impl<T> Unpin for Struct<T>`. (Notice that adding a projection operation\n //!     requires unsafe code, so the fact that `Unpin` is a safe trait does not break\n //!     the principle that you only have to worry about any of this if you use `unsafe`.)\n-//! 2.  The destructor of the wrapper must not move structural fields out of its argument. This\n+//! 2.  The destructor of the struct must not move structural fields out of its argument. This\n //!     is the exact point that was raised in the [previous section][drop-impl]: `drop` takes\n-//!     `&mut self`, but the wrapper (and hence its fields) might have been pinned before.\n+//!     `&mut self`, but the struct (and hence its fields) might have been pinned before.\n //!     You have to guarantee that you do not move a field inside your `Drop` implementation.\n-//!     In particular, as explained previously, this means that your wrapper type must *not*\n+//!     In particular, as explained previously, this means that your struct must *not*\n //!     be `#[repr(packed)]`.\n+//!     See that section for how to write `drop` in a way that the compiler can help you\n+//!     not accidentally break pinning.\n //! 3.  You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n-//!     once your wrapper is pinned, the memory that contains the\n+//!     once your struct is pinned, the memory that contains the\n //!     content is not overwritten or deallocated without calling the content's destructors.\n //!     This can be tricky, as witnessed by `VecDeque<T>`: the destructor of `VecDeque<T>` can fail\n //!     to call `drop` on all elements if one of the destructors panics. This violates the\n //!     `Drop` guarantee, because it can lead to elements being deallocated without\n //!     their destructor being called. (`VecDeque` has no pinning projections, so this\n //!     does not cause unsoundness.)\n //! 4.  You must not offer any other operations that could lead to data being moved out of\n-//!     the fields when your type is pinned. For example, if the wrapper contains an\n+//!     the structural fields when your type is pinned. For example, if the struct contains an\n //!     `Option<T>` and there is a `take`-like operation with type\n-//!     `fn(Pin<&mut Wrapper<T>>) -> Option<T>`,\n-//!     that operation can be used to move a `T` out of a pinned `Wrapper<T>` -- which means\n-//!     pinning cannot be structural.\n+//!     `fn(Pin<&mut Struct<T>>) -> Option<T>`,\n+//!     that operation can be used to move a `T` out of a pinned `Struct<T>` -- which means\n+//!     pinning cannot be structural for the field holding this data.\n //!\n //!     For a more complex example of moving data out of a pinned type, imagine if `RefCell<T>`\n //!     had a method `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`.\n@@ -231,13 +294,16 @@\n //!     (using `RefCell::get_pin_mut`) and then move that content using the mutable\n //!     reference we got later.\n //!\n-//! For a type like `Vec<T>`, both possibilites (structural pinning or not) make sense,\n-//! and the choice is up to the author. A `Vec<T>` with structural pinning could\n-//! have `get_pin`/`get_pin_mut` projections. However, it could *not* allow calling\n+//! ## Examples\n+//!\n+//! For a type like `Vec<T>`, both possibilites (structural pinning or not) make sense.\n+//! A `Vec<T>` with structural pinning could have `get_pin`/`get_pin_mut` methods to get\n+//! pinned references to elements. However, it could *not* allow calling\n //! `pop` on a pinned `Vec<T>` because that would move the (structurally pinned) contents!\n //! Nor could it allow `push`, which might reallocate and thus also move the contents.\n //! A `Vec<T>` without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n //! are never pinned and the `Vec<T>` itself is fine with being moved as well.\n+//! At that point pinning just has no effect on the vector at all.\n //!\n //! In the standard library, pointer types generally do not have structural pinning,\n //! and thus they do not offer pinning projections. This is why `Box<T>: Unpin` holds for all `T`.\n@@ -249,6 +315,13 @@\n //! whether the content is pinned is entirely independent of whether the pointer is\n //! pinned, meaning pinning is *not* structural.\n //!\n+//! When implementing a `Future` combinator, you will usually need structural pinning\n+//! for the nested futures, as you need to get pinned references to them to call `poll`.\n+//! But if your combinator contains any other data that does not need to be pinned,\n+//! you can make those fields not structural and hence freely access them with a\n+//! mutable reference even when you just have `Pin<&mut Self>` (such as in your own\n+//! `poll` implementation).\n+//!\n //! [`Pin<P>`]: struct.Pin.html\n //! [`Unpin`]: ../../std/marker/trait.Unpin.html\n //! [`Deref`]: ../../std/ops/trait.Deref.html"}]}