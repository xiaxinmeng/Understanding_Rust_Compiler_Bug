{"sha": "56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "node_id": "C_kwDOAAsO6NoAKDU2ZWU4NTI3NGU1YTNhNGRkYTkyZjNiZjczZDE2NjRjNzRmZjljMTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-20T04:52:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-20T04:52:28Z"}, "message": "Auto merge of #106090 - WaffleLapkin:dereffffffffff, r=Nilstrieb\n\nRemove some `ref` patterns from the compiler\n\nPrevious PR: https://github.com/rust-lang/rust/pull/105368\n\nr? `@Nilstrieb`", "tree": {"sha": "b8395fc6f6151aca9ccd2c401f763585999302a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8395fc6f6151aca9ccd2c401f763585999302a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "html_url": "https://github.com/rust-lang/rust/commit/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906", "url": "https://api.github.com/repos/rust-lang/rust/commits/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906", "html_url": "https://github.com/rust-lang/rust/commit/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906"}, {"sha": "65d1e8d9b556095dc50dc357e1ec4899afc3e975", "url": "https://api.github.com/repos/rust-lang/rust/commits/65d1e8d9b556095dc50dc357e1ec4899afc3e975", "html_url": "https://github.com/rust-lang/rust/commit/65d1e8d9b556095dc50dc357e1ec4899afc3e975"}], "stats": {"total": 1121, "additions": 529, "deletions": 592}, "files": [{"sha": "0579f7815352772807a19789d6928440256383b2", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -36,16 +36,16 @@ impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalErrKind {\n impl fmt::Display for ConstEvalErrKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use self::ConstEvalErrKind::*;\n-        match *self {\n+        match self {\n             ConstAccessesStatic => write!(f, \"constant accesses static\"),\n             ModifiedGlobal => {\n                 write!(f, \"modifying a static's initial value from another static's initializer\")\n             }\n-            AssertFailure(ref msg) => write!(f, \"{:?}\", msg),\n+            AssertFailure(msg) => write!(f, \"{:?}\", msg),\n             Panic { msg, line, col, file } => {\n                 write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col)\n             }\n-            Abort(ref msg) => write!(f, \"{}\", msg),\n+            Abort(msg) => write!(f, \"{}\", msg),\n         }\n     }\n }"}, {"sha": "4709514c82e85ab70a99727065a9c2008f26dcf0", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -533,7 +533,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         let eval_to_int =\n             |op| ecx.read_immediate(&ecx.eval_operand(op, None)?).map(|x| x.to_const_int());\n         let err = match msg {\n-            BoundsCheck { ref len, ref index } => {\n+            BoundsCheck { len, index } => {\n                 let len = eval_to_int(len)?;\n                 let index = eval_to_int(index)?;\n                 BoundsCheck { len, index }"}, {"sha": "b2c847d3fd8dd6fca2403ecd5d9216ae4c5e63f4", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -347,7 +347,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let new_vptr = self.get_vtable_ptr(ty, data_b.principal())?;\n                 self.write_immediate(Immediate::new_dyn_trait(old_data, new_vptr, self), dest)\n             }\n-            (_, &ty::Dynamic(ref data, _, ty::Dyn)) => {\n+            (_, &ty::Dynamic(data, _, ty::Dyn)) => {\n                 // Initial cast from sized to dyn trait\n                 let vtable = self.get_vtable_ptr(src_pointee_ty, data.principal())?;\n                 let ptr = self.read_scalar(src)?;"}, {"sha": "cc7b6c91b607426e57cd6ff9b65b597eb8b4d54e", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -79,9 +79,7 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n         }\n         sym::variant_count => match tp_ty.kind() {\n             // Correctly handles non-monomorphic calls, so there is no need for ensure_monomorphic_enough.\n-            ty::Adt(ref adt, _) => {\n-                ConstValue::from_machine_usize(adt.variants().len() as u64, &tcx)\n-            }\n+            ty::Adt(adt, _) => ConstValue::from_machine_usize(adt.variants().len() as u64, &tcx),\n             ty::Alias(..) | ty::Param(_) | ty::Placeholder(_) | ty::Infer(_) => {\n                 throw_inval!(TooGeneric)\n             }"}, {"sha": "291bfb2b55896dd73412d453533eab6223c56a6f", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -863,7 +863,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n \n             write!(fmt, \"{id:?}\")?;\n             match self.ecx.memory.alloc_map.get(id) {\n-                Some(&(kind, ref alloc)) => {\n+                Some((kind, alloc)) => {\n                     // normal alloc\n                     write!(fmt, \" ({}, \", kind)?;\n                     write_allocation_track_relocs("}, {"sha": "befc0928f3debd253efecb036e95d991b02be214", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -533,11 +533,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         use rustc_middle::mir::Operand::*;\n-        let op = match *mir_op {\n+        let op = match mir_op {\n             // FIXME: do some more logic on `move` to invalidate the old location\n-            Copy(place) | Move(place) => self.eval_place_to_op(place, layout)?,\n+            &Copy(place) | &Move(place) => self.eval_place_to_op(place, layout)?,\n \n-            Constant(ref constant) => {\n+            Constant(constant) => {\n                 let c =\n                     self.subst_from_current_frame_and_normalize_erasing_regions(constant.literal)?;\n "}, {"sha": "fad4cb06cd6fe4805f2f9dacfb3feac0bf075e22", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -111,7 +111,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 M::retag_place_contents(self, *kind, &dest)?;\n             }\n \n-            Intrinsic(box ref intrinsic) => self.emulate_nondiverging_intrinsic(intrinsic)?,\n+            Intrinsic(box intrinsic) => self.emulate_nondiverging_intrinsic(intrinsic)?,\n \n             // Statements we do not track.\n             AscribeUserType(..) => {}\n@@ -163,8 +163,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.copy_op(&op, &dest, /*allow_transmute*/ false)?;\n             }\n \n-            CopyForDeref(ref place) => {\n-                let op = self.eval_place_to_op(*place, Some(dest.layout))?;\n+            CopyForDeref(place) => {\n+                let op = self.eval_place_to_op(place, Some(dest.layout))?;\n                 self.copy_op(&op, &dest, /* allow_transmute*/ false)?;\n             }\n "}, {"sha": "19e359986a12e15762ad60cd06dc945a2f0eb046", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -419,7 +419,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             )\n         }\n         // Recursive checking\n-        if let Some(ref mut ref_tracking) = self.ref_tracking {\n+        if let Some(ref_tracking) = self.ref_tracking.as_deref_mut() {\n             // Proceed recursively even for ZST, no reason to skip them!\n             // `!` is a ZST and we want to validate it.\n             if let Ok((alloc_id, _offset, _prov)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {"}, {"sha": "f9efc2418dbbcd0ed5ccb8919da86b8bec11a391", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -481,12 +481,12 @@ macro_rules! make_value_visitor {\n                 };\n \n                 // Visit the fields of this value.\n-                match v.layout().fields {\n+                match &v.layout().fields {\n                     FieldsShape::Primitive => {}\n-                    FieldsShape::Union(fields) => {\n+                    &FieldsShape::Union(fields) => {\n                         self.visit_union(v, fields)?;\n                     }\n-                    FieldsShape::Arbitrary { ref offsets, .. } => {\n+                    FieldsShape::Arbitrary { offsets, .. } => {\n                         // FIXME: We collect in a vec because otherwise there are lifetime\n                         // errors: Projecting to a field needs access to `ecx`.\n                         let fields: Vec<InterpResult<'tcx, Self::V>> ="}, {"sha": "79f1737e32b21fcabe767b8999d753b5210aaa30", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -442,7 +442,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n         self.super_rvalue(rvalue, location);\n \n-        match *rvalue {\n+        match rvalue {\n             Rvalue::ThreadLocalRef(_) => self.check_op(ops::ThreadLocalAccess),\n \n             Rvalue::Use(_)\n@@ -451,18 +451,15 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n             | Rvalue::Discriminant(..)\n             | Rvalue::Len(_) => {}\n \n-            Rvalue::Aggregate(ref kind, ..) => {\n-                if let AggregateKind::Generator(def_id, ..) = kind.as_ref() {\n-                    if let Some(generator_kind) = self.tcx.generator_kind(def_id.to_def_id()) {\n-                        if matches!(generator_kind, hir::GeneratorKind::Async(..)) {\n-                            self.check_op(ops::Generator(generator_kind));\n-                        }\n-                    }\n+            Rvalue::Aggregate(kind, ..) => {\n+                if let AggregateKind::Generator(def_id, ..) = kind.as_ref()\n+                    && let Some(generator_kind @ hir::GeneratorKind::Async(..)) = self.tcx.generator_kind(def_id.to_def_id())\n+                {\n+                    self.check_op(ops::Generator(generator_kind));\n                 }\n             }\n \n-            Rvalue::Ref(_, kind @ BorrowKind::Mut { .. }, ref place)\n-            | Rvalue::Ref(_, kind @ BorrowKind::Unique, ref place) => {\n+            Rvalue::Ref(_, kind @ (BorrowKind::Mut { .. } | BorrowKind::Unique), place) => {\n                 let ty = place.ty(self.body, self.tcx).ty;\n                 let is_allowed = match ty.kind() {\n                     // Inside a `static mut`, `&mut [...]` is allowed.\n@@ -491,12 +488,12 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 }\n             }\n \n-            Rvalue::AddressOf(Mutability::Mut, ref place) => {\n+            Rvalue::AddressOf(Mutability::Mut, place) => {\n                 self.check_mut_borrow(place.local, hir::BorrowKind::Raw)\n             }\n \n-            Rvalue::Ref(_, BorrowKind::Shared | BorrowKind::Shallow, ref place)\n-            | Rvalue::AddressOf(Mutability::Not, ref place) => {\n+            Rvalue::Ref(_, BorrowKind::Shared | BorrowKind::Shallow, place)\n+            | Rvalue::AddressOf(Mutability::Not, place) => {\n                 let borrowed_place_has_mut_interior = qualifs::in_place::<HasMutInterior, _>(\n                     &self.ccx,\n                     &mut |local| self.qualifs.has_mut_interior(self.ccx, local, location),\n@@ -564,7 +561,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n             Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) => {}\n             Rvalue::ShallowInitBox(_, _) => {}\n \n-            Rvalue::UnaryOp(_, ref operand) => {\n+            Rvalue::UnaryOp(_, operand) => {\n                 let ty = operand.ty(self.body, self.tcx);\n                 if is_int_bool_or_char(ty) {\n                     // Int, bool, and char operations are fine.\n@@ -575,8 +572,8 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 }\n             }\n \n-            Rvalue::BinaryOp(op, box (ref lhs, ref rhs))\n-            | Rvalue::CheckedBinaryOp(op, box (ref lhs, ref rhs)) => {\n+            Rvalue::BinaryOp(op, box (lhs, rhs))\n+            | Rvalue::CheckedBinaryOp(op, box (lhs, rhs)) => {\n                 let lhs_ty = lhs.ty(self.body, self.tcx);\n                 let rhs_ty = rhs.ty(self.body, self.tcx);\n \n@@ -585,13 +582,16 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 } else if lhs_ty.is_fn_ptr() || lhs_ty.is_unsafe_ptr() {\n                     assert_eq!(lhs_ty, rhs_ty);\n                     assert!(\n-                        op == BinOp::Eq\n-                            || op == BinOp::Ne\n-                            || op == BinOp::Le\n-                            || op == BinOp::Lt\n-                            || op == BinOp::Ge\n-                            || op == BinOp::Gt\n-                            || op == BinOp::Offset\n+                        matches!(\n+                            op,\n+                            BinOp::Eq\n+                            | BinOp::Ne\n+                            | BinOp::Le\n+                            | BinOp::Lt\n+                            | BinOp::Ge\n+                            | BinOp::Gt\n+                            | BinOp::Offset\n+                        )\n                     );\n \n                     self.check_op(ops::RawPtrComparison);"}, {"sha": "fae6117f8f05224616eb95d0ed345b606b785890", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 49, "deletions": 53, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -133,7 +133,7 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n                 }\n                 _ => { /* mark as unpromotable below */ }\n             }\n-        } else if let TempState::Defined { ref mut uses, .. } = *temp {\n+        } else if let TempState::Defined { uses, .. } = temp {\n             // We always allow borrows, even mutable ones, as we need\n             // to promote mutable borrows of some ZSTs e.g., `&mut []`.\n             let allowed_use = match context {\n@@ -748,7 +748,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         if loc.statement_index < num_stmts {\n             let (mut rvalue, source_info) = {\n                 let statement = &mut self.source[loc.block].statements[loc.statement_index];\n-                let StatementKind::Assign(box (_, ref mut rhs)) = statement.kind else {\n+                let StatementKind::Assign(box (_, rhs)) = &mut statement.kind else {\n                     span_bug!(\n                         statement.source_info.span,\n                         \"{:?} is not an assignment\",\n@@ -778,9 +778,9 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 self.source[loc.block].terminator().clone()\n             } else {\n                 let terminator = self.source[loc.block].terminator_mut();\n-                let target = match terminator.kind {\n-                    TerminatorKind::Call { target: Some(target), .. } => target,\n-                    ref kind => {\n+                let target = match &terminator.kind {\n+                    TerminatorKind::Call { target: Some(target), .. } => *target,\n+                    kind => {\n                         span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n                     }\n                 };\n@@ -814,7 +814,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         ..terminator\n                     };\n                 }\n-                ref kind => {\n+                kind => {\n                     span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n                 }\n             };\n@@ -847,54 +847,50 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             let local_decls = &mut self.source.local_decls;\n             let loc = candidate.location;\n             let statement = &mut blocks[loc.block].statements[loc.statement_index];\n-            match statement.kind {\n-                StatementKind::Assign(box (\n-                    _,\n-                    Rvalue::Ref(ref mut region, borrow_kind, ref mut place),\n-                )) => {\n-                    // Use the underlying local for this (necessarily interior) borrow.\n-                    let ty = local_decls[place.local].ty;\n-                    let span = statement.source_info.span;\n-\n-                    let ref_ty = tcx.mk_ref(\n-                        tcx.lifetimes.re_erased,\n-                        ty::TypeAndMut { ty, mutbl: borrow_kind.to_mutbl_lossy() },\n-                    );\n+            let StatementKind::Assign(box (_, Rvalue::Ref(region, borrow_kind, place))) = &mut statement.kind else {\n+                bug!()\n+            };\n \n-                    *region = tcx.lifetimes.re_erased;\n-\n-                    let mut projection = vec![PlaceElem::Deref];\n-                    projection.extend(place.projection);\n-                    place.projection = tcx.intern_place_elems(&projection);\n-\n-                    // Create a temp to hold the promoted reference.\n-                    // This is because `*r` requires `r` to be a local,\n-                    // otherwise we would use the `promoted` directly.\n-                    let mut promoted_ref = LocalDecl::new(ref_ty, span);\n-                    promoted_ref.source_info = statement.source_info;\n-                    let promoted_ref = local_decls.push(promoted_ref);\n-                    assert_eq!(self.temps.push(TempState::Unpromotable), promoted_ref);\n-\n-                    let promoted_ref_statement = Statement {\n-                        source_info: statement.source_info,\n-                        kind: StatementKind::Assign(Box::new((\n-                            Place::from(promoted_ref),\n-                            Rvalue::Use(promoted_operand(ref_ty, span)),\n-                        ))),\n-                    };\n-                    self.extra_statements.push((loc, promoted_ref_statement));\n-\n-                    Rvalue::Ref(\n-                        tcx.lifetimes.re_erased,\n-                        borrow_kind,\n-                        Place {\n-                            local: mem::replace(&mut place.local, promoted_ref),\n-                            projection: List::empty(),\n-                        },\n-                    )\n-                }\n-                _ => bug!(),\n-            }\n+            // Use the underlying local for this (necessarily interior) borrow.\n+            let ty = local_decls[place.local].ty;\n+            let span = statement.source_info.span;\n+\n+            let ref_ty = tcx.mk_ref(\n+                tcx.lifetimes.re_erased,\n+                ty::TypeAndMut { ty, mutbl: borrow_kind.to_mutbl_lossy() },\n+            );\n+\n+            *region = tcx.lifetimes.re_erased;\n+\n+            let mut projection = vec![PlaceElem::Deref];\n+            projection.extend(place.projection);\n+            place.projection = tcx.intern_place_elems(&projection);\n+\n+            // Create a temp to hold the promoted reference.\n+            // This is because `*r` requires `r` to be a local,\n+            // otherwise we would use the `promoted` directly.\n+            let mut promoted_ref = LocalDecl::new(ref_ty, span);\n+            promoted_ref.source_info = statement.source_info;\n+            let promoted_ref = local_decls.push(promoted_ref);\n+            assert_eq!(self.temps.push(TempState::Unpromotable), promoted_ref);\n+\n+            let promoted_ref_statement = Statement {\n+                source_info: statement.source_info,\n+                kind: StatementKind::Assign(Box::new((\n+                    Place::from(promoted_ref),\n+                    Rvalue::Use(promoted_operand(ref_ty, span)),\n+                ))),\n+            };\n+            self.extra_statements.push((loc, promoted_ref_statement));\n+\n+            Rvalue::Ref(\n+                tcx.lifetimes.re_erased,\n+                *borrow_kind,\n+                Place {\n+                    local: mem::replace(&mut place.local, promoted_ref),\n+                    projection: List::empty(),\n+                },\n+            )\n         };\n \n         assert_eq!(self.new_block(), START_BLOCK);"}, {"sha": "dc1ce1747bfa0dc1d6def1306db79460d3e907f9", "filename": "compiler/rustc_data_structures/src/graph/implementation/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Ftests.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -70,8 +70,8 @@ fn test_adjacent_edges<N: PartialEq + Debug, E: PartialEq + Debug>(\n             \"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n             counter, expected_incoming[counter], edge_index, edge\n         );\n-        match expected_incoming[counter] {\n-            (ref e, ref n) => {\n+        match &expected_incoming[counter] {\n+            (e, n) => {\n                 assert!(e == &edge.data);\n                 assert!(n == graph.node_data(edge.source()));\n                 assert!(start_index == edge.target);\n@@ -88,8 +88,8 @@ fn test_adjacent_edges<N: PartialEq + Debug, E: PartialEq + Debug>(\n             \"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n             counter, expected_outgoing[counter], edge_index, edge\n         );\n-        match expected_outgoing[counter] {\n-            (ref e, ref n) => {\n+        match &expected_outgoing[counter] {\n+            (e, n) => {\n                 assert!(e == &edge.data);\n                 assert!(start_index == edge.source);\n                 assert!(n == graph.node_data(edge.target));"}, {"sha": "9409057d4847e419b8960e0a389d6341f7a6d192", "filename": "compiler/rustc_data_structures/src/sorted_map.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -1,6 +1,5 @@\n use crate::stable_hasher::{HashStable, StableHasher, StableOrd};\n use std::borrow::Borrow;\n-use std::cmp::Ordering;\n use std::fmt::Debug;\n use std::mem;\n use std::ops::{Bound, Index, IndexMut, RangeBounds};\n@@ -171,7 +170,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n     where\n         F: Fn(&mut K),\n     {\n-        self.data.iter_mut().map(|&mut (ref mut k, _)| k).for_each(f);\n+        self.data.iter_mut().map(|(k, _)| k).for_each(f);\n     }\n \n     /// Inserts a presorted range of elements into the map. If the range can be\n@@ -232,22 +231,22 @@ impl<K: Ord, V> SortedMap<K, V> {\n         R: RangeBounds<K>,\n     {\n         let start = match range.start_bound() {\n-            Bound::Included(ref k) => match self.lookup_index_for(k) {\n+            Bound::Included(k) => match self.lookup_index_for(k) {\n                 Ok(index) | Err(index) => index,\n             },\n-            Bound::Excluded(ref k) => match self.lookup_index_for(k) {\n+            Bound::Excluded(k) => match self.lookup_index_for(k) {\n                 Ok(index) => index + 1,\n                 Err(index) => index,\n             },\n             Bound::Unbounded => 0,\n         };\n \n         let end = match range.end_bound() {\n-            Bound::Included(ref k) => match self.lookup_index_for(k) {\n+            Bound::Included(k) => match self.lookup_index_for(k) {\n                 Ok(index) => index + 1,\n                 Err(index) => index,\n             },\n-            Bound::Excluded(ref k) => match self.lookup_index_for(k) {\n+            Bound::Excluded(k) => match self.lookup_index_for(k) {\n                 Ok(index) | Err(index) => index,\n             },\n             Bound::Unbounded => self.data.len(),\n@@ -302,7 +301,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for SortedMap<K, V> {\n         let mut data: Vec<(K, V)> = iter.into_iter().collect();\n \n         data.sort_unstable_by(|(k1, _), (k2, _)| k1.cmp(k2));\n-        data.dedup_by(|&mut (ref k1, _), &mut (ref k2, _)| k1.cmp(k2) == Ordering::Equal);\n+        data.dedup_by(|(k1, _), (k2, _)| k1 == k2);\n \n         SortedMap { data }\n     }"}, {"sha": "814e7c7fb9ba6751aa9dbe368319bd5525df3c17", "filename": "compiler/rustc_data_structures/src/sorted_map/index_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -63,13 +63,13 @@ impl<I: Idx, K: Ord, V> SortedIndexMultiMap<I, K, V> {\n     /// Returns an iterator over the items in the map in insertion order.\n     #[inline]\n     pub fn iter(&self) -> impl '_ + DoubleEndedIterator<Item = (&K, &V)> {\n-        self.items.iter().map(|(ref k, ref v)| (k, v))\n+        self.items.iter().map(|(k, v)| (k, v))\n     }\n \n     /// Returns an iterator over the items in the map in insertion order along with their indices.\n     #[inline]\n     pub fn iter_enumerated(&self) -> impl '_ + DoubleEndedIterator<Item = (I, (&K, &V))> {\n-        self.items.iter_enumerated().map(|(i, (ref k, ref v))| (i, (k, v)))\n+        self.items.iter_enumerated().map(|(i, (k, v))| (i, (k, v)))\n     }\n \n     /// Returns the item in the map with the given index."}, {"sha": "3cc250862df42bb39b28688d564a929d400a7cc7", "filename": "compiler/rustc_data_structures/src/sorted_map/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Ftests.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -6,7 +6,7 @@ fn test_sorted_index_multi_map() {\n     let set: SortedIndexMultiMap<usize, _, _> = entries.iter().copied().collect();\n \n     // Insertion order is preserved.\n-    assert!(entries.iter().map(|(ref k, ref v)| (k, v)).eq(set.iter()));\n+    assert!(entries.iter().map(|(k, v)| (k, v)).eq(set.iter()));\n \n     // Indexing\n     for (i, expect) in entries.iter().enumerate() {"}, {"sha": "11a408f216a1465ca4335fa7879a342a82ff61ae", "filename": "compiler/rustc_data_structures/src/tiny_list.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -37,9 +37,9 @@ impl<T: PartialEq> TinyList<T> {\n \n     #[inline]\n     pub fn remove(&mut self, data: &T) -> bool {\n-        self.head = match self.head {\n-            Some(ref mut head) if head.data == *data => head.next.take().map(|x| *x),\n-            Some(ref mut head) => return head.remove_next(data),\n+        self.head = match &mut self.head {\n+            Some(head) if head.data == *data => head.next.take().map(|x| *x),\n+            Some(head) => return head.remove_next(data),\n             None => return false,\n         };\n         true\n@@ -48,7 +48,7 @@ impl<T: PartialEq> TinyList<T> {\n     #[inline]\n     pub fn contains(&self, data: &T) -> bool {\n         let mut elem = self.head.as_ref();\n-        while let Some(ref e) = elem {\n+        while let Some(e) = elem {\n             if &e.data == data {\n                 return true;\n             }\n@@ -65,15 +65,14 @@ struct Element<T> {\n }\n \n impl<T: PartialEq> Element<T> {\n-    fn remove_next(&mut self, data: &T) -> bool {\n-        let mut n = self;\n+    fn remove_next(mut self: &mut Self, data: &T) -> bool {\n         loop {\n-            match n.next {\n+            match self.next {\n                 Some(ref mut next) if next.data == *data => {\n-                    n.next = next.next.take();\n+                    self.next = next.next.take();\n                     return true;\n                 }\n-                Some(ref mut next) => n = next,\n+                Some(ref mut next) => self = next,\n                 None => return false,\n             }\n         }"}, {"sha": "4b95e62bef02b1391af37c41a4e9823bec5b3983", "filename": "compiler/rustc_data_structures/src/tiny_list/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -6,7 +6,7 @@ use test::{black_box, Bencher};\n impl<T> TinyList<T> {\n     fn len(&self) -> usize {\n         let (mut elem, mut count) = (self.head.as_ref(), 0);\n-        while let Some(ref e) = elem {\n+        while let Some(e) = elem {\n             count += 1;\n             elem = e.next.as_deref();\n         }"}, {"sha": "951d59246785d08bff71641690fe154308428a34", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -63,21 +63,21 @@ pub enum Annotatable {\n \n impl Annotatable {\n     pub fn span(&self) -> Span {\n-        match *self {\n-            Annotatable::Item(ref item) => item.span,\n-            Annotatable::TraitItem(ref trait_item) => trait_item.span,\n-            Annotatable::ImplItem(ref impl_item) => impl_item.span,\n-            Annotatable::ForeignItem(ref foreign_item) => foreign_item.span,\n-            Annotatable::Stmt(ref stmt) => stmt.span,\n-            Annotatable::Expr(ref expr) => expr.span,\n-            Annotatable::Arm(ref arm) => arm.span,\n-            Annotatable::ExprField(ref field) => field.span,\n-            Annotatable::PatField(ref fp) => fp.pat.span,\n-            Annotatable::GenericParam(ref gp) => gp.ident.span,\n-            Annotatable::Param(ref p) => p.span,\n-            Annotatable::FieldDef(ref sf) => sf.span,\n-            Annotatable::Variant(ref v) => v.span,\n-            Annotatable::Crate(ref c) => c.spans.inner_span,\n+        match self {\n+            Annotatable::Item(item) => item.span,\n+            Annotatable::TraitItem(trait_item) => trait_item.span,\n+            Annotatable::ImplItem(impl_item) => impl_item.span,\n+            Annotatable::ForeignItem(foreign_item) => foreign_item.span,\n+            Annotatable::Stmt(stmt) => stmt.span,\n+            Annotatable::Expr(expr) => expr.span,\n+            Annotatable::Arm(arm) => arm.span,\n+            Annotatable::ExprField(field) => field.span,\n+            Annotatable::PatField(fp) => fp.pat.span,\n+            Annotatable::GenericParam(gp) => gp.ident.span,\n+            Annotatable::Param(p) => p.span,\n+            Annotatable::FieldDef(sf) => sf.span,\n+            Annotatable::Variant(v) => v.span,\n+            Annotatable::Crate(c) => c.spans.inner_span,\n         }\n     }\n "}, {"sha": "1fcbdfd9be5ce14353b7f1c572e2af7d6333f42b", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -298,7 +298,7 @@ impl<'a> StripUnconfigured<'a> {\n                     Some(AttrTokenTree::Delimited(sp, delim, inner))\n                         .into_iter()\n                 }\n-                AttrTokenTree::Token(ref token, _) if let TokenKind::Interpolated(ref nt) = token.kind => {\n+                AttrTokenTree::Token(ref token, _) if let TokenKind::Interpolated(nt) = &token.kind => {\n                     panic!(\n                         \"Nonterminal should have been flattened at {:?}: {:?}\",\n                         token.span, nt"}, {"sha": "79d058d9c97360d0aec61b0128d8ad140e14593d", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -144,12 +144,12 @@ macro_rules! ast_fragments {\n             }\n \n             pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n-                match *self {\n-                    AstFragment::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n+                match self {\n+                    AstFragment::OptExpr(Some(expr)) => visitor.visit_expr(expr),\n                     AstFragment::OptExpr(None) => {}\n-                    AstFragment::MethodReceiverExpr(ref expr) => visitor.visit_method_receiver_expr(expr),\n-                    $($(AstFragment::$Kind(ref ast) => visitor.$visit_ast(ast),)?)*\n-                    $($(AstFragment::$Kind(ref ast) => for ast_elt in &ast[..] {\n+                    AstFragment::MethodReceiverExpr(expr) => visitor.visit_method_receiver_expr(expr),\n+                    $($(AstFragment::$Kind(ast) => visitor.$visit_ast(ast),)?)*\n+                    $($(AstFragment::$Kind(ast) => for ast_elt in &ast[..] {\n                         visitor.$visit_ast_elt(ast_elt, $($args)*);\n                     })?)*\n                 }\n@@ -592,7 +592,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let expn_id = invoc.expansion_data.id;\n                     let parent_def = self.cx.resolver.invocation_parent(expn_id);\n                     let span = match &mut invoc.kind {\n-                        InvocationKind::Bang { ref mut span, .. } => span,\n+                        InvocationKind::Bang { span, .. } => span,\n                         InvocationKind::Attr { attr, .. } => &mut attr.span,\n                         InvocationKind::Derive { path, .. } => &mut path.span,\n                     };\n@@ -945,8 +945,8 @@ pub fn ensure_complete_parse<'a>(\n         let def_site_span = parser.token.span.with_ctxt(SyntaxContext::root());\n \n         let semi_span = parser.sess.source_map().next_point(span);\n-        let add_semicolon = match parser.sess.source_map().span_to_snippet(semi_span) {\n-            Ok(ref snippet) if &snippet[..] != \";\" && kind_name == \"expression\" => {\n+        let add_semicolon = match &parser.sess.source_map().span_to_snippet(semi_span) {\n+            Ok(snippet) if &snippet[..] != \";\" && kind_name == \"expression\" => {\n                 Some(span.shrink_to_hi())\n             }\n             _ => None,"}, {"sha": "5be134f4e664c80c189cefab7d41baa380b41045", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -151,9 +151,9 @@ impl<'a, T> Iterator for &'a Stack<'a, T> {\n \n     // Iterates from top to bottom of the stack.\n     fn next(&mut self) -> Option<&'a T> {\n-        match *self {\n+        match self {\n             Stack::Empty => None,\n-            Stack::Push { ref top, ref prev } => {\n+            Stack::Push { top, prev } => {\n                 *self = prev;\n                 Some(top)\n             }\n@@ -437,8 +437,8 @@ fn check_nested_occurrences(\n                 // We check that the meta-variable is correctly used.\n                 check_occurrences(sess, node_id, tt, macros, binders, ops, valid);\n             }\n-            (NestedMacroState::MacroRulesNotName, &TokenTree::Delimited(_, ref del))\n-            | (NestedMacroState::MacroName, &TokenTree::Delimited(_, ref del))\n+            (NestedMacroState::MacroRulesNotName, TokenTree::Delimited(_, del))\n+            | (NestedMacroState::MacroName, TokenTree::Delimited(_, del))\n                 if del.delim == Delimiter::Brace =>\n             {\n                 let macro_rules = state == NestedMacroState::MacroRulesNotName;\n@@ -497,7 +497,7 @@ fn check_nested_occurrences(\n                     valid,\n                 );\n             }\n-            (_, ref tt) => {\n+            (_, tt) => {\n                 state = NestedMacroState::Empty;\n                 check_occurrences(sess, node_id, tt, macros, binders, ops, valid);\n             }"}, {"sha": "4ebd75f0185604b0038a3ea8d8c70ac489344af7", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -486,11 +486,11 @@ pub fn compile_declarative_macro(\n     let mut valid = true;\n \n     // Extract the arguments:\n-    let lhses = match argument_map[&MacroRulesNormalizedIdent::new(lhs_nm)] {\n-        MatchedSeq(ref s) => s\n+    let lhses = match &argument_map[&MacroRulesNormalizedIdent::new(lhs_nm)] {\n+        MatchedSeq(s) => s\n             .iter()\n             .map(|m| {\n-                if let MatchedTokenTree(ref tt) = *m {\n+                if let MatchedTokenTree(tt) = m {\n                     let tt = mbe::quoted::parse(\n                         TokenStream::new(vec![tt.clone()]),\n                         true,\n@@ -510,11 +510,11 @@ pub fn compile_declarative_macro(\n         _ => sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\"),\n     };\n \n-    let rhses = match argument_map[&MacroRulesNormalizedIdent::new(rhs_nm)] {\n-        MatchedSeq(ref s) => s\n+    let rhses = match &argument_map[&MacroRulesNormalizedIdent::new(rhs_nm)] {\n+        MatchedSeq(s) => s\n             .iter()\n             .map(|m| {\n-                if let MatchedTokenTree(ref tt) = *m {\n+                if let MatchedTokenTree(tt) = m {\n                     return mbe::quoted::parse(\n                         TokenStream::new(vec![tt.clone()]),\n                         false,\n@@ -624,21 +624,21 @@ fn check_lhs_nt_follows(sess: &ParseSess, def: &ast::Item, lhs: &mbe::TokenTree)\n fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n     use mbe::TokenTree;\n     for tt in tts {\n-        match *tt {\n+        match tt {\n             TokenTree::Token(..)\n             | TokenTree::MetaVar(..)\n             | TokenTree::MetaVarDecl(..)\n             | TokenTree::MetaVarExpr(..) => (),\n-            TokenTree::Delimited(_, ref del) => {\n+            TokenTree::Delimited(_, del) => {\n                 if !check_lhs_no_empty_seq(sess, &del.tts) {\n                     return false;\n                 }\n             }\n-            TokenTree::Sequence(span, ref seq) => {\n+            TokenTree::Sequence(span, seq) => {\n                 if seq.separator.is_none()\n-                    && seq.tts.iter().all(|seq_tt| match *seq_tt {\n+                    && seq.tts.iter().all(|seq_tt| match seq_tt {\n                         TokenTree::MetaVarDecl(_, _, Some(NonterminalKind::Vis)) => true,\n-                        TokenTree::Sequence(_, ref sub_seq) => {\n+                        TokenTree::Sequence(_, sub_seq) => {\n                             sub_seq.kleene.op == mbe::KleeneOp::ZeroOrMore\n                                 || sub_seq.kleene.op == mbe::KleeneOp::ZeroOrOne\n                         }\n@@ -736,21 +736,21 @@ impl<'tt> FirstSets<'tt> {\n         fn build_recur<'tt>(sets: &mut FirstSets<'tt>, tts: &'tt [TokenTree]) -> TokenSet<'tt> {\n             let mut first = TokenSet::empty();\n             for tt in tts.iter().rev() {\n-                match *tt {\n+                match tt {\n                     TokenTree::Token(..)\n                     | TokenTree::MetaVar(..)\n                     | TokenTree::MetaVarDecl(..)\n                     | TokenTree::MetaVarExpr(..) => {\n                         first.replace_with(TtHandle::TtRef(tt));\n                     }\n-                    TokenTree::Delimited(span, ref delimited) => {\n+                    TokenTree::Delimited(span, delimited) => {\n                         build_recur(sets, &delimited.tts);\n                         first.replace_with(TtHandle::from_token_kind(\n                             token::OpenDelim(delimited.delim),\n                             span.open,\n                         ));\n                     }\n-                    TokenTree::Sequence(sp, ref seq_rep) => {\n+                    TokenTree::Sequence(sp, seq_rep) => {\n                         let subfirst = build_recur(sets, &seq_rep.tts);\n \n                         match sets.first.entry(sp.entire()) {\n@@ -804,22 +804,22 @@ impl<'tt> FirstSets<'tt> {\n         let mut first = TokenSet::empty();\n         for tt in tts.iter() {\n             assert!(first.maybe_empty);\n-            match *tt {\n+            match tt {\n                 TokenTree::Token(..)\n                 | TokenTree::MetaVar(..)\n                 | TokenTree::MetaVarDecl(..)\n                 | TokenTree::MetaVarExpr(..) => {\n                     first.add_one(TtHandle::TtRef(tt));\n                     return first;\n                 }\n-                TokenTree::Delimited(span, ref delimited) => {\n+                TokenTree::Delimited(span, delimited) => {\n                     first.add_one(TtHandle::from_token_kind(\n                         token::OpenDelim(delimited.delim),\n                         span.open,\n                     ));\n                     return first;\n                 }\n-                TokenTree::Sequence(sp, ref seq_rep) => {\n+                TokenTree::Sequence(sp, seq_rep) => {\n                     let subfirst_owned;\n                     let subfirst = match self.first.get(&sp.entire()) {\n                         Some(Some(subfirst)) => subfirst,\n@@ -1041,7 +1041,7 @@ fn check_matcher_core<'tt>(\n \n         // First, update `last` so that it corresponds to the set\n         // of NT tokens that might end the sequence `... token`.\n-        match *token {\n+        match token {\n             TokenTree::Token(..)\n             | TokenTree::MetaVar(..)\n             | TokenTree::MetaVarDecl(..)\n@@ -1057,7 +1057,7 @@ fn check_matcher_core<'tt>(\n                     suffix_first = build_suffix_first();\n                 }\n             }\n-            TokenTree::Delimited(span, ref d) => {\n+            TokenTree::Delimited(span, d) => {\n                 let my_suffix = TokenSet::singleton(TtHandle::from_token_kind(\n                     token::CloseDelim(d.delim),\n                     span.close,\n@@ -1070,7 +1070,7 @@ fn check_matcher_core<'tt>(\n                 // against SUFFIX\n                 continue 'each_token;\n             }\n-            TokenTree::Sequence(_, ref seq_rep) => {\n+            TokenTree::Sequence(_, seq_rep) => {\n                 suffix_first = build_suffix_first();\n                 // The trick here: when we check the interior, we want\n                 // to include the separator (if any) as a potential\n@@ -1372,8 +1372,8 @@ fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n }\n \n fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n-    match *tt {\n-        mbe::TokenTree::Token(ref token) => pprust::token_to_string(&token).into(),\n+    match tt {\n+        mbe::TokenTree::Token(token) => pprust::token_to_string(&token).into(),\n         mbe::TokenTree::MetaVar(_, name) => format!(\"${}\", name),\n         mbe::TokenTree::MetaVarDecl(_, name, Some(kind)) => format!(\"${}:{}\", name, kind),\n         mbe::TokenTree::MetaVarDecl(_, name, None) => format!(\"${}:\", name),"}, {"sha": "b79835be73a7ec1dfd04438ea4257c8cc326bda7", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -47,8 +47,7 @@ impl<'a> Iterator for Frame<'a> {\n \n     fn next(&mut self) -> Option<&'a mbe::TokenTree> {\n         match self {\n-            Frame::Delimited { tts, ref mut idx, .. }\n-            | Frame::Sequence { tts, ref mut idx, .. } => {\n+            Frame::Delimited { tts, idx, .. } | Frame::Sequence { tts, idx, .. } => {\n                 let res = tts.get(*idx);\n                 *idx += 1;\n                 res\n@@ -220,13 +219,13 @@ pub(super) fn transcribe<'a>(\n                 let ident = MacroRulesNormalizedIdent::new(original_ident);\n                 if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {\n                     match cur_matched {\n-                        MatchedTokenTree(ref tt) => {\n+                        MatchedTokenTree(tt) => {\n                             // `tt`s are emitted into the output stream directly as \"raw tokens\",\n                             // without wrapping them into groups.\n                             let token = tt.clone();\n                             result.push(token);\n                         }\n-                        MatchedNonterminal(ref nt) => {\n+                        MatchedNonterminal(nt) => {\n                             // Other variables are emitted into the output stream as groups with\n                             // `Delimiter::Invisible` to maintain parsing priorities.\n                             // `Interpolated` is currently used for such groups in rustc parser.\n@@ -299,12 +298,11 @@ fn lookup_cur_matched<'a>(\n     interpolations: &'a FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n     repeats: &[(usize, usize)],\n ) -> Option<&'a NamedMatch> {\n-    interpolations.get(&ident).map(|matched| {\n-        let mut matched = matched;\n+    interpolations.get(&ident).map(|mut matched| {\n         for &(idx, _) in repeats {\n             match matched {\n                 MatchedTokenTree(_) | MatchedNonterminal(_) => break,\n-                MatchedSeq(ref ads) => matched = ads.get(idx).unwrap(),\n+                MatchedSeq(ads) => matched = ads.get(idx).unwrap(),\n             }\n         }\n \n@@ -339,7 +337,7 @@ impl LockstepIterSize {\n         match self {\n             LockstepIterSize::Unconstrained => other,\n             LockstepIterSize::Contradiction(_) => self,\n-            LockstepIterSize::Constraint(l_len, ref l_id) => match other {\n+            LockstepIterSize::Constraint(l_len, l_id) => match other {\n                 LockstepIterSize::Unconstrained => self,\n                 LockstepIterSize::Contradiction(_) => other,\n                 LockstepIterSize::Constraint(r_len, _) if l_len == r_len => self,\n@@ -378,33 +376,33 @@ fn lockstep_iter_size(\n     repeats: &[(usize, usize)],\n ) -> LockstepIterSize {\n     use mbe::TokenTree;\n-    match *tree {\n-        TokenTree::Delimited(_, ref delimited) => {\n+    match tree {\n+        TokenTree::Delimited(_, delimited) => {\n             delimited.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n                 size.with(lockstep_iter_size(tt, interpolations, repeats))\n             })\n         }\n-        TokenTree::Sequence(_, ref seq) => {\n+        TokenTree::Sequence(_, seq) => {\n             seq.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n                 size.with(lockstep_iter_size(tt, interpolations, repeats))\n             })\n         }\n         TokenTree::MetaVar(_, name) | TokenTree::MetaVarDecl(_, name, _) => {\n-            let name = MacroRulesNormalizedIdent::new(name);\n+            let name = MacroRulesNormalizedIdent::new(*name);\n             match lookup_cur_matched(name, interpolations, repeats) {\n                 Some(matched) => match matched {\n                     MatchedTokenTree(_) | MatchedNonterminal(_) => LockstepIterSize::Unconstrained,\n-                    MatchedSeq(ref ads) => LockstepIterSize::Constraint(ads.len(), name),\n+                    MatchedSeq(ads) => LockstepIterSize::Constraint(ads.len(), name),\n                 },\n                 _ => LockstepIterSize::Unconstrained,\n             }\n         }\n-        TokenTree::MetaVarExpr(_, ref expr) => {\n+        TokenTree::MetaVarExpr(_, expr) => {\n             let default_rslt = LockstepIterSize::Unconstrained;\n             let Some(ident) = expr.ident() else { return default_rslt; };\n             let name = MacroRulesNormalizedIdent::new(ident);\n             match lookup_cur_matched(name, interpolations, repeats) {\n-                Some(MatchedSeq(ref ads)) => {\n+                Some(MatchedSeq(ads)) => {\n                     default_rslt.with(LockstepIterSize::Constraint(ads.len(), name))\n                 }\n                 _ => default_rslt,\n@@ -449,7 +447,7 @@ fn count_repetitions<'a>(\n                     Some(_) => Err(out_of_bounds_err(cx, declared_lhs_depth, sp.entire(), \"count\")),\n                 }\n             }\n-            MatchedSeq(ref named_matches) => {\n+            MatchedSeq(named_matches) => {\n                 let new_declared_lhs_depth = declared_lhs_depth + 1;\n                 match depth_opt {\n                     None => named_matches\n@@ -472,7 +470,7 @@ fn count_repetitions<'a>(\n     // before we start counting. `matched` contains the various levels of the\n     // tree as we descend, and its final value is the subtree we are currently at.\n     for &(idx, _) in repeats {\n-        if let MatchedSeq(ref ads) = matched {\n+        if let MatchedSeq(ads) = matched {\n             matched = &ads[idx];\n         }\n     }"}, {"sha": "0726d922c84a3e494ccbec353c20e6df333ccd73", "filename": "compiler/rustc_expand/src/parse/tests.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -176,9 +176,9 @@ fn get_spans_of_pat_idents(src: &str) -> Vec<Span> {\n     }\n     impl<'a> visit::Visitor<'a> for PatIdentVisitor {\n         fn visit_pat(&mut self, p: &'a ast::Pat) {\n-            match p.kind {\n-                PatKind::Ident(_, ref ident, _) => {\n-                    self.spans.push(ident.span.clone());\n+            match &p.kind {\n+                PatKind::Ident(_, ident, _) => {\n+                    self.spans.push(ident.span);\n                 }\n                 _ => {\n                     visit::walk_pat(self, p);\n@@ -290,10 +290,8 @@ fn ttdelim_span() {\n         )\n         .unwrap();\n \n-        let tts: Vec<_> = match expr.kind {\n-            ast::ExprKind::MacCall(ref mac) => mac.args.tokens.clone().into_trees().collect(),\n-            _ => panic!(\"not a macro\"),\n-        };\n+        let ast::ExprKind::MacCall(mac) = &expr.kind else { panic!(\"not a macro\") };\n+        let tts: Vec<_> = mac.args.tokens.clone().into_trees().collect();\n \n         let span = tts.iter().rev().next().unwrap().span();\n \n@@ -318,11 +316,8 @@ fn out_of_line_mod() {\n         .unwrap()\n         .unwrap();\n \n-        if let ast::ItemKind::Mod(_, ref mod_kind) = item.kind {\n-            assert!(matches!(mod_kind, ast::ModKind::Loaded(items, ..) if items.len() == 2));\n-        } else {\n-            panic!();\n-        }\n+        let ast::ItemKind::Mod(_, mod_kind) = &item.kind else { panic!() };\n+        assert!(matches!(mod_kind, ast::ModKind::Loaded(items, ..) if items.len() == 2));\n     });\n }\n "}, {"sha": "341ae18541b3796a5c58c2a89cfe9c1051fc181b", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -597,8 +597,8 @@ impl server::SourceFile for Rustc<'_, '_> {\n     }\n \n     fn path(&mut self, file: &Self::SourceFile) -> String {\n-        match file.name {\n-            FileName::Real(ref name) => name\n+        match &file.name {\n+            FileName::Real(name) => name\n                 .local_path()\n                 .expect(\"attempting to get a file path in an imported file in `proc_macro::SourceFile::path`\")\n                 .to_str()"}, {"sha": "6435b05cef8a8bac5041a2fe8db5207c5d9b86d9", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -569,17 +569,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .bindings\n             .iter()\n             .map(|binding| {\n-                let kind = match binding.kind {\n-                    hir::TypeBindingKind::Equality { ref term } => match term {\n-                        hir::Term::Ty(ref ty) => {\n+                let kind = match &binding.kind {\n+                    hir::TypeBindingKind::Equality { term } => match term {\n+                        hir::Term::Ty(ty) => {\n                             ConvertedBindingKind::Equality(self.ast_ty_to_ty(ty).into())\n                         }\n-                        hir::Term::Const(ref c) => {\n+                        hir::Term::Const(c) => {\n                             let c = Const::from_anon_const(self.tcx(), c.def_id);\n                             ConvertedBindingKind::Equality(c.into())\n                         }\n                     },\n-                    hir::TypeBindingKind::Constraint { ref bounds } => {\n+                    hir::TypeBindingKind::Constraint { bounds } => {\n                         ConvertedBindingKind::Constraint(bounds)\n                     }\n                 };\n@@ -1928,7 +1928,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ) -> Result<(Ty<'tcx>, DefKind, DefId), ErrorGuaranteed> {\n         let tcx = self.tcx();\n         let assoc_ident = assoc_segment.ident;\n-        let qself_res = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.kind {\n+        let qself_res = if let hir::TyKind::Path(hir::QPath::Resolved(_, path)) = &qself.kind {\n             path.res\n         } else {\n             Res::Err\n@@ -1971,8 +1971,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 return;\n                             };\n                             let (qself_sugg_span, is_self) = if let hir::TyKind::Path(\n-                                hir::QPath::Resolved(_, ref path)\n-                            ) = qself.kind {\n+                                hir::QPath::Resolved(_, path)\n+                            ) = &qself.kind {\n                                 // If the path segment already has type params, we want to overwrite\n                                 // them.\n                                 match &path.segments[..] {\n@@ -2760,7 +2760,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         \"generic `Self` types are currently not permitted in anonymous constants\",\n                     );\n                     if let Some(hir::Node::Item(&hir::Item {\n-                        kind: hir::ItemKind::Impl(ref impl_),\n+                        kind: hir::ItemKind::Impl(impl_),\n                         ..\n                     })) = tcx.hir().get_if_local(def_id)\n                     {\n@@ -2843,12 +2843,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn ast_ty_to_ty_inner(&self, ast_ty: &hir::Ty<'_>, borrowed: bool, in_path: bool) -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n-        let result_ty = match ast_ty.kind {\n-            hir::TyKind::Slice(ref ty) => tcx.mk_slice(self.ast_ty_to_ty(ty)),\n-            hir::TyKind::Ptr(ref mt) => {\n+        let result_ty = match &ast_ty.kind {\n+            hir::TyKind::Slice(ty) => tcx.mk_slice(self.ast_ty_to_ty(ty)),\n+            hir::TyKind::Ptr(mt) => {\n                 tcx.mk_ptr(ty::TypeAndMut { ty: self.ast_ty_to_ty(mt.ty), mutbl: mt.mutbl })\n             }\n-            hir::TyKind::Ref(ref region, ref mt) => {\n+            hir::TyKind::Ref(region, mt) => {\n                 let r = self.ast_region_to_region(region, None);\n                 debug!(?r);\n                 let t = self.ast_ty_to_ty_inner(mt.ty, true, false);\n@@ -2868,20 +2868,20 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     Some(ast_ty),\n                 ))\n             }\n-            hir::TyKind::TraitObject(bounds, ref lifetime, repr) => {\n+            hir::TyKind::TraitObject(bounds, lifetime, repr) => {\n                 self.maybe_lint_bare_trait(ast_ty, in_path);\n                 let repr = match repr {\n                     TraitObjectSyntax::Dyn | TraitObjectSyntax::None => ty::Dyn,\n                     TraitObjectSyntax::DynStar => ty::DynStar,\n                 };\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime, borrowed, repr)\n             }\n-            hir::TyKind::Path(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n+            hir::TyKind::Path(hir::QPath::Resolved(maybe_qself, path)) => {\n                 debug!(?maybe_qself, ?path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.ast_ty_to_ty(qself));\n                 self.res_to_ty(opt_self_ty, path, false)\n             }\n-            hir::TyKind::OpaqueDef(item_id, lifetimes, in_trait) => {\n+            &hir::TyKind::OpaqueDef(item_id, lifetimes, in_trait) => {\n                 let opaque_ty = tcx.hir().item(item_id);\n                 let def_id = item_id.owner_id.to_def_id();\n \n@@ -2892,14 +2892,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 }\n             }\n-            hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n+            hir::TyKind::Path(hir::QPath::TypeRelative(qself, segment)) => {\n                 debug!(?qself, ?segment);\n                 let ty = self.ast_ty_to_ty_inner(qself, false, true);\n                 self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, qself, segment, false)\n                     .map(|(ty, _, _)| ty)\n                     .unwrap_or_else(|_| tcx.ty_error())\n             }\n-            hir::TyKind::Path(hir::QPath::LangItem(lang_item, span, _)) => {\n+            &hir::TyKind::Path(hir::QPath::LangItem(lang_item, span, _)) => {\n                 let def_id = tcx.require_lang_item(lang_item, Some(span));\n                 let (substs, _) = self.create_substs_for_ast_path(\n                     span,\n@@ -2913,7 +2913,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 );\n                 EarlyBinder(tcx.at(span).type_of(def_id)).subst(tcx, substs)\n             }\n-            hir::TyKind::Array(ref ty, ref length) => {\n+            hir::TyKind::Array(ty, length) => {\n                 let length = match length {\n                     &hir::ArrayLen::Infer(_, span) => self.ct_infer(tcx.types.usize, None, span),\n                     hir::ArrayLen::Body(constant) => {\n@@ -2923,7 +2923,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                 tcx.mk_ty(ty::Array(self.ast_ty_to_ty(ty), length))\n             }\n-            hir::TyKind::Typeof(ref e) => {\n+            hir::TyKind::Typeof(e) => {\n                 let ty_erased = tcx.type_of(e.def_id);\n                 let ty = tcx.fold_regions(ty_erased, |r, _| {\n                     if r.is_erased() { tcx.lifetimes.re_static } else { r }"}, {"sha": "aa75132444a5a8d489fcc85a968deae9b79cbcc9", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -531,9 +531,7 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n         DefKind::Fn => {} // entirely within check_item_body\n         DefKind::Impl => {\n             let it = tcx.hir().item(id);\n-            let hir::ItemKind::Impl(ref impl_) = it.kind else {\n-                return;\n-            };\n+            let hir::ItemKind::Impl(impl_) = it.kind else { return };\n             debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.owner_id);\n             if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.owner_id) {\n                 check_impl_items_against_trait(\n@@ -548,15 +546,15 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n         }\n         DefKind::Trait => {\n             let it = tcx.hir().item(id);\n-            let hir::ItemKind::Trait(_, _, _, _, ref items) = it.kind else {\n+            let hir::ItemKind::Trait(_, _, _, _, items) = it.kind else {\n                 return;\n             };\n             check_on_unimplemented(tcx, it);\n \n             for item in items.iter() {\n                 let item = tcx.hir().trait_item(item.id);\n-                match item.kind {\n-                    hir::TraitItemKind::Fn(ref sig, _) => {\n+                match &item.kind {\n+                    hir::TraitItemKind::Fn(sig, _) => {\n                         let abi = sig.header.abi;\n                         fn_maybe_err(tcx, item.ident.span, abi);\n                     }\n@@ -652,8 +650,8 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n                     }\n \n                     let item = tcx.hir().foreign_item(item.id);\n-                    match item.kind {\n-                        hir::ForeignItemKind::Fn(ref fn_decl, _, _) => {\n+                    match &item.kind {\n+                        hir::ForeignItemKind::Fn(fn_decl, _, _) => {\n                             require_c_abi_if_c_variadic(tcx, fn_decl, abi, item.span);\n                         }\n                         hir::ForeignItemKind::Static(..) => {"}, {"sha": "cfebcceef3cdb1e1096907e76fd6df256d5dbdd5", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 98, "deletions": 137, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -47,42 +47,22 @@ pub(super) fn compare_impl_method<'tcx>(\n \n     let impl_m_span = tcx.def_span(impl_m.def_id);\n \n-    if let Err(_) = compare_self_type(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref) {\n-        return;\n-    }\n-\n-    if let Err(_) = compare_number_of_generics(tcx, impl_m, trait_m, trait_item_span, false) {\n-        return;\n-    }\n-\n-    if let Err(_) = compare_generic_param_kinds(tcx, impl_m, trait_m, false) {\n-        return;\n-    }\n-\n-    if let Err(_) =\n-        compare_number_of_method_arguments(tcx, impl_m, impl_m_span, trait_m, trait_item_span)\n-    {\n-        return;\n-    }\n-\n-    if let Err(_) = compare_synthetic_generics(tcx, impl_m, trait_m) {\n-        return;\n-    }\n-\n-    if let Err(_) = compare_asyncness(tcx, impl_m, impl_m_span, trait_m, trait_item_span) {\n-        return;\n-    }\n-\n-    if let Err(_) = compare_method_predicate_entailment(\n-        tcx,\n-        impl_m,\n-        impl_m_span,\n-        trait_m,\n-        impl_trait_ref,\n-        CheckImpliedWfMode::Check,\n-    ) {\n-        return;\n-    }\n+    let _: Result<_, ErrorGuaranteed> = try {\n+        compare_self_type(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref)?;\n+        compare_number_of_generics(tcx, impl_m, trait_m, trait_item_span, false)?;\n+        compare_generic_param_kinds(tcx, impl_m, trait_m, false)?;\n+        compare_number_of_method_arguments(tcx, impl_m, impl_m_span, trait_m, trait_item_span)?;\n+        compare_synthetic_generics(tcx, impl_m, trait_m)?;\n+        compare_asyncness(tcx, impl_m, impl_m_span, trait_m, trait_item_span)?;\n+        compare_method_predicate_entailment(\n+            tcx,\n+            impl_m,\n+            impl_m_span,\n+            trait_m,\n+            impl_trait_ref,\n+            CheckImpliedWfMode::Check,\n+        )?;\n+    };\n }\n \n /// This function is best explained by example. Consider a trait:\n@@ -936,16 +916,14 @@ fn report_trait_method_mismatch<'tcx>(\n             // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n             // span points only at the type `Box<Self`>, but we want to cover the whole\n             // argument pattern and type.\n-            let span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                ImplItemKind::Fn(ref sig, body) => tcx\n-                    .hir()\n-                    .body_param_names(body)\n-                    .zip(sig.decl.inputs.iter())\n-                    .map(|(param, ty)| param.span.to(ty.span))\n-                    .next()\n-                    .unwrap_or(impl_err_span),\n-                _ => bug!(\"{:?} is not a method\", impl_m),\n-            };\n+            let ImplItemKind::Fn(ref sig, body) = tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{impl_m:?} is not a method\") };\n+            let span = tcx\n+                .hir()\n+                .body_param_names(body)\n+                .zip(sig.decl.inputs.iter())\n+                .map(|(param, ty)| param.span.to(ty.span))\n+                .next()\n+                .unwrap_or(impl_err_span);\n \n             diag.span_suggestion(\n                 span,\n@@ -958,22 +936,21 @@ fn report_trait_method_mismatch<'tcx>(\n             if trait_sig.inputs().len() == *i {\n                 // Suggestion to change output type. We do not suggest in `async` functions\n                 // to avoid complex logic or incorrect output.\n-                match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                    ImplItemKind::Fn(ref sig, _) if !sig.header.asyncness.is_async() => {\n-                        let msg = \"change the output type to match the trait\";\n-                        let ap = Applicability::MachineApplicable;\n-                        match sig.decl.output {\n-                            hir::FnRetTy::DefaultReturn(sp) => {\n-                                let sugg = format!(\"-> {} \", trait_sig.output());\n-                                diag.span_suggestion_verbose(sp, msg, sugg, ap);\n-                            }\n-                            hir::FnRetTy::Return(hir_ty) => {\n-                                let sugg = trait_sig.output();\n-                                diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n-                            }\n-                        };\n-                    }\n-                    _ => {}\n+                if let ImplItemKind::Fn(sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind\n+                    && !sig.header.asyncness.is_async()\n+                {\n+                    let msg = \"change the output type to match the trait\";\n+                    let ap = Applicability::MachineApplicable;\n+                    match sig.decl.output {\n+                        hir::FnRetTy::DefaultReturn(sp) => {\n+                            let sugg = format!(\"-> {} \", trait_sig.output());\n+                            diag.span_suggestion_verbose(sp, msg, sugg, ap);\n+                        }\n+                        hir::FnRetTy::Return(hir_ty) => {\n+                            let sugg = trait_sig.output();\n+                            diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n+                        }\n+                    };\n                 };\n             } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n                 diag.span_suggestion(\n@@ -1100,25 +1077,18 @@ fn extract_spans_for_error_reporting<'tcx>(\n     trait_m: &ty::AssocItem,\n ) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n-    let mut impl_args = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-        ImplItemKind::Fn(ref sig, _) => {\n-            sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n-        }\n-        _ => bug!(\"{:?} is not a method\", impl_m),\n+    let mut impl_args = {\n+        let ImplItemKind::Fn(sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+        sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n     };\n-    let trait_args =\n-        trait_m.def_id.as_local().map(|def_id| match tcx.hir().expect_trait_item(def_id).kind {\n-            TraitItemKind::Fn(ref sig, _) => {\n-                sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n-            }\n-            _ => bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m),\n-        });\n+\n+    let trait_args = trait_m.def_id.as_local().map(|def_id| {\n+        let TraitItemKind::Fn(sig, _) = &tcx.hir().expect_trait_item(def_id).kind else { bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m) };\n+        sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n+    });\n \n     match terr {\n-        TypeError::ArgumentMutability(i) => {\n-            (impl_args.nth(i).unwrap(), trait_args.and_then(|mut args| args.nth(i)))\n-        }\n-        TypeError::ArgumentSorts(ExpectedFound { .. }, i) => {\n+        TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(ExpectedFound { .. }, i) => {\n             (impl_args.nth(i).unwrap(), trait_args.and_then(|mut args| args.nth(i)))\n         }\n         _ => (cause.span(), tcx.hir().span_if_local(trait_m.def_id)),\n@@ -1178,8 +1148,7 @@ fn compare_self_type<'tcx>(\n             } else {\n                 err.note_trait_signature(trait_m.name, trait_m.signature(tcx));\n             }\n-            let reported = err.emit();\n-            return Err(reported);\n+            return Err(err.emit());\n         }\n \n         (true, false) => {\n@@ -1198,8 +1167,8 @@ fn compare_self_type<'tcx>(\n             } else {\n                 err.note_trait_signature(trait_m.name, trait_m.signature(tcx));\n             }\n-            let reported = err.emit();\n-            return Err(reported);\n+\n+            return Err(err.emit());\n         }\n     }\n \n@@ -1381,41 +1350,39 @@ fn compare_number_of_method_arguments<'tcx>(\n     let trait_m_fty = tcx.fn_sig(trait_m.def_id);\n     let trait_number_args = trait_m_fty.inputs().skip_binder().len();\n     let impl_number_args = impl_m_fty.inputs().skip_binder().len();\n+\n     if trait_number_args != impl_number_args {\n-        let trait_span = if let Some(def_id) = trait_m.def_id.as_local() {\n-            match tcx.hir().expect_trait_item(def_id).kind {\n-                TraitItemKind::Fn(ref trait_m_sig, _) => {\n-                    let pos = if trait_number_args > 0 { trait_number_args - 1 } else { 0 };\n-                    if let Some(arg) = trait_m_sig.decl.inputs.get(pos) {\n-                        Some(if pos == 0 {\n-                            arg.span\n-                        } else {\n-                            arg.span.with_lo(trait_m_sig.decl.inputs[0].span.lo())\n-                        })\n-                    } else {\n-                        trait_item_span\n-                    }\n-                }\n-                _ => bug!(\"{:?} is not a method\", impl_m),\n-            }\n-        } else {\n-            trait_item_span\n-        };\n-        let impl_span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-            ImplItemKind::Fn(ref impl_m_sig, _) => {\n-                let pos = if impl_number_args > 0 { impl_number_args - 1 } else { 0 };\n-                if let Some(arg) = impl_m_sig.decl.inputs.get(pos) {\n+        let trait_span = trait_m\n+            .def_id\n+            .as_local()\n+            .and_then(|def_id| {\n+                let TraitItemKind::Fn(trait_m_sig, _) = &tcx.hir().expect_trait_item(def_id).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+                let pos = trait_number_args.saturating_sub(1);\n+                trait_m_sig.decl.inputs.get(pos).map(|arg| {\n                     if pos == 0 {\n                         arg.span\n                     } else {\n-                        arg.span.with_lo(impl_m_sig.decl.inputs[0].span.lo())\n+                        arg.span.with_lo(trait_m_sig.decl.inputs[0].span.lo())\n                     }\n+                })\n+            })\n+            .or(trait_item_span);\n+\n+        let ImplItemKind::Fn(impl_m_sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+        let pos = impl_number_args.saturating_sub(1);\n+        let impl_span = impl_m_sig\n+            .decl\n+            .inputs\n+            .get(pos)\n+            .map(|arg| {\n+                if pos == 0 {\n+                    arg.span\n                 } else {\n-                    impl_m_span\n+                    arg.span.with_lo(impl_m_sig.decl.inputs[0].span.lo())\n                 }\n-            }\n-            _ => bug!(\"{:?} is not a method\", impl_m),\n-        };\n+            })\n+            .unwrap_or(impl_m_span);\n+\n         let mut err = struct_span_err!(\n             tcx.sess,\n             impl_span,\n@@ -1426,6 +1393,7 @@ fn compare_number_of_method_arguments<'tcx>(\n             tcx.def_path_str(trait_m.def_id),\n             trait_number_args\n         );\n+\n         if let Some(trait_span) = trait_span {\n             err.span_label(\n                 trait_span,\n@@ -1437,6 +1405,7 @@ fn compare_number_of_method_arguments<'tcx>(\n         } else {\n             err.note_trait_signature(trait_m.name, trait_m.signature(tcx));\n         }\n+\n         err.span_label(\n             impl_span,\n             format!(\n@@ -1445,8 +1414,8 @@ fn compare_number_of_method_arguments<'tcx>(\n                 impl_number_args\n             ),\n         );\n-        let reported = err.emit();\n-        return Err(reported);\n+\n+        return Err(err.emit());\n     }\n \n     Ok(())\n@@ -1493,7 +1462,7 @@ fn compare_synthetic_generics<'tcx>(\n                 // explicit generics\n                 (true, false) => {\n                     err.span_label(impl_span, \"expected generic parameter, found `impl Trait`\");\n-                    (|| {\n+                    let _: Option<_> = try {\n                         // try taking the name from the trait impl\n                         // FIXME: this is obviously suboptimal since the name can already be used\n                         // as another generic argument\n@@ -1526,33 +1495,31 @@ fn compare_synthetic_generics<'tcx>(\n                             ],\n                             Applicability::MaybeIncorrect,\n                         );\n-                        Some(())\n-                    })();\n+                    };\n                 }\n                 // The case where the trait method uses `impl Trait`, but the impl method uses\n                 // explicit generics.\n                 (false, true) => {\n                     err.span_label(impl_span, \"expected `impl Trait`, found generic parameter\");\n-                    (|| {\n+                    let _: Option<_> = try {\n                         let impl_m = impl_m.def_id.as_local()?;\n                         let impl_m = tcx.hir().expect_impl_item(impl_m);\n-                        let input_tys = match impl_m.kind {\n-                            hir::ImplItemKind::Fn(ref sig, _) => sig.decl.inputs,\n-                            _ => unreachable!(),\n-                        };\n+                        let hir::ImplItemKind::Fn(sig, _) = &impl_m.kind else { unreachable!() };\n+                        let input_tys = sig.decl.inputs;\n+\n                         struct Visitor(Option<Span>, hir::def_id::LocalDefId);\n                         impl<'v> intravisit::Visitor<'v> for Visitor {\n                             fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n                                 intravisit::walk_ty(self, ty);\n-                                if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) =\n-                                    ty.kind\n+                                if let hir::TyKind::Path(hir::QPath::Resolved(None, path)) = ty.kind\n                                     && let Res::Def(DefKind::TyParam, def_id) = path.res\n                                     && def_id == self.1.to_def_id()\n                                 {\n                                     self.0 = Some(ty.span);\n                                 }\n                             }\n                         }\n+\n                         let mut visitor = Visitor(None, impl_def_id);\n                         for ty in input_tys {\n                             intravisit::Visitor::visit_ty(&mut visitor, ty);\n@@ -1573,13 +1540,11 @@ fn compare_synthetic_generics<'tcx>(\n                             ],\n                             Applicability::MaybeIncorrect,\n                         );\n-                        Some(())\n-                    })();\n+                    };\n                 }\n                 _ => unreachable!(),\n             }\n-            let reported = err.emit();\n-            error_found = Some(reported);\n+            error_found = Some(err.emit());\n         }\n     }\n     if let Some(reported) = error_found { Err(reported) } else { Ok(()) }\n@@ -1739,10 +1704,8 @@ pub(super) fn compare_impl_const_raw(\n         );\n \n         // Locate the Span containing just the type of the offending impl\n-        match tcx.hir().expect_impl_item(impl_const_item_def).kind {\n-            ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n-            _ => bug!(\"{:?} is not a impl const\", impl_const_item),\n-        }\n+        let ImplItemKind::Const(ty, _) = tcx.hir().expect_impl_item(impl_const_item_def).kind else { bug!(\"{impl_const_item:?} is not a impl const\") };\n+        cause.span = ty.span;\n \n         let mut diag = struct_span_err!(\n             tcx.sess,\n@@ -1754,10 +1717,8 @@ pub(super) fn compare_impl_const_raw(\n \n         let trait_c_span = trait_const_item_def.as_local().map(|trait_c_def_id| {\n             // Add a label to the Span containing just the type of the const\n-            match tcx.hir().expect_trait_item(trait_c_def_id).kind {\n-                TraitItemKind::Const(ref ty, _) => ty.span,\n-                _ => bug!(\"{:?} is not a trait const\", trait_const_item),\n-            }\n+            let TraitItemKind::Const(ty, _) = tcx.hir().expect_trait_item(trait_c_def_id).kind else { bug!(\"{trait_const_item:?} is not a trait const\") };\n+            ty.span\n         });\n \n         infcx.err_ctxt().note_type_err(\n@@ -1799,16 +1760,16 @@ pub(super) fn compare_impl_ty<'tcx>(\n ) {\n     debug!(\"compare_impl_type(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    let _: Result<(), ErrorGuaranteed> = (|| {\n+    let _: Result<(), ErrorGuaranteed> = try {\n         compare_number_of_generics(tcx, impl_ty, trait_ty, trait_item_span, false)?;\n \n         compare_generic_param_kinds(tcx, impl_ty, trait_ty, false)?;\n \n         let sp = tcx.def_span(impl_ty.def_id);\n         compare_type_predicate_entailment(tcx, impl_ty, sp, trait_ty, impl_trait_ref)?;\n \n-        check_type_bounds(tcx, trait_ty, impl_ty, impl_ty_span, impl_trait_ref)\n-    })();\n+        check_type_bounds(tcx, trait_ty, impl_ty, impl_ty_span, impl_trait_ref)?;\n+    };\n }\n \n /// The equivalent of [compare_method_predicate_entailment], but for associated types"}, {"sha": "82030d82f57a0536f90667df5ba79183aeed8f02", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -351,7 +351,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n             }\n \n             match *op {\n-                hir::InlineAsmOperand::In { reg, ref expr } => {\n+                hir::InlineAsmOperand::In { reg, expr } => {\n                     self.check_asm_operand_type(\n                         idx,\n                         reg,\n@@ -362,7 +362,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                         &target_features,\n                     );\n                 }\n-                hir::InlineAsmOperand::Out { reg, late: _, ref expr } => {\n+                hir::InlineAsmOperand::Out { reg, late: _, expr } => {\n                     if let Some(expr) = expr {\n                         self.check_asm_operand_type(\n                             idx,\n@@ -375,7 +375,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                         );\n                     }\n                 }\n-                hir::InlineAsmOperand::InOut { reg, late: _, ref expr } => {\n+                hir::InlineAsmOperand::InOut { reg, late: _, expr } => {\n                     self.check_asm_operand_type(\n                         idx,\n                         reg,\n@@ -386,7 +386,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                         &target_features,\n                     );\n                 }\n-                hir::InlineAsmOperand::SplitInOut { reg, late: _, ref in_expr, ref out_expr } => {\n+                hir::InlineAsmOperand::SplitInOut { reg, late: _, in_expr, out_expr } => {\n                     let in_ty = self.check_asm_operand_type(\n                         idx,\n                         reg,"}, {"sha": "b28bfb1d54b6ca7d1bc256a16b564ffe954a720f", "filename": "compiler/rustc_hir_analysis/src/check/region.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -180,7 +180,7 @@ fn resolve_arm<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, arm: &'tcx hir\n \n     visitor.terminating_scopes.insert(arm.body.hir_id.local_id);\n \n-    if let Some(hir::Guard::If(ref expr)) = arm.guard {\n+    if let Some(hir::Guard::If(expr)) = arm.guard {\n         visitor.terminating_scopes.insert(expr.hir_id.local_id);\n     }\n \n@@ -242,8 +242,8 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             // This ensures fixed size stacks.\n             hir::ExprKind::Binary(\n                 source_map::Spanned { node: hir::BinOpKind::And | hir::BinOpKind::Or, .. },\n-                ref l,\n-                ref r,\n+                l,\n+                r,\n             ) => {\n                 // expr is a short circuiting operator (|| or &&). As its\n                 // functionality can't be overridden by traits, it always\n@@ -288,20 +288,20 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n                     terminating(r.hir_id.local_id);\n                 }\n             }\n-            hir::ExprKind::If(_, ref then, Some(ref otherwise)) => {\n+            hir::ExprKind::If(_, then, Some(otherwise)) => {\n                 terminating(then.hir_id.local_id);\n                 terminating(otherwise.hir_id.local_id);\n             }\n \n-            hir::ExprKind::If(_, ref then, None) => {\n+            hir::ExprKind::If(_, then, None) => {\n                 terminating(then.hir_id.local_id);\n             }\n \n-            hir::ExprKind::Loop(ref body, _, _, _) => {\n+            hir::ExprKind::Loop(body, _, _, _) => {\n                 terminating(body.hir_id.local_id);\n             }\n \n-            hir::ExprKind::DropTemps(ref expr) => {\n+            hir::ExprKind::DropTemps(expr) => {\n                 // `DropTemps(expr)` does not denote a conditional scope.\n                 // Rather, we want to achieve the same behavior as `{ let _t = expr; _t }`.\n                 terminating(expr.hir_id.local_id);\n@@ -396,7 +396,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             let body = visitor.tcx.hir().body(body);\n             visitor.visit_body(body);\n         }\n-        hir::ExprKind::AssignOp(_, ref left_expr, ref right_expr) => {\n+        hir::ExprKind::AssignOp(_, left_expr, right_expr) => {\n             debug!(\n                 \"resolve_expr - enabling pessimistic_yield, was previously {}\",\n                 prev_pessimistic\n@@ -447,7 +447,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             }\n         }\n \n-        hir::ExprKind::If(ref cond, ref then, Some(ref otherwise)) => {\n+        hir::ExprKind::If(cond, then, Some(otherwise)) => {\n             let expr_cx = visitor.cx;\n             visitor.enter_scope(Scope { id: then.hir_id.local_id, data: ScopeData::IfThen });\n             visitor.cx.var_parent = visitor.cx.parent;\n@@ -457,7 +457,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             visitor.visit_expr(otherwise);\n         }\n \n-        hir::ExprKind::If(ref cond, ref then, None) => {\n+        hir::ExprKind::If(cond, then, None) => {\n             let expr_cx = visitor.cx;\n             visitor.enter_scope(Scope { id: then.hir_id.local_id, data: ScopeData::IfThen });\n             visitor.cx.var_parent = visitor.cx.parent;\n@@ -641,21 +641,21 @@ fn resolve_local<'tcx>(\n         match pat.kind {\n             PatKind::Binding(hir::BindingAnnotation(hir::ByRef::Yes, _), ..) => true,\n \n-            PatKind::Struct(_, ref field_pats, _) => {\n+            PatKind::Struct(_, field_pats, _) => {\n                 field_pats.iter().any(|fp| is_binding_pat(&fp.pat))\n             }\n \n-            PatKind::Slice(ref pats1, ref pats2, ref pats3) => {\n+            PatKind::Slice(pats1, pats2, pats3) => {\n                 pats1.iter().any(|p| is_binding_pat(&p))\n                     || pats2.iter().any(|p| is_binding_pat(&p))\n                     || pats3.iter().any(|p| is_binding_pat(&p))\n             }\n \n-            PatKind::Or(ref subpats)\n-            | PatKind::TupleStruct(_, ref subpats, _)\n-            | PatKind::Tuple(ref subpats, _) => subpats.iter().any(|p| is_binding_pat(&p)),\n+            PatKind::Or(subpats)\n+            | PatKind::TupleStruct(_, subpats, _)\n+            | PatKind::Tuple(subpats, _) => subpats.iter().any(|p| is_binding_pat(&p)),\n \n-            PatKind::Box(ref subpat) => is_binding_pat(&subpat),\n+            PatKind::Box(subpat) => is_binding_pat(&subpat),\n \n             PatKind::Ref(_, _)\n             | PatKind::Binding(hir::BindingAnnotation(hir::ByRef::No, _), ..)\n@@ -704,11 +704,11 @@ fn resolve_local<'tcx>(\n                     record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n                 }\n             }\n-            hir::ExprKind::Cast(ref subexpr, _) => {\n+            hir::ExprKind::Cast(subexpr, _) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id)\n             }\n-            hir::ExprKind::Block(ref block, _) => {\n-                if let Some(ref subexpr) = block.expr {\n+            hir::ExprKind::Block(block, _) => {\n+                if let Some(subexpr) = block.expr {\n                     record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n                 }\n             }"}, {"sha": "11237afe8a0e36f50b7153370acbe3c20e51b81b", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -178,7 +178,7 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         //\n         // won't be allowed unless there's an *explicit* implementation of `Send`\n         // for `T`\n-        hir::ItemKind::Impl(ref impl_) => {\n+        hir::ItemKind::Impl(impl_) => {\n             let is_auto = tcx\n                 .impl_trait_ref(def_id)\n                 .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.skip_binder().def_id));\n@@ -224,15 +224,15 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         hir::ItemKind::Const(ty, ..) => {\n             check_item_type(tcx, def_id, ty.span, false);\n         }\n-        hir::ItemKind::Struct(_, ref ast_generics) => {\n+        hir::ItemKind::Struct(_, ast_generics) => {\n             check_type_defn(tcx, item, false);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Union(_, ref ast_generics) => {\n+        hir::ItemKind::Union(_, ast_generics) => {\n             check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Enum(_, ref ast_generics) => {\n+        hir::ItemKind::Enum(_, ast_generics) => {\n             check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n@@ -1247,8 +1247,8 @@ fn check_impl<'tcx>(\n     constness: hir::Constness,\n ) {\n     enter_wf_checking_ctxt(tcx, item.span, item.owner_id.def_id, |wfcx| {\n-        match *ast_trait_ref {\n-            Some(ref ast_trait_ref) => {\n+        match ast_trait_ref {\n+            Some(ast_trait_ref) => {\n                 // `#[rustc_reservation_impl]` impls are not real impls and\n                 // therefore don't need to be WF (the trait's `Self: Trait` predicate\n                 // won't hold)."}, {"sha": "55de68f83f28413c1522fb23c7a9ffef99f9c75b", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -54,12 +54,9 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n         _ => {}\n     }\n \n-    let sp = match tcx.hir().expect_item(impl_did).kind {\n-        ItemKind::Impl(ref impl_) => impl_.self_ty.span,\n-        _ => bug!(\"expected Drop impl item\"),\n-    };\n+    let ItemKind::Impl(impl_) = tcx.hir().expect_item(impl_did).kind else { bug!(\"expected Drop impl item\") };\n \n-    tcx.sess.emit_err(DropImplOnWrongItem { span: sp });\n+    tcx.sess.emit_err(DropImplOnWrongItem { span: impl_.self_ty.span });\n }\n \n fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n@@ -505,12 +502,11 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                 return err_info;\n             } else if diff_fields.len() > 1 {\n                 let item = tcx.hir().expect_item(impl_did);\n-                let span =\n-                    if let ItemKind::Impl(hir::Impl { of_trait: Some(ref t), .. }) = item.kind {\n-                        t.path.span\n-                    } else {\n-                        tcx.def_span(impl_did)\n-                    };\n+                let span = if let ItemKind::Impl(hir::Impl { of_trait: Some(t), .. }) = &item.kind {\n+                    t.path.span\n+                } else {\n+                    tcx.def_span(impl_did)\n+                };\n \n                 struct_span_err!(\n                     tcx.sess,"}, {"sha": "dfb9824094346949c74b14f117fdd45dbaf6b375", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -182,7 +182,7 @@ impl<'tcx> InherentCollect<'tcx> {\n         }\n \n         let item = self.tcx.hir().item(id);\n-        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, ref items, .. }) = item.kind else {\n+        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, items, .. }) = item.kind else {\n             return;\n         };\n "}, {"sha": "95b03eb8263fda2031504dd4ef6a22319b31b23a", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -40,7 +40,7 @@ fn do_orphan_check_impl<'tcx>(\n     let trait_def_id = trait_ref.def_id;\n \n     let item = tcx.hir().expect_item(def_id);\n-    let hir::ItemKind::Impl(ref impl_) = item.kind else {\n+    let hir::ItemKind::Impl(impl_) = item.kind else {\n         bug!(\"{:?} is not an impl: {:?}\", def_id, item);\n     };\n     let sp = tcx.def_span(def_id);"}, {"sha": "fe6119dce873573baf819591798c33e3ecc19b92", "filename": "compiler/rustc_hir_analysis/src/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -11,7 +11,7 @@ use rustc_span::def_id::LocalDefId;\n pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     debug_assert!(matches!(tcx.def_kind(def_id), DefKind::Impl));\n     let item = tcx.hir().expect_item(def_id);\n-    let hir::ItemKind::Impl(ref impl_) = item.kind else { bug!() };\n+    let hir::ItemKind::Impl(impl_) = item.kind else { bug!() };\n \n     if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n         let trait_ref = trait_ref.subst_identity();"}, {"sha": "c17778ce8bc090e934b82b8399a5d05aa501ac22", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -561,15 +561,15 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id());\n     let def_id = item_id.owner_id.def_id;\n \n-    match it.kind {\n+    match &it.kind {\n         // These don't define types.\n         hir::ItemKind::ExternCrate(_)\n         | hir::ItemKind::Use(..)\n         | hir::ItemKind::Macro(..)\n         | hir::ItemKind::Mod(_)\n         | hir::ItemKind::GlobalAsm(_) => {}\n         hir::ItemKind::ForeignMod { items, .. } => {\n-            for item in items {\n+            for item in *items {\n                 let item = tcx.hir().foreign_item(item.id);\n                 tcx.ensure().generics_of(item.owner_id);\n                 tcx.ensure().type_of(item.owner_id);\n@@ -619,7 +619,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n             tcx.at(it.span).super_predicates_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n         }\n-        hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n+        hir::ItemKind::Struct(struct_def, _) | hir::ItemKind::Union(struct_def, _) => {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().type_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n@@ -854,14 +854,14 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtDef<'_> {\n     };\n \n     let repr = tcx.repr_options_of_def(def_id.to_def_id());\n-    let (kind, variants) = match item.kind {\n-        ItemKind::Enum(ref def, _) => {\n+    let (kind, variants) = match &item.kind {\n+        ItemKind::Enum(def, _) => {\n             let mut distance_from_explicit = 0;\n             let variants = def\n                 .variants\n                 .iter()\n                 .map(|v| {\n-                    let discr = if let Some(ref e) = v.disr_expr {\n+                    let discr = if let Some(e) = &v.disr_expr {\n                         distance_from_explicit = 0;\n                         ty::VariantDiscr::Explicit(e.def_id.to_def_id())\n                     } else {\n@@ -883,7 +883,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtDef<'_> {\n \n             (AdtKind::Enum, variants)\n         }\n-        ItemKind::Struct(ref def, _) | ItemKind::Union(ref def, _) => {\n+        ItemKind::Struct(def, _) | ItemKind::Union(def, _) => {\n             let adt_kind = match item.kind {\n                 ItemKind::Struct(..) => AdtKind::Struct,\n                 _ => AdtKind::Union,\n@@ -1343,21 +1343,19 @@ fn suggest_impl_trait<'tcx>(\n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::EarlyBinder<ty::TraitRef<'_>>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n     let item = tcx.hir().expect_item(def_id.expect_local());\n-    match item.kind {\n-        hir::ItemKind::Impl(ref impl_) => impl_\n-            .of_trait\n-            .as_ref()\n-            .map(|ast_trait_ref| {\n-                let selfty = tcx.type_of(def_id);\n-                icx.astconv().instantiate_mono_trait_ref(\n-                    ast_trait_ref,\n-                    selfty,\n-                    check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n-                )\n-            })\n-            .map(ty::EarlyBinder),\n-        _ => bug!(),\n-    }\n+    let hir::ItemKind::Impl(impl_) = item.kind else { bug!() };\n+    impl_\n+        .of_trait\n+        .as_ref()\n+        .map(|ast_trait_ref| {\n+            let selfty = tcx.type_of(def_id);\n+            icx.astconv().instantiate_mono_trait_ref(\n+                ast_trait_ref,\n+                selfty,\n+                check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n+            )\n+        })\n+        .map(ty::EarlyBinder)\n }\n \n fn check_impl_constness(\n@@ -1512,7 +1510,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n         for (input, ty) in iter::zip(decl.inputs, fty.inputs().skip_binder()) {\n             check(input, *ty)\n         }\n-        if let hir::FnRetTy::Return(ref ty) = decl.output {\n+        if let hir::FnRetTy::Return(ty) = decl.output {\n             check(ty, fty.output().skip_binder())\n         }\n     }"}, {"sha": "014ee9fcc207b425b06bac78729f606d2fbc6ebd", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -110,12 +110,12 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                     // expressions' count (i.e. `N` in `[x; N]`), and explicit\n                     // `enum` discriminants (i.e. `D` in `enum Foo { Bar = D }`),\n                     // as they shouldn't be able to cause query cycle errors.\n-                    Node::Expr(&Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n+                    Node::Expr(Expr { kind: ExprKind::Repeat(_, constant), .. })\n                         if constant.hir_id() == hir_id =>\n                     {\n                         Some(parent_def_id.to_def_id())\n                     }\n-                    Node::Variant(Variant { disr_expr: Some(ref constant), .. })\n+                    Node::Variant(Variant { disr_expr: Some(constant), .. })\n                         if constant.hir_id == hir_id =>\n                     {\n                         Some(parent_def_id.to_def_id())\n@@ -259,7 +259,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n \n     params.extend(ast_generics.params.iter().filter_map(|param| match param.kind {\n         GenericParamKind::Lifetime { .. } => None,\n-        GenericParamKind::Type { ref default, synthetic, .. } => {\n+        GenericParamKind::Type { default, synthetic, .. } => {\n             if default.is_some() {\n                 match allow_defaults {\n                     Defaults::Allowed => {}\n@@ -426,26 +426,22 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n     }\n \n     match node {\n-        Node::TraitItem(item) => match item.kind {\n-            hir::TraitItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, &item.generics, sig.decl)\n-            }\n+        Node::TraitItem(item) => match &item.kind {\n+            hir::TraitItemKind::Fn(sig, _) => has_late_bound_regions(tcx, &item.generics, sig.decl),\n             _ => None,\n         },\n-        Node::ImplItem(item) => match item.kind {\n-            hir::ImplItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, &item.generics, sig.decl)\n-            }\n+        Node::ImplItem(item) => match &item.kind {\n+            hir::ImplItemKind::Fn(sig, _) => has_late_bound_regions(tcx, &item.generics, sig.decl),\n             _ => None,\n         },\n         Node::ForeignItem(item) => match item.kind {\n-            hir::ForeignItemKind::Fn(fn_decl, _, ref generics) => {\n+            hir::ForeignItemKind::Fn(fn_decl, _, generics) => {\n                 has_late_bound_regions(tcx, generics, fn_decl)\n             }\n             _ => None,\n         },\n-        Node::Item(item) => match item.kind {\n-            hir::ItemKind::Fn(ref sig, .., ref generics, _) => {\n+        Node::Item(item) => match &item.kind {\n+            hir::ItemKind::Fn(sig, .., generics, _) => {\n                 has_late_bound_regions(tcx, generics, sig.decl)\n             }\n             _ => None,"}, {"sha": "359122d4e16abd81c0f79463bcdad18cc21c4230", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -428,7 +428,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             _ => {}\n         }\n         match item.kind {\n-            hir::ItemKind::Fn(_, ref generics, _) => {\n+            hir::ItemKind::Fn(_, generics, _) => {\n                 self.visit_early_late(item.hir_id(), generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n@@ -508,13 +508,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     this.with(scope, |this| intravisit::walk_item(this, item))\n                 });\n             }\n-            hir::ItemKind::TyAlias(_, ref generics)\n-            | hir::ItemKind::Enum(_, ref generics)\n-            | hir::ItemKind::Struct(_, ref generics)\n-            | hir::ItemKind::Union(_, ref generics)\n-            | hir::ItemKind::Trait(_, _, ref generics, ..)\n-            | hir::ItemKind::TraitAlias(ref generics, ..)\n-            | hir::ItemKind::Impl(hir::Impl { ref generics, .. }) => {\n+            hir::ItemKind::TyAlias(_, generics)\n+            | hir::ItemKind::Enum(_, generics)\n+            | hir::ItemKind::Struct(_, generics)\n+            | hir::ItemKind::Union(_, generics)\n+            | hir::ItemKind::Trait(_, _, generics, ..)\n+            | hir::ItemKind::TraitAlias(generics, ..)\n+            | hir::ItemKind::Impl(&hir::Impl { generics, .. }) => {\n                 // These kinds of items have only early-bound lifetime parameters.\n                 let lifetimes = generics\n                     .params\n@@ -544,7 +544,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n         match item.kind {\n-            hir::ForeignItemKind::Fn(_, _, ref generics) => {\n+            hir::ForeignItemKind::Fn(_, _, generics) => {\n                 self.visit_early_late(item.hir_id(), generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n                 })\n@@ -561,7 +561,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n         match ty.kind {\n-            hir::TyKind::BareFn(ref c) => {\n+            hir::TyKind::BareFn(c) => {\n                 let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n@@ -587,7 +587,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_ty(this, ty);\n                 });\n             }\n-            hir::TyKind::TraitObject(bounds, ref lifetime, _) => {\n+            hir::TyKind::TraitObject(bounds, lifetime, _) => {\n                 debug!(?bounds, ?lifetime, \"TraitObject\");\n                 let scope = Scope::TraitRefBoundary { s: self.scope };\n                 self.with(scope, |this| {\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     LifetimeName::Error => {}\n                 }\n             }\n-            hir::TyKind::Ref(ref lifetime_ref, ref mt) => {\n+            hir::TyKind::Ref(lifetime_ref, ref mt) => {\n                 self.visit_lifetime(lifetime_ref);\n                 let scope = Scope::ObjectLifetimeDefault {\n                     lifetime: self.map.defs.get(&lifetime_ref.hir_id).cloned(),\n@@ -632,7 +632,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 //                 ^                  ^ this gets resolved in the scope of\n                 //                                      the opaque_ty generics\n                 let opaque_ty = self.tcx.hir().item(item_id);\n-                match opaque_ty.kind {\n+                match &opaque_ty.kind {\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                         origin: hir::OpaqueTyOrigin::TyAlias,\n                         ..\n@@ -655,7 +655,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         origin: hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..),\n                         ..\n                     }) => {}\n-                    ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n+                    i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 };\n \n                 // Resolve the lifetimes that are applied to the opaque type.\n@@ -720,7 +720,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_trait_item(this, trait_item)\n                 });\n             }\n-            Type(bounds, ref ty) => {\n+            Type(bounds, ty) => {\n                 let generics = &trait_item.generics;\n                 let lifetimes = generics\n                     .params\n@@ -766,7 +766,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             Fn(..) => self.visit_early_late(impl_item.hir_id(), &impl_item.generics, |this| {\n                 intravisit::walk_impl_item(this, impl_item)\n             }),\n-            Type(ref ty) => {\n+            Type(ty) => {\n                 let generics = &impl_item.generics;\n                 let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n                     .params\n@@ -817,7 +817,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_path(&mut self, path: &hir::Path<'tcx>, _: hir::HirId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n-            if let Some(ref args) = segment.args {\n+            if let Some(args) = segment.args {\n                 self.visit_segment_args(path.res, depth, args);\n             }\n         }\n@@ -833,7 +833,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     ) {\n         let output = match fd.output {\n             hir::FnRetTy::DefaultReturn(_) => None,\n-            hir::FnRetTy::Return(ref ty) => Some(&**ty),\n+            hir::FnRetTy::Return(ty) => Some(ty),\n         };\n         self.visit_fn_like_elision(&fd.inputs, output, matches!(fk, intravisit::FnKind::Closure));\n         intravisit::walk_fn_kind(self, fk);\n@@ -846,13 +846,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             for param in generics.params {\n                 match param.kind {\n                     GenericParamKind::Lifetime { .. } => {}\n-                    GenericParamKind::Type { ref default, .. } => {\n-                        if let Some(ref ty) = default {\n-                            this.visit_ty(&ty);\n+                    GenericParamKind::Type { default, .. } => {\n+                        if let Some(ty) = default {\n+                            this.visit_ty(ty);\n                         }\n                     }\n-                    GenericParamKind::Const { ref ty, default } => {\n-                        this.visit_ty(&ty);\n+                    GenericParamKind::Const { ty, default } => {\n+                        this.visit_ty(ty);\n                         if let Some(default) = default {\n                             this.visit_body(this.tcx.hir().body(default.body));\n                         }\n@@ -863,9 +863,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 match predicate {\n                     &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                         hir_id,\n-                        ref bounded_ty,\n+                        bounded_ty,\n                         bounds,\n-                        ref bound_generic_params,\n+                        bound_generic_params,\n                         origin,\n                         ..\n                     }) => {\n@@ -905,7 +905,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         })\n                     }\n                     &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                        ref lifetime,\n+                        lifetime,\n                         bounds,\n                         ..\n                     }) => {\n@@ -914,7 +914,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                         if lifetime.res != hir::LifetimeName::Static {\n                             for bound in bounds {\n-                                let hir::GenericBound::Outlives(ref lt) = bound else {\n+                                let hir::GenericBound::Outlives(lt) = bound else {\n                                     continue;\n                                 };\n                                 if lt.res != hir::LifetimeName::Static {\n@@ -939,8 +939,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         }\n                     }\n                     &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                        ref lhs_ty,\n-                        ref rhs_ty,\n+                        lhs_ty,\n+                        rhs_ty,\n                         ..\n                     }) => {\n                         this.visit_ty(lhs_ty);\n@@ -1042,7 +1042,7 @@ fn object_lifetime_default(tcx: TyCtxt<'_>, param_def_id: DefId) -> ObjectLifeti\n                 }\n \n                 for bound in bound.bounds {\n-                    if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n+                    if let hir::GenericBound::Outlives(lifetime) = bound {\n                         set.insert(lifetime.res);\n                     }\n                 }\n@@ -1828,7 +1828,7 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n                     }\n                 }\n \n-                hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n+                hir::TyKind::Path(hir::QPath::Resolved(None, path)) => {\n                     // consider only the lifetimes on the final\n                     // segment; I am not sure it's even currently\n                     // valid to have them elsewhere, but even if it"}, {"sha": "46b277d9803d78db081c53ea63bc3861aa209c7c", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -85,30 +85,30 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n         Node::ImplItem(item) => item.generics,\n \n         Node::Item(item) => match item.kind {\n-            ItemKind::Impl(ref impl_) => {\n+            ItemKind::Impl(impl_) => {\n                 if impl_.defaultness.is_default() {\n                     is_default_impl_trait =\n                         tcx.impl_trait_ref(def_id).map(|t| ty::Binder::dummy(t.subst_identity()));\n                 }\n-                &impl_.generics\n+                impl_.generics\n             }\n-            ItemKind::Fn(.., ref generics, _)\n-            | ItemKind::TyAlias(_, ref generics)\n-            | ItemKind::Enum(_, ref generics)\n-            | ItemKind::Struct(_, ref generics)\n-            | ItemKind::Union(_, ref generics) => *generics,\n+            ItemKind::Fn(.., generics, _)\n+            | ItemKind::TyAlias(_, generics)\n+            | ItemKind::Enum(_, generics)\n+            | ItemKind::Struct(_, generics)\n+            | ItemKind::Union(_, generics) => generics,\n \n-            ItemKind::Trait(_, _, ref generics, ..) | ItemKind::TraitAlias(ref generics, _) => {\n+            ItemKind::Trait(_, _, generics, ..) | ItemKind::TraitAlias(generics, _) => {\n                 is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n-                *generics\n+                generics\n             }\n-            ItemKind::OpaqueTy(OpaqueTy { ref generics, .. }) => generics,\n+            ItemKind::OpaqueTy(OpaqueTy { generics, .. }) => generics,\n             _ => NO_GENERICS,\n         },\n \n         Node::ForeignItem(item) => match item.kind {\n             ForeignItemKind::Static(..) => NO_GENERICS,\n-            ForeignItemKind::Fn(_, _, ref generics) => *generics,\n+            ForeignItemKind::Fn(_, _, generics) => generics,\n             ForeignItemKind::Type => NO_GENERICS,\n         },\n \n@@ -350,7 +350,7 @@ fn const_evaluatable_predicates_of(\n     let node = tcx.hir().get(hir_id);\n \n     let mut collector = ConstCollector { tcx, preds: FxIndexSet::default() };\n-    if let hir::Node::Item(item) = node && let hir::ItemKind::Impl(ref impl_) = item.kind {\n+    if let hir::Node::Item(item) = node && let hir::ItemKind::Impl(impl_) = item.kind {\n         if let Some(of_trait) = &impl_.of_trait {\n             debug!(\"const_evaluatable_predicates_of({:?}): visit impl trait_ref\", def_id);\n             collector.visit_trait_ref(of_trait);\n@@ -511,8 +511,8 @@ pub(super) fn super_predicates_that_define_assoc_type(\n         };\n \n         let (generics, bounds) = match item.kind {\n-            hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n-            hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n+            hir::ItemKind::Trait(.., generics, supertraits, _) => (generics, supertraits),\n+            hir::ItemKind::TraitAlias(generics, supertraits) => (generics, supertraits),\n             _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n         };\n \n@@ -612,18 +612,18 @@ pub(super) fn type_param_predicates(\n \n         Node::Item(item) => {\n             match item.kind {\n-                ItemKind::Fn(.., ref generics, _)\n-                | ItemKind::Impl(hir::Impl { ref generics, .. })\n-                | ItemKind::TyAlias(_, ref generics)\n+                ItemKind::Fn(.., generics, _)\n+                | ItemKind::Impl(&hir::Impl { generics, .. })\n+                | ItemKind::TyAlias(_, generics)\n                 | ItemKind::OpaqueTy(OpaqueTy {\n-                    ref generics,\n+                    generics,\n                     origin: hir::OpaqueTyOrigin::TyAlias,\n                     ..\n                 })\n-                | ItemKind::Enum(_, ref generics)\n-                | ItemKind::Struct(_, ref generics)\n-                | ItemKind::Union(_, ref generics) => generics,\n-                ItemKind::Trait(_, _, ref generics, ..) => {\n+                | ItemKind::Enum(_, generics)\n+                | ItemKind::Struct(_, generics)\n+                | ItemKind::Union(_, generics) => generics,\n+                ItemKind::Trait(_, _, generics, ..) => {\n                     // Implied `Self: Trait` and supertrait bounds.\n                     if param_id == item_hir_id {\n                         let identity_trait_ref = ty::TraitRef::identity(tcx, item_def_id);\n@@ -637,7 +637,7 @@ pub(super) fn type_param_predicates(\n         }\n \n         Node::ForeignItem(item) => match item.kind {\n-            ForeignItemKind::Fn(_, _, ref generics) => generics,\n+            ForeignItemKind::Fn(_, _, generics) => generics,\n             _ => return result,\n         },\n \n@@ -681,8 +681,8 @@ impl<'tcx> ItemCtxt<'tcx> {\n         ast_generics\n             .predicates\n             .iter()\n-            .filter_map(|wp| match *wp {\n-                hir::WherePredicate::BoundPredicate(ref bp) => Some(bp),\n+            .filter_map(|wp| match wp {\n+                hir::WherePredicate::BoundPredicate(bp) => Some(bp),\n                 _ => None,\n             })\n             .flat_map(|bp| {"}, {"sha": "5e388a2f2babb0a0a17a2196316b198748fffb0a", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -379,7 +379,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             ForeignItemKind::Type => tcx.mk_foreign(def_id.to_def_id()),\n         },\n \n-        Node::Ctor(&ref def) | Node::Variant(Variant { data: ref def, .. }) => match *def {\n+        Node::Ctor(def) | Node::Variant(Variant { data: def, .. }) => match def {\n             VariantData::Unit(..) | VariantData::Struct(..) => {\n                 tcx.type_of(tcx.hir().get_parent_item(hir_id))\n             }\n@@ -404,17 +404,17 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         Node::AnonConst(_) => {\n             let parent_node = tcx.hir().get_parent(hir_id);\n             match parent_node {\n-                Node::Ty(&Ty { kind: TyKind::Array(_, ref constant), .. })\n-                | Node::Expr(&Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n+                Node::Ty(Ty { kind: TyKind::Array(_, constant), .. })\n+                | Node::Expr(Expr { kind: ExprKind::Repeat(_, constant), .. })\n                     if constant.hir_id() == hir_id =>\n                 {\n                     tcx.types.usize\n                 }\n-                Node::Ty(&Ty { kind: TyKind::Typeof(ref e), .. }) if e.hir_id == hir_id => {\n+                Node::Ty(Ty { kind: TyKind::Typeof(e), .. }) if e.hir_id == hir_id => {\n                     tcx.typeck(def_id).node_type(e.hir_id)\n                 }\n \n-                Node::Expr(&Expr { kind: ExprKind::ConstBlock(ref anon_const), .. })\n+                Node::Expr(Expr { kind: ExprKind::ConstBlock(anon_const), .. })\n                     if anon_const.hir_id == hir_id =>\n                 {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n@@ -434,18 +434,19 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     tcx.typeck(def_id).node_type(hir_id)\n                 }\n \n-                Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => {\n+                Node::Variant(Variant { disr_expr: Some(e), .. }) if e.hir_id == hir_id => {\n                     tcx.adt_def(tcx.hir().get_parent_item(hir_id)).repr().discr_type().to_ty(tcx)\n                 }\n \n                 Node::TypeBinding(\n-                    binding @ &TypeBinding {\n+                    TypeBinding {\n                         hir_id: binding_id,\n-                        kind: TypeBindingKind::Equality { term: Term::Const(ref e) },\n+                        kind: TypeBindingKind::Equality { term: Term::Const(e) },\n+                        ident,\n                         ..\n                     },\n                 ) if let Node::TraitRef(trait_ref) =\n-                    tcx.hir().get_parent(binding_id)\n+                    tcx.hir().get_parent(*binding_id)\n                     && e.hir_id == hir_id =>\n                 {\n                     let Some(trait_def_id) = trait_ref.trait_def_id() else {\n@@ -454,7 +455,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     let assoc_items = tcx.associated_items(trait_def_id);\n                     let assoc_item = assoc_items.find_by_name_and_kind(\n                         tcx,\n-                        binding.ident,\n+                        *ident,\n                         ty::AssocKind::Const,\n                         def_id.to_def_id(),\n                     );\n@@ -470,9 +471,9 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 }\n \n                 Node::TypeBinding(\n-                    binding @ &TypeBinding { hir_id: binding_id, gen_args, ref kind, .. },\n+                    TypeBinding { hir_id: binding_id, gen_args, kind, ident, .. },\n                 ) if let Node::TraitRef(trait_ref) =\n-                    tcx.hir().get_parent(binding_id)\n+                    tcx.hir().get_parent(*binding_id)\n                     && let Some((idx, _)) =\n                         gen_args.args.iter().enumerate().find(|(_, arg)| {\n                             if let GenericArg::Const(ct) = arg {\n@@ -488,7 +489,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     let assoc_items = tcx.associated_items(trait_def_id);\n                     let assoc_item = assoc_items.find_by_name_and_kind(\n                         tcx,\n-                        binding.ident,\n+                        *ident,\n                         match kind {\n                             // I think `<A: T>` type bindings requires that `A` is a type\n                             TypeBindingKind::Constraint { .. }"}, {"sha": "17dbb126bd1b0f357ac0f0204d8a6d70614cc0ba", "filename": "compiler/rustc_hir_analysis/src/hir_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -128,7 +128,7 @@ fn diagnostic_hir_wf_check<'tcx>(\n             },\n             hir::Node::Item(item) => match item.kind {\n                 hir::ItemKind::Static(ty, _, _) | hir::ItemKind::Const(ty, _) => vec![ty],\n-                hir::ItemKind::Impl(ref impl_) => match &impl_.of_trait {\n+                hir::ItemKind::Impl(impl_) => match &impl_.of_trait {\n                     Some(t) => t\n                         .path\n                         .segments"}, {"sha": "02548ae893f28682a16ed0d5593c3f6e642ab524", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -114,6 +114,7 @@ use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use std::iter;\n+use std::ops::Not;\n \n use astconv::AstConv;\n use bounds::Bounds;\n@@ -203,12 +204,8 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         }\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         match tcx.hir().find(hir_id) {\n-            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, ref generics, _), .. })) => {\n-                if !generics.params.is_empty() {\n-                    Some(generics.span)\n-                } else {\n-                    None\n-                }\n+            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, generics, _), .. })) => {\n+                generics.params.is_empty().not().then(|| generics.span)\n             }\n             _ => {\n                 span_bug!(tcx.def_span(def_id), \"main has a non-function type\");\n@@ -222,7 +219,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         }\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         match tcx.hir().find(hir_id) {\n-            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, ref generics, _), .. })) => {\n+            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, generics, _), .. })) => {\n                 Some(generics.where_clause_span)\n             }\n             _ => {\n@@ -244,7 +241,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         }\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         match tcx.hir().find(hir_id) {\n-            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(ref fn_sig, _, _), .. })) => {\n+            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(fn_sig, _, _), .. })) => {\n                 Some(fn_sig.decl.output.span())\n             }\n             _ => {\n@@ -374,7 +371,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n     match start_t.kind() {\n         ty::FnDef(..) => {\n             if let Some(Node::Item(it)) = tcx.hir().find(start_id) {\n-                if let hir::ItemKind::Fn(ref sig, ref generics, _) = it.kind {\n+                if let hir::ItemKind::Fn(sig, generics, _) = &it.kind {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n                         struct_span_err!("}, {"sha": "9133e6540d4450e07e96f9742c8115d8553e9722", "filename": "compiler/rustc_hir_analysis/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -727,8 +727,8 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         if let Some(parent_node) = self.tcx.hir().opt_parent_id(self.path_segment.hir_id)\n         && let Some(parent_node) = self.tcx.hir().find(parent_node)\n         && let hir::Node::Expr(expr) = parent_node {\n-            match expr.kind {\n-                hir::ExprKind::Path(ref qpath) => {\n+            match &expr.kind {\n+                hir::ExprKind::Path(qpath) => {\n                     self.suggest_moving_args_from_assoc_fn_to_trait_for_qualified_path(\n                         err,\n                         qpath,"}, {"sha": "eab01b200947eea874d3c80c38c07214f37887f3", "filename": "compiler/rustc_hir_analysis/src/variance/solve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -28,8 +28,8 @@ pub fn solve_constraints<'tcx>(\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n \n     let mut solutions = vec![ty::Bivariant; terms_cx.inferred_terms.len()];\n-    for &(id, ref variances) in &terms_cx.lang_items {\n-        let InferredIndex(start) = terms_cx.inferred_starts[&id];\n+    for (id, variances) in &terms_cx.lang_items {\n+        let InferredIndex(start) = terms_cx.inferred_starts[id];\n         for (i, &variance) in variances.iter().enumerate() {\n             solutions[start + i] = variance;\n         }"}, {"sha": "ce8aec8044bae63422a1fba1131dcd8b6aaaf746", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -251,7 +251,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     VarValue::Empty(a_universe) => {\n                         let b_data = var_values.value_mut(b_vid);\n \n-                        let changed = (|| match *b_data {\n+                        let changed = match *b_data {\n                             VarValue::Empty(b_universe) => {\n                                 // Empty regions are ordered according to the universe\n                                 // they are associated with.\n@@ -280,20 +280,20 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                                 };\n \n                                 if lub == cur_region {\n-                                    return false;\n+                                    false\n+                                } else {\n+                                    debug!(\n+                                        \"Expanding value of {:?} from {:?} to {:?}\",\n+                                        b_vid, cur_region, lub\n+                                    );\n+\n+                                    *b_data = VarValue::Value(lub);\n+                                    true\n                                 }\n-\n-                                debug!(\n-                                    \"Expanding value of {:?} from {:?} to {:?}\",\n-                                    b_vid, cur_region, lub\n-                                );\n-\n-                                *b_data = VarValue::Value(lub);\n-                                true\n                             }\n \n                             VarValue::ErrorValue => false,\n-                        })();\n+                        };\n \n                         if changed {\n                             changes.push(b_vid);"}, {"sha": "82bc4770b6b471dcd60caa00fea9ed733d7e9d03", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -3,6 +3,7 @@\n #![feature(internal_output_capture)]\n #![feature(thread_spawn_unchecked)]\n #![feature(once_cell)]\n+#![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]"}, {"sha": "379a76528f3bbba1d92aa19af21d0f15d8752d9d", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -558,7 +558,7 @@ fn write_out_deps(\n     }\n     let deps_filename = outputs.path(OutputType::DepInfo);\n \n-    let result = (|| -> io::Result<()> {\n+    let result: io::Result<()> = try {\n         // Build a list of files used to compile the output and\n         // write Makefile-compatible dependency rules\n         let mut files: Vec<String> = sess\n@@ -645,9 +645,7 @@ fn write_out_deps(\n                 writeln!(file)?;\n             }\n         }\n-\n-        Ok(())\n-    })();\n+    };\n \n     match result {\n         Ok(_) => {"}, {"sha": "fcc8f457a8b7887296526a2d1093a5b3f86027a6", "filename": "compiler/rustc_middle/src/traits/chalk.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -159,18 +159,20 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n             }\n             chalk_ir::TyKind::Array(ty, len) => Some(write!(fmt, \"[{:?}; {:?}]\", ty, len)),\n             chalk_ir::TyKind::Slice(ty) => Some(write!(fmt, \"[{:?}]\", ty)),\n-            chalk_ir::TyKind::Tuple(len, substs) => Some((|| {\n-                write!(fmt, \"(\")?;\n-                for (idx, substitution) in substs.interned().iter().enumerate() {\n-                    if idx == *len && *len != 1 {\n-                        // Don't add a trailing comma if the tuple has more than one element\n-                        write!(fmt, \"{:?}\", substitution)?;\n-                    } else {\n-                        write!(fmt, \"{:?},\", substitution)?;\n+            chalk_ir::TyKind::Tuple(len, substs) => Some(\n+                try {\n+                    write!(fmt, \"(\")?;\n+                    for (idx, substitution) in substs.interned().iter().enumerate() {\n+                        if idx == *len && *len != 1 {\n+                            // Don't add a trailing comma if the tuple has more than one element\n+                            write!(fmt, \"{:?}\", substitution)?;\n+                        } else {\n+                            write!(fmt, \"{:?},\", substitution)?;\n+                        }\n                     }\n-                }\n-                write!(fmt, \")\")\n-            })()),\n+                    write!(fmt, \")\")?;\n+                },\n+            ),\n             _ => None,\n         }\n     }"}, {"sha": "33fdc1901cd781b2832dbcdf832271ed706d5f8b", "filename": "compiler/rustc_mir_build/src/build/custom/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -86,10 +86,10 @@ pub(super) fn build_custom_mir<'tcx>(\n         block_map: FxHashMap::default(),\n     };\n \n-    let res = (|| {\n+    let res: PResult<_> = try {\n         pctxt.parse_args(&params)?;\n-        pctxt.parse_body(expr)\n-    })();\n+        pctxt.parse_body(expr)?;\n+    };\n     if let Err(err) = res {\n         tcx.sess.diagnostic().span_fatal(\n             err.span,"}, {"sha": "7808368519351b145df87a3b5f38b88f9a584f25", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 //\n                 // it is usually better to focus on `the_value` rather\n                 // than the entirety of block(s) surrounding it.\n-                let adjusted_span = (|| {\n+                let adjusted_span =\n                     if let ExprKind::Block { block } = expr.kind\n                         && let Some(tail_ex) = this.thir[block].expr\n                     {\n@@ -135,10 +135,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             tail_result_is_ignored: true,\n                             span: expr.span,\n                         });\n-                        return Some(expr.span);\n-                    }\n-                    None\n-                })();\n+                        Some(expr.span)\n+                    } else {\n+                        None\n+                    };\n \n                 let temp =\n                     unpack!(block = this.as_temp(block, statement_scope, expr, Mutability::Not));"}, {"sha": "aba5429da435f84292cb698a9e62d7d6b53b61ba", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -141,27 +141,22 @@ impl IntRange {\n     ) -> Option<IntRange> {\n         let ty = value.ty();\n         if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, ty) {\n-            let val = (|| {\n-                match value {\n-                    mir::ConstantKind::Val(ConstValue::Scalar(scalar), _) => {\n-                        // For this specific pattern we can skip a lot of effort and go\n-                        // straight to the result, after doing a bit of checking. (We\n-                        // could remove this branch and just fall through, which\n-                        // is more general but much slower.)\n-                        return scalar.to_bits_or_ptr_internal(target_size).unwrap().left();\n-                    }\n-                    mir::ConstantKind::Ty(c) => match c.kind() {\n-                        ty::ConstKind::Value(_) => bug!(\n-                            \"encountered ConstValue in mir::ConstantKind::Ty, whereas this is expected to be in ConstantKind::Val\"\n-                        ),\n-                        _ => {}\n-                    },\n-                    _ => {}\n+            let val = if let mir::ConstantKind::Val(ConstValue::Scalar(scalar), _) = value {\n+                // For this specific pattern we can skip a lot of effort and go\n+                // straight to the result, after doing a bit of checking. (We\n+                // could remove this branch and just fall through, which\n+                // is more general but much slower.)\n+                scalar.to_bits_or_ptr_internal(target_size).unwrap().left()?\n+            } else {\n+                if let mir::ConstantKind::Ty(c) = value\n+                    && let ty::ConstKind::Value(_) = c.kind()\n+                {\n+                    bug!(\"encountered ConstValue in mir::ConstantKind::Ty, whereas this is expected to be in ConstantKind::Val\");\n                 }\n \n                 // This is a more general form of the previous case.\n-                value.try_eval_bits(tcx, param_env, ty)\n-            })()?;\n+                value.try_eval_bits(tcx, param_env, ty)?\n+            };\n             let val = val ^ bias;\n             Some(IntRange { range: val..=val, bias })\n         } else {"}, {"sha": "27247271d1f4d3f6aa0f989352ec3e38ed75e51e", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -201,7 +201,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n         // wait to fold the substs.\n \n         // Wrap this in a closure so we don't accidentally return from the outer function\n-        let res = (|| match *ty.kind() {\n+        let res = match *ty.kind() {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n@@ -210,7 +210,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n             {\n                 // Only normalize `impl Trait` outside of type inference, usually in codegen.\n                 match self.param_env.reveal() {\n-                    Reveal::UserFacing => ty.try_super_fold_with(self),\n+                    Reveal::UserFacing => ty.try_super_fold_with(self)?,\n \n                     Reveal::All => {\n                         let substs = substs.try_fold_with(self)?;\n@@ -239,7 +239,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                         }\n                         let folded_ty = ensure_sufficient_stack(|| self.try_fold_ty(concrete_ty));\n                         self.anon_depth -= 1;\n-                        folded_ty\n+                        folded_ty?\n                     }\n                 }\n             }\n@@ -287,9 +287,9 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 // `tcx.normalize_projection_ty` may normalize to a type that still has\n                 // unevaluated consts, so keep normalizing here if that's the case.\n                 if res != ty && res.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n-                    Ok(res.try_super_fold_with(self)?)\n+                    res.try_super_fold_with(self)?\n                 } else {\n-                    Ok(res)\n+                    res\n                 }\n             }\n \n@@ -344,14 +344,14 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 // `tcx.normalize_projection_ty` may normalize to a type that still has\n                 // unevaluated consts, so keep normalizing here if that's the case.\n                 if res != ty && res.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n-                    Ok(res.try_super_fold_with(self)?)\n+                    res.try_super_fold_with(self)?\n                 } else {\n-                    Ok(res)\n+                    res\n                 }\n             }\n \n-            _ => ty.try_super_fold_with(self),\n-        })()?;\n+            _ => ty.try_super_fold_with(self)?,\n+        };\n \n         self.cache.insert(ty, res);\n         Ok(res)"}, {"sha": "a5dc6859732a3d2c5348fb8084e00e0afbd876a5", "filename": "src/tools/compiletest/src/read2.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs?ref=56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "patch": "@@ -110,9 +110,18 @@ impl ProcOutput {\n     fn into_bytes(self) -> Vec<u8> {\n         match self {\n             ProcOutput::Full { bytes, .. } => bytes,\n-            ProcOutput::Abbreviated { mut head, skipped, tail } => {\n+            ProcOutput::Abbreviated { mut head, mut skipped, tail } => {\n+                let mut tail = &*tail;\n+\n+                // Skip over '{' at the start of the tail, so we don't later wrongfully consider this as json.\n+                // See <https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp/topic/Weird.20CI.20failure/near/321797811>\n+                while tail.get(0) == Some(&b'{') {\n+                    tail = &tail[1..];\n+                    skipped += 1;\n+                }\n+\n                 write!(&mut head, \"\\n\\n<<<<<< SKIPPED {} BYTES >>>>>>\\n\\n\", skipped).unwrap();\n-                head.extend_from_slice(&tail);\n+                head.extend_from_slice(tail);\n                 head\n             }\n         }"}]}