{"sha": "527a29a5c61c57745a81e462df791e95cac08f0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyN2EyOWE1YzYxYzU3NzQ1YTgxZTQ2MmRmNzkxZTk1Y2FjMDhmMGM=", "commit": {"author": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2018-09-05T22:49:58Z"}, "committer": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2018-09-06T20:46:52Z"}, "message": "Skip a shared borrow of a immutable local variables\n\nissue #53643", "tree": {"sha": "66ff20bb4b457079d82f3235242b33d99f0a64cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66ff20bb4b457079d82f3235242b33d99f0a64cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/527a29a5c61c57745a81e462df791e95cac08f0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/527a29a5c61c57745a81e462df791e95cac08f0c", "html_url": "https://github.com/rust-lang/rust/commit/527a29a5c61c57745a81e462df791e95cac08f0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/527a29a5c61c57745a81e462df791e95cac08f0c/comments", "author": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35a5541fd90c96564d483eee248daabc6b133de3", "url": "https://api.github.com/repos/rust-lang/rust/commits/35a5541fd90c96564d483eee248daabc6b133de3", "html_url": "https://github.com/rust-lang/rust/commit/35a5541fd90c96564d483eee248daabc6b133de3"}], "stats": {"total": 250, "additions": 192, "deletions": 58}, "files": [{"sha": "0090605f461490c29ebfa5aa6fed929a2d67542a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=527a29a5c61c57745a81e462df791e95cac08f0c", "patch": "@@ -252,11 +252,6 @@ impl<'tcx> Mir<'tcx> {\n         } else if self.local_decls[local].name.is_some() {\n             LocalKind::Var\n         } else {\n-            debug_assert!(\n-                self.local_decls[local].mutability == Mutability::Mut,\n-                \"temp should be mutable\"\n-            );\n-\n             LocalKind::Temp\n         }\n     }\n@@ -784,33 +779,38 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// Create a new `LocalDecl` for a temporary.\n     #[inline]\n     pub fn new_temp(ty: Ty<'tcx>, span: Span) -> Self {\n-        LocalDecl {\n-            mutability: Mutability::Mut,\n-            ty,\n-            name: None,\n-            source_info: SourceInfo {\n-                span,\n-                scope: OUTERMOST_SOURCE_SCOPE,\n-            },\n-            visibility_scope: OUTERMOST_SOURCE_SCOPE,\n-            internal: false,\n-            is_user_variable: None,\n-        }\n+        Self::new_local(ty, Mutability::Mut, false, span)\n+    }\n+\n+    /// Create a new immutable `LocalDecl` for a temporary.\n+    #[inline]\n+    pub fn new_immutable_temp(ty: Ty<'tcx>, span: Span) -> Self {\n+        Self::new_local(ty, Mutability::Not, false, span)\n     }\n \n     /// Create a new `LocalDecl` for a internal temporary.\n     #[inline]\n     pub fn new_internal(ty: Ty<'tcx>, span: Span) -> Self {\n+        Self::new_local(ty, Mutability::Mut, true, span)\n+    }\n+\n+    #[inline]\n+    fn new_local(\n+        ty: Ty<'tcx>,\n+        mutability: Mutability,\n+        internal: bool,\n+        span: Span,\n+    ) -> Self {\n         LocalDecl {\n-            mutability: Mutability::Mut,\n+            mutability,\n             ty,\n             name: None,\n             source_info: SourceInfo {\n                 span,\n                 scope: OUTERMOST_SOURCE_SCOPE,\n             },\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n-            internal: true,\n+            internal,\n             is_user_variable: None,\n         }\n     }"}, {"sha": "8ddcfa054321e38ebc9cb3edd6d5d88935625e56", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=527a29a5c61c57745a81e462df791e95cac08f0c", "patch": "@@ -10,12 +10,14 @@\n \n use borrow_check::place_ext::PlaceExt;\n use dataflow::indexes::BorrowIndex;\n+use dataflow::move_paths::MoveData;\n use rustc::mir::traversal;\n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::{self, Location, Mir, Place};\n+use rustc::mir::{self, Location, Mir, Place, Local};\n use rustc::ty::{Region, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::bitvec::BitArray;\n use std::fmt;\n use std::hash::Hash;\n use std::ops::Index;\n@@ -43,6 +45,8 @@ crate struct BorrowSet<'tcx> {\n \n     /// Map from local to all the borrows on that local\n     crate local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n+\n+    crate locals_state_at_exit: LocalsStateAtExit,\n }\n \n impl<'tcx> Index<BorrowIndex> for BorrowSet<'tcx> {\n@@ -96,8 +100,52 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n     }\n }\n \n+crate enum LocalsStateAtExit {\n+    AllAreInvalidated,\n+    SomeAreInvalidated { has_storage_dead_or_moved: BitArray<Local> }\n+}\n+\n+impl LocalsStateAtExit {\n+    fn build(\n+        locals_are_invalidated_at_exit: bool,\n+        mir: &Mir<'tcx>,\n+        move_data: &MoveData<'tcx>\n+    ) -> Self {\n+        struct HasStorageDead(BitArray<Local>);\n+\n+        impl<'tcx> Visitor<'tcx> for HasStorageDead {\n+            fn visit_local(&mut self, local: &Local, ctx: PlaceContext<'tcx>, _: Location) {\n+                if ctx == PlaceContext::StorageDead {\n+                    self.0.insert(*local);\n+                }\n+            }\n+        }\n+\n+        if locals_are_invalidated_at_exit {\n+            LocalsStateAtExit::AllAreInvalidated\n+        } else {\n+            let mut has_storage_dead = HasStorageDead(BitArray::new(mir.local_decls.len()));\n+            has_storage_dead.visit_mir(mir);\n+            let mut has_storage_dead_or_moved = has_storage_dead.0;\n+            for move_out in &move_data.moves {\n+                if let Some(index) = move_data.base_local(move_out.path) {\n+                    has_storage_dead_or_moved.insert(index);\n+\n+                }\n+            }\n+            LocalsStateAtExit::SomeAreInvalidated{ has_storage_dead_or_moved }\n+        }\n+    }\n+}\n+\n impl<'tcx> BorrowSet<'tcx> {\n-    pub fn build(tcx: TyCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) -> Self {\n+    pub fn build(\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        locals_are_invalidated_at_exit: bool,\n+        move_data: &MoveData<'tcx>\n+    ) -> Self {\n+\n         let mut visitor = GatherBorrows {\n             tcx,\n             mir,\n@@ -107,6 +155,8 @@ impl<'tcx> BorrowSet<'tcx> {\n             region_map: FxHashMap(),\n             local_map: FxHashMap(),\n             pending_activations: FxHashMap(),\n+            locals_state_at_exit:\n+                LocalsStateAtExit::build(locals_are_invalidated_at_exit, mir, move_data),\n         };\n \n         for (block, block_data) in traversal::preorder(mir) {\n@@ -119,6 +169,7 @@ impl<'tcx> BorrowSet<'tcx> {\n             activation_map: visitor.activation_map,\n             region_map: visitor.region_map,\n             local_map: visitor.local_map,\n+            locals_state_at_exit: visitor.locals_state_at_exit,\n         }\n     }\n \n@@ -148,6 +199,8 @@ struct GatherBorrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     /// the borrow. When we find a later use of this activation, we\n     /// remove from the map (and add to the \"tombstone\" set below).\n     pending_activations: FxHashMap<mir::Local, BorrowIndex>,\n+\n+    locals_state_at_exit: LocalsStateAtExit,\n }\n \n impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n@@ -159,7 +212,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n         location: mir::Location,\n     ) {\n         if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n-            if borrowed_place.ignore_borrow(self.tcx, self.mir) {\n+            if borrowed_place.ignore_borrow(\n+                self.tcx, self.mir, &self.locals_state_at_exit) {\n                 return;\n             }\n "}, {"sha": "d6688a008139b275fedbf2cdb88325c58e3835dd", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=527a29a5c61c57745a81e462df791e95cac08f0c", "patch": "@@ -196,7 +196,12 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         |bd, i| DebugFormatted::new(&bd.move_data().inits[i]),\n     ));\n \n-    let borrow_set = Rc::new(BorrowSet::build(tcx, mir));\n+    let locals_are_invalidated_at_exit = match tcx.hir.body_owner_kind(id) {\n+            hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => false,\n+            hir::BodyOwnerKind::Fn => true,\n+    };\n+    let borrow_set = Rc::new(BorrowSet::build(\n+            tcx, mir, locals_are_invalidated_at_exit, &mdpe.move_data));\n \n     // If we are in non-lexical mode, compute the non-lexical lifetimes.\n     let (regioncx, polonius_output, opt_closure_req) = nll::compute_regions(\n@@ -241,10 +246,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         param_env: param_env,\n         location_table,\n         movable_generator,\n-        locals_are_invalidated_at_exit: match tcx.hir.body_owner_kind(id) {\n-            hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => false,\n-            hir::BodyOwnerKind::Fn => true,\n-        },\n+        locals_are_invalidated_at_exit,\n         access_place_error_reported: FxHashSet(),\n         reservation_error_reported: FxHashSet(),\n         moved_error_reported: FxHashSet(),"}, {"sha": "740cc64598438dcb2f46cc9e3647dafab0da37c3", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=527a29a5c61c57745a81e462df791e95cac08f0c", "patch": "@@ -10,27 +10,57 @@\n \n use rustc::hir;\n use rustc::mir::ProjectionElem;\n-use rustc::mir::{Local, Mir, Place};\n+use rustc::mir::{Local, Mir, Place, Mutability};\n use rustc::ty::{self, TyCtxt};\n+use borrow_check::borrow_set::LocalsStateAtExit;\n \n /// Extension methods for the `Place` type.\n crate trait PlaceExt<'tcx> {\n     /// Returns true if we can safely ignore borrows of this place.\n     /// This is true whenever there is no action that the user can do\n     /// to the place `self` that would invalidate the borrow. This is true\n     /// for borrows of raw pointer dereferents as well as shared references.\n-    fn ignore_borrow(&self, tcx: TyCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) -> bool;\n+    fn ignore_borrow(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        locals_state_at_exit: &LocalsStateAtExit,\n+        ) -> bool;\n \n     /// If this is a place like `x.f.g`, returns the local\n     /// `x`. Returns `None` if this is based in a static.\n     fn root_local(&self) -> Option<Local>;\n }\n \n impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n-    fn ignore_borrow(&self, tcx: TyCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) -> bool {\n+    fn ignore_borrow(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        locals_state_at_exit: &LocalsStateAtExit,\n+    ) -> bool {\n         match self {\n-            Place::Promoted(_) |\n-            Place::Local(_) => false,\n+            Place::Promoted(_) => false,\n+\n+            // If a local variable is immutable, then we only need to track borrows to guard\n+            // against two kinds of errors:\n+            // * The variable being dropped while still borrowed (e.g., because the fn returns\n+            //   a reference to a local variable)\n+            // * The variable being moved while still borrowed\n+            //\n+            // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n+            // so we don't have to worry about mutation while borrowed.\n+            Place::Local(index) => {\n+                match locals_state_at_exit {\n+                    LocalsStateAtExit::AllAreInvalidated => false,\n+                    LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n+                        let ignore = !has_storage_dead_or_moved.contains(*index) &&\n+                            mir.local_decls[*index].mutability == Mutability::Not;\n+                        debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n+                        ignore\n+                    }\n+                }\n+            }\n             Place::Static(static_) => {\n                 tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable)\n             }\n@@ -39,7 +69,8 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                 | ProjectionElem::Downcast(..)\n                 | ProjectionElem::Subslice { .. }\n                 | ProjectionElem::ConstantIndex { .. }\n-                | ProjectionElem::Index(_) => proj.base.ignore_borrow(tcx, mir),\n+                | ProjectionElem::Index(_) => proj.base.ignore_borrow(\n+                    tcx, mir, locals_state_at_exit),\n \n                 ProjectionElem::Deref => {\n                     let ty = proj.base.ty(mir, tcx).to_ty(tcx);\n@@ -55,7 +86,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                         // borrowed *that* one, leaving the original\n                         // path unborrowed.\n                         ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) => true,\n-                        _ => proj.base.ignore_borrow(tcx, mir),\n+                        _ => proj.base.ignore_borrow(tcx, mir, locals_state_at_exit),\n                     }\n                 }\n             },"}, {"sha": "9c23cbe751aaa815215268157f80431ae8cb07b1", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=527a29a5c61c57745a81e462df791e95cac08f0c", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             Category::Place |\n             Category::Rvalue(..) => {\n                 let operand =\n-                    unpack!(block = this.as_temp(block, scope, expr));\n+                    unpack!(block = this.as_temp(block, scope, expr, Mutability::Mut));\n                 block.and(Operand::Move(Place::Local(operand)))\n             }\n         }"}, {"sha": "4844c6fff88e55a2aa75af3f41c8907061e19ce2", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=527a29a5c61c57745a81e462df791e95cac08f0c", "patch": "@@ -28,22 +28,42 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         where M: Mirror<'tcx, Output=Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_place(block, expr)\n+        self.expr_as_place(block, expr, Mutability::Mut)\n+    }\n+\n+    /// Compile `expr`, yielding a place that we can move from etc.\n+    /// Mutability note: The caller of this method promises only to read from the resulting\n+    /// place. The place itself may or may not be mutable:\n+    /// * If this expr is a place expr like a.b, then we will return that place.\n+    /// * Otherwise, a temporary is created: in that event, it will be an immutable temporary.\n+    pub fn as_read_only_place<M>(&mut self,\n+                        block: BasicBlock,\n+                        expr: M)\n+                        -> BlockAnd<Place<'tcx>>\n+        where M: Mirror<'tcx, Output=Expr<'tcx>>\n+    {\n+        let expr = self.hir.mirror(expr);\n+        self.expr_as_place(block, expr, Mutability::Not)\n     }\n \n     fn expr_as_place(&mut self,\n                       mut block: BasicBlock,\n-                      expr: Expr<'tcx>)\n+                      expr: Expr<'tcx>,\n+                      mutability: Mutability)\n                       -> BlockAnd<Place<'tcx>> {\n-        debug!(\"expr_as_place(block={:?}, expr={:?})\", block, expr);\n+        debug!(\"expr_as_place(block={:?}, expr={:?}, mutability={:?})\", block, expr, mutability);\n \n         let this = self;\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n         match expr.kind {\n             ExprKind::Scope { region_scope, lint_level, value } => {\n                 this.in_scope((region_scope, source_info), lint_level, block, |this| {\n-                    this.as_place(block, value)\n+                    if mutability == Mutability::Not {\n+                        this.as_read_only_place(block, value)\n+                    } else {\n+                        this.as_place(block, value)\n+                    }\n                 })\n             }\n             ExprKind::Field { lhs, name } => {\n@@ -63,7 +83,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // region_scope=None so place indexes live forever. They are scalars so they\n                 // do not need storage annotations, and they are often copied between\n                 // places.\n-                let idx = unpack!(block = this.as_temp(block, None, index));\n+                let idx = unpack!(block = this.as_temp(block, None, index, Mutability::Mut));\n \n                 // bounds check:\n                 let (len, lt) = (this.temp(usize_ty.clone(), expr_span),\n@@ -137,7 +157,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Some(Category::Place) => false,\n                     _ => true,\n                 });\n-                let temp = unpack!(block = this.as_temp(block, expr.temp_lifetime, expr));\n+                let temp = unpack!(\n+                    block = this.as_temp(block, expr.temp_lifetime, expr, mutability));\n                 block.and(Place::Local(temp))\n             }\n         }"}, {"sha": "4d96055f97dacc91fe0b15446c7d4c2355e0286c", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=527a29a5c61c57745a81e462df791e95cac08f0c", "patch": "@@ -63,7 +63,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.and(Rvalue::Repeat(value_operand, count))\n             }\n             ExprKind::Borrow { region, borrow_kind, arg } => {\n-                let arg_place = unpack!(block = this.as_place(block, arg));\n+                let arg_place = match borrow_kind {\n+                    BorrowKind::Shared => unpack!(block = this.as_read_only_place(block, arg)),\n+                    _ => unpack!(block = this.as_place(block, arg))\n+                };\n                 block.and(Rvalue::Ref(region, borrow_kind, arg_place))\n             }\n             ExprKind::Binary { op, lhs, rhs } => {"}, {"sha": "340d4401a37e467ad6cdb7731aa2e32d99eb5c1f", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=527a29a5c61c57745a81e462df791e95cac08f0c", "patch": "@@ -21,33 +21,39 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn as_temp<M>(&mut self,\n                       block: BasicBlock,\n                       temp_lifetime: Option<region::Scope>,\n-                      expr: M)\n+                      expr: M,\n+                      mutability: Mutability)\n                       -> BlockAnd<Local>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_temp(block, temp_lifetime, expr)\n+        self.expr_as_temp(block, temp_lifetime, expr, mutability)\n     }\n \n     fn expr_as_temp(&mut self,\n                     mut block: BasicBlock,\n                     temp_lifetime: Option<region::Scope>,\n-                    expr: Expr<'tcx>)\n+                    expr: Expr<'tcx>,\n+                    mutability: Mutability)\n                     -> BlockAnd<Local> {\n-        debug!(\"expr_as_temp(block={:?}, temp_lifetime={:?}, expr={:?})\",\n-               block, temp_lifetime, expr);\n+        debug!(\"expr_as_temp(block={:?}, temp_lifetime={:?}, expr={:?}, mutability={:?})\",\n+               block, temp_lifetime, expr, mutability);\n         let this = self;\n \n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n         if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n             return this.in_scope((region_scope, source_info), lint_level, block, |this| {\n-                this.as_temp(block, temp_lifetime, value)\n+                this.as_temp(block, temp_lifetime, value, mutability)\n             });\n         }\n \n         let expr_ty = expr.ty;\n-        let temp = this.local_decls.push(LocalDecl::new_temp(expr_ty, expr_span));\n+        let temp = if mutability == Mutability::Not {\n+            this.local_decls.push(LocalDecl::new_immutable_temp(expr_ty, expr_span))\n+        } else {\n+            this.local_decls.push(LocalDecl::new_temp(expr_ty, expr_span))\n+        };\n \n         if !expr_ty.is_never() {\n             this.cfg.push(block, Statement {"}, {"sha": "999a858f3214ca87cf3b9a4a7dcecb0542a2c0ab", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=527a29a5c61c57745a81e462df791e95cac08f0c", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n         def_id: DefId,\n         body_id: Option<hir::BodyId>,\n-        borrow_set: &Rc<BorrowSet<'tcx>>\n+        borrow_set: &Rc<BorrowSet<'tcx>>,\n     ) -> Self {\n         let scope_tree = tcx.region_scope_tree(def_id);\n         let root_scope = body_id.map(|body_id| {\n@@ -233,7 +233,13 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                 // propagate_call_return method.\n \n                 if let mir::Rvalue::Ref(region, _, ref place) = *rhs {\n-                    if place.ignore_borrow(self.tcx, self.mir) { return; }\n+                    if place.ignore_borrow(\n+                        self.tcx,\n+                        self.mir,\n+                        &self.borrow_set.locals_state_at_exit,\n+                    ) {\n+                        return;\n+                    }\n                     let index = self.borrow_set.location_map.get(&location).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndex for location {:?}\", location);\n                     });"}, {"sha": "9f1ba1f0530d58dde567ac399c21fc2f2a122635", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=527a29a5c61c57745a81e462df791e95cac08f0c", "patch": "@@ -316,4 +316,14 @@ impl<'a, 'gcx, 'tcx> MoveData<'tcx> {\n                         -> Result<Self, (Self, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n         builder::gather_moves(mir, tcx)\n     }\n+\n+    /// For the move path `mpi`, returns the root local variable (if any) that starts the path.\n+    /// (e.g., for a path like `a.b.c` returns `Some(a)`)\n+    pub fn base_local(&self, mut mpi: MovePathIndex) -> Option<Local> {\n+        loop {\n+            let path = &self.move_paths[mpi];\n+            if let Place::Local(l) = path.place { return Some(l); }\n+            if let Some(parent) = path.parent { mpi = parent; continue } else { return None }\n+        }\n+    }\n }"}, {"sha": "9f5b5040b09574ae96c704617058a81f8f414ebc", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=527a29a5c61c57745a81e462df791e95cac08f0c", "patch": "@@ -612,8 +612,9 @@ fn write_temp_decls(mir: &Mir, w: &mut dyn Write) -> io::Result<()> {\n     for temp in mir.temps_iter() {\n         writeln!(\n             w,\n-            \"{}let mut {:?}: {};\",\n+            \"{}let {}{:?}: {};\",\n             INDENT,\n+            if mir.local_decls[temp].mutability == Mutability::Mut {\"mut \"} else {\"\"},\n             temp,\n             mir.local_decls[temp].ty\n         )?;"}, {"sha": "16e2fe046fb699f9cdf162cafd3b58306b8fbde9", "filename": "src/test/mir-opt/end_region_destruction_extents_1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs?ref=527a29a5c61c57745a81e462df791e95cac08f0c", "patch": "@@ -70,10 +70,10 @@ unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n //     let mut _2: D1<'12ds, '10s>;\n //     let mut _3: &'12ds S1;\n //     let mut _4: &'12ds S1;\n-//     let mut _5: S1;\n+//     let _5: S1;\n //     let mut _6: &'10s S1;\n //     let mut _7: &'10s S1;\n-//     let mut _8: S1;\n+//     let _8: S1;\n //     bb0: {\n //         StorageLive(_2);\n //         StorageLive(_3);\n@@ -118,10 +118,10 @@ unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n //     let mut _2: D1<'12ds, '10s>;\n //     let mut _3: &'12ds S1;\n //     let mut _4: &'12ds S1;\n-//     let mut _5: S1;\n+//     let _5: S1;\n //     let mut _6: &'10s S1;\n //     let mut _7: &'10s S1;\n-//     let mut _8: S1;\n+//     let _8: S1;\n //     bb0: {\n //         StorageLive(_2);\n //         StorageLive(_3);"}, {"sha": "e39b7df8a7ad806ce48e8a676dd9f68c2ba61ead", "filename": "src/test/mir-opt/storage_live_dead_in_statics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/527a29a5c61c57745a81e462df791e95cac08f0c/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs?ref=527a29a5c61c57745a81e462df791e95cac08f0c", "patch": "@@ -47,11 +47,11 @@ fn main() {\n // START rustc.XXX.mir_map.0.mir\n //    let mut _0: &'static Foo;\n //    let mut _1: &'static Foo;\n-//    let mut _2: Foo;\n+//    let _2: Foo;\n //    let mut _3: &'static [(u32, u32)];\n //    let mut _4: &'static [(u32, u32); 42];\n //    let mut _5: &'static [(u32, u32); 42];\n-//    let mut _6: [(u32, u32); 42];\n+//    let _6: [(u32, u32); 42];\n //    let mut _7: (u32, u32);\n //    let mut _8: (u32, u32);\n //    let mut _9: (u32, u32);"}]}