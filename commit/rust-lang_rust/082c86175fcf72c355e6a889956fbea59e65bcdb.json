{"sha": "082c86175fcf72c355e6a889956fbea59e65bcdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MmM4NjE3NWZjZjcyYzM1NWU2YTg4OTk1NmZiZWE1OWU2NWJjZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-22T21:32:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-22T21:32:15Z"}, "message": "Auto merge of #58644 - Centril:rollup, r=Centril\n\nRollup of 17 pull requests\n\nSuccessful merges:\n\n - #57656 (Deprecate the unstable Vec::resize_default)\n - #58059 (deprecate before_exec in favor of unsafe pre_exec)\n - #58064 (override `VecDeque::try_rfold`, also update iterator)\n - #58198 (Suggest removing parentheses surrounding lifetimes)\n - #58431 (fix overlapping references in BTree)\n - #58555 (Add a note about 2018e if someone uses `try {` in 2015e)\n - #58588 (remove a bit of dead code)\n - #58589 (cleanup macro after 2018 transition)\n - #58591 (Dedup a rustdoc diagnostic construction)\n - #58600 (fix small documentation typo)\n - #58601 (Search for target_triple.json only if builtin target not found)\n - #58606 (Docs: put Future trait into spotlight)\n - #58607 (Fixes #58586: Make E0505 erronous example fail for the 2018 edition)\n - #58615 (miri: explain why we use static alignment in ref-to-place conversion)\n - #58620 (introduce benchmarks of BTreeSet.intersection)\n - #58621 (Update miri links)\n - #58632 (Make std feature list sorted)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "1b8297e021423bd2069bb1654985bf52602e9ef1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b8297e021423bd2069bb1654985bf52602e9ef1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/082c86175fcf72c355e6a889956fbea59e65bcdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/082c86175fcf72c355e6a889956fbea59e65bcdb", "html_url": "https://github.com/rust-lang/rust/commit/082c86175fcf72c355e6a889956fbea59e65bcdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/082c86175fcf72c355e6a889956fbea59e65bcdb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1c6d00574494499f63c1e460ef886768643e7db", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1c6d00574494499f63c1e460ef886768643e7db", "html_url": "https://github.com/rust-lang/rust/commit/e1c6d00574494499f63c1e460ef886768643e7db"}, {"sha": "a8a343a78706a1d90ebd451046b76d176bab937d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8a343a78706a1d90ebd451046b76d176bab937d", "html_url": "https://github.com/rust-lang/rust/commit/a8a343a78706a1d90ebd451046b76d176bab937d"}], "stats": {"total": 752, "additions": 542, "deletions": 210}, "files": [{"sha": "e785f03d7de2b574c3b76b4c271bd8c77fabd665", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -161,10 +161,10 @@ it can be found [here][rctd].\n \n Currently building Rust will also build the following external projects:\n \n-* [clippy](https://github.com/rust-lang-nursery/rust-clippy)\n-* [miri](https://github.com/solson/miri)\n-* [rustfmt](https://github.com/rust-lang-nursery/rustfmt)\n-* [rls](https://github.com/rust-lang-nursery/rls/)\n+* [clippy](https://github.com/rust-lang/rust-clippy)\n+* [miri](https://github.com/rust-lang/miri)\n+* [rustfmt](https://github.com/rust-lang/rustfmt)\n+* [rls](https://github.com/rust-lang/rls/)\n \n We allow breakage of these tools in the nightly channel. Maintainers of these\n projects will be notified of the breakages and should fix them as soon as\n@@ -191,9 +191,9 @@ before the PR is merged.\n \n Rust's build system builds a number of tools that make use of the\n internals of the compiler. This includes \n-[Clippy](https://github.com/rust-lang-nursery/rust-clippy),\n-[RLS](https://github.com/rust-lang-nursery/rls) and\n-[rustfmt](https://github.com/rust-lang-nursery/rustfmt). If these tools\n+[Clippy](https://github.com/rust-lang/rust-clippy),\n+[RLS](https://github.com/rust-lang/rls) and\n+[rustfmt](https://github.com/rust-lang/rustfmt). If these tools\n break because of your changes, you may run into a sort of \"chicken and egg\"\n problem. These tools rely on the latest compiler to be built so you can't update\n them to reflect your changes to the compiler until those changes are merged into\n@@ -253,10 +253,10 @@ to complete a few more steps which are outlined with their rationale below.\n \n *(This error may change in the future to include more information.)*\n ```\n-error: failed to resolve patches for `https://github.com/rust-lang-nursery/rustfmt`\n+error: failed to resolve patches for `https://github.com/rust-lang/rustfmt`\n \n Caused by:\n-  patch for `rustfmt-nightly` in `https://github.com/rust-lang-nursery/rustfmt` did not resolve to any crates\n+  patch for `rustfmt-nightly` in `https://github.com/rust-lang/rustfmt` did not resolve to any crates\n failed to run: ~/rust/build/x86_64-unknown-linux-gnu/stage0/bin/cargo build --manifest-path ~/rust/src/bootstrap/Cargo.toml\n ```\n "}, {"sha": "c9acd3c307b54690851393d1e5304d78cbcee2ad", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -244,7 +244,7 @@ disambiguate the error type:\n /// use std::io;\n /// let mut input = String::new();\n /// io::stdin().read_line(&mut input)?;\n-/// # Ok::<(), io:Error>(())\n+/// # Ok::<(), io::Error>(())\n /// ```\n ```\n "}, {"sha": "095ca5dd2e21b4598ffff106e6576273494822be", "filename": "src/liballoc/benches/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Fbenches%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Fbenches%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmod.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -1 +1,2 @@\n mod map;\n+mod set;"}, {"sha": "08e1db5fbb74d01bf47784c61c0daf507355cfd7", "filename": "src/liballoc/benches/btree/set.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -0,0 +1,88 @@\n+use std::collections::BTreeSet;\n+\n+use rand::{thread_rng, Rng};\n+use test::{black_box, Bencher};\n+\n+fn random(n1: u32, n2: u32) -> [BTreeSet<usize>; 2] {\n+    let mut rng = thread_rng();\n+    let mut set1 = BTreeSet::new();\n+    let mut set2 = BTreeSet::new();\n+    for _ in 0..n1 {\n+        let i = rng.gen::<usize>();\n+        set1.insert(i);\n+    }\n+    for _ in 0..n2 {\n+        let i = rng.gen::<usize>();\n+        set2.insert(i);\n+    }\n+    [set1, set2]\n+}\n+\n+fn staggered(n1: u32, n2: u32) -> [BTreeSet<u32>; 2] {\n+    let mut even = BTreeSet::new();\n+    let mut odd = BTreeSet::new();\n+    for i in 0..n1 {\n+        even.insert(i * 2);\n+    }\n+    for i in 0..n2 {\n+        odd.insert(i * 2 + 1);\n+    }\n+    [even, odd]\n+}\n+\n+fn neg_vs_pos(n1: u32, n2: u32) -> [BTreeSet<i32>; 2] {\n+    let mut neg = BTreeSet::new();\n+    let mut pos = BTreeSet::new();\n+    for i in -(n1 as i32)..=-1 {\n+        neg.insert(i);\n+    }\n+    for i in 1..=(n2 as i32) {\n+        pos.insert(i);\n+    }\n+    [neg, pos]\n+}\n+\n+fn pos_vs_neg(n1: u32, n2: u32) -> [BTreeSet<i32>; 2] {\n+    let mut neg = BTreeSet::new();\n+    let mut pos = BTreeSet::new();\n+    for i in -(n1 as i32)..=-1 {\n+        neg.insert(i);\n+    }\n+    for i in 1..=(n2 as i32) {\n+        pos.insert(i);\n+    }\n+    [pos, neg]\n+}\n+\n+macro_rules! set_intersection_bench {\n+    ($name: ident, $sets: expr) => {\n+        #[bench]\n+        pub fn $name(b: &mut Bencher) {\n+            // setup\n+            let sets = $sets;\n+\n+            // measure\n+            b.iter(|| {\n+                let x = sets[0].intersection(&sets[1]).count();\n+                black_box(x);\n+            })\n+        }\n+    };\n+}\n+\n+set_intersection_bench! {intersect_random_100,          random(100, 100)}\n+set_intersection_bench! {intersect_random_10k,          random(10_000, 10_000)}\n+set_intersection_bench! {intersect_random_10_vs_10k,    random(10, 10_000)}\n+set_intersection_bench! {intersect_random_10k_vs_10,    random(10_000, 10)}\n+set_intersection_bench! {intersect_staggered_100,       staggered(100, 100)}\n+set_intersection_bench! {intersect_staggered_10k,       staggered(10_000, 10_000)}\n+set_intersection_bench! {intersect_staggered_10_vs_10k, staggered(10, 10_000)}\n+set_intersection_bench! {intersect_staggered_10k_vs_10, staggered(10_000, 10)}\n+set_intersection_bench! {intersect_neg_vs_pos_100,      neg_vs_pos(100, 100)}\n+set_intersection_bench! {intersect_neg_vs_pos_10k,      neg_vs_pos(10_000, 10_000)}\n+set_intersection_bench! {intersect_neg_vs_pos_10_vs_10k,neg_vs_pos(10, 10_000)}\n+set_intersection_bench! {intersect_neg_vs_pos_10k_vs_10,neg_vs_pos(10_000, 10)}\n+set_intersection_bench! {intersect_pos_vs_neg_100,      pos_vs_neg(100, 100)}\n+set_intersection_bench! {intersect_pos_vs_neg_10k,      pos_vs_neg(10_000, 10_000)}\n+set_intersection_bench! {intersect_pos_vs_neg_10_vs_10k,pos_vs_neg(10, 10_000)}\n+set_intersection_bench! {intersect_pos_vs_neg_10k_vs_10,pos_vs_neg(10_000, 10)}"}, {"sha": "7d2d3cfa61225d64c9544d37e0f65564b7d10942", "filename": "src/liballoc/benches/vec_deque.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec_deque.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -45,3 +45,10 @@ fn bench_mut_iter_1000(b: &mut Bencher) {\n         black_box(sum);\n     })\n }\n+\n+#[bench]\n+fn bench_try_fold(b: &mut Bencher) {\n+    let ring: VecDeque<_> = (0..1000).collect();\n+\n+    b.iter(|| black_box(ring.iter().try_fold(0, |a, b| Some(a + b))))\n+}"}, {"sha": "ce29978856ffd6315dd413c573a270771d09cb08", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -1634,9 +1634,11 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n \n         let mut cur_handle = match handle.right_kv() {\n             Ok(kv) => {\n-                let (k, v) = ptr::read(&kv).into_kv_mut();\n-                self.front = kv.right_edge();\n-                return (k, v);\n+                self.front = ptr::read(&kv).right_edge();\n+                // Doing the descend invalidates the references returned by `into_kv_mut`,\n+                // so we have to do this last.\n+                let (k, v) = kv.into_kv_mut();\n+                return (k, v); // coerce k from `&mut K` to `&K`\n             }\n             Err(last_edge) => {\n                 let next_level = last_edge.into_node().ascend().ok();\n@@ -1647,9 +1649,11 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n         loop {\n             match cur_handle.right_kv() {\n                 Ok(kv) => {\n-                    let (k, v) = ptr::read(&kv).into_kv_mut();\n-                    self.front = first_leaf_edge(kv.right_edge().descend());\n-                    return (k, v);\n+                    self.front = first_leaf_edge(ptr::read(&kv).right_edge().descend());\n+                    // Doing the descend invalidates the references returned by `into_kv_mut`,\n+                    // so we have to do this last.\n+                    let (k, v) = kv.into_kv_mut();\n+                    return (k, v); // coerce k from `&mut K` to `&K`\n                 }\n                 Err(last_edge) => {\n                     let next_level = last_edge.into_node().ascend().ok();\n@@ -1680,9 +1684,11 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n \n         let mut cur_handle = match handle.left_kv() {\n             Ok(kv) => {\n-                let (k, v) = ptr::read(&kv).into_kv_mut();\n-                self.back = kv.left_edge();\n-                return (k, v);\n+                self.back = ptr::read(&kv).left_edge();\n+                // Doing the descend invalidates the references returned by `into_kv_mut`,\n+                // so we have to do this last.\n+                let (k, v) = kv.into_kv_mut();\n+                return (k, v); // coerce k from `&mut K` to `&K`\n             }\n             Err(last_edge) => {\n                 let next_level = last_edge.into_node().ascend().ok();\n@@ -1693,9 +1699,11 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n         loop {\n             match cur_handle.left_kv() {\n                 Ok(kv) => {\n-                    let (k, v) = ptr::read(&kv).into_kv_mut();\n-                    self.back = last_leaf_edge(kv.left_edge().descend());\n-                    return (k, v);\n+                    self.back = last_leaf_edge(ptr::read(&kv).left_edge().descend());\n+                    // Doing the descend invalidates the references returned by `into_kv_mut`,\n+                    // so we have to do this last.\n+                    let (k, v) = kv.into_kv_mut();\n+                    return (k, v); // coerce k from `&mut K` to `&K`\n                 }\n                 Err(last_edge) => {\n                     let next_level = last_edge.into_node().ascend().ok();"}, {"sha": "66d619b1298b41e91a13a98d74afc27760ad9ecf", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -645,6 +645,8 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     }\n \n     fn into_key_slice_mut(mut self) -> &'a mut [K] {\n+        // Same as for `into_key_slice` above, we try to avoid a run-time check\n+        // (the alignment comparison will usually be performed at compile-time).\n         if mem::align_of::<K>() > mem::align_of::<LeafNode<(), ()>>() && self.is_shared_root() {\n             &mut []\n         } else {\n@@ -667,9 +669,26 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n-    fn into_slices_mut(self) -> (&'a mut [K], &'a mut [V]) {\n-        let k = unsafe { ptr::read(&self) };\n-        (k.into_key_slice_mut(), self.into_val_slice_mut())\n+    fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n+        debug_assert!(!self.is_shared_root());\n+        // We cannot use the getters here, because calling the second one\n+        // invalidates the reference returned by the first.\n+        // More precisely, it is the call to `len` that is the culprit,\n+        // because that creates a shared reference to the header, which *can*\n+        // overlap with the keys (and even the values, for ZST keys).\n+        unsafe {\n+            let len = self.len();\n+            let leaf = self.as_leaf_mut();\n+            let keys = slice::from_raw_parts_mut(\n+                MaybeUninit::first_ptr_mut(&mut (*leaf).keys),\n+                len\n+            );\n+            let vals = slice::from_raw_parts_mut(\n+                MaybeUninit::first_ptr_mut(&mut (*leaf).vals),\n+                len\n+            );\n+            (keys, vals)\n+        }\n     }\n }\n "}, {"sha": "4e90f783ec6a596cec9403518d260cb4b44b98cd", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -2170,12 +2170,29 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         back.iter().fold(accum, &mut f)\n     }\n \n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n     {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        let accum = front.iter().try_fold(init, &mut f)?;\n-        back.iter().try_fold(accum, &mut f)\n+        let (mut iter, final_res);\n+        if self.tail <= self.head {\n+            // single slice self.ring[self.tail..self.head]\n+            iter = self.ring[self.tail..self.head].iter();\n+            final_res = iter.try_fold(init, &mut f);\n+        } else {\n+            // two slices: self.ring[self.tail..], self.ring[..self.head]\n+            let (front, back) = self.ring.split_at(self.tail);\n+            let mut back_iter = back.iter();\n+            let res = back_iter.try_fold(init, &mut f);\n+            let len = self.ring.len();\n+            self.tail = (self.ring.len() - back_iter.len()) & (len - 1);\n+            iter = front[..self.head].iter();\n+            final_res = iter.try_fold(res?, &mut f);\n+        }\n+        self.tail = self.head - iter.len();\n+        final_res\n     }\n }\n \n@@ -2197,6 +2214,30 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n         accum = back.iter().rfold(accum, &mut f);\n         front.iter().rfold(accum, &mut f)\n     }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        let (mut iter, final_res);\n+        if self.tail <= self.head {\n+            // single slice self.ring[self.tail..self.head]\n+            iter = self.ring[self.tail..self.head].iter();\n+            final_res = iter.try_rfold(init, &mut f);\n+        } else {\n+            // two slices: self.ring[self.tail..], self.ring[..self.head]\n+            let (front, back) = self.ring.split_at(self.tail);\n+            let mut front_iter = front[..self.head].iter();\n+            let res = front_iter.try_rfold(init, &mut f);\n+            self.head = front_iter.len();\n+            iter = back.iter();\n+            final_res = iter.try_rfold(res?, &mut f);\n+        }\n+        self.head = self.tail + iter.len();\n+        final_res\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "16ddc1444fcf90ae04d6b69b33b34a36989b2c27", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -1465,6 +1465,15 @@ fn test_try_fold_unit() {\n     assert_eq!(Some(()), v.into_iter().try_fold((), |(), ()| Some(())));\n }\n \n+\n+#[test]\n+fn test_try_fold_unit_none() {\n+    let v: std::collections::VecDeque<()> = [(); 10].iter().cloned().collect();\n+    let mut iter = v.into_iter();\n+    assert!(iter.try_fold((), |_, _| None).is_none());\n+    assert_eq!(iter.len(), 9);\n+}\n+\n #[test]\n fn test_try_fold_rotated() {\n     let mut v: VecDeque<_> = (0..12).collect();\n@@ -1477,3 +1486,58 @@ fn test_try_fold_rotated() {\n         assert_eq!(Ok::<_, ()>(66), v.iter().try_fold(0, |a, b| Ok(a + b)));\n     }\n }\n+\n+#[test]\n+fn test_try_fold_moves_iter() {\n+    let v: VecDeque<_> = [10, 20, 30, 40, 100, 60, 70, 80, 90].iter().collect();\n+    let mut iter = v.into_iter();\n+    assert_eq!(iter.try_fold(0_i8, |acc, &x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next(), Some(&60));\n+}\n+\n+#[test]\n+fn test_try_fold_exhaust_wrap() {\n+    let mut v = VecDeque::with_capacity(7);\n+    v.push_back(1);\n+    v.push_back(1);\n+    v.push_back(1);\n+    v.pop_front();\n+    v.pop_front();\n+    let mut iter = v.iter();\n+    let _ = iter.try_fold(0, |_, _| Some(1));\n+    assert!(iter.is_empty());\n+}\n+\n+#[test]\n+fn test_try_fold_wraparound() {\n+    let mut v = VecDeque::with_capacity(8);\n+    v.push_back(7);\n+    v.push_back(8);\n+    v.push_back(9);\n+    v.push_front(2);\n+    v.push_front(1);\n+    let mut iter = v.iter();\n+    let _ = iter.find(|&&x| x == 2);\n+    assert_eq!(Some(&7), iter.next());\n+}\n+\n+#[test]\n+fn test_try_rfold_rotated() {\n+    let mut v: VecDeque<_> = (0..12).collect();\n+    for n in 0..10 {\n+        if n & 1 == 0 {\n+            v.rotate_left(n);\n+        } else {\n+            v.rotate_right(n);\n+        }\n+        assert_eq!(Ok::<_, ()>(66), v.iter().try_rfold(0, |a, b| Ok(a + b)));\n+    }\n+}\n+\n+#[test]\n+fn test_try_rfold_moves_iter() {\n+    let v : VecDeque<_> = [10, 20, 30, 40, 100, 60, 70, 80, 90].iter().collect();\n+    let mut iter = v.into_iter();\n+    assert_eq!(iter.try_rfold(0_i8, |acc, &x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next_back(), Some(&70));\n+}"}, {"sha": "dddfa3f158e71f70c2c4c9f7552ac4758baff097", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -1365,6 +1365,7 @@ impl<T: Default> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// #![feature(vec_resize_default)]\n     ///\n     /// let mut vec = vec![1, 2, 3];\n@@ -1381,6 +1382,9 @@ impl<T: Default> Vec<T> {\n     /// [`Default`]: ../../std/default/trait.Default.html\n     /// [`Clone`]: ../../std/clone/trait.Clone.html\n     #[unstable(feature = \"vec_resize_default\", issue = \"41758\")]\n+    #[rustc_deprecated(reason = \"This is moving towards being removed in favor \\\n+        of `.resize_with(Default::default)`.  If you disagree, please comment \\\n+        in the tracking issue.\", since = \"1.33.0\")]\n     pub fn resize_default(&mut self, new_len: usize) {\n         let len = self.len();\n "}, {"sha": "a143b54a61f543ea0285d49584e246df39758291", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -24,6 +24,7 @@ use task::{Poll, Waker};\n ///\n /// When using a future, you generally won't call `poll` directly, but instead\n /// `await!` the value.\n+#[doc(spotlight)]\n #[must_use = \"futures do nothing unless polled\"]\n pub trait Future {\n     /// The type of value produced on completion."}, {"sha": "f369324157a9e358209f694a76c31ae813ce82b6", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -1545,20 +1545,22 @@ Erroneous code example:\n ```compile_fail,E0505\n struct Value {}\n \n+fn borrow(val: &Value) {}\n+\n fn eat(val: Value) {}\n \n fn main() {\n     let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-        eat(x);\n-    }\n+    let _ref_to_val: &Value = &x;\n+    eat(x);\n+    borrow(_ref_to_val);\n }\n ```\n \n-Here, the function `eat` takes the ownership of `x`. However,\n-`x` cannot be moved because it was borrowed to `_ref_to_val`.\n-To fix that you can do few different things:\n+Here, the function `eat` takes ownership of `x`. However,\n+`x` cannot be moved because the borrow to `_ref_to_val`\n+needs to last till the function `borrow`.\n+To fix that you can do a few different things:\n \n * Try to avoid moving the variable.\n * Release borrow before move.\n@@ -1569,14 +1571,15 @@ Examples:\n ```\n struct Value {}\n \n+fn borrow(val: &Value) {}\n+\n fn eat(val: &Value) {}\n \n fn main() {\n     let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-        eat(&x); // pass by reference, if it's possible\n-    }\n+    let _ref_to_val: &Value = &x;\n+    eat(&x); // pass by reference, if it's possible\n+    borrow(_ref_to_val);\n }\n ```\n \n@@ -1585,12 +1588,15 @@ Or:\n ```\n struct Value {}\n \n+fn borrow(val: &Value) {}\n+\n fn eat(val: Value) {}\n \n fn main() {\n     let x = Value{};\n     {\n         let _ref_to_val: &Value = &x;\n+        borrow(_ref_to_val);\n     }\n     eat(x); // release borrow and then move it.\n }\n@@ -1602,14 +1608,15 @@ Or:\n #[derive(Clone, Copy)] // implement Copy trait\n struct Value {}\n \n+fn borrow(val: &Value) {}\n+\n fn eat(val: Value) {}\n \n fn main() {\n     let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-        eat(x); // it will be copied here.\n-    }\n+    let _ref_to_val: &Value = &x;\n+    eat(x); // it will be copied here.\n+    borrow(_ref_to_val);\n }\n ```\n "}, {"sha": "ec701a939f225d7a657efa1ec630f1030610f7f7", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -326,6 +326,10 @@ where\n \n         let mplace = MemPlace {\n             ptr: val.to_scalar_ptr()?,\n+            // We could use the run-time alignment here. For now, we do not, because\n+            // the point of tracking the alignment here is to make sure that the *static*\n+            // alignment information emitted with the loads is correct. The run-time\n+            // alignment can only be more restrictive.\n             align: layout.align.abi,\n             meta: val.to_meta()?,\n         };\n@@ -385,9 +389,11 @@ where\n         // above). In that case, all fields are equal.\n         let field_layout = base.layout.field(self, usize::try_from(field).unwrap_or(0))?;\n \n-        // Offset may need adjustment for unsized fields\n+        // Offset may need adjustment for unsized fields.\n         let (meta, offset) = if field_layout.is_unsized() {\n-            // re-use parent metadata to determine dynamic field layout\n+            // Re-use parent metadata to determine dynamic field layout.\n+            // With custom DSTS, this *will* execute user-defined code, but the same\n+            // happens at run-time so that's okay.\n             let align = match self.size_and_align_of(base.meta, field_layout)? {\n                 Some((_, align)) => align,\n                 None if offset == Size::ZERO =>"}, {"sha": "cd771d93e00f61fd651326869d684533e992015b", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -259,6 +259,10 @@ impl<'a> Resolver<'a> {\n                     format!(\"{}!\", path_str),\n                     Applicability::MaybeIncorrect,\n                 );\n+                if path_str == \"try\" && span.rust_2015() {\n+                    err.note(\"if you want the `try` keyword, \\\n+                        you need to be in the 2018 edition\");\n+                }\n             }\n             (Def::TyAlias(..), PathSource::Trait(_)) => {\n                 err.span_label(span, \"type aliases cannot be used as traits\");"}, {"sha": "bef2afc7b6292db5530e23008ab3e45fe9597234", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -259,6 +259,11 @@ impl ToJson for MergeFunctions {\n     }\n }\n \n+pub enum LoadTargetError {\n+    BuiltinTargetNotFound(String),\n+    Other(String),\n+}\n+\n pub type LinkArgs = BTreeMap<LinkerFlavor, Vec<String>>;\n pub type TargetResult = Result<Target, String>;\n \n@@ -269,21 +274,24 @@ macro_rules! supported_targets {\n         /// List of supported targets\n         const TARGETS: &[&str] = &[$($triple),*];\n \n-        fn load_specific(target: &str) -> TargetResult {\n+        fn load_specific(target: &str) -> Result<Target, LoadTargetError> {\n             match target {\n                 $(\n                     $triple => {\n-                        let mut t = $module::target()?;\n+                        let mut t = $module::target()\n+                            .map_err(LoadTargetError::Other)?;\n                         t.options.is_builtin = true;\n \n                         // round-trip through the JSON parser to ensure at\n                         // run-time that the parser works correctly\n-                        t = Target::from_json(t.to_json())?;\n+                        t = Target::from_json(t.to_json())\n+                            .map_err(LoadTargetError::Other)?;\n                         debug!(\"Got builtin target: {:?}\", t);\n                         Ok(t)\n                     },\n                 )+\n-                _ => Err(format!(\"Unable to find target: {}\", target))\n+                    _ => Err(LoadTargetError::BuiltinTargetNotFound(\n+                        format!(\"Unable to find target: {}\", target)))\n             }\n         }\n \n@@ -1176,8 +1184,10 @@ impl Target {\n         match *target_triple {\n             TargetTriple::TargetTriple(ref target_triple) => {\n                 // check if triple is in list of supported targets\n-                if let Ok(t) = load_specific(target_triple) {\n-                    return Ok(t)\n+                match load_specific(target_triple) {\n+                    Ok(t) => return Ok(t),\n+                    Err(LoadTargetError::BuiltinTargetNotFound(_)) => (),\n+                    Err(LoadTargetError::Other(e)) => return Err(e),\n                 }\n \n                 // search for a file named `target_triple`.json in RUST_TARGET_PATH"}, {"sha": "7f7fffbba100ee9038f5cf8da286deab31fa406f", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -458,26 +458,18 @@ fn resolution_failure(\n     link_range: Option<Range<usize>>,\n ) {\n     let sp = span_of_attrs(attrs);\n-    let msg = format!(\"`[{}]` cannot be resolved, ignoring it...\", path_str);\n \n-    let mut diag = if let Some(link_range) = link_range {\n+    let mut diag = cx.tcx.struct_span_lint_node(\n+        lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+        NodeId::from_u32(0),\n+        sp,\n+        &format!(\"`[{}]` cannot be resolved, ignoring it...\", path_str),\n+    );\n+    if let Some(link_range) = link_range {\n         if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs) {\n-            let mut diag = cx.tcx.struct_span_lint_node(\n-                lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-                NodeId::from_u32(0),\n-                sp,\n-                &msg,\n-            );\n+            diag.set_span(sp);\n             diag.span_label(sp, \"cannot be resolved, ignoring\");\n-            diag\n         } else {\n-            let mut diag = cx.tcx.struct_span_lint_node(\n-                lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-                NodeId::from_u32(0),\n-                sp,\n-                &msg,\n-            );\n-\n             // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n             //                       ^     ~~~~\n             //                       |     link_range\n@@ -494,13 +486,7 @@ fn resolution_failure(\n                 before=link_range.start - last_new_line_offset,\n                 found=link_range.len(),\n             ));\n-            diag\n         }\n-    } else {\n-        cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-                                     NodeId::from_u32(0),\n-                                     sp,\n-                                     &msg)\n     };\n     diag.help(\"to escape `[` and `]` characters, just add '\\\\' before them like \\\n                `\\\\[` or `\\\\]`\");"}, {"sha": "6dd3a6cc0fdbd45422c3ee8463dad5d099317d06", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -215,16 +215,22 @@\n // std may use features in a platform-specific way\n #![allow(unused_features)]\n \n+#![cfg_attr(test, feature(test, update_panic_count))]\n+#![cfg_attr(all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n+            feature(global_asm, range_contains, slice_index_methods,\n+                    decl_macro, coerce_unsized, sgx_platform, ptr_wrapping_offset_from))]\n+\n // std is implemented with unstable features, many of which are internal\n // compiler details that will never be stable\n-#![cfg_attr(test, feature(test, update_panic_count))]\n-#![feature(alloc)]\n+// NB: the following list is sorted to minimize merge conflicts.\n+#![feature(align_offset)]\n #![feature(alloc_error_handler)]\n+#![feature(alloc_layout_extra)]\n+#![feature(alloc)]\n #![feature(allocator_api)]\n #![feature(allocator_internals)]\n #![feature(allow_internal_unsafe)]\n #![feature(allow_internal_unstable)]\n-#![feature(align_offset)]\n #![feature(arbitrary_self_types)]\n #![feature(array_error_internals)]\n #![feature(asm)]\n@@ -233,72 +239,69 @@\n #![feature(cfg_target_has_atomic)]\n #![feature(cfg_target_thread_local)]\n #![feature(char_error_internals)]\n+#![feature(checked_duration_since)]\n #![feature(compiler_builtins_lib)]\n #![feature(concat_idents)]\n-#![feature(const_raw_ptr_deref)]\n #![feature(const_cstr_unchecked)]\n+#![feature(const_raw_ptr_deref)]\n #![feature(core_intrinsics)]\n+#![feature(doc_alias)]\n+#![feature(doc_cfg)]\n+#![feature(doc_keyword)]\n+#![feature(doc_masked)]\n+#![feature(doc_spotlight)]\n #![feature(dropck_eyepatch)]\n #![feature(duration_constants)]\n #![feature(exact_size_is_empty)]\n+#![feature(exhaustive_patterns)]\n #![feature(external_doc)]\n #![feature(fixed_size_array)]\n #![feature(fn_traits)]\n #![feature(fnbox)]\n #![feature(futures_api)]\n #![feature(generator_trait)]\n+#![feature(hash_raw_entry)]\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]\n #![feature(integer_atomics)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(linkage)]\n+#![feature(maybe_uninit)]\n #![feature(needs_panic_runtime)]\n #![feature(never_type)]\n #![feature(nll)]\n-#![feature(exhaustive_patterns)]\n+#![feature(non_exhaustive)]\n #![feature(on_unimplemented)]\n #![feature(optin_builtin_traits)]\n+#![feature(panic_info_message)]\n #![feature(panic_internals)]\n #![feature(panic_unwind)]\n #![feature(prelude_import)]\n #![feature(ptr_internals)]\n #![feature(raw)]\n-#![feature(hash_raw_entry)]\n+#![feature(renamed_spin_loop)]\n #![feature(rustc_attrs)]\n #![feature(rustc_const_unstable)]\n-#![feature(std_internals)]\n-#![feature(stdsimd)]\n+#![feature(rustc_private)]\n #![feature(shrink_to)]\n #![feature(slice_concat_ext)]\n #![feature(slice_internals)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n+#![feature(std_internals)]\n+#![feature(stdsimd)]\n #![feature(stmt_expr_attributes)]\n #![feature(str_internals)]\n-#![feature(renamed_spin_loop)]\n-#![feature(rustc_private)]\n #![feature(thread_local)]\n #![feature(toowned_clone_into)]\n #![feature(try_from)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n-#![feature(doc_cfg)]\n-#![feature(doc_masked)]\n-#![feature(doc_spotlight)]\n-#![feature(doc_alias)]\n-#![feature(doc_keyword)]\n-#![feature(panic_info_message)]\n-#![feature(non_exhaustive)]\n-#![feature(alloc_layout_extra)]\n-#![feature(maybe_uninit)]\n-#![feature(checked_duration_since)]\n-#![cfg_attr(all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n-            feature(global_asm, range_contains, slice_index_methods,\n-                    decl_macro, coerce_unsized, sgx_platform, ptr_wrapping_offset_from))]\n+// NB: the above list is sorted to minimize merge conflicts.\n \n #![default_lib_allocator]\n "}, {"sha": "020075531dd0e0420f22f2e4248dae215ed87890", "filename": "src/libstd/sys/redox/ext/process.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -36,7 +36,7 @@ pub trait CommandExt {\n     /// will be called and the spawn operation will immediately return with a\n     /// failure.\n     ///\n-    /// # Notes\n+    /// # Notes and Safety\n     ///\n     /// This closure will be run in the context of the child process after a\n     /// `fork`. This primarily means that any modifications made to memory on\n@@ -45,12 +45,32 @@ pub trait CommandExt {\n     /// like `malloc` or acquiring a mutex are not guaranteed to work (due to\n     /// other threads perhaps still running when the `fork` was run).\n     ///\n+    /// This also means that all resources such as file descriptors and\n+    /// memory-mapped regions got duplicated. It is your responsibility to make\n+    /// sure that the closure does not violate library invariants by making\n+    /// invalid use of these duplicates.\n+    ///\n     /// When this closure is run, aspects such as the stdio file descriptors and\n     /// working directory have successfully been changed, so output to these\n     /// locations may not appear where intended.\n+    #[stable(feature = \"process_pre_exec\", since = \"1.34.0\")]\n+    unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n+        where F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n+\n+    /// Schedules a closure to be run just before the `exec` function is\n+    /// invoked.\n+    ///\n+    /// This method is stable and usable, but it should be unsafe. To fix\n+    /// that, it got deprecated in favor of the unsafe [`pre_exec`].\n+    ///\n+    /// [`pre_exec`]: #tymethod.pre_exec\n     #[stable(feature = \"process_exec\", since = \"1.15.0\")]\n+    #[rustc_deprecated(since = \"1.37.0\", reason = \"should be unsafe, use `pre_exec` instead\")]\n     fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n+        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n+    {\n+        unsafe { self.pre_exec(f) }\n+    }\n \n     /// Performs all the required setup by this `Command`, followed by calling\n     /// the `execvp` syscall.\n@@ -87,10 +107,10 @@ impl CommandExt for process::Command {\n         self\n     }\n \n-    fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n+    unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n         where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n     {\n-        self.as_inner_mut().before_exec(Box::new(f));\n+        self.as_inner_mut().pre_exec(Box::new(f));\n         self\n     }\n "}, {"sha": "81af8eb553d00c15f9312b6a9e9c28c42018a888", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -116,8 +116,10 @@ impl Command {\n         self.gid = Some(id);\n     }\n \n-    pub fn before_exec(&mut self,\n-                       f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>) {\n+    pub unsafe fn pre_exec(\n+        &mut self,\n+        f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>,\n+    ) {\n         self.closures.push(f);\n     }\n "}, {"sha": "b487bb889bafa5ca115b2638d0e8a6a2832ee8a0", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -36,7 +36,7 @@ pub trait CommandExt {\n     /// will be called and the spawn operation will immediately return with a\n     /// failure.\n     ///\n-    /// # Notes\n+    /// # Notes and Safety\n     ///\n     /// This closure will be run in the context of the child process after a\n     /// `fork`. This primarily means that any modifications made to memory on\n@@ -45,12 +45,32 @@ pub trait CommandExt {\n     /// like `malloc` or acquiring a mutex are not guaranteed to work (due to\n     /// other threads perhaps still running when the `fork` was run).\n     ///\n+    /// This also means that all resources such as file descriptors and\n+    /// memory-mapped regions got duplicated. It is your responsibility to make\n+    /// sure that the closure does not violate library invariants by making\n+    /// invalid use of these duplicates.\n+    ///\n     /// When this closure is run, aspects such as the stdio file descriptors and\n     /// working directory have successfully been changed, so output to these\n     /// locations may not appear where intended.\n+    #[stable(feature = \"process_pre_exec\", since = \"1.34.0\")]\n+    unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n+        where F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n+\n+    /// Schedules a closure to be run just before the `exec` function is\n+    /// invoked.\n+    ///\n+    /// This method is stable and usable, but it should be unsafe. To fix\n+    /// that, it got deprecated in favor of the unsafe [`pre_exec`].\n+    ///\n+    /// [`pre_exec`]: #tymethod.pre_exec\n     #[stable(feature = \"process_exec\", since = \"1.15.0\")]\n+    #[rustc_deprecated(since = \"1.37.0\", reason = \"should be unsafe, use `pre_exec` instead\")]\n     fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n+        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n+    {\n+        unsafe { self.pre_exec(f) }\n+    }\n \n     /// Performs all the required setup by this `Command`, followed by calling\n     /// the `execvp` syscall.\n@@ -97,10 +117,10 @@ impl CommandExt for process::Command {\n         self\n     }\n \n-    fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n+    unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n         where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n     {\n-        self.as_inner_mut().before_exec(Box::new(f));\n+        self.as_inner_mut().pre_exec(Box::new(f));\n         self\n     }\n "}, {"sha": "7fa256e59b2db294c5f1dc513ed4348716274893", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -149,8 +149,10 @@ impl Command {\n         &mut self.closures\n     }\n \n-    pub fn before_exec(&mut self,\n-                       f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>) {\n+    pub unsafe fn pre_exec(\n+        &mut self,\n+        f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>,\n+    ) {\n         self.closures.push(f);\n     }\n "}, {"sha": "27b0cfb163077e8d2ba28731a415d9690169f20d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -9,12 +9,6 @@ use crate::ThinVec;\n use rustc_target::spec::abi::Abi;\n use syntax_pos::{Pos, Span, DUMMY_SP};\n \n-// Transitional re-exports so qquote can find the paths it is looking for\n-mod syntax {\n-    pub use crate::ext;\n-    pub use crate::parse;\n-}\n-\n pub trait AstBuilder {\n     // paths\n     fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path;"}, {"sha": "f50663f97853fad540f9f649af536587a9b8752f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -36,10 +36,8 @@ macro_rules! ast_fragments {\n     (\n         $($Kind:ident($AstTy:ty) {\n             $kind_name:expr;\n-            // FIXME: HACK: this should be `$(one ...)?` and `$(many ...)?` but `?` macro\n-            // repetition was removed from 2015 edition in #51587 because of ambiguities.\n-            $(one fn $mut_visit_ast:ident; fn $visit_ast:ident;)*\n-            $(many fn $flat_map_ast_elt:ident; fn $visit_ast_elt:ident;)*\n+            $(one fn $mut_visit_ast:ident; fn $visit_ast:ident;)?\n+            $(many fn $flat_map_ast_elt:ident; fn $visit_ast_elt:ident;)?\n             fn $make_ast:ident;\n         })*\n     ) => {"}, {"sha": "e6a48912c48b47a771f384d5eeb0d10434480746", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -5503,6 +5503,7 @@ impl<'a> Parser<'a> {\n             if is_bound_start {\n                 let lo = self.span;\n                 let has_parens = self.eat(&token::OpenDelim(token::Paren));\n+                let inner_lo = self.span;\n                 let question = if self.eat(&token::Question) { Some(self.prev_span) } else { None };\n                 if self.token.is_lifetime() {\n                     if let Some(question_span) = question {\n@@ -5511,9 +5512,21 @@ impl<'a> Parser<'a> {\n                     }\n                     bounds.push(GenericBound::Outlives(self.expect_lifetime()));\n                     if has_parens {\n+                        let inner_span = inner_lo.to(self.prev_span);\n                         self.expect(&token::CloseDelim(token::Paren))?;\n-                        self.span_err(self.prev_span,\n-                                      \"parenthesized lifetime bounds are not supported\");\n+                        let mut err = self.struct_span_err(\n+                            lo.to(self.prev_span),\n+                            \"parenthesized lifetime bounds are not supported\"\n+                        );\n+                        if let Ok(snippet) = self.sess.source_map().span_to_snippet(inner_span) {\n+                            err.span_suggestion_short(\n+                                lo.to(self.prev_span),\n+                                \"remove the parentheses\",\n+                                snippet.to_owned(),\n+                                Applicability::MachineApplicable\n+                            );\n+                        }\n+                        err.emit();\n                     }\n                 } else {\n                     let lifetime_defs = self.parse_late_bound_lifetime_defs()?;"}, {"sha": "91d2636b2ae63e28ba6d4d3d570ad60fb78abc48", "filename": "src/test/run-pass/command-before-exec.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e1c6d00574494499f63c1e460ef886768643e7db/src%2Ftest%2Frun-pass%2Fcommand-before-exec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c6d00574494499f63c1e460ef886768643e7db/src%2Ftest%2Frun-pass%2Fcommand-before-exec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommand-before-exec.rs?ref=e1c6d00574494499f63c1e460ef886768643e7db", "patch": "@@ -1,83 +0,0 @@\n-#![allow(stable_features)]\n-// ignore-windows - this is a unix-specific test\n-// ignore-cloudabi no processes\n-// ignore-emscripten no processes\n-\n-#![feature(process_exec, rustc_private)]\n-\n-extern crate libc;\n-\n-use std::env;\n-use std::io::Error;\n-use std::os::unix::process::CommandExt;\n-use std::process::Command;\n-use std::sync::Arc;\n-use std::sync::atomic::{AtomicUsize, Ordering};\n-\n-fn main() {\n-    if let Some(arg) = env::args().nth(1) {\n-        match &arg[..] {\n-            \"test1\" => println!(\"hello2\"),\n-            \"test2\" => assert_eq!(env::var(\"FOO\").unwrap(), \"BAR\"),\n-            \"test3\" => assert_eq!(env::current_dir().unwrap()\n-                                      .to_str().unwrap(), \"/\"),\n-            \"empty\" => {}\n-            _ => panic!(\"unknown argument: {}\", arg),\n-        }\n-        return\n-    }\n-\n-    let me = env::current_exe().unwrap();\n-\n-    let output = Command::new(&me).arg(\"test1\").before_exec(|| {\n-        println!(\"hello\");\n-        Ok(())\n-    }).output().unwrap();\n-    assert!(output.status.success());\n-    assert!(output.stderr.is_empty());\n-    assert_eq!(output.stdout, b\"hello\\nhello2\\n\");\n-\n-    let output = Command::new(&me).arg(\"test2\").before_exec(|| {\n-        env::set_var(\"FOO\", \"BAR\");\n-        Ok(())\n-    }).output().unwrap();\n-    assert!(output.status.success());\n-    assert!(output.stderr.is_empty());\n-    assert!(output.stdout.is_empty());\n-\n-    let output = Command::new(&me).arg(\"test3\").before_exec(|| {\n-        env::set_current_dir(\"/\").unwrap();\n-        Ok(())\n-    }).output().unwrap();\n-    assert!(output.status.success());\n-    assert!(output.stderr.is_empty());\n-    assert!(output.stdout.is_empty());\n-\n-    let output = Command::new(&me).arg(\"bad\").before_exec(|| {\n-        Err(Error::from_raw_os_error(102))\n-    }).output().unwrap_err();\n-    assert_eq!(output.raw_os_error(), Some(102));\n-\n-    let pid = unsafe { libc::getpid() };\n-    assert!(pid >= 0);\n-    let output = Command::new(&me).arg(\"empty\").before_exec(move || {\n-        let child = unsafe { libc::getpid() };\n-        assert!(child >= 0);\n-        assert!(pid != child);\n-        Ok(())\n-    }).output().unwrap();\n-    assert!(output.status.success());\n-    assert!(output.stderr.is_empty());\n-    assert!(output.stdout.is_empty());\n-\n-    let mem = Arc::new(AtomicUsize::new(0));\n-    let mem2 = mem.clone();\n-    let output = Command::new(&me).arg(\"empty\").before_exec(move || {\n-        assert_eq!(mem2.fetch_add(1, Ordering::SeqCst), 0);\n-        Ok(())\n-    }).output().unwrap();\n-    assert!(output.status.success());\n-    assert!(output.stderr.is_empty());\n-    assert!(output.stdout.is_empty());\n-    assert_eq!(mem.load(Ordering::SeqCst), 0);\n-}"}, {"sha": "21783fedd39c9ada818cfe30db07fdc311919bfd", "filename": "src/test/run-pass/command-pre-exec.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Ftest%2Frun-pass%2Fcommand-pre-exec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Ftest%2Frun-pass%2Fcommand-pre-exec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommand-pre-exec.rs?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -0,0 +1,115 @@\n+#![allow(stable_features)]\n+// ignore-windows - this is a unix-specific test\n+// ignore-cloudabi no processes\n+// ignore-emscripten no processes\n+#![feature(process_exec, rustc_private)]\n+\n+extern crate libc;\n+\n+use std::env;\n+use std::io::Error;\n+use std::os::unix::process::CommandExt;\n+use std::process::Command;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::sync::Arc;\n+\n+fn main() {\n+    if let Some(arg) = env::args().nth(1) {\n+        match &arg[..] {\n+            \"test1\" => println!(\"hello2\"),\n+            \"test2\" => assert_eq!(env::var(\"FOO\").unwrap(), \"BAR\"),\n+            \"test3\" => assert_eq!(env::current_dir().unwrap().to_str().unwrap(), \"/\"),\n+            \"empty\" => {}\n+            _ => panic!(\"unknown argument: {}\", arg),\n+        }\n+        return;\n+    }\n+\n+    let me = env::current_exe().unwrap();\n+\n+    let output = unsafe {\n+        Command::new(&me)\n+            .arg(\"test1\")\n+            .pre_exec(|| {\n+                println!(\"hello\");\n+                Ok(())\n+            })\n+            .output()\n+            .unwrap()\n+    };\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert_eq!(output.stdout, b\"hello\\nhello2\\n\");\n+\n+    let output = unsafe {\n+        Command::new(&me)\n+            .arg(\"test2\")\n+            .pre_exec(|| {\n+                env::set_var(\"FOO\", \"BAR\");\n+                Ok(())\n+            })\n+            .output()\n+            .unwrap()\n+    };\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert!(output.stdout.is_empty());\n+\n+    let output = unsafe {\n+        Command::new(&me)\n+            .arg(\"test3\")\n+            .pre_exec(|| {\n+                env::set_current_dir(\"/\").unwrap();\n+                Ok(())\n+            })\n+            .output()\n+            .unwrap()\n+    };\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert!(output.stdout.is_empty());\n+\n+    let output = unsafe {\n+        Command::new(&me)\n+            .arg(\"bad\")\n+            .pre_exec(|| Err(Error::from_raw_os_error(102)))\n+            .output()\n+            .unwrap_err()\n+    };\n+    assert_eq!(output.raw_os_error(), Some(102));\n+\n+    let pid = unsafe { libc::getpid() };\n+    assert!(pid >= 0);\n+    let output = unsafe {\n+        Command::new(&me)\n+            .arg(\"empty\")\n+            .pre_exec(move || {\n+                let child = libc::getpid();\n+                assert!(child >= 0);\n+                assert!(pid != child);\n+                Ok(())\n+            })\n+            .output()\n+            .unwrap()\n+    };\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert!(output.stdout.is_empty());\n+\n+    let mem = Arc::new(AtomicUsize::new(0));\n+    let mem2 = mem.clone();\n+    let output = unsafe {\n+        Command::new(&me)\n+            .arg(\"empty\")\n+            .pre_exec(move || {\n+                assert_eq!(mem2.fetch_add(1, Ordering::SeqCst), 0);\n+                Ok(())\n+            })\n+            .output()\n+            .unwrap()\n+    };\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert!(output.stdout.is_empty());\n+    assert_eq!(mem.load(Ordering::SeqCst), 0);\n+}"}, {"sha": "94ca66aef729bf26a1e36bf8707ec60ced7db4b9", "filename": "src/test/ui/parser/trait-object-lifetime-parens.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-object-lifetime-parens.stderr?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -1,14 +1,14 @@\n error: parenthesized lifetime bounds are not supported\n-  --> $DIR/trait-object-lifetime-parens.rs:5:24\n+  --> $DIR/trait-object-lifetime-parens.rs:5:21\n    |\n LL | fn f<'a, T: Trait + ('a)>() {} //~ ERROR parenthesized lifetime bounds are not supported\n-   |                        ^\n+   |                     ^^^^ help: remove the parentheses\n \n error: parenthesized lifetime bounds are not supported\n-  --> $DIR/trait-object-lifetime-parens.rs:8:27\n+  --> $DIR/trait-object-lifetime-parens.rs:8:24\n    |\n LL |     let _: Box<Trait + ('a)>; //~ ERROR parenthesized lifetime bounds are not supported\n-   |                           ^\n+   |                        ^^^^ help: remove the parentheses\n \n error: expected type, found `'a`\n   --> $DIR/trait-object-lifetime-parens.rs:9:17"}, {"sha": "7394fec6f36607f977825697fcb1d766056ac637", "filename": "src/test/ui/try-block/try-block-in-edition2015.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-edition2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-edition2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-edition2015.stderr?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -16,6 +16,8 @@ error[E0574]: expected struct, variant or union type, found macro `try`\n    |\n LL |     let try_result: Option<_> = try {\n    |                                 ^^^ help: use `!` to invoke the macro: `try!`\n+   |\n+   = note: if you want the `try` keyword, you need to be in the 2018 edition\n \n error: aborting due to 2 previous errors\n "}, {"sha": "fb6132a5358ef38d104036c71beab7c9b240bae5", "filename": "src/tools/publish_toolstate.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Ftools%2Fpublish_toolstate.py", "raw_url": "https://github.com/rust-lang/rust/raw/082c86175fcf72c355e6a889956fbea59e65bcdb/src%2Ftools%2Fpublish_toolstate.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fpublish_toolstate.py?ref=082c86175fcf72c355e6a889956fbea59e65bcdb", "patch": "@@ -25,7 +25,7 @@\n }\n \n REPOS = {\n-    'miri': 'https://github.com/solson/miri',\n+    'miri': 'https://github.com/rust-lang/miri',\n     'clippy-driver': 'https://github.com/rust-lang/rust-clippy',\n     'rls': 'https://github.com/rust-lang/rls',\n     'rustfmt': 'https://github.com/rust-lang/rustfmt',"}]}