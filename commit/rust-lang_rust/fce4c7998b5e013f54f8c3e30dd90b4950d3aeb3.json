{"sha": "fce4c7998b5e013f54f8c3e30dd90b4950d3aeb3", "node_id": "C_kwDOAAsO6NoAKGZjZTRjNzk5OGI1ZTAxM2Y1NGY4YzNlMzBkZDkwYjQ5NTBkM2FlYjM", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-05-17T23:00:53Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-05-19T23:23:28Z"}, "message": "Remove old match guard pattern tracking code\n\nThis is subsumed by the new changes that count pattern variables as\nbound for the whole guard expression.", "tree": {"sha": "4c5471a7252a50d01af1221cd30ce247e105403f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c5471a7252a50d01af1221cd30ce247e105403f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fce4c7998b5e013f54f8c3e30dd90b4950d3aeb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fce4c7998b5e013f54f8c3e30dd90b4950d3aeb3", "html_url": "https://github.com/rust-lang/rust/commit/fce4c7998b5e013f54f8c3e30dd90b4950d3aeb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fce4c7998b5e013f54f8c3e30dd90b4950d3aeb3/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d08efdec1c0e3c8135a547b2853af49a7f107f7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d08efdec1c0e3c8135a547b2853af49a7f107f7e", "html_url": "https://github.com/rust-lang/rust/commit/d08efdec1c0e3c8135a547b2853af49a7f107f7e"}], "stats": {"total": 135, "additions": 38, "deletions": 97}, "files": [{"sha": "60d19405bcfaf541919eb51b6a46bd46e071fda5", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 38, "deletions": 97, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/fce4c7998b5e013f54f8c3e30dd90b4950d3aeb3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fce4c7998b5e013f54f8c3e30dd90b4950d3aeb3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=fce4c7998b5e013f54f8c3e30dd90b4950d3aeb3", "patch": "@@ -17,7 +17,6 @@ use rustc_middle::middle::region::{self, Scope, ScopeData, YieldData};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use smallvec::SmallVec;\n use tracing::debug;\n \n mod drop_ranges;\n@@ -29,13 +28,6 @@ struct InteriorVisitor<'a, 'tcx> {\n     expr_count: usize,\n     kind: hir::GeneratorKind,\n     prev_unresolved_span: Option<Span>,\n-    /// Match arm guards have temporary borrows from the pattern bindings.\n-    /// In case there is a yield point in a guard with a reference to such bindings,\n-    /// such borrows can span across this yield point.\n-    /// As such, we need to track these borrows and record them despite of the fact\n-    /// that they may succeed the said yield point in the post-order.\n-    guard_bindings: SmallVec<[SmallVec<[HirId; 4]>; 1]>,\n-    guard_bindings_set: HirIdSet,\n     linted_values: HirIdSet,\n     drop_ranges: DropRanges,\n }\n@@ -48,7 +40,6 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n         scope: Option<region::Scope>,\n         expr: Option<&'tcx Expr<'tcx>>,\n         source_span: Span,\n-        guard_borrowing_from_pattern: bool,\n     ) {\n         use rustc_span::DUMMY_SP;\n \n@@ -89,8 +80,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                             // If it is a borrowing happening in the guard,\n                             // it needs to be recorded regardless because they\n                             // do live across this yield point.\n-                            guard_borrowing_from_pattern\n-                                || yield_data.expr_and_pat_count >= self.expr_count\n+                            yield_data.expr_and_pat_count >= self.expr_count\n                         })\n                         .cloned()\n                 })\n@@ -196,8 +186,6 @@ pub fn resolve_interior<'a, 'tcx>(\n         expr_count: 0,\n         kind,\n         prev_unresolved_span: None,\n-        guard_bindings: <_>::default(),\n-        guard_bindings_set: <_>::default(),\n         linted_values: <_>::default(),\n         drop_ranges: drop_ranges::compute_drop_ranges(fcx, def_id, body),\n     };\n@@ -284,8 +272,41 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         let Arm { guard, pat, body, .. } = arm;\n         self.visit_pat(pat);\n         if let Some(ref g) = guard {\n-            self.guard_bindings.push(<_>::default());\n             {\n+                // If there is a guard, we need to count all variables bound in the pattern as\n+                // borrowed for the entire guard body, regardless of whether they are accessed.\n+                // We do this by walking the pattern bindings and recording `&T` for any `x: T`\n+                // that is bound.\n+\n+                struct ArmPatCollector<'a, 'b, 'tcx> {\n+                    interior_visitor: &'a mut InteriorVisitor<'b, 'tcx>,\n+                    scope: Scope,\n+                }\n+\n+                impl<'a, 'b, 'tcx> Visitor<'tcx> for ArmPatCollector<'a, 'b, 'tcx> {\n+                    fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n+                        intravisit::walk_pat(self, pat);\n+                        if let PatKind::Binding(_, id, ident, ..) = pat.kind {\n+                            let ty =\n+                                self.interior_visitor.fcx.typeck_results.borrow().node_type(id);\n+                            let tcx = self.interior_visitor.fcx.tcx;\n+                            let ty = tcx.mk_ref(\n+                                // Use `ReErased` as `resolve_interior` is going to replace all the\n+                                // regions anyway.\n+                                tcx.mk_region(ty::ReErased),\n+                                ty::TypeAndMut { ty, mutbl: hir::Mutability::Not },\n+                            );\n+                            self.interior_visitor.record(\n+                                ty,\n+                                id,\n+                                Some(self.scope),\n+                                None,\n+                                ident.span,\n+                            );\n+                        }\n+                    }\n+                }\n+\n                 ArmPatCollector {\n                     interior_visitor: self,\n                     scope: Scope { id: g.body().hir_id.local_id, data: ScopeData::Node },\n@@ -301,12 +322,6 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                     self.visit_let_expr(l);\n                 }\n             }\n-\n-            let mut scope_var_ids =\n-                self.guard_bindings.pop().expect(\"should have pushed at least one earlier\");\n-            for var_id in scope_var_ids.drain(..) {\n-                self.guard_bindings_set.remove(&var_id);\n-            }\n         }\n         self.visit_expr(body);\n     }\n@@ -319,13 +334,11 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         if let PatKind::Binding(..) = pat.kind {\n             let scope = self.region_scope_tree.var_scope(pat.hir_id.local_id).unwrap();\n             let ty = self.fcx.typeck_results.borrow().pat_ty(pat);\n-            self.record(ty, pat.hir_id, Some(scope), None, pat.span, false);\n+            self.record(ty, pat.hir_id, Some(scope), None, pat.span);\n         }\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        let mut guard_borrowing_from_pattern = false;\n-\n         match &expr.kind {\n             ExprKind::Call(callee, args) => match &callee.kind {\n                 ExprKind::Path(qpath) => {\n@@ -352,16 +365,6 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                 }\n                 _ => intravisit::walk_expr(self, expr),\n             },\n-            ExprKind::Path(qpath) => {\n-                intravisit::walk_expr(self, expr);\n-                let res = self.fcx.typeck_results.borrow().qpath_res(qpath, expr.hir_id);\n-                match res {\n-                    Res::Local(id) if self.guard_bindings_set.contains(&id) => {\n-                        guard_borrowing_from_pattern = true;\n-                    }\n-                    _ => {}\n-                }\n-            }\n             _ => intravisit::walk_expr(self, expr),\n         }\n \n@@ -390,14 +393,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         // If there are adjustments, then record the final type --\n         // this is the actual value that is being produced.\n         if let Some(adjusted_ty) = self.fcx.typeck_results.borrow().expr_ty_adjusted_opt(expr) {\n-            self.record(\n-                adjusted_ty,\n-                expr.hir_id,\n-                scope,\n-                Some(expr),\n-                expr.span,\n-                guard_borrowing_from_pattern,\n-            );\n+            self.record(adjusted_ty, expr.hir_id, scope, Some(expr), expr.span);\n         }\n \n         // Also record the unadjusted type (which is the only type if\n@@ -425,68 +421,13 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         // The type table might not have information for this expression\n         // if it is in a malformed scope. (#66387)\n         if let Some(ty) = self.fcx.typeck_results.borrow().expr_ty_opt(expr) {\n-            if guard_borrowing_from_pattern {\n-                // Match guards create references to all the bindings in the pattern that are used\n-                // in the guard, e.g. `y if is_even(y) => ...` becomes `is_even(*r_y)` where `r_y`\n-                // is a reference to `y`, so we must record a reference to the type of the binding.\n-                let tcx = self.fcx.tcx;\n-                let ref_ty = tcx.mk_ref(\n-                    // Use `ReErased` as `resolve_interior` is going to replace all the regions anyway.\n-                    tcx.mk_region(ty::ReErased),\n-                    ty::TypeAndMut { ty, mutbl: hir::Mutability::Not },\n-                );\n-                self.record(\n-                    ref_ty,\n-                    expr.hir_id,\n-                    scope,\n-                    Some(expr),\n-                    expr.span,\n-                    guard_borrowing_from_pattern,\n-                );\n-            }\n-            self.record(\n-                ty,\n-                expr.hir_id,\n-                scope,\n-                Some(expr),\n-                expr.span,\n-                guard_borrowing_from_pattern,\n-            );\n+            self.record(ty, expr.hir_id, scope, Some(expr), expr.span);\n         } else {\n             self.fcx.tcx.sess.delay_span_bug(expr.span, \"no type for node\");\n         }\n     }\n }\n \n-struct ArmPatCollector<'a, 'b, 'tcx> {\n-    interior_visitor: &'a mut InteriorVisitor<'b, 'tcx>,\n-    scope: Scope,\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for ArmPatCollector<'a, 'b, 'tcx> {\n-    fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n-        intravisit::walk_pat(self, pat);\n-        if let PatKind::Binding(_, id, ..) = pat.kind {\n-            self.interior_visitor\n-                .guard_bindings\n-                .last_mut()\n-                .expect(\"should have pushed at least one earlier\")\n-                .push(id);\n-            self.interior_visitor.guard_bindings_set.insert(id);\n-\n-            let ty = self.interior_visitor.fcx.typeck_results.borrow().node_type(id);\n-            let ty = self.interior_visitor.fcx.tcx.mk_ref(\n-                // Use `ReErased` as `resolve_interior` is going to replace all the regions anyway.\n-                self.interior_visitor.fcx.tcx.mk_region(ty::ReErased),\n-                ty::TypeAndMut { ty, mutbl: hir::Mutability::Not },\n-            );\n-            // FIXME: use the right span\n-            let span = rustc_span::DUMMY_SP;\n-            self.interior_visitor.record(ty, id, Some(self.scope), None, span, true);\n-        }\n-    }\n-}\n-\n #[derive(Default)]\n pub struct SuspendCheckData<'a, 'tcx> {\n     expr: Option<&'tcx Expr<'tcx>>,"}]}