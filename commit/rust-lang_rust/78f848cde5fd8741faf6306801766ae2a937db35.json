{"sha": "78f848cde5fd8741faf6306801766ae2a937db35", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4Zjg0OGNkZTVmZDg3NDFmYWY2MzA2ODAxNzY2YWUyYTkzN2RiMzU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-01T21:04:51Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-01T23:48:26Z"}, "message": "Refactor the Typer interface to separate out UnboxedClosureTyper methods, which are\nthe only things that trait selection needs.", "tree": {"sha": "074a8e78a7f93826c3d4cf85fd3151c5915080bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/074a8e78a7f93826c3d4cf85fd3151c5915080bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78f848cde5fd8741faf6306801766ae2a937db35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78f848cde5fd8741faf6306801766ae2a937db35", "html_url": "https://github.com/rust-lang/rust/commit/78f848cde5fd8741faf6306801766ae2a937db35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78f848cde5fd8741faf6306801766ae2a937db35/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7092af7ee317a42c8ad7d9f8d02bb9ff64891949", "url": "https://api.github.com/repos/rust-lang/rust/commits/7092af7ee317a42c8ad7d9f8d02bb9ff64891949", "html_url": "https://github.com/rust-lang/rust/commit/7092af7ee317a42c8ad7d9f8d02bb9ff64891949"}], "stats": {"total": 314, "additions": 195, "deletions": 119}, "files": [{"sha": "93ff5404fa64957cc0bf01a378781c57b580835e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=78f848cde5fd8741faf6306801766ae2a937db35", "patch": "@@ -1229,7 +1229,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             // inferred by regionbk\n             let upvar_id = ty::UpvarId { var_id: id_var,\n                                          closure_expr_id: closure_expr.id };\n-            let upvar_borrow = self.typer.upvar_borrow(upvar_id);\n+            let upvar_borrow = self.typer.upvar_borrow(upvar_id).unwrap();\n \n             self.delegate.borrow(closure_expr.id,\n                                  closure_expr.span,"}, {"sha": "0c3438abb2b479873048863ad2a15a506da6f311", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=78f848cde5fd8741faf6306801766ae2a937db35", "patch": "@@ -111,7 +111,9 @@ use self::VarKind::*;\n \n use middle::def::*;\n use middle::mem_categorization::Typer;\n-use middle::{pat_util, ty};\n+use middle::pat_util;\n+use middle::ty;\n+use middle::ty::UnboxedClosureTyper;\n use lint;\n use util::nodemap::NodeMap;\n \n@@ -1515,16 +1517,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::FnOutput<'tcx> {\n         let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n         match fn_ty.sty {\n-            ty::ty_unboxed_closure(closure_def_id, _, _) =>\n-                self.ir.tcx.unboxed_closures()\n-                    .borrow()\n-                    .get(&closure_def_id)\n-                    .unwrap()\n-                    .closure_type\n-                    .sig\n-                    .0\n-                    .output,\n-            _ => ty::ty_fn_ret(fn_ty)\n+            ty::ty_unboxed_closure(closure_def_id, _, substs) =>\n+                self.ir.tcx.unboxed_closure_type(closure_def_id, substs).sig.0.output,\n+            _ =>\n+                ty::ty_fn_ret(fn_ty),\n         }\n     }\n "}, {"sha": "70942a950e324b3a7621b850c840d15f5245e559", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=78f848cde5fd8741faf6306801766ae2a937db35", "patch": "@@ -74,7 +74,7 @@ pub use self::categorization::*;\n use middle::def;\n use middle::region;\n use middle::ty::{mod, Ty};\n-use util::nodemap::{DefIdMap, NodeMap};\n+use util::nodemap::{NodeMap};\n use util::ppaux::{ty_to_string, Repr};\n \n use syntax::ast::{MutImmutable, MutMutable};\n@@ -280,7 +280,7 @@ impl<'t,TYPER:'t> Copy for MemCategorizationContext<'t,TYPER> {}\n /// In the borrow checker, in contrast, type checking is complete and we\n /// know that no errors have occurred, so we simply consult the tcx and we\n /// can be sure that only `Ok` results will occur.\n-pub trait Typer<'tcx> {\n+pub trait Typer<'tcx> : ty::UnboxedClosureTyper<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n     fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx>;\n     fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx>;\n@@ -290,11 +290,9 @@ pub trait Typer<'tcx> {\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>;\n     fn is_method_call(&self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent>;\n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n+    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow>;\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause;\n-    fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>>;\n }\n \n impl MutabilityCategory {\n@@ -622,8 +620,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                       self.cat_upvar(id, span, var_id, fn_node_id, kind, mode, false)\n                   }\n                   ty::ty_unboxed_closure(closure_id, _, _) => {\n-                      let unboxed_closures = self.typer.unboxed_closures().borrow();\n-                      let kind = (*unboxed_closures)[closure_id].kind;\n+                      let kind = self.typer.unboxed_closure_kind(closure_id);\n                       let mode = self.typer.capture_mode(fn_node_id);\n                       self.cat_upvar(id, span, var_id, fn_node_id, kind, mode, true)\n                   }\n@@ -800,7 +797,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 }\n \n                 // Look up upvar borrow so we can get its region\n-                let upvar_borrow = self.typer.upvar_borrow(upvar_id);\n+                let upvar_borrow = self.typer.upvar_borrow(upvar_id).unwrap();\n                 let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n \n                 Rc::new(cmt_ {"}, {"sha": "2dbb15b215ed0a7ed124bb8f4f8055fcabb63ab8", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=78f848cde5fd8741faf6306801766ae2a937db35", "patch": "@@ -110,7 +110,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     pub fn normalize_projection_type<'a>(&mut self,\n                                          infcx: &InferCtxt<'a,'tcx>,\n                                          param_env: &ty::ParameterEnvironment<'tcx>,\n-                                         typer: &Typer<'tcx>,\n+                                         typer: &ty::UnboxedClosureTyper<'tcx>,\n                                          projection_ty: ty::ProjectionTy<'tcx>,\n                                          cause: ObligationCause<'tcx>)\n                                          -> Ty<'tcx>\n@@ -187,7 +187,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     pub fn select_all_or_error<'a>(&mut self,\n                                    infcx: &InferCtxt<'a,'tcx>,\n                                    param_env: &ty::ParameterEnvironment<'tcx>,\n-                                   typer: &Typer<'tcx>)\n+                                   typer: &ty::UnboxedClosureTyper<'tcx>)\n                                    -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         try!(self.select_where_possible(infcx, param_env, typer));\n@@ -213,7 +213,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     pub fn select_new_obligations<'a>(&mut self,\n                                       infcx: &InferCtxt<'a,'tcx>,\n                                       param_env: &ty::ParameterEnvironment<'tcx>,\n-                                      typer: &Typer<'tcx>)\n+                                      typer: &ty::UnboxedClosureTyper<'tcx>)\n                                       -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx, param_env, typer);\n@@ -223,7 +223,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     pub fn select_where_possible<'a>(&mut self,\n                                      infcx: &InferCtxt<'a,'tcx>,\n                                      param_env: &ty::ParameterEnvironment<'tcx>,\n-                                     typer: &Typer<'tcx>)\n+                                     typer: &ty::UnboxedClosureTyper<'tcx>)\n                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx, param_env, typer);"}, {"sha": "c5ad8c3b230fc383ae66726b2f26ebea6ef1ad86", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 18, "deletions": 47, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=78f848cde5fd8741faf6306801766ae2a937db35", "patch": "@@ -45,7 +45,7 @@ use util::ppaux::Repr;\n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     param_env: &'cx ty::ParameterEnvironment<'tcx>,\n-    typer: &'cx (Typer<'tcx>+'cx),\n+    closure_typer: &'cx (ty::UnboxedClosureTyper<'tcx>+'cx),\n \n     /// Freshener used specifically for skolemizing entries on the\n     /// obligation stack. This ensures that all entries on the stack\n@@ -178,25 +178,25 @@ enum EvaluationResult<'tcx> {\n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>,\n                param_env: &'cx ty::ParameterEnvironment<'tcx>,\n-               typer: &'cx Typer<'tcx>)\n+               closure_typer: &'cx ty::UnboxedClosureTyper<'tcx>)\n                -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n             param_env: param_env,\n-            typer: typer,\n+            closure_typer: closure_typer,\n             freshener: infcx.freshener(),\n             intercrate: false,\n         }\n     }\n \n     pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>,\n                       param_env: &'cx ty::ParameterEnvironment<'tcx>,\n-                      typer: &'cx Typer<'tcx>)\n+                      closure_typer: &'cx ty::UnboxedClosureTyper<'tcx>)\n                       -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n             param_env: param_env,\n-            typer: typer,\n+            closure_typer: closure_typer,\n             freshener: infcx.freshener(),\n             intercrate: true,\n         }\n@@ -919,15 +919,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                kind,\n                obligation.repr(self.tcx()));\n \n-        let closure_kind = match self.typer.unboxed_closures().borrow().get(&closure_def_id) {\n-            Some(closure) => closure.kind,\n-            None => {\n-                self.tcx().sess.span_bug(\n-                    obligation.cause.span,\n-                    format!(\"No entry for unboxed closure: {}\",\n-                            closure_def_id.repr(self.tcx()))[]);\n-            }\n-        };\n+        let closure_kind = self.closure_typer.unboxed_closure_kind(closure_def_id);\n \n         debug!(\"closure_kind = {}\", closure_kind);\n \n@@ -1399,32 +1391,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     return Ok(ParameterBuiltin);\n                 }\n \n-                match self.tcx().freevars.borrow().get(&def_id.node) {\n-                    None => {\n-                        // No upvars.\n-                        Ok(If(Vec::new()))\n+                match self.closure_typer.unboxed_closure_upvars(def_id, substs) {\n+                    Some(upvars) => {\n+                        Ok(If(upvars.iter().map(|c| c.ty).collect()))\n                     }\n-\n-                    Some(freevars) => {\n-                        let tys: Vec<Ty> =\n-                            freevars\n-                            .iter()\n-                            .map(|freevar| {\n-                                let freevar_def_id = freevar.def.def_id();\n-                                self.typer.node_ty(freevar_def_id.node).subst(self.tcx(), substs)\n-                            })\n-                            .collect();\n-                        Ok(If(tys))\n+                    None => {\n+                        Ok(AmbiguousBuiltin)\n                     }\n                 }\n             }\n \n             ty::ty_struct(def_id, substs) => {\n                 let types: Vec<Ty> =\n-                    ty::struct_fields(self.tcx(), def_id, substs)\n-                    .iter()\n-                    .map(|f| f.mt.ty)\n-                    .collect();\n+                    ty::struct_fields(self.tcx(), def_id, substs).iter()\n+                                                                 .map(|f| f.mt.ty)\n+                                                                 .collect();\n                 nominal(self, bound, def_id, types)\n             }\n \n@@ -1799,27 +1780,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                closure_def_id.repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n-        let closure_type = match self.typer.unboxed_closures().borrow().get(&closure_def_id) {\n-            Some(closure) => closure.closure_type.clone(),\n-            None => {\n-                self.tcx().sess.span_bug(\n-                    obligation.cause.span,\n-                    format!(\"No entry for unboxed closure: {}\",\n-                            closure_def_id.repr(self.tcx()))[]);\n-            }\n-        };\n-\n+        let closure_type = self.closure_typer.unboxed_closure_type(closure_def_id, substs);\n         let closure_sig = &closure_type.sig;\n         let arguments_tuple = closure_sig.0.inputs[0];\n-        let substs =\n+        let trait_substs =\n             Substs::new_trait(\n-                vec![arguments_tuple.subst(self.tcx(), substs),\n-                     closure_sig.0.output.unwrap().subst(self.tcx(), substs)],\n+                vec![arguments_tuple, closure_sig.0.output.unwrap()],\n                 vec![],\n                 obligation.self_ty());\n         let trait_ref = ty::Binder(Rc::new(ty::TraitRef {\n             def_id: obligation.predicate.def_id(),\n-            substs: self.tcx().mk_substs(substs),\n+            substs: self.tcx().mk_substs(trait_substs),\n         }));\n \n         debug!(\"confirm_unboxed_closure_candidate(closure_def_id={}, trait_ref={})\","}, {"sha": "cea98ff20cd91bdb6a11265d94e5eccd7dec62f3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 98, "deletions": 31, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=78f848cde5fd8741faf6306801766ae2a937db35", "patch": "@@ -2259,6 +2259,23 @@ impl UnboxedClosureKind {\n     }\n }\n \n+pub trait UnboxedClosureTyper<'tcx> {\n+    fn unboxed_closure_kind(&self,\n+                            def_id: ast::DefId)\n+                            -> ty::UnboxedClosureKind;\n+\n+    fn unboxed_closure_type(&self,\n+                            def_id: ast::DefId,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> ty::ClosureTy<'tcx>;\n+\n+    // Returns `None` if the upvar types cannot yet be definitively determined.\n+    fn unboxed_closure_upvars(&self,\n+                              def_id: ast::DefId,\n+                              substs: &Substs<'tcx>)\n+                              -> Option<Vec<UnboxedClosureUpvar<'tcx>>>;\n+}\n+\n impl<'tcx> CommonTypes<'tcx> {\n     fn new(arena: &'tcx TypedArena<TyS<'tcx>>,\n            interner: &mut FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>)\n@@ -3345,7 +3362,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             ty_unboxed_closure(did, r, substs) => {\n                 // FIXME(#14449): `borrowed_contents` below assumes `&mut`\n                 // unboxed closure.\n-                let upvars = unboxed_closure_upvars(cx, did, substs);\n+                let upvars = unboxed_closure_upvars(cx, did, substs).unwrap();\n                 TypeContents::union(upvars.as_slice(),\n                                     |f| tc_ty(cx, f.ty, cache))\n                     | borrowed_contents(*r, MutMutable)\n@@ -3625,7 +3642,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             }\n \n             ty_unboxed_closure(did, _, substs) => {\n-                let upvars = unboxed_closure_upvars(cx, did, substs);\n+                let upvars = unboxed_closure_upvars(cx, did, substs).unwrap();\n                 upvars.iter().any(|f| type_requires(cx, seen, r_ty, f.ty))\n             }\n \n@@ -3717,7 +3734,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n                 find_nonrepresentable(cx, sp, seen, iter)\n             }\n             ty_unboxed_closure(did, _, substs) => {\n-                let upvars = unboxed_closure_upvars(cx, did, substs);\n+                let upvars = unboxed_closure_upvars(cx, did, substs).unwrap();\n                 find_nonrepresentable(cx, sp, seen, upvars.iter().map(|f| f.ty))\n             }\n             _ => Representable,\n@@ -5656,38 +5673,67 @@ pub struct UnboxedClosureUpvar<'tcx> {\n }\n \n // Returns a list of `UnboxedClosureUpvar`s for each upvar.\n-pub fn unboxed_closure_upvars<'tcx>(tcx: &ctxt<'tcx>, closure_id: ast::DefId, substs: &Substs<'tcx>)\n-                                    -> Vec<UnboxedClosureUpvar<'tcx>> {\n+pub fn unboxed_closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n+                                    closure_id: ast::DefId,\n+                                    substs: &Substs<'tcx>)\n+                                    -> Option<Vec<UnboxedClosureUpvar<'tcx>>>\n+{\n     // Presently an unboxed closure type cannot \"escape\" out of a\n     // function, so we will only encounter ones that originated in the\n     // local crate or were inlined into it along with some function.\n     // This may change if abstract return types of some sort are\n     // implemented.\n     assert!(closure_id.krate == ast::LOCAL_CRATE);\n+    let tcx = typer.tcx();\n     let capture_mode = tcx.capture_modes.borrow()[closure_id.node].clone();\n     match tcx.freevars.borrow().get(&closure_id.node) {\n-        None => vec![],\n+        None => Some(vec![]),\n         Some(ref freevars) => {\n-            freevars.iter().map(|freevar| {\n-                let freevar_def_id = freevar.def.def_id();\n-                let freevar_ty = node_id_to_type(tcx, freevar_def_id.node);\n-                let mut freevar_ty = freevar_ty.subst(tcx, substs);\n-                if capture_mode == ast::CaptureByRef {\n-                    let borrow = tcx.upvar_borrow_map.borrow()[ty::UpvarId {\n-                        var_id: freevar_def_id.node,\n-                        closure_expr_id: closure_id.node\n-                    }].clone();\n-                    freevar_ty = mk_rptr(tcx, tcx.mk_region(borrow.region), ty::mt {\n-                        ty: freevar_ty,\n-                        mutbl: borrow.kind.to_mutbl_lossy()\n-                    });\n-                }\n-                UnboxedClosureUpvar {\n-                    def: freevar.def,\n-                    span: freevar.span,\n-                    ty: freevar_ty\n-                }\n-            }).collect()\n+            freevars.iter()\n+                    .map(|freevar| {\n+                        let freevar_def_id = freevar.def.def_id();\n+                        let freevar_ty = typer.node_ty(freevar_def_id.node);\n+                        let freevar_ty = freevar_ty.subst(tcx, substs);\n+\n+                        match capture_mode {\n+                            ast::CaptureByValue => {\n+                                Some(UnboxedClosureUpvar { def: freevar.def,\n+                                                           span: freevar.span,\n+                                                           ty: freevar_ty })\n+                            }\n+\n+                            ast::CaptureByRef => {\n+                                let upvar_id = ty::UpvarId {\n+                                    var_id: freevar_def_id.node,\n+                                    closure_expr_id: closure_id.node\n+                                };\n+\n+                                // FIXME\n+                                let freevar_ref_ty = match typer.upvar_borrow(upvar_id) {\n+                                    Some(borrow) => {\n+                                        mk_rptr(tcx,\n+                                                tcx.mk_region(borrow.region),\n+                                                ty::mt {\n+                                                    ty: freevar_ty,\n+                                                    mutbl: borrow.kind.to_mutbl_lossy(),\n+                                                })\n+                                    }\n+                                    None => {\n+                                        // TODO we should really return None here;\n+                                        // but that requires better inference integration,\n+                                        // for now gin up something.\n+                                        freevar_ty\n+                                    }\n+                                };\n+                                Some(UnboxedClosureUpvar {\n+                                    def: freevar.def,\n+                                    span: freevar.span,\n+                                    ty: freevar_ref_ty,\n+                                })\n+                            }\n+                        }\n+                    })\n+                    .collect()\n         }\n     }\n }\n@@ -6501,21 +6547,42 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n         self.region_maps.temporary_scope(rvalue_id)\n     }\n \n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.upvar_borrow_map.borrow()[upvar_id].clone()\n+    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n+        Some(self.upvar_borrow_map.borrow()[upvar_id].clone())\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n         self.capture_modes.borrow()[closure_expr_id].clone()\n     }\n+}\n \n-    fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<UnboxedClosure<'tcx>>> {\n-        &self.unboxed_closures\n+impl<'tcx> UnboxedClosureTyper<'tcx> for ty::ctxt<'tcx> {\n+    fn unboxed_closure_kind(&self,\n+                            def_id: ast::DefId)\n+                            -> ty::UnboxedClosureKind\n+    {\n+        self.unboxed_closures.borrow()[def_id].kind\n+    }\n+\n+    fn unboxed_closure_type(&self,\n+                            def_id: ast::DefId,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> ty::ClosureTy<'tcx>\n+    {\n+        self.unboxed_closures.borrow()[def_id].closure_type.subst(self, substs)\n+    }\n+\n+    fn unboxed_closure_upvars(&self,\n+                              def_id: ast::DefId,\n+                              substs: &Substs<'tcx>)\n+                              -> Option<Vec<UnboxedClosureUpvar<'tcx>>>\n+    {\n+        unboxed_closure_upvars(self, def_id, substs)\n     }\n }\n \n+\n /// The category of explicit self.\n #[deriving(Clone, Copy, Eq, PartialEq, Show)]\n pub enum ExplicitSelfCategory {"}, {"sha": "24a3bb42c90f76836d714badc38c6065ca248766", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=78f848cde5fd8741faf6306801766ae2a937db35", "patch": "@@ -168,7 +168,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             Univariant(mk_struct(cx, ftys[], packed, t), dtor)\n         }\n         ty::ty_unboxed_closure(def_id, _, substs) => {\n-            let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs);\n+            let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n             Univariant(mk_struct(cx, upvar_types[], false, t), false)\n         }"}, {"sha": "b4dac456536e99f44a05a67c08b45d80197a4881", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=78f848cde5fd8741faf6306801766ae2a937db35", "patch": "@@ -729,7 +729,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n       }\n       ty::ty_unboxed_closure(def_id, _, substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs);\n+          let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs).unwrap();\n           for (i, upvar) in upvars.iter().enumerate() {\n               let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n               cx = f(cx, llupvar, upvar.ty);"}, {"sha": "8d1322da63522aa0c181d2aa779f0fa7ae3ab358", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=78f848cde5fd8741faf6306801766ae2a937db35", "patch": "@@ -39,7 +39,7 @@ use middle::ty::{mod, HasProjectionTypes, Ty};\n use middle::ty_fold;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use util::ppaux::Repr;\n-use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n+use util::nodemap::{FnvHashMap, NodeMap};\n \n use arena::TypedArena;\n use libc::{c_uint, c_char};\n@@ -617,13 +617,8 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         self.tcx().region_maps.temporary_scope(rvalue_id)\n     }\n \n-    fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n-        &self.tcx().unboxed_closures\n-    }\n-\n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.tcx().upvar_borrow_map.borrow()[upvar_id].clone()\n+    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n+        Some(self.tcx().upvar_borrow_map.borrow()[upvar_id].clone())\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n@@ -632,6 +627,35 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n }\n \n+impl<'blk, 'tcx> ty::UnboxedClosureTyper<'tcx> for BlockS<'blk, 'tcx> {\n+    fn unboxed_closure_kind(&self,\n+                            def_id: ast::DefId)\n+                            -> ty::UnboxedClosureKind\n+    {\n+        self.tcx().unboxed_closure_kind(def_id)\n+    }\n+\n+    fn unboxed_closure_type(&self,\n+                            def_id: ast::DefId,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> ty::ClosureTy<'tcx>\n+    {\n+        // the substitutions in `substs` are already monomorphized, so we can\n+        // ignore `param_substs`\n+        self.tcx().unboxed_closure_type(def_id, substs)\n+    }\n+\n+    fn unboxed_closure_upvars(&self,\n+                              def_id: ast::DefId,\n+                              substs: &Substs<'tcx>)\n+                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+    {\n+        // the substitutions in `substs` are already monomorphized, so we can\n+        // ignore `param_substs`\n+        ty::unboxed_closure_upvars(self.tcx(), def_id, substs)\n+    }\n+}\n+\n pub struct Result<'blk, 'tcx: 'blk> {\n     pub bcx: Block<'blk, 'tcx>,\n     pub val: ValueRef"}, {"sha": "5e9843d0e00bfe7b86268a7880878adadb79e589", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=78f848cde5fd8741faf6306801766ae2a937db35", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use middle::infer::InferCtxt;\n-use middle::mem_categorization as mc;\n use middle::traits::{mod, FulfillmentContext, Normalized, MiscObligation,\n                      SelectionContext, ObligationCause};\n use middle::ty::{mod, HasProjectionTypes};\n@@ -20,7 +19,7 @@ use util::ppaux::Repr;\n \n pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                 param_env: &ty::ParameterEnvironment<'tcx>,\n-                                                typer: &(mc::Typer<'tcx>+'a),\n+                                                typer: &(ty::UnboxedClosureTyper<'tcx>+'a),\n                                                 fulfillment_cx: &mut FulfillmentContext<'tcx>,\n                                                 span: Span,\n                                                 body_id: ast::NodeId,"}, {"sha": "6868c876ff562a61269d97bd1d3bfaeb04c4b206", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f848cde5fd8741faf6306801766ae2a937db35/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=78f848cde5fd8741faf6306801766ae2a937db35", "patch": "@@ -319,15 +319,37 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<CodeExtent> {\n         self.tcx().temporary_scope(rvalue_id)\n     }\n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.inh.upvar_borrow_map.borrow()[upvar_id].clone()\n+    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n+        self.inh.upvar_borrow_map.borrow().get(&upvar_id).cloned()\n     }\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n         self.ccx.tcx.capture_mode(closure_expr_id)\n     }\n-    fn unboxed_closures(&self) -> &RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n-        &self.inh.unboxed_closures\n+}\n+\n+impl<'a, 'tcx> ty::UnboxedClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n+    fn unboxed_closure_kind(&self,\n+                            def_id: ast::DefId)\n+                            -> ty::UnboxedClosureKind\n+    {\n+        self.inh.unboxed_closures.borrow()[def_id].kind\n+    }\n+\n+    fn unboxed_closure_type(&self,\n+                            def_id: ast::DefId,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> ty::ClosureTy<'tcx>\n+    {\n+        self.inh.unboxed_closures.borrow()[def_id].closure_type.subst(self.tcx(), substs)\n+    }\n+\n+    fn unboxed_closure_upvars(&self,\n+                              def_id: ast::DefId,\n+                              substs: &Substs<'tcx>)\n+                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+    {\n+        ty::unboxed_closure_upvars(self, def_id, substs)\n     }\n }\n \n@@ -352,7 +374,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n     }\n \n     fn normalize_associated_types_in<T>(&self,\n-                                        typer: &mc::Typer<'tcx>,\n+                                        typer: &ty::UnboxedClosureTyper<'tcx>,\n                                         span: Span,\n                                         body_id: ast::NodeId,\n                                         value: &T)"}]}