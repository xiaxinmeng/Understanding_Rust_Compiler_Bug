{"sha": "29a8219c4cb110baa5ad7123af187d881a02fd69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YTgyMTljNGNiMTEwYmFhNWFkNzEyM2FmMTg3ZDg4MWEwMmZkNjk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-27T02:18:30Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-27T03:37:08Z"}, "message": "Add a very simple map implementation for sequential integer keys\n\nUse it for the ast_map. Cuts 40% off the time spent prior to LLVM.", "tree": {"sha": "a5758464a098a9d00e75d3277f1609931c48410e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5758464a098a9d00e75d3277f1609931c48410e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29a8219c4cb110baa5ad7123af187d881a02fd69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29a8219c4cb110baa5ad7123af187d881a02fd69", "html_url": "https://github.com/rust-lang/rust/commit/29a8219c4cb110baa5ad7123af187d881a02fd69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29a8219c4cb110baa5ad7123af187d881a02fd69/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08b49a5d8fe975bcd8a0526526eb9692f3f3be4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/08b49a5d8fe975bcd8a0526526eb9692f3f3be4c", "html_url": "https://github.com/rust-lang/rust/commit/08b49a5d8fe975bcd8a0526526eb9692f3f3be4c"}], "stats": {"total": 105, "additions": 104, "deletions": 1}, "files": [{"sha": "f6943b60529ed347a1c92a9b67dbde1f5e571bd0", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29a8219c4cb110baa5ad7123af187d881a02fd69/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a8219c4cb110baa5ad7123af187d881a02fd69/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=29a8219c4cb110baa5ad7123af187d881a02fd69", "patch": "@@ -11,7 +11,7 @@ tag ast_node {\n type map = std::map::hashmap[node_id, ast_node];\n \n fn map_crate(&crate c) -> map {\n-    auto map = util::common::new_int_hash[ast_node]();\n+    auto map = util::common::new_seq_int_hash[ast_node]();\n \n     auto v_map = @rec(visit_item=bind map_item(map, _, _, _),\n                       visit_native_item=bind map_native_item(map, _, _, _),"}, {"sha": "e4a9d205c87474086e169689e8986ca5c7ab012d", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/29a8219c4cb110baa5ad7123af187d881a02fd69/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a8219c4cb110baa5ad7123af187d881a02fd69/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=29a8219c4cb110baa5ad7123af187d881a02fd69", "patch": "@@ -4,6 +4,7 @@ import std::map::hashmap;\n import std::uint;\n import std::int;\n import std::vec;\n+import std::option;\n import std::option::none;\n import std::option::some;\n import front::ast;\n@@ -104,6 +105,108 @@ fn new_uint_hash[V]() -> std::map::hashmap[uint, V] {\n     ret std::map::mk_hashmap[uint, V](hasher, eqer);\n }\n \n+fn new_seq_hash[K, V](fn(&K) -> uint key_idx,\n+                      fn(&uint) -> K idx_key) -> std::map::hashmap[K, V] {\n+    fn ensure_size[V](&mutable vec[mutable option::t[V]] bkts, uint idx) {\n+        auto bkt_len = vec::len(bkts);\n+        if (idx >= bkt_len) {\n+            auto needed = idx - bkt_len + 1u;\n+            auto new = vec::init_elt_mut(option::none[V], needed);\n+            bkts += new;\n+        }\n+    }\n+\n+    obj seq_hash[K, V](mutable uint nelts,\n+                       mutable vec[mutable option::t[V]] bkts,\n+                       fn(&K) -> uint key_idx,\n+                       fn(&uint) -> K idx_key) {\n+\n+        fn size() -> uint { nelts }\n+\n+        fn insert(&K key, &V value) -> bool {\n+            auto idx = key_idx(key);\n+            ensure_size(bkts, idx);\n+            if (option::is_some(bkts.(idx))) {\n+                bkts.(idx) = option::some(value);\n+                ret false;\n+            } else {\n+                bkts.(idx) = option::some(value);\n+                nelts += 1u;\n+                ret true;\n+            }\n+        }\n+\n+        fn contains_key(&K key) -> bool {\n+            auto idx = key_idx(key);\n+            ensure_size(bkts, idx);\n+            if (option::is_some(bkts.(idx))) {\n+                ret true;\n+            } else {\n+                ret false;\n+            }\n+        }\n+\n+        fn get(&K key) -> V {\n+            ret alt (self.find(key)) {\n+                case (option::some(?v)) { v }\n+                case (_) { fail }\n+            };\n+        }\n+\n+        fn find(&K key) -> option::t[V] {\n+            auto idx = key_idx(key);\n+            ensure_size(bkts, idx);\n+            ret bkts.(idx);\n+        }\n+\n+        fn remove(&K key) -> option::t[V] {\n+            auto idx = key_idx(key);\n+            ensure_size(bkts, idx);\n+            auto val = bkts.(idx);\n+            if (option::is_some(val)) {\n+                bkts.(idx) = option::none;\n+                nelts -= 1u;\n+            }\n+            ret val;\n+        }\n+\n+        fn rehash() { }\n+\n+        iter items() -> @tup(K, V) {\n+            auto idx = 0u;\n+            auto bktsize = vec::len(bkts);\n+            while (idx < bktsize) {\n+                alt (bkts.(idx)) {\n+                    case (option::some(?v)) {\n+                        // FIXME: Appease alias analysis\n+                        auto value = v;\n+                        put @tup(idx_key(idx), value);\n+                    }\n+                    case (_) { }\n+                }\n+                idx += 1u;\n+            }\n+        }\n+    }\n+\n+    let vec[mutable option::t[V]] bkts = [mutable];\n+    ret seq_hash[K, V](0u, bkts, key_idx, idx_key);\n+}\n+\n+// A specialized map for keys that are sequential ints\n+fn new_seq_int_hash[V]() -> std::map::hashmap[int, V] {\n+    auto key_idx = fn(&int key) -> uint { key as uint };\n+    auto idx_key = fn(&uint idx) -> int { idx as int };\n+    ret new_seq_hash(key_idx, idx_key);\n+}\n+\n+// A specialized map for keys that are sequential uints\n+fn new_seq_uint_hash[V]() -> std::map::hashmap[uint, V] {\n+    auto key_idx = fn(&uint key) -> uint { key };\n+    auto idx_key = fn(&uint idx) -> uint { idx };\n+    ret new_seq_hash(key_idx, idx_key);\n+}\n+\n fn istr(int i) -> str { ret int::to_str(i, 10u); }\n \n fn uistr(uint i) -> str { ret uint::to_str(i, 10u); }"}]}