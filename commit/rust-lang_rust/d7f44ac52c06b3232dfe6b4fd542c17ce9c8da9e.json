{"sha": "d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZjQ0YWM1MmMwNmIzMjMyZGZlNmI0ZmQ1NDJjMTdjZTljOGRhOWU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-03-08T19:25:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-08T19:25:56Z"}, "message": "Rollup merge of #48682 - spastorino:make_causal_lazy, r=nikomatsakis\n\n[NLL] Make causal tracking lazy\n\nClose #46590\n\ncc @nikomatsakis", "tree": {"sha": "6914dd832f0fe15bfbd7876369255dd54da2c96a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6914dd832f0fe15bfbd7876369255dd54da2c96a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaoY5ECRBK7hj4Ov3rIwAAdHIIAINuyKBR1xON35F0tuFQMIa0\nuwELWZbt/IDDR5hoQcAX7p9Zq2rCdPfF7AZ/QLQVwTuBQbqaIVCuROK+5wsO6gL6\n8+nIhbNau3JD5VWBHn2AbENZ1hZSkLZR/2iPz/aNJcYFOsOUqn9wuvlmbPpcS4yY\n/uMTm9lVsBZuf3n3LI7o/LZPPJgt2s8CtJbfTZTJmCMbgRdGwrYwC3A1cA8jYXvJ\njooFNnLe2NU7GhFdU5ezB/uGlkvbX95sdz3v6C4j53QOoj5QdRgMz/QvVXYoTYdo\nGDOFAzAcs35X57BFAqACk7C2jzXNRVllBLirO1I78gKgCl1KT830r1xa3VF5gAA=\n=e/yE\n-----END PGP SIGNATURE-----\n", "payload": "tree 6914dd832f0fe15bfbd7876369255dd54da2c96a\nparent f12d5aa517a9157bf96e630a87db7be516c86d52\nparent 52a47d4c0299e8dc2293f8ba6ff81e16a462bdd4\nauthor Manish Goregaokar <manishsmail@gmail.com> 1520537156 -0800\ncommitter GitHub <noreply@github.com> 1520537156 -0800\n\nRollup merge of #48682 - spastorino:make_causal_lazy, r=nikomatsakis\n\n[NLL] Make causal tracking lazy\n\nClose #46590\n\ncc @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "html_url": "https://github.com/rust-lang/rust/commit/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f12d5aa517a9157bf96e630a87db7be516c86d52", "url": "https://api.github.com/repos/rust-lang/rust/commits/f12d5aa517a9157bf96e630a87db7be516c86d52", "html_url": "https://github.com/rust-lang/rust/commit/f12d5aa517a9157bf96e630a87db7be516c86d52"}, {"sha": "52a47d4c0299e8dc2293f8ba6ff81e16a462bdd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/52a47d4c0299e8dc2293f8ba6ff81e16a462bdd4", "html_url": "https://github.com/rust-lang/rust/commit/52a47d4c0299e8dc2293f8ba6ff81e16a462bdd4"}], "stats": {"total": 2115, "additions": 1255, "deletions": 860}, "files": [{"sha": "52caf46878b1559676bbcda88d7a40265b3ee1bb", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -138,9 +138,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 self.explain_span(scope_decorated_tag, span)\n             }\n \n-            ty::ReEarlyBound(_) | ty::ReFree(_) => self.msg_span_from_free_region(region),\n-\n-            ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n+            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic => {\n+                self.msg_span_from_free_region(region)\n+            }\n \n             ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n \n@@ -175,6 +175,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn msg_span_from_free_region(self, region: ty::Region<'tcx>) -> (String, Option<Span>) {\n+        match *region {\n+            ty::ReEarlyBound(_) | ty::ReFree(_)  => {\n+                self.msg_span_from_early_bound_and_free_regions(region)\n+            },\n+            ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n+            _ => bug!(),\n+        }\n+    }\n+\n+    fn msg_span_from_early_bound_and_free_regions(\n+        self,\n+        region: ty::Region<'tcx>,\n+    ) -> (String, Option<Span>) {\n         let scope = region.free_region_binding_scope(self);\n         let node = self.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n         let unknown;"}, {"sha": "75b4409695e5e72b382a9a6ee8e5dd0d5ed0f89d", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 642, "deletions": 418, "changes": 1060, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -27,7 +27,7 @@ use lint;\n use middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy};\n-use syntax::codemap::{FilePathMapping, FileName};\n+use syntax::codemap::{FileName, FilePathMapping};\n use syntax::parse::token;\n use syntax::parse;\n use syntax::symbol::Symbol;\n@@ -64,12 +64,12 @@ pub enum Sanitizer {\n \n #[derive(Clone, Copy, PartialEq, Hash)]\n pub enum OptLevel {\n-    No, // -O0\n-    Less, // -O1\n-    Default, // -O2\n+    No,         // -O0\n+    Less,       // -O1\n+    Default,    // -O2\n     Aggressive, // -O3\n-    Size, // -Os\n-    SizeMin, // -Oz\n+    Size,       // -Os\n+    SizeMin,    // -Oz\n }\n \n #[derive(Clone, Copy, PartialEq, Hash)]\n@@ -99,8 +99,7 @@ pub enum DebugInfoLevel {\n     FullDebugInfo,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord,\n-         RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n pub enum OutputType {\n     Bitcode,\n     Assembly,\n@@ -117,12 +116,10 @@ pub enum OutputType {\n #[non_exhaustive]\n pub enum Epoch {\n     // epochs must be kept in order, newest to oldest\n-\n     /// The 2015 epoch\n     Epoch2015,\n     /// The 2018 epoch\n     Epoch2018,\n-\n     // when adding new epochs, be sure to update:\n     //\n     // - the list in the `parse_epoch` static\n@@ -163,7 +160,7 @@ impl str::FromStr for Epoch {\n         match s {\n             \"2015\" => Ok(Epoch::Epoch2015),\n             \"2018\" => Ok(Epoch::Epoch2018),\n-            _ => Err(())\n+            _ => Err(()),\n         }\n     }\n }\n@@ -190,14 +187,13 @@ impl<'a, 'tcx> ToStableHashKey<StableHashingContext<'a>> for OutputType {\n impl OutputType {\n     fn is_compatible_with_codegen_units_and_single_output_file(&self) -> bool {\n         match *self {\n-            OutputType::Exe |\n-            OutputType::DepInfo => true,\n-            OutputType::Bitcode |\n-            OutputType::Assembly |\n-            OutputType::LlvmAssembly |\n-            OutputType::Mir |\n-            OutputType::Object |\n-            OutputType::Metadata => false,\n+            OutputType::Exe | OutputType::DepInfo => true,\n+            OutputType::Bitcode\n+            | OutputType::Assembly\n+            | OutputType::LlvmAssembly\n+            | OutputType::Mir\n+            | OutputType::Object\n+            | OutputType::Metadata => false,\n         }\n     }\n \n@@ -216,14 +212,14 @@ impl OutputType {\n \n     fn from_shorthand(shorthand: &str) -> Option<Self> {\n         Some(match shorthand {\n-             \"asm\" => OutputType::Assembly,\n-             \"llvm-ir\" => OutputType::LlvmAssembly,\n-             \"mir\" => OutputType::Mir,\n-             \"llvm-bc\" => OutputType::Bitcode,\n-             \"obj\" => OutputType::Object,\n-             \"metadata\" => OutputType::Metadata,\n-             \"link\" => OutputType::Exe,\n-             \"dep-info\" => OutputType::DepInfo,\n+            \"asm\" => OutputType::Assembly,\n+            \"llvm-ir\" => OutputType::LlvmAssembly,\n+            \"mir\" => OutputType::Mir,\n+            \"llvm-bc\" => OutputType::Bitcode,\n+            \"obj\" => OutputType::Object,\n+            \"metadata\" => OutputType::Metadata,\n+            \"link\" => OutputType::Exe,\n+            \"dep-info\" => OutputType::DepInfo,\n             _ => return None,\n         })\n     }\n@@ -281,8 +277,9 @@ impl_stable_hash_for!(tuple_struct self::OutputTypes {\n \n impl OutputTypes {\n     pub fn new(entries: &[(OutputType, Option<PathBuf>)]) -> OutputTypes {\n-        OutputTypes(BTreeMap::from_iter(entries.iter()\n-                                               .map(|&(k, ref v)| (k, v.clone()))))\n+        OutputTypes(BTreeMap::from_iter(\n+            entries.iter().map(|&(k, ref v)| (k, v.clone())),\n+        ))\n     }\n \n     pub fn get(&self, key: &OutputType) -> Option<&Option<PathBuf>> {\n@@ -304,19 +301,17 @@ impl OutputTypes {\n     // True if any of the output types require codegen or linking.\n     pub fn should_trans(&self) -> bool {\n         self.0.keys().any(|k| match *k {\n-            OutputType::Bitcode |\n-            OutputType::Assembly |\n-            OutputType::LlvmAssembly |\n-            OutputType::Mir |\n-            OutputType::Object |\n-            OutputType::Exe => true,\n-            OutputType::Metadata |\n-            OutputType::DepInfo => false,\n+            OutputType::Bitcode\n+            | OutputType::Assembly\n+            | OutputType::LlvmAssembly\n+            | OutputType::Mir\n+            | OutputType::Object\n+            | OutputType::Exe => true,\n+            OutputType::Metadata | OutputType::DepInfo => false,\n         })\n     }\n }\n \n-\n // Use tree-based collections to cheaply get a deterministic Hash implementation.\n // DO NOT switch BTreeMap or BTreeSet out for an unsorted container type! That\n // would break dependency tracking for commandline arguments.\n@@ -522,8 +517,7 @@ pub enum Input {\n impl Input {\n     pub fn filestem(&self) -> String {\n         match *self {\n-            Input::File(ref ifile) => ifile.file_stem().unwrap()\n-                                           .to_str().unwrap().to_string(),\n+            Input::File(ref ifile) => ifile.file_stem().unwrap().to_str().unwrap().to_string(),\n             Input::Str { .. } => \"rust_out\".to_string(),\n         }\n     }\n@@ -550,28 +544,24 @@ pub const RUST_CGU_EXT: &str = \"rcgu\";\n \n impl OutputFilenames {\n     pub fn path(&self, flavor: OutputType) -> PathBuf {\n-        self.outputs.get(&flavor).and_then(|p| p.to_owned())\n+        self.outputs\n+            .get(&flavor)\n+            .and_then(|p| p.to_owned())\n             .or_else(|| self.single_output_file.clone())\n             .unwrap_or_else(|| self.temp_path(flavor, None))\n     }\n \n     /// Get the path where a compilation artifact of the given type for the\n     /// given codegen unit should be placed on disk. If codegen_unit_name is\n     /// None, a path distinct from those of any codegen unit will be generated.\n-    pub fn temp_path(&self,\n-                     flavor: OutputType,\n-                     codegen_unit_name: Option<&str>)\n-                     -> PathBuf {\n+    pub fn temp_path(&self, flavor: OutputType, codegen_unit_name: Option<&str>) -> PathBuf {\n         let extension = flavor.extension();\n         self.temp_path_ext(extension, codegen_unit_name)\n     }\n \n     /// Like temp_path, but also supports things where there is no corresponding\n     /// OutputType, like no-opt-bitcode or lto-bitcode.\n-    pub fn temp_path_ext(&self,\n-                         ext: &str,\n-                         codegen_unit_name: Option<&str>)\n-                         -> PathBuf {\n+    pub fn temp_path_ext(&self, ext: &str, codegen_unit_name: Option<&str>) -> PathBuf {\n         let base = self.out_directory.join(&self.filestem());\n \n         let mut extension = String::new();\n@@ -595,7 +585,9 @@ impl OutputFilenames {\n     }\n \n     pub fn with_extension(&self, extension: &str) -> PathBuf {\n-        self.out_directory.join(&self.filestem()).with_extension(extension)\n+        self.out_directory\n+            .join(&self.filestem())\n+            .with_extension(extension)\n     }\n \n     pub fn filestem(&self) -> String {\n@@ -612,8 +604,7 @@ pub fn host_triple() -> &'static str {\n     // Instead of grabbing the host triple (for the current host), we grab (at\n     // compile time) the target triple that this rustc is built with and\n     // calling that (at runtime) the host triple.\n-    (option_env!(\"CFG_COMPILER_HOST_TRIPLE\")).\n-        expect(\"CFG_COMPILER_HOST_TRIPLE\")\n+    (option_env!(\"CFG_COMPILER_HOST_TRIPLE\")).expect(\"CFG_COMPILER_HOST_TRIPLE\")\n }\n \n /// Some reasonable defaults\n@@ -652,15 +643,14 @@ pub fn basic_options() -> Options {\n impl Options {\n     /// True if there is a reason to build the dep graph.\n     pub fn build_dep_graph(&self) -> bool {\n-        self.incremental.is_some() ||\n-            self.debugging_opts.dump_dep_graph ||\n-            self.debugging_opts.query_dep_graph\n+        self.incremental.is_some() || self.debugging_opts.dump_dep_graph\n+            || self.debugging_opts.query_dep_graph\n     }\n \n     #[inline(always)]\n     pub fn enable_dep_node_debug_strs(&self) -> bool {\n-        cfg!(debug_assertions) &&\n-            (self.debugging_opts.query_dep_graph || self.debugging_opts.incremental_info)\n+        cfg!(debug_assertions)\n+            && (self.debugging_opts.query_dep_graph || self.debugging_opts.incremental_info)\n     }\n \n     pub fn file_path_mapping(&self) -> FilePathMapping {\n@@ -1312,8 +1302,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"choose which RELRO level to use\"),\n     nll: bool = (false, parse_bool, [UNTRACKED],\n                  \"run the non-lexical lifetimes MIR pass\"),\n-    nll_dump_cause: bool = (false, parse_bool, [UNTRACKED],\n-                 \"dump cause information when reporting errors from NLL\"),\n     trans_time_graph: bool = (false, parse_bool, [UNTRACKED],\n         \"generate a graphical HTML report of time spent in trans and LLVM\"),\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n@@ -1378,18 +1366,30 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     }\n     ret.insert((Symbol::intern(\"target_arch\"), Some(Symbol::intern(arch))));\n     ret.insert((Symbol::intern(\"target_endian\"), Some(Symbol::intern(end))));\n-    ret.insert((Symbol::intern(\"target_pointer_width\"), Some(Symbol::intern(wordsz))));\n+    ret.insert((\n+        Symbol::intern(\"target_pointer_width\"),\n+        Some(Symbol::intern(wordsz)),\n+    ));\n     ret.insert((Symbol::intern(\"target_env\"), Some(Symbol::intern(env))));\n-    ret.insert((Symbol::intern(\"target_vendor\"), Some(Symbol::intern(vendor))));\n+    ret.insert((\n+        Symbol::intern(\"target_vendor\"),\n+        Some(Symbol::intern(vendor)),\n+    ));\n     if sess.target.target.options.has_elf_tls {\n         ret.insert((Symbol::intern(\"target_thread_local\"), None));\n     }\n     for &i in &[8, 16, 32, 64, 128] {\n         if i >= min_atomic_width && i <= max_atomic_width {\n             let s = i.to_string();\n-            ret.insert((Symbol::intern(\"target_has_atomic\"), Some(Symbol::intern(&s))));\n+            ret.insert((\n+                Symbol::intern(\"target_has_atomic\"),\n+                Some(Symbol::intern(&s)),\n+            ));\n             if &s == wordsz {\n-                ret.insert((Symbol::intern(\"target_has_atomic\"), Some(Symbol::intern(\"ptr\"))));\n+                ret.insert((\n+                    Symbol::intern(\"target_has_atomic\"),\n+                    Some(Symbol::intern(\"ptr\")),\n+                ));\n             }\n         }\n     }\n@@ -1402,9 +1402,7 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     return ret;\n }\n \n-pub fn build_configuration(sess: &Session,\n-                           mut user_cfg: ast::CrateConfig)\n-                           -> ast::CrateConfig {\n+pub fn build_configuration(sess: &Session, mut user_cfg: ast::CrateConfig) -> ast::CrateConfig {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n     let default_cfg = default_configuration(sess);\n@@ -1431,8 +1429,11 @@ pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n         \"16\" => (ast::IntTy::I16, ast::UintTy::U16),\n         \"32\" => (ast::IntTy::I32, ast::UintTy::U32),\n         \"64\" => (ast::IntTy::I64, ast::UintTy::U64),\n-        w    => sp.fatal(&format!(\"target specification was invalid: \\\n-                                          unrecognized target-pointer-width {}\", w)).raise(),\n+        w => sp.fatal(&format!(\n+            \"target specification was invalid: \\\n+             unrecognized target-pointer-width {}\",\n+            w\n+        )).raise(),\n     };\n \n     Config {\n@@ -1461,7 +1462,8 @@ impl RustcOptGroup {\n     }\n \n     pub fn stable<F>(name: &'static str, f: F) -> RustcOptGroup\n-        where F: Fn(&mut getopts::Options) -> &mut getopts::Options + 'static,\n+    where\n+        F: Fn(&mut getopts::Options) -> &mut getopts::Options + 'static,\n     {\n         RustcOptGroup {\n             name,\n@@ -1471,7 +1473,8 @@ impl RustcOptGroup {\n     }\n \n     pub fn unstable<F>(name: &'static str, f: F) -> RustcOptGroup\n-        where F: Fn(&mut getopts::Options) -> &mut getopts::Options + 'static,\n+    where\n+        F: Fn(&mut getopts::Options) -> &mut getopts::Options + 'static,\n     {\n         RustcOptGroup {\n             name,\n@@ -1499,13 +1502,15 @@ mod opt {\n     pub type S = &'static str;\n \n     fn stable<F>(name: S, f: F) -> R\n-        where F: Fn(&mut getopts::Options) -> &mut getopts::Options + 'static\n+    where\n+        F: Fn(&mut getopts::Options) -> &mut getopts::Options + 'static,\n     {\n         RustcOptGroup::stable(name, f)\n     }\n \n     fn unstable<F>(name: S, f: F) -> R\n-        where F: Fn(&mut getopts::Options) -> &mut getopts::Options + 'static\n+    where\n+        F: Fn(&mut getopts::Options) -> &mut getopts::Options + 'static,\n     {\n         RustcOptGroup::unstable(name, f)\n     }\n@@ -1558,42 +1563,88 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n     vec![\n         opt::flag_s(\"h\", \"help\", \"Display this message\"),\n         opt::multi_s(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n-        opt::multi_s(\"L\", \"\",   \"Add a directory to the library search path. The\n+        opt::multi_s(\n+            \"L\",\n+            \"\",\n+            \"Add a directory to the library search path. The\n                              optional KIND can be one of dependency, crate, native,\n-                             framework or all (the default).\", \"[KIND=]PATH\"),\n-        opt::multi_s(\"l\", \"\",   \"Link the generated crate(s) to the specified native\n+                             framework or all (the default).\",\n+            \"[KIND=]PATH\",\n+        ),\n+        opt::multi_s(\n+            \"l\",\n+            \"\",\n+            \"Link the generated crate(s) to the specified native\n                              library NAME. The optional KIND can be one of\n                              static, dylib, or framework. If omitted, dylib is\n-                             assumed.\", \"[KIND=]NAME\"),\n-        opt::multi_s(\"\", \"crate-type\", \"Comma separated list of types of crates\n+                             assumed.\",\n+            \"[KIND=]NAME\",\n+        ),\n+        opt::multi_s(\n+            \"\",\n+            \"crate-type\",\n+            \"Comma separated list of types of crates\n                                     for the compiler to emit\",\n-                   \"[bin|lib|rlib|dylib|cdylib|staticlib|proc-macro]\"),\n-        opt::opt_s(\"\", \"crate-name\", \"Specify the name of the crate being built\",\n-               \"NAME\"),\n-        opt::multi_s(\"\", \"emit\", \"Comma separated list of types of output for \\\n-                              the compiler to emit\",\n-                 \"[asm|llvm-bc|llvm-ir|obj|metadata|link|dep-info|mir]\"),\n-        opt::multi_s(\"\", \"print\", \"Comma separated list of compiler information to \\\n-                               print on stdout\",\n-                     \"[crate-name|file-names|sysroot|cfg|target-list|\\\n-                       target-cpus|target-features|relocation-models|\\\n-                       code-models|tls-models|target-spec-json|native-static-libs]\"),\n-        opt::flagmulti_s(\"g\",  \"\",  \"Equivalent to -C debuginfo=2\"),\n+            \"[bin|lib|rlib|dylib|cdylib|staticlib|proc-macro]\",\n+        ),\n+        opt::opt_s(\n+            \"\",\n+            \"crate-name\",\n+            \"Specify the name of the crate being built\",\n+            \"NAME\",\n+        ),\n+        opt::multi_s(\n+            \"\",\n+            \"emit\",\n+            \"Comma separated list of types of output for \\\n+             the compiler to emit\",\n+            \"[asm|llvm-bc|llvm-ir|obj|metadata|link|dep-info|mir]\",\n+        ),\n+        opt::multi_s(\n+            \"\",\n+            \"print\",\n+            \"Comma separated list of compiler information to \\\n+             print on stdout\",\n+            \"[crate-name|file-names|sysroot|cfg|target-list|\\\n+             target-cpus|target-features|relocation-models|\\\n+             code-models|tls-models|target-spec-json|native-static-libs]\",\n+        ),\n+        opt::flagmulti_s(\"g\", \"\", \"Equivalent to -C debuginfo=2\"),\n         opt::flagmulti_s(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n         opt::opt_s(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),\n-        opt::opt_s(\"\",  \"out-dir\", \"Write output to compiler-chosen filename \\\n-                                in <dir>\", \"DIR\"),\n-        opt::opt_s(\"\", \"explain\", \"Provide a detailed explanation of an error \\\n-                               message\", \"OPT\"),\n+        opt::opt_s(\n+            \"\",\n+            \"out-dir\",\n+            \"Write output to compiler-chosen filename \\\n+             in <dir>\",\n+            \"DIR\",\n+        ),\n+        opt::opt_s(\n+            \"\",\n+            \"explain\",\n+            \"Provide a detailed explanation of an error \\\n+             message\",\n+            \"OPT\",\n+        ),\n         opt::flag_s(\"\", \"test\", \"Build a test harness\"),\n-        opt::opt_s(\"\", \"target\", \"Target triple for which the code is compiled\", \"TARGET\"),\n+        opt::opt_s(\n+            \"\",\n+            \"target\",\n+            \"Target triple for which the code is compiled\",\n+            \"TARGET\",\n+        ),\n         opt::multi_s(\"W\", \"warn\", \"Set lint warnings\", \"OPT\"),\n         opt::multi_s(\"A\", \"allow\", \"Set lint allowed\", \"OPT\"),\n         opt::multi_s(\"D\", \"deny\", \"Set lint denied\", \"OPT\"),\n         opt::multi_s(\"F\", \"forbid\", \"Set lint forbidden\", \"OPT\"),\n-        opt::multi_s(\"\", \"cap-lints\", \"Set the most restrictive lint level. \\\n-                                     More restrictive lints are capped at this \\\n-                                     level\", \"LEVEL\"),\n+        opt::multi_s(\n+            \"\",\n+            \"cap-lints\",\n+            \"Set the most restrictive lint level. \\\n+             More restrictive lints are capped at this \\\n+             level\",\n+            \"LEVEL\",\n+        ),\n         opt::multi_s(\"C\", \"codegen\", \"Set a codegen option\", \"OPT[=VALUE]\"),\n         opt::flag_s(\"V\", \"version\", \"Print version info and exit\"),\n         opt::flag_s(\"v\", \"verbose\", \"Use verbose output\"),\n@@ -1606,64 +1657,95 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n     let mut opts = rustc_short_optgroups();\n     opts.extend(vec![\n-        opt::multi_s(\"\", \"extern\", \"Specify where an external rust library is located\",\n-                     \"NAME=PATH\"),\n+        opt::multi_s(\n+            \"\",\n+            \"extern\",\n+            \"Specify where an external rust library is located\",\n+            \"NAME=PATH\",\n+        ),\n         opt::opt_s(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n         opt::multi(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n-        opt::opt_s(\"\", \"error-format\",\n-                      \"How errors and other messages are produced\",\n-                      \"human|json|short\"),\n-        opt::opt_s(\"\", \"color\", \"Configure coloring of output:\n+        opt::opt_s(\n+            \"\",\n+            \"error-format\",\n+            \"How errors and other messages are produced\",\n+            \"human|json|short\",\n+        ),\n+        opt::opt_s(\n+            \"\",\n+            \"color\",\n+            \"Configure coloring of output:\n                                  auto   = colorize, if output goes to a tty (default);\n                                  always = always colorize output;\n-                                 never  = never colorize output\", \"auto|always|never\"),\n-\n-        opt::opt(\"\", \"pretty\",\n-                 \"Pretty-print the input instead of compiling;\n+                                 never  = never colorize output\",\n+            \"auto|always|never\",\n+        ),\n+        opt::opt(\n+            \"\",\n+            \"pretty\",\n+            \"Pretty-print the input instead of compiling;\n                   valid types are: `normal` (un-annotated source),\n                   `expanded` (crates expanded), or\n                   `expanded,identified` (fully parenthesized, AST nodes with IDs).\",\n-                 \"TYPE\"),\n-        opt::multi_s(\"\", \"remap-path-prefix\", \"remap source names in output\", \"FROM=TO\"),\n+            \"TYPE\",\n+        ),\n+        opt::multi_s(\n+            \"\",\n+            \"remap-path-prefix\",\n+            \"remap source names in output\",\n+            \"FROM=TO\",\n+        ),\n     ]);\n     opts\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n-    cfgspecs.into_iter().map(|s| {\n-        let sess = parse::ParseSess::new(FilePathMapping::empty());\n-        let mut parser =\n-            parse::new_parser_from_source_str(&sess, FileName::CfgSpec, s.to_string());\n-\n-        let meta_item = panictry!(parser.parse_meta_item());\n-\n-        if parser.token != token::Eof {\n-            early_error(ErrorOutputType::default(), &format!(\"invalid --cfg argument: {}\", s))\n-        } else if meta_item.is_meta_item_list() {\n-            let msg =\n-                format!(\"invalid predicate in --cfg command line argument: `{}`\", meta_item.name());\n-            early_error(ErrorOutputType::default(), &msg)\n-        }\n+pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> ast::CrateConfig {\n+    cfgspecs\n+        .into_iter()\n+        .map(|s| {\n+            let sess = parse::ParseSess::new(FilePathMapping::empty());\n+            let mut parser =\n+                parse::new_parser_from_source_str(&sess, FileName::CfgSpec, s.to_string());\n+\n+            let meta_item = panictry!(parser.parse_meta_item());\n+\n+            if parser.token != token::Eof {\n+                early_error(\n+                    ErrorOutputType::default(),\n+                    &format!(\"invalid --cfg argument: {}\", s),\n+                )\n+            } else if meta_item.is_meta_item_list() {\n+                let msg = format!(\n+                    \"invalid predicate in --cfg command line argument: `{}`\",\n+                    meta_item.name()\n+                );\n+                early_error(ErrorOutputType::default(), &msg)\n+            }\n \n-        (meta_item.name(), meta_item.value_str())\n-    }).collect::<ast::CrateConfig>()\n+            (meta_item.name(), meta_item.value_str())\n+        })\n+        .collect::<ast::CrateConfig>()\n }\n \n-pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n-                                              -> (Options, ast::CrateConfig) {\n+pub fn build_session_options_and_crate_config(\n+    matches: &getopts::Matches,\n+) -> (Options, ast::CrateConfig) {\n     let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n-        Some(\"auto\")   => ColorConfig::Auto,\n+        Some(\"auto\") => ColorConfig::Auto,\n         Some(\"always\") => ColorConfig::Always,\n-        Some(\"never\")  => ColorConfig::Never,\n+        Some(\"never\") => ColorConfig::Never,\n \n         None => ColorConfig::Auto,\n \n-        Some(arg) => {\n-            early_error(ErrorOutputType::default(), &format!(\"argument for --color must be auto, \\\n-                                                              always or never (instead was `{}`)\",\n-                                                            arg))\n-        }\n+        Some(arg) => early_error(\n+            ErrorOutputType::default(),\n+            &format!(\n+                \"argument for --color must be auto, \\\n+                 always or never (instead was `{}`)\",\n+                arg\n+            ),\n+        ),\n     };\n \n     // We need the opts_present check because the driver will send us Matches\n@@ -1673,25 +1755,31 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n     let error_format = if matches.opts_present(&[\"error-format\".to_owned()]) {\n         match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n             Some(\"human\") => ErrorOutputType::HumanReadable(color),\n-            Some(\"json\")  => ErrorOutputType::Json(false),\n+            Some(\"json\") => ErrorOutputType::Json(false),\n             Some(\"pretty-json\") => ErrorOutputType::Json(true),\n             Some(\"short\") => {\n                 if nightly_options::is_unstable_enabled(matches) {\n                     ErrorOutputType::Short(color)\n                 } else {\n-                    early_error(ErrorOutputType::default(),\n-                                &format!(\"the `-Z unstable-options` flag must also be passed to \\\n-                                          enable the short error message option\"));\n+                    early_error(\n+                        ErrorOutputType::default(),\n+                        &format!(\n+                            \"the `-Z unstable-options` flag must also be passed to \\\n+                             enable the short error message option\"\n+                        ),\n+                    );\n                 }\n             }\n             None => ErrorOutputType::HumanReadable(color),\n \n-            Some(arg) => {\n-                early_error(ErrorOutputType::HumanReadable(color),\n-                            &format!(\"argument for --error-format must be `human`, `json` or \\\n-                                      `short` (instead was `{}`)\",\n-                                     arg))\n-            }\n+            Some(arg) => early_error(\n+                ErrorOutputType::HumanReadable(color),\n+                &format!(\n+                    \"argument for --error-format must be `human`, `json` or \\\n+                     `short` (instead was `{}`)\",\n+                    arg\n+                ),\n+            ),\n         }\n     } else {\n         ErrorOutputType::HumanReadable(color)\n@@ -1715,15 +1803,17 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n     }\n \n     let lint_cap = matches.opt_str(\"cap-lints\").map(|cap| {\n-        lint::Level::from_str(&cap).unwrap_or_else(|| {\n-            early_error(error_format, &format!(\"unknown lint level: `{}`\", cap))\n-        })\n+        lint::Level::from_str(&cap)\n+            .unwrap_or_else(|| early_error(error_format, &format!(\"unknown lint level: `{}`\", cap)))\n     });\n \n     let mut debugging_opts = build_debugging_options(matches, error_format);\n \n     if !debugging_opts.unstable_options && error_format == ErrorOutputType::Json(true) {\n-        early_error(ErrorOutputType::Json(false), \"--error-format=pretty-json is unstable\");\n+        early_error(\n+            ErrorOutputType::Json(false),\n+            \"--error-format=pretty-json is unstable\",\n+        );\n     }\n \n     let mut output_types = BTreeMap::new();\n@@ -1734,10 +1824,14 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n                 let shorthand = parts.next().unwrap();\n                 let output_type = match OutputType::from_shorthand(shorthand) {\n                     Some(output_type) => output_type,\n-                    None => early_error(error_format, &format!(\n-                        \"unknown emission type: `{}` - expected one of: {}\",\n-                        shorthand, OutputType::shorthands_display(),\n-                    )),\n+                    None => early_error(\n+                        error_format,\n+                        &format!(\n+                            \"unknown emission type: `{}` - expected one of: {}\",\n+                            shorthand,\n+                            OutputType::shorthands_display(),\n+                        ),\n+                    ),\n                 };\n                 let path = parts.next().map(PathBuf::from);\n                 output_types.insert(output_type, path);\n@@ -1754,21 +1848,25 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n \n     // Issue #30063: if user requests llvm-related output to one\n     // particular path, disable codegen-units.\n-    let incompatible: Vec<_> = output_types.iter()\n+    let incompatible: Vec<_> = output_types\n+        .iter()\n         .map(|ot_path| ot_path.0)\n-        .filter(|ot| {\n-            !ot.is_compatible_with_codegen_units_and_single_output_file()\n-        })\n+        .filter(|ot| !ot.is_compatible_with_codegen_units_and_single_output_file())\n         .map(|ot| ot.shorthand())\n         .collect();\n     if !incompatible.is_empty() {\n         match codegen_units {\n             Some(n) if n > 1 => {\n                 if matches.opt_present(\"o\") {\n                     for ot in &incompatible {\n-                        early_warn(error_format, &format!(\"--emit={} with -o incompatible with \\\n-                                                         -C codegen-units=N for N > 1\",\n-                                                        ot));\n+                        early_warn(\n+                            error_format,\n+                            &format!(\n+                                \"--emit={} with -o incompatible with \\\n+                                 -C codegen-units=N for N > 1\",\n+                                ot\n+                            ),\n+                        );\n                     }\n                     early_warn(error_format, \"resetting to default -C codegen-units=1\");\n                     codegen_units = Some(1);\n@@ -1783,21 +1881,30 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n     }\n \n     if debugging_opts.query_threads == Some(0) {\n-        early_error(error_format, \"Value for query threads must be a positive nonzero integer\");\n+        early_error(\n+            error_format,\n+            \"Value for query threads must be a positive nonzero integer\",\n+        );\n     }\n \n     if codegen_units == Some(0) {\n-        early_error(error_format, \"Value for codegen units must be a positive nonzero integer\");\n+        early_error(\n+            error_format,\n+            \"Value for codegen units must be a positive nonzero integer\",\n+        );\n     }\n \n     let incremental = match (&debugging_opts.incremental, &cg.incremental) {\n         (&Some(ref path1), &Some(ref path2)) => {\n             if path1 != path2 {\n-                early_error(error_format,\n-                    &format!(\"conflicting paths for `-Z incremental` and \\\n-                              `-C incremental` specified: {} versus {}\",\n-                              path1,\n-                              path2));\n+                early_error(\n+                    error_format,\n+                    &format!(\n+                        \"conflicting paths for `-Z incremental` and \\\n+                         `-C incremental` specified: {} versus {}\",\n+                        path1, path2\n+                    ),\n+                );\n             } else {\n                 Some(path1)\n             }\n@@ -1808,7 +1915,10 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n     }.map(|m| PathBuf::from(m));\n \n     if cg.lto != Lto::No && incremental.is_some() {\n-        early_error(error_format, \"can't perform LTO when compiling incrementally\");\n+        early_error(\n+            error_format,\n+            \"can't perform LTO when compiling incrementally\",\n+        );\n     }\n \n     let mut prints = Vec::<PrintRequest>::new();\n@@ -1828,25 +1938,32 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         prints.push(PrintRequest::CodeModels);\n         cg.code_model = None;\n     }\n-    if debugging_opts.tls_model.as_ref().map_or(false, |s| s == \"help\") {\n+    if debugging_opts\n+        .tls_model\n+        .as_ref()\n+        .map_or(false, |s| s == \"help\")\n+    {\n         prints.push(PrintRequest::TlsModels);\n         debugging_opts.tls_model = None;\n     }\n \n     let cg = cg;\n \n     let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| PathBuf::from(&m));\n-    let target = matches.opt_str(\"target\").unwrap_or(\n-        host_triple().to_string());\n+    let target = matches\n+        .opt_str(\"target\")\n+        .unwrap_or(host_triple().to_string());\n     let opt_level = {\n         if matches.opt_present(\"O\") {\n             if cg.opt_level.is_some() {\n                 early_error(error_format, \"-O and -C opt-level both provided\");\n             }\n             OptLevel::Default\n         } else {\n-            match (cg.opt_level.as_ref().map(String::as_ref),\n-                   nightly_options::is_nightly_build()) {\n+            match (\n+                cg.opt_level.as_ref().map(String::as_ref),\n+                nightly_options::is_nightly_build(),\n+            ) {\n                 (None, _) => OptLevel::No,\n                 (Some(\"0\"), _) => OptLevel::No,\n                 (Some(\"1\"), _) => OptLevel::Less,\n@@ -1855,13 +1972,23 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n                 (Some(\"s\"), true) => OptLevel::Size,\n                 (Some(\"z\"), true) => OptLevel::SizeMin,\n                 (Some(\"s\"), false) | (Some(\"z\"), false) => {\n-                    early_error(error_format, &format!(\"the optimizations s or z are only \\\n-                                                        accepted on the nightly compiler\"));\n-                },\n+                    early_error(\n+                        error_format,\n+                        &format!(\n+                            \"the optimizations s or z are only \\\n+                             accepted on the nightly compiler\"\n+                        ),\n+                    );\n+                }\n                 (Some(arg), _) => {\n-                    early_error(error_format, &format!(\"optimization level needs to be \\\n-                                                      between 0-3 (instead was `{}`)\",\n-                                                     arg));\n+                    early_error(\n+                        error_format,\n+                        &format!(\n+                            \"optimization level needs to be \\\n+                             between 0-3 (instead was `{}`)\",\n+                            arg\n+                        ),\n+                    );\n                 }\n             }\n         }\n@@ -1878,9 +2005,14 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n             Some(1) => LimitedDebugInfo,\n             Some(2) => FullDebugInfo,\n             Some(arg) => {\n-                early_error(error_format, &format!(\"debug info level needs to be between \\\n-                                                  0-2 (instead was `{}`)\",\n-                                                 arg));\n+                early_error(\n+                    error_format,\n+                    &format!(\n+                        \"debug info level needs to be between \\\n+                         0-2 (instead was `{}`)\",\n+                        arg\n+                    ),\n+                );\n             }\n         }\n     };\n@@ -1890,76 +2022,91 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         search_paths.add_path(&s[..], error_format);\n     }\n \n-    let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n-        // Parse string of the form \"[KIND=]lib[:new_name]\",\n-        // where KIND is one of \"dylib\", \"framework\", \"static\".\n-        let mut parts = s.splitn(2, '=');\n-        let kind = parts.next().unwrap();\n-        let (name, kind) = match (parts.next(), kind) {\n-            (None, name) => (name, None),\n-            (Some(name), \"dylib\") => (name, Some(cstore::NativeUnknown)),\n-            (Some(name), \"framework\") => (name, Some(cstore::NativeFramework)),\n-            (Some(name), \"static\") => (name, Some(cstore::NativeStatic)),\n-            (Some(name), \"static-nobundle\") => (name, Some(cstore::NativeStaticNobundle)),\n-            (_, s) => {\n-                early_error(error_format, &format!(\"unknown library kind `{}`, expected \\\n-                                                  one of dylib, framework, or static\",\n-                                                 s));\n+    let libs = matches\n+        .opt_strs(\"l\")\n+        .into_iter()\n+        .map(|s| {\n+            // Parse string of the form \"[KIND=]lib[:new_name]\",\n+            // where KIND is one of \"dylib\", \"framework\", \"static\".\n+            let mut parts = s.splitn(2, '=');\n+            let kind = parts.next().unwrap();\n+            let (name, kind) = match (parts.next(), kind) {\n+                (None, name) => (name, None),\n+                (Some(name), \"dylib\") => (name, Some(cstore::NativeUnknown)),\n+                (Some(name), \"framework\") => (name, Some(cstore::NativeFramework)),\n+                (Some(name), \"static\") => (name, Some(cstore::NativeStatic)),\n+                (Some(name), \"static-nobundle\") => (name, Some(cstore::NativeStaticNobundle)),\n+                (_, s) => {\n+                    early_error(\n+                        error_format,\n+                        &format!(\n+                            \"unknown library kind `{}`, expected \\\n+                             one of dylib, framework, or static\",\n+                            s\n+                        ),\n+                    );\n+                }\n+            };\n+            if kind == Some(cstore::NativeStaticNobundle) && !nightly_options::is_nightly_build() {\n+                early_error(\n+                    error_format,\n+                    &format!(\n+                        \"the library kind 'static-nobundle' is only \\\n+                         accepted on the nightly compiler\"\n+                    ),\n+                );\n             }\n-        };\n-        if kind == Some(cstore::NativeStaticNobundle) && !nightly_options::is_nightly_build() {\n-            early_error(error_format, &format!(\"the library kind 'static-nobundle' is only \\\n-                                                accepted on the nightly compiler\"));\n-        }\n-        let mut name_parts = name.splitn(2, ':');\n-        let name = name_parts.next().unwrap();\n-        let new_name = name_parts.next();\n-        (name.to_string(), new_name.map(|n| n.to_string()), kind)\n-    }).collect();\n+            let mut name_parts = name.splitn(2, ':');\n+            let name = name_parts.next().unwrap();\n+            let new_name = name_parts.next();\n+            (name.to_string(), new_name.map(|n| n.to_string()), kind)\n+        })\n+        .collect();\n \n     let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\"));\n     let test = matches.opt_present(\"test\");\n \n-    prints.extend(matches.opt_strs(\"print\").into_iter().map(|s| {\n-        match &*s {\n-            \"crate-name\" => PrintRequest::CrateName,\n-            \"file-names\" => PrintRequest::FileNames,\n-            \"sysroot\" => PrintRequest::Sysroot,\n-            \"cfg\" => PrintRequest::Cfg,\n-            \"target-list\" => PrintRequest::TargetList,\n-            \"target-cpus\" => PrintRequest::TargetCPUs,\n-            \"target-features\" => PrintRequest::TargetFeatures,\n-            \"relocation-models\" => PrintRequest::RelocationModels,\n-            \"code-models\" => PrintRequest::CodeModels,\n-            \"tls-models\" => PrintRequest::TlsModels,\n-            \"native-static-libs\" => PrintRequest::NativeStaticLibs,\n-            \"target-spec-json\" => {\n-                if nightly_options::is_unstable_enabled(matches) {\n-                    PrintRequest::TargetSpec\n-                } else {\n-                    early_error(error_format,\n-                                &format!(\"the `-Z unstable-options` flag must also be passed to \\\n-                                          enable the target-spec-json print option\"));\n-                }\n-            },\n-            req => {\n-                early_error(error_format, &format!(\"unknown print request `{}`\", req))\n+    prints.extend(matches.opt_strs(\"print\").into_iter().map(|s| match &*s {\n+        \"crate-name\" => PrintRequest::CrateName,\n+        \"file-names\" => PrintRequest::FileNames,\n+        \"sysroot\" => PrintRequest::Sysroot,\n+        \"cfg\" => PrintRequest::Cfg,\n+        \"target-list\" => PrintRequest::TargetList,\n+        \"target-cpus\" => PrintRequest::TargetCPUs,\n+        \"target-features\" => PrintRequest::TargetFeatures,\n+        \"relocation-models\" => PrintRequest::RelocationModels,\n+        \"code-models\" => PrintRequest::CodeModels,\n+        \"tls-models\" => PrintRequest::TlsModels,\n+        \"native-static-libs\" => PrintRequest::NativeStaticLibs,\n+        \"target-spec-json\" => {\n+            if nightly_options::is_unstable_enabled(matches) {\n+                PrintRequest::TargetSpec\n+            } else {\n+                early_error(\n+                    error_format,\n+                    &format!(\n+                        \"the `-Z unstable-options` flag must also be passed to \\\n+                         enable the target-spec-json print option\"\n+                    ),\n+                );\n             }\n         }\n+        req => early_error(error_format, &format!(\"unknown print request `{}`\", req)),\n     }));\n \n     let borrowck_mode = match debugging_opts.borrowck.as_ref().map(|s| &s[..]) {\n         None | Some(\"ast\") => BorrowckMode::Ast,\n         Some(\"mir\") => BorrowckMode::Mir,\n         Some(\"compare\") => BorrowckMode::Compare,\n-        Some(m) => {\n-            early_error(error_format, &format!(\"unknown borrowck mode `{}`\", m))\n-        },\n+        Some(m) => early_error(error_format, &format!(\"unknown borrowck mode `{}`\", m)),\n     };\n \n     if !cg.remark.is_empty() && debuginfo == NoDebugInfo {\n-        early_warn(error_format, \"-C remark will not show source locations without \\\n-                                --debuginfo\");\n+        early_warn(\n+            error_format,\n+            \"-C remark will not show source locations without \\\n+             --debuginfo\",\n+        );\n     }\n \n     let mut externs = BTreeMap::new();\n@@ -1971,78 +2118,85 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         };\n         let location = match parts.next() {\n             Some(s) => s,\n-            None => early_error(error_format, \"--extern value must be of the format `foo=bar`\"),\n+            None => early_error(\n+                error_format,\n+                \"--extern value must be of the format `foo=bar`\",\n+            ),\n         };\n \n-        externs.entry(name.to_string())\n-               .or_insert_with(BTreeSet::new)\n-               .insert(location.to_string());\n+        externs\n+            .entry(name.to_string())\n+            .or_insert_with(BTreeSet::new)\n+            .insert(location.to_string());\n     }\n \n     let crate_name = matches.opt_str(\"crate-name\");\n \n-    let remap_path_prefix = matches.opt_strs(\"remap-path-prefix\")\n+    let remap_path_prefix = matches\n+        .opt_strs(\"remap-path-prefix\")\n         .into_iter()\n         .map(|remap| {\n             let mut parts = remap.rsplitn(2, '='); // reverse iterator\n             let to = parts.next();\n             let from = parts.next();\n             match (from, to) {\n                 (Some(from), Some(to)) => (PathBuf::from(from), PathBuf::from(to)),\n-                _ => early_error(error_format,\n-                        \"--remap-path-prefix must contain '=' between FROM and TO\"),\n+                _ => early_error(\n+                    error_format,\n+                    \"--remap-path-prefix must contain '=' between FROM and TO\",\n+                ),\n             }\n         })\n         .collect();\n \n-    (Options {\n-        crate_types,\n-        optimize: opt_level,\n-        debuginfo,\n-        lint_opts,\n-        lint_cap,\n-        describe_lints,\n-        output_types: OutputTypes(output_types),\n-        search_paths,\n-        maybe_sysroot: sysroot_opt,\n-        target_triple: target,\n-        test,\n-        incremental,\n-        debugging_opts,\n-        prints,\n-        borrowck_mode,\n-        cg,\n-        error_format,\n-        externs: Externs(externs),\n-        crate_name,\n-        alt_std_name: None,\n-        libs,\n-        unstable_features: UnstableFeatures::from_environment(),\n-        debug_assertions,\n-        actually_rustdoc: false,\n-        cli_forced_codegen_units: codegen_units,\n-        cli_forced_thinlto_off: disable_thinlto,\n-        remap_path_prefix,\n-    },\n-    cfg)\n+    (\n+        Options {\n+            crate_types,\n+            optimize: opt_level,\n+            debuginfo,\n+            lint_opts,\n+            lint_cap,\n+            describe_lints,\n+            output_types: OutputTypes(output_types),\n+            search_paths,\n+            maybe_sysroot: sysroot_opt,\n+            target_triple: target,\n+            test,\n+            incremental,\n+            debugging_opts,\n+            prints,\n+            borrowck_mode,\n+            cg,\n+            error_format,\n+            externs: Externs(externs),\n+            crate_name,\n+            alt_std_name: None,\n+            libs,\n+            unstable_features: UnstableFeatures::from_environment(),\n+            debug_assertions,\n+            actually_rustdoc: false,\n+            cli_forced_codegen_units: codegen_units,\n+            cli_forced_thinlto_off: disable_thinlto,\n+            remap_path_prefix,\n+        },\n+        cfg,\n+    )\n }\n \n-pub fn parse_crate_types_from_list(list_list: Vec<String>)\n-                                   -> Result<Vec<CrateType>, String> {\n+pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateType>, String> {\n     let mut crate_types: Vec<CrateType> = Vec::new();\n     for unparsed_crate_type in &list_list {\n         for part in unparsed_crate_type.split(',') {\n             let new_part = match part {\n-                \"lib\"       => default_lib_output(),\n-                \"rlib\"      => CrateTypeRlib,\n+                \"lib\" => default_lib_output(),\n+                \"rlib\" => CrateTypeRlib,\n                 \"staticlib\" => CrateTypeStaticlib,\n-                \"dylib\"     => CrateTypeDylib,\n-                \"cdylib\"    => CrateTypeCdylib,\n-                \"bin\"       => CrateTypeExecutable,\n+                \"dylib\" => CrateTypeDylib,\n+                \"cdylib\" => CrateTypeCdylib,\n+                \"bin\" => CrateTypeExecutable,\n                 \"proc-macro\" => CrateTypeProcMacro,\n                 _ => {\n-                    return Err(format!(\"unknown crate type: `{}`\",\n-                                       part));\n+                    return Err(format!(\"unknown crate type: `{}`\", part));\n                 }\n             };\n             if !crate_types.contains(&new_part) {\n@@ -2061,38 +2215,52 @@ pub mod nightly_options {\n     use session::early_error;\n \n     pub fn is_unstable_enabled(matches: &getopts::Matches) -> bool {\n-        is_nightly_build() && matches.opt_strs(\"Z\").iter().any(|x| *x == \"unstable-options\")\n+        is_nightly_build()\n+            && matches\n+                .opt_strs(\"Z\")\n+                .iter()\n+                .any(|x| *x == \"unstable-options\")\n     }\n \n     pub fn is_nightly_build() -> bool {\n         UnstableFeatures::from_environment().is_nightly_build()\n     }\n \n     pub fn check_nightly_options(matches: &getopts::Matches, flags: &[RustcOptGroup]) {\n-        let has_z_unstable_option = matches.opt_strs(\"Z\").iter().any(|x| *x == \"unstable-options\");\n-        let really_allows_unstable_options = UnstableFeatures::from_environment()\n-            .is_nightly_build();\n+        let has_z_unstable_option = matches\n+            .opt_strs(\"Z\")\n+            .iter()\n+            .any(|x| *x == \"unstable-options\");\n+        let really_allows_unstable_options =\n+            UnstableFeatures::from_environment().is_nightly_build();\n \n         for opt in flags.iter() {\n             if opt.stability == OptionStability::Stable {\n-                continue\n+                continue;\n             }\n             if !matches.opt_present(opt.name) {\n-                continue\n+                continue;\n             }\n             if opt.name != \"Z\" && !has_z_unstable_option {\n-                early_error(ErrorOutputType::default(),\n-                            &format!(\"the `-Z unstable-options` flag must also be passed to enable \\\n-                                      the flag `{}`\",\n-                                     opt.name));\n+                early_error(\n+                    ErrorOutputType::default(),\n+                    &format!(\n+                        \"the `-Z unstable-options` flag must also be passed to enable \\\n+                         the flag `{}`\",\n+                        opt.name\n+                    ),\n+                );\n             }\n             if really_allows_unstable_options {\n-                continue\n+                continue;\n             }\n             match opt.stability {\n                 OptionStability::Unstable => {\n-                    let msg = format!(\"the option `{}` is only accepted on the \\\n-                                       nightly compiler\", opt.name);\n+                    let msg = format!(\n+                        \"the option `{}` is only accepted on the \\\n+                         nightly compiler\",\n+                        opt.name\n+                    );\n                     early_error(ErrorOutputType::default(), &msg);\n                 }\n                 OptionStability::Stable => {}\n@@ -2139,8 +2307,8 @@ mod dep_tracking {\n     use std::hash::Hash;\n     use std::path::PathBuf;\n     use std::collections::hash_map::DefaultHasher;\n-    use super::{Passes, CrateType, OptLevel, DebugInfoLevel, Lto,\n-                OutputTypes, ErrorOutputType, Sanitizer, Epoch};\n+    use super::{CrateType, DebugInfoLevel, Epoch, ErrorOutputType, Lto, OptLevel, OutputTypes,\n+                Passes, Sanitizer};\n     use syntax::feature_gate::UnstableFeatures;\n     use rustc_back::{PanicStrategy, RelroLevel};\n \n@@ -2207,13 +2375,17 @@ mod dep_tracking {\n     impl_dep_tracking_hash_for_sortable_vec_of!(PathBuf);\n     impl_dep_tracking_hash_for_sortable_vec_of!(CrateType);\n     impl_dep_tracking_hash_for_sortable_vec_of!((String, lint::Level));\n-    impl_dep_tracking_hash_for_sortable_vec_of!((String, Option<String>,\n-                                                 Option<cstore::NativeLibraryKind>));\n+    impl_dep_tracking_hash_for_sortable_vec_of!((\n+        String,\n+        Option<String>,\n+        Option<cstore::NativeLibraryKind>\n+    ));\n     impl_dep_tracking_hash_for_sortable_vec_of!((String, u64));\n \n     impl<T1, T2> DepTrackingHash for (T1, T2)\n-        where T1: DepTrackingHash,\n-              T2: DepTrackingHash\n+    where\n+        T1: DepTrackingHash,\n+        T2: DepTrackingHash,\n     {\n         fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n             Hash::hash(&0, hasher);\n@@ -2224,9 +2396,10 @@ mod dep_tracking {\n     }\n \n     impl<T1, T2, T3> DepTrackingHash for (T1, T2, T3)\n-        where T1: DepTrackingHash,\n-              T2: DepTrackingHash,\n-              T3: DepTrackingHash\n+    where\n+        T1: DepTrackingHash,\n+        T2: DepTrackingHash,\n+        T3: DepTrackingHash,\n     {\n         fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n             Hash::hash(&0, hasher);\n@@ -2239,9 +2412,11 @@ mod dep_tracking {\n     }\n \n     // This is a stable hash because BTreeMap is a sorted container\n-    pub fn stable_hash(sub_hashes: BTreeMap<&'static str, &dyn DepTrackingHash>,\n-                       hasher: &mut DefaultHasher,\n-                       error_format: ErrorOutputType) {\n+    pub fn stable_hash(\n+        sub_hashes: BTreeMap<&'static str, &dyn DepTrackingHash>,\n+        hasher: &mut DefaultHasher,\n+        error_format: ErrorOutputType,\n+    ) {\n         for (key, sub_hash) in sub_hashes {\n             // Using Hash::hash() instead of DepTrackingHash::hash() is fine for\n             // the keys, as they are just plain strings\n@@ -2264,7 +2439,7 @@ mod tests {\n     use std::collections::{BTreeMap, BTreeSet};\n     use std::iter::FromIterator;\n     use std::path::PathBuf;\n-    use super::{OutputType, OutputTypes, Externs};\n+    use super::{Externs, OutputType, OutputTypes};\n     use rustc_back::{PanicStrategy, RelroLevel};\n     use syntax::symbol::Symbol;\n \n@@ -2273,7 +2448,7 @@ mod tests {\n         for group in super::rustc_optgroups() {\n             (group.apply)(&mut opts);\n         }\n-        return opts\n+        return opts;\n     }\n \n     fn mk_map<K: Ord, V>(entries: Vec<(K, V)>) -> BTreeMap<K, V> {\n@@ -2287,11 +2462,10 @@ mod tests {\n     // When the user supplies --test we should implicitly supply --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test() {\n-        let matches =\n-            &match optgroups().parse(&[\"--test\".to_string()]) {\n-              Ok(m) => m,\n-              Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n-            };\n+        let matches = &match optgroups().parse(&[\"--test\".to_string()]) {\n+            Ok(m) => m,\n+            Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f),\n+        };\n         let registry = errors::registry::Registry::new(&[]);\n         let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n         let sess = build_session(sessopts, None, registry);\n@@ -2303,13 +2477,10 @@ mod tests {\n     // another --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n-        let matches =\n-            &match optgroups().parse(&[\"--test\".to_string(), \"--cfg=test\".to_string()]) {\n-              Ok(m) => m,\n-              Err(f) => {\n-                panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n-              }\n-            };\n+        let matches = &match optgroups().parse(&[\"--test\".to_string(), \"--cfg=test\".to_string()]) {\n+            Ok(m) => m,\n+            Err(f) => panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f),\n+        };\n         let registry = errors::registry::Registry::new(&[]);\n         let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n         let sess = build_session(sessopts, None, registry);\n@@ -2322,30 +2493,25 @@ mod tests {\n     #[test]\n     fn test_can_print_warnings() {\n         {\n-            let matches = optgroups().parse(&[\n-                \"-Awarnings\".to_string()\n-            ]).unwrap();\n+            let matches = optgroups().parse(&[\"-Awarnings\".to_string()]).unwrap();\n             let registry = errors::registry::Registry::new(&[]);\n             let (sessopts, _) = build_session_options_and_crate_config(&matches);\n             let sess = build_session(sessopts, None, registry);\n             assert!(!sess.diagnostic().flags.can_emit_warnings);\n         }\n \n         {\n-            let matches = optgroups().parse(&[\n-                \"-Awarnings\".to_string(),\n-                \"-Dwarnings\".to_string()\n-            ]).unwrap();\n+            let matches = optgroups()\n+                .parse(&[\"-Awarnings\".to_string(), \"-Dwarnings\".to_string()])\n+                .unwrap();\n             let registry = errors::registry::Registry::new(&[]);\n             let (sessopts, _) = build_session_options_and_crate_config(&matches);\n             let sess = build_session(sessopts, None, registry);\n             assert!(sess.diagnostic().flags.can_emit_warnings);\n         }\n \n         {\n-            let matches = optgroups().parse(&[\n-                \"-Adead_code\".to_string()\n-            ]).unwrap();\n+            let matches = optgroups().parse(&[\"-Adead_code\".to_string()]).unwrap();\n             let registry = errors::registry::Registry::new(&[]);\n             let (sessopts, _) = build_session_options_and_crate_config(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -2359,10 +2525,10 @@ mod tests {\n         let mut v2 = super::basic_options();\n         let mut v3 = super::basic_options();\n \n-        v1.output_types = OutputTypes::new(&[(OutputType::Exe,\n-                                              Some(PathBuf::from(\"./some/thing\")))]);\n-        v2.output_types = OutputTypes::new(&[(OutputType::Exe,\n-                                              Some(PathBuf::from(\"/some/thing\")))]);\n+        v1.output_types =\n+            OutputTypes::new(&[(OutputType::Exe, Some(PathBuf::from(\"./some/thing\")))]);\n+        v2.output_types =\n+            OutputTypes::new(&[(OutputType::Exe, Some(PathBuf::from(\"/some/thing\")))]);\n         v3.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n \n         assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n@@ -2403,24 +2569,36 @@ mod tests {\n         let mut v3 = super::basic_options();\n \n         v1.externs = Externs::new(mk_map(vec![\n-            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n-                                            String::from(\"c\")])),\n-            (String::from(\"d\"), mk_set(vec![String::from(\"e\"),\n-                                            String::from(\"f\")])),\n+            (\n+                String::from(\"a\"),\n+                mk_set(vec![String::from(\"b\"), String::from(\"c\")]),\n+            ),\n+            (\n+                String::from(\"d\"),\n+                mk_set(vec![String::from(\"e\"), String::from(\"f\")]),\n+            ),\n         ]));\n \n         v2.externs = Externs::new(mk_map(vec![\n-            (String::from(\"d\"), mk_set(vec![String::from(\"e\"),\n-                                            String::from(\"f\")])),\n-            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n-                                            String::from(\"c\")])),\n+            (\n+                String::from(\"d\"),\n+                mk_set(vec![String::from(\"e\"), String::from(\"f\")]),\n+            ),\n+            (\n+                String::from(\"a\"),\n+                mk_set(vec![String::from(\"b\"), String::from(\"c\")]),\n+            ),\n         ]));\n \n         v3.externs = Externs::new(mk_map(vec![\n-            (String::from(\"a\"), mk_set(vec![String::from(\"b\"),\n-                                            String::from(\"c\")])),\n-            (String::from(\"d\"), mk_set(vec![String::from(\"f\"),\n-                                            String::from(\"e\")])),\n+            (\n+                String::from(\"a\"),\n+                mk_set(vec![String::from(\"b\"), String::from(\"c\")]),\n+            ),\n+            (\n+                String::from(\"d\"),\n+                mk_set(vec![String::from(\"f\"), String::from(\"e\")]),\n+            ),\n         ]));\n \n         assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n@@ -2439,20 +2617,26 @@ mod tests {\n         let mut v2 = super::basic_options();\n         let mut v3 = super::basic_options();\n \n-        v1.lint_opts = vec![(String::from(\"a\"), lint::Allow),\n-                            (String::from(\"b\"), lint::Warn),\n-                            (String::from(\"c\"), lint::Deny),\n-                            (String::from(\"d\"), lint::Forbid)];\n-\n-        v2.lint_opts = vec![(String::from(\"a\"), lint::Allow),\n-                            (String::from(\"b\"), lint::Warn),\n-                            (String::from(\"X\"), lint::Deny),\n-                            (String::from(\"d\"), lint::Forbid)];\n-\n-        v3.lint_opts = vec![(String::from(\"a\"), lint::Allow),\n-                            (String::from(\"b\"), lint::Warn),\n-                            (String::from(\"c\"), lint::Forbid),\n-                            (String::from(\"d\"), lint::Deny)];\n+        v1.lint_opts = vec![\n+            (String::from(\"a\"), lint::Allow),\n+            (String::from(\"b\"), lint::Warn),\n+            (String::from(\"c\"), lint::Deny),\n+            (String::from(\"d\"), lint::Forbid),\n+        ];\n+\n+        v2.lint_opts = vec![\n+            (String::from(\"a\"), lint::Allow),\n+            (String::from(\"b\"), lint::Warn),\n+            (String::from(\"X\"), lint::Deny),\n+            (String::from(\"d\"), lint::Forbid),\n+        ];\n+\n+        v3.lint_opts = vec![\n+            (String::from(\"a\"), lint::Allow),\n+            (String::from(\"b\"), lint::Warn),\n+            (String::from(\"c\"), lint::Forbid),\n+            (String::from(\"d\"), lint::Deny),\n+        ];\n \n         assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n         assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n@@ -2469,15 +2653,19 @@ mod tests {\n         let mut v1 = super::basic_options();\n         let mut v2 = super::basic_options();\n \n-        v1.lint_opts = vec![(String::from(\"a\"), lint::Allow),\n-                            (String::from(\"b\"), lint::Warn),\n-                            (String::from(\"c\"), lint::Deny),\n-                            (String::from(\"d\"), lint::Forbid)];\n+        v1.lint_opts = vec![\n+            (String::from(\"a\"), lint::Allow),\n+            (String::from(\"b\"), lint::Warn),\n+            (String::from(\"c\"), lint::Deny),\n+            (String::from(\"d\"), lint::Forbid),\n+        ];\n \n-        v2.lint_opts = vec![(String::from(\"a\"), lint::Allow),\n-                            (String::from(\"c\"), lint::Deny),\n-                            (String::from(\"b\"), lint::Warn),\n-                            (String::from(\"d\"), lint::Forbid)];\n+        v2.lint_opts = vec![\n+            (String::from(\"a\"), lint::Allow),\n+            (String::from(\"c\"), lint::Deny),\n+            (String::from(\"b\"), lint::Warn),\n+            (String::from(\"d\"), lint::Forbid),\n+        ];\n \n         assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n \n@@ -2494,29 +2682,49 @@ mod tests {\n         let mut v4 = super::basic_options();\n \n         // Reference\n-        v1.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n-        v1.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n-        v1.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n-        v1.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n-        v1.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n-\n-        v2.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n-        v2.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n-        v2.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n-        v2.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n-        v2.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n-\n-        v3.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n-        v3.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n-        v3.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n-        v3.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n-        v3.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n-\n-        v4.search_paths.add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n-        v4.search_paths.add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n-        v4.search_paths.add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n-        v4.search_paths.add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n-        v4.search_paths.add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n+        v1.search_paths\n+            .add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n+        v1.search_paths\n+            .add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n+        v1.search_paths\n+            .add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n+        v1.search_paths\n+            .add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n+        v1.search_paths\n+            .add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n+\n+        v2.search_paths\n+            .add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n+        v2.search_paths\n+            .add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n+        v2.search_paths\n+            .add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n+        v2.search_paths\n+            .add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n+        v2.search_paths\n+            .add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n+\n+        v3.search_paths\n+            .add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n+        v3.search_paths\n+            .add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n+        v3.search_paths\n+            .add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n+        v3.search_paths\n+            .add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n+        v3.search_paths\n+            .add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n+\n+        v4.search_paths\n+            .add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n+        v4.search_paths\n+            .add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n+        v4.search_paths\n+            .add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n+        v4.search_paths\n+            .add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n+        v4.search_paths\n+            .add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n \n         assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n         assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n@@ -2537,24 +2745,36 @@ mod tests {\n         let mut v4 = super::basic_options();\n \n         // Reference\n-        v1.libs = vec![(String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-                       (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n-                       (String::from(\"c\"), None, Some(cstore::NativeUnknown))];\n+        v1.libs = vec![\n+            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+            (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+        ];\n \n         // Change label\n-        v2.libs = vec![(String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-                       (String::from(\"X\"), None, Some(cstore::NativeFramework)),\n-                       (String::from(\"c\"), None, Some(cstore::NativeUnknown))];\n+        v2.libs = vec![\n+            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+            (String::from(\"X\"), None, Some(cstore::NativeFramework)),\n+            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+        ];\n \n         // Change kind\n-        v3.libs = vec![(String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-                       (String::from(\"b\"), None, Some(cstore::NativeStatic)),\n-                       (String::from(\"c\"), None, Some(cstore::NativeUnknown))];\n+        v3.libs = vec![\n+            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+            (String::from(\"b\"), None, Some(cstore::NativeStatic)),\n+            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+        ];\n \n         // Change new-name\n-        v4.libs = vec![(String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-                       (String::from(\"b\"), Some(String::from(\"X\")), Some(cstore::NativeFramework)),\n-                       (String::from(\"c\"), None, Some(cstore::NativeUnknown))];\n+        v4.libs = vec![\n+            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+            (\n+                String::from(\"b\"),\n+                Some(String::from(\"X\")),\n+                Some(cstore::NativeFramework),\n+            ),\n+            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+        ];\n \n         assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n         assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n@@ -2574,17 +2794,23 @@ mod tests {\n         let mut v3 = super::basic_options();\n \n         // Reference\n-        v1.libs = vec![(String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-                       (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n-                       (String::from(\"c\"), None, Some(cstore::NativeUnknown))];\n-\n-        v2.libs = vec![(String::from(\"b\"), None, Some(cstore::NativeFramework)),\n-                       (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-                       (String::from(\"c\"), None, Some(cstore::NativeUnknown))];\n-\n-        v3.libs = vec![(String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-                       (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-                       (String::from(\"b\"), None, Some(cstore::NativeFramework))];\n+        v1.libs = vec![\n+            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+            (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+        ];\n+\n+        v2.libs = vec![\n+            (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+        ];\n+\n+        v3.libs = vec![\n+            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+            (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+        ];\n \n         assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n         assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n@@ -2623,8 +2849,7 @@ mod tests {\n         opts.cg.codegen_units = Some(42);\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n-        opts.cg.remark = super::SomePasses(vec![String::from(\"pass1\"),\n-                                                String::from(\"pass2\")]);\n+        opts.cg.remark = super::SomePasses(vec![String::from(\"pass1\"), String::from(\"pass2\")]);\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n         opts.cg.save_temps = true;\n@@ -2633,7 +2858,6 @@ mod tests {\n         opts.cg.incremental = Some(String::from(\"abc\"));\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n-\n         // Make sure changing a [TRACKED] option changes the hash\n         opts = reference.clone();\n         opts.cg.lto = Lto::Fat;"}, {"sha": "a355a1ca50137447453c940b82531dc994c1d442", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 378, "deletions": 266, "changes": 644, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -20,7 +20,7 @@ use lint::builtin::BuiltinLintDiagnostics;\n use middle::allocator::AllocatorKind;\n use middle::dependency_format;\n use session::search_paths::PathKind;\n-use session::config::{DebugInfoLevel, OutputType, Epoch};\n+use session::config::{DebugInfoLevel, Epoch, OutputType};\n use ty::tls;\n use util::nodemap::{FxHashMap, FxHashSet};\n use util::common::{duration_to_secs_str, ErrorReported};\n@@ -37,7 +37,7 @@ use syntax::parse;\n use syntax::parse::ParseSess;\n use syntax::{ast, codemap};\n use syntax::feature_gate::AttributeType;\n-use syntax_pos::{Span, MultiSpan};\n+use syntax_pos::{MultiSpan, Span};\n \n use rustc_back::{LinkerFlavor, PanicStrategy};\n use rustc_back::target::Target;\n@@ -87,7 +87,7 @@ pub struct Session {\n     pub plugin_attributes: RefCell<Vec<(String, AttributeType)>>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n-        /// The crate_disambiguator is constructed out of all the `-C metadata`\n+    /// The crate_disambiguator is constructed out of all the `-C metadata`\n     /// arguments passed to the compiler. Its value together with the crate-name\n     /// forms a unique global identifier for the crate. It is used to allow\n     /// multiple crates with the same name to coexist. See the\n@@ -141,7 +141,6 @@ pub struct Session {\n     out_of_fuel: Cell<bool>,\n \n     // The next two are public because the driver needs to read them.\n-\n     /// If -zprint-fuel=crate, Some(crate).\n     pub print_fuel_crate: Option<String>,\n     /// Always set to zero and incremented so that we can print fuel expended by a crate.\n@@ -175,7 +174,7 @@ enum DiagnosticBuilderMethod {\n     Note,\n     SpanNote,\n     SpanSuggestion(String), // suggestion\n-    // add more variants as needed to support one-time diagnostics\n+                            // add more variants as needed to support one-time diagnostics\n }\n \n /// Diagnostic message ID\u2014used by `Session.one_time_diagnostics` to avoid\n@@ -184,7 +183,7 @@ enum DiagnosticBuilderMethod {\n pub enum DiagnosticMessageId {\n     ErrorId(u16), // EXXXX error code as integer\n     LintId(lint::LintId),\n-    StabilityId(u32) // issue number\n+    StabilityId(u32), // issue number\n }\n \n impl From<&'static lint::Lint> for DiagnosticMessageId {\n@@ -201,33 +200,37 @@ impl Session {\n         }\n     }\n \n-    pub fn struct_span_warn<'a, S: Into<MultiSpan>>(&'a self,\n-                                                    sp: S,\n-                                                    msg: &str)\n-                                                    -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_warn<'a, S: Into<MultiSpan>>(\n+        &'a self,\n+        sp: S,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'a> {\n         self.diagnostic().struct_span_warn(sp, msg)\n     }\n-    pub fn struct_span_warn_with_code<'a, S: Into<MultiSpan>>(&'a self,\n-                                                              sp: S,\n-                                                              msg: &str,\n-                                                              code: DiagnosticId)\n-                                                              -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_warn_with_code<'a, S: Into<MultiSpan>>(\n+        &'a self,\n+        sp: S,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'a> {\n         self.diagnostic().struct_span_warn_with_code(sp, msg, code)\n     }\n-    pub fn struct_warn<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a>  {\n+    pub fn struct_warn<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n         self.diagnostic().struct_warn(msg)\n     }\n-    pub fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n-                                                   sp: S,\n-                                                   msg: &str)\n-                                                   -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_err<'a, S: Into<MultiSpan>>(\n+        &'a self,\n+        sp: S,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'a> {\n         self.diagnostic().struct_span_err(sp, msg)\n     }\n-    pub fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n-                                                             sp: S,\n-                                                             msg: &str,\n-                                                             code: DiagnosticId)\n-                                                             -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(\n+        &'a self,\n+        sp: S,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'a> {\n         self.diagnostic().struct_span_err_with_code(sp, msg, code)\n     }\n     // FIXME: This method should be removed (every error should have an associated error code).\n@@ -241,20 +244,22 @@ impl Session {\n     ) -> DiagnosticBuilder<'a> {\n         self.diagnostic().struct_err_with_code(msg, code)\n     }\n-    pub fn struct_span_fatal<'a, S: Into<MultiSpan>>(&'a self,\n-                                                     sp: S,\n-                                                     msg: &str)\n-                                                     -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_fatal<'a, S: Into<MultiSpan>>(\n+        &'a self,\n+        sp: S,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'a> {\n         self.diagnostic().struct_span_fatal(sp, msg)\n     }\n-    pub fn struct_span_fatal_with_code<'a, S: Into<MultiSpan>>(&'a self,\n-                                                               sp: S,\n-                                                               msg: &str,\n-                                                               code: DiagnosticId)\n-                                                               -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_fatal_with_code<'a, S: Into<MultiSpan>>(\n+        &'a self,\n+        sp: S,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'a> {\n         self.diagnostic().struct_span_fatal_with_code(sp, msg, code)\n     }\n-    pub fn struct_fatal<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a>  {\n+    pub fn struct_fatal<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n         self.diagnostic().struct_fatal(msg)\n     }\n \n@@ -267,7 +272,9 @@ impl Session {\n         msg: &str,\n         code: DiagnosticId,\n     ) -> ! {\n-        self.diagnostic().span_fatal_with_code(sp, msg, code).raise()\n+        self.diagnostic()\n+            .span_fatal_with_code(sp, msg, code)\n+            .raise()\n     }\n     pub fn fatal(&self, msg: &str) -> ! {\n         self.diagnostic().fatal(msg).raise()\n@@ -301,7 +308,8 @@ impl Session {\n         compile_result_from_err_count(self.err_count())\n     }\n     pub fn track_errors<F, T>(&self, f: F) -> Result<T, ErrorReported>\n-        where F: FnOnce() -> T\n+    where\n+        F: FnOnce() -> T,\n     {\n         let old_count = self.err_count();\n         let result = f();\n@@ -344,24 +352,31 @@ impl Session {\n         self.diagnostic().unimpl(msg)\n     }\n \n-    pub fn buffer_lint<S: Into<MultiSpan>>(&self,\n-                                           lint: &'static lint::Lint,\n-                                           id: ast::NodeId,\n-                                           sp: S,\n-                                           msg: &str) {\n+    pub fn buffer_lint<S: Into<MultiSpan>>(\n+        &self,\n+        lint: &'static lint::Lint,\n+        id: ast::NodeId,\n+        sp: S,\n+        msg: &str,\n+    ) {\n         match *self.buffered_lints.borrow_mut() {\n-            Some(ref mut buffer) => buffer.add_lint(lint, id, sp.into(),\n-                                                    msg, BuiltinLintDiagnostics::Normal),\n+            Some(ref mut buffer) => {\n+                buffer.add_lint(lint, id, sp.into(), msg, BuiltinLintDiagnostics::Normal)\n+            }\n             None => bug!(\"can't buffer lints after HIR lowering\"),\n         }\n     }\n \n-    pub fn buffer_lint_with_diagnostic<S: Into<MultiSpan>>(&self,\n-        lint: &'static lint::Lint, id: ast::NodeId, sp: S,\n-        msg: &str, diagnostic: BuiltinLintDiagnostics) {\n+    pub fn buffer_lint_with_diagnostic<S: Into<MultiSpan>>(\n+        &self,\n+        lint: &'static lint::Lint,\n+        id: ast::NodeId,\n+        sp: S,\n+        msg: &str,\n+        diagnostic: BuiltinLintDiagnostics,\n+    ) {\n         match *self.buffered_lints.borrow_mut() {\n-            Some(ref mut buffer) => buffer.add_lint(lint, id, sp.into(),\n-                                                    msg, diagnostic),\n+            Some(ref mut buffer) => buffer.add_lint(lint, id, sp.into(), msg, diagnostic),\n             None => bug!(\"can't buffer lints after HIR lowering\"),\n         }\n     }\n@@ -373,7 +388,7 @@ impl Session {\n             Some(next) => {\n                 self.next_node_id.set(ast::NodeId::new(next));\n             }\n-            None => bug!(\"Input too large, ran out of node ids!\")\n+            None => bug!(\"Input too large, ran out of node ids!\"),\n         }\n \n         id\n@@ -387,24 +402,27 @@ impl Session {\n \n     /// Analogous to calling methods on the given `DiagnosticBuilder`, but\n     /// deduplicates on lint ID, span (if any), and message for this `Session`\n-    fn diag_once<'a, 'b>(&'a self,\n-                         diag_builder: &'b mut DiagnosticBuilder<'a>,\n-                         method: DiagnosticBuilderMethod,\n-                         msg_id: DiagnosticMessageId,\n-                         message: &str,\n-                         span_maybe: Option<Span>) {\n-\n+    fn diag_once<'a, 'b>(\n+        &'a self,\n+        diag_builder: &'b mut DiagnosticBuilder<'a>,\n+        method: DiagnosticBuilderMethod,\n+        msg_id: DiagnosticMessageId,\n+        message: &str,\n+        span_maybe: Option<Span>,\n+    ) {\n         let id_span_message = (msg_id, span_maybe, message.to_owned());\n-        let fresh = self.one_time_diagnostics.borrow_mut().insert(id_span_message);\n+        let fresh = self.one_time_diagnostics\n+            .borrow_mut()\n+            .insert(id_span_message);\n         if fresh {\n             match method {\n                 DiagnosticBuilderMethod::Note => {\n                     diag_builder.note(message);\n-                },\n+                }\n                 DiagnosticBuilderMethod::SpanNote => {\n                     let span = span_maybe.expect(\"span_note needs a span\");\n                     diag_builder.span_note(span, message);\n-                },\n+                }\n                 DiagnosticBuilderMethod::SpanSuggestion(suggestion) => {\n                     let span = span_maybe.expect(\"span_suggestion needs a span\");\n                     diag_builder.span_suggestion(span, message, suggestion);\n@@ -413,37 +431,66 @@ impl Session {\n         }\n     }\n \n-    pub fn diag_span_note_once<'a, 'b>(&'a self,\n-                                       diag_builder: &'b mut DiagnosticBuilder<'a>,\n-                                       msg_id: DiagnosticMessageId, span: Span, message: &str) {\n-        self.diag_once(diag_builder, DiagnosticBuilderMethod::SpanNote,\n-                       msg_id, message, Some(span));\n-    }\n-\n-    pub fn diag_note_once<'a, 'b>(&'a self,\n-                                  diag_builder: &'b mut DiagnosticBuilder<'a>,\n-                                  msg_id: DiagnosticMessageId, message: &str) {\n-        self.diag_once(diag_builder, DiagnosticBuilderMethod::Note, msg_id, message, None);\n-    }\n-\n-    pub fn diag_span_suggestion_once<'a, 'b>(&'a self,\n-                                             diag_builder: &'b mut DiagnosticBuilder<'a>,\n-                                             msg_id: DiagnosticMessageId,\n-                                             span: Span,\n-                                             message: &str,\n-                                             suggestion: String) {\n-        self.diag_once(diag_builder, DiagnosticBuilderMethod::SpanSuggestion(suggestion),\n-                       msg_id, message, Some(span));\n+    pub fn diag_span_note_once<'a, 'b>(\n+        &'a self,\n+        diag_builder: &'b mut DiagnosticBuilder<'a>,\n+        msg_id: DiagnosticMessageId,\n+        span: Span,\n+        message: &str,\n+    ) {\n+        self.diag_once(\n+            diag_builder,\n+            DiagnosticBuilderMethod::SpanNote,\n+            msg_id,\n+            message,\n+            Some(span),\n+        );\n+    }\n+\n+    pub fn diag_note_once<'a, 'b>(\n+        &'a self,\n+        diag_builder: &'b mut DiagnosticBuilder<'a>,\n+        msg_id: DiagnosticMessageId,\n+        message: &str,\n+    ) {\n+        self.diag_once(\n+            diag_builder,\n+            DiagnosticBuilderMethod::Note,\n+            msg_id,\n+            message,\n+            None,\n+        );\n+    }\n+\n+    pub fn diag_span_suggestion_once<'a, 'b>(\n+        &'a self,\n+        diag_builder: &'b mut DiagnosticBuilder<'a>,\n+        msg_id: DiagnosticMessageId,\n+        span: Span,\n+        message: &str,\n+        suggestion: String,\n+    ) {\n+        self.diag_once(\n+            diag_builder,\n+            DiagnosticBuilderMethod::SpanSuggestion(suggestion),\n+            msg_id,\n+            message,\n+            Some(span),\n+        );\n     }\n \n     pub fn codemap<'a>(&'a self) -> &'a codemap::CodeMap {\n         self.parse_sess.codemap()\n     }\n-    pub fn verbose(&self) -> bool { self.opts.debugging_opts.verbose }\n-    pub fn time_passes(&self) -> bool { self.opts.debugging_opts.time_passes }\n+    pub fn verbose(&self) -> bool {\n+        self.opts.debugging_opts.verbose\n+    }\n+    pub fn time_passes(&self) -> bool {\n+        self.opts.debugging_opts.time_passes\n+    }\n     pub fn profile_queries(&self) -> bool {\n-        self.opts.debugging_opts.profile_queries ||\n-            self.opts.debugging_opts.profile_queries_and_keys\n+        self.opts.debugging_opts.profile_queries\n+            || self.opts.debugging_opts.profile_queries_and_keys\n     }\n     pub fn profile_queries_and_keys(&self) -> bool {\n         self.opts.debugging_opts.profile_queries_and_keys\n@@ -454,11 +501,21 @@ impl Session {\n     pub fn time_llvm_passes(&self) -> bool {\n         self.opts.debugging_opts.time_llvm_passes\n     }\n-    pub fn trans_stats(&self) -> bool { self.opts.debugging_opts.trans_stats }\n-    pub fn meta_stats(&self) -> bool { self.opts.debugging_opts.meta_stats }\n-    pub fn asm_comments(&self) -> bool { self.opts.debugging_opts.asm_comments }\n-    pub fn no_verify(&self) -> bool { self.opts.debugging_opts.no_verify }\n-    pub fn borrowck_stats(&self) -> bool { self.opts.debugging_opts.borrowck_stats }\n+    pub fn trans_stats(&self) -> bool {\n+        self.opts.debugging_opts.trans_stats\n+    }\n+    pub fn meta_stats(&self) -> bool {\n+        self.opts.debugging_opts.meta_stats\n+    }\n+    pub fn asm_comments(&self) -> bool {\n+        self.opts.debugging_opts.asm_comments\n+    }\n+    pub fn no_verify(&self) -> bool {\n+        self.opts.debugging_opts.no_verify\n+    }\n+    pub fn borrowck_stats(&self) -> bool {\n+        self.opts.debugging_opts.borrowck_stats\n+    }\n     pub fn print_llvm_passes(&self) -> bool {\n         self.opts.debugging_opts.print_llvm_passes\n     }\n@@ -481,28 +538,19 @@ impl Session {\n         *(self.features.borrow_mut()) = Some(features);\n     }\n \n-    /// If true, we should gather causal information during NLL\n-    /// checking. This will eventually be the normal thing, but right\n-    /// now it is too unoptimized.\n-    pub fn nll_dump_cause(&self) -> bool {\n-        self.opts.debugging_opts.nll_dump_cause\n-    }\n-\n     /// Calculates the flavor of LTO to use for this compilation.\n     pub fn lto(&self) -> config::Lto {\n         // If our target has codegen requirements ignore the command line\n         if self.target.target.options.requires_lto {\n-            return config::Lto::Fat\n+            return config::Lto::Fat;\n         }\n \n         // If the user specified something, return that. If they only said `-C\n         // lto` and we've for whatever reason forced off ThinLTO via the CLI,\n         // then ensure we can't use a ThinLTO.\n         match self.opts.cg.lto {\n             config::Lto::No => {}\n-            config::Lto::Yes if self.opts.cli_forced_thinlto_off => {\n-                return config::Lto::Fat\n-            }\n+            config::Lto::Yes if self.opts.cli_forced_thinlto_off => return config::Lto::Fat,\n             other => return other,\n         }\n \n@@ -515,28 +563,28 @@ impl Session {\n         // If processing command line options determined that we're incompatible\n         // with ThinLTO (e.g. `-C lto --emit llvm-ir`) then return that option.\n         if self.opts.cli_forced_thinlto_off {\n-            return config::Lto::No\n+            return config::Lto::No;\n         }\n \n         // If `-Z thinlto` specified process that, but note that this is mostly\n         // a deprecated option now that `-C lto=thin` exists.\n         if let Some(enabled) = self.opts.debugging_opts.thinlto {\n             if enabled {\n-                return config::Lto::ThinLocal\n+                return config::Lto::ThinLocal;\n             } else {\n-                return config::Lto::No\n+                return config::Lto::No;\n             }\n         }\n \n         // If there's only one codegen unit and LTO isn't enabled then there's\n         // no need for ThinLTO so just return false.\n         if self.codegen_units() == 1 {\n-            return config::Lto::No\n+            return config::Lto::No;\n         }\n \n         // Right now ThinLTO isn't compatible with incremental compilation.\n         if self.opts.incremental.is_some() {\n-            return config::Lto::No\n+            return config::Lto::No;\n         }\n \n         // Now we're in \"defaults\" territory. By default we enable ThinLTO for\n@@ -550,15 +598,23 @@ impl Session {\n     /// Returns the panic strategy for this compile session. If the user explicitly selected one\n     /// using '-C panic', use that, otherwise use the panic strategy defined by the target.\n     pub fn panic_strategy(&self) -> PanicStrategy {\n-        self.opts.cg.panic.unwrap_or(self.target.target.options.panic_strategy)\n+        self.opts\n+            .cg\n+            .panic\n+            .unwrap_or(self.target.target.options.panic_strategy)\n     }\n     pub fn linker_flavor(&self) -> LinkerFlavor {\n-        self.opts.debugging_opts.linker_flavor.unwrap_or(self.target.target.linker_flavor)\n+        self.opts\n+            .debugging_opts\n+            .linker_flavor\n+            .unwrap_or(self.target.target.linker_flavor)\n     }\n \n     pub fn fewer_names(&self) -> bool {\n-        let more_names = self.opts.output_types.contains_key(&OutputType::LlvmAssembly) ||\n-                         self.opts.output_types.contains_key(&OutputType::Bitcode);\n+        let more_names = self.opts\n+            .output_types\n+            .contains_key(&OutputType::LlvmAssembly)\n+            || self.opts.output_types.contains_key(&OutputType::Bitcode);\n         self.opts.debugging_opts.fewer_names || !more_names\n     }\n \n@@ -572,7 +628,9 @@ impl Session {\n         self.opts.debugging_opts.enable_nonzeroing_move_hints\n     }\n     pub fn overflow_checks(&self) -> bool {\n-        self.opts.cg.overflow_checks\n+        self.opts\n+            .cg\n+            .overflow_checks\n             .or(self.opts.debugging_opts.force_overflow_checks)\n             .unwrap_or(self.opts.debug_assertions)\n     }\n@@ -603,50 +661,59 @@ impl Session {\n     }\n \n     pub fn must_not_eliminate_frame_pointers(&self) -> bool {\n-        self.opts.debuginfo != DebugInfoLevel::NoDebugInfo ||\n-        !self.target.target.options.eliminate_frame_pointer\n+        self.opts.debuginfo != DebugInfoLevel::NoDebugInfo\n+            || !self.target.target.options.eliminate_frame_pointer\n     }\n \n     /// Returns the symbol name for the registrar function,\n     /// given the crate Svh and the function DefIndex.\n-    pub fn generate_plugin_registrar_symbol(&self,\n-                                            disambiguator: CrateDisambiguator)\n-                                            -> String {\n-        format!(\"__rustc_plugin_registrar_{}__\", disambiguator.to_fingerprint().to_hex())\n+    pub fn generate_plugin_registrar_symbol(&self, disambiguator: CrateDisambiguator) -> String {\n+        format!(\n+            \"__rustc_plugin_registrar_{}__\",\n+            disambiguator.to_fingerprint().to_hex()\n+        )\n     }\n \n-    pub fn generate_derive_registrar_symbol(&self,\n-                                            disambiguator: CrateDisambiguator)\n-                                            -> String {\n-        format!(\"__rustc_derive_registrar_{}__\", disambiguator.to_fingerprint().to_hex())\n+    pub fn generate_derive_registrar_symbol(&self, disambiguator: CrateDisambiguator) -> String {\n+        format!(\n+            \"__rustc_derive_registrar_{}__\",\n+            disambiguator.to_fingerprint().to_hex()\n+        )\n     }\n \n     pub fn sysroot<'a>(&'a self) -> &'a Path {\n         match self.opts.maybe_sysroot {\n-            Some (ref sysroot) => sysroot,\n-            None => self.default_sysroot.as_ref()\n-                        .expect(\"missing sysroot and default_sysroot in Session\")\n+            Some(ref sysroot) => sysroot,\n+            None => self.default_sysroot\n+                .as_ref()\n+                .expect(\"missing sysroot and default_sysroot in Session\"),\n         }\n     }\n     pub fn target_filesearch(&self, kind: PathKind) -> filesearch::FileSearch {\n-        filesearch::FileSearch::new(self.sysroot(),\n-                                    &self.opts.target_triple,\n-                                    &self.opts.search_paths,\n-                                    kind)\n+        filesearch::FileSearch::new(\n+            self.sysroot(),\n+            &self.opts.target_triple,\n+            &self.opts.search_paths,\n+            kind,\n+        )\n     }\n     pub fn host_filesearch(&self, kind: PathKind) -> filesearch::FileSearch {\n         filesearch::FileSearch::new(\n             self.sysroot(),\n             config::host_triple(),\n             &self.opts.search_paths,\n-            kind)\n+            kind,\n+        )\n     }\n \n     pub fn set_incr_session_load_dep_graph(&self, load: bool) {\n         let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n \n         match *incr_comp_session {\n-            IncrCompSession::Active { ref mut load_dep_graph, .. } => {\n+            IncrCompSession::Active {\n+                ref mut load_dep_graph,\n+                ..\n+            } => {\n                 *load_dep_graph = load;\n             }\n             _ => {}\n@@ -661,14 +728,20 @@ impl Session {\n         }\n     }\n \n-    pub fn init_incr_comp_session(&self,\n-                                  session_dir: PathBuf,\n-                                  lock_file: flock::Lock,\n-                                  load_dep_graph: bool) {\n+    pub fn init_incr_comp_session(\n+        &self,\n+        session_dir: PathBuf,\n+        lock_file: flock::Lock,\n+        load_dep_graph: bool,\n+    ) {\n         let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n \n-        if let IncrCompSession::NotInitialized = *incr_comp_session { } else {\n-            bug!(\"Trying to initialize IncrCompSession `{:?}`\", *incr_comp_session)\n+        if let IncrCompSession::NotInitialized = *incr_comp_session {\n+        } else {\n+            bug!(\n+                \"Trying to initialize IncrCompSession `{:?}`\",\n+                *incr_comp_session\n+            )\n         }\n \n         *incr_comp_session = IncrCompSession::Active {\n@@ -681,8 +754,12 @@ impl Session {\n     pub fn finalize_incr_comp_session(&self, new_directory_path: PathBuf) {\n         let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n \n-        if let IncrCompSession::Active { .. } = *incr_comp_session { } else {\n-            bug!(\"Trying to finalize IncrCompSession `{:?}`\", *incr_comp_session)\n+        if let IncrCompSession::Active { .. } = *incr_comp_session {\n+        } else {\n+            bug!(\n+                \"Trying to finalize IncrCompSession `{:?}`\",\n+                *incr_comp_session\n+            )\n         }\n \n         // Note: This will also drop the lock file, thus unlocking the directory\n@@ -695,35 +772,42 @@ impl Session {\n         let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n \n         let session_directory = match *incr_comp_session {\n-            IncrCompSession::Active { ref session_directory, .. } => {\n-                session_directory.clone()\n-            }\n+            IncrCompSession::Active {\n+                ref session_directory,\n+                ..\n+            } => session_directory.clone(),\n             IncrCompSession::InvalidBecauseOfErrors { .. } => return,\n-            _ => bug!(\"Trying to invalidate IncrCompSession `{:?}`\",\n-                      *incr_comp_session),\n+            _ => bug!(\n+                \"Trying to invalidate IncrCompSession `{:?}`\",\n+                *incr_comp_session\n+            ),\n         };\n \n         // Note: This will also drop the lock file, thus unlocking the directory\n-        *incr_comp_session = IncrCompSession::InvalidBecauseOfErrors {\n-            session_directory,\n-        };\n+        *incr_comp_session = IncrCompSession::InvalidBecauseOfErrors { session_directory };\n     }\n \n     pub fn incr_comp_session_dir(&self) -> cell::Ref<PathBuf> {\n         let incr_comp_session = self.incr_comp_session.borrow();\n-        cell::Ref::map(incr_comp_session, |incr_comp_session| {\n-            match *incr_comp_session {\n-                IncrCompSession::NotInitialized => {\n-                    bug!(\"Trying to get session directory from IncrCompSession `{:?}`\",\n-                        *incr_comp_session)\n+        cell::Ref::map(\n+            incr_comp_session,\n+            |incr_comp_session| match *incr_comp_session {\n+                IncrCompSession::NotInitialized => bug!(\n+                    \"Trying to get session directory from IncrCompSession `{:?}`\",\n+                    *incr_comp_session\n+                ),\n+                IncrCompSession::Active {\n+                    ref session_directory,\n+                    ..\n                 }\n-                IncrCompSession::Active { ref session_directory, .. } |\n-                IncrCompSession::Finalized { ref session_directory } |\n-                IncrCompSession::InvalidBecauseOfErrors { ref session_directory } => {\n-                    session_directory\n+                | IncrCompSession::Finalized {\n+                    ref session_directory,\n                 }\n-            }\n-        })\n+                | IncrCompSession::InvalidBecauseOfErrors {\n+                    ref session_directory,\n+                } => session_directory,\n+            },\n+        )\n     }\n \n     pub fn incr_comp_session_dir_opt(&self) -> Option<cell::Ref<PathBuf>> {\n@@ -735,25 +819,39 @@ impl Session {\n     }\n \n     pub fn print_perf_stats(&self) {\n-        println!(\"Total time spent computing SVHs:               {}\",\n-                 duration_to_secs_str(self.perf_stats.svh_time.get()));\n-        println!(\"Total time spent computing incr. comp. hashes: {}\",\n-                 duration_to_secs_str(self.perf_stats.incr_comp_hashes_time.get()));\n-        println!(\"Total number of incr. comp. hashes computed:   {}\",\n-                 self.perf_stats.incr_comp_hashes_count.get());\n-        println!(\"Total number of bytes hashed for incr. comp.:  {}\",\n-                 self.perf_stats.incr_comp_bytes_hashed.get());\n+        println!(\n+            \"Total time spent computing SVHs:               {}\",\n+            duration_to_secs_str(self.perf_stats.svh_time.get())\n+        );\n+        println!(\n+            \"Total time spent computing incr. comp. hashes: {}\",\n+            duration_to_secs_str(self.perf_stats.incr_comp_hashes_time.get())\n+        );\n+        println!(\n+            \"Total number of incr. comp. hashes computed:   {}\",\n+            self.perf_stats.incr_comp_hashes_count.get()\n+        );\n+        println!(\n+            \"Total number of bytes hashed for incr. comp.:  {}\",\n+            self.perf_stats.incr_comp_bytes_hashed.get()\n+        );\n         if self.perf_stats.incr_comp_hashes_count.get() != 0 {\n-            println!(\"Average bytes hashed per incr. comp. HIR node: {}\",\n-                    self.perf_stats.incr_comp_bytes_hashed.get() /\n-                    self.perf_stats.incr_comp_hashes_count.get());\n+            println!(\n+                \"Average bytes hashed per incr. comp. HIR node: {}\",\n+                self.perf_stats.incr_comp_bytes_hashed.get()\n+                    / self.perf_stats.incr_comp_hashes_count.get()\n+            );\n         } else {\n             println!(\"Average bytes hashed per incr. comp. HIR node: N/A\");\n         }\n-        println!(\"Total time spent computing symbol hashes:      {}\",\n-                 duration_to_secs_str(self.perf_stats.symbol_hash_time.get()));\n-        println!(\"Total time spent decoding DefPath tables:      {}\",\n-                 duration_to_secs_str(self.perf_stats.decode_def_path_tables_time.get()));\n+        println!(\n+            \"Total time spent computing symbol hashes:      {}\",\n+            duration_to_secs_str(self.perf_stats.symbol_hash_time.get())\n+        );\n+        println!(\n+            \"Total time spent decoding DefPath tables:      {}\",\n+            duration_to_secs_str(self.perf_stats.decode_def_path_tables_time.get())\n+        );\n     }\n \n     /// We want to know if we're allowed to do an optimization for crate foo from -z fuel=foo=n.\n@@ -768,15 +866,15 @@ impl Session {\n                     println!(\"optimization-fuel-exhausted: {}\", msg());\n                     self.out_of_fuel.set(true);\n                 } else if fuel > 0 {\n-                    self.optimization_fuel_limit.set(fuel-1);\n+                    self.optimization_fuel_limit.set(fuel - 1);\n                 }\n             }\n             _ => {}\n         }\n         match self.print_fuel_crate {\n-            Some(ref c) if c == crate_name=> {\n-                self.print_fuel.set(self.print_fuel.get()+1);\n-            },\n+            Some(ref c) if c == crate_name => {\n+                self.print_fuel.set(self.print_fuel.get() + 1);\n+            }\n             _ => {}\n         }\n         ret\n@@ -792,10 +890,10 @@ impl Session {\n     /// compilation\n     pub fn codegen_units(&self) -> usize {\n         if let Some(n) = self.opts.cli_forced_codegen_units {\n-            return n\n+            return n;\n         }\n         if let Some(n) = self.target.target.options.default_codegen_units {\n-            return n as usize\n+            return n as usize;\n         }\n \n         // Why is 16 codegen units the default all the time?\n@@ -865,29 +963,34 @@ impl Session {\n     }\n }\n \n-pub fn build_session(sopts: config::Options,\n-                     local_crate_source_file: Option<PathBuf>,\n-                     registry: errors::registry::Registry)\n-                     -> Session {\n+pub fn build_session(\n+    sopts: config::Options,\n+    local_crate_source_file: Option<PathBuf>,\n+    registry: errors::registry::Registry,\n+) -> Session {\n     let file_path_mapping = sopts.file_path_mapping();\n \n-    build_session_with_codemap(sopts,\n-                               local_crate_source_file,\n-                               registry,\n-                               Lrc::new(codemap::CodeMap::new(file_path_mapping)),\n-                               None)\n+    build_session_with_codemap(\n+        sopts,\n+        local_crate_source_file,\n+        registry,\n+        Lrc::new(codemap::CodeMap::new(file_path_mapping)),\n+        None,\n+    )\n }\n \n-pub fn build_session_with_codemap(sopts: config::Options,\n-                                  local_crate_source_file: Option<PathBuf>,\n-                                  registry: errors::registry::Registry,\n-                                  codemap: Lrc<codemap::CodeMap>,\n-                                  emitter_dest: Option<Box<dyn Write + Send>>)\n-                                  -> Session {\n+pub fn build_session_with_codemap(\n+    sopts: config::Options,\n+    local_crate_source_file: Option<PathBuf>,\n+    registry: errors::registry::Registry,\n+    codemap: Lrc<codemap::CodeMap>,\n+    emitter_dest: Option<Box<dyn Write + Send>>,\n+) -> Session {\n     // FIXME: This is not general enough to make the warning lint completely override\n     // normal diagnostic warnings, since the warning lint can also be denied and changed\n     // later via the source code.\n-    let warnings_allow = sopts.lint_opts\n+    let warnings_allow = sopts\n+        .lint_opts\n         .iter()\n         .filter(|&&(ref key, _)| *key == \"warnings\")\n         .map(|&(_, ref level)| *level == lint::Allow)\n@@ -901,87 +1004,96 @@ pub fn build_session_with_codemap(sopts: config::Options,\n \n     let external_macro_backtrace = sopts.debugging_opts.external_macro_backtrace;\n \n-    let emitter: Box<dyn Emitter> = match (sopts.error_format, emitter_dest) {\n-        (config::ErrorOutputType::HumanReadable(color_config), None) => {\n-            Box::new(EmitterWriter::stderr(color_config, Some(codemap.clone()),\n-                     false, sopts.debugging_opts.teach)\n-                     .ui_testing(sopts.debugging_opts.ui_testing))\n-        }\n-        (config::ErrorOutputType::HumanReadable(_), Some(dst)) => {\n-            Box::new(EmitterWriter::new(dst, Some(codemap.clone()),\n-                     false, false)\n-                     .ui_testing(sopts.debugging_opts.ui_testing))\n-        }\n-        (config::ErrorOutputType::Json(pretty), None) => {\n-            Box::new(JsonEmitter::stderr(Some(registry), codemap.clone(),\n-                     pretty, sopts.debugging_opts.approximate_suggestions)\n-                     .ui_testing(sopts.debugging_opts.ui_testing))\n-        }\n-        (config::ErrorOutputType::Json(pretty), Some(dst)) => {\n-            Box::new(JsonEmitter::new(dst, Some(registry), codemap.clone(),\n-                     pretty, sopts.debugging_opts.approximate_suggestions)\n-                     .ui_testing(sopts.debugging_opts.ui_testing))\n-        }\n-        (config::ErrorOutputType::Short(color_config), None) => {\n-            Box::new(EmitterWriter::stderr(color_config, Some(codemap.clone()), true, false))\n-        }\n-        (config::ErrorOutputType::Short(_), Some(dst)) => {\n-            Box::new(EmitterWriter::new(dst, Some(codemap.clone()), true, false))\n-        }\n-    };\n+    let emitter: Box<dyn Emitter> =\n+        match (sopts.error_format, emitter_dest) {\n+            (config::ErrorOutputType::HumanReadable(color_config), None) => Box::new(\n+                EmitterWriter::stderr(\n+                    color_config,\n+                    Some(codemap.clone()),\n+                    false,\n+                    sopts.debugging_opts.teach,\n+                ).ui_testing(sopts.debugging_opts.ui_testing),\n+            ),\n+            (config::ErrorOutputType::HumanReadable(_), Some(dst)) => Box::new(\n+                EmitterWriter::new(dst, Some(codemap.clone()), false, false)\n+                    .ui_testing(sopts.debugging_opts.ui_testing),\n+            ),\n+            (config::ErrorOutputType::Json(pretty), None) => Box::new(\n+                JsonEmitter::stderr(\n+                    Some(registry),\n+                    codemap.clone(),\n+                    pretty,\n+                    sopts.debugging_opts.approximate_suggestions,\n+                ).ui_testing(sopts.debugging_opts.ui_testing),\n+            ),\n+            (config::ErrorOutputType::Json(pretty), Some(dst)) => Box::new(\n+                JsonEmitter::new(\n+                    dst,\n+                    Some(registry),\n+                    codemap.clone(),\n+                    pretty,\n+                    sopts.debugging_opts.approximate_suggestions,\n+                ).ui_testing(sopts.debugging_opts.ui_testing),\n+            ),\n+            (config::ErrorOutputType::Short(color_config), None) => Box::new(\n+                EmitterWriter::stderr(color_config, Some(codemap.clone()), true, false),\n+            ),\n+            (config::ErrorOutputType::Short(_), Some(dst)) => {\n+                Box::new(EmitterWriter::new(dst, Some(codemap.clone()), true, false))\n+            }\n+        };\n \n-    let diagnostic_handler =\n-        errors::Handler::with_emitter_and_flags(\n-            emitter,\n-            errors::HandlerFlags {\n-                can_emit_warnings,\n-                treat_err_as_bug,\n-                external_macro_backtrace,\n-                .. Default::default()\n-            });\n+    let diagnostic_handler = errors::Handler::with_emitter_and_flags(\n+        emitter,\n+        errors::HandlerFlags {\n+            can_emit_warnings,\n+            treat_err_as_bug,\n+            external_macro_backtrace,\n+            ..Default::default()\n+        },\n+    );\n \n-    build_session_(sopts,\n-                   local_crate_source_file,\n-                   diagnostic_handler,\n-                   codemap)\n+    build_session_(sopts, local_crate_source_file, diagnostic_handler, codemap)\n }\n \n-pub fn build_session_(sopts: config::Options,\n-                      local_crate_source_file: Option<PathBuf>,\n-                      span_diagnostic: errors::Handler,\n-                      codemap: Lrc<codemap::CodeMap>)\n-                      -> Session {\n+pub fn build_session_(\n+    sopts: config::Options,\n+    local_crate_source_file: Option<PathBuf>,\n+    span_diagnostic: errors::Handler,\n+    codemap: Lrc<codemap::CodeMap>,\n+) -> Session {\n     let host = match Target::search(config::host_triple()) {\n         Ok(t) => t,\n         Err(e) => {\n-            span_diagnostic.fatal(&format!(\"Error loading host specification: {}\", e)).raise();\n+            span_diagnostic\n+                .fatal(&format!(\"Error loading host specification: {}\", e))\n+                .raise();\n         }\n     };\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n \n     let p_s = parse::ParseSess::with_span_handler(span_diagnostic, codemap);\n     let default_sysroot = match sopts.maybe_sysroot {\n         Some(_) => None,\n-        None => Some(filesearch::get_or_default_sysroot())\n+        None => Some(filesearch::get_or_default_sysroot()),\n     };\n \n     let file_path_mapping = sopts.file_path_mapping();\n \n-    let local_crate_source_file = local_crate_source_file.map(|path| {\n-        file_path_mapping.map_prefix(path).0\n-    });\n+    let local_crate_source_file =\n+        local_crate_source_file.map(|path| file_path_mapping.map_prefix(path).0);\n \n     let optimization_fuel_crate = sopts.debugging_opts.fuel.as_ref().map(|i| i.0.clone());\n-    let optimization_fuel_limit = Cell::new(sopts.debugging_opts.fuel.as_ref()\n-        .map(|i| i.1).unwrap_or(0));\n+    let optimization_fuel_limit =\n+        Cell::new(sopts.debugging_opts.fuel.as_ref().map(|i| i.1).unwrap_or(0));\n     let print_fuel_crate = sopts.debugging_opts.print_fuel.clone();\n     let print_fuel = Cell::new(0);\n \n     let working_dir = match env::current_dir() {\n         Ok(dir) => dir,\n-        Err(e) => {\n-            p_s.span_diagnostic.fatal(&format!(\"Current directory is invalid: {}\", e)).raise()\n-        }\n+        Err(e) => p_s.span_diagnostic\n+            .fatal(&format!(\"Current directory is invalid: {}\", e))\n+            .raise(),\n     };\n     let working_dir = file_path_mapping.map_prefix(working_dir);\n \n@@ -1090,15 +1202,11 @@ pub enum IncrCompSession {\n     },\n     /// This is the state after the session directory has been finalized. In this\n     /// state, the contents of the directory must not be modified any more.\n-    Finalized {\n-        session_directory: PathBuf,\n-    },\n+    Finalized { session_directory: PathBuf },\n     /// This is an error state that is reached when some compilation error has\n     /// occurred. It indicates that the contents of the session directory must\n     /// not be used, since they might be invalid.\n-    InvalidBecauseOfErrors {\n-        session_directory: PathBuf,\n-    }\n+    InvalidBecauseOfErrors { session_directory: PathBuf },\n }\n \n pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n@@ -1133,7 +1241,7 @@ pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n #[derive(Copy, Clone, Debug)]\n pub enum CompileIncomplete {\n     Stopped,\n-    Errored(ErrorReported)\n+    Errored(ErrorReported),\n }\n impl From<ErrorReported> for CompileIncomplete {\n     fn from(err: ErrorReported) -> CompileIncomplete {\n@@ -1160,23 +1268,27 @@ pub fn bug_fmt(file: &'static str, line: u32, args: fmt::Arguments) -> ! {\n \n #[cold]\n #[inline(never)]\n-pub fn span_bug_fmt<S: Into<MultiSpan>>(file: &'static str,\n-                                        line: u32,\n-                                        span: S,\n-                                        args: fmt::Arguments) -> ! {\n+pub fn span_bug_fmt<S: Into<MultiSpan>>(\n+    file: &'static str,\n+    line: u32,\n+    span: S,\n+    args: fmt::Arguments,\n+) -> ! {\n     opt_span_bug_fmt(file, line, Some(span), args);\n }\n \n-fn opt_span_bug_fmt<S: Into<MultiSpan>>(file: &'static str,\n-                                        line: u32,\n-                                        span: Option<S>,\n-                                        args: fmt::Arguments) -> ! {\n+fn opt_span_bug_fmt<S: Into<MultiSpan>>(\n+    file: &'static str,\n+    line: u32,\n+    span: Option<S>,\n+    args: fmt::Arguments,\n+) -> ! {\n     tls::with_opt(move |tcx| {\n         let msg = format!(\"{}:{}: {}\", file, line, args);\n         match (tcx, span) {\n             (Some(tcx), Some(span)) => tcx.sess.diagnostic().span_bug(span, &msg),\n             (Some(tcx), None) => tcx.sess.diagnostic().bug(&msg),\n-            (None, _) => panic!(msg)\n+            (None, _) => panic!(msg),\n         }\n     });\n     unreachable!();"}, {"sha": "77a3f138fe590ea5df544197c0ac95d73453ff20", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 42, "deletions": 37, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -124,6 +124,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n+        let tcx = self.tcx;\n         let value_msg = match self.describe_place(place) {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned(),\n@@ -132,7 +133,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned(),\n         };\n-        let mut err = self.tcx.cannot_move_when_borrowed(\n+        let mut err = tcx.cannot_move_when_borrowed(\n             span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             Origin::Mir,\n@@ -152,7 +153,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n-        let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n+        let tcx = self.tcx;\n+        let mut err = tcx.cannot_use_when_mutably_borrowed(\n             span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             self.retrieve_borrow_span(borrow),\n@@ -254,6 +256,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             .unwrap_or(issued_span);\n \n         let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n+        let tcx = self.tcx;\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n         let mut err = match (\n@@ -265,8 +268,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"mutable\",\n         ) {\n             (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt)\n-            | (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => self.tcx\n-                .cannot_reborrow_already_borrowed(\n+            | (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => {\n+                tcx.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     \"\",\n@@ -277,29 +280,32 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     \"\",\n                     end_issued_loan_span,\n                     Origin::Mir,\n-                ),\n+                )\n+            }\n \n-            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => self.tcx\n-                .cannot_mutably_borrow_multiply(\n+            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => {\n+                tcx.cannot_mutably_borrow_multiply(\n                     span,\n                     &desc_place,\n                     \"\",\n                     issued_span,\n                     \"\",\n                     end_issued_loan_span,\n                     Origin::Mir,\n-                ),\n+                )\n+            }\n \n-            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => self.tcx\n-                .cannot_uniquely_borrow_by_two_closures(\n+            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => {\n+                tcx.cannot_uniquely_borrow_by_two_closures(\n                     span,\n                     &desc_place,\n                     issued_span,\n                     end_issued_loan_span,\n                     Origin::Mir,\n-                ),\n+                )\n+            }\n \n-            (BorrowKind::Unique, _, _, _, _, _) => self.tcx.cannot_uniquely_borrow_by_one_closure(\n+            (BorrowKind::Unique, _, _, _, _, _) => tcx.cannot_uniquely_borrow_by_one_closure(\n                 span,\n                 &desc_place,\n                 \"\",\n@@ -310,8 +316,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 Origin::Mir,\n             ),\n \n-            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => self.tcx\n-                .cannot_reborrow_already_uniquely_borrowed(\n+            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => {\n+                tcx.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     &desc_place,\n                     \"\",\n@@ -320,10 +326,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     \"\",\n                     end_issued_loan_span,\n                     Origin::Mir,\n-                ),\n+                )\n+            }\n \n-            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => self.tcx\n-                .cannot_reborrow_already_uniquely_borrowed(\n+            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => {\n+                tcx.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     &desc_place,\n                     \"\",\n@@ -332,7 +339,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     \"\",\n                     end_issued_loan_span,\n                     Origin::Mir,\n-                ),\n+                )\n+            }\n \n             (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _) => unreachable!(),\n         };\n@@ -466,11 +474,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         _proper_span: Span,\n         end_span: Option<Span>,\n     ) {\n-        let mut err = self.tcx.path_does_not_live_long_enough(\n-            borrow_span,\n-            &format!(\"`{}`\", name),\n-            Origin::Mir,\n-        );\n+        let tcx = self.tcx;\n+        let mut err =\n+            tcx.path_does_not_live_long_enough(borrow_span, &format!(\"`{}`\", name), Origin::Mir);\n         err.span_label(borrow_span, \"borrowed value does not live long enough\");\n         err.span_label(\n             drop_span,\n@@ -493,9 +499,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         proper_span: Span,\n         end_span: Option<Span>,\n     ) {\n+        let tcx = self.tcx;\n         let mut err =\n-            self.tcx\n-                .path_does_not_live_long_enough(proper_span, \"borrowed value\", Origin::Mir);\n+            tcx.path_does_not_live_long_enough(proper_span, \"borrowed value\", Origin::Mir);\n         err.span_label(proper_span, \"temporary value does not live long enough\");\n         err.span_label(\n             drop_span,\n@@ -527,16 +533,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             context, name, scope_tree, borrow, drop_span, borrow_span\n         );\n \n-        let mut err = self.tcx.path_does_not_live_long_enough(\n-            borrow_span,\n-            &format!(\"`{}`\", name),\n-            Origin::Mir,\n-        );\n+        let tcx = self.tcx;\n+        let mut err =\n+            tcx.path_does_not_live_long_enough(borrow_span, &format!(\"`{}`\", name), Origin::Mir);\n         err.span_label(borrow_span, \"borrowed value does not live long enough\");\n         err.span_label(drop_span, \"borrowed value only lives until here\");\n \n-        if !self.tcx.nll() {\n-            self.tcx.note_and_explain_region(\n+        if !tcx.nll() {\n+            tcx.note_and_explain_region(\n                 scope_tree,\n                 &mut err,\n                 \"borrowed value must be valid for \",\n@@ -566,14 +570,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             context, scope_tree, borrow, drop_span, proper_span\n         );\n \n+        let tcx = self.tcx;\n         let mut err =\n-            self.tcx\n-                .path_does_not_live_long_enough(proper_span, \"borrowed value\", Origin::Mir);\n+            tcx.path_does_not_live_long_enough(proper_span, \"borrowed value\", Origin::Mir);\n         err.span_label(proper_span, \"temporary value does not live long enough\");\n         err.span_label(drop_span, \"temporary value only lives until here\");\n \n-        if !self.tcx.nll() {\n-            self.tcx.note_and_explain_region(\n+        if !tcx.nll() {\n+            tcx.note_and_explain_region(\n                 scope_tree,\n                 &mut err,\n                 \"borrowed value must be valid for \",\n@@ -592,7 +596,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, span): (&Place<'tcx>, Span),\n         loan: &BorrowData<'tcx>,\n     ) {\n-        let mut err = self.tcx.cannot_assign_to_borrowed(\n+        let tcx = self.tcx;\n+        let mut err = tcx.cannot_assign_to_borrowed(\n             span,\n             self.retrieve_borrow_span(loan),\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),"}, {"sha": "e51b16a3736181e681e834c7392bacdab0b1de2b", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 65, "deletions": 67, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -10,7 +10,7 @@\n \n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n-use borrow_check::nll::region_infer::RegionInferenceContext;\n+use borrow_check::nll::region_infer::{RegionCausalInfo, RegionInferenceContext};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n@@ -231,6 +231,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         access_place_error_reported: FxHashSet(),\n         reservation_error_reported: FxHashSet(),\n         nonlexical_regioncx: opt_regioncx.clone(),\n+        nonlexical_cause_info: None,\n     };\n \n     let borrows = Borrows::new(tcx, mir, opt_regioncx, def_id, body_id);\n@@ -311,6 +312,7 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// contains the results from region inference and lets us e.g.\n     /// find out which CFG points are contained in each borrow region.\n     nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n+    nonlexical_cause_info: Option<RegionCausalInfo>,\n }\n \n // Check that:\n@@ -337,9 +339,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n     ) {\n         debug!(\n             \"MirBorrowckCtxt::process_statement({:?}, {:?}): {}\",\n-            location,\n-            stmt,\n-            flow_state\n+            location, stmt, flow_state\n         );\n         let span = stmt.source_info.span;\n \n@@ -441,9 +441,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n         let loc = location;\n         debug!(\n             \"MirBorrowckCtxt::process_terminator({:?}, {:?}): {}\",\n-            location,\n-            term,\n-            flow_state\n+            location, term, flow_state\n         );\n         let span = term.source_info.span;\n \n@@ -582,8 +580,14 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             TerminatorKind::Goto { target: _ }\n             | TerminatorKind::Abort\n             | TerminatorKind::Unreachable\n-            | TerminatorKind::FalseEdges { real_target: _, imaginary_targets: _ }\n-            | TerminatorKind::FalseUnwind { real_target: _, unwind: _ } => {\n+            | TerminatorKind::FalseEdges {\n+                real_target: _,\n+                imaginary_targets: _,\n+            }\n+            | TerminatorKind::FalseUnwind {\n+                real_target: _,\n+                unwind: _,\n+            } => {\n                 // no data used, thus irrelevant to borrowck\n             }\n         }\n@@ -683,7 +687,8 @@ enum LocalMutationIsAllowed {\n \n struct AccessErrorsReported {\n     mutability_error: bool,\n-    #[allow(dead_code)] conflict_error: bool,\n+    #[allow(dead_code)]\n+    conflict_error: bool,\n }\n \n #[derive(Copy, Clone)]\n@@ -719,9 +724,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// allowed to be split into separate Reservation and\n     /// Activation phases.\n     fn allow_two_phase_borrow(&self, kind: BorrowKind) -> bool {\n-        self.tcx.two_phase_borrows() &&\n-            (kind.allows_two_phase_borrow() ||\n-             self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n+        self.tcx.two_phase_borrows()\n+            && (kind.allows_two_phase_borrow()\n+                || self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n     }\n \n     /// Invokes `access_place` as appropriate for dropping the value\n@@ -753,16 +758,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     let field_ty = gcx.normalize_associated_type_in_env(&field_ty, self.param_env);\n                     let place = drop_place.clone().field(Field::new(index), field_ty);\n \n-                    self.visit_terminator_drop(\n-                        loc,\n-                        term,\n-                        flow_state,\n-                        &place,\n-                        field_ty,\n-                        span,\n-                    );\n+                    self.visit_terminator_drop(loc, term, flow_state, &place, field_ty, span);\n                 }\n-            },\n+            }\n             _ => {\n                 // We have now refined the type of the value being\n                 // dropped (potentially) to just the type of a\n@@ -779,7 +777,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         flow_state,\n                     );\n                 }\n-            },\n+            }\n         }\n     }\n \n@@ -801,18 +799,25 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         if let Activation(_, borrow_index) = rw {\n             if self.reservation_error_reported.contains(&place_span.0) {\n-                debug!(\"skipping access_place for activation of invalid reservation \\\n-                     place: {:?} borrow_index: {:?}\", place_span.0, borrow_index);\n+                debug!(\n+                    \"skipping access_place for activation of invalid reservation \\\n+                     place: {:?} borrow_index: {:?}\",\n+                    place_span.0, borrow_index\n+                );\n                 return AccessErrorsReported {\n                     mutability_error: false,\n                     conflict_error: true,\n                 };\n             }\n         }\n \n-        if self.access_place_error_reported.contains(&(place_span.0.clone(), place_span.1)) {\n-            debug!(\"access_place: suppressing error place_span=`{:?}` kind=`{:?}`\",\n-                   place_span, kind);\n+        if self.access_place_error_reported\n+            .contains(&(place_span.0.clone(), place_span.1))\n+        {\n+            debug!(\n+                \"access_place: suppressing error place_span=`{:?}` kind=`{:?}`\",\n+                place_span, kind\n+            );\n             return AccessErrorsReported {\n                 mutability_error: false,\n                 conflict_error: true,\n@@ -825,9 +830,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             self.check_access_for_conflict(context, place_span, sd, rw, flow_state);\n \n         if conflict_error || mutability_error {\n-            debug!(\"access_place: logging error place_span=`{:?}` kind=`{:?}`\",\n-                   place_span, kind);\n-            self.access_place_error_reported.insert((place_span.0.clone(), place_span.1));\n+            debug!(\n+                \"access_place: logging error place_span=`{:?}` kind=`{:?}`\",\n+                place_span, kind\n+            );\n+            self.access_place_error_reported\n+                .insert((place_span.0.clone(), place_span.1));\n         }\n \n         AccessErrorsReported {\n@@ -875,8 +883,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut { .. }) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n-                    if this.allow_two_phase_borrow(borrow.kind) && index.is_reservation()\n-                    {\n+                    if this.allow_two_phase_borrow(borrow.kind) && index.is_reservation() {\n                         return Control::Continue;\n                     }\n \n@@ -915,15 +922,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 place_span.0\n                             );\n                             this.reservation_error_reported.insert(place_span.0.clone());\n-                        },\n+                        }\n                         Activation(_, activating) => {\n                             debug!(\n                                 \"observing check_place for activation of \\\n                                  borrow_index: {:?}\",\n                                 activating\n                             );\n-                        },\n-                        Read(..) | Write(..) => {},\n+                        }\n+                        Read(..) | Write(..) => {}\n                     }\n \n                     match kind {\n@@ -1210,11 +1217,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Reports an error if this is a borrow of local data.\n     /// This is called for all Yield statements on movable generators\n-    fn check_for_local_borrow(\n-        &mut self,\n-        borrow: &BorrowData<'tcx>,\n-        yield_span: Span)\n-    {\n+    fn check_for_local_borrow(&mut self, borrow: &BorrowData<'tcx>, yield_span: Span) {\n         fn borrow_of_local_data<'tcx>(place: &Place<'tcx>) -> bool {\n             match place {\n                 Place::Static(..) => false,\n@@ -1226,13 +1229,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         ProjectionElem::Deref => false,\n \n                         // For interior references and downcasts, find out if the base is local\n-                        ProjectionElem::Field(..) |\n-                        ProjectionElem::Index(..) |\n-                        ProjectionElem::ConstantIndex { .. } |\n-                        ProjectionElem::Subslice { .. } |\n-                        ProjectionElem::Downcast(..) => {\n-                            borrow_of_local_data(&proj.base)\n-                        }\n+                        ProjectionElem::Field(..)\n+                        | ProjectionElem::Index(..)\n+                        | ProjectionElem::ConstantIndex { .. }\n+                        | ProjectionElem::Subslice { .. }\n+                        | ProjectionElem::Downcast(..) => borrow_of_local_data(&proj.base),\n                     }\n                 }\n             }\n@@ -1241,9 +1242,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         debug!(\"check_for_local_borrow({:?})\", borrow);\n \n         if borrow_of_local_data(&borrow.borrowed_place) {\n-            self.tcx.cannot_borrow_across_generator_yield(self.retrieve_borrow_span(borrow),\n-                                                          yield_span,\n-                                                          Origin::Mir).emit();\n+            self.tcx\n+                .cannot_borrow_across_generator_yield(\n+                    self.retrieve_borrow_span(borrow),\n+                    yield_span,\n+                    Origin::Mir,\n+                )\n+                .emit();\n         }\n     }\n \n@@ -1531,9 +1536,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) -> bool {\n         debug!(\n             \"check_access_permissions({:?}, {:?}, {:?})\",\n-            place,\n-            kind,\n-            is_local_mutation_allowed\n+            place, kind, is_local_mutation_allowed\n         );\n         let mut error_reported = false;\n         match kind {\n@@ -1598,8 +1601,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         span,\n                         &format!(\n                             \"Accessing `{:?}` with the kind `{:?}` shouldn't be possible\",\n-                            place,\n-                            kind\n+                            place, kind\n                         ),\n                     );\n                 }\n@@ -1699,9 +1701,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             let decl = &self.mir.upvar_decls[field.index()];\n                             debug!(\n                                 \"decl.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n-                                decl,\n-                                is_local_mutation_allowed,\n-                                place\n+                                decl, is_local_mutation_allowed, place\n                             );\n                             match (decl.mutability, is_local_mutation_allowed) {\n                                 (Mutability::Not, LocalMutationIsAllowed::No)\n@@ -1722,7 +1722,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-\n     /// If this is a field projection, and the field is being projected from a closure type,\n     /// then returns the index of the field being projected. Note that this closure will always\n     /// be `self` in the current MIR, because that is the only time we directly access the fields\n@@ -1926,9 +1925,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) -> bool {\n         debug!(\n             \"places_conflict({:?},{:?},{:?})\",\n-            borrow_place,\n-            access_place,\n-            access\n+            borrow_place, access_place, access\n         );\n \n         // Return all the prefixes of `place` in reverse order, including\n@@ -1954,8 +1951,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let access_components = place_elements(access_place);\n         debug!(\n             \"places_conflict: components {:?} / {:?}\",\n-            borrow_components,\n-            access_components\n+            borrow_components, access_components\n         );\n \n         let borrow_components = borrow_components\n@@ -2161,8 +2157,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let borrowed = &data[i.borrow_index()];\n \n             if self.places_conflict(&borrowed.borrowed_place, place, access) {\n-                debug!(\"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n-                       i, borrowed, place, access);\n+                debug!(\n+                    \"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n+                    i, borrowed, place, access\n+                );\n                 let ctrl = op(self, i, borrowed);\n                 if ctrl == Control::Break {\n                     return;"}, {"sha": "4031bd5369da637b537017cdc730601e5a62e05f", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -18,19 +18,29 @@ use rustc_errors::DiagnosticBuilder;\n use util::liveness::{self, DefUse, LivenessMode};\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    /// Adds annotations to `err` explaining *why* the borrow contains the\n+    /// point from `context`. This is key for the \"3-point errors\"\n+    /// [described in the NLL RFC][d].\n+    ///\n+    /// [d]: https://rust-lang.github.io/rfcs/2094-nll.html#leveraging-intuition-framing-errors-in-terms-of-points\n     pub(in borrow_check) fn explain_why_borrow_contains_point(\n-        &self,\n+        &mut self,\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n         if let Some(regioncx) = &self.nonlexical_regioncx {\n-            if let Some(cause) = regioncx.why_region_contains_point(borrow.region, context.loc) {\n-                let mir = self.mir;\n+            let mir = self.mir;\n \n+            if self.nonlexical_cause_info.is_none() {\n+                self.nonlexical_cause_info = Some(regioncx.compute_causal_info(mir));\n+            }\n+\n+            let cause_info = self.nonlexical_cause_info.as_ref().unwrap();\n+            if let Some(cause) = cause_info.why_region_contains_point(borrow.region, context.loc) {\n                 match *cause.root_cause() {\n                     Cause::LiveVar(local, location) => {\n-                        match find_regular_use(&mir, regioncx, borrow, location, local) {\n+                        match find_regular_use(mir, regioncx, borrow, location, local) {\n                             Some(p) => {\n                                 err.span_label(\n                                     mir.source_info(p).span,\n@@ -48,9 +58,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     }\n \n                     Cause::DropVar(local, location) => {\n-                        match find_drop_use(&mir, regioncx, borrow, location, local) {\n+                        match find_drop_use(mir, regioncx, borrow, location, local) {\n                             Some(p) => {\n-                                let local_name = &mir.local_decls[local].name.unwrap();\n+                                let local_name = mir.local_decls[local].name.unwrap();\n \n                                 err.span_label(\n                                     mir.source_info(p).span,"}, {"sha": "66776a94ff01ff91a9b0c3b60a778214983d75a6", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -124,6 +124,10 @@ pub(crate) enum Cause {\n     },\n }\n \n+pub(crate) struct RegionCausalInfo {\n+    inferred_values: RegionValues,\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Constraint {\n     // NB. The ordering here is not significant for correctness, but\n@@ -250,16 +254,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .map(|origin| RegionDefinition::new(origin))\n             .collect();\n \n-        let nll_dump_cause = ty::tls::with(|tcx| tcx.sess.nll_dump_cause());\n-\n         let mut result = Self {\n             definitions,\n             elements: elements.clone(),\n-            liveness_constraints: RegionValues::new(\n-                elements,\n-                num_region_variables,\n-                TrackCauses(nll_dump_cause),\n-            ),\n+            liveness_constraints: RegionValues::new(elements, num_region_variables),\n             inferred_values: None,\n             constraints: Vec::new(),\n             type_tests: Vec::new(),\n@@ -348,17 +346,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         inferred_values.contains(r.to_region_vid(), p)\n     }\n \n-    /// Returns the *reason* that the region `r` contains the given point.\n-    pub(crate) fn why_region_contains_point<R>(&self, r: R, p: Location) -> Option<Rc<Cause>>\n-    where\n-        R: ToRegionVid,\n-    {\n-        let inferred_values = self.inferred_values\n-            .as_ref()\n-            .expect(\"region values not yet inferred\");\n-        inferred_values.cause(r.to_region_vid(), p)\n-    }\n-\n     /// Returns access to the value of `r` for debugging purposes.\n     pub(super) fn region_value_str(&self, r: RegionVid) -> String {\n         let inferred_values = self.inferred_values\n@@ -449,21 +436,33 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n+    /// Re-execute the region inference, this time tracking causal information.\n+    /// This is significantly slower, so it is done only when an error is being reported.\n+    pub(super) fn compute_causal_info(&self, mir: &Mir<'tcx>) -> RegionCausalInfo {\n+        let inferred_values = self.compute_region_values(mir, TrackCauses(true));\n+        RegionCausalInfo { inferred_values }\n+    }\n+\n     /// Propagate the region constraints: this will grow the values\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n     fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n-        debug!(\"propagate_constraints()\");\n-        debug!(\"propagate_constraints: constraints={:#?}\", {\n+        let inferred_values = self.compute_region_values(mir, TrackCauses(false));\n+        self.inferred_values = Some(inferred_values);\n+    }\n+\n+    fn compute_region_values(&self, mir: &Mir<'tcx>, track_causes: TrackCauses) -> RegionValues {\n+        debug!(\"compute_region_values()\");\n+        debug!(\"compute_region_values: constraints={:#?}\", {\n             let mut constraints: Vec<_> = self.constraints.iter().collect();\n             constraints.sort();\n             constraints\n         });\n \n         // The initial values for each region are derived from the liveness\n         // constraints we have accumulated.\n-        let mut inferred_values = self.liveness_constraints.clone();\n+        let mut inferred_values = self.liveness_constraints.duplicate(track_causes);\n \n         let dependency_map = self.build_dependency_map();\n \n@@ -507,7 +506,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             debug!(\"\\n\");\n         }\n \n-        self.inferred_values = Some(inferred_values);\n+        inferred_values\n     }\n \n     /// Builds up a map from each region variable X to a vector with the\n@@ -1097,6 +1096,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n }\n \n+impl RegionCausalInfo {\n+    /// Returns the *reason* that the region `r` contains the given point.\n+    pub(super) fn why_region_contains_point<R>(&self, r: R, p: Location) -> Option<Rc<Cause>>\n+    where\n+        R: ToRegionVid,\n+    {\n+        self.inferred_values.cause(r.to_region_vid(), p)\n+    }\n+}\n+\n impl<'tcx> RegionDefinition<'tcx> {\n     fn new(origin: RegionVariableOrigin) -> Self {\n         // Create a new region definition. Note that, for free"}, {"sha": "2f0b4c24bd6f14ca8aef242511a95c13e3ba53b9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -184,7 +184,6 @@ impl ToElementIndex for RegionElementIndex {\n /// compact `SparseBitMatrix` representation, with one row per region\n /// variable. The columns consist of either universal regions or\n /// points in the CFG.\n-#[derive(Clone)]\n pub(super) struct RegionValues {\n     elements: Rc<RegionValueElements>,\n     matrix: SparseBitMatrix<RegionVid, RegionElementIndex>,\n@@ -199,11 +198,10 @@ pub(super) struct RegionValues {\n type CauseMap = FxHashMap<(RegionVid, RegionElementIndex), Rc<Cause>>;\n \n impl RegionValues {\n-    pub(super) fn new(\n-        elements: &Rc<RegionValueElements>,\n-        num_region_variables: usize,\n-        track_causes: TrackCauses,\n-    ) -> Self {\n+    /// Creates a new set of \"region values\" that tracks causal information.\n+    /// Each of the regions in num_region_variables will be initialized with an\n+    /// empty set of points and no causal information.\n+    pub(super) fn new(elements: &Rc<RegionValueElements>, num_region_variables: usize) -> Self {\n         assert!(\n             elements.num_universal_regions <= num_region_variables,\n             \"universal regions are a subset of the region variables\"\n@@ -215,8 +213,22 @@ impl RegionValues {\n                 RegionVid::new(num_region_variables),\n                 RegionElementIndex::new(elements.num_elements()),\n             ),\n+            causes: Some(CauseMap::default()),\n+        }\n+    }\n+\n+    /// Duplicates the region values. If track_causes is false, then the\n+    /// resulting value will not track causal information (and any existing\n+    /// causal information is dropped). Otherwise, the causal information is\n+    /// preserved and maintained. Tracking the causal information makes region\n+    /// propagation significantly slower, so we prefer not to do it until an\n+    /// error is reported.\n+    pub(super) fn duplicate(&self, track_causes: TrackCauses) -> Self {\n+        Self {\n+            elements: self.elements.clone(),\n+            matrix: self.matrix.clone(),\n             causes: if track_causes.0 {\n-                Some(CauseMap::default())\n+                self.causes.clone()\n             } else {\n                 None\n             },"}, {"sha": "bec91f7f70dee9d86e5568302f49656e8e054451", "filename": "src/test/ui/issue-45157.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fissue-45157.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fissue-45157.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-45157.stderr?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -6,6 +6,9 @@ LL |         let mref = &mut u.s.a;\n ...\n LL |         let nref = &u.z.c;\n    |                    ^^^^^^ immutable borrow occurs here\n+LL |         //~^ ERROR cannot borrow `u.z.c` as immutable because it is also borrowed as mutable [E0502]\n+LL |         println!(\"{} {}\", mref, nref)\n+   |                           ---- borrow later used here\n \n error[E0502]: cannot borrow `u.s.a` as mutable because it is also borrowed as immutable\n   --> $DIR/issue-45157.rs:39:27\n@@ -14,7 +17,9 @@ LL |         let nref = &u.z.c;\n    |                    ------ immutable borrow occurs here\n LL |         //~^ ERROR cannot borrow `u.z.c` as immutable because it is also borrowed as mutable [E0502]\n LL |         println!(\"{} {}\", mref, nref)\n-   |                           ^^^^ mutable borrow occurs here\n+   |                           ^^^^  ---- borrow later used here\n+   |                           |\n+   |                           mutable borrow occurs here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "084d0c159ef3953ec99664a0ec515bbe95c0c4a1", "filename": "src/test/ui/nll/borrowed-local-error.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-local-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-local-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-local-error.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Znll-dump-cause\n-\n #![feature(nll)]\n \n fn gimme(x: &(u32,)) -> &u32 {"}, {"sha": "24964f651f79d47e51d352d309e3cc3e7557d890", "filename": "src/test/ui/nll/borrowed-local-error.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-local-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-local-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-local-error.stderr?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -1,5 +1,5 @@\n error[E0597]: `v` does not live long enough\n-  --> $DIR/borrowed-local-error.rs:22:9\n+  --> $DIR/borrowed-local-error.rs:20:9\n    |\n LL |       let x = gimme({\n    |  _____________-"}, {"sha": "a80bc686e34aa80a8668164e479a04b007e8d121", "filename": "src/test/ui/nll/borrowed-match-issue-45045.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-match-issue-45045.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-match-issue-45045.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-match-issue-45045.stderr?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -10,6 +10,8 @@ LL | |         //~^ cannot use `e` because it was mutably borrowed [E0503]\n LL | |         Xyz::B => println!(\"b\"),\n LL | |     };\n    | |_____^ use of borrowed `e`\n+LL |       *g = Xyz::B;\n+   |       ----------- borrow later used here\n \n error[E0503]: cannot use `e` because it was mutably borrowed\n   --> $DIR/borrowed-match-issue-45045.rs:25:9\n@@ -19,6 +21,9 @@ LL |     let f = &mut e;\n ...\n LL |         Xyz::A => println!(\"a\"),\n    |         ^^^^^^ use of borrowed `e`\n+...\n+LL |     *g = Xyz::B;\n+   |     ----------- borrow later used here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "675f85ecb4dd2ed78741d6ec92e96e94eb61fab3", "filename": "src/test/ui/nll/borrowed-referent-issue-38899.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-referent-issue-38899.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-referent-issue-38899.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-referent-issue-38899.stderr?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -6,6 +6,9 @@ LL |     let x = &mut block;\n LL |     println!(\"{}\", x.current);\n LL |     let p: &'a u8 = &*block.current;\n    |                     ^^^^^^^^^^^^^^^ immutable borrow occurs here\n+LL |     //~^ ERROR cannot borrow `*block.current` as immutable because it is also borrowed as mutable\n+LL |     drop(x);\n+   |          - borrow later used here\n \n error: aborting due to previous error\n "}, {"sha": "7aad7205a52a192876ab4ab809d00aa6e8cd30c4", "filename": "src/test/ui/nll/borrowed-temporary-error.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-temporary-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-temporary-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-temporary-error.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Znll-dump-cause\n-\n #![feature(nll)]\n \n fn gimme(x: &(u32,)) -> &u32 {"}, {"sha": "575d9b5a62d7135f4a70af18c27f97c7d9ce4715", "filename": "src/test/ui/nll/borrowed-temporary-error.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-temporary-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-temporary-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-temporary-error.stderr?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -1,5 +1,5 @@\n error[E0597]: borrowed value does not live long enough\n-  --> $DIR/borrowed-temporary-error.rs:22:10\n+  --> $DIR/borrowed-temporary-error.rs:20:10\n    |\n LL |         &(v,)\n    |          ^^^^ temporary value does not live long enough"}, {"sha": "9a59cebfccbe2089e47ce430f22ed9fe26f8326f", "filename": "src/test/ui/nll/borrowed-universal-error-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Znll-dump-cause\n-\n #![feature(nll)]\n #![allow(warnings)]\n "}, {"sha": "2e4d7cc8f818d02ec6c53570b0e3c6f05ab4711a", "filename": "src/test/ui/nll/borrowed-universal-error-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -1,14 +1,14 @@\n error[E0597]: `v` does not live long enough\n-  --> $DIR/borrowed-universal-error-2.rs:18:5\n+  --> $DIR/borrowed-universal-error-2.rs:16:5\n    |\n LL |     &v\n    |     ^^ borrowed value does not live long enough\n LL |     //~^ ERROR `v` does not live long enough [E0597]\n LL | }\n    | - borrowed value only lives until here\n    |\n-note: borrowed value must be valid for the lifetime 'a as defined on the function body at 16:1...\n-  --> $DIR/borrowed-universal-error-2.rs:16:1\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 14:1...\n+  --> $DIR/borrowed-universal-error-2.rs:14:1\n    |\n LL | fn foo<'a>(x: &'a (u32,)) -> &'a u32 {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "9482b9b140002543fc9bd812d0271a4f223f2b30", "filename": "src/test/ui/nll/borrowed-universal-error.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Znll-dump-cause\n-\n #![feature(nll)]\n #![allow(warnings)]\n "}, {"sha": "3e9a3ceb1dba41bf7db1e38c02d587360defd225", "filename": "src/test/ui/nll/borrowed-universal-error.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error.stderr?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -1,14 +1,14 @@\n error[E0597]: borrowed value does not live long enough\n-  --> $DIR/borrowed-universal-error.rs:22:12\n+  --> $DIR/borrowed-universal-error.rs:20:12\n    |\n LL |     gimme(&(v,))\n    |            ^^^^ temporary value does not live long enough\n LL |     //~^ ERROR borrowed value does not live long enough [E0597]\n LL | }\n    | - temporary value only lives until here\n    |\n-note: borrowed value must be valid for the lifetime 'a as defined on the function body at 20:1...\n-  --> $DIR/borrowed-universal-error.rs:20:1\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 18:1...\n+  --> $DIR/borrowed-universal-error.rs:18:1\n    |\n LL | fn foo<'a>(x: &'a (u32,)) -> &'a u32 {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "f49e06bd9e8c8c340228af0a2799d5c8c27f5445", "filename": "src/test/ui/nll/capture-ref-in-struct.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll-dump-cause\n-\n // Test that a structure which tries to store a pointer to `y` into\n // `p` (indirectly) fails to compile.\n "}, {"sha": "0fb718075849c4d8c419fb1f998431bde3e527ec", "filename": "src/test/ui/nll/capture-ref-in-struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.stderr?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -1,5 +1,5 @@\n error[E0597]: `y` does not live long enough\n-  --> $DIR/capture-ref-in-struct.rs:33:16\n+  --> $DIR/capture-ref-in-struct.rs:31:16\n    |\n LL |             y: &y,\n    |                ^^ borrowed value does not live long enough"}, {"sha": "7e918c6431de4450e874558b91bee2001218119e", "filename": "src/test/ui/nll/closure-requirements/escape-argument.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -22,7 +22,7 @@\n // basically checking that the MIR type checker correctly enforces the\n // closure signature.\n \n-// compile-flags:-Znll -Zborrowck=mir -Znll-dump-cause -Zverbose\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n "}, {"sha": "05700ae00ad4f72900ad96f2cdec06474a528f22", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -15,7 +15,7 @@\n //\n // except that the closure does so via a second closure.\n \n-// compile-flags:-Znll -Zborrowck=mir -Znll-dump-cause -Zverbose\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n "}, {"sha": "93d8bfafcbaa4ffed82d2b0be51f828a7d2b679b", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -19,7 +19,7 @@\n // `'b`.  This relationship is propagated to the closure creator,\n // which reports an error.\n \n-// compile-flags:-Znll -Zborrowck=mir -Znll-dump-cause -Zverbose\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n "}, {"sha": "86653138a185f3652c1356bc318fb44bd36c3c95", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -78,6 +78,8 @@ LL |     let cell = Cell::new(&a);\n ...\n LL | }\n    | - borrowed value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3d9a5456cbb3666972e79e19cbda3513f513b9ec", "filename": "src/test/ui/nll/drop-no-may-dangle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fdrop-no-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fdrop-no-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fdrop-no-may-dangle.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -13,7 +13,7 @@\n // because of destructor. (Note that the stderr also identifies this\n // destructor in the error message.)\n \n-// compile-flags:-Znll -Zborrowck=mir -Znll-dump-cause\n+// compile-flags:-Znll -Zborrowck=mir\n \n #![allow(warnings)]\n #![feature(dropck_eyepatch)]"}, {"sha": "e5944e75e424177fad5749b7c110b00e7930d19b", "filename": "src/test/ui/nll/get_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -13,7 +13,7 @@\n // a variety of errors from the older, AST-based machinery (notably\n // borrowck), and then we get the NLL error at the end.\n \n-// compile-flags:-Znll -Zborrowck=compare -Znll-dump-cause\n+// compile-flags:-Znll -Zborrowck=compare\n \n struct Map {\n }"}, {"sha": "82c5e8dafdcedf5488e6dcadf2d2e93c88120b20", "filename": "src/test/ui/nll/guarantor-issue-46974.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fguarantor-issue-46974.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fguarantor-issue-46974.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fguarantor-issue-46974.stderr?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -6,6 +6,8 @@ LL |     let t = &mut *s; // this borrow should last for the entire function\n LL |     let x = &t.0;\n LL |     *s = (2,); //~ ERROR cannot assign to `*s`\n    |     ^^^^^^^^^ assignment to borrowed `*s` occurs here\n+LL |     *x\n+   |     -- borrow later used here\n \n error[E0621]: explicit lifetime required in the type of `s`\n   --> $DIR/guarantor-issue-46974.rs:25:5"}, {"sha": "d4df2a01c8143e97a6c4a30df74c8d30be74e158", "filename": "src/test/ui/nll/maybe-initialized-drop-implicit-fragment-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll -Znll-dump-cause\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Znll\n \n \n #![allow(warnings)]"}, {"sha": "2eb90dca7026ec2182d728b9d2c6e8ed7c2f0970", "filename": "src/test/ui/nll/maybe-initialized-drop-with-fragment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir -Znll -Znll-dump-cause\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Znll\n \n #![allow(warnings)]\n "}, {"sha": "f639d8f243f1423cfeb124a4bdd3267cd6f49b50", "filename": "src/test/ui/nll/maybe-initialized-drop-with-uninitialized-fragments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir -Znll -Znll-dump-cause\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Znll\n \n #![allow(warnings)]\n "}, {"sha": "c2cc479d28e3e78a12a69a2c098ad34449d71378", "filename": "src/test/ui/nll/maybe-initialized-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir -Znll -Znll-dump-cause\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Znll\n \n #![allow(warnings)]\n "}, {"sha": "2184beac99b668885b01bafff270c2b08bde8807", "filename": "src/test/ui/nll/return-ref-mut-issue-46557.stderr", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr?ref=d7f44ac52c06b3232dfe6b4fd542c17ce9c8da9e", "patch": "@@ -1,11 +1,16 @@\n error[E0597]: borrowed value does not live long enough\n   --> $DIR/return-ref-mut-issue-46557.rs:17:21\n    |\n-LL |     let ref mut x = 1234543; //~ ERROR borrowed value does not live long enough [E0597]\n-   |                     ^^^^^^^ temporary value does not live long enough\n-LL |     x\n-LL | }\n-   | - temporary value only lives until here\n+LL |   fn gimme_static_mut() -> &'static mut u32 {\n+   |  ___________________________________________-\n+LL | |     let ref mut x = 1234543; //~ ERROR borrowed value does not live long enough [E0597]\n+   | |                     ^^^^^^^ temporary value does not live long enough\n+LL | |     x\n+LL | | }\n+   | | -\n+   | | |\n+   | |_temporary value only lives until here\n+   |   borrow later used here\n \n error: aborting due to previous error\n "}]}