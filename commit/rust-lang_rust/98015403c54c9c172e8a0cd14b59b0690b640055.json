{"sha": "98015403c54c9c172e8a0cd14b59b0690b640055", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4MDE1NDAzYzU0YzljMTcyZThhMGNkMTRiNTliMDY5MGI2NDAwNTU=", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-02-03T01:21:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-03T01:21:09Z"}, "message": "Merge pull request #55 from miguelraz/min-panics\n\nimplement guards in rem and div unsound cases", "tree": {"sha": "23dd08e85ef6c29b85959f66ed5bc6422ae770b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23dd08e85ef6c29b85959f66ed5bc6422ae770b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98015403c54c9c172e8a0cd14b59b0690b640055", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgGfqFCRBK7hj4Ov3rIwAAdHIIACpHMDf8UNfU7CEuUijF1lqJ\nkRoEnweK4w6usNsLP2hmvOcNbq4OfwZIxX9ohN/zIJFJ6sJHXJllC62d0kpspUeZ\n+IbuqxBxG6vvFSP9mEbbYHZkxW6O+ZiNGh/ws3x8P+DxzM5jrm6xTwbxBLhbT9Pt\nbKYSGfgY3O3ajFudxpEaeTjzzUl01GtSvlXeyKQn17FjJ78iY94zF8dvbg3yFVKL\nufddgs2ovnwqTEHPJU3OSE8NPmLNDj4ITHceAZmUuvonOWS11iEp5KmY78jk4nVh\nb64Bx0dnyqT9uXkZa2q3NvgPxxs1uOUvQ0jN91JdOVA1E908fayOqPuR/5H5r+A=\n=PCTk\n-----END PGP SIGNATURE-----\n", "payload": "tree 23dd08e85ef6c29b85959f66ed5bc6422ae770b6\nparent 3717408093ca2e79a6cdc28ff9a4854e806e836b\nparent c67fc2e4c5cf062725458108042dd89d618bd8de\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1612315269 -0800\ncommitter GitHub <noreply@github.com> 1612315269 -0800\n\nMerge pull request #55 from miguelraz/min-panics\n\nimplement guards in rem and div unsound cases"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98015403c54c9c172e8a0cd14b59b0690b640055", "html_url": "https://github.com/rust-lang/rust/commit/98015403c54c9c172e8a0cd14b59b0690b640055", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98015403c54c9c172e8a0cd14b59b0690b640055/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3717408093ca2e79a6cdc28ff9a4854e806e836b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3717408093ca2e79a6cdc28ff9a4854e806e836b", "html_url": "https://github.com/rust-lang/rust/commit/3717408093ca2e79a6cdc28ff9a4854e806e836b"}, {"sha": "c67fc2e4c5cf062725458108042dd89d618bd8de", "url": "https://api.github.com/repos/rust-lang/rust/commits/c67fc2e4c5cf062725458108042dd89d618bd8de", "html_url": "https://github.com/rust-lang/rust/commit/c67fc2e4c5cf062725458108042dd89d618bd8de"}], "stats": {"total": 86, "additions": 84, "deletions": 2}, "files": [{"sha": "51e97757c54e58818e1e60bac1d9c16fa04718be", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/98015403c54c9c172e8a0cd14b59b0690b640055/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98015403c54c9c172e8a0cd14b59b0690b640055/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=98015403c54c9c172e8a0cd14b59b0690b640055", "patch": "@@ -283,13 +283,20 @@ macro_rules! impl_unsigned_int_ops {\n \n                         #[inline]\n                         fn div(self, rhs: Self) -> Self::Output {\n-                            // TODO there is probably a better way of doing this\n-                            if AsRef::<[$scalar]>::as_ref(&rhs)\n+                            if rhs.as_slice()\n                                 .iter()\n                                 .any(|x| *x == 0)\n                             {\n                                 panic!(\"attempt to divide by zero\");\n                             }\n+\n+                            // Guards for div(MIN, -1),\n+                            // this check only applies to signed ints\n+                            if <$scalar>::MIN != 0 && self.as_slice().iter()\n+                                    .zip(rhs.as_slice().iter())\n+                                    .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n+                                panic!(\"attempt to divide with overflow\");\n+                            }\n                             unsafe { crate::intrinsics::simd_div(self, rhs) }\n                         }\n                     }\n@@ -304,6 +311,11 @@ macro_rules! impl_unsigned_int_ops {\n                             if rhs == 0 {\n                                 panic!(\"attempt to divide by zero\");\n                             }\n+                            if <$scalar>::MIN != 0 &&\n+                                self.as_slice().iter().any(|x| *x == <$scalar>::MIN) &&\n+                                rhs == -1 as _ {\n+                                    panic!(\"attempt to divide with overflow\");\n+                            }\n                             let rhs = Self::splat(rhs);\n                             unsafe { crate::intrinsics::simd_div(self, rhs) }\n                         }\n@@ -353,6 +365,14 @@ macro_rules! impl_unsigned_int_ops {\n                             {\n                                 panic!(\"attempt to calculate the remainder with a divisor of zero\");\n                             }\n+\n+                            // Guards for rem(MIN, -1)\n+                            // this branch applies the check only to signed ints\n+                            if <$scalar>::MIN != 0 && self.as_slice().iter()\n+                                    .zip(rhs.as_slice().iter())\n+                                    .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n+                                panic!(\"attempt to calculate the remainder with overflow\");\n+                            }\n                             unsafe { crate::intrinsics::simd_rem(self, rhs) }\n                         }\n                     }\n@@ -367,6 +387,11 @@ macro_rules! impl_unsigned_int_ops {\n                             if rhs == 0 {\n                                 panic!(\"attempt to calculate the remainder with a divisor of zero\");\n                             }\n+                            if <$scalar>::MIN != 0 &&\n+                                self.as_slice().iter().any(|x| *x == <$scalar>::MIN) &&\n+                                rhs == -1 as _ {\n+                                    panic!(\"attempt to calculate the remainder with overflow\");\n+                            }\n                             let rhs = Self::splat(rhs);\n                             unsafe { crate::intrinsics::simd_rem(self, rhs) }\n                         }"}, {"sha": "43c75c6a9c4940af174c1457014456313c63903f", "filename": "crates/core_simd/tests/ops_impl/int_macros.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/98015403c54c9c172e8a0cd14b59b0690b640055/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98015403c54c9c172e8a0cd14b59b0690b640055/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fint_macros.rs?ref=98015403c54c9c172e8a0cd14b59b0690b640055", "patch": "@@ -228,6 +228,39 @@ macro_rules! int_tests {\n                 assert_biteq!(a, expected);\n             }\n \n+            #[test]\n+            #[should_panic]\n+            fn div_min_panics() {\n+                let a = from_slice(&vec![$scalar::MIN; 64]);\n+                let b = from_slice(&vec![-1; 64]);\n+                let _ = a / b;\n+            }\n+\n+            #[test]\n+            #[should_panic]\n+            fn div_by_all_zeros_panics() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&vec![0 ; 64]);\n+                let _ = a / b;\n+            }\n+\n+            #[test]\n+            #[should_panic]\n+            fn div_by_one_zero_panics() {\n+                let a = from_slice(&A);\n+                let mut b = from_slice(&B);\n+                b[0] = 0 as _;\n+                let _ = a / b;\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn div_min_neg_one_no_panic() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&vec![-1; 64]);\n+                let _ = a / b;\n+            }\n+\n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn rem() {\n@@ -275,6 +308,30 @@ macro_rules! int_tests {\n                 assert_biteq!(a, expected);\n             }\n \n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn rem_min_neg_one_no_panic() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&vec![-1; 64]);\n+                let _ = a % b;\n+            }\n+\n+            #[test]\n+            #[should_panic]\n+            fn rem_min_panic() {\n+                let a = from_slice(&vec![$scalar::MIN; 64]);\n+                let b = from_slice(&vec![-1 ; 64]);\n+                let _ = a % b;\n+            }\n+\n+            #[test]\n+            #[should_panic]\n+            fn rem_min_zero_panic() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&vec![0 ; 64]);\n+                let _ = a % b;\n+            }\n+\n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn bitand() {"}]}