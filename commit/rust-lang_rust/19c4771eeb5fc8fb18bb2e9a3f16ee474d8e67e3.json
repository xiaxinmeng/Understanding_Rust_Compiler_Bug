{"sha": "19c4771eeb5fc8fb18bb2e9a3f16ee474d8e67e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5YzQ3NzFlZWI1ZmM4ZmIxOGJiMmU5YTNmMTZlZTQ3NGQ4ZTY3ZTM=", "commit": {"author": {"name": "flip1995", "email": "uwdkn@student.kit.edu", "date": "2018-02-22T19:25:58Z"}, "committer": {"name": "flip1995", "email": "uwdkn@student.kit.edu", "date": "2018-03-01T00:34:25Z"}, "message": "Implementing requested changes", "tree": {"sha": "f503ca9de7c1fe115fcc2f3f186ed0b4943d5e9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f503ca9de7c1fe115fcc2f3f186ed0b4943d5e9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19c4771eeb5fc8fb18bb2e9a3f16ee474d8e67e3", "comment_count": 0, "verification": {"verified": false, "reason": "unverified_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEz66kzxK9mXB0K2lyZ1erJvcvAIQFAlqXSpEACgkQZ1erJvcv\nAIStwhAAlHiBV79AIr/6UFkZs1WLJy5yvn4im2RbHJDg5VHBeCCf3uy3KvOmQDGs\ntVwaTWlbEt1CNTJR8mrby9Y67TN7jDrf8m/68aDVE+O0H1DDToJbQrXbfwH0qYA5\nYeMx1xmK/8ThRJFD+VGe0YTz0BdZzqc34tdNv/ca91CgIYU3qVkwN99qOK1zyJRW\nmuV88JUEcSO/0b/G4iM89LrsLhQTb9BCX+yYrOUV5S8NN172PwTPLO2VpT9smkvG\n8SuBuVFlFDfkuEJvEsLP2lQdSjdgUwcbQiFD4IGY8Lx9CfwAGM4U/79/lsvnUWir\n+ukGqeIpeWPYuui3yAk6uSmxnVQj+OrdNmSdYrO7bEZD4h5TFiCk+NgGEOfLPMuz\nFphgyr1O23oKVcJZmMYt09BmGmHDPdNDMWDo3KFjW8U89Cy/1V2AOk4myqg/5iUK\nqqeRjlWcuqrWmuT8dJ1jDMqgUqaWvHVU0oH6Zddvlu/PZyJh7Xcv7xJ9KRdnAMR1\n0Uj18pL/3x5/l6cQvGLgp4VtIgAdcwEWH09mSSTkznWLRCN1sgvJ4dD8RFd1eBj6\nw2En781K5d5XTGxchCsZCrVOqwFh29fONbs9DTj15YfNfoO98RXkpcx/jASDjNKc\nIMDVCbQxYsE3XIlhTdm/1201fMBUoRHyudgQQ0l73TqSwgXDi6Y=\n=EQLX\n-----END PGP SIGNATURE-----", "payload": "tree f503ca9de7c1fe115fcc2f3f186ed0b4943d5e9e\nparent e822e62ee80a9108bfdb7d0952c85fab2146f569\nauthor flip1995 <uwdkn@student.kit.edu> 1519327558 +0100\ncommitter flip1995 <uwdkn@student.kit.edu> 1519864465 +0100\n\nImplementing requested changes\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19c4771eeb5fc8fb18bb2e9a3f16ee474d8e67e3", "html_url": "https://github.com/rust-lang/rust/commit/19c4771eeb5fc8fb18bb2e9a3f16ee474d8e67e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19c4771eeb5fc8fb18bb2e9a3f16ee474d8e67e3/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e822e62ee80a9108bfdb7d0952c85fab2146f569", "url": "https://api.github.com/repos/rust-lang/rust/commits/e822e62ee80a9108bfdb7d0952c85fab2146f569", "html_url": "https://github.com/rust-lang/rust/commit/e822e62ee80a9108bfdb7d0952c85fab2146f569"}], "stats": {"total": 141, "additions": 56, "deletions": 85}, "files": [{"sha": "db9dfedc656ba23d12d80c67163d1a3d0f6ae6e6", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 56, "deletions": 85, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/19c4771eeb5fc8fb18bb2e9a3f16ee474d8e67e3/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c4771eeb5fc8fb18bb2e9a3f16ee474d8e67e3/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=19c4771eeb5fc8fb18bb2e9a3f16ee474d8e67e3", "patch": "@@ -153,18 +153,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                 if (negative && v > max + 1) || (!negative && v > max) {\n                                     if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n                                         let bits = int_ty_bits(t, cx.sess().target.isize_ty);\n-                                        let mut actually = v as i128;\n-                                        if bits < 128 {\n-                                            // v & 0b0..01..1, |1| = bits\n-                                            let trimmed = v & ((1 << bits) - 1);\n-                                            actually = if v & (1 << (bits - 1)) == 0 {\n-                                                // positive\n-                                                trimmed as i128\n-                                            } else {\n-                                                // negative -> two's complement\n-                                                (((-1 as i128 as u128) << bits) | trimmed) as i128\n-                                            };\n-                                        }\n+                                        let actually =\n+                                            ((v << (128 - bits)) as i128) >> (128 - bits);\n                                         let mut err = cx.struct_span_lint(\n                                             OVERFLOWING_LITERALS,\n                                             e.span,\n@@ -175,15 +165,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                              an `{:?}` and will become `{}{:?}`.\",\n                                             repr_str, v, t, actually, t\n                                         ));\n-                                        let sugg_ty = get_fitting_type(\n+                                        let sugg_ty = get_type_suggestion(\n                                             &cx.tables.node_id_to_type(e.hir_id).sty,\n                                             v,\n                                             negative,\n-                                        ).map_or(String::new(), |ty| match ty {\n-                                            ty::TyUint(t) => format!(\"Consider using `{:?}`\", t),\n-                                            ty::TyInt(t) => format!(\"Consider using `{:?}`\", t),\n-                                            _ => String::new(),\n-                                        });\n+                                        );\n                                         if !sugg_ty.is_empty() {\n                                             err.help(&sugg_ty);\n                                         }\n@@ -221,24 +207,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                 if let hir::ExprCast(..) = parent_expr.node {\n                                     if let ty::TyChar = cx.tables.expr_ty(parent_expr).sty {\n                                         let mut err = cx.struct_span_lint(\n-                                            OVERFLOWING_LITERALS,\n-                                            parent_expr.span,\n-                                            \"only u8 can be casted into char\",\n-                                        );\n-                                        err.span_suggestion(\n-                                            parent_expr.span,\n-                                            &\"use a char literal instead\",\n-                                            format!(\"'\\\\u{{{:X}}}'\", lit_val),\n-                                        );\n+                                                             OVERFLOWING_LITERALS,\n+                                                             parent_expr.span,\n+                                                             \"only u8 can be casted into char\");\n+                                        err.span_suggestion(parent_expr.span,\n+                                                            &\"use a char literal instead\",\n+                                                            format!(\"'\\\\u{{{:X}}}'\", lit_val));\n                                         err.emit();\n-                                        return;\n+                                        return\n                                     }\n                                 }\n                             }\n                             if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n                                 let bits = uint_ty_bits(t, cx.sess().target.usize_ty);\n-                                // u128 cannot be greater than max -> compiler error\n-                                let actually = lit_val & ((1 << bits) - 1);\n+                                let actually = (lit_val << (128 - bits)) >> (128 - bits);\n                                 let mut err = cx.struct_span_lint(\n                                     OVERFLOWING_LITERALS,\n                                     e.span,\n@@ -249,19 +231,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                      an `{:?}` and will become `{}{:?}`.\",\n                                     repr_str, lit_val, t, actually, t\n                                 ));\n-                                let sugg_ty = get_fitting_type(\n+                                let sugg_ty = get_type_suggestion(\n                                     &cx.tables.node_id_to_type(e.hir_id).sty,\n                                     lit_val,\n                                     false,\n-                                ).map_or(\n-                                    String::new(),\n-                                    |ty| {\n-                                        if let ty::TyUint(t) = ty {\n-                                            format!(\"Consider using `{:?}`\", t)\n-                                        } else {\n-                                            String::new()\n-                                        }\n-                                    },\n                                 );\n                                 if !sugg_ty.is_empty() {\n                                     err.help(&sugg_ty);\n@@ -279,19 +252,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                     }\n                     ty::TyFloat(t) => {\n                         let is_infinite = match lit.node {\n-                            ast::LitKind::Float(v, _) | ast::LitKind::FloatUnsuffixed(v) => match t\n-                            {\n-                                ast::FloatTy::F32 => v.as_str().parse().map(f32::is_infinite),\n-                                ast::FloatTy::F64 => v.as_str().parse().map(f64::is_infinite),\n-                            },\n+                            ast::LitKind::Float(v, _) |\n+                            ast::LitKind::FloatUnsuffixed(v) => {\n+                                match t {\n+                                    ast::FloatTy::F32 => v.as_str().parse().map(f32::is_infinite),\n+                                    ast::FloatTy::F64 => v.as_str().parse().map(f64::is_infinite),\n+                                }\n+                            }\n                             _ => bug!(),\n                         };\n                         if is_infinite == Ok(true) {\n-                            cx.span_lint(\n-                                OVERFLOWING_LITERALS,\n-                                e.span,\n-                                &format!(\"literal out of range for {:?}\", t),\n-                            );\n+                            cx.span_lint(OVERFLOWING_LITERALS,\n+                                         e.span,\n+                                         &format!(\"literal out of range for {:?}\", t));\n                         }\n                     }\n                     _ => (),\n@@ -421,26 +394,27 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         }\n \n         fn get_bin_hex_repr(cx: &LateContext, lit: &ast::Lit) -> Option<String> {\n-            if let Some(src) = cx.sess().codemap().span_to_snippet(lit.span).ok() {\n-                if let Some(firstch) = src.chars().next() {\n-                    if let Some(0) = char::to_digit(firstch, 10) {\n-                        if let Some(base) = src.chars().nth(1) {\n-                            if base == 'x' || base == 'b' {\n-                                return Some(src);\n-                            }\n-                        }\n-                    }\n+            let src = cx.sess().codemap().span_to_snippet(lit.span).ok()?;\n+            let firstch = src.chars().next()?;\n+\n+            if let Some(0) = char::to_digit(firstch, 10) {\n+                match src.chars().nth(1) {\n+                    Some('x') | Some('b') => return Some(src),\n+                    _ => return None,\n                 }\n             }\n \n             None\n         }\n \n-        fn get_fitting_type<'a>(\n-            t: &ty::TypeVariants,\n-            val: u128,\n-            negative: bool,\n-        ) -> Option<ty::TypeVariants<'a>> {\n+        // This function finds the next fitting type and generates a suggestion string.\n+        // It searches for fitting types in the following way (`X < Y`):\n+        //  - `iX`: if literal fits in `uX` => `uX`, else => `iY`\n+        //  - `-iX` => `iY`\n+        //  - `uX` => `uY`\n+        //\n+        // No suggestion for: `isize`, `usize`.\n+        fn get_type_suggestion<'a>(t: &ty::TypeVariants, val: u128, negative: bool) -> String {\n             use syntax::ast::IntTy::*;\n             use syntax::ast::UintTy::*;\n             macro_rules! find_fit {\n@@ -451,36 +425,33 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                         match $ty {\n                             $($type => {\n                                 $(if !negative && val <= uint_ty_range($utypes).1 {\n-                                    return Some(ty::TyUint($utypes))\n+                                    return format!(\"Consider using `{:?}`\", $utypes)\n                                 })*\n                                 $(if val <= int_ty_range($itypes).1 as u128 + _neg {\n-                                    return Some(ty::TyInt($itypes))\n+                                    return format!(\"Consider using `{:?}`\", $itypes)\n                                 })*\n-                                None\n+                                String::new()\n                             },)*\n-                            _ => None\n+                            _ => String::new()\n                         }\n                     }\n                 }\n             }\n-            if let &ty::TyInt(i) = t {\n-                return find_fit!(i, val, negative,\n-                                 I8 => [U8] => [I16, I32, I64, I128],\n-                                 I16 => [U16] => [I32, I64, I128],\n-                                 I32 => [U32] => [I64, I128],\n-                                 I64 => [U64] => [I128],\n-                                 I128 => [U128] => []);\n-            }\n-            if let &ty::TyUint(u) = t {\n-                return find_fit!(u, val, negative,\n-                                 U8 => [U8, U16, U32, U64, U128] => [],\n-                                 U16 => [U16, U32, U64, U128] => [],\n-                                 U32 => [U32, U64, U128] => [],\n-                                 U64 => [U64, U128] => [],\n-                                 U128 => [U128] => []);\n+            match t {\n+                &ty::TyInt(i) => find_fit!(i, val, negative,\n+                              I8 => [U8] => [I16, I32, I64, I128],\n+                              I16 => [U16] => [I32, I64, I128],\n+                              I32 => [U32] => [I64, I128],\n+                              I64 => [U64] => [I128],\n+                              I128 => [U128] => []),\n+                &ty::TyUint(u) => find_fit!(u, val, negative,\n+                              U8 => [U8, U16, U32, U64, U128] => [],\n+                              U16 => [U16, U32, U64, U128] => [],\n+                              U32 => [U32, U64, U128] => [],\n+                              U64 => [U64, U128] => [],\n+                              U128 => [U128] => []),\n+                _ => String::new(),\n             }\n-\n-            None\n         }\n     }\n }"}]}