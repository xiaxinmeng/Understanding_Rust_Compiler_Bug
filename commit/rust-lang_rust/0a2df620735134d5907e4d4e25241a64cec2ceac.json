{"sha": "0a2df620735134d5907e4d4e25241a64cec2ceac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMmRmNjIwNzM1MTM0ZDU5MDdlNGQ0ZTI1MjQxYTY0Y2VjMmNlYWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-27T12:58:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-27T12:58:34Z"}, "message": "Auto merge of #69916 - oli-obk:mir_bless, r=eddyb\n\nEnable blessing of mir opt tests\n\ncc @rust-lang/wg-mir-opt\ncc @RalfJung\n\nLong overdue, but now you can finally just add a\n\n```rust\n// EMIT_MIR rustc.function_name.MirPassName.before.mir\n```\n\n(or `after.mir` since most of the time you want to know the MIR after a pass). A `--bless` invocation will automatically create the files for you.\n\nI suggest we do this for all mir opt tests that have all of the MIR in their source anyway\n\nIf you use `rustc.function.MirPass.diff` you only get the diff that the MIR pass causes on the MIR.\n\nFixes #67865", "tree": {"sha": "f2b2003d172a1b7b290c69afd98c378be34cfd64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2b2003d172a1b7b290c69afd98c378be34cfd64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a2df620735134d5907e4d4e25241a64cec2ceac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a2df620735134d5907e4d4e25241a64cec2ceac", "html_url": "https://github.com/rust-lang/rust/commit/0a2df620735134d5907e4d4e25241a64cec2ceac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a2df620735134d5907e4d4e25241a64cec2ceac/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "697d6b3f3fa1f163acb5ae0911d7df7f02a54444", "url": "https://api.github.com/repos/rust-lang/rust/commits/697d6b3f3fa1f163acb5ae0911d7df7f02a54444", "html_url": "https://github.com/rust-lang/rust/commit/697d6b3f3fa1f163acb5ae0911d7df7f02a54444"}, {"sha": "c9a5a03ffda14aaf505015b3b866c5a9f3cc6bf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9a5a03ffda14aaf505015b3b866c5a9f3cc6bf4", "html_url": "https://github.com/rust-lang/rust/commit/c9a5a03ffda14aaf505015b3b866c5a9f3cc6bf4"}], "stats": {"total": 1475, "additions": 1201, "deletions": 274}, "files": [{"sha": "652268dcee8842847167f78daec1cfe8ddbffa87", "filename": "src/librustc_data_structures/sorted_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Flibrustc_data_structures%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Flibrustc_data_structures%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map.rs?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -110,13 +110,13 @@ impl<K: Ord, V> SortedMap<K, V> {\n \n     /// Iterate over the keys, sorted\n     #[inline]\n-    pub fn keys(&self) -> impl Iterator<Item = &K> + ExactSizeIterator {\n+    pub fn keys(&self) -> impl Iterator<Item = &K> + ExactSizeIterator + DoubleEndedIterator {\n         self.data.iter().map(|&(ref k, _)| k)\n     }\n \n     /// Iterate over values, sorted by key\n     #[inline]\n-    pub fn values(&self) -> impl Iterator<Item = &V> + ExactSizeIterator {\n+    pub fn values(&self) -> impl Iterator<Item = &V> + ExactSizeIterator + DoubleEndedIterator {\n         self.data.iter().map(|&(_, ref v)| v)\n     }\n "}, {"sha": "4b68d74feb13770adf1c673ce59c4eceaf03990d", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 25, "deletions": 71, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -649,58 +649,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         &self,\n         allocs_seen: &mut FxHashSet<AllocId>,\n         allocs_to_print: &mut VecDeque<AllocId>,\n-        mut msg: String,\n         alloc: &Allocation<Tag, Extra>,\n-        extra: String,\n     ) {\n-        use std::fmt::Write;\n-\n-        let prefix_len = msg.len();\n-        let mut relocations = vec![];\n-\n-        for i in 0..alloc.size.bytes() {\n-            let i = Size::from_bytes(i);\n-            if let Some(&(_, target_id)) = alloc.relocations().get(&i) {\n-                if allocs_seen.insert(target_id) {\n-                    allocs_to_print.push_back(target_id);\n-                }\n-                relocations.push((i, target_id));\n-            }\n-            if alloc.undef_mask().is_range_defined(i, i + Size::from_bytes(1)).is_ok() {\n-                // this `as usize` is fine, since `i` came from a `usize`\n-                let i = i.bytes_usize();\n-\n-                // Checked definedness (and thus range) and relocations. This access also doesn't\n-                // influence interpreter execution but is only for debugging.\n-                let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(i..i + 1);\n-                write!(msg, \"{:02x} \", bytes[0]).unwrap();\n-            } else {\n-                msg.push_str(\"__ \");\n+        for &(_, (_, target_id)) in alloc.relocations().iter() {\n+            if allocs_seen.insert(target_id) {\n+                allocs_to_print.push_back(target_id);\n             }\n         }\n-\n-        eprintln!(\n-            \"{}({} bytes, alignment {}){}\",\n-            msg,\n-            alloc.size.bytes(),\n-            alloc.align.bytes(),\n-            extra\n-        );\n-\n-        if !relocations.is_empty() {\n-            msg.clear();\n-            write!(msg, \"{:1$}\", \"\", prefix_len).unwrap(); // Print spaces.\n-            let mut pos = Size::ZERO;\n-            let relocation_width = (self.pointer_size().bytes() - 1) * 3;\n-            for (i, target_id) in relocations {\n-                write!(msg, \"{:1$}\", \"\", ((i - pos) * 3).bytes_usize()).unwrap();\n-                let target = format!(\"({})\", target_id);\n-                // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n-                write!(msg, \"\u2514{0:\u2500^1$}\u2518 \", target, relocation_width as usize).unwrap();\n-                pos = i + self.pointer_size();\n-            }\n-            eprintln!(\"{}\", msg);\n-        }\n+        crate::util::pretty::write_allocation(self.tcx.tcx, alloc, &mut std::io::stderr(), \"\")\n+            .unwrap();\n     }\n \n     /// Print a list of allocations and all allocations they point to, recursively.\n@@ -713,45 +670,42 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let mut allocs_seen = FxHashSet::default();\n \n         while let Some(id) = allocs_to_print.pop_front() {\n-            let msg = format!(\"Alloc {:<5} \", format!(\"{}:\", id));\n+            eprint!(\"Alloc {:<5}: \", id);\n+            fn msg<Tag, Extra>(alloc: &Allocation<Tag, Extra>, extra: &str) {\n+                eprintln!(\n+                    \"({} bytes, alignment {}){}\",\n+                    alloc.size.bytes(),\n+                    alloc.align.bytes(),\n+                    extra\n+                )\n+            };\n \n             // normal alloc?\n             match self.alloc_map.get_or(id, || Err(())) {\n                 Ok((kind, alloc)) => {\n-                    let extra = match kind {\n-                        MemoryKind::Stack => \" (stack)\".to_owned(),\n-                        MemoryKind::Vtable => \" (vtable)\".to_owned(),\n-                        MemoryKind::CallerLocation => \" (caller_location)\".to_owned(),\n-                        MemoryKind::Machine(m) => format!(\" ({:?})\", m),\n+                    match kind {\n+                        MemoryKind::Stack => msg(alloc, \" (stack)\"),\n+                        MemoryKind::Vtable => msg(alloc, \" (vtable)\"),\n+                        MemoryKind::CallerLocation => msg(alloc, \" (caller_location)\"),\n+                        MemoryKind::Machine(m) => msg(alloc, &format!(\" ({:?})\", m)),\n                     };\n-                    self.dump_alloc_helper(\n-                        &mut allocs_seen,\n-                        &mut allocs_to_print,\n-                        msg,\n-                        alloc,\n-                        extra,\n-                    );\n+                    self.dump_alloc_helper(&mut allocs_seen, &mut allocs_to_print, alloc);\n                 }\n                 Err(()) => {\n                     // global alloc?\n                     match self.tcx.alloc_map.lock().get(id) {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n-                            self.dump_alloc_helper(\n-                                &mut allocs_seen,\n-                                &mut allocs_to_print,\n-                                msg,\n-                                alloc,\n-                                \" (immutable)\".to_owned(),\n-                            );\n+                            msg(alloc, \" (immutable)\");\n+                            self.dump_alloc_helper(&mut allocs_seen, &mut allocs_to_print, alloc);\n                         }\n                         Some(GlobalAlloc::Function(func)) => {\n-                            eprintln!(\"{} {}\", msg, func);\n+                            eprintln!(\"{}\", func);\n                         }\n                         Some(GlobalAlloc::Static(did)) => {\n-                            eprintln!(\"{} {:?}\", msg, did);\n+                            eprintln!(\"{:?}\", did);\n                         }\n                         None => {\n-                            eprintln!(\"{} (deallocated)\", msg);\n+                            eprintln!(\"(deallocated)\");\n                         }\n                     }\n                 }"}, {"sha": "0368a73832d75448e869f0aaa9ecbb0f42642f6a", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 262, "deletions": 20, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -1,11 +1,14 @@\n use super::graphviz::write_mir_fn_graphviz;\n use crate::transform::MirSource;\n+use either::Either;\n+use rustc::mir::interpret::{read_target_uint, AllocId, Allocation, ConstValue, GlobalAlloc};\n use rustc::mir::visit::Visitor;\n use rustc::mir::*;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, layout::Size, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_index::vec::Idx;\n+use std::collections::BTreeSet;\n use std::fmt::Display;\n use std::fmt::Write as _;\n use std::fs;\n@@ -77,20 +80,7 @@ pub fn dump_mir<'tcx, F>(\n         return;\n     }\n \n-    let node_path = ty::print::with_forced_impl_filename_line(|| {\n-        // see notes on #41697 below\n-        tcx.def_path_str(source.def_id())\n-    });\n-    dump_matched_mir_node(\n-        tcx,\n-        pass_num,\n-        pass_name,\n-        &node_path,\n-        disambiguator,\n-        source,\n-        body,\n-        extra_data,\n-    );\n+    dump_matched_mir_node(tcx, pass_num, pass_name, disambiguator, source, body, extra_data);\n }\n \n pub fn dump_enabled<'tcx>(tcx: TyCtxt<'tcx>, pass_name: &str, source: MirSource<'tcx>) -> bool {\n@@ -117,7 +107,6 @@ fn dump_matched_mir_node<'tcx, F>(\n     tcx: TyCtxt<'tcx>,\n     pass_num: Option<&dyn Display>,\n     pass_name: &str,\n-    node_path: &str,\n     disambiguator: &dyn Display,\n     source: MirSource<'tcx>,\n     body: &Body<'tcx>,\n@@ -127,10 +116,16 @@ fn dump_matched_mir_node<'tcx, F>(\n {\n     let _: io::Result<()> = try {\n         let mut file = create_dump_file(tcx, \"mir\", pass_num, pass_name, disambiguator, source)?;\n-        writeln!(file, \"// MIR for `{}`\", node_path)?;\n-        writeln!(file, \"// source = {:?}\", source)?;\n-        writeln!(file, \"// pass_name = {}\", pass_name)?;\n-        writeln!(file, \"// disambiguator = {}\", disambiguator)?;\n+        let def_path = ty::print::with_forced_impl_filename_line(|| {\n+            // see notes on #41697 above\n+            tcx.def_path_str(source.def_id())\n+        });\n+        write!(file, \"// MIR for `{}\", def_path)?;\n+        match source.promoted {\n+            None => write!(file, \"`\")?,\n+            Some(promoted) => write!(file, \"::{:?}`\", promoted)?,\n+        }\n+        writeln!(file, \" {} {}\", disambiguator, pass_name)?;\n         if let Some(ref layout) = body.generator_layout {\n             writeln!(file, \"// generator_layout = {:?}\", layout)?;\n         }\n@@ -276,6 +271,9 @@ where\n     }\n \n     writeln!(w, \"}}\")?;\n+\n+    write_allocations(tcx, body, w)?;\n+\n     Ok(())\n }\n \n@@ -534,6 +532,250 @@ pub fn write_mir_intro<'tcx>(\n     Ok(())\n }\n \n+/// Find all `AllocId`s mentioned (recursively) in the MIR body and print their corresponding\n+/// allocations.\n+pub fn write_allocations<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'_>,\n+    w: &mut dyn Write,\n+) -> io::Result<()> {\n+    fn alloc_ids_from_alloc(alloc: &Allocation) -> impl DoubleEndedIterator<Item = AllocId> + '_ {\n+        alloc.relocations().values().map(|(_, id)| *id)\n+    }\n+    fn alloc_ids_from_const(val: ConstValue<'_>) -> impl Iterator<Item = AllocId> + '_ {\n+        match val {\n+            ConstValue::Scalar(interpret::Scalar::Ptr(ptr)) => {\n+                Either::Left(Either::Left(std::iter::once(ptr.alloc_id)))\n+            }\n+            ConstValue::Scalar(interpret::Scalar::Raw { .. }) => {\n+                Either::Left(Either::Right(std::iter::empty()))\n+            }\n+            ConstValue::ByRef { alloc, .. } | ConstValue::Slice { data: alloc, .. } => {\n+                Either::Right(alloc_ids_from_alloc(alloc))\n+            }\n+        }\n+    }\n+    struct CollectAllocIds(BTreeSet<AllocId>);\n+    impl<'tcx> TypeVisitor<'tcx> for CollectAllocIds {\n+        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+            if let ty::ConstKind::Value(val) = c.val {\n+                self.0.extend(alloc_ids_from_const(val));\n+            }\n+            c.super_visit_with(self)\n+        }\n+    }\n+    let mut visitor = CollectAllocIds(Default::default());\n+    body.visit_with(&mut visitor);\n+    let mut seen = visitor.0;\n+    let mut todo: Vec<_> = seen.iter().copied().collect();\n+    while let Some(id) = todo.pop() {\n+        let mut write_header_and_allocation =\n+            |w: &mut dyn Write, alloc: &Allocation| -> io::Result<()> {\n+                write!(w, \"size: {}, align: {})\", alloc.size.bytes(), alloc.align.bytes())?;\n+                if alloc.size == Size::ZERO {\n+                    write!(w, \" {{}}\")?;\n+                } else {\n+                    writeln!(w, \" {{\")?;\n+                    write_allocation(tcx, alloc, w, \"    \")?;\n+                    write!(w, \"}}\")?;\n+                    // `.rev()` because we are popping them from the back of the `todo` vector.\n+                    for id in alloc_ids_from_alloc(alloc).rev() {\n+                        if seen.insert(id) {\n+                            todo.push(id);\n+                        }\n+                    }\n+                }\n+                Ok(())\n+            };\n+        write!(w, \"\\n{}\", id)?;\n+        let alloc = tcx.alloc_map.lock().get(id);\n+        match alloc {\n+            // This can't really happen unless there are bugs, but it doesn't cost us anything to\n+            // gracefully handle it and allow buggy rustc to be debugged via allocation printing.\n+            None => write!(w, \" (deallocated)\")?,\n+            Some(GlobalAlloc::Function(inst)) => write!(w, \" (fn: {})\", inst)?,\n+            Some(GlobalAlloc::Static(did)) if !tcx.is_foreign_item(did) => {\n+                match tcx.const_eval_poly(did) {\n+                    Ok(ConstValue::ByRef { alloc, .. }) => {\n+                        write!(w, \" (static: {}, \", tcx.def_path_str(did))?;\n+                        write_header_and_allocation(w, alloc)?;\n+                    }\n+                    Ok(_) => {\n+                        span_bug!(tcx.def_span(did), \" static item without `ByRef` initializer\")\n+                    }\n+                    Err(_) => write!(\n+                        w,\n+                        \" (static: {}, error during initializer evaluation)\",\n+                        tcx.def_path_str(did)\n+                    )?,\n+                }\n+            }\n+            Some(GlobalAlloc::Static(did)) => {\n+                write!(w, \" (extern static: {})\", tcx.def_path_str(did))?\n+            }\n+            Some(GlobalAlloc::Memory(alloc)) => {\n+                write!(w, \" (\")?;\n+                write_header_and_allocation(w, alloc)?\n+            }\n+        }\n+\n+        writeln!(w)?;\n+    }\n+    Ok(())\n+}\n+\n+fn write_allocation_endline(w: &mut dyn Write, ascii: &str) -> io::Result<()> {\n+    for _ in 0..(BYTES_PER_LINE - ascii.chars().count()) {\n+        write!(w, \"   \")?;\n+    }\n+    writeln!(w, \" \u2502 {}\", ascii)\n+}\n+\n+/// Number of bytes to print per allocation hex dump line.\n+const BYTES_PER_LINE: usize = 16;\n+\n+/// Prints the line start address and returns the new line start address.\n+fn write_allocation_newline(\n+    w: &mut dyn Write,\n+    mut line_start: Size,\n+    ascii: &str,\n+    pos_width: usize,\n+    prefix: &str,\n+) -> io::Result<Size> {\n+    write_allocation_endline(w, ascii)?;\n+    line_start += Size::from_bytes(BYTES_PER_LINE);\n+    write!(w, \"{}0x{:02$x} \u2502 \", prefix, line_start.bytes(), pos_width)?;\n+    Ok(line_start)\n+}\n+\n+/// Dumps the bytes of an allocation to the given writer. This also prints relocations instead of\n+/// the raw bytes where applicable.\n+/// The byte format is similar to how hex editors print bytes. Each line starts with the address of\n+/// the start of the line, followed by all bytes in hex format (space separated).\n+/// If the allocation is small enough to fit into a single line, no start address is given.\n+/// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n+/// characters or characters whose value is larger than 127) with a `.`\n+///\n+/// The `prefix` argument allows callers to add an arbitrary prefix before each line (even if there\n+/// is only one line). Note that your prefix should contain a trailing space as the lines are\n+/// printed directly after it.\n+pub fn write_allocation<Tag, Extra>(\n+    tcx: TyCtxt<'tcx>,\n+    alloc: &Allocation<Tag, Extra>,\n+    w: &mut dyn Write,\n+    prefix: &str,\n+) -> io::Result<()> {\n+    let num_lines = alloc.size.bytes_usize().saturating_sub(BYTES_PER_LINE);\n+    // Number of chars needed to represent all line numbers.\n+    let pos_width = format!(\"{:x}\", alloc.size.bytes()).len();\n+\n+    if num_lines > 0 {\n+        write!(w, \"{}0x{:02$x} \u2502 \", prefix, 0, pos_width)?;\n+    } else {\n+        write!(w, \"{}\", prefix)?;\n+    }\n+\n+    let mut i = Size::ZERO;\n+    let mut line_start = Size::ZERO;\n+\n+    let ptr_size = tcx.data_layout.pointer_size;\n+\n+    let mut ascii = String::new();\n+\n+    let oversized_ptr = |target: &mut String, width| {\n+        if target.len() > width {\n+            write!(target, \" ({} ptr bytes)\", ptr_size.bytes()).unwrap();\n+        }\n+    };\n+\n+    while i < alloc.size {\n+        // The line start already has a space. While we could remove that space from the line start\n+        // printing and unconditionally print a space here, that would cause the single-line case\n+        // to have a single space before it, which looks weird.\n+        if i != line_start {\n+            write!(w, \" \")?;\n+        }\n+        if let Some(&(_, target_id)) = alloc.relocations().get(&i) {\n+            // Memory with a relocation must be defined\n+            let j = i.bytes_usize();\n+            let offset =\n+                alloc.inspect_with_undef_and_ptr_outside_interpreter(j..j + ptr_size.bytes_usize());\n+            let offset = read_target_uint(tcx.data_layout.endian, offset).unwrap();\n+            let relocation_width = |bytes| bytes * 3;\n+            let mut target = format!(\"{}+{}\", target_id, offset);\n+            if ((i - line_start) + ptr_size).bytes_usize() > BYTES_PER_LINE {\n+                // This branch handles the situation where a relocation starts in the current line\n+                // but ends in the next one.\n+                let remainder = Size::from_bytes(BYTES_PER_LINE) - (i - line_start);\n+                let overflow = ptr_size - remainder;\n+                let remainder_width = relocation_width(remainder.bytes_usize()) - 2;\n+                let overflow_width = relocation_width(overflow.bytes_usize() - 1) + 1;\n+                ascii.push('\u257e');\n+                for _ in 0..remainder.bytes() - 1 {\n+                    ascii.push('\u2500');\n+                }\n+                if overflow_width > remainder_width && overflow_width >= target.len() {\n+                    // The case where the relocation fits into the part in the next line\n+                    write!(w, \"\u257e{0:\u2500^1$}\", \"\", remainder_width)?;\n+                    line_start =\n+                        write_allocation_newline(w, line_start, &ascii, pos_width, prefix)?;\n+                    ascii.clear();\n+                    write!(w, \"{0:\u2500^1$}\u257c\", target, overflow_width)?;\n+                } else {\n+                    oversized_ptr(&mut target, remainder_width);\n+                    write!(w, \"\u257e{0:\u2500^1$}\", target, remainder_width)?;\n+                    line_start =\n+                        write_allocation_newline(w, line_start, &ascii, pos_width, prefix)?;\n+                    write!(w, \"{0:\u2500^1$}\u257c\", \"\", overflow_width)?;\n+                    ascii.clear();\n+                }\n+                for _ in 0..overflow.bytes() - 1 {\n+                    ascii.push('\u2500');\n+                }\n+                ascii.push('\u257c');\n+                i += ptr_size;\n+                continue;\n+            } else {\n+                // This branch handles a relocation that starts and ends in the current line.\n+                let relocation_width = relocation_width(ptr_size.bytes_usize() - 1);\n+                oversized_ptr(&mut target, relocation_width);\n+                ascii.push('\u257e');\n+                write!(w, \"\u257e{0:\u2500^1$}\u257c\", target, relocation_width)?;\n+                for _ in 0..ptr_size.bytes() - 2 {\n+                    ascii.push('\u2500');\n+                }\n+                ascii.push('\u257c');\n+                i += ptr_size;\n+            }\n+        } else if alloc.undef_mask().is_range_defined(i, i + Size::from_bytes(1)).is_ok() {\n+            let j = i.bytes_usize();\n+\n+            // Checked definedness (and thus range) and relocations. This access also doesn't\n+            // influence interpreter execution but is only for debugging.\n+            let c = alloc.inspect_with_undef_and_ptr_outside_interpreter(j..j + 1)[0];\n+            write!(w, \"{:02x}\", c)?;\n+            if c.is_ascii_control() || c >= 0x80 {\n+                ascii.push('.');\n+            } else {\n+                ascii.push(char::from(c));\n+            }\n+            i += Size::from_bytes(1);\n+        } else {\n+            write!(w, \"__\")?;\n+            ascii.push('\u2591');\n+            i += Size::from_bytes(1);\n+        }\n+        // Print a new line header if the next line still has some bytes to print.\n+        if i == line_start + Size::from_bytes(BYTES_PER_LINE) && i != alloc.size {\n+            line_start = write_allocation_newline(w, line_start, &ascii, pos_width, prefix)?;\n+            ascii.clear();\n+        }\n+    }\n+    write_allocation_endline(w, &ascii)?;\n+\n+    Ok(())\n+}\n+\n fn write_mir_sig(\n     tcx: TyCtxt<'_>,\n     src: MirSource<'tcx>,"}, {"sha": "a6f86d4e384ae91d3ab95d8f75c5d29dbbb4e78d", "filename": "src/test/mir-opt/README.md", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2FREADME.md?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -1,6 +1,46 @@\n This folder contains tests for MIR optimizations.\n \n-The test format is:\n+There are two test formats. One allows specifying a pattern to look for in the MIR, which also\n+permits leaving placeholders, but requires you to manually change the pattern if anything changes.\n+The other emits MIR to extra files that you can automatically update by specifying `--bless` on\n+the command line (just like `ui` tests updating `.stderr` files).\n+\n+# `--bless`able test format\n+\n+By default 32 bit and 64 bit targets use the same dump files, which can be problematic in the\n+presence of pointers in constants or other bit width dependent things. In that case you can add\n+\n+```\n+// EMIT_MIR_FOR_EACH_BIT_WIDTH\n+```\n+\n+to your test, causing separate files to be generated for 32bit and 64bit systems.\n+\n+## Emit a diff of the mir for a specific optimization\n+\n+This is what you want most often when you want to see how an optimization changes the MIR.\n+\n+```\n+// EMIT_MIR $file_name_of_some_mir_dump.diff\n+```\n+\n+## Emit mir after a specific optimization\n+\n+Use this if you are just interested in the final state after an optimization.\n+\n+```\n+// EMIT_MIR $file_name_of_some_mir_dump.after.mir\n+```\n+\n+## Emit mir before a specific optimization\n+\n+This exists mainly for completeness and is rarely useful.\n+\n+```\n+// EMIT_MIR $file_name_of_some_mir_dump.before.mir\n+```\n+\n+# Inline test format\n \n ```\n (arbitrary rust code)"}, {"sha": "17141b6334c827ee15e947cb2767920425b6c876", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -1,5 +1,7 @@\n // this tests move up progration, which is not yet implemented\n \n+// EMIT_MIR rustc.main.SimplifyCfg-initial.after.mir\n+\n // Check codegen for assignments (`a = b`) where the left-hand-side is\n // not yet initialized. Assignments tend to be absent in simple code,\n // so subtle breakage in them can leave a quite hard-to-find trail of\n@@ -13,40 +15,10 @@ fn main() {\n     // assignment:\n     nodrop_y = nodrop_x;\n \n-    let drop_x : Option<Box<u32>> = None;\n+    let drop_x: Option<Box<u32>> = None;\n     let drop_y;\n \n     // Since the type of `drop_y` has drop, we generate a `replace`\n     // terminator:\n     drop_y = drop_x;\n }\n-\n-// END RUST SOURCE\n-// START rustc.main.SimplifyCfg-initial.after.mir\n-//    bb0: {\n-//        StorageLive(_1);\n-//        _1 = const false;\n-//        FakeRead(ForLet, _1);\n-//        StorageLive(_2);\n-//        StorageLive(_3);\n-//        _3 = _1;\n-//        _2 = move _3;\n-//        StorageDead(_3);\n-//        StorageLive(_4);\n-//        _4 = std::option::Option::<std::boxed::Box<u32>>::None;\n-//        FakeRead(ForLet, _4);\n-//        AscribeUserType(_4, o, UserTypeProjection { base: UserType(1), projs: [] });\n-//        StorageLive(_5);\n-//        StorageLive(_6);\n-//        _6 = move _4;\n-//        replace(_5 <- move _6) -> [return: bb2, unwind: bb5];\n-//    }\n-//    ...\n-//    bb2: {\n-//        drop(_6) -> [return: bb6, unwind: bb4];\n-//    }\n-//    ...\n-//    bb5 (cleanup): {\n-//        drop(_6) -> bb4;\n-//    }\n-// END rustc.main.SimplifyCfg-initial.after.mir"}, {"sha": "a3f4573964c3d43f49b7cd2b1d736e9965214345", "filename": "src/test/mir-opt/basic_assignment/rustc.main.SimplifyCfg-initial.after.mir", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fbasic_assignment%2Frustc.main.SimplifyCfg-initial.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fbasic_assignment%2Frustc.main.SimplifyCfg-initial.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment%2Frustc.main.SimplifyCfg-initial.after.mir?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -0,0 +1,90 @@\n+// MIR for `main` after SimplifyCfg-initial\n+\n+| User Type Annotations\n+| 0: Canonical { max_universe: U0, variables: [], value: Ty(std::option::Option<std::boxed::Box<u32>>) } at $DIR/basic_assignment.rs:18:17: 18:33\n+| 1: Canonical { max_universe: U0, variables: [], value: Ty(std::option::Option<std::boxed::Box<u32>>) } at $DIR/basic_assignment.rs:18:17: 18:33\n+|\n+fn main() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/basic_assignment.rs:10:11: 10:11\n+    let _1: bool;                        // in scope 0 at $DIR/basic_assignment.rs:11:9: 11:17\n+    let mut _3: bool;                    // in scope 0 at $DIR/basic_assignment.rs:16:16: 16:24\n+    let mut _6: std::option::Option<std::boxed::Box<u32>>; // in scope 0 at $DIR/basic_assignment.rs:23:14: 23:20\n+    scope 1 {\n+        debug nodrop_x => _1;            // in scope 1 at $DIR/basic_assignment.rs:11:9: 11:17\n+        let _2: bool;                    // in scope 1 at $DIR/basic_assignment.rs:12:9: 12:17\n+        scope 2 {\n+            debug nodrop_y => _2;        // in scope 2 at $DIR/basic_assignment.rs:12:9: 12:17\n+            let _4: std::option::Option<std::boxed::Box<u32>> as UserTypeProjection { base: UserType(0), projs: [] }; // in scope 2 at $DIR/basic_assignment.rs:18:9: 18:15\n+            scope 3 {\n+                debug drop_x => _4;      // in scope 3 at $DIR/basic_assignment.rs:18:9: 18:15\n+                let _5: std::option::Option<std::boxed::Box<u32>>; // in scope 3 at $DIR/basic_assignment.rs:19:9: 19:15\n+                scope 4 {\n+                    debug drop_y => _5;  // in scope 4 at $DIR/basic_assignment.rs:19:9: 19:15\n+                }\n+            }\n+        }\n+    }\n+\n+    bb0: {\n+        StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/basic_assignment.rs:11:9: 11:17\n+        _1 = const false;                // bb0[1]: scope 0 at $DIR/basic_assignment.rs:11:20: 11:25\n+                                         // ty::Const\n+                                         // + ty: bool\n+                                         // + val: Value(Scalar(0x00))\n+                                         // mir::Constant\n+                                         // + span: $DIR/basic_assignment.rs:11:20: 11:25\n+                                         // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n+        FakeRead(ForLet, _1);            // bb0[2]: scope 0 at $DIR/basic_assignment.rs:11:9: 11:17\n+        StorageLive(_2);                 // bb0[3]: scope 1 at $DIR/basic_assignment.rs:12:9: 12:17\n+        StorageLive(_3);                 // bb0[4]: scope 2 at $DIR/basic_assignment.rs:16:16: 16:24\n+        _3 = _1;                         // bb0[5]: scope 2 at $DIR/basic_assignment.rs:16:16: 16:24\n+        _2 = move _3;                    // bb0[6]: scope 2 at $DIR/basic_assignment.rs:16:5: 16:24\n+        StorageDead(_3);                 // bb0[7]: scope 2 at $DIR/basic_assignment.rs:16:23: 16:24\n+        StorageLive(_4);                 // bb0[8]: scope 2 at $DIR/basic_assignment.rs:18:9: 18:15\n+        _4 = std::option::Option::<std::boxed::Box<u32>>::None; // bb0[9]: scope 2 at $DIR/basic_assignment.rs:18:36: 18:40\n+        FakeRead(ForLet, _4);            // bb0[10]: scope 2 at $DIR/basic_assignment.rs:18:9: 18:15\n+        AscribeUserType(_4, o, UserTypeProjection { base: UserType(1), projs: [] }); // bb0[11]: scope 2 at $DIR/basic_assignment.rs:18:17: 18:33\n+        StorageLive(_5);                 // bb0[12]: scope 3 at $DIR/basic_assignment.rs:19:9: 19:15\n+        StorageLive(_6);                 // bb0[13]: scope 4 at $DIR/basic_assignment.rs:23:14: 23:20\n+        _6 = move _4;                    // bb0[14]: scope 4 at $DIR/basic_assignment.rs:23:14: 23:20\n+        replace(_5 <- move _6) -> [return: bb2, unwind: bb5]; // bb0[15]: scope 4 at $DIR/basic_assignment.rs:23:5: 23:11\n+    }\n+\n+    bb1 (cleanup): {\n+        resume;                          // bb1[0]: scope 0 at $DIR/basic_assignment.rs:10:1: 24:2\n+    }\n+\n+    bb2: {\n+        drop(_6) -> [return: bb6, unwind: bb4]; // bb2[0]: scope 4 at $DIR/basic_assignment.rs:23:19: 23:20\n+    }\n+\n+    bb3 (cleanup): {\n+        drop(_4) -> bb1;                 // bb3[0]: scope 2 at $DIR/basic_assignment.rs:24:1: 24:2\n+    }\n+\n+    bb4 (cleanup): {\n+        drop(_5) -> bb3;                 // bb4[0]: scope 3 at $DIR/basic_assignment.rs:24:1: 24:2\n+    }\n+\n+    bb5 (cleanup): {\n+        drop(_6) -> bb4;                 // bb5[0]: scope 4 at $DIR/basic_assignment.rs:23:19: 23:20\n+    }\n+\n+    bb6: {\n+        StorageDead(_6);                 // bb6[0]: scope 4 at $DIR/basic_assignment.rs:23:19: 23:20\n+        _0 = ();                         // bb6[1]: scope 0 at $DIR/basic_assignment.rs:10:11: 24:2\n+        drop(_5) -> [return: bb7, unwind: bb3]; // bb6[2]: scope 3 at $DIR/basic_assignment.rs:24:1: 24:2\n+    }\n+\n+    bb7: {\n+        StorageDead(_5);                 // bb7[0]: scope 3 at $DIR/basic_assignment.rs:24:1: 24:2\n+        drop(_4) -> [return: bb8, unwind: bb1]; // bb7[1]: scope 2 at $DIR/basic_assignment.rs:24:1: 24:2\n+    }\n+\n+    bb8: {\n+        StorageDead(_4);                 // bb8[0]: scope 2 at $DIR/basic_assignment.rs:24:1: 24:2\n+        StorageDead(_2);                 // bb8[1]: scope 1 at $DIR/basic_assignment.rs:24:1: 24:2\n+        StorageDead(_1);                 // bb8[2]: scope 0 at $DIR/basic_assignment.rs:24:1: 24:2\n+        return;                          // bb8[3]: scope 0 at $DIR/basic_assignment.rs:24:2: 24:2\n+    }\n+}"}, {"sha": "c9d350a98fd9c80aca4b4696f2283922bcf3440f", "filename": "src/test/mir-opt/const-promotion-extern-static.rs", "status": "modified", "additions": 4, "deletions": 62, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -4,70 +4,12 @@ extern \"C\" {\n \n static Y: i32 = 42;\n \n+// EMIT_MIR rustc.BAR.PromoteTemps.diff\n+// EMIT_MIR rustc.BAR-promoted[0].ConstProp.after.mir\n static mut BAR: *const &i32 = [&Y].as_ptr();\n \n+// EMIT_MIR rustc.FOO.PromoteTemps.diff\n+// EMIT_MIR rustc.FOO-promoted[0].ConstProp.after.mir\n static mut FOO: *const &i32 = [unsafe { &X }].as_ptr();\n \n fn main() {}\n-\n-// END RUST SOURCE\n-// START rustc.FOO.PromoteTemps.before.mir\n-// bb0: {\n-// ...\n-//     _5 = const {alloc1+0: &i32};\n-//     _4 = &(*_5);\n-//     _3 = [move _4];\n-//     _2 = &_3;\n-//     _1 = move _2 as &[&i32] (Pointer(Unsize));\n-//     _0 = const core::slice::<impl [&i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1];\n-// }\n-// ...\n-// bb2: {\n-//     StorageDead(_5);\n-//     StorageDead(_3);\n-//     return;\n-// }\n-// END rustc.FOO.PromoteTemps.before.mir\n-// START rustc.BAR.PromoteTemps.before.mir\n-// bb0: {\n-// ...\n-//     _5 = const {alloc0+0: &i32};\n-//     _4 = &(*_5);\n-//     _3 = [move _4];\n-//     _2 = &_3;\n-//     _1 = move _2 as &[&i32] (Pointer(Unsize));\n-//     _0 = const core::slice::<impl [&i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1];\n-// }\n-// ...\n-// bb2: {\n-//     StorageDead(_5);\n-//     StorageDead(_3);\n-//     return;\n-// }\n-// END rustc.BAR.PromoteTemps.before.mir\n-// START rustc.BAR.PromoteTemps.after.mir\n-// bb0: {\n-// ...\n-//     _6 = const BAR::promoted[0];\n-//     _2 = &(*_6);\n-//     _1 = move _2 as &[&i32] (Pointer(Unsize));\n-//     _0 = const core::slice::<impl [&i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1];\n-// }\n-// ...\n-// bb2: {\n-//     return;\n-// }\n-// END rustc.BAR.PromoteTemps.after.mir\n-// START rustc.FOO.PromoteTemps.after.mir\n-// bb0: {\n-// ...\n-//     _6 = const FOO::promoted[0];\n-//     _2 = &(*_6);\n-//     _1 = move _2 as &[&i32] (Pointer(Unsize));\n-//     _0 = const core::slice::<impl [&i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1];\n-// }\n-// ...\n-// bb2: {\n-//     return;\n-// }\n-// END rustc.FOO.PromoteTemps.after.mir"}, {"sha": "256018adaa89befe0b8aa1cc20bb3ec0101e315c", "filename": "src/test/mir-opt/const-promotion-extern-static/rustc.BAR-promoted[0].ConstProp.after.mir", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.BAR-promoted%5B0%5D.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.BAR-promoted%5B0%5D.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.BAR-promoted%5B0%5D.ConstProp.after.mir?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -0,0 +1,26 @@\n+// MIR for `BAR::promoted[0]` after ConstProp\n+\n+promoted[0] in BAR: &[&i32; 1] = {\n+    let mut _0: &[&i32; 1];              // return place in scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+    let mut _1: [&i32; 1];               // in scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+    let mut _2: &i32;                    // in scope 0 at $DIR/const-promotion-extern-static.rs:9:32: 9:34\n+    let mut _3: &i32;                    // in scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n+\n+    bb0: {\n+        _3 = const {alloc0+0: &i32};     // bb0[0]: scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n+                                         // ty::Const\n+                                         // + ty: &i32\n+                                         // + val: Value(Scalar(alloc0+0))\n+                                         // mir::Constant\n+                                         // + span: $DIR/const-promotion-extern-static.rs:9:33: 9:34\n+                                         // + literal: Const { ty: &i32, val: Value(Scalar(alloc0+0)) }\n+        _2 = _3;                         // bb0[1]: scope 0 at $DIR/const-promotion-extern-static.rs:9:32: 9:34\n+        _1 = [move _2];                  // bb0[2]: scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+        _0 = &_1;                        // bb0[3]: scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+        return;                          // bb0[4]: scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+    }\n+}\n+\n+alloc0 (static: Y, size: 4, align: 4) {\n+    2a 00 00 00                                     \u2502 *...\n+}"}, {"sha": "bc5b114418e42c8c3cca72bc5352514c26e6cbea", "filename": "src/test/mir-opt/const-promotion-extern-static/rustc.BAR.PromoteTemps.diff", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.BAR.PromoteTemps.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.BAR.PromoteTemps.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.BAR.PromoteTemps.diff?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -0,0 +1,62 @@\n+- // MIR for `BAR` before PromoteTemps\n++ // MIR for `BAR` after PromoteTemps\n+  \n+  static mut BAR: *const &i32 = {\n+      let mut _0: *const &i32;             // return place in scope 0 at $DIR/const-promotion-extern-static.rs:9:17: 9:28\n+      let mut _1: &[&i32];                 // in scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+      let mut _2: &[&i32; 1];              // in scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+      let _3: [&i32; 1];                   // in scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+      let mut _4: &i32;                    // in scope 0 at $DIR/const-promotion-extern-static.rs:9:32: 9:34\n+      let _5: &i32;                        // in scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n++     let mut _6: &[&i32; 1];              // in scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+  \n+      bb0: {\n+          StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+          StorageLive(_2);                 // bb0[1]: scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+-         StorageLive(_3);                 // bb0[2]: scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+-         StorageLive(_4);                 // bb0[3]: scope 0 at $DIR/const-promotion-extern-static.rs:9:32: 9:34\n+-         StorageLive(_5);                 // bb0[4]: scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n+-         _5 = const {alloc0+0: &i32};     // bb0[5]: scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n++         _6 = const BAR::promoted[0];     // bb0[2]: scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+                                           // ty::Const\n+-                                          // + ty: &i32\n+-                                          // + val: Value(Scalar(alloc0+0))\n++                                          // + ty: &[&i32; 1]\n++                                          // + val: Unevaluated(DefId(0:6 ~ const_promotion_extern_static[317d]::BAR[0]), [], Some(promoted[0]))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/const-promotion-extern-static.rs:9:33: 9:34\n+-                                          // + literal: Const { ty: &i32, val: Value(Scalar(alloc0+0)) }\n+-         _4 = &(*_5);                     // bb0[6]: scope 0 at $DIR/const-promotion-extern-static.rs:9:32: 9:34\n+-         _3 = [move _4];                  // bb0[7]: scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+-         _2 = &_3;                        // bb0[8]: scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+-         _1 = move _2 as &[&i32] (Pointer(Unsize)); // bb0[9]: scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n+-         _0 = const core::slice::<impl [&i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1]; // bb0[10]: scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:44\n++                                          // + span: $DIR/const-promotion-extern-static.rs:9:31: 9:35\n++                                          // + literal: Const { ty: &[&i32; 1], val: Unevaluated(DefId(0:6 ~ const_promotion_extern_static[317d]::BAR[0]), [], Some(promoted[0])) }\n++         _2 = &(*_6);                     // bb0[3]: scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n++         _1 = move _2 as &[&i32] (Pointer(Unsize)); // bb0[4]: scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n++         _0 = const core::slice::<impl [&i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1]; // bb0[5]: scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:44\n+                                           // ty::Const\n+                                           // + ty: for<'r> fn(&'r [&i32]) -> *const &i32 {core::slice::<impl [&i32]>::as_ptr}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/const-promotion-extern-static.rs:9:36: 9:42\n+                                           // + literal: Const { ty: for<'r> fn(&'r [&i32]) -> *const &i32 {core::slice::<impl [&i32]>::as_ptr}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1 (cleanup): {\n+          resume;                          // bb1[0]: scope 0 at $DIR/const-promotion-extern-static.rs:9:1: 9:45\n+      }\n+  \n+      bb2: {\n+-         StorageDead(_5);                 // bb2[0]: scope 0 at $DIR/const-promotion-extern-static.rs:9:43: 9:44\n+-         StorageDead(_3);                 // bb2[1]: scope 0 at $DIR/const-promotion-extern-static.rs:9:43: 9:44\n+-         return;                          // bb2[2]: scope 0 at $DIR/const-promotion-extern-static.rs:9:1: 9:45\n++         return;                          // bb2[0]: scope 0 at $DIR/const-promotion-extern-static.rs:9:1: 9:45\n+      }\n+- }\n+- \n+- alloc0 (static: Y, size: 4, align: 4) {\n+-     2a 00 00 00                                     \u2502 *...\n+  }\n+  "}, {"sha": "5bbc05a9cab7c9c2d5ecef25c06ea88203808e48", "filename": "src/test/mir-opt/const-promotion-extern-static/rustc.FOO-promoted[0].ConstProp.after.mir", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.FOO-promoted%5B0%5D.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.FOO-promoted%5B0%5D.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.FOO-promoted%5B0%5D.ConstProp.after.mir?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -0,0 +1,26 @@\n+// MIR for `FOO::promoted[0]` after ConstProp\n+\n+promoted[0] in FOO: &[&i32; 1] = {\n+    let mut _0: &[&i32; 1];              // return place in scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+    let mut _1: [&i32; 1];               // in scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+    let mut _2: &i32;                    // in scope 0 at $DIR/const-promotion-extern-static.rs:13:32: 13:45\n+    let mut _3: &i32;                    // in scope 0 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n+    scope 1 {\n+    }\n+\n+    bb0: {\n+        _3 = const {alloc2+0: &i32};     // bb0[0]: scope 0 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n+                                         // ty::Const\n+                                         // + ty: &i32\n+                                         // + val: Value(Scalar(alloc2+0))\n+                                         // mir::Constant\n+                                         // + span: $DIR/const-promotion-extern-static.rs:13:42: 13:43\n+                                         // + literal: Const { ty: &i32, val: Value(Scalar(alloc2+0)) }\n+        _2 = _3;                         // bb0[1]: scope 0 at $DIR/const-promotion-extern-static.rs:13:41: 13:43\n+        _1 = [move _2];                  // bb0[2]: scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+        _0 = &_1;                        // bb0[3]: scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+        return;                          // bb0[4]: scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+    }\n+}\n+\n+alloc2 (extern static: X)"}, {"sha": "7df1a47b2f4977d42cfba3abbc8db071bc23697e", "filename": "src/test/mir-opt/const-promotion-extern-static/rustc.FOO.PromoteTemps.diff", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.FOO.PromoteTemps.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.FOO.PromoteTemps.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static%2Frustc.FOO.PromoteTemps.diff?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -0,0 +1,62 @@\n+- // MIR for `FOO` before PromoteTemps\n++ // MIR for `FOO` after PromoteTemps\n+  \n+  static mut FOO: *const &i32 = {\n+      let mut _0: *const &i32;             // return place in scope 0 at $DIR/const-promotion-extern-static.rs:13:17: 13:28\n+      let mut _1: &[&i32];                 // in scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+      let mut _2: &[&i32; 1];              // in scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+      let _3: [&i32; 1];                   // in scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+      let mut _4: &i32;                    // in scope 0 at $DIR/const-promotion-extern-static.rs:13:32: 13:45\n+      let _5: &i32;                        // in scope 0 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n++     let mut _6: &[&i32; 1];              // in scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+          StorageLive(_2);                 // bb0[1]: scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+-         StorageLive(_3);                 // bb0[2]: scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+-         StorageLive(_4);                 // bb0[3]: scope 0 at $DIR/const-promotion-extern-static.rs:13:32: 13:45\n+-         StorageLive(_5);                 // bb0[4]: scope 1 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n+-         _5 = const {alloc2+0: &i32};     // bb0[5]: scope 1 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n++         _6 = const FOO::promoted[0];     // bb0[2]: scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+                                           // ty::Const\n+-                                          // + ty: &i32\n+-                                          // + val: Value(Scalar(alloc2+0))\n++                                          // + ty: &[&i32; 1]\n++                                          // + val: Unevaluated(DefId(0:7 ~ const_promotion_extern_static[317d]::FOO[0]), [], Some(promoted[0]))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/const-promotion-extern-static.rs:13:42: 13:43\n+-                                          // + literal: Const { ty: &i32, val: Value(Scalar(alloc2+0)) }\n+-         _4 = &(*_5);                     // bb0[6]: scope 1 at $DIR/const-promotion-extern-static.rs:13:41: 13:43\n+-         _3 = [move _4];                  // bb0[7]: scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+-         _2 = &_3;                        // bb0[8]: scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+-         _1 = move _2 as &[&i32] (Pointer(Unsize)); // bb0[9]: scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n+-         _0 = const core::slice::<impl [&i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1]; // bb0[10]: scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:55\n++                                          // + span: $DIR/const-promotion-extern-static.rs:13:31: 13:46\n++                                          // + literal: Const { ty: &[&i32; 1], val: Unevaluated(DefId(0:7 ~ const_promotion_extern_static[317d]::FOO[0]), [], Some(promoted[0])) }\n++         _2 = &(*_6);                     // bb0[3]: scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n++         _1 = move _2 as &[&i32] (Pointer(Unsize)); // bb0[4]: scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n++         _0 = const core::slice::<impl [&i32]>::as_ptr(move _1) -> [return: bb2, unwind: bb1]; // bb0[5]: scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:55\n+                                           // ty::Const\n+                                           // + ty: for<'r> fn(&'r [&i32]) -> *const &i32 {core::slice::<impl [&i32]>::as_ptr}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/const-promotion-extern-static.rs:13:47: 13:53\n+                                           // + literal: Const { ty: for<'r> fn(&'r [&i32]) -> *const &i32 {core::slice::<impl [&i32]>::as_ptr}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1 (cleanup): {\n+          resume;                          // bb1[0]: scope 0 at $DIR/const-promotion-extern-static.rs:13:1: 13:56\n+      }\n+  \n+      bb2: {\n+-         StorageDead(_5);                 // bb2[0]: scope 0 at $DIR/const-promotion-extern-static.rs:13:54: 13:55\n+-         StorageDead(_3);                 // bb2[1]: scope 0 at $DIR/const-promotion-extern-static.rs:13:54: 13:55\n+-         return;                          // bb2[2]: scope 0 at $DIR/const-promotion-extern-static.rs:13:1: 13:56\n++         return;                          // bb2[0]: scope 0 at $DIR/const-promotion-extern-static.rs:13:1: 13:56\n+      }\n+  }\n+- \n+- alloc2 (extern static: X)\n+  "}, {"sha": "aaf996ee8e1a718d0913ad9ceb7df98dad2238a7", "filename": "src/test/mir-opt/const_allocation.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation.rs?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -0,0 +1,9 @@\n+// EMIT_MIR_FOR_EACH_BIT_WIDTH\n+\n+static FOO: &[(Option<i32>, &[&str])] =\n+    &[(None, &[]), (None, &[\"foo\", \"bar\"]), (Some(42), &[\"meh\", \"mop\", \"m\u00f6p\"])];\n+\n+// EMIT_MIR rustc.main.ConstProp.after.mir\n+fn main() {\n+    FOO;\n+}"}, {"sha": "5880672450878ff1b79e583d2f718f9b534b0659", "filename": "src/test/mir-opt/const_allocation/32bit/rustc.main.ConstProp.after.mir", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation%2F32bit%2Frustc.main.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation%2F32bit%2Frustc.main.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation%2F32bit%2Frustc.main.ConstProp.after.mir?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -0,0 +1,65 @@\n+// MIR for `main` after ConstProp\n+\n+fn main() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/const_allocation.rs:7:11: 7:11\n+    let _1: &[(std::option::Option<i32>, &[&str])]; // in scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+    let mut _2: &&[(std::option::Option<i32>, &[&str])]; // in scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+\n+    bb0: {\n+        StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+        StorageLive(_2);                 // bb0[1]: scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+        _2 = const {alloc0+0: &&[(std::option::Option<i32>, &[&str])]}; // bb0[2]: scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+                                         // ty::Const\n+                                         // + ty: &&[(std::option::Option<i32>, &[&str])]\n+                                         // + val: Value(Scalar(alloc0+0))\n+                                         // mir::Constant\n+                                         // + span: $DIR/const_allocation.rs:8:5: 8:8\n+                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&str])], val: Value(Scalar(alloc0+0)) }\n+        _1 = (*_2);                      // bb0[3]: scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+        StorageDead(_2);                 // bb0[4]: scope 0 at $DIR/const_allocation.rs:8:8: 8:9\n+        StorageDead(_1);                 // bb0[5]: scope 0 at $DIR/const_allocation.rs:8:8: 8:9\n+        _0 = ();                         // bb0[6]: scope 0 at $DIR/const_allocation.rs:7:11: 9:2\n+        return;                          // bb0[7]: scope 0 at $DIR/const_allocation.rs:9:2: 9:2\n+    }\n+}\n+\n+alloc0 (static: FOO, size: 8, align: 4) {\n+    \u257ealloc17+0\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+}\n+\n+alloc17 (size: 48, align: 4) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257ealloc4+0\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257ealloc8+0\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257ealloc13+0\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+}\n+\n+alloc4 (size: 0, align: 4) {}\n+\n+alloc8 (size: 16, align: 4) {\n+    \u257ealloc7+0\u2500\u257c 03 00 00 00 \u257ealloc9+0\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n+}\n+\n+alloc7 (size: 3, align: 1) {\n+    66 6f 6f                                        \u2502 foo\n+}\n+\n+alloc9 (size: 3, align: 1) {\n+    62 61 72                                        \u2502 bar\n+}\n+\n+alloc13 (size: 24, align: 4) {\n+    0x00 \u2502 \u257ealloc12+0\u257c 03 00 00 00 \u257ealloc14+0\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 \u257ealloc15+0\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+}\n+\n+alloc12 (size: 3, align: 1) {\n+    6d 65 68                                        \u2502 meh\n+}\n+\n+alloc14 (size: 3, align: 1) {\n+    6d 6f 70                                        \u2502 mop\n+}\n+\n+alloc15 (size: 4, align: 1) {\n+    6d c3 b6 70                                     \u2502 m..p\n+}"}, {"sha": "b60d23aa3f1175905f8b55863f7b2a0286aeab74", "filename": "src/test/mir-opt/const_allocation/64bit/rustc.main.ConstProp.after.mir", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation%2F64bit%2Frustc.main.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation%2F64bit%2Frustc.main.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation%2F64bit%2Frustc.main.ConstProp.after.mir?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -0,0 +1,69 @@\n+// MIR for `main` after ConstProp\n+\n+fn main() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/const_allocation.rs:7:11: 7:11\n+    let _1: &[(std::option::Option<i32>, &[&str])]; // in scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+    let mut _2: &&[(std::option::Option<i32>, &[&str])]; // in scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+\n+    bb0: {\n+        StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+        StorageLive(_2);                 // bb0[1]: scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+        _2 = const {alloc0+0: &&[(std::option::Option<i32>, &[&str])]}; // bb0[2]: scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+                                         // ty::Const\n+                                         // + ty: &&[(std::option::Option<i32>, &[&str])]\n+                                         // + val: Value(Scalar(alloc0+0))\n+                                         // mir::Constant\n+                                         // + span: $DIR/const_allocation.rs:8:5: 8:8\n+                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&str])], val: Value(Scalar(alloc0+0)) }\n+        _1 = (*_2);                      // bb0[3]: scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+        StorageDead(_2);                 // bb0[4]: scope 0 at $DIR/const_allocation.rs:8:8: 8:9\n+        StorageDead(_1);                 // bb0[5]: scope 0 at $DIR/const_allocation.rs:8:8: 8:9\n+        _0 = ();                         // bb0[6]: scope 0 at $DIR/const_allocation.rs:7:11: 9:2\n+        return;                          // bb0[7]: scope 0 at $DIR/const_allocation.rs:9:2: 9:2\n+    }\n+}\n+\n+alloc0 (static: FOO, size: 16, align: 8) {\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc17+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+}\n+\n+alloc17 (size: 72, align: 8) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc4+0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc8+0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc13+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n+}\n+\n+alloc4 (size: 0, align: 8) {}\n+\n+alloc8 (size: 32, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc7+0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc9+0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+}\n+\n+alloc7 (size: 3, align: 1) {\n+    66 6f 6f                                        \u2502 foo\n+}\n+\n+alloc9 (size: 3, align: 1) {\n+    62 61 72                                        \u2502 bar\n+}\n+\n+alloc13 (size: 48, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc12+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc14+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc15+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+}\n+\n+alloc12 (size: 3, align: 1) {\n+    6d 65 68                                        \u2502 meh\n+}\n+\n+alloc14 (size: 3, align: 1) {\n+    6d 6f 70                                        \u2502 mop\n+}\n+\n+alloc15 (size: 4, align: 1) {\n+    6d c3 b6 70                                     \u2502 m..p\n+}"}, {"sha": "ca61b84c0bcad72dce601cb7e2c657a1d1d0c770", "filename": "src/test/mir-opt/const_allocation2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2.rs?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -0,0 +1,11 @@\n+// EMIT_MIR_FOR_EACH_BIT_WIDTH\n+\n+// EMIT_MIR rustc.main.ConstProp.after.mir\n+fn main() {\n+    FOO;\n+}\n+\n+const BAR: [u8; 4] = [42, 69, 21, 111];\n+\n+static FOO: &[(Option<i32>, &[&u8])] =\n+    &[(None, &[]), (None, &[&5, &6]), (Some(42), &[&BAR[3], &42, &BAR[2]])];"}, {"sha": "6caecf1eceac08a3714e48670f8bcd6b738f2e34", "filename": "src/test/mir-opt/const_allocation2/32bit/rustc.main.ConstProp.after.mir", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F32bit%2Frustc.main.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F32bit%2Frustc.main.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F32bit%2Frustc.main.ConstProp.after.mir?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -0,0 +1,64 @@\n+// MIR for `main` after ConstProp\n+\n+fn main() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/const_allocation2.rs:4:11: 4:11\n+    let _1: &[(std::option::Option<i32>, &[&u8])]; // in scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+    let mut _2: &&[(std::option::Option<i32>, &[&u8])]; // in scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+\n+    bb0: {\n+        StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+        StorageLive(_2);                 // bb0[1]: scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+        _2 = const {alloc0+0: &&[(std::option::Option<i32>, &[&u8])]}; // bb0[2]: scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+                                         // ty::Const\n+                                         // + ty: &&[(std::option::Option<i32>, &[&u8])]\n+                                         // + val: Value(Scalar(alloc0+0))\n+                                         // mir::Constant\n+                                         // + span: $DIR/const_allocation2.rs:5:5: 5:8\n+                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&u8])], val: Value(Scalar(alloc0+0)) }\n+        _1 = (*_2);                      // bb0[3]: scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+        StorageDead(_2);                 // bb0[4]: scope 0 at $DIR/const_allocation2.rs:5:8: 5:9\n+        StorageDead(_1);                 // bb0[5]: scope 0 at $DIR/const_allocation2.rs:5:8: 5:9\n+        _0 = ();                         // bb0[6]: scope 0 at $DIR/const_allocation2.rs:4:11: 6:2\n+        return;                          // bb0[7]: scope 0 at $DIR/const_allocation2.rs:6:2: 6:2\n+    }\n+}\n+\n+alloc0 (static: FOO, size: 8, align: 4) {\n+    \u257ealloc24+0\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+}\n+\n+alloc24 (size: 48, align: 4) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257ealloc9+0\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257ealloc14+0\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257ealloc22+0\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+}\n+\n+alloc9 (size: 0, align: 4) {}\n+\n+alloc14 (size: 8, align: 4) {\n+    \u257ealloc12+0\u257c \u257ealloc13+0\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+}\n+\n+alloc12 (size: 1, align: 1) {\n+    05                                              \u2502 .\n+}\n+\n+alloc13 (size: 1, align: 1) {\n+    06                                              \u2502 .\n+}\n+\n+alloc22 (size: 12, align: 4) {\n+    \u257ealloc18+3\u257c \u257ealloc19+0\u257c \u257ealloc21+2\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+}\n+\n+alloc18 (size: 4, align: 1) {\n+    2a 45 15 6f                                     \u2502 *E.o\n+}\n+\n+alloc19 (size: 1, align: 1) {\n+    2a                                              \u2502 *\n+}\n+\n+alloc21 (size: 4, align: 1) {\n+    2a 45 15 6f                                     \u2502 *E.o\n+}"}, {"sha": "52e7c2aec2b122846602d287c5d8ad7ecbcd43d9", "filename": "src/test/mir-opt/const_allocation2/64bit/rustc.main.ConstProp.after.mir", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F64bit%2Frustc.main.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F64bit%2Frustc.main.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2%2F64bit%2Frustc.main.ConstProp.after.mir?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -0,0 +1,67 @@\n+// MIR for `main` after ConstProp\n+\n+fn main() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/const_allocation2.rs:4:11: 4:11\n+    let _1: &[(std::option::Option<i32>, &[&u8])]; // in scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+    let mut _2: &&[(std::option::Option<i32>, &[&u8])]; // in scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+\n+    bb0: {\n+        StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+        StorageLive(_2);                 // bb0[1]: scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+        _2 = const {alloc0+0: &&[(std::option::Option<i32>, &[&u8])]}; // bb0[2]: scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+                                         // ty::Const\n+                                         // + ty: &&[(std::option::Option<i32>, &[&u8])]\n+                                         // + val: Value(Scalar(alloc0+0))\n+                                         // mir::Constant\n+                                         // + span: $DIR/const_allocation2.rs:5:5: 5:8\n+                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&u8])], val: Value(Scalar(alloc0+0)) }\n+        _1 = (*_2);                      // bb0[3]: scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+        StorageDead(_2);                 // bb0[4]: scope 0 at $DIR/const_allocation2.rs:5:8: 5:9\n+        StorageDead(_1);                 // bb0[5]: scope 0 at $DIR/const_allocation2.rs:5:8: 5:9\n+        _0 = ();                         // bb0[6]: scope 0 at $DIR/const_allocation2.rs:4:11: 6:2\n+        return;                          // bb0[7]: scope 0 at $DIR/const_allocation2.rs:6:2: 6:2\n+    }\n+}\n+\n+alloc0 (static: FOO, size: 16, align: 8) {\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc24+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+}\n+\n+alloc24 (size: 72, align: 8) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc9+0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc14+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc22+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n+}\n+\n+alloc9 (size: 0, align: 8) {}\n+\n+alloc14 (size: 16, align: 8) {\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc12+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc13+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+}\n+\n+alloc12 (size: 1, align: 1) {\n+    05                                              \u2502 .\n+}\n+\n+alloc13 (size: 1, align: 1) {\n+    06                                              \u2502 .\n+}\n+\n+alloc22 (size: 24, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc18+3\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc19+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc21+2\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+}\n+\n+alloc18 (size: 4, align: 1) {\n+    2a 45 15 6f                                     \u2502 *E.o\n+}\n+\n+alloc19 (size: 1, align: 1) {\n+    2a                                              \u2502 *\n+}\n+\n+alloc21 (size: 4, align: 1) {\n+    2a 45 15 6f                                     \u2502 *E.o\n+}"}, {"sha": "73bb58e1a9892a6a1ff5f6dd4be0c6cc5be107c6", "filename": "src/test/mir-opt/const_allocation3.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation3.rs?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -0,0 +1,29 @@\n+// EMIT_MIR_FOR_EACH_BIT_WIDTH\n+\n+// EMIT_MIR rustc.main.ConstProp.after.mir\n+fn main() {\n+    FOO;\n+}\n+\n+#[repr(packed)]\n+struct Packed {\n+    a: [u8; 28],\n+    b: &'static i32,\n+    c: u32,\n+    d: [u8; 102],\n+    e: fn(),\n+    f: u16,\n+    g: &'static u8,\n+    h: [u8; 20],\n+}\n+\n+static FOO: &Packed = &Packed {\n+    a: [0xAB; 28],\n+    b: &42,\n+    c: 0xABCD_EF01,\n+    d: [0; 102],\n+    e: main,\n+    f: 0,\n+    g: &[0; 100][99],\n+    h: [0; 20],\n+};"}, {"sha": "4fc2c4c3fb3ddbba1ac546ab64038cdfc6840710", "filename": "src/test/mir-opt/const_allocation3/32bit/rustc.main.ConstProp.after.mir", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation3%2F32bit%2Frustc.main.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation3%2F32bit%2Frustc.main.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation3%2F32bit%2Frustc.main.ConstProp.after.mir?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -0,0 +1,58 @@\n+// MIR for `main` after ConstProp\n+\n+fn main() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/const_allocation3.rs:4:11: 4:11\n+    let _1: &Packed;                     // in scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+    let mut _2: &&Packed;                // in scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+\n+    bb0: {\n+        StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+        StorageLive(_2);                 // bb0[1]: scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+        _2 = const {alloc0+0: &&Packed}; // bb0[2]: scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+                                         // ty::Const\n+                                         // + ty: &&Packed\n+                                         // + val: Value(Scalar(alloc0+0))\n+                                         // mir::Constant\n+                                         // + span: $DIR/const_allocation3.rs:5:5: 5:8\n+                                         // + literal: Const { ty: &&Packed, val: Value(Scalar(alloc0+0)) }\n+        _1 = (*_2);                      // bb0[3]: scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+        StorageDead(_2);                 // bb0[4]: scope 0 at $DIR/const_allocation3.rs:5:8: 5:9\n+        StorageDead(_1);                 // bb0[5]: scope 0 at $DIR/const_allocation3.rs:5:8: 5:9\n+        _0 = ();                         // bb0[6]: scope 0 at $DIR/const_allocation3.rs:4:11: 6:2\n+        return;                          // bb0[7]: scope 0 at $DIR/const_allocation3.rs:6:2: 6:2\n+    }\n+}\n+\n+alloc0 (static: FOO, size: 4, align: 4) {\n+    \u257ealloc10+0\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+}\n+\n+alloc10 (size: 168, align: 1) {\n+    0x00 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab \u2502 ................\n+    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257ealloc5+0\u2500\u257c \u2502 ............\u257e\u2500\u2500\u257c\n+    0x20 \u2502 01 ef cd ab 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x30 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x40 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x50 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x60 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x70 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x80 \u2502 00 00 00 00 00 00 00 00 00 00 \u257ealloc7+0\u2500\u257c 00 00 \u2502 ..........\u257e\u2500\u2500\u257c..\n+    0x90 \u2502 \u257ealloc8+99\u257c 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u257c............\n+    0xa0 \u2502 00 00 00 00 00 00 00 00                         \u2502 ........\n+}\n+\n+alloc5 (size: 4, align: 4) {\n+    2a 00 00 00                                     \u2502 *...\n+}\n+\n+alloc7 (fn: main)\n+\n+alloc8 (size: 100, align: 1) {\n+    0x00 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x20 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x30 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x40 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x50 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x60 \u2502 00 00 00 00                                     \u2502 ....\n+}"}, {"sha": "ae5ebe7043706d111ea22e05f092adfaae182500", "filename": "src/test/mir-opt/const_allocation3/64bit/rustc.main.ConstProp.after.mir", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation3%2F64bit%2Frustc.main.ConstProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_allocation3%2F64bit%2Frustc.main.ConstProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation3%2F64bit%2Frustc.main.ConstProp.after.mir?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -0,0 +1,59 @@\n+// MIR for `main` after ConstProp\n+\n+fn main() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/const_allocation3.rs:4:11: 4:11\n+    let _1: &Packed;                     // in scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+    let mut _2: &&Packed;                // in scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+\n+    bb0: {\n+        StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+        StorageLive(_2);                 // bb0[1]: scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+        _2 = const {alloc0+0: &&Packed}; // bb0[2]: scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+                                         // ty::Const\n+                                         // + ty: &&Packed\n+                                         // + val: Value(Scalar(alloc0+0))\n+                                         // mir::Constant\n+                                         // + span: $DIR/const_allocation3.rs:5:5: 5:8\n+                                         // + literal: Const { ty: &&Packed, val: Value(Scalar(alloc0+0)) }\n+        _1 = (*_2);                      // bb0[3]: scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+        StorageDead(_2);                 // bb0[4]: scope 0 at $DIR/const_allocation3.rs:5:8: 5:9\n+        StorageDead(_1);                 // bb0[5]: scope 0 at $DIR/const_allocation3.rs:5:8: 5:9\n+        _0 = ();                         // bb0[6]: scope 0 at $DIR/const_allocation3.rs:4:11: 6:2\n+        return;                          // bb0[7]: scope 0 at $DIR/const_allocation3.rs:6:2: 6:2\n+    }\n+}\n+\n+alloc0 (static: FOO, size: 8, align: 8) {\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc10+0\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+}\n+\n+alloc10 (size: 180, align: 1) {\n+    0x00 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab \u2502 ................\n+    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500alloc5+0\u2500 \u2502 ............\u257e\u2500\u2500\u2500\n+    0x20 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 ef cd ab 00 00 00 00 00 00 00 00 \u2502 \u2500\u2500\u2500\u257c............\n+    0x30 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x40 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x50 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x60 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x70 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x80 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u257e\u2500\u2500\u2500\u2500 \u2502 ..............\u257e\u2500\n+    0x90 \u2502 \u2500\u2500\u2500\u2500alloc7+0\u2500\u2500\u2500\u2500\u257c 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500alloc8+99\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u2500\u2500\u2500\u2500\u2500\u257c..\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0xa0 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0xb0 \u2502 00 00 00 00                                     \u2502 ....\n+}\n+\n+alloc5 (size: 4, align: 4) {\n+    2a 00 00 00                                     \u2502 *...\n+}\n+\n+alloc7 (fn: main)\n+\n+alloc8 (size: 100, align: 1) {\n+    0x00 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x20 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x30 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x40 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x50 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n+    0x60 \u2502 00 00 00 00                                     \u2502 ....\n+}"}, {"sha": "2af5f32a66832fe7796f65513ee38a90c7fa7c5b", "filename": "src/test/mir-opt/const_prop/cast.rs", "status": "modified", "additions": 2, "deletions": 44, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcast.rs?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -1,49 +1,7 @@\n+// EMIT_MIR rustc.main.ConstProp.diff\n+\n fn main() {\n     let x = 42u8 as u32;\n \n     let y = 42u32 as u8;\n }\n-\n-// END RUST SOURCE\n-// START rustc.main.ConstProp.before.mir\n-// let mut _0: ();\n-// let _1: u32;\n-// scope 1 {\n-//   debug x => _1;\n-//   let _2: u8;\n-//   scope 2 {\n-//     debug y => _2;\n-//   }\n-// }\n-// bb0: {\n-//   StorageLive(_1);\n-//   _1 = const 42u8 as u32 (Misc);\n-//   StorageLive(_2);\n-//   _2 = const 42u32 as u8 (Misc);\n-//   _0 = ();\n-//   StorageDead(_2);\n-//   StorageDead(_1);\n-//   return;\n-// }\n-// END rustc.main.ConstProp.before.mir\n-// START rustc.main.ConstProp.after.mir\n-// let mut _0: ();\n-// let _1: u32;\n-// scope 1 {\n-//   debug x => _1;\n-//   let _2: u8;\n-//   scope 2 {\n-//     debug y => _2;\n-//   }\n-// }\n-// bb0: {\n-//   StorageLive(_1);\n-//   _1 = const 42u32;\n-//   StorageLive(_2);\n-//   _2 = const 42u8;\n-//   _0 = ();\n-//   StorageDead(_2);\n-//   StorageDead(_1);\n-//   return;\n-// }\n-// END rustc.main.ConstProp.after.mir"}, {"sha": "ee6a0e87b12fcb21821d871c4f6973201db82b48", "filename": "src/test/mir-opt/const_prop/cast/rustc.main.ConstProp.diff", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcast%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcast%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcast%2Frustc.main.ConstProp.diff?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -0,0 +1,48 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/cast.rs:3:11: 3:11\n+      let _1: u32;                         // in scope 0 at $DIR/cast.rs:4:9: 4:10\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/cast.rs:4:9: 4:10\n+          let _2: u8;                      // in scope 1 at $DIR/cast.rs:6:9: 6:10\n+          scope 2 {\n+              debug y => _2;               // in scope 2 at $DIR/cast.rs:6:9: 6:10\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/cast.rs:4:9: 4:10\n+-         _1 = const 42u8 as u32 (Misc);   // bb0[1]: scope 0 at $DIR/cast.rs:4:13: 4:24\n++         _1 = const 42u32;                // bb0[1]: scope 0 at $DIR/cast.rs:4:13: 4:24\n+                                           // ty::Const\n+-                                          // + ty: u8\n+-                                          // + val: Value(Scalar(0x2a))\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/cast.rs:4:13: 4:17\n+-                                          // + literal: Const { ty: u8, val: Value(Scalar(0x2a)) }\n+-         StorageLive(_2);                 // bb0[2]: scope 1 at $DIR/cast.rs:6:9: 6:10\n+-         _2 = const 42u32 as u8 (Misc);   // bb0[3]: scope 1 at $DIR/cast.rs:6:13: 6:24\n+-                                          // ty::Const\n+                                           // + ty: u32\n+                                           // + val: Value(Scalar(0x0000002a))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/cast.rs:6:13: 6:18\n++                                          // + span: $DIR/cast.rs:4:13: 4:24\n+                                           // + literal: Const { ty: u32, val: Value(Scalar(0x0000002a)) }\n++         StorageLive(_2);                 // bb0[2]: scope 1 at $DIR/cast.rs:6:9: 6:10\n++         _2 = const 42u8;                 // bb0[3]: scope 1 at $DIR/cast.rs:6:13: 6:24\n++                                          // ty::Const\n++                                          // + ty: u8\n++                                          // + val: Value(Scalar(0x2a))\n++                                          // mir::Constant\n++                                          // + span: $DIR/cast.rs:6:13: 6:24\n++                                          // + literal: Const { ty: u8, val: Value(Scalar(0x2a)) }\n+          _0 = ();                         // bb0[4]: scope 0 at $DIR/cast.rs:3:11: 7:2\n+          StorageDead(_2);                 // bb0[5]: scope 1 at $DIR/cast.rs:7:1: 7:2\n+          StorageDead(_1);                 // bb0[6]: scope 0 at $DIR/cast.rs:7:1: 7:2\n+          return;                          // bb0[7]: scope 0 at $DIR/cast.rs:7:2: 7:2\n+      }\n+  }\n+  "}, {"sha": "028483b7d95b530485cdcef183624651e72cbc3f", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -449,15 +449,8 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n pub fn make_tests(config: &Config, tests: &mut Vec<test::TestDescAndFn>) {\n     debug!(\"making tests from {:?}\", config.src_base.display());\n     let inputs = common_inputs_stamp(config);\n-    collect_tests_from_dir(\n-        config,\n-        &config.src_base,\n-        &config.src_base,\n-        &PathBuf::new(),\n-        &inputs,\n-        tests,\n-    )\n-    .expect(&format!(\"Could not read tests from {}\", config.src_base.display()));\n+    collect_tests_from_dir(config, &config.src_base, &PathBuf::new(), &inputs, tests)\n+        .expect(&format!(\"Could not read tests from {}\", config.src_base.display()));\n }\n \n /// Returns a stamp constructed from input files common to all test cases.\n@@ -494,7 +487,6 @@ fn common_inputs_stamp(config: &Config) -> Stamp {\n \n fn collect_tests_from_dir(\n     config: &Config,\n-    base: &Path,\n     dir: &Path,\n     relative_dir_path: &Path,\n     inputs: &Stamp,\n@@ -538,14 +530,7 @@ fn collect_tests_from_dir(\n             let relative_file_path = relative_dir_path.join(file.file_name());\n             if &file_name != \"auxiliary\" {\n                 debug!(\"found directory: {:?}\", file_path.display());\n-                collect_tests_from_dir(\n-                    config,\n-                    base,\n-                    &file_path,\n-                    &relative_file_path,\n-                    inputs,\n-                    tests,\n-                )?;\n+                collect_tests_from_dir(config, &file_path, &relative_file_path, inputs, tests)?;\n             }\n         } else {\n             debug!(\"found other file/directory: {:?}\", file_path.display());"}, {"sha": "0ee016f33dd885bae545c50f7653e193c8568f20", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 114, "deletions": 25, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2df620735134d5907e4d4e25241a64cec2ceac/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=0a2df620735134d5907e4d4e25241a64cec2ceac", "patch": "@@ -11,6 +11,7 @@ use crate::common::{UI_RUN_STDERR, UI_RUN_STDOUT};\n use crate::errors::{self, Error, ErrorKind};\n use crate::header::TestProps;\n use crate::json;\n+use crate::util::get_pointer_width;\n use crate::util::{logv, PathBufExt};\n use diff;\n use regex::{Captures, Regex};\n@@ -178,6 +179,33 @@ pub fn make_diff(expected: &str, actual: &str, context_size: usize) -> Vec<Misma\n     results\n }\n \n+fn print_diff(expected: &str, actual: &str, context_size: usize) {\n+    write_diff(expected, actual, context_size, std::io::stdout());\n+}\n+\n+fn write_diff(expected: &str, actual: &str, context_size: usize, mut dest: impl io::Write) {\n+    let diff_results = make_diff(expected, actual, context_size);\n+    for result in diff_results {\n+        let mut line_number = result.line_number;\n+        for line in result.lines {\n+            match line {\n+                DiffLine::Expected(e) => {\n+                    writeln!(dest, \"-\\t{}\", e).unwrap();\n+                    line_number += 1;\n+                }\n+                DiffLine::Context(c) => {\n+                    writeln!(dest, \"{}\\t{}\", line_number, c).unwrap();\n+                    line_number += 1;\n+                }\n+                DiffLine::Resulting(r) => {\n+                    writeln!(dest, \"+\\t{}\", r).unwrap();\n+                }\n+            }\n+        }\n+        writeln!(dest).unwrap();\n+    }\n+}\n+\n pub fn run(config: Config, testpaths: &TestPaths, revision: Option<&str>) {\n     match &*config.target {\n         \"arm-linux-androideabi\"\n@@ -3040,6 +3068,89 @@ impl<'test> TestCx<'test> {\n \n     fn check_mir_dump(&self) {\n         let test_file_contents = fs::read_to_string(&self.testpaths.file).unwrap();\n+\n+        let mut test_dir = self.testpaths.file.with_extension(\"\");\n+\n+        if test_file_contents.lines().any(|l| l == \"// EMIT_MIR_FOR_EACH_BIT_WIDTH\") {\n+            test_dir.push(get_pointer_width(&self.config.target))\n+        }\n+\n+        if self.config.bless {\n+            let _ = std::fs::remove_dir_all(&test_dir);\n+        }\n+        for l in test_file_contents.lines() {\n+            if l.starts_with(\"// EMIT_MIR \") {\n+                let test_name = l.trim_start_matches(\"// EMIT_MIR \");\n+                let expected_file = test_dir.join(test_name);\n+\n+                let dumped_string = if test_name.ends_with(\".diff\") {\n+                    let test_name = test_name.trim_end_matches(\".diff\");\n+                    let before = format!(\"{}.before.mir\", test_name);\n+                    let after = format!(\"{}.after.mir\", test_name);\n+                    let before = self.get_mir_dump_dir().join(before);\n+                    let after = self.get_mir_dump_dir().join(after);\n+                    debug!(\n+                        \"comparing the contents of: {} with {}\",\n+                        before.display(),\n+                        after.display()\n+                    );\n+                    let before = fs::read_to_string(before).unwrap();\n+                    let after = fs::read_to_string(after).unwrap();\n+                    let before = self.normalize_output(&before, &[]);\n+                    let after = self.normalize_output(&after, &[]);\n+                    let mut dumped_string = String::new();\n+                    for result in diff::lines(&before, &after) {\n+                        use std::fmt::Write;\n+                        match result {\n+                            diff::Result::Left(s) => writeln!(dumped_string, \"- {}\", s).unwrap(),\n+                            diff::Result::Right(s) => writeln!(dumped_string, \"+ {}\", s).unwrap(),\n+                            diff::Result::Both(s, _) => writeln!(dumped_string, \"  {}\", s).unwrap(),\n+                        }\n+                    }\n+                    dumped_string\n+                } else {\n+                    let mut output_file = PathBuf::new();\n+                    output_file.push(self.get_mir_dump_dir());\n+                    output_file.push(test_name);\n+                    debug!(\n+                        \"comparing the contents of: {} with {}\",\n+                        output_file.display(),\n+                        expected_file.display()\n+                    );\n+                    if !output_file.exists() {\n+                        panic!(\n+                            \"Output file `{}` from test does not exist, available files are in `{}`\",\n+                            output_file.display(),\n+                            output_file.parent().unwrap().display()\n+                        );\n+                    }\n+                    self.check_mir_test_timestamp(test_name, &output_file);\n+                    let dumped_string = fs::read_to_string(&output_file).unwrap();\n+                    self.normalize_output(&dumped_string, &[])\n+                };\n+                if self.config.bless {\n+                    let _ = std::fs::create_dir_all(&test_dir);\n+                    let _ = std::fs::remove_file(&expected_file);\n+                    std::fs::write(expected_file, dumped_string.as_bytes()).unwrap();\n+                } else {\n+                    if !expected_file.exists() {\n+                        panic!(\n+                            \"Output file `{}` from test does not exist\",\n+                            expected_file.display()\n+                        );\n+                    }\n+                    let expected_string = fs::read_to_string(&expected_file).unwrap();\n+                    if dumped_string != expected_string {\n+                        print_diff(&dumped_string, &expected_string, 3);\n+                        panic!(\n+                            \"Actual MIR output differs from expected MIR output {}\",\n+                            expected_file.display()\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n         if let Some(idx) = test_file_contents.find(\"// END RUST SOURCE\") {\n             let (_, tests_text) = test_file_contents.split_at(idx + \"// END_RUST SOURCE\".len());\n             let tests_text_str = String::from(tests_text);\n@@ -3090,13 +3201,10 @@ impl<'test> TestCx<'test> {\n         let mut output_file = PathBuf::new();\n         output_file.push(self.get_mir_dump_dir());\n         output_file.push(test_name);\n-        debug!(\"comparing the contests of: {:?}\", output_file);\n+        debug!(\"comparing the contents of: {:?}\", output_file);\n         debug!(\"with: {:?}\", expected_content);\n         if !output_file.exists() {\n-            panic!(\n-                \"Output file `{}` from test does not exist\",\n-                output_file.into_os_string().to_string_lossy()\n-            );\n+            panic!(\"Output file `{}` from test does not exist\", output_file.display());\n         }\n         self.check_mir_test_timestamp(test_name, &output_file);\n \n@@ -3356,26 +3464,7 @@ impl<'test> TestCx<'test> {\n                 println!(\"normalized {}:\\n{}\\n\", kind, actual);\n             } else {\n                 println!(\"diff of {}:\\n\", kind);\n-                let diff_results = make_diff(expected, actual, 3);\n-                for result in diff_results {\n-                    let mut line_number = result.line_number;\n-                    for line in result.lines {\n-                        match line {\n-                            DiffLine::Expected(e) => {\n-                                println!(\"-\\t{}\", e);\n-                                line_number += 1;\n-                            }\n-                            DiffLine::Context(c) => {\n-                                println!(\"{}\\t{}\", line_number, c);\n-                                line_number += 1;\n-                            }\n-                            DiffLine::Resulting(r) => {\n-                                println!(\"+\\t{}\", r);\n-                            }\n-                        }\n-                    }\n-                    println!();\n-                }\n+                print_diff(expected, actual, 3);\n             }\n         }\n "}]}