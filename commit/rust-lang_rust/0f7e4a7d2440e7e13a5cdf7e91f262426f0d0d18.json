{"sha": "0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmN2U0YTdkMjQ0MGU3ZTEzYTVjZGY3ZTkxZjI2MjQyNmYwZDBkMTg=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-03-24T16:37:27Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-03-25T20:28:36Z"}, "message": "Implement a very naive implements check\n\n... to make the infer_trait_method_simple test have the correct result.", "tree": {"sha": "ada013fd4cc4a246ae308e7f7be2ae6e07d072e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ada013fd4cc4a246ae308e7f7be2ae6e07d072e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18", "html_url": "https://github.com/rust-lang/rust/commit/0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c947c15ce1ec02261803f10568e4659e9396109e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c947c15ce1ec02261803f10568e4659e9396109e", "html_url": "https://github.com/rust-lang/rust/commit/c947c15ce1ec02261803f10568e4659e9396109e"}], "stats": {"total": 62, "additions": 50, "deletions": 12}, "files": [{"sha": "143919cdcf72ee0ca9738db0948909fbbc20c505", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18", "patch": "@@ -14,7 +14,7 @@ use crate::{\n     impl_block::{ModuleImplBlocks, ImplSourceMap},\n     generics::{GenericParams, GenericDef},\n     type_ref::TypeRef,\n-    traits::TraitData, Trait\n+    traits::TraitData, Trait, ty::TraitRef\n };\n \n #[salsa::query_group(DefDatabaseStorage)]\n@@ -102,6 +102,9 @@ pub trait HirDatabase: DefDatabase {\n \n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n     fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;\n+\n+    #[salsa::invoke(crate::ty::method_resolution::implements)]\n+    fn implements(&self, trait_ref: TraitRef) -> bool;\n }\n \n #[test]"}, {"sha": "d42c61e9d345757bae3789428c88add9f6b84d79", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18", "patch": "@@ -14,7 +14,7 @@ pub(crate) mod display;\n use std::sync::Arc;\n use std::{fmt, mem};\n \n-use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase};\n+use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase, Trait};\n \n pub(crate) use lower::{TypableDef, CallableDef, type_for_def, type_for_field, callable_item_sig};\n pub(crate) use infer::{infer, InferenceResult, InferTy};\n@@ -91,7 +91,7 @@ pub enum TypeCtor {\n /// A nominal type with (maybe 0) type parameters. This might be a primitive\n /// type like `bool`, a struct, tuple, function pointer, reference or\n /// several other things.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct ApplicationTy {\n     pub ctor: TypeCtor,\n     pub parameters: Substs,\n@@ -103,7 +103,7 @@ pub struct ApplicationTy {\n /// the same thing (but in a different way).\n ///\n /// This should be cheap to clone.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum Ty {\n     /// A nominal type with (maybe 0) type parameters. This might be a primitive\n     /// type like `bool`, a struct, tuple, function pointer, reference or\n@@ -132,7 +132,7 @@ pub enum Ty {\n }\n \n /// A list of substitutions for generic parameters.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Substs(Arc<[Ty]>);\n \n impl Substs {\n@@ -169,6 +169,21 @@ impl Substs {\n     }\n }\n \n+/// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n+/// Name to be bikeshedded: TraitBound? TraitImplements?\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct TraitRef {\n+    /// FIXME name?\n+    trait_: Trait,\n+    substs: Substs,\n+}\n+\n+impl TraitRef {\n+    pub fn self_ty(&self) -> &Ty {\n+        &self.substs.0[0]\n+    }\n+}\n+\n /// A function signature as seen by type inference: Several parameter types and\n /// one return type.\n #[derive(Clone, PartialEq, Eq, Debug)]"}, {"sha": "146e8a02e7d3a8187336fc5e516ca84cd7c4a458", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18", "patch": "@@ -8,12 +8,12 @@ use rustc_hash::FxHashMap;\n \n use crate::{\n     HirDatabase, Module, Crate, Name, Function, Trait,\n-    ids::TraitId,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n     ty::{Ty, TypeCtor},\n     nameres::CrateModuleId, resolve::Resolver, traits::TraitItem\n \n };\n+use super::{ TraitRef, Substs};\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -38,7 +38,7 @@ pub struct CrateImplBlocks {\n     /// To make sense of the CrateModuleIds, we need the source root.\n     krate: Crate,\n     impls: FxHashMap<TyFingerprint, Vec<(CrateModuleId, ImplId)>>,\n-    impls_by_trait: FxHashMap<TraitId, Vec<(CrateModuleId, ImplId)>>,\n+    impls_by_trait: FxHashMap<Trait, Vec<(CrateModuleId, ImplId)>>,\n }\n \n impl CrateImplBlocks {\n@@ -56,8 +56,7 @@ impl CrateImplBlocks {\n         &'a self,\n         tr: &Trait,\n     ) -> impl Iterator<Item = ImplBlock> + 'a {\n-        let id = tr.id;\n-        self.impls_by_trait.get(&id).into_iter().flat_map(|i| i.iter()).map(\n+        self.impls_by_trait.get(&tr).into_iter().flat_map(|i| i.iter()).map(\n             move |(module_id, impl_id)| {\n                 let module = Module { krate: self.krate, module_id: *module_id };\n                 ImplBlock::from_id(module, *impl_id)\n@@ -75,7 +74,7 @@ impl CrateImplBlocks {\n \n             if let Some(tr) = impl_block.target_trait(db) {\n                 self.impls_by_trait\n-                    .entry(tr.id)\n+                    .entry(tr)\n                     .or_insert_with(Vec::new)\n                     .push((module.module_id, impl_id));\n             } else {\n@@ -109,6 +108,24 @@ impl CrateImplBlocks {\n     }\n }\n \n+/// Rudimentary check whether an impl exists for a given type and trait; this\n+/// will actually be done by chalk.\n+pub(crate) fn implements(db: &impl HirDatabase, trait_ref: TraitRef) -> bool {\n+    // FIXME use all trait impls in the whole crate graph\n+    let krate = trait_ref.trait_.module(db).krate(db);\n+    let krate = match krate {\n+        Some(krate) => krate,\n+        None => return false,\n+    };\n+    let crate_impl_blocks = db.impls_in_crate(krate);\n+    for impl_block in crate_impl_blocks.lookup_impl_blocks_for_trait(&trait_ref.trait_) {\n+        if &impl_block.target_ty(db) == trait_ref.self_ty() {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n     match ty {\n         Ty::Apply(a_ty) => match a_ty.ctor {\n@@ -162,7 +179,10 @@ impl Ty {\n             }\n         }\n         // FIXME the implements check may result in other obligations or unifying variables?\n-        candidates.retain(|(_t, _m)| /* self implements t */ true);\n+        candidates.retain(|(t, _m)| {\n+            let trait_ref = TraitRef { trait_: *t, substs: Substs::single(self.clone()) };\n+            db.implements(trait_ref)\n+        });\n         // FIXME what happens if there are still multiple potential candidates?\n         let (_chosen_trait, chosen_method) = candidates.first()?;\n         Some((self.clone(), *chosen_method))"}, {"sha": "655f3c52237611b2897e2f0895fa1f80d90d8b3d", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=0f7e4a7d2440e7e13a5cdf7e91f262426f0d0d18", "patch": "@@ -1920,7 +1920,7 @@ fn test() {\n [176; 178) 'S1': S1\n [176; 187) 'S1.method()': u32\n [203; 205) 'S2': S2\n-[203; 214) 'S2.method()': u32\"###\n+[203; 214) 'S2.method()': i128\"###\n     );\n }\n "}]}