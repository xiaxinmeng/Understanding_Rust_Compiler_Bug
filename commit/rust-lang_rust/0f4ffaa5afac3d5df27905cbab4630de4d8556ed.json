{"sha": "0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "node_id": "C_kwDOAAsO6NoAKDBmNGZmYWE1YWZhYzNkNWRmMjc5MDVjYmFiNDYzMGRlNGQ4NTU2ZWQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-04-16T16:29:42Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-04-16T17:20:35Z"}, "message": "Fix duplicate eager expansion errors", "tree": {"sha": "57e99063d07410d4f9c99de2b67ad5c5b7e126ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57e99063d07410d4f9c99de2b67ad5c5b7e126ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "html_url": "https://github.com/rust-lang/rust/commit/0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1632c2727474c0a88b19de3718af806d42e4450", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1632c2727474c0a88b19de3718af806d42e4450", "html_url": "https://github.com/rust-lang/rust/commit/d1632c2727474c0a88b19de3718af806d42e4450"}], "stats": {"total": 120, "additions": 70, "deletions": 50}, "files": [{"sha": "668b436e0196579289254e012c921335ff3e6c48", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "patch": "@@ -638,7 +638,6 @@ impl<'a> AssocItemCollector<'a> {\n                     self.items.push((item.name.clone(), def.into()));\n                 }\n                 AssocItem::MacroCall(call) => {\n-                    // TODO: These are the wrong errors to report, report in collect_macro_items instead\n                     let file_id = self.expander.current_file_id();\n                     let root = self.db.parse_or_expand(file_id);\n                     if let Some(root) = root {"}, {"sha": "48c1baf3081b306e67962a3699ccf58753254604", "filename": "crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "patch": "@@ -101,6 +101,7 @@ pub struct ItemTree {\n     top_level: SmallVec<[ModItem; 1]>,\n     attrs: FxHashMap<AttrOwner, RawAttrs>,\n \n+    // FIXME: Remove this indirection, an item tree is almost always non-empty?\n     data: Option<Box<ItemTreeData>>,\n }\n "}, {"sha": "34d704942abcaa10e144ce0f909313528a096203", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "patch": "@@ -823,7 +823,7 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n             return Ok(ExpandResult::only_err(ExpandError::Other(\"malformed macro invocation\".into())));\n         };\n \n-        macro_call_as_call_id(\n+        macro_call_as_call_id_(\n             db,\n             &AstIdWithPath::new(ast_id.file_id, ast_id.value, path),\n             expands_to,\n@@ -852,6 +852,16 @@ fn macro_call_as_call_id(\n     expand_to: ExpandTo,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+) -> Result<Option<MacroCallId>, UnresolvedMacro> {\n+    macro_call_as_call_id_(db, call, expand_to, krate, resolver).map(|res| res.value)\n+}\n+\n+fn macro_call_as_call_id_(\n+    db: &dyn db::DefDatabase,\n+    call: &AstIdWithPath<ast::MacroCall>,\n+    expand_to: ExpandTo,\n+    krate: CrateId,\n+    resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n ) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro> {\n     let def =\n         resolver(call.path.clone()).ok_or_else(|| UnresolvedMacro { path: call.path.clone() })?;"}, {"sha": "6592c6b90249d1e353a7235409b813c2e2ae1454", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "patch": "@@ -1117,8 +1117,9 @@ impl DefCollector<'_> {\n                         self.def_map.krate,\n                         resolver_def_id,\n                     );\n-                    if let Ok(ExpandResult { value: Some(call_id), .. }) = call_id {\n+                    if let Ok(Some(call_id)) = call_id {\n                         push_resolved(directive, call_id);\n+\n                         res = ReachedFixedPoint::No;\n                         return false;\n                     }\n@@ -1354,26 +1355,30 @@ impl DefCollector<'_> {\n         let file_id = macro_call_id.as_file();\n \n         // First, fetch the raw expansion result for purposes of error reporting. This goes through\n-        // `macro_expand_error` to avoid depending on the full expansion result (to improve\n+        // `parse_macro_expansion_error` to avoid depending on the full expansion result (to improve\n         // incrementality).\n-        let loc: MacroCallLoc = self.db.lookup_intern_macro_call(macro_call_id);\n-        let err = self.db.macro_expand_error(macro_call_id);\n+        let ExpandResult { value, err } = self.db.parse_macro_expansion_error(macro_call_id);\n         if let Some(err) = err {\n+            let loc: MacroCallLoc = self.db.lookup_intern_macro_call(macro_call_id);\n             let diag = match err {\n+                // why is this reported here?\n                 hir_expand::ExpandError::UnresolvedProcMacro(krate) => {\n                     always!(krate == loc.def.krate);\n-                    // Missing proc macros are non-fatal, so they are handled specially.\n                     DefDiagnostic::unresolved_proc_macro(module_id, loc.kind.clone(), loc.def.krate)\n                 }\n-                _ => DefDiagnostic::macro_error(module_id, loc.kind, err.to_string()),\n+                _ => DefDiagnostic::macro_error(module_id, loc.kind.clone(), err.to_string()),\n             };\n \n             self.def_map.diagnostics.push(diag);\n         }\n+        if let Some(errors) = value {\n+            let loc: MacroCallLoc = self.db.lookup_intern_macro_call(macro_call_id);\n+            let diag = DefDiagnostic::macro_expansion_parse_error(module_id, loc.kind, &errors);\n+            self.def_map.diagnostics.push(diag);\n+        }\n \n         // Then, fetch and process the item tree. This will reuse the expansion result from above.\n         let item_tree = self.db.file_item_tree(file_id);\n-        // FIXME: report parse errors for the macro expansion here\n \n         let mod_dir = self.mod_dirs[&module_id].clone();\n         ModCollector {\n@@ -1395,6 +1400,7 @@ impl DefCollector<'_> {\n         for directive in &self.unresolved_macros {\n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n+                    // FIXME: we shouldn't need to re-resolve the macro here just to get the unresolved error!\n                     let macro_call_as_call_id = macro_call_as_call_id(\n                         self.db,\n                         ast_id,\n@@ -2110,7 +2116,7 @@ impl ModCollector<'_, '_> {\n         let ast_id = AstIdWithPath::new(self.file_id(), mac.ast_id, ModPath::clone(&mac.path));\n \n         // Case 1: try to resolve in legacy scope and expand macro_rules\n-        match macro_call_as_call_id(\n+        if let Ok(res) = macro_call_as_call_id(\n             self.def_collector.db,\n             &ast_id,\n             mac.expand_to,\n@@ -2131,29 +2137,18 @@ impl ModCollector<'_, '_> {\n                 })\n             },\n         ) {\n-            Ok(res) => {\n-                // Legacy macros need to be expanded immediately, so that any macros they produce\n-                // are in scope.\n-                if let Some(val) = res.value {\n-                    self.def_collector.collect_macro_expansion(\n-                        self.module_id,\n-                        val,\n-                        self.macro_depth + 1,\n-                        container,\n-                    );\n-                }\n-\n-                if let Some(err) = res.err {\n-                    self.def_collector.def_map.diagnostics.push(DefDiagnostic::macro_error(\n-                        self.module_id,\n-                        MacroCallKind::FnLike { ast_id: ast_id.ast_id, expand_to: mac.expand_to },\n-                        err.to_string(),\n-                    ));\n-                }\n-\n-                return;\n+            // Legacy macros need to be expanded immediately, so that any macros they produce\n+            // are in scope.\n+            if let Some(val) = res {\n+                self.def_collector.collect_macro_expansion(\n+                    self.module_id,\n+                    val,\n+                    self.macro_depth + 1,\n+                    container,\n+                );\n             }\n-            Err(UnresolvedMacro { .. }) => (),\n+\n+            return;\n         }\n \n         // Case 2: resolve in module scope, expand during name resolution."}, {"sha": "b07462cde0f19a706e9b6bff3116b4ab0323516b", "filename": "crates/hir-def/src/nameres/tests/incremental.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "patch": "@@ -140,7 +140,7 @@ m!(Z);\n         let n_recalculated_item_trees = events.iter().filter(|it| it.contains(\"item_tree\")).count();\n         assert_eq!(n_recalculated_item_trees, 6);\n         let n_reparsed_macros =\n-            events.iter().filter(|it| it.contains(\"parse_macro_expansion\")).count();\n+            events.iter().filter(|it| it.contains(\"parse_macro_expansion(\")).count();\n         assert_eq!(n_reparsed_macros, 3);\n     }\n "}, {"sha": "afc2be07418652bff02a4db58bef4b3a372e7227", "filename": "crates/hir-expand/src/db.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "patch": "@@ -9,7 +9,7 @@ use mbe::syntax_node_to_token_tree;\n use rustc_hash::FxHashSet;\n use syntax::{\n     ast::{self, HasAttrs, HasDocComments},\n-    AstNode, GreenNode, Parse, SyntaxNode, SyntaxToken, T,\n+    AstNode, GreenNode, Parse, SyntaxError, SyntaxNode, SyntaxToken, T,\n };\n \n use crate::{\n@@ -132,15 +132,18 @@ pub trait ExpandDatabase: SourceDatabase {\n     /// just fetches procedural ones.\n     fn macro_def(&self, id: MacroDefId) -> Result<Arc<TokenExpander>, mbe::ParseError>;\n \n-    /// Expand macro call to a token tree. This query is LRUed (we keep 128 or so results in memory)\n+    /// Expand macro call to a token tree.\n     fn macro_expand(&self, macro_call: MacroCallId) -> ExpandResult<Option<Arc<tt::Subtree>>>;\n     /// Special case of the previous query for procedural macros. We can't LRU\n     /// proc macros, since they are not deterministic in general, and\n     /// non-determinism breaks salsa in a very, very, very bad way. @edwin0cheng\n     /// heroically debugged this once!\n     fn expand_proc_macro(&self, call: MacroCallId) -> ExpandResult<tt::Subtree>;\n-    /// Firewall query that returns the error from the `macro_expand` query.\n-    fn macro_expand_error(&self, macro_call: MacroCallId) -> Option<ExpandError>;\n+    /// Firewall query that returns the errors from the `parse_macro_expansion` query.\n+    fn parse_macro_expansion_error(\n+        &self,\n+        macro_call: MacroCallId,\n+    ) -> ExpandResult<Option<Box<[SyntaxError]>>>;\n \n     fn hygiene_frame(&self, file_id: HirFileId) -> Arc<HygieneFrame>;\n }\n@@ -448,6 +451,7 @@ fn macro_def(\n fn macro_expand(\n     db: &dyn ExpandDatabase,\n     id: MacroCallId,\n+    // FIXME: Remove the OPtion if possible\n ) -> ExpandResult<Option<Arc<tt::Subtree>>> {\n     let _p = profile::span(\"macro_expand\");\n     let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n@@ -498,8 +502,12 @@ fn macro_expand(\n     ExpandResult { value: Some(Arc::new(tt)), err }\n }\n \n-fn macro_expand_error(db: &dyn ExpandDatabase, macro_call: MacroCallId) -> Option<ExpandError> {\n-    db.macro_expand(macro_call).err\n+fn parse_macro_expansion_error(\n+    db: &dyn ExpandDatabase,\n+    macro_call_id: MacroCallId,\n+) -> ExpandResult<Option<Box<[SyntaxError]>>> {\n+    db.parse_macro_expansion(MacroFile { macro_call_id })\n+        .map(|it| it.map(|(it, _)| it.errors().to_vec().into_boxed_slice()))\n }\n \n fn expand_proc_macro(db: &dyn ExpandDatabase, id: MacroCallId) -> ExpandResult<tt::Subtree> {"}, {"sha": "7ec27af04b9d32a42a9f5627b5fe2c64fb203c18", "filename": "crates/hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fhir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fhir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdb.rs?ref=0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "patch": "@@ -6,8 +6,8 @@\n pub use hir_def::db::*;\n pub use hir_expand::db::{\n     AstIdMapQuery, ExpandDatabase, ExpandDatabaseStorage, ExpandProcMacroQuery, HygieneFrameQuery,\n-    InternMacroCallQuery, MacroArgTextQuery, MacroDefQuery, MacroExpandErrorQuery,\n-    MacroExpandQuery, ParseMacroExpansionQuery,\n+    InternMacroCallQuery, MacroArgTextQuery, MacroDefQuery, MacroExpandQuery,\n+    ParseMacroExpansionQuery,\n };\n pub use hir_ty::db::*;\n "}, {"sha": "8d14371d034a9b9f5b3e616d3cb347c6ae1d35ce", "filename": "crates/ide-db/src/apply_change.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fide-db%2Fsrc%2Fapply_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fide-db%2Fsrc%2Fapply_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fapply_change.rs?ref=0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "patch": "@@ -80,7 +80,6 @@ impl RootDatabase {\n             hir::db::MacroDefQuery\n             hir::db::MacroExpandQuery\n             hir::db::ExpandProcMacroQuery\n-            hir::db::MacroExpandErrorQuery\n             hir::db::HygieneFrameQuery\n \n             // DefDatabase"}, {"sha": "12b6e3c4bb83484ecd1c48e6ca454efaaeb34ede", "filename": "crates/ide-db/src/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Flib.rs?ref=0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "patch": "@@ -152,7 +152,6 @@ impl RootDatabase {\n         let lru_capacity = lru_capacity.unwrap_or(base_db::DEFAULT_LRU_CAP);\n         base_db::ParseQuery.in_db_mut(self).set_lru_capacity(lru_capacity);\n         hir::db::ParseMacroExpansionQuery.in_db_mut(self).set_lru_capacity(lru_capacity);\n-        hir::db::MacroExpandQuery.in_db_mut(self).set_lru_capacity(lru_capacity);\n     }\n \n     pub fn update_lru_capacities(&mut self, lru_capacities: &FxHashMap<Box<str>, usize>) {\n@@ -167,12 +166,6 @@ impl RootDatabase {\n                 .copied()\n                 .unwrap_or(base_db::DEFAULT_LRU_CAP),\n         );\n-        hir_db::MacroExpandQuery.in_db_mut(self).set_lru_capacity(\n-            lru_capacities\n-                .get(stringify!(MacroExpandQuery))\n-                .copied()\n-                .unwrap_or(base_db::DEFAULT_LRU_CAP),\n-        );\n \n         macro_rules! update_lru_capacity_per_query {\n             ($( $module:ident :: $query:ident )*) => {$(\n@@ -201,7 +194,6 @@ impl RootDatabase {\n             hir_db::MacroDefQuery\n             // hir_db::MacroExpandQuery\n             hir_db::ExpandProcMacroQuery\n-            hir_db::MacroExpandErrorQuery\n             hir_db::HygieneFrameQuery\n \n             // DefDatabase"}, {"sha": "7547779a95c72da17fc1f07523f53eaefab95949", "filename": "crates/ide-diagnostics/src/handlers/macro_error.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ffaa5afac3d5df27905cbab4630de4d8556ed/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs?ref=0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "patch": "@@ -238,6 +238,22 @@ fn f() {\n   //^^^ error: invalid macro definition: expected subtree\n \n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn expansion_syntax_diagnostic() {\n+        check_diagnostics(\n+            r#\"\n+macro_rules! foo {\n+    () => { struct; };\n+}\n+\n+fn f() {\n+    foo!();\n+  //^^^ error: Syntax Error in Expansion: expected a name\n+}\n \"#,\n         )\n     }"}]}