{"sha": "42232ba70add056cf422960ac96986264870b313", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMjMyYmE3MGFkZDA1NmNmNDIyOTYwYWM5Njk4NjI2NDg3MGIzMTM=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-07-18T20:48:03Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-22T04:25:28Z"}, "message": "rustdoc: Add support for associated items even outside the impl itself\n\nPreviously, associated items would only be available for linking\ndirectly on the `impl Trait for Type`. Now they can be used anywhere.\n\n- Make `item` for resolve mandatory\n- Refactor resolving associated items into a separate function\n- Remove broken trait_item logic\n- Don't skip the type namespace for associated items\n- Only call `variant_field` for `TypeNS`\n- Add test for associated items\n- Use exhaustive matches instead of wildcards\n\nWildcards caused several bugs while implementing this.", "tree": {"sha": "7dc620d2855ca503beeca6845d0a1281bd2e1ea8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dc620d2855ca503beeca6845d0a1281bd2e1ea8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42232ba70add056cf422960ac96986264870b313", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42232ba70add056cf422960ac96986264870b313", "html_url": "https://github.com/rust-lang/rust/commit/42232ba70add056cf422960ac96986264870b313", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42232ba70add056cf422960ac96986264870b313/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a97d65d6e474e86cad99cd833a5cd2ba32eb678f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a97d65d6e474e86cad99cd833a5cd2ba32eb678f", "html_url": "https://github.com/rust-lang/rust/commit/a97d65d6e474e86cad99cd833a5cd2ba32eb678f"}], "stats": {"total": 373, "additions": 284, "deletions": 89}, "files": [{"sha": "932585918dfb3f1142cdf913893d21ba2bf61768", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/42232ba70add056cf422960ac96986264870b313/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42232ba70add056cf422960ac96986264870b313/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=42232ba70add056cf422960ac96986264870b313", "patch": "@@ -20,7 +20,7 @@ use rustc_hir::lang_items;\n use rustc_hir::Mutability;\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::stability;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{AssocKind, TyCtxt};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -288,6 +288,15 @@ impl ItemEnum {\n             _ => false,\n         }\n     }\n+\n+    pub fn as_assoc_kind(&self) -> Option<AssocKind> {\n+        match *self {\n+            ItemEnum::AssocConstItem(..) => Some(AssocKind::Const),\n+            ItemEnum::AssocTypeItem(..) => Some(AssocKind::Type),\n+            ItemEnum::TyMethodItem(..) | ItemEnum::MethodItem(..) => Some(AssocKind::Fn),\n+            _ => None,\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "199d5d201dc323baf70fef35c62d9b1d1a5c0754", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 188, "deletions": 88, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/42232ba70add056cf422960ac96986264870b313/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42232ba70add056cf422960ac96986264870b313/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=42232ba70add056cf422960ac96986264870b313", "patch": "@@ -185,7 +185,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         current_item: &Option<String>,\n         parent_id: Option<DefId>,\n         extra_fragment: &Option<String>,\n-        item_opt: Option<&Item>,\n     ) -> Result<(Res, Option<String>), ErrorKind> {\n         let cx = self.cx;\n \n@@ -245,13 +244,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     return Err(ErrorKind::AnchorFailure(AnchorFailure::Primitive));\n                 }\n                 return Ok((prim, Some(path.to_owned())));\n-            } else {\n-                // If resolution failed, it may still be a method\n-                // because methods are not handled by the resolver\n-                // If so, bail when we're not looking for a value.\n-                if ns != ValueNS {\n-                    return Err(ErrorKind::ResolutionFailure);\n-                }\n             }\n \n             // Try looking for methods and associated items.\n@@ -299,65 +291,54 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 })\n                 .map_err(|_| ErrorKind::ResolutionFailure)?;\n             if let Res::Err = ty_res {\n-                return self.variant_field(path_str, current_item, module_id);\n+                return if ns == Namespace::ValueNS {\n+                    self.variant_field(path_str, current_item, module_id)\n+                } else {\n+                    Err(ErrorKind::ResolutionFailure)\n+                };\n             }\n             let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n-            match ty_res {\n+            let res = match ty_res {\n                 Res::Def(\n                     DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::TyAlias,\n                     did,\n                 ) => {\n+                    debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n                     // Checks if item_name belongs to `impl SomeItem`\n-                    let impl_item = cx\n+                    let kind = cx\n                         .tcx\n                         .inherent_impls(did)\n                         .iter()\n-                        .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n-                        .find(|item| item.ident.name == item_name);\n-                    let trait_item = item_opt\n-                        .and_then(|item| self.cx.as_local_hir_id(item.def_id))\n-                        .and_then(|item_hir| {\n-                            // Checks if item_name belongs to `impl SomeTrait for SomeItem`\n-                            let parent_hir = self.cx.tcx.hir().get_parent_item(item_hir);\n-                            let item_parent = self.cx.tcx.hir().find(parent_hir);\n-                            match item_parent {\n-                                Some(hir::Node::Item(hir::Item {\n-                                    kind: hir::ItemKind::Impl { of_trait: Some(_), self_ty, .. },\n-                                    ..\n-                                })) => cx\n-                                    .tcx\n-                                    .associated_item_def_ids(self_ty.hir_id.owner)\n-                                    .iter()\n-                                    .map(|child| {\n-                                        let associated_item = cx.tcx.associated_item(*child);\n-                                        associated_item\n-                                    })\n-                                    .find(|child| child.ident.name == item_name),\n-                                _ => None,\n-                            }\n+                        .flat_map(|&imp| {\n+                            cx.tcx.associated_items(imp).find_by_name_and_namespace(\n+                                cx.tcx,\n+                                Ident::with_dummy_span(item_name),\n+                                ns,\n+                                imp,\n+                            )\n+                        })\n+                        .map(|item| item.kind)\n+                        // There should only ever be one associated item that matches from any inherent impl\n+                        .next()\n+                        // Check if item_name belongs to `impl SomeTrait for SomeItem`\n+                        // This gives precedence to `impl SomeItem`:\n+                        // Although having both would be ambiguous, use impl version for compat. sake.\n+                        // To handle that properly resolve() would have to support\n+                        // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n+                        .or_else(|| {\n+                            let kind = resolve_associated_trait_item(did, item_name, ns, &self.cx);\n+                            debug!(\"got associated item kind {:?}\", kind);\n+                            kind\n                         });\n-                    let item = match (impl_item, trait_item) {\n-                        (Some(from_impl), Some(_)) => {\n-                            // Although it's ambiguous, return impl version for compat. sake.\n-                            // To handle that properly resolve() would have to support\n-                            // something like\n-                            // [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n-                            Some(from_impl)\n-                        }\n-                        (None, Some(from_trait)) => Some(from_trait),\n-                        (Some(from_impl), None) => Some(from_impl),\n-                        _ => None,\n-                    };\n \n-                    if let Some(item) = item {\n-                        let out = match item.kind {\n-                            ty::AssocKind::Fn if ns == ValueNS => \"method\",\n-                            ty::AssocKind::Const if ns == ValueNS => \"associatedconstant\",\n-                            ty::AssocKind::Type if ns == ValueNS => \"associatedtype\",\n-                            _ => return self.variant_field(path_str, current_item, module_id),\n+                    if let Some(kind) = kind {\n+                        let out = match kind {\n+                            ty::AssocKind::Fn => \"method\",\n+                            ty::AssocKind::Const => \"associatedconstant\",\n+                            ty::AssocKind::Type => \"associatedtype\",\n                         };\n-                        if extra_fragment.is_some() {\n-                            Err(ErrorKind::AnchorFailure(if item.kind == ty::AssocKind::Fn {\n+                        Some(if extra_fragment.is_some() {\n+                            Err(ErrorKind::AnchorFailure(if kind == ty::AssocKind::Fn {\n                                 AnchorFailure::Method\n                             } else {\n                                 AnchorFailure::AssocConstant\n@@ -368,18 +349,19 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             // Store the kind in a side channel so that only the disambiguator logic looks at it.\n                             self.kind_side_channel.replace(Some(item.kind.as_def_kind()));\n                             Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n-                        }\n-                    } else {\n+                        })\n+                    } else if ns == Namespace::ValueNS {\n                         match cx.tcx.type_of(did).kind {\n                             ty::Adt(def, _) => {\n-                                if let Some(item) = if def.is_enum() {\n+                                let field = if def.is_enum() {\n                                     def.all_fields().find(|item| item.ident.name == item_name)\n                                 } else {\n                                     def.non_enum_variant()\n                                         .fields\n                                         .iter()\n                                         .find(|item| item.ident.name == item_name)\n-                                } {\n+                                };\n+                                field.map(|item| {\n                                     if extra_fragment.is_some() {\n                                         Err(ErrorKind::AnchorFailure(if def.is_enum() {\n                                             AnchorFailure::Variant\n@@ -400,31 +382,31 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                             )),\n                                         ))\n                                     }\n-                                } else {\n-                                    self.variant_field(path_str, current_item, module_id)\n-                                }\n+                                })\n                             }\n-                            _ => self.variant_field(path_str, current_item, module_id),\n+                            _ => None,\n                         }\n+                    } else {\n+                        // We already know this isn't in ValueNS, so no need to check variant_field\n+                        return Err(ErrorKind::ResolutionFailure);\n                     }\n                 }\n-                Res::Def(DefKind::Trait, did) => {\n-                    let item = cx\n-                        .tcx\n-                        .associated_item_def_ids(did)\n-                        .iter()\n-                        .map(|item| cx.tcx.associated_item(*item))\n-                        .find(|item| item.ident.name == item_name);\n-                    if let Some(item) = item {\n-                        let kind =\n-                            match item.kind {\n-                                ty::AssocKind::Const if ns == ValueNS => \"associatedconstant\",\n-                                ty::AssocKind::Type if ns == TypeNS => \"associatedtype\",\n-                                ty::AssocKind::Fn if ns == ValueNS => {\n-                                    if item.defaultness.has_value() { \"method\" } else { \"tymethod\" }\n+                Res::Def(DefKind::Trait, did) => cx\n+                    .tcx\n+                    .associated_items(did)\n+                    .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, did)\n+                    .map(|item| {\n+                        let kind = match item.kind {\n+                            ty::AssocKind::Const => \"associatedconstant\",\n+                            ty::AssocKind::Type => \"associatedtype\",\n+                            ty::AssocKind::Fn => {\n+                                if item.defaultness.has_value() {\n+                                    \"method\"\n+                                } else {\n+                                    \"tymethod\"\n                                 }\n-                                _ => return self.variant_field(path_str, current_item, module_id),\n-                            };\n+                            }\n+                        };\n \n                         if extra_fragment.is_some() {\n                             Err(ErrorKind::AnchorFailure(if item.kind == ty::AssocKind::Const {\n@@ -438,19 +420,135 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n                             Ok((res, Some(format!(\"{}.{}\", kind, item_name))))\n                         }\n-                    } else {\n-                        self.variant_field(path_str, current_item, module_id)\n-                    }\n+                    }),\n+                _ => None,\n+            };\n+            res.unwrap_or_else(|| {\n+                if ns == Namespace::ValueNS {\n+                    self.variant_field(path_str, current_item, module_id)\n+                } else {\n+                    Err(ErrorKind::ResolutionFailure)\n                 }\n-                _ => self.variant_field(path_str, current_item, module_id),\n-            }\n+            })\n         } else {\n             debug!(\"attempting to resolve item without parent module: {}\", path_str);\n             Err(ErrorKind::ResolutionFailure)\n         }\n     }\n }\n \n+fn resolve_associated_trait_item(\n+    did: DefId,\n+    item_name: Symbol,\n+    ns: Namespace,\n+    cx: &DocContext<'_>,\n+) -> Option<ty::AssocKind> {\n+    use rustc_hir::def_id::LOCAL_CRATE;\n+\n+    let ty = cx.tcx.type_of(did);\n+    // First consider automatic impls: `impl From<T> for T`\n+    let implicit_impls = crate::clean::get_auto_trait_and_blanket_impls(cx, ty, did);\n+    let mut candidates: Vec<_> = implicit_impls\n+        .flat_map(|impl_outer| {\n+            match impl_outer.inner {\n+                ImplItem(impl_) => {\n+                    debug!(\"considering auto or blanket impl for trait {:?}\", impl_.trait_);\n+                    // Give precedence to methods that were overridden\n+                    if !impl_.provided_trait_methods.contains(&*item_name.as_str()) {\n+                        let mut items = impl_.items.into_iter().filter_map(|assoc| {\n+                            if assoc.name.as_deref() != Some(&*item_name.as_str()) {\n+                                return None;\n+                            }\n+                            let kind = assoc\n+                                .inner\n+                                .as_assoc_kind()\n+                                .expect(\"inner items for a trait should be associated items\");\n+                            if kind.namespace() != ns {\n+                                return None;\n+                            }\n+\n+                            trace!(\"considering associated item {:?}\", assoc.inner);\n+                            // We have a slight issue: normal methods come from `clean` types,\n+                            // but provided methods come directly from `tcx`.\n+                            // Fortunately, we don't need the whole method, we just need to know\n+                            // what kind of associated item it is.\n+                            Some((assoc.def_id, kind))\n+                        });\n+                        let assoc = items.next();\n+                        debug_assert_eq!(items.count(), 0);\n+                        assoc\n+                    } else {\n+                        // These are provided methods or default types:\n+                        // ```\n+                        // trait T {\n+                        //   type A = usize;\n+                        //   fn has_default() -> A { 0 }\n+                        // }\n+                        // ```\n+                        let trait_ = impl_.trait_.unwrap().def_id().unwrap();\n+                        cx.tcx\n+                            .associated_items(trait_)\n+                            .find_by_name_and_namespace(\n+                                cx.tcx,\n+                                Ident::with_dummy_span(item_name),\n+                                ns,\n+                                trait_,\n+                            )\n+                            .map(|assoc| (assoc.def_id, assoc.kind))\n+                    }\n+                }\n+                _ => panic!(\"get_impls returned something that wasn't an impl\"),\n+            }\n+        })\n+        .collect();\n+    // Next consider explicit impls: `impl MyTrait for MyType`\n+    // There isn't a cheap way to do this. Just look at every trait!\n+    for &trait_ in cx.tcx.all_traits(LOCAL_CRATE) {\n+        trace!(\"considering explicit impl for trait {:?}\", trait_);\n+        // We can skip the trait if it doesn't have the associated item `item_name`\n+        let assoc_item = cx\n+            .tcx\n+            .associated_items(trait_)\n+            .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n+            .map(|assoc| (assoc.def_id, assoc.kind));\n+        if let Some(assoc_item) = assoc_item {\n+            debug!(\"considering item {:?}\", assoc_item);\n+            // Look at each trait implementation to see if it's an impl for `did`\n+            cx.tcx.for_each_relevant_impl(trait_, ty, |impl_| {\n+                use ty::TyKind;\n+\n+                let trait_ref = cx.tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n+                // Check if these are the same type.\n+                let impl_type = trait_ref.self_ty();\n+                debug!(\n+                    \"comparing type {} with kind {:?} against def_id {:?}\",\n+                    impl_type, impl_type.kind, did\n+                );\n+                // Fast path: if this is a primitive simple `==` will work\n+                let same_type = impl_type == ty\n+                    || match impl_type.kind {\n+                        // Check if these are the same def_id\n+                        TyKind::Adt(def, _) => {\n+                            debug!(\"adt did: {:?}\", def.did);\n+                            def.did == did\n+                        }\n+                        TyKind::Foreign(def_id) => def_id == did,\n+                        _ => false,\n+                    };\n+                if same_type {\n+                    // We found it!\n+                    debug!(\"found a match!\");\n+                    candidates.push(assoc_item);\n+                }\n+            });\n+        }\n+    }\n+\n+    // FIXME: warn about ambiguity\n+    debug!(\"the candidates were {:?}\", candidates);\n+    candidates.pop().map(|(_, kind)| kind)\n+}\n+\n /// Check for resolve collisions between a trait and its derive\n ///\n /// These are common and we should just resolve to the trait in that case\n@@ -644,7 +742,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             &current_item,\n                             base_node,\n                             &extra_fragment,\n-                            Some(&item),\n                         ) {\n                             Ok(res) => res,\n                             Err(ErrorKind::ResolutionFailure) => {\n@@ -673,13 +770,16 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 &current_item,\n                                 base_node,\n                                 &extra_fragment,\n-                                Some(&item),\n                             ) {\n+                                Ok(res) => {\n+                                    debug!(\"got res in TypeNS: {:?}\", res);\n+                                    Some(res)\n+                                }\n                                 Err(ErrorKind::AnchorFailure(msg)) => {\n                                     anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n                                     continue;\n                                 }\n-                                x => x.ok(),\n+                                Err(ErrorKind::ResolutionFailure) => None,\n                             },\n                             value_ns: match self.resolve(\n                                 path_str,\n@@ -688,13 +788,13 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 &current_item,\n                                 base_node,\n                                 &extra_fragment,\n-                                Some(&item),\n                             ) {\n+                                Ok(res) => Some(res),\n                                 Err(ErrorKind::AnchorFailure(msg)) => {\n                                     anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n                                     continue;\n                                 }\n-                                x => x.ok(),\n+                                Err(ErrorKind::ResolutionFailure) => None,\n                             }\n                             .and_then(|(res, fragment)| {\n                                 // Constructors are picked up in the type namespace."}, {"sha": "2051129b948f3ca71170ee2ed02ca09cbd1dfefc", "filename": "src/test/rustdoc/intra-link-associated-defaults.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/42232ba70add056cf422960ac96986264870b313/src%2Ftest%2Frustdoc%2Fintra-link-associated-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42232ba70add056cf422960ac96986264870b313/src%2Ftest%2Frustdoc%2Fintra-link-associated-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-associated-defaults.rs?ref=42232ba70add056cf422960ac96986264870b313", "patch": "@@ -0,0 +1,27 @@\n+// ignore-tidy-linelength\n+#![deny(intra_doc_link_resolution_failure)]\n+#![feature(associated_type_defaults)]\n+\n+pub trait TraitWithDefault {\n+    type T = usize;\n+    fn f() -> Self::T {\n+        0\n+    }\n+}\n+\n+/// Link to [UsesDefaults::T] and [UsesDefaults::f]\n+// @has 'intra_link_associated_defaults/struct.UsesDefaults.html' '//a[@href=\"../intra_link_associated_defaults/struct.UsesDefaults.html#associatedtype.T\"]' 'UsesDefaults::T'\n+// @has 'intra_link_associated_defaults/struct.UsesDefaults.html' '//a[@href=\"../intra_link_associated_defaults/struct.UsesDefaults.html#method.f\"]' 'UsesDefaults::f'\n+pub struct UsesDefaults;\n+impl TraitWithDefault for UsesDefaults {}\n+\n+/// Link to [OverridesDefaults::T] and [OverridesDefaults::f]\n+// @has 'intra_link_associated_defaults/struct.OverridesDefaults.html' '//a[@href=\"../intra_link_associated_defaults/struct.OverridesDefaults.html#associatedtype.T\"]' 'OverridesDefaults::T'\n+// @has 'intra_link_associated_defaults/struct.OverridesDefaults.html' '//a[@href=\"../intra_link_associated_defaults/struct.OverridesDefaults.html#method.f\"]' 'OverridesDefaults::f'\n+pub struct OverridesDefaults;\n+impl TraitWithDefault for OverridesDefaults {\n+    type T = bool;\n+    fn f() -> bool {\n+        true\n+    }\n+}"}, {"sha": "16a21e33748fa100cbfc3c91b99c6c1f46373e2a", "filename": "src/test/rustdoc/intra-link-associated-items.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/42232ba70add056cf422960ac96986264870b313/src%2Ftest%2Frustdoc%2Fintra-link-associated-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42232ba70add056cf422960ac96986264870b313/src%2Ftest%2Frustdoc%2Fintra-link-associated-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-associated-items.rs?ref=42232ba70add056cf422960ac96986264870b313", "patch": "@@ -0,0 +1,59 @@\n+// ignore-tidy-linelength\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+/// [`std::collections::BTreeMap::into_iter`]\n+/// [`String::from`] is ambiguous as to which `From` impl\n+// @has 'intra_link_associated_items/fn.foo.html' '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/collections/btree/map/struct.BTreeMap.html#method.into_iter\"]' 'std::collections::BTreeMap::into_iter'\n+// @has 'intra_link_associated_items/fn.foo.html' '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/string/struct.String.html#method.from\"]' 'String::from'\n+pub fn foo() {}\n+\n+/// Link to [MyStruct], [link from struct][MyStruct::method], [MyStruct::clone], [MyStruct::Input]\n+// @has 'intra_link_associated_items/struct.MyStruct.html' '//a[@href=\"../intra_link_associated_items/struct.MyStruct.html\"]' 'MyStruct'\n+// @has 'intra_link_associated_items/struct.MyStruct.html' '//a[@href=\"../intra_link_associated_items/struct.MyStruct.html#method.method\"]' 'link from struct'\n+// @has 'intra_link_associated_items/struct.MyStruct.html' '//a[@href=\"../intra_link_associated_items/struct.MyStruct.html#method.clone\"]' 'MyStruct::clone'\n+// @has 'intra_link_associated_items/struct.MyStruct.html' '//a[@href=\"../intra_link_associated_items/struct.MyStruct.html#associatedtype.Input\"]' 'MyStruct::Input'\n+pub struct MyStruct { foo: () }\n+\n+impl Clone for MyStruct {\n+    fn clone(&self) -> Self {\n+        MyStruct\n+    }\n+}\n+\n+pub trait T {\n+    type Input;\n+    fn method(i: Self::Input);\n+}\n+\n+impl T for MyStruct {\n+    type Input = usize;\n+\n+    /// [link from method][MyStruct::method] on method\n+    // @has 'intra_link_associated_items/struct.MyStruct.html' '//a[@href=\"../intra_link_associated_items/struct.MyStruct.html#method.method\"]' 'link from method'\n+    fn method(i: usize) {\n+    }\n+}\n+\n+/// Ambiguity between which trait to use\n+pub trait T1 {\n+    fn ambiguous_method();\n+}\n+\n+pub trait T2 {\n+    fn ambiguous_method();\n+}\n+\n+/// Link to [S::ambiguous_method]\n+// FIXME: there is no way to disambiguate these.\n+// Since we have `#[deny(intra_doc_failure)]`, we still know it was one or the other.\n+pub struct S;\n+\n+impl T1 for S {\n+    fn ambiguous_method() {}\n+}\n+\n+impl T2 for S {\n+    fn ambiguous_method() {}\n+}\n+\n+fn main() {}"}]}