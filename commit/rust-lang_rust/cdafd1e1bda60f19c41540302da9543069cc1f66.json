{"sha": "cdafd1e1bda60f19c41540302da9543069cc1f66", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkYWZkMWUxYmRhNjBmMTljNDE1NDAzMDJkYTk1NDMwNjljYzFmNjY=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-26T17:35:59Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T00:46:32Z"}, "message": "Let MissingConstructors handle the subtleties of missing constructors", "tree": {"sha": "a105955ced216a6402454d6c1f2b310debf684b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a105955ced216a6402454d6c1f2b310debf684b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdafd1e1bda60f19c41540302da9543069cc1f66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdafd1e1bda60f19c41540302da9543069cc1f66", "html_url": "https://github.com/rust-lang/rust/commit/cdafd1e1bda60f19c41540302da9543069cc1f66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdafd1e1bda60f19c41540302da9543069cc1f66/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1190e7275cd1eadc0ef17b564fc84551973b6d85", "url": "https://api.github.com/repos/rust-lang/rust/commits/1190e7275cd1eadc0ef17b564fc84551973b6d85", "html_url": "https://github.com/rust-lang/rust/commit/1190e7275cd1eadc0ef17b564fc84551973b6d85"}], "stats": {"total": 161, "additions": 72, "deletions": 89}, "files": [{"sha": "e61578afd78156cbb8c6bd6ba151bce789260817", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 72, "deletions": 89, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/cdafd1e1bda60f19c41540302da9543069cc1f66/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdafd1e1bda60f19c41540302da9543069cc1f66/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=cdafd1e1bda60f19c41540302da9543069cc1f66", "patch": "@@ -1309,11 +1309,6 @@ impl<'tcx> Constructor<'tcx> {\n \n         Pat { ty, span: DUMMY_SP, kind: Box::new(pat) }\n     }\n-\n-    /// Like `apply`, but where all the subpatterns are wildcards `_`.\n-    fn apply_wildcards<'a>(&self, cx: &MatchCheckCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Pat<'tcx> {\n-        self.apply(cx, ty, Fields::wildcards(cx, self, ty))\n-    }\n }\n \n /// Some fields need to be explicitly hidden away in certain cases; see the comment above the\n@@ -1649,35 +1644,15 @@ impl<'tcx> Usefulness<'tcx> {\n         }\n     }\n \n-    fn apply_wildcard(self, ty: Ty<'tcx>) -> Self {\n-        match self {\n-            UsefulWithWitness(witnesses) => {\n-                let wild = Pat::wildcard_from_ty(ty);\n-                UsefulWithWitness(\n-                    witnesses\n-                        .into_iter()\n-                        .map(|mut witness| {\n-                            witness.0.push(wild.clone());\n-                            witness\n-                        })\n-                        .collect(),\n-                )\n-            }\n-            x => x,\n-        }\n-    }\n-\n-    fn apply_missing_ctors(\n+    fn apply_wildcard<'p>(\n         self,\n-        cx: &MatchCheckCtxt<'_, 'tcx>,\n-        ty: Ty<'tcx>,\n-        missing_ctors: &MissingConstructors<'tcx>,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: PatCtxt<'tcx>,\n+        missing_ctors: MissingConstructors<'tcx>,\n     ) -> Self {\n         match self {\n             UsefulWithWitness(witnesses) => {\n-                let new_patterns: Vec<_> =\n-                    missing_ctors.iter().map(|ctor| ctor.apply_wildcards(cx, ty)).collect();\n-                // Add the new patterns to each witness\n+                let new_patterns = missing_ctors.report_patterns(cx, pcx);\n                 UsefulWithWitness(\n                     witnesses\n                         .into_iter()\n@@ -2270,11 +2245,21 @@ impl<'tcx> std::cmp::PartialEq for IntRange<'tcx> {\n struct MissingConstructors<'tcx> {\n     all_ctors: Vec<Constructor<'tcx>>,\n     used_ctors: Vec<Constructor<'tcx>>,\n+    is_top_level: bool,\n }\n \n impl<'tcx> MissingConstructors<'tcx> {\n-    fn new(all_ctors: Vec<Constructor<'tcx>>, used_ctors: Vec<Constructor<'tcx>>) -> Self {\n-        MissingConstructors { all_ctors, used_ctors }\n+    fn new<'p>(\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: PatCtxt<'tcx>,\n+        matrix: &Matrix<'p, 'tcx>,\n+        is_top_level: bool,\n+    ) -> Self {\n+        let used_ctors: Vec<Constructor<'_>> =\n+            matrix.head_ctors(cx).cloned().filter(|c| !c.is_wildcard()).collect();\n+        let all_ctors = all_constructors(cx, pcx);\n+\n+        MissingConstructors { all_ctors, used_ctors, is_top_level }\n     }\n \n     fn into_inner(self) -> (Vec<Constructor<'tcx>>, Vec<Constructor<'tcx>>) {\n@@ -2284,16 +2269,64 @@ impl<'tcx> MissingConstructors<'tcx> {\n     fn is_empty(&self) -> bool {\n         self.iter().next().is_none()\n     }\n-    /// Whether this contains all the constructors for the given type or only a\n-    /// subset.\n-    fn all_ctors_are_missing(&self) -> bool {\n-        self.used_ctors.is_empty()\n-    }\n \n     /// Iterate over all_ctors \\ used_ctors\n     fn iter<'a>(&'a self) -> impl Iterator<Item = Constructor<'tcx>> + Captures<'a> {\n         self.all_ctors.iter().flat_map(move |req_ctor| req_ctor.subtract_ctors(&self.used_ctors))\n     }\n+\n+    /// List the patterns corresponding to the missing constructors. In some cases, instead of\n+    /// listing all constructors of a given type, we prefer to simply report a wildcard.\n+    fn report_patterns<'p>(\n+        &self,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: PatCtxt<'tcx>,\n+    ) -> SmallVec<[Pat<'tcx>; 1]> {\n+        // There are 2 ways we can report a witness here.\n+        // Commonly, we can report all the \"free\"\n+        // constructors as witnesses, e.g., if we have:\n+        //\n+        // ```\n+        //     enum Direction { N, S, E, W }\n+        //     let Direction::N = ...;\n+        // ```\n+        //\n+        // we can report 3 witnesses: `S`, `E`, and `W`.\n+        //\n+        // However, there is a case where we don't want\n+        // to do this and instead report a single `_` witness:\n+        // if the user didn't actually specify a constructor\n+        // in this arm, e.g., in\n+        //\n+        // ```\n+        //     let x: (Direction, Direction, bool) = ...;\n+        //     let (_, _, false) = x;\n+        // ```\n+        //\n+        // we don't want to show all 16 possible witnesses\n+        // `(<direction-1>, <direction-2>, true)` - we are\n+        // satisfied with `(_, _, true)`. In this case,\n+        // `used_ctors` is empty.\n+        // The exception is: if we are at the top-level, for example in an empty match, we\n+        // sometimes prefer reporting the list of constructors instead of just `_`.\n+        let report_when_all_missing = self.is_top_level && !IntRange::is_integral(pcx.ty);\n+        if self.used_ctors.is_empty() && !report_when_all_missing {\n+            // All constructors are unused. Report only a wildcard\n+            // rather than each individual constructor.\n+            smallvec![Pat::wildcard_from_ty(pcx.ty)]\n+        } else {\n+            // Construct for each missing constructor a \"wild\" version of this\n+            // constructor, that matches everything that can be built with\n+            // it. For example, if `ctor` is a `Constructor::Variant` for\n+            // `Option::Some`, we get the pattern `Some(_)`.\n+            self.iter()\n+                .map(|missing_ctor| {\n+                    let fields = Fields::wildcards(cx, &missing_ctor, pcx.ty);\n+                    missing_ctor.apply(cx, pcx.ty, fields)\n+                })\n+                .collect()\n+        }\n+    }\n }\n \n impl<'tcx> fmt::Debug for MissingConstructors<'tcx> {\n@@ -2434,14 +2467,6 @@ crate fn is_useful<'p, 'tcx>(\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n \n-        let used_ctors: Vec<Constructor<'_>> =\n-            matrix.head_ctors(cx).cloned().filter(|c| !c.is_wildcard()).collect();\n-        debug!(\"is_useful_used_ctors = {:#?}\", used_ctors);\n-        // `all_ctors` are all the constructors for the given type, which\n-        // should all be represented (or caught with the wild pattern `_`).\n-        let all_ctors = all_constructors(cx, pcx);\n-        debug!(\"is_useful_all_ctors = {:#?}\", all_ctors);\n-\n         // `missing_ctors` is the set of constructors from the same type as the\n         // first column of `matrix` that are matched only by wildcard patterns\n         // from the first column.\n@@ -2453,7 +2478,7 @@ crate fn is_useful<'p, 'tcx>(\n         // Missing constructors are those that are not matched by any non-wildcard patterns in the\n         // current column. We only fully construct them on-demand, because they're rarely used and\n         // can be big.\n-        let missing_ctors = MissingConstructors::new(all_ctors, used_ctors);\n+        let missing_ctors = MissingConstructors::new(cx, pcx, matrix, is_top_level);\n \n         debug!(\"is_useful_missing_ctors.empty()={:#?}\", missing_ctors.is_empty(),);\n \n@@ -2485,49 +2510,7 @@ crate fn is_useful<'p, 'tcx>(\n             let usefulness =\n                 is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n \n-            // In this case, there's at least one \"free\"\n-            // constructor that is only matched against by\n-            // wildcard patterns.\n-            //\n-            // There are 2 ways we can report a witness here.\n-            // Commonly, we can report all the \"free\"\n-            // constructors as witnesses, e.g., if we have:\n-            //\n-            // ```\n-            //     enum Direction { N, S, E, W }\n-            //     let Direction::N = ...;\n-            // ```\n-            //\n-            // we can report 3 witnesses: `S`, `E`, and `W`.\n-            //\n-            // However, there is a case where we don't want\n-            // to do this and instead report a single `_` witness:\n-            // if the user didn't actually specify a constructor\n-            // in this arm, e.g., in\n-            //\n-            // ```\n-            //     let x: (Direction, Direction, bool) = ...;\n-            //     let (_, _, false) = x;\n-            // ```\n-            //\n-            // we don't want to show all 16 possible witnesses\n-            // `(<direction-1>, <direction-2>, true)` - we are\n-            // satisfied with `(_, _, true)`. In this case,\n-            // `used_ctors` is empty.\n-            // The exception is: if we are at the top-level, for example in an empty match, we\n-            // sometimes prefer reporting the list of constructors instead of just `_`.\n-            let report_ctors_rather_than_wildcard = is_top_level && !IntRange::is_integral(pcx.ty);\n-            if missing_ctors.all_ctors_are_missing() && !report_ctors_rather_than_wildcard {\n-                // All constructors are unused. Add a wild pattern\n-                // rather than each individual constructor.\n-                usefulness.apply_wildcard(pcx.ty)\n-            } else {\n-                // Construct for each missing constructor a \"wild\" version of this\n-                // constructor, that matches everything that can be built with\n-                // it. For example, if `ctor` is a `Constructor::Variant` for\n-                // `Option::Some`, we get the pattern `Some(_)`.\n-                usefulness.apply_missing_ctors(cx, pcx.ty, &missing_ctors)\n-            }\n+            usefulness.apply_wildcard(cx, pcx, missing_ctors)\n         }\n     };\n     debug!(\"is_useful::returns({:#?}, {:#?}) = {:?}\", matrix, v, ret);"}]}