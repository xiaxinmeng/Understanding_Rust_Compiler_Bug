{"sha": "3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3", "node_id": "C_kwDOAAsO6NoAKDMyMDNlYTg5NmQxZWQ5ZjZiOGE4YWYyNWE4MDI4ZGY1MWE2YmQ1YjM", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-05-11T06:41:24Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-05-11T12:13:11Z"}, "message": "Add `macro_use` prelude to `DefMap`", "tree": {"sha": "c53a2b33ea4e627feac54d32c5173a98d689affd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c53a2b33ea4e627feac54d32c5173a98d689affd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmRc29cACgkQ4laYqTBY\nYXHFkw/7BA38V7zpY9Vb/jghyoxENZmZUrPX1QXc7LqEV6Hmi0BLjTXBPt9Oum5D\n64ks3ptXMV2pt/PtfvnGXi6BpZGdV8bX2IQSXl3ROum1V796fzVKRUKRVT1l1Por\nyiSYpkgu22/8VKUeMeqYPFYqnfgV+6e5SVWlhc+bm+AncypBIzMDbgi+Oyyq1zbo\nz3+DmoABvBx7WHDtmF2duPEIPrw5CxBBSs2wT3WwE5ABCSjqyPWCCF3fiTDY+wYK\nLTBcIi84jhydga3KWHsX9nc8XpOMsvAzTrQQmxRdccuJW5bLxB99PoWPlvbZCTrR\n5Uk16Be+afp/OD2cR8iY4nq6sffAB+zEERNPU58nnleFc/DlLe6Ce3rjKTa9wShU\nzRuqmpOxStC5k596wZf73gAP9qN1PhJUTxP3KgC2HDhsNlCkq7l+XTSAPimWQ+j0\nsrlGFV1HI5OR2r+LsW1haMMAvCiDSqt+b+f+cHyNmVRDwOEhbCnuENbqTibIQY02\nnR2sVWKRd5dUdXZVaFASeGmoeSbjdtIgVu2gID53Aw5tVX9bDZB9uQcANbcRG44x\nK+T1rtfRdTDxz3vJ/y4kLuOm0h8jOFZEnQuMlbZfsNAjQ2WeGwtotNXu+nAkIZW9\nIZ2/Vn/vyN9veDyq1CzcvZP7g6lg9NBUBjlkdjZlWLXS5giViTk=\n=8Xrc\n-----END PGP SIGNATURE-----", "payload": "tree c53a2b33ea4e627feac54d32c5173a98d689affd\nparent 96113b7b8e3239b14768f009728f1dc094a4612f\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1683787284 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1683807191 +0900\n\nAdd `macro_use` prelude to `DefMap`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3", "html_url": "https://github.com/rust-lang/rust/commit/3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96113b7b8e3239b14768f009728f1dc094a4612f", "url": "https://api.github.com/repos/rust-lang/rust/commits/96113b7b8e3239b14768f009728f1dc094a4612f", "html_url": "https://github.com/rust-lang/rust/commit/96113b7b8e3239b14768f009728f1dc094a4612f"}], "stats": {"total": 104, "additions": 84, "deletions": 20}, "files": [{"sha": "2e5f090ce76d3842cc7a8029d527e2a8efd4184b", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3", "patch": "@@ -105,6 +105,9 @@ pub struct DefMap {\n     prelude: Option<ModuleId>,\n     /// The extern prelude is only populated for non-block DefMaps\n     extern_prelude: FxHashMap<Name, ModuleId>,\n+    /// `macro_use` prelude that contains macros from `#[macro_use]`'d external crates. Note that\n+    /// this contains all kinds of macro, not just `macro_rules!` macro.\n+    macro_use_prelude: FxHashMap<Name, MacroId>,\n \n     /// Side table for resolving derive helpers.\n     exported_derives: FxHashMap<MacroDefId, Box<[Name]>>,\n@@ -277,6 +280,7 @@ impl DefMap {\n             edition,\n             recursion_limit: None,\n             extern_prelude: FxHashMap::default(),\n+            macro_use_prelude: FxHashMap::default(),\n             exported_derives: FxHashMap::default(),\n             fn_proc_macro_mapping: FxHashMap::default(),\n             proc_macro_loading_error: None,\n@@ -489,6 +493,7 @@ impl DefMap {\n             _c: _,\n             exported_derives,\n             extern_prelude,\n+            macro_use_prelude,\n             diagnostics,\n             modules,\n             registered_attrs,\n@@ -507,6 +512,7 @@ impl DefMap {\n         } = self;\n \n         extern_prelude.shrink_to_fit();\n+        macro_use_prelude.shrink_to_fit();\n         exported_derives.shrink_to_fit();\n         diagnostics.shrink_to_fit();\n         modules.shrink_to_fit();"}, {"sha": "84e9b9f571901e1e47ff41ef399c4f27b426d608", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3", "patch": "@@ -707,6 +707,7 @@ impl DefCollector<'_> {\n     }\n \n     /// Import macros from `#[macro_use] extern crate`.\n+    // FIXME: Support `#[macro_rules(macro_name, ...)]`.\n     fn import_macros_from_extern_crate(\n         &mut self,\n         current_module_id: LocalModuleId,\n@@ -725,7 +726,7 @@ impl DefCollector<'_> {\n             }\n \n             cov_mark::hit!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-            self.import_all_macros_exported(current_module_id, m.krate);\n+            self.import_all_macros_exported(m.krate);\n         }\n     }\n \n@@ -734,11 +735,12 @@ impl DefCollector<'_> {\n     /// Exported macros are just all macros in the root module scope.\n     /// Note that it contains not only all `#[macro_export]` macros, but also all aliases\n     /// created by `use` in the root module, ignoring the visibility of `use`.\n-    fn import_all_macros_exported(&mut self, current_module_id: LocalModuleId, krate: CrateId) {\n+    fn import_all_macros_exported(&mut self, krate: CrateId) {\n         let def_map = self.db.crate_def_map(krate);\n         for (name, def) in def_map[def_map.root].scope.macros() {\n-            // `#[macro_use]` brings macros into legacy scope. Yes, even non-`macro_rules!` macros.\n-            self.define_legacy_macro(current_module_id, name.clone(), def);\n+            // `#[macro_use]` brings macros into macro_use prelude. Yes, even non-`macro_rules!`\n+            // macros.\n+            self.def_map.macro_use_prelude.insert(name.clone(), def);\n         }\n     }\n \n@@ -1509,26 +1511,32 @@ impl ModCollector<'_, '_> {\n \n     fn collect(&mut self, items: &[ModItem], container: ItemContainerId) {\n         let krate = self.def_collector.def_map.krate;\n+        let is_crate_root = self.module_id == self.def_collector.def_map.root;\n \n         // Note: don't assert that inserted value is fresh: it's simply not true\n         // for macros.\n         self.def_collector.mod_dirs.insert(self.module_id, self.mod_dir.clone());\n \n         // Prelude module is always considered to be `#[macro_use]`.\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n-            if prelude_module.krate != krate {\n+            if prelude_module.krate != krate && is_crate_root {\n                 cov_mark::hit!(prelude_is_macro_use);\n-                self.def_collector.import_all_macros_exported(self.module_id, prelude_module.krate);\n+                self.def_collector.import_all_macros_exported(prelude_module.krate);\n             }\n         }\n \n         // This should be processed eagerly instead of deferred to resolving.\n         // `#[macro_use] extern crate` is hoisted to imports macros before collecting\n         // any other items.\n-        for &item in items {\n-            let attrs = self.item_tree.attrs(self.def_collector.db, krate, item.into());\n-            if attrs.cfg().map_or(true, |cfg| self.is_cfg_enabled(&cfg)) {\n-                if let ModItem::ExternCrate(id) = item {\n+        //\n+        // If we're not at the crate root, `macro_use`d extern crates are an error so let's just\n+        // ignore them.\n+        // FIXME: Support `#[macro_rules(macro_name, ...)]`.\n+        if is_crate_root {\n+            for &item in items {\n+                let ModItem::ExternCrate(id) = item else { continue; };\n+                let attrs = self.item_tree.attrs(self.def_collector.db, krate, item.into());\n+                if attrs.cfg().map_or(true, |cfg| self.is_cfg_enabled(&cfg)) {\n                     let import = &self.item_tree[id];\n                     let attrs = self.item_tree.attrs(\n                         self.def_collector.db,"}, {"sha": "5b454620e7bb3a913fc4f387a7d04eb9ddf9f80e", "filename": "crates/hir-def/src/nameres/path_resolution.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3", "patch": "@@ -385,7 +385,7 @@ impl DefMap {\n         // Resolve in:\n         //  - legacy scope of macro\n         //  - current module / scope\n-        //  - extern prelude\n+        //  - extern prelude / macro_use prelude\n         //  - std prelude\n         let from_legacy_macro = self[module]\n             .scope\n@@ -414,9 +414,18 @@ impl DefMap {\n                 .get(name)\n                 .map_or(PerNs::none(), |&it| PerNs::types(it.into(), Visibility::Public))\n         };\n+        let macro_use_prelude = || {\n+            self.macro_use_prelude\n+                .get(name)\n+                .map_or(PerNs::none(), |&it| PerNs::macros(it.into(), Visibility::Public))\n+        };\n         let prelude = || self.resolve_in_prelude(db, name);\n \n-        from_legacy_macro.or(from_scope_or_builtin).or_else(extern_prelude).or_else(prelude)\n+        from_legacy_macro\n+            .or(from_scope_or_builtin)\n+            .or_else(extern_prelude)\n+            .or_else(macro_use_prelude)\n+            .or_else(prelude)\n     }\n \n     fn resolve_name_in_crate_root_or_extern_prelude("}, {"sha": "ea3209b9c20aa9accf937baa93038acf61523fdd", "filename": "crates/hir-def/src/nameres/tests/macros.rs", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3", "patch": "@@ -1216,17 +1216,58 @@ fn proc_attr(a: TokenStream, b: TokenStream) -> TokenStream { a }\n     \"#,\n     );\n \n-    let root = &def_map[def_map.root()].scope;\n-    let actual = root\n-        .legacy_macros()\n-        .sorted_by(|a, b| std::cmp::Ord::cmp(&a.0, &b.0))\n-        .map(|(name, _)| format!(\"{name}\\n\"))\n-        .collect::<String>();\n+    let root_module = &def_map[def_map.root()].scope;\n+    assert!(\n+        root_module.legacy_macros().count() == 0,\n+        \"`#[macro_use]` shouldn't bring macros into textual macro scope\",\n+    );\n+\n+    let actual = def_map.macro_use_prelude.iter().map(|(name, _)| name).sorted().join(\"\\n\");\n \n     expect![[r#\"\n         legacy\n         macro20\n-        proc_attr\n-    \"#]]\n+        proc_attr\"#]]\n     .assert_eq(&actual);\n }\n+\n+#[test]\n+fn non_prelude_macros_take_precedence_over_macro_use_prelude() {\n+    check(\n+        r#\"\n+//- /lib.rs edition:2021 crate:lib deps:dep,core\n+#[macro_use]\n+extern crate dep;\n+\n+macro foo() { struct Ok; }\n+macro bar() { fn ok() {} }\n+\n+foo!();\n+bar!();\n+\n+//- /dep.rs crate:dep\n+#[macro_export]\n+macro_rules! foo {\n+    () => { struct NotOk; }\n+}\n+\n+//- /core.rs crate:core\n+pub mod prelude {\n+    pub mod rust_2021 {\n+        #[macro_export]\n+        macro_rules! bar {\n+            () => { fn not_ok() {} }\n+        }\n+    }\n+}\n+        \"#,\n+        expect![[r#\"\n+            crate\n+            Ok: t v\n+            bar: m\n+            dep: t\n+            foo: m\n+            ok: v\n+        \"#]],\n+    );\n+}"}]}