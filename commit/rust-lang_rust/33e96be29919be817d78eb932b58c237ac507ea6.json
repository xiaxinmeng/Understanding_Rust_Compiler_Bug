{"sha": "33e96be29919be817d78eb932b58c237ac507ea6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzZTk2YmUyOTkxOWJlODE3ZDc4ZWI5MzJiNThjMjM3YWM1MDdlYTY=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-12-05T18:07:41Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-12-05T18:07:41Z"}, "message": "rollup merge of #19512: cybergeek94/master\n\nAdded the example from [this Reddit thread][1], reworked to be more robust with correct logic (first link skipped the 0th and 1st Fibonacci numbers, second forgot about the last two valid values before overflow). Will yield all Fibonacci numbers sequentially in the range `[0, <u32 as Int>::max_value())`.\n\nIf the example is too complicated I can change it to a more naive version, perhaps using signed integers to check for overflow instead of `Option` and `.checked_add()`.\n\nAlso reworded the doc comments to clarify the usage and behavior of `Unfold`, as the thread suggested that it wasn't really clear how `Unfold` worked and when one should use it.\n\nThis change is in the `core` crate but I based the example on `std` since that's where most readers will find the example. I included a note about `core` for clarity. Edit: removed.\n\nTested with `rustdoc src/libcore/lib.rs`. Rebased against latest master as of the creation of this PR.\n\n[1]: http://www.reddit.com/r/rust/comments/2ny8r1/a_question_about_loops/cmighu4?context=10000", "tree": {"sha": "4e8a8b9381cc230816cf778fd3eb1d947668e661", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e8a8b9381cc230816cf778fd3eb1d947668e661"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33e96be29919be817d78eb932b58c237ac507ea6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33e96be29919be817d78eb932b58c237ac507ea6", "html_url": "https://github.com/rust-lang/rust/commit/33e96be29919be817d78eb932b58c237ac507ea6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33e96be29919be817d78eb932b58c237ac507ea6/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8c1812f365c3b7466536f57d4eb745a90ca31e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8c1812f365c3b7466536f57d4eb745a90ca31e9", "html_url": "https://github.com/rust-lang/rust/commit/a8c1812f365c3b7466536f57d4eb745a90ca31e9"}, {"sha": "2e1911b47ae5a4fd8cf4c4a98e739666f99daf82", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e1911b47ae5a4fd8cf4c4a98e739666f99daf82", "html_url": "https://github.com/rust-lang/rust/commit/2e1911b47ae5a4fd8cf4c4a98e739666f99daf82"}], "stats": {"total": 37, "additions": 34, "deletions": 3}, "files": [{"sha": "f137f43058fa6b64c3a66f9bdd63b08e2840ab7a", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/33e96be29919be817d78eb932b58c237ac507ea6/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33e96be29919be817d78eb932b58c237ac507ea6/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=33e96be29919be817d78eb932b58c237ac507ea6", "patch": "@@ -2036,18 +2036,49 @@ for Inspect<'a, A, T> {\n     }\n }\n \n-/// An iterator which just modifies the contained state throughout iteration.\n+/// An iterator which passes mutable state to a closure and yields the result.\n+///\n+/// # Example: The Fibonacci Sequence\n+///\n+/// An iterator that yields sequential Fibonacci numbers, and stops on overflow.\n+///\n+/// ```rust\n+/// use std::iter::Unfold;\n+/// use std::num::Int; // For `.checked_add()`\n+///\n+/// // This iterator will yield up to the last Fibonacci number before the max value of `u32`.\n+/// // You can simply change `u32` to `u64` in this line if you want higher values than that.\n+/// let mut fibonacci = Unfold::new((Some(0u32), Some(1u32)), |&(ref mut x2, ref mut x1)| {\n+///     // Attempt to get the next Fibonacci number\n+///     // `x1` will be `None` if previously overflowed.\n+///     let next = match (*x2, *x1) {\n+///         (Some(x2), Some(x1)) => x2.checked_add(x1),\n+///         _ => None,\n+///     };\n+///\n+///     // Shift left: ret <- x2 <- x1 <- next\n+///     let ret = *x2;\n+///     *x2 = *x1;\n+///     *x1 = next;\n+///\n+///     ret\n+/// });\n+///\n+/// for i in fibonacci {\n+///     println!(\"{}\", i);\n+/// }\n+/// ```\n #[experimental]\n pub struct Unfold<'a, A, St> {\n     f: |&mut St|: 'a -> Option<A>,\n-    /// Internal state that will be yielded on the next iteration\n+    /// Internal state that will be passed to the closure on the next iteration\n     pub state: St,\n }\n \n #[experimental]\n impl<'a, A, St> Unfold<'a, A, St> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n-    /// function\" and an initial state to eventually pass to the iterator\n+    /// function\" and an initial state to eventually pass to the closure\n     #[inline]\n     pub fn new<'a>(initial_state: St, f: |&mut St|: 'a -> Option<A>)\n                -> Unfold<'a, A, St> {"}]}