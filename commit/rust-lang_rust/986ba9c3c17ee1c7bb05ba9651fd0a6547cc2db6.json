{"sha": "986ba9c3c17ee1c7bb05ba9651fd0a6547cc2db6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NmJhOWMzYzE3ZWUxYzdiYjA1YmE5NjUxZmQwYTY1NDdjYzJkYjY=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-05T01:37:55Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-05T01:37:55Z"}, "message": "std: Update the c_str docs, and support CString not owning the pointer", "tree": {"sha": "e18551ecb7f363357ed52f765ddbaadbcfa7e052", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e18551ecb7f363357ed52f765ddbaadbcfa7e052"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/986ba9c3c17ee1c7bb05ba9651fd0a6547cc2db6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/986ba9c3c17ee1c7bb05ba9651fd0a6547cc2db6", "html_url": "https://github.com/rust-lang/rust/commit/986ba9c3c17ee1c7bb05ba9651fd0a6547cc2db6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/986ba9c3c17ee1c7bb05ba9651fd0a6547cc2db6/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c94b5044c2e589292def83e9cce187407c9328a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c94b5044c2e589292def83e9cce187407c9328a", "html_url": "https://github.com/rust-lang/rust/commit/3c94b5044c2e589292def83e9cce187407c9328a"}], "stats": {"total": 201, "additions": 63, "deletions": 138}, "files": [{"sha": "312cfe546036738601f9aaa4ecd48247678a2933", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 63, "deletions": 138, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/986ba9c3c17ee1c7bb05ba9651fd0a6547cc2db6/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986ba9c3c17ee1c7bb05ba9651fd0a6547cc2db6/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=986ba9c3c17ee1c7bb05ba9651fd0a6547cc2db6", "patch": "@@ -18,105 +18,77 @@ use ptr;\n use str::StrSlice;\n use vec::ImmutableVector;\n \n-/**\n- * The representation of a C String.\n- *\n- * This structure wraps a `*libc::c_char`, and will automatically free the\n- * memory it is pointing to when it goes out of scope.\n- */\n+/// The representation of a C String.\n+///\n+/// This structure wraps a `*libc::c_char`, and will automatically free the\n+/// memory it is pointing to when it goes out of scope.\n pub struct CString {\n     priv buf: *libc::c_char,\n+    priv owns_buffer_: bool,\n }\n \n impl<'self> CString {\n-    /**\n-     * Create a C String from a str.\n-     */\n-    pub fn from_str(s: &str) -> CString {\n-        s.to_c_str()\n+    /// Create a C String from a pointer.\n+    pub fn new(buf: *libc::c_char, owns_buffer: bool) -> CString {\n+        CString { buf: buf, owns_buffer_: owns_buffer }\n     }\n \n-    /**\n-     * Take the wrapped `*libc::c_char` from the `CString` wrapper.\n-     *\n-     * # Failure\n-     *\n-     * If the wrapper is empty.\n-     */\n-    pub unsafe fn take(&mut self) -> *libc::c_char {\n-        if self.buf.is_null() {\n-            fail!(\"CString has no wrapped `*libc::c_char`\");\n-        }\n-        let buf = self.buf;\n-        self.buf = ptr::null();\n-        buf\n-    }\n-\n-    /**\n-     * Puts a `*libc::c_char` into the `CString` wrapper.\n-     *\n-     * # Failure\n-     *\n-     * If the `*libc::c_char` is null.\n-     * If the wrapper is not empty.\n-     */\n-    pub fn put_back(&mut self, buf: *libc::c_char) {\n-        if buf.is_null() {\n-            fail!(\"attempt to put a null pointer into a CString\");\n-        }\n-        if self.buf.is_not_null() {\n-            fail!(\"CString already wraps a `*libc::c_char`\");\n-        }\n-        self.buf = buf;\n+    /// Unwraps the wrapped `*libc::c_char` from the `CString` wrapper.\n+    pub unsafe fn unwrap(self) -> *libc::c_char {\n+        let mut c_str = self;\n+        c_str.owns_buffer_ = false;\n+        c_str.buf\n     }\n \n-    /**\n-     * Calls a closure with a reference to the underlying `*libc::c_char`.\n-     */\n+    /// Calls a closure with a reference to the underlying `*libc::c_char`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the CString is null.\n     pub fn with_ref<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n-        if self.buf.is_null() {\n-            fail!(\"CString already wraps a `*libc::c_char`\");\n-        }\n+        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(self.buf)\n     }\n \n-    /**\n-     * Calls a closure with a mutable reference to the underlying `*libc::c_char`.\n-     */\n+    /// Calls a closure with a mutable reference to the underlying `*libc::c_char`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the CString is null.\n     pub fn with_mut_ref<T>(&mut self, f: &fn(*mut libc::c_char) -> T) -> T {\n-        if self.buf.is_not_null() {\n-            fail!(\"CString already wraps a `*libc::c_char`\");\n-        }\n+        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(unsafe { cast::transmute(self.buf) })\n     }\n \n-    /**\n-     * Returns true if the CString does not wrap a `*libc::c_char`.\n-     */\n-    pub fn is_empty(&self) -> bool {\n+    /// Returns true if the CString is a null.\n+    pub fn is_null(&self) -> bool {\n         self.buf.is_null()\n     }\n \n-    /**\n-     * Returns true if the CString wraps a `*libc::c_char`.\n-     */\n-    pub fn is_not_empty(&self) -> bool {\n+    /// Returns true if the CString is not null.\n+    pub fn is_not_null(&self) -> bool {\n         self.buf.is_not_null()\n     }\n \n-    /**\n-     * Converts the CString into a `&[u8]` without copying.\n-     */\n+    /// Returns whether or not the `CString` owns the buffer.\n+    pub fn owns_buffer(&self) -> bool {\n+        self.owns_buffer_\n+    }\n+\n+    /// Converts the CString into a `&[u8]` without copying.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the CString is null.\n     pub fn as_bytes(&self) -> &'self [u8] {\n+        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         unsafe {\n             let len = libc::strlen(self.buf) as uint;\n             cast::transmute((self.buf, len + 1))\n         }\n     }\n \n-    /**\n-     * Return a CString iterator.\n-     */\n+    /// Return a CString iterator.\n     fn iter(&self) -> CStringIterator<'self> {\n         CStringIterator {\n             ptr: self.buf,\n@@ -127,37 +99,28 @@ impl<'self> CString {\n \n impl Drop for CString {\n     fn drop(&self) {\n-        if self.buf.is_not_null() {\n+        if self.owns_buffer_ && self.buf.is_not_null() {\n             unsafe {\n                 libc::free(self.buf as *libc::c_void)\n-            };\n+            }\n         }\n     }\n }\n \n-/**\n- * A generic trait for converting a value to a CString.\n- */\n+/// A generic trait for converting a value to a CString.\n pub trait ToCStr {\n-    /**\n-     * Create a C String.\n-     */\n+    /// Create a C String.\n     fn to_c_str(&self) -> CString;\n }\n \n impl<'self> ToCStr for &'self str {\n-    /**\n-     * Create a C String from a `&str`.\n-     */\n+    #[inline]\n     fn to_c_str(&self) -> CString {\n         self.as_bytes().to_c_str()\n     }\n }\n \n impl<'self> ToCStr for &'self [u8] {\n-    /**\n-     * Create a C String from a `&[u8]`.\n-     */\n     fn to_c_str(&self) -> CString {\n         do self.as_imm_buf |self_buf, self_len| {\n             unsafe {\n@@ -168,26 +131,22 @@ impl<'self> ToCStr for &'self [u8] {\n \n                 ptr::copy_memory(buf, self_buf, self_len);\n                 *ptr::mut_offset(buf, self_len as int) = 0;\n-                CString { buf: buf as *libc::c_char }\n+\n+                CString::new(buf as *libc::c_char, true)\n             }\n         }\n     }\n }\n \n-/**\n- * External iterator for a CString's bytes.\n- *\n- * Use with the `std::iterator` module.\n- */\n+/// External iterator for a CString's bytes.\n+///\n+/// Use with the `std::iterator` module.\n pub struct CStringIterator<'self> {\n     priv ptr: *libc::c_char,\n     priv lifetime: &'self libc::c_char, // FIXME: #5922\n }\n \n impl<'self> Iterator<libc::c_char> for CStringIterator<'self> {\n-    /**\n-     * Advance the iterator.\n-     */\n     fn next(&mut self) -> Option<libc::c_char> {\n         if self.ptr.is_null() {\n             None\n@@ -226,66 +185,32 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_take() {\n-        let mut c_str = \"hello\".to_c_str();\n-        unsafe { libc::free(c_str.take() as *libc::c_void) }\n-        assert!(c_str.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_take_and_put_back() {\n-        let mut c_str = \"hello\".to_c_str();\n-        assert!(c_str.is_not_empty());\n-\n-        let buf = unsafe { c_str.take() };\n-\n-        assert!(c_str.is_empty());\n-\n-        c_str.put_back(buf);\n-\n-        assert!(c_str.is_not_empty());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[ignore(cfg(windows))]\n-    fn test_take_empty_fail() {\n-        let mut c_str = \"hello\".to_c_str();\n-        unsafe {\n-            libc::free(c_str.take() as *libc::c_void);\n-            c_str.take();\n-        }\n+    fn test_is_null() {\n+        let c_str = CString::new(ptr::null(), false);\n+        assert!(c_str.is_null());\n+        assert!(!c_str.is_not_null());\n     }\n \n     #[test]\n-    #[should_fail]\n-    #[ignore(cfg(windows))]\n-    fn test_put_back_null_fail() {\n-        let mut c_str = \"hello\".to_c_str();\n-        c_str.put_back(ptr::null());\n+    fn test_unwrap() {\n+        let c_str = \"hello\".to_c_str();\n+        unsafe { libc::free(c_str.unwrap() as *libc::c_void) }\n     }\n \n     #[test]\n-    #[should_fail]\n-    #[ignore(cfg(windows))]\n-    fn test_put_back_full_fail() {\n-        let mut c_str = \"hello\".to_c_str();\n-        c_str.put_back(0xdeadbeef as *libc::c_char);\n-    }\n-\n-    fn test_with() {\n+    fn test_with_ref() {\n         let c_str = \"hello\".to_c_str();\n         let len = unsafe { c_str.with_ref(|buf| libc::strlen(buf)) };\n-        assert!(c_str.is_not_empty());\n+        assert!(!c_str.is_null());\n+        assert!(c_str.is_not_null());\n         assert_eq!(len, 5);\n     }\n \n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    fn test_with_empty_fail() {\n-        let mut c_str = \"hello\".to_c_str();\n-        unsafe { libc::free(c_str.take() as *libc::c_void) }\n+    fn test_with_ref_empty_fail() {\n+        let c_str = CString::new(ptr::null(), false);\n         c_str.with_ref(|_| ());\n     }\n }"}]}