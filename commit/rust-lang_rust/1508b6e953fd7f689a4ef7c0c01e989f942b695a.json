{"sha": "1508b6e953fd7f689a4ef7c0c01e989f942b695a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MDhiNmU5NTNmZDdmNjg5YTRlZjdjMGMwMWU5ODlmOTQyYjY5NWE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-06T21:02:06Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-07T00:45:22Z"}, "message": "Add some doc examples to lib{green,native}\n\n\"How do I start in libX\" is a common question that I've seen, so I figured\nputting the examples in as many places as possible is probably a good idea.", "tree": {"sha": "90f4d4fdab6c9257ff25745ea3ee3f999b27ea48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90f4d4fdab6c9257ff25745ea3ee3f999b27ea48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1508b6e953fd7f689a4ef7c0c01e989f942b695a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1508b6e953fd7f689a4ef7c0c01e989f942b695a", "html_url": "https://github.com/rust-lang/rust/commit/1508b6e953fd7f689a4ef7c0c01e989f942b695a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1508b6e953fd7f689a4ef7c0c01e989f942b695a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66b9c35654d1e7716ab5ef6236c6cf308818e71c", "url": "https://api.github.com/repos/rust-lang/rust/commits/66b9c35654d1e7716ab5ef6236c6cf308818e71c", "html_url": "https://github.com/rust-lang/rust/commit/66b9c35654d1e7716ab5ef6236c6cf308818e71c"}], "stats": {"total": 185, "additions": 178, "deletions": 7}, "files": [{"sha": "40319c1ec4fabeb55cbe17fff0aa3fe75480eab8", "filename": "src/doc/guide-runtime.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1508b6e953fd7f689a4ef7c0c01e989f942b695a/src%2Fdoc%2Fguide-runtime.md", "raw_url": "https://github.com/rust-lang/rust/raw/1508b6e953fd7f689a4ef7c0c01e989f942b695a/src%2Fdoc%2Fguide-runtime.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-runtime.md?ref=1508b6e953fd7f689a4ef7c0c01e989f942b695a", "patch": "@@ -236,9 +236,7 @@ extern mod green;\n \n #[start]\n fn start(argc: int, argv: **u8) -> int {\n-    green::start(argc, argv, proc() {\n-        main();\n-    })\n+    green::start(argc, argv, main)\n }\n \n fn main() {}"}, {"sha": "30b786e4f19ee5978babc349d595f6bd8158cc4e", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 149, "deletions": 3, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/1508b6e953fd7f689a4ef7c0c01e989f942b695a/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1508b6e953fd7f689a4ef7c0c01e989f942b695a/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=1508b6e953fd7f689a4ef7c0c01e989f942b695a", "patch": "@@ -12,10 +12,156 @@\n //!\n //! This library provides M:N threading for rust programs. Internally this has\n //! the implementation of a green scheduler along with context switching and a\n-//! stack-allocation strategy.\n+//! stack-allocation strategy. This can be optionally linked in to rust\n+//! programs in order to provide M:N functionality inside of 1:1 programs.\n //!\n-//! This can be optionally linked in to rust programs in order to provide M:N\n-//! functionality inside of 1:1 programs.\n+//! # Architecture\n+//!\n+//! An M:N scheduling library implies that there are N OS thread upon which M\n+//! \"green threads\" are multiplexed. In other words, a set of green threads are\n+//! all run inside a pool of OS threads.\n+//!\n+//! With this design, you can achieve _concurrency_ by spawning many green\n+//! threads, and you can achieve _parallelism_ by running the green threads\n+//! simultaneously on multiple OS threads. Each OS thread is a candidate for\n+//! being scheduled on a different core (the source of parallelism), and then\n+//! all of the green threads cooperatively schedule amongst one another (the\n+//! source of concurrency).\n+//!\n+//! ## Schedulers\n+//!\n+//! In order to coordinate among green threads, each OS thread is primarily\n+//! running something which we call a Scheduler. Whenever a reference to a\n+//! Scheduler is made, it is synonymous to referencing one OS thread. Each\n+//! scheduler is bound to one and exactly one OS thread, and the thread that it\n+//! is bound to never changes.\n+//!\n+//! Each scheduler is connected to a pool of other schedulers (a `SchedPool`)\n+//! which is the thread pool term from above. A pool of schedulers all share the\n+//! work that they create. Furthermore, whenever a green thread is created (also\n+//! synonymously referred to as a green task), it is associated with a\n+//! `SchedPool` forevermore. A green thread cannot leave its scheduler pool.\n+//!\n+//! Schedulers can have at most one green thread running on them at a time. When\n+//! a scheduler is asleep on its event loop, there are no green tasks running on\n+//! the OS thread or the scheduler. The term \"context switch\" is used for when\n+//! the running green thread is swapped out, but this simply changes the one\n+//! green thread which is running on the scheduler.\n+//!\n+//! ## Green Threads\n+//!\n+//! A green thread can largely be summarized by a stack and a register context.\n+//! Whenever a green thread is spawned, it allocates a stack, and then prepares\n+//! a register context for execution. The green task may be executed across\n+//! multiple OS threads, but it will always use the same stack and it will carry\n+//! its register context across OS threads.\n+//!\n+//! Each green thread is cooperatively scheduled with other green threads.\n+//! Primarily, this means that there is no pre-emption of a green thread. The\n+//! major consequence of this design is that a green thread stuck in an infinite\n+//! loop will prevent all other green threads from running on that particular\n+//! scheduler.\n+//!\n+//! Scheduling events for green threads occur on communication and I/O\n+//! boundaries. For example, if a green task blocks waiting for a message on a\n+//! channel some other green thread can now run on the scheduler. This also has\n+//! the consequence that until a green thread performs any form of scheduling\n+//! event, it will be running on the same OS thread (unconditionally).\n+//!\n+//! ## Work Stealing\n+//!\n+//! With a pool of schedulers, a new green task has a number of options when\n+//! deciding where to run initially. The current implementation uses a concept\n+//! called work stealing in order to spread out work among schedulers.\n+//!\n+//! In a work-stealing model, each scheduler maintains a local queue of tasks to\n+//! run, and this queue is stolen from by other schedulers. Implementation-wise,\n+//! work stealing has some hairy parts, but from a user-perspective, work\n+//! stealing simply implies what with M green threads and N schedulers where\n+//! M > N it is very likely that all schedulers will be busy executing work.\n+//!\n+//! # Considerations when using libgreen\n+//!\n+//! An M:N runtime has both pros and cons, and there is no one answer as to\n+//! whether M:N or 1:1 is appropriate to use. As always, there are many\n+//! advantages and disadvantages between the two. Regardless of the workload,\n+//! however, there are some aspects of using green thread which you should be\n+//! aware of:\n+//!\n+//! * The largest concern when using libgreen is interoperating with native\n+//!   code. Care should be taken when calling native code that will block the OS\n+//!   thread as it will prevent further green tasks from being scheduled on the\n+//!   OS thread.\n+//!\n+//! * Native code using thread-local-storage should be approached\n+//!   with care. Green threads may migrate among OS threads at any time, so\n+//!   native libraries using thread-local state may not always work.\n+//!\n+//! * Native synchronization primitives (e.g. pthread mutexes) will also not\n+//!   work for green threads. The reason for this is because native primitives\n+//!   often operate on a _os thread_ granularity whereas green threads are\n+//!   operating on a more granular unit of work.\n+//!\n+//! * A green threading runtime is not fork-safe. If the process forks(), it\n+//!   cannot expect to make reasonable progress by continuing to use green\n+//!   threads.\n+//!\n+//! Note that these concerns do not mean that operating with native code is a\n+//! lost cause. These are simply just concerns which should be considered when\n+//! invoking native code.\n+//!\n+//! # Starting with libgreen\n+//!\n+//! ```rust\n+//! extern mod green;\n+//!\n+//! #[start]\n+//! fn start(argc: int, argv: **u8) -> int { green::start(argc, argv, main) }\n+//!\n+//! fn main() {\n+//!     // this code is running in a pool of schedulers\n+//! }\n+//! ```\n+//!\n+//! # Using a scheduler pool\n+//!\n+//! ```rust\n+//! use std::task::TaskOpts;\n+//! use green::{SchedPool, PoolConfig};\n+//! use green::sched::{PinnedTask, TaskFromFriend};\n+//!\n+//! let config = PoolConfig::new();\n+//! let mut pool = SchedPool::new(config);\n+//!\n+//! // Spawn tasks into the pool of schedulers\n+//! pool.spawn(TaskOpts::new(), proc() {\n+//!     // this code is running inside the pool of schedulers\n+//!\n+//!     spawn(proc() {\n+//!         // this code is also running inside the same scheduler pool\n+//!     });\n+//! });\n+//!\n+//! // Dynamically add a new scheduler to the scheduler pool. This adds another\n+//! // OS thread that green threads can be multiplexed on to.\n+//! let mut handle = pool.spawn_sched();\n+//!\n+//! // Pin a task to the spawned scheduler\n+//! let task = pool.task(TaskOpts::new(), proc() { /* ... */ });\n+//! handle.send(PinnedTask(task));\n+//!\n+//! // Schedule a task on this new scheduler\n+//! let task = pool.task(TaskOpts::new(), proc() { /* ... */ });\n+//! handle.send(TaskFromFriend(task));\n+//!\n+//! // Handles keep schedulers alive, so be sure to drop all handles before\n+//! // destroying the sched pool\n+//! drop(handle);\n+//!\n+//! // Required to shut down this scheduler pool.\n+//! // The task will fail if `shutdown` is not called.\n+//! pool.shutdown();\n+//! ```\n \n #[crate_id = \"green#0.10-pre\"];\n #[license = \"MIT/ASL2\"];"}, {"sha": "4840c561289f95f87f5b8ff9f3430d0a8f776adf", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1508b6e953fd7f689a4ef7c0c01e989f942b695a/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1508b6e953fd7f689a4ef7c0c01e989f942b695a/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=1508b6e953fd7f689a4ef7c0c01e989f942b695a", "patch": "@@ -8,11 +8,38 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! The native runtime crate\n+//! The native I/O and threading crate\n //!\n //! This crate contains an implementation of 1:1 scheduling for a \"native\"\n //! runtime. In addition, all I/O provided by this crate is the thread blocking\n //! version of I/O.\n+//!\n+//! # Starting with libnative\n+//!\n+//! ```rust\n+//! extern mod native;\n+//!\n+//! #[start]\n+//! fn start(argc: int, argv: **u8) -> int { native::start(argc, argv, main) }\n+//!\n+//! fn main() {\n+//!     // this code is running on the main OS thread\n+//! }\n+//! ```\n+//!\n+//! # Force spawning a native task\n+//!\n+//! ```rust\n+//! extern mod native;\n+//!\n+//! fn main() {\n+//!     // We're not sure whether this main function is run in 1:1 or M:N mode.\n+//!\n+//!     native::task::spawn(proc() {\n+//!         // this code is guaranteed to be run on a native thread\n+//!     });\n+//! }\n+//! ```\n \n #[crate_id = \"native#0.10-pre\"];\n #[license = \"MIT/ASL2\"];"}]}