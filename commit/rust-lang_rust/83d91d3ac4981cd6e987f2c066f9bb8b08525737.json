{"sha": "83d91d3ac4981cd6e987f2c066f9bb8b08525737", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZDkxZDNhYzQ5ODFjZDZlOTg3ZjJjMDY2ZjliYjhiMDg1MjU3Mzc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-03-28T07:43:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-28T07:43:29Z"}, "message": "Rollup merge of #58803 - haraldh:fs_copy_fix, r=alexcrichton\n\nfs::copy() unix: set file mode early\n\nA convenience method like fs::copy() should try to prevent pitfalls a\nnormal user doesn't think about.\n\nIn case of an empty umask, setting the file mode early prevents\ntemporarily world readable or even writeable files,\nbecause the default mode is 0o666.\n\nIn case the target is a named pipe or special device node, setting the\nfile mode can lead to unwanted side effects, like setting permissons on\n`/dev/stdout` or for root setting permissions on `/dev/null`.\n\ncopy_file_range() returns EINVAL, if the destination is a FIFO/pipe or\na device like \"/dev/null\", so fallback to io::copy, too.\n\nFixes: https://github.com/rust-lang/rust/issues/26933\nFixed: https://github.com/rust-lang/rust/issues/37885", "tree": {"sha": "c3ce68b5a8a13f1a47b632c78525de9e2238318e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3ce68b5a8a13f1a47b632c78525de9e2238318e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83d91d3ac4981cd6e987f2c066f9bb8b08525737", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcnHshCRBK7hj4Ov3rIwAAdHIIALKPxACfz6QVmOiAGjWZ4ITI\nmVYSdImKNGQNo/iVK52K1vMw4uIARlwHuMYnDqYCfmXb7GfpvFoMc/kouWdEacur\n3OfCkdPErsm35l2ufLdY2YIdR7Up6lTShvE5obI3xUpMfvxB3sEA7ec84I4vZ5gE\njqBEo8nfaAV71A4NGnbCam7T4CZzRvVWYfirG34dOqAmPpANkbsaVYUkJArOhsU7\nHZVRbDHcSLy12tQK2vRF6AaGsgB01yJJ9w76RSOOnbp7moeJb0jIW6sSFF7DUGuC\neamXbkLmppCa6Ojkuvi6Ckcn77PSbPeSO/7JgCdiwRbXgSaI9mEYDWrib9Tz2cQ=\n=b6qb\n-----END PGP SIGNATURE-----\n", "payload": "tree c3ce68b5a8a13f1a47b632c78525de9e2238318e\nparent 5a90b66de32bdd5320e5b98ca954059f9e19fec6\nparent cf8347ba6bc82c41de2ad9bf561af593a89cbe45\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1553759009 +0100\ncommitter GitHub <noreply@github.com> 1553759009 +0100\n\nRollup merge of #58803 - haraldh:fs_copy_fix, r=alexcrichton\n\nfs::copy() unix: set file mode early\n\nA convenience method like fs::copy() should try to prevent pitfalls a\nnormal user doesn't think about.\n\nIn case of an empty umask, setting the file mode early prevents\ntemporarily world readable or even writeable files,\nbecause the default mode is 0o666.\n\nIn case the target is a named pipe or special device node, setting the\nfile mode can lead to unwanted side effects, like setting permissons on\n`/dev/stdout` or for root setting permissions on `/dev/null`.\n\ncopy_file_range() returns EINVAL, if the destination is a FIFO/pipe or\na device like \"/dev/null\", so fallback to io::copy, too.\n\nFixes: https://github.com/rust-lang/rust/issues/26933\nFixed: https://github.com/rust-lang/rust/issues/37885\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83d91d3ac4981cd6e987f2c066f9bb8b08525737", "html_url": "https://github.com/rust-lang/rust/commit/83d91d3ac4981cd6e987f2c066f9bb8b08525737", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83d91d3ac4981cd6e987f2c066f9bb8b08525737/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a90b66de32bdd5320e5b98ca954059f9e19fec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a90b66de32bdd5320e5b98ca954059f9e19fec6", "html_url": "https://github.com/rust-lang/rust/commit/5a90b66de32bdd5320e5b98ca954059f9e19fec6"}, {"sha": "cf8347ba6bc82c41de2ad9bf561af593a89cbe45", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf8347ba6bc82c41de2ad9bf561af593a89cbe45", "html_url": "https://github.com/rust-lang/rust/commit/cf8347ba6bc82c41de2ad9bf561af593a89cbe45"}], "stats": {"total": 142, "additions": 83, "deletions": 59}, "files": [{"sha": "c73f7983146d411b4980bce29e1f54cab4328636", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 74, "deletions": 55, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/83d91d3ac4981cd6e987f2c066f9bb8b08525737/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d91d3ac4981cd6e987f2c066f9bb8b08525737/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=83d91d3ac4981cd6e987f2c066f9bb8b08525737", "patch": "@@ -827,30 +827,54 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n \n+fn open_and_set_permissions(\n+    from: &Path,\n+    to: &Path,\n+) -> io::Result<(crate::fs::File, crate::fs::File, u64, crate::fs::Metadata)> {\n+    use crate::fs::{File, OpenOptions};\n+    use crate::os::unix::fs::{OpenOptionsExt, PermissionsExt};\n+\n+    let reader = File::open(from)?;\n+    let (perm, len) = {\n+        let metadata = reader.metadata()?;\n+        if !metadata.is_file() {\n+            return Err(Error::new(\n+                ErrorKind::InvalidInput,\n+                \"the source path is not an existing regular file\",\n+            ));\n+        }\n+        (metadata.permissions(), metadata.len())\n+    };\n+    let writer = OpenOptions::new()\n+        // create the file with the correct mode right away\n+        .mode(perm.mode())\n+        .write(true)\n+        .create(true)\n+        .truncate(true)\n+        .open(to)?;\n+    let writer_metadata = writer.metadata()?;\n+    if writer_metadata.is_file() {\n+        // Set the correct file permissions, in case the file already existed.\n+        // Don't set the permissions on already existing non-files like\n+        // pipes/FIFOs or device nodes.\n+        writer.set_permissions(perm)?;\n+    }\n+    Ok((reader, writer, len, writer_metadata))\n+}\n+\n #[cfg(not(any(target_os = \"linux\",\n               target_os = \"android\",\n               target_os = \"macos\",\n               target_os = \"ios\")))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n-    use crate::fs::File;\n-    if !from.is_file() {\n-        return Err(Error::new(ErrorKind::InvalidInput,\n-                              \"the source path is not an existing regular file\"))\n-    }\n+    let (mut reader, mut writer, _, _) = open_and_set_permissions(from, to)?;\n \n-    let mut reader = File::open(from)?;\n-    let mut writer = File::create(to)?;\n-    let perm = reader.metadata()?.permissions();\n-\n-    let ret = io::copy(&mut reader, &mut writer)?;\n-    writer.set_permissions(perm)?;\n-    Ok(ret)\n+    io::copy(&mut reader, &mut writer)\n }\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     use crate::cmp;\n-    use crate::fs::File;\n     use crate::sync::atomic::{AtomicBool, Ordering};\n \n     // Kernel prior to 4.5 don't have copy_file_range\n@@ -876,17 +900,7 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         )\n     }\n \n-    if !from.is_file() {\n-        return Err(Error::new(ErrorKind::InvalidInput,\n-                              \"the source path is not an existing regular file\"))\n-    }\n-\n-    let mut reader = File::open(from)?;\n-    let mut writer = File::create(to)?;\n-    let (perm, len) = {\n-        let metadata = reader.metadata()?;\n-        (metadata.permissions(), metadata.size())\n-    };\n+    let (mut reader, mut writer, len, _) = open_and_set_permissions(from, to)?;\n \n     let has_copy_file_range = HAS_COPY_FILE_RANGE.load(Ordering::Relaxed);\n     let mut written = 0u64;\n@@ -896,13 +910,14 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n             let copy_result = unsafe {\n                 // We actually don't have to adjust the offsets,\n                 // because copy_file_range adjusts the file offset automatically\n-                cvt(copy_file_range(reader.as_raw_fd(),\n-                                    ptr::null_mut(),\n-                                    writer.as_raw_fd(),\n-                                    ptr::null_mut(),\n-                                    bytes_to_copy,\n-                                    0)\n-                    )\n+                cvt(copy_file_range(\n+                    reader.as_raw_fd(),\n+                    ptr::null_mut(),\n+                    writer.as_raw_fd(),\n+                    ptr::null_mut(),\n+                    bytes_to_copy,\n+                    0,\n+                ))\n             };\n             if let Err(ref copy_err) = copy_result {\n                 match copy_err.raw_os_error() {\n@@ -920,24 +935,25 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n             Ok(ret) => written += ret as u64,\n             Err(err) => {\n                 match err.raw_os_error() {\n-                    Some(os_err) if os_err == libc::ENOSYS\n-                                 || os_err == libc::EXDEV\n-                                 || os_err == libc::EPERM => {\n-                        // Try fallback io::copy if either:\n-                        // - Kernel version is < 4.5 (ENOSYS)\n-                        // - Files are mounted on different fs (EXDEV)\n-                        // - copy_file_range is disallowed, for example by seccomp (EPERM)\n-                        assert_eq!(written, 0);\n-                        let ret = io::copy(&mut reader, &mut writer)?;\n-                        writer.set_permissions(perm)?;\n-                        return Ok(ret)\n-                    },\n+                    Some(os_err)\n+                    if os_err == libc::ENOSYS\n+                        || os_err == libc::EXDEV\n+                        || os_err == libc::EINVAL\n+                        || os_err == libc::EPERM =>\n+                        {\n+                            // Try fallback io::copy if either:\n+                            // - Kernel version is < 4.5 (ENOSYS)\n+                            // - Files are mounted on different fs (EXDEV)\n+                            // - copy_file_range is disallowed, for example by seccomp (EPERM)\n+                            // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n+                            assert_eq!(written, 0);\n+                            return io::copy(&mut reader, &mut writer);\n+                        }\n                     _ => return Err(err),\n                 }\n             }\n         }\n     }\n-    writer.set_permissions(perm)?;\n     Ok(written)\n }\n \n@@ -960,9 +976,9 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     type copyfile_flags_t = u32;\n \n     extern \"C\" {\n-        fn copyfile(\n-            from: *const libc::c_char,\n-            to: *const libc::c_char,\n+        fn fcopyfile(\n+            from: libc::c_int,\n+            to: libc::c_int,\n             state: copyfile_state_t,\n             flags: copyfile_flags_t,\n         ) -> libc::c_int;\n@@ -988,10 +1004,7 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         }\n     }\n \n-    if !from.is_file() {\n-        return Err(Error::new(ErrorKind::InvalidInput,\n-                              \"the source path is not an existing regular file\"))\n-    }\n+    let (reader, writer, _, writer_metadata) = open_and_set_permissions(from, to)?;\n \n     // We ensure that `FreeOnDrop` never contains a null pointer so it is\n     // always safe to call `copyfile_state_free`\n@@ -1003,12 +1016,18 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         FreeOnDrop(state)\n     };\n \n+    let flags = if writer_metadata.is_file() {\n+        COPYFILE_ALL\n+    } else {\n+        COPYFILE_DATA\n+    };\n+\n     cvt(unsafe {\n-        copyfile(\n-            cstr(from)?.as_ptr(),\n-            cstr(to)?.as_ptr(),\n+        fcopyfile(\n+            reader.as_raw_fd(),\n+            writer.as_raw_fd(),\n             state.0,\n-            COPYFILE_ALL,\n+            flags,\n         )\n     })?;\n "}, {"sha": "dfcef59aa57825851f827159fb833cf12dfdfbb3", "filename": "src/test/run-pass/paths-containing-nul.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/83d91d3ac4981cd6e987f2c066f9bb8b08525737/src%2Ftest%2Frun-pass%2Fpaths-containing-nul.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d91d3ac4981cd6e987f2c066f9bb8b08525737/src%2Ftest%2Frun-pass%2Fpaths-containing-nul.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpaths-containing-nul.rs?ref=83d91d3ac4981cd6e987f2c066f9bb8b08525737", "patch": "@@ -1,6 +1,7 @@\n #![allow(deprecated)]\n // ignore-cloudabi no files or I/O\n // ignore-wasm32-bare no files or I/O\n+// ignore-emscripten no files\n \n use std::fs;\n use std::io;\n@@ -22,14 +23,18 @@ fn main() {\n     assert_invalid_input(\"remove_file\", fs::remove_file(\"\\0\"));\n     assert_invalid_input(\"metadata\", fs::metadata(\"\\0\"));\n     assert_invalid_input(\"symlink_metadata\", fs::symlink_metadata(\"\\0\"));\n+\n+    // If `dummy_file` does not exist, then we might get another unrelated error\n+    let dummy_file = std::env::current_exe().unwrap();\n+\n     assert_invalid_input(\"rename1\", fs::rename(\"\\0\", \"a\"));\n-    assert_invalid_input(\"rename2\", fs::rename(\"a\", \"\\0\"));\n+    assert_invalid_input(\"rename2\", fs::rename(&dummy_file, \"\\0\"));\n     assert_invalid_input(\"copy1\", fs::copy(\"\\0\", \"a\"));\n-    assert_invalid_input(\"copy2\", fs::copy(\"a\", \"\\0\"));\n+    assert_invalid_input(\"copy2\", fs::copy(&dummy_file, \"\\0\"));\n     assert_invalid_input(\"hard_link1\", fs::hard_link(\"\\0\", \"a\"));\n-    assert_invalid_input(\"hard_link2\", fs::hard_link(\"a\", \"\\0\"));\n+    assert_invalid_input(\"hard_link2\", fs::hard_link(&dummy_file, \"\\0\"));\n     assert_invalid_input(\"soft_link1\", fs::soft_link(\"\\0\", \"a\"));\n-    assert_invalid_input(\"soft_link2\", fs::soft_link(\"a\", \"\\0\"));\n+    assert_invalid_input(\"soft_link2\", fs::soft_link(&dummy_file, \"\\0\"));\n     assert_invalid_input(\"read_link\", fs::read_link(\"\\0\"));\n     assert_invalid_input(\"canonicalize\", fs::canonicalize(\"\\0\"));\n     assert_invalid_input(\"create_dir\", fs::create_dir(\"\\0\"));"}]}