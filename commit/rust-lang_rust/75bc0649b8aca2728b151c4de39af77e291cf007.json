{"sha": "75bc0649b8aca2728b151c4de39af77e291cf007", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1YmMwNjQ5YjhhY2EyNzI4YjE1MWM0ZGUzOWFmNzdlMjkxY2YwMDc=", "commit": {"author": {"name": "Meade Kincke", "email": "thedarkula2049@gmail.com", "date": "2018-07-02T17:09:47Z"}, "committer": {"name": "Meade Kincke", "email": "thedarkula2049@gmail.com", "date": "2018-07-07T00:09:09Z"}, "message": "Omitted the walk in visit_expr()", "tree": {"sha": "3367acab9fef4db23e8d321fa12c85c3b97f4136", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3367acab9fef4db23e8d321fa12c85c3b97f4136"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75bc0649b8aca2728b151c4de39af77e291cf007", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75bc0649b8aca2728b151c4de39af77e291cf007", "html_url": "https://github.com/rust-lang/rust/commit/75bc0649b8aca2728b151c4de39af77e291cf007", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75bc0649b8aca2728b151c4de39af77e291cf007/comments", "author": null, "committer": null, "parents": [{"sha": "e06c875442e91cc2c597135d1e807a69e73eee26", "url": "https://api.github.com/repos/rust-lang/rust/commits/e06c875442e91cc2c597135d1e807a69e73eee26", "html_url": "https://github.com/rust-lang/rust/commit/e06c875442e91cc2c597135d1e807a69e73eee26"}], "stats": {"total": 239, "additions": 174, "deletions": 65}, "files": [{"sha": "37950b37406b5f9efa97b1681aea2e9ab9e4f843", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 174, "deletions": 65, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/75bc0649b8aca2728b151c4de39af77e291cf007/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75bc0649b8aca2728b151c4de39af77e291cf007/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=75bc0649b8aca2728b151c4de39af77e291cf007", "patch": "@@ -40,7 +40,7 @@ use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax::attr;\n use syntax_pos::{Span, DUMMY_SP};\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n@@ -65,7 +65,7 @@ fn const_is_rvalue_promotable_to_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     assert!(def_id.is_local());\n \n     let node_id = tcx.hir.as_local_node_id(def_id)\n-                     .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n+        .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n     let body_id = tcx.hir.body_owned_by(node_id);\n     let body_hir_id = tcx.hir.node_to_hir_id(body_id.node_id);\n     tcx.rvalue_promotable_map(def_id).contains(&body_hir_id.local_id)\n@@ -94,7 +94,7 @@ fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // `def_id` should be a `Body` owner\n     let node_id = tcx.hir.as_local_node_id(def_id)\n-                     .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n+        .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n     let body_id = tcx.hir.body_owned_by(node_id);\n     visitor.visit_nested_body(body_id);\n \n@@ -117,7 +117,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     // Returns true iff all the values of the type are promotable.\n     fn type_has_only_promotable_values(&mut self, ty: Ty<'gcx>) -> bool {\n         ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) &&\n-        !ty.needs_drop(self.tcx, self.param_env)\n+            !ty.needs_drop(self.tcx, self.param_env)\n     }\n \n     fn handle_const_fn_call(&mut self, def_id: DefId, ret_ty: Ty<'gcx>, span: Span) {\n@@ -133,21 +133,21 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n \n         if let Some(&attr::Stability {\n             rustc_const_unstable: Some(attr::RustcConstUnstable {\n-                feature: ref feature_name\n-            }),\n-        .. }) = self.tcx.lookup_stability(def_id) {\n+                                           feature: ref feature_name\n+                                       }),\n+            .. }) = self.tcx.lookup_stability(def_id) {\n             self.promotable &=\n                 // feature-gate is enabled,\n                 self.tcx.features()\n                     .declared_lib_features\n                     .iter()\n                     .any(|&(ref sym, _)| sym == feature_name) ||\n \n-                // this comes from a crate with the feature-gate enabled,\n-                !def_id.is_local() ||\n+                    // this comes from a crate with the feature-gate enabled,\n+                    !def_id.is_local() ||\n \n-                // this comes from a macro that has #[allow_internal_unstable]\n-                span.allows_unstable();\n+                    // this comes from a macro that has #[allow_internal_unstable]\n+                    span.allows_unstable();\n         }\n     }\n \n@@ -216,7 +216,9 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n \n     fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt) {\n         match stmt.node {\n-            hir::StmtDecl(ref decl, _) => {\n+            hir::StmtDecl(ref decl, node_id) => {\n+                self.visit_id(node_id);\n+                self.visit_decl(decl);\n                 match &decl.node {\n                     hir::DeclLocal(local) => {\n                         self.promotable = false;\n@@ -231,12 +233,12 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                     hir::DeclItem(_) => {}\n                 }\n             }\n-            hir::StmtExpr(..) |\n-            hir::StmtSemi(..) => {\n-                self.promotable = false;\n+            hir::StmtExpr(ref box_expr, node_id) |\n+            hir::StmtSemi(ref box_expr, node_id) => {\n+                self.visit_expr(box_expr);\n+                self.visit_id(node_id);\n             }\n         }\n-        intravisit::walk_stmt(self, stmt);\n     }\n \n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n@@ -247,20 +249,6 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         check_expr(self, ex, node_ty);\n         check_adjustments(self, ex);\n \n-        if let hir::ExprMatch(ref discr, ref arms, _) = ex.node {\n-            // Compute the most demanding borrow from all the arms'\n-            // patterns and set that on the discriminator.\n-            let mut mut_borrow = false;\n-            for pat in arms.iter().flat_map(|arm| &arm.pats) {\n-                mut_borrow = self.remove_mut_rvalue_borrow(pat);\n-            }\n-            if mut_borrow {\n-                self.mut_rvalue_borrows.insert(discr.id);\n-            }\n-        }\n-\n-        intravisit::walk_expr(self, ex);\n-\n         // Handle borrows on (or inside the autorefs of) this expression.\n         if self.mut_rvalue_borrows.remove(&ex.id) {\n             self.promotable = false;\n@@ -271,6 +259,16 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         }\n         self.promotable &= outer;\n     }\n+\n+    fn visit_block(&mut self, block: &'tcx hir::Block) {\n+        for index in block.stmts.iter() {\n+            self.visit_stmt(index)\n+        }\n+        match block.expr {\n+            Some(ref box_expr) => { self.visit_expr(&*box_expr) },\n+            None => {},\n+        }\n+    }\n }\n \n /// This function is used to enforce the constraints on\n@@ -279,7 +277,9 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n /// every nested expression. If the expression is not part\n /// of a const/static item, it is qualified for promotion\n /// instead of producing errors.\n-fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node_ty: Ty<'tcx>) {\n+fn check_expr<'a, 'tcx>(\n+    v: &mut CheckCrateVisitor<'a, 'tcx>,\n+    e: &'tcx hir::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n         ty::TyAdt(def, _) if def.has_dtor(v.tcx) => {\n             v.promotable = false;\n@@ -288,32 +288,32 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n     }\n \n     match e.node {\n-        hir::ExprUnary(..) |\n-        hir::ExprBinary(..) |\n-        hir::ExprIndex(..) if v.tables.is_method_call(e) => {\n+        hir::ExprBox(ref expr) => {\n+            v.visit_expr(&expr);\n             v.promotable = false;\n         }\n-        hir::ExprBox(_) => {\n-            v.promotable = false;\n-        }\n-        hir::ExprUnary(op, _) => {\n+        hir::ExprUnary(op, ref expr) => {\n+            v.visit_expr(expr);\n             if op == hir::UnDeref {\n                 v.promotable = false;\n             }\n         }\n-        hir::ExprBinary(op, ref lhs, _) => {\n+        hir::ExprBinary(op, ref lhs, ref rhs) => {\n+            v.visit_expr(lhs);\n+            v.visit_expr(rhs);\n             match v.tables.node_id_to_type(lhs.hir_id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op.node == hir::BiEq || op.node == hir::BiNe ||\n-                            op.node == hir::BiLe || op.node == hir::BiLt ||\n-                            op.node == hir::BiGe || op.node == hir::BiGt);\n+                        op.node == hir::BiLe || op.node == hir::BiLt ||\n+                        op.node == hir::BiGe || op.node == hir::BiGt);\n \n                     v.promotable = false;\n                 }\n                 _ => {}\n             }\n         }\n         hir::ExprCast(ref from, _) => {\n+            v.visit_expr(from);\n             debug!(\"Checking const cast(id={})\", from.id);\n             match v.tables.cast_kinds().get(from.hir_id) {\n                 None => v.tcx.sess.delay_span_bug(e.span, \"no kind for cast\"),\n@@ -324,6 +324,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprPath(ref qpath) => {\n+            v.visit_qpath(qpath, e.id, e.span);\n             let def = v.tables.qpath_def(qpath, e.hir_id);\n             match def {\n                 Def::VariantCtor(..) | Def::StructCtor(..) |\n@@ -379,7 +380,11 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                 }\n             }\n         }\n-        hir::ExprCall(ref callee, _) => {\n+        hir::ExprCall(ref callee, ref hirvec) => {\n+            v.visit_expr(callee);\n+            for index in hirvec.iter() {\n+                v.visit_expr(index)\n+            }\n             let mut callee = &**callee;\n             loop {\n                 callee = match callee.node {\n@@ -413,7 +418,10 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                 _ => v.promotable = false\n             }\n         }\n-        hir::ExprMethodCall(..) => {\n+        hir::ExprMethodCall(ref _pathsegment, ref _span, ref hirvec) => {\n+            for index in hirvec.iter() {\n+                v.visit_expr(index)\n+            }\n             if let Some(def) = v.tables.type_dependent_defs().get(e.hir_id) {\n                 let def_id = def.def_id();\n                 match v.tcx.associated_item(def_id).container {\n@@ -424,7 +432,14 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                 v.tcx.sess.delay_span_bug(e.span, \"no type-dependent def for method call\");\n             }\n         }\n-        hir::ExprStruct(..) => {\n+        hir::ExprStruct(ref _qpath, ref hirvec, ref option_expr) => {\n+            for index in hirvec.iter() {\n+                v.visit_expr(&index.expr);\n+            }\n+            match *option_expr {\n+                Some(ref expr) => { v.visit_expr(&expr) },\n+                None => {},\n+            }\n             if let ty::TyAdt(adt, ..) = v.tables.expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n                 if Some(adt.did) == v.tcx.lang_items().unsafe_cell_type() {\n@@ -433,52 +448,146 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n \n-        hir::ExprLit(_) |\n-        hir::ExprAddrOf(..) |\n-        hir::ExprRepeat(..) => {}\n+        hir::ExprLit(_) => {}\n+\n+        hir::ExprAddrOf(ref _mutability, ref expr) => {\n+            v.visit_expr(expr);\n+        }\n+\n+        hir::ExprRepeat(ref expr, ref _anon_cast) => {\n+            v.visit_expr(expr);\n+        }\n \n-        hir::ExprClosure(..) => {\n+        hir::ExprClosure(_capture_clause, ref _box_fn_decl,\n+                         body_id, _span, _option_generator_movability) => {\n+            v.visit_nested_body(body_id);\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n             if v.tcx.with_freevars(e.id, |fv| !fv.is_empty()) {\n                 v.promotable = false;\n             }\n         }\n \n-        hir::ExprField(ref expr, _) => {\n+        hir::ExprField(ref expr, _ident) => {\n+            v.visit_expr(expr);\n             if let Some(def) = v.tables.expr_ty(expr).ty_adt_def() {\n                 if def.is_union() {\n                     v.promotable = false\n                 }\n             }\n         }\n \n-        hir::ExprBlock(..) |\n-        hir::ExprIndex(..) |\n-        hir::ExprArray(_) |\n-        hir::ExprType(..) |\n-        hir::ExprTup(..) => {}\n+        hir::ExprBlock(ref box_block, ref _option_label) => {\n+            v.visit_block(box_block);\n+        }\n+\n+        hir::ExprIndex(ref lhs, ref rhs) => {\n+            if v.tables.is_method_call(e) {\n+                v.promotable = false;\n+            }\n+            v.visit_expr(lhs);\n+            v.visit_expr(rhs);\n+        }\n+\n+        hir::ExprArray(ref hirvec) => {\n+            for index in hirvec.iter() {\n+                v.visit_expr(index)\n+            }\n+        }\n+\n+        hir::ExprType(ref expr, ref _ty) => {\n+            v.visit_expr(expr);\n+        }\n+\n+        hir::ExprTup(ref hirvec) => {\n+            for index in hirvec.iter() {\n+                v.visit_expr(index)\n+            }\n+        }\n+\n \n         // Conditional control flow (possible to implement).\n-        hir::ExprMatch(..) |\n-        hir::ExprIf(..) |\n+        hir::ExprMatch(ref expr, ref hirvec_arm, ref _match_source) => {\n+            // Compute the most demanding borrow from all the arms'\n+            // patterns and set that on the discriminator.\n+            let mut mut_borrow = false;\n+            for pat in hirvec_arm.iter().flat_map(|arm| &arm.pats) {\n+                mut_borrow = v.remove_mut_rvalue_borrow(pat);\n+            }\n+            if mut_borrow {\n+                v.mut_rvalue_borrows.insert(expr.id);\n+            }\n+\n+            v.visit_expr(expr);\n+            for index in hirvec_arm.iter() {\n+                match *index {\n+                    ref arm => {\n+                        v.visit_expr(&*arm.body);\n+                        match arm.guard {\n+                            Some(ref expr) => v.visit_expr(&expr),\n+                            None => {},\n+                        }\n+                    }\n+                }\n+            }\n+            v.promotable = false;\n+        }\n+\n+        hir::ExprIf(ref lhs, ref rhs, ref option_expr) => {\n+            v.visit_expr(lhs);\n+            v.visit_expr(rhs);\n+            match option_expr {\n+                Some(ref expr) => v.visit_expr(&expr),\n+                None => {},\n+            }\n+            v.promotable = false;\n+        }\n \n         // Loops (not very meaningful in constants).\n-        hir::ExprWhile(..) |\n-        hir::ExprLoop(..) |\n+        hir::ExprWhile(ref expr, ref box_block, ref _option_label) => {\n+            v.visit_expr(expr);\n+            v.visit_block(box_block);\n+            v.promotable = false;\n+        }\n+\n+        hir::ExprLoop(ref box_block, ref _option_label, ref _loop_source) => {\n+            v.visit_block(box_block);\n+            v.promotable = false;\n+        }\n \n         // More control flow (also not very meaningful).\n-        hir::ExprBreak(..) |\n-        hir::ExprContinue(_) |\n-        hir::ExprRet(_) |\n+        hir::ExprBreak(_, ref option_expr) | hir::ExprRet(ref option_expr) => {\n+            match *option_expr {\n+                Some(ref expr) => { v.visit_expr(&expr) },\n+                None => {},\n+            }\n+            v.promotable = false;\n+        }\n+\n+        hir::ExprContinue(_) => {\n+            v.promotable = false;\n+        }\n \n         // Generator expressions\n-        hir::ExprYield(_) |\n+        hir::ExprYield(ref expr) => {\n+            v.visit_expr(&expr);\n+            v.promotable = false;\n+        }\n \n         // Expressions with side-effects.\n-        hir::ExprAssign(..) |\n-        hir::ExprAssignOp(..) |\n-        hir::ExprInlineAsm(..) => {\n+        hir::ExprAssignOp(_, ref lhs, ref rhs) | hir::ExprAssign(ref lhs, ref rhs) => {\n+            v.visit_expr(lhs);\n+            v.visit_expr(rhs);\n+            v.promotable = false;\n+        }\n+\n+        hir::ExprInlineAsm(ref _inline_asm, ref hirvec_lhs, ref hirvec_rhs) => {\n+            for index in hirvec_lhs.iter() {\n+                v.visit_expr(index)\n+            }\n+            for index in hirvec_rhs.iter() {\n+                v.visit_expr(index)\n+            }\n             v.promotable = false;\n         }\n     }"}]}