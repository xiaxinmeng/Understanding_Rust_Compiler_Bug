{"sha": "1ecc1e51c08f38b6ee42dae9a0f8bd6dc1f1b86f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlY2MxZTUxYzA4ZjM4YjZlZTQyZGFlOWEwZjhiZDZkYzFmMWI4NmY=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-09-05T17:30:23Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-09-06T20:35:14Z"}, "message": "quote_* macros no longer need to be capturing\n\nThis is actually almost a problem, because those were my poster-child\nmacros for \"here's how to implement a capturing macro.\" Following this\nchange, there will be no macros that use capturing; this will probably\nmake life unpleasant for the first person that wants to implement a\ncapturing macro. I should probably create a dummy_capturing macro,\njust to show how it works.", "tree": {"sha": "4849df84b721c66cde6c4231e7283143c657c210", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4849df84b721c66cde6c4231e7283143c657c210"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ecc1e51c08f38b6ee42dae9a0f8bd6dc1f1b86f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ecc1e51c08f38b6ee42dae9a0f8bd6dc1f1b86f", "html_url": "https://github.com/rust-lang/rust/commit/1ecc1e51c08f38b6ee42dae9a0f8bd6dc1f1b86f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ecc1e51c08f38b6ee42dae9a0f8bd6dc1f1b86f/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4664d3320dacb1cbf42081369d3fc4f61f2af1a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4664d3320dacb1cbf42081369d3fc4f61f2af1a3", "html_url": "https://github.com/rust-lang/rust/commit/4664d3320dacb1cbf42081369d3fc4f61f2af1a3"}], "stats": {"total": 110, "additions": 19, "deletions": 91}, "files": [{"sha": "3d5d62aeadf1e99a7532ecde6c0c9f4e7395fe1f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1ecc1e51c08f38b6ee42dae9a0f8bd6dc1f1b86f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ecc1e51c08f38b6ee42dae9a0f8bd6dc1f1b86f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=1ecc1e51c08f38b6ee42dae9a0f8bd6dc1f1b86f", "patch": "@@ -185,17 +185,18 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n \n     // Quasi-quoting expanders\n     syntax_expanders.insert(intern(&\"quote_tokens\"),\n-        @SE(NormalTT(ext::quote::expand_quote_tokens, None)));\n+                            builtin_normal_tt_no_ctxt(\n+                                ext::quote::expand_quote_tokens));\n     syntax_expanders.insert(intern(&\"quote_expr\"),\n-        @SE(NormalTT(ext::quote::expand_quote_expr, None)));\n+                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_expr));\n     syntax_expanders.insert(intern(&\"quote_ty\"),\n-        @SE(NormalTT(ext::quote::expand_quote_ty, None)));\n+                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_ty));\n     syntax_expanders.insert(intern(&\"quote_item\"),\n-        @SE(NormalTT(ext::quote::expand_quote_item, None)));\n+                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_item));\n     syntax_expanders.insert(intern(&\"quote_pat\"),\n-        @SE(NormalTT(ext::quote::expand_quote_pat, None)));\n+                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_pat));\n     syntax_expanders.insert(intern(&\"quote_stmt\"),\n-        @SE(NormalTT(ext::quote::expand_quote_stmt, None)));\n+                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_stmt));\n \n     syntax_expanders.insert(intern(&\"line\"),\n                             builtin_normal_tt_no_ctxt("}, {"sha": "5f57eba5b4c92b3e5e82352fe31d8d3b258b68b9", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1ecc1e51c08f38b6ee42dae9a0f8bd6dc1f1b86f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ecc1e51c08f38b6ee42dae9a0f8bd6dc1f1b86f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1ecc1e51c08f38b6ee42dae9a0f8bd6dc1f1b86f", "patch": "@@ -1856,58 +1856,6 @@ mod test {\n         }\n     }\n \n-    #[test] fn quote_expr_test() {\n-        quote_ext_cx_test(@\"fn main(){let ext_cx = 13; quote_expr!(dontcare);}\");\n-    }\n-    #[test] fn quote_item_test() {\n-        quote_ext_cx_test(@\"fn main(){let ext_cx = 13; quote_item!(dontcare);}\");\n-    }\n-    #[test] fn quote_pat_test() {\n-        quote_ext_cx_test(@\"fn main(){let ext_cx = 13; quote_pat!(dontcare);}\");\n-    }\n-    #[test] fn quote_ty_test() {\n-        quote_ext_cx_test(@\"fn main(){let ext_cx = 13; quote_ty!(dontcare);}\");\n-    }\n-    #[test] fn quote_tokens_test() {\n-        quote_ext_cx_test(@\"fn main(){let ext_cx = 13; quote_tokens!(dontcare);}\");\n-    }\n-\n-    fn quote_ext_cx_test(crate_str : @str) {\n-        let crate = expand_crate_str(crate_str);\n-        // find the ext_cx binding\n-        let bindings = @mut ~[];\n-        visit::walk_crate(&mut new_name_finder(bindings), crate, ());\n-        let cxbinds : ~[&ast::Ident] =\n-            bindings.iter().filter(|b|{@\"ext_cx\" == (ident_to_str(*b))}).collect();\n-        let cxbind = match cxbinds {\n-            [b] => b,\n-            _ => fail!(\"expected just one binding for ext_cx\")\n-        };\n-        let resolved_binding = mtwt_resolve(*cxbind);\n-        // find all the ext_cx varrefs:\n-        let varrefs = @mut ~[];\n-        visit::walk_crate(&mut new_path_finder(varrefs), crate, ());\n-        // the ext_cx binding should bind all of the ext_cx varrefs:\n-        for (idx,v) in varrefs.iter().filter(|p|{ p.segments.len() == 1\n-                    && (@\"ext_cx\" == (ident_to_str(&p.segments[0].identifier)))\n-            }).enumerate() {\n-            if (mtwt_resolve(v.segments[0].identifier) != resolved_binding) {\n-                std::io::println(\"uh oh, ext_cx binding didn't match ext_cx varref:\");\n-                std::io::println(fmt!(\"this is varref # %?\",idx));\n-                std::io::println(fmt!(\"binding: %?\",cxbind));\n-                std::io::println(fmt!(\"resolves to: %?\",resolved_binding));\n-                std::io::println(fmt!(\"varref: %?\",v.segments[0]));\n-                std::io::println(fmt!(\"resolves to: %?\",mtwt_resolve(v.segments[0].identifier)));\n-                let table = get_sctable();\n-                std::io::println(\"SC table:\");\n-                for (idx,val) in table.table.iter().enumerate() {\n-                    std::io::println(fmt!(\"%4u : %?\",idx,val));\n-                }\n-            }\n-            assert_eq!(mtwt_resolve(v.segments[0].identifier),resolved_binding);\n-        };\n-    }\n-\n     #[test] fn fmt_in_macro_used_inside_module_macro() {\n         let crate_str = @\"macro_rules! fmt_wrap(($b:expr)=>(fmt!(\\\"left: %?\\\", $b)))\n macro_rules! foo_module (() => (mod generated { fn a() { let xx = 147; fmt_wrap!(xx);}}))"}, {"sha": "6527b083cc1b6f35bcd88b4989eff7a9ed43595d", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 12, "deletions": 33, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1ecc1e51c08f38b6ee42dae9a0f8bd6dc1f1b86f/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ecc1e51c08f38b6ee42dae9a0f8bd6dc1f1b86f/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=1ecc1e51c08f38b6ee42dae9a0f8bd6dc1f1b86f", "patch": "@@ -12,7 +12,6 @@ use ast;\n use codemap::{BytePos, Pos, Span};\n use ext::base::ExtCtxt;\n use ext::base;\n-use ext::expand;\n use ext::build::AstBuilder;\n use parse::token::*;\n use parse::token;\n@@ -292,73 +291,53 @@ pub mod rt {\n \n pub fn expand_quote_tokens(cx: @ExtCtxt,\n                            sp: Span,\n-                           tts: &[ast::token_tree],\n-                           ctxt: ast::SyntaxContext) -> base::MacResult {\n+                           tts: &[ast::token_tree]) -> base::MacResult {\n     let (cx_expr, expr) = expand_tts(cx, sp, tts);\n     let expanded = expand_wrapper(cx, sp, cx_expr, expr);\n-    // repaint the expanded code so it's as though it was the original text.\n-    let repainted = expand::replace_ctxts(expanded,ctxt);\n-    base::MRExpr(repainted)\n+    base::MRExpr(expanded)\n }\n \n pub fn expand_quote_expr(cx: @ExtCtxt,\n                          sp: Span,\n-                         tts: &[ast::token_tree],\n-                         ctxt: ast::SyntaxContext) -> base::MacResult {\n+                         tts: &[ast::token_tree]) -> base::MacResult {\n     let expanded = expand_parse_call(cx, sp, \"parse_expr\", ~[], tts);\n-    // repaint the expanded code so it's as though it was the original text.\n-    let repainted = expand::replace_ctxts(expanded,ctxt);\n-    base::MRExpr(repainted)\n+    base::MRExpr(expanded)\n }\n \n-// these probably need to be capturing, too...\n-\n pub fn expand_quote_item(cx: @ExtCtxt,\n                          sp: Span,\n-                         tts: &[ast::token_tree],\n-                         ctxt: ast::SyntaxContext) -> base::MacResult {\n+                         tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n     let expanded = expand_parse_call(cx, sp, \"parse_item\",\n                                     ~[e_attrs], tts);\n-    // repaint the expanded code so it's as though it was the original text.\n-    let repainted = expand::replace_ctxts(expanded,ctxt);\n-    base::MRExpr(repainted)\n+    base::MRExpr(expanded)\n }\n \n pub fn expand_quote_pat(cx: @ExtCtxt,\n                         sp: Span,\n-                        tts: &[ast::token_tree],\n-                        ctxt: ast::SyntaxContext) -> base::MacResult {\n+                        tts: &[ast::token_tree]) -> base::MacResult {\n     let e_refutable = cx.expr_lit(sp, ast::lit_bool(true));\n     let expanded = expand_parse_call(cx, sp, \"parse_pat\",\n                                     ~[e_refutable], tts);\n-    // repaint the expanded code so it's as though it was the original text.\n-    let repainted = expand::replace_ctxts(expanded,ctxt);\n-    base::MRExpr(repainted)\n+    base::MRExpr(expanded)\n }\n \n pub fn expand_quote_ty(cx: @ExtCtxt,\n                        sp: Span,\n-                       tts: &[ast::token_tree],\n-                       ctxt: ast::SyntaxContext) -> base::MacResult {\n+                       tts: &[ast::token_tree]) -> base::MacResult {\n     let e_param_colons = cx.expr_lit(sp, ast::lit_bool(false));\n     let expanded = expand_parse_call(cx, sp, \"parse_ty\",\n                                      ~[e_param_colons], tts);\n-    // repaint the expanded code so it's as though it was the original text.\n-    let repainted = expand::replace_ctxts(expanded,ctxt);\n-    base::MRExpr(repainted)\n+    base::MRExpr(expanded)\n }\n \n pub fn expand_quote_stmt(cx: @ExtCtxt,\n                          sp: Span,\n-                         tts: &[ast::token_tree],\n-                         ctxt: ast::SyntaxContext) -> base::MacResult {\n+                         tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n     let expanded = expand_parse_call(cx, sp, \"parse_stmt\",\n                                     ~[e_attrs], tts);\n-    // repaint the expanded code so it's as though it was the original text.\n-    let repainted = expand::replace_ctxts(expanded,ctxt);\n-    base::MRExpr(repainted)\n+    base::MRExpr(expanded)\n }\n \n fn ids_ext(strs: ~[~str]) -> ~[ast::Ident] {"}]}