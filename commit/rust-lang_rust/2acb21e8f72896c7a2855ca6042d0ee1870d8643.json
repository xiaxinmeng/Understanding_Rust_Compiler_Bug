{"sha": "2acb21e8f72896c7a2855ca6042d0ee1870d8643", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhY2IyMWU4ZjcyODk2YzdhMjg1NWNhNjA0MmQwZWUxODcwZDg2NDM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-20T19:44:06Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-20T19:44:06Z"}, "message": "merge parse_impl and parser_api", "tree": {"sha": "7c297534569dcf2b69d6e7af9032318aa7c8cc23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c297534569dcf2b69d6e7af9032318aa7c8cc23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2acb21e8f72896c7a2855ca6042d0ee1870d8643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2acb21e8f72896c7a2855ca6042d0ee1870d8643", "html_url": "https://github.com/rust-lang/rust/commit/2acb21e8f72896c7a2855ca6042d0ee1870d8643", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2acb21e8f72896c7a2855ca6042d0ee1870d8643/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e72ad0a2faac98972544dd42316ccf8090717102", "url": "https://api.github.com/repos/rust-lang/rust/commits/e72ad0a2faac98972544dd42316ccf8090717102", "html_url": "https://github.com/rust-lang/rust/commit/e72ad0a2faac98972544dd42316ccf8090717102"}], "stats": {"total": 273, "additions": 102, "deletions": 171}, "files": [{"sha": "92d7895d3ec283589860ef2a0b07088063d2ebdb", "filename": "crates/ra_syntax/src/parsing/parser_api.rs", "status": "modified", "additions": 92, "deletions": 16, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/2acb21e8f72896c7a2855ca6042d0ee1870d8643/crates%2Fra_syntax%2Fsrc%2Fparsing%2Fparser_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acb21e8f72896c7a2855ca6042d0ee1870d8643/crates%2Fra_syntax%2Fsrc%2Fparsing%2Fparser_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Fparser_api.rs?ref=2acb21e8f72896c7a2855ca6042d0ee1870d8643", "patch": "@@ -1,10 +1,14 @@\n+use std::cell::Cell;\n+\n use drop_bomb::DropBomb;\n \n use crate::{\n-    SyntaxKind::{self, ERROR},\n+    syntax_error::ParseError,\n+    SyntaxKind::{self, ERROR, EOF, TOMBSTONE},\n     parsing::{\n+        TokenSource, TokenPos,\n         token_set::TokenSet,\n-        parser_impl::ParserImpl,\n+        parser_impl::event::Event,\n     },\n };\n \n@@ -17,9 +21,22 @@ use crate::{\n /// tree, but rather a flat stream of events of the form\n /// \"start expression, consume number literal,\n /// finish expression\". See `Event` docs for more.\n-pub(crate) struct Parser<'t>(pub(super) ParserImpl<'t>);\n+pub(crate) struct Parser<'t> {\n+    token_source: &'t dyn TokenSource,\n+    pos: TokenPos,\n+    events: Vec<Event>,\n+    steps: Cell<u32>,\n+}\n \n impl<'t> Parser<'t> {\n+    pub(super) fn new(token_source: &'t dyn TokenSource) -> Parser<'t> {\n+        Parser { token_source, pos: TokenPos::default(), events: Vec::new(), steps: Cell::new(0) }\n+    }\n+\n+    pub(crate) fn finish(self) -> Vec<Event> {\n+        self.events\n+    }\n+\n     /// Returns the kind of the current token.\n     /// If parser has already reached the end of input,\n     /// the special `EOF` kind is returned.\n@@ -32,21 +49,39 @@ impl<'t> Parser<'t> {\n     ///\n     /// Useful for parsing things like `>>`.\n     pub(crate) fn current2(&self) -> Option<(SyntaxKind, SyntaxKind)> {\n-        self.0.current2()\n+        let c1 = self.token_source.token_kind(self.pos);\n+        let c2 = self.token_source.token_kind(self.pos + 1);\n+        if self.token_source.is_token_joint_to_next(self.pos) {\n+            Some((c1, c2))\n+        } else {\n+            None\n+        }\n     }\n \n     /// Returns the kinds of the current three tokens, if they are not separated\n     /// by trivia.\n     ///\n     /// Useful for parsing things like `=>>`.\n     pub(crate) fn current3(&self) -> Option<(SyntaxKind, SyntaxKind, SyntaxKind)> {\n-        self.0.current3()\n+        let c1 = self.token_source.token_kind(self.pos);\n+        let c2 = self.token_source.token_kind(self.pos + 1);\n+        let c3 = self.token_source.token_kind(self.pos + 2);\n+        if self.token_source.is_token_joint_to_next(self.pos)\n+            && self.token_source.is_token_joint_to_next(self.pos + 1)\n+        {\n+            Some((c1, c2, c3))\n+        } else {\n+            None\n+        }\n     }\n \n     /// Lookahead operation: returns the kind of the next nth\n     /// token.\n     pub(crate) fn nth(&self, n: u32) -> SyntaxKind {\n-        self.0.nth(n)\n+        let steps = self.steps.get();\n+        assert!(steps <= 10_000_000, \"the parser seems stuck\");\n+        self.steps.set(steps + 1);\n+        self.token_source.token_kind(self.pos + n)\n     }\n \n     /// Checks if the current token is `kind`.\n@@ -60,20 +95,26 @@ impl<'t> Parser<'t> {\n     }\n \n     /// Checks if the current token is contextual keyword with text `t`.\n-    pub(crate) fn at_contextual_kw(&self, t: &str) -> bool {\n-        self.0.at_kw(t)\n+    pub(crate) fn at_contextual_kw(&self, kw: &str) -> bool {\n+        self.token_source.is_keyword(self.pos, kw)\n     }\n \n     /// Starts a new node in the syntax tree. All nodes and tokens\n     /// consumed between the `start` and the corresponding `Marker::complete`\n     /// belong to the same node.\n     pub(crate) fn start(&mut self) -> Marker {\n-        Marker::new(self.0.start())\n+        let pos = self.events.len() as u32;\n+        self.push_event(Event::tombstone());\n+        Marker::new(pos)\n     }\n \n     /// Advances the parser by one token unconditionally.\n     pub(crate) fn bump(&mut self) {\n-        self.0.bump();\n+        let kind = self.nth(0);\n+        if kind == EOF {\n+            return;\n+        }\n+        self.do_bump(kind, 1);\n     }\n \n     /// Advances the parser by one token, remapping its kind.\n@@ -83,22 +124,27 @@ impl<'t> Parser<'t> {\n     /// `union` keyword, and keyword is what ends up in the\n     /// final tree.\n     pub(crate) fn bump_remap(&mut self, kind: SyntaxKind) {\n-        self.0.bump_remap(kind);\n+        if self.nth(0) == EOF {\n+            // TODO: panic!?\n+            return;\n+        }\n+        self.do_bump(kind, 1);\n     }\n \n     /// Advances the parser by `n` tokens, remapping its kind.\n     /// This is useful to create compound tokens from parts. For\n     /// example, an `<<` token is two consecutive remapped `<` tokens\n     pub(crate) fn bump_compound(&mut self, kind: SyntaxKind, n: u8) {\n-        self.0.bump_compound(kind, n);\n+        self.do_bump(kind, n);\n     }\n \n     /// Emit error with the `message`\n     /// TODO: this should be much more fancy and support\n     /// structured errors with spans and notes, like rustc\n     /// does.\n     pub(crate) fn error<T: Into<String>>(&mut self, message: T) {\n-        self.0.error(message.into())\n+        let msg = ParseError(message.into());\n+        self.push_event(Event::Error { msg })\n     }\n \n     /// Consume the next token if `kind` matches.\n@@ -136,6 +182,15 @@ impl<'t> Parser<'t> {\n             m.complete(self, ERROR);\n         };\n     }\n+\n+    fn do_bump(&mut self, kind: SyntaxKind, n_raw_tokens: u8) {\n+        self.pos += u32::from(n_raw_tokens);\n+        self.push_event(Event::Token { kind, n_raw_tokens });\n+    }\n+\n+    fn push_event(&mut self, event: Event) {\n+        self.events.push(event)\n+    }\n }\n \n /// See `Parser::start`.\n@@ -154,15 +209,28 @@ impl Marker {\n     /// operation like `.precede()` to deal with forward_parent.\n     pub(crate) fn complete(mut self, p: &mut Parser, kind: SyntaxKind) -> CompletedMarker {\n         self.bomb.defuse();\n-        p.0.complete(self.pos, kind);\n+        let idx = self.pos as usize;\n+        match p.events[idx] {\n+            Event::Start { kind: ref mut slot, .. } => {\n+                *slot = kind;\n+            }\n+            _ => unreachable!(),\n+        }\n+        p.push_event(Event::Finish);\n         CompletedMarker::new(self.pos, kind)\n     }\n \n     /// Abandons the syntax tree node. All its children\n     /// are attached to its parent instead.\n     pub(crate) fn abandon(mut self, p: &mut Parser) {\n         self.bomb.defuse();\n-        p.0.abandon(self.pos);\n+        let idx = self.pos as usize;\n+        if idx == p.events.len() - 1 {\n+            match p.events.pop() {\n+                Some(Event::Start { kind: TOMBSTONE, forward_parent: None }) => (),\n+                _ => unreachable!(),\n+            }\n+        }\n     }\n }\n \n@@ -186,7 +254,15 @@ impl CompletedMarker {\n     /// then mark `NEWSTART` as `START`'s parent with saving its relative\n     /// distance to `NEWSTART` into forward_parent(=2 in this case);\n     pub(crate) fn precede(self, p: &mut Parser) -> Marker {\n-        Marker::new(p.0.precede(self.0))\n+        let new_pos = p.start();\n+        let idx = self.0 as usize;\n+        match p.events[idx] {\n+            Event::Start { ref mut forward_parent, .. } => {\n+                *forward_parent = Some(new_pos.pos - self.0);\n+            }\n+            _ => unreachable!(),\n+        }\n+        new_pos\n     }\n \n     pub(crate) fn kind(&self) -> SyntaxKind {"}, {"sha": "6eed0e656a4abe1582f7c74c9d655ad7e12a6ae2", "filename": "crates/ra_syntax/src/parsing/parser_impl.rs", "status": "modified", "additions": 10, "deletions": 155, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/2acb21e8f72896c7a2855ca6042d0ee1870d8643/crates%2Fra_syntax%2Fsrc%2Fparsing%2Fparser_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acb21e8f72896c7a2855ca6042d0ee1870d8643/crates%2Fra_syntax%2Fsrc%2Fparsing%2Fparser_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Fparser_impl.rs?ref=2acb21e8f72896c7a2855ca6042d0ee1870d8643", "patch": "@@ -1,20 +1,13 @@\n-mod event;\n-pub(crate) mod input;\n-\n-use std::cell::Cell;\n-\n-use crate::{\n-    syntax_error::ParseError,\n-    parsing::{\n-        TreeSink, TokenSource, TokenPos,\n-        lexer::Token,\n-        parser_api::Parser,\n-        parser_impl::event::{Event, EventProcessor},\n-    },\n+pub(super) mod event;\n+pub(super) mod input;\n+\n+use crate::parsing::{\n+    TreeSink, TokenSource,\n+    lexer::Token,\n+    parser_api::Parser,\n+    parser_impl::event::EventProcessor,\n };\n \n-use crate::SyntaxKind::{self, EOF, TOMBSTONE};\n-\n /// Parse a sequence of tokens into the representative node tree\n pub(super) fn parse_with<S: TreeSink>(\n     sink: S,\n@@ -24,147 +17,9 @@ pub(super) fn parse_with<S: TreeSink>(\n ) -> S::Tree {\n     let mut events = {\n         let input = input::ParserInput::new(text, tokens);\n-        let parser_impl = ParserImpl::new(&input);\n-        let mut parser_api = Parser(parser_impl);\n+        let mut parser_api = Parser::new(&input);\n         parser(&mut parser_api);\n-        parser_api.0.into_events()\n+        parser_api.finish()\n     };\n     EventProcessor::new(sink, text, tokens, &mut events).process().finish()\n }\n-\n-/// Implementation details of `Parser`, extracted\n-/// to a separate struct in order not to pollute\n-/// the public API of the `Parser`.\n-pub(super) struct ParserImpl<'a> {\n-    token_source: &'a dyn TokenSource,\n-    pos: TokenPos,\n-    events: Vec<Event>,\n-    steps: Cell<u32>,\n-}\n-\n-impl<'a> ParserImpl<'a> {\n-    fn new(token_source: &'a dyn TokenSource) -> ParserImpl<'a> {\n-        ParserImpl {\n-            token_source,\n-            pos: TokenPos::default(),\n-            events: Vec::new(),\n-            steps: Cell::new(0),\n-        }\n-    }\n-\n-    fn into_events(self) -> Vec<Event> {\n-        assert_eq!(self.nth(0), EOF);\n-        self.events\n-    }\n-\n-    pub(super) fn current2(&self) -> Option<(SyntaxKind, SyntaxKind)> {\n-        let c1 = self.token_source.token_kind(self.pos);\n-        let c2 = self.token_source.token_kind(self.pos + 1);\n-        if self.token_source.is_token_joint_to_next(self.pos) {\n-            Some((c1, c2))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub(super) fn current3(&self) -> Option<(SyntaxKind, SyntaxKind, SyntaxKind)> {\n-        let c1 = self.token_source.token_kind(self.pos);\n-        let c2 = self.token_source.token_kind(self.pos + 1);\n-        let c3 = self.token_source.token_kind(self.pos + 2);\n-        if self.token_source.is_token_joint_to_next(self.pos)\n-            && self.token_source.is_token_joint_to_next(self.pos + 1)\n-        {\n-            Some((c1, c2, c3))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Get the syntax kind of the nth token.\n-    pub(super) fn nth(&self, n: u32) -> SyntaxKind {\n-        let steps = self.steps.get();\n-        assert!(steps <= 10_000_000, \"the parser seems stuck\");\n-        self.steps.set(steps + 1);\n-        self.token_source.token_kind(self.pos + n)\n-    }\n-\n-    pub(super) fn at_kw(&self, kw: &str) -> bool {\n-        self.token_source.is_keyword(self.pos, kw)\n-    }\n-\n-    /// Start parsing right behind the last event.\n-    pub(super) fn start(&mut self) -> u32 {\n-        let pos = self.events.len() as u32;\n-        self.push_event(Event::tombstone());\n-        pos\n-    }\n-\n-    /// Advances the parser by one token unconditionally.\n-    pub(super) fn bump(&mut self) {\n-        let kind = self.nth(0);\n-        if kind == EOF {\n-            return;\n-        }\n-        self.do_bump(kind, 1);\n-    }\n-\n-    pub(super) fn bump_remap(&mut self, kind: SyntaxKind) {\n-        if self.nth(0) == EOF {\n-            // TODO: panic!?\n-            return;\n-        }\n-        self.do_bump(kind, 1);\n-    }\n-\n-    pub(super) fn bump_compound(&mut self, kind: SyntaxKind, n: u8) {\n-        self.do_bump(kind, n);\n-    }\n-\n-    fn do_bump(&mut self, kind: SyntaxKind, n_raw_tokens: u8) {\n-        self.pos += u32::from(n_raw_tokens);\n-        self.push_event(Event::Token { kind, n_raw_tokens });\n-    }\n-\n-    /// Append one Error event to the back of events.\n-    pub(super) fn error(&mut self, msg: String) {\n-        self.push_event(Event::Error { msg: ParseError(msg) })\n-    }\n-\n-    /// Complete an event with appending a `Finish` event.\n-    pub(super) fn complete(&mut self, pos: u32, kind: SyntaxKind) {\n-        match self.events[pos as usize] {\n-            Event::Start { kind: ref mut slot, .. } => {\n-                *slot = kind;\n-            }\n-            _ => unreachable!(),\n-        }\n-        self.push_event(Event::Finish);\n-    }\n-\n-    /// Ignore the dummy `Start` event.\n-    pub(super) fn abandon(&mut self, pos: u32) {\n-        let idx = pos as usize;\n-        if idx == self.events.len() - 1 {\n-            match self.events.pop() {\n-                Some(Event::Start { kind: TOMBSTONE, forward_parent: None }) => (),\n-                _ => unreachable!(),\n-            }\n-        }\n-    }\n-\n-    /// Save the relative distance of a completed event to its forward_parent.\n-    pub(super) fn precede(&mut self, pos: u32) -> u32 {\n-        let new_pos = self.start();\n-        match self.events[pos as usize] {\n-            Event::Start { ref mut forward_parent, .. } => {\n-                *forward_parent = Some(new_pos - pos);\n-            }\n-            _ => unreachable!(),\n-        }\n-        new_pos\n-    }\n-\n-    fn push_event(&mut self, event: Event) {\n-        self.events.push(event)\n-    }\n-}"}]}