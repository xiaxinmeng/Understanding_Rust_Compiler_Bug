{"sha": "bd3fb81e5e7cd19fe3a2812efffc750007d43852", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkM2ZiODFlNWU3Y2QxOWZlM2EyODEyZWZmZmM3NTAwMDdkNDM4NTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-05T23:51:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-05T23:51:30Z"}, "message": "auto merge of #13934 : huonw/rust/transmute-mut, r=alexcrichton\n\nTurning a `&T` into an `&mut T` is undefined behaviour, and needs to be\r\ndone very very carefully. Providing a convenience function for exactly\r\nthis task is a bad idea, just tempting people into doing the wrong\r\nthing.\r\n\r\n(The right thing is to use types like `Cell`, `RefCell` or `Unsafe`.)\r\n\r\ncc https://github.com/mozilla/rust/issues/13933", "tree": {"sha": "f37362d5d982408e05b5167163c88da33bbb098d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f37362d5d982408e05b5167163c88da33bbb098d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd3fb81e5e7cd19fe3a2812efffc750007d43852", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd3fb81e5e7cd19fe3a2812efffc750007d43852", "html_url": "https://github.com/rust-lang/rust/commit/bd3fb81e5e7cd19fe3a2812efffc750007d43852", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd3fb81e5e7cd19fe3a2812efffc750007d43852/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7583544fb541b9822dd658e5bf7aae1233cb5794", "url": "https://api.github.com/repos/rust-lang/rust/commits/7583544fb541b9822dd658e5bf7aae1233cb5794", "html_url": "https://github.com/rust-lang/rust/commit/7583544fb541b9822dd658e5bf7aae1233cb5794"}, {"sha": "edd9bad4eeb1367464e190d63113600fca0ef25a", "url": "https://api.github.com/repos/rust-lang/rust/commits/edd9bad4eeb1367464e190d63113600fca0ef25a", "html_url": "https://github.com/rust-lang/rust/commit/edd9bad4eeb1367464e190d63113600fca0ef25a"}], "stats": {"total": 120, "additions": 74, "deletions": 46}, "files": [{"sha": "d80385587dad5f66998a75dc743115a06ef0bee4", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=bd3fb81e5e7cd19fe3a2812efffc750007d43852", "patch": "@@ -26,7 +26,7 @@\n \n extern crate collections;\n \n-use std::cast::{transmute, transmute_mut, transmute_mut_lifetime};\n+use std::cast::{transmute, transmute_mut_lifetime};\n use std::cast;\n use std::cell::{Cell, RefCell};\n use std::mem;\n@@ -281,8 +281,8 @@ impl Arena {\n     #[inline]\n     pub fn alloc<'a, T>(&'a self, op: || -> T) -> &'a T {\n         unsafe {\n-            // FIXME: Borrow check\n-            let this = transmute_mut(self);\n+            // FIXME #13933: Remove/justify all `&T` to `&mut T` transmutes\n+            let this: &mut Arena = transmute::<&_, &mut _>(self);\n             if intrinsics::needs_drop::<T>() {\n                 this.alloc_noncopy(op)\n             } else {\n@@ -438,7 +438,8 @@ impl<T> TypedArena<T> {\n     #[inline]\n     pub fn alloc<'a>(&'a self, object: T) -> &'a T {\n         unsafe {\n-            let this = cast::transmute_mut(self);\n+            // FIXME #13933: Remove/justify all `&T` to `&mut T` transmutes\n+            let this: &mut TypedArena<T> = cast::transmute::<&_, &mut _>(self);\n             if this.ptr == this.end {\n                 this.grow()\n             }"}, {"sha": "aae15a86614420acb4824132d4d8318c56e4b309", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=bd3fb81e5e7cd19fe3a2812efffc750007d43852", "patch": "@@ -174,7 +174,8 @@ impl rtio::RtioFileStream for FileDesc {\n     fn tell(&self) -> Result<u64, IoError> {\n         // This transmute is fine because our seek implementation doesn't\n         // actually use the mutable self at all.\n-        unsafe { cast::transmute_mut(self).seek(0, io::SeekCur) }\n+        // FIXME #13933: Remove/justify all `&T` to `&mut T` transmutes\n+        unsafe { cast::transmute::<&_, &mut FileDesc>(self).seek(0, io::SeekCur) }\n     }\n \n     fn fsync(&mut self) -> Result<(), IoError> {"}, {"sha": "9037363f9a00eb46c7338b0f41efbcca1b3a10b5", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=bd3fb81e5e7cd19fe3a2812efffc750007d43852", "patch": "@@ -445,7 +445,8 @@ impl rtio::RtioFileStream for FileWatcher {\n     fn tell(&self) -> Result<u64, IoError> {\n         use libc::SEEK_CUR;\n         // this is temporary\n-        let self_ = unsafe { cast::transmute_mut(self) };\n+        // FIXME #13933: Remove/justify all `&T` to `&mut T` transmutes\n+        let self_ = unsafe { cast::transmute::<&_, &mut FileWatcher>(self) };\n         self_.seek_common(0, SEEK_CUR)\n     }\n     fn fsync(&mut self) -> Result<(), IoError> {"}, {"sha": "7a8f517bbf92c0af6d6014f554b68b550c353b4d", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=bd3fb81e5e7cd19fe3a2812efffc750007d43852", "patch": "@@ -60,6 +60,7 @@ pub unsafe fn transmute<L, G>(thing: L) -> G {\n \n /// Coerce an immutable reference to be mutable.\n #[inline]\n+#[deprecated=\"casting &T to &mut T is undefined behaviour: use Cell<T>, RefCell<T> or Unsafe<T>\"]\n pub unsafe fn transmute_mut<'a,T>(ptr: &'a T) -> &'a mut T { transmute(ptr) }\n \n /// Coerce a reference to have an arbitrary associated lifetime."}, {"sha": "c78498924656c5fa5b0b1910464cdc347ccd37ee", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 49, "deletions": 29, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=bd3fb81e5e7cd19fe3a2812efffc750007d43852", "patch": "@@ -271,7 +271,6 @@\n // And now that you've seen all the races that I found and attempted to fix,\n // here's the code for you to find some more!\n \n-use cast;\n use cell::Cell;\n use clone::Clone;\n use iter::Iterator;\n@@ -284,6 +283,7 @@ use result::{Ok, Err, Result};\n use rt::local::Local;\n use rt::task::{Task, BlockedTask};\n use sync::arc::UnsafeArc;\n+use ty::Unsafe;\n \n pub use comm::select::{Select, Handle};\n \n@@ -325,7 +325,7 @@ static RESCHED_FREQ: int = 256;\n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n pub struct Receiver<T> {\n-    inner: Flavor<T>,\n+    inner: Unsafe<Flavor<T>>,\n     receives: Cell<uint>,\n     // can't share in an arc\n     marker: marker::NoShare,\n@@ -341,7 +341,7 @@ pub struct Messages<'a, T> {\n /// The sending-half of Rust's asynchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n pub struct Sender<T> {\n-    inner: Flavor<T>,\n+    inner: Unsafe<Flavor<T>>,\n     sends: Cell<uint>,\n     // can't share in an arc\n     marker: marker::NoShare,\n@@ -390,6 +390,27 @@ enum Flavor<T> {\n     Sync(UnsafeArc<sync::Packet<T>>),\n }\n \n+#[doc(hidden)]\n+trait UnsafeFlavor<T> {\n+    fn inner_unsafe<'a>(&'a self) -> &'a Unsafe<Flavor<T>>;\n+    unsafe fn mut_inner<'a>(&'a self) -> &'a mut Flavor<T> {\n+        &mut *self.inner_unsafe().get()\n+    }\n+    unsafe fn inner<'a>(&'a self) -> &'a Flavor<T> {\n+        &*self.inner_unsafe().get()\n+    }\n+}\n+impl<T> UnsafeFlavor<T> for Sender<T> {\n+    fn inner_unsafe<'a>(&'a self) -> &'a Unsafe<Flavor<T>> {\n+        &self.inner\n+    }\n+}\n+impl<T> UnsafeFlavor<T> for Receiver<T> {\n+    fn inner_unsafe<'a>(&'a self) -> &'a Unsafe<Flavor<T>> {\n+        &self.inner\n+    }\n+}\n+\n /// Creates a new asynchronous channel, returning the sender/receiver halves.\n ///\n /// All data sent on the sender will become available on the receiver, and no\n@@ -458,7 +479,7 @@ pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n \n impl<T: Send> Sender<T> {\n     fn new(inner: Flavor<T>) -> Sender<T> {\n-        Sender { inner: inner, sends: Cell::new(0), marker: marker::NoShare }\n+        Sender { inner: Unsafe::new(inner), sends: Cell::new(0), marker: marker::NoShare }\n     }\n \n     /// Sends a value along this channel to be received by the corresponding\n@@ -532,7 +553,7 @@ impl<T: Send> Sender<T> {\n             task.map(|t| t.maybe_yield());\n         }\n \n-        let (new_inner, ret) = match self.inner {\n+        let (new_inner, ret) = match *unsafe { self.inner() } {\n             Oneshot(ref p) => {\n                 let p = p.get();\n                 unsafe {\n@@ -564,16 +585,16 @@ impl<T: Send> Sender<T> {\n         };\n \n         unsafe {\n-            let mut tmp = Sender::new(Stream(new_inner));\n-            mem::swap(&mut cast::transmute_mut(self).inner, &mut tmp.inner);\n+            let tmp = Sender::new(Stream(new_inner));\n+            mem::swap(self.mut_inner(), tmp.mut_inner());\n         }\n         return ret;\n     }\n }\n \n impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n-        let (packet, sleeper) = match self.inner {\n+        let (packet, sleeper) = match *unsafe { self.inner() } {\n             Oneshot(ref p) => {\n                 let (a, b) = UnsafeArc::new2(shared::Packet::new());\n                 match unsafe { (*p.get()).upgrade(Receiver::new(Shared(a))) } {\n@@ -598,8 +619,8 @@ impl<T: Send> Clone for Sender<T> {\n         unsafe {\n             (*packet.get()).inherit_blocker(sleeper);\n \n-            let mut tmp = Sender::new(Shared(packet.clone()));\n-            mem::swap(&mut cast::transmute_mut(self).inner, &mut tmp.inner);\n+            let tmp = Sender::new(Shared(packet.clone()));\n+            mem::swap(self.mut_inner(), tmp.mut_inner());\n         }\n         Sender::new(Shared(packet))\n     }\n@@ -608,7 +629,7 @@ impl<T: Send> Clone for Sender<T> {\n #[unsafe_destructor]\n impl<T: Send> Drop for Sender<T> {\n     fn drop(&mut self) {\n-        match self.inner {\n+        match *unsafe { self.mut_inner() } {\n             Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n             Stream(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n             Shared(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n@@ -705,7 +726,7 @@ impl<T: Send> Drop for SyncSender<T> {\n \n impl<T: Send> Receiver<T> {\n     fn new(inner: Flavor<T>) -> Receiver<T> {\n-        Receiver { inner: inner, receives: Cell::new(0), marker: marker::NoShare }\n+        Receiver { inner: Unsafe::new(inner), receives: Cell::new(0), marker: marker::NoShare }\n     }\n \n     /// Blocks waiting for a value on this receiver\n@@ -757,7 +778,7 @@ impl<T: Send> Receiver<T> {\n         }\n \n         loop {\n-            let mut new_port = match self.inner {\n+            let new_port = match *unsafe { self.inner() } {\n                 Oneshot(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n@@ -790,8 +811,8 @@ impl<T: Send> Receiver<T> {\n                 }\n             };\n             unsafe {\n-                mem::swap(&mut cast::transmute_mut(self).inner,\n-                          &mut new_port.inner);\n+                mem::swap(self.mut_inner(),\n+                          new_port.mut_inner());\n             }\n         }\n     }\n@@ -810,7 +831,7 @@ impl<T: Send> Receiver<T> {\n     /// the value found on the receiver is returned.\n     pub fn recv_opt(&self) -> Result<T, ()> {\n         loop {\n-            let mut new_port = match self.inner {\n+            let new_port = match *unsafe { self.inner() } {\n                 Oneshot(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n@@ -837,8 +858,7 @@ impl<T: Send> Receiver<T> {\n                 Sync(ref p) => return unsafe { (*p.get()).recv() }\n             };\n             unsafe {\n-                mem::swap(&mut cast::transmute_mut(self).inner,\n-                          &mut new_port.inner);\n+                mem::swap(self.mut_inner(), new_port.mut_inner());\n             }\n         }\n     }\n@@ -853,7 +873,7 @@ impl<T: Send> Receiver<T> {\n impl<T: Send> select::Packet for Receiver<T> {\n     fn can_recv(&self) -> bool {\n         loop {\n-            let mut new_port = match self.inner {\n+            let new_port = match *unsafe { self.inner() } {\n                 Oneshot(ref p) => {\n                     match unsafe { (*p.get()).can_recv() } {\n                         Ok(ret) => return ret,\n@@ -874,15 +894,15 @@ impl<T: Send> select::Packet for Receiver<T> {\n                 }\n             };\n             unsafe {\n-                mem::swap(&mut cast::transmute_mut(self).inner,\n-                          &mut new_port.inner);\n+                mem::swap(self.mut_inner(),\n+                          new_port.mut_inner());\n             }\n         }\n     }\n \n     fn start_selection(&self, mut task: BlockedTask) -> Result<(), BlockedTask>{\n         loop {\n-            let (t, mut new_port) = match self.inner {\n+            let (t, new_port) = match *unsafe { self.inner() } {\n                 Oneshot(ref p) => {\n                     match unsafe { (*p.get()).start_selection(task) } {\n                         oneshot::SelSuccess => return Ok(()),\n@@ -906,16 +926,16 @@ impl<T: Send> select::Packet for Receiver<T> {\n             };\n             task = t;\n             unsafe {\n-                mem::swap(&mut cast::transmute_mut(self).inner,\n-                          &mut new_port.inner);\n+                mem::swap(self.mut_inner(),\n+                          new_port.mut_inner());\n             }\n         }\n     }\n \n     fn abort_selection(&self) -> bool {\n         let mut was_upgrade = false;\n         loop {\n-            let result = match self.inner {\n+            let result = match *unsafe { self.inner() } {\n                 Oneshot(ref p) => unsafe { (*p.get()).abort_selection() },\n                 Stream(ref p) => unsafe {\n                     (*p.get()).abort_selection(was_upgrade)\n@@ -927,11 +947,11 @@ impl<T: Send> select::Packet for Receiver<T> {\n                     (*p.get()).abort_selection()\n                 },\n             };\n-            let mut new_port = match result { Ok(b) => return b, Err(p) => p };\n+            let new_port = match result { Ok(b) => return b, Err(p) => p };\n             was_upgrade = true;\n             unsafe {\n-                mem::swap(&mut cast::transmute_mut(self).inner,\n-                          &mut new_port.inner);\n+                mem::swap(self.mut_inner(),\n+                          new_port.mut_inner());\n             }\n         }\n     }\n@@ -944,7 +964,7 @@ impl<'a, T: Send> Iterator<T> for Messages<'a, T> {\n #[unsafe_destructor]\n impl<T: Send> Drop for Receiver<T> {\n     fn drop(&mut self) {\n-        match self.inner {\n+        match *unsafe { self.mut_inner() } {\n             Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },\n             Stream(ref mut p) => unsafe { (*p.get()).drop_port(); },\n             Shared(ref mut p) => unsafe { (*p.get()).drop_port(); },"}, {"sha": "e5c7ba4aa54bcbf9b0166c5eecda9086d8300d9c", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=bd3fb81e5e7cd19fe3a2812efffc750007d43852", "patch": "@@ -196,11 +196,11 @@ pub fn get_mut<T: 'static, U>(key: Key<T>, f: |Option<&mut T>| -> U) -> U {\n         match x {\n             None => f(None),\n             // We're violating a lot of compiler guarantees with this\n-            // invocation of `transmute_mut`, but we're doing runtime checks to\n+            // invocation of `transmute`, but we're doing runtime checks to\n             // ensure that it's always valid (only one at a time).\n             //\n             // there is no need to be upset!\n-            Some(x) => { f(Some(unsafe { cast::transmute_mut(x) })) }\n+            Some(x) => { f(Some(unsafe { cast::transmute::<&_, &mut _>(x) })) }\n         }\n     })\n }"}, {"sha": "d8c866ef44a39193e34996efaef6f649741cf248", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=bd3fb81e5e7cd19fe3a2812efffc750007d43852", "patch": "@@ -1739,15 +1739,19 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n         if self.len() == 0 { return None; }\n         unsafe {\n             let s: &mut Slice<T> = transmute(self);\n-            Some(cast::transmute_mut(&*raw::shift_ptr(s)))\n+            // FIXME #13933: this `&` -> `&mut` cast is a little\n+            // dubious\n+            Some(&mut *(raw::shift_ptr(s) as *mut _))\n         }\n     }\n \n     fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n         if self.len() == 0 { return None; }\n         unsafe {\n             let s: &mut Slice<T> = transmute(self);\n-            Some(cast::transmute_mut(&*raw::pop_ptr(s)))\n+            // FIXME #13933: this `&` -> `&mut` cast is a little\n+            // dubious\n+            Some(&mut *(raw::pop_ptr(s) as *mut _))\n         }\n     }\n \n@@ -3108,23 +3112,23 @@ mod tests {\n     #[should_fail]\n     fn test_from_elem_fail() {\n         use cast;\n+        use cell::Cell;\n         use rc::Rc;\n \n         struct S {\n-            f: int,\n+            f: Cell<int>,\n             boxes: (~int, Rc<int>)\n         }\n \n         impl Clone for S {\n             fn clone(&self) -> S {\n-                let s = unsafe { cast::transmute_mut(self) };\n-                s.f += 1;\n-                if s.f == 10 { fail!() }\n-                S { f: s.f, boxes: s.boxes.clone() }\n+                self.f.set(self.f.get() + 1);\n+                if self.f.get() == 10 { fail!() }\n+                S { f: self.f, boxes: self.boxes.clone() }\n             }\n         }\n \n-        let s = S { f: 0, boxes: (box 0, Rc::new(0)) };\n+        let s = S { f: Cell::new(0), boxes: (box 0, Rc::new(0)) };\n         let _ = Vec::from_elem(100, s);\n     }\n "}, {"sha": "f5369ec862f8a0bf8bb004805ab354da1c0adf8c", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd3fb81e5e7cd19fe3a2812efffc750007d43852/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=bd3fb81e5e7cd19fe3a2812efffc750007d43852", "patch": "@@ -148,7 +148,7 @@ impl<T: Send + Share + Clone> Arc<T> {\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the Arc itself to be `mut`, so we're returning the only possible\n         // reference to the inner data.\n-        unsafe { cast::transmute_mut(self.deref()) }\n+        unsafe { cast::transmute::<&_, &mut _>(self.deref()) }\n     }\n }\n "}]}