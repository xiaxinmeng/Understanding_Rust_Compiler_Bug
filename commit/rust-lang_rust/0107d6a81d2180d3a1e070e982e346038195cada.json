{"sha": "0107d6a81d2180d3a1e070e982e346038195cada", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMDdkNmE4MWQyMTgwZDNhMWUwNzBlOTgyZTM0NjAzODE5NWNhZGE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2011-08-16T16:07:26Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2011-08-16T21:16:14Z"}, "message": "Change type parameter syntax to foo<T>.\n\nThis preserves the old syntax for now.", "tree": {"sha": "28e29a252d82ad5d247c83572bd4fa8b521a5e74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28e29a252d82ad5d247c83572bd4fa8b521a5e74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0107d6a81d2180d3a1e070e982e346038195cada", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0107d6a81d2180d3a1e070e982e346038195cada", "html_url": "https://github.com/rust-lang/rust/commit/0107d6a81d2180d3a1e070e982e346038195cada", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0107d6a81d2180d3a1e070e982e346038195cada/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e06893819eeafaa5c5b1518a8d809c211ce8519", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e06893819eeafaa5c5b1518a8d809c211ce8519", "html_url": "https://github.com/rust-lang/rust/commit/6e06893819eeafaa5c5b1518a8d809c211ce8519"}], "stats": {"total": 81, "additions": 64, "deletions": 17}, "files": [{"sha": "b1a4a92373df5f3b9e22ed11223167c68e5f1e4e", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 57, "deletions": 10, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0107d6a81d2180d3a1e070e982e346038195cada/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0107d6a81d2180d3a1e070e982e346038195cada/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=0107d6a81d2180d3a1e070e982e346038195cada", "patch": "@@ -35,6 +35,7 @@ type parser =\n     obj {\n         fn peek() -> token::token ;\n         fn bump() ;\n+        fn swap(token::token, uint, uint) ;\n         fn look_ahead(uint) -> token::token ;\n         fn fatal(str) -> !  ;\n         fn warn(str) ;\n@@ -97,6 +98,10 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n                 tok_span = next.span;\n             }\n         }\n+        fn swap(next: token::token, lo: uint, hi: uint) {\n+            tok = next;\n+            tok_span = ast::mk_sp(lo, hi);\n+        }\n         fn look_ahead(distance: uint) -> token::token {\n             while vec::len(buffer) < distance {\n                 let next = lexer::next_token(rdr);\n@@ -202,6 +207,23 @@ fn expect(p: &parser, t: token::token) {\n     }\n }\n \n+fn expect_gt(p: &parser) {\n+    if p.peek() == token::GT {\n+        p.bump();\n+    } else if p.peek() == token::BINOP(token::LSR) {\n+        p.swap(token::GT, p.get_lo_pos() + 1u, p.get_hi_pos());\n+    } else if p.peek() == token::BINOP(token::ASR) {\n+        p.swap(token::BINOP(token::LSR), p.get_lo_pos() + 1u,\n+               p.get_hi_pos());\n+    } else {\n+        let s: str = \"expecting \";\n+        s += token::to_str(p.get_reader(), token::GT);\n+        s += \", found \";\n+        s += token::to_str(p.get_reader(), p.peek());\n+        p.fatal(s);\n+    }\n+}\n+\n fn spanned[T](lo: uint, hi: uint, node: &T) -> spanned[T] {\n     ret {node: node, span: ast::mk_sp(lo, hi)};\n }\n@@ -426,24 +448,23 @@ fn parse_ty_postfix(orig_t: ast::ty_, p: &parser, colons_before_params: bool)\n         -> @ast::ty {\n     let lo = p.get_lo_pos();\n \n-    let end;\n+    let seq;\n     if p.peek() == token::LBRACKET {\n         p.bump();\n-        end = token::RBRACKET;\n+        seq = parse_seq_to_end(token::RBRACKET, some(token::COMMA),\n+                               bind parse_ty(_, false), p);\n     } else if colons_before_params && p.peek() == token::MOD_SEP {\n         p.bump();\n         expect(p, token::LT);\n-        end = token::GT;\n+        seq = parse_seq_to_gt(some(token::COMMA), bind parse_ty(_, false), p);\n     } else if !colons_before_params && p.peek() == token::LT {\n         p.bump();\n-        end = token::GT;\n+        seq = parse_seq_to_gt(some(token::COMMA), bind parse_ty(_, false), p);\n     } else {\n         ret @spanned(lo, p.get_lo_pos(), orig_t);\n     }\n \n     // If we're here, we have explicit type parameter instantiation.\n-    let seq = parse_seq_to_end(end, some(token::COMMA),\n-                               bind parse_ty(_, false), p);\n \n     alt orig_t {\n       ast::ty_path(pth, ann) {\n@@ -554,10 +575,17 @@ fn parse_ty(p: &parser, colons_before_params: bool) -> @ast::ty {\n                                parse_type_constraints(p));\n         }\n     } else if (eat_word(p, \"vec\")) {\n-        expect(p, token::LBRACKET);\n-        t = ast::ty_vec(parse_mt(p));\n-        hi = p.get_hi_pos();\n-        expect(p, token::RBRACKET);\n+        if p.peek() == token::LBRACKET {\n+            p.bump();\n+            t = ast::ty_vec(parse_mt(p));\n+            hi = p.get_hi_pos();\n+            expect(p, token::RBRACKET);\n+        } else {\n+            expect(p, token::LT);\n+            t = ast::ty_vec(parse_mt(p));\n+            hi = p.get_hi_pos();\n+            expect_gt(p);\n+        }\n     } else if (p.peek() == token::LBRACKET) {\n         expect(p, token::LBRACKET);\n         t = ast::ty_ivec(parse_mt(p));\n@@ -615,6 +643,25 @@ fn parse_fn_block_arg(p: &parser) -> ast::arg {\n     ret {mode: m, ty: t, ident: i, id: p.get_id()};\n }\n \n+fn parse_seq_to_gt[T](sep: option::t[token::token], f: fn(&parser) -> T,\n+                      p: &parser) -> [T] {\n+    let first = true;\n+    let v = ~[];\n+    while p.peek() != token::GT &&\n+          p.peek() != token::BINOP(token::LSR) &&\n+          p.peek() != token::BINOP(token::ASR) {\n+        alt sep {\n+          some(t) { if first { first = false; } else { expect(p, t); } }\n+          _ { }\n+        }\n+        v += ~[f(p)];\n+    }\n+\n+    expect_gt(p);\n+\n+    ret v;\n+}\n+\n fn parse_seq_to_end[T](ket: token::token, sep: option::t[token::token],\n                        f: fn(&parser) -> T , p: &parser) -> [T] {\n     let val = parse_seq_to_before_end(ket, sep, f, p);"}, {"sha": "d2af60096ec23a4fce485fc7232337363ec722bc", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0107d6a81d2180d3a1e070e982e346038195cada/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0107d6a81d2180d3a1e070e982e346038195cada/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=0107d6a81d2180d3a1e070e982e346038195cada", "patch": "@@ -282,7 +282,7 @@ fn print_type(s: &ps, ty: &@ast::ty) {\n       ast::ty_str. { word(s.s, \"str\"); }\n       ast::ty_istr. { word(s.s, \"istr\"); }\n       ast::ty_box(mt) { word(s.s, \"@\"); print_mt(s, mt); }\n-      ast::ty_vec(mt) { word(s.s, \"vec[\"); print_mt(s, mt); word(s.s, \"]\"); }\n+      ast::ty_vec(mt) { word(s.s, \"vec<\"); print_mt(s, mt); word(s.s, \">\"); }\n       ast::ty_ivec(mt) {\n         word(s.s, \"[\");\n         alt mt.mut {\n@@ -296,14 +296,14 @@ fn print_type(s: &ps, ty: &@ast::ty) {\n       ast::ty_ptr(mt) { word(s.s, \"*\"); print_mt(s, mt); }\n       ast::ty_task. { word(s.s, \"task\"); }\n       ast::ty_port(t) {\n-        word(s.s, \"port[\");\n+        word(s.s, \"port<\");\n         print_type(s, t);\n-        word(s.s, \"]\");\n+        word(s.s, \">\");\n       }\n       ast::ty_chan(t) {\n-        word(s.s, \"chan[\");\n+        word(s.s, \"chan<\");\n         print_type(s, t);\n-        word(s.s, \"]\");\n+        word(s.s, \">\");\n       }\n       ast::ty_rec(fields) {\n         word(s.s, \"{\");\n@@ -1097,9 +1097,9 @@ fn print_path(s: &ps, path: &ast::path) {\n         word(s.s, id);\n     }\n     if vec::len(path.node.types) > 0u {\n-        word(s.s, \"[\");\n+        word(s.s, \"<\");\n         commasep(s, inconsistent, path.node.types, print_type);\n-        word(s.s, \"]\");\n+        word(s.s, \">\");\n     }\n }\n "}]}