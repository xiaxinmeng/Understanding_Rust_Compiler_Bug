{"sha": "0491a231777735ba050c208ce621df93f863bf7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0OTFhMjMxNzc3NzM1YmEwNTBjMjA4Y2U2MjFkZjkzZjg2M2JmN2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-08T20:13:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-08T20:13:45Z"}, "message": "Auto merge of #37192 - cristicbz:rust-rc-into-raw, r=brson\n\nAdd `{into,from}_raw` to Rc and Arc\n\nThese methods convert to and from a `*const T` for `Rc` and `Arc` similar to the way they work on `Box`. The only slight complication is that `from_raw` needs to offset the pointer back to find the beginning of the `RcBox`/`ArcInner`.\n\nI felt this is a fairly small addition, filling in a gap (when compared to `Box`) so it wouldn't need an RFC. The motivation is primarily for FFI.\n\n(I'll create an issue and update a PR with the issue number if reviewers agree with the change in principle **Edit: done #37197**)\n\n~~Edit: This was initially `{into,from}_raw` but concerns were raised about the possible footgun if mixed with the methods of the same name of `Box`.~~\n\nEdit: This was went from `{into,from}_raw` to `{into,from}_inner_raw` then back to `{into,from}_raw` during review.", "tree": {"sha": "6727b82d88cd92b18b3d0e3dd39a1221310e482f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6727b82d88cd92b18b3d0e3dd39a1221310e482f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0491a231777735ba050c208ce621df93f863bf7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0491a231777735ba050c208ce621df93f863bf7c", "html_url": "https://github.com/rust-lang/rust/commit/0491a231777735ba050c208ce621df93f863bf7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0491a231777735ba050c208ce621df93f863bf7c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38a959a543dfc70a67e64f7d369ed6c9e12fc806", "url": "https://api.github.com/repos/rust-lang/rust/commits/38a959a543dfc70a67e64f7d369ed6c9e12fc806", "html_url": "https://github.com/rust-lang/rust/commit/38a959a543dfc70a67e64f7d369ed6c9e12fc806"}, {"sha": "651cf58f2e906fa6d333013891adca5074440bea", "url": "https://api.github.com/repos/rust-lang/rust/commits/651cf58f2e906fa6d333013891adca5074440bea", "html_url": "https://github.com/rust-lang/rust/commit/651cf58f2e906fa6d333013891adca5074440bea"}], "stats": {"total": 190, "additions": 190, "deletions": 0}, "files": [{"sha": "85dd2e9a4a5d4b1e749e1237022bc8c13df8909c", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0491a231777735ba050c208ce621df93f863bf7c/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0491a231777735ba050c208ce621df93f863bf7c/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=0491a231777735ba050c208ce621df93f863bf7c", "patch": "@@ -274,6 +274,68 @@ impl<T> Arc<T> {\n             Ok(elem)\n         }\n     }\n+\n+    /// Consumes the `Arc`, returning the wrapped pointer.\n+    ///\n+    /// To avoid a memory leak the pointer must be converted back to an `Arc` using\n+    /// [`Arc::from_raw`][from_raw].\n+    ///\n+    /// [from_raw]: struct.Arc.html#method.from_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_raw)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(10);\n+    /// let x_ptr = Arc::into_raw(x);\n+    /// assert_eq!(unsafe { *x_ptr }, 10);\n+    /// ```\n+    #[unstable(feature = \"rc_raw\", issue = \"37197\")]\n+    pub fn into_raw(this: Self) -> *mut T {\n+        let ptr = unsafe { &mut (**this.ptr).data as *mut _ };\n+        mem::forget(this);\n+        ptr\n+    }\n+\n+    /// Constructs an `Arc` from a raw pointer.\n+    ///\n+    /// The raw pointer must have been previously returned by a call to a\n+    /// [`Arc::into_raw`][into_raw].\n+    ///\n+    /// This function is unsafe because improper use may lead to memory problems. For example, a\n+    /// double-free may occur if the function is called twice on the same raw pointer.\n+    ///\n+    /// [into_raw]: struct.Arc.html#method.into_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_raw)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(10);\n+    /// let x_ptr = Arc::into_raw(x);\n+    ///\n+    /// unsafe {\n+    ///     // Convert back to an `Arc` to prevent leak.\n+    ///     let x = Arc::from_raw(x_ptr);\n+    ///     assert_eq!(*x, 10);\n+    ///\n+    ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory unsafe.\n+    /// }\n+    ///\n+    /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n+    /// ```\n+    #[unstable(feature = \"rc_raw\", issue = \"37197\")]\n+    pub unsafe fn from_raw(ptr: *mut T) -> Self {\n+        // To find the corresponding pointer to the `ArcInner` we need to subtract the offset of the\n+        // `data` field from the pointer.\n+        Arc { ptr: Shared::new((ptr as *mut u8).offset(-offset_of!(ArcInner<T>, data)) as *mut _) }\n+    }\n }\n \n impl<T: ?Sized> Arc<T> {\n@@ -1183,6 +1245,23 @@ mod tests {\n         assert_eq!(Arc::try_unwrap(x), Ok(5));\n     }\n \n+    #[test]\n+    fn into_from_raw() {\n+        let x = Arc::new(box \"hello\");\n+        let y = x.clone();\n+\n+        let x_ptr = Arc::into_raw(x);\n+        drop(y);\n+        unsafe {\n+            assert_eq!(**x_ptr, \"hello\");\n+\n+            let x = Arc::from_raw(x_ptr);\n+            assert_eq!(**x, \"hello\");\n+\n+            assert_eq!(Arc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+        }\n+    }\n+\n     #[test]\n     fn test_cowarc_clone_make_mut() {\n         let mut cow0 = Arc::new(75);"}, {"sha": "0d450184ed8773fc10339485ef53d11a638e35eb", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0491a231777735ba050c208ce621df93f863bf7c/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0491a231777735ba050c208ce621df93f863bf7c/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=0491a231777735ba050c208ce621df93f863bf7c", "patch": "@@ -99,6 +99,10 @@\n #[macro_use]\n extern crate std;\n \n+// Module with internal macros used by other modules (needs to be included before other modules).\n+#[macro_use]\n+mod macros;\n+\n // Heaps provided for low-level allocation strategies\n \n pub mod heap;"}, {"sha": "7da91c87e967e5beff35a4e4795985115934cb24", "filename": "src/liballoc/macros.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0491a231777735ba050c208ce621df93f863bf7c/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0491a231777735ba050c208ce621df93f863bf7c/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=0491a231777735ba050c208ce621df93f863bf7c", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Private macro to get the offset of a struct field in bytes from the address of the struct.\n+macro_rules! offset_of {\n+    ($container:path, $field:ident) => {{\n+        // Make sure the field actually exists. This line ensures that a compile-time error is\n+        // generated if $field is accessed through a Deref impl.\n+        let $container { $field : _, .. };\n+\n+        // Create an (invalid) instance of the container and calculate the offset to its\n+        // field. Using a null pointer might be UB if `&(*(0 as *const T)).field` is interpreted to\n+        // be nullptr deref.\n+        let invalid: $container = ::core::mem::uninitialized();\n+        let offset = &invalid.$field as *const _ as usize - &invalid as *const _ as usize;\n+\n+        // Do not run destructors on the made up invalid instance.\n+        ::core::mem::forget(invalid);\n+        offset as isize\n+    }};\n+}"}, {"sha": "8d863d7d9e917ba6656141f13dcab74dbda32551", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0491a231777735ba050c208ce621df93f863bf7c/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0491a231777735ba050c208ce621df93f863bf7c/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=0491a231777735ba050c208ce621df93f863bf7c", "patch": "@@ -364,6 +364,68 @@ impl<T> Rc<T> {\n     pub fn would_unwrap(this: &Self) -> bool {\n         Rc::strong_count(&this) == 1\n     }\n+\n+    /// Consumes the `Rc`, returning the wrapped pointer.\n+    ///\n+    /// To avoid a memory leak the pointer must be converted back to an `Rc` using\n+    /// [`Rc::from_raw`][from_raw].\n+    ///\n+    /// [from_raw]: struct.Rc.html#method.from_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_raw)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let x = Rc::new(10);\n+    /// let x_ptr = Rc::into_raw(x);\n+    /// assert_eq!(unsafe { *x_ptr }, 10);\n+    /// ```\n+    #[unstable(feature = \"rc_raw\", issue = \"37197\")]\n+    pub fn into_raw(this: Self) -> *mut T {\n+        let ptr = unsafe { &mut (**this.ptr).value as *mut _ };\n+        mem::forget(this);\n+        ptr\n+    }\n+\n+    /// Constructs an `Rc` from a raw pointer.\n+    ///\n+    /// The raw pointer must have been previously returned by a call to a\n+    /// [`Rc::into_raw`][into_raw].\n+    ///\n+    /// This function is unsafe because improper use may lead to memory problems. For example, a\n+    /// double-free may occur if the function is called twice on the same raw pointer.\n+    ///\n+    /// [into_raw]: struct.Rc.html#method.into_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_raw)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let x = Rc::new(10);\n+    /// let x_ptr = Rc::into_raw(x);\n+    ///\n+    /// unsafe {\n+    ///     // Convert back to an `Rc` to prevent leak.\n+    ///     let x = Rc::from_raw(x_ptr);\n+    ///     assert_eq!(*x, 10);\n+    ///\n+    ///     // Further calls to `Rc::from_raw(x_ptr)` would be memory unsafe.\n+    /// }\n+    ///\n+    /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n+    /// ```\n+    #[unstable(feature = \"rc_raw\", issue = \"37197\")]\n+    pub unsafe fn from_raw(ptr: *mut T) -> Self {\n+        // To find the corresponding pointer to the `RcBox` we need to subtract the offset of the\n+        // `value` field from the pointer.\n+        Rc { ptr: Shared::new((ptr as *mut u8).offset(-offset_of!(RcBox<T>, value)) as *mut _) }\n+    }\n }\n \n impl Rc<str> {\n@@ -1287,6 +1349,23 @@ mod tests {\n         assert_eq!(Rc::try_unwrap(x), Ok(5));\n     }\n \n+    #[test]\n+    fn into_from_raw() {\n+        let x = Rc::new(box \"hello\");\n+        let y = x.clone();\n+\n+        let x_ptr = Rc::into_raw(x);\n+        drop(y);\n+        unsafe {\n+            assert_eq!(**x_ptr, \"hello\");\n+\n+            let x = Rc::from_raw(x_ptr);\n+            assert_eq!(**x, \"hello\");\n+\n+            assert_eq!(Rc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+        }\n+    }\n+\n     #[test]\n     fn get_mut() {\n         let mut x = Rc::new(3);"}]}