{"sha": "263fdfeea868dd086da3585ee6fe7d23993e66f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2M2ZkZmVlYTg2OGRkMDg2ZGEzNTg1ZWU2ZmU3ZDIzOTkzZTY2Zjg=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2015-04-04T03:45:43Z"}, "committer": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2015-04-04T04:38:51Z"}, "message": "Cleanup and modernize some things in libcore::iter", "tree": {"sha": "adaf1bdc691fea7ef58682bce831b9a6022789cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adaf1bdc691fea7ef58682bce831b9a6022789cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/263fdfeea868dd086da3585ee6fe7d23993e66f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/263fdfeea868dd086da3585ee6fe7d23993e66f8", "html_url": "https://github.com/rust-lang/rust/commit/263fdfeea868dd086da3585ee6fe7d23993e66f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/263fdfeea868dd086da3585ee6fe7d23993e66f8/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f207ecbe021e2a81fbff4ea1904b955a156aa340", "url": "https://api.github.com/repos/rust-lang/rust/commits/f207ecbe021e2a81fbff4ea1904b955a156aa340", "html_url": "https://github.com/rust-lang/rust/commit/f207ecbe021e2a81fbff4ea1904b955a156aa340"}], "stats": {"total": 152, "additions": 62, "deletions": 90}, "files": [{"sha": "b83c2dea0d2f0e3a6b666e92e6b9339842d92914", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 62, "deletions": 90, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/263fdfeea868dd086da3585ee6fe7d23993e66f8/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263fdfeea868dd086da3585ee6fe7d23993e66f8/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=263fdfeea868dd086da3585ee6fe7d23993e66f8", "patch": "@@ -608,7 +608,11 @@ pub trait Iterator {\n     fn all<F>(&mut self, mut f: F) -> bool where\n         Self: Sized, F: FnMut(Self::Item) -> bool\n     {\n-        for x in self.by_ref() { if !f(x) { return false; } }\n+        for x in self.by_ref() {\n+            if !f(x) {\n+                return false;\n+            }\n+        }\n         true\n     }\n \n@@ -633,7 +637,11 @@ pub trait Iterator {\n         Self: Sized,\n         F: FnMut(Self::Item) -> bool\n     {\n-        for x in self.by_ref() { if f(x) { return true; } }\n+        for x in self.by_ref() {\n+            if f(x) {\n+                return true;\n+            }\n+        }\n         false\n     }\n \n@@ -1562,13 +1570,11 @@ impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n \n     #[inline]\n     fn next(&mut self) -> Option<(A::Item, B::Item)> {\n-        match self.a.next() {\n-            None => None,\n-            Some(x) => match self.b.next() {\n-                None => None,\n-                Some(y) => Some((x, y))\n-            }\n-        }\n+        self.a.next().and_then(|x| {\n+            self.b.next().and_then(|y| {\n+                Some((x, y))\n+            })\n+        })\n     }\n \n     #[inline]\n@@ -1626,13 +1632,11 @@ impl<A, B> RandomAccessIterator for Zip<A, B> where\n \n     #[inline]\n     fn idx(&mut self, index: usize) -> Option<(A::Item, B::Item)> {\n-        match self.a.idx(index) {\n-            None => None,\n-            Some(x) => match self.b.idx(index) {\n-                None => None,\n-                Some(y) => Some((x, y))\n-            }\n-        }\n+        self.a.idx(index).and_then(|x| {\n+            self.b.idx(index).and_then(|y| {\n+                Some((x, y))\n+            })\n+        })\n     }\n }\n \n@@ -1748,9 +1752,8 @@ impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         for x in self.iter.by_ref() {\n-            match (self.f)(x) {\n-                Some(y) => return Some(y),\n-                None => ()\n+            if let Some(y) = (self.f)(x) {\n+                return Some(y);\n             }\n         }\n         None\n@@ -1770,9 +1773,8 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n         for x in self.iter.by_ref().rev() {\n-            match (self.f)(x) {\n-                Some(y) => return Some(y),\n-                None => ()\n+            if let Some(y) = (self.f)(x) {\n+                return Some(y);\n             }\n         }\n         None\n@@ -1794,14 +1796,11 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n \n     #[inline]\n     fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        match self.iter.next() {\n-            Some(a) => {\n-                let ret = Some((self.count, a));\n-                self.count += 1;\n-                ret\n-            }\n-            _ => None\n-        }\n+        self.iter.next().map(|a| {\n+            let ret = (self.count, a);\n+            self.count += 1;\n+            ret\n+        })\n     }\n \n     #[inline]\n@@ -1816,13 +1815,10 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        match self.iter.next_back() {\n-            Some(a) => {\n-                let len = self.iter.len();\n-                Some((self.count + len, a))\n-            }\n-            _ => None\n-        }\n+        self.iter.next_back().map(|a| {\n+            let len = self.iter.len();\n+            (self.count + len, a)\n+        })\n     }\n }\n \n@@ -1835,10 +1831,7 @@ impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n \n     #[inline]\n     fn idx(&mut self, index: usize) -> Option<(usize, <I as Iterator>::Item)> {\n-        match self.iter.idx(index) {\n-            Some(a) => Some((self.count + index, a)),\n-            _ => None,\n-        }\n+        self.iter.idx(index).map(|a| (self.count + index, a))\n     }\n }\n \n@@ -1865,19 +1858,18 @@ impl<I: Iterator> Iterator for Peekable<I> {\n \n     #[inline]\n     fn next(&mut self) -> Option<I::Item> {\n-        if self.peeked.is_some() { self.peeked.take() }\n-        else { self.iter.next() }\n+        match self.peeked {\n+            Some(_) => self.peeked.take(),\n+            None => self.iter.next(),\n+        }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lo, hi) = self.iter.size_hint();\n         if self.peeked.is_some() {\n             let lo = lo.saturating_add(1);\n-            let hi = match hi {\n-                Some(x) => x.checked_add(1),\n-                None => None\n-            };\n+            let hi = hi.and_then(|x| x.checked_add(1));\n             (lo, hi)\n         } else {\n             (lo, hi)\n@@ -1966,17 +1958,14 @@ impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n         if self.flag {\n             None\n         } else {\n-            match self.iter.next() {\n-                Some(x) => {\n-                    if (self.predicate)(&x) {\n-                        Some(x)\n-                    } else {\n-                        self.flag = true;\n-                        None\n-                    }\n+            self.iter.next().and_then(|x| {\n+                if (self.predicate)(&x) {\n+                    Some(x)\n+                } else {\n+                    self.flag = true;\n+                    None\n                 }\n-                None => None\n-            }\n+            })\n         }\n     }\n \n@@ -2030,11 +2019,7 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n         let (lower, upper) = self.iter.size_hint();\n \n         let lower = lower.saturating_sub(self.n);\n-\n-        let upper = match upper {\n-            Some(x) => Some(x.saturating_sub(self.n)),\n-            None => None\n-        };\n+        let upper = upper.map(|x| x.saturating_sub(self.n));\n \n         (lower, upper)\n     }\n@@ -2316,9 +2301,8 @@ pub struct Inspect<I, F> {\n impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) {\n     #[inline]\n     fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n-        match elt {\n-            Some(ref a) => (self.f)(a),\n-            None => ()\n+        if let Some(ref a) = elt {\n+            (self.f)(a);\n         }\n \n         elt\n@@ -2619,17 +2603,14 @@ impl<A: Step + One + Clone> Iterator for RangeInclusive<A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        match self.range.next() {\n-            Some(x) => Some(x),\n-            None => {\n-                if !self.done && self.range.start == self.range.end {\n-                    self.done = true;\n-                    Some(self.range.end.clone())\n-                } else {\n-                    None\n-                }\n+        self.range.next().or_else(|| {\n+            if !self.done && self.range.start == self.range.end {\n+                self.done = true;\n+                Some(self.range.end.clone())\n+            } else {\n+                None\n             }\n-        }\n+        })\n     }\n \n     #[inline]\n@@ -2639,10 +2620,7 @@ impl<A: Step + One + Clone> Iterator for RangeInclusive<A> {\n             (lo, hi)\n         } else {\n             let lo = lo.saturating_add(1);\n-            let hi = match hi {\n-                Some(x) => x.checked_add(1),\n-                None => None\n-            };\n+            let hi = hi.and_then(|x| x.checked_add(1));\n             (lo, hi)\n         }\n     }\n@@ -2805,10 +2783,9 @@ impl<A: Step + One + Clone> Iterator for ops::Range<A> {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if let Some(hint) = Step::steps_between(&self.start, &self.end, &A::one()) {\n-            (hint, Some(hint))\n-        } else {\n-            (0, None)\n+        match Step::steps_between(&self.start, &self.end, &A::one()) {\n+            Some(hint) => (hint, Some(hint)),\n+            None => (0, None)\n         }\n     }\n }\n@@ -2899,13 +2876,8 @@ pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n         let &mut (ref mut f, ref mut val, ref mut first) = st;\n         if *first {\n             *first = false;\n-        } else {\n-            match val.take() {\n-                Some(x) => {\n-                    *val = Some((*f)(x))\n-                }\n-                None => {}\n-            }\n+        } else if let Some(x) = val.take() {\n+            *val = Some((*f)(x))\n         }\n         val.clone()\n     }"}]}