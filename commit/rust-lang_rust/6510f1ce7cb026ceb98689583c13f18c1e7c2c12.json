{"sha": "6510f1ce7cb026ceb98689583c13f18c1e7c2c12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MTBmMWNlN2NiMDI2Y2ViOTg2ODk1ODNjMTNmMThjMWU3YzJjMTI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-12T15:20:07Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-12T19:30:35Z"}, "message": "Change module dereference syntax from . to ::\n\nThis will need to be a snapshot.", "tree": {"sha": "daee2983e121887082fbba929919d2a2dccef36c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daee2983e121887082fbba929919d2a2dccef36c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6510f1ce7cb026ceb98689583c13f18c1e7c2c12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6510f1ce7cb026ceb98689583c13f18c1e7c2c12", "html_url": "https://github.com/rust-lang/rust/commit/6510f1ce7cb026ceb98689583c13f18c1e7c2c12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd9b6dccb4cd45c8cfab8caebd82817c106db7b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd9b6dccb4cd45c8cfab8caebd82817c106db7b8", "html_url": "https://github.com/rust-lang/rust/commit/dd9b6dccb4cd45c8cfab8caebd82817c106db7b8"}], "stats": {"total": 152, "additions": 41, "deletions": 111}, "files": [{"sha": "5ae564178b12c6e709367550acb734e7f5bc074b", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=6510f1ce7cb026ceb98689583c13f18c1e7c2c12", "patch": "@@ -312,7 +312,7 @@ fn resolve_path(vec[ast.ident] path, vec[u8] data) -> resolve_result {\n     fn eq_item(vec[u8] data, str s) -> bool {\n         ret Str.eq(Str.unsafe_from_bytes(data), s);\n     }\n-    auto s = Str.connect(path, \".\");\n+    auto s = Str.connect(path, \"::\");\n     auto md = EBML.new_doc(data);\n     auto paths = EBML.get_doc(md, metadata.tag_paths);\n     auto eqer = bind eq_item(_, s);"}, {"sha": "adcdaa162798a00f0e3d2f92ace6e550470a48e4", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=6510f1ce7cb026ceb98689583c13f18c1e7c2c12", "patch": "@@ -634,7 +634,6 @@ fn next_token(reader rdr) -> token.token {\n \n     alt (c) {\n         // One-byte tokens.\n-        case (':') { rdr.bump(); ret token.COLON; }\n         case ('?') { rdr.bump(); ret token.QUES; }\n         case (';') { rdr.bump(); ret token.SEMI; }\n         case (',') { rdr.bump(); ret token.COMMA; }\n@@ -648,7 +647,16 @@ fn next_token(reader rdr) -> token.token {\n         case ('@') { rdr.bump(); ret token.AT; }\n         case ('#') { rdr.bump(); ret token.POUND; }\n         case ('~') { rdr.bump(); ret token.TILDE; }\n-\n+        case (':') {\n+            rdr.bump();\n+            if (rdr.curr() == ':') {\n+                rdr.bump();\n+                ret token.MOD_SEP;\n+            }\n+            else {\n+                ret token.COLON;\n+            };\n+        }\n \n         // Multi-byte tokens.\n         case ('=') {"}, {"sha": "a14bcf3a2634c78f7ed7b00c61afc22ccb253bcf", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 17, "deletions": 55, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=6510f1ce7cb026ceb98689583c13f18c1e7c2c12", "patch": "@@ -322,7 +322,7 @@ fn parse_constr_arg(parser p) -> @ast.constr_arg {\n \n fn parse_ty_constr(parser p) -> @ast.constr {\n     auto lo = p.get_lo_pos();\n-    auto path = parse_path(p, GREEDY);\n+    auto path = parse_path(p);\n     auto pf = parse_constr_arg;\n     auto args = parse_seq[@ast.constr_arg](token.LPAREN,\n                                          token.RPAREN,\n@@ -472,7 +472,7 @@ fn parse_ty(parser p) -> @ast.ty {\n         }\n \n         case (token.IDENT(_)) {\n-            auto path = parse_path(p, GREEDY);\n+            auto path = parse_path(p);\n             t = ast.ty_path(path, p.get_ann());\n             hi = path.span.hi;\n         }\n@@ -603,11 +603,6 @@ fn is_ident(token.token t) -> bool {\n     ret false;\n }\n \n-tag greed {\n-    GREEDY;\n-    MINIMAL;\n-}\n-\n fn parse_ty_args(parser p, uint hi) ->\n     util.common.spanned[vec[@ast.ty]] {\n \n@@ -623,33 +618,23 @@ fn parse_ty_args(parser p, uint hi) ->\n     ret spanned(hi, hi, v);\n }\n \n-fn parse_path(parser p, greed g) -> ast.path {\n+fn parse_path(parser p) -> ast.path {\n \n     auto lo = p.get_lo_pos();\n     auto hi = lo;\n \n     let vec[ast.ident] ids = vec();\n-    let bool more = true;\n-    while (more) {\n+    while (true) {\n         alt (p.peek()) {\n             case (token.IDENT(?i)) {\n                 hi = p.get_hi_pos();\n                 ids += vec(p.get_str(i));\n                 p.bump();\n-                if (p.peek() == token.DOT) {\n-                    if (g == GREEDY) {\n-                        p.bump();\n-                        assert (is_ident(p.peek()));\n-                    } else {\n-                        more = false;\n-                    }\n-                } else {\n-                    more = false;\n-                }\n-            }\n-            case (_) {\n-                more = false;\n+                if (p.peek() == token.MOD_SEP) {\n+                    p.bump();\n+                } else { break; }\n             }\n+            case (_) { break; }\n         }\n     }\n \n@@ -690,7 +675,7 @@ fn parse_bottom_expr(parser p) -> @ast.expr {\n     alt (p.peek()) {\n \n         case (token.IDENT(_)) {\n-            auto pth = parse_path(p, MINIMAL);\n+            auto pth = parse_path(p);\n             hi = pth.span.hi;\n             ex = ast.expr_path(pth, p.get_ann());\n         }\n@@ -804,7 +789,7 @@ fn parse_bottom_expr(parser p) -> @ast.expr {\n \n         case (token.POUND) {\n             p.bump();\n-            auto pth = parse_path(p, GREEDY);\n+            auto pth = parse_path(p);\n             auto pf = parse_expr;\n             auto es = parse_seq[@ast.expr](token.LPAREN,\n                                            token.RPAREN,\n@@ -980,31 +965,6 @@ fn expand_syntax_ext(parser p, ast.span sp,\n     }\n }\n \n-fn extend_expr_by_ident(parser p, uint lo, uint hi,\n-                               @ast.expr e, ast.ident i) -> @ast.expr {\n-    auto e_ = e.node;\n-    alt (e.node) {\n-        case (ast.expr_path(?pth, ?ann)) {\n-            if (Vec.len[@ast.ty](pth.node.types) == 0u) {\n-                auto idents_ = pth.node.idents;\n-                idents_ += vec(i);\n-                auto tys = parse_ty_args(p, hi);\n-                auto pth_ = spanned(pth.span.lo, tys.span.hi,\n-                                    rec(idents=idents_,\n-                                        types=tys.node));\n-                e_ = ast.expr_path(pth_, ann);\n-                ret @spanned(pth_.span.lo, pth_.span.hi, e_);\n-            } else {\n-                e_ = ast.expr_field(e, i, ann);\n-            }\n-        }\n-        case (_) {\n-            e_ = ast.expr_field(e, i, p.get_ann());\n-        }\n-    }\n-    ret @spanned(lo, hi, e_);\n-}\n-\n fn parse_self_method(parser p) -> @ast.expr {\n     auto sp = p.get_span();\n     let ast.ident f_name = parse_ident(p);\n@@ -1042,7 +1002,9 @@ fn parse_dot_or_call_expr(parser p) -> @ast.expr {\n                     case (token.IDENT(?i)) {\n                         hi = p.get_hi_pos();\n                         p.bump();\n-                        e = extend_expr_by_ident(p, lo, hi, e, p.get_str(i));\n+                        auto e_ = ast.expr_field(e, p.get_str(i),\n+                                                 p.get_ann());\n+                        e = @spanned(lo, hi, e_);\n                     }\n \n                     case (token.LPAREN) {\n@@ -1404,7 +1366,7 @@ fn parse_spawn_expr(parser p) -> @ast.expr {\n     expect(p, token.SPAWN);\n \n     // FIXME: Parse domain and name\n-\n+    // FIXME: why no full expr?\n     auto fn_expr = parse_bottom_expr(p);\n     auto pf = parse_expr;\n     auto es = parse_seq[@ast.expr](token.LPAREN,\n@@ -1509,7 +1471,7 @@ fn parse_pat(parser p) -> @ast.pat {\n             }\n         }\n         case (token.IDENT(_)) {\n-            auto tag_path = parse_path(p, GREEDY);\n+            auto tag_path = parse_path(p);\n             hi = tag_path.span.hi;\n \n             let vec[@ast.pat] args;\n@@ -2249,7 +2211,7 @@ fn parse_rest_import_name(parser p, ast.ident first,\n     auto lo = p.get_lo_pos();\n     let vec[ast.ident] identifiers = vec(first);\n     while (p.peek() != token.SEMI) {\n-        expect(p, token.DOT);\n+        expect(p, token.MOD_SEP);\n         auto i = parse_ident(p);\n         identifiers += vec(i);\n     }\n@@ -2377,7 +2339,7 @@ fn parse_crate_directive(parser p) -> ast.crate_directive\n     alt (p.peek()) {\n         case (token.AUTH) {\n             p.bump();\n-            auto n = parse_path(p, GREEDY);\n+            auto n = parse_path(p);\n             expect(p, token.EQ);\n             auto a = parse_auth(p);\n             auto hi = p.get_hi_pos();"}, {"sha": "43db0b16517256facc4d19279f4f5aac1b921a64", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=6510f1ce7cb026ceb98689583c13f18c1e7c2c12", "patch": "@@ -47,6 +47,7 @@ tag token {\n     COMMA;\n     SEMI;\n     COLON;\n+    MOD_SEP;\n     QUES;\n     RARROW;\n     SEND;\n@@ -218,6 +219,7 @@ fn to_str(lexer.reader r, token t) -> str {\n         case (COMMA) { ret \",\"; }\n         case (SEMI) { ret \";\"; }\n         case (COLON) { ret \":\"; }\n+        case (MOD_SEP) { ret \"::\"; }\n         case (QUES) { ret \"?\"; }\n         case (RARROW) { ret \"->\"; }\n         case (SEND) { ret \"<|\"; }"}, {"sha": "ee62864329c2d5acc75634d13b722ec5a0cdaa27", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=6510f1ce7cb026ceb98689583c13f18c1e7c2c12", "patch": "@@ -301,7 +301,7 @@ fn add_to_index(&EBML.writer ebml_w,\n                 &mutable vec[tup(str, uint)] index,\n                 &str name) {\n     auto full_path = path + vec(name);\n-    index += vec(tup(Str.connect(full_path, \".\"), ebml_w.writer.tell()));\n+    index += vec(tup(Str.connect(full_path, \"::\"), ebml_w.writer.tell()));\n }\n \n fn encode_native_module_item_paths(&EBML.writer ebml_w,"}, {"sha": "7b7d6369efed4b6eff29120c8f97edf7e63492f7", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 6, "deletions": 48, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=6510f1ce7cb026ceb98689583c13f18c1e7c2c12", "patch": "@@ -170,6 +170,7 @@ fn resolve_imports(&env e) {\n     }\n }\n \n+// FIXME this should use walk (will need to add walk_arm)\n fn resolve_names(&@env e, &ast.crate c) -> @ast.crate {\n     auto fld = @rec(fold_pat_tag = bind fold_pat_tag(e,_,_,_,_,_),\n                     fold_expr_path = bind fold_expr_path(e,_,_,_,_),\n@@ -277,54 +278,11 @@ fn resolve_import(&env e, &@ast.view_item it, &list[scope] sc) {\n     }\n }\n \n-// We received a path expression of the following form:\n-//\n-//     a.b.c.d\n-//\n-// Somewhere along this path there might be a split from a path-expr\n-// to a runtime field-expr. For example:\n-//\n-//     'a' could be the name of a variable in the local scope\n-//     and 'b.c.d' could be a field-sequence inside it.\n-//\n-// Or:\n-//\n-//     'a.b' could be a module path to a constant record, and 'c.d'\n-//     could be a field within it.\n-//\n-// Our job here is to figure out what the prefix of 'a.b.c.d' is that\n-// corresponds to a static binding-name (a module or slot, with no type info)\n-// and split that off as the 'primary' expr_path, with secondary expr_field\n-// expressions tacked on the end.\n-\n fn fold_expr_path(@env e, &list[scope] sc, &span sp, &ast.path p, &ann a)\n     -> @ast.expr {\n-    auto idents = p.node.idents;\n-    auto n_idents = Vec.len(idents);\n-    assert (n_idents != 0u);\n-\n-    auto dcur = lookup_in_scope_strict(*e, sc, sp, idents.(0), ns_value);\n-    auto i = 1u;\n-    while (i < n_idents) {\n-        if (!is_module(dcur)) { break; }\n-        dcur = lookup_in_mod_strict(*e, dcur, sp, idents.(i), ns_value,\n-                                    outside);\n-        i += 1u;\n-    }\n-    if (is_module(dcur)) {\n-        e.sess.span_err(sp, \"can't refer to a module as a first-class value\");\n-    }\n-\n-    p = rec(node=rec(idents=Vec.slice(idents, 0u, i) with p.node) with p);\n-    auto ex = @fold.respan(sp, ast.expr_path(p, a));\n-    e.def_map.insert(ast.ann_tag(a), dcur);\n-    // FIXME this duplicates the ann. Is that a problem? How will we deal with\n-    // splitting this into path and field exprs when we don't fold?\n-    while (i < n_idents) {\n-        ex = @fold.respan(sp, ast.expr_field(ex, idents.(i), a));\n-        i += 1u;\n-    }\n-    ret ex;\n+    auto df = lookup_path_strict(*e, sc, sp, p.node.idents, ns_value);\n+    e.def_map.insert(ast.ann_tag(a), df);\n+    ret @fold.respan(sp, ast.expr_path(p, a));\n }\n \n \n@@ -337,7 +295,7 @@ fn fold_pat_tag(@env e, &list[scope] sc, &span sp, &ast.path p,\n         }\n         case (_) {\n             e.sess.span_err(sp, \"not a tag variant: \" +\n-                            Str.connect(p.node.idents, \".\"));\n+                            Str.connect(p.node.idents, \"::\"));\n             fail;\n         }\n     }\n@@ -383,7 +341,7 @@ fn lookup_path_strict(&env e, &list[scope] sc, &span sp, vec[ident] idents,\n         i += 1u;\n     }\n     if (is_module(dcur)) {\n-        e.sess.span_err(sp, Str.connect(idents, \".\") +\n+        e.sess.span_err(sp, Str.connect(idents, \"::\") +\n                         \" is a module, not a \" + ns_name(ns));\n     }\n     ret dcur;"}, {"sha": "ecdf78cf54aeb35bc6d9ea65bb43800e8ea3a043", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6510f1ce7cb026ceb98689583c13f18c1e7c2c12", "patch": "@@ -5439,7 +5439,7 @@ fn load_if_immediate(&@block_ctxt cx, ValueRef v, &ty.t t) -> ValueRef {\n \n fn trans_log(int lvl, &@block_ctxt cx, &@ast.expr e) -> result {\n     auto lcx = cx.fcx.lcx;\n-    auto modname = Str.connect(lcx.module_path, \".\");\n+    auto modname = Str.connect(lcx.module_path, \"::\");\n     auto global;\n     if (lcx.ccx.module_data.contains_key(modname)) {\n         global = lcx.ccx.module_data.get(modname);"}, {"sha": "8c79c605b149bebdb72bb9557a0c740377ac2b64", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=6510f1ce7cb026ceb98689583c13f18c1e7c2c12", "patch": "@@ -484,7 +484,7 @@ fn cname(&ctxt cx, &t typ) -> Option.t[str] { ret cx.ts.others.(typ).cname; }\n // Stringification\n \n fn path_to_str(&ast.path pth) -> str {\n-    auto result = Str.connect(pth.node.idents,  \".\");\n+    auto result = Str.connect(pth.node.idents,  \"::\");\n     if (Vec.len[@ast.ty](pth.node.types) > 0u) {\n         auto f = pretty.pprust.ty_to_str;\n         result += \"[\";"}, {"sha": "071e076c073fff155884cbbb7b34aa8db229fbbc", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510f1ce7cb026ceb98689583c13f18c1e7c2c12/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=6510f1ce7cb026ceb98689583c13f18c1e7c2c12", "patch": "@@ -751,7 +751,7 @@ fn print_path(ps s, ast.path path) {\n     auto first = true;\n     for (str id in path.node.idents) {\n         if (first) {first = false;}\n-        else {wrd(s.s, \".\");}\n+        else {wrd(s.s, \"::\");}\n         wrd(s.s, id);\n     }\n     if (Vec.len[@ast.ty](path.node.types) > 0u) {\n@@ -856,7 +856,7 @@ fn print_view_item(ps s, @ast.view_item item) {\n             auto first = true;\n             for (str elt in ids) {\n                 if (first) {first = false;}\n-                else {wrd(s.s, \".\");}\n+                else {wrd(s.s, \":\");}\n                 wrd(s.s, elt);\n             }\n         }"}]}