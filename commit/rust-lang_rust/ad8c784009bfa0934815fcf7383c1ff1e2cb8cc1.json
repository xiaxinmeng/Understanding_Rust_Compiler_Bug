{"sha": "ad8c784009bfa0934815fcf7383c1ff1e2cb8cc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkOGM3ODQwMDliZmEwOTM0ODE1ZmNmNzM4M2MxZmYxZTJjYjhjYzE=", "commit": {"author": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-25T01:50:25Z"}, "committer": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-25T01:50:25Z"}, "message": "Return length from write_os_str_to_c_str", "tree": {"sha": "eb01b63ee73a0b773cfcd52e757eb988e0276e1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb01b63ee73a0b773cfcd52e757eb988e0276e1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad8c784009bfa0934815fcf7383c1ff1e2cb8cc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad8c784009bfa0934815fcf7383c1ff1e2cb8cc1", "html_url": "https://github.com/rust-lang/rust/commit/ad8c784009bfa0934815fcf7383c1ff1e2cb8cc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad8c784009bfa0934815fcf7383c1ff1e2cb8cc1/comments", "author": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e03b4133894614b37469cde63d4f4c28341ec81", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e03b4133894614b37469cde63d4f4c28341ec81", "html_url": "https://github.com/rust-lang/rust/commit/9e03b4133894614b37469cde63d4f4c28341ec81"}], "stats": {"total": 71, "additions": 33, "deletions": 38}, "files": [{"sha": "53facf89dce922b8d5907eda1f8930c78c4f7335", "filename": "src/helpers.rs", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ad8c784009bfa0934815fcf7383c1ff1e2cb8cc1/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8c784009bfa0934815fcf7383c1ff1e2cb8cc1/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=ad8c784009bfa0934815fcf7383c1ff1e2cb8cc1", "patch": "@@ -474,35 +474,42 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Helper function to write an OsStr as a null-terminated sequence of bytes, which is what\n-    /// the Unix APIs usually handle. This function returns `Ok(false)` without trying to write if\n-    /// `size` is not large enough to fit the contents of `os_string` plus a null terminator. It\n-    /// returns `Ok(true)` if the writing process was successful.\n+    /// the Unix APIs usually handle. This function returns `Ok((false, length))` without trying\n+    /// to write if `size` is not large enough to fit the contents of `os_string` plus a null\n+    /// terminator. It returns `Ok((true, length))` if the writing process was successful. The\n+    /// string length returned does not include the null terminator.\n     fn write_os_str_to_c_str(\n         &mut self,\n         os_str: &OsStr,\n         scalar: Scalar<Tag>,\n         size: u64,\n-    ) -> InterpResult<'tcx, bool> {\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n+        #[cfg(target_os = \"unix\")]\n+        fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n+            std::os::unix::ffi::OsStringExt::into_bytes(os_str)\n+        }\n+        #[cfg(not(target_os = \"unix\"))]\n+        fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n+            // On non-unix platforms the best we can do to transform bytes from/to OS strings is to do the\n+            // intermediate transformation into strings. Which invalidates non-utf8 paths that are actually\n+            // valid.\n+            os_str\n+                .to_str()\n+                .map(|s| s.as_bytes())\n+                .ok_or_else(|| err_unsup_format!(\"{:?} is not a valid utf-8 string\", os_str).into())\n+        }\n+\n         let bytes = os_str_to_bytes(os_str)?;\n         // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required null\n         // terminator to memory using the `ptr` pointer would cause an out-of-bounds access.\n-        if size <= bytes.len() as u64 {\n-            return Ok(false);\n+        let string_length = bytes.len() as u64;\n+        if size <= string_length {\n+            return Ok((false, string_length));\n         }\n         self.eval_context_mut()\n             .memory\n             .write_bytes(scalar, bytes.iter().copied().chain(iter::once(0u8)))?;\n-        Ok(true)\n-    }\n-\n-    /// Helper function to determine how long an OsStr would be as a C string, not including the\n-    /// null terminator.\n-    fn os_str_length_as_c_str(\n-        &mut self,\n-        os_str: &OsStr,\n-    ) -> InterpResult<'tcx, usize> {\n-        let bytes = os_str_to_bytes(os_str)?;\n-        Ok(bytes.len())\n+        Ok((true, string_length))\n     }\n \n     fn alloc_os_str_as_c_str(\n@@ -520,22 +527,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n }\n \n-#[cfg(target_os = \"unix\")]\n-fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n-    std::os::unix::ffi::OsStringExt::into_bytes(os_str)\n-}\n-\n-#[cfg(not(target_os = \"unix\"))]\n-fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n-    // On non-unix platforms the best we can do to transform bytes from/to OS strings is to do the\n-    // intermediate transformation into strings. Which invalidates non-utf8 paths that are actually\n-    // valid.\n-    os_str\n-        .to_str()\n-        .map(|s| s.as_bytes())\n-        .ok_or_else(|| err_unsup_format!(\"{:?} is not a valid utf-8 string\", os_str).into())\n-}\n-\n pub fn immty_from_int_checked<'tcx>(\n     int: impl Into<i128>,\n     layout: TyLayout<'tcx>,"}, {"sha": "3fd895576e534cc1b2a8a3a962dc5c0042ded5de", "filename": "src/shims/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8c784009bfa0934815fcf7383c1ff1e2cb8cc1/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8c784009bfa0934815fcf7383c1ff1e2cb8cc1/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=ad8c784009bfa0934815fcf7383c1ff1e2cb8cc1", "patch": "@@ -124,7 +124,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // If we cannot get the current directory, we return null\n         match env::current_dir() {\n             Ok(cwd) => {\n-                if this.write_os_str_to_c_str(&OsString::from(cwd), buf, size)? {\n+                if this.write_os_str_to_c_str(&OsString::from(cwd), buf, size)?.0 {\n                     return Ok(buf);\n                 }\n                 let erange = this.eval_libc(\"ERANGE\")?;"}, {"sha": "cbdaf9a65b7d0bddc06869e23f3f9d237ef78c49", "filename": "src/shims/fs.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad8c784009bfa0934815fcf7383c1ff1e2cb8cc1/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8c784009bfa0934815fcf7383c1ff1e2cb8cc1/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=ad8c784009bfa0934815fcf7383c1ff1e2cb8cc1", "patch": "@@ -906,7 +906,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let name_place = this.mplace_field(entry_place, 4)?;\n \n                 let file_name = dir_entry.file_name();\n-                let name_fits = this.write_os_str_to_c_str(&file_name, name_place.ptr, name_place.layout.size.bytes())?;\n+                let (name_fits, _) = this.write_os_str_to_c_str(\n+                    &file_name, name_place.ptr,\n+                    name_place.layout.size.bytes(),\n+                )?;\n                 if !name_fits {\n                     throw_unsup_format!(\"A directory entry had a name too large to fit in libc::dirent64\");\n                 }\n@@ -990,7 +993,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let name_place = this.mplace_field(entry_place, 5)?;\n \n                 let file_name = dir_entry.file_name();\n-                let name_fits = this.write_os_str_to_c_str(&file_name, name_place.ptr, name_place.layout.size.bytes())?;\n+                let (name_fits, file_name_len) = this.write_os_str_to_c_str(\n+                    &file_name, name_place.ptr,\n+                    name_place.layout.size.bytes(),\n+                )?;\n                 if !name_fits {\n                     throw_unsup_format!(\"A directory entry had a name too large to fit in libc::dirent\");\n                 }\n@@ -1008,8 +1014,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 #[cfg(not(unix))]\n                 let ino = 0;\n \n-                let file_name_len = this.os_str_length_as_c_str(&file_name)? as u128;\n-\n                 let file_type = this.file_type_to_d_type(dir_entry.file_type())? as u128;\n \n                 let imms = ["}]}