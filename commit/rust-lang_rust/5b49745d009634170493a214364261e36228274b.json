{"sha": "5b49745d009634170493a214364261e36228274b", "node_id": "C_kwDOAAsO6NoAKDViNDk3NDVkMDA5NjM0MTcwNDkzYTIxNDM2NDI2MWUzNjIyODI3NGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-20T15:50:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-20T15:50:31Z"}, "message": "Auto merge of #13269 - Veykril:repr, r=Veykril\n\nProperly set the enum variant body type from the repr attribute\n\nFollow up for https://github.com/rust-lang/rust-analyzer/pull/12966, fixes some type inference problems", "tree": {"sha": "20ef418d7c9626e20c58f154e6bece98e4e3fbcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20ef418d7c9626e20c58f154e6bece98e4e3fbcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b49745d009634170493a214364261e36228274b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b49745d009634170493a214364261e36228274b", "html_url": "https://github.com/rust-lang/rust/commit/5b49745d009634170493a214364261e36228274b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b49745d009634170493a214364261e36228274b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "817a6a860971e91e42c0a3624513f90516536dfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/817a6a860971e91e42c0a3624513f90516536dfb", "html_url": "https://github.com/rust-lang/rust/commit/817a6a860971e91e42c0a3624513f90516536dfb"}, {"sha": "9bf386f4c03571c58e6a38267f1008241ea723ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bf386f4c03571c58e6a38267f1008241ea723ef", "html_url": "https://github.com/rust-lang/rust/commit/9bf386f4c03571c58e6a38267f1008241ea723ef"}], "stats": {"total": 252, "additions": 182, "deletions": 70}, "files": [{"sha": "14f8629056faf371326ba16fee0aa8771ad83997", "filename": "crates/hir-def/src/adt.rs", "status": "modified", "additions": 71, "deletions": 11, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5b49745d009634170493a214364261e36228274b/crates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b49745d009634170493a214364261e36228274b/crates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fadt.rs?ref=5b49745d009634170493a214364261e36228274b", "patch": "@@ -1,6 +1,6 @@\n //! Defines hir-level representation of structs, enums and unions\n \n-use std::sync::Arc;\n+use std::{num::NonZeroU32, sync::Arc};\n \n use base_db::CrateId;\n use either::Either;\n@@ -14,6 +14,7 @@ use tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n \n use crate::{\n     body::{CfgExpander, LowerCtx},\n+    builtin_type::{BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     intern::Interned,\n     item_tree::{AttrOwner, Field, Fields, ItemTree, ModItem, RawVisibilityId},\n@@ -31,14 +32,15 @@ use cfg::CfgOptions;\n pub struct StructData {\n     pub name: Name,\n     pub variant_data: Arc<VariantData>,\n-    pub repr: Option<ReprKind>,\n+    pub repr: Option<ReprData>,\n     pub visibility: RawVisibility,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct EnumData {\n     pub name: Name,\n     pub variants: Arena<EnumVariantData>,\n+    pub repr: Option<ReprData>,\n     pub visibility: RawVisibility,\n }\n \n@@ -63,32 +65,80 @@ pub struct FieldData {\n     pub visibility: RawVisibility,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Copy, Debug, Clone, PartialEq, Eq)]\n pub enum ReprKind {\n-    Packed,\n-    Other,\n+    C,\n+    BuiltinInt { builtin: Either<BuiltinInt, BuiltinUint>, is_c: bool },\n+    Transparent,\n+    Default,\n+}\n+\n+#[derive(Copy, Debug, Clone, PartialEq, Eq)]\n+pub struct ReprData {\n+    pub kind: ReprKind,\n+    pub packed: bool,\n+    pub align: Option<NonZeroU32>,\n }\n \n fn repr_from_value(\n     db: &dyn DefDatabase,\n     krate: CrateId,\n     item_tree: &ItemTree,\n     of: AttrOwner,\n-) -> Option<ReprKind> {\n+) -> Option<ReprData> {\n     item_tree.attrs(db, krate, of).by_key(\"repr\").tt_values().find_map(parse_repr_tt)\n }\n \n-fn parse_repr_tt(tt: &Subtree) -> Option<ReprKind> {\n+fn parse_repr_tt(tt: &Subtree) -> Option<ReprData> {\n     match tt.delimiter {\n         Some(Delimiter { kind: DelimiterKind::Parenthesis, .. }) => {}\n         _ => return None,\n     }\n \n-    let mut it = tt.token_trees.iter();\n-    match it.next()? {\n-        TokenTree::Leaf(Leaf::Ident(ident)) if ident.text == \"packed\" => Some(ReprKind::Packed),\n-        _ => Some(ReprKind::Other),\n+    let mut data = ReprData { kind: ReprKind::Default, packed: false, align: None };\n+\n+    let mut tts = tt.token_trees.iter().peekable();\n+    while let Some(tt) = tts.next() {\n+        if let TokenTree::Leaf(Leaf::Ident(ident)) = tt {\n+            match &*ident.text {\n+                \"packed\" => {\n+                    data.packed = true;\n+                    if let Some(TokenTree::Subtree(_)) = tts.peek() {\n+                        tts.next();\n+                    }\n+                }\n+                \"align\" => {\n+                    if let Some(TokenTree::Subtree(tt)) = tts.peek() {\n+                        tts.next();\n+                        if let Some(TokenTree::Leaf(Leaf::Literal(lit))) = tt.token_trees.first() {\n+                            if let Ok(align) = lit.text.parse() {\n+                                data.align = Some(align);\n+                            }\n+                        }\n+                    }\n+                }\n+                \"C\" => {\n+                    if let ReprKind::BuiltinInt { is_c, .. } = &mut data.kind {\n+                        *is_c = true;\n+                    } else {\n+                        data.kind = ReprKind::C;\n+                    }\n+                }\n+                \"transparent\" => data.kind = ReprKind::Transparent,\n+                repr => {\n+                    let is_c = matches!(data.kind, ReprKind::C);\n+                    if let Some(builtin) = BuiltinInt::from_suffix(repr)\n+                        .map(Either::Left)\n+                        .or_else(|| BuiltinUint::from_suffix(repr).map(Either::Right))\n+                    {\n+                        data.kind = ReprKind::BuiltinInt { builtin, is_c };\n+                    }\n+                }\n+            }\n+        }\n     }\n+\n+    Some(data)\n }\n \n impl StructData {\n@@ -108,6 +158,7 @@ impl StructData {\n             visibility: item_tree[strukt.visibility].clone(),\n         })\n     }\n+\n     pub(crate) fn union_data_query(db: &dyn DefDatabase, id: UnionId) -> Arc<StructData> {\n         let loc = id.lookup(db);\n         let krate = loc.container.krate;\n@@ -133,6 +184,7 @@ impl EnumData {\n         let krate = loc.container.krate;\n         let item_tree = loc.id.item_tree(db);\n         let cfg_options = db.crate_graph()[krate].cfg_options.clone();\n+        let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n \n         let enum_ = &item_tree[loc.id.value];\n         let mut variants = Arena::new();\n@@ -158,6 +210,7 @@ impl EnumData {\n         Arc::new(EnumData {\n             name: enum_.name.clone(),\n             variants,\n+            repr,\n             visibility: item_tree[enum_.visibility].clone(),\n         })\n     }\n@@ -166,6 +219,13 @@ impl EnumData {\n         let (id, _) = self.variants.iter().find(|(_id, data)| &data.name == name)?;\n         Some(id)\n     }\n+\n+    pub fn variant_body_type(&self) -> Either<BuiltinInt, BuiltinUint> {\n+        match self.repr {\n+            Some(ReprData { kind: ReprKind::BuiltinInt { builtin, .. }, .. }) => builtin,\n+            _ => Either::Left(BuiltinInt::Isize),\n+        }\n+    }\n }\n \n impl HasChildSource<LocalEnumVariantId> for EnumId {"}, {"sha": "5c7aa72349f6e1c89be036ed2a539610926cc8c5", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b49745d009634170493a214364261e36228274b/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b49745d009634170493a214364261e36228274b/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=5b49745d009634170493a214364261e36228274b", "patch": "@@ -479,7 +479,6 @@ pub enum DefWithBodyId {\n \n impl_from!(FunctionId, ConstId, StaticId for DefWithBodyId);\n \n-// FIXME: Rename EnumVariantId to VariantId so that the macro above can be used\n impl From<EnumVariantId> for DefWithBodyId {\n     fn from(id: EnumVariantId) -> Self {\n         DefWithBodyId::VariantId(id)"}, {"sha": "2c0c6e0b8394fb14e8e819bc6fa6ea99eef71a1b", "filename": "crates/hir-ty/src/consteval.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5b49745d009634170493a214364261e36228274b/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b49745d009634170493a214364261e36228274b/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=5b49745d009634170493a214364261e36228274b", "patch": "@@ -153,7 +153,7 @@ fn is_valid(scalar: &Scalar, value: i128) -> bool {\n     }\n }\n \n-fn get_name(variant: EnumVariantId, ctx: &mut ConstEvalCtx<'_>) -> String {\n+fn get_name(ctx: &mut ConstEvalCtx<'_>, variant: EnumVariantId) -> String {\n     let loc = variant.parent.lookup(ctx.db.upcast());\n     let children = variant.parent.child_source(ctx.db.upcast());\n     let item_tree = loc.id.item_tree(ctx.db.upcast());\n@@ -167,20 +167,24 @@ pub fn eval_const(\n     expr_id: ExprId,\n     ctx: &mut ConstEvalCtx<'_>,\n ) -> Result<ComputedExpr, ConstEvalError> {\n+    let u128_to_i128 = |it: u128| -> Result<i128, ConstEvalError> {\n+        it.try_into().map_err(|_| ConstEvalError::NotSupported(\"u128 is too big\"))\n+    };\n+\n     let expr = &ctx.exprs[expr_id];\n     match expr {\n         Expr::Missing => match ctx.owner {\n+            // evaluate the implicit variant index of an enum variant without expression\n+            // FIXME: This should return the type of the enum representation\n             DefWithBodyId::VariantId(variant) => {\n                 let prev_idx: u32 = variant.local_id.into_raw().into();\n-                let prev_idx = prev_idx.checked_sub(1).map(|idx| Idx::from_raw(RawIdx::from(idx)));\n+                let prev_idx = prev_idx.checked_sub(1).map(RawIdx::from).map(Idx::from_raw);\n                 let value = match prev_idx {\n-                    Some(prev) => {\n-                        let prev_variant = EnumVariantId { local_id: prev, ..variant };\n+                    Some(local_id) => {\n+                        let prev_variant = EnumVariantId { local_id, parent: variant.parent };\n                         1 + match ctx.db.const_eval_variant(prev_variant)? {\n                             ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                            ComputedExpr::Literal(Literal::Uint(v, _)) => v\n-                                .try_into()\n-                                .map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?,\n+                            ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n                             _ => {\n                                 return Err(ConstEvalError::NotSupported(\n                                     \"Enum can't contain this kind of value\",\n@@ -206,9 +210,7 @@ pub fn eval_const(\n                             return Ok(ComputedExpr::Literal(Literal::Bool(!b)))\n                         }\n                         ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                        ComputedExpr::Literal(Literal::Uint(v, _)) => v\n-                            .try_into()\n-                            .map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?,\n+                        ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n                         _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n                     };\n                     let r = match ty.kind(Interner) {\n@@ -237,9 +239,7 @@ pub fn eval_const(\n                 hir_def::expr::UnaryOp::Neg => {\n                     let v = match ev {\n                         ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                        ComputedExpr::Literal(Literal::Uint(v, _)) => v\n-                            .try_into()\n-                            .map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?,\n+                        ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n                         _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n                     };\n                     Ok(ComputedExpr::Literal(Literal::Int(\n@@ -258,16 +258,12 @@ pub fn eval_const(\n             let op = op.ok_or(ConstEvalError::IncompleteExpr)?;\n             let v1 = match lhs {\n                 ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                ComputedExpr::Literal(Literal::Uint(v, _)) => {\n-                    v.try_into().map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?\n-                }\n+                ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n                 _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n             };\n             let v2 = match rhs {\n                 ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                ComputedExpr::Literal(Literal::Uint(v, _)) => {\n-                    v.try_into().map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?\n-                }\n+                ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n                 _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n             };\n             match op {\n@@ -380,7 +376,7 @@ pub fn eval_const(\n                 }\n                 ValueNs::EnumVariantId(id) => match ctx.db.const_eval_variant(id)? {\n                     ComputedExpr::Literal(lit) => {\n-                        Ok(ComputedExpr::Enum(get_name(id, ctx), id, lit))\n+                        Ok(ComputedExpr::Enum(get_name(ctx, id), id, lit))\n                     }\n                     _ => Err(ConstEvalError::NotSupported(\n                         \"Enums can't evalute to anything but numbers\",\n@@ -389,6 +385,7 @@ pub fn eval_const(\n                 _ => Err(ConstEvalError::NotSupported(\"path that are not const or local\")),\n             }\n         }\n+        // FIXME: Handle the cast target\n         &Expr::Cast { expr, .. } => match eval_const(expr, ctx)? {\n             ComputedExpr::Enum(_, _, lit) => Ok(ComputedExpr::Literal(lit)),\n             _ => Err(ConstEvalError::NotSupported(\"Can't cast these types\")),\n@@ -463,15 +460,15 @@ pub(crate) fn const_eval_recover(\n     Err(ConstEvalError::Loop)\n }\n \n-pub(crate) fn const_eval_recover_variant(\n+pub(crate) fn const_eval_variant_recover(\n     _: &dyn HirDatabase,\n     _: &[String],\n     _: &EnumVariantId,\n ) -> Result<ComputedExpr, ConstEvalError> {\n     Err(ConstEvalError::Loop)\n }\n \n-pub(crate) fn const_eval_query(\n+pub(crate) fn const_eval_variant_query(\n     db: &dyn HirDatabase,\n     const_id: ConstId,\n ) -> Result<ComputedExpr, ConstEvalError> {"}, {"sha": "72abcc2b4b602bdb1e13efe6d949ff7761340065", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5b49745d009634170493a214364261e36228274b/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b49745d009634170493a214364261e36228274b/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=5b49745d009634170493a214364261e36228274b", "patch": "@@ -7,8 +7,7 @@ use arrayvec::ArrayVec;\n use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n     db::DefDatabase, expr::ExprId, BlockId, ConstId, ConstParamId, DefWithBodyId, EnumVariantId,\n-    FunctionId, GenericDefId, ImplId, LifetimeParamId, LocalFieldId, Lookup, TypeOrConstParamId,\n-    VariantId,\n+    FunctionId, GenericDefId, ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n };\n use la_arena::ArenaMap;\n \n@@ -44,12 +43,12 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::lower::const_param_ty_query)]\n     fn const_param_ty(&self, def: ConstParamId) -> Ty;\n \n-    #[salsa::invoke(crate::consteval::const_eval_query)]\n+    #[salsa::invoke(crate::consteval::const_eval_variant_query)]\n     #[salsa::cycle(crate::consteval::const_eval_recover)]\n     fn const_eval(&self, def: ConstId) -> Result<ComputedExpr, ConstEvalError>;\n \n     #[salsa::invoke(crate::consteval::const_eval_query_variant)]\n-    #[salsa::cycle(crate::consteval::const_eval_recover_variant)]\n+    #[salsa::cycle(crate::consteval::const_eval_variant_recover)]\n     fn const_eval_variant(&self, def: EnumVariantId) -> Result<ComputedExpr, ConstEvalError>;\n \n     #[salsa::invoke(crate::lower::impl_trait_query)]\n@@ -194,11 +193,7 @@ fn infer_wait(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult>\n             db.const_data(it).name.clone().unwrap_or_else(Name::missing).to_string()\n         }\n         DefWithBodyId::VariantId(it) => {\n-            let up_db: &dyn DefDatabase = db.upcast();\n-            let loc = it.parent.lookup(up_db);\n-            let item_tree = loc.id.item_tree(up_db);\n-            let konst = &item_tree[loc.id.value];\n-            konst.name.to_string()\n+            db.enum_data(it.parent).variants[it.local_id].name.to_string()\n         }\n     });\n     db.infer_query(def)"}, {"sha": "daf1e2f0c6d3b1269fd6fc0a3fbce8de18a77b71", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5b49745d009634170493a214364261e36228274b/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b49745d009634170493a214364261e36228274b/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=5b49745d009634170493a214364261e36228274b", "patch": "@@ -19,6 +19,7 @@ use std::sync::Arc;\n use chalk_ir::{cast::Cast, ConstValue, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n use hir_def::{\n     body::Body,\n+    builtin_type::BuiltinType,\n     data::{ConstData, StaticData},\n     expr::{BindingAnnotation, ExprId, PatId},\n     lang_item::LangItemTarget,\n@@ -68,8 +69,10 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n         DefWithBodyId::FunctionId(f) => ctx.collect_fn(f),\n         DefWithBodyId::StaticId(s) => ctx.collect_static(&db.static_data(s)),\n         DefWithBodyId::VariantId(v) => {\n-            // FIXME: This should return the `repr(...)` type of the enum\n-            ctx.return_ty = TyBuilder::def_ty(db, v.parent.into()).fill_with_unknown().build()\n+            ctx.return_ty = TyBuilder::builtin(match db.enum_data(v.parent).variant_body_type() {\n+                Either::Left(builtin) => BuiltinType::Int(builtin),\n+                Either::Right(builtin) => BuiltinType::Uint(builtin),\n+            });\n         }\n     }\n "}, {"sha": "ebbc5410147c6b8d63e8b4df5623fba06db5b4d5", "filename": "crates/hir-ty/src/tests.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b49745d009634170493a214364261e36228274b/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b49745d009634170493a214364261e36228274b/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=5b49745d009634170493a214364261e36228274b", "patch": "@@ -461,6 +461,18 @@ fn visit_module(\n                     let body = db.body(def);\n                     visit_body(db, &body, cb);\n                 }\n+                ModuleDefId::AdtId(hir_def::AdtId::EnumId(it)) => {\n+                    db.enum_data(it)\n+                        .variants\n+                        .iter()\n+                        .map(|(id, _)| hir_def::EnumVariantId { parent: it, local_id: id })\n+                        .for_each(|it| {\n+                            let def = it.into();\n+                            cb(def);\n+                            let body = db.body(def);\n+                            visit_body(db, &body, cb);\n+                        });\n+                }\n                 ModuleDefId::TraitId(it) => {\n                     let trait_data = db.trait_data(it);\n                     for &(_, item) in trait_data.items.iter() {"}, {"sha": "1757327b929d02309975659e7070546d485d1c9e", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 56, "deletions": 21, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5b49745d009634170493a214364261e36228274b/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b49745d009634170493a214364261e36228274b/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=5b49745d009634170493a214364261e36228274b", "patch": "@@ -1693,16 +1693,16 @@ fn infer_type_param() {\n fn infer_const() {\n     check_infer(\n         r#\"\n-        struct Foo;\n-        impl Foo { const ASSOC_CONST: u32 = 0; }\n-        const GLOBAL_CONST: u32 = 101;\n-        fn test() {\n-            const LOCAL_CONST: u32 = 99;\n-            let x = LOCAL_CONST;\n-            let z = GLOBAL_CONST;\n-            let id = Foo::ASSOC_CONST;\n-        }\n-        \"#,\n+struct Foo;\n+impl Foo { const ASSOC_CONST: u32 = 0; }\n+const GLOBAL_CONST: u32 = 101;\n+fn test() {\n+    const LOCAL_CONST: u32 = 99;\n+    let x = LOCAL_CONST;\n+    let z = GLOBAL_CONST;\n+    let id = Foo::ASSOC_CONST;\n+}\n+\"#,\n         expect![[r#\"\n             48..49 '0': u32\n             79..82 '101': u32\n@@ -1722,17 +1722,17 @@ fn infer_const() {\n fn infer_static() {\n     check_infer(\n         r#\"\n-        static GLOBAL_STATIC: u32 = 101;\n-        static mut GLOBAL_STATIC_MUT: u32 = 101;\n-        fn test() {\n-            static LOCAL_STATIC: u32 = 99;\n-            static mut LOCAL_STATIC_MUT: u32 = 99;\n-            let x = LOCAL_STATIC;\n-            let y = LOCAL_STATIC_MUT;\n-            let z = GLOBAL_STATIC;\n-            let w = GLOBAL_STATIC_MUT;\n-        }\n-        \"#,\n+static GLOBAL_STATIC: u32 = 101;\n+static mut GLOBAL_STATIC_MUT: u32 = 101;\n+fn test() {\n+    static LOCAL_STATIC: u32 = 99;\n+    static mut LOCAL_STATIC_MUT: u32 = 99;\n+    let x = LOCAL_STATIC;\n+    let y = LOCAL_STATIC_MUT;\n+    let z = GLOBAL_STATIC;\n+    let w = GLOBAL_STATIC_MUT;\n+}\n+\"#,\n         expect![[r#\"\n             28..31 '101': u32\n             69..72 '101': u32\n@@ -1751,6 +1751,41 @@ fn infer_static() {\n     );\n }\n \n+#[test]\n+fn infer_enum_variant() {\n+    check_infer(\n+        r#\"\n+enum Foo {\n+    A = 15,\n+    B = Foo::A as isize + 1\n+}\n+\"#,\n+        expect![[r#\"\n+            19..21 '15': isize\n+            31..37 'Foo::A': Foo\n+            31..46 'Foo::A as isize': isize\n+            31..50 'Foo::A...ze + 1': isize\n+            49..50 '1': isize\n+        \"#]],\n+    );\n+    check_infer(\n+        r#\"\n+#[repr(u32)]\n+enum Foo {\n+    A = 15,\n+    B = Foo::A as u32 + 1\n+}\n+\"#,\n+        expect![[r#\"\n+            32..34 '15': u32\n+            44..50 'Foo::A': Foo\n+            44..57 'Foo::A as u32': u32\n+            44..61 'Foo::A...32 + 1': u32\n+            60..61 '1': u32\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn shadowing_primitive() {\n     check_types("}, {"sha": "1c48d2ff0817c6716cc88f42525fe645013d1a92", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5b49745d009634170493a214364261e36228274b/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b49745d009634170493a214364261e36228274b/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=5b49745d009634170493a214364261e36228274b", "patch": "@@ -39,7 +39,7 @@ use arrayvec::ArrayVec;\n use base_db::{CrateDisplayName, CrateId, CrateOrigin, Edition, FileId, ProcMacroKind};\n use either::Either;\n use hir_def::{\n-    adt::{ReprKind, VariantData},\n+    adt::{ReprData, VariantData},\n     body::{BodyDiagnostic, SyntheticSyntax},\n     expr::{BindingAnnotation, LabelId, Pat, PatId},\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n@@ -874,7 +874,7 @@ impl Struct {\n         Type::from_def(db, self.id)\n     }\n \n-    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprKind> {\n+    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprData> {\n         db.struct_data(self.id).repr.clone()\n     }\n \n@@ -953,6 +953,17 @@ impl Enum {\n         Type::from_def(db, self.id)\n     }\n \n+    /// The type of the enum variant bodies.\n+    pub fn variant_body_ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::new_for_crate(\n+            self.id.lookup(db.upcast()).container.krate(),\n+            TyBuilder::builtin(match db.enum_data(self.id).variant_body_type() {\n+                Either::Left(builtin) => hir_def::builtin_type::BuiltinType::Int(builtin),\n+                Either::Right(builtin) => hir_def::builtin_type::BuiltinType::Uint(builtin),\n+            }),\n+        )\n+    }\n+\n     pub fn is_data_carrying(self, db: &dyn HirDatabase) -> bool {\n         self.variants(db).iter().any(|v| !matches!(v.kind(db), StructKind::Unit))\n     }\n@@ -1176,7 +1187,7 @@ impl DefWithBody {\n             DefWithBody::Function(it) => it.ret_type(db),\n             DefWithBody::Static(it) => it.ty(db),\n             DefWithBody::Const(it) => it.ty(db),\n-            DefWithBody::Variant(it) => it.parent.ty(db),\n+            DefWithBody::Variant(it) => it.parent.variant_body_ty(db),\n         }\n     }\n \n@@ -2964,7 +2975,7 @@ impl Type {\n \n         let adt = adt_id.into();\n         match adt {\n-            Adt::Struct(s) => matches!(s.repr(db), Some(ReprKind::Packed)),\n+            Adt::Struct(s) => matches!(s.repr(db), Some(ReprData { packed: true, .. })),\n             _ => false,\n         }\n     }"}]}