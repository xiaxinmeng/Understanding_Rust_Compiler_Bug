{"sha": "88f8fbcce07f74b26e308ae5b2156d75ec03e35e", "node_id": "C_kwDOAAsO6NoAKDg4ZjhmYmNjZTA3Zjc0YjI2ZTMwOGFlNWIyMTU2ZDc1ZWMwM2UzNWU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-31T23:19:16Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-04-04T07:01:28Z"}, "message": "A new matcher representation for use in `parse_tt`.\n\n`parse_tt` currently traverses a `&[TokenTree]` to do matching. But this\nis a bad representation for the traversal.\n- `TokenTree` is nested, and there's a bunch of expensive and fiddly\n  state required to handle entering and exiting nested submatchers.\n- There are three positions (sequence separators, sequence Kleene ops,\n  and end of the matcher) that are represented by an index that exceeds\n  the end of the `&[TokenTree]`, which is clumsy and error-prone.\n\nThis commit introduces a new representation called `MatcherLoc` that is\ndesigned specifically for matching. It fixes all the above problems,\nmaking the code much easier to read. A `&[TokenTree]` is converted to a\n`&[MatcherLoc]` before matching begins. Despite the cost of the\nconversion, it's still a net performance win, because various pieces of\ntraversal state are computed once up-front, rather than having to be\nrecomputed repeatedly during the macro matching.\n\nSome improvements worth noting.\n- `parse_tt_inner` is *much* easier to read. No more having to compare\n  `idx` against `len` and read comments to understand what the result\n  means.\n- The handling of `Delimited` in `parse_tt_inner` is now trivial.\n- The three end-of-sequence cases in `parse_tt_inner` are now handled in\n  three separate match arms, and the control flow is much simpler.\n- `nameize` is no longer recursive.\n- There were two places that issued \"missing fragment specifier\" errors:\n  one in `parse_tt_inner()`, and one in `nameize()`. Presumably the\n  latter was never executed. There's now a single place issuing these\n  errors, in `compute_locs()`.\n- The number of heap allocations done for a `check full` build of\n  `async-std-1.10.0` (an extreme example of heavy macro use) drops from\n  11.8M to 2.6M, and most of these occur outside of macro matching.\n- The size of `MatcherPos` drops from 64 bytes to 16 bytes. Small enough\n  that it no longer needs boxing, which partly accounts for the\n  reduction in allocations.\n- The rest of the drop in allocations is due to the removal of\n  `MatcherKind`, because we no longer need to record anything for the\n  parent matcher when entering a submatcher.\n- Overall it reduces code size by 45 lines.", "tree": {"sha": "b5575dceb1815c1414879dba6ac34d6327908a9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5575dceb1815c1414879dba6ac34d6327908a9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88f8fbcce07f74b26e308ae5b2156d75ec03e35e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88f8fbcce07f74b26e308ae5b2156d75ec03e35e", "html_url": "https://github.com/rust-lang/rust/commit/88f8fbcce07f74b26e308ae5b2156d75ec03e35e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88f8fbcce07f74b26e308ae5b2156d75ec03e35e/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ad4eb207b369017f5140918b5e4b0d3650b46b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad4eb207b369017f5140918b5e4b0d3650b46b0", "html_url": "https://github.com/rust-lang/rust/commit/2ad4eb207b369017f5140918b5e4b0d3650b46b0"}], "stats": {"total": 623, "additions": 289, "deletions": 334}, "files": [{"sha": "cd5bb93de65bd9166dfa3df8677e5c56f27a103e", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88f8fbcce07f74b26e308ae5b2156d75ec03e35e/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f8fbcce07f74b26e308ae5b2156d75ec03e35e/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=88f8fbcce07f74b26e308ae5b2156d75ec03e35e", "patch": "@@ -1,7 +1,5 @@\n #![feature(associated_type_bounds)]\n #![feature(associated_type_defaults)]\n-#![feature(box_patterns)]\n-#![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(if_let_guard)]"}, {"sha": "c1bf8f8816ac8716bb7e7d063af54055ea19999c", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 289, "deletions": 332, "changes": 621, "blob_url": "https://github.com/rust-lang/rust/blob/88f8fbcce07f74b26e308ae5b2156d75ec03e35e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f8fbcce07f74b26e308ae5b2156d75ec03e35e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=88f8fbcce07f74b26e308ae5b2156d75ec03e35e", "patch": "@@ -17,7 +17,7 @@\n //! A \"matcher position\" (a.k.a. \"position\" or \"mp\") is a dot in the middle of a matcher, usually\n //! written as a `\u00b7`. For example `\u00b7 a $( a )* a b` is one, as is `a $( \u00b7 a )* a b`.\n //!\n-//! The parser walks through the input a character at a time, maintaining a list\n+//! The parser walks through the input a token at a time, maintaining a list\n //! of threads consistent with the current position in the input string: `cur_mps`.\n //!\n //! As it processes them, it fills up `eof_mps` with threads that would be valid if\n@@ -73,12 +73,13 @@\n crate use NamedMatch::*;\n crate use ParseResult::*;\n \n-use crate::mbe::{self, SequenceRepetition, TokenTree};\n+use crate::mbe::{KleeneOp, TokenTree};\n \n-use rustc_ast::token::{self, DocComment, Nonterminal, Token, TokenKind};\n+use rustc_ast::token::{self, DocComment, Nonterminal, NonterminalKind, Token};\n use rustc_parse::parser::{NtOrTt, Parser};\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::MacroRulesNormalizedIdent;\n+use rustc_span::Span;\n \n use smallvec::{smallvec, SmallVec};\n \n@@ -88,153 +89,88 @@ use rustc_span::symbol::Ident;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n-// One element is enough to cover 95-99% of vectors for most benchmarks. Also,\n-// vectors longer than one frequently have many elements, not just two or\n-// three.\n+// One element is enough to cover 95-99% of vectors for most benchmarks. Also, vectors longer than\n+// one frequently have many elements, not just two or three.\n type NamedMatchVec = SmallVec<[NamedMatch; 1]>;\n \n // This type is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(NamedMatchVec, 48);\n \n-#[derive(Clone)]\n-enum MatcherKind<'tt> {\n-    TopLevel,\n-    Delimited(Box<DelimitedSubmatcher<'tt>>),\n-    Sequence(Box<SequenceSubmatcher<'tt>>),\n-}\n-\n-#[derive(Clone)]\n-struct DelimitedSubmatcher<'tt> {\n-    parent: Parent<'tt>,\n-}\n-\n-#[derive(Clone)]\n-struct SequenceSubmatcher<'tt> {\n-    parent: Parent<'tt>,\n-    seq: &'tt SequenceRepetition,\n-}\n-\n-/// Data used to ascend from a submatcher back to its parent matcher. A subset of the fields from\n-/// `MathcherPos`.\n-#[derive(Clone)]\n-struct Parent<'tt> {\n-    tts: &'tt [TokenTree],\n-    idx: usize,\n-    kind: MatcherKind<'tt>,\n+/// A unit within a matcher that a `MatcherPos` can refer to. Similar to (and derived from)\n+/// `mbe::TokenTree`, but designed specifically for fast and easy traversal during matching.\n+/// Notable differences to `mbe::TokenTree`:\n+/// - It is non-recursive, i.e. there is no nesting.\n+/// - The end pieces of each sequence (the separator, if present, and the Kleene op) are\n+///   represented explicitly, as is the very end of the matcher.\n+///\n+/// This means a matcher can be represented by `&[MatcherLoc]`, and traversal mostly involves\n+/// simply incrementing the current matcher position index by one.\n+enum MatcherLoc<'tt> {\n+    Token {\n+        token: &'tt Token,\n+    },\n+    Delimited,\n+    Sequence {\n+        op: KleeneOp,\n+        num_metavar_decls: usize,\n+        idx_first_after: usize,\n+        next_metavar: usize,\n+        seq_depth: usize,\n+    },\n+    SequenceKleeneOpNoSep {\n+        op: KleeneOp,\n+        idx_first: usize,\n+    },\n+    SequenceSep {\n+        separator: &'tt Token,\n+    },\n+    SequenceKleeneOpAfterSep {\n+        idx_first: usize,\n+    },\n+    MetaVarDecl {\n+        span: Span,\n+        bind: Ident,\n+        kind: NonterminalKind,\n+        next_metavar: usize,\n+        seq_depth: usize,\n+    },\n+    Eof,\n }\n \n-/// A single matcher position, which could be within the top-level matcher, a submatcher, a\n-/// subsubmatcher, etc. For example:\n-/// ```text\n-/// macro_rules! m { $id:ident ( $($e:expr),* ) } => { ... }\n-///                              <---------->     second submatcher; one tt, one metavar\n-///                            <-------------->   first submatcher; three tts, zero metavars\n-///                  <--------------------------> top-level matcher; two tts, one metavar\n-/// ```\n-struct MatcherPos<'tt> {\n-    /// The tokens that make up the current matcher. When we are within a `Sequence` or `Delimited`\n-    /// submatcher, this is just the contents of that submatcher.\n-    tts: &'tt [TokenTree],\n-\n-    /// The \"dot\" position within the current submatcher, i.e. the index into `tts`. Can go one or\n-    /// two positions past the final elements in `tts` when dealing with sequences, see\n-    /// `parse_tt_inner` for details.\n+/// A single matcher position, representing the state of matching.\n+struct MatcherPos {\n+    /// The index into `TtParser::locs`, which represents the \"dot\".\n     idx: usize,\n \n-    /// This vector ends up with one element per metavar in the *top-level* matcher, even when this\n-    /// `MatcherPos` is for a submatcher. Each element records token trees matched against the\n-    /// relevant metavar by the black box parser. The element will be a `MatchedSeq` if the\n-    /// corresponding metavar is within a sequence.\n+    /// The matches made against metavar decls so far. On a successful match, this vector ends up\n+    /// with one element per metavar decl in the matcher. Each element records token trees matched\n+    /// against the relevant metavar by the black box parser. An element will be a `MatchedSeq` if\n+    /// the corresponding metavar decl is within a sequence.\n     matches: Lrc<NamedMatchVec>,\n-\n-    /// The number of sequences this mp is within.\n-    seq_depth: usize,\n-\n-    /// The position in `matches` of the next metavar to be matched against the source token\n-    /// stream. Should not be used if there are no metavars.\n-    match_cur: usize,\n-\n-    /// What kind of matcher we are in. For submatchers, this contains enough information to\n-    /// reconstitute a `MatcherPos` within the parent once we ascend out of the submatcher.\n-    kind: MatcherKind<'tt>,\n }\n \n // This type is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MatcherPos<'_>, 64);\n-\n-impl<'tt> MatcherPos<'tt> {\n-    fn top_level(matcher: &'tt [TokenTree], empty_matches: Lrc<NamedMatchVec>) -> Self {\n-        MatcherPos {\n-            tts: matcher,\n-            idx: 0,\n-            matches: empty_matches,\n-            seq_depth: 0,\n-            match_cur: 0,\n-            kind: MatcherKind::TopLevel,\n-        }\n-    }\n+rustc_data_structures::static_assert_size!(MatcherPos, 16);\n \n-    fn empty_sequence(\n-        parent_mp: &MatcherPos<'tt>,\n-        seq: &'tt SequenceRepetition,\n-        empty_matches: Lrc<NamedMatchVec>,\n-    ) -> Self {\n-        let mut mp = MatcherPos {\n-            tts: parent_mp.tts,\n-            idx: parent_mp.idx + 1,\n-            matches: parent_mp.matches.clone(), // a cheap clone\n-            seq_depth: parent_mp.seq_depth,\n-            match_cur: parent_mp.match_cur + seq.num_captures,\n-            kind: parent_mp.kind.clone(), // an expensive clone\n-        };\n-        for idx in parent_mp.match_cur..parent_mp.match_cur + seq.num_captures {\n-            mp.push_match(idx, MatchedSeq(empty_matches.clone()));\n-        }\n-        mp\n-    }\n-\n-    fn sequence(\n-        parent_mp: Box<MatcherPos<'tt>>,\n-        seq: &'tt SequenceRepetition,\n-        empty_matches: Lrc<NamedMatchVec>,\n-    ) -> Self {\n-        let seq_kind = box SequenceSubmatcher {\n-            parent: Parent { tts: parent_mp.tts, idx: parent_mp.idx, kind: parent_mp.kind },\n-            seq,\n-        };\n-        let mut mp = MatcherPos {\n-            tts: &seq.tts,\n-            idx: 0,\n-            matches: parent_mp.matches,\n-            seq_depth: parent_mp.seq_depth,\n-            match_cur: parent_mp.match_cur,\n-            kind: MatcherKind::Sequence(seq_kind),\n-        };\n-        // Start with an empty vec for each metavar within the sequence. Note that `mp.seq_depth`\n-        // must have the parent's depth at this point for these `push_match` calls to work.\n-        for idx in mp.match_cur..mp.match_cur + seq.num_captures {\n-            mp.push_match(idx, MatchedSeq(empty_matches.clone()));\n-        }\n-        mp.seq_depth += 1;\n-        mp\n-    }\n-\n-    /// Adds `m` as a named match for the `idx`-th metavar.\n-    fn push_match(&mut self, idx: usize, m: NamedMatch) {\n+impl MatcherPos {\n+    /// Adds `m` as a named match for the `metavar_idx`-th metavar. There are only two call sites,\n+    /// and both are hot enough to be always worth inlining.\n+    #[inline(always)]\n+    fn push_match(&mut self, metavar_idx: usize, seq_depth: usize, m: NamedMatch) {\n         let matches = Lrc::make_mut(&mut self.matches);\n-        match self.seq_depth {\n+        match seq_depth {\n             0 => {\n                 // We are not within a sequence. Just append `m`.\n-                assert_eq!(idx, matches.len());\n+                assert_eq!(metavar_idx, matches.len());\n                 matches.push(m);\n             }\n             _ => {\n                 // We are within a sequence. Find the final `MatchedSeq` at the appropriate depth\n                 // and append `m` to its vector.\n-                let mut curr = &mut matches[idx];\n-                for _ in 0..self.seq_depth - 1 {\n+                let mut curr = &mut matches[metavar_idx];\n+                for _ in 0..seq_depth - 1 {\n                     match curr {\n                         MatchedSeq(seq) => {\n                             let seq = Lrc::make_mut(seq);\n@@ -255,9 +191,9 @@ impl<'tt> MatcherPos<'tt> {\n     }\n }\n \n-enum EofMatcherPositions<'tt> {\n+enum EofMatcherPositions {\n     None,\n-    One(Box<MatcherPos<'tt>>),\n+    One(MatcherPos),\n     Multiple,\n }\n \n@@ -349,63 +285,6 @@ crate enum NamedMatch {\n     MatchedNonterminal(Lrc<Nonterminal>),\n }\n \n-fn nameize<I: Iterator<Item = NamedMatch>>(\n-    sess: &ParseSess,\n-    matcher: &[TokenTree],\n-    mut res: I,\n-) -> NamedParseResult {\n-    // Recursively descend into each type of matcher (e.g., sequences, delimited, metavars) and make\n-    // sure that each metavar has _exactly one_ binding. If a metavar does not have exactly one\n-    // binding, then there is an error. If it does, then we insert the binding into the\n-    // `NamedParseResult`.\n-    fn n_rec<I: Iterator<Item = NamedMatch>>(\n-        sess: &ParseSess,\n-        tt: &TokenTree,\n-        res: &mut I,\n-        ret_val: &mut FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n-    ) -> Result<(), (rustc_span::Span, String)> {\n-        match *tt {\n-            TokenTree::Sequence(_, ref seq) => {\n-                for next_m in &seq.tts {\n-                    n_rec(sess, next_m, res.by_ref(), ret_val)?\n-                }\n-            }\n-            TokenTree::Delimited(_, ref delim) => {\n-                for next_m in delim.inner_tts() {\n-                    n_rec(sess, next_m, res.by_ref(), ret_val)?;\n-                }\n-            }\n-            TokenTree::MetaVarDecl(span, _, None) => {\n-                if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n-                    return Err((span, \"missing fragment specifier\".to_string()));\n-                }\n-            }\n-            TokenTree::MetaVarDecl(sp, bind_name, _) => match ret_val\n-                .entry(MacroRulesNormalizedIdent::new(bind_name))\n-            {\n-                Vacant(spot) => {\n-                    spot.insert(res.next().unwrap());\n-                }\n-                Occupied(..) => return Err((sp, format!(\"duplicated bind name: {}\", bind_name))),\n-            },\n-            TokenTree::Token(..) => (),\n-            TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),\n-        }\n-\n-        Ok(())\n-    }\n-\n-    let mut ret_val = FxHashMap::default();\n-    for tt in matcher {\n-        match n_rec(sess, tt, res.by_ref(), &mut ret_val) {\n-            Ok(_) => {}\n-            Err((sp, msg)) => return Error(sp, msg),\n-        }\n-    }\n-\n-    Success(ret_val)\n-}\n-\n /// Performs a token equality check, ignoring syntax context (that is, an unhygienic comparison)\n fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n     if let (Some((ident1, is_raw1)), Some((ident2, is_raw2))) = (t1.ident(), t2.ident()) {\n@@ -417,21 +296,24 @@ fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n     }\n }\n \n-// Note: the position vectors could be created and dropped within `parse_tt`, but to avoid excess\n+// Note: the vectors could be created and dropped within `parse_tt`, but to avoid excess\n // allocations we have a single vector fo each kind that is cleared and reused repeatedly.\n pub struct TtParser<'tt> {\n     macro_name: Ident,\n \n+    /// The matcher of the current rule.\n+    locs: Vec<MatcherLoc<'tt>>,\n+\n     /// The set of current mps to be processed. This should be empty by the end of a successful\n     /// execution of `parse_tt_inner`.\n-    cur_mps: Vec<Box<MatcherPos<'tt>>>,\n+    cur_mps: Vec<MatcherPos>,\n \n     /// The set of newly generated mps. These are used to replenish `cur_mps` in the function\n     /// `parse_tt`.\n-    next_mps: Vec<Box<MatcherPos<'tt>>>,\n+    next_mps: Vec<MatcherPos>,\n \n     /// The set of mps that are waiting for the black-box parser.\n-    bb_mps: Vec<Box<MatcherPos<'tt>>>,\n+    bb_mps: Vec<MatcherPos>,\n \n     /// Pre-allocate an empty match array, so it can be cloned cheaply for macros with many rules\n     /// that have no metavars.\n@@ -442,13 +324,107 @@ impl<'tt> TtParser<'tt> {\n     pub(super) fn new(macro_name: Ident) -> TtParser<'tt> {\n         TtParser {\n             macro_name,\n+            locs: vec![],\n             cur_mps: vec![],\n             next_mps: vec![],\n             bb_mps: vec![],\n             empty_matches: Lrc::new(smallvec![]),\n         }\n     }\n \n+    /// Convert a `&[TokenTree]` to a `&[MatcherLoc]`. Note: this conversion happens every time the\n+    /// macro is called, which may be many times if there are many call sites or if it is\n+    /// recursive. This conversion is fairly cheap and the representation is sufficiently better\n+    /// for matching than `&[TokenTree]` that it's a clear performance win even with the overhead.\n+    /// But it might be possible to move the conversion outwards so it only occurs once per macro.\n+    fn compute_locs(\n+        &mut self,\n+        sess: &ParseSess,\n+        matcher: &'tt [TokenTree],\n+    ) -> Result<usize, (Span, String)> {\n+        fn inner<'tt>(\n+            sess: &ParseSess,\n+            tts: &'tt [TokenTree],\n+            locs: &mut Vec<MatcherLoc<'tt>>,\n+            next_metavar: &mut usize,\n+            seq_depth: usize,\n+        ) -> Result<(), (Span, String)> {\n+            for tt in tts {\n+                match tt {\n+                    TokenTree::Token(token) => {\n+                        locs.push(MatcherLoc::Token { token });\n+                    }\n+                    TokenTree::Delimited(_, delimited) => {\n+                        locs.push(MatcherLoc::Delimited);\n+                        inner(sess, &delimited.all_tts, locs, next_metavar, seq_depth)?;\n+                    }\n+                    TokenTree::Sequence(_, seq) => {\n+                        // We can't determine `idx_first_after` and construct the final\n+                        // `MatcherLoc::Sequence` until after `inner()` is called and the sequence\n+                        // end pieces are processed. So we push a dummy value (`Eof` is cheapest to\n+                        // construct) now, and overwrite it with the proper value below.\n+                        let dummy = MatcherLoc::Eof;\n+                        locs.push(dummy);\n+\n+                        let next_metavar_orig = *next_metavar;\n+                        let op = seq.kleene.op;\n+                        let idx_first = locs.len();\n+                        let idx_seq = idx_first - 1;\n+                        inner(sess, &seq.tts, locs, next_metavar, seq_depth + 1)?;\n+\n+                        if let Some(separator) = &seq.separator {\n+                            locs.push(MatcherLoc::SequenceSep { separator });\n+                            locs.push(MatcherLoc::SequenceKleeneOpAfterSep { idx_first });\n+                        } else {\n+                            locs.push(MatcherLoc::SequenceKleeneOpNoSep { op, idx_first });\n+                        }\n+\n+                        // Overwrite the dummy value pushed above with the proper value.\n+                        locs[idx_seq] = MatcherLoc::Sequence {\n+                            op,\n+                            num_metavar_decls: seq.num_captures,\n+                            idx_first_after: locs.len(),\n+                            next_metavar: next_metavar_orig,\n+                            seq_depth,\n+                        };\n+                    }\n+                    &TokenTree::MetaVarDecl(span, bind, kind) => {\n+                        if let Some(kind) = kind {\n+                            locs.push(MatcherLoc::MetaVarDecl {\n+                                span,\n+                                bind,\n+                                kind,\n+                                next_metavar: *next_metavar,\n+                                seq_depth,\n+                            });\n+                            *next_metavar += 1;\n+                        } else if sess\n+                            .missing_fragment_specifiers\n+                            .borrow_mut()\n+                            .remove(&span)\n+                            .is_some()\n+                        {\n+                            // E.g. `$e` instead of `$e:expr`.\n+                            return Err((span, \"missing fragment specifier\".to_string()));\n+                        }\n+                    }\n+                    TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),\n+                }\n+            }\n+            Ok(())\n+        }\n+\n+        self.locs.clear();\n+        let mut next_metavar = 0;\n+        inner(sess, matcher, &mut self.locs, &mut next_metavar, /* seq_depth */ 0)?;\n+\n+        // A final entry is needed for eof.\n+        self.locs.push(MatcherLoc::Eof);\n+\n+        // This is the number of metavar decls.\n+        Ok(next_metavar)\n+    }\n+\n     /// Process the matcher positions of `cur_mps` until it is empty. In the process, this will\n     /// produce more mps in `next_mps` and `bb_mps`.\n     ///\n@@ -458,160 +434,121 @@ impl<'tt> TtParser<'tt> {\n     /// track of through the mps generated.\n     fn parse_tt_inner(\n         &mut self,\n-        sess: &ParseSess,\n-        matcher: &[TokenTree],\n+        num_metavar_decls: usize,\n         token: &Token,\n     ) -> Option<NamedParseResult> {\n         // Matcher positions that would be valid if the macro invocation was over now. Only\n         // modified if `token == Eof`.\n         let mut eof_mps = EofMatcherPositions::None;\n \n         while let Some(mut mp) = self.cur_mps.pop() {\n-            // Get the current position of the \"dot\" (`idx`) in `mp` and the number of token\n-            // trees in the matcher (`len`).\n-            let idx = mp.idx;\n-            let len = mp.tts.len();\n-\n-            if idx < len {\n-                // We are in the middle of a matcher. Compare the matcher's current tt against\n-                // `token`.\n-                match &mp.tts[idx] {\n-                    TokenTree::Sequence(_sp, seq) => {\n-                        let op = seq.kleene.op;\n-                        if op == mbe::KleeneOp::ZeroOrMore || op == mbe::KleeneOp::ZeroOrOne {\n-                            // Allow for the possibility of zero matches of this sequence.\n-                            self.cur_mps.push(box MatcherPos::empty_sequence(\n-                                &*mp,\n-                                &seq,\n-                                self.empty_matches.clone(),\n-                            ));\n-                        }\n-\n-                        // Allow for the possibility of one or more matches of this sequence.\n-                        self.cur_mps.push(box MatcherPos::sequence(\n-                            mp,\n-                            &seq,\n-                            self.empty_matches.clone(),\n-                        ));\n+            match &self.locs[mp.idx] {\n+                &MatcherLoc::Sequence {\n+                    op,\n+                    num_metavar_decls,\n+                    idx_first_after,\n+                    next_metavar,\n+                    seq_depth,\n+                } => {\n+                    // Install an empty vec for each metavar within the sequence.\n+                    for metavar_idx in next_metavar..next_metavar + num_metavar_decls {\n+                        mp.push_match(\n+                            metavar_idx,\n+                            seq_depth,\n+                            MatchedSeq(self.empty_matches.clone()),\n+                        );\n                     }\n \n-                    &TokenTree::MetaVarDecl(span, _, None) => {\n-                        // E.g. `$e` instead of `$e:expr`.\n-                        if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n-                            return Some(Error(span, \"missing fragment specifier\".to_string()));\n-                        }\n+                    if op == KleeneOp::ZeroOrMore || op == KleeneOp::ZeroOrOne {\n+                        // Try zero matches of this sequence, by skipping over it.\n+                        self.cur_mps.push(MatcherPos {\n+                            idx: idx_first_after,\n+                            matches: mp.matches.clone(), // a cheap clone\n+                        });\n                     }\n \n-                    &TokenTree::MetaVarDecl(_, _, Some(kind)) => {\n-                        // Built-in nonterminals never start with these tokens, so we can eliminate\n-                        // them from consideration.\n-                        //\n-                        // We use the span of the metavariable declaration to determine any\n-                        // edition-specific matching behavior for non-terminals.\n-                        if Parser::nonterminal_may_begin_with(kind, token) {\n-                            self.bb_mps.push(mp);\n-                        }\n+                    // Try one or more matches of this sequence, by entering it.\n+                    mp.idx += 1;\n+                    self.cur_mps.push(mp);\n+                }\n+                MatcherLoc::MetaVarDecl { kind, .. } => {\n+                    // Built-in nonterminals never start with these tokens, so we can eliminate\n+                    // them from consideration. We use the span of the metavariable declaration\n+                    // to determine any edition-specific matching behavior for non-terminals.\n+                    if Parser::nonterminal_may_begin_with(*kind, token) {\n+                        self.bb_mps.push(mp);\n                     }\n-\n-                    TokenTree::Delimited(_, delimited) => {\n-                        // To descend into a delimited submatcher, we update `mp` appropriately,\n-                        // including enough information to re-ascend afterwards, and push it onto\n-                        // `cur_mps`. Later, when we reach the closing delimiter, we will recover\n-                        // the parent matcher position to ascend. Note that we use `all_tts` to\n-                        // include the open and close delimiter tokens.\n-                        let kind = MatcherKind::Delimited(box DelimitedSubmatcher {\n-                            parent: Parent { tts: mp.tts, idx: mp.idx, kind: mp.kind },\n-                        });\n-                        mp.tts = &delimited.all_tts;\n-                        mp.idx = 0;\n-                        mp.kind = kind;\n+                }\n+                MatcherLoc::Delimited => {\n+                    // Entering the delimeter is trivial.\n+                    mp.idx += 1;\n+                    self.cur_mps.push(mp);\n+                }\n+                MatcherLoc::Token { token: t } => {\n+                    // If it's a doc comment, we just ignore it and move on to the next tt in the\n+                    // matcher. This is a bug, but #95267 showed that existing programs rely on\n+                    // this behaviour, and changing it would require some care and a transition\n+                    // period.\n+                    //\n+                    // If the token matches, we can just advance the parser.\n+                    //\n+                    // Otherwise, this match has failed, there is nothing to do, and hopefully\n+                    // another mp in `cur_mps` will match.\n+                    if matches!(t, Token { kind: DocComment(..), .. }) {\n+                        mp.idx += 1;\n                         self.cur_mps.push(mp);\n+                    } else if token_name_eq(&t, token) {\n+                        mp.idx += 1;\n+                        self.next_mps.push(mp);\n                     }\n-\n-                    TokenTree::Token(t) => {\n-                        // If it's a doc comment, we just ignore it and move on to the next tt in\n-                        // the matcher. This is a bug, but #95267 showed that existing programs\n-                        // rely on this behaviour, and changing it would require some care and a\n-                        // transition period.\n-                        //\n-                        // If the token matches, we can just advance the parser.\n-                        //\n-                        // Otherwise, this match has failed, there is nothing to do, and hopefully\n-                        // another mp in `cur_mps` will match.\n-                        if matches!(t, Token { kind: DocComment(..), .. }) {\n-                            mp.idx += 1;\n-                            self.cur_mps.push(mp);\n-                        } else if token_name_eq(&t, token) {\n-                            if let TokenKind::CloseDelim(_) = token.kind {\n-                                // Ascend out of the delimited submatcher.\n-                                debug_assert_eq!(idx, len - 1);\n-                                match mp.kind {\n-                                    MatcherKind::Delimited(submatcher) => {\n-                                        mp.tts = submatcher.parent.tts;\n-                                        mp.idx = submatcher.parent.idx;\n-                                        mp.kind = submatcher.parent.kind;\n-                                    }\n-                                    _ => unreachable!(),\n-                                }\n-                            }\n-                            mp.idx += 1;\n-                            self.next_mps.push(mp);\n-                        }\n-                    }\n-\n-                    // These cannot appear in a matcher.\n-                    TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),\n                 }\n-            } else if let MatcherKind::Sequence(box SequenceSubmatcher { parent, seq }) = &mp.kind {\n-                // We are past the end of a sequence.\n-                // - If it has no separator, we must be only one past the end.\n-                // - If it has a separator, we may be one past the end, in which case we must\n-                //   look for a separator. Or we may be two past the end, in which case we have\n-                //   already dealt with the separator.\n-                debug_assert!(idx == len || idx == len + 1 && seq.separator.is_some());\n-\n-                if idx == len {\n-                    // Sequence matching may have finished: move the \"dot\" past the sequence in\n-                    // `parent`. This applies whether a separator is used or not. If sequence\n-                    // matching hasn't finished, this `new_mp` will fail quietly when it is\n+                &MatcherLoc::SequenceKleeneOpNoSep { op, idx_first } => {\n+                    // We are past the end of a sequence with no separator. Try ending the\n+                    // sequence. If that's not possible, `ending_mp` will fail quietly when it is\n                     // processed next time around the loop.\n-                    let new_mp = box MatcherPos {\n-                        tts: parent.tts,\n-                        idx: parent.idx + 1,\n+                    let ending_mp = MatcherPos {\n+                        idx: mp.idx + 1,             // +1 skips the Kleene op\n                         matches: mp.matches.clone(), // a cheap clone\n-                        seq_depth: mp.seq_depth - 1,\n-                        match_cur: mp.match_cur,\n-                        kind: parent.kind.clone(), // an expensive clone\n                     };\n-                    self.cur_mps.push(new_mp);\n+                    self.cur_mps.push(ending_mp);\n+\n+                    if op != KleeneOp::ZeroOrOne {\n+                        // Try another repetition.\n+                        mp.idx = idx_first;\n+                        self.cur_mps.push(mp);\n+                    }\n                 }\n+                MatcherLoc::SequenceSep { separator } => {\n+                    // We are past the end of a sequence with a separator but we haven't seen the\n+                    // separator yet. Try ending the sequence. If that's not possible, `ending_mp`\n+                    // will fail quietly when it is processed next time around the loop.\n+                    let ending_mp = MatcherPos {\n+                        idx: mp.idx + 2,             // +2 skips the separator and the Kleene op\n+                        matches: mp.matches.clone(), // a cheap clone\n+                    };\n+                    self.cur_mps.push(ending_mp);\n \n-                if seq.separator.is_some() && idx == len {\n-                    // Look for the separator.\n-                    if seq.separator.as_ref().map_or(false, |sep| token_name_eq(token, sep)) {\n-                        // The matcher has a separator, and it matches the current token. We can\n-                        // advance past the separator token.\n+                    if token_name_eq(token, separator) {\n+                        // The separator matches the current token. Advance past it.\n                         mp.idx += 1;\n                         self.next_mps.push(mp);\n                     }\n-                } else if seq.kleene.op != mbe::KleeneOp::ZeroOrOne {\n-                    // We don't need to look for a separator: either this sequence doesn't have\n-                    // one, or it does and we've already handled it. Also, we are allowed to have\n-                    // more than one repetition. Move the \"dot\" back to the beginning of the\n-                    // matcher and try to match again.\n-                    mp.match_cur -= seq.num_captures;\n-                    mp.idx = 0;\n+                }\n+                &MatcherLoc::SequenceKleeneOpAfterSep { idx_first } => {\n+                    // We are past the sequence separator. This can't be a `?` Kleene op, because\n+                    // they don't permit separators. Try another repetition.\n+                    mp.idx = idx_first;\n                     self.cur_mps.push(mp);\n                 }\n-            } else {\n-                // We are past the end of the matcher, and not in a sequence. Look for end of\n-                // input.\n-                debug_assert_eq!(idx, len);\n-                if *token == token::Eof {\n-                    eof_mps = match eof_mps {\n-                        EofMatcherPositions::None => EofMatcherPositions::One(mp),\n-                        EofMatcherPositions::One(_) | EofMatcherPositions::Multiple => {\n-                            EofMatcherPositions::Multiple\n+                MatcherLoc::Eof => {\n+                    // We are past the matcher's end, and not in a sequence. Try to end things.\n+                    debug_assert_eq!(mp.idx, self.locs.len() - 1);\n+                    if *token == token::Eof {\n+                        eof_mps = match eof_mps {\n+                            EofMatcherPositions::None => EofMatcherPositions::One(mp),\n+                            EofMatcherPositions::One(_) | EofMatcherPositions::Multiple => {\n+                                EofMatcherPositions::Multiple\n+                            }\n                         }\n                     }\n                 }\n@@ -623,11 +560,11 @@ impl<'tt> TtParser<'tt> {\n         if *token == token::Eof {\n             Some(match eof_mps {\n                 EofMatcherPositions::One(mut eof_mp) => {\n-                    assert_eq!(eof_mp.matches.len(), count_metavar_decls(matcher));\n+                    assert_eq!(eof_mp.matches.len(), num_metavar_decls);\n                     // Need to take ownership of the matches from within the `Lrc`.\n                     Lrc::make_mut(&mut eof_mp.matches);\n                     let matches = Lrc::try_unwrap(eof_mp.matches).unwrap().into_iter();\n-                    nameize(sess, matcher, matches)\n+                    self.nameize(matches)\n                 }\n                 EofMatcherPositions::Multiple => {\n                     Error(token.span, \"ambiguity: multiple successful parses\".to_string())\n@@ -651,22 +588,27 @@ impl<'tt> TtParser<'tt> {\n         parser: &mut Cow<'_, Parser<'_>>,\n         matcher: &'tt [TokenTree],\n     ) -> NamedParseResult {\n+        let num_metavar_decls = match self.compute_locs(parser.sess, matcher) {\n+            Ok(num_metavar_decls) => num_metavar_decls,\n+            Err((span, msg)) => return Error(span, msg),\n+        };\n+\n         // A queue of possible matcher positions. We initialize it with the matcher position in\n         // which the \"dot\" is before the first token of the first token tree in `matcher`.\n         // `parse_tt_inner` then processes all of these possible matcher positions and produces\n         // possible next positions into `next_mps`. After some post-processing, the contents of\n         // `next_mps` replenish `cur_mps` and we start over again.\n         self.cur_mps.clear();\n-        self.cur_mps.push(box MatcherPos::top_level(matcher, self.empty_matches.clone()));\n+        self.cur_mps.push(MatcherPos { idx: 0, matches: self.empty_matches.clone() });\n \n         loop {\n             self.next_mps.clear();\n             self.bb_mps.clear();\n \n             // Process `cur_mps` until either we have finished the input or we need to get some\n             // parsing from the black-box parser done.\n-            if let Some(result) = self.parse_tt_inner(parser.sess, matcher, &parser.token) {\n-                return result;\n+            if let Some(res) = self.parse_tt_inner(num_metavar_decls, &parser.token) {\n+                return res;\n             }\n \n             // `parse_tt_inner` handled all of `cur_mps`, so it's empty.\n@@ -693,8 +635,11 @@ impl<'tt> TtParser<'tt> {\n                 (0, 1) => {\n                     // We need to call the black-box parser to get some nonterminal.\n                     let mut mp = self.bb_mps.pop().unwrap();\n-                    if let TokenTree::MetaVarDecl(span, _, Some(kind)) = mp.tts[mp.idx] {\n-                        let match_cur = mp.match_cur;\n+                    let loc = &self.locs[mp.idx];\n+                    if let &MatcherLoc::MetaVarDecl {\n+                        span, kind, next_metavar, seq_depth, ..\n+                    } = loc\n+                    {\n                         // We use the span of the metavariable declaration to determine any\n                         // edition-specific matching behavior for non-terminals.\n                         let nt = match parser.to_mut().parse_nonterminal(kind) {\n@@ -714,9 +659,8 @@ impl<'tt> TtParser<'tt> {\n                             NtOrTt::Nt(nt) => MatchedNonterminal(Lrc::new(nt)),\n                             NtOrTt::Tt(tt) => MatchedTokenTree(tt),\n                         };\n-                        mp.push_match(match_cur, m);\n+                        mp.push_match(next_metavar, seq_depth, m);\n                         mp.idx += 1;\n-                        mp.match_cur += 1;\n                     } else {\n                         unreachable!()\n                     }\n@@ -737,11 +681,9 @@ impl<'tt> TtParser<'tt> {\n         let nts = self\n             .bb_mps\n             .iter()\n-            .map(|mp| match mp.tts[mp.idx] {\n-                TokenTree::MetaVarDecl(_, bind, Some(kind)) => {\n-                    format!(\"{} ('{}')\", kind, bind)\n-                }\n-                _ => panic!(),\n+            .map(|mp| match &self.locs[mp.idx] {\n+                MatcherLoc::MetaVarDecl { bind, kind, .. } => format!(\"{} ('{}')\", kind, bind),\n+                _ => unreachable!(),\n             })\n             .collect::<Vec<String>>()\n             .join(\" or \");\n@@ -759,4 +701,19 @@ impl<'tt> TtParser<'tt> {\n             ),\n         )\n     }\n+\n+    fn nameize<I: Iterator<Item = NamedMatch>>(&self, mut res: I) -> NamedParseResult {\n+        // Make that each metavar has _exactly one_ binding. If so, insert the binding into the\n+        // `NamedParseResult`. Otherwise, it's an error.\n+        let mut ret_val = FxHashMap::default();\n+        for loc in self.locs.iter() {\n+            if let &MatcherLoc::MetaVarDecl { span, bind, .. } = loc {\n+                match ret_val.entry(MacroRulesNormalizedIdent::new(bind)) {\n+                    Vacant(spot) => spot.insert(res.next().unwrap()),\n+                    Occupied(..) => return Error(span, format!(\"duplicated bind name: {}\", bind)),\n+                };\n+            }\n+        }\n+        Success(ret_val)\n+    }\n }"}]}