{"sha": "f088606d8946d992c61153dc7f208efdaf9fb12d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwODg2MDZkODk0NmQ5OTJjNjExNTNkYzdmMjA4ZWZkYWY5ZmIxMmQ=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-20T11:12:29Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-20T11:12:29Z"}, "message": "Rename `unexpanded_macros` to `unresolved_macros`", "tree": {"sha": "43619eb3d9476b12b4869b6c89b5eeb8dc54e990", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43619eb3d9476b12b4869b6c89b5eeb8dc54e990"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f088606d8946d992c61153dc7f208efdaf9fb12d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f088606d8946d992c61153dc7f208efdaf9fb12d", "html_url": "https://github.com/rust-lang/rust/commit/f088606d8946d992c61153dc7f208efdaf9fb12d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f088606d8946d992c61153dc7f208efdaf9fb12d/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "764241e38e46316b6370977e8b51e841e93e84b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/764241e38e46316b6370977e8b51e841e93e84b9", "html_url": "https://github.com/rust-lang/rust/commit/764241e38e46316b6370977e8b51e841e93e84b9"}], "stats": {"total": 46, "additions": 31, "deletions": 15}, "files": [{"sha": "2c8f1b5b8b691deb96c1cff57bd1390e616c1a12", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f088606d8946d992c61153dc7f208efdaf9fb12d/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f088606d8946d992c61153dc7f208efdaf9fb12d/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=f088606d8946d992c61153dc7f208efdaf9fb12d", "patch": "@@ -94,7 +94,7 @@ pub(super) fn collect_defs(\n         unresolved_imports: Vec::new(),\n         resolved_imports: Vec::new(),\n \n-        unexpanded_macros: Vec::new(),\n+        unresolved_macros: Vec::new(),\n         mod_dirs: FxHashMap::default(),\n         cfg_options,\n         proc_macros,\n@@ -237,7 +237,7 @@ struct DefCollector<'a> {\n     glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, Visibility)>>,\n     unresolved_imports: Vec<ImportDirective>,\n     resolved_imports: Vec<ImportDirective>,\n-    unexpanded_macros: Vec<MacroDirective>,\n+    unresolved_macros: Vec<MacroDirective>,\n     mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n     cfg_options: &'a CfgOptions,\n     /// List of procedural macros defined by this crate. This is read from the dynamic library\n@@ -374,8 +374,8 @@ impl DefCollector<'_> {\n         cov_mark::hit!(unresolved_attribute_fallback);\n \n         let mut added_items = false;\n-        let unexpanded_macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n-        for directive in &unexpanded_macros {\n+        let unresolved_macros = std::mem::replace(&mut self.unresolved_macros, Vec::new());\n+        for directive in &unresolved_macros {\n             if let MacroDirectiveKind::Attr { ast_id, mod_item, .. } = &directive.kind {\n                 // Make sure to only add such items once.\n                 if !self.ignore_attrs_on.insert(ast_id.ast_id.with_value(*mod_item)) {\n@@ -399,7 +399,7 @@ impl DefCollector<'_> {\n         }\n \n         // The collection above might add new unresolved macros (eg. derives), so merge the lists.\n-        self.unexpanded_macros.extend(unexpanded_macros);\n+        self.unresolved_macros.extend(unresolved_macros);\n \n         if added_items {\n             // Continue name resolution with the new data.\n@@ -873,7 +873,7 @@ impl DefCollector<'_> {\n     }\n \n     fn resolve_macros(&mut self) -> ReachedFixedPoint {\n-        let mut macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n+        let mut macros = std::mem::replace(&mut self.unresolved_macros, Vec::new());\n         let mut resolved = Vec::new();\n         let mut res = ReachedFixedPoint::Yes;\n         macros.retain(|directive| {\n@@ -929,7 +929,7 @@ impl DefCollector<'_> {\n \n             true\n         });\n-        self.unexpanded_macros = macros;\n+        self.unresolved_macros = macros;\n \n         for (module_id, macro_call_id, depth) in resolved {\n             self.collect_macro_expansion(module_id, macro_call_id, depth);\n@@ -1000,7 +1000,7 @@ impl DefCollector<'_> {\n     fn finish(mut self) -> DefMap {\n         // Emit diagnostics for all remaining unexpanded macros.\n \n-        for directive in &self.unexpanded_macros {\n+        for directive in &self.unresolved_macros {\n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, fragment } => match macro_call_as_call_id(\n                     ast_id,\n@@ -1137,7 +1137,7 @@ impl ModCollector<'_, '_> {\n                 }\n             }\n \n-            if let Err(()) = self.resolve_attributes(&attrs, item) {\n+            if let Err(()) = self.resolve_attributes(&attrs, None, item) {\n                 // Do not process the item. It has at least one non-builtin attribute, so the\n                 // fixed-point algorithm is required to resolve the rest of them.\n                 continue;\n@@ -1453,7 +1453,12 @@ impl ModCollector<'_, '_> {\n     ///\n     /// Returns `Err` when some attributes could not be resolved to builtins and have been\n     /// registered as unresolved.\n-    fn resolve_attributes(&mut self, attrs: &Attrs, mod_item: ModItem) -> Result<(), ()> {\n+    fn resolve_attributes(\n+        &mut self,\n+        attrs: &Attrs,\n+        mut ignore_up_to: Option<AttrId>,\n+        mod_item: ModItem,\n+    ) -> Result<(), ()> {\n         fn is_builtin_attr(path: &ModPath) -> bool {\n             if path.kind == PathKind::Plain {\n                 if let Some(tool_module) = path.segments().first() {\n@@ -1484,7 +1489,18 @@ impl ModCollector<'_, '_> {\n             return Ok(());\n         }\n \n-        match attrs.iter().find(|attr| !is_builtin_attr(&attr.path)) {\n+        match attrs\n+            .iter()\n+            .skip_while(|attr| match ignore_up_to {\n+                Some(id) if attr.id == id => {\n+                    ignore_up_to = None;\n+                    false\n+                }\n+                Some(_) => true,\n+                None => false,\n+            })\n+            .find(|attr| !is_builtin_attr(&attr.path))\n+        {\n             Some(non_builtin_attr) => {\n                 log::debug!(\"non-builtin attribute {}\", non_builtin_attr.path);\n \n@@ -1493,7 +1509,7 @@ impl ModCollector<'_, '_> {\n                     mod_item.ast_id(self.item_tree),\n                     non_builtin_attr.path.as_ref().clone(),\n                 );\n-                self.def_collector.unexpanded_macros.push(MacroDirective {\n+                self.def_collector.unresolved_macros.push(MacroDirective {\n                     module_id: self.module_id,\n                     depth: self.macro_depth + 1,\n                     kind: MacroDirectiveKind::Attr { ast_id, attr: non_builtin_attr.id, mod_item },\n@@ -1511,7 +1527,7 @@ impl ModCollector<'_, '_> {\n                 Some(derive_macros) => {\n                     for path in derive_macros {\n                         let ast_id = AstIdWithPath::new(self.file_id, ast_id, path);\n-                        self.def_collector.unexpanded_macros.push(MacroDirective {\n+                        self.def_collector.unresolved_macros.push(MacroDirective {\n                             module_id: self.module_id,\n                             depth: self.macro_depth + 1,\n                             kind: MacroDirectiveKind::Derive { ast_id, derive_attr: derive.id },\n@@ -1686,7 +1702,7 @@ impl ModCollector<'_, '_> {\n             ast_id.path.kind = PathKind::Super(0);\n         }\n \n-        self.def_collector.unexpanded_macros.push(MacroDirective {\n+        self.def_collector.unresolved_macros.push(MacroDirective {\n             module_id: self.module_id,\n             depth: self.macro_depth + 1,\n             kind: MacroDirectiveKind::FnLike { ast_id, fragment: mac.fragment },\n@@ -1731,7 +1747,7 @@ mod tests {\n             glob_imports: FxHashMap::default(),\n             unresolved_imports: Vec::new(),\n             resolved_imports: Vec::new(),\n-            unexpanded_macros: Vec::new(),\n+            unresolved_macros: Vec::new(),\n             mod_dirs: FxHashMap::default(),\n             cfg_options: &CfgOptions::default(),\n             proc_macros: Default::default(),"}]}