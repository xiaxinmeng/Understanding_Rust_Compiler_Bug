{"sha": "ef4186a85b4c9bd94d258e3280cb239f26b8436e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNDE4NmE4NWI0YzliZDk0ZDI1OGUzMjgwY2IyMzlmMjZiODQzNmU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-06-20T11:23:31Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-06-20T11:23:31Z"}, "message": "Use Cranelift legalization for icmp.i128\n\nThe previous translation was wrong for signed 128bit comparisions\n\nThis fixes several libcore tests", "tree": {"sha": "d48388739b13f34557cfe74c01ccedc7945a7ad7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d48388739b13f34557cfe74c01ccedc7945a7ad7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef4186a85b4c9bd94d258e3280cb239f26b8436e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef4186a85b4c9bd94d258e3280cb239f26b8436e", "html_url": "https://github.com/rust-lang/rust/commit/ef4186a85b4c9bd94d258e3280cb239f26b8436e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef4186a85b4c9bd94d258e3280cb239f26b8436e/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c6bf836fe3d4cfda1b827a5cd3982e5a588c0ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c6bf836fe3d4cfda1b827a5cd3982e5a588c0ff", "html_url": "https://github.com/rust-lang/rust/commit/5c6bf836fe3d4cfda1b827a5cd3982e5a588c0ff"}], "stats": {"total": 180, "additions": 14, "deletions": 166}, "files": [{"sha": "7038df874a4676faed765710301e1c54f3f43d35", "filename": "example/std_example.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef4186a85b4c9bd94d258e3280cb239f26b8436e/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4186a85b4c9bd94d258e3280cb239f26b8436e/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=ef4186a85b4c9bd94d258e3280cb239f26b8436e", "patch": "@@ -81,6 +81,12 @@ fn main() {\n     assert_eq!(houndred_f32 as i128, 100);\n     assert_eq!(houndred_f64 as i128, 100);\n \n+    // Test signed 128bit comparing\n+    let max = usize::MAX as i128;\n+    if 100i128 < 0i128 || 100i128 > max {\n+        panic!();\n+    }\n+\n     let _a = 1u32 << 2u8;\n \n     let empty: [i32; 0] = [];"}, {"sha": "282d476bd7504d3fed90136f282f566dc5804d12", "filename": "patches/0022-core-Disable-not-compiling-tests.patch", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ef4186a85b4c9bd94d258e3280cb239f26b8436e/patches%2F0022-core-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/ef4186a85b4c9bd94d258e3280cb239f26b8436e/patches%2F0022-core-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0022-core-Disable-not-compiling-tests.patch?ref=ef4186a85b4c9bd94d258e3280cb239f26b8436e", "patch": "@@ -119,25 +119,5 @@ index 6609bc3..241b497 100644\n  \n  #[test]\n  #[should_panic(expected = \"index 0 greater than length of slice\")]\n-diff --git a/src/libcore/tests/iter.rs b/src/libcore/tests/iter.rs\n-index b73b621..d6cc3f8 100644\n---- a/src/libcore/tests/iter.rs\n-+++ b/src/libcore/tests/iter.rs\n-@@ -2541,6 +2541,7 @@ fn test_steps_between() {\n- \n-     // Skip u64/i64 to avoid differences with 32-bit vs 64-bit platforms\n- \n-+    /*\n-     assert_eq!(Step::steps_between(&20_u128, &200_u128), Some(180_usize));\n-     assert_eq!(Step::steps_between(&-20_i128, &80_i128), Some(100_usize));\n-     if cfg!(target_pointer_width = \"64\") {\n-@@ -2552,6 +2553,7 @@ fn test_steps_between() {\n-         Step::steps_between(&-0x1_0000_0000_0000_0000_i128, &0x1_0000_0000_0000_0000_i128,),\n-         None,\n-     );\n-+    */\n- }\n- \n- #[test]\n--- \n+--\n 2.21.0 (Apple Git-122)"}, {"sha": "18b5ed3d3bdd33cdf5d69579d36062a557529d61", "filename": "patches/0023-core-Ignore-failing-tests.patch", "status": "modified", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/ef4186a85b4c9bd94d258e3280cb239f26b8436e/patches%2F0023-core-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/ef4186a85b4c9bd94d258e3280cb239f26b8436e/patches%2F0023-core-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0023-core-Ignore-failing-tests.patch?ref=ef4186a85b4c9bd94d258e3280cb239f26b8436e", "patch": "@@ -66,87 +66,6 @@ index c9096b7..be37fcd 100644\n  fn test_successors() {\n      let mut powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\n      assert_eq!(powers_of_10.by_ref().collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n-diff --git a/src/libcore/tests/num/bignum.rs b/src/libcore/tests/num/bignum.rs\n-index b9e15ec..32f6de8 100644\n---- a/src/libcore/tests/num/bignum.rs\n-+++ b/src/libcore/tests/num/bignum.rs\n-@@ -3,6 +3,7 @@ use core::num::bignum::tests::Big8x3 as Big;\n- \n- #[test]\n- #[should_panic]\n-+#[ignore]\n- fn test_from_u64_overflow() {\n-     Big::from_u64(0x1000000);\n- }\n-@@ -19,12 +20,14 @@ fn test_add() {\n- \n- #[test]\n- #[should_panic]\n-+#[ignore]\n- fn test_add_overflow_1() {\n-     Big::from_small(1).add(&Big::from_u64(0xffffff));\n- }\n- \n- #[test]\n- #[should_panic]\n-+#[ignore]\n- fn test_add_overflow_2() {\n-     Big::from_u64(0xffffff).add(&Big::from_small(1));\n- }\n-@@ -42,6 +45,7 @@ fn test_add_small() {\n- \n- #[test]\n- #[should_panic]\n-+#[ignore]\n- fn test_add_small_overflow() {\n-     Big::from_u64(0xffffff).add_small(1);\n- }\n-@@ -76,6 +80,7 @@ fn test_mul_small() {\n- \n- #[test]\n- #[should_panic]\n-+#[ignore]\n- fn test_mul_small_overflow() {\n-     Big::from_u64(0x800000).mul_small(2);\n- }\n-@@ -118,12 +123,14 @@ fn test_mul_pow5() {\n- \n- #[test]\n- #[should_panic]\n-+#[ignore]\n- fn test_mul_pow5_overflow_1() {\n-     Big::from_small(1).mul_pow5(12);\n- }\n- \n- #[test]\n- #[should_panic]\n-+#[ignore]\n- fn test_mul_pow5_overflow_2() {\n-     Big::from_small(230).mul_pow5(8);\n- }\n-@@ -141,12 +148,14 @@ fn test_mul_digits() {\n- \n- #[test]\n- #[should_panic]\n-+#[ignore]\n- fn test_mul_digits_overflow_1() {\n-     Big::from_u64(0x800000).mul_digits(&[2]);\n- }\n- \n- #[test]\n- #[should_panic]\n-+#[ignore]\n- fn test_mul_digits_overflow_2() {\n-     Big::from_u64(0x1000).mul_digits(&[0, 0x10]);\n- }\n-@@ -206,6 +215,7 @@ fn test_get_bit() {\n- \n- #[test]\n- #[should_panic]\n-+#[ignore]\n- fn test_get_bit_out_of_range() {\n-     Big::from_small(42).get_bit(24);\n- }\n diff --git a/src/libcore/tests/num/mod.rs b/src/libcore/tests/num/mod.rs\n index a17c094..5bb11d2 100644\n --- a/src/libcore/tests/num/mod.rs\n@@ -159,18 +78,6 @@ index a17c094..5bb11d2 100644\n  fn from_str_issue7588() {\n      let u: Option<u8> = u8::from_str_radix(\"1000\", 10).ok();\n      assert_eq!(u, None);\n-@@ -613,11 +614,9 @@ test_impl_try_from_signed_to_unsigned_err! { test_try_i64u32, i64, u32 }\n- test_impl_try_from_signed_to_unsigned_err! { test_try_i128u8, i128, u8 }\n- test_impl_try_from_signed_to_unsigned_err! { test_try_i128u16, i128, u16 }\n- test_impl_try_from_signed_to_unsigned_err! { test_try_i128u32, i128, u32 }\n--test_impl_try_from_signed_to_unsigned_err! { test_try_i128u64, i128, u64 }\n- \n- assume_usize_width! {\n-     test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu8, isize, u8 }\n--    test_impl_try_from_signed_to_unsigned_err! { test_try_i128usize, i128, usize }\n- \n-     cfg_block! {\n-         #[cfg(target_pointer_width = \"16\")] {\n @@ -640,6 +639,7 @@ macro_rules! test_float {\n          mod $modname {\n              // FIXME(nagisa): these tests should test for sign of -0.0"}, {"sha": "e3312eb135390323a734de3d71d968eb37bca1bb", "filename": "src/common.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ef4186a85b4c9bd94d258e3280cb239f26b8436e/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4186a85b4c9bd94d258e3280cb239f26b8436e/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=ef4186a85b4c9bd94d258e3280cb239f26b8436e", "patch": "@@ -81,51 +81,6 @@ pub(crate) fn has_ptr_meta<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-pub(crate) fn codegen_icmp(\n-    fx: &mut FunctionCx<'_, '_, impl Backend>,\n-    intcc: IntCC,\n-    lhs: Value,\n-    rhs: Value,\n-) -> Value {\n-    let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n-    let rhs_ty = fx.bcx.func.dfg.value_type(rhs);\n-    assert_eq!(lhs_ty, rhs_ty);\n-    if lhs_ty == types::I128 {\n-        // FIXME legalize `icmp.i128` in Cranelift\n-\n-        let (lhs_lsb, lhs_msb) = fx.bcx.ins().isplit(lhs);\n-        let (rhs_lsb, rhs_msb) = fx.bcx.ins().isplit(rhs);\n-\n-        match intcc {\n-            IntCC::Equal => {\n-                let lsb_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_lsb, rhs_lsb);\n-                let msb_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_msb, rhs_msb);\n-                fx.bcx.ins().band(lsb_eq, msb_eq)\n-            }\n-            IntCC::NotEqual => {\n-                let lsb_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_lsb, rhs_lsb);\n-                let msb_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_msb, rhs_msb);\n-                fx.bcx.ins().bor(lsb_ne, msb_ne)\n-            }\n-            _ => {\n-                // if msb_eq {\n-                //     lsb_cc\n-                // } else {\n-                //     msb_cc\n-                // }\n-\n-                let msb_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_msb, rhs_msb);\n-                let lsb_cc = fx.bcx.ins().icmp(intcc, lhs_lsb, rhs_lsb);\n-                let msb_cc = fx.bcx.ins().icmp(intcc, lhs_msb, rhs_msb);\n-\n-                fx.bcx.ins().select(msb_eq, lsb_cc, msb_cc)\n-            }\n-        }\n-    } else {\n-        fx.bcx.ins().icmp(intcc, lhs, rhs)\n-    }\n-}\n-\n pub(crate) fn codegen_icmp_imm(\n     fx: &mut FunctionCx<'_, '_, impl Backend>,\n     intcc: IntCC,"}, {"sha": "594d24b581e36c523ad30b455274c45dc5aed819", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef4186a85b4c9bd94d258e3280cb239f26b8436e/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4186a85b4c9bd94d258e3280cb239f26b8436e/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=ef4186a85b4c9bd94d258e3280cb239f26b8436e", "patch": "@@ -126,7 +126,7 @@ macro atomic_minmax($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $\n     let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n \n     // Compare\n-    let is_eq = codegen_icmp($fx, IntCC::SignedGreaterThan, old, $src);\n+    let is_eq = $fx.bcx.ins().icmp(IntCC::SignedGreaterThan, old, $src);\n     let new = $fx.bcx.ins().select(is_eq, old, $src);\n \n     // Write new\n@@ -257,7 +257,7 @@ macro simd_cmp {\n         if let Some(vector_ty) = vector_ty {\n             let x = $x.load_scalar($fx);\n             let y = $y.load_scalar($fx);\n-            let val = codegen_icmp($fx, IntCC::$cc, x, y);\n+            let val = $fx.bcx.ins().icmp(IntCC::$cc, x, y);\n \n             // HACK This depends on the fact that icmp for vectors represents bools as 0 and !0, not 0 and 1.\n             let val = $fx.bcx.ins().raw_bitcast(vector_ty, val);\n@@ -271,7 +271,7 @@ macro simd_cmp {\n                 $ret,\n                 |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n                     let res_lane = match lane_layout.ty.kind {\n-                        ty::Uint(_) | ty::Int(_) => codegen_icmp(fx, IntCC::$cc, x_lane, y_lane),\n+                        ty::Uint(_) | ty::Int(_) => fx.bcx.ins().icmp(IntCC::$cc, x_lane, y_lane),\n                         _ => unreachable!(\"{:?}\", lane_layout.ty),\n                     };\n                     bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n@@ -288,8 +288,8 @@ macro simd_cmp {\n             $ret,\n             |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n                 let res_lane = match lane_layout.ty.kind {\n-                    ty::Uint(_) => codegen_icmp(fx, IntCC::$cc_u, x_lane, y_lane),\n-                    ty::Int(_) => codegen_icmp(fx, IntCC::$cc_s, x_lane, y_lane),\n+                    ty::Uint(_) => fx.bcx.ins().icmp(IntCC::$cc_u, x_lane, y_lane),\n+                    ty::Int(_) => fx.bcx.ins().icmp(IntCC::$cc_s, x_lane, y_lane),\n                     _ => unreachable!(\"{:?}\", lane_layout.ty),\n                 };\n                 bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n@@ -869,7 +869,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n \n             // Compare\n-            let is_eq = codegen_icmp(fx, IntCC::Equal, old, test_old);\n+            let is_eq = fx.bcx.ins().icmp(IntCC::Equal, old, test_old);\n             let new = fx.bcx.ins().select(is_eq, new, old); // Keep old if not equal to test_old\n \n             // Write new"}, {"sha": "5acff80768eafcbfc4bcb3d7b89186ab361bed1f", "filename": "src/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4186a85b4c9bd94d258e3280cb239f26b8436e/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4186a85b4c9bd94d258e3280cb239f26b8436e/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=ef4186a85b4c9bd94d258e3280cb239f26b8436e", "patch": "@@ -46,7 +46,7 @@ fn codegen_compare_bin_op<'tcx>(\n     rhs: Value,\n ) -> CValue<'tcx> {\n     let intcc = crate::num::bin_op_to_intcc(bin_op, signed).unwrap();\n-    let val = codegen_icmp(fx, intcc, lhs, rhs);\n+    let val = fx.bcx.ins().icmp(intcc, lhs, rhs);\n     let val = fx.bcx.ins().bint(types::I8, val);\n     CValue::by_val(val, fx.layout_of(fx.tcx.types.bool))\n }"}]}