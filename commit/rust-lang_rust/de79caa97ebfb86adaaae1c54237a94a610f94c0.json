{"sha": "de79caa97ebfb86adaaae1c54237a94a610f94c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlNzljYWE5N2ViZmI4NmFkYWFhZTFjNTQyMzdhOTRhNjEwZjk0YzA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-14T17:04:03Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-14T17:05:28Z"}, "message": "Add crude support for casts in constant expressions\n\nOnly casts to integral and float types are supported\n\nCloses #1975", "tree": {"sha": "e434939aacae6c1777d971d125be161cca1ea00a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e434939aacae6c1777d971d125be161cca1ea00a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de79caa97ebfb86adaaae1c54237a94a610f94c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de79caa97ebfb86adaaae1c54237a94a610f94c0", "html_url": "https://github.com/rust-lang/rust/commit/de79caa97ebfb86adaaae1c54237a94a610f94c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de79caa97ebfb86adaaae1c54237a94a610f94c0/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c988800cf5611130e468761caa4d2f5adbdc6781", "url": "https://api.github.com/repos/rust-lang/rust/commits/c988800cf5611130e468761caa4d2f5adbdc6781", "html_url": "https://github.com/rust-lang/rust/commit/c988800cf5611130e468761caa4d2f5adbdc6781"}], "stats": {"total": 202, "additions": 129, "deletions": 73}, "files": [{"sha": "eb4f74105f29f6f737ac0be3eb7f197a3fd5b2c6", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=de79caa97ebfb86adaaae1c54237a94a610f94c0", "patch": "@@ -148,7 +148,8 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n         time(time_passes, \"typechecking\",\n              bind typeck::check_crate(ty_cx, impl_map, crate));\n     time(time_passes, \"const checking\",\n-         bind middle::check_const::check_crate(sess, crate, method_map));\n+         bind middle::check_const::check_crate(sess, crate, method_map,\n+                                               ty_cx));\n \n     if upto == cu_typeck { ret {crate: crate, tcx: some(ty_cx)}; }\n "}, {"sha": "334535efb42b098150e7693005e86484f2d71f72", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=de79caa97ebfb86adaaae1c54237a94a610f94c0", "patch": "@@ -258,19 +258,19 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n       }\n       pat_lit(la) {\n         alt b.node {\n-          pat_lit(lb) { lit_expr_eq(la, lb) }\n+          pat_lit(lb) { lit_expr_eq(tcx, la, lb) }\n           _ { false }\n         }\n       }\n       pat_range(begina, enda) {\n         alt b.node {\n           pat_lit(lb) {\n-            compare_lit_exprs(begina, lb) <= 0 &&\n-            compare_lit_exprs(enda, lb) >= 0\n+            compare_lit_exprs(tcx, begina, lb) <= 0 &&\n+            compare_lit_exprs(tcx, enda, lb) >= 0\n           }\n           pat_range(beginb, endb) {\n-            compare_lit_exprs(begina, beginb) <= 0 &&\n-            compare_lit_exprs(enda, endb) >= 0\n+            compare_lit_exprs(tcx, begina, beginb) <= 0 &&\n+            compare_lit_exprs(tcx, enda, endb) >= 0\n           }\n           _ { false }\n         }"}, {"sha": "9098bf1fc11bfe9ea955e9036f2069af74433669", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=de79caa97ebfb86adaaae1c54237a94a610f94c0", "patch": "@@ -3,11 +3,12 @@ import syntax::{visit, ast_util};\n import driver::session::session;\n import std::map::hashmap;\n \n-fn check_crate(sess: session, crate: @crate, method_map: typeck::method_map) {\n+fn check_crate(sess: session, crate: @crate, method_map: typeck::method_map,\n+               tcx: ty::ctxt) {\n     visit::visit_crate(*crate, false, visit::mk_vt(@{\n         visit_item: check_item,\n         visit_pat: check_pat,\n-        visit_expr: bind check_expr(sess, method_map, _, _, _)\n+        visit_expr: bind check_expr(sess, method_map, tcx, _, _, _)\n         with *visit::default_visitor()\n     }));\n     sess.abort_if_errors();\n@@ -42,8 +43,8 @@ fn check_pat(p: @pat, &&_is_const: bool, v: visit::vt<bool>) {\n     }\n }\n \n-fn check_expr(sess: session, method_map: typeck::method_map, e: @expr,\n-              &&is_const: bool, v: visit::vt<bool>) {\n+fn check_expr(sess: session, method_map: typeck::method_map, tcx: ty::ctxt,\n+              e: @expr, &&is_const: bool, v: visit::vt<bool>) {\n     if is_const {\n         alt e.node {\n           expr_unary(box(_), _) | expr_unary(uniq(_), _) |\n@@ -63,6 +64,14 @@ fn check_expr(sess: session, method_map: typeck::method_map, e: @expr,\n             }\n           }\n           expr_lit(_) {}\n+          expr_cast(_, _) {\n+            let ety = ty::expr_ty(tcx, e);\n+            if !ty::type_is_numeric(ety) {\n+                sess.span_err(e.span, \"can not cast to `\" +\n+                              util::ppaux::ty_to_str(tcx, ety) +\n+                              \"` in a constant expression\");\n+            }\n+          }\n           _ {\n             sess.span_err(e.span,\n                           \"constant contains unimplemented expression type\");"}, {"sha": "eeb2c4136cf3c806bd5225e777a6fb5fac78ed57", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=de79caa97ebfb86adaaae1c54237a94a610f94c0", "patch": "@@ -23,12 +23,12 @@ enum opt {\n     var(/* disr val */int, /* variant dids */{enm: def_id, var: def_id}),\n     range(@ast::expr, @ast::expr)\n }\n-fn opt_eq(a: opt, b: opt) -> bool {\n+fn opt_eq(tcx: ty::ctxt, a: opt, b: opt) -> bool {\n     alt (a, b) {\n-      (lit(a), lit(b)) { ast_util::compare_lit_exprs(a, b) == 0 }\n+      (lit(a), lit(b)) { ast_util::compare_lit_exprs(tcx, a, b) == 0 }\n       (range(a1, a2), range(b1, b2)) {\n-        ast_util::compare_lit_exprs(a1, b1) == 0 &&\n-        ast_util::compare_lit_exprs(a2, b2) == 0\n+        ast_util::compare_lit_exprs(tcx, a1, b1) == 0 &&\n+        ast_util::compare_lit_exprs(tcx, a2, b2) == 0\n       }\n       (var(a, _), var(b, _)) { a == b }\n       _ { false }\n@@ -161,18 +161,18 @@ fn enter_opt(tcx: ty::ctxt, m: match, opt: opt, col: uint,\n     enter_match(tcx.def_map, m, col, val) {|p|\n         alt p.node {\n           ast::pat_enum(_, subpats) {\n-            if opt_eq(variant_opt(tcx, p.id), opt) { some(subpats) }\n+            if opt_eq(tcx, variant_opt(tcx, p.id), opt) { some(subpats) }\n             else { none }\n           }\n           ast::pat_ident(_, none) if pat_is_variant(tcx.def_map, p) {\n-            if opt_eq(variant_opt(tcx, p.id), opt) { some([]) }\n+            if opt_eq(tcx, variant_opt(tcx, p.id), opt) { some([]) }\n             else { none }\n           }\n           ast::pat_lit(l) {\n-            if opt_eq(lit(l), opt) { some([]) } else { none }\n+            if opt_eq(tcx, lit(l), opt) { some([]) } else { none }\n           }\n           ast::pat_range(l1, l2) {\n-            if opt_eq(range(l1, l2), opt) { some([]) } else { none }\n+            if opt_eq(tcx, range(l1, l2), opt) { some([]) } else { none }\n           }\n           _ { some(vec::from_elem(variant_size, dummy)) }\n         }\n@@ -232,21 +232,21 @@ fn enter_uniq(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n }\n \n fn get_options(ccx: crate_ctxt, m: match, col: uint) -> [opt] {\n-    fn add_to_set(&set: [opt], val: opt) {\n-        for l in set { if opt_eq(l, val) { ret; } }\n+    fn add_to_set(tcx: ty::ctxt, &set: [opt], val: opt) {\n+        for l in set { if opt_eq(tcx, l, val) { ret; } }\n         set += [val];\n     }\n \n     let found = [];\n     for br in m {\n         let cur = br.pats[col];\n         if pat_is_variant(ccx.tcx.def_map, cur) {\n-            add_to_set(found, variant_opt(ccx.tcx, br.pats[col].id));\n+            add_to_set(ccx.tcx, found, variant_opt(ccx.tcx, br.pats[col].id));\n         } else {\n             alt cur.node {\n-              ast::pat_lit(l) { add_to_set(found, lit(l)); }\n+              ast::pat_lit(l) { add_to_set(ccx.tcx, found, lit(l)); }\n               ast::pat_range(l1, l2) {\n-                add_to_set(found, range(l1, l2));\n+                add_to_set(ccx.tcx, found, range(l1, l2));\n               }\n               _ {}\n             }"}, {"sha": "a4a2c9cfcd4e0fa945b80a36b64795d51cb24295", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 46, "deletions": 22, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=de79caa97ebfb86adaaae1c54237a94a610f94c0", "patch": "@@ -2592,6 +2592,17 @@ fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n         } else { llsrc };\n }\n \n+enum cast_kind { cast_pointer, cast_integral, cast_float,\n+                 cast_enum, cast_other, }\n+fn cast_type_kind(t: ty::t) -> cast_kind {\n+    if ty::type_is_fp(t) { cast_float }\n+    else if ty::type_is_unsafe_ptr(t) { cast_pointer }\n+    else if ty::type_is_integral(t) { cast_integral }\n+    else if ty::type_is_enum(t) { cast_enum }\n+    else { cast_other }\n+}\n+\n+\n fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n               dest: dest) -> block {\n     let ccx = cx.ccx();\n@@ -2605,55 +2616,48 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n     let t_in = expr_ty(cx, e);\n     let ll_t_out = type_of(ccx, t_out);\n \n-    enum kind { pointer, integral, float, enum_, other, }\n-    fn t_kind(t: ty::t) -> kind {\n-        ret if ty::type_is_fp(t) { float }\n-        else if ty::type_is_unsafe_ptr(t) { pointer }\n-        else if ty::type_is_integral(t) { integral }\n-        else if ty::type_is_enum(t) { enum_ }\n-        else { other };\n-    }\n-    let k_in = t_kind(t_in);\n-    let k_out = t_kind(t_out);\n-    let s_in = k_in == integral && ty::type_is_signed(t_in);\n+    let k_in = cast_type_kind(t_in);\n+    let k_out = cast_type_kind(t_out);\n+    let s_in = k_in == cast_integral && ty::type_is_signed(t_in);\n \n     let newval =\n         alt {in: k_in, out: k_out} {\n-          {in: integral, out: integral} {\n+          {in: cast_integral, out: cast_integral} {\n             int_cast(e_res.bcx, ll_t_out, ll_t_in, e_res.val, s_in)\n           }\n-          {in: float, out: float} {\n+          {in: cast_float, out: cast_float} {\n             float_cast(e_res.bcx, ll_t_out, ll_t_in, e_res.val)\n           }\n-          {in: integral, out: float} {\n+          {in: cast_integral, out: cast_float} {\n             if s_in {\n                 SIToFP(e_res.bcx, e_res.val, ll_t_out)\n             } else { UIToFP(e_res.bcx, e_res.val, ll_t_out) }\n           }\n-          {in: float, out: integral} {\n+          {in: cast_float, out: cast_integral} {\n             if ty::type_is_signed(t_out) {\n                 FPToSI(e_res.bcx, e_res.val, ll_t_out)\n             } else { FPToUI(e_res.bcx, e_res.val, ll_t_out) }\n           }\n-          {in: integral, out: pointer} {\n+          {in: cast_integral, out: cast_pointer} {\n             IntToPtr(e_res.bcx, e_res.val, ll_t_out)\n           }\n-          {in: pointer, out: integral} {\n+          {in: cast_pointer, out: cast_integral} {\n             PtrToInt(e_res.bcx, e_res.val, ll_t_out)\n           }\n-          {in: pointer, out: pointer} {\n+          {in: cast_pointer, out: cast_pointer} {\n             PointerCast(e_res.bcx, e_res.val, ll_t_out)\n           }\n-          {in: enum_, out: integral} | {in: enum_, out: float} {\n+          {in: cast_enum, out: cast_integral} |\n+          {in: cast_enum, out: cast_float} {\n             let cx = e_res.bcx;\n             let llenumty = T_opaque_enum_ptr(ccx);\n             let av_enum = PointerCast(cx, e_res.val, llenumty);\n             let lldiscrim_a_ptr = GEPi(cx, av_enum, [0, 0]);\n             let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n             alt k_out {\n-              integral {int_cast(e_res.bcx, ll_t_out,\n-                                  val_ty(lldiscrim_a), lldiscrim_a, true)}\n-              float {SIToFP(e_res.bcx, lldiscrim_a, ll_t_out)}\n+              cast_integral {int_cast(e_res.bcx, ll_t_out,\n+                                      val_ty(lldiscrim_a), lldiscrim_a, true)}\n+              cast_float {SIToFP(e_res.bcx, lldiscrim_a, ll_t_out)}\n               _ { ccx.sess.bug(\"translating unsupported cast.\") }\n             }\n           }\n@@ -4335,6 +4339,26 @@ fn trans_const_expr(cx: crate_ctxt, e: @ast::expr) -> ValueRef {\n           }\n         }\n       }\n+      ast::expr_cast(base, tp) {\n+        let ety = ty::expr_ty(cx.tcx, e), llty = type_of(cx, ety);\n+        let basety = ty::expr_ty(cx.tcx, base);\n+        let v = trans_const_expr(cx, base);\n+        alt check (cast_type_kind(basety), cast_type_kind(ety)) {\n+          (cast_integral, cast_integral) {\n+            let s = if ty::type_is_signed(basety) { True } else { False };\n+            llvm::LLVMConstIntCast(v, llty, s)\n+          }\n+          (cast_integral, cast_float) {\n+            if ty::type_is_signed(basety) { llvm::LLVMConstSIToFP(v, llty) }\n+            else { llvm::LLVMConstUIToFP(v, llty) }\n+          }\n+          (cast_float, cast_float) { llvm::LLVMConstFPCast(v, llty) }\n+          (cast_float, cast_integral) {\n+            if ty::type_is_signed(ety) { llvm::LLVMConstFPToSI(v, llty) }\n+            else { llvm::LLVMConstFPToUI(v, llty) }\n+          }\n+        }\n+      }\n       _ { cx.sess.span_bug(e.span,\n             \"bad constant expression type in trans_const_expr\"); }\n     }"}, {"sha": "e2272c429ce2311cda6a1c0a7b88c892195a8f33", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=de79caa97ebfb86adaaae1c54237a94a610f94c0", "patch": "@@ -2373,7 +2373,7 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n                 alt variant.node.disr_expr {\n                   some (ex) {\n                     // FIXME: issue #1417\n-                    disr_val = alt syntax::ast_util::eval_const_expr(ex) {\n+                    disr_val = alt syntax::ast_util::eval_const_expr(cx, ex) {\n                       ast_util::const_int(val) {val as int}\n                       _ { cx.sess.bug(\"tag_variants: bad disr expr\"); }\n                     }"}, {"sha": "74f8fcca4ad97dfb1eb719630e01fce7bbbe479a", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=de79caa97ebfb86adaaae1c54237a94a610f94c0", "patch": "@@ -1437,8 +1437,9 @@ fn check_lit(ccx: @crate_ctxt, lit: @ast::lit) -> ty::t {\n     }\n }\n \n-fn valid_range_bounds(from: @ast::expr, to: @ast::expr) -> bool {\n-    ast_util::compare_lit_exprs(from, to) <= 0\n+fn valid_range_bounds(tcx: ty::ctxt, from: @ast::expr, to: @ast::expr)\n+    -> bool {\n+    ast_util::compare_lit_exprs(tcx, from, to) <= 0\n }\n \n fn check_pat_variant(fcx: @fn_ctxt, map: pat_util::pat_id_map,\n@@ -1516,7 +1517,7 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n             tcx.sess.span_err(pat.span, \"mismatched types in range\");\n         } else if !ty::type_is_numeric(b_ty) {\n             tcx.sess.span_err(pat.span, \"non-numeric type used in range\");\n-        } else if !valid_range_bounds(begin, end) {\n+        } else if !valid_range_bounds(tcx, begin, end) {\n             tcx.sess.span_err(begin.span, \"lower range bound must be less \\\n                                            than upper\");\n         }\n@@ -2913,14 +2914,14 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n         alt v.node.disr_expr {\n           some(e) {\n             check_expr(fcx, e);\n-            let cty = expr_ty(fcx.ccx.tcx, e);\n-            let declty = ty::mk_int(fcx.ccx.tcx);\n+            let cty = expr_ty(ccx.tcx, e);\n+            let declty = ty::mk_int(ccx.tcx);\n             demand::simple(fcx, e.span, declty, cty);\n             // FIXME: issue #1417\n             // Also, check_expr (from check_const pass) doesn't guarantee that\n             // the expression in an form that eval_const_expr can handle, so\n             // we may still get an internal compiler error\n-            alt syntax::ast_util::eval_const_expr(e) {\n+            alt syntax::ast_util::eval_const_expr(ccx.tcx, e) {\n               syntax::ast_util::const_int(val) {\n                 disr_val = val as int;\n               }"}, {"sha": "e5a15edf1a3f2022d8bf5b2e8f5dd9fb3981e665", "filename": "src/rustc/syntax/ast_util.rs", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de79caa97ebfb86adaaae1c54237a94a610f94c0/src%2Frustc%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast_util.rs?ref=de79caa97ebfb86adaaae1c54237a94a610f94c0", "patch": "@@ -250,38 +250,36 @@ enum const_val {\n }\n \n // FIXME: issue #1417\n-fn eval_const_expr(e: @expr) -> const_val {\n+fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n+    import middle::ty;\n     fn fromb(b: bool) -> const_val { const_int(b as i64) }\n-    alt e.node {\n+    alt check e.node {\n       expr_unary(neg, inner) {\n-        alt eval_const_expr(inner) {\n+        alt check eval_const_expr(tcx, inner) {\n           const_float(f) { const_float(-f) }\n           const_int(i) { const_int(-i) }\n           const_uint(i) { const_uint(-i) }\n-          _ { fail \"eval_const_expr: bad neg argument\"; }\n         }\n       }\n       expr_unary(not, inner) {\n-        alt eval_const_expr(inner) {\n+        alt check eval_const_expr(tcx, inner) {\n           const_int(i) { const_int(!i) }\n           const_uint(i) { const_uint(!i) }\n-          _ { fail \"eval_const_expr: bad not argument\"; }\n         }\n       }\n       expr_binary(op, a, b) {\n-        alt (eval_const_expr(a), eval_const_expr(b)) {\n+        alt check (eval_const_expr(tcx, a), eval_const_expr(tcx, b)) {\n           (const_float(a), const_float(b)) {\n-            alt op {\n+            alt check op {\n               add { const_float(a + b) } subtract { const_float(a - b) }\n               mul { const_float(a * b) } div { const_float(a / b) }\n               rem { const_float(a % b) } eq { fromb(a == b) }\n               lt { fromb(a < b) } le { fromb(a <= b) } ne { fromb(a != b) }\n               ge { fromb(a >= b) } gt { fromb(a > b) }\n-              _ { fail \"eval_const_expr: can't apply this binop to floats\"; }\n             }\n           }\n           (const_int(a), const_int(b)) {\n-            alt op {\n+            alt check op {\n               add { const_int(a + b) } subtract { const_int(a - b) }\n               mul { const_int(a * b) } div { const_int(a / b) }\n               rem { const_int(a % b) } and | bitand { const_int(a & b) }\n@@ -291,11 +289,11 @@ fn eval_const_expr(e: @expr) -> const_val {\n               eq { fromb(a == b) } lt { fromb(a < b) }\n               le { fromb(a <= b) } ne { fromb(a != b) }\n               ge { fromb(a >= b) } gt { fromb(a > b) }\n-              _ { fail \"eval_const_expr: can't apply this binop to ints\"; }\n             }\n+\n           }\n           (const_uint(a), const_uint(b)) {\n-            alt op {\n+            alt check op {\n               add { const_uint(a + b) } subtract { const_uint(a - b) }\n               mul { const_uint(a * b) } div { const_uint(a / b) }\n               rem { const_uint(a % b) } and | bitand { const_uint(a & b) }\n@@ -306,17 +304,38 @@ fn eval_const_expr(e: @expr) -> const_val {\n               eq { fromb(a == b) } lt { fromb(a < b) }\n               le { fromb(a <= b) } ne { fromb(a != b) }\n               ge { fromb(a >= b) } gt { fromb(a > b) }\n-              _ { fail \"eval_const_expr: can't apply this binop to uints\"; }\n             }\n           }\n-          _ { fail \"eval_constr_expr: bad binary arguments\"; }\n         }\n       }\n-      expr_lit(lit) { lit_to_const(lit) }\n-      // Precondition?\n-      _ {\n-          fail \"eval_const_expr: non-constant expression\";\n+      expr_cast(base, _) {\n+        let ety = ty::expr_ty(tcx, e);\n+        let base = eval_const_expr(tcx, base);\n+        alt check ty::get(ety).struct {\n+          ty::ty_float(_) {\n+            alt check base {\n+              const_uint(u) { const_float(u as f64) }\n+              const_int(i) { const_float(i as f64) }\n+              const_float(_) { base }\n+            }\n+          }\n+          ty::ty_uint(_) {\n+            alt check base {\n+              const_uint(_) { base }\n+              const_int(i) { const_uint(i as u64) }\n+              const_float(f) { const_uint(f as u64) }\n+            }\n+          }\n+          ty::ty_int(_) | ty::ty_bool {\n+            alt check base {\n+              const_uint(u) { const_int(u as i64) }\n+              const_int(_) { base }\n+              const_float(f) { const_int(f as i64) }\n+            }\n+          }\n+        }\n       }\n+      expr_lit(lit) { lit_to_const(lit) }\n     }\n }\n \n@@ -375,11 +394,13 @@ fn compare_const_vals(a: const_val, b: const_val) -> int {\n   }\n }\n \n-fn compare_lit_exprs(a: @expr, b: @expr) -> int {\n-  compare_const_vals(eval_const_expr(a), eval_const_expr(b))\n+fn compare_lit_exprs(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> int {\n+  compare_const_vals(eval_const_expr(tcx, a), eval_const_expr(tcx, b))\n }\n \n-fn lit_expr_eq(a: @expr, b: @expr) -> bool { compare_lit_exprs(a, b) == 0 }\n+fn lit_expr_eq(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> bool {\n+    compare_lit_exprs(tcx, a, b) == 0\n+}\n \n fn lit_eq(a: @lit, b: @lit) -> bool {\n     compare_const_vals(lit_to_const(a), lit_to_const(b)) == 0"}]}