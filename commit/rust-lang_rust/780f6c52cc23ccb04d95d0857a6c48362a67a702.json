{"sha": "780f6c52cc23ccb04d95d0857a6c48362a67a702", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MGY2YzUyY2MyM2NjYjA0ZDk1ZDA4NTdhNmM0ODM2MmE2N2E3MDI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-01T18:42:41Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-09T15:02:13Z"}, "message": "extract out `fully_perform_op_and_get_region_constraints`", "tree": {"sha": "b148de90bdcb8b43385143bc44049d6ecb3a7b1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b148de90bdcb8b43385143bc44049d6ecb3a7b1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/780f6c52cc23ccb04d95d0857a6c48362a67a702", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/780f6c52cc23ccb04d95d0857a6c48362a67a702", "html_url": "https://github.com/rust-lang/rust/commit/780f6c52cc23ccb04d95d0857a6c48362a67a702", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/780f6c52cc23ccb04d95d0857a6c48362a67a702/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ff89805fe3f1a481037d51383ae876dc1693177", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ff89805fe3f1a481037d51383ae876dc1693177", "html_url": "https://github.com/rust-lang/rust/commit/7ff89805fe3f1a481037d51383ae876dc1693177"}], "stats": {"total": 77, "additions": 57, "deletions": 20}, "files": [{"sha": "a8ae614d619fa6bfaca3cefa102fdee200b22665", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 57, "deletions": 20, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/780f6c52cc23ccb04d95d0857a6c48362a67a702/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f6c52cc23ccb04d95d0857a6c48362a67a702/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=780f6c52cc23ccb04d95d0857a6c48362a67a702", "patch": "@@ -712,21 +712,65 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         traits::ObligationCause::misc(span, self.body_id)\n     }\n \n-    #[inline(never)]\n-    fn fully_perform_op<OP, R>(\n+    /// Given some operation `op` that manipulates types, proves\n+    /// predicates, or otherwise uses the inference context, executes\n+    /// `op` and then executes all the further obligations that `op`\n+    /// returns. This will yield a set of outlives constraints amongst\n+    /// regions which are extracted and stored as having occured at\n+    /// `locations`.\n+    ///\n+    /// **Any `rustc::infer` operations that might generate region\n+    /// constraints should occur within this method so that those\n+    /// constraints can be properly localized!**\n+    fn fully_perform_op<R>(\n         &mut self,\n         locations: Locations,\n         describe_op: impl Fn() -> String,\n-        op: OP,\n-    ) -> Result<R, TypeError<'tcx>>\n-    where\n-        OP: FnOnce(&mut Self) -> InferResult<'tcx, R>,\n-    {\n+        op: impl FnOnce(&mut Self) -> InferResult<'tcx, R>,\n+    ) -> Result<R, TypeError<'tcx>> {\n+        let (r, opt_data) = self.fully_perform_op_and_get_region_constraint_data(\n+            || format!(\"{} at {:?}\", describe_op(), locations),\n+            op,\n+        )?;\n+\n+        if let Some(data) = opt_data {\n+            self.push_region_constraints(locations, data);\n+        }\n+\n+        Ok(r)\n+    }\n+\n+    fn push_region_constraints(\n+        &mut self,\n+        locations: Locations,\n+        data: Rc<RegionConstraintData<'tcx>>,\n+    ) {\n+        debug!(\n+            \"push_region_constraints: constraints generated at {:?} are {:#?}\",\n+            locations, data\n+        );\n+\n+        self.constraints\n+            .outlives_sets\n+            .push(OutlivesSet { locations, data });\n+    }\n+\n+    /// Helper for `fully_perform_op`, but also used on its own\n+    /// sometimes to enable better caching: executes `op` fully (along\n+    /// with resulting obligations) and returns the full set of region\n+    /// obligations. If the same `op` were to be performed at some\n+    /// other location, then the same set of region obligations would\n+    /// be generated there, so this can be useful for caching.\n+    #[inline(never)]\n+    fn fully_perform_op_and_get_region_constraint_data<R>(\n+        &mut self,\n+        describe_op: impl Fn() -> String,\n+        op: impl FnOnce(&mut Self) -> InferResult<'tcx, R>,\n+    ) -> Result<(R, Option<Rc<RegionConstraintData<'tcx>>>), TypeError<'tcx>> {\n         if cfg!(debug_assertions) {\n             info!(\n-                \"fully_perform_op(describe_op={}) at {:?}\",\n+                \"fully_perform_op_and_get_region_constraint_data({})\",\n                 describe_op(),\n-                locations\n             );\n         }\n \n@@ -745,18 +789,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         );\n \n         let data = self.infcx.take_and_reset_region_constraints();\n-        if !data.is_empty() {\n-            debug!(\n-                \"fully_perform_op: constraints generated at {:?} are {:#?}\",\n-                locations, data\n-            );\n-            let data = Rc::new(data);\n-            self.constraints\n-                .outlives_sets\n-                .push(OutlivesSet { locations, data });\n+        if data.is_empty() {\n+            Ok((value, None))\n+        } else {\n+            Ok((value, Some(Rc::new(data))))\n         }\n-\n-        Ok(value)\n     }\n \n     #[inline(never)]"}]}