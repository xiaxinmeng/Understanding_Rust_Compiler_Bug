{"sha": "75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1NjgxZjlhZDdhNmI3OWM1YTM0ZmQ4MGM5NWMyMjI1OGUzMGRkYjU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-19T20:41:21Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-20T21:53:28Z"}, "message": "Get rid of def_ids and anns in AST nodes, use single node_id\n\nThis reduces some redundancy in the AST data structures and cruft in\nthe code that works with them. To get a def_id from a node_id, apply\nast::local_def, which adds the local crate_num to the given node_id.\nMost code only deals with crate-local node_ids, and won't have to\ncreate def_ids at all.", "tree": {"sha": "53a7bfddff8a8b8c5ba22b8bcaeb60b3c680b443", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53a7bfddff8a8b8c5ba22b8bcaeb60b3c680b443"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "html_url": "https://github.com/rust-lang/rust/commit/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d8a5cb9e67d0e38d2062bd7685aa5514305dfc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d8a5cb9e67d0e38d2062bd7685aa5514305dfc6", "html_url": "https://github.com/rust-lang/rust/commit/3d8a5cb9e67d0e38d2062bd7685aa5514305dfc6"}], "stats": {"total": 3013, "additions": 1539, "deletions": 1474}, "files": [{"sha": "f5f79fb0a2a65c8ec4cbda68720cd40527afbe97", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -76,8 +76,7 @@ fn time[T](bool do_it, str what, fn() -> T  thunk) -> T {\n fn compile_input(session::session sess, eval::env env, str input,\n                  str output) {\n     auto time_passes = sess.get_opts().time_passes;\n-    auto def = tup(ast::local_crate, 0);\n-    auto p = parser::new_parser(sess, env, def, input, 0u, 0u);\n+    auto p = parser::new_parser(sess, env, input, 0u, 0);\n     auto crate =\n         time(time_passes, \"parsing\", bind parse_input(sess, p, input));\n     if (sess.get_opts().output_type == link::output_type_none) { ret; }\n@@ -103,8 +102,7 @@ fn compile_input(session::session sess, eval::env env, str input,\n \n fn pretty_print_input(session::session sess, eval::env env, str input,\n                       pp_mode ppm) {\n-    auto def = tup(ast::local_crate, 0);\n-    auto p = front::parser::new_parser(sess, env, def, input, 0u, 0u);\n+    auto p = front::parser::new_parser(sess, env, input, 0u, 0);\n     auto crate = parse_input(sess, p, input);\n     auto mode;\n     alt (ppm) {"}, {"sha": "c873f798f4711fad9440d61c5d3b14f4645a5f53", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 78, "deletions": 84, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -16,17 +16,16 @@ type path = spanned[path_];\n fn path_name(&path p) -> str { ret str::connect(p.node.idents, \"::\"); }\n \n type crate_num = int;\n+type node_id = int;\n+type def_id = tup(crate_num, node_id);\n \n const crate_num local_crate = 0;\n-\n-type def_num = int;\n-\n-type def_id = tup(crate_num, def_num);\n+fn local_def(node_id id) -> def_id {\n+    ret tup(local_crate, id);\n+}\n \n type ty_param = ident;\n \n-type ann = rec(uint id);\n-\n tag def {\n     def_fn(def_id);\n     def_obj(def_id);\n@@ -102,15 +101,15 @@ type meta_item_ = rec(ident key, str value);\n \n type block = spanned[block_];\n \n-type block_ = rec(vec[@stmt] stmts, option::t[@expr] expr, ann a);\n+type block_ = rec(vec[@stmt] stmts, option::t[@expr] expr, node_id id);\n \n type pat = spanned[pat_];\n \n tag pat_ {\n-    pat_wild(ann);\n-    pat_bind(ident, def_id, ann);\n-    pat_lit(@lit, ann);\n-    pat_tag(path, vec[@pat], ann);\n+    pat_wild(node_id);\n+    pat_bind(ident, node_id);\n+    pat_lit(@lit, node_id);\n+    pat_tag(path, vec[@pat], node_id);\n }\n \n tag mutability { mut; imm; maybe_mut; }\n@@ -183,8 +182,8 @@ tag mode { val; alias(bool); }\n type stmt = spanned[stmt_];\n \n tag stmt_ {\n-    stmt_decl(@decl, ann);\n-    stmt_expr(@expr, ann);\n+    stmt_decl(@decl, node_id);\n+    stmt_expr(@expr, node_id);\n \n     // These only exist in crate-level blocks.\n     stmt_crate_directive(@crate_directive);\n@@ -199,8 +198,7 @@ type local_ =\n         bool infer,\n         ident ident,\n         option::t[initializer] init,\n-        def_id id,\n-        ann ann);\n+        node_id id);\n \n type local = spanned[local_];\n \n@@ -225,58 +223,58 @@ tag seq_kind { sk_unique; sk_rc; }\n type expr = spanned[expr_];\n \n tag expr_ {\n-    expr_vec(vec[@expr], mutability, seq_kind, ann);\n-    expr_tup(vec[elt], ann);\n-    expr_rec(vec[field], option::t[@expr], ann);\n-    expr_call(@expr, vec[@expr], ann);\n-    expr_self_method(ident, ann);\n-    expr_bind(@expr, vec[option::t[@expr]], ann);\n-    expr_spawn(spawn_dom, option::t[str], @expr, vec[@expr], ann);\n-    expr_binary(binop, @expr, @expr, ann);\n-    expr_unary(unop, @expr, ann);\n-    expr_lit(@lit, ann);\n-    expr_cast(@expr, @ty, ann);\n-    expr_if(@expr, block, option::t[@expr], ann);\n-    expr_while(@expr, block, ann);\n-    expr_for(@local, @expr, block, ann);\n-    expr_for_each(@local, @expr, block, ann);\n-    expr_do_while(block, @expr, ann);\n-    expr_alt(@expr, vec[arm], ann);\n-    expr_fn(_fn, ann);\n-    expr_block(block, ann);\n+    expr_vec(vec[@expr], mutability, seq_kind, node_id);\n+    expr_tup(vec[elt], node_id);\n+    expr_rec(vec[field], option::t[@expr], node_id);\n+    expr_call(@expr, vec[@expr], node_id);\n+    expr_self_method(ident, node_id);\n+    expr_bind(@expr, vec[option::t[@expr]], node_id);\n+    expr_spawn(spawn_dom, option::t[str], @expr, vec[@expr], node_id);\n+    expr_binary(binop, @expr, @expr, node_id);\n+    expr_unary(unop, @expr, node_id);\n+    expr_lit(@lit, node_id);\n+    expr_cast(@expr, @ty, node_id);\n+    expr_if(@expr, block, option::t[@expr], node_id);\n+    expr_while(@expr, block, node_id);\n+    expr_for(@local, @expr, block, node_id);\n+    expr_for_each(@local, @expr, block, node_id);\n+    expr_do_while(block, @expr, node_id);\n+    expr_alt(@expr, vec[arm], node_id);\n+    expr_fn(_fn, node_id);\n+    expr_block(block, node_id);\n     /*\n      * FIXME: many of these @exprs should be constrained with\n      * is_lval once we have constrained types working.\n      */\n-    expr_move(@expr, @expr, ann);\n-    expr_assign(@expr,@expr, ann);\n-    expr_swap(@expr, @expr, ann);\n-    expr_assign_op(binop, @expr, @expr, ann);\n-    expr_send(@expr, @expr, ann);\n-    expr_recv(@expr, @expr, ann);\n-    expr_field(@expr, ident, ann);\n-    expr_index(@expr, @expr, ann);\n-    expr_path(path, ann);\n-    expr_ext(path, vec[@expr], option::t[str], @expr, ann);\n-    expr_fail(ann, option::t[str]);\n-    expr_break(ann);\n-    expr_cont(ann);\n-    expr_ret(option::t[@expr], ann);\n-    expr_put(option::t[@expr], ann);\n-    expr_be(@expr, ann);\n-    expr_log(int, @expr, ann);\n+    expr_move(@expr, @expr, node_id);\n+    expr_assign(@expr,@expr, node_id);\n+    expr_swap(@expr, @expr, node_id);\n+    expr_assign_op(binop, @expr, @expr, node_id);\n+    expr_send(@expr, @expr, node_id);\n+    expr_recv(@expr, @expr, node_id);\n+    expr_field(@expr, ident, node_id);\n+    expr_index(@expr, @expr, node_id);\n+    expr_path(path, node_id);\n+    expr_ext(path, vec[@expr], option::t[str], @expr, node_id);\n+    expr_fail(node_id, option::t[str]);\n+    expr_break(node_id);\n+    expr_cont(node_id);\n+    expr_ret(option::t[@expr], node_id);\n+    expr_put(option::t[@expr], node_id);\n+    expr_be(@expr, node_id);\n+    expr_log(int, @expr, node_id);\n \n     /* just an assert, no significance to typestate */\n-    expr_assert(@expr, ann);\n+    expr_assert(@expr, node_id);\n \n     /* preds that typestate is aware of */\n-    expr_check(@expr, ann);\n+    expr_check(@expr, node_id);\n    /* FIXME Would be nice if expr_check desugared\n       to expr_if_check. */\n-    expr_if_check(@expr, block, option::t[@expr], ann);\n-    expr_port(ann);\n-    expr_chan(@expr, ann);\n-    expr_anon_obj(anon_obj, vec[ty_param], obj_def_ids, ann);\n+    expr_if_check(@expr, block, option::t[@expr], node_id);\n+    expr_port(node_id);\n+    expr_chan(@expr, node_id);\n+    expr_anon_obj(anon_obj, vec[ty_param], obj_def_ids, node_id);\n }\n \n type lit = spanned[lit_];\n@@ -348,7 +346,7 @@ tag ty_ {\n     ty_rec(vec[ty_field]);\n     ty_fn(proto, vec[ty_arg], @ty, controlflow, vec[@constr]);\n     ty_obj(vec[ty_method]);\n-    ty_path(path, ann);\n+    ty_path(path, node_id);\n     ty_type;\n     ty_constr(@ty, vec[@constr]);\n }\n@@ -368,15 +366,17 @@ type constr_arg = constr_arg_general[uint];\n \n type constr_arg_general[T] = spanned[constr_arg_general_[T]];\n \n-type constr_ = rec(path path, vec[@constr_arg_general[uint]] args, ann ann);\n+type constr_ = rec(path path,\n+                   vec[@constr_arg_general[uint]] args,\n+                   node_id id);\n \n type constr = spanned[constr_];\n \n \n /* The parser generates ast::constrs; resolve generates\n  a mapping from each function to a list of ty::constr_defs,\n  corresponding to these. */\n-type arg = rec(mode mode, @ty ty, ident ident, def_id id);\n+type arg = rec(mode mode, @ty ty, ident ident, node_id id);\n \n type fn_decl =\n     rec(vec[arg] inputs,\n@@ -402,11 +402,11 @@ tag controlflow {\n \n type _fn = rec(fn_decl decl, proto proto, block body);\n \n-type method_ = rec(ident ident, _fn meth, def_id id, ann ann);\n+type method_ = rec(ident ident, _fn meth, node_id id);\n \n type method = spanned[method_];\n \n-type obj_field = rec(mutability mut, @ty ty, ident ident, def_id id, ann ann);\n+type obj_field = rec(mutability mut, @ty ty, ident ident, node_id id);\n \n type _obj =\n     rec(vec[obj_field] fields, vec[@method] methods, option::t[@method] dtor);\n@@ -435,22 +435,22 @@ type native_mod =\n         vec[@view_item] view_items,\n         vec[@native_item] items);\n \n-type variant_arg = rec(@ty ty, def_id id);\n+type variant_arg = rec(@ty ty, node_id id);\n \n-type variant_ = rec(str name, vec[variant_arg] args, def_id id, ann ann);\n+type variant_ = rec(str name, vec[variant_arg] args, node_id id);\n \n type variant = spanned[variant_];\n \n type view_item = spanned[view_item_];\n \n tag view_item_ {\n-    view_item_use(ident, vec[@meta_item], def_id, ann);\n-    view_item_import(ident, vec[ident], def_id);\n-    view_item_import_glob(vec[ident], def_id);\n-    view_item_export(ident);\n+    view_item_use(ident, vec[@meta_item], node_id);\n+    view_item_import(ident, vec[ident], node_id);\n+    view_item_import_glob(vec[ident], node_id);\n+    view_item_export(ident, node_id);\n }\n \n-type obj_def_ids = rec(def_id ty, def_id ctor);\n+type obj_def_ids = rec(node_id ty, node_id ctor);\n \n \n // Meta-data associated with an item\n@@ -464,14 +464,11 @@ tag attr_style { attr_outer; attr_inner; }\n \n type attribute_ = rec(attr_style style, meta_item value);\n \n-type item =\n-    rec(ident ident,\n-        vec[attribute] attrs,\n-        def_id id, // For objs, this is the type def_id\n-\n-        ann ann,\n-        item_ node,\n-        span span);\n+type item = rec(ident ident,\n+                vec[attribute] attrs,\n+                node_id id, // For objs, this is the type's def_id\n+                item_ node,\n+                span span);\n \n tag item_ {\n     item_const(@ty, @expr);\n@@ -480,21 +477,18 @@ tag item_ {\n     item_native_mod(native_mod);\n     item_ty(@ty, vec[ty_param]);\n     item_tag(vec[variant], vec[ty_param]);\n-    item_obj(_obj, vec[ty_param], def_id);\n-    /* constructor id */\n-\n+    item_obj(_obj, vec[ty_param], node_id /* constructor id */);\n }\n \n type native_item = spanned[native_item_];\n \n tag native_item_ {\n-    native_item_ty(ident, def_id);\n+    native_item_ty(ident, node_id);\n     native_item_fn(ident,\n                    option::t[str],\n                    fn_decl,\n                    vec[ty_param],\n-                   def_id,\n-                   ann);\n+                   node_id);\n }\n \n fn is_exported(ident i, _mod m) -> bool {\n@@ -514,7 +508,7 @@ fn is_exported(ident i, _mod m) -> bool {\n     auto count = 0u;\n     for (@ast::view_item vi in m.view_items) {\n         alt (vi.node) {\n-            case (ast::view_item_export(?id)) {\n+            case (ast::view_item_export(?id, _)) {\n                 if (str::eq(i, id)) {\n                     // even if it's nonlocal (since it's explicit)\n "}, {"sha": "f118775d3f8b4dc0207acdbdcda180d8ccbbfc83", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -359,8 +359,8 @@ fn parse_def_id(vec[u8] buf) -> ast::def_id {\n     auto crate_part = vec::slice[u8](buf, 0u, colon_idx);\n     auto def_part = vec::slice[u8](buf, colon_idx + 1u, len);\n     auto crate_num = uint::parse_buf(crate_part, 10u) as int;\n-    auto def_num = uint::parse_buf(def_part, 10u) as int;\n-    ret tup(crate_num, def_num);\n+    auto def_id = uint::parse_buf(def_part, 10u) as int;\n+    ret tup(crate_num, def_id);\n }\n \n fn lookup_hash(&ebml::doc d, fn(vec[u8]) -> bool  eq_fn, uint hash) ->\n@@ -407,7 +407,7 @@ fn maybe_find_item(int item_id, &ebml::doc items) -> option::t[ebml::doc] {\n         ret ebml::be_uint_from_bytes(bytes, 0u, 4u) as int == item_id;\n     }\n     auto eqer = bind eq_item(_, item_id);\n-    auto found = lookup_hash(items, eqer, metadata::hash_def_num(item_id));\n+    auto found = lookup_hash(items, eqer, metadata::hash_def_id(item_id));\n     if (vec::len(found) == 0u) {\n         ret option::none[ebml::doc];\n     } else { ret option::some[ebml::doc](found.(0)); }\n@@ -606,7 +606,7 @@ type env =\n \n fn visit_view_item(env e, &@ast::view_item i) {\n     alt (i.node) {\n-        case (ast::view_item_use(?ident, ?meta_items, ?id, ?ann)) {\n+        case (ast::view_item_use(?ident, ?meta_items, ?id)) {\n             auto cnum;\n             if (!e.crate_cache.contains_key(ident)) {\n                 cnum = e.next_crate_num;\n@@ -615,7 +615,7 @@ fn visit_view_item(env e, &@ast::view_item i) {\n                 e.crate_cache.insert(ident, e.next_crate_num);\n                 e.next_crate_num += 1;\n             } else { cnum = e.crate_cache.get(ident); }\n-            e.crate_map.insert(ann.id, cnum);\n+            e.crate_map.insert(id, cnum);\n         }\n         case (_) { }\n     }"}, {"sha": "1de0688d488da425d973c438c1e32560ff827b61", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -31,7 +31,7 @@ type ctx =\n          mutable vec[str] deps,\n          session::session sess,\n          mutable uint chpos,\n-         mutable uint next_ann);\n+         mutable int next_id);\n \n fn mk_env() -> env { ret []; }\n \n@@ -287,33 +287,31 @@ fn eval_crate_directive(ctx cx, env e, @ast::crate_directive cdir, str prefix,\n             }\n             auto full_path = prefix + std::fs::path_sep() + file_path;\n             if (cx.mode == mode_depend) { cx.deps += [full_path]; ret; }\n-            auto start_id = cx.p.next_def_id();\n             auto p0 =\n-                new_parser(cx.sess, e, start_id, full_path, cx.chpos,\n-                           cx.next_ann);\n+                new_parser(cx.sess, e, full_path, cx.chpos,\n+                           cx.next_id);\n             auto inner_attrs = parse_inner_attrs_and_next(p0);\n             auto first_item_outer_attrs = inner_attrs._1;\n-            auto m0 = parse_mod_items(p0, token::EOF,\n-                                      first_item_outer_attrs);\n-            auto next_id = p0.next_def_id();\n-            // Thread defids and chpos through the parsers\n+            auto m0 = parse_mod_items(p0, token::EOF, first_item_outer_attrs);\n \n-            cx.p.set_def(next_id._1);\n+            auto i = front::parser::mk_item(p0, cdir.span.lo, cdir.span.hi,\n+                                            id, ast::item_mod(m0), []);\n+            // Thread defids and chpos through the parsers\n             cx.chpos = p0.get_chpos();\n-            cx.next_ann = p0.next_ann_num();\n-            auto i = front::parser::mk_item(cx.p, cdir.span.lo, cdir.span.hi,\n-                                            id, ast::item_mod(m0),\n-                                            inner_attrs._0);\n+            cx.next_id = p0.next_id();\n             vec::push[@ast::item](items, i);\n         }\n         case (ast::cdir_dir_mod(?id, ?dir_opt, ?cdirs)) {\n             auto path = id;\n             alt (dir_opt) { case (some(?d)) { path = d; } case (none) { } }\n             auto full_path = prefix + std::fs::path_sep() + path;\n             auto m0 = eval_crate_directives_to_mod(cx, e, cdirs, full_path);\n-            auto i =\n-                front::parser::mk_item(cx.p, cdir.span.lo, cdir.span.hi, id,\n-                                       ast::item_mod(m0), []);\n+            auto i = @rec(ident=id,\n+                          attrs=[],\n+                          id=cx.next_id,\n+                          node=ast::item_mod(m0),\n+                          span=cdir.span);\n+            cx.next_id += 1;\n             vec::push[@ast::item](items, i);\n         }\n         case (ast::cdir_view_item(?vi)) {"}, {"sha": "d300febbc45bb263cce67d3497f6803798b1d994", "filename": "src/comp/front/ext.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Ffront%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Ffront%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fext.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -25,15 +25,15 @@ fn syntax_expander_table() -> hashmap[str, syntax_extension] {\n \n type span_msg_fn = fn(span, str) -> !  ;\n \n-type next_ann_fn = fn() -> ast::ann ;\n+type next_id_fn = fn() -> ast::node_id ;\n \n \n // Provides a limited set of services necessary for syntax extensions\n // to do their thing\n type ext_ctxt =\n     rec(span_msg_fn span_fatal,\n         span_msg_fn span_unimpl,\n-        next_ann_fn next_ann);\n+        next_id_fn next_id);\n \n fn mk_ctxt(parser parser) -> ext_ctxt {\n     auto sess = parser.get_session();\n@@ -45,11 +45,11 @@ fn mk_ctxt(parser parser) -> ext_ctxt {\n         sess.span_unimpl(sp, msg);\n     }\n     auto ext_span_unimpl = bind ext_span_unimpl_(sess, _, _);\n-    fn ext_next_ann_(parser parser) -> ast::ann { parser.get_ann() }\n-    auto ext_next_ann = bind ext_next_ann_(parser);\n+    fn ext_next_id_(parser parser) -> ast::node_id { parser.get_id() }\n+    auto ext_next_id = bind ext_next_id_(parser);\n     ret rec(span_fatal=ext_span_fatal,\n             span_unimpl=ext_span_unimpl,\n-            next_ann=ext_next_ann);\n+            next_id=ext_next_id);\n }\n //\n // Local Variables:"}, {"sha": "b85a54a8d9b0bcb2c81f1ff38a38daaa6d6bdad8", "filename": "src/comp/front/extenv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Ffront%2Fextenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Ffront%2Fextenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextenv.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -44,7 +44,7 @@ fn expr_to_str(&ext_ctxt cx, @ast::expr expr) -> str {\n \n fn make_new_lit(&ext_ctxt cx, common::span sp, ast::lit_ lit) -> @ast::expr {\n     auto sp_lit = @rec(node=lit, span=sp);\n-    auto expr = ast::expr_lit(sp_lit, cx.next_ann());\n+    auto expr = ast::expr_lit(sp_lit, cx.next_id());\n     ret @rec(node=expr, span=sp);\n }\n "}, {"sha": "42f712feefc6fb5c1c8812ea4ccfb7dd2b4f2d63", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -56,7 +56,7 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n     fn make_new_lit(&ext_ctxt cx, common::span sp, ast::lit_ lit) ->\n        @ast::expr {\n         auto sp_lit = @rec(node=lit, span=sp);\n-        auto expr = ast::expr_lit(sp_lit, cx.next_ann());\n+        auto expr = ast::expr_lit(sp_lit, cx.next_id());\n         ret @rec(node=expr, span=sp);\n     }\n     fn make_new_str(&ext_ctxt cx, common::span sp, str s) -> @ast::expr {\n@@ -73,29 +73,29 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n     }\n     fn make_add_expr(&ext_ctxt cx, common::span sp, @ast::expr lhs,\n                      @ast::expr rhs) -> @ast::expr {\n-        auto binexpr = ast::expr_binary(ast::add, lhs, rhs, cx.next_ann());\n+        auto binexpr = ast::expr_binary(ast::add, lhs, rhs, cx.next_id());\n         ret @rec(node=binexpr, span=sp);\n     }\n     fn make_path_expr(&ext_ctxt cx, common::span sp, vec[ast::ident] idents)\n        -> @ast::expr {\n         let vec[@ast::ty] types = [];\n         auto path = rec(idents=idents, types=types);\n         auto sp_path = rec(node=path, span=sp);\n-        auto pathexpr = ast::expr_path(sp_path, cx.next_ann());\n+        auto pathexpr = ast::expr_path(sp_path, cx.next_id());\n         auto sp_pathexpr = @rec(node=pathexpr, span=sp);\n         ret sp_pathexpr;\n     }\n     fn make_vec_expr(&ext_ctxt cx, common::span sp, vec[@ast::expr] exprs) ->\n        @ast::expr {\n         auto vecexpr =\n-            ast::expr_vec(exprs, ast::imm, ast::sk_rc, cx.next_ann());\n+            ast::expr_vec(exprs, ast::imm, ast::sk_rc, cx.next_id());\n         auto sp_vecexpr = @rec(node=vecexpr, span=sp);\n         ret sp_vecexpr;\n     }\n     fn make_call(&ext_ctxt cx, common::span sp, vec[ast::ident] fn_path,\n                  vec[@ast::expr] args) -> @ast::expr {\n         auto pathexpr = make_path_expr(cx, sp, fn_path);\n-        auto callexpr = ast::expr_call(pathexpr, args, cx.next_ann());\n+        auto callexpr = ast::expr_call(pathexpr, args, cx.next_id());\n         auto sp_callexpr = @rec(node=callexpr, span=sp);\n         ret sp_callexpr;\n     }\n@@ -110,7 +110,7 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n             astfields += [astfield];\n         }\n         auto recexpr =\n-            ast::expr_rec(astfields, option::none[@ast::expr], cx.next_ann());\n+            ast::expr_rec(astfields, option::none[@ast::expr], cx.next_id());\n         auto sp_recexpr = @rec(node=recexpr, span=sp);\n         ret sp_recexpr;\n     }"}, {"sha": "b3366298e987a948b1b3cc7a5f37e5b6c6bc7db8", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 98, "deletions": 110, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -38,34 +38,30 @@ type parser =\n         fn get_lo_pos() -> uint ;\n         fn get_hi_pos() -> uint ;\n         fn get_last_lo_pos() -> uint ;\n-        fn next_def_id() -> ast::def_id ;\n-        fn set_def(ast::def_num) ;\n         fn get_prec_table() -> vec[op_spec] ;\n         fn get_str(token::str_num) -> str ;\n         fn get_reader() -> lexer::reader ;\n         fn get_filemap() -> codemap::filemap ;\n         fn get_bad_expr_words() -> hashmap[str, ()] ;\n         fn get_syntax_expanders() -> hashmap[str, ext::syntax_extension] ;\n         fn get_chpos() -> uint ;\n-        fn get_ann() -> ast::ann ;\n-        fn next_ann_num() -> uint ;\n+        fn get_id() -> ast::node_id ;\n+        fn next_id() -> ast::node_id ;\n     };\n \n-fn new_parser(session::session sess, eval::env env, ast::def_id initial_def,\n-              str path, uint pos, uint next_ann) -> parser {\n+fn new_parser(session::session sess, eval::env env,\n+              str path, uint pos, ast::node_id next_id) -> parser {\n     obj stdio_parser(session::session sess,\n                      eval::env env,\n                      file_type ftype,\n                      mutable token::token tok,\n                      mutable uint lo,\n                      mutable uint hi,\n                      mutable uint last_lo,\n-                     mutable ast::def_num def,\n                      mutable restriction res,\n-                     ast::crate_num crate,\n                      lexer::reader rdr,\n                      vec[op_spec] precs,\n-                     mutable uint next_ann_var,\n+                     mutable ast::node_id next_id_var,\n                      hashmap[str, ()] bad_words,\n                      hashmap[str, ext::syntax_extension] syntax_expanders) {\n         fn peek() -> token::token { ret tok; }\n@@ -86,8 +82,6 @@ fn new_parser(session::session sess, eval::env env, ast::def_id initial_def,\n         fn get_lo_pos() -> uint { ret lo; }\n         fn get_hi_pos() -> uint { ret hi; }\n         fn get_last_lo_pos() -> uint { ret last_lo; }\n-        fn next_def_id() -> ast::def_id { def += 1; ret tup(crate, def); }\n-        fn set_def(ast::def_num d) { def = d; }\n         fn get_file_type() -> file_type { ret ftype; }\n         fn get_env() -> eval::env { ret env; }\n         fn get_prec_table() -> vec[op_spec] { ret precs; }\n@@ -101,12 +95,12 @@ fn new_parser(session::session sess, eval::env env, ast::def_id initial_def,\n             ret syntax_expanders;\n         }\n         fn get_chpos() -> uint { ret rdr.get_chpos(); }\n-        fn get_ann() -> ast::ann {\n-            auto rv = rec(id=next_ann_var);\n-            next_ann_var += 1u;\n+        fn get_id() -> ast::node_id {\n+            auto rv = next_id_var;\n+            next_id_var += 1;\n             ret rv;\n         }\n-        fn next_ann_num() -> uint { ret next_ann_var; }\n+        fn next_id() -> ast::node_id { ret next_id_var; }\n     }\n     auto ftype = SOURCE_FILE;\n     if (str::ends_with(path, \".rc\")) { ftype = CRATE_FILE; }\n@@ -120,8 +114,8 @@ fn new_parser(session::session sess, eval::env env, ast::def_id initial_def,\n     lexer::consume_whitespace_and_comments(rdr);\n     auto npos = rdr.get_chpos();\n     ret stdio_parser(sess, env, ftype, lexer::next_token(rdr), npos, npos,\n-                     npos, initial_def._1, UNRESTRICTED, initial_def._0, rdr,\n-                     prec_table(), next_ann, bad_expr_word_table(),\n+                     npos, UNRESTRICTED, rdr,\n+                     prec_table(), next_id, bad_expr_word_table(),\n                      ext::syntax_expander_table());\n }\n \n@@ -378,7 +372,7 @@ fn parse_ty_constr(&vec[ast::arg] fn_args, &parser p) -> @ast::constr {\n     // FIXME fix the def_id\n \n     ret @spanned(lo, args.span.hi,\n-                 rec(path=path, args=args.node, ann=p.get_ann()));\n+                 rec(path=path, args=args.node, id=p.get_id()));\n }\n \n \n@@ -576,7 +570,7 @@ fn parse_ty(&parser p) -> @ast::ty {\n         hi = typ.span.hi;\n     } else if (is_ident(p.peek())) {\n         auto path = parse_path(p);\n-        t = ast::ty_path(path, p.get_ann());\n+        t = ast::ty_path(path, p.get_id());\n         hi = path.span.hi;\n     } else { p.err(\"expecting type\"); t = ast::ty_nil; fail; }\n     ret parse_ty_postfix(@spanned(lo, hi, t), p);\n@@ -590,7 +584,7 @@ fn parse_arg(&parser p) -> ast::arg {\n     }\n     let @ast::ty t = parse_ty(p);\n     let ast::ident i = parse_value_ident(p);\n-    ret rec(mode=m, ty=t, ident=i, id=p.next_def_id());\n+    ret rec(mode=m, ty=t, ident=i, id=p.get_id());\n }\n \n fn parse_seq_to_end[T](token::token ket, option::t[token::token] sep,\n@@ -714,15 +708,15 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n     // alt-exhaustive-match checking are co-operating.\n \n     auto lit = @spanned(lo, hi, ast::lit_nil);\n-    let ast::expr_ ex = ast::expr_lit(lit, p.get_ann());\n+    let ast::expr_ ex = ast::expr_lit(lit, p.get_id());\n     if (p.peek() == token::LPAREN) {\n         p.bump();\n         alt (p.peek()) {\n             case (token::RPAREN) {\n                 hi = p.get_hi_pos();\n                 p.bump();\n                 auto lit = @spanned(lo, hi, ast::lit_nil);\n-                ret @spanned(lo, hi, ast::expr_lit(lit, p.get_ann()));\n+                ret @spanned(lo, hi, ast::expr_lit(lit, p.get_id()));\n             }\n             case (_) {/* fall through */ }\n         }\n@@ -733,7 +727,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n     } else if (p.peek() == token::LBRACE) {\n         auto blk = parse_block(p);\n         ret @spanned(blk.span.lo, blk.span.hi,\n-                     ast::expr_block(blk, p.get_ann()));\n+                     ast::expr_block(blk, p.get_id()));\n     } else if (eat_word(p, \"if\")) {\n         ret parse_if_expr(p);\n     } else if (eat_word(p, \"for\")) {\n@@ -758,14 +752,14 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                       parse_elt, p);\n         hi = es.span.hi;\n-        ex = ast::expr_tup(es.node, p.get_ann());\n+        ex = ast::expr_tup(es.node, p.get_id());\n     } else if (p.peek() == token::LBRACKET) {\n         p.bump();\n         auto mut = parse_mutability(p);\n         auto es =\n             parse_seq_to_end(token::RBRACKET, some(token::COMMA), parse_expr,\n                              p);\n-        ex = ast::expr_vec(es, mut, ast::sk_rc, p.get_ann());\n+        ex = ast::expr_vec(es, mut, ast::sk_rc, p.get_id());\n     } else if (p.peek() == token::TILDE) {\n         p.bump();\n         alt (p.peek()) {\n@@ -776,14 +770,14 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n                 auto es =\n                     parse_seq_to_end(token::RBRACKET, some(token::COMMA),\n                                      parse_expr, p);\n-                ex = ast::expr_vec(es, mut, ast::sk_unique, p.get_ann());\n+                ex = ast::expr_vec(es, mut, ast::sk_unique, p.get_id());\n             }\n             case (token::LIT_STR(?s)) {\n                 p.bump();\n                 auto lit =\n                     @rec(node=ast::lit_str(p.get_str(s), ast::sk_unique),\n                          span=p.get_span());\n-                ex = ast::expr_lit(lit, p.get_ann());\n+                ex = ast::expr_lit(lit, p.get_id());\n             }\n             case (_) {\n                 p.get_session().span_unimpl(p.get_span(),\n@@ -824,8 +818,8 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n \n         let ast::anon_obj ob =\n             rec(fields=fields, methods=meths, with_obj=with_obj);\n-        auto odid = rec(ty=p.next_def_id(), ctor=p.next_def_id());\n-        ex = ast::expr_anon_obj(ob, ty_params, odid, p.get_ann());\n+        auto odid = rec(ty=p.get_id(), ctor=p.get_id());\n+        ex = ast::expr_anon_obj(ob, ty_params, odid, p.get_id());\n     } else if (eat_word(p, \"rec\")) {\n         expect(p, token::LPAREN);\n         auto fields = [parse_field(p)];\n@@ -846,7 +840,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n                 fields += [parse_field(p)];\n             } else { unexpected(p, p.peek()); }\n         }\n-        ex = ast::expr_rec(fields, base, p.get_ann());\n+        ex = ast::expr_rec(fields, base, p.get_id());\n     } else if (eat_word(p, \"bind\")) {\n         auto e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n         fn parse_expr_opt(&parser p) -> option::t[@ast::expr] {\n@@ -859,7 +853,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                       parse_expr_opt, p);\n         hi = es.span.hi;\n-        ex = ast::expr_bind(e, es.node, p.get_ann());\n+        ex = ast::expr_bind(e, es.node, p.get_id());\n     } else if (p.peek() == token::POUND) {\n         auto ex_ext = parse_syntax_ext(p);\n         lo = ex_ext.span.lo;\n@@ -870,47 +864,47 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             case (token::LIT_STR(?s)) { msg = some(p.get_str(s)); p.bump(); }\n             case (_) { msg = none; }\n         }\n-        ex = ast::expr_fail(p.get_ann(), msg);\n+        ex = ast::expr_fail(p.get_id(), msg);\n     } else if (eat_word(p, \"log\")) {\n         auto e = parse_expr(p);\n         auto hi = e.span.hi;\n-        ex = ast::expr_log(1, e, p.get_ann());\n+        ex = ast::expr_log(1, e, p.get_id());\n     } else if (eat_word(p, \"log_err\")) {\n         auto e = parse_expr(p);\n         auto hi = e.span.hi;\n-        ex = ast::expr_log(0, e, p.get_ann());\n+        ex = ast::expr_log(0, e, p.get_id());\n     } else if (eat_word(p, \"assert\")) {\n         auto e = parse_expr(p);\n         auto hi = e.span.hi;\n-        ex = ast::expr_assert(e, p.get_ann());\n+        ex = ast::expr_assert(e, p.get_id());\n     } else if (eat_word(p, \"check\")) {\n         /* Should be a predicate (pure boolean function) applied to \n            arguments that are all either slot variables or literals.\n            but the typechecker enforces that. */\n \n         auto e = parse_expr(p);\n         auto hi = e.span.hi;\n-        ex = ast::expr_check(e, p.get_ann());\n+        ex = ast::expr_check(e, p.get_id());\n     } else if (eat_word(p, \"ret\")) {\n         alt (p.peek()) {\n-            case (token::SEMI) { ex = ast::expr_ret(none, p.get_ann()); }\n+            case (token::SEMI) { ex = ast::expr_ret(none, p.get_id()); }\n             case (_) {\n                 auto e = parse_expr(p);\n                 hi = e.span.hi;\n-                ex = ast::expr_ret(some(e), p.get_ann());\n+                ex = ast::expr_ret(some(e), p.get_id());\n             }\n         }\n     } else if (eat_word(p, \"break\")) {\n-        ex = ast::expr_break(p.get_ann());\n+        ex = ast::expr_break(p.get_id());\n     } else if (eat_word(p, \"cont\")) {\n-        ex = ast::expr_cont(p.get_ann());\n+        ex = ast::expr_cont(p.get_id());\n     } else if (eat_word(p, \"put\")) {\n         alt (p.peek()) {\n-            case (token::SEMI) { ex = ast::expr_put(none, p.get_ann()); }\n+            case (token::SEMI) { ex = ast::expr_put(none, p.get_id()); }\n             case (_) {\n                 auto e = parse_expr(p);\n                 hi = e.span.hi;\n-                ex = ast::expr_put(some(e), p.get_ann());\n+                ex = ast::expr_put(some(e), p.get_id());\n             }\n         }\n     } else if (eat_word(p, \"be\")) {\n@@ -919,19 +913,19 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         // FIXME: Is this the right place for this check?\n         if (/*check*/ast::is_call_expr(e)) {\n             hi = e.span.hi;\n-            ex = ast::expr_be(e, p.get_ann());\n+            ex = ast::expr_be(e, p.get_id());\n         } else { p.err(\"Non-call expression in tail call\"); }\n     } else if (eat_word(p, \"port\")) {\n         expect(p, token::LPAREN);\n         expect(p, token::RPAREN);\n         hi = p.get_hi_pos();\n-        ex = ast::expr_port(p.get_ann());\n+        ex = ast::expr_port(p.get_id());\n     } else if (eat_word(p, \"chan\")) {\n         expect(p, token::LPAREN);\n         auto e = parse_expr(p);\n         hi = e.span.hi;\n         expect(p, token::RPAREN);\n-        ex = ast::expr_chan(e, p.get_ann());\n+        ex = ast::expr_chan(e, p.get_id());\n     } else if (eat_word(p, \"self\")) {\n         log \"parsing a self-call...\";\n         expect(p, token::DOT);\n@@ -942,17 +936,17 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                       parse_expr, p);\n         hi = es.span.hi;\n-        ex = ast::expr_call(f, es.node, p.get_ann());\n+        ex = ast::expr_call(f, es.node, p.get_id());\n     } else if (is_ident(p.peek()) && !is_word(p, \"true\") &&\n                    !is_word(p, \"false\")) {\n         check_bad_word(p);\n         auto pth = parse_path_and_ty_param_substs(p);\n         hi = pth.span.hi;\n-        ex = ast::expr_path(pth, p.get_ann());\n+        ex = ast::expr_path(pth, p.get_id());\n     } else {\n         auto lit = parse_lit(p);\n         hi = lit.span.hi;\n-        ex = ast::expr_lit(@lit, p.get_ann());\n+        ex = ast::expr_lit(@lit, p.get_id());\n     }\n     ret @spanned(lo, hi, ex);\n }\n@@ -989,7 +983,7 @@ fn expand_syntax_ext(&parser p, common::span sp, &ast::path path,\n         case (some(ext::x(?ext))) {\n             auto ext_cx = ext::mk_ctxt(p);\n             ret ast::expr_ext(path, args, body, ext(ext_cx, sp, args, body),\n-                              p.get_ann());\n+                              p.get_id());\n         }\n     }\n }\n@@ -998,7 +992,7 @@ fn parse_self_method(&parser p) -> @ast::expr {\n     auto sp = p.get_span();\n     let ast::ident f_name = parse_ident(p);\n     auto hi = p.get_span();\n-    ret @rec(node=ast::expr_self_method(f_name, p.get_ann()), span=sp);\n+    ret @rec(node=ast::expr_self_method(f_name, p.get_id()), span=sp);\n }\n \n fn parse_dot_or_call_expr(&parser p) -> @ast::expr {\n@@ -1020,7 +1014,7 @@ fn parse_dot_or_call_expr_with(&parser p, @ast::expr e) -> @ast::expr {\n                         parse_seq(token::LPAREN, token::RPAREN,\n                                   some(token::COMMA), parse_expr, p);\n                     hi = es.span.hi;\n-                    auto e_ = ast::expr_call(e, es.node, p.get_ann());\n+                    auto e_ = ast::expr_call(e, es.node, p.get_id());\n                     e = @spanned(lo, hi, e_);\n                 }\n             }\n@@ -1031,15 +1025,15 @@ fn parse_dot_or_call_expr_with(&parser p, @ast::expr e) -> @ast::expr {\n                         hi = p.get_hi_pos();\n                         p.bump();\n                         auto e_ =\n-                            ast::expr_field(e, p.get_str(i), p.get_ann());\n+                            ast::expr_field(e, p.get_str(i), p.get_id());\n                         e = @spanned(lo, hi, e_);\n                     }\n                     case (token::LPAREN) {\n                         p.bump();\n                         auto ix = parse_expr(p);\n                         hi = ix.span.hi;\n                         expect(p, token::RPAREN);\n-                        auto e_ = ast::expr_index(e, ix, p.get_ann());\n+                        auto e_ = ast::expr_index(e, ix, p.get_id());\n                         e = @spanned(lo, hi, e_);\n                     }\n                     case (?t) { unexpected(p, t); }\n@@ -1063,27 +1057,27 @@ fn parse_prefix_expr(&parser p) -> @ast::expr {\n     // alt-exhaustive-match checking are co-operating.\n \n     auto lit = @spanned(lo, lo, ast::lit_nil);\n-    let ast::expr_ ex = ast::expr_lit(lit, p.get_ann());\n+    let ast::expr_ ex = ast::expr_lit(lit, p.get_id());\n     alt (p.peek()) {\n         case (token::NOT) {\n             p.bump();\n             auto e = parse_prefix_expr(p);\n             hi = e.span.hi;\n-            ex = ast::expr_unary(ast::not, e, p.get_ann());\n+            ex = ast::expr_unary(ast::not, e, p.get_id());\n         }\n         case (token::BINOP(?b)) {\n             alt (b) {\n                 case (token::MINUS) {\n                     p.bump();\n                     auto e = parse_prefix_expr(p);\n                     hi = e.span.hi;\n-                    ex = ast::expr_unary(ast::neg, e, p.get_ann());\n+                    ex = ast::expr_unary(ast::neg, e, p.get_id());\n                 }\n                 case (token::STAR) {\n                     p.bump();\n                     auto e = parse_prefix_expr(p);\n                     hi = e.span.hi;\n-                    ex = ast::expr_unary(ast::deref, e, p.get_ann());\n+                    ex = ast::expr_unary(ast::deref, e, p.get_id());\n                 }\n                 case (_) { ret parse_dot_or_call_expr(p); }\n             }\n@@ -1093,7 +1087,7 @@ fn parse_prefix_expr(&parser p) -> @ast::expr {\n             auto m = parse_mutability(p);\n             auto e = parse_prefix_expr(p);\n             hi = e.span.hi;\n-            ex = ast::expr_unary(ast::box(m), e, p.get_ann());\n+            ex = ast::expr_unary(ast::box(m), e, p.get_id());\n         }\n         case (_) { ret parse_dot_or_call_expr(p); }\n     }\n@@ -1141,14 +1135,14 @@ fn parse_more_binops(&parser p, @ast::expr lhs, int min_prec) -> @ast::expr {\n         if (cur.prec > min_prec && cur.tok == peeked) {\n             p.bump();\n             auto rhs = parse_more_binops(p, parse_prefix_expr(p), cur.prec);\n-            auto bin = ast::expr_binary(cur.op, lhs, rhs, p.get_ann());\n+            auto bin = ast::expr_binary(cur.op, lhs, rhs, p.get_id());\n             auto span = @spanned(lhs.span.lo, rhs.span.hi, bin);\n             ret parse_more_binops(p, span, min_prec);\n         }\n     }\n     if (as_prec > min_prec && eat_word(p, \"as\")) {\n         auto rhs = parse_ty(p);\n-        auto _as = ast::expr_cast(lhs, rhs, p.get_ann());\n+        auto _as = ast::expr_cast(lhs, rhs, p.get_id());\n         auto span = @spanned(lhs.span.lo, rhs.span.hi, _as);\n         ret parse_more_binops(p, span, min_prec);\n     }\n@@ -1163,7 +1157,7 @@ fn parse_assign_expr(&parser p) -> @ast::expr {\n             p.bump();\n             auto rhs = parse_expr(p);\n             ret @spanned(lo, rhs.span.hi,\n-                         ast::expr_assign(lhs, rhs, p.get_ann()));\n+                         ast::expr_assign(lhs, rhs, p.get_id()));\n         }\n         case (token::BINOPEQ(?op)) {\n             p.bump();\n@@ -1183,31 +1177,31 @@ fn parse_assign_expr(&parser p) -> @ast::expr {\n                 case (token::ASR) { aop = ast::asr; }\n             }\n             ret @spanned(lo, rhs.span.hi,\n-                         ast::expr_assign_op(aop, lhs, rhs, p.get_ann()));\n+                         ast::expr_assign_op(aop, lhs, rhs, p.get_id()));\n         }\n         case (token::LARROW) {\n             p.bump();\n             auto rhs = parse_expr(p);\n             ret @spanned(lo, rhs.span.hi,\n-                         ast::expr_move(lhs, rhs, p.get_ann()));\n+                         ast::expr_move(lhs, rhs, p.get_id()));\n         }\n         case (token::SEND) {\n             p.bump();\n             auto rhs = parse_expr(p);\n             ret @spanned(lo, rhs.span.hi,\n-                         ast::expr_send(lhs, rhs, p.get_ann()));\n+                         ast::expr_send(lhs, rhs, p.get_id()));\n         }\n         case (token::RECV) {\n             p.bump();\n             auto rhs = parse_expr(p);\n             ret @spanned(lo, rhs.span.hi,\n-                         ast::expr_recv(lhs, rhs, p.get_ann()));\n+                         ast::expr_recv(lhs, rhs, p.get_id()));\n         }\n         case (token::DARROW) {\n             p.bump();\n             auto rhs = parse_expr(p);\n             ret @spanned(lo, rhs.span.hi,\n-                         ast::expr_swap(lhs, rhs, p.get_ann()));\n+                         ast::expr_swap(lhs, rhs, p.get_id()));\n         }\n         case (_) {/* fall through */ }\n     }\n@@ -1216,7 +1210,7 @@ fn parse_assign_expr(&parser p) -> @ast::expr {\n \n fn parse_if_expr_1(&parser p) -> tup(@ast::expr,\n                                      ast::block, option::t[@ast::expr],\n-                                     ast::ann, uint, uint) {\n+                                     ast::node_id, uint, uint) {\n     auto lo = p.get_last_lo_pos();\n     expect(p, token::LPAREN);\n     auto cond = parse_expr(p);\n@@ -1229,7 +1223,7 @@ fn parse_if_expr_1(&parser p) -> tup(@ast::expr,\n         els = some(elexpr);\n         hi = elexpr.span.hi;\n     }\n-    ret tup(cond, thn, els, p.get_ann(), lo, hi);\n+    ret tup(cond, thn, els, p.get_id(), lo, hi);\n }\n \n fn parse_if_expr(&parser p) -> @ast::expr {\n@@ -1250,7 +1244,7 @@ fn parse_fn_expr(&parser p) -> @ast::expr {\n     auto decl = parse_fn_decl(p, ast::impure_fn);\n     auto body = parse_block(p);\n     auto _fn = rec(decl=decl, proto=ast::proto_fn, body=body);\n-    ret @spanned(lo, body.span.hi, ast::expr_fn(_fn, p.get_ann()));\n+    ret @spanned(lo, body.span.hi, ast::expr_fn(_fn, p.get_id()));\n }\n \n fn parse_else_expr(&parser p) -> @ast::expr {\n@@ -1259,7 +1253,7 @@ fn parse_else_expr(&parser p) -> @ast::expr {\n     } else {\n         auto blk = parse_block(p);\n         ret @spanned(blk.span.lo, blk.span.hi,\n-                     ast::expr_block(blk, p.get_ann()));\n+                     ast::expr_block(blk, p.get_id()));\n     }\n }\n \n@@ -1284,9 +1278,9 @@ fn parse_for_expr(&parser p) -> @ast::expr {\n     auto hi = body.span.hi;\n     if (is_each) {\n         ret @spanned(lo, hi,\n-                     ast::expr_for_each(decl, seq, body, p.get_ann()));\n+                     ast::expr_for_each(decl, seq, body, p.get_id()));\n     } else {\n-        ret @spanned(lo, hi, ast::expr_for(decl, seq, body, p.get_ann()));\n+        ret @spanned(lo, hi, ast::expr_for(decl, seq, body, p.get_id()));\n     }\n }\n \n@@ -1297,7 +1291,7 @@ fn parse_while_expr(&parser p) -> @ast::expr {\n     expect(p, token::RPAREN);\n     auto body = parse_block(p);\n     auto hi = body.span.hi;\n-    ret @spanned(lo, hi, ast::expr_while(cond, body, p.get_ann()));\n+    ret @spanned(lo, hi, ast::expr_while(cond, body, p.get_id()));\n }\n \n fn parse_do_while_expr(&parser p) -> @ast::expr {\n@@ -1308,7 +1302,7 @@ fn parse_do_while_expr(&parser p) -> @ast::expr {\n     auto cond = parse_expr(p);\n     expect(p, token::RPAREN);\n     auto hi = cond.span.hi;\n-    ret @spanned(lo, hi, ast::expr_do_while(body, cond, p.get_ann()));\n+    ret @spanned(lo, hi, ast::expr_do_while(body, cond, p.get_id()));\n }\n \n fn parse_alt_expr(&parser p) -> @ast::expr {\n@@ -1335,7 +1329,7 @@ fn parse_alt_expr(&parser p) -> @ast::expr {\n     }\n     auto hi = p.get_hi_pos();\n     p.bump();\n-    auto expr = ast::expr_alt(discriminant, arms, p.get_ann());\n+    auto expr = ast::expr_alt(discriminant, arms, p.get_id());\n     ret @spanned(lo, hi, expr);\n }\n \n@@ -1351,7 +1345,7 @@ fn parse_spawn_expr(&parser p) -> @ast::expr {\n     auto hi = es.span.hi;\n     auto spawn_expr =\n         ast::expr_spawn(ast::dom_implicit, option::none, fn_expr, es.node,\n-                        p.get_ann());\n+                        p.get_id());\n     ret @spanned(lo, hi, spawn_expr);\n }\n \n@@ -1398,7 +1392,7 @@ fn parse_pat(&parser p) -> @ast::pat {\n     alt (p.peek()) {\n         case (token::UNDERSCORE) {\n             p.bump();\n-            pat = ast::pat_wild(p.get_ann());\n+            pat = ast::pat_wild(p.get_id());\n         }\n         case (token::QUES) {\n             p.bump();\n@@ -1407,8 +1401,7 @@ fn parse_pat(&parser p) -> @ast::pat {\n                     hi = p.get_hi_pos();\n                     p.bump();\n                     pat =\n-                        ast::pat_bind(p.get_str(id), p.next_def_id(),\n-                                      p.get_ann());\n+                        ast::pat_bind(p.get_str(id), p.get_id());\n                 }\n                 case (?tok) {\n                     p.err(\"expected identifier after '?' in pattern but \" +\n@@ -1421,7 +1414,7 @@ fn parse_pat(&parser p) -> @ast::pat {\n             if (!is_ident(tok) || is_word(p, \"true\") || is_word(p, \"false\")) {\n                 auto lit = parse_lit(p);\n                 hi = lit.span.hi;\n-                pat = ast::pat_lit(@lit, p.get_ann());\n+                pat = ast::pat_lit(@lit, p.get_id());\n             } else {\n                 auto tag_path = parse_path_and_ty_param_substs(p);\n                 hi = tag_path.span.hi;\n@@ -1437,7 +1430,7 @@ fn parse_pat(&parser p) -> @ast::pat {\n                     }\n                     case (_) { args = []; }\n                 }\n-                pat = ast::pat_tag(tag_path, args, p.get_ann());\n+                pat = ast::pat_tag(tag_path, args, p.get_id());\n             }\n         }\n     }\n@@ -1454,9 +1447,7 @@ fn parse_local_full(&option::t[@ast::ty] tyopt, &parser p)\n                      infer=false,\n                      ident=ident,\n                      init=init,\n-                     id=p.next_def_id(),\n-                     ann=p.get_ann()));\n-             \n+                     id=p.get_id()));\n }\n \n fn parse_typed_local(&parser p) -> @ast::local {\n@@ -1497,11 +1488,11 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n     if (eat_word(p, \"let\")) {\n         auto decl = parse_let(p);\n         auto hi = p.get_span();\n-        ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_ann()));\n+        ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_id()));\n     } else if (eat_word(p, \"auto\")) {\n         auto decl = parse_auto(p);\n         auto hi = p.get_span();\n-        ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_ann()));\n+        ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_id()));\n     } else {\n \n         auto item_attrs;\n@@ -1514,7 +1505,7 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n             }\n             case (some(right(?ext))) {\n                 ret @spanned(lo, ext.span.hi,\n-                             ast::stmt_expr(ext, p.get_ann()));\n+                             ast::stmt_expr(ext, p.get_id()));\n             }\n         }\n \n@@ -1534,19 +1525,19 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n             case (got_item(?i)) {\n                 auto hi = i.span.hi;\n                 auto decl = @spanned(lo, hi, ast::decl_item(i));\n-                ret @spanned(lo, hi, ast::stmt_decl(decl, p.get_ann()));\n+                ret @spanned(lo, hi, ast::stmt_decl(decl, p.get_id()));\n             }\n             case (fn_no_item) { // parse_item will have already skipped \"fn\"\n \n                 auto e = parse_fn_expr(p);\n                 e = parse_dot_or_call_expr_with(p, e);\n-                ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_ann()));\n+                ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_id()));\n             }\n             case (no_item) {\n                 // Remainder are line-expr stmts.\n \n                 auto e = parse_expr(p);\n-                ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_ann()));\n+                ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_id()));\n             }\n         }\n     }\n@@ -1667,7 +1658,7 @@ fn parse_block(&parser p) -> ast::block {\n     }\n     auto hi = p.get_hi_pos();\n     p.bump();\n-    auto bloc = rec(stmts=stmts, expr=expr, a=p.get_ann());\n+    auto bloc = rec(stmts=stmts, expr=expr, id=p.get_id());\n     ret spanned(lo, hi, bloc);\n }\n \n@@ -1731,8 +1722,7 @@ fn mk_item(&parser p, uint lo, uint hi, &ast::ident ident, &ast::item_ node,\n            &vec[ast::attribute] attrs) -> @ast::item {\n     ret @rec(ident=ident,\n              attrs=attrs,\n-             id=p.next_def_id(),\n-             ann=p.get_ann(),\n+             id=p.get_id(),\n              node=node,\n              span=rec(lo=lo, hi=hi));\n }\n@@ -1749,15 +1739,15 @@ fn parse_obj_field(&parser p) -> ast::obj_field {\n     auto mut = parse_mutability(p);\n     auto ty = parse_ty(p);\n     auto ident = parse_value_ident(p);\n-    ret rec(mut=mut, ty=ty, ident=ident, id=p.next_def_id(), ann=p.get_ann());\n+    ret rec(mut=mut, ty=ty, ident=ident, id=p.get_id());\n }\n \n fn parse_method(&parser p) -> @ast::method {\n     auto lo = p.get_lo_pos();\n     auto proto = parse_proto(p);\n     auto ident = parse_value_ident(p);\n     auto f = parse_fn(p, proto, ast::impure_fn);\n-    auto meth = rec(ident=ident, meth=f, id=p.next_def_id(), ann=p.get_ann());\n+    auto meth = rec(ident=ident, meth=f, id=p.get_id());\n     ret @spanned(lo, f.body.span.hi, meth);\n }\n \n@@ -1776,7 +1766,7 @@ fn parse_dtor(&parser p) -> @ast::method {\n             constraints=[]);\n     let ast::_fn f = rec(decl=d, proto=ast::proto_fn, body=b);\n     let ast::method_ m =\n-        rec(ident=\"drop\", meth=f, id=p.next_def_id(), ann=p.get_ann());\n+        rec(ident=\"drop\", meth=f, id=p.get_id());\n     ret @spanned(lo, f.body.span.hi, m);\n }\n \n@@ -1801,7 +1791,7 @@ fn parse_item_obj(&parser p, ast::layer lyr, vec[ast::attribute] attrs) ->\n     expect(p, token::RBRACE);\n     let ast::_obj ob = rec(fields=fields.node, methods=meths, dtor=dtor);\n     ret mk_item(p, lo, hi, ident, ast::item_obj(ob, ty_params,\n-                                                p.next_def_id()), attrs);\n+                                                p.get_id()), attrs);\n }\n \n fn parse_mod_items(&parser p, token::token term,\n@@ -1856,7 +1846,7 @@ fn parse_item_native_type(&parser p) -> @ast::native_item {\n     auto t = parse_type_decl(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n-    auto item = ast::native_item_ty(t._1, p.next_def_id());\n+    auto item = ast::native_item_ty(t._1, p.get_id());\n     ret @spanned(t._0, hi, item);\n }\n \n@@ -1872,8 +1862,7 @@ fn parse_item_native_fn(&parser p) -> @ast::native_item {\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n     auto item =\n-        ast::native_item_fn(t._0, link_name, decl, t._1, p.next_def_id(),\n-                            p.get_ann());\n+        ast::native_item_fn(t._0, link_name, decl, t._1, p.get_id());\n     ret @spanned(lo, hi, item);\n }\n \n@@ -1975,19 +1964,18 @@ fn parse_item_tag(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n                             parse_seq(token::LPAREN, token::RPAREN,\n                                       some(token::COMMA), parse_ty, p);\n                         for (@ast::ty ty in arg_tys.node) {\n-                            args += [rec(ty=ty, id=p.next_def_id())];\n+                            args += [rec(ty=ty, id=p.get_id())];\n                         }\n                     }\n                     case (_) {/* empty */ }\n                 }\n                 auto vhi = p.get_hi_pos();\n                 expect(p, token::SEMI);\n-                auto id = p.next_def_id();\n+                auto id = p.get_id();\n                 auto vr =\n                     rec(name=p.get_str(name),\n                         args=args,\n-                        id=id,\n-                        ann=p.get_ann());\n+                        id=p.get_id());\n                 variants += [spanned(vlo, vhi, vr)];\n             }\n             case (token::RBRACE) {/* empty */ }\n@@ -2165,7 +2153,7 @@ fn parse_use(&parser p) -> @ast::view_item {\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n     auto use_decl =\n-        ast::view_item_use(ident, metadata, p.next_def_id(), p.get_ann());\n+        ast::view_item_use(ident, metadata, p.get_id());\n     ret @spanned(lo, hi, use_decl);\n }\n \n@@ -2201,17 +2189,17 @@ fn parse_rest_import_name(&parser p, ast::ident first,\n         case (some(?i)) {\n             if (glob) { p.err(\"globbed imports can't be renamed\"); }\n             import_decl =\n-                ast::view_item_import(i, identifiers, p.next_def_id());\n+                ast::view_item_import(i, identifiers, p.get_id());\n         }\n         case (_) {\n             if (glob) {\n                 import_decl =\n-                    ast::view_item_import_glob(identifiers, p.next_def_id());\n+                    ast::view_item_import_glob(identifiers, p.get_id());\n             } else {\n                 auto len = vec::len(identifiers);\n                 import_decl =\n                     ast::view_item_import(identifiers.(len - 1u), identifiers,\n-                                          p.next_def_id());\n+                                          p.get_id());\n             }\n         }\n     }\n@@ -2254,7 +2242,7 @@ fn parse_export(&parser p) -> @ast::view_item {\n     auto id = parse_ident(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n-    ret @spanned(lo, hi, ast::view_item_export(id));\n+    ret @spanned(lo, hi, ast::view_item_export(id, p.get_id()));\n }\n \n fn parse_view_item(&parser p) -> @ast::view_item {\n@@ -2390,7 +2378,7 @@ fn parse_crate_from_crate_file(&parser p) -> @ast::crate {\n              mutable deps=deps,\n              sess=p.get_session(),\n              mutable chpos=p.get_chpos(),\n-             mutable next_ann=p.next_ann_num());\n+             mutable next_id=p.next_id());\n     auto m =\n         eval::eval_crate_directives_to_mod(cx, p.get_env(), cdirs, prefix);\n     auto hi = p.get_hi_pos();"}, {"sha": "da41d065229654193d9f3a369652ec8e7e77d728", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -1,7 +1,8 @@\n \n import front::ast;\n import front::ast::ident;\n-import front::ast::def_num;\n+import front::ast::node_id;\n+import front::ast::def_id;\n import util::common::span;\n import visit::vt;\n import std::vec;\n@@ -22,9 +23,9 @@ import std::option::is_none;\n tag valid { valid; overwritten(span, ast::path); val_taken(span, ast::path); }\n \n type restrict =\n-    @rec(vec[def_num] root_vars,\n-         def_num block_defnum,\n-         vec[def_num] bindings,\n+    @rec(vec[node_id] root_vars,\n+         node_id block_defnum,\n+         vec[node_id] bindings,\n          vec[ty::t] tys,\n          vec[uint] depends_on,\n          mutable valid ok);\n@@ -33,8 +34,8 @@ type scope = vec[restrict];\n \n tag local_info { arg(ast::mode); objfield(ast::mutability); }\n \n-type ctx =\n-    rec(@ty::ctxt tcx, std::map::hashmap[def_num, local_info] local_map);\n+type ctx = rec(@ty::ctxt tcx,\n+               std::map::hashmap[node_id, local_info] local_map);\n \n fn check_crate(@ty::ctxt tcx, &@ast::crate crate) {\n     auto cx =\n@@ -44,19 +45,18 @@ fn check_crate(@ty::ctxt tcx, &@ast::crate crate) {\n              // arguments that's otherwise not easily available.\n              local_map=util::common::new_int_hash());\n     auto v =\n-        @rec(visit_fn=bind visit_fn(cx, _, _, _, _, _, _, _, _),\n+        @rec(visit_fn=bind visit_fn(cx, _, _, _, _, _, _, _),\n              visit_item=bind visit_item(cx, _, _, _),\n              visit_expr=bind visit_expr(cx, _, _, _)\n              with *visit::default_visitor[scope]());\n     visit::visit_crate(*crate, [], visit::vtor(v));\n }\n \n fn visit_fn(@ctx cx, &ast::_fn f, &vec[ast::ty_param] tp, &span sp,\n-            &ident name, &ast::def_id d_id, &ast::ann a, &scope sc,\n-            &vt[scope] v) {\n+            &ident name, ast::node_id id, &scope sc, &vt[scope] v) {\n     visit::visit_fn_decl(f.decl, sc, v);\n     for (ast::arg arg_ in f.decl.inputs) {\n-        cx.local_map.insert(arg_.id._1, arg(arg_.mode));\n+        cx.local_map.insert(arg_.id, arg(arg_.mode));\n     }\n     vt(v).visit_block(f.body, [], v);\n }\n@@ -65,7 +65,7 @@ fn visit_item(@ctx cx, &@ast::item i, &scope sc, &vt[scope] v) {\n     alt (i.node) {\n         case (ast::item_obj(?o, _, _)) {\n             for (ast::obj_field f in o.fields) {\n-                cx.local_map.insert(f.id._1, objfield(f.mut));\n+                cx.local_map.insert(f.id, objfield(f.mut));\n             }\n         }\n         case (_) { }\n@@ -107,8 +107,8 @@ fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n         case (ast::expr_for(?decl, ?seq, ?block, _)) {\n             check_for(*cx, decl, seq, block, sc, v);\n         }\n-        case (ast::expr_path(?pt, ?ann)) {\n-            check_var(*cx, ex, pt, ann, false, sc);\n+        case (ast::expr_path(?pt, ?id)) {\n+            check_var(*cx, ex, pt, id, false, sc);\n             handled = false;\n         }\n         case (ast::expr_move(?dest, ?src, _)) {\n@@ -126,11 +126,11 @@ fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n }\n \n fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n-   rec(vec[def_num] root_vars, vec[ty::t] unsafe_ts) {\n+   rec(vec[node_id] root_vars, vec[ty::t] unsafe_ts) {\n     auto fty = ty::expr_ty(*cx.tcx, f);\n     auto arg_ts = fty_args(cx, fty);\n-    let vec[def_num] roots = [];\n-    let vec[tup(uint, def_num)] mut_roots = [];\n+    let vec[node_id] roots = [];\n+    let vec[tup(uint, node_id)] mut_roots = [];\n     let vec[ty::t] unsafe_ts = [];\n     let vec[uint] unsafe_t_offsets = [];\n     auto i = 0u;\n@@ -169,8 +169,8 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n     }\n     if (vec::len(unsafe_ts) > 0u) {\n         alt (f.node) {\n-            case (ast::expr_path(_, ?ann)) {\n-                if (def_is_local(cx.tcx.def_map.get(ann.id), true)) {\n+            case (ast::expr_path(_, ?id)) {\n+                if (def_is_local(cx.tcx.def_map.get(id), true)) {\n                     cx.tcx.sess.span_fatal(f.span,\n                                          #fmt(\"function may alias with \\\n                          argument %u, which is not immutably rooted\",\n@@ -200,7 +200,7 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n     }\n     // Ensure we're not passing a root by mutable alias.\n \n-    for (tup(uint, def_num) root in mut_roots) {\n+    for (tup(uint, node_id) root in mut_roots) {\n         auto mut_alias_to_root = vec::count(root._1, roots) > 1u;\n         for (restrict r in sc) {\n             if (vec::member(root._1, r.root_vars)) {\n@@ -228,8 +228,8 @@ fn check_tail_call(&ctx cx, &@ast::expr call) {\n             auto mut_a = arg_t.mode == ty::mo_alias(true);\n             auto ok = true;\n             alt (args.(i).node) {\n-                case (ast::expr_path(_, ?ann)) {\n-                    auto def = cx.tcx.def_map.get(ann.id);\n+                case (ast::expr_path(_, ?id)) {\n+                    auto def = cx.tcx.def_map.get(id);\n                     auto dnum = ast::def_id_of_def(def)._1;\n                     alt (cx.local_map.find(dnum)) {\n                         case (some(arg(ast::alias(?mut)))) {\n@@ -282,11 +282,11 @@ fn check_alt(&ctx cx, &@ast::expr input, &vec[ast::arm] arms, &scope sc,\n     }\n }\n \n-fn arm_defnums(&ast::arm arm) -> vec[def_num] {\n+fn arm_defnums(&ast::arm arm) -> vec[node_id] {\n     auto dnums = [];\n-    fn walk_pat(&mutable vec[def_num] found, &@ast::pat p) {\n+    fn walk_pat(&mutable vec[node_id] found, &@ast::pat p) {\n         alt (p.node) {\n-            case (ast::pat_bind(_, ?did, _)) { vec::push(found, did._1); }\n+            case (ast::pat_bind(_, ?id)) { vec::push(found, id); }\n             case (ast::pat_tag(_, ?children, _)) {\n                 for (@ast::pat child in children) { walk_pat(found, child); }\n             }\n@@ -303,7 +303,7 @@ fn check_for_each(&ctx cx, &@ast::local local, &@ast::expr call,\n     alt (call.node) {\n         case (ast::expr_call(?f, ?args, _)) {\n             auto data = check_call(cx, f, args, sc);\n-            auto defnum = local.node.id._1;\n+            auto defnum = local.node.id;\n             auto new_sc =\n                 @rec(root_vars=data.root_vars,\n                      block_defnum=defnum,\n@@ -319,7 +319,7 @@ fn check_for_each(&ctx cx, &@ast::local local, &@ast::expr call,\n fn check_for(&ctx cx, &@ast::local local, &@ast::expr seq, &ast::block block,\n              &scope sc, &vt[scope] v) {\n     visit::visit_expr(seq, sc, v);\n-    auto defnum = local.node.id._1;\n+    auto defnum = local.node.id;\n     auto root = expr_root(cx, seq, false);\n     auto root_def =\n         alt (path_def_id(cx, root.ex)) {\n@@ -347,9 +347,9 @@ fn check_for(&ctx cx, &@ast::local local, &@ast::expr seq, &ast::block block,\n     visit::visit_block(block, sc + [new_sc], v);\n }\n \n-fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::ann ann, bool assign,\n-             &scope sc) {\n-    auto def = cx.tcx.def_map.get(ann.id);\n+fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::node_id id,\n+             bool assign, &scope sc) {\n+    auto def = cx.tcx.def_map.get(id);\n     if (!def_is_local(def, true)) { ret; }\n     auto my_defnum = ast::def_id_of_def(def)._1;\n     auto var_t = ty::expr_ty(*cx.tcx, ex);\n@@ -374,8 +374,8 @@ fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src, &scope sc,\n                 &vt[scope] v) {\n     visit_expr(cx, src, sc, v);\n     alt (dest.node) {\n-        case (ast::expr_path(?p, ?ann)) {\n-            auto dnum = ast::def_id_of_def(cx.tcx.def_map.get(ann.id))._1;\n+        case (ast::expr_path(?p, ?id)) {\n+            auto dnum = ast::def_id_of_def(cx.tcx.def_map.get(id))._1;\n             if (is_immutable_alias(cx, sc, dnum)) {\n                 cx.tcx.sess.span_fatal(dest.span,\n                                      \"assigning to immutable alias\");\n@@ -389,7 +389,7 @@ fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src, &scope sc,\n                     r.ok = overwritten(dest.span, p);\n                 }\n             }\n-            check_var(*cx, dest, p, ann, true, sc);\n+            check_var(*cx, dest, p, id, true, sc);\n         }\n         case (_) {\n             auto root = expr_root(*cx, dest, false);\n@@ -410,7 +410,7 @@ fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src, &scope sc,\n     }\n }\n \n-fn is_immutable_alias(&@ctx cx, &scope sc, def_num dnum) -> bool {\n+fn is_immutable_alias(&@ctx cx, &scope sc, node_id dnum) -> bool {\n     alt (cx.local_map.find(dnum)) {\n         case (some(arg(ast::alias(false)))) { ret true; }\n         case (_) { }\n@@ -421,7 +421,7 @@ fn is_immutable_alias(&@ctx cx, &scope sc, def_num dnum) -> bool {\n     ret false;\n }\n \n-fn is_immutable_objfield(&@ctx cx, def_num dnum) -> bool {\n+fn is_immutable_objfield(&@ctx cx, node_id dnum) -> bool {\n     ret cx.local_map.find(dnum) == some(objfield(ast::imm));\n }\n \n@@ -447,11 +447,11 @@ fn test_scope(&ctx cx, &scope sc, &restrict r, &ast::path p) {\n     }\n }\n \n-fn deps(&scope sc, vec[def_num] roots) -> vec[uint] {\n+fn deps(&scope sc, vec[node_id] roots) -> vec[uint] {\n     auto i = 0u;\n     auto result = [];\n     for (restrict r in sc) {\n-        for (def_num dn in roots) {\n+        for (node_id dn in roots) {\n             if (vec::member(dn, r.bindings)) { vec::push(result, i); }\n         }\n         i += 1u;\n@@ -567,8 +567,8 @@ fn inner_mut(&vec[deref] ds) -> option::t[ty::t] {\n \n fn path_def_id(&ctx cx, &@ast::expr ex) -> option::t[ast::def_id] {\n     alt (ex.node) {\n-        case (ast::expr_path(_, ?ann)) {\n-            ret some(ast::def_id_of_def(cx.tcx.def_map.get(ann.id)));\n+        case (ast::expr_path(_, ?id)) {\n+            ret some(ast::def_id_of_def(cx.tcx.def_map.get(id)));\n         }\n         case (_) { ret none; }\n     }"}, {"sha": "ca486a6e5f3e1ed8143ee28fe83c0aae97831fe5", "filename": "src/comp/middle/ast_map.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -0,0 +1,56 @@\n+import front::ast::*;\n+import visit::vt;\n+\n+tag ast_node {\n+    node_item(@item);\n+    node_obj_ctor(@item);\n+    node_native_item(@native_item);\n+    node_expr(@expr);\n+}\n+\n+type map = std::map::hashmap[node_id, ast_node];\n+\n+fn map_crate(&crate c) -> map {\n+    auto map = util::common::new_int_hash[ast_node]();\n+\n+    auto v_map = @rec(visit_item=bind map_item(map, _, _, _),\n+                      visit_native_item=bind map_native_item(map, _, _, _),\n+                      visit_expr=bind map_expr(map, _, _, _)\n+                      with *visit::default_visitor[()]());\n+    visit::visit_crate(c, (), visit::vtor(v_map));\n+    ret map;\n+}\n+\n+fn map_item(&map map, &@item i, &() e, &vt[()] v) {\n+    map.insert(i.id, node_item(i));\n+    alt (i.node) {\n+        case (item_obj(_, _, ?ctor_id)) {\n+            map.insert(ctor_id, node_obj_ctor(i));\n+        }\n+        case (_) {}\n+    }\n+    visit::visit_item(i, e, v);\n+}\n+\n+fn map_native_item(&map map, &@native_item i, &() e, &vt[()] v) {\n+    auto id = alt (i.node) {\n+        case (native_item_ty(_, ?id)) { id }\n+        case (native_item_fn(_, _, _, _, ?id)) { id }\n+    };\n+    map.insert(id, node_native_item(i));\n+    visit::visit_native_item(i, e, v);\n+}\n+\n+fn map_expr(&map map, &@expr ex, &() e, &vt[()] v) {\n+    map.insert(ty::expr_node_id(ex), node_expr(ex));\n+    visit::visit_expr(ex, e, v);\n+}\n+\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "29ef13f59e076f29c96034decb0d135794a5af64", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 107, "deletions": 108, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -8,7 +8,6 @@ import std::io;\n import std::option;\n import std::option::some;\n import std::option::none;\n-import front::ast;\n import front::ast::*;\n import middle::trans;\n import middle::ty;\n@@ -83,7 +82,7 @@ tag abbrev_ctxt { ac_no_abbrevs; ac_use_abbrevs(hashmap[ty::t, ty_abbrev]); }\n \n mod Encode {\n     type ctxt =\n-        rec(fn(&ast::def_id) -> str  ds, // Def -> str Callback:\n+        rec(fn(&def_id) -> str  ds, // Def -> str Callback:\n \n             ty::ctxt tcx, // The type context.\n \n@@ -149,9 +148,9 @@ mod Encode {\n     }\n     fn enc_mt(&io::writer w, &@ctxt cx, &ty::mt mt) {\n         alt (mt.mut) {\n-            case (ast::imm) { }\n-            case (ast::mut) { w.write_char('m'); }\n-            case (ast::maybe_mut) { w.write_char('?'); }\n+            case (imm) { }\n+            case (mut) { w.write_char('m'); }\n+            case (maybe_mut) { w.write_char('?'); }\n         }\n         enc_ty(w, cx, mt.ty);\n     }\n@@ -214,14 +213,14 @@ mod Encode {\n             case (ty::ty_native_fn(?abi, ?args, ?out)) {\n                 w.write_char('N');\n                 alt (abi) {\n-                    case (ast::native_abi_rust) { w.write_char('r'); }\n-                    case (ast::native_abi_rust_intrinsic) {\n+                    case (native_abi_rust) { w.write_char('r'); }\n+                    case (native_abi_rust_intrinsic) {\n                         w.write_char('i');\n                     }\n-                    case (ast::native_abi_cdecl) { w.write_char('c'); }\n-                    case (ast::native_abi_llvm) { w.write_char('l'); }\n+                    case (native_abi_cdecl) { w.write_char('c'); }\n+                    case (native_abi_llvm) { w.write_char('l'); }\n                 }\n-                enc_ty_fn(w, cx, args, out, ast::return, []);\n+                enc_ty_fn(w, cx, args, out, return, []);\n             }\n             case (ty::ty_obj(?methods)) {\n                 w.write_str(\"O[\");\n@@ -245,14 +244,14 @@ mod Encode {\n             case (ty::ty_task) { w.write_char('a'); }\n         }\n     }\n-    fn enc_proto(&io::writer w, ast::proto proto) {\n+    fn enc_proto(&io::writer w, proto proto) {\n         alt (proto) {\n-            case (ast::proto_iter) { w.write_char('W'); }\n-            case (ast::proto_fn) { w.write_char('F'); }\n+            case (proto_iter) { w.write_char('W'); }\n+            case (proto_fn) { w.write_char('F'); }\n         }\n     }\n     fn enc_ty_fn(&io::writer w, &@ctxt cx, &vec[ty::arg] args, &ty::t out,\n-                 &ast::controlflow cf, &vec[@ty::constr_def] constrs) {\n+                 &controlflow cf, &vec[@ty::constr_def] constrs) {\n         w.write_char('[');\n         for (ty::arg arg in args) {\n             alt (arg.mode) {\n@@ -266,7 +265,7 @@ mod Encode {\n         }\n         w.write_char(']');\n         alt (cf) {\n-            case (ast::noreturn) { w.write_char('!'); }\n+            case (noreturn) { w.write_char('!'); }\n             case (_) { enc_ty(w, cx, out); }\n         }\n         auto colon = true;\n@@ -310,20 +309,20 @@ fn encode_name(&ebml::writer ebml_w, &str name) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_def_id(&ebml::writer ebml_w, &ast::def_id id) {\n+fn encode_def_id(&ebml::writer ebml_w, &def_id id) {\n     ebml::start_tag(ebml_w, tag_def_id);\n     ebml_w.writer.write(str::bytes(def_to_str(id)));\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_tag_variant_paths(&ebml::writer ebml_w, &vec[ast::variant] variants,\n+fn encode_tag_variant_paths(&ebml::writer ebml_w, &vec[variant] variants,\n                             &vec[str] path,\n                             &mutable vec[tup(str, uint)] index) {\n-    for (ast::variant variant in variants) {\n+    for (variant variant in variants) {\n         add_to_index(ebml_w, path, index, variant.node.name);\n         ebml::start_tag(ebml_w, tag_paths_data_item);\n         encode_name(ebml_w, variant.node.name);\n-        encode_def_id(ebml_w, variant.node.id);\n+        encode_def_id(ebml_w, local_def(variant.node.id));\n         ebml::end_tag(ebml_w);\n     }\n }\n@@ -335,98 +334,98 @@ fn add_to_index(&ebml::writer ebml_w, &vec[str] path,\n }\n \n fn encode_native_module_item_paths(&ebml::writer ebml_w,\n-                                   &ast::native_mod nmod, &vec[str] path,\n+                                   &native_mod nmod, &vec[str] path,\n                                    &mutable vec[tup(str, uint)] index) {\n-    for (@ast::native_item nitem in nmod.items) {\n+    for (@native_item nitem in nmod.items) {\n         alt (nitem.node) {\n-            case (ast::native_item_ty(?id, ?did)) {\n-                add_to_index(ebml_w, path, index, id);\n+            case (native_item_ty(?ident, ?id)) {\n+                add_to_index(ebml_w, path, index, ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, id);\n-                encode_def_id(ebml_w, did);\n+                encode_name(ebml_w, ident);\n+                encode_def_id(ebml_w, local_def(id));\n                 ebml::end_tag(ebml_w);\n             }\n-            case (ast::native_item_fn(?id, _, _, _, ?did, _)) {\n-                add_to_index(ebml_w, path, index, id);\n+            case (native_item_fn(?ident, _, _, _, ?id)) {\n+                add_to_index(ebml_w, path, index, ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, id);\n-                encode_def_id(ebml_w, did);\n+                encode_name(ebml_w, ident);\n+                encode_def_id(ebml_w, local_def(id));\n                 ebml::end_tag(ebml_w);\n             }\n         }\n     }\n }\n \n-fn encode_module_item_paths(&ebml::writer ebml_w, &ast::_mod module,\n+fn encode_module_item_paths(&ebml::writer ebml_w, &_mod module,\n                             &vec[str] path,\n                             &mutable vec[tup(str, uint)] index) {\n-    for (@ast::item it in module.items) {\n-        if (!ast::is_exported(it.ident, module)) { cont; }\n+    for (@item it in module.items) {\n+        if (!is_exported(it.ident, module)) { cont; }\n         alt (it.node) {\n-            case (ast::item_const(_, _)) {\n+            case (item_const(_, _)) {\n                 add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, it.id);\n+                encode_def_id(ebml_w, local_def(it.id));\n                 ebml::end_tag(ebml_w);\n             }\n-            case (ast::item_fn(_, ?tps)) {\n+            case (item_fn(_, ?tps)) {\n                 add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, it.id);\n+                encode_def_id(ebml_w, local_def(it.id));\n                 ebml::end_tag(ebml_w);\n             }\n-            case (ast::item_mod(?_mod)) {\n+            case (item_mod(?_mod)) {\n                 add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_mod);\n                 encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, it.id);\n+                encode_def_id(ebml_w, local_def(it.id));\n                 encode_module_item_paths(ebml_w, _mod, path + [it.ident],\n                                          index);\n                 ebml::end_tag(ebml_w);\n             }\n-            case (ast::item_native_mod(?nmod)) {\n+            case (item_native_mod(?nmod)) {\n                 add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_mod);\n                 encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, it.id);\n+                encode_def_id(ebml_w, local_def(it.id));\n                 encode_native_module_item_paths(ebml_w, nmod,\n                                                 path + [it.ident], index);\n                 ebml::end_tag(ebml_w);\n             }\n-            case (ast::item_ty(_, ?tps)) {\n+            case (item_ty(_, ?tps)) {\n                 add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, it.id);\n+                encode_def_id(ebml_w, local_def(it.id));\n                 ebml::end_tag(ebml_w);\n             }\n-            case (ast::item_tag(?variants, ?tps)) {\n+            case (item_tag(?variants, ?tps)) {\n                 add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, it.id);\n+                encode_def_id(ebml_w, local_def(it.id));\n                 ebml::end_tag(ebml_w);\n                 encode_tag_variant_paths(ebml_w, variants, path, index);\n             }\n-            case (ast::item_obj(_, ?tps, ?ctor_id)) {\n+            case (item_obj(_, ?tps, ?ctor_id)) {\n                 add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, ctor_id);\n+                encode_def_id(ebml_w, local_def(ctor_id));\n                 ebml::end_tag(ebml_w);\n                 add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, it.id);\n+                encode_def_id(ebml_w, local_def(it.id));\n                 ebml::end_tag(ebml_w);\n             }\n         }\n     }\n }\n \n-fn encode_item_paths(&ebml::writer ebml_w, &@ast::crate crate) ->\n+fn encode_item_paths(&ebml::writer ebml_w, &@crate crate) ->\n    vec[tup(str, uint)] {\n     let vec[tup(str, uint)] index = [];\n     let vec[str] path = [];\n@@ -444,15 +443,15 @@ fn encode_kind(&ebml::writer ebml_w, u8 c) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn def_to_str(&ast::def_id did) -> str { ret #fmt(\"%d:%d\", did._0, did._1); }\n+fn def_to_str(&def_id did) -> str { ret #fmt(\"%d:%d\", did._0, did._1); }\n \n-fn encode_type_param_count(&ebml::writer ebml_w, &vec[ast::ty_param] tps) {\n+fn encode_type_param_count(&ebml::writer ebml_w, &vec[ty_param] tps) {\n     ebml::start_tag(ebml_w, tag_items_data_item_ty_param_count);\n-    ebml::write_vint(ebml_w.writer, vec::len[ast::ty_param](tps));\n+    ebml::write_vint(ebml_w.writer, vec::len[ty_param](tps));\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_variant_id(&ebml::writer ebml_w, &ast::def_id vid) {\n+fn encode_variant_id(&ebml::writer ebml_w, &def_id vid) {\n     ebml::start_tag(ebml_w, tag_items_data_item_variant);\n     ebml_w.writer.write(str::bytes(def_to_str(vid)));\n     ebml::end_tag(ebml_w);\n@@ -468,37 +467,37 @@ fn encode_type(&@trans::crate_ctxt cx, &ebml::writer ebml_w, &ty::t typ) {\n }\n \n fn encode_symbol(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n-                 &ast::def_id did) {\n+                 node_id id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::bytes(cx.item_symbols.get(did)));\n+    ebml_w.writer.write(str::bytes(cx.item_symbols.get(id)));\n     ebml::end_tag(ebml_w);\n }\n \n fn encode_discriminant(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n-                       &ast::def_id did) {\n+                       node_id id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::bytes(cx.discrim_symbols.get(did)));\n+    ebml_w.writer.write(str::bytes(cx.discrim_symbols.get(id)));\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_tag_id(&ebml::writer ebml_w, &ast::def_id id) {\n+fn encode_tag_id(&ebml::writer ebml_w, &def_id id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_tag_id);\n     ebml_w.writer.write(str::bytes(def_to_str(id)));\n     ebml::end_tag(ebml_w);\n }\n \n fn encode_tag_variant_info(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n-                           &ast::def_id did, &vec[ast::variant] variants,\n+                           node_id id, &vec[variant] variants,\n                            &mutable vec[tup(int, uint)] index,\n-                           &vec[ast::ty_param] ty_params) {\n-    for (ast::variant variant in variants) {\n-        index += [tup(variant.node.id._1, ebml_w.writer.tell())];\n+                           &vec[ty_param] ty_params) {\n+    for (variant variant in variants) {\n+        index += [tup(variant.node.id, ebml_w.writer.tell())];\n         ebml::start_tag(ebml_w, tag_items_data_item);\n-        encode_def_id(ebml_w, variant.node.id);\n+        encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_kind(ebml_w, 'v' as u8);\n-        encode_tag_id(ebml_w, did);\n-        encode_type(cx, ebml_w, trans::node_ann_type(cx, variant.node.ann));\n-        if (vec::len[ast::variant_arg](variant.node.args) > 0u) {\n+        encode_tag_id(ebml_w, local_def(id));\n+        encode_type(cx, ebml_w, trans::node_id_type(cx, variant.node.id));\n+        if (vec::len[variant_arg](variant.node.args) > 0u) {\n             encode_symbol(cx, ebml_w, variant.node.id);\n         }\n         encode_discriminant(cx, ebml_w, variant.node.id);\n@@ -508,70 +507,70 @@ fn encode_tag_variant_info(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n }\n \n fn encode_info_for_item(@trans::crate_ctxt cx, &ebml::writer ebml_w,\n-                        @ast::item item, &mutable vec[tup(int, uint)] index) {\n+                        @item item, &mutable vec[tup(int, uint)] index) {\n     alt (item.node) {\n-        case (ast::item_const(_, _)) {\n+        case (item_const(_, _)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, item.id);\n+            encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 'c' as u8);\n-            encode_type(cx, ebml_w, trans::node_ann_type(cx, item.ann));\n+            encode_type(cx, ebml_w, trans::node_id_type(cx, item.id));\n             encode_symbol(cx, ebml_w, item.id);\n             ebml::end_tag(ebml_w);\n         }\n-        case (ast::item_fn(_, ?tps)) {\n+        case (item_fn(_, ?tps)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, item.id);\n+            encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 'f' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, trans::node_ann_type(cx, item.ann));\n+            encode_type(cx, ebml_w, trans::node_id_type(cx, item.id));\n             encode_symbol(cx, ebml_w, item.id);\n             ebml::end_tag(ebml_w);\n         }\n-        case (ast::item_mod(_)) {\n+        case (item_mod(_)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, item.id);\n+            encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 'm' as u8);\n             ebml::end_tag(ebml_w);\n         }\n-        case (ast::item_native_mod(_)) {\n+        case (item_native_mod(_)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, item.id);\n+            encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 'n' as u8);\n             ebml::end_tag(ebml_w);\n         }\n-        case (ast::item_ty(_, ?tps)) {\n+        case (item_ty(_, ?tps)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, item.id);\n+            encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, trans::node_ann_type(cx, item.ann));\n+            encode_type(cx, ebml_w, trans::node_id_type(cx, item.id));\n             ebml::end_tag(ebml_w);\n         }\n-        case (ast::item_tag(?variants, ?tps)) {\n+        case (item_tag(?variants, ?tps)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, item.id);\n+            encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 't' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, trans::node_ann_type(cx, item.ann));\n-            for (ast::variant v in variants) {\n-                encode_variant_id(ebml_w, v.node.id);\n+            encode_type(cx, ebml_w, trans::node_id_type(cx, item.id));\n+            for (variant v in variants) {\n+                encode_variant_id(ebml_w, local_def(v.node.id));\n             }\n             ebml::end_tag(ebml_w);\n             encode_tag_variant_info(cx, ebml_w, item.id, variants, index,\n                                     tps);\n         }\n-        case (ast::item_obj(_, ?tps, ?ctor_id)) {\n+        case (item_obj(_, ?tps, ?ctor_id)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, ctor_id);\n+            encode_def_id(ebml_w, local_def(ctor_id));\n             encode_kind(ebml_w, 'o' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            auto fn_ty = trans::node_ann_type(cx, item.ann);\n+            auto fn_ty = trans::node_id_type(cx, item.id);\n             encode_type(cx, ebml_w, fn_ty);\n             encode_symbol(cx, ebml_w, ctor_id);\n             ebml::end_tag(ebml_w);\n-            index += [tup(item.id._1, ebml_w.writer.tell())];\n+            index += [tup(item.id, ebml_w.writer.tell())];\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, item.id);\n+            encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n             encode_type(cx, ebml_w, ty::ty_fn_ret(cx.tcx, fn_ty));\n@@ -581,20 +580,20 @@ fn encode_info_for_item(@trans::crate_ctxt cx, &ebml::writer ebml_w,\n }\n \n fn encode_info_for_native_item(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n-                               &@ast::native_item nitem) {\n+                               &@native_item nitem) {\n     ebml::start_tag(ebml_w, tag_items_data_item);\n     alt (nitem.node) {\n-        case (ast::native_item_ty(_, ?did)) {\n-            encode_def_id(ebml_w, did);\n+        case (native_item_ty(_, ?id)) {\n+            encode_def_id(ebml_w, local_def(id));\n             encode_kind(ebml_w, 'T' as u8);\n             encode_type(cx, ebml_w, ty::mk_native(cx.tcx));\n         }\n-        case (ast::native_item_fn(_, _, _, ?tps, ?did, ?ann)) {\n-            encode_def_id(ebml_w, did);\n+        case (native_item_fn(_, _, _, ?tps, ?id)) {\n+            encode_def_id(ebml_w, local_def(id));\n             encode_kind(ebml_w, 'F' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, trans::node_ann_type(cx, ann));\n-            encode_symbol(cx, ebml_w, did);\n+            encode_type(cx, ebml_w, trans::node_id_type(cx, id));\n+            encode_symbol(cx, ebml_w, id);\n         }\n     }\n     ebml::end_tag(ebml_w);\n@@ -604,13 +603,13 @@ fn encode_info_for_items(&@trans::crate_ctxt cx, &ebml::writer ebml_w) ->\n    vec[tup(int, uint)] {\n     let vec[tup(int, uint)] index = [];\n     ebml::start_tag(ebml_w, tag_items_data);\n-    for each (@tup(ast::def_id, @ast::item) kvp in cx.items.items()) {\n-        index += [tup(kvp._0._1, ebml_w.writer.tell())];\n+    for each (@tup(node_id, @item) kvp in cx.items.items()) {\n+        index += [tup(kvp._0, ebml_w.writer.tell())];\n         encode_info_for_item(cx, ebml_w, kvp._1, index);\n     }\n-    for each (@tup(ast::def_id, @ast::native_item) kvp in\n+    for each (@tup(node_id, @native_item) kvp in\n              cx.native_items.items()) {\n-        index += [tup(kvp._0._1, ebml_w.writer.tell())];\n+        index += [tup(kvp._0, ebml_w.writer.tell())];\n         encode_info_for_native_item(cx, ebml_w, kvp._1);\n     }\n     ebml::end_tag(ebml_w);\n@@ -621,7 +620,7 @@ fn encode_info_for_items(&@trans::crate_ctxt cx, &ebml::writer ebml_w) ->\n // Path and definition ID indexing\n \n // djb's cdb hashes.\n-fn hash_def_num(&int def_num) -> uint { ret 177573u ^ (def_num as uint); }\n+fn hash_def_id(&int def_id) -> uint { ret 177573u ^ (def_id as uint); }\n \n fn hash_path(&str s) -> uint {\n     auto h = 5381u;\n@@ -670,8 +669,8 @@ fn write_int(&io::writer writer, &int n) {\n     writer.write_be_uint(n as uint, 4u);\n }\n \n-fn encode_meta_items(&ebml::writer ebml_w, &ast::crate crate) {\n-    fn encode_meta_item(&ebml::writer ebml_w, &ast::meta_item mi) {\n+fn encode_meta_items(&ebml::writer ebml_w, &crate crate) {\n+    fn encode_meta_item(&ebml::writer ebml_w, &meta_item mi) {\n         ebml::start_tag(ebml_w, tag_meta_item);\n         ebml::start_tag(ebml_w, tag_meta_item_key);\n         ebml_w.writer.write(str::bytes(mi.node.key));\n@@ -682,18 +681,18 @@ fn encode_meta_items(&ebml::writer ebml_w, &ast::crate crate) {\n         ebml::end_tag(ebml_w);\n     }\n     ebml::start_tag(ebml_w, tag_meta_export);\n-    for each (@ast::meta_item mi in link::crate_export_metas(crate)) {\n+    for each (@meta_item mi in link::crate_export_metas(crate)) {\n         encode_meta_item(ebml_w, *mi);\n     }\n     ebml::end_tag(ebml_w);\n     ebml::start_tag(ebml_w, tag_meta_local);\n-    for each (@ast::meta_item mi in link::crate_local_metas(crate)) {\n+    for each (@meta_item mi in link::crate_local_metas(crate)) {\n         encode_meta_item(ebml_w, *mi);\n     }\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_metadata(&@trans::crate_ctxt cx, &@ast::crate crate) -> ValueRef {\n+fn encode_metadata(&@trans::crate_ctxt cx, &@crate crate) -> ValueRef {\n     auto string_w = io::string_writer();\n     auto buf_w = string_w.get_writer().get_buf_writer();\n     auto ebml_w = ebml::create_writer(buf_w);\n@@ -714,7 +713,7 @@ fn encode_metadata(&@trans::crate_ctxt cx, &@ast::crate crate) -> ValueRef {\n     ebml::start_tag(ebml_w, tag_items);\n     auto items_index = encode_info_for_items(cx, ebml_w);\n     auto int_writer = write_int;\n-    auto item_hasher = hash_def_num;\n+    auto item_hasher = hash_def_id;\n     auto items_buckets = create_index[int](items_index, item_hasher);\n     encode_index[int](ebml_w, items_buckets, int_writer);\n     ebml::end_tag(ebml_w);\n@@ -725,7 +724,7 @@ fn encode_metadata(&@trans::crate_ctxt cx, &@ast::crate crate) -> ValueRef {\n     ret C_postr(string_w.get_str());\n }\n \n-fn write_metadata(&@trans::crate_ctxt cx, &@ast::crate crate) {\n+fn write_metadata(&@trans::crate_ctxt cx, &@crate crate) {\n     if (!cx.sess.get_opts().shared) { ret; }\n     auto llmeta = encode_metadata(cx, crate);\n     auto llconst = trans::C_struct([llmeta]);"}, {"sha": "356dab8403967b1f7ff713e8224298c39af6b86b", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 114, "deletions": 91, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -3,12 +3,13 @@ import front::ast;\n import front::ast::ident;\n import front::ast::def;\n import front::ast::def_id;\n-import front::ast::ann;\n+import front::ast::node_id;\n+import front::ast::local_def;\n+\n import front::creader;\n import driver::session::session;\n import util::common::new_def_hash;\n import util::common::new_int_hash;\n-import util::common::new_uint_hash;\n import util::common::new_str_hash;\n import util::common::span;\n import util::common::respan;\n@@ -107,17 +108,17 @@ type indexed_mod =\n    only need to look at them to determine exports, which they can't control.*/\n \n // It should be safe to use index to memoize lookups of globbed names.\n-type crate_map = hashmap[uint, ast::crate_num];\n+type crate_map = hashmap[node_id, ast::crate_num];\n \n-type def_map = hashmap[uint, def];\n+type def_map = hashmap[node_id, def];\n \n type env =\n     rec(crate_map crate_map,\n         def_map def_map,\n         constr_table fn_constrs,\n-        hashmap[def_id, @ast::item] ast_map,\n-        hashmap[ast::def_num, import_state] imports,\n-        hashmap[ast::def_num, @indexed_mod] mod_map,\n+        hashmap[ast::node_id, @ast::item] ast_map,\n+        hashmap[ast::node_id, import_state] imports,\n+        hashmap[ast::node_id, @indexed_mod] mod_map,\n         hashmap[def_id, vec[ident]] ext_map,\n         ext_hash ext_cache,\n         session sess);\n@@ -132,10 +133,10 @@ tag namespace { ns_value; ns_type; ns_module; }\n fn resolve_crate(session sess, @ast::crate crate) ->\n    tup(def_map, constr_table) {\n     auto e =\n-        @rec(crate_map=new_uint_hash[ast::crate_num](),\n-             def_map=new_uint_hash[def](),\n-             fn_constrs=new_def_hash[vec[ty::constr_def]](),\n-             ast_map=new_def_hash[@ast::item](),\n+        @rec(crate_map=new_int_hash[ast::crate_num](),\n+             def_map=new_int_hash[def](),\n+             fn_constrs = new_int_hash[vec[ty::constr_def]](),\n+             ast_map=new_int_hash[@ast::item](),\n              imports=new_int_hash[import_state](),\n              mod_map=new_int_hash[@indexed_mod](),\n              ext_map=new_def_hash[vec[ident]](),\n@@ -170,8 +171,8 @@ fn map_crate(&@env e, &@ast::crate c) {\n                           glob_imported_names=new_str_hash[import_state]()));\n     fn index_vi(@env e, &@ast::view_item i, &scopes sc, &vt[scopes] v) {\n         alt (i.node) {\n-            case (ast::view_item_import(_, ?ids, ?defid)) {\n-                e.imports.insert(defid._1, todo(i, sc));\n+            case (ast::view_item_import(_, ?ids, ?id)) {\n+                e.imports.insert(id, todo(i, sc));\n             }\n             case (_) { }\n         }\n@@ -181,7 +182,7 @@ fn map_crate(&@env e, &@ast::crate c) {\n         alt (i.node) {\n             case (ast::item_mod(?md)) {\n                 auto s = new_str_hash[import_state]();\n-                e.mod_map.insert(i.id._1,\n+                e.mod_map.insert(i.id,\n                                  @rec(m=some(md),\n                                       index=index_mod(md),\n                                       mutable glob_imports=vec::empty[def](),\n@@ -190,7 +191,7 @@ fn map_crate(&@env e, &@ast::crate c) {\n             }\n             case (ast::item_native_mod(?nmd)) {\n                 auto s = new_str_hash[import_state]();\n-                e.mod_map.insert(i.id._1,\n+                e.mod_map.insert(i.id,\n                                  @rec(m=none[ast::_mod],\n                                       index=index_nmod(nmd),\n                                       mutable glob_imports=vec::empty[def](),\n@@ -218,10 +219,10 @@ fn map_crate(&@env e, &@ast::crate c) {\n                 case (cons(scope_item(?i), ?tl)) {\n                     alt (i.node) {\n                         case (ast::item_mod(_)) {\n-                            ret e.mod_map.get(i.id._1);\n+                            ret e.mod_map.get(i.id);\n                         }\n                         case (ast::item_native_mod(_)) {\n-                            ret e.mod_map.get(i.id._1);\n+                            ret e.mod_map.get(i.id);\n                         }\n                         case (_) { be find_mod(e, *tl); }\n                     }\n@@ -248,7 +249,7 @@ fn map_crate(&@env e, &@ast::crate c) {\n }\n \n fn resolve_imports(&env e) {\n-    for each (@tup(ast::def_num, import_state) it in e.imports.items()) {\n+    for each (@tup(ast::node_id, import_state) it in e.imports.items()) {\n         alt (it._1) {\n             case (todo(?item, ?sc)) { resolve_import(e, item, sc); }\n             case (resolved(_, _, _)) { }\n@@ -266,16 +267,16 @@ fn resolve_names(&@env e, &@ast::crate c) {\n              visit_expr=bind walk_expr(e, _, _, _),\n              visit_ty=bind walk_ty(e, _, _, _),\n              visit_constr=bind walk_constr(e, _, _, _),\n-             visit_fn=bind visit_fn_with_scope(e, _, _, _, _, _, _, _, _)\n+             visit_fn=bind visit_fn_with_scope(e, _, _, _, _, _, _, _)\n              with *visit::default_visitor());\n     visit::visit_crate(*c, cons(scope_crate(c), @nil), visit::vtor(v));\n     e.sess.abort_if_errors();\n \n     fn walk_expr(@env e, &@ast::expr exp, &scopes sc, &vt[scopes] v) {\n         visit_expr_with_scope(exp, sc, v);\n         alt (exp.node) {\n-            case (ast::expr_path(?p, ?a)) {\n-                maybe_insert(e, a.id,\n+            case (ast::expr_path(?p, ?id)) {\n+                maybe_insert(e, id,\n                              lookup_path_strict(*e, sc, exp.span,\n                                                 p.node.idents, ns_value));\n             }\n@@ -285,16 +286,16 @@ fn resolve_names(&@env e, &@ast::crate c) {\n     fn walk_ty(@env e, &@ast::ty t, &scopes sc, &vt[scopes] v) {\n         visit::visit_ty(t, sc, v);\n         alt (t.node) {\n-            case (ast::ty_path(?p, ?a)) {\n-                maybe_insert(e, a.id,\n+            case (ast::ty_path(?p, ?id)) {\n+                maybe_insert(e, id,\n                              lookup_path_strict(*e, sc, t.span,\n                                                 p.node.idents, ns_type));\n             }\n             case (_) { }\n         }\n     }\n     fn walk_constr(@env e, &@ast::constr c, &scopes sc, &vt[scopes] v) {\n-        maybe_insert(e, c.node.ann.id,\n+        maybe_insert(e, c.node.id,\n                      lookup_path_strict(*e, sc, c.span,\n                                         c.node.path.node.idents, ns_value));\n     }\n@@ -304,14 +305,14 @@ fn resolve_names(&@env e, &@ast::crate c) {\n     }\n     fn walk_pat(&env e, &scopes sc, &@ast::pat pat) {\n         alt (pat.node) {\n-            case (ast::pat_tag(?p, ?children, ?a)) {\n+            case (ast::pat_tag(?p, ?children, ?id)) {\n                 auto fnd =\n                     lookup_path_strict(e, sc, p.span, p.node.idents,\n                                        ns_value);\n                 if (option::is_some(fnd)) {\n                     alt (option::get(fnd)) {\n                         case (ast::def_variant(?did, ?vid)) {\n-                            e.def_map.insert(a.id, option::get(fnd));\n+                            e.def_map.insert(id, option::get(fnd));\n                             for (@ast::pat child in children) {\n                                 walk_pat(e, sc, child);\n                             }\n@@ -328,7 +329,7 @@ fn resolve_names(&@env e, &@ast::crate c) {\n         }\n     }\n \n-    fn maybe_insert(@env e, uint id,\n+    fn maybe_insert(@env e, node_id id,\n                     option::t[def] def) {\n         if (option::is_some(def)) {\n             e.def_map.insert(id, option::get(def));\n@@ -348,16 +349,16 @@ fn visit_native_item_with_scope(&@ast::native_item ni, &scopes sc,\n }\n \n fn visit_fn_with_scope(&@env e, &ast::_fn f, &vec[ast::ty_param] tp, &span sp,\n-                       &ident name, &def_id d_id, &ann a, &scopes sc,\n+                       &ident name, node_id id, &scopes sc,\n                        &vt[scopes] v) {\n     // here's where we need to set up the mapping\n     // for f's constrs in the table.\n \n     for (@ast::constr c in f.decl.constraints) {\n-        resolve_constr(e, d_id, c, sc, v);\n+        resolve_constr(e, id, c, sc, v); \n     }\n-    visit::visit_fn(f, tp, sp, name, d_id, a, cons(scope_fn(f.decl, tp), @sc),\n-                    v);\n+    visit::visit_fn(f, tp, sp, name, id,\n+                    cons(scope_fn(f.decl, tp), @sc), v);\n }\n \n fn visit_block_with_scope(&ast::block b, &scopes sc, &vt[scopes] v) {\n@@ -411,7 +412,7 @@ fn follow_import(&env e, &scopes sc,\n     }\n }\n \n-fn resolve_constr(@env e, &def_id d_id, &@ast::constr c, &scopes sc,\n+fn resolve_constr(@env e, node_id id, &@ast::constr c, &scopes sc,\n                   &vt[scopes] v) {\n     auto new_def =\n         lookup_path_strict(*e, sc, c.span, c.node.path.node.idents, ns_value);\n@@ -421,7 +422,7 @@ fn resolve_constr(@env e, &def_id d_id, &@ast::constr c, &scopes sc,\n                 let ty::constr_general[uint] c_ =\n                     rec(path=c.node.path, args=c.node.args, id=pred_id);\n                 let ty::constr_def new_constr = respan(c.span, c_);\n-                add_constr(e, d_id, new_constr);\n+                add_constr(e, id, new_constr);\n             }\n             case (_) {\n                 e.sess.span_err(c.span,\n@@ -432,9 +433,9 @@ fn resolve_constr(@env e, &def_id d_id, &@ast::constr c, &scopes sc,\n     }\n }\n \n-fn add_constr(&@env e, &def_id d_id, &ty::constr_def c) {\n-    e.fn_constrs.insert(d_id,\n-                        alt (e.fn_constrs.find(d_id)) {\n+fn add_constr(&@env e, node_id id, &ty::constr_def c) {\n+    e.fn_constrs.insert(id,\n+                        alt (e.fn_constrs.find(id)) {\n                             case (none) { [c] }\n                             case (some(?cs)) { cs + [c] }\n                         });\n@@ -446,8 +447,8 @@ fn resolve_import(&env e, &@ast::view_item it, &scopes sc) {\n     auto defid;\n     auto ids;\n     alt (it.node) {\n-        case (ast::view_item_import(_, ?_ids, ?_defid)) {\n-            defid = _defid;\n+        case (ast::view_item_import(_, ?_ids, ?_id)) {\n+            defid = local_def(_id);\n             ids = _ids;\n         }\n     }\n@@ -511,15 +512,15 @@ fn resolve_import(&env e, &@ast::view_item it, &scopes sc) {\n             e.imports.insert(defid._1, resolved(val, typ, md));\n         }\n     }\n-    fn remove_if_unresolved(hashmap[ast::def_num, import_state] imports,\n-                            ast::def_num def_num) {\n+    fn remove_if_unresolved(hashmap[ast::node_id, import_state] imports,\n+                            ast::node_id node_id) {\n         // If we couldn't resolve the import, don't leave it in a partially\n         // resolved state, to avoid having it reported later as a cyclic\n         // import\n-        if (imports.contains_key(def_num)) {\n-            alt (imports.get(def_num)) {\n+        if (imports.contains_key(node_id)) {\n+            alt (imports.get(node_id)) {\n                 case (resolving(_)) {\n-                    imports.remove(def_num);\n+                    imports.remove(node_id);\n                 }\n                 case (_) { }\n             }\n@@ -605,8 +606,7 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident id, namespace ns) ->\n \n         alt (s) {\n             case (scope_crate(?c)) {\n-                auto defid = tup(ast::local_crate, -1);\n-                ret lookup_in_local_mod(e, defid, sp, id, ns, inside);\n+                ret lookup_in_local_mod(e, -1, sp, id, ns, inside);\n             }\n             case (scope_item(?it)) {\n                 alt (it.node) {\n@@ -634,7 +634,7 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident id, namespace ns) ->\n             }\n             case (scope_native_item(?it)) {\n                 alt (it.node) {\n-                    case (ast::native_item_fn(_, _, ?decl, ?ty_params, _, _))\n+                    case (ast::native_item_fn(_, _, ?decl, ?ty_params, _))\n                          {\n                         ret lookup_in_fn(id, decl, ty_params, ns);\n                     }\n@@ -646,7 +646,7 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident id, namespace ns) ->\n             case (scope_loop(?local)) {\n                 if (ns == ns_value) {\n                     if (str::eq(local.node.ident, id)) {\n-                        ret some(ast::def_local(local.node.id));\n+                        ret some(ast::def_local(local_def(local.node.id)));\n                     }\n                 }\n             }\n@@ -696,16 +696,18 @@ fn lookup_in_ty_params(&ident id, &vec[ast::ty_param] ty_params) ->\n     ret none[def];\n }\n \n-fn lookup_in_pat(&ident id, &ast::pat pat) -> option::t[def] {\n+fn lookup_in_pat(&ident ident, &ast::pat pat) -> option::t[def] {\n     alt (pat.node) {\n-        case (ast::pat_bind(?name, ?defid, _)) {\n-            if (str::eq(name, id)) { ret some(ast::def_binding(defid)); }\n+        case (ast::pat_bind(?name, ?id)) {\n+            if (str::eq(name, ident)) {\n+                ret some(ast::def_binding(local_def(id)));\n+            }\n         }\n         case (ast::pat_wild(_)) { }\n         case (ast::pat_lit(_, _)) { }\n         case (ast::pat_tag(_, ?pats, _)) {\n             for (@ast::pat p in pats) {\n-                auto found = lookup_in_pat(id, *p);\n+                auto found = lookup_in_pat(ident, *p);\n                 if (!option::is_none(found)) { ret found; }\n             }\n         }\n@@ -718,7 +720,9 @@ fn lookup_in_fn(&ident id, &ast::fn_decl decl, &vec[ast::ty_param] ty_params,\n     alt (ns) {\n         case (ns_value) {\n             for (ast::arg a in decl.inputs) {\n-                if (str::eq(a.ident, id)) { ret some(ast::def_arg(a.id)); }\n+                if (str::eq(a.ident, id)) {\n+                    ret some(ast::def_arg(local_def(a.id)));\n+                }\n             }\n             ret none[def];\n         }\n@@ -733,7 +737,7 @@ fn lookup_in_obj(&ident id, &ast::_obj ob, &vec[ast::ty_param] ty_params,\n         case (ns_value) {\n             for (ast::obj_field f in ob.fields) {\n                 if (str::eq(f.ident, id)) {\n-                    ret some(ast::def_obj_field(f.id));\n+                    ret some(ast::def_obj_field(local_def(f.id)));\n                 }\n             }\n             ret none[def];\n@@ -751,22 +755,24 @@ fn lookup_in_block(&ident id, &ast::block_ b, namespace ns) ->\n                 alt (d.node) {\n                     case (ast::decl_local(?loc)) {\n                         if (ns == ns_value && str::eq(id, loc.node.ident)) {\n-                            ret some(ast::def_local(loc.node.id));\n+                            ret some(ast::def_local(local_def(loc.node.id)));\n                         }\n                     }\n                     case (ast::decl_item(?it)) {\n                         alt (it.node) {\n                             case (ast::item_tag(?variants, _)) {\n                                 if (ns == ns_type) {\n                                     if (str::eq(it.ident, id)) {\n-                                        ret some(ast::def_ty(it.id));\n+                                        ret some(ast::def_ty\n+                                                 (local_def(it.id)));\n                                     }\n                                 } else if (ns == ns_value) {\n                                     for (ast::variant v in variants) {\n                                         if (str::eq(v.node.name, id)) {\n                                             auto i = v.node.id;\n-                                            ret some(ast::def_variant(it.id,\n-                                                                      i));\n+                                            ret some(ast::def_variant\n+                                                     (local_def(it.id),\n+                                                      local_def(i)));\n                                         }\n                                     }\n                                 }\n@@ -792,27 +798,39 @@ fn lookup_in_block(&ident id, &ast::block_ b, namespace ns) ->\n fn found_def_item(&@ast::item i, namespace ns) -> option::t[def] {\n     alt (i.node) {\n         case (ast::item_const(_, _)) {\n-            if (ns == ns_value) { ret some(ast::def_const(i.id)); }\n+            if (ns == ns_value) {\n+                ret some(ast::def_const(local_def(i.id)));\n+            }\n         }\n         case (ast::item_fn(_, _)) {\n-            if (ns == ns_value) { ret some(ast::def_fn(i.id)); }\n+            if (ns == ns_value) {\n+                ret some(ast::def_fn(local_def(i.id)));\n+            }\n         }\n         case (ast::item_mod(_)) {\n-            if (ns == ns_module) { ret some(ast::def_mod(i.id)); }\n+            if (ns == ns_module) {\n+                ret some(ast::def_mod(local_def(i.id)));\n+            }\n         }\n         case (ast::item_native_mod(_)) {\n-            if (ns == ns_module) { ret some(ast::def_native_mod(i.id)); }\n+            if (ns == ns_module) {\n+                ret some(ast::def_native_mod(local_def(i.id)));\n+            }\n         }\n         case (ast::item_ty(_, _)) {\n-            if (ns == ns_type) { ret some(ast::def_ty(i.id)); }\n+            if (ns == ns_type) {\n+                ret some(ast::def_ty(local_def(i.id)));\n+            }\n         }\n         case (ast::item_tag(_, _)) {\n-            if (ns == ns_type) { ret some(ast::def_ty(i.id)); }\n+            if (ns == ns_type) {\n+                ret some(ast::def_ty(local_def(i.id)));\n+            }\n         }\n         case (ast::item_obj(_, _, ?ctor_id)) {\n             alt (ns) {\n-                case (ns_value) { ret some(ast::def_obj(ctor_id)); }\n-                case (ns_type) { ret some(ast::def_obj(i.id)); }\n+                case (ns_value) { ret some(ast::def_obj(local_def(ctor_id)));}\n+                case (ns_type) { ret some(ast::def_obj(local_def(i.id))); }\n                 case (_) { }\n             }\n         }\n@@ -850,22 +868,22 @@ fn lookup_in_mod(&env e, def m, &span sp, &ident id, namespace ns, dir dr) ->\n     }\n     alt (m) {\n         case (ast::def_mod(?defid)) {\n-            ret lookup_in_local_mod(e, defid, sp, id, ns, dr);\n+            ret lookup_in_local_mod(e, defid._1, sp, id, ns, dr);\n         }\n         case (ast::def_native_mod(?defid)) {\n-            ret lookup_in_local_native_mod(e, defid, sp, id, ns);\n+            ret lookup_in_local_native_mod(e, defid._1, sp, id, ns);\n         }\n     }\n }\n \n fn found_view_item(&env e, @ast::view_item vi, namespace ns) ->\n    option::t[def] {\n     alt (vi.node) {\n-        case (ast::view_item_use(_, _, _, ?ann)) {\n-            ret some(ast::def_mod(tup(e.crate_map.get(ann.id), -1)));\n+        case (ast::view_item_use(_, _, ?id)) {\n+            ret some(ast::def_mod(tup(e.crate_map.get(id), -1)));\n         }\n-        case (ast::view_item_import(_, _, ?defid)) {\n-            ret lookup_import(e, defid, ns);\n+        case (ast::view_item_import(_, _, ?id)) {\n+            ret lookup_import(e, local_def(id), ns);\n         }\n         case (ast::view_item_import_glob(_, ?defid)) {\n             ret none[def]; //will be handled in the fallback glob pass\n@@ -894,14 +912,14 @@ fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n     }\n }\n \n-fn lookup_in_local_native_mod(&env e, def_id defid, &span sp, &ident id,\n+fn lookup_in_local_native_mod(&env e, node_id node_id, &span sp, &ident id,\n                               namespace ns) -> option::t[def] {\n-    ret lookup_in_local_mod(e, defid, sp, id, ns, inside);\n+    ret lookup_in_local_mod(e, node_id, sp, id, ns, inside);\n }\n \n-fn lookup_in_local_mod(&env e, def_id defid, &span sp, &ident id,\n+fn lookup_in_local_mod(&env e, node_id node_id, &span sp, &ident id,\n                        namespace ns, dir dr) -> option::t[def] {\n-    auto info = e.mod_map.get(defid._1);\n+    auto info = e.mod_map.get(node_id);\n     if (dr == outside && !ast::is_exported(id, option::get(info.m))) {\n         // if we're in a native mod, then dr==inside, so info.m is some _mod\n \n@@ -947,14 +965,14 @@ fn lookup_glob_in_mod(&env e, @indexed_mod info, &span sp, &ident id,\n             ret some[def](matches.(0));\n         } else {\n             for (def match in matches) {\n-                alt (e.ast_map.find(ast::def_id_of_def(match))) {\n+                alt (e.ast_map.find(ast::def_id_of_def(match)._1)) {\n                     case (some(?it)) {\n                         e.sess.span_note(it.span,\n                                          \"'\" + id + \"' is defined here.\");\n                     }\n                     case (_) {\n                         e.sess.bug(\"Internal error: imports and matches \" +\n-                                       \"don't agree\");\n+                                   \"don't agree\");\n                     }\n                 }\n             }\n@@ -1001,18 +1019,23 @@ fn lookup_in_mie(&env e, &mod_index_entry mie, namespace ns) ->\n                 case (ast::item_tag(?variants, _)) {\n                     if (ns == ns_value) {\n                         auto vid = variants.(variant_idx).node.id;\n-                        ret some(ast::def_variant(item.id, vid));\n+                        ret some(ast::def_variant(local_def(item.id),\n+                                                  local_def(vid)));\n                     } else { ret none[def]; }\n                 }\n             }\n         }\n         case (mie_native_item(?native_item)) {\n             alt (native_item.node) {\n                 case (ast::native_item_ty(_, ?id)) {\n-                    if (ns == ns_type) { ret some(ast::def_native_ty(id)); }\n+                    if (ns == ns_type) {\n+                        ret some(ast::def_native_ty(local_def(id)));\n+                    }\n                 }\n-                case (ast::native_item_fn(_, _, _, _, ?id, _)) {\n-                    if (ns == ns_value) { ret some(ast::def_native_fn(id)); }\n+                case (ast::native_item_fn(_, _, _, _, ?id)) {\n+                    if (ns == ns_value) {\n+                        ret some(ast::def_native_fn(local_def(id)));\n+                    }\n                 }\n             }\n         }\n@@ -1035,8 +1058,8 @@ fn index_mod(&ast::_mod md) -> mod_index {\n     auto index = new_str_hash[list[mod_index_entry]]();\n     for (@ast::view_item it in md.view_items) {\n         alt (it.node) {\n-            case (ast::view_item_use(?id, _, _, _)) {\n-                add_to_index(index, id, mie_view_item(it));\n+            case (ast::view_item_use(?ident, _, _)) {\n+                add_to_index(index, ident, mie_view_item(it));\n             }\n             case (ast::view_item_import(?def_ident, _, _)) {\n                 add_to_index(index, def_ident, mie_view_item(it));\n@@ -1045,7 +1068,7 @@ fn index_mod(&ast::_mod md) -> mod_index {\n                  //globbed imports have to be resolved lazily.\n                  ast::view_item_import_glob(_, _)) {\n             }\n-            case (ast::view_item_export(_)) { }\n+            case (ast::view_item_export(_, _)) { }\n         }\n     }\n     for (@ast::item it in md.items) {\n@@ -1090,16 +1113,16 @@ fn index_nmod(&ast::native_mod md) -> mod_index {\n                 add_to_index(index, def_ident, mie_view_item(it));\n             }\n             case (ast::view_item_import_glob(_, _)) { }\n-            case (ast::view_item_export(_)) { }\n+            case (ast::view_item_export(_, _)) { }\n         }\n     }\n     for (@ast::native_item it in md.items) {\n         alt (it.node) {\n-            case (ast::native_item_ty(?id, _)) {\n-                add_to_index(index, id, mie_native_item(it));\n+            case (ast::native_item_ty(?ident, _)) {\n+                add_to_index(index, ident, mie_native_item(it));\n             }\n-            case (ast::native_item_fn(?id, _, _, _, _, _)) {\n-                add_to_index(index, id, mie_native_item(it));\n+            case (ast::native_item_fn(?ident, _, _, _, _)) {\n+                add_to_index(index, ident, mie_native_item(it));\n             }\n         }\n     }\n@@ -1142,7 +1165,7 @@ fn check_for_collisions(&@env e, &ast::crate c) {\n     // Module indices make checking those relatively simple -- just check each\n     // name for multiple entities in the same namespace.\n \n-    for each (@tup(ast::def_num, @indexed_mod) m in e.mod_map.items()) {\n+    for each (@tup(ast::node_id, @indexed_mod) m in e.mod_map.items()) {\n         for each (@tup(ident, list[mod_index_entry]) name in\n                  m._1.index.items()) {\n             check_mod_name(*e, name._0, name._1);\n@@ -1225,7 +1248,7 @@ fn check_arm(@env e, &ast::arm a, &() x, &vt[()] v) {\n     visit::visit_arm(a, x, v);\n     fn walk_pat(checker ch, &@ast::pat p) {\n         alt (p.node) {\n-            case (ast::pat_bind(?name, _, _)) { add_name(ch, p.span, name); }\n+            case (ast::pat_bind(?name, _)) { add_name(ch, p.span, name); }\n             case (ast::pat_tag(_, ?children, _)) {\n                 for (@ast::pat child in children) { walk_pat(ch, child); }\n             }"}, {"sha": "726f7b491ef858de1bc6fb1f3c86bed997a3344c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 242, "deletions": 239, "changes": 481, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -37,6 +37,7 @@ import visit::vt;\n import util::common;\n import util::common::istr;\n import util::common::new_def_hash;\n+import util::common::new_int_hash;\n import util::common::new_str_hash;\n import util::common::local_rhs_span;\n import util::common::span;\n@@ -124,22 +125,22 @@ type crate_ctxt =\n         // A mapping from the def_id of each item in this crate to the address\n         // of the first instruction of the item's definition in the executable\n         // we're generating.\n-        hashmap[ast::def_id, ValueRef] item_ids,\n-        hashmap[ast::def_id, @ast::item] items,\n-        hashmap[ast::def_id, @ast::native_item] native_items,\n-        hashmap[ast::def_id, str] item_symbols,\n+        hashmap[ast::node_id, ValueRef] item_ids,\n+        hashmap[ast::node_id, @ast::item] items,\n+        hashmap[ast::node_id, @ast::native_item] native_items,\n+        hashmap[ast::node_id, str] item_symbols,\n         mutable option::t[ValueRef] main_fn,\n         str crate_meta_name,\n         str crate_meta_vers,\n         str crate_meta_extras_hash,\n \n         // TODO: hashmap[tup(tag_id,subtys), @tag_info]\n         hashmap[ty::t, uint] tag_sizes,\n-        hashmap[ast::def_id, ValueRef] discrims,\n-        hashmap[ast::def_id, str] discrim_symbols,\n-        hashmap[ast::def_id, ValueRef] fn_pairs,\n-        hashmap[ast::def_id, ValueRef] consts,\n-        hashmap[ast::def_id, ()] obj_methods,\n+        hashmap[ast::node_id, ValueRef] discrims,\n+        hashmap[ast::node_id, str] discrim_symbols,\n+        hashmap[ast::node_id, ValueRef] fn_pairs,\n+        hashmap[ast::node_id, ValueRef] consts,\n+        hashmap[ast::node_id, ()] obj_methods,\n         hashmap[ty::t, @tydesc_info] tydescs,\n         hashmap[str, ValueRef] module_data,\n         hashmap[ty::t, TypeRef] lltypes,\n@@ -228,20 +229,20 @@ type fn_ctxt =\n         // LLVM-stuff-in-the-frame.\n \n         // Maps arguments to allocas created for them in llallocas.\n-        hashmap[ast::def_id, ValueRef] llargs,\n+        hashmap[ast::node_id, ValueRef] llargs,\n \n         // Maps fields in objects to pointers into the interior of llself's\n         // body.\n-        hashmap[ast::def_id, ValueRef] llobjfields,\n+        hashmap[ast::node_id, ValueRef] llobjfields,\n \n         // Maps the def_ids for local variables to the allocas created for\n         // them in llallocas.\n-        hashmap[ast::def_id, ValueRef] lllocals,\n+        hashmap[ast::node_id, ValueRef] lllocals,\n \n         // The same as above, but for variables accessed via the frame pointer\n         // we pass into an iter, for access to the static environment of the\n         // iter-calling frame.\n-        hashmap[ast::def_id, ValueRef] llupvars,\n+        hashmap[ast::node_id, ValueRef] llupvars,\n \n         // For convenience, a vector of the incoming tydescs for each of this\n         // functions type parameters, fetched via llvm::LLVMGetParam.  For\n@@ -3048,7 +3049,7 @@ fn move_val(@block_ctxt cx, copy_action action, ValueRef dst, ValueRef src,\n                                 ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n }\n \n-fn trans_lit(&@crate_ctxt cx, &ast::lit lit, &ast::ann ann) -> ValueRef {\n+fn trans_lit(&@crate_ctxt cx, &ast::lit lit, ast::node_id id) -> ValueRef {\n     alt (lit.node) {\n         case (ast::lit_int(?i)) { ret C_int(i); }\n         case (ast::lit_uint(?u)) { ret C_int(u as int); }\n@@ -3091,16 +3092,16 @@ fn trans_lit(&@crate_ctxt cx, &ast::lit lit, &ast::ann ann) -> ValueRef {\n \n \n // Converts an annotation to a type\n-fn node_ann_type(&@crate_ctxt cx, &ast::ann a) -> ty::t {\n-    ret ty::ann_to_monotype(cx.tcx, a);\n+fn node_id_type(&@crate_ctxt cx, ast::node_id id) -> ty::t {\n+    ret ty::node_id_to_monotype(cx.tcx, id);\n }\n \n-fn node_type(&@crate_ctxt cx, &span sp, &ast::ann a) -> TypeRef {\n-    ret type_of(cx, sp, node_ann_type(cx, a));\n+fn node_type(&@crate_ctxt cx, &span sp, ast::node_id id) -> TypeRef {\n+    ret type_of(cx, sp, node_id_type(cx, id));\n }\n \n-fn trans_unary(&@block_ctxt cx, ast::unop op, &@ast::expr e, &ast::ann a) ->\n-   result {\n+fn trans_unary(&@block_ctxt cx, ast::unop op, &@ast::expr e,\n+               ast::node_id id) -> result {\n     auto sub = trans_expr(cx, e);\n     auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n     alt (op) {\n@@ -3121,7 +3122,7 @@ fn trans_unary(&@block_ctxt cx, ast::unop op, &@ast::expr e, &ast::ann a) ->\n         case (ast::box(_)) {\n             auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n             auto e_val = sub.val;\n-            auto box_ty = node_ann_type(sub.bcx.fcx.lcx.ccx, a);\n+            auto box_ty = node_id_type(sub.bcx.fcx.lcx.ccx, id);\n             sub = trans_malloc_boxed(sub.bcx, e_ty);\n             find_scope_cx(cx).cleanups +=\n                 [clean(bind drop_ty(_, sub.val, box_ty))];\n@@ -4049,8 +4050,8 @@ fn join_branches(&@block_ctxt parent_cx, &vec[result] ins) -> @block_ctxt {\n tag out_method { return; save_in(ValueRef); }\n \n fn trans_if(&@block_ctxt cx, &@ast::expr cond, &ast::block thn,\n-            &option::t[@ast::expr] els, &ast::ann ann, &out_method output) ->\n-   result {\n+            &option::t[@ast::expr] els, ast::node_id id, &out_method output)\n+    -> result {\n     auto cond_res = trans_expr(cx, cond);\n     auto then_cx = new_scope_block_ctxt(cx, \"then\");\n     auto then_res = trans_block(then_cx, thn, output);\n@@ -4060,14 +4061,14 @@ fn trans_if(&@block_ctxt cx, &@ast::expr cond, &ast::block thn,\n     alt (els) {\n         case (some(?elexpr)) {\n             alt (elexpr.node) {\n-                case (ast::expr_if(_, _, _, ?ann)) {\n+                case (ast::expr_if(_, _, _, ?id)) {\n                     // Synthesize a block here to act as the else block\n                     // containing an if expression. Needed in order for the\n                     // else scope to behave like a normal block scope. A tad\n                     // ugly.\n \n                     let ast::block_ elseif_blk_ =\n-                        rec(stmts=[], expr=some[@ast::expr](elexpr), a=ann);\n+                        rec(stmts=[], expr=some[@ast::expr](elexpr), id=id);\n                     auto elseif_blk = rec(node=elseif_blk_, span=elexpr.span);\n                     else_res = trans_block(else_cx, elseif_blk, output);\n                 }\n@@ -4082,7 +4083,7 @@ fn trans_if(&@block_ctxt cx, &@ast::expr cond, &ast::block thn,\n             }\n             // FIXME: This isn't quite right, particularly re: dynamic types\n \n-            auto expr_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx, ann);\n+            auto expr_ty = ty::node_id_to_type(cx.fcx.lcx.ccx.tcx, id);\n             if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n                 expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n             } else {\n@@ -4130,21 +4131,21 @@ fn trans_for(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n // Searches through a block for all references to locals or upvars in this\n // frame and returns the list of definition IDs thus found.\n fn collect_upvars(&@block_ctxt cx, &ast::block bloc,\n-                  &ast::def_id initial_decl) -> vec[ast::def_id] {\n+                  ast::node_id initial_decl) -> vec[ast::node_id] {\n     type env =\n-        @rec(mutable vec[ast::def_id] refs,\n-             hashmap[ast::def_id, ()] decls,\n+        @rec(mutable vec[ast::node_id] refs,\n+             hashmap[ast::node_id, ()] decls,\n              resolve::def_map def_map);\n \n     fn walk_expr(env e, &@ast::expr expr) {\n         alt (expr.node) {\n-            case (ast::expr_path(?path, ?ann)) {\n-                alt (e.def_map.get(ann.id)) {\n+            case (ast::expr_path(?path, ?id)) {\n+                alt (e.def_map.get(id)) {\n                     case (ast::def_arg(?did)) {\n-                        vec::push[ast::def_id](e.refs, did);\n+                        vec::push(e.refs, did._1);\n                     }\n                     case (ast::def_local(?did)) {\n-                        vec::push[ast::def_id](e.refs, did);\n+                        vec::push(e.refs, did._1);\n                     }\n                     case (_) { }\n                 }\n@@ -4155,11 +4156,10 @@ fn collect_upvars(&@block_ctxt cx, &ast::block bloc,\n     fn walk_local(env e, &@ast::local local) {\n         e.decls.insert(local.node.id, ());\n     }\n-    let vec[ast::def_id] refs = [];\n-    let hashmap[ast::def_id, ()] decls = new_def_hash[()]();\n+    let hashmap[ast::node_id, ()] decls = new_int_hash[()]();\n     decls.insert(initial_decl, ());\n     let env e =\n-        @rec(mutable refs=refs,\n+        @rec(mutable refs=[],\n              decls=decls,\n              def_map=cx.fcx.lcx.ccx.tcx.def_map);\n     auto visitor =\n@@ -4169,8 +4169,8 @@ fn collect_upvars(&@block_ctxt cx, &ast::block bloc,\n     walk::walk_block(*visitor, bloc);\n     // Calculate (refs - decls). This is the set of captured upvars.\n \n-    let vec[ast::def_id] result = [];\n-    for (ast::def_id ref_id_ in e.refs) {\n+    let vec[ast::node_id] result = [];\n+    for (ast::node_id ref_id_ in e.refs) {\n         auto ref_id = ref_id_;\n         if (!decls.contains_key(ref_id)) { result += [ref_id]; }\n     }\n@@ -4208,23 +4208,23 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n     auto lcx = cx.fcx.lcx;\n     // FIXME: possibly support alias-mode here?\n \n-    auto decl_ty = node_ann_type(lcx.ccx, local.node.ann);\n+    auto decl_ty = node_id_type(lcx.ccx, local.node.id);\n     auto decl_id = local.node.id;\n     auto upvars = collect_upvars(cx, body, decl_id);\n-    auto upvar_count = vec::len[ast::def_id](upvars);\n+    auto upvar_count = vec::len(upvars);\n     auto llbindingsptr;\n     if (upvar_count > 0u) {\n         // Gather up the upvars.\n \n         let vec[ValueRef] llbindings = [];\n         let vec[TypeRef] llbindingtys = [];\n-        for (ast::def_id did in upvars) {\n+        for (ast::node_id nid in upvars) {\n             auto llbinding;\n-            alt (cx.fcx.lllocals.find(did)) {\n+            alt (cx.fcx.lllocals.find(nid)) {\n                 case (none) {\n-                    alt (cx.fcx.llupvars.find(did)) {\n+                    alt (cx.fcx.llupvars.find(nid)) {\n                         case (none[ValueRef]) {\n-                            llbinding = cx.fcx.llargs.get(did);\n+                            llbinding = cx.fcx.llargs.get(nid);\n                         }\n                         case (some[ValueRef](?llval)) { llbinding = llval; }\n                     }\n@@ -4338,7 +4338,7 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n \n     // Step 3: Call iter passing [lliterbody, llenv], plus other args.\n     alt (seq.node) {\n-        case (ast::expr_call(?f, ?args, ?ann)) {\n+        case (ast::expr_call(?f, ?args, ?id)) {\n             auto pair = alloca(cx, T_fn_pair(lcx.ccx.tn, iter_body_llty));\n             auto code_cell =\n                 cx.build.GEP(pair, [C_int(0), C_int(abi::fn_field_code)]);\n@@ -4353,7 +4353,7 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n \n             r =\n                 trans_call(cx, f, some[ValueRef](cx.build.Load(pair)), args,\n-                           ann);\n+                           id);\n             ret res(r.bcx, C_nil());\n         }\n     }\n@@ -4394,23 +4394,23 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                    &@block_ctxt next_cx) -> result {\n     alt (pat.node) {\n         case (ast::pat_wild(_)) { ret res(cx, llval); }\n-        case (ast::pat_bind(_, _, _)) { ret res(cx, llval); }\n-        case (ast::pat_lit(?lt, ?ann)) {\n-            auto lllit = trans_lit(cx.fcx.lcx.ccx, *lt, ann);\n-            auto lltype = ty::ann_to_type(cx.fcx.lcx.ccx.tcx, ann);\n+        case (ast::pat_bind(_, _)) { ret res(cx, llval); }\n+        case (ast::pat_lit(?lt, ?id)) {\n+            auto lllit = trans_lit(cx.fcx.lcx.ccx, *lt, id);\n+            auto lltype = ty::node_id_to_type(cx.fcx.lcx.ccx.tcx, id);\n             auto lleq = trans_compare(cx, ast::eq, lltype, llval, lllit);\n             auto matched_cx = new_sub_block_ctxt(lleq.bcx, \"matched_cx\");\n             lleq.bcx.build.CondBr(lleq.val, matched_cx.llbb, next_cx.llbb);\n             ret res(matched_cx, llval);\n         }\n-        case (ast::pat_tag(?id, ?subpats, ?ann)) {\n+        case (ast::pat_tag(?ident, ?subpats, ?id)) {\n             auto lltagptr =\n                 cx.build.PointerCast(llval,\n                                      T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n             auto lldiscrimptr = cx.build.GEP(lltagptr, [C_int(0), C_int(0)]);\n             auto lldiscrim = cx.build.Load(lldiscrimptr);\n             auto vdef =\n-                ast::variant_def_ids(cx.fcx.lcx.ccx.tcx.def_map.get(ann.id));\n+                ast::variant_def_ids(cx.fcx.lcx.ccx.tcx.def_map.get(id));\n             auto variant_tag = 0;\n             auto variants = ty::tag_variants(cx.fcx.lcx.ccx.tcx, vdef._0);\n             auto i = 0;\n@@ -4427,7 +4427,8 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                 cx.build.ICmp(lib::llvm::LLVMIntEQ, lldiscrim,\n                               C_int(variant_tag));\n             cx.build.CondBr(lleq, matched_cx.llbb, next_cx.llbb);\n-            auto ty_params = ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx, ann);\n+            auto ty_params = ty::node_id_to_type_params\n+                (cx.fcx.lcx.ccx.tcx, id);\n             if (vec::len[@ast::pat](subpats) > 0u) {\n                 auto llblobptr =\n                     matched_cx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n@@ -4458,33 +4459,33 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n     alt (pat.node) {\n         case (ast::pat_wild(_)) { ret res(cx, llval); }\n         case (ast::pat_lit(_, _)) { ret res(cx, llval); }\n-        case (ast::pat_bind(?id, ?def_id, ?ann)) {\n+        case (ast::pat_bind(?name, ?id)) {\n             if (bind_alias) {\n-                cx.fcx.lllocals.insert(def_id, llval);\n+                cx.fcx.lllocals.insert(id, llval);\n                 ret res(cx, llval);\n             } else {\n-                auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n+                auto t = node_id_type(cx.fcx.lcx.ccx, id);\n                 auto rslt = alloc_ty(cx, t);\n                 auto dst = rslt.val;\n                 auto bcx = rslt.bcx;\n-                maybe_name_value(cx.fcx.lcx.ccx, dst, id);\n-                bcx.fcx.lllocals.insert(def_id, dst);\n+                maybe_name_value(cx.fcx.lcx.ccx, dst, name);\n+                bcx.fcx.lllocals.insert(id, dst);\n                 bcx.cleanups += [clean(bind drop_slot(_, dst, t))];\n                 ret copy_val(bcx, INIT, dst, llval, t);\n             }\n         }\n-        case (ast::pat_tag(_, ?subpats, ?ann)) {\n+        case (ast::pat_tag(_, ?subpats, ?id)) {\n             if (vec::len[@ast::pat](subpats) == 0u) { ret res(cx, llval); }\n             // Get the appropriate variant for this tag.\n \n             auto vdef =\n-                ast::variant_def_ids(cx.fcx.lcx.ccx.tcx.def_map.get(ann.id));\n+                ast::variant_def_ids(cx.fcx.lcx.ccx.tcx.def_map.get(id));\n             auto lltagptr =\n                 cx.build.PointerCast(llval,\n                                      T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n             auto llblobptr = cx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n             auto ty_param_substs =\n-                ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx, ann);\n+                ty::node_id_to_type_params(cx.fcx.lcx.ccx.tcx, id);\n             auto this_cx = cx;\n             auto i = 0;\n             for (@ast::pat subpat in subpats) {\n@@ -4503,7 +4504,7 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n }\n \n fn trans_alt(&@block_ctxt cx, &@ast::expr expr, &vec[ast::arm] arms,\n-             &ast::ann ann, &out_method output) -> result {\n+             ast::node_id id, &out_method output) -> result {\n     auto expr_res = trans_expr(cx, expr);\n     auto this_cx = expr_res.bcx;\n     let vec[result] arm_results = [];\n@@ -4525,7 +4526,7 @@ fn trans_alt(&@block_ctxt cx, &@ast::expr expr, &vec[ast::arm] arms,\n                    \"non-exhaustive match failure\");\n     // FIXME: This isn't quite right, particularly re: dynamic types\n \n-    auto expr_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx, ann);\n+    auto expr_ty = ty::node_id_to_type(cx.fcx.lcx.ccx.tcx, id);\n     auto expr_llty;\n     if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n         expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n@@ -4577,20 +4578,20 @@ fn trans_external_path(&@block_ctxt cx, &ast::def_id did,\n }\n \n fn lval_generic_fn(&@block_ctxt cx, &ty::ty_param_count_and_ty tpt,\n-                   &ast::def_id fn_id, &ast::ann ann) -> lval_result {\n+                   &ast::def_id fn_id, ast::node_id id) -> lval_result {\n     auto lv;\n     if (cx.fcx.lcx.ccx.sess.get_targ_crate_num() == fn_id._0) {\n         // Internal reference.\n \n-        assert (cx.fcx.lcx.ccx.fn_pairs.contains_key(fn_id));\n-        lv = lval_val(cx, cx.fcx.lcx.ccx.fn_pairs.get(fn_id));\n+        assert (cx.fcx.lcx.ccx.fn_pairs.contains_key(fn_id._1));\n+        lv = lval_val(cx, cx.fcx.lcx.ccx.fn_pairs.get(fn_id._1));\n     } else {\n         // External reference.\n \n         lv = trans_external_path(cx, fn_id, tpt);\n     }\n-    auto tys = ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx, ann);\n-    auto monoty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx, ann);\n+    auto tys = ty::node_id_to_type_params(cx.fcx.lcx.ccx.tcx, id);\n+    auto monoty = ty::node_id_to_type(cx.fcx.lcx.ccx.tcx, id);\n     if (vec::len[ty::t](tys) != 0u) {\n         auto bcx = lv.res.bcx;\n         let vec[ValueRef] tydescs = [];\n@@ -4614,7 +4615,7 @@ fn lval_generic_fn(&@block_ctxt cx, &ty::ty_param_count_and_ty tpt,\n \n fn lookup_discriminant(&@local_ctxt lcx, &ast::def_id tid, &ast::def_id vid)\n    -> ValueRef {\n-    alt (lcx.ccx.discrims.find(vid)) {\n+    alt (lcx.ccx.discrims.find(vid._1)) {\n         case (none) {\n             // It's an external discriminant that we haven't seen yet.\n \n@@ -4626,61 +4627,61 @@ fn lookup_discriminant(&@local_ctxt lcx, &ast::def_id tid, &ast::def_id vid)\n                                  lib::llvm::LLVMExternalLinkage as\n                                      llvm::Linkage);\n             llvm::LLVMSetGlobalConstant(gvar, True);\n-            lcx.ccx.discrims.insert(vid, gvar);\n+            lcx.ccx.discrims.insert(vid._1, gvar);\n             ret gvar;\n         }\n         case (some(?llval)) { ret llval; }\n     }\n }\n \n-fn trans_path(&@block_ctxt cx, &ast::path p, &ast::ann ann) -> lval_result {\n-    alt (cx.fcx.lcx.ccx.tcx.def_map.get(ann.id)) {\n+fn trans_path(&@block_ctxt cx, &ast::path p, ast::node_id id) -> lval_result {\n+    alt (cx.fcx.lcx.ccx.tcx.def_map.get(id)) {\n         case (ast::def_arg(?did)) {\n-            alt (cx.fcx.llargs.find(did)) {\n+            alt (cx.fcx.llargs.find(did._1)) {\n                 case (none) {\n-                    assert (cx.fcx.llupvars.contains_key(did));\n-                    ret lval_mem(cx, cx.fcx.llupvars.get(did));\n+                    assert (cx.fcx.llupvars.contains_key(did._1));\n+                    ret lval_mem(cx, cx.fcx.llupvars.get(did._1));\n                 }\n                 case (some(?llval)) { ret lval_mem(cx, llval); }\n             }\n         }\n         case (ast::def_local(?did)) {\n-            alt (cx.fcx.lllocals.find(did)) {\n+            alt (cx.fcx.lllocals.find(did._1)) {\n                 case (none) {\n-                    assert (cx.fcx.llupvars.contains_key(did));\n-                    ret lval_mem(cx, cx.fcx.llupvars.get(did));\n+                    assert (cx.fcx.llupvars.contains_key(did._1));\n+                    ret lval_mem(cx, cx.fcx.llupvars.get(did._1));\n                 }\n                 case (some(?llval)) { ret lval_mem(cx, llval); }\n             }\n         }\n         case (ast::def_binding(?did)) {\n-            assert (cx.fcx.lllocals.contains_key(did));\n-            ret lval_mem(cx, cx.fcx.lllocals.get(did));\n+            assert (cx.fcx.lllocals.contains_key(did._1));\n+            ret lval_mem(cx, cx.fcx.lllocals.get(did._1));\n         }\n         case (ast::def_obj_field(?did)) {\n-            assert (cx.fcx.llobjfields.contains_key(did));\n-            ret lval_mem(cx, cx.fcx.llobjfields.get(did));\n+            assert (cx.fcx.llobjfields.contains_key(did._1));\n+            ret lval_mem(cx, cx.fcx.llobjfields.get(did._1));\n         }\n         case (ast::def_fn(?did)) {\n             auto tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.tcx, did);\n-            ret lval_generic_fn(cx, tyt, did, ann);\n+            ret lval_generic_fn(cx, tyt, did, id);\n         }\n         case (ast::def_obj(?did)) {\n             auto tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.tcx, did);\n-            ret lval_generic_fn(cx, tyt, did, ann);\n+            ret lval_generic_fn(cx, tyt, did, id);\n         }\n         case (ast::def_variant(?tid, ?vid)) {\n             auto v_tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.tcx, vid);\n             alt (ty::struct(cx.fcx.lcx.ccx.tcx, v_tyt._1)) {\n                 case (ty::ty_fn(_, _, _, _, _)) {\n                     // N-ary variant.\n \n-                    ret lval_generic_fn(cx, v_tyt, vid, ann);\n+                    ret lval_generic_fn(cx, v_tyt, vid, id);\n                 }\n                 case (_) {\n                     // Nullary variant.\n \n-                    auto tag_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n+                    auto tag_ty = node_id_type(cx.fcx.lcx.ccx, id);\n                     auto lldiscrim_gv =\n                         lookup_discriminant(cx.fcx.lcx, tid, vid);\n                     auto lldiscrim = cx.build.Load(lldiscrim_gv);\n@@ -4707,12 +4708,12 @@ fn trans_path(&@block_ctxt cx, &ast::path p, &ast::ann ann) -> lval_result {\n         case (ast::def_const(?did)) {\n             // TODO: externals\n \n-            assert (cx.fcx.lcx.ccx.consts.contains_key(did));\n-            ret lval_mem(cx, cx.fcx.lcx.ccx.consts.get(did));\n+            assert (cx.fcx.lcx.ccx.consts.contains_key(did._1));\n+            ret lval_mem(cx, cx.fcx.lcx.ccx.consts.get(did._1));\n         }\n         case (ast::def_native_fn(?did)) {\n             auto tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.tcx, did);\n-            ret lval_generic_fn(cx, tyt, did, ann);\n+            ret lval_generic_fn(cx, tyt, did, id);\n         }\n         case (_) {\n             cx.fcx.lcx.ccx.sess.span_unimpl(cx.sp, \"def variant in trans\");\n@@ -4721,7 +4722,7 @@ fn trans_path(&@block_ctxt cx, &ast::path p, &ast::ann ann) -> lval_result {\n }\n \n fn trans_field(&@block_ctxt cx, &span sp, ValueRef v, &ty::t t0,\n-               &ast::ident field, &ast::ann ann) -> lval_result {\n+               &ast::ident field, ast::node_id id) -> lval_result {\n     auto r = autoderef(cx, v, t0);\n     auto t = autoderefed_ty(cx.fcx.lcx.ccx, t0);\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n@@ -4759,7 +4760,7 @@ fn trans_field(&@block_ctxt cx, &span sp, ValueRef v, &ty::t t0,\n }\n \n fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base, &@ast::expr idx,\n-               &ast::ann ann) -> lval_result {\n+               ast::node_id id) -> lval_result {\n     // Is this an interior vector?\n \n     auto base_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, base);\n@@ -4781,7 +4782,7 @@ fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base, &@ast::expr idx,\n     } else if (ix_size > int_size) {\n         ix_val = bcx.build.Trunc(ix.val, T_int());\n     } else { ix_val = ix.val; }\n-    auto unit_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n+    auto unit_ty = node_id_type(cx.fcx.lcx.ccx, id);\n     auto unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n     maybe_name_value(cx.fcx.lcx.ccx, unit_sz.val, \"unit_sz\");\n@@ -4839,29 +4840,29 @@ fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base, &@ast::expr idx,\n // immediate).\n fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n     alt (e.node) {\n-        case (ast::expr_path(?p, ?ann)) { ret trans_path(cx, p, ann); }\n-        case (ast::expr_field(?base, ?ident, ?ann)) {\n+        case (ast::expr_path(?p, ?id)) { ret trans_path(cx, p, id); }\n+        case (ast::expr_field(?base, ?ident, ?id)) {\n             auto r = trans_expr(cx, base);\n             auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, base);\n-            ret trans_field(r.bcx, e.span, r.val, t, ident, ann);\n+            ret trans_field(r.bcx, e.span, r.val, t, ident, id);\n         }\n-        case (ast::expr_index(?base, ?idx, ?ann)) {\n-            ret trans_index(cx, e.span, base, idx, ann);\n+        case (ast::expr_index(?base, ?idx, ?id)) {\n+            ret trans_index(cx, e.span, base, idx, id);\n         }\n-        case (ast::expr_unary(?unop, ?base, ?ann)) {\n+        case (ast::expr_unary(?unop, ?base, ?id)) {\n             assert (unop == ast::deref);\n             auto sub = trans_expr(cx, base);\n             auto val =\n                 sub.bcx.build.GEP(sub.val,\n                                   [C_int(0), C_int(abi::box_rc_field_body)]);\n             ret lval_mem(sub.bcx, val);\n         }\n-        case (ast::expr_self_method(?ident, ?ann)) {\n+        case (ast::expr_self_method(?ident, ?id)) {\n             alt ({ cx.fcx.llself }) {\n                 case (some(?pair)) {\n                     auto r = pair.v;\n                     auto t = pair.t;\n-                    ret trans_field(cx, e.span, r, t, ident, ann);\n+                    ret trans_field(cx, e.span, r, t, ident, id);\n                 }\n                 case (_) {\n                     // Shouldn't happen.\n@@ -4898,10 +4899,10 @@ fn int_cast(&@block_ctxt bcx, TypeRef lldsttype, TypeRef llsrctype,\n     ret bcx.build.TruncOrBitCast(llsrc, lldsttype);\n }\n \n-fn trans_cast(&@block_ctxt cx, &@ast::expr e, &ast::ann ann) -> result {\n+fn trans_cast(&@block_ctxt cx, &@ast::expr e, ast::node_id id) -> result {\n     auto e_res = trans_expr(cx, e);\n     auto llsrctype = val_ty(e_res.val);\n-    auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n+    auto t = node_id_type(cx.fcx.lcx.ccx, id);\n     auto lldsttype = type_of(cx.fcx.lcx.ccx, e.span, t);\n     if (!ty::type_is_fp(cx.fcx.lcx.ccx.tcx, t)) {\n \n@@ -5043,7 +5044,7 @@ fn trans_bind_thunk(&@local_ctxt cx, &span sp, &ty::t incoming_fty,\n }\n \n fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n-              &vec[option::t[@ast::expr]] args, &ast::ann ann) -> result {\n+              &vec[option::t[@ast::expr]] args, ast::node_id id) -> result {\n     auto f_res = trans_lval(cx, f);\n     if (f_res.is_mem) {\n         cx.fcx.lcx.ccx.sess.unimpl(\"re-binding existing function\");\n@@ -5077,7 +5078,7 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n             ret f_res.res;\n         } else {\n             auto bcx = f_res.res.bcx;\n-            auto pair_t = node_type(cx.fcx.lcx.ccx, cx.sp, ann);\n+            auto pair_t = node_type(cx.fcx.lcx.ccx, cx.sp, id);\n             auto pair_v = alloca(bcx, pair_t);\n             // Translate the bound expressions.\n \n@@ -5188,7 +5189,7 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n \n             auto pair_code =\n                 bcx.build.GEP(pair_v, [C_int(0), C_int(abi::fn_field_code)]);\n-            let ty::t pair_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n+            let ty::t pair_ty = node_id_type(cx.fcx.lcx.ccx, id);\n             let ValueRef llthunk =\n                 trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty,\n                                  args, closure_ty, bound_tys, ty_param_count);\n@@ -5350,7 +5351,7 @@ fn trans_args(&@block_ctxt cx, ValueRef llenv, &option::t[ValueRef] llobj,\n }\n \n fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n-              &vec[@ast::expr] args, &ast::ann ann) -> result {\n+              &vec[@ast::expr] args, ast::node_id id) -> result {\n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n     // expression because of the hack that allows us to process self-calls\n     // with trans_call.\n@@ -5386,7 +5387,7 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n         }\n         case (_) { fn_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, f); }\n     }\n-    auto ret_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx, ann);\n+    auto ret_ty = ty::node_id_to_type(cx.fcx.lcx.ccx.tcx, id);\n     auto args_res =\n         trans_args(f_res.res.bcx, llenv, f_res.llobj, f_res.generic,\n                    lliterbody, args, fn_ty);\n@@ -5425,9 +5426,10 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n     ret res(bcx, retval);\n }\n \n-fn trans_tup(&@block_ctxt cx, &vec[ast::elt] elts, &ast::ann ann) -> result {\n+fn trans_tup(&@block_ctxt cx, &vec[ast::elt] elts, ast::node_id id)\n+    -> result {\n     auto bcx = cx;\n-    auto t = node_ann_type(bcx.fcx.lcx.ccx, ann);\n+    auto t = node_id_type(bcx.fcx.lcx.ccx, id);\n     auto tup_res = alloc_ty(bcx, t);\n     auto tup_val = tup_res.val;\n     bcx = tup_res.bcx;\n@@ -5445,9 +5447,9 @@ fn trans_tup(&@block_ctxt cx, &vec[ast::elt] elts, &ast::ann ann) -> result {\n     ret res(bcx, tup_val);\n }\n \n-fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, &ast::ann ann) ->\n+fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, ast::node_id id) ->\n    result {\n-    auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n+    auto t = node_id_type(cx.fcx.lcx.ccx, id);\n     auto unit_ty = t;\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty::ty_vec(?mt)) { unit_ty = mt.ty; }\n@@ -5505,9 +5507,9 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, &ast::ann ann) ->\n \n \n // TODO: Move me to ivec::\n-fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann) ->\n-   result {\n-    auto typ = node_ann_type(bcx.fcx.lcx.ccx, ann);\n+fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, ast::node_id id) ->\n+        result {\n+    auto typ = node_id_type(bcx.fcx.lcx.ccx, id);\n     auto unit_ty;\n     alt (ty::struct(bcx.fcx.lcx.ccx.tcx, typ)) {\n         case (ty::ty_ivec(?mt)) { unit_ty = mt.ty; }\n@@ -5599,9 +5601,9 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann) ->\n }\n \n fn trans_rec(&@block_ctxt cx, &vec[ast::field] fields,\n-             &option::t[@ast::expr] base, &ast::ann ann) -> result {\n+             &option::t[@ast::expr] base, ast::node_id id) -> result {\n     auto bcx = cx;\n-    auto t = node_ann_type(bcx.fcx.lcx.ccx, ann);\n+    auto t = node_id_type(bcx.fcx.lcx.ccx, id);\n     auto rec_res = alloc_ty(bcx, t);\n     auto rec_val = rec_res.val;\n     bcx = rec_res.bcx;\n@@ -5653,18 +5655,18 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n     // FIXME Fill in cx.sp\n \n     alt (e.node) {\n-        case (ast::expr_lit(?lit, ?ann)) {\n-            ret res(cx, trans_lit(cx.fcx.lcx.ccx, *lit, ann));\n+        case (ast::expr_lit(?lit, ?id)) {\n+            ret res(cx, trans_lit(cx.fcx.lcx.ccx, *lit, id));\n         }\n-        case (ast::expr_unary(?op, ?x, ?ann)) {\n-            if (op != ast::deref) { ret trans_unary(cx, op, x, ann); }\n+        case (ast::expr_unary(?op, ?x, ?id)) {\n+            if (op != ast::deref) { ret trans_unary(cx, op, x, id); }\n         }\n         case (ast::expr_binary(?op, ?x, ?y, _)) {\n             ret trans_binary(cx, op, x, y);\n         }\n-        case (ast::expr_if(?cond, ?thn, ?els, ?ann)) {\n-            ret with_out_method(bind trans_if(cx, cond, thn, els, ann, _), cx,\n-                                ann, output);\n+        case (ast::expr_if(?cond, ?thn, ?els, ?id)) {\n+            ret with_out_method(bind trans_if(cx, cond, thn, els, id, _), cx,\n+                                id, output);\n         }\n         case (ast::expr_if_check(?cond, ?thn, ?els, ?ann)) {\n             ret with_out_method(bind trans_if(cx, cond, thn, els, ann, _), cx,\n@@ -5682,14 +5684,14 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n         case (ast::expr_do_while(?body, ?cond, _)) {\n             ret trans_do_while(cx, body, cond);\n         }\n-        case (ast::expr_alt(?expr, ?arms, ?ann)) {\n-            ret with_out_method(bind trans_alt(cx, expr, arms, ann, _), cx,\n-                                ann, output);\n+        case (ast::expr_alt(?expr, ?arms, ?id)) {\n+            ret with_out_method(bind trans_alt(cx, expr, arms, id, _), cx,\n+                                id, output);\n         }\n-        case (ast::expr_fn(?f, ?ann)) {\n+        case (ast::expr_fn(?f, ?id)) {\n             auto ccx = cx.fcx.lcx.ccx;\n             let TypeRef llfnty =\n-                alt (ty::struct(ccx.tcx, node_ann_type(ccx, ann))) {\n+                alt (ty::struct(ccx.tcx, node_id_type(ccx, id))) {\n                     case (ty::ty_fn(?proto, ?inputs, ?output, _, _)) {\n                         type_of_fn_full(ccx, e.span, proto, none, inputs,\n                                         output, 0u)\n@@ -5698,14 +5700,14 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n             auto sub_cx = extend_path(cx.fcx.lcx, ccx.names.next(\"anon\"));\n             auto s = mangle_internal_name_by_path(ccx, sub_cx.path);\n             auto llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfnty);\n-            trans_fn(sub_cx, e.span, f, llfn, none, [], ann);\n+            trans_fn(sub_cx, e.span, f, llfn, none, [], id);\n             ret res(cx, create_fn_pair(ccx, s, llfnty, llfn, false));\n         }\n-        case (ast::expr_block(?blk, ?ann)) {\n+        case (ast::expr_block(?blk, ?id)) {\n             auto sub_cx = new_scope_block_ctxt(cx, \"block-expr body\");\n             auto next_cx = new_sub_block_ctxt(cx, \"next\");\n             auto sub =\n-                with_out_method(bind trans_block(sub_cx, blk, _), cx, ann,\n+                with_out_method(bind trans_block(sub_cx, blk, _), cx, id,\n                                 output);\n             cx.build.Br(sub_cx.llbb);\n             sub.bcx.build.Br(next_cx.llbb);\n@@ -5788,22 +5790,22 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n                 copy_val(v.bcx, DROP_EXISTING, lhs_res.res.val, v.val, t);\n             ret res(copy_res.bcx, C_nil());\n         }\n-        case (ast::expr_bind(?f, ?args, ?ann)) {\n-            ret trans_bind(cx, f, args, ann);\n+        case (ast::expr_bind(?f, ?args, ?id)) {\n+            ret trans_bind(cx, f, args, id);\n         }\n-        case (ast::expr_call(?f, ?args, ?ann)) {\n-            ret trans_call(cx, f, none[ValueRef], args, ann);\n+        case (ast::expr_call(?f, ?args, ?id)) {\n+            ret trans_call(cx, f, none[ValueRef], args, id);\n         }\n-        case (ast::expr_cast(?e, _, ?ann)) { ret trans_cast(cx, e, ann); }\n-        case (ast::expr_vec(?args, _, ast::sk_rc, ?ann)) {\n-            ret trans_vec(cx, args, ann);\n+        case (ast::expr_cast(?e, _, ?id)) { ret trans_cast(cx, e, id); }\n+        case (ast::expr_vec(?args, _, ast::sk_rc, ?id)) {\n+            ret trans_vec(cx, args, id);\n         }\n-        case (ast::expr_vec(?args, _, ast::sk_unique, ?ann)) {\n-            ret trans_ivec(cx, args, ann);\n+        case (ast::expr_vec(?args, _, ast::sk_unique, ?id)) {\n+            ret trans_ivec(cx, args, id);\n         }\n-        case (ast::expr_tup(?args, ?ann)) { ret trans_tup(cx, args, ann); }\n-        case (ast::expr_rec(?args, ?base, ?ann)) {\n-            ret trans_rec(cx, args, base, ann);\n+        case (ast::expr_tup(?args, ?id)) { ret trans_tup(cx, args, id); }\n+        case (ast::expr_rec(?args, ?base, ?id)) {\n+            ret trans_rec(cx, args, base, id);\n         }\n         case (ast::expr_ext(_, _, _, ?expanded, _)) {\n             ret trans_expr(cx, expanded);\n@@ -5828,19 +5830,19 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n         case (ast::expr_ret(?e, _)) { ret trans_ret(cx, e); }\n         case (ast::expr_put(?e, _)) { ret trans_put(cx, e); }\n         case (ast::expr_be(?e, _)) { ret trans_be(cx, e); }\n-        case (ast::expr_port(?ann)) { ret trans_port(cx, ann); }\n-        case (ast::expr_chan(?e, ?ann)) { ret trans_chan(cx, e, ann); }\n-        case (ast::expr_send(?lhs, ?rhs, ?ann)) {\n-            ret trans_send(cx, lhs, rhs, ann);\n+        case (ast::expr_port(?id)) { ret trans_port(cx, id); }\n+        case (ast::expr_chan(?e, ?id)) { ret trans_chan(cx, e, id); }\n+        case (ast::expr_send(?lhs, ?rhs, ?id)) {\n+            ret trans_send(cx, lhs, rhs, id);\n         }\n-        case (ast::expr_recv(?lhs, ?rhs, ?ann)) {\n-            ret trans_recv(cx, lhs, rhs, ann);\n+        case (ast::expr_recv(?lhs, ?rhs, ?id)) {\n+            ret trans_recv(cx, lhs, rhs, id);\n         }\n-        case (ast::expr_spawn(?dom, ?name, ?func, ?args, ?ann)) {\n-            ret trans_spawn(cx, dom, name, func, args, ann);\n+        case (ast::expr_spawn(?dom, ?name, ?func, ?args, ?id)) {\n+            ret trans_spawn(cx, dom, name, func, args, id);\n         }\n-        case (ast::expr_anon_obj(?anon_obj, ?tps, ?odid, ?ann)) {\n-            ret trans_anon_obj(cx, e.span, anon_obj, tps, odid.ctor, ann);\n+        case (ast::expr_anon_obj(?anon_obj, ?tps, ?odid, ?id)) {\n+            ret trans_anon_obj(cx, e.span, anon_obj, tps, odid.ctor, id);\n         }\n         case (_) {\n             // The expression is an lvalue. Fall through.\n@@ -5857,12 +5859,12 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n }\n \n fn with_out_method(fn(&out_method) -> result  work, @block_ctxt cx,\n-                   &ast::ann ann, &out_method outer_output) -> result {\n+                   ast::node_id id, &out_method outer_output) -> result {\n     auto ccx = cx.fcx.lcx.ccx;\n     if (outer_output != return) {\n         ret work(outer_output);\n     } else {\n-        auto tp = node_ann_type(ccx, ann);\n+        auto tp = node_id_type(ccx, id);\n         if (ty::type_is_nil(ccx.tcx, tp)) { ret work(return); }\n         auto res_alloca = alloc_ty(cx, tp);\n         cx = zero_alloca(res_alloca.bcx, res_alloca.val, tp).bcx;\n@@ -6144,8 +6146,8 @@ fn trans_be(&@block_ctxt cx, &@ast::expr e) -> result {\n     ret trans_ret(cx, some(e));\n }\n \n-fn trans_port(&@block_ctxt cx, &ast::ann ann) -> result {\n-    auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n+fn trans_port(&@block_ctxt cx, ast::node_id id) -> result {\n+    auto t = node_id_type(cx.fcx.lcx.ccx, id);\n     auto unit_ty;\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty::ty_port(?t)) { unit_ty = t; }\n@@ -6165,15 +6167,15 @@ fn trans_port(&@block_ctxt cx, &ast::ann ann) -> result {\n     ret res(bcx, port_val);\n }\n \n-fn trans_chan(&@block_ctxt cx, &@ast::expr e, &ast::ann ann) -> result {\n+fn trans_chan(&@block_ctxt cx, &@ast::expr e, ast::node_id id) -> result {\n     auto bcx = cx;\n     auto prt = trans_expr(bcx, e);\n     bcx = prt.bcx;\n     auto prt_val = bcx.build.PointerCast(prt.val, T_opaque_port_ptr());\n     auto chan_raw_val =\n         bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_chan,\n                        [bcx.fcx.lltaskptr, prt_val]);\n-    auto chan_ty = node_ann_type(bcx.fcx.lcx.ccx, ann);\n+    auto chan_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n     auto chan_llty = type_of(bcx.fcx.lcx.ccx, e.span, chan_ty);\n     auto chan_val = bcx.build.PointerCast(chan_raw_val, chan_llty);\n     auto dropref = clean(bind drop_ty(_, chan_val, chan_ty));\n@@ -6182,7 +6184,7 @@ fn trans_chan(&@block_ctxt cx, &@ast::expr e, &ast::ann ann) -> result {\n }\n \n fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n-               &@ast::expr func, &vec[@ast::expr] args, &ast::ann ann) ->\n+               &@ast::expr func, &vec[@ast::expr] args, ast::node_id id) ->\n    result {\n     auto bcx = cx;\n     // Make the task name\n@@ -6270,7 +6272,7 @@ fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n     bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.start_task,\n                    [bcx.fcx.lltaskptr, new_task, llfnptr_i, llargs_i,\n                     args_size]);\n-    auto task_ty = node_ann_type(bcx.fcx.lcx.ccx, ann);\n+    auto task_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n     auto dropref = clean(bind drop_ty(_, new_task, task_ty));\n     find_scope_cx(bcx).cleanups += [dropref];\n     ret res(bcx, new_task);\n@@ -6377,13 +6379,13 @@ fn deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t, ValueRef target_task)\n }\n \n fn trans_send(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n-              &ast::ann ann) -> result {\n+              ast::node_id id) -> result {\n     auto bcx = cx;\n     auto chn = trans_expr(bcx, lhs);\n     bcx = chn.bcx;\n     auto data = trans_expr(bcx, rhs);\n     bcx = data.bcx;\n-    auto chan_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n+    auto chan_ty = node_id_type(cx.fcx.lcx.ccx, id);\n     auto unit_ty;\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, chan_ty)) {\n         case (ty::ty_chan(?t)) { unit_ty = t; }\n@@ -6403,12 +6405,12 @@ fn trans_send(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n }\n \n fn trans_recv(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n-              &ast::ann ann) -> result {\n+              ast::node_id id) -> result {\n     auto bcx = cx;\n     auto data = trans_lval(bcx, rhs);\n     assert (data.is_mem);\n     bcx = data.res.bcx;\n-    auto unit_ty = node_ann_type(bcx.fcx.lcx.ccx, ann);\n+    auto unit_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n     // FIXME: calculate copy init-ness in typestate.\n \n     ret recv_val(bcx, data.res.val, lhs, unit_ty, DROP_EXISTING);\n@@ -6469,9 +6471,10 @@ fn recv_val(&@block_ctxt cx, ValueRef to, &@ast::expr from, &ty::t unit_ty,\n // function and putting it in the generated code as an object item, we are\n // instead \"inlining\" the construction of the object and returning the object\n // itself.\n-fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n-                  &vec[ast::ty_param] ty_params, ast::def_id oid,\n-                  &ast::ann ann) -> result {\n+fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj, \n+                  &vec[ast::ty_param] ty_params, ast::node_id oid,\n+                  ast::node_id id) -> result {\n+\n     // Right now, we're assuming that anon objs don't take ty params, even\n     // though the AST supports it.  It's nonsensical to write an expression\n     // like \"obj[T](){ ... with ... }\", since T is never instantiated;\n@@ -6498,7 +6501,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n     // trans_obj for translating the anonymous wrapper object.  Eventually we\n     // should abstract this code out of trans_anon_obj and trans_obj.\n \n-    auto self_ty = ty::ann_to_type(ccx.tcx, ann);\n+    auto self_ty = ty::node_id_to_type(ccx.tcx, id);\n     auto llself_ty = type_of(ccx, sp, self_ty);\n     // Allocate the object that we're going to return.  It's a two-word pair\n     // containing a vtable pointer and a body pointer.\n@@ -6569,7 +6572,7 @@ fn init_local(&@block_ctxt cx, &@ast::local local) -> result {\n \n     assert (cx.fcx.lllocals.contains_key(local.node.id));\n     auto llptr = cx.fcx.lllocals.get(local.node.id);\n-    auto ty = node_ann_type(cx.fcx.lcx.ccx, local.node.ann);\n+    auto ty = node_id_type(cx.fcx.lcx.ccx, local.node.id);\n     auto bcx = cx;\n     find_scope_cx(cx).cleanups += [clean(bind drop_slot(_, llptr, ty))];\n     alt (local.node.init) {\n@@ -6581,8 +6584,8 @@ fn init_local(&@block_ctxt cx, &@ast::local local) -> result {\n                     // the value.\n \n                     ty =\n-                        node_ann_type(cx.fcx.lcx.ccx,\n-                                      ty::expr_ann(init.expr));\n+                        node_id_type(cx.fcx.lcx.ccx,\n+                                      ty::expr_node_id(init.expr));\n                     auto sub = trans_expr(bcx, init.expr);\n                     bcx = copy_val(sub.bcx, INIT, llptr, sub.val, ty).bcx;\n                 }\n@@ -6794,7 +6797,7 @@ fn alloc_ty(&@block_ctxt cx, &ty::t t) -> result {\n }\n \n fn alloc_local(&@block_ctxt cx, &@ast::local local) -> result {\n-    auto t = node_ann_type(cx.fcx.lcx.ccx, local.node.ann);\n+    auto t = node_id_type(cx.fcx.lcx.ccx, local.node.id);\n     auto r = alloc_ty(cx, t);\n     r.bcx.fcx.lllocals.insert(local.node.id, r.val);\n     ret r;\n@@ -6890,10 +6893,11 @@ fn new_fn_ctxt(@local_ctxt cx, &span sp, ValueRef llfndecl) -> @fn_ctxt {\n     let ValueRef llretptr = llvm::LLVMGetParam(llfndecl, 0u);\n     let ValueRef lltaskptr = llvm::LLVMGetParam(llfndecl, 1u);\n     let ValueRef llenv = llvm::LLVMGetParam(llfndecl, 2u);\n-    let hashmap[ast::def_id, ValueRef] llargs = new_def_hash[ValueRef]();\n-    let hashmap[ast::def_id, ValueRef] llobjfields = new_def_hash[ValueRef]();\n-    let hashmap[ast::def_id, ValueRef] lllocals = new_def_hash[ValueRef]();\n-    let hashmap[ast::def_id, ValueRef] llupvars = new_def_hash[ValueRef]();\n+    let hashmap[ast::node_id, ValueRef] llargs = new_int_hash[ValueRef]();\n+    let hashmap[ast::node_id, ValueRef] llobjfields =\n+        new_int_hash[ValueRef]();\n+    let hashmap[ast::node_id, ValueRef] lllocals = new_int_hash[ValueRef]();\n+    let hashmap[ast::node_id, ValueRef] llupvars = new_int_hash[ValueRef]();\n     auto derived_tydescs =\n         map::mk_hashmap[ty::t, derived_tydesc_info](ty::hash_ty, ty::eq_ty);\n     auto llbbs = mk_standard_basic_blocks(llfndecl);\n@@ -7034,8 +7038,8 @@ fn is_terminated(&@block_ctxt cx) -> bool {\n     ret llvm::LLVMIsATerminatorInst(inst) as int != 0;\n }\n \n-fn arg_tys_of_fn(&@crate_ctxt ccx, ast::ann ann) -> vec[ty::arg] {\n-    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx, ann))) {\n+fn arg_tys_of_fn(&@crate_ctxt ccx,ast::node_id id) -> vec[ty::arg] {\n+    alt (ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, id))) {\n         case (ty::ty_fn(_, ?arg_tys, _, _, _)) { ret arg_tys; }\n     }\n }\n@@ -7044,7 +7048,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, val_self_pair llself) {\n     auto bcx = llstaticallocas_block_ctxt(fcx);\n     let vec[ty::t] field_tys = [];\n     for (ast::obj_field f in bcx.fcx.lcx.obj_fields) {\n-        field_tys += [node_ann_type(bcx.fcx.lcx.ccx, f.ann)];\n+        field_tys += [node_id_type(bcx.fcx.lcx.ccx, f.id)];\n     }\n     // Synthesize a tuple type for the fields so that GEP_tup_like() can work\n     // its magic.\n@@ -7107,28 +7111,28 @@ fn finish_fn(&@fn_ctxt fcx, BasicBlockRef lltop) {\n // function.\n fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n             option::t[ty_self_pair] ty_self, &vec[ast::ty_param] ty_params,\n-            &ast::ann ann) {\n+            ast::node_id id) {\n     set_uwtable(llfndecl);\n     // Set up arguments to the function.\n \n     auto fcx = new_fn_ctxt(cx, sp, llfndecl);\n     create_llargs_for_fn_args(fcx, f.proto, ty_self,\n-                              ty::ret_ty_of_fn(cx.ccx.tcx, ann), \n+                              ty::ret_ty_of_fn(cx.ccx.tcx, id), \n                               f.decl.inputs, ty_params);\n     copy_any_self_to_alloca(fcx, ty_self);\n     alt ({ fcx.llself }) {\n         case (some(?llself)) { populate_fn_ctxt_from_llself(fcx, llself); }\n         case (_) { }\n     }\n-    auto arg_tys = arg_tys_of_fn(fcx.lcx.ccx, ann);\n+    auto arg_tys = arg_tys_of_fn(fcx.lcx.ccx, id);\n     copy_args_to_allocas(fcx, f.decl.inputs, arg_tys);\n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n \n     auto bcx = new_top_block_ctxt(fcx);\n     add_cleanups_for_args(bcx, f.decl.inputs, arg_tys);\n     auto lltop = bcx.llbb;\n-    auto block_ty = node_ann_type(cx.ccx, f.body.node.a);\n+    auto block_ty = node_id_type(cx.ccx, f.body.node.id);\n     // This call to trans_block is the place where we bridge between\n     // translation calls that don't have a return value (trans_crate,\n     // trans_mod, trans_item, trans_obj, et cetera) and those that do\n@@ -7171,7 +7175,7 @@ fn create_vtbl(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n         std::sort::merge_sort[@ast::method](bind meth_lteq(_, _), ob.methods);\n     for (@ast::method m in meths) {\n         auto llfnty = T_nil();\n-        alt (ty::struct(cx.ccx.tcx, node_ann_type(cx.ccx, m.node.ann))) {\n+        alt (ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.node.id))) {\n             case (ty::ty_fn(?proto, ?inputs, ?output, _, _)) {\n                 llfnty =\n                     type_of_fn_full(cx.ccx, m.span, proto,\n@@ -7192,7 +7196,7 @@ fn create_vtbl(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n         cx.ccx.item_symbols.insert(m.node.id, s);\n         trans_fn(mcx, m.span, m.node.meth, llfn,\n                  some[ty_self_pair](tup(llself_ty, self_ty)), ty_params,\n-                 m.node.ann);\n+                 m.node.id);\n         methods += [llfn];\n     }\n     auto vtbl = C_struct(methods);\n@@ -7215,20 +7219,20 @@ fn trans_dtor(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n     cx.ccx.item_symbols.insert(dtor.node.id, s);\n     trans_fn(cx, dtor.span, dtor.node.meth, llfn,\n              some[ty_self_pair](tup(llself_ty, self_ty)), ty_params,\n-             dtor.node.ann);\n+             dtor.node.id);\n     ret llfn;\n }\n \n \n // trans_obj: creates an LLVM function that is the object constructor for the\n // object being translated.\n-fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::def_id oid,\n-             &vec[ast::ty_param] ty_params, &ast::ann ann) {\n+fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n+             &vec[ast::ty_param] ty_params, ast::node_id type_id) {\n     // To make a function, we have to create a function context and, inside\n     // that, a number of block contexts for which code is generated.\n \n     auto ccx = cx.ccx;\n-    auto llctor_decl = ccx.item_ids.get(oid);\n+    auto llctor_decl = ccx.item_ids.get(ctor_id);\n     // Much like trans_fn, we must create an LLVM function, but since we're\n     // starting with an ast::_obj rather than an ast::_fn, we have some setup\n     // work to do.\n@@ -7245,9 +7249,9 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::def_id oid,\n     // Both regular arguments and type parameters are handled here.\n \n     create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty_self_pair],\n-                              ty::ret_ty_of_fn(ccx.tcx, ann),\n+                              ty::ret_ty_of_fn(ccx.tcx, type_id),\n                               fn_args, ty_params);\n-    let vec[ty::arg] arg_tys = arg_tys_of_fn(ccx, ann);\n+    let vec[ty::arg] arg_tys = arg_tys_of_fn(ccx, type_id);\n     copy_args_to_allocas(fcx, fn_args, arg_tys);\n     //  Create the first block context in the function and keep a handle on it\n     //  to pass to finish_fn later.\n@@ -7257,7 +7261,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::def_id oid,\n     // Pick up the type of this object by looking at our own output type, that\n     // is, the output type of the object constructor we're building.\n \n-    auto self_ty = ty::ret_ty_of_fn(ccx.tcx, ann);\n+    auto self_ty = ty::ret_ty_of_fn(ccx.tcx, type_id);\n     auto llself_ty = type_of(ccx, sp, self_ty);\n     // Set up the two-word pair that we're going to return from the object\n     // constructor we're building.  The two elements of this pair will be a\n@@ -7410,7 +7414,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::def_id oid,\n     finish_fn(fcx, lltop);\n }\n \n-fn trans_tag_variant(@local_ctxt cx, ast::def_id tag_id,\n+fn trans_tag_variant(@local_ctxt cx, ast::node_id tag_id,\n                      &ast::variant variant, int index,\n                      &vec[ast::ty_param] ty_params) {\n     if (vec::len[ast::variant_arg](variant.node.args) == 0u) {\n@@ -7432,16 +7436,15 @@ fn trans_tag_variant(@local_ctxt cx, ast::def_id tag_id,\n     let ValueRef llfndecl = cx.ccx.item_ids.get(variant.node.id);\n     auto fcx = new_fn_ctxt(cx, variant.span, llfndecl);\n     create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty_self_pair],\n-                              ty::ret_ty_of_fn(cx.ccx.tcx, variant.node.ann),\n-                              fn_args,\n-                              ty_params);\n+                              ty::ret_ty_of_fn(cx.ccx.tcx, variant.node.id),\n+                              fn_args, ty_params);\n     let vec[ty::t] ty_param_substs = [];\n     i = 0u;\n     for (ast::ty_param tp in ty_params) {\n         ty_param_substs += [ty::mk_param(cx.ccx.tcx, i)];\n         i += 1u;\n     }\n-    auto arg_tys = arg_tys_of_fn(cx.ccx, variant.node.ann);\n+    auto arg_tys = arg_tys_of_fn(cx.ccx, variant.node.id);\n     copy_args_to_allocas(fcx, fn_args, arg_tys);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n@@ -7455,7 +7458,8 @@ fn trans_tag_variant(@local_ctxt cx, ast::def_id tag_id,\n     i = 0u;\n     for (ast::variant_arg va in variant.node.args) {\n         auto rslt =\n-            GEP_tag(bcx, llblobptr, tag_id, variant.node.id, ty_param_substs,\n+            GEP_tag(bcx, llblobptr, ast::local_def(tag_id),\n+                    ast::local_def(variant.node.id), ty_param_substs,\n                     i as int);\n         bcx = rslt.bcx;\n         auto lldestptr = rslt.val;\n@@ -7486,21 +7490,20 @@ fn trans_tag_variant(@local_ctxt cx, ast::def_id tag_id,\n // that does so later on?\n fn trans_const_expr(&@crate_ctxt cx, @ast::expr e) -> ValueRef {\n     alt (e.node) {\n-        case (ast::expr_lit(?lit, ?ann)) { ret trans_lit(cx, *lit, ann); }\n+        case (ast::expr_lit(?lit, ?id)) { ret trans_lit(cx, *lit, id); }\n         case (_) {\n             cx.sess.span_unimpl(e.span, \"consts that's not a plain literal\");\n         }\n     }\n }\n \n-fn trans_const(&@crate_ctxt cx, @ast::expr e, &ast::def_id cid,\n-               &ast::ann ann) {\n-    auto t = node_ann_type(cx, ann);\n+fn trans_const(&@crate_ctxt cx, @ast::expr e, ast::node_id id) {\n+    auto t = node_id_type(cx, id);\n     auto v = trans_const_expr(cx, e);\n     // The scalars come back as 1st class LLVM vals\n     // which we have to stick into global constants.\n \n-    auto g = cx.consts.get(cid);\n+    auto g = cx.consts.get(id);\n     llvm::LLVMSetInitializer(g, v);\n     llvm::LLVMSetGlobalConstant(g, True);\n }\n@@ -7511,13 +7514,13 @@ fn trans_item(@local_ctxt cx, &ast::item item) {\n             auto sub_cx = extend_path(cx, item.ident);\n             auto llfndecl = cx.ccx.item_ids.get(item.id);\n             trans_fn(sub_cx, item.span, f, llfndecl, none[ty_self_pair], tps,\n-                     item.ann);\n+                     item.id);\n         }\n         case (ast::item_obj(?ob, ?tps, ?ctor_id)) {\n             auto sub_cx =\n                 @rec(obj_typarams=tps, obj_fields=ob.fields\n                      with *extend_path(cx, item.ident));\n-            trans_obj(sub_cx, item.span, ob, ctor_id, tps, item.ann);\n+            trans_obj(sub_cx, item.span, ob, ctor_id, tps, item.id);\n         }\n         case (ast::item_mod(?m)) {\n             auto sub_cx =\n@@ -7534,7 +7537,7 @@ fn trans_item(@local_ctxt cx, &ast::item item) {\n             }\n         }\n         case (ast::item_const(_, ?expr)) {\n-            trans_const(cx.ccx, expr, item.id, item.ann);\n+            trans_const(cx.ccx, expr, item.id);\n         }\n         case (_) {/* fall through */ }\n     }\n@@ -7557,10 +7560,10 @@ fn get_pair_fn_ty(TypeRef llpairty) -> TypeRef {\n }\n \n fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp, vec[str] path, str flav,\n-                    vec[ast::ty_param] ty_params, &ast::ann ann,\n-                    ast::def_id id) {\n+                    vec[ast::ty_param] ty_params, ast::node_id node_id,\n+                    ast::node_id def_id) {\n     auto llfty;\n-    alt (ty::struct(ccx.tcx, node_ann_type(ccx, ann))) {\n+    alt (ty::struct(ccx.tcx, node_id_type(ccx, node_id))) {\n         case (ty::ty_fn(?proto, ?inputs, ?output, _, _)) {\n             llfty =\n                 type_of_fn(ccx, sp, proto, inputs, output,\n@@ -7581,8 +7584,8 @@ fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp, vec[str] path, str flav,\n     let ValueRef llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfty);\n     // Declare the global constant pair that points to it.\n \n-    let str ps = mangle_exported_name(ccx, path, node_ann_type(ccx, ann));\n-    register_fn_pair(ccx, ps, llfty, llfn, id);\n+    let str ps = mangle_exported_name(ccx, path, node_id_type(ccx, node_id));\n+    register_fn_pair(ccx, ps, llfty, llfn, def_id);\n     if (is_main) {\n         if (ccx.main_fn != none[ValueRef]) {\n             ccx.sess.span_fatal(sp, \"multiple 'main' functions\");\n@@ -7608,7 +7611,7 @@ fn create_fn_pair(&@crate_ctxt cx, str ps, TypeRef llfnty, ValueRef llfn,\n }\n \n fn register_fn_pair(&@crate_ctxt cx, str ps, TypeRef llfnty, ValueRef llfn,\n-                    ast::def_id id) {\n+                    ast::node_id id) {\n     // FIXME: We should also hide the unexported pairs in crates.\n \n     auto gvar =\n@@ -7620,15 +7623,15 @@ fn register_fn_pair(&@crate_ctxt cx, str ps, TypeRef llfnty, ValueRef llfn,\n \n \n // Returns the number of type parameters that the given native function has.\n-fn native_fn_ty_param_count(&@crate_ctxt cx, &ast::def_id id) -> uint {\n+fn native_fn_ty_param_count(&@crate_ctxt cx, ast::node_id id) -> uint {\n     auto count;\n     auto native_item = cx.native_items.get(id);\n     alt (native_item.node) {\n         case (ast::native_item_ty(_, _)) {\n             cx.sess.bug(\"decl_native_fn_and_pair(): native fn isn't \" +\n                             \"actually a fn\");\n         }\n-        case (ast::native_item_fn(_, _, _, ?tps, _, _)) {\n+        case (ast::native_item_fn(_, _, _, ?tps, _)) {\n             count = vec::len[ast::ty_param](tps);\n         }\n     }\n@@ -7645,18 +7648,18 @@ fn native_fn_wrapper_type(&@crate_ctxt cx, &span sp, uint ty_param_count,\n }\n \n fn decl_native_fn_and_pair(&@crate_ctxt ccx, &span sp, vec[str] path,\n-                           str name, &ast::ann ann, ast::def_id id) {\n+                           str name, ast::node_id id) {\n     auto num_ty_param = native_fn_ty_param_count(ccx, id);\n     // Declare the wrapper.\n \n-    auto t = node_ann_type(ccx, ann);\n+    auto t = node_id_type(ccx, id);\n     auto wrapper_type = native_fn_wrapper_type(ccx, sp, num_ty_param, t);\n     let str s = mangle_internal_name_by_path(ccx, path);\n     let ValueRef wrapper_fn =\n         decl_internal_fastcall_fn(ccx.llmod, s, wrapper_type);\n     // Declare the global constant pair that points to it.\n \n-    let str ps = mangle_exported_name(ccx, path, node_ann_type(ccx, ann));\n+    let str ps = mangle_exported_name(ccx, path, node_id_type(ccx, id));\n     register_fn_pair(ccx, ps, wrapper_type, wrapper_fn, id);\n     // Build the wrapper.\n \n@@ -7666,7 +7669,7 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx, &span sp, vec[str] path,\n     // Declare the function itself.\n \n     auto item = ccx.native_items.get(id);\n-    auto fn_type = node_ann_type(ccx, ann); // NB: has no type params\n+    auto fn_type = node_id_type(ccx, id); // NB: has no type params\n \n     auto abi = ty::ty_fn_abi(ccx.tcx, fn_type);\n     auto llfnty =\n@@ -7803,14 +7806,14 @@ fn item_path(&@ast::item item) -> vec[str] { ret [item.ident]; }\n fn collect_native_item(@crate_ctxt ccx, &@ast::native_item i, &vec[str] pt,\n                        &vt[vec[str]] v) {\n     alt (i.node) {\n-        case (ast::native_item_fn(?name, _, _, _, ?fid, ?ann)) {\n-            ccx.native_items.insert(fid, i);\n-            if (!ccx.obj_methods.contains_key(fid)) {\n-                decl_native_fn_and_pair(ccx, i.span, pt, name, ann, fid);\n+        case (ast::native_item_fn(?name, _, _, _, ?id)) {\n+            ccx.native_items.insert(id, i);\n+            if (!ccx.obj_methods.contains_key(id)) {\n+                decl_native_fn_and_pair(ccx, i.span, pt, name, id);\n             }\n         }\n-        case (ast::native_item_ty(_, ?tid)) {\n-            ccx.native_items.insert(tid, i);\n+        case (ast::native_item_ty(_, ?id)) {\n+            ccx.native_items.insert(id, i);\n         }\n     }\n }\n@@ -7820,7 +7823,7 @@ fn collect_item_1(@crate_ctxt ccx, &@ast::item i, &vec[str] pt,\n     visit::visit_item(i, pt + item_path(i), v);\n     alt (i.node) {\n         case (ast::item_const(_, _)) {\n-            auto typ = node_ann_type(ccx, i.ann);\n+            auto typ = node_id_type(ccx, i.id);\n             auto g =\n                 llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, i.span, typ),\n                                     str::buf(ccx.names.next(i.ident)));\n@@ -7846,12 +7849,12 @@ fn collect_item_2(&@crate_ctxt ccx, &@ast::item i, &vec[str] pt,\n         case (ast::item_fn(?f, ?tps)) {\n             ccx.items.insert(i.id, i);\n             if (!ccx.obj_methods.contains_key(i.id)) {\n-                decl_fn_and_pair(ccx, i.span, new_pt, \"fn\", tps, i.ann, i.id);\n+                decl_fn_and_pair(ccx, i.span, new_pt, \"fn\", tps, i.id, i.id);\n             }\n         }\n         case (ast::item_obj(?ob, ?tps, ?ctor_id)) {\n             ccx.items.insert(ctor_id, i);\n-            decl_fn_and_pair(ccx, i.span, new_pt, \"obj_ctor\", tps, i.ann,\n+            decl_fn_and_pair(ccx, i.span, new_pt, \"obj_ctor\", tps, i.id,\n                              ctor_id);\n             for (@ast::method m in ob.methods) {\n                 ccx.obj_methods.insert(m.node.id, ());\n@@ -7882,7 +7885,7 @@ fn collect_tag_ctor(@crate_ctxt ccx, &@ast::item i, &vec[str] pt,\n                 if (vec::len[ast::variant_arg](variant.node.args) != 0u) {\n                     decl_fn_and_pair(ccx, i.span,\n                                      new_pt + [variant.node.name], \"tag\", tps,\n-                                     variant.node.ann, variant.node.id);\n+                                     variant.node.id, variant.node.id);\n                 }\n             }\n         }\n@@ -7929,7 +7932,7 @@ fn trans_constant(@crate_ctxt ccx, &@ast::item it, &vec[str] pt,\n             ccx.item_ids.insert(it.id, v);\n             auto s =\n                 mangle_exported_name(ccx, new_pt + [it.ident],\n-                                     node_ann_type(ccx, it.ann));\n+                                     node_id_type(ccx, it.id));\n             ccx.item_symbols.insert(it.id, s);\n         }\n         case (_) { }\n@@ -8128,20 +8131,20 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n              tn=tn,\n              externs=new_str_hash[ValueRef](),\n              intrinsics=intrinsics,\n-             item_ids=new_def_hash[ValueRef](),\n-             items=new_def_hash[@ast::item](),\n-             native_items=new_def_hash[@ast::native_item](),\n-             item_symbols=new_def_hash[str](),\n+             item_ids=new_int_hash[ValueRef](),\n+             items=new_int_hash[@ast::item](),\n+             native_items=new_int_hash[@ast::native_item](),\n+             item_symbols=new_int_hash[str](),\n              mutable main_fn=none[ValueRef],\n              crate_meta_name=crate_meta_name(sess, *crate, output),\n              crate_meta_vers=crate_meta_vers(sess, *crate),\n              crate_meta_extras_hash=crate_meta_extras_hash(sha, *crate),\n              tag_sizes=tag_sizes,\n-             discrims=new_def_hash[ValueRef](),\n-             discrim_symbols=new_def_hash[str](),\n-             fn_pairs=new_def_hash[ValueRef](),\n-             consts=new_def_hash[ValueRef](),\n-             obj_methods=new_def_hash[()](),\n+             discrims=new_int_hash[ValueRef](),\n+             discrim_symbols=new_int_hash[str](),\n+             fn_pairs=new_int_hash[ValueRef](),\n+             consts=new_int_hash[ValueRef](),\n+             obj_methods=new_int_hash[()](),\n              tydescs=tydescs,\n              module_data=new_str_hash[ValueRef](),\n              lltypes=lltypes,"}, {"sha": "59a0b53694790af1206d83143aac9f4cb508c328", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -4,7 +4,8 @@ import std::option;\n import std::option::some;\n import std::option::none;\n import front::ast::*;\n-import middle::ty::expr_ann;\n+import middle::ty::expr_node_id;\n+import util::common::istr;\n import util::common::uistr;\n import util::common::span;\n import util::common::new_str_hash;\n@@ -23,70 +24,69 @@ import aux::crate_ctxt;\n import aux::add_node;\n import middle::tstate::ann::empty_ann;\n \n-fn collect_ids_expr(&@expr e, @mutable vec[uint] res) {\n-    vec::push(*res, expr_ann(e).id);\n+fn collect_ids_expr(&@expr e, @mutable vec[node_id] res) {\n+    vec::push(*res, expr_node_id(e));\n }\n \n-fn collect_ids_block(&block b, @mutable vec[uint] res) {\n-    vec::push(*res, b.node.a.id);\n+fn collect_ids_block(&block b, @mutable vec[node_id] res) {\n+    vec::push(*res, b.node.id);\n }\n \n-fn collect_ids_stmt(&@stmt s, @mutable vec[uint] res) {\n+fn collect_ids_stmt(&@stmt s, @mutable vec[node_id] res) {\n     alt (s.node) {\n-        case (stmt_decl(_, ?a)) {\n-            log \"node_id \" + uistr(a.id);\n+        case (stmt_decl(_, ?id)) {\n+            log \"node_id \" + istr(id);\n             log_stmt(*s);\n-            vec::push(*res, a.id);\n+            vec::push(*res, id);\n         }\n-        case (stmt_expr(_, ?a)) {\n-            log \"node_id \" + uistr(a.id);\n+        case (stmt_expr(_, ?id)) {\n+            log \"node_id \" + istr(id);\n             log_stmt(*s);\n-            vec::push(*res, a.id);\n+            vec::push(*res, id);\n         }\n         case (_) { }\n     }\n }\n \n-fn collect_ids_local(&@local l, @mutable vec[uint] res) {\n-    vec::push(*res, l.node.ann.id);\n+fn collect_ids_local(&@local l, @mutable vec[node_id] res) {\n+    vec::push(*res, l.node.id);\n }\n \n-fn node_ids_in_fn(&_fn f, &span sp, &ident i, &def_id d, &ann a,\n-                  @mutable vec[uint] res) {\n+fn node_ids_in_fn(&_fn f, &span sp, &ident i, node_id id,\n+                  @mutable vec[node_id] res) {\n     auto collect_ids = walk::default_visitor();\n     collect_ids =\n         rec(visit_expr_pre=bind collect_ids_expr(_, res),\n             visit_block_pre=bind collect_ids_block(_, res),\n             visit_stmt_pre=bind collect_ids_stmt(_, res),\n             visit_local_pre=bind collect_ids_local(_, res) with collect_ids);\n-    walk::walk_fn(collect_ids, f, sp, i, d, a);\n+    walk::walk_fn(collect_ids, f, sp, i, id);\n }\n \n-fn init_vecs(&crate_ctxt ccx, &vec[uint] node_ids, uint len) {\n-    for (uint i in node_ids) {\n-        log uistr(i) + \" |-> \" + uistr(len);\n+fn init_vecs(&crate_ctxt ccx, &vec[node_id] node_ids, uint len) {\n+    for (node_id i in node_ids) {\n+        log istr(i) + \" |-> \" + uistr(len);\n         add_node(ccx, i, empty_ann(len));\n     }\n }\n \n fn visit_fn(&crate_ctxt ccx, uint num_constraints, &_fn f, &span sp, &ident i,\n-            &def_id d, &ann a) {\n-    let @mutable vec[uint] node_ids = @mutable [];\n-    node_ids_in_fn(f, sp, i, d, a, node_ids);\n+            node_id id) {\n+    let @mutable vec[node_id] node_ids = @mutable [];\n+    node_ids_in_fn(f, sp, i, id, node_ids);\n     auto node_id_vec = *node_ids;\n     init_vecs(ccx, node_id_vec, num_constraints);\n }\n \n-fn annotate_in_fn(&crate_ctxt ccx, &_fn f, &span sp, &ident i, &def_id f_id,\n-                  &ann a) {\n-    auto f_info = get_fn_info(ccx, f_id);\n-    visit_fn(ccx, num_constraints(f_info), f, sp, i, f_id, a);\n+fn annotate_in_fn(&crate_ctxt ccx, &_fn f, &span sp, &ident i, node_id id) {\n+    auto f_info = get_fn_info(ccx, id);\n+    visit_fn(ccx, num_constraints(f_info), f, sp, i, id);\n }\n \n fn annotate_crate(&crate_ctxt ccx, &crate crate) {\n     auto do_ann = walk::default_visitor();\n     do_ann =\n-        rec(visit_fn_pre=bind annotate_in_fn(ccx, _, _, _, _, _) with do_ann);\n+        rec(visit_fn_pre=bind annotate_in_fn(ccx, _, _, _, _) with do_ann);\n     walk::walk_crate(do_ann, crate);\n }\n //"}, {"sha": "582a1971d5452a4ee73d79341923bed0ff26c0d3", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 70, "deletions": 73, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -10,14 +10,15 @@ import std::option::some;\n import std::option::maybe;\n import front::ast;\n import front::ast::*;\n-import middle::ty::expr_ann;\n+import middle::ty::expr_node_id;\n import util::common;\n import util::common::span;\n import util::common::respan;\n import util::common::log_block;\n-import util::common::new_def_hash;\n+import util::common::new_int_hash;\n import util::common::new_uint_hash;\n import util::common::log_expr_err;\n+import util::common::istr;\n import util::common::uistr;\n import util::common::lit_eq;\n import pretty::pprust::path_to_str;\n@@ -37,7 +38,6 @@ import tstate::ann::extend_poststate;\n import tstate::ann::set_precondition;\n import tstate::ann::set_postcondition;\n import tstate::ann::ts_ann;\n-import util::common::istr;\n import pretty::ppaux::constr_args_to_str;\n import pretty::ppaux::lit_to_str;\n \n@@ -210,13 +210,13 @@ tag constraint {\n \n tag constr__ { ninit(ident); npred(path, vec[@constr_arg_use]); }\n \n-type constr_ = rec(def_id id, constr__ c);\n+type constr_ = rec(node_id id, constr__ c);\n \n type constr = spanned[constr_];\n \n type norm_constraint = rec(uint bit_num, constr c);\n \n-type constr_map = @std::map::hashmap[def_id, constraint];\n+type constr_map = @std::map::hashmap[node_id, constraint];\n \n type fn_info = rec(constr_map constrs, uint num_constraints, controlflow cf);\n \n@@ -226,51 +226,53 @@ type node_ann_table = @mutable vec[mutable ts_ann];\n \n \n /* mapping from function name to fn_info map */\n-type fn_info_map = @std::map::hashmap[def_id, fn_info];\n+type fn_info_map = @std::map::hashmap[node_id, fn_info];\n \n-type fn_ctxt = rec(fn_info enclosing, def_id id, ident name, crate_ctxt ccx);\n+type fn_ctxt = rec(fn_info enclosing, node_id id, ident name, crate_ctxt ccx);\n \n type crate_ctxt = rec(ty::ctxt tcx, node_ann_table node_anns, fn_info_map fm);\n \n-fn get_fn_info(&crate_ctxt ccx, def_id did) -> fn_info {\n-    assert (ccx.fm.contains_key(did));\n-    ret ccx.fm.get(did);\n+fn get_fn_info(&crate_ctxt ccx, node_id id) -> fn_info {\n+    assert (ccx.fm.contains_key(id));\n+    ret ccx.fm.get(id);\n }\n \n-fn add_node(&crate_ctxt ccx, uint i, &ts_ann a) {\n+fn add_node(&crate_ctxt ccx, node_id i, &ts_ann a) {\n     auto sz = len(*ccx.node_anns);\n-    if (sz <= i) { grow(*ccx.node_anns, i - sz + 1u, empty_ann(0u)); }\n+    if (sz <= i as uint) {\n+        grow(*ccx.node_anns, (i as uint) - sz + 1u, empty_ann(0u));\n+    }\n     ccx.node_anns.(i) = a;\n }\n \n-fn get_ts_ann(&crate_ctxt ccx, uint i) -> option::t[ts_ann] {\n-    if (i < len(*ccx.node_anns)) {\n+fn get_ts_ann(&crate_ctxt ccx, node_id i) -> option::t[ts_ann] {\n+    if (i as uint < len(*ccx.node_anns)) {\n         ret some[ts_ann](ccx.node_anns.(i));\n     } else { ret none[ts_ann]; }\n }\n \n \n /********* utils ********/\n-fn ann_to_ts_ann(&crate_ctxt ccx, &ann a) -> ts_ann {\n-    alt (get_ts_ann(ccx, a.id)) {\n+fn node_id_to_ts_ann(&crate_ctxt ccx, node_id id) -> ts_ann {\n+    alt (get_ts_ann(ccx, id)) {\n         case (none) {\n-            log_err \"ann_to_ts_ann: no ts_ann for node_id \" + uistr(a.id);\n+            log_err \"node_id_to_ts_ann: no ts_ann for node_id \" + istr(id);\n             fail;\n         }\n         case (some(?t)) { ret t; }\n     }\n }\n \n-fn ann_to_poststate(&crate_ctxt ccx, ann a) -> poststate {\n-    log \"ann_to_poststate\";\n-    ret ann_to_ts_ann(ccx, a).states.poststate;\n+fn node_id_to_poststate(&crate_ctxt ccx, node_id id) -> poststate {\n+    log \"node_id_to_poststate\";\n+    ret node_id_to_ts_ann(ccx, id).states.poststate;\n }\n \n fn stmt_to_ann(&crate_ctxt ccx, &stmt s) -> ts_ann {\n     log \"stmt_to_ann\";\n     alt (s.node) {\n-        case (stmt_decl(_, ?a)) { ret ann_to_ts_ann(ccx, a); }\n-        case (stmt_expr(_, ?a)) { ret ann_to_ts_ann(ccx, a); }\n+        case (stmt_decl(_, ?id)) { ret node_id_to_ts_ann(ccx, id); }\n+        case (stmt_expr(_, ?id)) { ret node_id_to_ts_ann(ccx, id); }\n         case (stmt_crate_directive(_)) {\n             log_err \"expecting an annotated statement here\";\n             fail;\n@@ -282,14 +284,14 @@ fn stmt_to_ann(&crate_ctxt ccx, &stmt s) -> ts_ann {\n /* fails if e has no annotation */\n fn expr_states(&crate_ctxt ccx, @expr e) -> pre_and_post_state {\n     log \"expr_states\";\n-    ret ann_to_ts_ann(ccx, expr_ann(e)).states;\n+    ret node_id_to_ts_ann(ccx, expr_node_id(e)).states;\n }\n \n \n /* fails if e has no annotation */\n fn expr_pp(&crate_ctxt ccx, @expr e) -> pre_and_post {\n     log \"expr_pp\";\n-    ret ann_to_ts_ann(ccx, expr_ann(e)).conditions;\n+    ret node_id_to_ts_ann(ccx, expr_node_id(e)).conditions;\n }\n \n fn stmt_pp(&crate_ctxt ccx, &stmt s) -> pre_and_post {\n@@ -300,22 +302,22 @@ fn stmt_pp(&crate_ctxt ccx, &stmt s) -> pre_and_post {\n /* fails if b has no annotation */\n fn block_pp(&crate_ctxt ccx, &block b) -> pre_and_post {\n     log \"block_pp\";\n-    ret ann_to_ts_ann(ccx, b.node.a).conditions;\n+    ret node_id_to_ts_ann(ccx, b.node.id).conditions;\n }\n \n fn clear_pp(pre_and_post pp) {\n     ann::clear(pp.precondition);\n     ann::clear(pp.postcondition);\n }\n \n-fn clear_precond(&crate_ctxt ccx, &ann a) {\n-    auto pp = ann_to_ts_ann(ccx, a);\n+fn clear_precond(&crate_ctxt ccx, node_id id) {\n+    auto pp = node_id_to_ts_ann(ccx, id);\n     ann::clear(pp.conditions.precondition);\n }\n \n fn block_states(&crate_ctxt ccx, &block b) -> pre_and_post_state {\n     log \"block_states\";\n-    ret ann_to_ts_ann(ccx, b.node.a).states;\n+    ret node_id_to_ts_ann(ccx, b.node.id).states;\n }\n \n fn stmt_states(&crate_ctxt ccx, &stmt s) -> pre_and_post_state {\n@@ -376,60 +378,63 @@ fn block_poststate(&crate_ctxt ccx, &block b) -> poststate {\n \n \n /* sets the pre_and_post for an ann */\n-fn with_pp(&crate_ctxt ccx, &ann a, pre_and_post p) {\n-    add_node(ccx, a.id, @rec(conditions=p, states=empty_states(pps_len(p))));\n+fn with_pp(&crate_ctxt ccx, node_id id, pre_and_post p) {\n+    add_node(ccx, id, @rec(conditions=p, states=empty_states(pps_len(p))));\n }\n \n-fn set_prestate_ann(&crate_ctxt ccx, &ann a, &prestate pre) -> bool {\n+fn set_prestate_ann(&crate_ctxt ccx, node_id id, &prestate pre) -> bool {\n     log \"set_prestate_ann\";\n-    ret set_prestate(ann_to_ts_ann(ccx, a), pre);\n+    ret set_prestate(node_id_to_ts_ann(ccx, id), pre);\n }\n \n-fn extend_prestate_ann(&crate_ctxt ccx, &ann a, &prestate pre) -> bool {\n+fn extend_prestate_ann(&crate_ctxt ccx, node_id id, &prestate pre) -> bool {\n     log \"extend_prestate_ann\";\n-    ret extend_prestate(ann_to_ts_ann(ccx, a).states.prestate, pre);\n+    ret extend_prestate(node_id_to_ts_ann(ccx, id).states.prestate, pre);\n }\n \n-fn set_poststate_ann(&crate_ctxt ccx, &ann a, &poststate post) -> bool {\n+fn set_poststate_ann(&crate_ctxt ccx, node_id id, &poststate post) -> bool {\n     log \"set_poststate_ann\";\n-    ret set_poststate(ann_to_ts_ann(ccx, a), post);\n+    ret set_poststate(node_id_to_ts_ann(ccx, id), post);\n }\n \n-fn extend_poststate_ann(&crate_ctxt ccx, &ann a, &poststate post) -> bool {\n+fn extend_poststate_ann(&crate_ctxt ccx, node_id id, &poststate post)\n+    -> bool {\n     log \"extend_poststate_ann\";\n-    ret extend_poststate(ann_to_ts_ann(ccx, a).states.poststate, post);\n+    ret extend_poststate(node_id_to_ts_ann(ccx, id).states.poststate, post);\n }\n \n-fn set_pre_and_post(&crate_ctxt ccx, &ann a, &precond pre, &postcond post) {\n+fn set_pre_and_post(&crate_ctxt ccx, node_id id, &precond pre,\n+                    &postcond post) {\n     log \"set_pre_and_post\";\n-    auto t = ann_to_ts_ann(ccx, a);\n+    auto t = node_id_to_ts_ann(ccx, id);\n     set_precondition(t, pre);\n     set_postcondition(t, post);\n }\n \n-fn copy_pre_post(&crate_ctxt ccx, &ann a, &@expr sub) {\n+fn copy_pre_post(&crate_ctxt ccx, node_id id, &@expr sub) {\n     log \"set_pre_and_post\";\n     auto p = expr_pp(ccx, sub);\n-    copy_pre_post_(ccx, a, p.precondition, p.postcondition);\n+    copy_pre_post_(ccx, id, p.precondition, p.postcondition);\n }\n \n-fn copy_pre_post_(&crate_ctxt ccx, &ann a, &prestate pre, &poststate post) {\n+fn copy_pre_post_(&crate_ctxt ccx, node_id id, &prestate pre,\n+                  &poststate post) {\n     log \"set_pre_and_post\";\n-    auto t = ann_to_ts_ann(ccx, a);\n+    auto t = node_id_to_ts_ann(ccx, id);\n     set_precondition(t, pre);\n     set_postcondition(t, post);\n }\n \n /* sets all bits to *1* */\n-fn set_postcond_false(&crate_ctxt ccx, &ann a) {\n-    auto p = ann_to_ts_ann(ccx, a);\n+fn set_postcond_false(&crate_ctxt ccx, node_id id) {\n+    auto p = node_id_to_ts_ann(ccx, id);\n     ann::set(p.conditions.postcondition);\n }\n \n-fn pure_exp(&crate_ctxt ccx, &ann a, &prestate p) -> bool {\n+fn pure_exp(&crate_ctxt ccx, node_id id, &prestate p) -> bool {\n     auto changed = false;\n-    changed = extend_prestate_ann(ccx, a, p) || changed;\n-    changed = extend_poststate_ann(ccx, a, p) || changed;\n+    changed = extend_prestate_ann(ccx, id, p) || changed;\n+    changed = extend_poststate_ann(ccx, id, p) || changed;\n     ret changed;\n }\n \n@@ -449,49 +454,41 @@ fn num_constraints(fn_info m) -> uint { ret m.num_constraints; }\n \n fn new_crate_ctxt(ty::ctxt cx) -> crate_ctxt {\n     let vec[mutable ts_ann] na = vec::empty_mut();\n-    ret rec(tcx=cx, node_anns=@mutable na, fm=@new_def_hash[fn_info]());\n+    ret rec(tcx=cx, node_anns=@mutable na, fm=@new_int_hash[fn_info]());\n }\n \n-fn controlflow_def_id(&crate_ctxt ccx, &def_id d) -> controlflow {\n-    alt (ccx.fm.find(d)) {\n-        case (some(?fi)) { ret fi.cf; }\n-        case (none) { ret return; }\n-    }\n-}\n-\n-\n /* Use e's type to determine whether it returns.\n  If it has a function type with a ! annotation,\n the answer is noreturn. */\n fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n-    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx, expr_ann(e)))) {\n+    alt (ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, expr_node_id(e)))) {\n         case (ty::ty_fn(_, _, _, ?cf, _)) { ret cf; }\n         case (_) { ret return; }\n     }\n }\n \n fn constraints_expr(&ty::ctxt cx, @expr e) -> vec[@ty::constr_def] {\n-    alt (ty::struct(cx, ty::ann_to_type(cx, expr_ann(e)))) {\n+    alt (ty::struct(cx, ty::node_id_to_type(cx, expr_node_id(e)))) {\n         case (ty::ty_fn(_, _, _, _, ?cs)) { ret cs; }\n         case (_) { ret []; }\n     }\n }\n \n-fn ann_to_def_strict(&ty::ctxt cx, &ann a) -> def {\n-    alt (cx.def_map.find(a.id)) {\n+fn node_id_to_def_strict(&ty::ctxt cx, node_id id) -> def {\n+    alt (cx.def_map.find(id)) {\n         case (none) {\n-            log_err \"ann_to_def: node_id \" + uistr(a.id) + \" has no def\";\n+            log_err \"node_id_to_def: node_id \" + istr(id) + \" has no def\";\n             fail;\n         }\n         case (some(?d)) { ret d; }\n     }\n }\n \n-fn ann_to_def(&crate_ctxt ccx, &ann a) -> option::t[def] {\n-    ret ccx.tcx.def_map.find(a.id);\n+fn node_id_to_def(&crate_ctxt ccx, node_id id) -> option::t[def] {\n+    ret ccx.tcx.def_map.find(id);\n }\n \n-fn norm_a_constraint(&def_id id, &constraint c) -> vec[norm_constraint] {\n+fn norm_a_constraint(node_id id, &constraint c) -> vec[norm_constraint] {\n     alt (c) {\n         case (cinit(?n, ?sp, ?i)) {\n             ret [rec(bit_num=n, c=respan(sp, rec(id=id, c=ninit(i))))];\n@@ -515,7 +512,7 @@ fn norm_a_constraint(&def_id id, &constraint c) -> vec[norm_constraint] {\n // non-exhaustive match in trans.\n fn constraints(&fn_ctxt fcx) -> vec[norm_constraint] {\n     let vec[norm_constraint] res = [];\n-    for each (@tup(def_id, constraint) p in fcx.enclosing.constrs.items()) {\n+    for each (@tup(node_id, constraint) p in fcx.enclosing.constrs.items()) {\n         res += norm_a_constraint(p._0, p._1);\n     }\n     ret res;\n@@ -536,14 +533,14 @@ fn match_args(&fn_ctxt fcx, vec[pred_desc] occs, vec[@constr_arg_use] occ) ->\n     fcx.ccx.tcx.sess.bug(\"match_args: no match for occurring args\");\n }\n \n-fn def_id_for_constr(ty::ctxt tcx, uint t) -> def_id {\n+fn node_id_for_constr(ty::ctxt tcx, node_id t) -> node_id {\n     alt (tcx.def_map.find(t)) {\n         case (none) {\n-            tcx.sess.bug(\"def_id_for_constr: bad node_id \" + uistr(t));\n+            tcx.sess.bug(\"node_id_for_constr: bad node_id \" + istr(t));\n         }\n-        case (some(def_fn(?i))) { ret i; }\n+        case (some(def_fn(?i))) { ret i._1; }\n         case (_) {\n-            tcx.sess.bug(\"def_id_for_constr: pred is not a function\");\n+            tcx.sess.bug(\"node_id_for_constr: pred is not a function\");\n         }\n     }\n }\n@@ -580,9 +577,9 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n              // typechecker bug\n              expr_call(?operator, ?args, _)) {\n             alt (operator.node) {\n-                case (expr_path(?p, ?a)) {\n+                case (expr_path(?p, ?id)) {\n                     ret respan(e.span,\n-                               rec(id=def_id_for_constr(tcx, a.id),\n+                               rec(id=node_id_for_constr(tcx, id),\n                                    c=npred(p,\n                                            exprs_to_constr_args(tcx, args))));\n                 }"}, {"sha": "3850986a4f8f7f0de4d5d1c053aa4909a0d57722", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -21,7 +21,7 @@ import aux::expr_precond;\n import aux::block_prestate;\n import aux::expr_prestate;\n import aux::stmt_prestate;\n-import tstate::aux::ann_to_ts_ann;\n+import tstate::aux::node_id_to_ts_ann;\n import tstate::ann::pre_and_post;\n import tstate::ann::precond;\n import tstate::ann::postcond;\n@@ -136,9 +136,9 @@ fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n     ret intersect_postconds_go(bitv::clone(pcs.(0)), pcs);\n }\n \n-fn gen(&fn_ctxt fcx, &ann a, &constr_ c) -> bool {\n+fn gen(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {\n     ret set_in_postcond(bit_num(fcx, c),\n-                        ann_to_ts_ann(fcx.ccx, a).conditions);\n+                        node_id_to_ts_ann(fcx.ccx, id).conditions);\n }\n \n fn declare_var(&fn_ctxt fcx, &constr_ c, prestate pre) -> prestate {\n@@ -149,19 +149,19 @@ fn declare_var(&fn_ctxt fcx, &constr_ c, prestate pre) -> prestate {\n     ret res;\n }\n \n-fn relax_precond_block_non_recursive(&fn_ctxt fcx, uint i, &block b) {\n-    relax_precond(i, block_precond(fcx.ccx, b));\n+fn relax_precond_block_non_recursive(&fn_ctxt fcx, node_id i, &block b) {\n+    relax_precond(i as uint, block_precond(fcx.ccx, b));\n }\n \n-fn relax_precond_expr(&fn_ctxt fcx, uint i, &@expr e) {\n-    relax_precond(i, expr_precond(fcx.ccx, e));\n+fn relax_precond_expr(&fn_ctxt fcx, node_id i, &@expr e) {\n+    relax_precond(i as uint, expr_precond(fcx.ccx, e));\n }\n \n-fn relax_precond_stmt(&fn_ctxt fcx, uint i, &@stmt s) {\n-    relax_precond(i, stmt_precond(fcx.ccx, *s));\n+fn relax_precond_stmt(&fn_ctxt fcx, node_id i, &@stmt s) {\n+    relax_precond(i as uint, stmt_precond(fcx.ccx, *s));\n }\n \n-fn relax_precond_block(&fn_ctxt fcx, uint i, &block b) {\n+fn relax_precond_block(&fn_ctxt fcx, node_id i, &block b) {\n     relax_precond_block_non_recursive(fcx, i, b);\n     // FIXME: should use visit instead\n     // could at least generalize this pattern \n@@ -184,14 +184,16 @@ fn relax_precond_block(&fn_ctxt fcx, uint i, &block b) {\n     walk::walk_block(v, b);\n }\n \n-fn gen_poststate(&fn_ctxt fcx, &ann a, &constr_ c) -> bool {\n+fn gen_poststate(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {\n     log \"gen_poststate\";\n-    ret set_in_poststate(bit_num(fcx, c), ann_to_ts_ann(fcx.ccx, a).states);\n+    ret set_in_poststate(bit_num(fcx, c),\n+                         node_id_to_ts_ann(fcx.ccx, id).states);\n }\n \n-fn kill_poststate(&fn_ctxt fcx, &ann a, &constr_ c) -> bool {\n+fn kill_poststate(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {\n     log \"kill_poststate\";\n-    ret clear_in_poststate(bit_num(fcx, c), ann_to_ts_ann(fcx.ccx, a).states);\n+    ret clear_in_poststate(bit_num(fcx, c),\n+                           node_id_to_ts_ann(fcx.ccx, id).states);\n }\n //\n // Local Variables:"}, {"sha": "27933ee8eab19de19495a075eda478692d121d4f", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -1,15 +1,16 @@\n \n import front::ast;\n import front::ast::method;\n-import front::ast::ann;\n import front::ast::item;\n import front::ast::item_fn;\n import front::ast::_fn;\n import front::ast::obj_field;\n import front::ast::_obj;\n import front::ast::stmt;\n import front::ast::ident;\n+import front::ast::node_id;\n import front::ast::def_id;\n+import front::ast::local_def;\n import front::ast::ty_param;\n import front::ast::crate;\n import front::ast::return;\n@@ -118,8 +119,8 @@ fn check_states_stmt(&fn_ctxt fcx, &@stmt s) {\n     }\n }\n \n-fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a,\n-                                   &span sp, &ident i, &def_id d) {\n+fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, node_id id,\n+                                   &span sp, &ident i) {\n     /* Postorder traversal instead of pre is important\n        because we want the smallest possible erroneous statement\n        or expression. */\n@@ -141,13 +142,13 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a,\n                   keep_going=bind kg(keepgoing)\n                   with walk::default_visitor());\n \n-    walk::walk_fn(v, f, sp, i, d, a);\n+    walk::walk_fn(v, f, sp, i, id);\n \n     /* Finally, check that the return value is initialized */\n     auto post = aux::block_poststate(fcx.ccx, f.body);\n     let aux::constr_ ret_c = rec(id=fcx.id, c=aux::ninit(fcx.name));\n     if (f.proto == ast::proto_fn && !promises(fcx, post, ret_c) &&\n-            !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, a)) &&\n+            !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n             f.decl.cf == return) {\n         fcx.ccx.tcx.sess.span_note(f.body.span,\n                                    \"In function \" + fcx.name +\n@@ -171,26 +172,24 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a,\n     }\n }\n \n-fn check_fn_states(&fn_ctxt fcx, &_fn f, &ann a, &span sp, &ident i,\n-                   &def_id d) {\n+fn check_fn_states(&fn_ctxt fcx, &_fn f, node_id id, &span sp, &ident i) {\n     /* Compute the pre- and post-states for this function */\n \n     auto g = find_pre_post_state_fn;\n     fixed_point_states(fcx, g, f);\n     /* Now compare each expr's pre-state to its precondition\n        and post-state to its postcondition */\n \n-    check_states_against_conditions(fcx, f, a, sp, i, d);\n+    check_states_against_conditions(fcx, f, id, sp, i);\n }\n \n-fn fn_states(&crate_ctxt ccx, &_fn f, &span sp, &ident i, &def_id id,\n-             &ann a) {\n+fn fn_states(&crate_ctxt ccx, &_fn f, &span sp, &ident i, node_id id) {\n     /* Look up the var-to-bit-num map for this function */\n \n     assert (ccx.fm.contains_key(id));\n     auto f_info = ccx.fm.get(id);\n     auto fcx = rec(enclosing=f_info, id=id, name=i, ccx=ccx);\n-    check_fn_states(fcx, f, a, sp, i, id);\n+    check_fn_states(fcx, f, id, sp, i);\n }\n \n fn check_crate(ty::ctxt cx, @crate crate) {\n@@ -205,15 +204,15 @@ fn check_crate(ty::ctxt cx, @crate crate) {\n \n     auto do_pre_post = walk::default_visitor();\n     do_pre_post =\n-        rec(visit_fn_post=bind fn_pre_post(ccx, _, _, _, _, _)\n+        rec(visit_fn_post=bind fn_pre_post(ccx, _, _, _, _)\n             with do_pre_post);\n     walk::walk_crate(do_pre_post, *crate);\n     /* Check the pre- and postcondition against the pre- and poststate\n        for every expression */\n \n     auto do_states = walk::default_visitor();\n     do_states =\n-        rec(visit_fn_post=bind fn_states(ccx, _, _, _, _, _) with do_states);\n+        rec(visit_fn_post=bind fn_states(ccx, _, _, _, _) with do_states);\n     walk::walk_crate(do_states, *crate);\n }\n //"}, {"sha": "203eff471d31b9b481d6dab3c2a6fa2a8ec709ba", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -18,7 +18,8 @@ import aux::num_constraints;\n import aux::constr_map;\n import aux::expr_to_constr;\n import aux::constraints_expr;\n-import aux::ann_to_def_strict;\n+import aux::node_id_to_def_strict;\n+import util::common::new_int_hash;\n import util::common::new_def_hash;\n import util::common::uistr;\n import util::common::span;\n@@ -42,10 +43,10 @@ fn collect_pred(&ctxt cx, &@expr e) {\n         }\n         // If it's a call, generate appropriate instances of the\n         // call's constraints.\n-        case (expr_call(?operator, ?operands, ?a)) {\n+        case (expr_call(?operator, ?operands, _)) {\n             for (@ty::constr_def c in constraints_expr(cx.tcx, operator)) {\n                 let aux::constr ct = respan(c.span,\n-                      rec(id=c.node.id,\n+                      rec(id=c.node.id._1,\n                           c=aux::substitute_constr_args(cx.tcx,\n                                                         operands, c)));\n                 vec::push(*cx.cs, ct);\n@@ -55,14 +56,14 @@ fn collect_pred(&ctxt cx, &@expr e) {\n     }\n }\n \n-fn find_locals(&ty::ctxt tcx, &_fn f, &span sp, &ident i, &def_id d, &ann a)\n-   -> ctxt {\n+fn find_locals(&ty::ctxt tcx, &_fn f, &span sp, &ident i, node_id id)\n+    -> ctxt {\n     let ctxt cx = rec(cs=@mutable vec::alloc(0u), tcx=tcx);\n     auto visitor = walk::default_visitor();\n     visitor =\n         rec(visit_local_pre=bind collect_local(cx, _),\n             visit_expr_pre=bind collect_pred(cx, _) with visitor);\n-    walk_fn(visitor, f, sp, i, d, a);\n+    walk_fn(visitor, f, sp, i, id);\n     ret cx;\n }\n \n@@ -103,14 +104,14 @@ fn add_constraint(&ty::ctxt tcx, aux::constr c, uint next, constr_map tbl) ->\n /* builds a table mapping each local var defined in f\n    to a bit number in the precondition/postcondition vectors */\n fn mk_fn_info(&crate_ctxt ccx, &_fn f, &span f_sp, &ident f_name,\n-              &def_id f_id, &ann a) {\n-    auto res_map = @new_def_hash[constraint]();\n+              node_id id) {\n+    auto res_map = @new_int_hash[constraint]();\n     let uint next = 0u;\n     let vec[arg] f_args = f.decl.inputs;\n     /* ignore args, which we know are initialized;\n        just collect locally declared vars */\n \n-    let ctxt cx = find_locals(ccx.tcx, f, f_sp, f_name, f_id, a);\n+    let ctxt cx = find_locals(ccx.tcx, f, f_sp, f_name, id);\n     /* now we have to add bit nums for both the constraints\n        and the variables... */\n \n@@ -120,13 +121,13 @@ fn mk_fn_info(&crate_ctxt ccx, &_fn f, &span f_sp, &ident f_name,\n     /* add a pseudo-entry for the function's return value\n        we can safely use the function's name itself for this purpose */\n \n-    add_constraint(cx.tcx, respan(f_sp, rec(id=f_id, c=ninit(f_name))), next,\n+    add_constraint(cx.tcx, respan(f_sp, rec(id=id, c=ninit(f_name))), next,\n                    res_map);\n     auto res =\n         rec(constrs=res_map,\n             num_constraints=vec::len(*cx.cs) + 1u,\n             cf=f.decl.cf);\n-    ccx.fm.insert(f_id, res);\n+    ccx.fm.insert(id, res);\n     log f_name + \" has \" + uistr(num_constraints(res)) + \" constraints\";\n }\n \n@@ -137,7 +138,7 @@ fn mk_fn_info(&crate_ctxt ccx, &_fn f, &span f_sp, &ident f_name,\n fn mk_f_to_fn_info(&crate_ctxt ccx, @crate c) {\n     let ast_visitor vars_visitor = walk::default_visitor();\n     vars_visitor =\n-        rec(visit_fn_pre=bind mk_fn_info(ccx, _, _, _, _, _)\n+        rec(visit_fn_pre=bind mk_fn_info(ccx, _, _, _, _)\n             with vars_visitor);\n     walk_crate(vars_visitor, *c);\n }"}, {"sha": "58788eca533f6bfceff4101ba9d39c841299513b", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 131, "deletions": 129, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -5,8 +5,6 @@ import std::option;\n import std::option::none;\n import std::option::some;\n \n-// FIXME: needs to be tstate::ann because ann is also a type name...\n-// that's probably a bug.\n import tstate::ann::pre_and_post;\n import tstate::ann::get_post;\n import tstate::ann::postcond;\n@@ -40,9 +38,9 @@ import aux::expr_poststate;\n import aux::block_postcond;\n import aux::fn_info;\n import aux::log_pp;\n-import aux::ann_to_def;\n-import aux::ann_to_def_strict;\n-import aux::ann_to_ts_ann;\n+import aux::node_id_to_def;\n+import aux::node_id_to_def_strict;\n+import aux::node_id_to_ts_ann;\n import aux::set_postcond_false;\n import aux::controlflow_expr;\n import aux::expr_to_constr;\n@@ -62,7 +60,8 @@ import bitvectors::bit_num;\n import bitvectors::gen;\n import bitvectors::relax_precond_block;\n import front::ast::*;\n-import middle::ty::expr_ann;\n+import middle::ty::expr_node_id;\n+import util::common::new_int_hash;\n import util::common::new_def_hash;\n import util::common::uistr;\n import util::common::log_expr;\n@@ -107,10 +106,10 @@ fn find_pre_post_item(&crate_ctxt ccx, &item i) {\n             // make a fake fcx\n \n             auto fake_fcx =\n-                rec(enclosing=rec(constrs=@new_def_hash[constraint](),\n+                rec(enclosing=rec(constrs=@new_int_hash[constraint](),\n                                   num_constraints=0u,\n                                   cf=return),\n-                    id=tup(0, 0),\n+                    id=0,\n                     name=\"\",\n                     ccx=ccx);\n             find_pre_post_expr(fake_fcx, e);\n@@ -137,7 +136,7 @@ fn find_pre_post_item(&crate_ctxt ccx, &item i) {\n    sets the precondition in a to be the result of combining\n    the preconditions for <args>, and the postcondition in a to \n    be the union of all postconditions for <args> */\n-fn find_pre_post_exprs(&fn_ctxt fcx, &vec[@expr] args, ann a) {\n+fn find_pre_post_exprs(&fn_ctxt fcx, &vec[@expr] args, node_id id) {\n     if (vec::len[@expr](args) > 0u) {\n         log \"find_pre_post_exprs: oper =\";\n         log_expr(*args.(0));\n@@ -154,18 +153,18 @@ fn find_pre_post_exprs(&fn_ctxt fcx, &vec[@expr] args, ann a) {\n     auto g = bind get_pp(fcx.ccx, _);\n     auto pps = vec::map[@expr, pre_and_post](g, args);\n     auto h = get_post;\n-    set_pre_and_post(fcx.ccx, a, seq_preconds(fcx, pps),\n+    set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps),\n                      union_postconds(nv,\n                                      vec::map[pre_and_post,\n                                               postcond](h, pps)));\n }\n \n fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n-                      &ann a) {\n+                      node_id id) {\n     find_pre_post_expr(fcx, index);\n     find_pre_post_block(fcx, body);\n     auto v_init = rec(id=l.node.id, c=ninit(l.node.ident));\n-    relax_precond_block(fcx, bit_num(fcx, v_init), body);\n+    relax_precond_block(fcx, bit_num(fcx, v_init) as node_id, body);\n \n     auto loop_precond =\n         seq_preconds(fcx,\n@@ -174,14 +173,14 @@ fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n     auto loop_postcond =\n         intersect_postconds([expr_postcond(fcx.ccx, index),\n                              block_postcond(fcx.ccx, body)]);\n-    copy_pre_post_(fcx.ccx, a, loop_precond, loop_postcond);\n+    copy_pre_post_(fcx.ccx, id, loop_precond, loop_postcond);\n }\n \n // Generates a pre/post assuming that a is the \n // annotation for an if-expression with consequent conseq\n // and alternative maybe_alt\n fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n-                  &option::t[@expr] maybe_alt, &ann a, &if_ty chck) {\n+                  &option::t[@expr] maybe_alt, node_id id, &if_ty chck) {\n     auto num_local_vars = num_constraints(fcx.enclosing);\n     find_pre_post_expr(fcx, antec);\n     find_pre_post_block(fcx, conseq);\n@@ -190,7 +189,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n             alt (chck) {\n                 case (if_check) {\n                     let aux::constr c = expr_to_constr(fcx.ccx.tcx, antec);\n-                    gen(fcx, expr_ann(antec), c.node);\n+                    gen(fcx, expr_node_id(antec), c.node);\n                 }\n                 case (_) {}\n             }\n@@ -199,7 +198,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                 seq_preconds(fcx,\n                              [expr_pp(fcx.ccx, antec),\n                               block_pp(fcx.ccx, conseq)]);\n-            set_pre_and_post(fcx.ccx, a, precond_res,\n+            set_pre_and_post(fcx.ccx, id, precond_res,\n                              expr_poststate(fcx.ccx, antec));\n         }\n         case (some(?altern)) {\n@@ -223,7 +222,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n             alt (chck) {\n                 case (if_check) {\n                     let aux::constr c = expr_to_constr(fcx.ccx.tcx, antec);\n-                    gen(fcx, expr_ann(antec), c.node);\n+                    gen(fcx, expr_node_id(antec), c.node);\n                 }\n                 case (_) {}\n             }\n@@ -243,29 +242,29 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n             auto postcond_res =\n                 intersect_postconds([postcond_true_case,\n                                      postcond_false_case]);\n-            set_pre_and_post(fcx.ccx, a, precond_res, postcond_res);\n+            set_pre_and_post(fcx.ccx, id, precond_res, postcond_res);\n         }\n     }\n }\n \n-fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs, &ann larger_ann,\n-                &ann new_var, &path pth) {\n-    alt (ann_to_def(fcx.ccx, new_var)) {\n+fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs, node_id larger_id,\n+                node_id new_var, &path pth) {\n+    alt (node_id_to_def(fcx.ccx, new_var)) {\n         case (some(?d)) {\n             alt (d) {\n                 case (def_local(?d_id)) {\n                     find_pre_post_expr(fcx, rhs);\n                     auto p = expr_pp(fcx.ccx, rhs);\n-                    set_pre_and_post(fcx.ccx, larger_ann, p.precondition,\n+                    set_pre_and_post(fcx.ccx, larger_id, p.precondition,\n                                      p.postcondition);\n-                    gen(fcx, larger_ann,\n-                        rec(id=d_id,\n+                    gen(fcx, larger_id,\n+                        rec(id=d_id._1,\n                             c=ninit(path_to_ident(fcx.ccx.tcx, pth))));\n                 }\n-                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], larger_ann); }\n+                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], larger_id); }\n             }\n         }\n-        case (_) { find_pre_post_exprs(fcx, [lhs, rhs], larger_ann); }\n+        case (_) { find_pre_post_exprs(fcx, [lhs, rhs], larger_id); }\n     }\n }\n \n@@ -279,10 +278,10 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             \"):\";\n     log_expr(*e);\n     alt (e.node) {\n-        case (expr_call(?operator, ?operands, ?a)) {\n+        case (expr_call(?operator, ?operands, ?id)) {\n             auto args = vec::clone[@expr](operands);\n             vec::push[@expr](args, operator);\n-            find_pre_post_exprs(fcx, args, a);\n+            find_pre_post_exprs(fcx, args, id);\n             /* see if the call has any constraints on its type */\n \n             log \"a function: \";\n@@ -292,162 +291,164 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                 {\n                 auto i =\n                     bit_num(fcx,\n-                            rec(id=c.node.id,\n+                            rec(id=c.node.id._1,\n                                 c=substitute_constr_args(fcx.ccx.tcx,\n                                                          operands, c)));\n                 require(i, pp);\n             }\n \n             /* if this is a failing call, its postcondition sets everything */\n             alt (controlflow_expr(fcx.ccx, operator)) {\n-                case (noreturn) { set_postcond_false(fcx.ccx, a); }\n+                case (noreturn) { set_postcond_false(fcx.ccx, id); }\n                 case (_) { }\n             }\n         }\n-        case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n+        case (expr_spawn(_, _, ?operator, ?operands, ?id)) {\n             auto args = vec::clone[@expr](operands);\n             vec::push[@expr](args, operator);\n-            find_pre_post_exprs(fcx, args, a);\n+            find_pre_post_exprs(fcx, args, id);\n         }\n-        case (expr_vec(?args, _, _, ?a)) {\n-            find_pre_post_exprs(fcx, args, a);\n+        case (expr_vec(?args, _, _, ?id)) {\n+            find_pre_post_exprs(fcx, args, id);\n         }\n-        case (expr_tup(?elts, ?a)) {\n-            find_pre_post_exprs(fcx, elt_exprs(elts), a);\n+        case (expr_tup(?elts, ?id)) {\n+            find_pre_post_exprs(fcx, elt_exprs(elts), id);\n         }\n-        case (expr_path(?p, ?a)) {\n+        case (expr_path(?p, ?id)) {\n             auto res = expr_pp(fcx.ccx, e);\n             clear_pp(res);\n-            auto df = ann_to_def_strict(fcx.ccx.tcx, a);\n+            auto df = node_id_to_def_strict(fcx.ccx.tcx, id);\n             alt (df) {\n                 case (def_local(?d_id)) {\n                     auto i =\n                         bit_num(fcx,\n-                                rec(id=d_id,\n+                                rec(id=d_id._1,\n                                     c=ninit(path_to_ident(fcx.ccx.tcx, p))));\n                     require_and_preserve(i, res);\n                 }\n                 case (_) {/* nothing to check */ }\n             }\n         }\n-        case (expr_self_method(?v, ?a)) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_log(_, ?arg, ?a)) {\n+        case (expr_self_method(?v, ?id)) { clear_pp(expr_pp(fcx.ccx, e)); }\n+        case (expr_log(_, ?arg, ?id)) {\n             find_pre_post_expr(fcx, arg);\n-            copy_pre_post(fcx.ccx, a, arg);\n+            copy_pre_post(fcx.ccx, id, arg);\n         }\n-        case (expr_chan(?arg, ?a)) {\n+        case (expr_chan(?arg, ?id)) {\n             find_pre_post_expr(fcx, arg);\n-            copy_pre_post(fcx.ccx, a, arg);\n+            copy_pre_post(fcx.ccx, id, arg);\n         }\n-        case (expr_put(?opt, ?a)) {\n+        case (expr_put(?opt, ?id)) {\n             alt (opt) {\n                 case (some(?arg)) {\n                     find_pre_post_expr(fcx, arg);\n-                    copy_pre_post(fcx.ccx, a, arg);\n+                    copy_pre_post(fcx.ccx, id, arg);\n                 }\n                 case (none) { clear_pp(expr_pp(fcx.ccx, e)); }\n             }\n         }\n         case (\n              // FIXME this was just put in here as a placeholder\n-             expr_fn(?f, ?a)) {\n+             expr_fn(?f, ?id)) {\n             clear_pp(expr_pp(fcx.ccx, e));\n         }\n-        case (expr_block(?b, ?a)) {\n+        case (expr_block(?b, ?id)) {\n             find_pre_post_block(fcx, b);\n             auto p = block_pp(fcx.ccx, b);\n-            set_pre_and_post(fcx.ccx, a, p.precondition, p.postcondition);\n+            set_pre_and_post(fcx.ccx, id, p.precondition, p.postcondition);\n         }\n-        case (expr_rec(?fields, ?maybe_base, ?a)) {\n+        case (expr_rec(?fields, ?maybe_base, ?id)) {\n             auto es = field_exprs(fields);\n             vec::plus_option[@expr](es, maybe_base);\n-            find_pre_post_exprs(fcx, es, a);\n+            find_pre_post_exprs(fcx, es, id);\n         }\n-        case (expr_move(?lhs, ?rhs, ?a)) {\n+        case (expr_move(?lhs, ?rhs, ?id)) {\n \n             // FIXME: this needs to deinitialize the rhs\n             alt (lhs.node) {\n                 case (expr_path(?p, ?a_lhs)) {\n-                    gen_if_local(fcx, lhs, rhs, a, a_lhs, p);\n+                    gen_if_local(fcx, lhs, rhs, id, a_lhs, p);\n                 }\n-                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], a); }\n+                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], id); }\n             }\n         }\n-        case (expr_swap(?lhs, ?rhs, ?a)) {\n+        case (expr_swap(?lhs, ?rhs, ?id)) {\n             // Both sides must already be initialized\n \n-            find_pre_post_exprs(fcx, [lhs, rhs], a);\n+            find_pre_post_exprs(fcx, [lhs, rhs], id);\n         }\n-        case (expr_assign(?lhs, ?rhs, ?a)) {\n+        case (expr_assign(?lhs, ?rhs, ?id)) {\n             alt (lhs.node) {\n                 case (expr_path(?p, ?a_lhs)) {\n-                    gen_if_local(fcx, lhs, rhs, a, a_lhs, p);\n+                    gen_if_local(fcx, lhs, rhs, id, a_lhs, p);\n                 }\n-                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], a); }\n+                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], id); }\n             }\n         }\n-        case (expr_recv(?lhs, ?rhs, ?a)) {\n+        case (expr_recv(?lhs, ?rhs, ?id)) {\n             alt (rhs.node) {\n-                case (expr_path(?p, ?a_rhs)) {\n-                    gen_if_local(fcx, rhs, lhs, a, a_rhs, p);\n+                case (expr_path(?p, ?id_rhs)) {\n+                    gen_if_local(fcx, rhs, lhs, id, id_rhs, p);\n                 }\n                 case (_) {\n                     // doesn't check that rhs is an lval, but\n                     // that's probably ok\n \n-                    find_pre_post_exprs(fcx, [lhs, rhs], a);\n+                    find_pre_post_exprs(fcx, [lhs, rhs], id);\n                 }\n             }\n         }\n-        case (expr_assign_op(_, ?lhs, ?rhs, ?a)) {\n+        case (expr_assign_op(_, ?lhs, ?rhs, ?id)) {\n             /* Different from expr_assign in that the lhs *must*\n                already be initialized */\n \n-            find_pre_post_exprs(fcx, [lhs, rhs], a);\n+            find_pre_post_exprs(fcx, [lhs, rhs], id);\n         }\n-        case (expr_lit(_, ?a)) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_ret(?maybe_val, ?a)) {\n+        case (expr_lit(_, ?id)) { clear_pp(expr_pp(fcx.ccx, e)); }\n+        case (expr_ret(?maybe_val, ?id)) {\n             alt (maybe_val) {\n                 case (none) {\n-                    clear_precond(fcx.ccx, a);\n-                    set_postcond_false(fcx.ccx, a);\n+                    clear_precond(fcx.ccx, id);\n+                    set_postcond_false(fcx.ccx, id);\n                 }\n                 case (some(?ret_val)) {\n                     find_pre_post_expr(fcx, ret_val);\n-                    set_precondition(ann_to_ts_ann(fcx.ccx, a),\n+                    set_precondition(node_id_to_ts_ann(fcx.ccx, id),\n                                      expr_precond(fcx.ccx, ret_val));\n-                    set_postcond_false(fcx.ccx, a);\n+                    set_postcond_false(fcx.ccx, id);\n                 }\n             }\n         }\n-        case (expr_be(?e, ?a)) {\n+        case (expr_be(?e, ?id)) {\n             find_pre_post_expr(fcx, e);\n-            set_pre_and_post(fcx.ccx, a, expr_prestate(fcx.ccx, e),\n+            set_pre_and_post(fcx.ccx, id, expr_prestate(fcx.ccx, e),\n                              false_postcond(num_local_vars));\n         }\n-        case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n-            join_then_else(fcx, antec, conseq, maybe_alt, a, plain_if);\n+        case (expr_if(?antec, ?conseq, ?maybe_alt, ?id)) {\n+            join_then_else(fcx, antec, conseq, maybe_alt, id, plain_if);\n         }\n-        case (expr_binary(?bop, ?l, ?r, ?a)) {\n+        case (expr_binary(?bop, ?l, ?r, ?id)) {\n             /* *unless* bop is lazy (e.g. and, or)? \n                FIXME */\n \n-            find_pre_post_exprs(fcx, [l, r], a);\n+            find_pre_post_exprs(fcx, [l, r], id);\n         }\n-        case (expr_send(?l, ?r, ?a)) { find_pre_post_exprs(fcx, [l, r], a); }\n-        case (expr_unary(_, ?operand, ?a)) {\n+        case (expr_send(?l, ?r, ?id)) {\n+            find_pre_post_exprs(fcx, [l, r], id);\n+        }\n+        case (expr_unary(_, ?operand, ?id)) {\n             find_pre_post_expr(fcx, operand);\n-            copy_pre_post(fcx.ccx, a, operand);\n+            copy_pre_post(fcx.ccx, id, operand);\n         }\n-        case (expr_cast(?operand, _, ?a)) {\n+        case (expr_cast(?operand, _, ?id)) {\n             find_pre_post_expr(fcx, operand);\n-            copy_pre_post(fcx.ccx, a, operand);\n+            copy_pre_post(fcx.ccx, id, operand);\n         }\n-        case (expr_while(?test, ?body, ?a)) {\n+        case (expr_while(?test, ?body, ?id)) {\n             find_pre_post_expr(fcx, test);\n             find_pre_post_block(fcx, body);\n             log \"666\";\n-            set_pre_and_post(fcx.ccx, a,\n+            set_pre_and_post(fcx.ccx, id,\n                              seq_preconds(fcx,\n                                           [expr_pp(fcx.ccx, test),\n                                            block_pp(fcx.ccx, body)]),\n@@ -456,7 +457,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                                                   block_postcond(fcx.ccx,\n                                                                  body)]));\n         }\n-        case (expr_do_while(?body, ?test, ?a)) {\n+        case (expr_do_while(?body, ?test, ?id)) {\n             find_pre_post_block(fcx, body);\n             find_pre_post_expr(fcx, test);\n             auto loop_postcond =\n@@ -469,22 +470,22 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             if (has_nonlocal_exits(body)) {\n                 loop_postcond = empty_poststate(num_local_vars);\n             }\n-            set_pre_and_post(fcx.ccx, a,\n+            set_pre_and_post(fcx.ccx, id,\n                              seq_preconds(fcx,\n                                           [block_pp(fcx.ccx, body),\n                                            expr_pp(fcx.ccx, test)]),\n                              loop_postcond);\n         }\n-        case (expr_for(?d, ?index, ?body, ?a)) {\n-            find_pre_post_loop(fcx, d, index, body, a);\n+        case (expr_for(?d, ?index, ?body, ?id)) {\n+            find_pre_post_loop(fcx, d, index, body, id);\n         }\n-        case (expr_for_each(?d, ?index, ?body, ?a)) {\n-            find_pre_post_loop(fcx, d, index, body, a);\n+        case (expr_for_each(?d, ?index, ?body, ?id)) {\n+            find_pre_post_loop(fcx, d, index, body, id);\n         }\n-        case (expr_index(?e, ?sub, ?a)) {\n-            find_pre_post_exprs(fcx, [e, sub], a);\n+        case (expr_index(?e, ?sub, ?id)) {\n+            find_pre_post_exprs(fcx, [e, sub], id);\n         }\n-        case (expr_alt(?ex, ?alts, ?a)) {\n+        case (expr_alt(?ex, ?alts, ?id)) {\n             find_pre_post_expr(fcx, ex);\n             fn do_an_alt(&fn_ctxt fcx, &arm an_alt) -> pre_and_post {\n                 find_pre_post_block(fcx, an_alt.block);\n@@ -506,54 +507,54 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             auto g = bind combine_pp(antec_pp, fcx, _, _);\n             auto alts_overall_pp =\n                 vec::foldl[pre_and_post, pre_and_post](g, e_pp, alt_pps);\n-            set_pre_and_post(fcx.ccx, a, alts_overall_pp.precondition,\n+            set_pre_and_post(fcx.ccx, id, alts_overall_pp.precondition,\n                              alts_overall_pp.postcondition);\n         }\n-        case (expr_field(?operator, _, ?a)) {\n+        case (expr_field(?operator, _, ?id)) {\n             find_pre_post_expr(fcx, operator);\n-            copy_pre_post(fcx.ccx, a, operator);\n+            copy_pre_post(fcx.ccx, id, operator);\n         }\n-        case (expr_fail(?a, _)) {\n-            set_pre_and_post(fcx.ccx, a,\n+        case (expr_fail(?id, _)) {\n+            set_pre_and_post(fcx.ccx, id,\n                              /* if execution continues after fail,\n                                 then everything is true! */\n                              empty_prestate(num_local_vars),\n                              false_postcond(num_local_vars));\n         }\n-        case (expr_assert(?p, ?a)) {\n+        case (expr_assert(?p, ?id)) {\n             find_pre_post_expr(fcx, p);\n-            copy_pre_post(fcx.ccx, a, p);\n+            copy_pre_post(fcx.ccx, id, p);\n         }\n-        case (expr_check(?p, ?a)) {\n+        case (expr_check(?p, ?id)) {\n             find_pre_post_expr(fcx, p);\n-            copy_pre_post(fcx.ccx, a, p);\n+            copy_pre_post(fcx.ccx, id, p);\n             /* predicate p holds after this expression executes */\n \n             let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n-            gen(fcx, a, c.node);\n+            gen(fcx, id, c.node);\n         }\n-        case (expr_if_check(?p, ?conseq, ?maybe_alt, ?a)) {\n-            join_then_else(fcx, p, conseq, maybe_alt, a, if_check);\n+        case (expr_if_check(?p, ?conseq, ?maybe_alt, ?id)) {\n+            join_then_else(fcx, p, conseq, maybe_alt, id, if_check);\n         }\n \n-        case (expr_bind(?operator, ?maybe_args, ?a)) {\n+        case (expr_bind(?operator, ?maybe_args, ?id)) {\n             auto args = vec::cat_options[@expr](maybe_args);\n             vec::push[@expr](args, operator); /* ??? order of eval? */\n \n-            find_pre_post_exprs(fcx, args, a);\n+            find_pre_post_exprs(fcx, args, id);\n         }\n-        case (expr_break(?a)) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_cont(?a)) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_port(?a)) { clear_pp(expr_pp(fcx.ccx, e)); }\n-        case (expr_ext(_, _, _, ?expanded, ?a)) {\n+        case (expr_break(?id)) { clear_pp(expr_pp(fcx.ccx, e)); }\n+        case (expr_cont(?id)) { clear_pp(expr_pp(fcx.ccx, e)); }\n+        case (expr_port(?id)) { clear_pp(expr_pp(fcx.ccx, e)); }\n+        case (expr_ext(_, _, _, ?expanded, ?id)) {\n             find_pre_post_expr(fcx, expanded);\n-            copy_pre_post(fcx.ccx, a, expanded);\n+            copy_pre_post(fcx.ccx, id, expanded);\n         }\n-        case (expr_anon_obj(?anon_obj, _, _, ?a)) {\n+        case (expr_anon_obj(?anon_obj, _, _, ?id)) {\n             alt (anon_obj.with_obj) {\n                 case (some(?ex)) {\n                     find_pre_post_expr(fcx, ex);\n-                    copy_pre_post(fcx.ccx, a, ex);\n+                    copy_pre_post(fcx.ccx, id, ex);\n                 }\n                 case (none) { clear_pp(expr_pp(fcx.ccx, e)); }\n             }\n@@ -567,39 +568,40 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s) {\n     auto enclosing = fcx.enclosing;\n     auto num_local_vars = num_constraints(enclosing);\n     alt (s.node) {\n-        case (stmt_decl(?adecl, ?a)) {\n+        case (stmt_decl(?adecl, ?id)) {\n             alt (adecl.node) {\n                 case (decl_local(?alocal)) {\n                     alt (alocal.node.init) {\n                         case (some(?an_init)) {\n                             find_pre_post_expr(fcx, an_init.expr);\n-                            copy_pre_post(fcx.ccx, alocal.node.ann, \n+                            copy_pre_post(fcx.ccx, alocal.node.id, \n                                           an_init.expr);\n                             /* Inherit ann from initializer, and add var being\n                                initialized to the postcondition */\n \n-                            copy_pre_post(fcx.ccx, a, an_init.expr);\n-                            gen(fcx, a,\n+                            copy_pre_post(fcx.ccx, id, an_init.expr);\n+                            gen(fcx, id,\n                                 rec(id=alocal.node.id, \n                                     c=ninit(alocal.node.ident)));\n                         }\n                         case (none) {\n-                            clear_pp(ann_to_ts_ann(fcx.ccx,\n-                                                   alocal.node.ann)\n+                            clear_pp(node_id_to_ts_ann(fcx.ccx,\n+                                                       alocal.node.id)\n+                                     .conditions);\n+                            clear_pp(node_id_to_ts_ann(fcx.ccx, id)\n                                      .conditions);\n-                            clear_pp(ann_to_ts_ann(fcx.ccx, a).conditions);\n                         }\n                     }\n                 }\n                 case (decl_item(?anitem)) {\n-                    clear_pp(ann_to_ts_ann(fcx.ccx, a).conditions);\n+                    clear_pp(node_id_to_ts_ann(fcx.ccx, id).conditions);\n                     find_pre_post_item(fcx.ccx, *anitem);\n                 }\n             }\n         }\n-        case (stmt_expr(?e, ?a)) {\n+        case (stmt_expr(?e, ?id)) {\n             find_pre_post_expr(fcx, e);\n-            copy_pre_post(fcx.ccx, a, e);\n+            copy_pre_post(fcx.ccx, id, e);\n         }\n     }\n }\n@@ -661,7 +663,7 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) {\n     if (!has_nonlocal_exits(b)) {\n         block_postcond = union_postconds(nv, postconds);\n     }\n-    set_pre_and_post(fcx.ccx, b.node.a, block_precond, block_postcond);\n+    set_pre_and_post(fcx.ccx, b.node.id, block_precond, block_postcond);\n }\n \n fn find_pre_post_fn(&fn_ctxt fcx, &_fn f) {\n@@ -670,17 +672,17 @@ fn find_pre_post_fn(&fn_ctxt fcx, &_fn f) {\n     // Treat the tail expression as a return statement\n     alt (f.body.node.expr) {\n         case (some(?tailexpr)) {\n-            auto tailann = expr_ann(tailexpr);\n+            auto tailann = expr_node_id(tailexpr);\n             set_postcond_false(fcx.ccx, tailann);\n         }\n         case (none) {/* fallthrough */ }\n     }\n }\n \n-fn fn_pre_post(crate_ctxt ccx, &_fn f, &span sp, &ident i, &def_id id,\n-               &ann a) {\n+fn fn_pre_post(crate_ctxt ccx, &_fn f, &span sp, &ident i, node_id id) {\n     assert (ccx.fm.contains_key(id));\n-    auto fcx = rec(enclosing=ccx.fm.get(id), id=id, name=i, ccx=ccx);\n+    auto fcx = rec(enclosing=ccx.fm.get(id), id=id, name=i,\n+                   ccx=ccx);\n     find_pre_post_fn(fcx, f);\n }\n //"}, {"sha": "1e1e1dfbfa8c756702b96066923a78d1e9415031", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 148, "deletions": 146, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -55,7 +55,7 @@ import aux::log_states;\n import aux::log_states_err;\n import aux::block_states;\n import aux::controlflow_expr;\n-import aux::ann_to_def;\n+import aux::node_id_to_def;\n import aux::expr_to_constr;\n import aux::ninit;\n import aux::npred;\n@@ -73,7 +73,7 @@ import bitvectors::gen_poststate;\n import bitvectors::kill_poststate;\n import front::ast;\n import front::ast::*;\n-import middle::ty::expr_ann;\n+import middle::ty::expr_node_id;\n import middle::ty::expr_ty;\n import middle::ty::type_is_nil;\n import middle::ty::type_is_bot;\n@@ -101,23 +101,23 @@ fn seq_states(&fn_ctxt fcx, prestate pres, vec[@expr] exprs) ->\n     ret tup(changed, post);\n }\n \n-fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres, &ann a,\n+fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres, ast::node_id id,\n                              &vec[@expr] es) -> bool {\n     auto res = seq_states(fcx, pres, es);\n     auto changed = res._0;\n-    changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-    changed = extend_poststate_ann(fcx.ccx, a, res._1) || changed;\n+    changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n+    changed = extend_poststate_ann(fcx.ccx, id, res._1) || changed;\n     ret changed;\n }\n \n fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@local l,\n-                            &@expr index, &block body, &ann a) -> bool {\n+                            &@expr index, &block body, node_id id) -> bool {\n     auto changed = false;\n     /* same issues as while */\n \n     // FIXME: also want to set l as initialized, no?\n \n-    changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+    changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n     changed = find_pre_post_state_expr(fcx, pres, index) || changed;\n     /* in general, would need the intersection of\n        (poststate of index, poststate of body) */\n@@ -127,33 +127,33 @@ fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@local l,\n             || changed;\n \n     if (has_nonlocal_exits(body)) { \n-        changed = set_poststate_ann(fcx.ccx, a, pres) || changed;\n+        changed = set_poststate_ann(fcx.ccx, id, pres) || changed;\n     }\n \n     auto res_p =\n         intersect_postconds([expr_poststate(fcx.ccx, index),\n                              block_poststate(fcx.ccx, body)]);\n-    changed = extend_poststate_ann(fcx.ccx, a, res_p) || changed;\n+    changed = extend_poststate_ann(fcx.ccx, id, res_p) || changed;\n     ret changed;\n }\n \n-fn gen_if_local(&fn_ctxt fcx, &ann a_new_var, &ann a, &path p) -> bool {\n-    alt (ann_to_def(fcx.ccx, a_new_var)) {\n+fn gen_if_local(&fn_ctxt fcx, node_id new_var, node_id id, &path p) -> bool {\n+    alt (node_id_to_def(fcx.ccx, new_var)) {\n         case (some(def_local(?loc))) {\n-            ret gen_poststate(fcx, a,\n-                              rec(id=loc,\n+            ret gen_poststate(fcx, id,\n+                              rec(id=loc._1,\n                                   c=ninit(path_to_ident(fcx.ccx.tcx, p))));\n         }\n         case (_) { ret false; }\n     }\n }\n \n fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n-                  &option::t[@expr] maybe_alt, &ann a, &if_ty chk,\n+                  &option::t[@expr] maybe_alt, ast::node_id id, &if_ty chk,\n                   &prestate pres) -> bool {\n     auto changed = false;\n \n-    changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+    changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n     changed = find_pre_post_state_expr(fcx, pres, antec) || changed;\n     \n     /*\n@@ -179,7 +179,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                                   conseq) || changed;\n    \n             changed =\n-                extend_poststate_ann(fcx.ccx, a,\n+                extend_poststate_ann(fcx.ccx, id,\n                                      expr_poststate(fcx.ccx, antec))\n                 || changed;\n         }\n@@ -219,7 +219,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                block_poststate(fcx.ccx, conseq))); */\n \n             changed =\n-                extend_poststate_ann(fcx.ccx, a, poststate_res) ||\n+                extend_poststate_ann(fcx.ccx, id, poststate_res) ||\n                 changed;\n         }\n     }\n@@ -238,13 +238,13 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n \n     /* FIXME could get rid of some of the copy/paste */\n     alt (e.node) {\n-        case (expr_vec(?elts, _, _, ?a)) {\n-            ret find_pre_post_state_exprs(fcx, pres, a, elts);\n+        case (expr_vec(?elts, _, _, ?id)) {\n+            ret find_pre_post_state_exprs(fcx, pres, id, elts);\n         }\n-        case (expr_tup(?elts, ?a)) {\n-            ret find_pre_post_state_exprs(fcx, pres, a, elt_exprs(elts));\n+        case (expr_tup(?elts, ?id)) {\n+            ret find_pre_post_state_exprs(fcx, pres, id, elt_exprs(elts));\n         }\n-        case (expr_call(?operator, ?operands, ?a)) {\n+        case (expr_call(?operator, ?operands, ?id)) {\n             /* do the prestate for the rator */\n \n             /*            fcx.ccx.tcx.sess.span_note(operator.span, \n@@ -258,13 +258,13 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             changed =\n                 find_pre_post_state_exprs(fcx,\n                                           expr_poststate(fcx.ccx, operator),\n-                                          a, operands) || changed;\n+                                          id, operands) || changed;\n             /* if this is a failing call, it sets everything as initialized */\n \n             alt (controlflow_expr(fcx.ccx, operator)) {\n                 case (noreturn) {\n                     changed =\n-                        set_poststate_ann(fcx.ccx, a,\n+                        set_poststate_ann(fcx.ccx, id,\n                                           false_postcond(num_local_vars)) ||\n                             changed;\n                 }\n@@ -276,110 +276,110 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             */\n             ret changed;\n         }\n-        case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n+        case (expr_spawn(_, _, ?operator, ?operands, ?id)) {\n             changed = find_pre_post_state_expr(fcx, pres, operator);\n             ret find_pre_post_state_exprs(fcx,\n                                           expr_poststate(fcx.ccx, operator),\n-                                          a, operands) || changed;\n+                                          id, operands) || changed;\n         }\n-        case (expr_bind(?operator, ?maybe_args, ?a)) {\n+        case (expr_bind(?operator, ?maybe_args, ?id)) {\n             changed =\n                 find_pre_post_state_expr(fcx, pres, operator) || changed;\n             ret find_pre_post_state_exprs(fcx,\n                                           expr_poststate(fcx.ccx, operator),\n-                                          a, cat_options[@expr](maybe_args))\n+                                          id, cat_options[@expr](maybe_args))\n                     || changed;\n         }\n-        case (expr_path(_, ?a)) { ret pure_exp(fcx.ccx, a, pres); }\n-        case (expr_log(_, ?e, ?a)) {\n+        case (expr_path(_, ?id)) { ret pure_exp(fcx.ccx, id, pres); }\n+        case (expr_log(_, ?e, ?id)) {\n             /* factor out the \"one exp\" pattern */\n \n             changed = find_pre_post_state_expr(fcx, pres, e);\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             changed =\n-                extend_poststate_ann(fcx.ccx, a, expr_poststate(fcx.ccx, e))\n+                extend_poststate_ann(fcx.ccx, id, expr_poststate(fcx.ccx, e))\n                     || changed;\n             ret changed;\n         }\n-        case (expr_chan(?e, ?a)) {\n+        case (expr_chan(?e, ?id)) {\n             changed = find_pre_post_state_expr(fcx, pres, e);\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             changed =\n-                extend_poststate_ann(fcx.ccx, a, expr_poststate(fcx.ccx, e))\n+                extend_poststate_ann(fcx.ccx, id, expr_poststate(fcx.ccx, e))\n                     || changed;\n             ret changed;\n         }\n-        case (expr_ext(_, _, _, ?expanded, ?a)) {\n+        case (expr_ext(_, _, _, ?expanded, ?id)) {\n             changed = find_pre_post_state_expr(fcx, pres, expanded);\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             changed =\n-                extend_poststate_ann(fcx.ccx, a,\n+                extend_poststate_ann(fcx.ccx, id,\n                                      expr_poststate(fcx.ccx, expanded)) ||\n                     changed;\n             ret changed;\n         }\n-        case (expr_put(?maybe_e, ?a)) {\n+        case (expr_put(?maybe_e, ?id)) {\n             alt (maybe_e) {\n                 case (some(?arg)) {\n                     changed = find_pre_post_state_expr(fcx, pres, arg);\n                     changed =\n-                        extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+                        extend_prestate_ann(fcx.ccx, id, pres) || changed;\n                     changed =\n-                        extend_poststate_ann(fcx.ccx, a,\n+                        extend_poststate_ann(fcx.ccx, id,\n                                              expr_poststate(fcx.ccx, arg)) ||\n                             changed;\n                     ret changed;\n                 }\n-                case (none) { ret pure_exp(fcx.ccx, a, pres); }\n+                case (none) { ret pure_exp(fcx.ccx, id, pres); }\n             }\n         }\n-        case (expr_lit(?l, ?a)) { ret pure_exp(fcx.ccx, a, pres); }\n+        case (expr_lit(?l, ?id)) { ret pure_exp(fcx.ccx, id, pres); }\n         case (\n              // FIXME This was just put in here as a placeholder\n-             expr_fn(?f, ?a)) {\n-            ret pure_exp(fcx.ccx, a, pres);\n+             expr_fn(?f, ?id)) {\n+            ret pure_exp(fcx.ccx, id, pres);\n         }\n-        case (expr_block(?b, ?a)) {\n+        case (expr_block(?b, ?id)) {\n             changed = find_pre_post_state_block(fcx, pres, b) || changed;\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             changed =\n-                extend_poststate_ann(fcx.ccx, a, block_poststate(fcx.ccx, b))\n+                extend_poststate_ann(fcx.ccx, id, block_poststate(fcx.ccx, b))\n                     || changed;\n             ret changed;\n         }\n-        case (expr_rec(?fields, ?maybe_base, ?a)) {\n+        case (expr_rec(?fields, ?maybe_base, ?id)) {\n             changed =\n-                find_pre_post_state_exprs(fcx, pres, a, field_exprs(fields))\n+                find_pre_post_state_exprs(fcx, pres, id, field_exprs(fields))\n                     || changed;\n             alt (maybe_base) {\n                 case (none) {/* do nothing */ }\n                 case (some(?base)) {\n                     changed =\n                         find_pre_post_state_expr(fcx, pres, base) || changed;\n                     changed =\n-                        extend_poststate_ann(fcx.ccx, a,\n+                        extend_poststate_ann(fcx.ccx, id,\n                                              expr_poststate(fcx.ccx, base)) ||\n                             changed;\n                 }\n             }\n             ret changed;\n         }\n-        case (expr_move(?lhs, ?rhs, ?a)) {\n+        case (expr_move(?lhs, ?rhs, ?id)) {\n             // FIXME: this needs to deinitialize the rhs\n \n-            extend_prestate_ann(fcx.ccx, a, pres);\n+            extend_prestate_ann(fcx.ccx, id, pres);\n             alt (lhs.node) {\n-                case (expr_path(?p, ?a_lhs)) {\n+                case (expr_path(?p, ?id_lhs)) {\n                     // assignment to local var\n \n-                    changed = pure_exp(fcx.ccx, a_lhs, pres) || changed;\n+                    changed = pure_exp(fcx.ccx, id_lhs, pres) || changed;\n                     changed =\n                         find_pre_post_state_expr(fcx, pres, rhs) || changed;\n                     changed =\n-                        extend_poststate_ann(fcx.ccx, a,\n+                        extend_poststate_ann(fcx.ccx, id,\n                                              expr_poststate(fcx.ccx, rhs)) ||\n                             changed;\n-                    changed = gen_if_local(fcx, a_lhs, a, p) || changed;\n+                    changed = gen_if_local(fcx, id_lhs, id, p) || changed;\n                 }\n                 case (_) {\n                     // assignment to something that must already have been\n@@ -392,15 +392,15 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                                                  expr_poststate(fcx.ccx, lhs),\n                                                  rhs) || changed;\n                     changed =\n-                        extend_poststate_ann(fcx.ccx, a,\n+                        extend_poststate_ann(fcx.ccx, id,\n                                              expr_poststate(fcx.ccx, rhs)) ||\n                             changed;\n                 }\n             }\n             ret changed;\n         }\n-        case (expr_assign(?lhs, ?rhs, ?a)) {\n-            extend_prestate_ann(fcx.ccx, a, pres);\n+        case (expr_assign(?lhs, ?rhs, ?id)) {\n+            extend_prestate_ann(fcx.ccx, id, pres);\n             alt (lhs.node) {\n                 case (expr_path(?p, ?a_lhs)) {\n                     // assignment to local var\n@@ -409,10 +409,10 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                     changed =\n                         find_pre_post_state_expr(fcx, pres, rhs) || changed;\n                     changed =\n-                        extend_poststate_ann(fcx.ccx, a,\n+                        extend_poststate_ann(fcx.ccx, id,\n                                              expr_poststate(fcx.ccx, rhs)) ||\n                             changed;\n-                    changed = gen_if_local(fcx, a_lhs, a, p) || changed;\n+                    changed = gen_if_local(fcx, a_lhs, id, p) || changed;\n                 }\n                 case (_) {\n                     // assignment to something that must already have been\n@@ -425,40 +425,40 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                                                  expr_poststate(fcx.ccx, lhs),\n                                                  rhs) || changed;\n                     changed =\n-                        extend_poststate_ann(fcx.ccx, a,\n+                        extend_poststate_ann(fcx.ccx, id,\n                                              expr_poststate(fcx.ccx, rhs)) ||\n                             changed;\n                 }\n             }\n             ret changed;\n         }\n-        case (expr_swap(?lhs, ?rhs, ?a)) {\n+        case (expr_swap(?lhs, ?rhs, ?id)) {\n             /* quite similar to binary -- should abstract this */\n \n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, lhs) || changed;\n             changed =\n                 find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, lhs),\n                                          rhs) || changed;\n             changed =\n-                extend_poststate_ann(fcx.ccx, a, expr_poststate(fcx.ccx, rhs))\n-                    || changed;\n+                extend_poststate_ann(fcx.ccx, id,\n+                                     expr_poststate(fcx.ccx, rhs)) || changed;\n             ret changed;\n         }\n-        case (expr_recv(?lhs, ?rhs, ?a)) {\n-            extend_prestate_ann(fcx.ccx, a, pres);\n+        case (expr_recv(?lhs, ?rhs, ?id)) {\n+            extend_prestate_ann(fcx.ccx, id, pres);\n             alt (rhs.node) {\n-                case (expr_path(?p, ?a_rhs)) {\n+                case (expr_path(?p, ?id_rhs)) {\n                     // receive to local var\n \n-                    changed = pure_exp(fcx.ccx, a_rhs, pres) || changed;\n+                    changed = pure_exp(fcx.ccx, id_rhs, pres) || changed;\n                     changed =\n                         find_pre_post_state_expr(fcx, pres, lhs) || changed;\n                     changed =\n-                        extend_poststate_ann(fcx.ccx, a,\n+                        extend_poststate_ann(fcx.ccx, id,\n                                              expr_poststate(fcx.ccx, lhs)) ||\n                             changed;\n-                    changed = gen_if_local(fcx, a_rhs, a, p) || changed;\n+                    changed = gen_if_local(fcx, id_rhs, id, p) || changed;\n                 }\n                 case (_) {\n                     // receive to something that must already have been init'd\n@@ -470,25 +470,26 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                                                  expr_poststate(fcx.ccx, rhs),\n                                                  lhs) || changed;\n                     changed =\n-                        extend_poststate_ann(fcx.ccx, a,\n+                        extend_poststate_ann(fcx.ccx, id,\n                                              expr_poststate(fcx.ccx, lhs)) ||\n                             changed;\n                 }\n             }\n             ret changed;\n         }\n-        case (expr_ret(?maybe_ret_val, ?a)) {\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        case (expr_ret(?maybe_ret_val, ?id)) {\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             /* normally, everything is true if execution continues after\n                a ret expression (since execution never continues locally\n                after a ret expression */\n \n-            set_poststate_ann(fcx.ccx, a, false_postcond(num_local_vars));\n+            set_poststate_ann(fcx.ccx, id, false_postcond(num_local_vars));\n             /* return from an always-failing function clears the return bit */\n \n             alt (fcx.enclosing.cf) {\n                 case (noreturn) {\n-                    kill_poststate(fcx, a, rec(id=fcx.id, c=ninit(fcx.name)));\n+                    kill_poststate(fcx, id, rec(id=fcx.id,\n+                                                c=ninit(fcx.name)));\n                 }\n                 case (_) { }\n             }\n@@ -502,58 +503,59 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             }\n             ret changed;\n         }\n-        case (expr_be(?e, ?a)) {\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-            set_poststate_ann(fcx.ccx, a, false_postcond(num_local_vars));\n+        case (expr_be(?e, ?id)) {\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n+            set_poststate_ann(fcx.ccx, id, false_postcond(num_local_vars));\n             changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n             ret changed;\n         }\n-        case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n-            changed = join_then_else(fcx, antec, conseq, maybe_alt, a,\n+        case (expr_if(?antec, ?conseq, ?maybe_alt, ?id)) {\n+            changed = join_then_else(fcx, antec, conseq, maybe_alt, id,\n                                      plain_if, pres)\n                 || changed;\n \n             ret changed;\n         }\n-        case (expr_binary(?bop, ?l, ?r, ?a)) {\n+        case (expr_binary(?bop, ?l, ?r, ?id)) {\n             /* FIXME: what if bop is lazy? */\n \n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, l) || changed;\n             changed =\n                 find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, l), r)\n                     || changed;\n             changed =\n-                extend_poststate_ann(fcx.ccx, a, expr_poststate(fcx.ccx, r))\n+                extend_poststate_ann(fcx.ccx, id, expr_poststate(fcx.ccx, r))\n                     || changed;\n             ret changed;\n         }\n-        case (expr_send(?l, ?r, ?a)) {\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        case (expr_send(?l, ?r, ?id)) {\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, l) || changed;\n             changed =\n                 find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, l), r)\n                     || changed;\n             changed =\n-                extend_poststate_ann(fcx.ccx, a, expr_poststate(fcx.ccx, r))\n+                extend_poststate_ann(fcx.ccx, id, expr_poststate(fcx.ccx, r))\n                     || changed;\n             ret changed;\n         }\n-        case (expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n+        case (expr_assign_op(?op, ?lhs, ?rhs, ?id)) {\n             /* quite similar to binary -- should abstract this */\n \n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, lhs) || changed;\n             changed =\n                 find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, lhs),\n                                          rhs) || changed;\n             changed =\n-                extend_poststate_ann(fcx.ccx, a, expr_poststate(fcx.ccx, rhs))\n+                extend_poststate_ann(fcx.ccx, id,\n+                                     expr_poststate(fcx.ccx, rhs))\n                     || changed;\n             ret changed;\n         }\n-        case (expr_while(?test, ?body, ?a)) {\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        case (expr_while(?test, ?body, ?id)) {\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             /* to handle general predicates, we need to pass in\n                 pres `intersect` (poststate(a)) \n              like: auto test_pres = intersect_postconds(pres,\n@@ -570,22 +572,22 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             /* conservative approximation: if a loop contains a break\n                or cont, we assume nothing about the poststate */\n             if (has_nonlocal_exits(body)) { \n-                changed = set_poststate_ann(fcx.ccx, a, pres) || changed;\n+                changed = set_poststate_ann(fcx.ccx, id, pres) || changed;\n             }\n \n             changed =\n                 {\n                     auto e_post = expr_poststate(fcx.ccx, test);\n                     auto b_post = block_poststate(fcx.ccx, body);\n-                    extend_poststate_ann(fcx.ccx, a,\n+                    extend_poststate_ann(fcx.ccx, id,\n                                          intersect_postconds([e_post,\n                                                               b_post])) ||\n                         changed\n                 };\n             ret changed;\n         }\n-        case (expr_do_while(?body, ?test, ?a)) {\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        case (expr_do_while(?body, ?test, ?id)) {\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             auto changed0 = changed;\n             changed = find_pre_post_state_block(fcx, pres, body) || changed;\n             /* conservative approximination: if the body of the loop\n@@ -600,7 +602,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                 // FIXME\n                  // This doesn't set \"changed\", as if the previous state\n                 // was different, this might come back true every time\n-                set_poststate_ann(fcx.ccx, body.node.a, pres);\n+                set_poststate_ann(fcx.ccx, body.node.id, pres);\n                 changed = changed0;\n             }\n \n@@ -609,34 +611,34 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                                          test) || changed;\n \n             if (breaks) {\n-                set_poststate_ann(fcx.ccx, a, pres);\n+                set_poststate_ann(fcx.ccx, id, pres);\n             }\n             else {\n-                changed =  extend_poststate_ann(fcx.ccx, a,\n+                changed =  extend_poststate_ann(fcx.ccx, id,\n                                             expr_poststate(fcx.ccx, test)) ||\n                     changed;\n             }\n             ret changed;\n         }\n-        case (expr_for(?d, ?index, ?body, ?a)) {\n-            ret find_pre_post_state_loop(fcx, pres, d, index, body, a);\n+        case (expr_for(?d, ?index, ?body, ?id)) {\n+            ret find_pre_post_state_loop(fcx, pres, d, index, body, id);\n         }\n-        case (expr_for_each(?d, ?index, ?body, ?a)) {\n-            ret find_pre_post_state_loop(fcx, pres, d, index, body, a);\n+        case (expr_for_each(?d, ?index, ?body, ?id)) {\n+            ret find_pre_post_state_loop(fcx, pres, d, index, body, id);\n         }\n-        case (expr_index(?e, ?sub, ?a)) {\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        case (expr_index(?e, ?sub, ?id)) {\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n             changed =\n                 find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, e), sub)\n                     || changed;\n             changed =\n-                extend_poststate_ann(fcx.ccx, a,\n+                extend_poststate_ann(fcx.ccx, id,\n                                      expr_poststate(fcx.ccx, sub));\n             ret changed;\n         }\n-        case (expr_alt(?e, ?alts, ?a)) {\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        case (expr_alt(?e, ?alts, ?id)) {\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n             auto e_post = expr_poststate(fcx.ccx, e);\n             auto a_post;\n@@ -657,85 +659,85 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n \n                 a_post = e_post;\n             }\n-            changed = extend_poststate_ann(fcx.ccx, a, a_post) || changed;\n+            changed = extend_poststate_ann(fcx.ccx, id, a_post) || changed;\n             ret changed;\n         }\n-        case (expr_field(?e, _, ?a)) {\n+        case (expr_field(?e, _, ?id)) {\n             changed = find_pre_post_state_expr(fcx, pres, e);\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             changed =\n-                extend_poststate_ann(fcx.ccx, a, expr_poststate(fcx.ccx, e))\n+                extend_poststate_ann(fcx.ccx, id, expr_poststate(fcx.ccx, e))\n                     || changed;\n             ret changed;\n         }\n-        case (expr_unary(_, ?operand, ?a)) {\n+        case (expr_unary(_, ?operand, ?id)) {\n             changed = find_pre_post_state_expr(fcx, pres, operand) || changed;\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             changed =\n-                extend_poststate_ann(fcx.ccx, a,\n+                extend_poststate_ann(fcx.ccx, id,\n                                      expr_poststate(fcx.ccx, operand)) ||\n                     changed;\n             ret changed;\n         }\n-        case (expr_cast(?operand, _, ?a)) {\n+        case (expr_cast(?operand, _, ?id)) {\n             changed = find_pre_post_state_expr(fcx, pres, operand) || changed;\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             changed =\n-                extend_poststate_ann(fcx.ccx, a,\n+                extend_poststate_ann(fcx.ccx, id,\n                                      expr_poststate(fcx.ccx, operand)) ||\n                     changed;\n             ret changed;\n         }\n-        case (expr_fail(?a, _)) {\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        case (expr_fail(?id, _)) {\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             /* if execution continues after fail, then everything is true!\n                woo! */\n \n             changed =\n-                set_poststate_ann(fcx.ccx, a, false_postcond(num_local_vars))\n+                set_poststate_ann(fcx.ccx, id, false_postcond(num_local_vars))\n                     || changed;\n             ret changed;\n         }\n-        case (expr_assert(?p, ?a)) {\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        case (expr_assert(?p, ?id)) {\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n-            changed = extend_poststate_ann(fcx.ccx, a, pres) || changed;\n+            changed = extend_poststate_ann(fcx.ccx, id, pres) || changed;\n             ret changed;\n         }\n-        case (expr_check(?p, ?a)) {\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        case (expr_check(?p, ?id)) {\n+            changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n-            changed = extend_poststate_ann(fcx.ccx, a, pres) || changed;\n+            changed = extend_poststate_ann(fcx.ccx, id, pres) || changed;\n             /* predicate p holds after this expression executes */\n \n             let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n-            changed = gen_poststate(fcx, a, c.node) || changed;\n+            changed = gen_poststate(fcx, id, c.node) || changed;\n             ret changed;\n         }\n-        case (expr_if_check(?p, ?conseq, ?maybe_alt, ?a)) {\n-            changed = join_then_else(fcx, p, conseq, maybe_alt, a, if_check,\n+        case (expr_if_check(?p, ?conseq, ?maybe_alt, ?id)) {\n+            changed = join_then_else(fcx, p, conseq, maybe_alt, id, if_check,\n                                      pres)\n                 || changed;\n \n             ret changed;\n         }\n-        case (expr_break(?a)) { ret pure_exp(fcx.ccx, a, pres); }\n-        case (expr_cont(?a)) { ret pure_exp(fcx.ccx, a, pres); }\n-        case (expr_port(?a)) { ret pure_exp(fcx.ccx, a, pres); }\n-        case (expr_self_method(_, ?a)) { ret pure_exp(fcx.ccx, a, pres); }\n-        case (expr_anon_obj(?anon_obj, _, _, ?a)) {\n+        case (expr_break(?id)) { ret pure_exp(fcx.ccx, id, pres); }\n+        case (expr_cont(?id)) { ret pure_exp(fcx.ccx, id, pres); }\n+        case (expr_port(?id)) { ret pure_exp(fcx.ccx, id, pres); }\n+        case (expr_self_method(_, ?id)) { ret pure_exp(fcx.ccx, id, pres); }\n+        case (expr_anon_obj(?anon_obj, _, _, ?id)) {\n             alt (anon_obj.with_obj) {\n                 case (some(?e)) {\n                     changed = find_pre_post_state_expr(fcx, pres, e);\n                     changed =\n-                        extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+                        extend_prestate_ann(fcx.ccx, id, pres) || changed;\n                     changed =\n-                        extend_poststate_ann(fcx.ccx, a,\n+                        extend_poststate_ann(fcx.ccx, id,\n                                              expr_poststate(fcx.ccx, e)) ||\n                             changed;\n                     ret changed;\n                 }\n-                case (none) { ret pure_exp(fcx.ccx, a, pres); }\n+                case (none) { ret pure_exp(fcx.ccx, id, pres); }\n             }\n         }\n     }\n@@ -757,7 +759,7 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n     */\n \n     alt (s.node) {\n-        case (stmt_decl(?adecl, ?a)) {\n+        case (stmt_decl(?adecl, ?id)) {\n             alt (adecl.node) {\n                 case (decl_local(?alocal)) {\n                     alt (alocal.node.init) {\n@@ -775,7 +777,7 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n                                                                 an_init.expr))\n                                     || changed;\n                             changed =\n-                                gen_poststate(fcx, a,\n+                                gen_poststate(fcx, id,\n                                               rec(id=alocal.node.id,\n                                                   c=ninit(alocal.node.ident)))\n                                 || changed;\n@@ -868,8 +870,8 @@ fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b) ->\n         }\n     }\n \n-    set_prestate_ann(fcx.ccx, b.node.a, pres0);\n-    set_poststate_ann(fcx.ccx, b.node.a, post);\n+    set_prestate_ann(fcx.ccx, b.node.id, pres0);\n+    set_poststate_ann(fcx.ccx, b.node.id, post);\n     \n     /*\n     log_err \"For block:\";\n@@ -894,7 +896,7 @@ fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n \n     alt (f.body.node.expr) {\n         case (some(?tailexpr)) {\n-            auto tailann = expr_ann(tailexpr);\n+            auto tailann = expr_node_id(tailexpr);\n             auto tailty = expr_ty(fcx.ccx.tcx, tailexpr);\n \n             // Since blocks and alts and ifs that don't have results\n@@ -906,7 +908,7 @@ fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n                 auto p = false_postcond(num_local_vars);\n                 set_poststate_ann(fcx.ccx, tailann, p);\n                 // be sure to set the block poststate to the same thing\n-                set_poststate_ann(fcx.ccx, f.body.node.a, p);\n+                set_poststate_ann(fcx.ccx, f.body.node.id, p);\n                 alt (fcx.enclosing.cf) {\n                     case (noreturn) {\n                         kill_poststate(fcx, tailann,"}, {"sha": "4dbe8444ef8d124137bfff1c2f8fe92956943a08", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 95, "deletions": 91, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -24,10 +24,10 @@ import util::data::interner;\n import pretty::ppaux::ty_to_str;\n \n \n-export ann_to_monotype;\n-export ann_to_type;\n-export ann_to_type_params;\n-export ann_to_ty_param_substs_opt_and_ty;\n+export node_id_to_monotype;\n+export node_id_to_type;\n+export node_id_to_type_params;\n+export node_id_to_ty_param_substs_opt_and_ty;\n export any_item_native;\n export any_item_rust;\n export arg;\n@@ -42,7 +42,7 @@ export ctxt;\n export decl_local_ty;\n export def_has_ty_params;\n export eq_ty;\n-export expr_ann;\n+export expr_node_id;\n export expr_has_ty_params;\n export expr_ty;\n export fold_ty;\n@@ -95,7 +95,7 @@ export mo_val;\n export mo_alias;\n export mt;\n export node_type_table;\n-export pat_ann;\n+export pat_node_id;\n export pat_ty;\n export path_to_str;\n export rename;\n@@ -106,7 +106,7 @@ export sequence_element_type;\n export sequence_is_interior;\n export struct;\n export sort_methods;\n-export stmt_ann;\n+export stmt_node_id;\n export strip_boxes;\n export sty;\n export substitute_type_params;\n@@ -195,9 +195,8 @@ tag any_item {\n     any_item_native(@ast::native_item, ast::native_abi);\n }\n \n-type item_table = hashmap[ast::def_id, any_item];\n-\n-type constr_table = hashmap[ast::def_id, vec[constr_def]];\n+type item_table = hashmap[ast::node_id, any_item];\n+type constr_table = hashmap[ast::node_id, vec[constr_def]]; \n \n type mt = rec(t ty, ast::mutability mut);\n \n@@ -400,7 +399,7 @@ fn mk_ctxt(session::session s, resolve::def_map dm, constr_table cs) -> ctxt {\n     let node_type_table ntt =\n         @smallintmap::mk[ty::ty_param_substs_opt_and_ty]();\n     auto tcache = new_def_hash[ty::ty_param_count_and_ty]();\n-    auto items = new_def_hash[any_item]();\n+    auto items = new_int_hash[any_item]();\n     auto ts = @interner::mk[raw_t](hash_raw_ty, eq_raw_ty);\n     auto cx =\n         rec(ts=ts,\n@@ -1602,32 +1601,32 @@ fn eq_ty(&t a, &t b) -> bool { ret a == b; }\n \n \n // Type lookups\n-fn ann_to_ty_param_substs_opt_and_ty(&ctxt cx, &ast::ann ann) ->\n+fn node_id_to_ty_param_substs_opt_and_ty(&ctxt cx, &ast::node_id id) ->\n    ty_param_substs_opt_and_ty {\n \n     // Pull out the node type table.\n-    alt (smallintmap::find(*cx.node_types, ann.id)) {\n+    alt (smallintmap::find(*cx.node_types, id as uint)) {\n         case (none) {\n-            cx.sess.bug(\"ann_to_ty_param_substs_opt_and_ty() called on an \" +\n-                            \"untyped node\");\n+            cx.sess.bug(\"node_id_to_ty_param_substs_opt_and_ty() called on \" +\n+                       \"an untyped node (\" + std::int::to_str(id, 10u) + \")\");\n         }\n         case (some(?tpot)) { ret tpot; }\n     }\n }\n \n-fn ann_to_type(&ctxt cx, &ast::ann ann) -> t {\n-    ret ann_to_ty_param_substs_opt_and_ty(cx, ann)._1;\n+fn node_id_to_type(&ctxt cx, &ast::node_id id) -> t {\n+    ret node_id_to_ty_param_substs_opt_and_ty(cx, id)._1;\n }\n \n-fn ann_to_type_params(&ctxt cx, &ast::ann ann) -> vec[t] {\n-    alt (ann_to_ty_param_substs_opt_and_ty(cx, ann)._0) {\n+fn node_id_to_type_params(&ctxt cx, &ast::node_id id) -> vec[t] {\n+    alt (node_id_to_ty_param_substs_opt_and_ty(cx, id)._0) {\n         case (none) { let vec[t] result = []; ret result; }\n         case (some(?tps)) { ret tps; }\n     }\n }\n \n-fn ann_has_type_params(&ctxt cx, &ast::ann ann) -> bool {\n-    auto tpt = ann_to_ty_param_substs_opt_and_ty(cx, ann);\n+fn node_id_has_type_params(&ctxt cx, &ast::node_id id) -> bool {\n+    auto tpt = node_id_to_ty_param_substs_opt_and_ty(cx, id);\n     ret !option::is_none[vec[t]](tpt._0);\n }\n \n@@ -1645,8 +1644,8 @@ fn ty_param_substs_opt_and_ty_to_monotype(&ctxt cx,\n \n // Returns the type of an annotation, with type parameter substitutions\n // performed if applicable.\n-fn ann_to_monotype(&ctxt cx, ast::ann a) -> t {\n-    auto tpot = ann_to_ty_param_substs_opt_and_ty(cx, a);\n+fn node_id_to_monotype(&ctxt cx, ast::node_id id) -> t {\n+    auto tpot = node_id_to_ty_param_substs_opt_and_ty(cx, id);\n     ret ty_param_substs_opt_and_ty_to_monotype(cx, tpot);\n }\n \n@@ -1726,59 +1725,61 @@ fn ty_var_id(&ctxt cx, t typ) -> int {\n \n \n // Type accessors for AST nodes\n-fn block_ty(&ctxt cx, &ast::block b) -> t { ret ann_to_type(cx, b.node.a); }\n+fn block_ty(&ctxt cx, &ast::block b) -> t {\n+    ret node_id_to_type(cx, b.node.id);\n+}\n \n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n fn pat_ty(&ctxt cx, &@ast::pat pat) -> t {\n-    ret ann_to_monotype(cx, pat_ann(pat));\n-}\n-\n-fn expr_ann(&@ast::expr e) -> ast::ann {\n-    alt (e.node) {\n-        case (ast::expr_vec(_, _, _, ?a)) { ret a; }\n-        case (ast::expr_tup(_, ?a)) { ret a; }\n-        case (ast::expr_rec(_, _, ?a)) { ret a; }\n-        case (ast::expr_call(_, _, ?a)) { ret a; }\n-        case (ast::expr_bind(_, _, ?a)) { ret a; }\n-        case (ast::expr_binary(_, _, _, ?a)) { ret a; }\n-        case (ast::expr_unary(_, _, ?a)) { ret a; }\n-        case (ast::expr_lit(_, ?a)) { ret a; }\n-        case (ast::expr_cast(_, _, ?a)) { ret a; }\n-        case (ast::expr_if(_, _, _, ?a)) { ret a; }\n-        case (ast::expr_if_check(_, _, _, ?a)) { ret a; }\n-        case (ast::expr_while(_, _, ?a)) { ret a; }\n-        case (ast::expr_for(_, _, _, ?a)) { ret a; }\n-        case (ast::expr_for_each(_, _, _, ?a)) { ret a; }\n-        case (ast::expr_do_while(_, _, ?a)) { ret a; }\n-        case (ast::expr_alt(_, _, ?a)) { ret a; }\n-        case (ast::expr_fn(_, ?a)) { ret a; }\n-        case (ast::expr_block(_, ?a)) { ret a; }\n-        case (ast::expr_move(_, _, ?a)) { ret a; }\n-        case (ast::expr_assign(_, _, ?a)) { ret a; }\n-        case (ast::expr_swap(_, _, ?a)) { ret a; }\n-        case (ast::expr_assign_op(_, _, _, ?a)) { ret a; }\n-        case (ast::expr_send(_, _, ?a)) { ret a; }\n-        case (ast::expr_recv(_, _, ?a)) { ret a; }\n-        case (ast::expr_field(_, _, ?a)) { ret a; }\n-        case (ast::expr_index(_, _, ?a)) { ret a; }\n-        case (ast::expr_path(_, ?a)) { ret a; }\n-        case (ast::expr_ext(_, _, _, _, ?a)) { ret a; }\n-        case (ast::expr_fail(?a, _)) { ret a; }\n-        case (ast::expr_ret(_, ?a)) { ret a; }\n-        case (ast::expr_put(_, ?a)) { ret a; }\n-        case (ast::expr_be(_, ?a)) { ret a; }\n-        case (ast::expr_log(_, _, ?a)) { ret a; }\n-        case (ast::expr_assert(_, ?a)) { ret a; }\n-        case (ast::expr_check(_, ?a)) { ret a; }\n-        case (ast::expr_port(?a)) { ret a; }\n-        case (ast::expr_chan(_, ?a)) { ret a; }\n-        case (ast::expr_anon_obj(_, _, _, ?a)) { ret a; }\n-        case (ast::expr_break(?a)) { ret a; }\n-        case (ast::expr_cont(?a)) { ret a; }\n-        case (ast::expr_self_method(_, ?a)) { ret a; }\n-        case (ast::expr_spawn(_, _, _, _, ?a)) { ret a; }\n+    ret node_id_to_monotype(cx, pat_node_id(pat));\n+}\n+\n+fn expr_node_id(&@ast::expr e) -> ast::node_id {\n+    ret alt (e.node) {\n+        case (ast::expr_vec(_, _, _, ?id)) { id }\n+        case (ast::expr_tup(_, ?id)) { id }\n+        case (ast::expr_rec(_, _, ?id)) { id }\n+        case (ast::expr_call(_, _, ?id)) { id }\n+        case (ast::expr_bind(_, _, ?id)) { id }\n+        case (ast::expr_binary(_, _, _, ?id)) { id }\n+        case (ast::expr_unary(_, _, ?id)) { id }\n+        case (ast::expr_lit(_, ?id)) { id }\n+        case (ast::expr_cast(_, _, ?id)) { id }\n+        case (ast::expr_if(_, _, _, ?id)) { id }\n+        case (ast::expr_if_check(_, _, _, ?id)) { id }\n+        case (ast::expr_while(_, _, ?id)) { id }\n+        case (ast::expr_for(_, _, _, ?id)) { id }\n+        case (ast::expr_for_each(_, _, _, ?id)) { id }\n+        case (ast::expr_do_while(_, _, ?id)) { id }\n+        case (ast::expr_alt(_, _, ?id)) { id }\n+        case (ast::expr_fn(_, ?id)) { id }\n+        case (ast::expr_block(_, ?id)) { id }\n+        case (ast::expr_move(_, _, ?id)) { id }\n+        case (ast::expr_assign(_, _, ?id)) { id }\n+        case (ast::expr_swap(_, _, ?id)) { id }\n+        case (ast::expr_assign_op(_, _, _, ?id)) { id }\n+        case (ast::expr_send(_, _, ?id)) { id }\n+        case (ast::expr_recv(_, _, ?id)) { id }\n+        case (ast::expr_field(_, _, ?id)) { id }\n+        case (ast::expr_index(_, _, ?id)) { id }\n+        case (ast::expr_path(_, ?id)) { id }\n+        case (ast::expr_ext(_, _, _, _, ?id)) { id }\n+        case (ast::expr_fail(?id, _)) { id }\n+        case (ast::expr_ret(_, ?id)) { id }\n+        case (ast::expr_put(_, ?id)) { id }\n+        case (ast::expr_be(_, ?id)) { id }\n+        case (ast::expr_log(_, _, ?id)) { id }\n+        case (ast::expr_assert(_, ?id)) { id }\n+        case (ast::expr_check(_, ?id)) { id }\n+        case (ast::expr_port(?id)) { id }\n+        case (ast::expr_chan(_, ?id)) { id }\n+        case (ast::expr_anon_obj(_, _, _, ?id)) { id }\n+        case (ast::expr_break(?id)) { id }\n+        case (ast::expr_cont(?id)) { id }\n+        case (ast::expr_self_method(_, ?id)) { id }\n+        case (ast::expr_spawn(_, _, _, _, ?id)) { id }\n     }\n }\n \n@@ -1790,39 +1791,39 @@ fn expr_ann(&@ast::expr e) -> ast::ann {\n // instead of \"fn(&T) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n fn expr_ty(&ctxt cx, &@ast::expr expr) -> t {\n-    ret ann_to_monotype(cx, expr_ann(expr));\n+    ret node_id_to_monotype(cx, expr_node_id(expr));\n }\n \n fn expr_ty_params_and_ty(&ctxt cx, &@ast::expr expr) -> tup(vec[t], t) {\n-    auto a = expr_ann(expr);\n-    ret tup(ann_to_type_params(cx, a), ann_to_type(cx, a));\n+    auto a = expr_node_id(expr);\n+    ret tup(node_id_to_type_params(cx, a), node_id_to_type(cx, a));\n }\n \n fn expr_has_ty_params(&ctxt cx, &@ast::expr expr) -> bool {\n-    ret ann_has_type_params(cx, expr_ann(expr));\n+    ret node_id_has_type_params(cx, expr_node_id(expr));\n }\n \n fn decl_local_ty(&ctxt cx, &@ast::local l) -> t {\n-    ret ann_to_type(cx, l.node.ann);\n+    ret node_id_to_type(cx, l.node.id);\n }\n \n-fn stmt_ann(&@ast::stmt s) -> ast::ann {\n+fn stmt_node_id(&@ast::stmt s) -> ast::node_id {\n     alt (s.node) {\n-        case (ast::stmt_decl(_, ?a)) { ret a; }\n-        case (ast::stmt_expr(_, ?a)) { ret a; }\n+        case (ast::stmt_decl(_, ?id)) { ret id; }\n+        case (ast::stmt_expr(_, ?id)) { ret id; }\n         case (ast::stmt_crate_directive(_)) {\n-            log_err \"ty::stmt_ann(): crate directive found\";\n+            log_err \"ty::stmt_node_id(): crate directive found\";\n             fail;\n         }\n     }\n }\n \n-fn pat_ann(&@ast::pat p) -> ast::ann {\n+fn pat_node_id(&@ast::pat p) -> ast::node_id {\n     alt (p.node) {\n-        case (ast::pat_wild(?a)) { ret a; }\n-        case (ast::pat_bind(_, _, ?a)) { ret a; }\n-        case (ast::pat_lit(_, ?a)) { ret a; }\n-        case (ast::pat_tag(_, _, ?a)) { ret a; }\n+        case (ast::pat_wild(?id)) { ret id; }\n+        case (ast::pat_bind(_, ?id)) { ret id; }\n+        case (ast::pat_lit(_, ?id)) { ret id; }\n+        case (ast::pat_tag(_, _, ?id)) { ret id; }\n     }\n }\n \n@@ -2688,14 +2689,15 @@ fn tag_variants(&ctxt cx, &ast::def_id id) -> vec[variant_info] {\n     if (cx.sess.get_targ_crate_num() != id._0) {\n         ret creader::get_tag_variants(cx, id);\n     }\n-    assert (cx.items.contains_key(id));\n-    alt (cx.items.get(id)) {\n+    assert (cx.items.contains_key(id._1));\n+    alt (cx.items.get(id._1)) {\n         case (any_item_rust(?item)) {\n             alt (item.node) {\n                 case (ast::item_tag(?variants, _)) {\n                     let vec[variant_info] result = [];\n                     for (ast::variant variant in variants) {\n-                        auto ctor_ty = ann_to_monotype(cx, variant.node.ann);\n+                        auto ctor_ty = node_id_to_monotype\n+                            (cx, variant.node.id);\n                         let vec[t] arg_tys = [];\n                         if (vec::len[ast::variant_arg](variant.node.args) >\n                                 0u) {\n@@ -2705,7 +2707,9 @@ fn tag_variants(&ctxt cx, &ast::def_id id) -> vec[variant_info] {\n                         }\n                         auto did = variant.node.id;\n                         result +=\n-                            [rec(args=arg_tys, ctor_ty=ctor_ty, id=did)];\n+                            [rec(args=arg_tys,\n+                                 ctor_ty=ctor_ty,\n+                                 id=ast::local_def(did))];\n                     }\n                     ret result;\n                 }\n@@ -2759,8 +2763,8 @@ fn ret_ty_of_fn_ty(ctxt cx, t a_ty) -> t {\n     }\n }\n \n-fn ret_ty_of_fn(ctxt cx, ast::ann ann) -> t {\n-    ret ret_ty_of_fn_ty(cx, ann_to_type(cx, ann));\n+fn ret_ty_of_fn(ctxt cx, ast::node_id id) -> t {\n+    ret ret_ty_of_fn_ty(cx, node_id_to_type(cx, id));\n }\n \n "}, {"sha": "ca07350f2e824d8f5d88a0f82e401cadc22afa42", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 229, "deletions": 224, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -1,16 +1,17 @@\n \n import front::ast;\n-import front::ast::ann;\n import front::ast::mutability;\n+import front::ast::local_def;\n import front::creader;\n import driver::session;\n import util::common;\n import util::common::span;\n import util::common::respan;\n+import util::common::new_int_hash;\n import util::common::new_def_hash;\n import util::common::log_expr_err;\n import middle::ty;\n-import middle::ty::ann_to_type;\n+import middle::ty::node_id_to_type;\n import middle::ty::arg;\n import middle::ty::bind_params_in_type;\n import middle::ty::block_ty;\n@@ -49,7 +50,7 @@ type ty_table = hashmap[ast::def_id, ty::t];\n \n type fn_purity_table = hashmap[ast::def_id, ast::purity];\n \n-type obj_info = rec(vec[ast::obj_field] obj_fields, ast::def_id this_obj);\n+type obj_info = rec(vec[ast::obj_field] obj_fields, ast::node_id this_obj);\n \n type crate_ctxt =\n     rec(mutable vec[obj_info] obj_infos,\n@@ -60,10 +61,10 @@ type fn_ctxt =\n     rec(ty::t ret_ty,\n         ast::purity purity,\n         @ty::unify::var_bindings var_bindings,\n-        hashmap[ast::def_id, int] locals,\n-        hashmap[ast::def_id, ast::ident] local_names,\n+        hashmap[ast::node_id, int] locals,\n+        hashmap[ast::node_id, ast::ident] local_names,\n         mutable int next_var_id,\n-        mutable vec[uint] fixups,\n+        mutable vec[ast::node_id] fixups,\n         @crate_ctxt ccx);\n \n \n@@ -76,18 +77,18 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &span sp, &ast::def defn) ->\n    ty_param_count_and_ty {\n     alt (defn) {\n         case (ast::def_arg(?id)) {\n-            assert (fcx.locals.contains_key(id));\n-            auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id));\n+            assert (fcx.locals.contains_key(id._1));\n+            auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id._1));\n             ret tup(0u, typ);\n         }\n         case (ast::def_local(?id)) {\n-            assert (fcx.locals.contains_key(id));\n-            auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id));\n+            assert (fcx.locals.contains_key(id._1));\n+            auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id._1));\n             ret tup(0u, typ);\n         }\n         case (ast::def_obj_field(?id)) {\n-            assert (fcx.locals.contains_key(id));\n-            auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id));\n+            assert (fcx.locals.contains_key(id._1));\n+            auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id._1));\n             ret tup(0u, typ);\n         }\n         case (ast::def_fn(?id)) { ret ty::lookup_item_type(fcx.ccx.tcx, id); }\n@@ -101,8 +102,8 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &span sp, &ast::def defn) ->\n             ret ty::lookup_item_type(fcx.ccx.tcx, vid);\n         }\n         case (ast::def_binding(?id)) {\n-            assert (fcx.locals.contains_key(id));\n-            auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id));\n+            assert (fcx.locals.contains_key(id._1));\n+            auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id._1));\n             ret tup(0u, typ);\n         }\n         case (ast::def_obj(?id)) {\n@@ -319,8 +320,8 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             let vec[@ty::constr_def] out_constrs = vec::map(g, constrs);\n             typ = ty::mk_fn(tcx, proto, i, out_ty, cf, out_constrs);\n         }\n-        case (ast::ty_path(?path, ?ann)) {\n-            alt (tcx.def_map.get(ann.id)) {\n+        case (ast::ty_path(?path, ?id)) {\n+            alt (tcx.def_map.get(id)) {\n                 case (ast::def_ty(?id)) {\n                     typ =\n                         instantiate(tcx, ast_ty.span, getter, id,\n@@ -384,21 +385,22 @@ fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast::ty ast_ty) -> ty::t {\n \n // Functions that write types into the node type table.\n mod write {\n-    fn inner(&node_type_table ntt, uint node_id,\n+    fn inner(&node_type_table ntt, ast::node_id node_id,\n              &ty_param_substs_opt_and_ty tpot) {\n-        smallintmap::insert(*ntt, node_id, tpot);\n+        smallintmap::insert(*ntt, node_id as uint, tpot);\n     }\n \n     // Writes a type parameter count and type pair into the node type table.\n-    fn ty(&ty::ctxt tcx, uint node_id, &ty_param_substs_opt_and_ty tpot) {\n+    fn ty(&ty::ctxt tcx, ast::node_id node_id,\n+          &ty_param_substs_opt_and_ty tpot) {\n         assert (!ty::type_contains_vars(tcx, tpot._1));\n         ret inner(tcx.node_types, node_id, tpot);\n     }\n \n     // Writes a type parameter count and type pair into the node type table.\n     // This function allows for the possibility of type variables, which will\n     // be rewritten later during the fixup phase.\n-    fn ty_fixup(@fn_ctxt fcx, uint node_id,\n+    fn ty_fixup(@fn_ctxt fcx, ast::node_id node_id,\n                 &ty_param_substs_opt_and_ty tpot) {\n         inner(fcx.ccx.tcx.node_types, node_id, tpot);\n         if (ty::type_contains_vars(fcx.ccx.tcx, tpot._1)) {\n@@ -407,23 +409,23 @@ mod write {\n     }\n \n     // Writes a type with no type parameters into the node type table.\n-    fn ty_only(&ty::ctxt tcx, uint node_id, ty::t typ) {\n+    fn ty_only(&ty::ctxt tcx, ast::node_id node_id, ty::t typ) {\n         ret ty(tcx, node_id, tup(none[vec[ty::t]], typ));\n     }\n \n     // Writes a type with no type parameters into the node type table. This\n     // function allows for the possibility of type variables.\n-    fn ty_only_fixup(@fn_ctxt fcx, uint node_id, ty::t typ) {\n+    fn ty_only_fixup(@fn_ctxt fcx, ast::node_id node_id, ty::t typ) {\n         ret ty_fixup(fcx, node_id, tup(none[vec[ty::t]], typ));\n     }\n \n     // Writes a nil type into the node type table.\n-    fn nil_ty(&ty::ctxt tcx, uint node_id) {\n+    fn nil_ty(&ty::ctxt tcx, ast::node_id node_id) {\n         ret ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_nil(tcx)));\n     }\n \n     // Writes the bottom type into the node type table.\n-    fn bot_ty(&ty::ctxt tcx, uint node_id) {\n+    fn bot_ty(&ty::ctxt tcx, ast::node_id node_id) {\n         ret ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_bot(tcx)));\n     }\n }\n@@ -487,7 +489,7 @@ mod collect {\n \n             ret creader::get_type(cx.tcx, id);\n         }\n-        auto it = cx.tcx.items.get(id);\n+        auto it = cx.tcx.items.get(id._1);\n         auto tpt;\n         alt (it) {\n             case (ty::any_item_rust(?item)) { tpt = ty_of_item(cx, item); }\n@@ -536,7 +538,7 @@ mod collect {\n         ret tup(ty_param_count, t_obj);\n     }\n     fn ty_of_obj_ctor(@ctxt cx, &ast::ident id, &ast::_obj obj_info,\n-                      &ast::def_id ctor_id, &vec[ast::ty_param] ty_params) ->\n+                      ast::node_id ctor_id, &vec[ast::ty_param] ty_params) ->\n        ty::ty_param_count_and_ty {\n         auto t_obj = ty_of_obj(cx, id, obj_info, ty_params);\n         let vec[arg] t_inputs = [];\n@@ -548,7 +550,7 @@ mod collect {\n         auto t_fn = ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj._1,\n                               ast::return, []);\n         auto tpt = tup(t_obj._0, t_fn);\n-        cx.tcx.tcache.insert(ctor_id, tpt);\n+        cx.tcx.tcache.insert(local_def(ctor_id), tpt);\n         ret tpt;\n     }\n     fn ty_of_item(&@ctxt cx, &@ast::item it) -> ty::ty_param_count_and_ty {\n@@ -558,21 +560,21 @@ mod collect {\n             case (ast::item_const(?t, _)) {\n                 auto typ = convert(t);\n                 auto tpt = tup(0u, typ);\n-                cx.tcx.tcache.insert(it.id, tpt);\n+                cx.tcx.tcache.insert(local_def(it.id), tpt);\n                 ret tpt;\n             }\n             case (ast::item_fn(?fn_info, ?tps)) {\n                 auto f = bind ty_of_arg(cx, _);\n                 ret ty_of_fn_decl(cx, convert, f, fn_info.decl, fn_info.proto,\n-                                  tps, some(it.id));\n+                                  tps, some(local_def(it.id)));\n             }\n             case (ast::item_obj(?obj_info, ?tps, _)) {\n                 auto t_obj = ty_of_obj(cx, it.ident, obj_info, tps);\n-                cx.tcx.tcache.insert(it.id, t_obj);\n+                cx.tcx.tcache.insert(local_def(it.id), t_obj);\n                 ret t_obj;\n             }\n             case (ast::item_ty(?t, ?tps)) {\n-                alt (cx.tcx.tcache.find(it.id)) {\n+                alt (cx.tcx.tcache.find(local_def(it.id))) {\n                     case (some(?tpt)) { ret tpt; }\n                     case (none) { }\n                 }\n@@ -582,7 +584,7 @@ mod collect {\n                 auto typ = convert(t);\n                 auto ty_param_count = vec::len[ast::ty_param](tps);\n                 auto tpt = tup(ty_param_count, typ);\n-                cx.tcx.tcache.insert(it.id, tpt);\n+                cx.tcx.tcache.insert(local_def(it.id), tpt);\n                 ret tpt;\n             }\n             case (ast::item_tag(_, ?tps)) {\n@@ -594,10 +596,10 @@ mod collect {\n                     subtys += [ty::mk_param(cx.tcx, i)];\n                     i += 1u;\n                 }\n-                auto t = ty::mk_tag(cx.tcx, it.id, subtys);\n+                auto t = ty::mk_tag(cx.tcx, local_def(it.id), subtys);\n                 auto ty_param_count = vec::len[ast::ty_param](tps);\n                 auto tpt = tup(ty_param_count, t);\n-                cx.tcx.tcache.insert(it.id, tpt);\n+                cx.tcx.tcache.insert(local_def(it.id), tpt);\n                 ret tpt;\n             }\n             case (ast::item_mod(_)) { fail; }\n@@ -607,21 +609,21 @@ mod collect {\n     fn ty_of_native_item(&@ctxt cx, &@ast::native_item it,\n                          ast::native_abi abi) -> ty::ty_param_count_and_ty {\n         alt (it.node) {\n-            case (ast::native_item_fn(_, _, ?fn_decl, ?params, ?did, _)) {\n+            case (ast::native_item_fn(_, _, ?fn_decl, ?params, ?id)) {\n                 auto get = bind getter(cx, _);\n                 auto convert = bind ast_ty_to_ty(cx.tcx, get, _);\n                 auto f = bind ty_of_arg(cx, _);\n                 ret ty_of_native_fn_decl(cx, convert, f, fn_decl, abi, params,\n-                                         did);\n+                                         ast::local_def(id));\n             }\n-            case (ast::native_item_ty(?tpt, ?def_id)) {\n-                alt (cx.tcx.tcache.find(def_id)) {\n+            case (ast::native_item_ty(?tpt, ?id)) {\n+                alt (cx.tcx.tcache.find(local_def(id))) {\n                     case (some(?tpt)) { ret tpt; }\n                     case (none) { }\n                 }\n                 auto t = ty::mk_native(cx.tcx);\n                 auto tpt = tup(0u, t);\n-                cx.tcx.tcache.insert(def_id, tpt);\n+                cx.tcx.tcache.insert(local_def(id), tpt);\n                 ret tpt;\n             }\n         }\n@@ -661,8 +663,8 @@ mod collect {\n                                       ast::return, []);\n             }\n             auto tpt = tup(ty_param_count, result_ty);\n-            cx.tcx.tcache.insert(variant.node.id, tpt);\n-            write::ty_only(cx.tcx, variant.node.ann.id, result_ty);\n+            cx.tcx.tcache.insert(local_def(variant.node.id), tpt);\n+            write::ty_only(cx.tcx, variant.node.id, result_ty);\n         }\n     }\n     fn get_obj_method_types(&@ctxt cx, &ast::_obj object) -> vec[ty::method] {\n@@ -685,11 +687,10 @@ mod collect {\n     }\n     fn collect_native(ty::item_table id_to_ty_item, &@ast::native_item i) {\n         alt (i.node) {\n-            case (ast::native_item_ty(_, ?def_id)) {\n+            case (ast::native_item_ty(_, ?id)) {\n                 // The abi of types is not used.\n                 auto abi = ast::native_abi_cdecl;\n-                id_to_ty_item.insert(def_id,\n-                                     ty::any_item_native(i, abi));\n+                id_to_ty_item.insert(id, ty::any_item_native(i, abi));\n             }\n             case (_) {/* no-op */ }\n         }\n@@ -709,8 +710,9 @@ mod collect {\n             }\n             case (ast::item_tag(?variants, ?ty_params)) {\n                 auto tpt = ty_of_item(cx, it);\n-                write::ty_only(cx.tcx, it.ann.id, tpt._1);\n-                get_tag_variant_types(cx, it.id, variants, ty_params);\n+                write::ty_only(cx.tcx, it.id, tpt._1);\n+                get_tag_variant_types(cx, local_def(it.id), variants,\n+                                      ty_params);\n             }\n             case (ast::item_obj(?object, ?ty_params, ?ctor_id)) {\n                 // This calls ty_of_obj().\n@@ -721,7 +723,7 @@ mod collect {\n \n                 auto tpt =\n                     ty_of_obj_ctor(cx, it.ident, object, ctor_id, ty_params);\n-                write::ty_only(cx.tcx, it.ann.id, tpt._1);\n+                write::ty_only(cx.tcx, it.id, tpt._1);\n                 // Write the methods into the type table.\n                 //\n                 // FIXME: Inefficient; this ends up calling\n@@ -731,7 +733,7 @@ mod collect {\n                 auto method_types = get_obj_method_types(cx, object);\n                 auto i = 0u;\n                 while (i < vec::len[@ast::method](object.methods)) {\n-                    write::ty_only(cx.tcx, object.methods.(i).node.ann.id,\n+                    write::ty_only(cx.tcx, object.methods.(i).node.id,\n                                    ty::method_ty_to_fn_ty(cx.tcx,\n                                                           method_types.(i)));\n                     i += 1u;\n@@ -745,7 +747,7 @@ mod collect {\n                 i = 0u;\n                 while (i < vec::len[ty::arg](args)) {\n                     auto fld = object.fields.(i);\n-                    write::ty_only(cx.tcx, fld.ann.id, args.(i).ty);\n+                    write::ty_only(cx.tcx, fld.id, args.(i).ty);\n                     i += 1u;\n                 }\n \n@@ -755,7 +757,7 @@ mod collect {\n                     case (some(?m)) {\n                         auto t = ty::mk_fn(cx.tcx, ast::proto_fn, [],\n                                    ty::mk_nil(cx.tcx), ast::return, []);\n-                        write::ty_only(cx.tcx, m.node.ann.id, t);\n+                        write::ty_only(cx.tcx, m.node.id, t);\n                     }\n                 }\n             }\n@@ -765,7 +767,7 @@ mod collect {\n                 // it into the node type table.\n \n                 auto tpt = ty_of_item(cx, it);\n-                write::ty_only(cx.tcx, it.ann.id, tpt._1);\n+                write::ty_only(cx.tcx, it.id, tpt._1);\n             }\n         }\n     }\n@@ -782,8 +784,8 @@ mod collect {\n                 // FIXME: Native types have no annotation. Should they? --pcw\n \n             }\n-            case (ast::native_item_fn(_, _, _, _, _, ?ann)) {\n-                write::ty_only(cx.tcx, ann.id, tpt._1);\n+            case (ast::native_item_fn(_, _, _, _, ?id)) {\n+                write::ty_only(cx.tcx, id, tpt._1);\n             }\n         }\n     }\n@@ -984,8 +986,9 @@ mod writeback {\n             }\n         }\n     }\n-    fn resolve_type_vars_for_node(&@fn_ctxt fcx, &span sp, &ast::ann ann) {\n-        auto tpot = ty::ann_to_ty_param_substs_opt_and_ty(fcx.ccx.tcx, ann);\n+    fn resolve_type_vars_for_node(&@fn_ctxt fcx, &span sp, ast::node_id id) {\n+        auto tpot = ty::node_id_to_ty_param_substs_opt_and_ty\n+            (fcx.ccx.tcx, id);\n         auto new_ty = resolve_type_vars_in_type(fcx, sp, tpot._1);\n         auto new_substs_opt;\n         alt (tpot._0) {\n@@ -998,19 +1001,19 @@ mod writeback {\n                 new_substs_opt = some[vec[ty::t]](new_substs);\n             }\n         }\n-        write::ty(fcx.ccx.tcx, ann.id, tup(new_substs_opt, new_ty));\n+        write::ty(fcx.ccx.tcx, id, tup(new_substs_opt, new_ty));\n     }\n     fn visit_stmt_pre(@fn_ctxt fcx, &@ast::stmt s) {\n-        resolve_type_vars_for_node(fcx, s.span, ty::stmt_ann(s));\n+        resolve_type_vars_for_node(fcx, s.span, ty::stmt_node_id(s));\n     }\n     fn visit_expr_pre(@fn_ctxt fcx, &@ast::expr e) {\n-        resolve_type_vars_for_node(fcx, e.span, ty::expr_ann(e));\n+        resolve_type_vars_for_node(fcx, e.span, ty::expr_node_id(e));\n     }\n     fn visit_block_pre(@fn_ctxt fcx, &ast::block b) {\n-        resolve_type_vars_for_node(fcx, b.span, b.node.a);\n+        resolve_type_vars_for_node(fcx, b.span, b.node.id);\n     }\n     fn visit_pat_pre(@fn_ctxt fcx, &@ast::pat p) {\n-        resolve_type_vars_for_node(fcx, p.span, ty::pat_ann(p));\n+        resolve_type_vars_for_node(fcx, p.span, ty::pat_node_id(p));\n     }\n     fn visit_local_pre(@fn_ctxt fcx, &@ast::local l) {\n         auto var_id = fcx.locals.get(l.node.id);\n@@ -1019,7 +1022,7 @@ mod writeback {\n                                         var_id);\n         alt (fix_rslt) {\n             case (fix_ok(?lty)) {\n-                write::ty_only(fcx.ccx.tcx, l.node.ann.id, lty);\n+                write::ty_only(fcx.ccx.tcx, l.node.id, lty);\n             }\n             case (fix_err(_)) {\n                 fcx.ccx.tcx.sess.span_fatal(l.span,\n@@ -1058,24 +1061,25 @@ mod writeback {\n // for them before typechecking the function.\n type gather_result =\n     rec(@ty::unify::var_bindings var_bindings,\n-        hashmap[ast::def_id, int] locals,\n-        hashmap[ast::def_id, ast::ident] local_names,\n+        hashmap[ast::node_id, int] locals,\n+        hashmap[ast::node_id, ast::ident] local_names,\n         int next_var_id);\n \n fn gather_locals(&@crate_ctxt ccx, &ast::fn_decl decl, &ast::block body,\n-                 &ast::ann ann) -> gather_result {\n+                 &ast::node_id id) -> gather_result {\n     fn next_var_id(@mutable int nvi) -> int {\n         auto rv = *nvi;\n         *nvi += 1;\n         ret rv;\n     }\n     fn assign(&ty::ctxt tcx, &@ty::unify::var_bindings var_bindings,\n-              &hashmap[ast::def_id, int] locals,\n-              &hashmap[ast::def_id, ast::ident] local_names, @mutable int nvi,\n-              ast::def_id lid, &ast::ident ident, option::t[ty::t] ty_opt) {\n+              &hashmap[ast::node_id, int] locals,\n+              &hashmap[ast::node_id, ast::ident] local_names,\n+              @mutable int nvi,\n+              ast::node_id nid, &ast::ident ident, option::t[ty::t] ty_opt) {\n         auto var_id = next_var_id(nvi);\n-        locals.insert(lid, var_id);\n-        local_names.insert(lid, ident);\n+        locals.insert(nid, var_id);\n+        local_names.insert(nid, ident);\n         alt (ty_opt) {\n             case (none[ty::t]) {/* nothing to do */ }\n             case (some[ty::t](?typ)) {\n@@ -1085,24 +1089,24 @@ fn gather_locals(&@crate_ctxt ccx, &ast::fn_decl decl, &ast::block body,\n         }\n     }\n     auto vb = ty::unify::mk_var_bindings();\n-    auto locals = new_def_hash[int]();\n-    auto local_names = new_def_hash[ast::ident]();\n+    auto locals = new_int_hash[int]();\n+    auto local_names = new_int_hash[ast::ident]();\n     auto nvi = @mutable 0;\n     // Add object fields, if any.\n \n     alt (get_obj_info(ccx)) {\n         case (option::some(?oinfo)) {\n             for (ast::obj_field f in oinfo.obj_fields) {\n-                auto field_ty = ty::ann_to_type(ccx.tcx, f.ann);\n-                assign(ccx.tcx, vb, locals, local_names, nvi, f.id, f.ident,\n-                       some[ty::t](field_ty));\n+                auto field_ty = ty::node_id_to_type(ccx.tcx, f.id);\n+                assign(ccx.tcx, vb, locals, local_names, nvi, f.id,\n+                       f.ident, some(field_ty));\n             }\n         }\n         case (option::none) {/* no fields */ }\n     }\n     // Add formal parameters.\n \n-    auto args = ty::ty_fn_args(ccx.tcx, ty::ann_to_type(ccx.tcx, ann));\n+    auto args = ty::ty_fn_args(ccx.tcx, ty::node_id_to_type(ccx.tcx, id));\n     auto i = 0u;\n     for (ty::arg arg in args) {\n         assign(ccx.tcx, vb, locals, local_names, nvi, decl.inputs.(i).id,\n@@ -1112,8 +1116,8 @@ fn gather_locals(&@crate_ctxt ccx, &ast::fn_decl decl, &ast::block body,\n     // Add explicitly-declared locals.\n \n     fn visit_local_pre(@crate_ctxt ccx, @ty::unify::var_bindings vb,\n-                       hashmap[ast::def_id, int] locals,\n-                       hashmap[ast::def_id, ast::ident] local_names,\n+                       hashmap[ast::node_id, int] locals,\n+                       hashmap[ast::node_id, ast::ident] local_names,\n                        @mutable int nvi, &@ast::local local) {\n         alt (local.node.ty) {\n             case (none) {\n@@ -1134,13 +1138,13 @@ fn gather_locals(&@crate_ctxt ccx, &ast::fn_decl decl, &ast::block body,\n     // Add pattern bindings.\n \n     fn visit_pat_pre(@crate_ctxt ccx, @ty::unify::var_bindings vb,\n-                     hashmap[ast::def_id, int] locals,\n-                     hashmap[ast::def_id, ast::ident] local_names,\n+                     hashmap[ast::node_id, int] locals,\n+                     hashmap[ast::node_id, ast::ident] local_names,\n                      @mutable int nvi, &@ast::pat p) {\n         alt (p.node) {\n-            case (ast::pat_bind(?ident, ?did, _)) {\n-                assign(ccx.tcx, vb, locals, local_names, nvi, did, ident,\n-                       none[ty::t]);\n+            case (ast::pat_bind(?ident, ?id)) {\n+                assign(ccx.tcx, vb, locals, local_names, nvi,\n+                       id, ident, none[ty::t]);\n             }\n             case (_) {/* no-op */ }\n         }\n@@ -1166,7 +1170,7 @@ fn replace_expr_type(&@fn_ctxt fcx, &@ast::expr expr,\n     if (ty::expr_has_ty_params(fcx.ccx.tcx, expr)) {\n         new_tps = some[vec[ty::t]](new_tyt._0);\n     } else { new_tps = none[vec[ty::t]]; }\n-    write::ty_fixup(fcx, ty::expr_ann(expr).id, tup(new_tps, new_tyt._1));\n+    write::ty_fixup(fcx, ty::expr_node_id(expr), tup(new_tps, new_tyt._1));\n }\n \n \n@@ -1191,24 +1195,24 @@ fn check_lit(@crate_ctxt ccx, &@ast::lit lit) -> ty::t {\n // their types immediately.\n fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n     alt (pat.node) {\n-        case (ast::pat_wild(?ann)) {\n-            write::ty_only_fixup(fcx, ann.id, expected);\n+        case (ast::pat_wild(?id)) {\n+            write::ty_only_fixup(fcx, id, expected);\n         }\n-        case (ast::pat_lit(?lt, ?ann)) {\n+        case (ast::pat_lit(?lt, ?id)) {\n             auto typ = check_lit(fcx.ccx, lt);\n             typ = demand::simple(fcx, pat.span, expected, typ);\n-            write::ty_only_fixup(fcx, ann.id, typ);\n+            write::ty_only_fixup(fcx, id, typ);\n         }\n-        case (ast::pat_bind(?id, ?def_id, ?ann)) {\n-            auto vid = fcx.locals.get(def_id);\n+        case (ast::pat_bind(?name, ?id)) {\n+            auto vid = fcx.locals.get(id);\n             auto typ = ty::mk_var(fcx.ccx.tcx, vid);\n             typ = demand::simple(fcx, pat.span, expected, typ);\n-            write::ty_only_fixup(fcx, ann.id, typ);\n+            write::ty_only_fixup(fcx, id, typ);\n         }\n-        case (ast::pat_tag(?path, ?subpats, ?ann)) {\n+        case (ast::pat_tag(?path, ?subpats, ?id)) {\n             // Typecheck the path.\n \n-            auto v_def = fcx.ccx.tcx.def_map.get(ann.id);\n+            auto v_def = fcx.ccx.tcx.def_map.get(id);\n             auto v_def_ids = ast::variant_def_ids(v_def);\n             auto tag_tpt = ty::lookup_item_type(fcx.ccx.tcx, v_def_ids._0);\n             auto path_tpot = instantiate_path(fcx, path, tag_tpt, pat.span);\n@@ -1283,7 +1287,7 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n                                                    \"\"\n                                                } else { \"s\" }));\n             }\n-            write::ty_fixup(fcx, ann.id, path_tpot);\n+            write::ty_fixup(fcx, id, path_tpot);\n         }\n     }\n }\n@@ -1309,9 +1313,9 @@ fn require_pure_call(@crate_ctxt ccx, &ast::purity caller_purity,\n         case (ast::impure_fn) { ret; }\n         case (ast::pure_fn) {\n             alt (callee.node) {\n-                case (ast::expr_path(_, ?ann)) {\n+                case (ast::expr_path(_, ?id)) {\n                     auto d_id;\n-                    alt (ccx.tcx.def_map.get(ann.id)) {\n+                    alt (ccx.tcx.def_map.get(id)) {\n                         case (ast::def_fn(?_d_id)) { d_id = _d_id; }\n                     }\n                     alt (get_function_purity(ccx, d_id)) {\n@@ -1408,12 +1412,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n     // A generic function for checking assignment expressions\n \n     fn check_assignment(&@fn_ctxt fcx, &span sp, &@ast::expr lhs,\n-                        &@ast::expr rhs, &ast::ann a) {\n+                        &@ast::expr rhs, &ast::node_id id) {\n         check_expr(fcx, lhs);\n         check_expr(fcx, rhs);\n         demand::simple(fcx, sp, expr_ty(fcx.ccx.tcx, lhs),\n                        expr_ty(fcx.ccx.tcx, rhs));\n-        write::ty_only_fixup(fcx, a.id, ty::mk_nil(fcx.ccx.tcx));\n+        write::ty_only_fixup(fcx, id, ty::mk_nil(fcx.ccx.tcx));\n     }\n     // A generic function for checking call expressions\n \n@@ -1431,7 +1435,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n     fn check_for_or_for_each(&@fn_ctxt fcx, &@ast::local local,\n                              &ty::t element_ty, &ast::block body,\n-                             uint node_id) {\n+                             ast::node_id node_id) {\n         check_decl_local(fcx, local);\n         check_block(fcx, body);\n         // Unify type of decl with element type of the seq\n@@ -1454,9 +1458,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             alt (e.node) {\n                 case (ast::expr_call(?operator, ?operands, _)) {\n                     alt (operator.node) {\n-                        case (ast::expr_path(?oper_name, ?ann)) {\n+                        case (ast::expr_path(?oper_name, ?id)) {\n                             auto d_id;\n-                            alt (fcx.ccx.tcx.def_map.get(ann.id)) {\n+                            alt (fcx.ccx.tcx.def_map.get(id)) {\n                                 case (ast::def_fn(?_d_id)) { d_id = _d_id; }\n                             }\n                             for (@ast::expr operand in operands) {\n@@ -1485,7 +1489,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n     // A generic function for checking the then and else in an if\n     // or if-check\n     fn check_then_else(&@fn_ctxt fcx, &ast::block thn,\n-                       &option::t[@ast::expr] elsopt, &ann a, &span sp) {\n+                       &option::t[@ast::expr] elsopt,\n+                       ast::node_id id, &span sp) {\n         check_block(fcx, thn);\n         auto if_t =\n             alt (elsopt) {\n@@ -1500,15 +1505,15 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     }\n                     case (none) { ty::mk_nil(fcx.ccx.tcx) }\n             };\n-        write::ty_only_fixup(fcx, a.id, if_t);\n+        write::ty_only_fixup(fcx, id, if_t);\n     }\n \n     alt (expr.node) {\n-        case (ast::expr_lit(?lit, ?a)) {\n+        case (ast::expr_lit(?lit, ?id)) {\n             auto typ = check_lit(fcx.ccx, lit);\n-            write::ty_only_fixup(fcx, a.id, typ);\n+            write::ty_only_fixup(fcx, id, typ);\n         }\n-        case (ast::expr_binary(?binop, ?lhs, ?rhs, ?a)) {\n+        case (ast::expr_binary(?binop, ?lhs, ?rhs, ?id)) {\n             check_expr(fcx, lhs);\n             check_expr(fcx, rhs);\n \n@@ -1529,9 +1534,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 case (ast::gt) { t = ty::mk_bool(fcx.ccx.tcx); }\n                 case (_) {/* fall through */ }\n             }\n-            write::ty_only_fixup(fcx, a.id, t);\n+            write::ty_only_fixup(fcx, id, t);\n         }\n-        case (ast::expr_unary(?unop, ?oper, ?a)) {\n+        case (ast::expr_unary(?unop, ?oper, ?id)) {\n             check_expr(fcx, oper);\n             auto oper_t = expr_ty(fcx.ccx.tcx, oper);\n             alt (unop) {\n@@ -1562,15 +1567,15 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n                 case (_) { oper_t = strip_boxes(fcx, expr.span, oper_t); }\n             }\n-            write::ty_only_fixup(fcx, a.id, oper_t);\n+            write::ty_only_fixup(fcx, id, oper_t);\n         }\n-        case (ast::expr_path(?pth, ?old_ann)) {\n+        case (ast::expr_path(?pth, ?old_id)) {\n             auto t = ty::mk_nil(fcx.ccx.tcx);\n-            auto defn = fcx.ccx.tcx.def_map.get(old_ann.id);\n+            auto defn = fcx.ccx.tcx.def_map.get(old_id);\n             auto tpt = ty_param_count_and_ty_for_def(fcx, expr.span, defn);\n             if (ty::def_has_ty_params(defn)) {\n                 auto path_tpot = instantiate_path(fcx, pth, tpt, expr.span);\n-                write::ty_fixup(fcx, old_ann.id, path_tpot);\n+                write::ty_fixup(fcx, old_id, path_tpot);\n                 ret;\n             }\n             // The definition doesn't take type parameters. If the programmer\n@@ -1581,17 +1586,17 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                           \"this kind of value does not \\\n                                            take type parameters\");\n             }\n-            write::ty_only_fixup(fcx, old_ann.id, tpt._1);\n+            write::ty_only_fixup(fcx, old_id, tpt._1);\n         }\n-        case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?a)) {\n+        case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?id)) {\n             check_expr(fcx, expanded);\n             auto t = expr_ty(fcx.ccx.tcx, expanded);\n-            write::ty_only_fixup(fcx, a.id, t);\n+            write::ty_only_fixup(fcx, id, t);\n         }\n-        case (ast::expr_fail(?a, _)) { write::bot_ty(fcx.ccx.tcx, a.id); }\n-        case (ast::expr_break(?a)) { write::bot_ty(fcx.ccx.tcx, a.id); }\n-        case (ast::expr_cont(?a)) { write::bot_ty(fcx.ccx.tcx, a.id); }\n-        case (ast::expr_ret(?expr_opt, ?a)) {\n+        case (ast::expr_fail(?id, _)) { write::bot_ty(fcx.ccx.tcx, id); }\n+        case (ast::expr_break(?id)) { write::bot_ty(fcx.ccx.tcx, id); }\n+        case (ast::expr_cont(?id)) { write::bot_ty(fcx.ccx.tcx, id); }\n+        case (ast::expr_ret(?expr_opt, ?id)) {\n             alt (expr_opt) {\n                 case (none) {\n                     auto nil = ty::mk_nil(fcx.ccx.tcx);\n@@ -1600,17 +1605,17 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                                   \"ret; in function \\\n                                                    returning non-nil\");\n                     }\n-                    write::bot_ty(fcx.ccx.tcx, a.id);\n+                    write::bot_ty(fcx.ccx.tcx, id);\n                 }\n                 case (some(?e)) {\n                     check_expr(fcx, e);\n                     demand::simple(fcx, expr.span, fcx.ret_ty,\n                                    expr_ty(fcx.ccx.tcx, e));\n-                    write::bot_ty(fcx.ccx.tcx, a.id);\n+                    write::bot_ty(fcx.ccx.tcx, id);\n                 }\n             }\n         }\n-        case (ast::expr_put(?expr_opt, ?a)) {\n+        case (ast::expr_put(?expr_opt, ?id)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n             alt (expr_opt) {\n                 case (none) {\n@@ -1620,57 +1625,57 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                                   \"put; in iterator \\\n                                                    yielding non-nil\");\n                     }\n-                    write::nil_ty(fcx.ccx.tcx, a.id);\n+                    write::nil_ty(fcx.ccx.tcx, id);\n                 }\n                 case (some(?e)) {\n                     check_expr(fcx, e);\n-                    write::nil_ty(fcx.ccx.tcx, a.id);\n+                    write::nil_ty(fcx.ccx.tcx, id);\n                 }\n             }\n         }\n-        case (ast::expr_be(?e, ?a)) {\n+        case (ast::expr_be(?e, ?id)) {\n             // FIXME: prove instead of assert\n \n             assert (ast::is_call_expr(e));\n             check_expr(fcx, e);\n             demand::simple(fcx, e.span, fcx.ret_ty, expr_ty(fcx.ccx.tcx, e));\n-            write::nil_ty(fcx.ccx.tcx, a.id);\n+            write::nil_ty(fcx.ccx.tcx, id);\n         }\n-        case (ast::expr_log(?l, ?e, ?a)) {\n+        case (ast::expr_log(?l, ?e, ?id)) {\n             auto expr_t = check_expr(fcx, e);\n-            write::nil_ty(fcx.ccx.tcx, a.id);\n+            write::nil_ty(fcx.ccx.tcx, id);\n         }\n-        case (ast::expr_check(?e, ?a)) {\n+        case (ast::expr_check(?e, ?id)) {\n             check_pred_expr(fcx, e);\n-            write::nil_ty(fcx.ccx.tcx, a.id);\n+            write::nil_ty(fcx.ccx.tcx, id);\n         }\n-        case (ast::expr_if_check(?cond, ?thn, ?elsopt, ?a)) {\n+        case (ast::expr_if_check(?cond, ?thn, ?elsopt, ?id)) {\n             check_pred_expr(fcx, cond);\n-            check_then_else(fcx, thn, elsopt, a, expr.span);\n+            check_then_else(fcx, thn, elsopt, id, expr.span);\n         }\n-        case (ast::expr_assert(?e, ?a)) {\n+        case (ast::expr_assert(?e, ?id)) {\n             check_expr(fcx, e);\n             auto ety = expr_ty(fcx.ccx.tcx, e);\n             demand::simple(fcx, expr.span, ty::mk_bool(fcx.ccx.tcx), ety);\n-            write::nil_ty(fcx.ccx.tcx, a.id);\n+            write::nil_ty(fcx.ccx.tcx, id);\n         }\n-        case (ast::expr_move(?lhs, ?rhs, ?a)) {\n+        case (ast::expr_move(?lhs, ?rhs, ?id)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n-            check_assignment(fcx, expr.span, lhs, rhs, a);\n+            check_assignment(fcx, expr.span, lhs, rhs, id);\n         }\n-        case (ast::expr_assign(?lhs, ?rhs, ?a)) {\n+        case (ast::expr_assign(?lhs, ?rhs, ?id)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n-            check_assignment(fcx, expr.span, lhs, rhs, a);\n+            check_assignment(fcx, expr.span, lhs, rhs, id);\n         }\n-        case (ast::expr_swap(?lhs, ?rhs, ?a)) {\n+        case (ast::expr_swap(?lhs, ?rhs, ?id)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n-            check_assignment(fcx, expr.span, lhs, rhs, a);\n+            check_assignment(fcx, expr.span, lhs, rhs, id);\n         }\n-        case (ast::expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n+        case (ast::expr_assign_op(?op, ?lhs, ?rhs, ?id)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n-            check_assignment(fcx, expr.span, lhs, rhs, a);\n+            check_assignment(fcx, expr.span, lhs, rhs, id);\n         }\n-        case (ast::expr_send(?lhs, ?rhs, ?a)) {\n+        case (ast::expr_send(?lhs, ?rhs, ?id)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n             check_expr(fcx, lhs);\n             check_expr(fcx, rhs);\n@@ -1688,25 +1693,25 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     fcx.ccx.tcx.sess.span_fatal(expr.span,s);\n                 }\n             }\n-            write::ty_only_fixup(fcx, a.id, chan_t);\n+            write::ty_only_fixup(fcx, id, chan_t);\n         }\n-        case (ast::expr_recv(?lhs, ?rhs, ?a)) {\n+        case (ast::expr_recv(?lhs, ?rhs, ?id)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n             check_expr(fcx, lhs);\n             check_expr(fcx, rhs);\n             auto item_t = expr_ty(fcx.ccx.tcx, rhs);\n             auto port_t = ty::mk_port(fcx.ccx.tcx, item_t);\n             demand::simple(fcx, expr.span, port_t, expr_ty(fcx.ccx.tcx, lhs));\n-            write::ty_only_fixup(fcx, a.id, item_t);\n+            write::ty_only_fixup(fcx, id, item_t);\n         }\n-        case (ast::expr_if(?cond, ?thn, ?elsopt, ?a)) {\n+        case (ast::expr_if(?cond, ?thn, ?elsopt, ?id)) {\n             check_expr(fcx, cond);\n             demand::simple(fcx, cond.span,\n                            ty::mk_bool(fcx.ccx.tcx),\n                            expr_ty(fcx.ccx.tcx, cond));\n-            check_then_else(fcx, thn, elsopt, a, expr.span);\n+            check_then_else(fcx, thn, elsopt, id, expr.span);\n         }\n-        case (ast::expr_for(?decl, ?seq, ?body, ?a)) {\n+        case (ast::expr_for(?decl, ?seq, ?body, ?id)) {\n             check_expr(fcx, seq);\n             auto elt_ty;\n             alt (structure_of(fcx, expr.span, expr_ty(fcx.ccx.tcx, seq))) {\n@@ -1720,28 +1725,28 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                                is not a vector or string\");\n                 }\n             }\n-            check_for_or_for_each(fcx, decl, elt_ty, body, a.id);\n+            check_for_or_for_each(fcx, decl, elt_ty, body, id);\n         }\n-        case (ast::expr_for_each(?decl, ?seq, ?body, ?a)) {\n+        case (ast::expr_for_each(?decl, ?seq, ?body, ?id)) {\n             check_expr(fcx, seq);\n             check_for_or_for_each(fcx, decl, expr_ty(fcx.ccx.tcx, seq), body,\n-                                  a.id);\n+                                  id);\n         }\n-        case (ast::expr_while(?cond, ?body, ?a)) {\n+        case (ast::expr_while(?cond, ?body, ?id)) {\n             check_expr(fcx, cond);\n             check_block(fcx, body);\n             demand::simple(fcx, cond.span, ty::mk_bool(fcx.ccx.tcx),\n                            expr_ty(fcx.ccx.tcx, cond));\n             auto typ = ty::mk_nil(fcx.ccx.tcx);\n-            write::ty_only_fixup(fcx, a.id, typ);\n+            write::ty_only_fixup(fcx, id, typ);\n         }\n-        case (ast::expr_do_while(?body, ?cond, ?a)) {\n+        case (ast::expr_do_while(?body, ?cond, ?id)) {\n             check_expr(fcx, cond);\n             check_block(fcx, body);\n             auto typ = block_ty(fcx.ccx.tcx, body);\n-            write::ty_only_fixup(fcx, a.id, typ);\n+            write::ty_only_fixup(fcx, id, typ);\n         }\n-        case (ast::expr_alt(?expr, ?arms, ?a)) {\n+        case (ast::expr_alt(?expr, ?arms, ?id)) {\n             check_expr(fcx, expr);\n             // Typecheck the patterns first, so that we get types for all the\n             // bindings.\n@@ -1766,33 +1771,33 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         demand::simple(fcx, arm.block.span, result_ty, bty);\n                 }\n             }\n-            write::ty_only_fixup(fcx, a.id, result_ty);\n+            write::ty_only_fixup(fcx, id, result_ty);\n         }\n-        case (ast::expr_fn(?f, ?a)) {\n+        case (ast::expr_fn(?f, ?id)) {\n             auto cx = @rec(tcx=fcx.ccx.tcx);\n             auto convert =\n                 bind ast_ty_to_ty(cx.tcx, bind collect::getter(cx, _), _);\n             auto ty_of_arg = bind collect::ty_of_arg(cx, _);\n             auto fty =\n                 collect::ty_of_fn_decl(cx, convert, ty_of_arg, f.decl,\n                                        f.proto, [], none)._1;\n-            write::ty_only_fixup(fcx, a.id, fty);\n-            check_fn(fcx.ccx, f.decl, f.proto, f.body, a);\n+            write::ty_only_fixup(fcx, id, fty);\n+            check_fn(fcx.ccx, f.decl, f.proto, f.body, id);\n         }\n-        case (ast::expr_block(?b, ?a)) {\n+        case (ast::expr_block(?b, ?id)) {\n             check_block(fcx, b);\n             alt (b.node.expr) {\n                 case (some(?expr)) {\n                     auto typ = expr_ty(fcx.ccx.tcx, expr);\n-                    write::ty_only_fixup(fcx, a.id, typ);\n+                    write::ty_only_fixup(fcx, id, typ);\n                 }\n                 case (none) {\n                     auto typ = ty::mk_nil(fcx.ccx.tcx);\n-                    write::ty_only_fixup(fcx, a.id, typ);\n+                    write::ty_only_fixup(fcx, id, typ);\n                 }\n             }\n         }\n-        case (ast::expr_bind(?f, ?args, ?a)) {\n+        case (ast::expr_bind(?f, ?args, ?id)) {\n             // Call the generic checker.\n \n             check_call_or_bind(fcx, expr.span, f, args);\n@@ -1831,9 +1836,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     fail;\n                 }\n             }\n-            write::ty_only_fixup(fcx, a.id, t_1);\n+            write::ty_only_fixup(fcx, id, t_1);\n         }\n-        case (ast::expr_call(?f, ?args, ?a)) {\n+        case (ast::expr_call(?f, ?args, ?id)) {\n             /* here we're kind of hosed, as f can be any expr\n              need to restrict it to being an explicit expr_path if we're\n             inside a pure function, and need an environment mapping from\n@@ -1853,9 +1858,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     fail;\n                 }\n             }\n-            write::ty_only_fixup(fcx, a.id, rt_1);\n+            write::ty_only_fixup(fcx, id, rt_1);\n         }\n-        case (ast::expr_self_method(?id, ?a)) {\n+        case (ast::expr_self_method(?ident, ?id)) {\n             auto t = ty::mk_nil(fcx.ccx.tcx);\n             let ty::t this_obj_ty;\n             let option::t[obj_info] this_obj_info = get_obj_info(fcx.ccx);\n@@ -1869,7 +1874,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n                     this_obj_ty =\n                         ty::lookup_item_type(fcx.ccx.tcx,\n-                                             obj_info.this_obj)._1;\n+                                             local_def(obj_info.this_obj))._1;\n                 }\n                 case (none) { fail; }\n             }\n@@ -1878,27 +1883,27 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             alt (structure_of(fcx, expr.span, this_obj_ty)) {\n                 case (ty::ty_obj(?methods)) {\n                     for (ty::method method in methods) {\n-                        if (method.ident == id) {\n+                        if (method.ident == ident) {\n                             t = ty::method_ty_to_fn_ty(fcx.ccx.tcx, method);\n                         }\n                     }\n                 }\n                 case (_) { fail; }\n             }\n-            write::ty_only_fixup(fcx, a.id, t);\n+            write::ty_only_fixup(fcx, id, t);\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n         }\n-        case (ast::expr_spawn(_, _, ?f, ?args, ?a)) {\n+        case (ast::expr_spawn(_, _, ?f, ?args, ?id)) {\n             check_call(fcx, expr.span, f, args);\n             auto fty = expr_ty(fcx.ccx.tcx, f);\n             auto ret_ty = ty::ret_ty_of_fn_ty(fcx.ccx.tcx, fty);\n             demand::simple(fcx, f.span, ty::mk_nil(fcx.ccx.tcx), ret_ty);\n             // FIXME: Other typechecks needed\n \n             auto typ = ty::mk_task(fcx.ccx.tcx);\n-            write::ty_only_fixup(fcx, a.id, typ);\n+            write::ty_only_fixup(fcx, id, typ);\n         }\n-        case (ast::expr_cast(?e, ?t, ?a)) {\n+        case (ast::expr_cast(?e, ?t, ?id)) {\n             check_expr(fcx, e);\n             auto t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n             // FIXME: there are more forms of cast to support, eventually.\n@@ -1912,9 +1917,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                                                 e)) + \" as \" +\n                                               ty_to_str(fcx.ccx.tcx, t_1));\n             }\n-            write::ty_only_fixup(fcx, a.id, t_1);\n+            write::ty_only_fixup(fcx, id, t_1);\n         }\n-        case (ast::expr_vec(?args, ?mut, ?kind, ?a)) {\n+        case (ast::expr_vec(?args, ?mut, ?kind, ?id)) {\n             let ty::t t;\n             if (vec::len[@ast::expr](args) == 0u) {\n                 t = next_ty_var(fcx);\n@@ -1936,19 +1941,19 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     typ = ty::mk_ivec(fcx.ccx.tcx, rec(ty=t, mut=mut));\n                 }\n             }\n-            write::ty_only_fixup(fcx, a.id, typ);\n+            write::ty_only_fixup(fcx, id, typ);\n         }\n-        case (ast::expr_tup(?elts, ?a)) {\n+        case (ast::expr_tup(?elts, ?id)) {\n             let vec[ty::mt] elts_mt = [];\n             for (ast::elt e in elts) {\n                 check_expr(fcx, e.expr);\n                 auto ety = expr_ty(fcx.ccx.tcx, e.expr);\n                 elts_mt += [rec(ty=ety, mut=e.mut)];\n             }\n             auto typ = ty::mk_tup(fcx.ccx.tcx, elts_mt);\n-            write::ty_only_fixup(fcx, a.id, typ);\n+            write::ty_only_fixup(fcx, id, typ);\n         }\n-        case (ast::expr_rec(?fields, ?base, ?a)) {\n+        case (ast::expr_rec(?fields, ?base, ?id)) {\n             alt (base) {\n                 case (none) {/* no-op */ }\n                 case (some(?b_0)) { check_expr(fcx, b_0); }\n@@ -1964,7 +1969,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             alt (base) {\n                 case (none) {\n                     auto typ = ty::mk_rec(fcx.ccx.tcx, fields_t);\n-                    write::ty_only_fixup(fcx, a.id, typ);\n+                    write::ty_only_fixup(fcx, id, typ);\n                 }\n                 case (some(?bexpr)) {\n                     check_expr(fcx, bexpr);\n@@ -1978,7 +1983,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                                        non-record base\");\n                         }\n                     }\n-                    write::ty_only_fixup(fcx, a.id, bexpr_t);\n+                    write::ty_only_fixup(fcx, id, bexpr_t);\n                     for (ty::field f in fields_t) {\n                         auto found = false;\n                         for (ty::field bf in base_fields) {\n@@ -1998,7 +2003,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n         }\n-        case (ast::expr_field(?base, ?field, ?a)) {\n+        case (ast::expr_field(?base, ?field, ?id)) {\n             check_expr(fcx, base);\n             auto base_t = expr_ty(fcx.ccx.tcx, base);\n             base_t = strip_boxes(fcx, expr.span, base_t);\n@@ -2010,7 +2015,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                                   \"bad index on tuple\");\n                     }\n-                    write::ty_only_fixup(fcx, a.id, args.(ix).ty);\n+                    write::ty_only_fixup(fcx, id, args.(ix).ty);\n                 }\n                 case (ty::ty_rec(?fields)) {\n                     let uint ix =\n@@ -2020,7 +2025,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                                   \"bad index on record\");\n                     }\n-                    write::ty_only_fixup(fcx, a.id, fields.(ix).mt.ty);\n+                    write::ty_only_fixup(fcx, id, fields.(ix).mt.ty);\n                 }\n                 case (ty::ty_obj(?methods)) {\n                     let uint ix =\n@@ -2034,7 +2039,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     auto t =\n                         ty::mk_fn(fcx.ccx.tcx, meth.proto, meth.inputs,\n                                   meth.output, meth.cf, meth.constrs);\n-                    write::ty_only_fixup(fcx, a.id, t);\n+                    write::ty_only_fixup(fcx, id, t);\n                 }\n                 case (_) {\n                     fcx.ccx.tcx.sess.span_unimpl(expr.span,\n@@ -2045,7 +2050,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n         }\n-        case (ast::expr_index(?base, ?idx, ?a)) {\n+        case (ast::expr_index(?base, ?idx, ?id)) {\n             check_expr(fcx, base);\n             auto base_t = expr_ty(fcx.ccx.tcx, base);\n             base_t = strip_boxes(fcx, expr.span, base_t);\n@@ -2059,18 +2064,18 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n             alt (structure_of(fcx, expr.span, base_t)) {\n                 case (ty::ty_vec(?mt)) {\n-                    write::ty_only_fixup(fcx, a.id, mt.ty);\n+                    write::ty_only_fixup(fcx, id, mt.ty);\n                 }\n                 case (ty::ty_ivec(?mt)) {\n-                    write::ty_only_fixup(fcx, a.id, mt.ty);\n+                    write::ty_only_fixup(fcx, id, mt.ty);\n                 }\n                 case (ty::ty_str) {\n                     auto typ = ty::mk_mach(fcx.ccx.tcx, common::ty_u8);\n-                    write::ty_only_fixup(fcx, a.id, typ);\n+                    write::ty_only_fixup(fcx, id, typ);\n                 }\n                 case (ty::ty_istr) {\n                     auto typ = ty::mk_mach(fcx.ccx.tcx, common::ty_u8);\n-                    write::ty_only_fixup(fcx, a.id, typ);\n+                    write::ty_only_fixup(fcx, id, typ);\n                 }\n                 case (_) {\n                     fcx.ccx.tcx.sess.span_fatal(expr.span,\n@@ -2080,18 +2085,18 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n         }\n-        case (ast::expr_port(?a)) {\n+        case (ast::expr_port(?id)) {\n             auto t = next_ty_var(fcx);\n             auto pt = ty::mk_port(fcx.ccx.tcx, t);\n-            write::ty_only_fixup(fcx, a.id, pt);\n+            write::ty_only_fixup(fcx, id, pt);\n         }\n-        case (ast::expr_chan(?x, ?a)) {\n+        case (ast::expr_chan(?x, ?id)) {\n             check_expr(fcx, x);\n             auto port_t = expr_ty(fcx.ccx.tcx, x);\n             alt (structure_of(fcx, expr.span, port_t)) {\n                 case (ty::ty_port(?subtype)) {\n                     auto ct = ty::mk_chan(fcx.ccx.tcx, subtype);\n-                    write::ty_only_fixup(fcx, a.id, ct);\n+                    write::ty_only_fixup(fcx, id, ct);\n                 }\n                 case (_) {\n                     fcx.ccx.tcx.sess.span_fatal(expr.span,\n@@ -2101,7 +2106,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n         }\n-        case (ast::expr_anon_obj(?anon_obj, ?tps, ?obj_def_ids, ?a)) {\n+        case (ast::expr_anon_obj(?anon_obj, ?tps, ?obj_def_ids, ?id)) {\n             // TODO: We probably need to do more work here to be able to\n             // handle additional methods that use 'self'\n \n@@ -2112,7 +2117,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 case (none) { }\n                 case (some(?v)) { fields = v; }\n             }\n-            let ast::def_id di = obj_def_ids.ty;\n+            let ast::node_id di = obj_def_ids.ty;\n             vec::push[obj_info](fcx.ccx.obj_infos,\n                                 rec(obj_fields=fields, this_obj=di));\n             // Typecheck 'with_obj', if it exists.\n@@ -2158,13 +2163,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n             auto method_types = get_anon_obj_method_types(fcx.ccx, anon_obj);\n             auto ot = ty::mk_obj(fcx.ccx.tcx, ty::sort_methods(method_types));\n-            write::ty_only_fixup(fcx, a.id, ot);\n+            write::ty_only_fixup(fcx, id, ot);\n             // Write the methods into the node type table.  (This happens in\n             // collect::convert for regular objects.)\n \n             auto i = 0u;\n             while (i < vec::len[@ast::method](anon_obj.methods)) {\n-                write::ty_only(fcx.ccx.tcx, anon_obj.methods.(i).node.ann.id,\n+                write::ty_only(fcx.ccx.tcx, anon_obj.methods.(i).node.id,\n                                ty::method_ty_to_fn_ty(fcx.ccx.tcx,\n                                                       method_types.(i)));\n                 i += 1u;\n@@ -2201,7 +2206,7 @@ fn get_obj_info(&@crate_ctxt ccx) -> option::t[obj_info] {\n \n fn ast_constr_to_constr(ty::ctxt tcx, &@ast::constr c)\n     -> @ty::constr_def {\n-    alt (tcx.def_map.find(c.node.ann.id)) {\n+    alt (tcx.def_map.find(c.node.id)) {\n         case (some(ast::def_fn(?pred_id))) {\n             ret @respan(c.span, rec(path=c.node.path, args=c.node.args,\n                                     id=pred_id));\n@@ -2214,10 +2219,10 @@ fn ast_constr_to_constr(ty::ctxt tcx, &@ast::constr c)\n     }\n }\n \n-fn check_decl_initializer(&@fn_ctxt fcx, &ast::def_id lid,\n+fn check_decl_initializer(&@fn_ctxt fcx, ast::node_id nid,\n                           &ast::initializer init) {\n     check_expr(fcx, init.expr);\n-    auto lty = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(lid));\n+    auto lty = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(nid));\n     alt (init.op) {\n         case (ast::init_assign) {\n             demand::simple(fcx, init.expr.span, lty,\n@@ -2236,24 +2241,24 @@ fn check_decl_initializer(&@fn_ctxt fcx, &ast::def_id lid,\n }\n \n fn check_decl_local(&@fn_ctxt fcx, &@ast::local local) -> @ast::local {\n-    auto a_res = local.node.ann;\n-    alt (fcx.locals.find(local.node.id)) {\n+    auto a_id = local.node.id;\n+    alt (fcx.locals.find(a_id)) {\n         case (none) {\n \n             fcx.ccx.tcx.sess.bug(\"check_decl_local: local id not found \" +\n                                      local.node.ident);\n         }\n         case (some(?i)) {\n             auto t = ty::mk_var(fcx.ccx.tcx, i);\n-            write::ty_only_fixup(fcx, a_res.id, t);\n+            write::ty_only_fixup(fcx, a_id, t);\n             auto initopt = local.node.init;\n             alt (initopt) {\n                 case (some(?init)) {\n                     check_decl_initializer(fcx, local.node.id, init);\n                 }\n                 case (_) {/* fall through */ }\n             }\n-            auto newlocal = rec(init=initopt, ann=a_res with local.node);\n+            auto newlocal = rec(init=initopt with local.node);\n             ret @rec(node=newlocal, span=local.span);\n         }\n     }\n@@ -2262,15 +2267,15 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast::local local) -> @ast::local {\n fn check_stmt(&@fn_ctxt fcx, &@ast::stmt stmt) {\n     auto node_id;\n     alt (stmt.node) {\n-        case (ast::stmt_decl(?decl, ?a)) {\n-            node_id = a.id;\n+        case (ast::stmt_decl(?decl, ?id)) {\n+            node_id = id;\n             alt (decl.node) {\n                 case (ast::decl_local(?l)) { check_decl_local(fcx, l); }\n                 case (ast::decl_item(_)) {/* ignore for now */ }\n             }\n         }\n-        case (ast::stmt_expr(?expr, ?a)) {\n-            node_id = a.id;\n+        case (ast::stmt_expr(?expr, ?id)) {\n+            node_id = id;\n             check_expr(fcx, expr);\n         }\n     }\n@@ -2280,37 +2285,37 @@ fn check_stmt(&@fn_ctxt fcx, &@ast::stmt stmt) {\n fn check_block(&@fn_ctxt fcx, &ast::block block) {\n     for (@ast::stmt s in block.node.stmts) { check_stmt(fcx, s); }\n     alt (block.node.expr) {\n-        case (none) { write::nil_ty(fcx.ccx.tcx, block.node.a.id); }\n+        case (none) { write::nil_ty(fcx.ccx.tcx, block.node.id); }\n         case (some(?e)) {\n             check_expr(fcx, e);\n             auto ety = expr_ty(fcx.ccx.tcx, e);\n-            write::ty_only_fixup(fcx, block.node.a.id, ety);\n+            write::ty_only_fixup(fcx, block.node.id, ety);\n         }\n     }\n }\n \n-fn check_const(&@crate_ctxt ccx, &span sp, &@ast::expr e, &ast::ann ann) {\n+fn check_const(&@crate_ctxt ccx, &span sp, &@ast::expr e, &ast::node_id id) {\n     // FIXME: this is kinda a kludge; we manufacture a fake function context\n     // and statement context for checking the initializer expression.\n \n-    auto rty = ann_to_type(ccx.tcx, ann);\n-    let vec[uint] fixups = [];\n+    auto rty = node_id_to_type(ccx.tcx, id);\n+    let vec[ast::node_id] fixups = [];\n     let @fn_ctxt fcx =\n         @rec(ret_ty=rty,\n              purity=ast::pure_fn,\n              var_bindings=ty::unify::mk_var_bindings(),\n-             locals=new_def_hash[int](),\n-             local_names=new_def_hash[ast::ident](),\n+             locals=new_int_hash[int](),\n+             local_names=new_int_hash[ast::ident](),\n              mutable next_var_id=0,\n              mutable fixups=fixups,\n              ccx=ccx);\n     check_expr(fcx, e);\n }\n \n fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,\n-            &ast::block body, &ast::ann ann) {\n-    auto gather_result = gather_locals(ccx, decl, body, ann);\n-    let vec[uint] fixups = [];\n+            &ast::block body, &ast::node_id id) {\n+    auto gather_result = gather_locals(ccx, decl, body, id);\n+    let vec[ast::node_id] fixups = [];\n     let @fn_ctxt fcx =\n         @rec(ret_ty=ast_ty_to_ty_crate(ccx, decl.output),\n              purity=decl.purity,\n@@ -2351,16 +2356,16 @@ fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,\n \n fn check_method(&@crate_ctxt ccx, &@ast::method method) {\n     auto m = method.node.meth;\n-    check_fn(ccx, m.decl, m.proto, m.body, method.node.ann);\n+    check_fn(ccx, m.decl, m.proto, m.body, method.node.id);\n }\n \n fn check_item(@crate_ctxt ccx, &@ast::item it) {\n     alt (it.node) {\n         case (ast::item_const(_, ?e)) {\n-            check_const(ccx, it.span, e, it.ann);\n+            check_const(ccx, it.span, e, it.id);\n         }\n         case (ast::item_fn(?f, _)) {\n-            check_fn(ccx, f.decl, f.proto, f.body, it.ann);\n+            check_fn(ccx, f.decl, f.proto, f.body, it.id);\n         }\n         case (ast::item_obj(?ob, _, _)) {\n             // We're entering an object, so gather up the info we need.\n@@ -2386,7 +2391,7 @@ fn mk_fn_purity_table(&@ast::crate crate) -> @fn_purity_table {\n     fn do_one(@fn_purity_table t, &@ast::item i) {\n         alt (i.node) {\n             case (ast::item_fn(?f, _)) {\n-                t.insert(i.id, f.decl.purity);\n+                t.insert(local_def(i.id), f.decl.purity);\n             }\n             case (_) { }\n         }"}, {"sha": "9487295b9a9f8e3e6f1172349f4fe71596adfbfe", "filename": "src/comp/middle/visit.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fvisit.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -34,7 +34,7 @@ type visitor[E] =\n          fn(&@expr, &E, &vt[E])  visit_expr,\n          fn(&@ty, &E, &vt[E])  visit_ty,\n          fn(&@constr, &E, &vt[E])  visit_constr,\n-         fn(&_fn, &vec[ty_param], &span, &ident, &def_id, &ann, &E, &vt[E])\n+         fn(&_fn, &vec[ty_param], &span, &ident, node_id, &E, &vt[E])\n              visit_fn);\n \n fn default_visitor[E]() -> visitor[E] {\n@@ -51,7 +51,7 @@ fn default_visitor[E]() -> visitor[E] {\n              visit_expr=bind visit_expr[E](_, _, _),\n              visit_ty=bind visit_ty[E](_, _, _),\n              visit_constr=bind visit_constr[E](_, _, _),\n-             visit_fn=bind visit_fn[E](_, _, _, _, _, _, _, _));\n+             visit_fn=bind visit_fn[E](_, _, _, _, _, _, _));\n }\n \n fn visit_crate[E](&crate c, &E e, &vt[E] v) {\n@@ -103,7 +103,7 @@ fn visit_item[E](&@item i, &E e, &vt[E] v) {\n             vt(v).visit_expr(ex, e, v);\n         }\n         case (item_fn(?f, ?tp)) {\n-            vt(v).visit_fn(f, tp, i.span, i.ident, i.id, i.ann, e, v);\n+            vt(v).visit_fn(f, tp, i.span, i.ident, i.id, e, v);\n         }\n         case (item_mod(?m)) { vt(v).visit_mod(m, i.span, e, v); }\n         case (item_native_mod(?nm)) {\n@@ -126,13 +126,13 @@ fn visit_item[E](&@item i, &E e, &vt[E] v) {\n             for (obj_field f in ob.fields) { vt(v).visit_ty(f.ty, e, v); }\n             for (@method m in ob.methods) {\n                 vt(v).visit_fn(m.node.meth, [], m.span, m.node.ident,\n-                               m.node.id, m.node.ann, e, v);\n+                               m.node.id, e, v);\n             }\n             alt (ob.dtor) {\n                 case (none) { }\n                 case (some(?m)) {\n                     vt(v).visit_fn(m.node.meth, [], m.span, m.node.ident,\n-                                   m.node.id, m.node.ann, e, v);\n+                                   m.node.id, e, v);\n                 }\n             }\n         }\n@@ -202,7 +202,7 @@ fn visit_pat[E](&@pat p, &E e, &vt[E] v) {\n \n fn visit_native_item[E](&@native_item ni, &E e, &vt[E] v) {\n     alt (ni.node) {\n-        case (native_item_fn(_, _, ?fd, _, _, _)) { visit_fn_decl(fd, e, v); }\n+        case (native_item_fn(_, _, ?fd, _, _)) { visit_fn_decl(fd, e, v); }\n         case (native_item_ty(_, _)) { }\n     }\n }\n@@ -213,8 +213,8 @@ fn visit_fn_decl[E](&fn_decl fd, &E e, &vt[E] v) {\n     vt(v).visit_ty(fd.output, e, v);\n }\n \n-fn visit_fn[E](&_fn f, &vec[ty_param] tp, &span sp, &ident i, &def_id d,\n-               &ann a, &E e, &vt[E] v) {\n+fn visit_fn[E](&_fn f, &vec[ty_param] tp, &span sp, &ident i,\n+               node_id id, &E e, &vt[E] v) {\n     visit_fn_decl(f.decl, e, v);\n     vt(v).visit_block(f.body, e, v);\n }\n@@ -383,7 +383,7 @@ fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n             }\n             for (@method m in anon_obj.methods) {\n                 vt(v).visit_fn(m.node.meth, [], m.span, m.node.ident,\n-                               m.node.id, m.node.ann, e, v);\n+                               m.node.id, e, v);\n             }\n         }\n     }"}, {"sha": "8f02b25455c1cf778386cab44fc02310223d9119", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -40,10 +40,8 @@ type ast_visitor =\n         fn(&@ast::ty)  visit_ty_pre,\n         fn(&@ast::ty)  visit_ty_post,\n         fn(&@ast::constr)  visit_constr,\n-        fn(&ast::_fn, &span, &ast::ident, &ast::def_id, &ast::ann)\n-            visit_fn_pre,\n-        fn(&ast::_fn, &span, &ast::ident, &ast::def_id, &ast::ann)\n-            visit_fn_post);\n+        fn(&ast::_fn, &span, &ast::ident, ast::node_id) visit_fn_pre,\n+        fn(&ast::_fn, &span, &ast::ident, ast::node_id) visit_fn_post);\n \n fn walk_crate(&ast_visitor v, &ast::crate c) {\n     if (!v.keep_going()) { ret; }\n@@ -104,7 +102,7 @@ fn walk_item(&ast_visitor v, @ast::item i) {\n     alt (i.node) {\n         case (ast::item_const(?t, ?e)) { walk_ty(v, t); walk_expr(v, e); }\n         case (ast::item_fn(?f, _)) {\n-            walk_fn(v, f, i.span, i.ident, i.id, i.ann);\n+            walk_fn(v, f, i.span, i.ident, i.id);\n         }\n         case (ast::item_mod(?m)) { walk_mod(v, m); }\n         case (ast::item_native_mod(?nm)) { walk_native_mod(v, nm); }\n@@ -120,15 +118,13 @@ fn walk_item(&ast_visitor v, @ast::item i) {\n             for (ast::obj_field f in ob.fields) { walk_ty(v, f.ty); }\n             for (@ast::method m in ob.methods) {\n                 v.visit_method_pre(m);\n-                walk_fn(v, m.node.meth, m.span, m.node.ident, m.node.id,\n-                        m.node.ann);\n+                walk_fn(v, m.node.meth, m.span, m.node.ident, m.node.id);\n                 v.visit_method_post(m);\n             }\n             alt (ob.dtor) {\n                 case (none) { }\n                 case (some(?m)) {\n-                    walk_fn(v, m.node.meth, m.span, m.node.ident, m.node.id,\n-                            m.node.ann);\n+                    walk_fn(v, m.node.meth, m.span, m.node.ident, m.node.id);\n                 }\n             }\n         }\n@@ -207,7 +203,7 @@ fn walk_native_item(&ast_visitor v, @ast::native_item ni) {\n     if (!v.keep_going()) { ret; }\n     v.visit_native_item_pre(ni);\n     alt (ni.node) {\n-        case (ast::native_item_fn(_, _, ?fd, _, _, _)) {\n+        case (ast::native_item_fn(_, _, ?fd, _, _)) {\n             walk_fn_decl(v, fd);\n         }\n         case (ast::native_item_ty(_, _)) { }\n@@ -222,12 +218,12 @@ fn walk_fn_decl(&ast_visitor v, &ast::fn_decl fd) {\n }\n \n fn walk_fn(&ast_visitor v, &ast::_fn f, &span sp, &ast::ident i,\n-           &ast::def_id d, &ast::ann a) {\n+           ast::node_id d) {\n     if (!v.keep_going()) { ret; }\n-    v.visit_fn_pre(f, sp, i, d, a);\n+    v.visit_fn_pre(f, sp, i, d);\n     walk_fn_decl(v, f.decl);\n     walk_block(v, f.body);\n-    v.visit_fn_post(f, sp, i, d, a);\n+    v.visit_fn_post(f, sp, i, d);\n }\n \n fn walk_block(&ast_visitor v, &ast::block b) {\n@@ -402,8 +398,7 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n             // Methods\n             for (@ast::method m in anon_obj.methods) {\n                 v.visit_method_pre(m);\n-                walk_fn(v, m.node.meth, m.span, m.node.ident, m.node.id,\n-                        m.node.ann);\n+                walk_fn(v, m.node.meth, m.span, m.node.ident, m.node.id);\n                 v.visit_method_post(m);\n             }\n         }\n@@ -445,9 +440,7 @@ fn def_visit_ty(&@ast::ty t) { }\n \n fn def_visit_constr(&@ast::constr c) { }\n \n-fn def_visit_fn(&ast::_fn f, &span sp, &ast::ident i, &ast::def_id d,\n-                &ast::ann a) {\n-}\n+fn def_visit_fn(&ast::_fn f, &span sp, &ast::ident i, ast::node_id d) { }\n \n fn default_visitor() -> ast_visitor {\n     ret rec(keep_going=def_keep_going,"}, {"sha": "8886d9de4cd5eec9451560b679df9b4f1240dc27", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75681f9ad7a6b79c5a34fd80c95c22258e30ddb5/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=75681f9ad7a6b79c5a34fd80c95c22258e30ddb5", "patch": "@@ -1,5 +1,6 @@\n \n import std::uint;\n+import std::int;\n import std::vec;\n import std::str;\n import std::io;\n@@ -323,8 +324,8 @@ fn print_item(&ps s, &@ast::item item) {\n                         word_nbsp(s, \"type\");\n                         word(s.s, id);\n                     }\n-                    case (ast::native_item_fn(?id, ?lname, ?decl, ?typarams,\n-                                              _, _)) {\n+                    case (ast::native_item_fn(?id, ?lname, ?decl,\n+                                              ?typarams, _)) {\n                         print_fn(s, decl, ast::proto_fn, id, typarams);\n                         alt (lname) {\n                             case (none) { }\n@@ -426,7 +427,7 @@ fn print_item(&ps s, &@ast::item item) {\n     alt (s.mode) {\n         case (mo_identified) {\n             space(s.s);\n-            synth_comment(s, uint::to_str(item.ann.id, 10u));\n+            synth_comment(s, int::to_str(item.id, 10u));\n         }\n         case (_) {/* no-op */ }\n     }\n@@ -497,7 +498,7 @@ fn print_block(&ps s, ast::block blk) {\n     alt (s.mode) {\n         case (mo_identified) {\n             space(s.s);\n-            synth_comment(s, \"block \" + uint::to_str(blk.node.a.id, 10u));\n+            synth_comment(s, \"block \" + int::to_str(blk.node.id, 10u));\n         }\n         case (_) {/* no-op */ }\n     }\n@@ -865,7 +866,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n         }\n         case (mo_identified) {\n             space(s.s);\n-            synth_comment(s, uint::to_str(ty::expr_ann(expr).id, 10u));\n+            synth_comment(s, int::to_str(ty::expr_node_id(expr), 10u));\n             pclose(s);\n         }\n     }\n@@ -891,7 +892,7 @@ fn print_decl(&ps s, &@ast::decl decl) {\n                     alt (s.mode) {\n                         case (mo_untyped) {/* no-op */ }\n                         case (mo_typed(?tcx)) {\n-                            auto lty = ty::ann_to_type(tcx, loc.node.ann);\n+                            auto lty = ty::node_id_to_type(tcx, loc.node.id);\n                             word_space(s, ppaux::ty_to_str(tcx, lty));\n                         }\n                         case (mo_identified) {/* no-op */ }\n@@ -943,7 +944,7 @@ fn print_pat(&ps s, &@ast::pat pat) {\n     maybe_print_comment(s, pat.span.lo);\n     alt (pat.node) {\n         case (ast::pat_wild(_)) { word(s.s, \"_\"); }\n-        case (ast::pat_bind(?id, _, _)) { word(s.s, \"?\" + id); }\n+        case (ast::pat_bind(?id, _)) { word(s.s, \"?\" + id); }\n         case (ast::pat_lit(?lit, _)) { print_literal(s, lit); }\n         case (ast::pat_tag(?path, ?args, _)) {\n             print_path(s, path);\n@@ -959,7 +960,7 @@ fn print_pat(&ps s, &@ast::pat pat) {\n     alt (s.mode) {\n         case (mo_identified) {\n             space(s.s);\n-            synth_comment(s, uint::to_str(ty::pat_ann(pat).id, 10u));\n+            synth_comment(s, int::to_str(ty::pat_node_id(pat), 10u));\n         }\n         case (_) {/* no-op */ }\n     }\n@@ -1029,7 +1030,7 @@ fn print_view_item(&ps s, &@ast::view_item item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     alt (item.node) {\n-        case (ast::view_item_use(?id, ?mta, _, _)) {\n+        case (ast::view_item_use(?id, ?mta, _)) {\n             head(s, \"use\");\n             word(s.s, id);\n             if (vec::len(mta) > 0u) {\n@@ -1059,7 +1060,7 @@ fn print_view_item(&ps s, &@ast::view_item item) {\n             }\n             word(s.s, \"::*\");\n         }\n-        case (ast::view_item_export(?id)) {\n+        case (ast::view_item_export(?id, _)) {\n             head(s, \"export\");\n             word(s.s, id);\n         }"}]}