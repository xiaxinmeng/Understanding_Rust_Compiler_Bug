{"sha": "c2e7743da8ba6062c89b700957fda01f54732c30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyZTc3NDNkYThiYTYwNjJjODliNzAwOTU3ZmRhMDFmNTQ3MzJjMzA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-09-11T14:52:39Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-31T18:25:55Z"}, "message": "rustc_codegen_ssa: move debuginfo scopes into FunctionDebugContext.", "tree": {"sha": "7814c7a468c3a6b5dabd84b930fb85b7ca538ff6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7814c7a468c3a6b5dabd84b930fb85b7ca538ff6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2e7743da8ba6062c89b700957fda01f54732c30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2e7743da8ba6062c89b700957fda01f54732c30", "html_url": "https://github.com/rust-lang/rust/commit/c2e7743da8ba6062c89b700957fda01f54732c30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2e7743da8ba6062c89b700957fda01f54732c30/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06869b8d17d06818d8e2ac36834ba21827443985", "url": "https://api.github.com/repos/rust-lang/rust/commits/06869b8d17d06818d8e2ac36834ba21827443985", "html_url": "https://github.com/rust-lang/rust/commit/06869b8d17d06818d8e2ac36834ba21827443985"}], "stats": {"total": 242, "additions": 88, "deletions": 154}, "files": [{"sha": "6ee76b71fced68f3855833f6f6b352f058d3daa5", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 21, "deletions": 37, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c2e7743da8ba6062c89b700957fda01f54732c30/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e7743da8ba6062c89b700957fda01f54732c30/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=c2e7743da8ba6062c89b700957fda01f54732c30", "patch": "@@ -1,4 +1,4 @@\n-use rustc_codegen_ssa::mir::debuginfo::{FunctionDebugContext, FunctionDebugContextData, DebugScope};\n+use rustc_codegen_ssa::mir::debuginfo::{FunctionDebugContext, DebugScope};\n use super::metadata::file_metadata;\n use super::utils::{DIB, span_start};\n \n@@ -12,34 +12,20 @@ use libc::c_uint;\n use syntax_pos::Pos;\n \n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::{Idx, IndexVec};\n-\n-use syntax_pos::BytePos;\n+use rustc_index::vec::Idx;\n \n /// Produces DIScope DIEs for each MIR Scope which has variables defined in it.\n-/// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(\n+pub fn compute_mir_scopes(\n     cx: &CodegenCx<'ll, '_>,\n     mir: &Body<'_>,\n-    debug_context: &FunctionDebugContext<&'ll DISubprogram>,\n-) -> IndexVec<SourceScope, DebugScope<&'ll DIScope>> {\n-    let null_scope = DebugScope {\n-        scope_metadata: None,\n-        file_start_pos: BytePos(0),\n-        file_end_pos: BytePos(0)\n-    };\n-    let mut scopes = IndexVec::from_elem(null_scope, &mir.source_scopes);\n-\n-    let debug_context = match *debug_context {\n-        FunctionDebugContext::RegularContext(ref data) => data,\n-        FunctionDebugContext::DebugInfoDisabled |\n-        FunctionDebugContext::FunctionWithoutDebugInfo => {\n-            return scopes;\n-        }\n-    };\n-\n+    fn_metadata: &'ll DISubprogram,\n+    debug_context: &mut FunctionDebugContext<&'ll DIScope>,\n+) {\n     // Find all the scopes with variables defined in them.\n     let mut has_variables = BitSet::new_empty(mir.source_scopes.len());\n+    // FIXME(eddyb) base this on `decl.name`, or even better, on debuginfo.\n+    // FIXME(eddyb) take into account that arguments always have debuginfo,\n+    // irrespective of their name (assuming full debuginfo is enabled).\n     for var in mir.vars_iter() {\n         let decl = &mir.local_decls[var];\n         has_variables.insert(decl.visibility_scope);\n@@ -48,31 +34,29 @@ pub fn create_mir_scopes(\n     // Instantiate all scopes.\n     for idx in 0..mir.source_scopes.len() {\n         let scope = SourceScope::new(idx);\n-        make_mir_scope(cx, &mir, &has_variables, debug_context, scope, &mut scopes);\n+        make_mir_scope(cx, &mir, fn_metadata, &has_variables, debug_context, scope);\n     }\n-\n-    scopes\n }\n \n fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n                   mir: &Body<'_>,\n+                  fn_metadata: &'ll DISubprogram,\n                   has_variables: &BitSet<SourceScope>,\n-                  debug_context: &FunctionDebugContextData<&'ll DISubprogram>,\n-                  scope: SourceScope,\n-                  scopes: &mut IndexVec<SourceScope, DebugScope<&'ll DIScope>>) {\n-    if scopes[scope].is_valid() {\n+                  debug_context: &mut FunctionDebugContext<&'ll DISubprogram>,\n+                  scope: SourceScope) {\n+    if debug_context.scopes[scope].is_valid() {\n         return;\n     }\n \n     let scope_data = &mir.source_scopes[scope];\n     let parent_scope = if let Some(parent) = scope_data.parent_scope {\n-        make_mir_scope(cx, mir, has_variables, debug_context, parent, scopes);\n-        scopes[parent]\n+        make_mir_scope(cx, mir, fn_metadata, has_variables, debug_context, parent);\n+        debug_context.scopes[parent]\n     } else {\n         // The root is the function itself.\n         let loc = span_start(cx, mir.span);\n-        scopes[scope] = DebugScope {\n-            scope_metadata: Some(debug_context.fn_metadata),\n+        debug_context.scopes[scope] = DebugScope {\n+            scope_metadata: Some(fn_metadata),\n             file_start_pos: loc.file.start_pos,\n             file_end_pos: loc.file.end_pos,\n         };\n@@ -86,8 +70,8 @@ fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n         // However, we don't skip creating a nested scope if\n         // our parent is the root, because we might want to\n         // put arguments in the root and not have shadowing.\n-        if parent_scope.scope_metadata.unwrap() != debug_context.fn_metadata {\n-            scopes[scope] = parent_scope;\n+        if parent_scope.scope_metadata.unwrap() != fn_metadata {\n+            debug_context.scopes[scope] = parent_scope;\n             return;\n         }\n     }\n@@ -105,7 +89,7 @@ fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n             loc.line as c_uint,\n             loc.col.to_usize() as c_uint))\n     };\n-    scopes[scope] = DebugScope {\n+    debug_context.scopes[scope] = DebugScope {\n         scope_metadata,\n         file_start_pos: loc.file.start_pos,\n         file_end_pos: loc.file.end_pos,"}, {"sha": "01563a3eed3a87103466cdf7aef920feb0d41d95", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c2e7743da8ba6062c89b700957fda01f54732c30/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e7743da8ba6062c89b700957fda01f54732c30/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=c2e7743da8ba6062c89b700957fda01f54732c30", "patch": "@@ -11,7 +11,7 @@ use self::metadata::{type_metadata, file_metadata, TypeMap};\n use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n \n use crate::llvm;\n-use crate::llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilder, DISubprogram, DIArray, DIFlags,\n+use crate::llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilder, DIArray, DIFlags,\n     DISPFlags, DILexicalBlock};\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n@@ -29,13 +29,13 @@ use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_index::vec::IndexVec;\n use rustc_codegen_ssa::debuginfo::type_names;\n use rustc_codegen_ssa::mir::debuginfo::{FunctionDebugContext, DebugScope, VariableAccess,\n-    VariableKind, FunctionDebugContextData};\n+    VariableKind};\n \n use libc::c_uint;\n use std::cell::RefCell;\n use std::ffi::{CStr, CString};\n \n-use syntax_pos::{self, Span, Pos};\n+use syntax_pos::{self, BytePos, Span, Pos};\n use syntax::ast;\n use syntax::symbol::Symbol;\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n@@ -48,7 +48,7 @@ pub mod metadata;\n mod create_scope_map;\n mod source_loc;\n \n-pub use self::create_scope_map::{create_mir_scopes};\n+pub use self::create_scope_map::compute_mir_scopes;\n pub use self::metadata::create_global_var_metadata;\n pub use self::metadata::extend_scope_to_file;\n pub use self::source_loc::set_source_location;\n@@ -149,21 +149,21 @@ pub fn finalize(cx: &CodegenCx<'_, '_>) {\n impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn declare_local(\n         &mut self,\n-        dbg_context: &FunctionDebugContext<&'ll DISubprogram>,\n+        dbg_context: &FunctionDebugContext<&'ll DIScope>,\n         variable_name: ast::Name,\n         variable_type: Ty<'tcx>,\n         scope_metadata: &'ll DIScope,\n         variable_access: VariableAccess<'_, &'ll Value>,\n         variable_kind: VariableKind,\n         span: Span,\n     ) {\n-        assert!(!dbg_context.get_ref(span).source_locations_enabled);\n+        assert!(!dbg_context.source_locations_enabled);\n         let cx = self.cx();\n \n         let file = span_start(cx, span).file;\n         let file_metadata = file_metadata(cx,\n                                           &file.name,\n-                                          dbg_context.get_ref(span).defining_crate);\n+                                          dbg_context.defining_crate);\n \n         let loc = span_start(cx, span);\n         let type_metadata = type_metadata(cx, variable_type, span);\n@@ -215,8 +215,8 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn set_source_location(\n         &mut self,\n-        debug_context: &mut FunctionDebugContext<&'ll DISubprogram>,\n-        scope: Option<&'ll DIScope>,\n+        debug_context: &mut FunctionDebugContext<&'ll DIScope>,\n+        scope: &'ll DIScope,\n         span: Span,\n     ) {\n         set_source_location(debug_context, &self, scope, span)\n@@ -269,14 +269,14 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         sig: ty::FnSig<'tcx>,\n         llfn: &'ll Value,\n         mir: &mir::Body<'_>,\n-    ) -> FunctionDebugContext<&'ll DISubprogram> {\n+    ) -> Option<FunctionDebugContext<&'ll DIScope>> {\n         if self.sess().opts.debuginfo == DebugInfo::None {\n-            return FunctionDebugContext::DebugInfoDisabled;\n+            return None;\n         }\n \n         if let InstanceDef::Item(def_id) = instance.def {\n             if self.tcx().codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::NO_DEBUG) {\n-                return FunctionDebugContext::FunctionWithoutDebugInfo;\n+                return None;\n             }\n         }\n \n@@ -285,7 +285,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         // This can be the case for functions inlined from another crate\n         if span.is_dummy() {\n             // FIXME(simulacrum): Probably can't happen; remove.\n-            return FunctionDebugContext::FunctionWithoutDebugInfo;\n+            return None;\n         }\n \n         let def_id = instance.def_id();\n@@ -358,14 +358,23 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 None)\n         };\n \n-        // Initialize fn debug context (including scope map and namespace map)\n-        let fn_debug_context = FunctionDebugContextData {\n-            fn_metadata,\n+        // Initialize fn debug context (including scopes).\n+        // FIXME(eddyb) figure out a way to not need `Option` for `scope_metadata`.\n+        let null_scope = DebugScope {\n+            scope_metadata: None,\n+            file_start_pos: BytePos(0),\n+            file_end_pos: BytePos(0)\n+        };\n+        let mut fn_debug_context = FunctionDebugContext {\n+            scopes: IndexVec::from_elem(null_scope, &mir.source_scopes),\n             source_locations_enabled: false,\n             defining_crate: def_id.krate,\n         };\n \n-        return FunctionDebugContext::RegularContext(fn_debug_context);\n+        // Fill in all the scopes, with the information from the MIR body.\n+        compute_mir_scopes(self, mir, fn_metadata, &mut fn_debug_context);\n+\n+        return Some(fn_debug_context);\n \n         fn get_function_signature<'ll, 'tcx>(\n             cx: &CodegenCx<'ll, 'tcx>,\n@@ -550,14 +559,6 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         metadata::create_vtable_metadata(self, ty, vtable)\n     }\n \n-    fn create_mir_scopes(\n-        &self,\n-        mir: &mir::Body<'_>,\n-        debug_context: &mut FunctionDebugContext<&'ll DISubprogram>,\n-    ) -> IndexVec<mir::SourceScope, DebugScope<&'ll DIScope>> {\n-        create_scope_map::create_mir_scopes(self, mir, debug_context)\n-    }\n-\n     fn extend_scope_to_file(\n          &self,\n          scope_metadata: &'ll DIScope,"}, {"sha": "ccb3bde1cbe4e3bd4da90b36fdd942d840dac746", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c2e7743da8ba6062c89b700957fda01f54732c30/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e7743da8ba6062c89b700957fda01f54732c30/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=c2e7743da8ba6062c89b700957fda01f54732c30", "patch": "@@ -18,22 +18,13 @@ use syntax_pos::{Span, Pos};\n pub fn set_source_location<D>(\n     debug_context: &FunctionDebugContext<D>,\n     bx: &Builder<'_, 'll, '_>,\n-    scope: Option<&'ll DIScope>,\n+    scope: &'ll DIScope,\n     span: Span,\n ) {\n-    let function_debug_context = match *debug_context {\n-        FunctionDebugContext::DebugInfoDisabled => return,\n-        FunctionDebugContext::FunctionWithoutDebugInfo => {\n-            set_debug_location(bx, UnknownLocation);\n-            return;\n-        }\n-        FunctionDebugContext::RegularContext(ref data) => data\n-    };\n-\n-    let dbg_loc = if function_debug_context.source_locations_enabled {\n+    let dbg_loc = if debug_context.source_locations_enabled {\n         debug!(\"set_source_location: {}\", bx.sess().source_map().span_to_string(span));\n         let loc = span_start(bx.cx(), span);\n-        InternalDebugLocation::new(scope.unwrap(), loc.line, loc.col.to_usize())\n+        InternalDebugLocation::new(scope, loc.line, loc.col.to_usize())\n     } else {\n         UnknownLocation\n     };"}, {"sha": "f6c7a378811393c099ccf58cc1a4c85071a88f71", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 27, "deletions": 60, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c2e7743da8ba6062c89b700957fda01f54732c30/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e7743da8ba6062c89b700957fda01f54732c30/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=c2e7743da8ba6062c89b700957fda01f54732c30", "patch": "@@ -1,4 +1,4 @@\n-use rustc_index::vec::Idx;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc::hir::def_id::CrateNum;\n use rustc::mir;\n use rustc::session::config::DebugInfo;\n@@ -13,51 +13,8 @@ use syntax::symbol::kw;\n use super::{FunctionCx, LocalRef};\n use super::OperandValue;\n \n-pub enum FunctionDebugContext<D> {\n-    RegularContext(FunctionDebugContextData<D>),\n-    DebugInfoDisabled,\n-    FunctionWithoutDebugInfo,\n-}\n-\n-impl<D> FunctionDebugContext<D> {\n-    pub fn get_ref(&self, span: Span) -> &FunctionDebugContextData<D> {\n-        match *self {\n-            FunctionDebugContext::RegularContext(ref data) => data,\n-            FunctionDebugContext::DebugInfoDisabled => {\n-                span_bug!(\n-                    span,\n-                    \"debuginfo: Error trying to access FunctionDebugContext \\\n-                     although debug info is disabled!\",\n-                );\n-            }\n-            FunctionDebugContext::FunctionWithoutDebugInfo => {\n-                span_bug!(\n-                    span,\n-                    \"debuginfo: Error trying to access FunctionDebugContext \\\n-                     for function that should be ignored by debug info!\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-/// Enables emitting source locations for the given functions.\n-///\n-/// Since we don't want source locations to be emitted for the function prelude,\n-/// they are disabled when beginning to codegen a new function. This functions\n-/// switches source location emitting on and must therefore be called before the\n-/// first real statement/expression of the function is codegened.\n-pub fn start_emitting_source_locations<D>(dbg_context: &mut FunctionDebugContext<D>) {\n-    match *dbg_context {\n-        FunctionDebugContext::RegularContext(ref mut data) => {\n-            data.source_locations_enabled = true;\n-        },\n-        _ => { /* safe to ignore */ }\n-    }\n-}\n-\n-pub struct FunctionDebugContextData<D> {\n-    pub fn_metadata: D,\n+pub struct FunctionDebugContext<D> {\n+    pub scopes: IndexVec<mir::SourceScope, DebugScope<D>>,\n     pub source_locations_enabled: bool,\n     pub defining_crate: CrateNum,\n }\n@@ -75,7 +32,6 @@ pub enum VariableKind {\n     LocalVariable,\n }\n \n-\n #[derive(Clone, Copy, Debug)]\n pub struct DebugScope<D> {\n     pub scope_metadata: Option<D>,\n@@ -98,17 +54,17 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         source_info: mir::SourceInfo\n     ) {\n         let (scope, span) = self.debug_loc(source_info);\n-        bx.set_source_location(&mut self.debug_context, scope, span);\n+        if let Some(debug_context) = &mut self.debug_context {\n+            // FIXME(eddyb) get rid of this unwrap somehow.\n+            bx.set_source_location(debug_context, scope.unwrap(), span);\n+        }\n     }\n \n     pub fn debug_loc(&self, source_info: mir::SourceInfo) -> (Option<Bx::DIScope>, Span) {\n         // Bail out if debug info emission is not enabled.\n         match self.debug_context {\n-            FunctionDebugContext::DebugInfoDisabled |\n-            FunctionDebugContext::FunctionWithoutDebugInfo => {\n-                return (self.scopes[source_info.scope].scope_metadata, source_info.span);\n-            }\n-            FunctionDebugContext::RegularContext(_) =>{}\n+            None => return (None, source_info.span),\n+            Some(_) => {}\n         }\n \n         // In order to have a good line stepping behavior in debugger, we overwrite debug\n@@ -135,11 +91,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     // \"extension\" into that file.\n     fn scope_metadata_for_loc(&self, scope_id: mir::SourceScope, pos: BytePos)\n                               -> Option<Bx::DIScope> {\n-        let scope_metadata = self.scopes[scope_id].scope_metadata;\n-        if pos < self.scopes[scope_id].file_start_pos ||\n-           pos >= self.scopes[scope_id].file_end_pos {\n+        let debug_context = self.debug_context.as_ref()?;\n+        let scope_metadata = debug_context.scopes[scope_id].scope_metadata;\n+        if pos < debug_context.scopes[scope_id].file_start_pos ||\n+           pos >= debug_context.scopes[scope_id].file_end_pos {\n             let sm = self.cx.sess().source_map();\n-            let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n+            let defining_crate = debug_context.defining_crate;\n             Some(self.cx.extend_scope_to_file(\n                 scope_metadata.unwrap(),\n                 &sm.lookup_char_pos(pos).file,\n@@ -214,6 +171,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 return;\n             }\n \n+            let debug_context = match &self.debug_context {\n+                Some(debug_context) => debug_context,\n+                None => return,\n+            };\n+\n             // FIXME(eddyb) add debuginfo for unsized places too.\n             let place = match local_ref {\n                 LocalRef::Place(place) => place,\n@@ -225,7 +187,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 scope: decl.visibility_scope,\n             });\n             if let Some(scope) = scope {\n-                bx.declare_local(&self.debug_context, name, place.layout.ty, scope,\n+                bx.declare_local(debug_context, name, place.layout.ty, scope,\n                     VariableAccess::DirectVariable { alloca: place.llval },\n                     kind, span);\n             }\n@@ -249,14 +211,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             return;\n         }\n \n+        let debug_context = match &self.debug_context {\n+            Some(debug_context) => debug_context,\n+            None => return,\n+        };\n+\n         for local in self.locals.indices() {\n             self.debug_introduce_local(bx, local);\n         }\n \n         // Declare closure captures as if they were local variables.\n         // FIXME(eddyb) generalize this to `name => place` mappings.\n         let upvar_scope = if !upvar_debuginfo.is_empty() {\n-            self.scopes[mir::OUTERMOST_SOURCE_SCOPE].scope_metadata\n+            debug_context.scopes[mir::OUTERMOST_SOURCE_SCOPE].scope_metadata\n         } else {\n             None\n         };\n@@ -362,7 +329,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     address_operations: &ops\n                 };\n                 bx.declare_local(\n-                    &self.debug_context,\n+                    debug_context,\n                     name,\n                     ty,\n                     var_scope,"}, {"sha": "0e790e51a4c883e9d568f31fed0c1863b6212f2b", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c2e7743da8ba6062c89b700957fda01f54732c30/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e7743da8ba6062c89b700957fda01f54732c30/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=c2e7743da8ba6062c89b700957fda01f54732c30", "patch": "@@ -23,7 +23,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n \n     mir: &'a mir::Body<'tcx>,\n \n-    debug_context: FunctionDebugContext<Bx::DIScope>,\n+    debug_context: Option<FunctionDebugContext<Bx::DIScope>>,\n \n     llfn: Bx::Function,\n \n@@ -74,8 +74,6 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     /// notably `expect`.\n     locals: IndexVec<mir::Local, LocalRef<'tcx, Bx::Value>>,\n \n-    /// Debug information for MIR scopes.\n-    scopes: IndexVec<mir::SourceScope, debuginfo::DebugScope<Bx::DIScope>>,\n }\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n@@ -129,8 +127,10 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     let fn_ty = FnType::new(cx, sig, &[]);\n     debug!(\"fn_ty: {:?}\", fn_ty);\n-    let mut debug_context =\n+\n+    let debug_context =\n         cx.create_function_debug_context(instance, sig, llfn, mir);\n+\n     let mut bx = Bx::new_block(cx, llfn, \"start\");\n \n     if mir.basic_blocks().iter().any(|bb| bb.is_cleanup) {\n@@ -152,8 +152,6 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             }\n         }).collect();\n \n-    // Compute debuginfo scopes from MIR scopes.\n-    let scopes = cx.create_mir_scopes(mir, &mut debug_context);\n     let (landing_pads, funclets) = create_funclets(mir, &mut bx, &cleanup_kinds, &block_bxs);\n \n     let mut fx = FunctionCx {\n@@ -168,7 +166,6 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         cleanup_kinds,\n         landing_pads,\n         funclets,\n-        scopes,\n         locals: IndexVec::new(),\n         debug_context,\n     };\n@@ -221,7 +218,9 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n     // emitting should be enabled.\n-    debuginfo::start_emitting_source_locations(&mut fx.debug_context);\n+    if let Some(debug_context) = &mut fx.debug_context {\n+        debug_context.source_locations_enabled = true;\n+    }\n \n     let rpo = traversal::reverse_postorder(&mir);\n     let mut visited = BitSet::new_empty(mir.basic_blocks().len());"}, {"sha": "ac4e1b94d7f5aea67224b8b192c3991af6c76bbe", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c2e7743da8ba6062c89b700957fda01f54732c30/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e7743da8ba6062c89b700957fda01f54732c30/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=c2e7743da8ba6062c89b700957fda01f54732c30", "patch": "@@ -1,9 +1,8 @@\n use super::BackendTypes;\n-use crate::mir::debuginfo::{FunctionDebugContext, DebugScope, VariableAccess, VariableKind};\n+use crate::mir::debuginfo::{FunctionDebugContext, VariableAccess, VariableKind};\n use rustc::hir::def_id::CrateNum;\n use rustc::mir;\n use rustc::ty::{self, Ty, Instance};\n-use rustc_index::vec::IndexVec;\n use syntax::ast::Name;\n use syntax_pos::{SourceFile, Span};\n \n@@ -13,22 +12,15 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n     /// Creates the function-specific debug context.\n     ///\n     /// Returns the FunctionDebugContext for the function which holds state needed\n-    /// for debug info creation. The function may also return another variant of the\n-    /// FunctionDebugContext enum which indicates why no debuginfo should be created\n-    /// for the function.\n+    /// for debug info creation, if it is enabled.\n     fn create_function_debug_context(\n         &self,\n         instance: Instance<'tcx>,\n         sig: ty::FnSig<'tcx>,\n         llfn: Self::Function,\n         mir: &mir::Body<'_>,\n-    ) -> FunctionDebugContext<Self::DIScope>;\n+    ) -> Option<FunctionDebugContext<Self::DIScope>>;\n \n-    fn create_mir_scopes(\n-        &self,\n-        mir: &mir::Body<'_>,\n-        debug_context: &mut FunctionDebugContext<Self::DIScope>,\n-    ) -> IndexVec<mir::SourceScope, DebugScope<Self::DIScope>>;\n     fn extend_scope_to_file(\n         &self,\n         scope_metadata: Self::DIScope,\n@@ -53,7 +45,7 @@ pub trait DebugInfoBuilderMethods<'tcx>: BackendTypes {\n     fn set_source_location(\n         &mut self,\n         debug_context: &mut FunctionDebugContext<Self::DIScope>,\n-        scope: Option<Self::DIScope>,\n+        scope: Self::DIScope,\n         span: Span,\n     );\n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self);"}]}