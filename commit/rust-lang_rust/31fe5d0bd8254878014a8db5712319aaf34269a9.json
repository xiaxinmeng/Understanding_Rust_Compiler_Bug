{"sha": "31fe5d0bd8254878014a8db5712319aaf34269a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZmU1ZDBiZDgyNTQ4NzgwMTRhOGRiNTcxMjMxOWFhZjM0MjY5YTk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-12-07T23:32:21Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-12-08T02:50:23Z"}, "message": "rt: Run most upcalls on the C stack", "tree": {"sha": "cc2ad0c529e26ec77abdbeee108c17f12b01a424", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc2ad0c529e26ec77abdbeee108c17f12b01a424"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31fe5d0bd8254878014a8db5712319aaf34269a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31fe5d0bd8254878014a8db5712319aaf34269a9", "html_url": "https://github.com/rust-lang/rust/commit/31fe5d0bd8254878014a8db5712319aaf34269a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31fe5d0bd8254878014a8db5712319aaf34269a9/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fc4403442504dfd05e317f7d34d8935d4c47e0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fc4403442504dfd05e317f7d34d8935d4c47e0f", "html_url": "https://github.com/rust-lang/rust/commit/0fc4403442504dfd05e317f7d34d8935d4c47e0f"}], "stats": {"total": 126, "additions": 66, "deletions": 60}, "files": [{"sha": "e74f8ed23e2c76a93c8f4f2c5d6c3c58e93c8d03", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 66, "deletions": 60, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/31fe5d0bd8254878014a8db5712319aaf34269a9/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/31fe5d0bd8254878014a8db5712319aaf34269a9/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=31fe5d0bd8254878014a8db5712319aaf34269a9", "patch": "@@ -6,6 +6,8 @@\n #include \"rust_upcall.h\"\n #include <stdint.h>\n \n+#define SWITCH_STACK(A, F) upcall_call_shim_on_c_stack((void*)A, (void*)F)\n+\n extern \"C\" void record_sp(void *limit);\n \n /**\n@@ -32,26 +34,6 @@ upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n     task->record_stack_limit();\n }\n \n-#if defined(__i386__) || defined(__x86_64__) || defined(_M_X64)\n-void\n-check_stack(rust_task *task) {\n-    void *esp;\n-#   ifdef __i386__\n-    asm volatile(\"movl %%esp,%0\" : \"=r\" (esp));\n-#   else\n-    asm volatile(\"mov %%rsp,%0\" : \"=r\" (esp));\n-#   endif\n-    if (esp < task->stk->data)\n-        task->kernel->fatal(\"Out of stack space, sorry\");\n-}\n-#else\n-#warning \"Stack checks are not supported on this architecture\"\n-void\n-check_stack(rust_task *task) {\n-    // TODO\n-}\n-#endif\n-\n // Copy elements from one vector to another,\n // dealing with reference counts\n static inline void\n@@ -87,11 +69,12 @@ upcall_s_fail(s_fail_args *args) {\n }\n \n struct s_malloc_args {\n+    uintptr_t retval;\n     size_t nbytes;\n     type_desc *td;\n };\n \n-extern \"C\" CDECL uintptr_t\n+extern \"C\" CDECL void\n upcall_s_malloc(s_malloc_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n@@ -115,7 +98,7 @@ upcall_s_malloc(s_malloc_args *args) {\n     LOG(task, mem,\n         \"upcall malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \") = 0x%\" PRIxPTR,\n         args->nbytes, args->td, (uintptr_t)p);\n-    return (uintptr_t) p;\n+    args->retval = (uintptr_t) p;\n }\n \n struct s_free_args {\n@@ -143,11 +126,12 @@ upcall_s_free(s_free_args *args) {\n }\n \n struct s_shared_malloc_args {\n+    uintptr_t retval;\n     size_t nbytes;\n     type_desc *td;\n };\n \n-extern \"C\" CDECL uintptr_t\n+extern \"C\" CDECL void\n upcall_s_shared_malloc(s_shared_malloc_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n@@ -161,7 +145,7 @@ upcall_s_shared_malloc(s_shared_malloc_args *args) {\n         \"upcall shared_malloc(%\" PRIdPTR \", 0x%\" PRIxPTR\n         \") = 0x%\" PRIxPTR,\n         args->nbytes, args->td, (uintptr_t)p);\n-    return (uintptr_t) p;\n+    args->retval = (uintptr_t) p;\n }\n \n struct s_shared_free_args {\n@@ -184,17 +168,17 @@ upcall_s_shared_free(s_shared_free_args *args) {\n }\n \n struct s_get_type_desc_args {\n+    type_desc *retval;\n     size_t size;\n     size_t align;\n     size_t n_descs;\n     type_desc const **descs;\n     uintptr_t n_obj_params;\n };\n \n-extern \"C\" CDECL type_desc *\n+extern \"C\" CDECL void\n upcall_s_get_type_desc(s_get_type_desc_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n-    check_stack(task);\n     LOG_UPCALL_ENTRY(task);\n \n     LOG(task, cache, \"upcall get_type_desc with size=%\" PRIdPTR\n@@ -204,7 +188,7 @@ upcall_s_get_type_desc(s_get_type_desc_args *args) {\n     type_desc *td = cache->get_type_desc(args->size, args->align, args->n_descs,\n                                          args->descs, args->n_obj_params);\n     LOG(task, cache, \"returning tydesc 0x%\" PRIxPTR, td);\n-    return td;\n+    args->retval = td;\n }\n \n struct s_vec_grow_args {\n@@ -238,16 +222,21 @@ upcall_s_vec_push(s_vec_push_args *args) {\n     v->fill += args->elt_ty->size;\n }\n \n+struct s_dynastack_mark_args {\n+    void *retval;\n+};\n+\n /**\n  * Returns a token that can be used to deallocate all of the allocated space\n  * space in the dynamic stack.\n  */\n-extern \"C\" CDECL void *\n-upcall_s_dynastack_mark() {\n-    return rust_scheduler::get_task()->dynastack.mark();\n+extern \"C\" CDECL void\n+upcall_s_dynastack_mark(s_dynastack_mark_args *args) {\n+    args->retval = rust_scheduler::get_task()->dynastack.mark();\n }\n \n struct s_dynastack_alloc_args {\n+    void *retval;\n     size_t sz;\n };\n \n@@ -256,13 +245,15 @@ struct s_dynastack_alloc_args {\n  *\n  * FIXME: Deprecated since dynamic stacks need to be self-describing for GC.\n  */\n-extern \"C\" CDECL void *\n+extern \"C\" CDECL void\n upcall_s_dynastack_alloc(s_dynastack_alloc_args *args) {\n     size_t sz = args->sz;\n-    return sz ? rust_scheduler::get_task()->dynastack.alloc(sz, NULL) : NULL;\n+    args->retval = sz ?\n+        rust_scheduler::get_task()->dynastack.alloc(sz, NULL) : NULL;\n }\n \n struct s_dynastack_alloc_2_args {\n+    void *retval;\n     size_t sz;\n     type_desc *ty;\n };\n@@ -271,11 +262,12 @@ struct s_dynastack_alloc_2_args {\n  * Allocates space associated with a type descriptor in the dynamic stack and\n  * returns it.\n  */\n-extern \"C\" CDECL void *\n+extern \"C\" CDECL void\n upcall_s_dynastack_alloc_2(s_dynastack_alloc_2_args *args) {\n     size_t sz = args->sz;\n     type_desc *ty = args->ty;\n-    return sz ? rust_scheduler::get_task()->dynastack.alloc(sz, ty) : NULL;\n+    args->retval = sz ?\n+        rust_scheduler::get_task()->dynastack.alloc(sz, ty) : NULL;\n }\n \n struct s_dynastack_free_args {\n@@ -296,20 +288,21 @@ __gxx_personality_v0(int version,\n                      _Unwind_Context *context);\n \n struct s_rust_personality_args {\n+    _Unwind_Reason_Code retval;\n     int version;\n     _Unwind_Action actions;\n     uint64_t exception_class;\n     _Unwind_Exception *ue_header;\n     _Unwind_Context *context;\n };\n \n-extern \"C\" _Unwind_Reason_Code\n+extern \"C\" void\n upcall_s_rust_personality(s_rust_personality_args *args) {\n-    return __gxx_personality_v0(args->version,\n-                                args->actions,\n-                                args->exception_class,\n-                                args->ue_header,\n-                                args->context);\n+    args->retval = __gxx_personality_v0(args->version,\n+                                        args->actions,\n+                                        args->exception_class,\n+                                        args->ue_header,\n+                                        args->context);\n }\n \n extern \"C\" void\n@@ -355,14 +348,17 @@ extern \"C\" CDECL void\n upcall_fail(char const *expr,\n             char const *file,\n             size_t line) {\n+    // FIXME: Need to fix the stack switching function to unwind properly\n+    // in order to switch stacks here\n     s_fail_args args = {expr,file,line};\n     upcall_s_fail(&args);\n }\n \n extern \"C\" CDECL uintptr_t\n upcall_malloc(size_t nbytes, type_desc *td) {\n-    s_malloc_args args = {nbytes, td};\n-    return upcall_s_malloc(&args);\n+    s_malloc_args args = {0, nbytes, td};\n+    SWITCH_STACK(&args, upcall_s_malloc);\n+    return args.retval;\n }\n \n /**\n@@ -371,13 +367,14 @@ upcall_malloc(size_t nbytes, type_desc *td) {\n extern \"C\" CDECL void\n upcall_free(void* ptr, uintptr_t is_gc) {\n     s_free_args args = {ptr, is_gc};\n-    upcall_s_free(&args);\n+    SWITCH_STACK(&args, upcall_s_free);\n }\n \n extern \"C\" CDECL uintptr_t\n upcall_shared_malloc(size_t nbytes, type_desc *td) {\n-    s_shared_malloc_args args = {nbytes, td};\n-    return upcall_s_shared_malloc(&args);\n+    s_shared_malloc_args args = {0, nbytes, td};\n+    SWITCH_STACK(&args, upcall_s_shared_malloc);\n+    return args.retval;\n }\n \n /**\n@@ -386,7 +383,7 @@ upcall_shared_malloc(size_t nbytes, type_desc *td) {\n extern \"C\" CDECL void\n upcall_shared_free(void* ptr) {\n     s_shared_free_args args = {ptr};\n-    upcall_s_shared_free(&args);\n+    SWITCH_STACK(&args, upcall_s_shared_free);\n }\n \n extern \"C\" CDECL type_desc *\n@@ -396,18 +393,21 @@ upcall_get_type_desc(void *curr_crate, // ignored, legacy compat.\n                      size_t n_descs,\n                      type_desc const **descs,\n                      uintptr_t n_obj_params) {\n-    s_get_type_desc_args args = {size,align,n_descs,descs,n_obj_params};\n-    return upcall_s_get_type_desc(&args);\n+    s_get_type_desc_args args = {0,size,align,n_descs,descs,n_obj_params};\n+    SWITCH_STACK(&args, upcall_s_get_type_desc);\n+    return args.retval;\n }\n \n extern \"C\" CDECL void\n upcall_vec_grow(rust_vec** vp, size_t new_sz) {\n     s_vec_grow_args args = {vp, new_sz};\n-    upcall_s_vec_grow(&args);\n+    SWITCH_STACK(&args, upcall_s_vec_grow);\n }\n \n extern \"C\" CDECL void\n upcall_vec_push(rust_vec** vp, type_desc* elt_ty, void* elt) {\n+    // FIXME: Switching stacks here causes crashes, probably\n+    // because this upcall calls take glue\n     s_vec_push_args args = {vp, elt_ty, elt};\n     upcall_s_vec_push(&args);\n }\n@@ -418,7 +418,9 @@ upcall_vec_push(rust_vec** vp, type_desc* elt_ty, void* elt) {\n  */\n extern \"C\" CDECL void *\n upcall_dynastack_mark() {\n-    return upcall_s_dynastack_mark();\n+    s_dynastack_mark_args args = {0};\n+    SWITCH_STACK(&args, upcall_s_dynastack_mark);\n+    return args.retval;\n }\n \n /**\n@@ -428,8 +430,9 @@ upcall_dynastack_mark() {\n  */\n extern \"C\" CDECL void *\n upcall_dynastack_alloc(size_t sz) {\n-    s_dynastack_alloc_args args = {sz};\n-    return upcall_s_dynastack_alloc(&args);\n+    s_dynastack_alloc_args args = {0, sz};\n+    SWITCH_STACK(&args, upcall_s_dynastack_alloc);\n+    return args.retval;\n }\n \n /**\n@@ -438,15 +441,16 @@ upcall_dynastack_alloc(size_t sz) {\n  */\n extern \"C\" CDECL void *\n upcall_dynastack_alloc_2(size_t sz, type_desc *ty) {\n-    s_dynastack_alloc_2_args args = {sz, ty};\n-    return upcall_s_dynastack_alloc_2(&args);\n+    s_dynastack_alloc_2_args args = {0, sz, ty};\n+    SWITCH_STACK(&args, upcall_s_dynastack_alloc_2);\n+    return args.retval;\n }\n \n /** Frees space in the dynamic stack. */\n extern \"C\" CDECL void\n upcall_dynastack_free(void *ptr) {\n     s_dynastack_free_args args = {ptr};\n-    return upcall_s_dynastack_free(&args);\n+    SWITCH_STACK(&args, upcall_s_dynastack_free);\n }\n \n extern \"C\" _Unwind_Reason_Code\n@@ -455,23 +459,25 @@ upcall_rust_personality(int version,\n                         uint64_t exception_class,\n                         _Unwind_Exception *ue_header,\n                         _Unwind_Context *context) {\n-    s_rust_personality_args args = {version, actions, exception_class, ue_header, \n-                                    context};\n-    return upcall_s_rust_personality(&args);\n+    s_rust_personality_args args = {(_Unwind_Reason_Code)0,\n+                                    version, actions, exception_class,\n+                                    ue_header, context};\n+    SWITCH_STACK(&args, upcall_s_rust_personality);\n+    return args.retval;\n }\n \n extern \"C\" void\n upcall_cmp_type(int8_t *result, const type_desc *tydesc,\n                 const type_desc **subtydescs, uint8_t *data_0,\n                 uint8_t *data_1, uint8_t cmp_type) {\n     s_cmp_type_args args = {result, tydesc, subtydescs, data_0, data_1, cmp_type};\n-    upcall_s_cmp_type(&args);\n+    SWITCH_STACK(&args, upcall_s_cmp_type);\n }\n \n extern \"C\" void\n upcall_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level) {\n     s_log_type_args args = {tydesc, data, level};\n-    upcall_s_log_type(&args);\n+    SWITCH_STACK(&args, upcall_s_log_type);\n }\n \n struct rust_new_stack2_args {"}]}