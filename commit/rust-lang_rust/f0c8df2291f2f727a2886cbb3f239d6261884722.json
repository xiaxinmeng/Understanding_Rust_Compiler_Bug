{"sha": "f0c8df2291f2f727a2886cbb3f239d6261884722", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwYzhkZjIyOTFmMmY3MjdhMjg4NmNiYjNmMjM5ZDYyNjE4ODQ3MjI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-23T01:41:10Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-24T18:05:13Z"}, "message": "handle ptr-int casts explicitly in cast.rs", "tree": {"sha": "7064df6e86193317f28eab90e58bbea301a4e93f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7064df6e86193317f28eab90e58bbea301a4e93f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0c8df2291f2f727a2886cbb3f239d6261884722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0c8df2291f2f727a2886cbb3f239d6261884722", "html_url": "https://github.com/rust-lang/rust/commit/f0c8df2291f2f727a2886cbb3f239d6261884722", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0c8df2291f2f727a2886cbb3f239d6261884722/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b7f690274683777e810bfb61aae2af2e36aaab8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7f690274683777e810bfb61aae2af2e36aaab8", "html_url": "https://github.com/rust-lang/rust/commit/7b7f690274683777e810bfb61aae2af2e36aaab8"}], "stats": {"total": 54, "additions": 30, "deletions": 24}, "files": [{"sha": "cb0b1121709875b92b2c67fc48f5c250fde111c2", "filename": "src/cast.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f0c8df2291f2f727a2886cbb3f239d6261884722/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c8df2291f2f727a2886cbb3f239d6261884722/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=f0c8df2291f2f727a2886cbb3f239d6261884722", "patch": "@@ -19,9 +19,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             F32 => self.cast_float(val.to_f32()? as f64, dest_ty),\n             F64 => self.cast_float(val.to_f64()?, dest_ty),\n \n-            I8 | I16 | I32 | I64 | I128 => self.cast_signed_int(val.to_i128()?, dest_ty),\n-\n-            Bool | Char | U8 | U16 | U32 | U64 | U128 => self.cast_int(val.to_u128()?, dest_ty, false),\n+            I8 | I16 | I32 | I64 | I128 => {\n+                if val.is_ptr() {\n+                    self.cast_ptr(val, dest_ty)\n+                } else {\n+                    self.cast_signed_int(val.to_i128()?, dest_ty)\n+                }\n+            },\n+\n+            Bool | Char | U8 | U16 | U32 | U64 | U128 => {\n+                if val.is_ptr() {\n+                    self.cast_ptr(val, dest_ty)\n+                } else {\n+                    self.cast_int(val.to_u128()?, dest_ty, false)\n+                }\n+            },\n \n             FnPtr | Ptr => self.cast_ptr(val, dest_ty),\n         }\n@@ -70,6 +82,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             TyChar if v as u8 as u128 == v => Ok(PrimVal::Bytes(v)),\n             TyChar => Err(EvalError::InvalidChar(v)),\n \n+            // No alignment check needed for raw pointers\n             TyRawPtr(_) => Ok(PrimVal::Bytes(v % (1 << self.memory.pointer_size()))),\n \n             _ => Err(EvalError::Unimplemented(format!(\"int to {:?} cast\", ty))),\n@@ -94,8 +107,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn cast_ptr(&self, ptr: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         use rustc::ty::TypeVariants::*;\n         match ty.sty {\n-            TyRef(..) | TyRawPtr(_) | TyFnPtr(_) | TyInt(_) | TyUint(_) =>\n+            // Casting to a reference or fn pointer is not permitted by rustc, no need to support it here.\n+            TyRawPtr(_) | TyInt(IntTy::Is) | TyUint(UintTy::Us) =>\n                 Ok(ptr),\n+            TyInt(_) | TyUint(_) => Err(EvalError::ReadPointerAsBytes),\n             _ => Err(EvalError::Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }\n     }"}, {"sha": "919232d9eef703c949051a24fb1a0deef994e242", "filename": "src/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0c8df2291f2f727a2886cbb3f239d6261884722/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c8df2291f2f727a2886cbb3f239d6261884722/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=f0c8df2291f2f727a2886cbb3f239d6261884722", "patch": "@@ -21,7 +21,7 @@ pub enum EvalError<'tcx> {\n         access: bool,\n         allocation_size: u64,\n     },\n-    NullPointerOutOfBounds,\n+    InvalidNullPointerUsage,\n     ReadPointerAsBytes,\n     ReadBytesAsPointer,\n     InvalidPointerMath,\n@@ -84,8 +84,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"invalid enum discriminant value read\",\n             EvalError::PointerOutOfBounds { .. } =>\n                 \"pointer offset outside bounds of allocation\",\n-            EvalError::NullPointerOutOfBounds =>\n-                \"invalid NULL pointer offset\",\n+            EvalError::InvalidNullPointerUsage =>\n+                \"invalid use of NULL pointer\",\n             EvalError::ReadPointerAsBytes =>\n                 \"a raw memory access tried to access part of a pointer value as raw bytes\",\n             EvalError::ReadBytesAsPointer =>"}, {"sha": "ece2b37209c5d04ceca7c9598c0e45b28965942e", "filename": "src/eval_context.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f0c8df2291f2f727a2886cbb3f239d6261884722/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c8df2291f2f727a2886cbb3f239d6261884722/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=f0c8df2291f2f727a2886cbb3f239d6261884722", "patch": "@@ -717,19 +717,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 (Value::ByVal(_), _) => bug!(\"expected fat ptr\"),\n                             }\n                         } else {\n-                            // First, try casting\n-                            let dest_val = self.value_to_primval(src, src_ty).and_then(\n-                                |src_val| { self.cast_primval(src_val, src_ty, dest_ty) })\n-                                // Alternatively, if the sizes are equal, try just reading at the target type\n-                                .or_else(|err| {\n-                                    let size = self.type_size(src_ty)?;\n-                                    if size.is_some() && size == self.type_size(dest_ty)? {\n-                                        self.value_to_primval(src, dest_ty)\n-                                    } else {\n-                                        Err(err)\n-                                    }\n-                                });\n-                            self.write_value(Value::ByVal(dest_val?), dest, dest_ty)?;\n+                            let src_val = self.value_to_primval(src, src_ty)?;\n+                            let dest_val = self.cast_primval(src_val, src_ty, dest_ty)?;\n+                            self.write_value(Value::ByVal(dest_val), dest, dest_ty)?;\n                         }\n                     }\n \n@@ -908,7 +898,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // allocation.\n \n         if ptr.is_null()? { // NULL pointers must only be offset by 0\n-            return if offset == 0 { Ok(ptr) } else { Err(EvalError::NullPointerOutOfBounds) };\n+            return if offset == 0 { Ok(ptr) } else { Err(EvalError::InvalidNullPointerUsage) };\n         }\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n@@ -919,7 +909,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.check_bounds(ptr, false)?;\n             } else if ptr.is_null()? {\n                 // We moved *to* a NULL pointer.  That seems wrong, LLVM considers the NULL pointer its own small allocation.  Reject this, for now.\n-                return Err(EvalError::NullPointerOutOfBounds);\n+                return Err(EvalError::InvalidNullPointerUsage);\n             }\n             Ok(ptr)\n         } else {"}, {"sha": "396c71ebb03d18298eff130625e9b26d108a402c", "filename": "tests/compile-fail/ptr_int_cast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0c8df2291f2f727a2886cbb3f239d6261884722/tests%2Fcompile-fail%2Fptr_int_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c8df2291f2f727a2886cbb3f239d6261884722/tests%2Fcompile-fail%2Fptr_int_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_int_cast.rs?ref=f0c8df2291f2f727a2886cbb3f239d6261884722", "patch": "@@ -1,7 +1,8 @@\n fn main() {\n     let x = &1;\n     // Casting down to u8 and back up to a pointer loses too much precision; this must not work.\n-    let x = x as *const i32 as u8;\n-    let x = x as *const i32; //~ ERROR: a raw memory access tried to access part of a pointer value as raw bytes\n+    let x = x as *const i32;\n+    let x = x as u8; //~ ERROR: a raw memory access tried to access part of a pointer value as raw bytes\n+    let x = x as *const i32;\n     let _ = unsafe { *x };\n }"}]}