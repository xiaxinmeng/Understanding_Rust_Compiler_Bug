{"sha": "8be8d84fa019492fe2f0abc9672fc2d88916bf60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiZThkODRmYTAxOTQ5MmZlMmYwYWJjOTY3MmZjMmQ4ODkxNmJmNjA=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-05T14:27:09Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-05T14:27:09Z"}, "message": "Merge pull request #300 from Manishearth/minmax\n\nnew lint: min_max", "tree": {"sha": "efcc231d3522ce644c6e73593516f2b2cc25c7bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efcc231d3522ce644c6e73593516f2b2cc25c7bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8be8d84fa019492fe2f0abc9672fc2d88916bf60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8be8d84fa019492fe2f0abc9672fc2d88916bf60", "html_url": "https://github.com/rust-lang/rust/commit/8be8d84fa019492fe2f0abc9672fc2d88916bf60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8be8d84fa019492fe2f0abc9672fc2d88916bf60/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c50d763fc3a800317d81f90c729ed669ad6e476", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c50d763fc3a800317d81f90c729ed669ad6e476", "html_url": "https://github.com/rust-lang/rust/commit/0c50d763fc3a800317d81f90c729ed669ad6e476"}, {"sha": "79bf820170faf257e68540d43cdf40112822a87d", "url": "https://api.github.com/repos/rust-lang/rust/commits/79bf820170faf257e68540d43cdf40112822a87d", "html_url": "https://github.com/rust-lang/rust/commit/79bf820170faf257e68540d43cdf40112822a87d"}], "stats": {"total": 118, "additions": 112, "deletions": 6}, "files": [{"sha": "c7071688e10b5b6011edd8f097140209779ddb80", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8be8d84fa019492fe2f0abc9672fc2d88916bf60/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/8be8d84fa019492fe2f0abc9672fc2d88916bf60/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=8be8d84fa019492fe2f0abc9672fc2d88916bf60", "patch": "@@ -4,7 +4,7 @@\n A collection of lints that give helpful tips to newbies and catch oversights.\n \n ##Lints\n-There are 54 lints included in this crate:\n+There are 55 lints included in this crate:\n \n name                                                                                                 | default | meaning\n -----------------------------------------------------------------------------------------------------|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -31,6 +31,7 @@ name\n [let_unit_value](https://github.com/Manishearth/rust-clippy/wiki#let_unit_value)                     | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n [linkedlist](https://github.com/Manishearth/rust-clippy/wiki#linkedlist)                             | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a RingBuf\n [match_ref_pats](https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats)                     | warn    | a match has all arms prefixed with `&`; the match expression can be dereferenced instead\n+[min_max](https://github.com/Manishearth/rust-clippy/wiki#min_max)                                   | warn    | `min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\n [modulo_one](https://github.com/Manishearth/rust-clippy/wiki#modulo_one)                             | warn    | taking a number modulo 1, which always returns 0\n [mut_mut](https://github.com/Manishearth/rust-clippy/wiki#mut_mut)                                   | warn    | usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, or shows a fundamental misunderstanding of references)\n [needless_bool](https://github.com/Manishearth/rust-clippy/wiki#needless_bool)                       | warn    | if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`"}, {"sha": "0c32dc5efadfa272a54957f1506aed16a6725aa0", "filename": "src/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8be8d84fa019492fe2f0abc9672fc2d88916bf60/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8be8d84fa019492fe2f0abc9672fc2d88916bf60/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=8be8d84fa019492fe2f0abc9672fc2d88916bf60", "patch": "@@ -121,10 +121,10 @@ impl PartialOrd for Constant {\n             (&ConstantInt(ref lv, lty), &ConstantInt(ref rv, rty)) =>\n                 Some(match (is_negative(lty) && *lv != 0,\n                             is_negative(rty) && *rv != 0) {\n-                    (true, true) => lv.cmp(rv),\n-                    (false, false) => rv.cmp(lv),\n-                    (true, false) => Greater,\n-                    (false, true) => Less,\n+                    (true, true) => rv.cmp(lv),\n+                    (false, false) => lv.cmp(rv),\n+                    (true, false) => Less,\n+                    (false, true) => Greater,\n                 }),\n             (&ConstantFloat(ref ls, lw), &ConstantFloat(ref rs, rw)) =>\n                 if match (lw, rw) {\n@@ -154,8 +154,8 @@ impl PartialOrd for Constant {\n fn lit_to_constant(lit: &Lit_) -> Constant {\n     match *lit {\n         LitStr(ref is, style) => ConstantStr(is.to_string(), style),\n-        LitBinary(ref blob) => ConstantBinary(blob.clone()),\n         LitByte(b) => ConstantByte(b),\n+        LitByteStr(ref s) => ConstantBinary(s.clone()),\n         LitChar(c) => ConstantChar(c),\n         LitInt(value, ty) => ConstantInt(value, ty),\n         LitFloat(ref is, ty) => ConstantFloat(is.to_string(), ty.into()),"}, {"sha": "7665d06b193add108fc429bf0fadda13919f0997", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8be8d84fa019492fe2f0abc9672fc2d88916bf60/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8be8d84fa019492fe2f0abc9672fc2d88916bf60/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=8be8d84fa019492fe2f0abc9672fc2d88916bf60", "patch": "@@ -32,6 +32,7 @@ pub mod needless_bool;\n pub mod approx_const;\n pub mod eta_reduction;\n pub mod identity_op;\n+pub mod minmax;\n pub mod mut_mut;\n pub mod len_zero;\n pub mod attrs;\n@@ -85,6 +86,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box types::TypeComplexityPass as LintPassObject);\n     reg.register_lint_pass(box matches::MatchPass as LintPassObject);\n     reg.register_lint_pass(box misc::PatternPass as LintPassObject);\n+    reg.register_lint_pass(box minmax::MinMaxPass as LintPassObject);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n         methods::OPTION_UNWRAP_USED,\n@@ -125,6 +127,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         methods::STR_TO_STRING,\n         methods::STRING_TO_STRING,\n         methods::WRONG_SELF_CONVENTION,\n+        minmax::MIN_MAX,\n         misc::CMP_NAN,\n         misc::CMP_OWNED,\n         misc::FLOAT_CMP,"}, {"sha": "72190d70e2e5da1afa27875a415e2d98125b07ec", "filename": "src/minmax.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8be8d84fa019492fe2f0abc9672fc2d88916bf60/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8be8d84fa019492fe2f0abc9672fc2d88916bf60/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=8be8d84fa019492fe2f0abc9672fc2d88916bf60", "patch": "@@ -0,0 +1,73 @@\n+use rustc::lint::{Context, LintPass, LintArray};\n+use rustc_front::hir::*;\n+use syntax::ptr::P;\n+use std::cmp::PartialOrd;\n+use std::cmp::Ordering::*;\n+\n+use consts::{Constant, constant_simple};\n+use utils::{match_path, span_lint};\n+use self::MinMax::{Min, Max};\n+\n+declare_lint!(pub MIN_MAX, Warn,\n+    \"`min(_, max(_, _))` (or vice versa) with bounds clamping the result \\\n+    to a constant\");\n+\n+#[allow(missing_copy_implementations)]\n+pub struct MinMaxPass;\n+\n+impl LintPass for MinMaxPass {\n+    fn get_lints(&self) -> LintArray {\n+       lint_array!(MIN_MAX)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        if let Some((outer_max, outer_c, oe)) = min_max(expr) {\n+            if let Some((inner_max, inner_c, _)) = min_max(oe) {\n+                if outer_max == inner_max { return; }\n+                match (outer_max, outer_c.partial_cmp(&inner_c)) {\n+                    (_, None) | (Max, Some(Less)) | (Min, Some(Greater)) => (),\n+                    _ => {\n+                        span_lint(cx, MIN_MAX, expr.span,\n+                            \"this min/max combination leads to constant result\")\n+                    },\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Debug)]\n+enum MinMax {\n+    Min,\n+    Max,\n+}\n+\n+fn min_max(expr: &Expr) -> Option<(MinMax, Constant, &Expr)> {\n+    if let ExprCall(ref path, ref args) = expr.node {\n+        if let ExprPath(None, ref path) = path.node {\n+            if match_path(path, &[\"std\", \"cmp\", \"min\"]) {\n+                fetch_const(args, Min)\n+            } else {\n+                if match_path(path, &[\"std\", \"cmp\", \"max\"]) {\n+                    fetch_const(args, Max)\n+                } else {\n+                    None\n+                }\n+            }\n+        } else { None }\n+    } else { None }\n+ }\n+\n+fn fetch_const(args: &[P<Expr>], m: MinMax) ->\n+        Option<(MinMax, Constant, &Expr)> {\n+    if args.len() != 2 { return None }\n+    if let Some(c) = constant_simple(&args[0]) {\n+        if let None = constant_simple(&args[1]) { // otherwise ignore\n+            Some((m, c, &args[1]))\n+        } else { None }\n+    } else {\n+        if let Some(c) = constant_simple(&args[1]) {\n+            Some((m, c, &args[0]))\n+        } else { None }\n+    }\n+}"}, {"sha": "5a5fae4930d3380ecf9c4e49e94c5679e966e7a2", "filename": "tests/compile-fail/min_max.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8be8d84fa019492fe2f0abc9672fc2d88916bf60/tests%2Fcompile-fail%2Fmin_max.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8be8d84fa019492fe2f0abc9672fc2d88916bf60/tests%2Fcompile-fail%2Fmin_max.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmin_max.rs?ref=8be8d84fa019492fe2f0abc9672fc2d88916bf60", "patch": "@@ -0,0 +1,29 @@\n+#![feature(plugin)]\n+\n+#![plugin(clippy)]\n+#![deny(clippy)]\n+\n+use std::cmp::{min, max};\n+\n+const LARGE : usize = 3;\n+\n+fn main() {\n+    let x;\n+    x = 2usize;\n+    min(1, max(3, x)); //~ERROR this min/max combination leads to constant result\n+    min(max(3, x), 1); //~ERROR this min/max combination leads to constant result\n+    max(min(x, 1), 3); //~ERROR this min/max combination leads to constant result\n+    max(3, min(x, 1)); //~ERROR this min/max combination leads to constant result\n+\n+    min(3, max(1, x)); // ok, could be 1, 2 or 3 depending on x\n+\n+    min(1, max(LARGE, x)); // no error, we don't lookup consts here\n+\n+    let s;\n+    s = \"Hello\";\n+\n+    min(\"Apple\", max(\"Zoo\", s)); //~ERROR this min/max combination leads to constant result\n+    max(min(s, \"Apple\"), \"Zoo\"); //~ERROR this min/max combination leads to constant result\n+\n+    max(\"Apple\", min(s, \"Zoo\")); // ok\n+}"}]}