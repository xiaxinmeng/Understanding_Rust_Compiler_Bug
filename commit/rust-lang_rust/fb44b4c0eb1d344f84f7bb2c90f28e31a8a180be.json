{"sha": "fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNDRiNGMwZWIxZDM0NGY4NGY3YmIyYzkwZjI4ZTMxYThhMTgwYmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-04T18:11:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-04T18:11:51Z"}, "message": "Auto merge of #48171 - FraGag:doc-copy-clone-impls, r=nikomatsakis\n\nBetter document the implementors of Clone and Copy\n\nThere are two parts to this change. The first part is a change to the compiler and to the standard library (specifically, libcore) to allow implementations of `Clone` and `Copy` to be written for a subset of builtin types. By adding these implementations to libcore, they now show up in the documentation. This is a [breaking-change] for users of `#![no_core]`, because they will now have to supply their own copy of the implementations of `Clone` and `Copy` that were added in libcore.\n\nThe second part is purely a documentation change to document the other implementors of `Clone` and `Copy` that cannot be described in Rust code (yet) and are thus provided by the compiler.\n\nFixes #25893", "tree": {"sha": "9f860914840b493b7f11e1be457a861ec0c63e29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f860914840b493b7f11e1be457a861ec0c63e29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "html_url": "https://github.com/rust-lang/rust/commit/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17fea66ba46bb32d1a49495518d899cede1d298a", "url": "https://api.github.com/repos/rust-lang/rust/commits/17fea66ba46bb32d1a49495518d899cede1d298a", "html_url": "https://github.com/rust-lang/rust/commit/17fea66ba46bb32d1a49495518d899cede1d298a"}, {"sha": "87c08f9926b7078489a93cedd1c9f10df1bdf2e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/87c08f9926b7078489a93cedd1c9f10df1bdf2e0", "html_url": "https://github.com/rust-lang/rust/commit/87c08f9926b7078489a93cedd1c9f10df1bdf2e0"}], "stats": {"total": 263, "additions": 221, "deletions": 42}, "files": [{"sha": "f8e8c69621ae2bdc4dd5f4e4ad620a8fe844975c", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 82, "deletions": 5, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "patch": "@@ -63,11 +63,6 @@\n /// This trait can be used with `#[derive]` if all fields are `Clone`. The `derive`d\n /// implementation of [`clone`] calls [`clone`] on each field.\n ///\n-/// ## Closures\n-///\n-/// Closure types automatically implement `Clone` if they capture no value from the environment\n-/// or if all such captured values implement `Clone` themselves.\n-///\n /// ## How can I implement `Clone`?\n ///\n /// Types that are [`Copy`] should have a trivial implementation of `Clone`. More formally:\n@@ -92,6 +87,23 @@\n ///     fn clone(&self) -> Stats { *self }\n /// }\n /// ```\n+///\n+/// ## Additional implementors\n+///\n+/// In addition to the [implementors listed below][impls],\n+/// the following types also implement `Clone`:\n+///\n+/// * Function item types (i.e. the distinct types defined for each function)\n+/// * Function pointer types (e.g. `fn() -> i32`)\n+/// * Array types, for all sizes, if the item type also implements `Clone` (e.g. `[i32; 123456]`)\n+/// * Tuple types, if each component also implements `Clone` (e.g. `()`, `(i32, bool)`)\n+/// * Closure types, if they capture no value from the environment\n+///   or if all such captured values implement `Clone` themselves.\n+///   Note that variables captured by shared reference always implement `Clone`\n+///   (even if the referent doesn't),\n+///   while variables captured by mutable reference never implement `Clone`.\n+///\n+/// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"clone\"]\n pub trait Clone : Sized {\n@@ -135,3 +147,68 @@ pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: ::marker::PhantomData\n            reason = \"deriving hack, should not be public\",\n            issue = \"0\")]\n pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: ::marker::PhantomData<T> }\n+\n+/// Implementations of `Clone` for primitive types.\n+///\n+/// Implementations that cannot be described in Rust\n+/// are implemented in `SelectionContext::copy_clone_conditions()` in librustc.\n+#[cfg(not(stage0))]\n+mod impls {\n+\n+    use super::Clone;\n+\n+    macro_rules! impl_clone {\n+        ($($t:ty)*) => {\n+            $(\n+                #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+                impl Clone for $t {\n+                    #[inline]\n+                    fn clone(&self) -> Self {\n+                        *self\n+                    }\n+                }\n+            )*\n+        }\n+    }\n+\n+    impl_clone! {\n+        usize u8 u16 u32 u64 u128\n+        isize i8 i16 i32 i64 i128\n+        f32 f64\n+        bool char\n+    }\n+\n+    #[stable(feature = \"never_type\", since = \"1.26.0\")]\n+    impl Clone for ! {\n+        #[inline]\n+        fn clone(&self) -> Self {\n+            *self\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: ?Sized> Clone for *const T {\n+        #[inline]\n+        fn clone(&self) -> Self {\n+            *self\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: ?Sized> Clone for *mut T {\n+        #[inline]\n+        fn clone(&self) -> Self {\n+            *self\n+        }\n+    }\n+\n+    // Shared references can be cloned, but mutable references *cannot*!\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T: ?Sized> Clone for &'a T {\n+        #[inline]\n+        fn clone(&self) -> Self {\n+            *self\n+        }\n+    }\n+\n+}"}, {"sha": "885aabe08069d4e064cbebd9183819fe799084e8", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "patch": "@@ -166,11 +166,6 @@ pub trait Unsize<T: ?Sized> {\n /// are allowed to access `x` after the assignment. Under the hood, both a copy and a move\n /// can result in bits being copied in memory, although this is sometimes optimized away.\n ///\n-/// ## Closures\n-///\n-/// Closure types automatically implement `Copy` if they capture no value from the environment\n-/// or if all such captured values implement `Copy` themselves.\n-///\n /// ## How can I implement `Copy`?\n ///\n /// There are two ways to implement `Copy` on your type. The simplest is to use `derive`:\n@@ -265,13 +260,29 @@ pub trait Unsize<T: ?Sized> {\n /// non-`Copy` in the future, it could be prudent to omit the `Copy` implementation now, to\n /// avoid a breaking API change.\n ///\n+/// ## Additional implementors\n+///\n+/// In addition to the [implementors listed below][impls],\n+/// the following types also implement `Copy`:\n+///\n+/// * Function item types (i.e. the distinct types defined for each function)\n+/// * Function pointer types (e.g. `fn() -> i32`)\n+/// * Array types, for all sizes, if the item type also implements `Copy` (e.g. `[i32; 123456]`)\n+/// * Tuple types, if each component also implements `Copy` (e.g. `()`, `(i32, bool)`)\n+/// * Closure types, if they capture no value from the environment\n+///   or if all such captured values implement `Copy` themselves.\n+///   Note that variables captured by shared reference always implement `Copy`\n+///   (even if the referent doesn't),\n+///   while variables captured by mutable reference never implement `Copy`.\n+///\n /// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n /// [`String`]: ../../std/string/struct.String.html\n /// [`Drop`]: ../../std/ops/trait.Drop.html\n /// [`size_of::<T>`]: ../../std/mem/fn.size_of.html\n /// [`Clone`]: ../clone/trait.Clone.html\n /// [`String`]: ../../std/string/struct.String.html\n /// [`i32`]: ../../std/primitive.i32.html\n+/// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"copy\"]\n pub trait Copy : Clone {\n@@ -593,3 +604,43 @@ unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}\n /// This trait is automatically implemented for almost every type.\n #[unstable(feature = \"pin\", issue = \"49150\")]\n pub unsafe auto trait Unpin {}\n+\n+/// Implementations of `Copy` for primitive types.\n+///\n+/// Implementations that cannot be described in Rust\n+/// are implemented in `SelectionContext::copy_clone_conditions()` in librustc.\n+#[cfg(not(stage0))]\n+mod copy_impls {\n+\n+    use super::Copy;\n+\n+    macro_rules! impl_copy {\n+        ($($t:ty)*) => {\n+            $(\n+                #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+                impl Copy for $t {}\n+            )*\n+        }\n+    }\n+\n+    impl_copy! {\n+        usize u8 u16 u32 u64 u128\n+        isize i8 i16 i32 i64 i128\n+        f32 f64\n+        bool char\n+    }\n+\n+    #[stable(feature = \"never_type\", since = \"1.26.0\")]\n+    impl Copy for ! {}\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: ?Sized> Copy for *const T {}\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: ?Sized> Copy for *mut T {}\n+\n+    // Shared references can be copied, but mutable references *cannot*!\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T: ?Sized> Copy for &'a T {}\n+\n+}"}, {"sha": "a7e78a78e17c8776d7780008ccb3ce541ec64ae9", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "patch": "@@ -1 +1 @@\n-Subproject commit ed04152aacf5b4798f78ff13396f3c04c0a77144\n+Subproject commit a7e78a78e17c8776d7780008ccb3ce541ec64ae9"}, {"sha": "bbd428611874ae2d994cbcd90ebe1eeb4181023c", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "patch": "@@ -2061,11 +2061,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         match self_ty.sty {\n             ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n+            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyError => {\n+                Where(ty::Binder(Vec::new()))\n+            }\n+\n             ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n-            ty::TyRawPtr(..) | ty::TyError | ty::TyNever |\n+            ty::TyChar | ty::TyRawPtr(..) | ty::TyNever |\n             ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                Where(ty::Binder(Vec::new()))\n+                // Implementations provided in libcore\n+                None\n             }\n \n             ty::TyDynamic(..) | ty::TyStr | ty::TySlice(..) |"}, {"sha": "22f851a908b252b5f2046949b4f4fdb74a812876", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "patch": "@@ -197,7 +197,14 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n         // FIXME: (@jroesch) float this code up\n         tcx.infer_ctxt().enter(|infcx| {\n             let (adt, substs) = match self_type.sty {\n+                // These types used to have a builtin impl.\n+                // Now libcore provides that impl.\n+                ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n+                ty::TyChar | ty::TyRawPtr(..) | ty::TyNever |\n+                ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => return Ok(()),\n+\n                 ty::TyAdt(adt, substs) => (adt, substs),\n+\n                 _ => return Err(CopyImplementationError::NotAnAdt),\n             };\n "}, {"sha": "99726bb65f38557ee75e852833c9b3d0d36db4ec", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "patch": "@@ -1908,16 +1908,16 @@ differs from the behavior for `&T`, which is always `Copy`).\n \n E0206: r##\"\n You can only implement `Copy` for a struct or enum. Both of the following\n-examples will fail, because neither `i32` (primitive type) nor `&'static Bar`\n-(reference to `Bar`) is a struct or enum:\n+examples will fail, because neither `[u8; 256]` nor `&'static mut Bar`\n+(mutable reference to `Bar`) is a struct or enum:\n \n ```compile_fail,E0206\n-type Foo = i32;\n+type Foo = [u8; 256];\n impl Copy for Foo { } // error\n \n #[derive(Copy, Clone)]\n struct Bar;\n-impl Copy for &'static Bar { } // error\n+impl Copy for &'static mut Bar { } // error\n ```\n \"##,\n "}, {"sha": "8b3294281e9603cf24dd8db15420bedb67efbb78", "filename": "src/test/codegen/repeat-trusted-len.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs?ref=fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "patch": "@@ -15,9 +15,14 @@\n \n use std::iter;\n \n+// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n+#[no_mangle]\n+pub fn helper(_: usize) {\n+}\n+\n // CHECK-LABEL: @repeat_take_collect\n #[no_mangle]\n pub fn repeat_take_collect() -> Vec<u8> {\n-// CHECK: call void @llvm.memset.p0i8\n+// CHECK: call void @llvm.memset.p0i8.[[USIZE]](i8* {{(nonnull )?}}%{{[0-9]+}}, i8 42, [[USIZE]] 100000, i32 1, i1 false)\n     iter::repeat(42).take(100000).collect()\n }"}, {"sha": "54f888b3796a17b1763fa2b1ac9134b499a293b5", "filename": "src/test/run-make-fulldeps/atomic-lock-free/atomic_lock_free.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Ftest%2Frun-make-fulldeps%2Fatomic-lock-free%2Fatomic_lock_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Ftest%2Frun-make-fulldeps%2Fatomic-lock-free%2Fatomic_lock_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fatomic-lock-free%2Fatomic_lock_free.rs?ref=fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "patch": "@@ -23,6 +23,8 @@ trait Copy {}\n #[lang = \"freeze\"]\n trait Freeze {}\n \n+impl<T: ?Sized> Copy for *mut T {}\n+\n #[cfg(target_has_atomic = \"8\")]\n pub unsafe fn atomic_u8(x: *mut u8) {\n     atomic_xadd(x, 1);"}, {"sha": "21411a35e3c353197109a348293a7540a805991e", "filename": "src/test/run-make-fulldeps/simd-ffi/simd.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Ftest%2Frun-make-fulldeps%2Fsimd-ffi%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Ftest%2Frun-make-fulldeps%2Fsimd-ffi%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsimd-ffi%2Fsimd.rs?ref=fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "patch": "@@ -75,6 +75,9 @@ pub trait Sized { }\n #[lang = \"copy\"]\n pub trait Copy { }\n \n+impl Copy for f32 {}\n+impl Copy for i32 {}\n+\n pub mod marker {\n     pub use Copy;\n }"}, {"sha": "f48790d1f4039311a5e6b5f378d4b8bf8e872a59", "filename": "src/test/ui/coherence-impls-copy.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Ftest%2Fui%2Fcoherence-impls-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Ftest%2Fui%2Fcoherence-impls-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence-impls-copy.rs?ref=fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "patch": "@@ -12,6 +12,10 @@\n \n use std::marker::Copy;\n \n+impl Copy for i32 {}\n+//~^ ERROR conflicting implementations of trait `std::marker::Copy` for type `i32`:\n+//~| ERROR only traits defined in the current crate can be implemented for arbitrary types\n+\n enum TestE {\n   A\n }\n@@ -35,14 +39,14 @@ impl Copy for (MyType, MyType) {}\n //~| ERROR only traits defined in the current crate can be implemented for arbitrary types\n \n impl Copy for &'static NotSync {}\n-//~^ ERROR the trait `Copy` may not be implemented for this type\n+//~^ ERROR conflicting implementations of trait `std::marker::Copy` for type `&NotSync`:\n \n impl Copy for [MyType] {}\n //~^ ERROR the trait `Copy` may not be implemented for this type\n //~| ERROR only traits defined in the current crate can be implemented for arbitrary types\n \n impl Copy for &'static [NotSync] {}\n-//~^ ERROR the trait `Copy` may not be implemented for this type\n+//~^ ERROR conflicting implementations of trait `std::marker::Copy` for type `&[NotSync]`:\n //~| ERROR only traits defined in the current crate can be implemented for arbitrary types\n \n fn main() {"}, {"sha": "24e7e85b1a9615d5743ee0716e7e59ff3450b26e", "filename": "src/test/ui/coherence-impls-copy.stderr", "status": "modified", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Ftest%2Fui%2Fcoherence-impls-copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Ftest%2Fui%2Fcoherence-impls-copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence-impls-copy.stderr?ref=fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "patch": "@@ -1,35 +1,61 @@\n-error[E0206]: the trait `Copy` may not be implemented for this type\n-  --> $DIR/coherence-impls-copy.rs:29:15\n+error[E0119]: conflicting implementations of trait `std::marker::Copy` for type `i32`:\n+  --> $DIR/coherence-impls-copy.rs:15:1\n    |\n-LL | impl Copy for &'static mut MyType {}\n-   |               ^^^^^^^^^^^^^^^^^^^ type is not a structure or enumeration\n+LL | impl Copy for i32 {}\n+   | ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: conflicting implementation in crate `core`:\n+           - impl std::marker::Copy for i32;\n+\n+error[E0119]: conflicting implementations of trait `std::marker::Copy` for type `&NotSync`:\n+  --> $DIR/coherence-impls-copy.rs:41:1\n+   |\n+LL | impl Copy for &'static NotSync {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: conflicting implementation in crate `core`:\n+           - impl<'a, T> std::marker::Copy for &'a T\n+             where T: ?Sized;\n+\n+error[E0119]: conflicting implementations of trait `std::marker::Copy` for type `&[NotSync]`:\n+  --> $DIR/coherence-impls-copy.rs:48:1\n+   |\n+LL | impl Copy for &'static [NotSync] {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: conflicting implementation in crate `core`:\n+           - impl<'a, T> std::marker::Copy for &'a T\n+             where T: ?Sized;\n \n error[E0206]: the trait `Copy` may not be implemented for this type\n   --> $DIR/coherence-impls-copy.rs:33:15\n    |\n-LL | impl Copy for (MyType, MyType) {}\n-   |               ^^^^^^^^^^^^^^^^ type is not a structure or enumeration\n+LL | impl Copy for &'static mut MyType {}\n+   |               ^^^^^^^^^^^^^^^^^^^ type is not a structure or enumeration\n \n error[E0206]: the trait `Copy` may not be implemented for this type\n   --> $DIR/coherence-impls-copy.rs:37:15\n    |\n-LL | impl Copy for &'static NotSync {}\n+LL | impl Copy for (MyType, MyType) {}\n    |               ^^^^^^^^^^^^^^^^ type is not a structure or enumeration\n \n error[E0206]: the trait `Copy` may not be implemented for this type\n-  --> $DIR/coherence-impls-copy.rs:40:15\n+  --> $DIR/coherence-impls-copy.rs:44:15\n    |\n LL | impl Copy for [MyType] {}\n    |               ^^^^^^^^ type is not a structure or enumeration\n \n-error[E0206]: the trait `Copy` may not be implemented for this type\n-  --> $DIR/coherence-impls-copy.rs:44:15\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/coherence-impls-copy.rs:15:1\n    |\n-LL | impl Copy for &'static [NotSync] {}\n-   |               ^^^^^^^^^^^^^^^^^^ type is not a structure or enumeration\n+LL | impl Copy for i32 {}\n+   | ^^^^^^^^^^^^^^^^^ impl doesn't use types inside crate\n+   |\n+   = note: the impl does not reference any types defined in this crate\n+   = note: define and implement a trait or new type instead\n \n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-impls-copy.rs:33:1\n+  --> $DIR/coherence-impls-copy.rs:37:1\n    |\n LL | impl Copy for (MyType, MyType) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl doesn't use types inside crate\n@@ -38,7 +64,7 @@ LL | impl Copy for (MyType, MyType) {}\n    = note: define and implement a trait or new type instead\n \n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-impls-copy.rs:40:1\n+  --> $DIR/coherence-impls-copy.rs:44:1\n    |\n LL | impl Copy for [MyType] {}\n    | ^^^^^^^^^^^^^^^^^^^^^^ impl doesn't use types inside crate\n@@ -47,15 +73,15 @@ LL | impl Copy for [MyType] {}\n    = note: define and implement a trait or new type instead\n \n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-impls-copy.rs:44:1\n+  --> $DIR/coherence-impls-copy.rs:48:1\n    |\n LL | impl Copy for &'static [NotSync] {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl doesn't use types inside crate\n    |\n    = note: the impl does not reference any types defined in this crate\n    = note: define and implement a trait or new type instead\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 10 previous errors\n \n-Some errors occurred: E0117, E0206.\n+Some errors occurred: E0117, E0119, E0206.\n For more information about an error, try `rustc --explain E0117`."}, {"sha": "9b3d1b351ddd97a37c0394ad69660dfc48d4a44f", "filename": "src/test/ui/error-codes/E0206.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Ftest%2Fui%2Ferror-codes%2FE0206.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Ftest%2Fui%2Ferror-codes%2FE0206.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0206.rs?ref=fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type Foo = i32;\n+type Foo = [u8; 256];\n \n impl Copy for Foo { }\n //~^ ERROR the trait `Copy` may not be implemented for this type\n@@ -17,7 +17,7 @@ impl Copy for Foo { }\n #[derive(Copy, Clone)]\n struct Bar;\n \n-impl Copy for &'static Bar { }\n+impl Copy for &'static mut Bar { }\n //~^ ERROR the trait `Copy` may not be implemented for this type\n \n fn main() {"}, {"sha": "f2c23b0767af8728317e401d3642457f40c84766", "filename": "src/test/ui/error-codes/E0206.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Ftest%2Fui%2Ferror-codes%2FE0206.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be/src%2Ftest%2Fui%2Ferror-codes%2FE0206.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0206.stderr?ref=fb44b4c0eb1d344f84f7bb2c90f28e31a8a180be", "patch": "@@ -7,8 +7,8 @@ LL | impl Copy for Foo { }\n error[E0206]: the trait `Copy` may not be implemented for this type\n   --> $DIR/E0206.rs:20:15\n    |\n-LL | impl Copy for &'static Bar { }\n-   |               ^^^^^^^^^^^^ type is not a structure or enumeration\n+LL | impl Copy for &'static mut Bar { }\n+   |               ^^^^^^^^^^^^^^^^ type is not a structure or enumeration\n \n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> $DIR/E0206.rs:13:1"}]}