{"sha": "64ba7a31cbf2218c8f9e69aa778d1bfe332ab218", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0YmE3YTMxY2JmMjIxOGM4ZjllNjlhYTc3OGQxYmZlMzMyYWIyMTg=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-07T22:42:33Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-07T22:57:49Z"}, "message": "Touch up semaphores; add another test", "tree": {"sha": "6800c3b677016a6bbd30228ed6b2ab1e35b9d5f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6800c3b677016a6bbd30228ed6b2ab1e35b9d5f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64ba7a31cbf2218c8f9e69aa778d1bfe332ab218", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64ba7a31cbf2218c8f9e69aa778d1bfe332ab218", "html_url": "https://github.com/rust-lang/rust/commit/64ba7a31cbf2218c8f9e69aa778d1bfe332ab218", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64ba7a31cbf2218c8f9e69aa778d1bfe332ab218/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3f9e18b7acb64d905db4c76e483f5b555cb9188", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f9e18b7acb64d905db4c76e483f5b555cb9188", "html_url": "https://github.com/rust-lang/rust/commit/a3f9e18b7acb64d905db4c76e483f5b555cb9188"}], "stats": {"total": 60, "additions": 44, "deletions": 16}, "files": [{"sha": "3e1b85441e9abc667f3d5bd8e781172bacc6377b", "filename": "src/libcore/sync.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/64ba7a31cbf2218c8f9e69aa778d1bfe332ab218/src%2Flibcore%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ba7a31cbf2218c8f9e69aa778d1bfe332ab218/src%2Flibcore%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync.rs?ref=64ba7a31cbf2218c8f9e69aa778d1bfe332ab218", "patch": "@@ -17,19 +17,23 @@ type signal_end = pipes::chan<()>;\n type waitqueue = { head: pipes::port<signal_end>,\n                    tail: pipes::chan<signal_end> };\n \n-fn new_waiter() -> (signal_end, wait_end) { pipes::stream() }\n+fn waitqueue() -> waitqueue {\n+    let (tail, head) = pipes::stream();\n+    { head: head, tail: tail }\n+}\n \n-/// A counting semaphore.\n-enum semaphore = exclusive<{\n+/// A counting, blocking, bounded-waiting semaphore.\n+enum semaphore = exclusive<semaphore_inner>;\n+type semaphore_inner = {\n     mut count: int,\n     waiters:   waitqueue,\n-}>;\n+    //blocked:   waitqueue,\n+};\n \n /// Create a new semaphore with the specified count.\n fn new_semaphore(count: int) -> semaphore {\n-    let (tail, head) = pipes::stream();\n     semaphore(exclusive({ mut count: count,\n-                          waiters: { head: head, tail: tail } }))\n+                          waiters: waitqueue(), /* blocked: waitqueue() */ }))\n }\n \n impl semaphore for &semaphore {\n@@ -42,20 +46,21 @@ impl semaphore for &semaphore {\n      * Acquires a resource represented by the semaphore. Blocks if necessary\n      * until resource(s) become available.\n      */\n-    fn wait() {\n+    fn acquire() {\n         let mut waiter_nobe = none;\n         unsafe {\n             do (**self).with |state| {\n                 state.count -= 1;\n                 if state.count < 0 {\n-                    let (signal_end,wait_end) = new_waiter();\n+                    let (signal_end,wait_end) = pipes::stream();\n                     waiter_nobe = some(wait_end);\n                     // Enqueue ourself.\n                     state.waiters.tail.send(signal_end);\n                 }\n             }\n         }\n-        for 1000.times { task::yield(); }\n+        // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n+        /* for 1000.times { task::yield(); } */\n         // Need to wait outside the exclusive.\n         if waiter_nobe.is_some() {\n             let _ = option::unwrap(waiter_nobe).recv();\n@@ -66,7 +71,7 @@ impl semaphore for &semaphore {\n      * Release a held resource represented by the semaphore. Wakes a blocked\n      * contending task, if any exist.\n      */\n-    fn signal() {\n+    fn release() {\n         unsafe {\n             do (**self).with |state| {\n                 state.count += 1;\n@@ -85,7 +90,7 @@ impl semaphore for &semaphore {\n \n     /// Runs a function with ownership of one of the semaphore's resources.\n     fn access<U>(blk: fn() -> U) -> U {\n-        self.wait();\n+        self.acquire();\n         let _x = sem_release(self);\n         blk()\n     }\n@@ -95,7 +100,7 @@ impl semaphore for &semaphore {\n struct sem_release {\n     sem: &semaphore;\n     new(sem: &semaphore) { self.sem = sem; }\n-    drop { self.sem.signal(); }\n+    drop { self.sem.release(); }\n }\n \n #[cfg(test)]\n@@ -120,11 +125,11 @@ mod tests {\n         let s = ~new_semaphore(0);\n         let s2 = ~s.clone();\n         do task::spawn {\n-            s2.wait();\n+            s2.acquire();\n             c.send(());\n         }\n         for 10.times { task::yield(); }\n-        s.signal();\n+        s.release();\n         let _ = p.recv();\n \n         /* Parent waits and child signals */\n@@ -133,14 +138,16 @@ mod tests {\n         let s2 = ~s.clone();\n         do task::spawn {\n             for 10.times { task::yield(); }\n-            s2.signal();\n+            s2.release();\n             let _ = p.recv();\n         }\n-        s.wait();\n+        s.acquire();\n         c.send(());\n     }\n     #[test]\n     fn test_sem_mutual_exclusion() {\n+        // Unsafely achieve shared state, and do the textbook\n+        // \"load tmp <- ptr; inc tmp; store ptr <- tmp\" dance.\n         let (c,p) = pipes::stream();\n         let s = ~new_semaphore(1);\n         let s2 = ~s.clone();\n@@ -167,7 +174,28 @@ mod tests {\n         }\n     }\n     #[test]\n+    fn test_sem_multi_resource() {\n+        // Parent and child both get in the critical section at the same\n+        // time, and shake hands.\n+        let s = ~new_semaphore(2);\n+        let s2 = ~s.clone();\n+        let (c1,p1) = pipes::stream();\n+        let (c2,p2) = pipes::stream();\n+        do task::spawn {\n+            do s2.access {\n+                let _ = p2.recv();\n+                c1.send(());\n+            }\n+        }\n+        do s.access {\n+            c2.send(());\n+            let _ = p1.recv();\n+        }\n+    }\n+    #[test]\n     fn test_sem_runtime_friendly_blocking() {\n+        // Force the runtime to schedule two threads on the same sched_loop.\n+        // When one blocks, it should schedule the other one.\n         do task::spawn_sched(task::manual_threads(1)) {\n             let s = ~new_semaphore(1);\n             let s2 = ~s.clone();"}]}