{"sha": "6b756c4b4a0f632e537cdfd2c0ac63cea357c8ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiNzU2YzRiNGEwZjYzMmU1MzdjZGZkMmMwYWM2M2NlYTM1N2M4YWQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-11T00:11:16Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-11T00:11:24Z"}, "message": "Update docs to describe kinds rather than layers, remove old terms.", "tree": {"sha": "32ab9f07d7e631f6ea6468ee872252dcf4f61ab6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32ab9f07d7e631f6ea6468ee872252dcf4f61ab6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b756c4b4a0f632e537cdfd2c0ac63cea357c8ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b756c4b4a0f632e537cdfd2c0ac63cea357c8ad", "html_url": "https://github.com/rust-lang/rust/commit/6b756c4b4a0f632e537cdfd2c0ac63cea357c8ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b756c4b4a0f632e537cdfd2c0ac63cea357c8ad/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0daa4fb1c42c26b7b958e15b31e634f73215e4ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/0daa4fb1c42c26b7b958e15b31e634f73215e4ff", "html_url": "https://github.com/rust-lang/rust/commit/0daa4fb1c42c26b7b958e15b31e634f73215e4ff"}], "stats": {"total": 73, "additions": 28, "deletions": 45}, "files": [{"sha": "920fb10322f82b20efc5c5714578661e16ebf1a3", "filename": "doc/rust.texi", "status": "modified", "additions": 28, "deletions": 45, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6b756c4b4a0f632e537cdfd2c0ac63cea357c8ad/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/6b756c4b4a0f632e537cdfd2c0ac63cea357c8ad/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=6b756c4b4a0f632e537cdfd2c0ac63cea357c8ad", "patch": "@@ -351,7 +351,7 @@ Rust has a lightweight object system based on structural object types: there\n is no ``class hierarchy'' nor any concept of inheritance. Method overriding\n and object restriction are performed explicitly on object values, which are\n little more than order-insensitive records of methods sharing a common private\n-value. Objects that reside outside the GC layer can have destructors.\n+value.\n \n @sp 1\n @item Dynamic type\n@@ -395,32 +395,16 @@ can designate other tasks to handle signals for them. This permits\n organizing tasks into mutually-supervising or mutually-failing groups.\n \n @sp 1\n-@item Deterministic destruction\n-\n-Non-GC objects can have destructor functions, which are executed\n-deterministically in top-down ownership order, as control frames are exited\n-and/or objects are otherwise freed from data structures holding them. The same\n-destructors are run in the same order whether the object is deleted by\n-unwinding during failure or normal execution.\n-\n-Similarly, the rules for freeing non-GC values are deterministic and\n-predictable: on scope-exit or structure-release, local slots are released\n-immediately. Referenced boxes have their reference count decreased and are\n-released if the count drops to zero. Aliases are silently forgotten.\n-\n-GC values are local to a task, and are subject to per-task garbage\n-collection. As a result, unreferenced GC-layer boxes are not necessarily freed\n-immediately; if an unreferenced GC box is part of an acyclic graph, it is\n-freed when the last reference to it drops, but if it is part of a reference\n-cycle it will be freed when the GC collects it (or when the owning task\n-terminates, at the latest).\n-\n-GC values can point to non-GC values but not vice-versa. Doing so merely\n-delays (to an undefined future time) the moment when the deterministic,\n-top-down destruction sequence for the referenced non-GC values\n-@emph{start}. In other words, the non-GC ``leaves'' of a GC value are released\n-in a locally-predictable order, even if the ``interior'' cyclic part of the GC\n-value is released in an unpredictable order.\n+@item Resource types with deterministic destruction\n+\n+Rust includes a type constructor for @emph{resource} types, which have an\n+associated destructor and cannot be moved in memory. Resources types belong to\n+the kind of @emph{pinned} types, and any value that directly contains a\n+resource is implicitly pinned as well.\n+\n+Resources can only contain types from the pinned or unique kinds of type,\n+which means that unlike finalizers, there is always a deterministic, top-down\n+order to run the destructors of a resource and its sub-resources.\n \n @sp 1\n @item Typestate system\n@@ -662,10 +646,7 @@ The keywords are:\n @tab @code{import}\n @tab @code{export}\n @tab @code{let}\n-@item @code{state}\n-@tab @code{gc}\n @tab @code{const}\n-@tab @code{thread}\n @item @code{auth}\n @tab @code{unsafe}\n @tab @code{as}\n@@ -699,7 +680,7 @@ The keywords are:\n @tab @code{iter}\n @tab @code{pred}\n @tab @code{obj}\n-@tab @code{drop}\n+@tab @code{resource}\n @item @code{task}\n @tab @code{port}\n @tab @code{chan}\n@@ -1975,13 +1956,15 @@ aspects of a value include:\n @item Whether the value represents textual or numerical information.\n @item Whether the value represents integral or floating-point information.\n @item The sequence of memory operations required to access the value.\n-@item The storage layer the value resides in (immutable, state or gc).\n+@item The @emph{kind} of the type (pinned, unique or shared).\n @end itemize\n \n For example, the type @code{@{x: u8, y: u8@}} defines the set of immutable\n values that are composite records, each containing two unsigned 8-bit integers\n accessed through the components @code{x} and @code{y}, and laid out in memory\n-with the @code{x} component preceding the @code{y} component.\n+with the @code{x} component preceding the @code{y} component. This type is of\n+@emph{unique} kind, meaning that there is no shared substructure with other\n+types, but it can be copied and moved freely.\n \n @node       Ref.Item.Tag\n @subsection Ref.Item.Tag\n@@ -2269,10 +2252,9 @@ assert (p._1 == \"world\");\n @cindex Vector types\n @cindex Array types, see @i{Vector types}\n \n-The vector type-constructor represents a homogeneous array of\n-values of a given type. A vector has a fixed size. The layer of a vector type\n-is to the layer of its member type, like any type that contains a single\n-member type.\n+The vector type-constructor represents a homogeneous array of values of a\n+given type. A vector has a fixed size. The kind of a vector type depends on\n+the kind of its member type, as with other simple structural types.\n \n Vectors can be sliced. A slice expression builds a new vector by copying a\n contiguous range -- given by a pair of indices representing a half-open\n@@ -2378,8 +2360,8 @@ Ports are modeled as stateful native types, with built-in meaning to the\n language. They cannot be transmitted over channels or otherwise replicated,\n and are always local to the task that creates them.\n \n-Ports (like channels) can only be carry types of the immutable layer. No\n-mutable values can pass over a port or channel.\n+Ports (like channels) can only be carry types of unique kind. No shared or\n+pinned values can pass over a port or channel.\n \n An example of a @code{port} type:\n @example\n@@ -2404,8 +2386,8 @@ Channels are immutable, and can be transmitted over channels to other\n tasks. They are modeled as immutable native types with built-in meaning to the\n language.\n \n-Channels (like ports) can only be carry types of the immutable layer. No\n-mutable values can pass over a port or channel.\n+Channels (like ports) can only be carry types of unique kind. No\n+pinned or shared values can pass over a port or channel.\n \n When a task sends a message into a channel, the task forms an outgoing queue\n associated with that channel. The per-task queue @emph{associated} with a\n@@ -2465,20 +2447,21 @@ declaration. Such a ``plain'' object type can be used to describe an interface\n that a variety of particular objects may conform to, by supporting a superset\n of the methods.\n \n-An object type that can contain fields of a given layer must be declared as\n-residing in that layer (or lower), like any other type.\n+The kind of an object type serves as a restriction to the kinds of fields that\n+may be stored in it. Unique objects, for example, can only carry unique values\n+in their fields.\n \n An example of an object type with two separate object items supporting it, and\n a client function using both items via the object type:\n \n @example\n \n-state type taker =\n+type taker =\n     state obj @{\n         fn take(int);\n     @};\n \n-state obj adder(mutable int x) @{\n+obj adder(mutable int x) @{\n     fn take(int y) @{\n         x += y;\n     @}"}]}