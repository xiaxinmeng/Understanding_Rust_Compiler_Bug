{"sha": "655eed35b7ca7cae08f21ead6151b9dfb69794ff", "node_id": "C_kwDOAAsO6NoAKDY1NWVlZDM1YjdjYTdjYWUwOGYyMWVhZDYxNTFiOWRmYjY5Nzk0ZmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-22T21:39:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-22T21:39:41Z"}, "message": "Auto merge of #2248 - RalfJung:arc-drop-fix, r=RalfJung\n\ndo not protect SRW items\n\nThis is the Miri version of https://github.com/rust-lang/rust/pull/98017.", "tree": {"sha": "302419ac9fb3ef9f80e07a97e2a240968810151f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/302419ac9fb3ef9f80e07a97e2a240968810151f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/655eed35b7ca7cae08f21ead6151b9dfb69794ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/655eed35b7ca7cae08f21ead6151b9dfb69794ff", "html_url": "https://github.com/rust-lang/rust/commit/655eed35b7ca7cae08f21ead6151b9dfb69794ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/655eed35b7ca7cae08f21ead6151b9dfb69794ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35023f50c05896b703dc736b2dc56f7a776a095e", "url": "https://api.github.com/repos/rust-lang/rust/commits/35023f50c05896b703dc736b2dc56f7a776a095e", "html_url": "https://github.com/rust-lang/rust/commit/35023f50c05896b703dc736b2dc56f7a776a095e"}, {"sha": "1b214a0d128779a03accff4e9426edb7c570082c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b214a0d128779a03accff4e9426edb7c570082c", "html_url": "https://github.com/rust-lang/rust/commit/1b214a0d128779a03accff4e9426edb7c570082c"}], "stats": {"total": 191, "additions": 102, "deletions": 89}, "files": [{"sha": "0c537e0d7a5c66b0ff7515246c8f0d783e776eaf", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/655eed35b7ca7cae08f21ead6151b9dfb69794ff/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655eed35b7ca7cae08f21ead6151b9dfb69794ff/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=655eed35b7ca7cae08f21ead6151b9dfb69794ff", "patch": "@@ -821,6 +821,13 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     } else {\n                         Permission::SharedReadWrite\n                     };\n+                    let protector = if frozen {\n+                        protector\n+                    } else {\n+                        // We do not protect inside UnsafeCell.\n+                        // This fixes https://github.com/rust-lang/rust/issues/55005.\n+                        None\n+                    };\n                     let item = Item { perm, tag: new_tag, protector };\n                     let mut global = this.machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n                     stacked_borrows.for_each(range, |offset, stack, history| {"}, {"sha": "9c0c59d364f28fe1bd6b073a82fee8d1a51586d7", "filename": "tests/fail/stacked_borrows/deallocate_against_barrier2.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35023f50c05896b703dc736b2dc56f7a776a095e/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35023f50c05896b703dc736b2dc56f7a776a095e/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.rs?ref=35023f50c05896b703dc736b2dc56f7a776a095e", "patch": "@@ -1,17 +0,0 @@\n-// error-pattern: deallocating while item is protected\n-\n-use std::cell::Cell;\n-\n-// Check that even `&Cell` are dereferenceable.\n-// Also see <https://github.com/rust-lang/rust/issues/55005>.\n-fn inner(x: &Cell<i32>, f: fn(&Cell<i32>)) {\n-    // `f` may mutate, but it may not deallocate!\n-    f(x)\n-}\n-\n-fn main() {\n-    inner(Box::leak(Box::new(Cell::new(0))), |x| {\n-        let raw = x as *const _ as *mut Cell<i32>;\n-        drop(unsafe { Box::from_raw(raw) });\n-    });\n-}"}, {"sha": "088daec040fec0dad6bfd45be7fa9ca517c86fd1", "filename": "tests/fail/stacked_borrows/deallocate_against_barrier2.stderr", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/35023f50c05896b703dc736b2dc56f7a776a095e/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/35023f50c05896b703dc736b2dc56f7a776a095e/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.stderr?ref=35023f50c05896b703dc736b2dc56f7a776a095e", "patch": "@@ -1,38 +0,0 @@\n-error: Undefined Behavior: deallocating while item is protected: [SharedReadWrite for <TAG> (call ID)]\n-  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   |\n-LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item is protected: [SharedReadWrite for <TAG> (call ID)]\n-   |\n-   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n-   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-           \n-   = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   = note: inside `<std::alloc::Global as std::alloc::Allocator>::deallocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   = note: inside `alloc::alloc::box_free::<std::cell::Cell<i32>, std::alloc::Global>` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   = note: inside `std::ptr::drop_in_place::<std::boxed::Box<std::cell::Cell<i32>>> - shim(Some(std::boxed::Box<std::cell::Cell<i32>>))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n-   = note: inside `std::mem::drop::<std::boxed::Box<std::cell::Cell<i32>>>` at RUSTLIB/core/src/mem/mod.rs:LL:CC\n-note: inside closure at $DIR/deallocate_against_barrier2.rs:LL:CC\n-  --> $DIR/deallocate_against_barrier2.rs:LL:CC\n-   |\n-LL |         drop(unsafe { Box::from_raw(raw) });\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: inside `<[closure@$DIR/deallocate_against_barrier2.rs:LL:CC] as std::ops::FnOnce<(&std::cell::Cell<i32>,)>>::call_once - shim` at RUSTLIB/core/src/ops/function.rs:LL:CC\n-note: inside `inner` at $DIR/deallocate_against_barrier2.rs:LL:CC\n-  --> $DIR/deallocate_against_barrier2.rs:LL:CC\n-   |\n-LL |     f(x)\n-   |     ^^^^\n-note: inside `main` at $DIR/deallocate_against_barrier2.rs:LL:CC\n-  --> $DIR/deallocate_against_barrier2.rs:LL:CC\n-   |\n-LL | /     inner(Box::leak(Box::new(Cell::new(0))), |x| {\n-LL | |         let raw = x as *const _ as *mut Cell<i32>;\n-LL | |         drop(unsafe { Box::from_raw(raw) });\n-LL | |     });\n-   | |______^\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}, {"sha": "b5192cd4214098ff3685c2e300a503181d5851ce", "filename": "tests/pass/0concurrency_arc_drop.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/655eed35b7ca7cae08f21ead6151b9dfb69794ff/tests%2Fpass%2F0concurrency_arc_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655eed35b7ca7cae08f21ead6151b9dfb69794ff/tests%2Fpass%2F0concurrency_arc_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2F0concurrency_arc_drop.rs?ref=655eed35b7ca7cae08f21ead6151b9dfb69794ff", "patch": "@@ -0,0 +1,19 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+use std::sync::Arc;\n+use std::thread;\n+\n+/// Test for Arc::drop bug (https://github.com/rust-lang/rust/issues/55005)\n+fn main() {\n+    // The bug seems to take up to 700 iterations to reproduce with most seeds (tested 0-9).\n+    for _ in 0..700 {\n+        let arc_1 = Arc::new(());\n+        let arc_2 = arc_1.clone();\n+        let thread = thread::spawn(|| drop(arc_2));\n+        let mut i = 0;\n+        while i < 256 {\n+            i += 1;\n+        }\n+        drop(arc_1);\n+        thread.join().unwrap();\n+    }\n+}"}, {"sha": "d4680130e7fb869e142540bc0f70c6b15aaf6742", "filename": "tests/pass/0weak_memory_consistency.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655eed35b7ca7cae08f21ead6151b9dfb69794ff/tests%2Fpass%2F0weak_memory_consistency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655eed35b7ca7cae08f21ead6151b9dfb69794ff/tests%2Fpass%2F0weak_memory_consistency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2F0weak_memory_consistency.rs?ref=655eed35b7ca7cae08f21ead6151b9dfb69794ff", "patch": "@@ -217,7 +217,7 @@ fn test_single_thread() {\n }\n \n pub fn main() {\n-    for _ in 0..50 {\n+    for _ in 0..75 {\n         test_single_thread();\n         test_mixed_access();\n         test_load_buffering_acq_rel();"}, {"sha": "5b7805ba2265118348ed1ac9b86d61bea3075fae", "filename": "tests/pass/concurrency/sync.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/655eed35b7ca7cae08f21ead6151b9dfb69794ff/tests%2Fpass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655eed35b7ca7cae08f21ead6151b9dfb69794ff/tests%2Fpass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fsync.rs?ref=655eed35b7ca7cae08f21ead6151b9dfb69794ff", "patch": "@@ -1,6 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// We are making scheduler assumptions here.\n-// compile-flags: -Zmiri-disable-isolation -Zmiri-strict-provenance -Zmiri-preemption-rate=0\n+// compile-flags: -Zmiri-disable-isolation -Zmiri-strict-provenance\n \n use std::sync::{Arc, Barrier, Condvar, Mutex, Once, RwLock};\n use std::thread;\n@@ -53,35 +52,6 @@ fn check_conditional_variables_notify_one() {\n     }\n }\n \n-fn check_conditional_variables_notify_all() {\n-    let pair = Arc::new(((Mutex::new(())), Condvar::new()));\n-\n-    // Spawn threads and block them on the conditional variable.\n-    let handles: Vec<_> = (0..5)\n-        .map(|_| {\n-            let pair2 = pair.clone();\n-            thread::spawn(move || {\n-                let (lock, cvar) = &*pair2;\n-                let guard = lock.lock().unwrap();\n-                // Block waiting on the conditional variable.\n-                let _ = cvar.wait(guard).unwrap();\n-            })\n-        })\n-        .inspect(|_| {\n-            thread::yield_now();\n-            thread::yield_now();\n-        })\n-        .collect();\n-\n-    let (_, cvar) = &*pair;\n-    // Unblock all threads.\n-    cvar.notify_all();\n-\n-    for handle in handles {\n-        handle.join().unwrap();\n-    }\n-}\n-\n /// Test that waiting on a conditional variable with a timeout does not\n /// deadlock.\n fn check_conditional_variables_timed_wait_timeout() {\n@@ -301,7 +271,6 @@ fn check_condvar() {\n fn main() {\n     check_barriers();\n     check_conditional_variables_notify_one();\n-    check_conditional_variables_notify_all();\n     check_conditional_variables_timed_wait_timeout();\n     check_conditional_variables_timed_wait_notimeout();\n     check_mutex();"}, {"sha": "38dbeb575d641341e7dc136ff8c95b2c424a052a", "filename": "tests/pass/concurrency/sync_nopreempt.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/655eed35b7ca7cae08f21ead6151b9dfb69794ff/tests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655eed35b7ca7cae08f21ead6151b9dfb69794ff/tests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs?ref=655eed35b7ca7cae08f21ead6151b9dfb69794ff", "patch": "@@ -0,0 +1,40 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// We are making scheduler assumptions here.\n+// compile-flags: -Zmiri-strict-provenance -Zmiri-preemption-rate=0\n+\n+use std::sync::{Condvar, Mutex, Arc};\n+use std::thread;\n+\n+fn check_conditional_variables_notify_all() {\n+    let pair = Arc::new(((Mutex::new(())), Condvar::new()));\n+\n+    // Spawn threads and block them on the conditional variable.\n+    let handles: Vec<_> = (0..5)\n+        .map(|_| {\n+            let pair2 = pair.clone();\n+            thread::spawn(move || {\n+                let (lock, cvar) = &*pair2;\n+                let guard = lock.lock().unwrap();\n+                // Block waiting on the conditional variable.\n+                let _ = cvar.wait(guard).unwrap();\n+            })\n+        })\n+        .inspect(|_| {\n+            // Ensure the other threads all run and block on the `wait`.\n+            thread::yield_now();\n+            thread::yield_now();\n+        })\n+        .collect();\n+\n+    let (_, cvar) = &*pair;\n+    // Unblock all threads.\n+    cvar.notify_all();\n+\n+    for handle in handles {\n+        handle.join().unwrap();\n+    }\n+}\n+\n+fn main() {\n+    check_conditional_variables_notify_all();\n+}"}, {"sha": "9ee8af45aefe9a0ae24bc8c97da0149a348b2dc0", "filename": "tests/pass/stacked-borrows/interior_mutability.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/655eed35b7ca7cae08f21ead6151b9dfb69794ff/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655eed35b7ca7cae08f21ead6151b9dfb69794ff/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs?ref=655eed35b7ca7cae08f21ead6151b9dfb69794ff", "patch": "@@ -1,11 +1,14 @@\n+// compile-flags: -Zmiri-tag-raw-pointers\n use std::cell::{Cell, RefCell, UnsafeCell};\n-use std::mem::MaybeUninit;\n+use std::mem::{self, MaybeUninit};\n \n fn main() {\n     aliasing_mut_and_shr();\n     aliasing_frz_and_shr();\n     into_interior_mutability();\n     unsafe_cell_2phase();\n+    unsafe_cell_deallocate();\n+    unsafe_cell_invalidate();\n }\n \n fn aliasing_mut_and_shr() {\n@@ -67,3 +70,33 @@ fn unsafe_cell_2phase() {\n         let _val = (*x2.get()).get(0);\n     }\n }\n+\n+/// Make sure we can deallocate an UnsafeCell that was passed to an active fn call.\n+/// (This is the fix for https://github.com/rust-lang/rust/issues/55005.)\n+fn unsafe_cell_deallocate() {\n+    fn f(x: &UnsafeCell<i32>) {\n+        let b: Box<i32> = unsafe { Box::from_raw(x as *const _ as *mut i32) };\n+        drop(b)\n+    }\n+\n+    let b = Box::new(0i32);\n+    f(unsafe { mem::transmute(Box::into_raw(b)) });\n+}\n+\n+/// As a side-effect of the above, we also allow this -- at least for now.\n+fn unsafe_cell_invalidate() {\n+    fn f(_x: &UnsafeCell<i32>, y: *mut i32) {\n+        // Writing to y invalidates x, but that is okay.\n+        unsafe {\n+            *y += 1;\n+        }\n+    }\n+\n+    let mut x = 0i32;\n+    let raw1 = &mut x as *mut _;\n+    let ref1 = unsafe { &mut *raw1 };\n+    let raw2 = ref1 as *mut _;\n+    // Now the borrow stack is: raw1, ref2, raw2.\n+    // So using raw1 invalidates raw2.\n+    f(unsafe { mem::transmute(raw2) }, raw1);\n+}"}]}