{"sha": "090767b5ef59188e5defb466ff6580b99891f1ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MDc2N2I1ZWY1OTE4OGU1ZGVmYjQ2NmZmNjU4MGI5OTg5MWYxZWQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-03-16T17:17:18Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-03-22T16:07:19Z"}, "message": "Allocate numerical values of DefIndexes from two seperate ranges.\n\nThis way we can have all item-likes occupy a dense range of\nDefIndexes, which is good for making fast, array-based\ndictionaries.", "tree": {"sha": "a25ab66b9efb89f7d656151d532ced74e0ddd380", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a25ab66b9efb89f7d656151d532ced74e0ddd380"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/090767b5ef59188e5defb466ff6580b99891f1ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/090767b5ef59188e5defb466ff6580b99891f1ed", "html_url": "https://github.com/rust-lang/rust/commit/090767b5ef59188e5defb466ff6580b99891f1ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/090767b5ef59188e5defb466ff6580b99891f1ed/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc259ee844f608599293c83d96de353005681cca", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc259ee844f608599293c83d96de353005681cca", "html_url": "https://github.com/rust-lang/rust/commit/bc259ee844f608599293c83d96de353005681cca"}], "stats": {"total": 309, "additions": 237, "deletions": 72}, "files": [{"sha": "a6b18ac10a79074bb35d0c3e39a5c590fce391f5", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/090767b5ef59188e5defb466ff6580b99891f1ed/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090767b5ef59188e5defb466ff6580b99891f1ed/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=090767b5ef59188e5defb466ff6580b99891f1ed", "patch": "@@ -78,33 +78,86 @@ impl serialize::UseSpecializedDecodable for CrateNum {\n /// A DefIndex is an index into the hir-map for a crate, identifying a\n /// particular definition. It should really be considered an interned\n /// shorthand for a particular DefPath.\n+///\n+/// At the moment we are allocating the numerical values of DefIndexes into two\n+/// ranges: the \"low\" range (starting at zero) and the \"high\" range (starting at\n+/// DEF_INDEX_HI_START). This allows us to allocate the DefIndexes of all\n+/// item-likes (Items, TraitItems, and ImplItems) into one of these ranges and\n+/// consequently use a simple array for lookup tables keyed by DefIndex and\n+/// known to be densely populated. This is especially important for the HIR map.\n+///\n+/// Since the DefIndex is mostly treated as an opaque ID, you probably\n+/// don't have to care about these ranges.\n #[derive(Clone, Debug, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n            RustcDecodable, Hash, Copy)]\n pub struct DefIndex(u32);\n \n impl DefIndex {\n+    #[inline]\n     pub fn new(x: usize) -> DefIndex {\n         assert!(x < (u32::MAX as usize));\n         DefIndex(x as u32)\n     }\n \n+    #[inline]\n     pub fn from_u32(x: u32) -> DefIndex {\n         DefIndex(x)\n     }\n \n+    #[inline]\n     pub fn as_usize(&self) -> usize {\n         self.0 as usize\n     }\n \n+    #[inline]\n     pub fn as_u32(&self) -> u32 {\n         self.0\n     }\n+\n+    #[inline]\n+    pub fn address_space(&self) -> DefIndexAddressSpace {\n+        if self.0 < DEF_INDEX_HI_START.0 {\n+            DefIndexAddressSpace::Low\n+        } else {\n+            DefIndexAddressSpace::High\n+        }\n+    }\n+\n+    /// Converts this DefIndex into a zero-based array index.\n+    /// This index is the offset within the given \"range\" of the DefIndex,\n+    /// that is, if the DefIndex is part of the \"high\" range, the resulting\n+    /// index will be (DefIndex - DEF_INDEX_HI_START).\n+    #[inline]\n+    pub fn as_array_index(&self) -> usize {\n+        (self.0 & !DEF_INDEX_HI_START.0) as usize\n+    }\n }\n \n+/// The start of the \"high\" range of DefIndexes.\n+const DEF_INDEX_HI_START: DefIndex = DefIndex(1 << 31);\n+\n /// The crate root is always assigned index 0 by the AST Map code,\n /// thanks to `NodeCollector::new`.\n pub const CRATE_DEF_INDEX: DefIndex = DefIndex(0);\n \n+#[derive(Copy, Clone, Eq, PartialEq, Hash)]\n+pub enum DefIndexAddressSpace {\n+    Low = 0,\n+    High = 1,\n+}\n+\n+impl DefIndexAddressSpace {\n+    #[inline]\n+    pub fn index(&self) -> usize {\n+        *self as usize\n+    }\n+\n+    #[inline]\n+    pub fn start(&self) -> usize {\n+        self.index() * DEF_INDEX_HI_START.as_usize()\n+    }\n+}\n+\n /// A DefId identifies a particular *definition*, by combining a crate\n /// index and a def index.\n #[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable, RustcDecodable, Hash, Copy)]"}, {"sha": "2ac1a036f99e1a996a85f60c1f653c0693474181", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/090767b5ef59188e5defb466ff6580b99891f1ed/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090767b5ef59188e5defb466ff6580b99891f1ed/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=090767b5ef59188e5defb466ff6580b99891f1ed", "patch": "@@ -41,7 +41,7 @@\n // in the HIR, especially for multiple identifiers.\n \n use hir;\n-use hir::map::{Definitions, DefKey};\n+use hir::map::{Definitions, DefKey, REGULAR_SPACE};\n use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId, CRATE_DEF_INDEX};\n use hir::def::{Def, PathResolution};\n@@ -2711,7 +2711,10 @@ impl<'a> LoweringContext<'a> {\n         let def_id = {\n             let defs = self.resolver.definitions();\n             let def_path_data = DefPathData::Binding(name.as_str());\n-            let def_index = defs.create_def_with_parent(parent_def, id, def_path_data);\n+            let def_index = defs.create_def_with_parent(parent_def,\n+                                                        id,\n+                                                        def_path_data,\n+                                                        REGULAR_SPACE);\n             DefId::local(def_index)\n         };\n "}, {"sha": "cae358a303e028ea17a60d9a7745d30de4af558b", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 46, "deletions": 21, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/090767b5ef59188e5defb466ff6580b99891f1ed/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090767b5ef59188e5defb466ff6580b99891f1ed/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=090767b5ef59188e5defb466ff6580b99891f1ed", "patch": "@@ -9,13 +9,15 @@\n // except according to those terms.\n \n use hir::map::definitions::*;\n-use hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n+use hir::def_id::{CRATE_DEF_INDEX, DefIndex, DefIndexAddressSpace};\n \n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n use syntax::visit;\n use syntax::symbol::{Symbol, keywords};\n \n+use hir::map::{ITEM_LIKE_SPACE, REGULAR_SPACE};\n+\n /// Creates def ids for nodes in the AST.\n pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n@@ -39,23 +41,31 @@ impl<'a> DefCollector<'a> {\n     }\n \n     pub fn collect_root(&mut self) {\n-        let root = self.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n+        let root = self.create_def_with_parent(None,\n+                                               CRATE_NODE_ID,\n+                                               DefPathData::CrateRoot,\n+                                               ITEM_LIKE_SPACE);\n         assert_eq!(root, CRATE_DEF_INDEX);\n         self.parent_def = Some(root);\n     }\n \n-    fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n+    fn create_def(&mut self,\n+                  node_id: NodeId,\n+                  data: DefPathData,\n+                  address_space: DefIndexAddressSpace)\n+                  -> DefIndex {\n         let parent_def = self.parent_def;\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n-        self.definitions.create_def_with_parent(parent_def, node_id, data)\n+        self.definitions.create_def_with_parent(parent_def, node_id, data, address_space)\n     }\n \n     fn create_def_with_parent(&mut self,\n                               parent: Option<DefIndex>,\n                               node_id: NodeId,\n-                              data: DefPathData)\n+                              data: DefPathData,\n+                              address_space: DefIndexAddressSpace)\n                               -> DefIndex {\n-        self.definitions.create_def_with_parent(parent, node_id, data)\n+        self.definitions.create_def_with_parent(parent, node_id, data, address_space)\n     }\n \n     pub fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n@@ -76,7 +86,7 @@ impl<'a> DefCollector<'a> {\n             _ => {}\n         }\n \n-        self.create_def(expr.id, DefPathData::Initializer);\n+        self.create_def(expr.id, DefPathData::Initializer, REGULAR_SPACE);\n     }\n \n     fn visit_macro_invoc(&mut self, id: NodeId, const_expr: bool) {\n@@ -118,27 +128,32 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     ViewPathSimple(..) => {}\n                     ViewPathList(_, ref imports) => {\n                         for import in imports {\n-                            self.create_def(import.node.id, DefPathData::Misc);\n+                            self.create_def(import.node.id,\n+                                            DefPathData::Misc,\n+                                            ITEM_LIKE_SPACE);\n                         }\n                     }\n                 }\n                 DefPathData::Misc\n             }\n         };\n-        let def = self.create_def(i.id, def_data);\n+        let def = self.create_def(i.id, def_data, ITEM_LIKE_SPACE);\n \n         self.with_parent(def, |this| {\n             match i.node {\n                 ItemKind::Enum(ref enum_definition, _) => {\n                     for v in &enum_definition.variants {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.name.name.as_str()));\n+                                            DefPathData::EnumVariant(v.node.name.name.as_str()),\n+                                            REGULAR_SPACE);\n                         this.with_parent(variant_def_index, |this| {\n                             for (index, field) in v.node.data.fields().iter().enumerate() {\n                                 let name = field.ident.map(|ident| ident.name)\n                                     .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n-                                this.create_def(field.id, DefPathData::Field(name.as_str()));\n+                                this.create_def(field.id,\n+                                                DefPathData::Field(name.as_str()),\n+                                                REGULAR_SPACE);\n                             }\n \n                             if let Some(ref expr) = v.node.disr_expr {\n@@ -151,13 +166,14 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     // If this is a tuple-like struct, register the constructor.\n                     if !struct_def.is_struct() {\n                         this.create_def(struct_def.id(),\n-                                        DefPathData::StructCtor);\n+                                        DefPathData::StructCtor,\n+                                        REGULAR_SPACE);\n                     }\n \n                     for (index, field) in struct_def.fields().iter().enumerate() {\n                         let name = field.ident.map(|ident| ident.name.as_str())\n                             .unwrap_or(Symbol::intern(&index.to_string()).as_str());\n-                        this.create_def(field.id, DefPathData::Field(name));\n+                        this.create_def(field.id, DefPathData::Field(name), REGULAR_SPACE);\n                     }\n                 }\n                 _ => {}\n@@ -168,7 +184,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n         let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.ident.name.as_str()));\n+                                  DefPathData::ValueNs(foreign_item.ident.name.as_str()),\n+                                  REGULAR_SPACE);\n \n         self.with_parent(def, |this| {\n             visit::walk_foreign_item(this, foreign_item);\n@@ -177,7 +194,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_generics(&mut self, generics: &'a Generics) {\n         for ty_param in generics.ty_params.iter() {\n-            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.ident.name.as_str()));\n+            self.create_def(ty_param.id,\n+                            DefPathData::TypeParam(ty_param.ident.name.as_str()),\n+                            REGULAR_SPACE);\n         }\n \n         visit::walk_generics(self, generics);\n@@ -191,7 +210,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id, false),\n         };\n \n-        let def = self.create_def(ti.id, def_data);\n+        let def = self.create_def(ti.id, def_data, ITEM_LIKE_SPACE);\n         self.with_parent(def, |this| {\n             if let TraitItemKind::Const(_, Some(ref expr)) = ti.node {\n                 this.visit_const_expr(expr);\n@@ -209,7 +228,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id, false),\n         };\n \n-        let def = self.create_def(ii.id, def_data);\n+        let def = self.create_def(ii.id, def_data, ITEM_LIKE_SPACE);\n         self.with_parent(def, |this| {\n             if let ImplItemKind::Const(_, ref expr) = ii.node {\n                 this.visit_const_expr(expr);\n@@ -225,7 +244,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         match pat.node {\n             PatKind::Mac(..) => return self.visit_macro_invoc(pat.id, false),\n             PatKind::Ident(_, id, _) => {\n-                let def = self.create_def(pat.id, DefPathData::Binding(id.node.name.as_str()));\n+                let def = self.create_def(pat.id,\n+                                          DefPathData::Binding(id.node.name.as_str()),\n+                                          REGULAR_SPACE);\n                 self.parent_def = Some(def);\n             }\n             _ => {}\n@@ -242,7 +263,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id, false),\n             ExprKind::Repeat(_, ref count) => self.visit_const_expr(count),\n             ExprKind::Closure(..) => {\n-                let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n+                let def = self.create_def(expr.id,\n+                                          DefPathData::ClosureExpr,\n+                                          REGULAR_SPACE);\n                 self.parent_def = Some(def);\n             }\n             _ => {}\n@@ -257,7 +280,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             TyKind::Mac(..) => return self.visit_macro_invoc(ty.id, false),\n             TyKind::Array(_, ref length) => self.visit_const_expr(length),\n             TyKind::ImplTrait(..) => {\n-                self.create_def(ty.id, DefPathData::ImplTrait);\n+                self.create_def(ty.id, DefPathData::ImplTrait, REGULAR_SPACE);\n             }\n             TyKind::Typeof(ref expr) => self.visit_const_expr(expr),\n             _ => {}\n@@ -266,7 +289,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_lifetime_def(&mut self, def: &'a LifetimeDef) {\n-        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name.as_str()));\n+        self.create_def(def.lifetime.id,\n+                        DefPathData::LifetimeDef(def.lifetime.name.as_str()),\n+                        REGULAR_SPACE);\n     }\n \n     fn visit_stmt(&mut self, stmt: &'a Stmt) {"}, {"sha": "809d5db3071d7be75607974035a056b28ef3c377", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 78, "deletions": 26, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/090767b5ef59188e5defb466ff6580b99891f1ed/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090767b5ef59188e5defb466ff6580b99891f1ed/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=090767b5ef59188e5defb466ff6580b99891f1ed", "patch": "@@ -15,7 +15,7 @@\n //! expressions) that are mostly just leftovers.\n \n use hir;\n-use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, DefIndexAddressSpace};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::StableHasher;\n@@ -31,24 +31,44 @@ use util::nodemap::NodeMap;\n /// Internally the DefPathTable holds a tree of DefKeys, where each DefKey\n /// stores the DefIndex of its parent.\n /// There is one DefPathTable for each crate.\n-#[derive(Clone)]\n pub struct DefPathTable {\n-    index_to_key: Vec<DefKey>,\n+    index_to_key: [Vec<DefKey>; 2],\n     key_to_index: FxHashMap<DefKey, DefIndex>,\n }\n \n+// Unfortunately we have to provide a manual impl of Clone because of the\n+// fixed-sized array field.\n+impl Clone for DefPathTable {\n+    fn clone(&self) -> Self {\n+        DefPathTable {\n+            index_to_key: [self.index_to_key[0].clone(),\n+                           self.index_to_key[1].clone()],\n+            key_to_index: self.key_to_index.clone(),\n+        }\n+    }\n+}\n+\n impl DefPathTable {\n-    fn insert(&mut self, key: DefKey) -> DefIndex {\n-        let index = DefIndex::new(self.index_to_key.len());\n-        debug!(\"DefPathTable::insert() - {:?} <-> {:?}\", key, index);\n-        self.index_to_key.push(key.clone());\n+\n+    fn allocate(&mut self,\n+                key: DefKey,\n+                address_space: DefIndexAddressSpace)\n+                -> DefIndex {\n+        let index = {\n+            let index_to_key = &mut self.index_to_key[address_space.index()];\n+            let index = DefIndex::new(index_to_key.len() + address_space.start());\n+            debug!(\"DefPathTable::insert() - {:?} <-> {:?}\", key, index);\n+            index_to_key.push(key.clone());\n+            index\n+        };\n         self.key_to_index.insert(key, index);\n         index\n     }\n \n     #[inline(always)]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.index_to_key[index.as_usize()].clone()\n+        self.index_to_key[index.address_space().index()]\n+                         [index.as_array_index()].clone()\n     }\n \n     #[inline(always)]\n@@ -96,17 +116,28 @@ impl DefPathTable {\n \n impl Encodable for DefPathTable {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.index_to_key.encode(s)\n+        self.index_to_key[DefIndexAddressSpace::Low.index()].encode(s)?;\n+        self.index_to_key[DefIndexAddressSpace::High.index()].encode(s)\n     }\n }\n \n impl Decodable for DefPathTable {\n     fn decode<D: Decoder>(d: &mut D) -> Result<DefPathTable, D::Error> {\n-        let index_to_key: Vec<DefKey> = Decodable::decode(d)?;\n-        let key_to_index = index_to_key.iter()\n-                                       .enumerate()\n-                                       .map(|(index, key)| (key.clone(), DefIndex::new(index)))\n-                                       .collect();\n+        let index_to_key_lo: Vec<DefKey> = Decodable::decode(d)?;\n+        let index_to_key_high: Vec<DefKey> = Decodable::decode(d)?;\n+\n+        let index_to_key = [index_to_key_lo, index_to_key_high];\n+\n+        let mut key_to_index = FxHashMap();\n+\n+        for space in &[DefIndexAddressSpace::Low, DefIndexAddressSpace::High] {\n+            key_to_index.extend(index_to_key[space.index()]\n+                .iter()\n+                .enumerate()\n+                .map(|(index, key)| (key.clone(),\n+                                     DefIndex::new(index + space.start()))))\n+        }\n+\n         Ok(DefPathTable {\n             index_to_key: index_to_key,\n             key_to_index: key_to_index,\n@@ -118,14 +149,29 @@ impl Decodable for DefPathTable {\n /// The definition table containing node definitions.\n /// It holds the DefPathTable for local DefIds/DefPaths and it also stores a\n /// mapping from NodeIds to local DefIds.\n-#[derive(Clone)]\n pub struct Definitions {\n     table: DefPathTable,\n     node_to_def_index: NodeMap<DefIndex>,\n-    def_index_to_node: Vec<ast::NodeId>,\n+    def_index_to_node: [Vec<ast::NodeId>; 2],\n     pub(super) node_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n }\n \n+// Unfortunately we have to provide a manual impl of Clone because of the\n+// fixed-sized array field.\n+impl Clone for Definitions {\n+    fn clone(&self) -> Self {\n+        Definitions {\n+            table: self.table.clone(),\n+            node_to_def_index: self.node_to_def_index.clone(),\n+            def_index_to_node: [\n+                self.def_index_to_node[0].clone(),\n+                self.def_index_to_node[1].clone(),\n+            ],\n+            node_to_hir_id: self.node_to_hir_id.clone(),\n+        }\n+    }\n+}\n+\n /// A unique identifier that we can use to lookup a definition\n /// precisely. It combines the index of the definition's parent (if\n /// any) with a `DisambiguatedDefPathData`.\n@@ -290,11 +336,11 @@ impl Definitions {\n     pub fn new() -> Definitions {\n         Definitions {\n             table: DefPathTable {\n-                index_to_key: vec![],\n+                index_to_key: [vec![], vec![]],\n                 key_to_index: FxHashMap(),\n             },\n             node_to_def_index: NodeMap(),\n-            def_index_to_node: vec![],\n+            def_index_to_node: [vec![], vec![]],\n             node_to_hir_id: IndexVec::new(),\n         }\n     }\n@@ -304,8 +350,9 @@ impl Definitions {\n     }\n \n     /// Get the number of definitions.\n-    pub fn len(&self) -> usize {\n-        self.def_index_to_node.len()\n+    pub fn def_index_counts_lo_hi(&self) -> (usize, usize) {\n+        (self.def_index_to_node[DefIndexAddressSpace::Low.index()].len(),\n+         self.def_index_to_node[DefIndexAddressSpace::High.index()].len())\n     }\n \n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n@@ -339,8 +386,9 @@ impl Definitions {\n \n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n-            assert!(def_id.index.as_usize() < self.def_index_to_node.len());\n-            Some(self.def_index_to_node[def_id.index.as_usize()])\n+            let space_index = def_id.index.address_space().index();\n+            let array_index = def_id.index.as_array_index();\n+            Some(self.def_index_to_node[space_index][array_index])\n         } else {\n             None\n         }\n@@ -350,7 +398,9 @@ impl Definitions {\n     pub fn create_def_with_parent(&mut self,\n                                   parent: Option<DefIndex>,\n                                   node_id: ast::NodeId,\n-                                  data: DefPathData)\n+                                  data: DefPathData,\n+                                  // is_owner: bool)\n+                                  address_space: DefIndexAddressSpace)\n                                   -> DefIndex {\n         debug!(\"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n                parent, node_id, data);\n@@ -380,11 +430,13 @@ impl Definitions {\n         debug!(\"create_def_with_parent: after disambiguation, key = {:?}\", key);\n \n         // Create the definition.\n-        let index = self.table.insert(key);\n+        let index = self.table.allocate(key, address_space);\n+        assert_eq!(index.as_array_index(),\n+                   self.def_index_to_node[address_space.index()].len());\n+        self.def_index_to_node[address_space.index()].push(node_id);\n+\n         debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n         self.node_to_def_index.insert(node_id, index);\n-        assert_eq!(index.as_usize(), self.def_index_to_node.len());\n-        self.def_index_to_node.push(node_id);\n \n         index\n     }"}, {"sha": "583b3b848f30d88a7e572cc713233555a265f594", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/090767b5ef59188e5defb466ff6580b99891f1ed/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090767b5ef59188e5defb466ff6580b99891f1ed/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=090767b5ef59188e5defb466ff6580b99891f1ed", "patch": "@@ -17,7 +17,7 @@ pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n \n use dep_graph::{DepGraph, DepNode};\n \n-use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n+use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex, DefIndexAddressSpace};\n \n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n@@ -38,6 +38,9 @@ mod def_collector;\n pub mod definitions;\n mod hir_id_validator;\n \n+pub const ITEM_LIKE_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::Low;\n+pub const REGULAR_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n+\n #[derive(Copy, Clone, Debug)]\n pub enum Node<'hir> {\n     NodeItem(&'hir Item),\n@@ -347,10 +350,6 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn num_local_def_ids(&self) -> usize {\n-        self.definitions.len()\n-    }\n-\n     pub fn definitions(&self) -> &Definitions {\n         &self.definitions\n     }"}, {"sha": "970a401177ba54e600e3b67aa5a7786717a0a4d3", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/090767b5ef59188e5defb466ff6580b99891f1ed/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090767b5ef59188e5defb466ff6580b99891f1ed/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=090767b5ef59188e5defb466ff6580b99891f1ed", "patch": "@@ -10,7 +10,7 @@\n \n use schema::*;\n \n-use rustc::hir::def_id::{DefId, DefIndex};\n+use rustc::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace};\n use std::io::{Cursor, Write};\n use std::slice;\n use std::u32;\n@@ -23,12 +23,15 @@ use std::u32;\n /// appropriate spot by calling `record_position`. We should never\n /// visit the same index twice.\n pub struct Index {\n-    positions: Vec<u32>,\n+    positions: [Vec<u32>; 2]\n }\n \n impl Index {\n-    pub fn new(max_index: usize) -> Index {\n-        Index { positions: vec![u32::MAX; max_index] }\n+    pub fn new((max_index_lo, max_index_hi): (usize, usize)) -> Index {\n+        Index {\n+            positions: [vec![u32::MAX; max_index_lo],\n+                        vec![u32::MAX; max_index_hi]],\n+        }\n     }\n \n     pub fn record(&mut self, def_id: DefId, entry: Lazy<Entry>) {\n@@ -37,24 +40,31 @@ impl Index {\n     }\n \n     pub fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry>) {\n-        let item = item.as_usize();\n-\n         assert!(entry.position < (u32::MAX as usize));\n         let position = entry.position as u32;\n+        let space_index = item.address_space().index();\n+        let array_index = item.as_array_index();\n \n-        assert!(self.positions[item] == u32::MAX,\n+        assert!(self.positions[space_index][array_index] == u32::MAX,\n                 \"recorded position for item {:?} twice, first at {:?} and now at {:?}\",\n                 item,\n-                self.positions[item],\n+                self.positions[space_index][array_index],\n                 position);\n \n-        self.positions[item] = position.to_le();\n+        self.positions[space_index][array_index] = position.to_le();\n     }\n \n     pub fn write_index(&self, buf: &mut Cursor<Vec<u8>>) -> LazySeq<Index> {\n         let pos = buf.position();\n-        buf.write_all(words_to_bytes(&self.positions)).unwrap();\n-        LazySeq::with_position_and_length(pos as usize, self.positions.len())\n+\n+        // First we write the length of the lower range ...\n+        buf.write_all(words_to_bytes(&[self.positions[0].len() as u32])).unwrap();\n+        // ... then the values in the lower range ...\n+        buf.write_all(words_to_bytes(&self.positions[0][..])).unwrap();\n+        // ... then the values in the higher range.\n+        buf.write_all(words_to_bytes(&self.positions[1][..])).unwrap();\n+        LazySeq::with_position_and_length(pos as usize,\n+            self.positions[0].len() + self.positions[1].len() + 1)\n     }\n }\n \n@@ -70,7 +80,18 @@ impl<'tcx> LazySeq<Index> {\n                index,\n                words.len());\n \n-        let position = u32::from_le(words[index].get());\n+        let positions = match def_index.address_space() {\n+            DefIndexAddressSpace::Low => &words[1..],\n+            DefIndexAddressSpace::High => {\n+                // This is a DefIndex in the higher range, so find out where\n+                // that starts:\n+                let lo_count = u32::from_le(words[0].get()) as usize;\n+                &words[lo_count + 1 .. ]\n+            }\n+        };\n+\n+        let array_index = def_index.as_array_index();\n+        let position = u32::from_le(positions[array_index].get());\n         if position == u32::MAX {\n             debug!(\"Index::lookup: position=u32::MAX\");\n             None\n@@ -84,14 +105,26 @@ impl<'tcx> LazySeq<Index> {\n                                bytes: &'a [u8])\n                                -> impl Iterator<Item = (DefIndex, Lazy<Entry<'tcx>>)> + 'a {\n         let words = &bytes_to_words(&bytes[self.position..])[..self.len];\n-        words.iter().map(|word| word.get()).enumerate().filter_map(|(index, position)| {\n-            if position == u32::MAX {\n+        let lo_count = u32::from_le(words[0].get()) as usize;\n+        let lo = &words[1 .. lo_count + 1];\n+        let hi = &words[1 + lo_count ..];\n+\n+        lo.iter().map(|word| word.get()).enumerate().filter_map(|(index, pos)| {\n+            if pos == u32::MAX {\n+                None\n+            } else {\n+                let pos = u32::from_le(pos) as usize;\n+                Some((DefIndex::new(index), Lazy::with_position(pos)))\n+            }\n+        }).chain(hi.iter().map(|word| word.get()).enumerate().filter_map(|(index, pos)| {\n+            if pos == u32::MAX {\n                 None\n             } else {\n-                let position = u32::from_le(position) as usize;\n-                Some((DefIndex::new(index), Lazy::with_position(position)))\n+                let pos = u32::from_le(pos) as usize;\n+                Some((DefIndex::new(index + DefIndexAddressSpace::High.start()),\n+                                    Lazy::with_position(pos)))\n             }\n-        })\n+        }))\n     }\n }\n "}, {"sha": "a811f72bc956cbe1408c0ff27753d0583ce0f111", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/090767b5ef59188e5defb466ff6580b99891f1ed/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090767b5ef59188e5defb466ff6580b99891f1ed/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=090767b5ef59188e5defb466ff6580b99891f1ed", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'b, 'tcx> DerefMut for IndexBuilder<'a, 'b, 'tcx> {\n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n         IndexBuilder {\n-            items: Index::new(ecx.tcx.hir.num_local_def_ids()),\n+            items: Index::new(ecx.tcx.hir.definitions().def_index_counts_lo_hi()),\n             ecx: ecx,\n         }\n     }"}]}