{"sha": "fab99073b01539ce2664366011c7f3e378e52b7e", "node_id": "C_kwDOAAsO6NoAKGZhYjk5MDczYjAxNTM5Y2UyNjY0MzY2MDExYzdmM2UzNzhlNTJiN2U", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-13T09:22:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-13T09:22:24Z"}, "message": "Auto merge of #110275 - matthiaskrgr:rollup-8ntb3o5, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #110072 (Stabilize IsTerminal)\n - #110195 (Erase lifetimes above `ty::INNERMOST` when probing ambiguous types)\n - #110218 (Remove `ToRegionVid`)\n - #110220 (cleanup our region error API)\n - #110234 (Fix btree `CursorMut::insert_after` check)\n - #110262 (Update unwind_safe.rs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "7530fca909abbf5fb61655c627bd66e20f083fbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7530fca909abbf5fb61655c627bd66e20f083fbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fab99073b01539ce2664366011c7f3e378e52b7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fab99073b01539ce2664366011c7f3e378e52b7e", "html_url": "https://github.com/rust-lang/rust/commit/fab99073b01539ce2664366011c7f3e378e52b7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fab99073b01539ce2664366011c7f3e378e52b7e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d37e2f74afd131cda7b08520d37426bfbb622b5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d37e2f74afd131cda7b08520d37426bfbb622b5c", "html_url": "https://github.com/rust-lang/rust/commit/d37e2f74afd131cda7b08520d37426bfbb622b5c"}, {"sha": "b14730f667a1fb1bd248d00177a36e5a84691d99", "url": "https://api.github.com/repos/rust-lang/rust/commits/b14730f667a1fb1bd248d00177a36e5a84691d99", "html_url": "https://github.com/rust-lang/rust/commit/b14730f667a1fb1bd248d00177a36e5a84691d99"}], "stats": {"total": 862, "additions": 352, "deletions": 510}, "files": [{"sha": "4824f6346d4c87b1b7474cda90c07e1fda572c4d", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -1,6 +1,5 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n-use crate::nll::ToRegionVid;\n use crate::path_utils::allow_two_phase_borrow;\n use crate::place_ext::PlaceExt;\n use crate::BorrowIndex;\n@@ -204,7 +203,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n                 return;\n             }\n \n-            let region = region.to_region_vid();\n+            let region = region.as_var();\n \n             let borrow = BorrowData {\n                 kind,\n@@ -279,7 +278,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n             let borrow_data = &self.location_map[&location];\n             assert_eq!(borrow_data.reserve_location, location);\n             assert_eq!(borrow_data.kind, kind);\n-            assert_eq!(borrow_data.region, region.to_region_vid());\n+            assert_eq!(borrow_data.region, region.as_var());\n             assert_eq!(borrow_data.borrowed_place, place);\n         }\n "}, {"sha": "2aa09a3f26c1758d6dc76f2d06f239a2efeada8c", "filename": "compiler/rustc_borrowck/src/constraint_generation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -12,8 +12,8 @@ use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, RegionVid, Ty, TyCtxt};\n \n use crate::{\n-    borrow_set::BorrowSet, facts::AllFacts, location::LocationTable, nll::ToRegionVid,\n-    places_conflict, region_infer::values::LivenessValues,\n+    borrow_set::BorrowSet, facts::AllFacts, location::LocationTable, places_conflict,\n+    region_infer::values::LivenessValues,\n };\n \n pub(super) fn generate_constraints<'tcx>(\n@@ -170,7 +170,7 @@ impl<'cx, 'tcx> ConstraintGeneration<'cx, 'tcx> {\n         debug!(\"add_regular_live_constraint(live_ty={:?}, location={:?})\", live_ty, location);\n \n         self.infcx.tcx.for_each_free_region(&live_ty, |live_region| {\n-            let vid = live_region.to_region_vid();\n+            let vid = live_region.as_var();\n             self.liveness_constraints.add_element(vid, location);\n         });\n     }"}, {"sha": "94939c7e4cd72ea0824baf09b64670e9fe2cae99", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -11,9 +11,7 @@ use rustc_mir_dataflow::{self, fmt::DebugWithContext, CallReturnPlaces, GenKill}\n use rustc_mir_dataflow::{Analysis, Direction, Results};\n use std::fmt;\n \n-use crate::{\n-    places_conflict, BorrowSet, PlaceConflictBias, PlaceExt, RegionInferenceContext, ToRegionVid,\n-};\n+use crate::{places_conflict, BorrowSet, PlaceConflictBias, PlaceExt, RegionInferenceContext};\n \n /// A tuple with named fields that can hold either the results or the transient state of the\n /// dataflow analyses used by the borrow checker.\n@@ -242,7 +240,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     ) -> Self {\n         let mut prec = OutOfScopePrecomputer::new(body, nonlexical_regioncx);\n         for (borrow_index, borrow_data) in borrow_set.iter_enumerated() {\n-            let borrow_region = borrow_data.region.to_region_vid();\n+            let borrow_region = borrow_data.region;\n             let location = borrow_data.reserve_location;\n \n             prec.precompute_borrows_out_of_scope(borrow_index, borrow_region, location);"}, {"sha": "2495613fea1d2c9e6473f7a299c9199c6630f0cf", "filename": "compiler/rustc_borrowck/src/diagnostics/find_use.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -6,7 +6,6 @@ use std::rc::Rc;\n \n use crate::{\n     def_use::{self, DefUse},\n-    nll::ToRegionVid,\n     region_infer::{Cause, RegionInferenceContext},\n };\n use rustc_data_structures::fx::FxIndexSet;\n@@ -117,7 +116,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for DefUseVisitor<'cx, 'tcx> {\n \n         let mut found_it = false;\n         self.tcx.for_each_free_region(&local_ty, |r| {\n-            if r.to_region_vid() == self.region_vid {\n+            if r.as_var() == self.region_vid {\n                 found_it = true;\n             }\n         });"}, {"sha": "f69c4829ae2999ba9df9f39c02f8da69b86b10e4", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::ty::{self, RegionVid, Ty};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n-use crate::{nll::ToRegionVid, universal_regions::DefiningTy, MirBorrowckCtxt};\n+use crate::{universal_regions::DefiningTy, MirBorrowckCtxt};\n \n /// A name for a particular region used in emitting diagnostics. This name could be a generated\n /// name like `'1`, a name used by the user like `'a`, or a name like `'static`.\n@@ -497,7 +497,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 //     &\n                 //     - let's call the lifetime of this reference `'1`\n                 (ty::Ref(region, referent_ty, _), hir::TyKind::Ref(_lifetime, referent_hir_ty)) => {\n-                    if region.to_region_vid() == needle_fr {\n+                    if region.as_var() == needle_fr {\n                         // Just grab the first character, the `&`.\n                         let source_map = self.infcx.tcx.sess.source_map();\n                         let ampersand_span = source_map.start_point(hir_ty.span);\n@@ -598,7 +598,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         for (kind, hir_arg) in iter::zip(substs, args.args) {\n             match (kind.unpack(), hir_arg) {\n                 (GenericArgKind::Lifetime(r), hir::GenericArg::Lifetime(lt)) => {\n-                    if r.to_region_vid() == needle_fr {\n+                    if r.as_var() == needle_fr {\n                         return Some(lt);\n                     }\n                 }\n@@ -666,7 +666,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let return_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n         debug!(\"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\", return_ty);\n-        if !tcx.any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr) {\n+        if !tcx.any_free_region_meets(&return_ty, |r| r.as_var() == fr) {\n             return None;\n         }\n \n@@ -803,7 +803,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let tcx = self.infcx.tcx;\n \n-        if !tcx.any_free_region_meets(&yield_ty, |r| r.to_region_vid() == fr) {\n+        if !tcx.any_free_region_meets(&yield_ty, |r| r.as_var() == fr) {\n             return None;\n         }\n "}, {"sha": "376415e3d3208466ca69af129d650beb154ae6e2", "filename": "compiler/rustc_borrowck/src/diagnostics/var_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -1,8 +1,8 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n+use crate::region_infer::RegionInferenceContext;\n use crate::Upvar;\n-use crate::{nll::ToRegionVid, region_infer::RegionInferenceContext};\n use rustc_index::vec::{Idx, IndexSlice};\n use rustc_middle::mir::{Body, Local};\n use rustc_middle::ty::{RegionVid, TyCtxt};\n@@ -46,7 +46,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.universal_regions().defining_ty.upvar_tys().position(|upvar_ty| {\n                 debug!(\"get_upvar_index_for_region: upvar_ty={upvar_ty:?}\");\n                 tcx.any_free_region_meets(&upvar_ty, |r| {\n-                    let r = r.to_region_vid();\n+                    let r = r.as_var();\n                     debug!(\"get_upvar_index_for_region: r={r:?} fr={fr:?}\");\n                     r == fr\n                 })\n@@ -96,7 +96,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.universal_regions().unnormalized_input_tys.iter().skip(implicit_inputs).position(\n                 |arg_ty| {\n                     debug!(\"get_argument_index_for_region: arg_ty = {arg_ty:?}\");\n-                    tcx.any_free_region_meets(arg_ty, |r| r.to_region_vid() == fr)\n+                    tcx.any_free_region_meets(arg_ty, |r| r.as_var() == fr)\n                 },\n             )?;\n "}, {"sha": "a4b285a34fa4654eac10e3934274415fe20f2ba3", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -94,7 +94,7 @@ pub mod consumers;\n \n use borrow_set::{BorrowData, BorrowSet};\n use dataflow::{BorrowIndex, BorrowckFlowState as Flows, BorrowckResults, Borrows};\n-use nll::{PoloniusOutput, ToRegionVid};\n+use nll::PoloniusOutput;\n use place_ext::PlaceExt;\n use places_conflict::{places_conflict, PlaceConflictBias};\n use region_infer::RegionInferenceContext;\n@@ -507,9 +507,7 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n         F: Fn() -> RegionCtxt,\n     {\n         let next_region = self.infcx.next_region_var(origin);\n-        let vid = next_region\n-            .as_var()\n-            .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n+        let vid = next_region.as_var();\n \n         if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n@@ -531,9 +529,7 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n         F: Fn() -> RegionCtxt,\n     {\n         let next_region = self.infcx.next_nll_region_var(origin.clone());\n-        let vid = next_region\n-            .as_var()\n-            .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n+        let vid = next_region.as_var();\n \n         if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);"}, {"sha": "59a3ab3189d75628e48a0849f882ab6b8fa6a686", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n     Promoted,\n };\n-use rustc_middle::ty::{self, OpaqueHiddenType, Region, RegionVid, TyCtxt};\n+use rustc_middle::ty::{self, OpaqueHiddenType, TyCtxt};\n use rustc_span::symbol::sym;\n use std::env;\n use std::io;\n@@ -444,27 +444,6 @@ fn for_each_region_constraint<'tcx>(\n     Ok(())\n }\n \n-/// Right now, we piggy back on the `ReVar` to store our NLL inference\n-/// regions. These are indexed with `RegionVid`. This method will\n-/// assert that the region is a `ReVar` and extract its internal index.\n-/// This is reasonable because in our MIR we replace all universal regions\n-/// with inference variables.\n-pub trait ToRegionVid {\n-    fn to_region_vid(self) -> RegionVid;\n-}\n-\n-impl<'tcx> ToRegionVid for Region<'tcx> {\n-    fn to_region_vid(self) -> RegionVid {\n-        if let ty::ReVar(vid) = *self { vid } else { bug!(\"region is not an ReVar: {:?}\", self) }\n-    }\n-}\n-\n-impl ToRegionVid for RegionVid {\n-    fn to_region_vid(self) -> RegionVid {\n-        self\n-    }\n-}\n-\n pub(crate) trait ConstraintDescription {\n     fn description(&self) -> &'static str;\n }"}, {"sha": "729f3dbff3b46b1050128075f5c091cf86f8ba65", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -27,7 +27,7 @@ use crate::{\n     },\n     diagnostics::{RegionErrorKind, RegionErrors, UniverseInfo},\n     member_constraints::{MemberConstraintSet, NllMemberConstraintIndex},\n-    nll::{PoloniusOutput, ToRegionVid},\n+    nll::PoloniusOutput,\n     region_infer::reverse_sccs::ReverseSccGraph,\n     region_infer::values::{\n         LivenessValues, PlaceholderIndices, RegionElement, RegionValueElements, RegionValues,\n@@ -593,39 +593,36 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Returns `true` if the region `r` contains the point `p`.\n     ///\n     /// Panics if called before `solve()` executes,\n-    pub(crate) fn region_contains(&self, r: impl ToRegionVid, p: impl ToElementIndex) -> bool {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+    pub(crate) fn region_contains(&self, r: RegionVid, p: impl ToElementIndex) -> bool {\n+        let scc = self.constraint_sccs.scc(r);\n         self.scc_values.contains(scc, p)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n     pub(crate) fn region_value_str(&self, r: RegionVid) -> String {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        let scc = self.constraint_sccs.scc(r);\n         self.scc_values.region_value_str(scc)\n     }\n \n     pub(crate) fn placeholders_contained_in<'a>(\n         &'a self,\n         r: RegionVid,\n     ) -> impl Iterator<Item = ty::PlaceholderRegion> + 'a {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        let scc = self.constraint_sccs.scc(r);\n         self.scc_values.placeholders_contained_in(scc)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n     pub(crate) fn region_universe(&self, r: RegionVid) -> ty::UniverseIndex {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        let scc = self.constraint_sccs.scc(r);\n         self.scc_universes[scc]\n     }\n \n     /// Once region solving has completed, this function will return\n     /// the member constraints that were applied to the value of a given\n     /// region `r`. See `AppliedMemberConstraint`.\n-    pub(crate) fn applied_member_constraints(\n-        &self,\n-        r: impl ToRegionVid,\n-    ) -> &[AppliedMemberConstraint] {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+    pub(crate) fn applied_member_constraints(&self, r: RegionVid) -> &[AppliedMemberConstraint] {\n+        let scc = self.constraint_sccs.scc(r);\n         binary_search_util::binary_search_slice(\n             &self.member_constraints_applied,\n             |applied| applied.member_region_scc,\n@@ -1133,7 +1130,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let r_vid = self.to_region_vid(r);\n             let r_scc = self.constraint_sccs.scc(r_vid);\n \n-            // The challenge if this. We have some region variable `r`\n+            // The challenge is this. We have some region variable `r`\n             // whose value is a set of CFG points and universal\n             // regions. We want to find if that set is *equivalent* to\n             // any of the named regions found in the closure.\n@@ -2234,7 +2231,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         r: RegionVid,\n         body: &Body<'_>,\n     ) -> Option<Location> {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        let scc = self.constraint_sccs.scc(r);\n         let locations = self.scc_values.locations_outlived_by(scc);\n         for location in locations {\n             let bb = &body[location.block];"}, {"sha": "71eae7b27d1db7835d8e4625781d9b6f3f9013ac", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -12,7 +12,6 @@ use rustc_span::{Span, DUMMY_SP};\n \n use crate::{\n     constraints::OutlivesConstraint,\n-    nll::ToRegionVid,\n     region_infer::TypeTest,\n     type_check::{Locations, MirTypeckRegionConstraints},\n     universal_regions::UniversalRegions,\n@@ -198,7 +197,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n \n     fn to_region_vid(&mut self, r: ty::Region<'tcx>) -> ty::RegionVid {\n         if let ty::RePlaceholder(placeholder) = *r {\n-            self.constraints.placeholder_region(self.infcx, placeholder).to_region_vid()\n+            self.constraints.placeholder_region(self.infcx, placeholder).as_var()\n         } else {\n             self.universal_regions.to_region_vid(r)\n         }"}, {"sha": "f1ad0ca55ccfd45b0a9dc8bdc11345dcbb286984", "filename": "compiler/rustc_borrowck/src/type_check/liveness/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fmod.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -11,7 +11,6 @@ use crate::{\n     constraints::OutlivesConstraintSet,\n     facts::{AllFacts, AllFactsExt},\n     location::LocationTable,\n-    nll::ToRegionVid,\n     region_infer::values::RegionValueElements,\n     universal_regions::UniversalRegions,\n };\n@@ -80,9 +79,7 @@ fn compute_relevant_live_locals<'tcx>(\n ) -> (Vec<Local>, Vec<Local>) {\n     let (boring_locals, relevant_live_locals): (Vec<_>, Vec<_>) =\n         body.local_decls.iter_enumerated().partition_map(|(local, local_decl)| {\n-            if tcx.all_free_regions_meet(&local_decl.ty, |r| {\n-                free_regions.contains(&r.to_region_vid())\n-            }) {\n+            if tcx.all_free_regions_meet(&local_decl.ty, |r| free_regions.contains(&r.as_var())) {\n                 Either::Left(local)\n             } else {\n                 Either::Right(local)"}, {"sha": "375eca1b29d3daf841f5b0d184d2a0976276cde0", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -56,7 +56,6 @@ use crate::{\n     facts::AllFacts,\n     location::LocationTable,\n     member_constraints::MemberConstraintSet,\n-    nll::ToRegionVid,\n     path_utils,\n     region_infer::values::{\n         LivenessValues, PlaceholderIndex, PlaceholderIndices, RegionValueElements,\n@@ -2419,7 +2418,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if let Some(all_facts) = all_facts {\n             let _prof_timer = self.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n             if let Some(borrow_index) = borrow_set.get_index_of(&location) {\n-                let region_vid = borrow_region.to_region_vid();\n+                let region_vid = borrow_region.as_var();\n                 all_facts.loan_issued_at.push((\n                     region_vid,\n                     borrow_index,\n@@ -2465,8 +2464,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     match base_ty.kind() {\n                         ty::Ref(ref_region, _, mutbl) => {\n                             constraints.outlives_constraints.push(OutlivesConstraint {\n-                                sup: ref_region.to_region_vid(),\n-                                sub: borrow_region.to_region_vid(),\n+                                sup: ref_region.as_var(),\n+                                sub: borrow_region.as_var(),\n                                 locations: location.to_locations(),\n                                 span: location.to_locations().span(body),\n                                 category,"}, {"sha": "7e6d17ec3437e7062680df9557b1843f80d27506", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -131,13 +131,9 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n             ty::BoundRegionKind::BrEnv => BoundRegionInfo::Name(sym::env),\n         };\n \n-        let reg_var =\n-            reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n-\n         if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n             let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-            debug!(?reg_var);\n-            var_to_origin.insert(reg_var, RegionCtxt::Placeholder(reg_info));\n+            var_to_origin.insert(reg.as_var(), RegionCtxt::Placeholder(reg_info));\n         }\n \n         reg\n@@ -150,12 +146,9 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n             universe,\n         );\n \n-        let reg_var =\n-            reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n-\n         if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n             let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-            var_to_origin.insert(reg_var, RegionCtxt::Existential(None));\n+            var_to_origin.insert(reg.as_var(), RegionCtxt::Existential(None));\n         }\n \n         reg"}, {"sha": "70fddb1057c09c86f69a7f5f03c6773648b0b52d", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -28,7 +28,6 @@ use rustc_span::symbol::{kw, sym};\n use rustc_span::Symbol;\n use std::iter;\n \n-use crate::nll::ToRegionVid;\n use crate::renumber::{BoundRegionInfo, RegionCtxt};\n use crate::BorrowckInferCtxt;\n \n@@ -406,7 +405,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         // Create the \"global\" region that is always free in all contexts: 'static.\n         let fr_static =\n-            self.infcx.next_nll_region_var(FR, || RegionCtxt::Free(kw::Static)).to_region_vid();\n+            self.infcx.next_nll_region_var(FR, || RegionCtxt::Free(kw::Static)).as_var();\n \n         // We've now added all the global regions. The next ones we\n         // add will be external.\n@@ -446,7 +445,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                         };\n \n                         debug!(?region_vid);\n-                        indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+                        indices.insert_late_bound_region(r, region_vid.as_var());\n                     }\n                 },\n             );\n@@ -480,7 +479,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 };\n \n                 debug!(?region_vid);\n-                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+                indices.insert_late_bound_region(r, region_vid.as_var());\n             }\n         });\n \n@@ -499,7 +498,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 let reg_vid = self\n                     .infcx\n                     .next_nll_region_var(FR, || RegionCtxt::Free(Symbol::intern(\"c-variadic\")))\n-                    .to_region_vid();\n+                    .as_var();\n \n                 let region = self.infcx.tcx.mk_re_var(reg_vid);\n                 let va_list_ty =\n@@ -514,7 +513,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let fr_fn_body = self\n             .infcx\n             .next_nll_region_var(FR, || RegionCtxt::Free(Symbol::intern(\"fn_body\")))\n-            .to_region_vid();\n+            .as_var();\n \n         let num_universals = self.infcx.num_region_vars();\n \n@@ -635,7 +634,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         let global_mapping = iter::once((tcx.lifetimes.re_static, fr_static));\n         let subst_mapping =\n-            iter::zip(identity_substs.regions(), fr_substs.regions().map(|r| r.to_region_vid()));\n+            iter::zip(identity_substs.regions(), fr_substs.regions().map(|r| r.as_var()));\n \n         UniversalRegionIndices { indices: global_mapping.chain(subst_mapping).collect(), fr_static }\n     }\n@@ -789,7 +788,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n                 self.next_nll_region_var(origin, || RegionCtxt::Bound(BoundRegionInfo::Name(name)))\n             };\n \n-            indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n+            indices.insert_late_bound_region(liberated_region, region_vid.as_var());\n             debug!(?liberated_region, ?region_vid);\n             region_vid\n         });\n@@ -822,7 +821,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n                 };\n \n                 debug!(?region_vid);\n-                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+                indices.insert_late_bound_region(r, region_vid.as_var());\n             }\n         });\n     }\n@@ -843,7 +842,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n                     })\n                 };\n \n-                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+                indices.insert_late_bound_region(r, region_vid.as_var());\n             }\n         });\n     }\n@@ -861,7 +860,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     }\n \n     /// Converts `r` into a local inference variable: `r` can either\n-    /// by a `ReVar` (i.e., already a reference to an inference\n+    /// be a `ReVar` (i.e., already a reference to an inference\n     /// variable) or it can be `'static` or some early-bound\n     /// region. This is useful when taking the results from\n     /// type-checking and trait-matching, which may sometimes\n@@ -870,7 +869,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     /// fully initialized.\n     pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n         if let ty::ReVar(..) = *r {\n-            r.to_region_vid()\n+            r.as_var()\n         } else if r.is_error() {\n             // We use the `'static` `RegionVid` because `ReError` doesn't actually exist in the\n             // `UniversalRegionIndices`. This is fine because 1) it is a fallback only used if"}, {"sha": "b9f0e756e65fee115492cff4e3c8ca3696d83a41", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -5,7 +5,6 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(is_terminal)]\n #![feature(lazy_cell)]\n #![feature(decl_macro)]\n #![recursion_limit = \"256\"]"}, {"sha": "d20b168904d6f993330b84c11f1226a14b25c2f5", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -6,7 +6,6 @@\n #![feature(array_windows)]\n #![feature(drain_filter)]\n #![feature(if_let_guard)]\n-#![feature(is_terminal)]\n #![feature(adt_const_params)]\n #![feature(let_chains)]\n #![feature(never_type)]"}, {"sha": "8d1156c1771e9cd4c3cce7851bc81e0d1c0ea9cc", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -2520,24 +2520,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                     tcx,\n                                     infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id),\n                                 );\n-                                // I guess we don't need to make a universe unless we need it,\n-                                // but also we're on the error path, so it doesn't matter here.\n-                                let universe = infcx.create_next_universe();\n+                                let value = tcx.fold_regions(qself_ty, |_, _| tcx.lifetimes.re_erased);\n+                                // FIXME: Don't bother dealing with non-lifetime binders here...\n+                                if value.has_escaping_bound_vars() {\n+                                    return false;\n+                                }\n                                 infcx\n                                     .can_eq(\n                                         ty::ParamEnv::empty(),\n                                         impl_.self_ty(),\n-                                        tcx.replace_escaping_bound_vars_uncached(qself_ty, ty::fold::FnMutDelegate {\n-                                            regions: &mut |_| tcx.lifetimes.re_erased,\n-                                            types: &mut |bv| tcx.mk_placeholder(ty::PlaceholderType {\n-                                                universe,\n-                                                bound: bv,\n-                                            }),\n-                                            consts: &mut |bv, ty| tcx.mk_const(ty::PlaceholderConst {\n-                                                universe,\n-                                                bound: bv,\n-                                            }, ty),\n-                                        })\n+                                        value,\n                                     )\n                             })\n                             && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative"}, {"sha": "0bb98fdf2a23e157068cc496dd304276ae9180e4", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -452,11 +452,8 @@ fn check_opaque_meets_bounds<'tcx>(\n         hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n         // Can have different predicates to their defining use\n         hir::OpaqueTyOrigin::TyAlias => {\n-            let outlives_environment = OutlivesEnvironment::new(param_env);\n-            let _ = infcx.err_ctxt().check_region_obligations_and_report_errors(\n-                defining_use_anchor,\n-                &outlives_environment,\n-            );\n+            let outlives_env = OutlivesEnvironment::new(param_env);\n+            let _ = ocx.resolve_regions_and_report_errors(defining_use_anchor, &outlives_env);\n         }\n     }\n     // Clean up after ourselves"}, {"sha": "5d119a7737a4cf4d740a34685300963ba6058cab", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -332,10 +332,6 @@ fn compare_method_predicate_entailment<'tcx>(\n         param_env,\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys.clone()),\n     );\n-    infcx.process_registered_region_obligations(\n-        outlives_env.region_bound_pairs(),\n-        outlives_env.param_env,\n-    );\n     let errors = infcx.resolve_regions(&outlives_env);\n     if !errors.is_empty() {\n         // FIXME(compiler-errors): This can be simplified when IMPLIED_BOUNDS_ENTAILMENT\n@@ -722,18 +718,18 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n         return Err(reported);\n     }\n \n+    let collected_types = collector.types;\n+\n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n-    let outlives_environment = OutlivesEnvironment::with_bounds(\n+    let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys),\n     );\n-    infcx\n-        .err_ctxt()\n-        .check_region_obligations_and_report_errors(impl_m_def_id, &outlives_environment)?;\n+    ocx.resolve_regions_and_report_errors(impl_m_def_id, &outlives_env)?;\n \n     let mut collected_tys = FxHashMap::default();\n-    for (def_id, (ty, substs)) in collector.types {\n+    for (def_id, (ty, substs)) in collected_types {\n         match infcx.fully_resolve(ty) {\n             Ok(ty) => {\n                 // `ty` contains free regions that we created earlier while liberating the\n@@ -1742,11 +1738,8 @@ pub(super) fn compare_impl_const_raw(\n         return Err(infcx.err_ctxt().report_fulfillment_errors(&errors));\n     }\n \n-    let outlives_environment = OutlivesEnvironment::new(param_env);\n-    infcx\n-        .err_ctxt()\n-        .check_region_obligations_and_report_errors(impl_const_item_def, &outlives_environment)?;\n-    Ok(())\n+    let outlives_env = OutlivesEnvironment::new(param_env);\n+    ocx.resolve_regions_and_report_errors(impl_const_item_def, &outlives_env)\n }\n \n pub(super) fn compare_impl_ty<'tcx>(\n@@ -1845,13 +1838,8 @@ fn compare_type_predicate_entailment<'tcx>(\n \n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n-    let outlives_environment = OutlivesEnvironment::new(param_env);\n-    infcx.err_ctxt().check_region_obligations_and_report_errors(\n-        impl_ty.def_id.expect_local(),\n-        &outlives_environment,\n-    )?;\n-\n-    Ok(())\n+    let outlives_env = OutlivesEnvironment::new(param_env);\n+    ocx.resolve_regions_and_report_errors(impl_ty_def_id, &outlives_env)\n }\n \n /// Validate that `ProjectionCandidate`s created for this associated type will\n@@ -2063,14 +2051,8 @@ pub(super) fn check_type_bounds<'tcx>(\n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_def_id, assumed_wf_types);\n-    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n-\n-    infcx.err_ctxt().check_region_obligations_and_report_errors(\n-        impl_ty.def_id.expect_local(),\n-        &outlives_environment,\n-    )?;\n-\n-    Ok(())\n+    let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n+    ocx.resolve_regions_and_report_errors(impl_ty_def_id, &outlives_env)\n }\n \n fn assoc_item_kind_str(impl_item: &ty::AssocItem) -> &'static str {"}, {"sha": "53197bc849106c44917b26b9a5c907634d5c9666", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -114,11 +114,9 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n         return;\n     }\n \n-    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n+    let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n \n-    let _ = infcx\n-        .err_ctxt()\n-        .check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n+    let _ = wfcx.ocx.resolve_regions_and_report_errors(body_def_id, &outlives_env);\n }\n \n fn check_well_formed(tcx: TyCtxt<'_>, def_id: hir::OwnerId) {\n@@ -680,12 +678,7 @@ fn resolve_regions_with_wf_tys<'tcx>(\n \n     add_constraints(&infcx, region_bound_pairs);\n \n-    infcx.process_registered_region_obligations(\n-        outlives_environment.region_bound_pairs(),\n-        param_env,\n-    );\n     let errors = infcx.resolve_regions(&outlives_environment);\n-\n     debug!(?errors, \"errors\");\n \n     // If we were able to prove that the type outlives the region without"}, {"sha": "0f40cca9427b4500c02a03a8c19bbb785a1798c9", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -354,9 +354,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n \n                 // Finally, resolve all regions.\n                 let outlives_env = OutlivesEnvironment::new(param_env);\n-                let _ = infcx\n-                    .err_ctxt()\n-                    .check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+                let _ = ocx.resolve_regions_and_report_errors(impl_did, &outlives_env);\n             }\n         }\n         _ => {\n@@ -592,7 +590,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: LocalDefId) -> Coe\n \n     // Finally, resolve all regions.\n     let outlives_env = OutlivesEnvironment::new(param_env);\n-    let _ = infcx.err_ctxt().check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+    let _ = ocx.resolve_regions_and_report_errors(impl_did, &outlives_env);\n \n     CoerceUnsizedInfo { custom_kind: kind }\n }"}, {"sha": "c173bd913a84c416d807f6ac77f2ccee5d58786e", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -8,10 +8,7 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::print::with_forced_trimmed_paths;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{\n-    self, ImplTraitInTraitData, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable,\n-    TypeVisitableExt,\n-};\n+use rustc_middle::ty::{self, ImplTraitInTraitData, IsSuggestable, Ty, TyCtxt, TypeVisitableExt};\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -874,28 +871,6 @@ fn infer_placeholder_type<'a>(\n     item_ident: Ident,\n     kind: &'static str,\n ) -> Ty<'a> {\n-    // Attempts to make the type nameable by turning FnDefs into FnPtrs.\n-    struct MakeNameable<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-    }\n-\n-    impl<'tcx> TypeFolder<TyCtxt<'tcx>> for MakeNameable<'tcx> {\n-        fn interner(&self) -> TyCtxt<'tcx> {\n-            self.tcx\n-        }\n-\n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-            let ty = match *ty.kind() {\n-                ty::FnDef(def_id, substs) => {\n-                    self.tcx.mk_fn_ptr(self.tcx.fn_sig(def_id).subst(self.tcx, substs))\n-                }\n-                _ => ty,\n-            };\n-\n-            ty.super_fold_with(self)\n-        }\n-    }\n-\n     let ty = tcx.diagnostic_only_typeck(def_id).node_type(body_id.hir_id);\n \n     // If this came from a free `const` or `static mut?` item,"}, {"sha": "eb2fc395223ed5f4c28728d834eae654e722b95b", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -180,8 +180,7 @@ fn get_impl_substs(\n \n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_def_id, assumed_wf_types);\n     let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n-    let _ =\n-        infcx.err_ctxt().check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n+    let _ = ocx.resolve_regions_and_report_errors(impl1_def_id, &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n         let span = tcx.def_span(impl1_def_id);\n         tcx.sess.emit_err(SubstsOnOverriddenImpl { span });"}, {"sha": "a52c94cb00c531621f9834b66a666d688a17bc5c", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -12,9 +12,7 @@ use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{\n-    self, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitableExt,\n-};\n+use rustc_middle::ty::{self, IsSuggestable, Ty, TyCtxt, TypeVisitableExt};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n@@ -965,21 +963,3 @@ fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>, rhs: Ty<'tcx>, op: hir::BinOp) -> bool\n         }\n     }\n }\n-\n-struct TypeParamEraser<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, Span);\n-\n-impl<'tcx> TypeFolder<TyCtxt<'tcx>> for TypeParamEraser<'_, 'tcx> {\n-    fn interner(&self) -> TyCtxt<'tcx> {\n-        self.0.tcx\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match ty.kind() {\n-            ty::Param(_) => self.0.next_ty_var(TypeVariableOrigin {\n-                kind: TypeVariableOriginKind::MiscVariable,\n-                span: self.1,\n-            }),\n-            _ => ty.super_fold_with(self),\n-        }\n-    }\n-}"}, {"sha": "9e5f6d107d132eef3b9ec4b0d4b2900f7621cfdd", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -74,6 +74,7 @@ use rustc_middle::ty::{\n     self, error::TypeError, List, Region, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable,\n     TypeVisitable, TypeVisitableExt,\n };\n+use rustc_span::DUMMY_SP;\n use rustc_span::{sym, symbol::kw, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::ops::{ControlFlow, Deref};\n@@ -113,7 +114,11 @@ fn escape_literal(s: &str) -> String {\n \n /// A helper for building type related errors. The `typeck_results`\n /// field is only populated during an in-progress typeck.\n-/// Get an instance by calling `InferCtxt::err` or `FnCtxt::infer_err`.\n+/// Get an instance by calling `InferCtxt::err_ctxt` or `FnCtxt::err_ctxt`.\n+///\n+/// You must only create this if you intend to actually emit an error.\n+/// This provides a lot of utility methods which should not be used\n+/// during the happy path.\n pub struct TypeErrCtxt<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'tcx>,\n     pub typeck_results: Option<std::cell::Ref<'a, ty::TypeckResults<'tcx>>>,\n@@ -125,6 +130,19 @@ pub struct TypeErrCtxt<'a, 'tcx> {\n         Box<dyn Fn(Ty<'tcx>) -> Vec<(Ty<'tcx>, Vec<PredicateObligation<'tcx>>)> + 'a>,\n }\n \n+impl Drop for TypeErrCtxt<'_, '_> {\n+    fn drop(&mut self) {\n+        if let Some(_) = self.infcx.tcx.sess.has_errors_or_delayed_span_bugs() {\n+            // ok, emitted an error.\n+        } else {\n+            self.infcx\n+                .tcx\n+                .sess\n+                .delay_span_bug(DUMMY_SP, \"used a `TypeErrCtxt` without failing compilation\");\n+        }\n+    }\n+}\n+\n impl TypeErrCtxt<'_, '_> {\n     /// This is just to avoid a potential footgun of accidentally\n     /// dropping `typeck_results` by calling `InferCtxt::err_ctxt`\n@@ -409,7 +427,11 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         &self,\n         generic_param_scope: LocalDefId,\n         errors: &[RegionResolutionError<'tcx>],\n-    ) {\n+    ) -> ErrorGuaranteed {\n+        if let Some(guaranteed) = self.infcx.tainted_by_errors() {\n+            return guaranteed;\n+        }\n+\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n@@ -489,6 +511,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n         }\n+\n+        self.tcx\n+            .sess\n+            .delay_span_bug(self.tcx.def_span(generic_param_scope), \"expected region errors\")\n     }\n \n     // This method goes through all the errors and try to group certain types"}, {"sha": "66f51328bbe7ce9f0dba71643d90c5b4595584b5", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 141, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -45,8 +45,7 @@ use self::combine::CombineFields;\n use self::error_reporting::TypeErrCtxt;\n use self::free_regions::RegionRelations;\n use self::lexical_region_resolve::LexicalRegionResolutions;\n-use self::outlives::env::OutlivesEnvironment;\n-use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n+use self::region_constraints::{GenericKind, VarInfos, VerifyBound};\n use self::region_constraints::{\n     RegionConstraintCollector, RegionConstraintStorage, RegionSnapshot,\n };\n@@ -1213,95 +1212,6 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.tainted_by_errors.set(Some(e));\n     }\n \n-    pub fn skip_region_resolution(&self) {\n-        let (var_infos, _) = {\n-            let mut inner = self.inner.borrow_mut();\n-            let inner = &mut *inner;\n-            // Note: `inner.region_obligations` may not be empty, because we\n-            // didn't necessarily call `process_registered_region_obligations`.\n-            // This is okay, because that doesn't introduce new vars.\n-            inner\n-                .region_constraint_storage\n-                .take()\n-                .expect(\"regions already resolved\")\n-                .with_log(&mut inner.undo_log)\n-                .into_infos_and_data()\n-        };\n-\n-        let lexical_region_resolutions = LexicalRegionResolutions {\n-            values: rustc_index::vec::IndexVec::from_elem_n(\n-                crate::infer::lexical_region_resolve::VarValue::Value(self.tcx.lifetimes.re_erased),\n-                var_infos.len(),\n-            ),\n-        };\n-\n-        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n-        assert!(old_value.is_none());\n-    }\n-\n-    /// Process the region constraints and return any errors that\n-    /// result. After this, no more unification operations should be\n-    /// done -- or the compiler will panic -- but it is legal to use\n-    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n-    pub fn resolve_regions(\n-        &self,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) -> Vec<RegionResolutionError<'tcx>> {\n-        let (var_infos, data) = {\n-            let mut inner = self.inner.borrow_mut();\n-            let inner = &mut *inner;\n-            assert!(\n-                self.tainted_by_errors().is_some() || inner.region_obligations.is_empty(),\n-                \"region_obligations not empty: {:#?}\",\n-                inner.region_obligations\n-            );\n-            inner\n-                .region_constraint_storage\n-                .take()\n-                .expect(\"regions already resolved\")\n-                .with_log(&mut inner.undo_log)\n-                .into_infos_and_data()\n-        };\n-\n-        let region_rels = &RegionRelations::new(self.tcx, outlives_env.free_region_map());\n-\n-        let (lexical_region_resolutions, errors) =\n-            lexical_region_resolve::resolve(outlives_env.param_env, region_rels, var_infos, data);\n-\n-        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n-        assert!(old_value.is_none());\n-\n-        errors\n-    }\n-    /// Obtains (and clears) the current set of region\n-    /// constraints. The inference context is still usable: further\n-    /// unifications will simply add new constraints.\n-    ///\n-    /// This method is not meant to be used with normal lexical region\n-    /// resolution. Rather, it is used in the NLL mode as a kind of\n-    /// interim hack: basically we run normal type-check and generate\n-    /// region constraints as normal, but then we take them and\n-    /// translate them into the form that the NLL solver\n-    /// understands. See the NLL module for mode details.\n-    pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n-        assert!(\n-            self.inner.borrow().region_obligations.is_empty(),\n-            \"region_obligations not empty: {:#?}\",\n-            self.inner.borrow().region_obligations\n-        );\n-\n-        self.inner.borrow_mut().unwrap_region_constraints().take_and_reset_data()\n-    }\n-\n-    /// Gives temporary access to the region constraint data.\n-    pub fn with_region_constraints<R>(\n-        &self,\n-        op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n-    ) -> R {\n-        let mut inner = self.inner.borrow_mut();\n-        op(inner.unwrap_region_constraints().data())\n-    }\n-\n     pub fn region_var_origin(&self, vid: ty::RegionVid) -> RegionVariableOrigin {\n         let mut inner = self.inner.borrow_mut();\n         let inner = &mut *inner;\n@@ -1754,56 +1664,6 @@ impl<'cx, 'tcx> Drop for CanonicalizationCtxtGuard<'cx, 'tcx> {\n }\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n-    /// Processes registered region obliations and resolves regions, reporting\n-    /// any errors if any were raised. Prefer using this function over manually\n-    /// calling `resolve_regions_and_report_errors`.\n-    pub fn check_region_obligations_and_report_errors(\n-        &self,\n-        generic_param_scope: LocalDefId,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) -> Result<(), ErrorGuaranteed> {\n-        self.process_registered_region_obligations(\n-            outlives_env.region_bound_pairs(),\n-            outlives_env.param_env,\n-        );\n-\n-        self.resolve_regions_and_report_errors(generic_param_scope, outlives_env)\n-    }\n-\n-    /// Process the region constraints and report any errors that\n-    /// result. After this, no more unification operations should be\n-    /// done -- or the compiler will panic -- but it is legal to use\n-    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n-    ///\n-    /// Make sure to call [`InferCtxt::process_registered_region_obligations`]\n-    /// first, or preferably use [`TypeErrCtxt::check_region_obligations_and_report_errors`]\n-    /// to do both of these operations together.\n-    pub fn resolve_regions_and_report_errors(\n-        &self,\n-        generic_param_scope: LocalDefId,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) -> Result<(), ErrorGuaranteed> {\n-        let errors = self.resolve_regions(outlives_env);\n-\n-        if let None = self.tainted_by_errors() {\n-            // As a heuristic, just skip reporting region errors\n-            // altogether if other errors have been reported while\n-            // this infcx was in use. This is totally hokey but\n-            // otherwise we have a hard time separating legit region\n-            // errors from silly ones.\n-            self.report_region_errors(generic_param_scope, &errors);\n-        }\n-\n-        if errors.is_empty() {\n-            Ok(())\n-        } else {\n-            Err(self\n-                .tcx\n-                .sess\n-                .delay_span_bug(rustc_span::DUMMY_SP, \"error should have been emitted\"))\n-        }\n-    }\n-\n     // [Note-Type-error-reporting]\n     // An invariant is that anytime the expected or actual type is Error (the special\n     // error type, meaning that an error occurred when typechecking this expression),"}, {"sha": "9a9a1696b0063532821fdd7e4d667f677d95cd48", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 102, "deletions": 3, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -1,14 +1,18 @@\n //! Various code related to computing outlives relations.\n+use self::env::OutlivesEnvironment;\n+use super::region_constraints::RegionConstraintData;\n+use super::{InferCtxt, RegionResolutionError};\n+use crate::infer::free_regions::RegionRelations;\n+use crate::infer::lexical_region_resolve::{self, LexicalRegionResolutions};\n+use rustc_middle::traits::query::OutlivesBound;\n+use rustc_middle::ty;\n \n pub mod components;\n pub mod env;\n pub mod obligations;\n pub mod test_type_match;\n pub mod verify;\n \n-use rustc_middle::traits::query::OutlivesBound;\n-use rustc_middle::ty;\n-\n #[instrument(level = \"debug\", skip(param_env), ret)]\n pub fn explicit_outlives_bounds<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n@@ -39,3 +43,98 @@ pub fn explicit_outlives_bounds<'tcx>(\n             ))) => Some(OutlivesBound::RegionSubRegion(r_b, r_a)),\n         })\n }\n+\n+impl<'tcx> InferCtxt<'tcx> {\n+    pub fn skip_region_resolution(&self) {\n+        let (var_infos, _) = {\n+            let mut inner = self.inner.borrow_mut();\n+            let inner = &mut *inner;\n+            // Note: `inner.region_obligations` may not be empty, because we\n+            // didn't necessarily call `process_registered_region_obligations`.\n+            // This is okay, because that doesn't introduce new vars.\n+            inner\n+                .region_constraint_storage\n+                .take()\n+                .expect(\"regions already resolved\")\n+                .with_log(&mut inner.undo_log)\n+                .into_infos_and_data()\n+        };\n+\n+        let lexical_region_resolutions = LexicalRegionResolutions {\n+            values: rustc_index::vec::IndexVec::from_elem_n(\n+                crate::infer::lexical_region_resolve::VarValue::Value(self.tcx.lifetimes.re_erased),\n+                var_infos.len(),\n+            ),\n+        };\n+\n+        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n+        assert!(old_value.is_none());\n+    }\n+\n+    /// Process the region constraints and return any errors that\n+    /// result. After this, no more unification operations should be\n+    /// done -- or the compiler will panic -- but it is legal to use\n+    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n+    #[must_use]\n+    pub fn resolve_regions(\n+        &self,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+    ) -> Vec<RegionResolutionError<'tcx>> {\n+        self.process_registered_region_obligations(outlives_env);\n+\n+        let (var_infos, data) = {\n+            let mut inner = self.inner.borrow_mut();\n+            let inner = &mut *inner;\n+            assert!(\n+                self.tainted_by_errors().is_some() || inner.region_obligations.is_empty(),\n+                \"region_obligations not empty: {:#?}\",\n+                inner.region_obligations\n+            );\n+            inner\n+                .region_constraint_storage\n+                .take()\n+                .expect(\"regions already resolved\")\n+                .with_log(&mut inner.undo_log)\n+                .into_infos_and_data()\n+        };\n+\n+        let region_rels = &RegionRelations::new(self.tcx, outlives_env.free_region_map());\n+\n+        let (lexical_region_resolutions, errors) =\n+            lexical_region_resolve::resolve(outlives_env.param_env, region_rels, var_infos, data);\n+\n+        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n+        assert!(old_value.is_none());\n+\n+        errors\n+    }\n+\n+    /// Obtains (and clears) the current set of region\n+    /// constraints. The inference context is still usable: further\n+    /// unifications will simply add new constraints.\n+    ///\n+    /// This method is not meant to be used with normal lexical region\n+    /// resolution. Rather, it is used in the NLL mode as a kind of\n+    /// interim hack: basically we run normal type-check and generate\n+    /// region constraints as normal, but then we take them and\n+    /// translate them into the form that the NLL solver\n+    /// understands. See the NLL module for mode details.\n+    pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n+        assert!(\n+            self.inner.borrow().region_obligations.is_empty(),\n+            \"region_obligations not empty: {:#?}\",\n+            self.inner.borrow().region_obligations\n+        );\n+\n+        self.inner.borrow_mut().unwrap_region_constraints().take_and_reset_data()\n+    }\n+\n+    /// Gives temporary access to the region constraint data.\n+    pub fn with_region_constraints<R>(\n+        &self,\n+        op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n+    ) -> R {\n+        let mut inner = self.inner.borrow_mut();\n+        op(inner.unwrap_region_constraints().data())\n+    }\n+}"}, {"sha": "ccf11c61b573bb6f88f027938d867ec6f6df6946", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -72,6 +72,8 @@ use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Region, SubstsRef, Ty, TyCtxt, TypeVisitableExt};\n use smallvec::smallvec;\n \n+use super::env::OutlivesEnvironment;\n+\n impl<'tcx> InferCtxt<'tcx> {\n     /// Registers that the given region obligation must be resolved\n     /// from within the scope of `body_id`. These regions are enqueued\n@@ -112,39 +114,17 @@ impl<'tcx> InferCtxt<'tcx> {\n         std::mem::take(&mut self.inner.borrow_mut().region_obligations)\n     }\n \n-    /// NOTE: Prefer using `TypeErrCtxt::check_region_obligations_and_report_errors`\n-    /// instead of calling this directly.\n-    ///\n     /// Process the region obligations that must be proven (during\n     /// `regionck`) for the given `body_id`, given information about\n-    /// the region bounds in scope and so forth. This function must be\n-    /// invoked for all relevant body-ids before region inference is\n-    /// done (or else an assert will fire).\n+    /// the region bounds in scope and so forth.\n     ///\n     /// See the `region_obligations` field of `InferCtxt` for some\n     /// comments about how this function fits into the overall expected\n     /// flow of the inferencer. The key point is that it is\n     /// invoked after all type-inference variables have been bound --\n-    /// towards the end of regionck. This also ensures that the\n-    /// region-bound-pairs are available (see comments above regarding\n-    /// closures).\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `region_bound_pairs_map`: the set of region bounds implied by\n-    ///   the parameters and where-clauses. In particular, each pair\n-    ///   `('a, K)` in this list tells us that the bounds in scope\n-    ///   indicate that `K: 'a`, where `K` is either a generic\n-    ///   parameter like `T` or a projection like `T::Item`.\n-    /// - `param_env` is the parameter environment for the enclosing function.\n-    /// - `body_id` is the body-id whose region obligations are being\n-    ///   processed.\n-    #[instrument(level = \"debug\", skip(self, region_bound_pairs))]\n-    pub fn process_registered_region_obligations(\n-        &self,\n-        region_bound_pairs: &RegionBoundPairs<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) {\n+    /// right before lexical region resolution.\n+    #[instrument(level = \"debug\", skip(self, outlives_env))]\n+    pub fn process_registered_region_obligations(&self, outlives_env: &OutlivesEnvironment<'tcx>) {\n         assert!(\n             !self.in_snapshot.get(),\n             \"cannot process registered region obligations in a snapshot\"\n@@ -153,15 +133,16 @@ impl<'tcx> InferCtxt<'tcx> {\n         let my_region_obligations = self.take_registered_region_obligations();\n \n         for RegionObligation { sup_type, sub_region, origin } in my_region_obligations {\n-            debug!(\n-                \"process_registered_region_obligations: sup_type={:?} sub_region={:?} origin={:?}\",\n-                sup_type, sub_region, origin\n-            );\n-\n+            debug!(?sup_type, ?sub_region, ?origin);\n             let sup_type = self.resolve_vars_if_possible(sup_type);\n \n-            let outlives =\n-                &mut TypeOutlives::new(self, self.tcx, &region_bound_pairs, None, param_env);\n+            let outlives = &mut TypeOutlives::new(\n+                self,\n+                self.tcx,\n+                &outlives_env.region_bound_pairs(),\n+                None,\n+                outlives_env.param_env,\n+            );\n             let category = origin.to_constraint_category();\n             outlives.type_must_outlive(origin, sup_type, sub_region, category);\n         }"}, {"sha": "b8940e2f0456c60a13b0353d4c6d1998a185e9eb", "filename": "compiler/rustc_infer/src/traits/engine.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -36,6 +36,7 @@ pub trait TraitEngine<'tcx>: 'tcx {\n         obligation: PredicateObligation<'tcx>,\n     );\n \n+    #[must_use]\n     fn select_where_possible(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>>;\n \n     fn collect_remaining_errors(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>>;\n@@ -58,6 +59,7 @@ pub trait TraitEngineExt<'tcx> {\n         obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n     );\n \n+    #[must_use]\n     fn select_all_or_error(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>>;\n }\n "}, {"sha": "3cbb2c21e289e9c72c7f4cc7559dd0abc329f081", "filename": "compiler/rustc_log/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_log%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_log%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_log%2Fsrc%2Flib.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -40,7 +40,6 @@\n \n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n-#![feature(is_terminal)]\n \n use std::env::{self, VarError};\n use std::fmt::{self, Display};"}, {"sha": "96c1577d52bcb42aa08646552cc8cca24fd0e068", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 80, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -7,8 +7,8 @@ use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n use crate::ty::visit::ValidateBoundVars;\n use crate::ty::InferTy::*;\n use crate::ty::{\n-    self, AdtDef, Discr, FallibleTypeFolder, Term, Ty, TyCtxt, TypeFlags, TypeFoldable,\n-    TypeSuperFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,\n+    self, AdtDef, Discr, Term, Ty, TyCtxt, TypeFlags, TypeSuperVisitable, TypeVisitable,\n+    TypeVisitableExt, TypeVisitor,\n };\n use crate::ty::{List, ParamEnv};\n use hir::def::DefKind;\n@@ -1156,81 +1156,6 @@ where\n     }\n }\n \n-struct SkipBindersAt<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    index: ty::DebruijnIndex,\n-}\n-\n-impl<'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for SkipBindersAt<'tcx> {\n-    type Error = ();\n-\n-    fn interner(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn try_fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Result<Binder<'tcx, T>, Self::Error>\n-    where\n-        T: ty::TypeFoldable<TyCtxt<'tcx>>,\n-    {\n-        self.index.shift_in(1);\n-        let value = t.try_map_bound(|t| t.try_fold_with(self));\n-        self.index.shift_out(1);\n-        value\n-    }\n-\n-    fn try_fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n-        if !ty.has_escaping_bound_vars() {\n-            Ok(ty)\n-        } else if let ty::Bound(index, bv) = *ty.kind() {\n-            if index == self.index {\n-                Err(())\n-            } else {\n-                Ok(self.interner().mk_bound(index.shifted_out(1), bv))\n-            }\n-        } else {\n-            ty.try_super_fold_with(self)\n-        }\n-    }\n-\n-    fn try_fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n-        if !r.has_escaping_bound_vars() {\n-            Ok(r)\n-        } else if let ty::ReLateBound(index, bv) = r.kind() {\n-            if index == self.index {\n-                Err(())\n-            } else {\n-                Ok(self.interner().mk_re_late_bound(index.shifted_out(1), bv))\n-            }\n-        } else {\n-            r.try_super_fold_with(self)\n-        }\n-    }\n-\n-    fn try_fold_const(&mut self, ct: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, Self::Error> {\n-        if !ct.has_escaping_bound_vars() {\n-            Ok(ct)\n-        } else if let ty::ConstKind::Bound(index, bv) = ct.kind() {\n-            if index == self.index {\n-                Err(())\n-            } else {\n-                Ok(self.interner().mk_const(\n-                    ty::ConstKind::Bound(index.shifted_out(1), bv),\n-                    ct.ty().try_fold_with(self)?,\n-                ))\n-            }\n-        } else {\n-            ct.try_super_fold_with(self)\n-        }\n-    }\n-\n-    fn try_fold_predicate(\n-        &mut self,\n-        p: ty::Predicate<'tcx>,\n-    ) -> Result<ty::Predicate<'tcx>, Self::Error> {\n-        if !p.has_escaping_bound_vars() { Ok(p) } else { p.try_super_fold_with(self) }\n-    }\n-}\n-\n /// Represents the projection of an associated type.\n ///\n /// For a projection, this would be `<Ty as Trait<...>>::N`.\n@@ -1772,10 +1697,10 @@ impl<'tcx> Region<'tcx> {\n         matches!(self.kind(), ty::ReVar(_))\n     }\n \n-    pub fn as_var(self) -> Option<RegionVid> {\n+    pub fn as_var(self) -> RegionVid {\n         match self.kind() {\n-            ty::ReVar(vid) => Some(vid),\n-            _ => None,\n+            ty::ReVar(vid) => vid,\n+            _ => bug!(\"expected region {:?} to be of kind ReVar\", self),\n         }\n     }\n }"}, {"sha": "182d995c4eb067bf6557c61864b207f8829f47af", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -9,7 +9,6 @@ use crate::infer::InferCtxt;\n use crate::traits::project::ProjectAndUnifyResult;\n use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{ImplPolarity, Region, RegionVid};\n \n@@ -187,7 +186,8 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n             panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\", trait_did, ty, errors);\n         }\n \n-        infcx.process_registered_region_obligations(&Default::default(), full_env);\n+        let outlives_env = OutlivesEnvironment::new(full_env);\n+        infcx.process_registered_region_obligations(&outlives_env);\n \n         let region_data =\n             infcx.inner.borrow_mut().unwrap_region_constraints().region_constraint_data().clone();\n@@ -851,23 +851,3 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n         infcx.freshen(p)\n     }\n }\n-\n-/// Replaces all ReVars in a type with ty::Region's, using the provided map\n-pub struct RegionReplacer<'a, 'tcx> {\n-    vid_to_region: &'a FxHashMap<ty::RegionVid, ty::Region<'tcx>>,\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for RegionReplacer<'a, 'tcx> {\n-    fn interner(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        (match *r {\n-            ty::ReVar(vid) => self.vid_to_region.get(&vid).cloned(),\n-            _ => None,\n-        })\n-        .unwrap_or_else(|| r.super_fold_with(self))\n-    }\n-}"}, {"sha": "3c918b6028d475b584d83b1e6e3dbf0f88f81f11", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -405,9 +405,6 @@ fn resolve_negative_obligation<'tcx>(\n         param_env,\n         infcx.implied_bounds_tys(param_env, body_def_id, wf_tys),\n     );\n-\n-    infcx.process_registered_region_obligations(outlives_env.region_bound_pairs(), param_env);\n-\n     infcx.resolve_regions(&outlives_env).is_empty()\n }\n "}, {"sha": "2beebe94b6d1d3e5b93da70cc90089da6a9cde72", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -6,11 +6,13 @@ use super::{ChalkFulfillmentContext, FulfillmentContext};\n use crate::solve::FulfillmentCtxt as NextFulfillmentCtxt;\n use crate::traits::NormalizeExt;\n use rustc_data_structures::fx::FxIndexSet;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{\n     Canonical, CanonicalQueryResponse, CanonicalVarValues, QueryResponse,\n };\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk};\n use rustc_infer::traits::query::Fallible;\n use rustc_infer::traits::{\n@@ -173,14 +175,33 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n+    #[must_use]\n     pub fn select_where_possible(&self) -> Vec<FulfillmentError<'tcx>> {\n         self.engine.borrow_mut().select_where_possible(self.infcx)\n     }\n \n+    #[must_use]\n     pub fn select_all_or_error(&self) -> Vec<FulfillmentError<'tcx>> {\n         self.engine.borrow_mut().select_all_or_error(self.infcx)\n     }\n \n+    /// Resolves regions and reports errors.\n+    ///\n+    /// Takes ownership of the context as doing trait solving afterwards\n+    /// will result in region constraints getting ignored.\n+    pub fn resolve_regions_and_report_errors(\n+        self,\n+        generic_param_scope: LocalDefId,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+    ) -> Result<(), ErrorGuaranteed> {\n+        let errors = self.infcx.resolve_regions(&outlives_env);\n+        if errors.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(self.infcx.err_ctxt().report_region_errors(generic_param_scope, &errors))\n+        }\n+    }\n+\n     pub fn assumed_wf_types(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,"}, {"sha": "210083fc4eb657723364c55fa7fcd2d4b0d84556", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -1776,7 +1776,10 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n                 // constrain inference variables a bit more to nested obligations from normalize so\n                 // we can have more helpful errors.\n-                ocx.select_where_possible();\n+                //\n+                // we intentionally drop errors from normalization here,\n+                // since the normalization is just done to improve the error message.\n+                let _ = ocx.select_where_possible();\n \n                 if let Err(new_err) = ocx.eq_exp(\n                     &obligation.cause,"}, {"sha": "af567c074384e8fefb4dbb8d267f0a1ad2d117c9", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -117,10 +117,6 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n                     FxIndexSet::from_iter([self_type]),\n                 ),\n             );\n-            infcx.process_registered_region_obligations(\n-                outlives_env.region_bound_pairs(),\n-                param_env,\n-            );\n             let errors = infcx.resolve_regions(&outlives_env);\n             if !errors.is_empty() {\n                 infringing.push((field, ty, InfringingFieldsReason::Regions(errors)));"}, {"sha": "da675379cd58bfc0d70e8675cea0bae76e3160aa", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -3183,7 +3183,7 @@ impl<'a, K: Ord, V, A: Allocator + Clone> CursorMut<'a, K, V, A> {\n                 panic!(\"key must be ordered above the current element\");\n             }\n         }\n-        if let Some((next, _)) = self.peek_prev() {\n+        if let Some((next, _)) = self.peek_next() {\n             if &key >= next {\n                 panic!(\"key must be ordered below the next element\");\n             }"}, {"sha": "4311f21c925cda7a7ffdcab338ee78085cf4e92c", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -2385,3 +2385,67 @@ fn test_cursor_mut() {\n     assert_eq!(cur.key(), Some(&4));\n     assert_eq!(map, BTreeMap::from([(0, '?'), (1, 'a'), (3, 'c'), (4, 'd')]));\n }\n+\n+#[should_panic(expected = \"key must be ordered above the previous element\")]\n+#[test]\n+fn test_cursor_mut_insert_before_1() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_before(0, 'd');\n+}\n+\n+#[should_panic(expected = \"key must be ordered above the previous element\")]\n+#[test]\n+fn test_cursor_mut_insert_before_2() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_before(1, 'd');\n+}\n+\n+#[should_panic(expected = \"key must be ordered below the current element\")]\n+#[test]\n+fn test_cursor_mut_insert_before_3() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_before(2, 'd');\n+}\n+\n+#[should_panic(expected = \"key must be ordered below the current element\")]\n+#[test]\n+fn test_cursor_mut_insert_before_4() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_before(3, 'd');\n+}\n+\n+#[should_panic(expected = \"key must be ordered above the current element\")]\n+#[test]\n+fn test_cursor_mut_insert_after_1() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_after(1, 'd');\n+}\n+\n+#[should_panic(expected = \"key must be ordered above the current element\")]\n+#[test]\n+fn test_cursor_mut_insert_after_2() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_after(2, 'd');\n+}\n+\n+#[should_panic(expected = \"key must be ordered below the next element\")]\n+#[test]\n+fn test_cursor_mut_insert_after_3() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_after(3, 'd');\n+}\n+\n+#[should_panic(expected = \"key must be ordered below the next element\")]\n+#[test]\n+fn test_cursor_mut_insert_after_4() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_after(4, 'd');\n+}"}, {"sha": "7e7b6b4dbe9b1f1c7fea6c245adc81e51250c157", "filename": "library/core/src/panic/unwind_safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -28,7 +28,7 @@ use crate::task::{Context, Poll};\n /// 2. This broken invariant is then later observed.\n ///\n /// Typically in Rust, it is difficult to perform step (2) because catching a\n-/// panic involves either spawning a thread (which in turns makes it difficult\n+/// panic involves either spawning a thread (which in turn makes it difficult\n /// to later witness broken invariants) or using the `catch_unwind` function in this\n /// module. Additionally, even if an invariant is witnessed, it typically isn't a\n /// problem in Rust because there are no uninitialized values (like in C or C++)."}, {"sha": "020c723925aebc412dc79328350ca7c2d8244fcc", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -268,7 +268,7 @@ pub(crate) use self::stdio::attempt_print_to_stderr;\n #[unstable(feature = \"internal_output_capture\", issue = \"none\")]\n #[doc(no_inline, hidden)]\n pub use self::stdio::set_output_capture;\n-#[unstable(feature = \"is_terminal\", issue = \"98070\")]\n+#[stable(feature = \"is_terminal\", since = \"CURRENT_RUSTC_VERSION\")]\n pub use self::stdio::IsTerminal;\n #[unstable(feature = \"print_internals\", issue = \"none\")]\n pub use self::stdio::{_eprint, _print};"}, {"sha": "b2c57b8ddc78e6bdda75a95a16d1488ef5318bd9", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -1047,7 +1047,7 @@ pub(crate) fn attempt_print_to_stderr(args: fmt::Arguments<'_>) {\n }\n \n /// Trait to determine if a descriptor/handle refers to a terminal/tty.\n-#[unstable(feature = \"is_terminal\", issue = \"98070\")]\n+#[stable(feature = \"is_terminal\", since = \"CURRENT_RUSTC_VERSION\")]\n pub trait IsTerminal: crate::sealed::Sealed {\n     /// Returns `true` if the descriptor/handle refers to a terminal/tty.\n     ///\n@@ -1063,6 +1063,7 @@ pub trait IsTerminal: crate::sealed::Sealed {\n     /// Note that this [may change in the future][changes].\n     ///\n     /// [changes]: io#platform-specific-behavior\n+    #[stable(feature = \"is_terminal\", since = \"CURRENT_RUSTC_VERSION\")]\n     fn is_terminal(&self) -> bool;\n }\n \n@@ -1071,7 +1072,7 @@ macro_rules! impl_is_terminal {\n         #[unstable(feature = \"sealed\", issue = \"none\")]\n         impl crate::sealed::Sealed for $t {}\n \n-        #[unstable(feature = \"is_terminal\", issue = \"98070\")]\n+        #[stable(feature = \"is_terminal\", since = \"CURRENT_RUSTC_VERSION\")]\n         impl IsTerminal for $t {\n             #[inline]\n             fn is_terminal(&self) -> bool {"}, {"sha": "71f3576c93d4b440ec4b0f4100f49000b7862168", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -254,7 +254,6 @@\n #![feature(exhaustive_patterns)]\n #![feature(if_let_guard)]\n #![feature(intra_doc_pointers)]\n-#![feature(is_terminal)]\n #![feature(lang_items)]\n #![feature(let_chains)]\n #![feature(linkage)]"}, {"sha": "6a6e6f33158fc5c654ca4d250958a5a3c22cf64e", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -201,7 +201,7 @@ macro_rules! impl_is_terminal {\n         #[unstable(feature = \"sealed\", issue = \"none\")]\n         impl crate::sealed::Sealed for $t {}\n \n-        #[unstable(feature = \"is_terminal\", issue = \"98070\")]\n+        #[stable(feature = \"is_terminal\", since = \"CURRENT_RUSTC_VERSION\")]\n         impl crate::io::IsTerminal for $t {\n             #[inline]\n             fn is_terminal(&self) -> bool {"}, {"sha": "f6622874625fcfc8e15b3a5c2a6dd6d387104190", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -389,7 +389,7 @@ macro_rules! impl_is_terminal {\n         #[unstable(feature = \"sealed\", issue = \"none\")]\n         impl crate::sealed::Sealed for $t {}\n \n-        #[unstable(feature = \"is_terminal\", issue = \"98070\")]\n+        #[stable(feature = \"is_terminal\", since = \"CURRENT_RUSTC_VERSION\")]\n         impl crate::io::IsTerminal for $t {\n             #[inline]\n             fn is_terminal(&self) -> bool {"}, {"sha": "9fb31ed7663d051722c6192a0f845a613012e9b2", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -17,7 +17,6 @@\n #![unstable(feature = \"test\", issue = \"50297\")]\n #![doc(test(attr(deny(warnings))))]\n #![feature(internal_output_capture)]\n-#![feature(is_terminal)]\n #![feature(staged_api)]\n #![feature(process_exitcode_internals)]\n #![feature(panic_can_unwind)]"}, {"sha": "b3640eab95339e2445e2b3fb7c00811eb581333a", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -7,7 +7,6 @@\n #![feature(assert_matches)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n-#![feature(is_terminal)]\n #![feature(let_chains)]\n #![feature(test)]\n #![feature(never_type)]"}, {"sha": "f67a718ba73a91508354fbada1002294437b437d", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -7,7 +7,6 @@\n #![feature(yeet_expr)]\n #![feature(nonzero_ops)]\n #![feature(local_key_cell_methods)]\n-#![feature(is_terminal)]\n #![feature(round_ties_even)]\n // Configure clippy and other lints\n #![allow("}, {"sha": "e379288de01cbf06911c97cfa4e90446b137b803", "filename": "src/tools/miri/tests/pass/shims/fs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -3,7 +3,6 @@\n \n #![feature(io_error_more)]\n #![feature(io_error_uncategorized)]\n-#![feature(is_terminal)]\n \n use std::collections::HashMap;\n use std::ffi::{c_char, OsString};"}, {"sha": "295723957a4265fe55f08986076a9597f6c13392", "filename": "src/tools/miri/tests/pass/shims/io.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fio.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -1,5 +1,3 @@\n-#![feature(is_terminal)]\n-\n use std::io::IsTerminal;\n \n fn main() {"}, {"sha": "d985386423d29c07debe82952e73a53f703341b4", "filename": "tests/ui/traits/non_lifetime_binders/missing-assoc-item.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fmissing-assoc-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fmissing-assoc-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fmissing-assoc-item.stderr?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -11,7 +11,12 @@ error[E0223]: ambiguous associated type\n   --> $DIR/missing-assoc-item.rs:6:12\n    |\n LL |     for<B> B::Item: Send,\n-   |            ^^^^^^^ help: use the fully-qualified path: `<B as IntoIterator>::Item`\n+   |            ^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `Item` implemented for `B`, you could use the fully-qualified path\n+   |\n+LL |     for<B> <B as Example>::Item: Send,\n+   |            ~~~~~~~~~~~~~~~~~~~~\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "f124b58b5b605c234e58d3d346b7525c1329e0b2", "filename": "tests/ui/typeck/issue-110052.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/tests%2Fui%2Ftypeck%2Fissue-110052.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/tests%2Fui%2Ftypeck%2Fissue-110052.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-110052.rs?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -0,0 +1,12 @@\n+// Makes sure we deal with escaping lifetimes *above* INNERMOST when\n+// suggesting trait for ambiguous associated type.\n+\n+impl<I, V> Validator<I> for ()\n+where\n+    for<'iter> dyn Validator<<&'iter I>::Item>:,\n+    //~^ ERROR ambiguous associated type\n+{}\n+\n+pub trait Validator<T> {}\n+\n+fn main() {}"}, {"sha": "0c15c03a7408de20612cacf16c748d7a069c9faf", "filename": "tests/ui/typeck/issue-110052.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fab99073b01539ce2664366011c7f3e378e52b7e/tests%2Fui%2Ftypeck%2Fissue-110052.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fab99073b01539ce2664366011c7f3e378e52b7e/tests%2Fui%2Ftypeck%2Fissue-110052.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-110052.stderr?ref=fab99073b01539ce2664366011c7f3e378e52b7e", "patch": "@@ -0,0 +1,9 @@\n+error[E0223]: ambiguous associated type\n+  --> $DIR/issue-110052.rs:6:30\n+   |\n+LL |     for<'iter> dyn Validator<<&'iter I>::Item>:,\n+   |                              ^^^^^^^^^^^^^^^^ help: use the fully-qualified path: `<&'iter I as IntoIterator>::Item`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0223`."}]}