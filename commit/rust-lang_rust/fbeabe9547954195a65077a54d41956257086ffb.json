{"sha": "fbeabe9547954195a65077a54d41956257086ffb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiZWFiZTk1NDc5NTQxOTVhNjUwNzdhNTRkNDE5NTYyNTcwODZmZmI=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-10-24T23:09:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-24T23:09:12Z"}, "message": "Merge pull request #3113 from scampi/issue3105\n\nFix handling of code that is annotated with rustfmt::skip.", "tree": {"sha": "6aa426c54dbdadcbee3f9f9e3ed470a82b078e41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6aa426c54dbdadcbee3f9f9e3ed470a82b078e41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbeabe9547954195a65077a54d41956257086ffb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb0PuYCRBK7hj4Ov3rIwAAdHIIAHDdDppoVcZ5UiGkOSCaX9/h\nMBbR+nsOhyWzeN4sMtNit92XXzae2I0y5KK7fmCJ/zHMoCnhXqfjX7oWa9ZWcr3w\nNcZ1ilZtUX/k9ExKalMZevtl6WgFQ/HABEtlNlPN0mytwUkvw21JuJNpj1O7WECA\nqfBFAOxM8VoJATI8U6RjemHi9xNHJo/n0rqHEiB+dnYUVBqkRyu1Pqw/Fh4K92Vn\ncClHs8UveHCbTuuBQgWpFW5KNZ9LU84wh6mhVi5BzZ44XvobiTnMIW6uc7fDmfN/\nxYHLw5WN5ehLFKAVOkuBUxgZ9ZlSDGAVofsEbAm7YtmssvMNxFAQCho5XiDcrKA=\n=O1bT\n-----END PGP SIGNATURE-----\n", "payload": "tree 6aa426c54dbdadcbee3f9f9e3ed470a82b078e41\nparent 4789f65041d428a597f91cea9ad90b548b93cb28\nparent 2f5d864c086df35a57b65400b2e0f3f90e52d1ea\nauthor Nick Cameron <nrc@ncameron.org> 1540422552 +1300\ncommitter GitHub <noreply@github.com> 1540422552 +1300\n\nMerge pull request #3113 from scampi/issue3105\n\nFix handling of code that is annotated with rustfmt::skip."}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbeabe9547954195a65077a54d41956257086ffb", "html_url": "https://github.com/rust-lang/rust/commit/fbeabe9547954195a65077a54d41956257086ffb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbeabe9547954195a65077a54d41956257086ffb/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4789f65041d428a597f91cea9ad90b548b93cb28", "url": "https://api.github.com/repos/rust-lang/rust/commits/4789f65041d428a597f91cea9ad90b548b93cb28", "html_url": "https://github.com/rust-lang/rust/commit/4789f65041d428a597f91cea9ad90b548b93cb28"}, {"sha": "2f5d864c086df35a57b65400b2e0f3f90e52d1ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f5d864c086df35a57b65400b2e0f3f90e52d1ea", "html_url": "https://github.com/rust-lang/rust/commit/2f5d864c086df35a57b65400b2e0f3f90e52d1ea"}], "stats": {"total": 277, "additions": 196, "deletions": 81}, "files": [{"sha": "e76bb3318562e78d85a5036121de00df03ef4557", "filename": "src/comment.rs", "status": "modified", "additions": 6, "deletions": 47, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/fbeabe9547954195a65077a54d41956257086ffb/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbeabe9547954195a65077a54d41956257086ffb/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=fbeabe9547954195a65077a54d41956257086ffb", "patch": "@@ -19,7 +19,7 @@ use config::Config;\n use rewrite::RewriteContext;\n use shape::{Indent, Shape};\n use string::{rewrite_string, StringFormat};\n-use utils::{count_newlines, first_line_width, last_line_width};\n+use utils::{count_newlines, first_line_width, last_line_width, trim_left_preserve_layout};\n use {ErrorKind, FormattingError};\n \n fn is_custom_comment(comment: &str) -> bool {\n@@ -332,12 +332,12 @@ fn identify_comment(\n     let (first_group, rest) = orig.split_at(first_group_ending);\n     let rewritten_first_group =\n         if !config.normalize_comments() && has_bare_lines && style.is_block_comment() {\n-            light_rewrite_block_comment_with_bare_lines(first_group, shape, config)?\n+            trim_left_preserve_layout(first_group, &shape.indent, config)\n         } else if !config.normalize_comments()\n             && !config.wrap_comments()\n             && !config.format_doc_comments()\n         {\n-            light_rewrite_comment(first_group, shape.indent, config, is_doc_comment)?\n+            light_rewrite_comment(first_group, shape.indent, config, is_doc_comment)\n         } else {\n             rewrite_comment_inner(\n                 first_group,\n@@ -370,47 +370,6 @@ fn identify_comment(\n     }\n }\n \n-/// Trims a minimum of leading whitespaces so that the content layout is kept and aligns to indent.\n-fn light_rewrite_block_comment_with_bare_lines(\n-    orig: &str,\n-    shape: Shape,\n-    config: &Config,\n-) -> Option<String> {\n-    let prefix_whitespace_min = orig\n-        .lines()\n-        // skip the line with the starting sigil since the leading whitespace is removed\n-        // otherwise, the minimum would always be zero\n-        .skip(1)\n-        .filter(|line| !line.is_empty())\n-        .map(|line| {\n-            let mut width = 0;\n-            for c in line.chars() {\n-                match c {\n-                    ' ' => width += 1,\n-                    '\\t' => width += config.tab_spaces(),\n-                    _ => break,\n-                }\n-            }\n-            width\n-        })\n-        .min()?;\n-\n-    let indent_str = shape.indent.to_string(config);\n-    let mut lines = orig.lines();\n-    let first_line = lines.next()?;\n-    let rest = lines\n-        .map(|line| {\n-            if line.is_empty() {\n-                line\n-            } else {\n-                &line[prefix_whitespace_min..]\n-            }\n-        })\n-        .collect::<Vec<&str>>()\n-        .join(&format!(\"\\n{}\", indent_str));\n-    Some(format!(\"{}\\n{}{}\", first_line, indent_str, rest))\n-}\n-\n /// Attributes for code blocks in rustdoc.\n /// See https://doc.rust-lang.org/rustdoc/print.html#attributes\n enum CodeBlockAttribute {\n@@ -661,7 +620,7 @@ impl<'a> CommentRewrite<'a> {\n                         let mut config = self.fmt.config.clone();\n                         config.set().format_doc_comments(false);\n                         match ::format_code_block(&self.code_block_buffer, &config) {\n-                            Some(ref s) => trim_custom_comment_prefix(s),\n+                            Some(ref s) => trim_custom_comment_prefix(&s.snippet),\n                             None => trim_custom_comment_prefix(&self.code_block_buffer),\n                         }\n                     }\n@@ -912,7 +871,7 @@ fn light_rewrite_comment(\n     offset: Indent,\n     config: &Config,\n     is_doc_comment: bool,\n-) -> Option<String> {\n+) -> String {\n     let lines: Vec<&str> = orig\n         .lines()\n         .map(|l| {\n@@ -933,7 +892,7 @@ fn light_rewrite_comment(\n             trim_right_unless_two_whitespaces(left_trimmed, is_doc_comment)\n         })\n         .collect();\n-    Some(lines.join(&format!(\"\\n{}\", offset.to_string(config))))\n+    lines.join(&format!(\"\\n{}\", offset.to_string(config)))\n }\n \n /// Trims comment characters and possibly a single space from the left of a string."}, {"sha": "039276ba6e886b39a54b1581d3ef459ce30833f7", "filename": "src/formatting.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbeabe9547954195a65077a54d41956257086ffb/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbeabe9547954195a65077a54d41956257086ffb/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=fbeabe9547954195a65077a54d41956257086ffb", "patch": "@@ -173,6 +173,8 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n         if visitor.macro_rewrite_failure {\n             self.report.add_macro_format_failure();\n         }\n+        self.report\n+            .add_non_formatted_ranges(visitor.skipped_range.clone());\n \n         self.handler\n             .handle_formatted_file(path, visitor.buffer.to_owned(), &mut self.report)"}, {"sha": "2dcbf823d5560e5117d6bef2de7c656401a125e8", "filename": "src/lib.rs", "status": "modified", "additions": 66, "deletions": 17, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/fbeabe9547954195a65077a54d41956257086ffb/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbeabe9547954195a65077a54d41956257086ffb/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=fbeabe9547954195a65077a54d41956257086ffb", "patch": "@@ -144,22 +144,56 @@ impl From<io::Error> for ErrorKind {\n     }\n }\n \n+/// Result of formatting a snippet of code along with ranges of lines that didn't get formatted,\n+/// i.e., that got returned as they were originally.\n+#[derive(Debug)]\n+struct FormattedSnippet {\n+    snippet: String,\n+    non_formatted_ranges: Vec<(usize, usize)>,\n+}\n+\n+impl FormattedSnippet {\n+    /// In case the snippet needed to be wrapped in a function, this shifts down the ranges of\n+    /// non-formatted code.\n+    fn unwrap_code_block(&mut self) {\n+        self.non_formatted_ranges\n+            .iter_mut()\n+            .for_each(|(low, high)| {\n+                *low -= 1;\n+                *high -= 1;\n+            });\n+    }\n+\n+    /// Returns true if the line n did not get formatted.\n+    fn is_line_non_formatted(&self, n: usize) -> bool {\n+        self.non_formatted_ranges\n+            .iter()\n+            .any(|(low, high)| *low <= n && n <= *high)\n+    }\n+}\n+\n /// Reports on any issues that occurred during a run of Rustfmt.\n ///\n /// Can be reported to the user via its `Display` implementation of `print_fancy`.\n #[derive(Clone)]\n pub struct FormatReport {\n     // Maps stringified file paths to their associated formatting errors.\n     internal: Rc<RefCell<(FormatErrorMap, ReportedErrors)>>,\n+    non_formatted_ranges: Vec<(usize, usize)>,\n }\n \n impl FormatReport {\n     fn new() -> FormatReport {\n         FormatReport {\n             internal: Rc::new(RefCell::new((HashMap::new(), ReportedErrors::default()))),\n+            non_formatted_ranges: Vec::new(),\n         }\n     }\n \n+    fn add_non_formatted_ranges(&mut self, mut ranges: Vec<(usize, usize)>) {\n+        self.non_formatted_ranges.append(&mut ranges);\n+    }\n+\n     fn append(&self, f: FileName, mut v: Vec<FormattingError>) {\n         self.track_errors(&v);\n         self.internal\n@@ -349,37 +383,44 @@ impl fmt::Display for FormatReport {\n \n /// Format the given snippet. The snippet is expected to be *complete* code.\n /// When we cannot parse the given snippet, this function returns `None`.\n-fn format_snippet(snippet: &str, config: &Config) -> Option<String> {\n+fn format_snippet(snippet: &str, config: &Config) -> Option<FormattedSnippet> {\n     let mut config = config.clone();\n-    let out = panic::catch_unwind(|| {\n+    panic::catch_unwind(|| {\n         let mut out: Vec<u8> = Vec::with_capacity(snippet.len() * 2);\n         config.set().emit_mode(config::EmitMode::Stdout);\n         config.set().verbose(Verbosity::Quiet);\n         config.set().hide_parse_errors(true);\n-        let formatting_error = {\n+\n+        let (formatting_error, result) = {\n             let input = Input::Text(snippet.into());\n             let mut session = Session::new(config, Some(&mut out));\n             let result = session.format(input);\n-            session.errors.has_macro_format_failure\n-                || session.out.as_ref().unwrap().is_empty() && !snippet.is_empty()\n-                || result.is_err()\n+            (\n+                session.errors.has_macro_format_failure\n+                    || session.out.as_ref().unwrap().is_empty() && !snippet.is_empty()\n+                    || result.is_err(),\n+                result,\n+            )\n         };\n         if formatting_error {\n             None\n         } else {\n-            Some(out)\n+            String::from_utf8(out).ok().map(|snippet| FormattedSnippet {\n+                snippet,\n+                non_formatted_ranges: result.unwrap().non_formatted_ranges,\n+            })\n         }\n     })\n-    .ok()??; // The first try operator handles the error from catch_unwind,\n-             // whereas the second one handles None from the closure.\n-    String::from_utf8(out).ok()\n+    // Discard panics encountered while formatting the snippet\n+    // The ? operator is needed to remove the extra Option\n+    .ok()?\n }\n \n /// Format the given code block. Mainly targeted for code block in comment.\n /// The code block may be incomplete (i.e. parser may be unable to parse it).\n /// To avoid panic in parser, we wrap the code block with a dummy function.\n /// The returned code block does *not* end with newline.\n-fn format_code_block(code_snippet: &str, config: &Config) -> Option<String> {\n+fn format_code_block(code_snippet: &str, config: &Config) -> Option<FormattedSnippet> {\n     const FN_MAIN_PREFIX: &str = \"fn main() {\\n\";\n \n     fn enclose_in_main_block(s: &str, config: &Config) -> String {\n@@ -412,13 +453,18 @@ fn format_code_block(code_snippet: &str, config: &Config) -> Option<String> {\n     config_with_unix_newline\n         .set()\n         .newline_style(NewlineStyle::Unix);\n-    let formatted = format_snippet(&snippet, &config_with_unix_newline)?;\n+    let mut formatted = format_snippet(&snippet, &config_with_unix_newline)?;\n+    // Remove wrapping main block\n+    formatted.unwrap_code_block();\n \n     // Trim \"fn main() {\" on the first line and \"}\" on the last line,\n     // then unindent the whole code block.\n-    let block_len = formatted.rfind('}').unwrap_or(formatted.len());\n+    let block_len = formatted\n+        .snippet\n+        .rfind('}')\n+        .unwrap_or(formatted.snippet.len());\n     let mut is_indented = true;\n-    for (kind, ref line) in LineClasses::new(&formatted[FN_MAIN_PREFIX.len()..block_len]) {\n+    for (kind, ref line) in LineClasses::new(&formatted.snippet[FN_MAIN_PREFIX.len()..block_len]) {\n         if !is_first {\n             result.push('\\n');\n         } else {\n@@ -451,7 +497,10 @@ fn format_code_block(code_snippet: &str, config: &Config) -> Option<String> {\n         result.push_str(trimmed_line);\n         is_indented = !kind.is_string() || line.ends_with('\\\\');\n     }\n-    Some(result)\n+    Some(FormattedSnippet {\n+        snippet: result,\n+        non_formatted_ranges: formatted.non_formatted_ranges,\n+    })\n }\n \n /// A session is a run of rustfmt across a single or multiple inputs.\n@@ -571,10 +620,10 @@ mod unit_tests {\n \n     fn test_format_inner<F>(formatter: F, input: &str, expected: &str) -> bool\n     where\n-        F: Fn(&str, &Config) -> Option<String>,\n+        F: Fn(&str, &Config) -> Option<FormattedSnippet>,\n     {\n         let output = formatter(input, &Config::default());\n-        output.is_some() && output.unwrap() == expected\n+        output.is_some() && output.unwrap().snippet == expected\n     }\n \n     #[test]"}, {"sha": "d378bb8ffb1499595184c6c96034906579d53f7d", "filename": "src/macros.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fbeabe9547954195a65077a54d41956257086ffb/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbeabe9547954195a65077a54d41956257086ffb/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=fbeabe9547954195a65077a54d41956257086ffb", "patch": "@@ -1323,7 +1323,7 @@ impl MacroBranch {\n         config.set().max_width(new_width);\n \n         // First try to format as items, then as statements.\n-        let new_body = match ::format_snippet(&body_str, &config) {\n+        let new_body_snippet = match ::format_snippet(&body_str, &config) {\n             Some(new_body) => new_body,\n             None => {\n                 let new_width = new_width + config.tab_spaces();\n@@ -1334,15 +1334,23 @@ impl MacroBranch {\n                 }\n             }\n         };\n-        let new_body = wrap_str(new_body, config.max_width(), shape)?;\n+        let new_body = wrap_str(\n+            new_body_snippet.snippet.to_string(),\n+            config.max_width(),\n+            shape,\n+        )?;\n \n         // Indent the body since it is in a block.\n         let indent_str = body_indent.to_string(&config);\n         let mut new_body = LineClasses::new(new_body.trim_right())\n+            .enumerate()\n             .fold(\n                 (String::new(), true),\n-                |(mut s, need_indent), (kind, ref l)| {\n-                    if !l.is_empty() && need_indent {\n+                |(mut s, need_indent), (i, (kind, ref l))| {\n+                    if !l.is_empty()\n+                        && need_indent\n+                        && !new_body_snippet.is_line_non_formatted(i + 1)\n+                    {\n                         s += &indent_str;\n                     }\n                     (s + l + \"\\n\", !kind.is_string() || l.ends_with('\\\\'))"}, {"sha": "a2d15b820eb657d768ab45ca37dd8ed7c14b7ba5", "filename": "src/utils.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fbeabe9547954195a65077a54d41956257086ffb/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbeabe9547954195a65077a54d41956257086ffb/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=fbeabe9547954195a65077a54d41956257086ffb", "patch": "@@ -21,8 +21,9 @@ use syntax::ptr;\n use syntax::source_map::{BytePos, Span, NO_EXPANSION};\n \n use comment::{filter_normal_code, CharClasses, FullCodeCharKind};\n+use config::Config;\n use rewrite::RewriteContext;\n-use shape::Shape;\n+use shape::{Indent, Shape};\n \n pub const DEPR_SKIP_ANNOTATION: &str = \"rustfmt_skip\";\n pub const SKIP_ANNOTATION: &str = \"rustfmt::skip\";\n@@ -482,6 +483,44 @@ pub fn remove_trailing_white_spaces(text: &str) -> String {\n     buffer\n }\n \n+/// Trims a minimum of leading whitespaces so that the content layout is kept and aligns to indent.\n+pub fn trim_left_preserve_layout(orig: &str, indent: &Indent, config: &Config) -> String {\n+    let prefix_whitespace_min = orig\n+        .lines()\n+        // skip the line with the starting sigil since the leading whitespace is removed\n+        // otherwise, the minimum would always be zero\n+        .skip(1)\n+        .filter(|line| !line.is_empty())\n+        .map(|line| {\n+            let mut width = 0;\n+            for c in line.chars() {\n+                match c {\n+                    ' ' => width += 1,\n+                    '\\t' => width += config.tab_spaces(),\n+                    _ => break,\n+                }\n+            }\n+            width\n+        })\n+        .min()\n+        .unwrap_or(0);\n+\n+    let indent_str = indent.to_string(config);\n+    let mut lines = orig.lines();\n+    let first_line = lines.next().unwrap();\n+    let rest = lines\n+        .map(|line| {\n+            if line.is_empty() {\n+                String::from(\"\\n\")\n+            } else {\n+                format!(\"\\n{}{}\", indent_str, &line[prefix_whitespace_min..])\n+            }\n+        })\n+        .collect::<Vec<String>>()\n+        .concat();\n+    format!(\"{}{}\", first_line, rest)\n+}\n+\n #[test]\n fn test_remove_trailing_white_spaces() {\n     let s = \"    r#\\\"\\n        test\\n    \\\"#\";"}, {"sha": "b286465b2765ffcf5cc74fe5f210d1534638ba34", "filename": "src/visitor.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fbeabe9547954195a65077a54d41956257086ffb/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbeabe9547954195a65077a54d41956257086ffb/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=fbeabe9547954195a65077a54d41956257086ffb", "patch": "@@ -71,6 +71,8 @@ pub struct FmtVisitor<'a> {\n     pub is_if_else_block: bool,\n     pub snippet_provider: &'a SnippetProvider<'a>,\n     pub line_number: usize,\n+    /// List of 1-based line ranges which were annotated with skip\n+    /// Both bounds are inclusifs.\n     pub skipped_range: Vec<(usize, usize)>,\n     pub macro_rewrite_failure: bool,\n     pub(crate) report: FormatReport,\n@@ -109,8 +111,9 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 self.format_missing(stmt.span.hi());\n             }\n             ast::StmtKind::Local(..) | ast::StmtKind::Expr(..) | ast::StmtKind::Semi(..) => {\n-                if contains_skip(get_attrs_from_stmt(stmt)) {\n-                    self.push_skipped_with_span(stmt.span());\n+                let attrs = get_attrs_from_stmt(stmt);\n+                if contains_skip(attrs) {\n+                    self.push_skipped_with_span(attrs, stmt.span());\n                 } else {\n                     let shape = self.shape();\n                     let rewrite = self.with_context(|ctx| stmt.rewrite(&ctx, shape));\n@@ -120,7 +123,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             ast::StmtKind::Mac(ref mac) => {\n                 let (ref mac, _macro_style, ref attrs) = **mac;\n                 if self.visit_attrs(attrs, ast::AttrStyle::Outer) {\n-                    self.push_skipped_with_span(stmt.span());\n+                    self.push_skipped_with_span(attrs, stmt.span());\n                 } else {\n                     self.visit_mac(mac, None, MacroPosition::Statement);\n                 }\n@@ -328,14 +331,14 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             // For use items, skip rewriting attributes. Just check for a skip attribute.\n             ast::ItemKind::Use(..) => {\n                 if contains_skip(attrs) {\n-                    self.push_skipped_with_span(item.span());\n+                    self.push_skipped_with_span(attrs.as_slice(), item.span());\n                     return;\n                 }\n             }\n             // Module is inline, in this case we treat it like any other item.\n             _ if !is_mod_decl(item) => {\n                 if self.visit_attrs(&item.attrs, ast::AttrStyle::Outer) {\n-                    self.push_skipped_with_span(item.span());\n+                    self.push_skipped_with_span(item.attrs.as_slice(), item.span());\n                     return;\n                 }\n             }\n@@ -354,7 +357,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             }\n             _ => {\n                 if self.visit_attrs(&item.attrs, ast::AttrStyle::Outer) {\n-                    self.push_skipped_with_span(item.span());\n+                    self.push_skipped_with_span(item.attrs.as_slice(), item.span());\n                     return;\n                 }\n             }\n@@ -471,7 +474,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         skip_out_of_file_lines_range_visitor!(self, ti.span);\n \n         if self.visit_attrs(&ti.attrs, ast::AttrStyle::Outer) {\n-            self.push_skipped_with_span(ti.span());\n+            self.push_skipped_with_span(ti.attrs.as_slice(), ti.span());\n             return;\n         }\n \n@@ -515,7 +518,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         skip_out_of_file_lines_range_visitor!(self, ii.span);\n \n         if self.visit_attrs(&ii.attrs, ast::AttrStyle::Outer) {\n-            self.push_skipped_with_span(ii.span());\n+            self.push_skipped_with_span(ii.attrs.as_slice(), ii.span());\n             return;\n         }\n \n@@ -589,10 +592,17 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         self.push_rewrite_inner(span, rewrite);\n     }\n \n-    pub fn push_skipped_with_span(&mut self, span: Span) {\n-        self.format_missing_with_indent(source!(self, span).lo());\n-        let lo = self.line_number + 1;\n-        self.push_rewrite_inner(span, None);\n+    pub fn push_skipped_with_span(&mut self, attrs: &[ast::Attribute], item_span: Span) {\n+        self.format_missing_with_indent(source!(self, item_span).lo());\n+        // do not take into account the lines with attributes as part of the skipped range\n+        let attrs_end = attrs\n+            .iter()\n+            .map(|attr| self.source_map.lookup_char_pos(attr.span().hi()).line)\n+            .max()\n+            .unwrap_or(1);\n+        // Add 1 to get the line past the last attribute\n+        let lo = attrs_end + 1;\n+        self.push_rewrite_inner(item_span, None);\n         let hi = self.line_number + 1;\n         self.skipped_range.push((lo, hi));\n     }"}, {"sha": "4f1123805b82708738009555869f89b29c96f887", "filename": "tests/target/issue-3105.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fbeabe9547954195a65077a54d41956257086ffb/tests%2Ftarget%2Fissue-3105.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbeabe9547954195a65077a54d41956257086ffb/tests%2Ftarget%2Fissue-3105.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3105.rs?ref=fbeabe9547954195a65077a54d41956257086ffb", "patch": "@@ -0,0 +1,48 @@\n+// rustfmt-wrap_comments: true\n+\n+/// Although the indentation of the skipped method is off, it shouldn't be\n+/// changed.\n+///\n+/// ```\n+/// pub unsafe fn _mm256_shufflehi_epi16(a: __m256i, imm8: i32) -> __m256i {\n+///     let imm8 = (imm8 & 0xFF) as u8;\n+///     let a = a.as_i16x16();\n+///     macro_rules! shuffle_done {\n+///         ($x01:expr, $x23:expr, $x45:expr, $x67:expr) => {\n+///             #[cfg_attr(rustfmt, rustfmt_skip)]\n+///       simd_shuffle16(a, a, [\n+///           0, 1, 2, 3, 4+$x01, 4+$x23, 4+$x45, 4+$x67,\n+///           8, 9, 10, 11, 12+$x01, 12+$x23, 12+$x45, 12+$x67\n+///       ]);\n+///         };\n+///     }\n+/// }\n+/// ```\n+pub unsafe fn _mm256_shufflehi_epi16(a: __m256i, imm8: i32) -> __m256i {\n+    let imm8 = (imm8 & 0xFF) as u8;\n+    let a = a.as_i16x16();\n+    macro_rules! shuffle_done {\n+        ($x01:expr, $x23:expr, $x45:expr, $x67:expr) => {\n+            #[cfg_attr(rustfmt, rustfmt_skip)]\n+                         simd_shuffle16(a, a, [\n+                             0, 1, 2, 3, 4+$x01, 4+$x23, 4+$x45, 4+$x67,\n+                             8, 9, 10, 11, 12+$x01, 12+$x23, 12+$x45, 12+$x67\n+                         ]);\n+        };\n+    }\n+}\n+\n+/// The skipped method shouldn't right-shift\n+pub unsafe fn _mm256_shufflehi_epi32(a: __m256i, imm8: i32) -> __m256i {\n+    let imm8 = (imm8 & 0xFF) as u8;\n+    let a = a.as_i16x16();\n+    macro_rules! shuffle_done {\n+        ($x01:expr, $x23:expr, $x45:expr, $x67:expr) => {\n+            #[cfg_attr(rustfmt, rustfmt_skip)]\n+            simd_shuffle32(a, a, [\n+                0, 1, 2, 3, 4+$x01, 4+$x23, 4+$x45, 4+$x67,\n+                8, 9, 10, 11, 12+$x01, 12+$x23, 12+$x45, 12+$x67\n+            ]);\n+        };\n+    }\n+}"}]}