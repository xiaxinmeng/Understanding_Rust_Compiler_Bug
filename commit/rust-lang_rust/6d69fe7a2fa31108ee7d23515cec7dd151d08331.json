{"sha": "6d69fe7a2fa31108ee7d23515cec7dd151d08331", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNjlmZTdhMmZhMzExMDhlZTdkMjM1MTVjZWM3ZGQxNTFkMDgzMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-04T01:43:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-04T01:43:40Z"}, "message": "Auto merge of #54861 - rep-nop:find_main_in_doctest, r=estebank\n\nrustdoc: Replaces fn main search and extern crate search with proper parsing during doctests.\n\nFixes #21299.\nFixes #33731.\n\nLet me know if there's any additional changes you'd like made!", "tree": {"sha": "42306bbfe5108ed35ff0b7da27069e79012dd033", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42306bbfe5108ed35ff0b7da27069e79012dd033"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d69fe7a2fa31108ee7d23515cec7dd151d08331", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d69fe7a2fa31108ee7d23515cec7dd151d08331", "html_url": "https://github.com/rust-lang/rust/commit/6d69fe7a2fa31108ee7d23515cec7dd151d08331", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d69fe7a2fa31108ee7d23515cec7dd151d08331/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c5c05d7d93469e9b4069746bc8799ba9efd807a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c5c05d7d93469e9b4069746bc8799ba9efd807a", "html_url": "https://github.com/rust-lang/rust/commit/4c5c05d7d93469e9b4069746bc8799ba9efd807a"}, {"sha": "014c8c4c3872ff74169ffbbc3a69acd92be2a76c", "url": "https://api.github.com/repos/rust-lang/rust/commits/014c8c4c3872ff74169ffbbc3a69acd92be2a76c", "html_url": "https://github.com/rust-lang/rust/commit/014c8c4c3872ff74169ffbbc3a69acd92be2a76c"}], "stats": {"total": 227, "additions": 201, "deletions": 26}, "files": [{"sha": "06cb4fbd71602787933804c4a9375caa888723bd", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 118, "deletions": 17, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/6d69fe7a2fa31108ee7d23515cec7dd151d08331/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69fe7a2fa31108ee7d23515cec7dd151d08331/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=6d69fe7a2fa31108ee7d23515cec7dd151d08331", "patch": "@@ -378,7 +378,7 @@ pub fn make_test(s: &str,\n                  dont_insert_main: bool,\n                  opts: &TestOptions)\n                  -> (String, usize) {\n-    let (crate_attrs, everything_else) = partition_source(s);\n+    let (crate_attrs, everything_else, crates) = partition_source(s);\n     let everything_else = everything_else.trim();\n     let mut line_offset = 0;\n     let mut prog = String::new();\n@@ -402,30 +402,91 @@ pub fn make_test(s: &str,\n     // are intended to be crate attributes.\n     prog.push_str(&crate_attrs);\n \n+    // Uses libsyntax to parse the doctest and find if there's a main fn and the extern\n+    // crate already is included.\n+    let (already_has_main, already_has_extern_crate) = crate::syntax::with_globals(|| {\n+        use crate::syntax::{ast, parse::{self, ParseSess}, source_map::FilePathMapping};\n+        use crate::syntax_pos::FileName;\n+        use errors::emitter::EmitterWriter;\n+        use errors::Handler;\n+\n+        let filename = FileName::Anon;\n+        let source = crates + &everything_else;\n+\n+        // any errors in parsing should also appear when the doctest is compiled for real, so just\n+        // send all the errors that libsyntax emits directly into a Sink instead of stderr\n+        let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let emitter = EmitterWriter::new(box io::sink(), None, false, false);\n+        let handler = Handler::with_emitter(false, false, box emitter);\n+        let sess = ParseSess::with_span_handler(handler, cm);\n+\n+        debug!(\"about to parse: \\n{}\", source);\n+\n+        let mut found_main = false;\n+        let mut found_extern_crate = cratename.is_none();\n+\n+        let mut parser = match parse::maybe_new_parser_from_source_str(&sess, filename, source) {\n+            Ok(p) => p,\n+            Err(errs) => {\n+                for mut err in errs {\n+                    err.cancel();\n+                }\n+\n+                return (found_main, found_extern_crate);\n+            }\n+        };\n+\n+        loop {\n+            match parser.parse_item() {\n+                Ok(Some(item)) => {\n+                    if !found_main {\n+                        if let ast::ItemKind::Fn(..) = item.node {\n+                            if item.ident.as_str() == \"main\" {\n+                                found_main = true;\n+                            }\n+                        }\n+                    }\n+\n+                    if !found_extern_crate {\n+                        if let ast::ItemKind::ExternCrate(original) = item.node {\n+                            // This code will never be reached if `cratename` is none because\n+                            // `found_extern_crate` is initialized to `true` if it is none.\n+                            let cratename = cratename.unwrap();\n+\n+                            match original {\n+                                Some(name) => found_extern_crate = name.as_str() == cratename,\n+                                None => found_extern_crate = item.ident.as_str() == cratename,\n+                            }\n+                        }\n+                    }\n+\n+                    if found_main && found_extern_crate {\n+                        break;\n+                    }\n+                }\n+                Ok(None) => break,\n+                Err(mut e) => {\n+                    e.cancel();\n+                    break;\n+                }\n+            }\n+        }\n+\n+        (found_main, found_extern_crate)\n+    });\n+\n     // Don't inject `extern crate std` because it's already injected by the\n     // compiler.\n-    if !s.contains(\"extern crate\") && !opts.no_crate_inject && cratename != Some(\"std\") {\n+    if !already_has_extern_crate && !opts.no_crate_inject && cratename != Some(\"std\") {\n         if let Some(cratename) = cratename {\n+            // Make sure its actually used if not included.\n             if s.contains(cratename) {\n                 prog.push_str(&format!(\"extern crate {};\\n\", cratename));\n                 line_offset += 1;\n             }\n         }\n     }\n \n-    // FIXME (#21299): prefer libsyntax or some other actual parser over this\n-    // best-effort ad hoc approach\n-    let already_has_main = s.lines()\n-        .map(|line| {\n-            let comment = line.find(\"//\");\n-            if let Some(comment_begins) = comment {\n-                &line[0..comment_begins]\n-            } else {\n-                line\n-            }\n-        })\n-        .any(|code| code.contains(\"fn main\"));\n-\n     if dont_insert_main || already_has_main {\n         prog.push_str(everything_else);\n     } else {\n@@ -441,9 +502,10 @@ pub fn make_test(s: &str,\n }\n \n // FIXME(aburka): use a real parser to deal with multiline attributes\n-fn partition_source(s: &str) -> (String, String) {\n+fn partition_source(s: &str) -> (String, String, String) {\n     let mut after_header = false;\n     let mut before = String::new();\n+    let mut crates = String::new();\n     let mut after = String::new();\n \n     for line in s.lines() {\n@@ -457,12 +519,17 @@ fn partition_source(s: &str) -> (String, String) {\n             after.push_str(line);\n             after.push_str(\"\\n\");\n         } else {\n+            if trimline.starts_with(\"#[macro_use] extern crate\")\n+                || trimline.starts_with(\"extern crate\") {\n+                crates.push_str(line);\n+                crates.push_str(\"\\n\");\n+            }\n             before.push_str(line);\n             before.push_str(\"\\n\");\n         }\n     }\n \n-    (before, after)\n+    (before, after, crates)\n }\n \n pub trait Tester {\n@@ -1014,4 +1081,38 @@ assert_eq!(2+2, 4);\n         let output = make_test(input, None, false, &opts);\n         assert_eq!(output, (expected, 1));\n     }\n+\n+    #[test]\n+    fn make_test_issues_21299_33731() {\n+        let opts = TestOptions::default();\n+\n+        let input =\n+\"// fn main\n+assert_eq!(2+2, 4);\";\n+\n+        let expected =\n+\"#![allow(unused)]\n+fn main() {\n+// fn main\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+\n+        let output = make_test(input, None, false, &opts);\n+        assert_eq!(output, (expected, 2));\n+\n+        let input =\n+\"extern crate hella_qwop;\n+assert_eq!(asdf::foo, 4);\";\n+\n+        let expected =\n+\"#![allow(unused)]\n+extern crate hella_qwop;\n+extern crate asdf;\n+fn main() {\n+assert_eq!(asdf::foo, 4);\n+}\".to_string();\n+\n+        let output = make_test(input, Some(\"asdf\"), false, &opts);\n+        assert_eq!(output, (expected, 3));\n+    }\n }"}, {"sha": "e9a6535cba1d231460068d3bbc4c0a33ae5cdb0b", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6d69fe7a2fa31108ee7d23515cec7dd151d08331/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69fe7a2fa31108ee7d23515cec7dd151d08331/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=6d69fe7a2fa31108ee7d23515cec7dd151d08331", "patch": "@@ -70,6 +70,23 @@ macro_rules! panictry {\n     })\n }\n \n+// A variant of 'panictry!' that works on a Vec<Diagnostic> instead of a single DiagnosticBuilder.\n+macro_rules! panictry_buffer {\n+    ($handler:expr, $e:expr) => ({\n+        use std::result::Result::{Ok, Err};\n+        use errors::{FatalError, DiagnosticBuilder};\n+        match $e {\n+            Ok(e) => e,\n+            Err(errs) => {\n+                for e in errs {\n+                    DiagnosticBuilder::new_diagnostic($handler, e).emit();\n+                }\n+                FatalError.raise()\n+            }\n+        }\n+    })\n+}\n+\n #[macro_export]\n macro_rules! unwrap_or {\n     ($opt:expr, $default:expr) => {"}, {"sha": "590506566dd5f0d40baa1fbb83c95c955a6c6f0c", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6d69fe7a2fa31108ee7d23515cec7dd151d08331/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69fe7a2fa31108ee7d23515cec7dd151d08331/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=6d69fe7a2fa31108ee7d23515cec7dd151d08331", "patch": "@@ -11,7 +11,7 @@\n use ast::{self, Ident};\n use syntax_pos::{self, BytePos, CharPos, Pos, Span, NO_EXPANSION};\n use source_map::{SourceMap, FilePathMapping};\n-use errors::{Applicability, FatalError, DiagnosticBuilder};\n+use errors::{Applicability, FatalError, Diagnostic, DiagnosticBuilder};\n use parse::{token, ParseSess};\n use str::char_at;\n use symbol::{Symbol, keywords};\n@@ -175,6 +175,16 @@ impl<'a> StringReader<'a> {\n         self.fatal_errs.clear();\n     }\n \n+    pub fn buffer_fatal_errors(&mut self) -> Vec<Diagnostic> {\n+        let mut buffer = Vec::new();\n+\n+        for err in self.fatal_errs.drain(..) {\n+            err.buffer(&mut buffer);\n+        }\n+\n+        buffer\n+    }\n+\n     pub fn peek(&self) -> TokenAndSpan {\n         // FIXME(pcwalton): Bad copy!\n         TokenAndSpan {\n@@ -251,6 +261,17 @@ impl<'a> StringReader<'a> {\n         Ok(sr)\n     }\n \n+    pub fn new_or_buffered_errs(sess: &'a ParseSess,\n+                                source_file: Lrc<syntax_pos::SourceFile>,\n+                                override_span: Option<Span>) -> Result<Self, Vec<Diagnostic>> {\n+        let mut sr = StringReader::new_raw(sess, source_file, override_span);\n+        if sr.advance_token().is_err() {\n+            Err(sr.buffer_fatal_errors())\n+        } else {\n+            Ok(sr)\n+        }\n+    }\n+\n     pub fn retokenize(sess: &'a ParseSess, mut span: Span) -> Self {\n         let begin = sess.source_map().lookup_byte_offset(span.lo());\n         let end = sess.source_map().lookup_byte_offset(span.hi());"}, {"sha": "fd66bf55a74be8b8d53a0ec4df50260c7198ff3c", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6d69fe7a2fa31108ee7d23515cec7dd151d08331/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69fe7a2fa31108ee7d23515cec7dd151d08331/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=6d69fe7a2fa31108ee7d23515cec7dd151d08331", "patch": "@@ -15,7 +15,7 @@ use ast::{self, CrateConfig, NodeId};\n use early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n use source_map::{SourceMap, FilePathMapping};\n use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n-use errors::{Handler, ColorConfig, DiagnosticBuilder};\n+use errors::{Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n use ptr::P;\n@@ -174,12 +174,21 @@ pub fn parse_stream_from_source_str(name: FileName, source: String, sess: &Parse\n     source_file_to_stream(sess, sess.source_map().new_source_file(name, source), override_span)\n }\n \n-// Create a new parser from a source string\n+/// Create a new parser from a source string\n pub fn new_parser_from_source_str(sess: &ParseSess, name: FileName, source: String)\n                                       -> Parser {\n-    let mut parser = source_file_to_parser(sess, sess.source_map().new_source_file(name, source));\n+    panictry_buffer!(&sess.span_diagnostic, maybe_new_parser_from_source_str(sess, name, source))\n+}\n+\n+/// Create a new parser from a source string. Returns any buffered errors from lexing the initial\n+/// token stream.\n+pub fn maybe_new_parser_from_source_str(sess: &ParseSess, name: FileName, source: String)\n+    -> Result<Parser, Vec<Diagnostic>>\n+{\n+    let mut parser = maybe_source_file_to_parser(sess,\n+                                                 sess.source_map().new_source_file(name, source))?;\n     parser.recurse_into_file_modules = false;\n-    parser\n+    Ok(parser)\n }\n \n /// Create a new parser, handling errors as appropriate\n@@ -204,14 +213,23 @@ crate fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n \n /// Given a source_file and config, return a parser\n fn source_file_to_parser(sess: & ParseSess, source_file: Lrc<SourceFile>) -> Parser {\n+    panictry_buffer!(&sess.span_diagnostic,\n+                     maybe_source_file_to_parser(sess, source_file))\n+}\n+\n+/// Given a source_file and config, return a parser. Returns any buffered errors from lexing the\n+/// initial token stream.\n+fn maybe_source_file_to_parser(sess: &ParseSess, source_file: Lrc<SourceFile>)\n+    -> Result<Parser, Vec<Diagnostic>>\n+{\n     let end_pos = source_file.end_pos;\n-    let mut parser = stream_to_parser(sess, source_file_to_stream(sess, source_file, None));\n+    let mut parser = stream_to_parser(sess, maybe_file_to_stream(sess, source_file, None)?);\n \n     if parser.token == token::Eof && parser.span.is_dummy() {\n         parser.span = Span::new(end_pos, end_pos, parser.span.ctxt());\n     }\n \n-    parser\n+    Ok(parser)\n }\n \n // must preserve old name for now, because quote! from the *existing*\n@@ -243,9 +261,25 @@ fn file_to_source_file(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n pub fn source_file_to_stream(sess: &ParseSess,\n                              source_file: Lrc<SourceFile>,\n                              override_span: Option<Span>) -> TokenStream {\n-    let mut srdr = lexer::StringReader::new(sess, source_file, override_span);\n+    panictry_buffer!(&sess.span_diagnostic, maybe_file_to_stream(sess, source_file, override_span))\n+}\n+\n+/// Given a source file, produce a sequence of token-trees. Returns any buffered errors from\n+/// parsing the token tream.\n+pub fn maybe_file_to_stream(sess: &ParseSess,\n+                            source_file: Lrc<SourceFile>,\n+                            override_span: Option<Span>) -> Result<TokenStream, Vec<Diagnostic>> {\n+    let mut srdr = lexer::StringReader::new_or_buffered_errs(sess, source_file, override_span)?;\n     srdr.real_token();\n-    panictry!(srdr.parse_all_token_trees())\n+\n+    match srdr.parse_all_token_trees() {\n+        Ok(stream) => Ok(stream),\n+        Err(err) => {\n+            let mut buffer = Vec::with_capacity(1);\n+            err.buffer(&mut buffer);\n+            Err(buffer)\n+        }\n+    }\n }\n \n /// Given stream and the `ParseSess`, produce a parser"}, {"sha": "a5556e1d570eb89e6f04ffb258bd8f1f7ff9bfc8", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d69fe7a2fa31108ee7d23515cec7dd151d08331/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69fe7a2fa31108ee7d23515cec7dd151d08331/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=6d69fe7a2fa31108ee7d23515cec7dd151d08331", "patch": "@@ -10,6 +10,7 @@\n \n #![feature(rustc_private)]\n \n+extern crate env_logger;\n extern crate syntax;\n extern crate rustdoc;\n extern crate serialize as rustc_serialize;\n@@ -264,6 +265,7 @@ fn parse_args() -> (OutputFormat, PathBuf) {\n }\n \n fn main() {\n+    env_logger::init();\n     PLAYGROUND.with(|slot| {\n         *slot.borrow_mut() = Some((None, String::from(\"https://play.rust-lang.org/\")));\n     });"}]}