{"sha": "db635fc5664c0a19cdb4063545ca2d2b297f0212", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNjM1ZmM1NjY0YzBhMTljZGI0MDYzNTQ1Y2EyZDJiMjk3ZjAyMTI=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-12-17T12:11:33Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-12-17T13:49:52Z"}, "message": "Kill borrows from a projection after assignment.\n\nThis commit extends previous work to kill borrows from a local after\nassignment into that local to kill borrows from a projection after\nassignment into a prefix of that place.", "tree": {"sha": "53610cb23ec6723c00757e9f41b5c4b09c9e2d80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53610cb23ec6723c00757e9f41b5c4b09c9e2d80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db635fc5664c0a19cdb4063545ca2d2b297f0212", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlwXqYAACgkQAXYLT59T\n8VQ5NRAApDJX1p+aY8Uf3xfd7bNcbIkrT4BtMzH+NN0YffI9Nl5F6YH4tGBZb494\n9inqSrmlSkBpQN0r8lwNW9Aohd1pSkZPUGSASxvrTGtciDuYFyyhci504+gmiovu\npSqmCvtw21loWilyhvTQrKAn2+/BUzCFNWyLi9J+gQyISKN9X3bwObcBxYWgr3NL\nD2xv/4BzJLXbs9IrBghYC0VxaKruG31QwPvliQrLv7zSbECDopCsV1Mhur8InS50\nnNjJ1xn5m9oZnZUZu8oLFZl9Ya+nmKQfaaQSCKmZNKX1ldiNBZqEIh8kE6a0yymp\n+jUXWPgugOpByP5vKfdph838qOV1lE7gOXvNJrHZWzyyLwuppigza2tSkIr6BFhU\ntcLa6sp5gW83zLLVbsK9ed6TlXU35ZpTrKZlKvEBFmftQ/cx6xMro7z+6jkclhYF\nuJM2ctycGyXcUcnMFMU+TxFN1ExI45YlxtrkksLt2NN4m1EEag1zZj4yyLhy46cd\nnWJK1PzFnRnjSDpkWAGT4GFh9c3h0o1SPpndGMZOX5c1zTyZnPRtGMCpGGJq/ZFK\nt9uA46ZG3Vv3v4v38sDqp0E3MZKjgv0yd6nHCC0ToNcOuGZd029X/x1NwzBjQZ15\nOZ8EctjHXvlfNP+OrCz+Ro42ET6HNMwGPCr7ShE4VnmI9YN7NkU=\n=L/12\n-----END PGP SIGNATURE-----", "payload": "tree 53610cb23ec6723c00757e9f41b5c4b09c9e2d80\nparent 1149c58bb8020338ea5f3065af0a3342d42a31fa\nauthor David Wood <david@davidtw.co> 1545048693 +0100\ncommitter David Wood <david@davidtw.co> 1545054592 +0100\n\nKill borrows from a projection after assignment.\n\nThis commit extends previous work to kill borrows from a local after\nassignment into that local to kill borrows from a projection after\nassignment into a prefix of that place.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db635fc5664c0a19cdb4063545ca2d2b297f0212", "html_url": "https://github.com/rust-lang/rust/commit/db635fc5664c0a19cdb4063545ca2d2b297f0212", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db635fc5664c0a19cdb4063545ca2d2b297f0212/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1149c58bb8020338ea5f3065af0a3342d42a31fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/1149c58bb8020338ea5f3065af0a3342d42a31fa", "html_url": "https://github.com/rust-lang/rust/commit/1149c58bb8020338ea5f3065af0a3342d42a31fa"}], "stats": {"total": 206, "additions": 125, "deletions": 81}, "files": [{"sha": "c328ac49f40dc3671677b12f3c030d25855b8ad4", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=db635fc5664c0a19cdb4063545ca2d2b297f0212", "patch": "@@ -63,7 +63,7 @@ mod move_errors;\n mod mutability_errors;\n mod path_utils;\n crate mod place_ext;\n-mod places_conflict;\n+crate mod places_conflict;\n mod prefixes;\n mod used_muts;\n \n@@ -1370,7 +1370,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             place,\n             borrow.kind,\n             root_place,\n-            sd\n+            sd,\n+            places_conflict::PlaceConflictBias::Overlap,\n         ) {\n             debug!(\"check_for_invalidation_at_exit({:?}): INVALID\", place);\n             // FIXME: should be talking about the region lifetime instead"}, {"sha": "5e17afc3d3cdc94dc1c299d83be2efc27e4a70dd", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=db635fc5664c0a19cdb4063545ca2d2b297f0212", "patch": "@@ -68,6 +68,7 @@ pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n             borrowed.kind,\n             place,\n             access,\n+            places_conflict::PlaceConflictBias::Overlap,\n         ) {\n             debug!(\n                 \"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\","}, {"sha": "d6e73419db2e61cfe99dc28cca426f538fb5e7c2", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 60, "deletions": 9, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=db635fc5664c0a19cdb4063545ca2d2b297f0212", "patch": "@@ -17,17 +17,55 @@ use rustc::mir::{Projection, ProjectionElem};\n use rustc::ty::{self, TyCtxt};\n use std::cmp::max;\n \n+/// When checking if a place conflicts with another place, this enum is used to influence decisions\n+/// where a place might be equal or disjoint with another place, such as if `a[i] == a[j]`.\n+/// `PlaceConflictBias::Overlap` would bias toward assuming that `i` might equal `j` and that these\n+/// places overlap. `PlaceConflictBias::NoOverlap` assumes that for the purposes of the predicate\n+/// being run in the calling context, the conservative choice is to assume the compared indices\n+/// are disjoint (and therefore, do not overlap).\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+crate enum PlaceConflictBias {\n+    Overlap,\n+    NoOverlap,\n+}\n+\n+/// Helper function for checking if places conflict with a mutable borrow and deep access depth.\n+/// This is used to check for places conflicting outside of the borrow checking code (such as in\n+/// dataflow).\n+crate fn places_conflict<'gcx, 'tcx>(\n+    tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    borrow_place: &Place<'tcx>,\n+    access_place: &Place<'tcx>,\n+    bias: PlaceConflictBias,\n+) -> bool {\n+    borrow_conflicts_with_place(\n+        tcx,\n+        mir,\n+        borrow_place,\n+        BorrowKind::Mut { allow_two_phase_borrow: true },\n+        access_place,\n+        AccessDepth::Deep,\n+        bias,\n+    )\n+}\n+\n+/// Checks whether the `borrow_place` conflicts with the `access_place` given a borrow kind and\n+/// access depth. The `bias` parameter is used to determine how the unknowable (comparing runtime\n+/// array indices, for example) should be interpreted - this depends on what the caller wants in\n+/// order to make the conservative choice and preserve soundness.\n pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n     tcx: TyCtxt<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n     access_place: &Place<'tcx>,\n     access: AccessDepth,\n+    bias: PlaceConflictBias,\n ) -> bool {\n     debug!(\n-        \"borrow_conflicts_with_place({:?},{:?},{:?})\",\n-        borrow_place, access_place, access\n+        \"borrow_conflicts_with_place({:?}, {:?}, {:?}, {:?})\",\n+        borrow_place, access_place, access, bias,\n     );\n \n     // This Local/Local case is handled by the more general code below, but\n@@ -46,7 +84,8 @@ pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n                 borrow_components,\n                 borrow_kind,\n                 access_components,\n-                access\n+                access,\n+                bias,\n             )\n         })\n     })\n@@ -59,6 +98,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n     borrow_kind: BorrowKind,\n     mut access_components: PlaceComponentsIter<'_, 'tcx>,\n     access: AccessDepth,\n+    bias: PlaceConflictBias,\n ) -> bool {\n     // The borrowck rules for proving disjointness are applied from the \"root\" of the\n     // borrow forwards, iterating over \"similar\" projections in lockstep until\n@@ -121,7 +161,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                 // check whether the components being borrowed vs\n                 // accessed are disjoint (as in the second example,\n                 // but not the first).\n-                match place_element_conflict(tcx, mir, borrow_c, access_c) {\n+                match place_element_conflict(tcx, mir, borrow_c, access_c, bias) {\n                     Overlap::Arbitrary => {\n                         // We have encountered different fields of potentially\n                         // the same union - the borrow now partially overlaps.\n@@ -193,7 +233,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                         bug!(\"Tracking borrow behind shared reference.\");\n                     }\n                     (ProjectionElem::Deref, ty::Ref(_, _, hir::MutMutable), AccessDepth::Drop) => {\n-                        // Values behind a mutatble reference are not access either by Dropping a\n+                        // Values behind a mutable reference are not access either by dropping a\n                         // value, or by StorageDead\n                         debug!(\"borrow_conflicts_with_place: drop access behind ptr\");\n                         return false;\n@@ -331,6 +371,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n     mir: &Mir<'tcx>,\n     elem1: &Place<'tcx>,\n     elem2: &Place<'tcx>,\n+    bias: PlaceConflictBias,\n ) -> Overlap {\n     match (elem1, elem2) {\n         (Place::Local(l1), Place::Local(l2)) => {\n@@ -448,10 +489,20 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n                 | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..)) => {\n                     // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n-                    // (if the indexes differ) or equal (if they are the same), so this\n-                    // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n-                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-INDEX\");\n-                    Overlap::EqualOrDisjoint\n+                    // (if the indexes differ) or equal (if they are the same).\n+                    match bias {\n+                        PlaceConflictBias::Overlap => {\n+                            // If we are biased towards overlapping, then this is the recursive\n+                            // case that gives \"equal *or* disjoint\" its meaning.\n+                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-INDEX\");\n+                            Overlap::EqualOrDisjoint\n+                        }\n+                        PlaceConflictBias::NoOverlap => {\n+                            // If we are biased towards no overlapping, then this is disjoint.\n+                            debug!(\"place_element_conflict: DISJOINT-ARRAY-INDEX\");\n+                            Overlap::Disjoint\n+                        }\n+                    }\n                 }\n                 (ProjectionElem::ConstantIndex { offset: o1, min_length: _, from_end: false },\n                     ProjectionElem::ConstantIndex { offset: o2, min_length: _, from_end: false })"}, {"sha": "532143af6d39c832a1cc47d5d478c0b6cb1ce214", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 54, "deletions": 23, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=db635fc5664c0a19cdb4063545ca2d2b297f0212", "patch": "@@ -11,7 +11,6 @@\n use borrow_check::borrow_set::{BorrowSet, BorrowData};\n use borrow_check::place_ext::PlaceExt;\n \n-use rustc;\n use rustc::mir::{self, Location, Place, Mir};\n use rustc::ty::TyCtxt;\n use rustc::ty::RegionVid;\n@@ -24,6 +23,7 @@ use dataflow::{BitDenotation, BlockSets, InitialFlow};\n pub use dataflow::indexes::BorrowIndex;\n use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::ToRegionVid;\n+use borrow_check::places_conflict;\n \n use std::rc::Rc;\n \n@@ -191,12 +191,54 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn kill_borrows_on_local(&self,\n-                             sets: &mut BlockSets<BorrowIndex>,\n-                             local: &rustc::mir::Local)\n-    {\n-        if let Some(borrow_indexes) = self.borrow_set.local_map.get(local) {\n-            sets.kill_all(borrow_indexes);\n+    /// Kill any borrows that conflict with `place`.\n+    fn kill_borrows_on_place(\n+        &self,\n+        sets: &mut BlockSets<BorrowIndex>,\n+        location: Location,\n+        place: &Place<'tcx>\n+    ) {\n+        debug!(\"kill_borrows_on_place: location={:?} place={:?}\", location, place);\n+        // Handle the `Place::Local(..)` case first and exit early.\n+        if let Place::Local(local) = place {\n+            if let Some(borrow_indexes) = self.borrow_set.local_map.get(&local) {\n+                debug!(\n+                    \"kill_borrows_on_place: local={:?} borrow_indexes={:?}\",\n+                    local, borrow_indexes,\n+                );\n+                sets.kill_all(borrow_indexes);\n+                return;\n+            }\n+        }\n+\n+        // Otherwise, look at all borrows that are live and if they conflict with the assignment\n+        // into our place then we can kill them.\n+        let mut borrows = sets.on_entry.clone();\n+        let _ = borrows.union(sets.gen_set);\n+        for borrow_index in borrows.iter() {\n+            let borrow_data = &self.borrows()[borrow_index];\n+            debug!(\n+                \"kill_borrows_on_place: borrow_index={:?} borrow_data={:?}\",\n+                borrow_index, borrow_data,\n+            );\n+\n+            // By passing `PlaceConflictBias::NoOverlap`, we conservatively assume that any given\n+            // pair of array indices are unequal, so that when `places_conflict` returns true, we\n+            // will be assured that two places being compared definitely denotes the same sets of\n+            // locations.\n+            if places_conflict::places_conflict(\n+                self.tcx,\n+                self.mir,\n+                place,\n+                &borrow_data.borrowed_place,\n+                places_conflict::PlaceConflictBias::NoOverlap,\n+            ) {\n+                debug!(\n+                    \"kill_borrows_on_place: (kill) place={:?} borrow_index={:?} borrow_data={:?}\",\n+                    place, borrow_index, borrow_data,\n+                );\n+                sets.kill(borrow_index);\n+            }\n         }\n     }\n }\n@@ -222,7 +264,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n     }\n \n     fn statement_effect(&self, sets: &mut BlockSets<BorrowIndex>, location: Location) {\n-        debug!(\"Borrows::statement_effect sets: {:?} location: {:?}\", sets, location);\n+        debug!(\"Borrows::statement_effect: sets={:?} location={:?}\", sets, location);\n \n         let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n             panic!(\"could not find block at location {:?}\", location);\n@@ -231,21 +273,17 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             panic!(\"could not find statement at location {:?}\");\n         });\n \n+        debug!(\"Borrows::statement_effect: stmt={:?}\", stmt);\n         match stmt.kind {\n             mir::StatementKind::Assign(ref lhs, ref rhs) => {\n                 // Make sure there are no remaining borrows for variables\n                 // that are assigned over.\n-                if let Place::Local(ref local) = *lhs {\n-                    // FIXME: Handle the case in which we're assigning over\n-                    // a projection (`foo.bar`).\n-                    self.kill_borrows_on_local(sets, local);\n-                }\n+                self.kill_borrows_on_place(sets, location, lhs);\n \n                 // NOTE: if/when the Assign case is revised to inspect\n                 // the assigned_place here, make sure to also\n                 // re-consider the current implementations of the\n                 // propagate_call_return method.\n-\n                 if let mir::Rvalue::Ref(_, _, ref place) = **rhs {\n                     if place.ignore_borrow(\n                         self.tcx,\n@@ -279,19 +317,13 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             mir::StatementKind::StorageDead(local) => {\n                 // Make sure there are no remaining borrows for locals that\n                 // are gone out of scope.\n-                self.kill_borrows_on_local(sets, &local)\n+                self.kill_borrows_on_place(sets, location, &Place::Local(local));\n             }\n \n             mir::StatementKind::InlineAsm { ref outputs, ref asm, .. } => {\n                 for (output, kind) in outputs.iter().zip(&asm.outputs) {\n                     if !kind.is_indirect && !kind.is_rw {\n-                        // Make sure there are no remaining borrows for direct\n-                        // output variables.\n-                        if let Place::Local(ref local) = *output {\n-                            // FIXME: Handle the case in which we're assigning over\n-                            // a projection (`foo.bar`).\n-                            self.kill_borrows_on_local(sets, local);\n-                        }\n+                        self.kill_borrows_on_place(sets, location, output);\n                     }\n                 }\n             }\n@@ -342,4 +374,3 @@ impl<'a, 'gcx, 'tcx> InitialFlow for Borrows<'a, 'gcx, 'tcx> {\n         false // bottom = nothing is reserved or activated yet\n     }\n }\n-"}, {"sha": "82e73651f4310357f34c52ec959262a43fad2666", "filename": "src/test/ui/nll/issue-46589.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Ftest%2Fui%2Fnll%2Fissue-46589.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Ftest%2Fui%2Fnll%2Fissue-46589.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-46589.rs?ref=db635fc5664c0a19cdb4063545ca2d2b297f0212", "patch": "@@ -31,7 +31,6 @@ impl Foo {\n         };\n \n         let c = other;\n-        //~^ ERROR cannot move out of `other` because it is borrowed [E0505]\n     }\n }\n "}, {"sha": "6df2983f4652ee59f7e8384505f0d13d0c5b9c27", "filename": "src/test/ui/nll/issue-46589.stderr", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Ftest%2Fui%2Fnll%2Fissue-46589.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Ftest%2Fui%2Fnll%2Fissue-46589.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-46589.stderr?ref=db635fc5664c0a19cdb4063545ca2d2b297f0212", "patch": "@@ -10,19 +10,6 @@ LL |             None => (*other).new_self()\n    |                     second mutable borrow occurs here\n    |                     first borrow later used here\n \n-error[E0505]: cannot move out of `other` because it is borrowed\n-  --> $DIR/issue-46589.rs:33:17\n-   |\n-LL |         *other = match (*other).get_self() {\n-   |                        -------- borrow of `**other` occurs here\n-...\n-LL |         let c = other;\n-   |                 ^^^^^\n-   |                 |\n-   |                 move out of `other` occurs here\n-   |                 borrow later used here\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors occurred: E0499, E0505.\n-For more information about an error, try `rustc --explain E0499`.\n+For more information about this error, try `rustc --explain E0499`."}, {"sha": "320d80438b06781a69cb9c1ca18a2adedbf8bdaa", "filename": "src/test/ui/nll/loan_ends_mid_block_pair.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.rs?ref=db635fc5664c0a19cdb4063545ca2d2b297f0212", "patch": "@@ -27,10 +27,8 @@ fn nll_fail() {\n     //~| ERROR (Mir) [E0506]\n     data.0 = 'f';\n     //~^ ERROR (Ast) [E0506]\n-    //~| ERROR (Mir) [E0506]\n     data.0 = 'g';\n     //~^ ERROR (Ast) [E0506]\n-    //~| ERROR (Mir) [E0506]\n     capitalize(c);\n }\n "}, {"sha": "3ba3fa15a5387672c06010f3ef6fbb6ca71e6668", "filename": "src/test/ui/nll/loan_ends_mid_block_pair.stderr", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db635fc5664c0a19cdb4063545ca2d2b297f0212/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.stderr?ref=db635fc5664c0a19cdb4063545ca2d2b297f0212", "patch": "@@ -17,7 +17,7 @@ LL |     data.0 = 'f';\n    |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n \n error[E0506]: cannot assign to `data.0` because it is borrowed (Ast)\n-  --> $DIR/loan_ends_mid_block_pair.rs:31:5\n+  --> $DIR/loan_ends_mid_block_pair.rs:30:5\n    |\n LL |     let c = &mut data.0;\n    |                  ------ borrow of `data.0` occurs here\n@@ -26,7 +26,7 @@ LL |     data.0 = 'g';\n    |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n \n error[E0506]: cannot assign to `data.0` because it is borrowed (Ast)\n-  --> $DIR/loan_ends_mid_block_pair.rs:41:5\n+  --> $DIR/loan_ends_mid_block_pair.rs:39:5\n    |\n LL |     let c = &mut data.0;\n    |                  ------ borrow of `data.0` occurs here\n@@ -35,7 +35,7 @@ LL |     data.0 = 'e';\n    |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n \n error[E0506]: cannot assign to `data.0` because it is borrowed (Ast)\n-  --> $DIR/loan_ends_mid_block_pair.rs:43:5\n+  --> $DIR/loan_ends_mid_block_pair.rs:41:5\n    |\n LL |     let c = &mut data.0;\n    |                  ------ borrow of `data.0` occurs here\n@@ -44,7 +44,7 @@ LL |     data.0 = 'f';\n    |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n \n error[E0506]: cannot assign to `data.0` because it is borrowed (Ast)\n-  --> $DIR/loan_ends_mid_block_pair.rs:45:5\n+  --> $DIR/loan_ends_mid_block_pair.rs:43:5\n    |\n LL |     let c = &mut data.0;\n    |                  ------ borrow of `data.0` occurs here\n@@ -64,30 +64,6 @@ LL |     data.0 = 'e';\n LL |     capitalize(c);\n    |                - borrow later used here\n \n-error[E0506]: cannot assign to `data.0` because it is borrowed (Mir)\n-  --> $DIR/loan_ends_mid_block_pair.rs:28:5\n-   |\n-LL |     let c = &mut data.0;\n-   |             ----------- borrow of `data.0` occurs here\n-...\n-LL |     data.0 = 'f';\n-   |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n-...\n-LL |     capitalize(c);\n-   |                - borrow later used here\n-\n-error[E0506]: cannot assign to `data.0` because it is borrowed (Mir)\n-  --> $DIR/loan_ends_mid_block_pair.rs:31:5\n-   |\n-LL |     let c = &mut data.0;\n-   |             ----------- borrow of `data.0` occurs here\n-...\n-LL |     data.0 = 'g';\n-   |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n-...\n-LL |     capitalize(c);\n-   |                - borrow later used here\n-\n-error: aborting due to 9 previous errors\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0506`."}]}