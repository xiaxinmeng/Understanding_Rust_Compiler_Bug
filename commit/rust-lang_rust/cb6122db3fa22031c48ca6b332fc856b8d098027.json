{"sha": "cb6122db3fa22031c48ca6b332fc856b8d098027", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNjEyMmRiM2ZhMjIwMzFjNDhjYTZiMzMyZmM4NTZiOGQwOTgwMjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-14T10:34:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-14T10:34:43Z"}, "message": "Auto merge of #67076 - mbrubeck:condvar, r=dtolnay\n\nStabilize Condvar::wait_while and wait_timeout_while (previously wait_until, wait_timeout_until)\n\nCloses #47960.", "tree": {"sha": "d732be6f73a740064dbfae5b4b94bf6de53b70ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d732be6f73a740064dbfae5b4b94bf6de53b70ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb6122db3fa22031c48ca6b332fc856b8d098027", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb6122db3fa22031c48ca6b332fc856b8d098027", "html_url": "https://github.com/rust-lang/rust/commit/cb6122db3fa22031c48ca6b332fc856b8d098027", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb6122db3fa22031c48ca6b332fc856b8d098027/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c06e4aca19046b07d952b16e9f002bfab38fde6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c06e4aca19046b07d952b16e9f002bfab38fde6b", "html_url": "https://github.com/rust-lang/rust/commit/c06e4aca19046b07d952b16e9f002bfab38fde6b"}, {"sha": "98d054af08017e4b7f68c4985b1ed821b845fc00", "url": "https://api.github.com/repos/rust-lang/rust/commits/98d054af08017e4b7f68c4985b1ed821b845fc00", "html_url": "https://github.com/rust-lang/rust/commit/98d054af08017e4b7f68c4985b1ed821b845fc00"}], "stats": {"total": 77, "additions": 34, "deletions": 43}, "files": [{"sha": "77e521eae9afefe72ff8180eb555a6f926ff774d", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 34, "deletions": 43, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/cb6122db3fa22031c48ca6b332fc856b8d098027/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb6122db3fa22031c48ca6b332fc856b8d098027/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=cb6122db3fa22031c48ca6b332fc856b8d098027", "patch": "@@ -204,9 +204,7 @@ impl Condvar {\n     }\n \n     /// Blocks the current thread until this condition variable receives a\n-    /// notification and the required condition is met. Spurious wakeups are\n-    /// ignored and this function will only return once the condition has been\n-    /// met.\n+    /// notification and the provided condition is false.\n     ///\n     /// This function will atomically unlock the mutex specified (represented by\n     /// `guard`) and block the current thread. This means that any calls\n@@ -228,37 +226,35 @@ impl Condvar {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(wait_until)]\n-    ///\n     /// use std::sync::{Arc, Mutex, Condvar};\n     /// use std::thread;\n     ///\n-    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+    /// let pair = Arc::new((Mutex::new(true), Condvar::new()));\n     /// let pair2 = pair.clone();\n     ///\n     /// thread::spawn(move|| {\n     ///     let (lock, cvar) = &*pair2;\n-    ///     let mut started = lock.lock().unwrap();\n-    ///     *started = true;\n+    ///     let mut pending = lock.lock().unwrap();\n+    ///     *pending = false;\n     ///     // We notify the condvar that the value has changed.\n     ///     cvar.notify_one();\n     /// });\n     ///\n     /// // Wait for the thread to start up.\n     /// let (lock, cvar) = &*pair;\n-    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n-    /// let _guard = cvar.wait_until(lock.lock().unwrap(), |started| { *started }).unwrap();\n+    /// // As long as the value inside the `Mutex<bool>` is `true`, we wait.\n+    /// let _guard = cvar.wait_while(lock.lock().unwrap(), |pending| { *pending }).unwrap();\n     /// ```\n-    #[unstable(feature = \"wait_until\", issue = \"47960\")]\n-    pub fn wait_until<'a, T, F>(\n+    #[stable(feature = \"wait_until\", since = \"1.42.0\")]\n+    pub fn wait_while<'a, T, F>(\n         &self,\n         mut guard: MutexGuard<'a, T>,\n         mut condition: F,\n     ) -> LockResult<MutexGuard<'a, T>>\n     where\n         F: FnMut(&mut T) -> bool,\n     {\n-        while !condition(&mut *guard) {\n+        while condition(&mut *guard) {\n             guard = self.wait(guard)?;\n         }\n         Ok(guard)\n@@ -343,11 +339,10 @@ impl Condvar {\n     /// Condition variables normally have a boolean predicate associated with\n     /// them, and the predicate must always be checked each time this function\n     /// returns to protect against spurious wakeups. Additionally, it is\n-    /// typically desirable for the time-out to not exceed some duration in\n+    /// typically desirable for the timeout to not exceed some duration in\n     /// spite of spurious wakes, thus the sleep-duration is decremented by the\n-    /// amount slept. Alternatively, use the `wait_timeout_until` method\n-    /// to wait until a condition is met with a total time-out regardless\n-    /// of spurious wakes.\n+    /// amount slept. Alternatively, use the `wait_timeout_while` method\n+    /// to wait with a timeout while a predicate is true.\n     ///\n     /// The returned [`WaitTimeoutResult`] value indicates if the timeout is\n     /// known to have elapsed.\n@@ -356,7 +351,7 @@ impl Condvar {\n     /// returns, regardless of whether the timeout elapsed or not.\n     ///\n     /// [`wait`]: #method.wait\n-    /// [`wait_timeout_until`]: #method.wait_timeout_until\n+    /// [`wait_timeout_while`]: #method.wait_timeout_while\n     /// [`WaitTimeoutResult`]: struct.WaitTimeoutResult.html\n     ///\n     /// # Examples\n@@ -407,10 +402,9 @@ impl Condvar {\n     }\n \n     /// Waits on this condition variable for a notification, timing out after a\n-    /// specified duration. Spurious wakes will not cause this function to\n-    /// return.\n+    /// specified duration.\n     ///\n-    /// The semantics of this function are equivalent to [`wait_until`] except\n+    /// The semantics of this function are equivalent to [`wait_while`] except\n     /// that the thread will be blocked for roughly no longer than `dur`. This\n     /// method should not be used for precise timing due to anomalies such as\n     /// preemption or platform differences that may not cause the maximum\n@@ -423,47 +417,45 @@ impl Condvar {\n     /// The returned [`WaitTimeoutResult`] value indicates if the timeout is\n     /// known to have elapsed without the condition being met.\n     ///\n-    /// Like [`wait_until`], the lock specified will be re-acquired when this\n+    /// Like [`wait_while`], the lock specified will be re-acquired when this\n     /// function returns, regardless of whether the timeout elapsed or not.\n     ///\n-    /// [`wait_until`]: #method.wait_until\n+    /// [`wait_while`]: #method.wait_while\n     /// [`wait_timeout`]: #method.wait_timeout\n     /// [`WaitTimeoutResult`]: struct.WaitTimeoutResult.html\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(wait_timeout_until)]\n-    ///\n     /// use std::sync::{Arc, Mutex, Condvar};\n     /// use std::thread;\n     /// use std::time::Duration;\n     ///\n-    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+    /// let pair = Arc::new((Mutex::new(true), Condvar::new()));\n     /// let pair2 = pair.clone();\n     ///\n     /// thread::spawn(move|| {\n     ///     let (lock, cvar) = &*pair2;\n-    ///     let mut started = lock.lock().unwrap();\n-    ///     *started = true;\n+    ///     let mut pending = lock.lock().unwrap();\n+    ///     *pending = false;\n     ///     // We notify the condvar that the value has changed.\n     ///     cvar.notify_one();\n     /// });\n     ///\n     /// // wait for the thread to start up\n     /// let (lock, cvar) = &*pair;\n-    /// let result = cvar.wait_timeout_until(\n+    /// let result = cvar.wait_timeout_while(\n     ///     lock.lock().unwrap(),\n     ///     Duration::from_millis(100),\n-    ///     |&mut started| started,\n+    ///     |&mut pending| pending,\n     /// ).unwrap();\n     /// if result.1.timed_out() {\n-    ///     // timed-out without the condition ever evaluating to true.\n+    ///     // timed-out without the condition ever evaluating to false.\n     /// }\n     /// // access the locked mutex via result.0\n     /// ```\n-    #[unstable(feature = \"wait_timeout_until\", issue = \"47960\")]\n-    pub fn wait_timeout_until<'a, T, F>(\n+    #[stable(feature = \"wait_timeout_until\", since = \"1.42.0\")]\n+    pub fn wait_timeout_while<'a, T, F>(\n         &self,\n         mut guard: MutexGuard<'a, T>,\n         dur: Duration,\n@@ -474,7 +466,7 @@ impl Condvar {\n     {\n         let start = Instant::now();\n         loop {\n-            if condition(&mut *guard) {\n+            if !condition(&mut *guard) {\n                 return Ok((guard, WaitTimeoutResult(false)));\n             }\n             let timeout = match dur.checked_sub(start.elapsed()) {\n@@ -613,7 +605,6 @@ impl Drop for Condvar {\n #[cfg(test)]\n mod tests {\n     use crate::sync::atomic::{AtomicBool, Ordering};\n-    /// #![feature(wait_until)]\n     use crate::sync::mpsc::channel;\n     use crate::sync::{Arc, Condvar, Mutex};\n     use crate::thread;\n@@ -683,7 +674,7 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    fn wait_until() {\n+    fn wait_while() {\n         let pair = Arc::new((Mutex::new(false), Condvar::new()));\n         let pair2 = pair.clone();\n \n@@ -698,7 +689,7 @@ mod tests {\n \n         // Wait for the thread to start up.\n         let &(ref lock, ref cvar) = &*pair;\n-        let guard = cvar.wait_until(lock.lock().unwrap(), |started| *started);\n+        let guard = cvar.wait_while(lock.lock().unwrap(), |started| !*started);\n         assert!(*guard.unwrap());\n     }\n \n@@ -725,32 +716,32 @@ mod tests {\n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n     #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n-    fn wait_timeout_until_wait() {\n+    fn wait_timeout_while_wait() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());\n \n         let g = m.lock().unwrap();\n-        let (_g, wait) = c.wait_timeout_until(g, Duration::from_millis(1), |_| false).unwrap();\n+        let (_g, wait) = c.wait_timeout_while(g, Duration::from_millis(1), |_| true).unwrap();\n         // no spurious wakeups. ensure it timed-out\n         assert!(wait.timed_out());\n     }\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    fn wait_timeout_until_instant_satisfy() {\n+    fn wait_timeout_while_instant_satisfy() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());\n \n         let g = m.lock().unwrap();\n-        let (_g, wait) = c.wait_timeout_until(g, Duration::from_millis(0), |_| true).unwrap();\n+        let (_g, wait) = c.wait_timeout_while(g, Duration::from_millis(0), |_| false).unwrap();\n         // ensure it didn't time-out even if we were not given any time.\n         assert!(!wait.timed_out());\n     }\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n     #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n-    fn wait_timeout_until_wake() {\n+    fn wait_timeout_while_wake() {\n         let pair = Arc::new((Mutex::new(false), Condvar::new()));\n         let pair_copy = pair.clone();\n \n@@ -764,7 +755,7 @@ mod tests {\n             cvar.notify_one();\n         });\n         let (g2, wait) = c\n-            .wait_timeout_until(g, Duration::from_millis(u64::MAX), |&mut notified| notified)\n+            .wait_timeout_while(g, Duration::from_millis(u64::MAX), |&mut notified| !notified)\n             .unwrap();\n         // ensure it didn't time-out even if we were not given any time.\n         assert!(!wait.timed_out());"}]}