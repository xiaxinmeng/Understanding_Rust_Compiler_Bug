{"sha": "2777386dc2e3c950980a469d4ac9701ccbab3a02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NzczODZkYzJlM2M5NTA5ODBhNDY5ZDRhYzk3MDFjY2JhYjNhMDI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-08-01T23:05:19Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-08-02T01:44:36Z"}, "message": "Replace `abstract type` with type alias `impl Trait`", "tree": {"sha": "db77502df9a3e35e81d9eaf17b816a7506a65cfb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db77502df9a3e35e81d9eaf17b816a7506a65cfb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2777386dc2e3c950980a469d4ac9701ccbab3a02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2777386dc2e3c950980a469d4ac9701ccbab3a02", "html_url": "https://github.com/rust-lang/rust/commit/2777386dc2e3c950980a469d4ac9701ccbab3a02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2777386dc2e3c950980a469d4ac9701ccbab3a02/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70c8839f7cc14436a0ed3ab21d2ee14082e29e46", "url": "https://api.github.com/repos/rust-lang/rust/commits/70c8839f7cc14436a0ed3ab21d2ee14082e29e46", "html_url": "https://github.com/rust-lang/rust/commit/70c8839f7cc14436a0ed3ab21d2ee14082e29e46"}], "stats": {"total": 90, "additions": 45, "deletions": 45}, "files": [{"sha": "f2d4ceb16366ec8ca87ff40f2f09816c2c3240ea", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2777386dc2e3c950980a469d4ac9701ccbab3a02/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2777386dc2e3c950980a469d4ac9701ccbab3a02/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=2777386dc2e3c950980a469d4ac9701ccbab3a02", "patch": "@@ -1894,7 +1894,7 @@ impl<'a> LoweringContext<'a> {\n                     hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n                         if self.collect_elided_lifetimes {\n                             // Use `'_` for both implicit and underscore lifetimes in\n-                            // `abstract type Foo<'_>: SomeTrait<'_>;`.\n+                            // `type Foo<'_> = impl SomeTrait<'_>;`.\n                             hir::LifetimeName::Underscore\n                         } else {\n                             return;"}, {"sha": "7105dd8f745c6fdde1299f1cb49b9f925538676e", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2777386dc2e3c950980a469d4ac9701ccbab3a02/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2777386dc2e3c950980a469d4ac9701ccbab3a02/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=2777386dc2e3c950980a469d4ac9701ccbab3a02", "patch": "@@ -18,19 +18,19 @@ use syntax_pos::Span;\n \n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n \n-/// Information about the opaque, abstract types whose values we\n+/// Information about the opaque types whose values we\n /// are inferring in this function (these are the `impl Trait` that\n /// appear in the return type).\n #[derive(Copy, Clone, Debug)]\n pub struct OpaqueTypeDecl<'tcx> {\n-    /// The substitutions that we apply to the abstract that this\n+    /// The substitutions that we apply to the opaque type that this\n     /// `impl Trait` desugars to. e.g., if:\n     ///\n     ///     fn foo<'a, 'b, T>() -> impl Trait<'a>\n     ///\n     /// winds up desugared to:\n     ///\n-    ///     abstract type Foo<'x, X>: Trait<'x>\n+    ///     type Foo<'x, X> = impl Trait<'x>\n     ///     fn foo<'a, 'b, T>() -> Foo<'a, T>\n     ///\n     /// then `substs` would be `['a, T]`.\n@@ -50,7 +50,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// over-approximated, but better than nothing.\n     pub definition_span: Span,\n \n-    /// The type variable that represents the value of the abstract type\n+    /// The type variable that represents the value of the opaque type\n     /// that we require. In other words, after we compile this function,\n     /// we will be created a constraint like:\n     ///\n@@ -164,12 +164,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Here, we have two `impl Trait` types whose values are being\n     /// inferred (the `impl Bar<'a>` and the `impl\n     /// Bar<'b>`). Conceptually, this is sugar for a setup where we\n-    /// define underlying abstract types (`Foo1`, `Foo2`) and then, in\n+    /// define underlying opaque types (`Foo1`, `Foo2`) and then, in\n     /// the return type of `foo`, we *reference* those definitions:\n     ///\n     /// ```text\n-    /// abstract type Foo1<'x>: Bar<'x>;\n-    /// abstract type Foo2<'x>: Bar<'x>;\n+    /// type Foo1<'x> = impl Bar<'x>;\n+    /// type Foo2<'x> = impl Bar<'x>;\n     /// fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n     ///                    //  ^^^^ ^^\n     ///                    //  |    |\n@@ -228,7 +228,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ///\n     /// This is actually a bit of a tricky constraint in general. We\n     /// want to say that each variable (e.g., `'0`) can only take on\n-    /// values that were supplied as arguments to the abstract type\n+    /// values that were supplied as arguments to the opaque type\n     /// (e.g., `'a` for `Foo1<'a>`) or `'static`, which is always in\n     /// scope. We don't have a constraint quite of this kind in the current\n     /// region checker.\n@@ -279,10 +279,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// # The `free_region_relations` parameter\n     ///\n     /// The `free_region_relations` argument is used to find the\n-    /// \"minimum\" of the regions supplied to a given abstract type.\n+    /// \"minimum\" of the regions supplied to a given opaque type.\n     /// It must be a relation that can answer whether `'a <= 'b`,\n     /// where `'a` and `'b` are regions that appear in the \"substs\"\n-    /// for the abstract type references (the `<'a>` in `Foo1<'a>`).\n+    /// for the opaque type references (the `<'a>` in `Foo1<'a>`).\n     ///\n     /// Note that we do not impose the constraints based on the\n     /// generic regions from the `Foo1` definition (e.g., `'x`). This\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ///\n     /// Here, the fact that `'b: 'a` is known only because of the\n     /// implied bounds from the `&'a &'b u32` parameter, and is not\n-    /// \"inherent\" to the abstract type definition.\n+    /// \"inherent\" to the opaque type definition.\n     ///\n     /// # Parameters\n     ///\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // There were no `required_region_bounds`,\n         // so we have to search for a `least_region`.\n         // Go through all the regions used as arguments to the\n-        // abstract type. These are the parameters to the abstract\n+        // opaque type. These are the parameters to the opaque\n         // type; so in our example above, `substs` would contain\n         // `['a]` for the first impl trait and `'b` for the\n         // second.\n@@ -528,12 +528,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Given the fully resolved, instantiated type for an opaque\n     /// type, i.e., the value of an inference variable like C1 or C2\n-    /// (*), computes the \"definition type\" for an abstract type\n+    /// (*), computes the \"definition type\" for an opaque type\n     /// definition -- that is, the inferred value of `Foo1<'x>` or\n     /// `Foo2<'x>` that we would conceptually use in its definition:\n     ///\n-    ///     abstract type Foo1<'x>: Bar<'x> = AAA; <-- this type AAA\n-    ///     abstract type Foo2<'x>: Bar<'x> = BBB; <-- or this type BBB\n+    ///     type Foo1<'x> = impl Bar<'x> = AAA; <-- this type AAA\n+    ///     type Foo2<'x> = impl Bar<'x> = BBB; <-- or this type BBB\n     ///     fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n     ///\n     /// Note that these values are defined in terms of a distinct set of\n@@ -994,15 +994,15 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     // value we are inferring.  At present, this is\n                     // always true during the first phase of\n                     // type-check, but not always true later on during\n-                    // NLL. Once we support named abstract types more fully,\n+                    // NLL. Once we support named opaque types more fully,\n                     // this same scenario will be able to arise during all phases.\n                     //\n-                    // Here is an example using `abstract type` that indicates\n-                    // the distinction we are checking for:\n+                    // Here is an example using type alias `impl Trait`\n+                    // that indicates the distinction we are checking for:\n                     //\n                     // ```rust\n                     // mod a {\n-                    //   pub abstract type Foo: Iterator;\n+                    //   pub type Foo = impl Iterator;\n                     //   pub fn make_foo() -> Foo { .. }\n                     // }\n                     //"}, {"sha": "90e449a0c67e6223f281cd128b5f0d89a8942286", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2777386dc2e3c950980a469d4ac9701ccbab3a02/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2777386dc2e3c950980a469d4ac9701ccbab3a02/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=2777386dc2e3c950980a469d4ac9701ccbab3a02", "patch": "@@ -268,17 +268,17 @@ enum Scope<'a> {\n         track_lifetime_uses: bool,\n \n         /// Whether or not this binder would serve as the parent\n-        /// binder for abstract types introduced within. For example:\n+        /// binder for opaque types introduced within. For example:\n         ///\n         ///     fn foo<'a>() -> impl for<'b> Trait<Item = impl Trait2<'a>>\n         ///\n-        /// Here, the abstract types we create for the `impl Trait`\n+        /// Here, the opaque types we create for the `impl Trait`\n         /// and `impl Trait2` references will both have the `foo` item\n         /// as their parent. When we get to `impl Trait2`, we find\n         /// that it is nested within the `for<>` binder -- this flag\n         /// allows us to skip that when looking for the parent binder\n-        /// of the resulting abstract type.\n-        abstract_type_parent: bool,\n+        /// of the resulting opaque type.\n+        opaque_type_parent: bool,\n \n         s: ScopeRef<'a>,\n     },\n@@ -526,7 +526,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index: index + non_lifetime_count,\n-                    abstract_type_parent: true,\n+                    opaque_type_parent: true,\n                     track_lifetime_uses,\n                     s: ROOT_SCOPE,\n                 };\n@@ -574,7 +574,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     next_early_index,\n                     track_lifetime_uses: true,\n-                    abstract_type_parent: false,\n+                    opaque_type_parent: false,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n@@ -622,9 +622,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             hir::TyKind::Def(item_id, ref lifetimes) => {\n                 // Resolve the lifetimes in the bounds to the lifetime defs in the generics.\n                 // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n-                // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n-                //                          ^            ^ this gets resolved in the scope of\n-                //                                         the exist_ty generics\n+                // `type MyAnonTy<'b> = impl MyTrait<'b>;`\n+                //                 ^                  ^ this gets resolved in the scope of\n+                //                                      the opaque_ty generics\n                 let (generics, bounds) = match self.tcx.hir().expect_item(item_id.id).node\n                 {\n                     // Named opaque `impl Trait` types are reached via `TyKind::Path`.\n@@ -687,7 +687,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                 // We want to start our early-bound indices at the end of the parent scope,\n                 // not including any parent `impl Trait`s.\n-                let mut index = self.next_early_index_for_abstract_type();\n+                let mut index = self.next_early_index_for_opaque_type();\n                 debug!(\"visit_ty: index = {}\", index);\n \n                 let mut elision = None;\n@@ -728,7 +728,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             next_early_index,\n                             s: this.scope,\n                             track_lifetime_uses: true,\n-                            abstract_type_parent: false,\n+                            opaque_type_parent: false,\n                         };\n                         this.with(scope, |_old_scope, this| {\n                             this.visit_generics(generics);\n@@ -743,7 +743,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         next_early_index,\n                         s: self.scope,\n                         track_lifetime_uses: true,\n-                        abstract_type_parent: false,\n+                        opaque_type_parent: false,\n                     };\n                     self.with(scope, |_old_scope, this| {\n                         this.visit_generics(generics);\n@@ -796,7 +796,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n                     track_lifetime_uses: true,\n-                    abstract_type_parent: true,\n+                    opaque_type_parent: true,\n                 };\n                 self.with(scope, |_old_scope, this| {\n                     this.visit_generics(generics);\n@@ -848,7 +848,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n                     track_lifetime_uses: true,\n-                    abstract_type_parent: true,\n+                    opaque_type_parent: true,\n                 };\n                 self.with(scope, |_old_scope, this| {\n                     this.visit_generics(generics);\n@@ -879,7 +879,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index,\n                     s: self.scope,\n                     track_lifetime_uses: true,\n-                    abstract_type_parent: true,\n+                    opaque_type_parent: true,\n                 };\n                 self.with(scope, |_old_scope, this| {\n                     this.visit_generics(generics);\n@@ -967,7 +967,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             s: self.scope,\n                             next_early_index,\n                             track_lifetime_uses: true,\n-                            abstract_type_parent: false,\n+                            opaque_type_parent: false,\n                         };\n                         let result = self.with(scope, |old_scope, this| {\n                             this.check_lifetime_params(old_scope, &bound_generic_params);\n@@ -1037,7 +1037,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 s: self.scope,\n                 next_early_index,\n                 track_lifetime_uses: true,\n-                abstract_type_parent: false,\n+                opaque_type_parent: false,\n             };\n             self.with(scope, |old_scope, this| {\n                 this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n@@ -1753,7 +1753,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             lifetimes,\n             next_early_index,\n             s: self.scope,\n-            abstract_type_parent: true,\n+            opaque_type_parent: true,\n             track_lifetime_uses: false,\n         };\n         self.with(scope, move |old_scope, this| {\n@@ -1762,17 +1762,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         });\n     }\n \n-    fn next_early_index_helper(&self, only_abstract_type_parent: bool) -> u32 {\n+    fn next_early_index_helper(&self, only_opaque_type_parent: bool) -> u32 {\n         let mut scope = self.scope;\n         loop {\n             match *scope {\n                 Scope::Root => return 0,\n \n                 Scope::Binder {\n                     next_early_index,\n-                    abstract_type_parent,\n+                    opaque_type_parent,\n                     ..\n-                } if (!only_abstract_type_parent || abstract_type_parent) =>\n+                } if (!only_opaque_type_parent || opaque_type_parent) =>\n                 {\n                     return next_early_index\n                 }\n@@ -1792,10 +1792,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     /// Returns the next index one would use for an `impl Trait` that\n-    /// is being converted into an `abstract type`. This will be the\n+    /// is being converted into an opaque type alias `impl Trait`. This will be the\n     /// next early index from the enclosing item, for the most\n-    /// part. See the `abstract_type_parent` field for more info.\n-    fn next_early_index_for_abstract_type(&self) -> u32 {\n+    /// part. See the `opaque_type_parent` field for more info.\n+    fn next_early_index_for_opaque_type(&self) -> u32 {\n         self.next_early_index_helper(false)\n     }\n "}, {"sha": "97f73b4e1f224085509d45515b8c03559592af43", "filename": "src/test/rustdoc-ui/coverage/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2777386dc2e3c950980a469d4ac9701ccbab3a02/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2777386dc2e3c950980a469d4ac9701ccbab3a02/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Ftraits.rs?ref=2777386dc2e3c950980a469d4ac9701ccbab3a02", "patch": "@@ -31,7 +31,7 @@ pub trait MyAlias = ThisTrait + Send + Sync;\n \n // FIXME(58624): once rustdoc can process opaque `impl Trait` types,\n // we need to make sure they're counted\n-// /// woah, getting all abstract in here\n+// /// woah, getting all opaque in here\n // pub type ThisExists = impl ThisTrait;\n //\n // /// why don't we get a little more concrete"}]}