{"sha": "4136b59b7da8866762761ed29405a5c5f58a5e3d", "node_id": "C_kwDOAAsO6NoAKDQxMzZiNTliN2RhODg2Njc2Mjc2MWVkMjk0MDVhNWM1ZjU4YTVlM2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-20T12:09:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-20T12:09:52Z"}, "message": "Auto merge of #99806 - oli-obk:unconstrained_opaque_type, r=estebank\n\nAllow patterns to constrain the hidden type of opaque types\n\nfixes #96572\n\nreverts a revert as original PR was a perf regression that was fixed by reverting it: https://github.com/rust-lang/rust/pull/99368#issuecomment-1186587864)\n\nTODO:\n\n* check if https://github.com/rust-lang/rust/issues/99685 is avoided", "tree": {"sha": "8d1b8d66efb35a9408c4331d44adde8815290734", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d1b8d66efb35a9408c4331d44adde8815290734"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4136b59b7da8866762761ed29405a5c5f58a5e3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4136b59b7da8866762761ed29405a5c5f58a5e3d", "html_url": "https://github.com/rust-lang/rust/commit/4136b59b7da8866762761ed29405a5c5f58a5e3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4136b59b7da8866762761ed29405a5c5f58a5e3d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fd6d03e22fba2930ad377b87299de6a37076074", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fd6d03e22fba2930ad377b87299de6a37076074", "html_url": "https://github.com/rust-lang/rust/commit/8fd6d03e22fba2930ad377b87299de6a37076074"}, {"sha": "1905f8c441fa2050de5c4574bb7f6594abc31274", "url": "https://api.github.com/repos/rust-lang/rust/commits/1905f8c441fa2050de5c4574bb7f6594abc31274", "html_url": "https://github.com/rust-lang/rust/commit/1905f8c441fa2050de5c4574bb7f6594abc31274"}], "stats": {"total": 563, "additions": 384, "deletions": 179}, "files": [{"sha": "7fff598878537191cde6ef15f82aef1dd1421132", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -2146,7 +2146,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             }\n                             StorageDeadOrDrop::Destructor(_) => kind,\n                         },\n-                        ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n+                        ProjectionElem::OpaqueCast { .. }\n+                        | ProjectionElem::Field(..)\n+                        | ProjectionElem::Downcast(..) => {\n                             match place_ty.ty.kind() {\n                                 ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                     // Report the outermost adt with a destructor"}, {"sha": "baabeea58232bcc760ad65b5314e17634995e400", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -237,6 +237,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                 ProjectionElem::Downcast(..) if opt.including_downcast => return None,\n                 ProjectionElem::Downcast(..) => (),\n+                ProjectionElem::OpaqueCast(..) => (),\n                 ProjectionElem::Field(field, _ty) => {\n                     // FIXME(project-rfc_2229#36): print capture precisely here.\n                     if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n@@ -317,6 +318,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     PlaceRef { local, projection: proj_base }.ty(self.body, self.infcx.tcx)\n                 }\n                 ProjectionElem::Downcast(..) => place.ty(self.body, self.infcx.tcx),\n+                ProjectionElem::OpaqueCast(ty) => PlaceTy::from_ty(*ty),\n                 ProjectionElem::Field(_, field_type) => PlaceTy::from_ty(*field_type),\n             },\n         };"}, {"sha": "202729b4744d624b62423b8dd1d3845eec1e3431", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -169,6 +169,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         ..,\n                         ProjectionElem::Index(_)\n                         | ProjectionElem::ConstantIndex { .. }\n+                        | ProjectionElem::OpaqueCast { .. }\n                         | ProjectionElem::Subslice { .. }\n                         | ProjectionElem::Downcast(..),\n                     ],"}, {"sha": "cb16bec57ee5a1910e7938dbca35ac966691f442", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -1781,6 +1781,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         for (place_base, elem) in place.iter_projections().rev() {\n             match elem {\n                 ProjectionElem::Index(_/*operand*/) |\n+                ProjectionElem::OpaqueCast(_) |\n                 ProjectionElem::ConstantIndex { .. } |\n                 // assigning to P[i] requires P to be valid.\n                 ProjectionElem::Downcast(_/*adt_def*/, _/*variant_idx*/) =>\n@@ -2172,6 +2173,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     | ProjectionElem::Index(..)\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. }\n+                    | ProjectionElem::OpaqueCast { .. }\n                     | ProjectionElem::Downcast(..) => {\n                         let upvar_field_projection = self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {"}, {"sha": "0e71efd6f8d3e2ffc79b59bb06610ace769fa066", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -250,6 +250,7 @@ fn place_components_conflict<'tcx>(\n                 | (ProjectionElem::Index { .. }, _, _)\n                 | (ProjectionElem::ConstantIndex { .. }, _, _)\n                 | (ProjectionElem::Subslice { .. }, _, _)\n+                | (ProjectionElem::OpaqueCast { .. }, _, _)\n                 | (ProjectionElem::Downcast { .. }, _, _) => {\n                     // Recursive case. This can still be disjoint on a\n                     // further iteration if this a shallow access and\n@@ -317,6 +318,17 @@ fn place_projection_conflict<'tcx>(\n             debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n             Overlap::EqualOrDisjoint\n         }\n+        (ProjectionElem::OpaqueCast(v1), ProjectionElem::OpaqueCast(v2)) => {\n+            if v1 == v2 {\n+                // same type - recur.\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-OPAQUE\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                // Different types. Disjoint!\n+                debug!(\"place_element_conflict: DISJOINT-OPAQUE\");\n+                Overlap::Disjoint\n+            }\n+        }\n         (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n             if f1 == f2 {\n                 // same field (e.g., `a.y` vs. `a.y`) - recur.\n@@ -520,6 +532,7 @@ fn place_projection_conflict<'tcx>(\n             | ProjectionElem::Field(..)\n             | ProjectionElem::Index(..)\n             | ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::OpaqueCast { .. }\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Downcast(..),\n             _,"}, {"sha": "2b50cbac9a02da128786fa86e3ed5d80dcfa8b44", "filename": "compiler/rustc_borrowck/src/prefixes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -81,6 +81,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         }\n                         ProjectionElem::Downcast(..)\n                         | ProjectionElem::Subslice { .. }\n+                        | ProjectionElem::OpaqueCast { .. }\n                         | ProjectionElem::ConstantIndex { .. }\n                         | ProjectionElem::Index(_) => {\n                             cursor = cursor_base;"}, {"sha": "c51debdc863dd22e7e6d16ef6a462153f55d4bf3", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -764,6 +764,19 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 }\n                 PlaceTy::from_ty(fty)\n             }\n+            ProjectionElem::OpaqueCast(ty) => {\n+                let ty = self.sanitize_type(place, ty);\n+                let ty = self.cx.normalize(ty, location);\n+                self.cx\n+                    .eq_types(\n+                        base.ty,\n+                        ty,\n+                        location.to_locations(),\n+                        ConstraintCategory::TypeAnnotation,\n+                    )\n+                    .unwrap();\n+                PlaceTy::from_ty(ty)\n+            }\n         }\n     }\n \n@@ -1170,10 +1183,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 tcx,\n                 self.param_env,\n                 proj,\n-                |this, field, ()| {\n+                |this, field, _| {\n                     let ty = this.field_ty(tcx, field);\n                     self.normalize(ty, locations)\n                 },\n+                |_, _| unreachable!(),\n             );\n             curr_projected_ty = projected_ty;\n         }\n@@ -2503,6 +2517,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n                 ProjectionElem::Field(..)\n                 | ProjectionElem::Downcast(..)\n+                | ProjectionElem::OpaqueCast(..)\n                 | ProjectionElem::Index(..)\n                 | ProjectionElem::ConstantIndex { .. }\n                 | ProjectionElem::Subslice { .. } => {"}, {"sha": "11540d8008160324d74ad358c875fac72cfb1aea", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -850,6 +850,7 @@ pub(crate) fn codegen_place<'tcx>(\n             PlaceElem::Deref => {\n                 cplace = cplace.place_deref(fx);\n             }\n+            PlaceElem::OpaqueCast(ty) => cplace = cplace.place_opaque_cast(fx, ty),\n             PlaceElem::Field(field, _ty) => {\n                 cplace = cplace.place_field(fx, field);\n             }"}, {"sha": "3fa3e3657cb63ce13dc09f0edec5aed3e08e69ae", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -621,6 +621,14 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n+    pub(crate) fn place_opaque_cast(\n+        self,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> CPlace<'tcx> {\n+        CPlace { inner: self.inner, layout: fx.layout_of(ty) }\n+    }\n+\n     pub(crate) fn place_field(\n         self,\n         fx: &mut FunctionCx<'_, '_, 'tcx>,"}, {"sha": "9c18df5643f1c51dc1889a5cec2a2b18b13e968c", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -400,6 +400,21 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         downcast\n     }\n \n+    pub fn project_type<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        &self,\n+        bx: &mut Bx,\n+        ty: Ty<'tcx>,\n+    ) -> Self {\n+        let mut downcast = *self;\n+        downcast.layout = bx.cx().layout_of(ty);\n+\n+        // Cast to the appropriate type.\n+        let variant_ty = bx.cx().backend_type(downcast.layout);\n+        downcast.llval = bx.pointercast(downcast.llval, bx.cx().type_ptr_to(variant_ty));\n+\n+        downcast\n+    }\n+\n     pub fn storage_live<Bx: BuilderMethods<'a, 'tcx, Value = V>>(&self, bx: &mut Bx) {\n         bx.lifetime_start(self.llval, self.layout.size);\n     }\n@@ -442,6 +457,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 mir::ProjectionElem::Field(ref field, _) => {\n                     cg_base.project_field(bx, field.index())\n                 }\n+                mir::ProjectionElem::OpaqueCast(ty) => cg_base.project_type(bx, ty),\n                 mir::ProjectionElem::Index(index) => {\n                     let index = &mir::Operand::Copy(mir::Place::from(index));\n                     let index = self.codegen_operand(bx, index);"}, {"sha": "6b2e2bb8aca8c604ce9fde02652de85675af3b09", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -350,6 +350,11 @@ where\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::Provenance>> {\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n+            OpaqueCast(ty) => {\n+                let mut place = base.clone();\n+                place.layout = self.layout_of(ty)?;\n+                place\n+            }\n             Field(field, _) => self.place_field(base, field.index())?,\n             Downcast(_, variant) => self.place_downcast(base, variant)?,\n             Deref => self.deref_operand(&self.place_to_op(base)?)?.into(),\n@@ -374,6 +379,11 @@ where\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n+            OpaqueCast(ty) => {\n+                let mut op = base.clone();\n+                op.layout = self.layout_of(ty)?;\n+                op\n+            }\n             Field(field, _) => self.operand_field(base, field.index())?,\n             Downcast(_, variant) => self.operand_downcast(base, variant)?,\n             Deref => self.deref_operand(base)?.into(),"}, {"sha": "a8f6507d5949ddfabb994577c54fb8f94ce507f3", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -656,6 +656,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n             ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Downcast(..)\n+            | ProjectionElem::OpaqueCast(..)\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Field(..)\n             | ProjectionElem::Index(_) => {}"}, {"sha": "fb22befd0a4a76c97056ba3a00b4c8b4d96b411d", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -308,6 +308,7 @@ where\n \n             ProjectionElem::Deref\n             | ProjectionElem::Field(_, _)\n+            | ProjectionElem::OpaqueCast(_)\n             | ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Downcast(_, _)"}, {"sha": "461051574e565e03849e0224bf5e89fad35bdc3e", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -361,7 +361,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             return Err(Unpromotable);\n                         }\n                     }\n-                    ProjectionElem::Downcast(..) => {\n+                    ProjectionElem::OpaqueCast(..) | ProjectionElem::Downcast(..) => {\n                         return Err(Unpromotable);\n                     }\n "}, {"sha": "86ffce8ceb41a2fee5f92e442de54acb3967f5d7", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -1380,6 +1380,7 @@ impl<V, T> ProjectionElem<V, T> {\n \n             Self::Field(_, _)\n             | Self::Index(_)\n+            | Self::OpaqueCast(_)\n             | Self::ConstantIndex { .. }\n             | Self::Subslice { .. }\n             | Self::Downcast(_, _) => false,\n@@ -1574,7 +1575,9 @@ impl Debug for Place<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         for elem in self.projection.iter().rev() {\n             match elem {\n-                ProjectionElem::Downcast(_, _) | ProjectionElem::Field(_, _) => {\n+                ProjectionElem::OpaqueCast(_)\n+                | ProjectionElem::Downcast(_, _)\n+                | ProjectionElem::Field(_, _) => {\n                     write!(fmt, \"(\").unwrap();\n                 }\n                 ProjectionElem::Deref => {\n@@ -1590,6 +1593,9 @@ impl Debug for Place<'_> {\n \n         for elem in self.projection.iter() {\n             match elem {\n+                ProjectionElem::OpaqueCast(ty) => {\n+                    write!(fmt, \" as {})\", ty)?;\n+                }\n                 ProjectionElem::Downcast(Some(name), _index) => {\n                     write!(fmt, \" as {})\", name)?;\n                 }"}, {"sha": "d461b4e434fd7caef95d79d0e43f0009276b42fc", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -829,6 +829,9 @@ pub type AssertMessage<'tcx> = AssertKind<Operand<'tcx>>;\n ///    generator has more than one variant, the parent place's variant index must be set, indicating\n ///    which variant is being used. If it has just one variant, the variant index may or may not be\n ///    included - the single possible variant is inferred if it is not included.\n+///  - [`OpaqueCast`](ProjectionElem::OpaqueCast): This projection changes the place's type to the\n+///    given one, and makes no other changes. A `OpaqueCast` projection on any type other than an\n+///    opaque type from the current crate is not well-formed.\n ///  - [`ConstantIndex`](ProjectionElem::ConstantIndex): Computes an offset in units of `T` into the\n ///    place as described in the documentation for the `ProjectionElem`. The resulting address is\n ///    the parent's address plus that offset, and the type is `T`. This is only legal if the parent\n@@ -928,6 +931,10 @@ pub enum ProjectionElem<V, T> {\n     ///\n     /// The included Symbol is the name of the variant, used for printing MIR.\n     Downcast(Option<Symbol>, VariantIdx),\n+\n+    /// Like an explicit cast from an opaque type to a concrete type, but without\n+    /// requiring an intermediate variable.\n+    OpaqueCast(T),\n }\n \n /// Alias for projections as they appear in places, where the base is a place"}, {"sha": "fa3adafd4b85f385c884f5b5c155234dbfce021a", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -56,7 +56,7 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// `PlaceElem`, where we can just use the `Ty` that is already\n     /// stored inline on field projection elems.\n     pub fn projection_ty(self, tcx: TyCtxt<'tcx>, elem: PlaceElem<'tcx>) -> PlaceTy<'tcx> {\n-        self.projection_ty_core(tcx, ty::ParamEnv::empty(), &elem, |_, _, ty| ty)\n+        self.projection_ty_core(tcx, ty::ParamEnv::empty(), &elem, |_, _, ty| ty, |_, ty| ty)\n     }\n \n     /// `place_ty.projection_ty_core(tcx, elem, |...| { ... })`\n@@ -70,6 +70,7 @@ impl<'tcx> PlaceTy<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         elem: &ProjectionElem<V, T>,\n         mut handle_field: impl FnMut(&Self, Field, T) -> Ty<'tcx>,\n+        mut handle_opaque_cast: impl FnMut(&Self, T) -> Ty<'tcx>,\n     ) -> PlaceTy<'tcx>\n     where\n         V: ::std::fmt::Debug,\n@@ -108,6 +109,7 @@ impl<'tcx> PlaceTy<'tcx> {\n                 PlaceTy { ty: self.ty, variant_index: Some(index) }\n             }\n             ProjectionElem::Field(f, fty) => PlaceTy::from_ty(handle_field(&self, f, fty)),\n+            ProjectionElem::OpaqueCast(ty) => PlaceTy::from_ty(handle_opaque_cast(&self, ty)),\n         };\n         debug!(\"projection_ty self: {:?} elem: {:?} yields: {:?}\", self, elem, answer);\n         answer"}, {"sha": "ddcf3711bfc957b92956234fb6d50e7fc040935d", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -1084,6 +1084,11 @@ macro_rules! visit_place_fns {\n                     self.visit_ty(&mut new_ty, TyContext::Location(location));\n                     if ty != new_ty { Some(PlaceElem::Field(field, new_ty)) } else { None }\n                 }\n+                PlaceElem::OpaqueCast(ty) => {\n+                    let mut new_ty = ty;\n+                    self.visit_ty(&mut new_ty, TyContext::Location(location));\n+                    if ty != new_ty { Some(PlaceElem::OpaqueCast(new_ty)) } else { None }\n+                }\n                 PlaceElem::Deref\n                 | PlaceElem::ConstantIndex { .. }\n                 | PlaceElem::Subslice { .. }\n@@ -1153,7 +1158,7 @@ macro_rules! visit_place_fns {\n             location: Location,\n         ) {\n             match elem {\n-                ProjectionElem::Field(_field, ty) => {\n+                ProjectionElem::OpaqueCast(ty) | ProjectionElem::Field(_, ty) => {\n                     self.visit_ty(ty, TyContext::Location(location));\n                 }\n                 ProjectionElem::Index(local) => {"}, {"sha": "4d9e9b7c4738d117f42f21fe6f13887dc7f9fbee", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -69,7 +69,7 @@ pub(crate) enum PlaceBase {\n /// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n #[derive(Clone, Debug, PartialEq)]\n-pub(crate) struct PlaceBuilder<'tcx> {\n+pub(in crate::build) struct PlaceBuilder<'tcx> {\n     base: PlaceBase,\n     projection: Vec<PlaceElem<'tcx>>,\n }\n@@ -102,6 +102,8 @@ fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n                 variant = Some(*idx);\n                 continue;\n             }\n+            // These do not affect anything, they just make sure we know the right type.\n+            ProjectionElem::OpaqueCast(_) => continue,\n             ProjectionElem::Index(..)\n             | ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Subslice { .. } => {\n@@ -168,22 +170,22 @@ fn find_capture_matching_projections<'a, 'tcx>(\n /// `PlaceBuilder` now starts from `PlaceBase::Local`.\n ///\n /// Returns a Result with the error being the PlaceBuilder (`from_builder`) that was not found.\n-fn to_upvars_resolved_place_builder<'a, 'tcx>(\n+#[instrument(level = \"trace\", skip(cx), ret)]\n+fn to_upvars_resolved_place_builder<'tcx>(\n     from_builder: PlaceBuilder<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    upvars: &'a CaptureMap<'tcx>,\n+    cx: &Builder<'_, 'tcx>,\n ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n     match from_builder.base {\n         PlaceBase::Local(_) => Ok(from_builder),\n         PlaceBase::Upvar { var_hir_id, closure_def_id } => {\n             let Some((capture_index, capture)) =\n                 find_capture_matching_projections(\n-                    upvars,\n+                    &cx.upvars,\n                     var_hir_id,\n                     &from_builder.projection,\n                 ) else {\n-                let closure_span = tcx.def_span(closure_def_id);\n-                if !enable_precise_capture(tcx, closure_span) {\n+                let closure_span = cx.tcx.def_span(closure_def_id);\n+                if !enable_precise_capture(cx.tcx, closure_span) {\n                     bug!(\n                         \"No associated capture found for {:?}[{:#?}] even though \\\n                             capture_disjoint_fields isn't enabled\",\n@@ -200,12 +202,13 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n             };\n \n             // Access the capture by accessing the field within the Closure struct.\n-            let capture_info = &upvars[capture_index];\n+            let capture_info = &cx.upvars[capture_index];\n \n             let mut upvar_resolved_place_builder = PlaceBuilder::from(capture_info.use_place);\n \n             // We used some of the projections to build the capture itself,\n             // now we apply the remaining to the upvar resolved place.\n+            trace!(?capture.captured_place, ?from_builder.projection);\n             let remaining_projections = strip_prefix(\n                 capture.captured_place.place.base_ty,\n                 from_builder.projection,\n@@ -230,16 +233,21 @@ fn strip_prefix<'tcx>(\n     prefix_projections: &[HirProjection<'tcx>],\n ) -> impl Iterator<Item = PlaceElem<'tcx>> {\n     let mut iter = projections.into_iter();\n+    let mut next = || match iter.next()? {\n+        // Filter out opaque casts, they are unnecessary in the prefix.\n+        ProjectionElem::OpaqueCast(..) => iter.next(),\n+        other => Some(other),\n+    };\n     for projection in prefix_projections {\n         match projection.kind {\n             HirProjectionKind::Deref => {\n-                assert!(matches!(iter.next(), Some(ProjectionElem::Deref)));\n+                assert!(matches!(next(), Some(ProjectionElem::Deref)));\n             }\n             HirProjectionKind::Field(..) => {\n                 if base_ty.is_enum() {\n-                    assert!(matches!(iter.next(), Some(ProjectionElem::Downcast(..))));\n+                    assert!(matches!(next(), Some(ProjectionElem::Downcast(..))));\n                 }\n-                assert!(matches!(iter.next(), Some(ProjectionElem::Field(..))));\n+                assert!(matches!(next(), Some(ProjectionElem::Field(..))));\n             }\n             HirProjectionKind::Index | HirProjectionKind::Subslice => {\n                 bug!(\"unexpected projection kind: {:?}\", projection);\n@@ -251,24 +259,16 @@ fn strip_prefix<'tcx>(\n }\n \n impl<'tcx> PlaceBuilder<'tcx> {\n-    pub(in crate::build) fn into_place<'a>(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        upvars: &'a CaptureMap<'tcx>,\n-    ) -> Place<'tcx> {\n+    pub(in crate::build) fn into_place(self, cx: &Builder<'_, 'tcx>) -> Place<'tcx> {\n         if let PlaceBase::Local(local) = self.base {\n-            Place { local, projection: tcx.intern_place_elems(&self.projection) }\n+            Place { local, projection: cx.tcx.intern_place_elems(&self.projection) }\n         } else {\n-            self.expect_upvars_resolved(tcx, upvars).into_place(tcx, upvars)\n+            self.expect_upvars_resolved(cx).into_place(cx)\n         }\n     }\n \n-    fn expect_upvars_resolved<'a>(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        upvars: &'a CaptureMap<'tcx>,\n-    ) -> PlaceBuilder<'tcx> {\n-        to_upvars_resolved_place_builder(self, tcx, upvars).unwrap()\n+    fn expect_upvars_resolved(self, cx: &Builder<'_, 'tcx>) -> PlaceBuilder<'tcx> {\n+        to_upvars_resolved_place_builder(self, cx).unwrap()\n     }\n \n     /// Attempts to resolve the `PlaceBuilder`.\n@@ -282,18 +282,21 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     /// not captured. This can happen because the final mir that will be\n     /// generated doesn't require a read for this place. Failures will only\n     /// happen inside closures.\n-    pub(in crate::build) fn try_upvars_resolved<'a>(\n+    pub(in crate::build) fn try_upvars_resolved(\n         self,\n-        tcx: TyCtxt<'tcx>,\n-        upvars: &'a CaptureMap<'tcx>,\n+        cx: &Builder<'_, 'tcx>,\n     ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n-        to_upvars_resolved_place_builder(self, tcx, upvars)\n+        to_upvars_resolved_place_builder(self, cx)\n     }\n \n     pub(crate) fn base(&self) -> PlaceBase {\n         self.base\n     }\n \n+    pub(crate) fn projection(&self) -> &[PlaceElem<'tcx>] {\n+        &self.projection\n+    }\n+\n     pub(crate) fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n         self.project(PlaceElem::Field(f, ty))\n     }\n@@ -353,7 +356,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.tcx, &self.upvars))\n+        block.and(place_builder.into_place(self))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -377,7 +380,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.tcx, &self.upvars))\n+        block.and(place_builder.into_place(self))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -472,7 +475,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             inferred_ty: expr.ty,\n                         });\n \n-                    let place = place_builder.clone().into_place(this.tcx, &this.upvars);\n+                    let place = place_builder.clone().into_place(this);\n                     this.cfg.push(\n                         block,\n                         Statement {\n@@ -610,7 +613,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         if is_outermost_index {\n             self.read_fake_borrows(block, fake_borrow_temps, source_info)\n         } else {\n-            base_place = base_place.expect_upvars_resolved(self.tcx, &self.upvars);\n+            base_place = base_place.expect_upvars_resolved(self);\n             self.add_fake_borrows_of_base(\n                 &base_place,\n                 block,\n@@ -638,12 +641,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let lt = self.temp(bool_ty, expr_span);\n \n         // len = len(slice)\n-        self.cfg.push_assign(\n-            block,\n-            source_info,\n-            len,\n-            Rvalue::Len(slice.into_place(self.tcx, &self.upvars)),\n-        );\n+        self.cfg.push_assign(block, source_info, len, Rvalue::Len(slice.into_place(self)));\n         // lt = idx < len\n         self.cfg.push_assign(\n             block,\n@@ -723,6 +721,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     }\n                     ProjectionElem::Field(..)\n                     | ProjectionElem::Downcast(..)\n+                    | ProjectionElem::OpaqueCast(..)\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. } => (),\n                 }"}, {"sha": "16295b1b19a13ee48e1440399d4e907f8030c675", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -329,10 +329,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let place_builder =\n                         unpack!(block = this.as_place_builder(block, &this.thir[*thir_place]));\n \n-                    if let Ok(place_builder_resolved) =\n-                        place_builder.try_upvars_resolved(this.tcx, &this.upvars)\n-                    {\n-                        let mir_place = place_builder_resolved.into_place(this.tcx, &this.upvars);\n+                    if let Ok(place_builder_resolved) = place_builder.try_upvars_resolved(this) {\n+                        let mir_place = place_builder_resolved.into_place(this);\n                         this.cfg.push_fake_read(\n                             block,\n                             this.source_info(this.tcx.hir().span(*hir_id)),\n@@ -623,8 +621,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // by the parent itself. The mutability of the current capture\n             // is same as that of the capture in the parent closure.\n             PlaceBase::Upvar { .. } => {\n-                let enclosing_upvars_resolved =\n-                    arg_place_builder.clone().into_place(this.tcx, &this.upvars);\n+                let enclosing_upvars_resolved = arg_place_builder.clone().into_place(this);\n \n                 match enclosing_upvars_resolved.as_ref() {\n                     PlaceRef {\n@@ -661,7 +658,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n         };\n \n-        let arg_place = arg_place_builder.into_place(this.tcx, &this.upvars);\n+        let arg_place = arg_place_builder.into_place(this);\n \n         this.cfg.push_assign(\n             block,"}, {"sha": "0ca4e37451995aae9a11d8c10ad6cf0f63b481a5", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -23,17 +23,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         ensure_sufficient_stack(|| self.as_temp_inner(block, temp_lifetime, expr, mutability))\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn as_temp_inner(\n         &mut self,\n         mut block: BasicBlock,\n         temp_lifetime: Option<region::Scope>,\n         expr: &Expr<'tcx>,\n         mutability: Mutability,\n     ) -> BlockAnd<Local> {\n-        debug!(\n-            \"as_temp(block={:?}, temp_lifetime={:?}, expr={:?}, mutability={:?})\",\n-            block, temp_lifetime, expr, mutability\n-        );\n         let this = self;\n \n         let expr_span = expr.span;"}, {"sha": "4b8c134b9d0a836496873a53914e06f02c284ed8", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -15,14 +15,13 @@ use std::iter;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn expr_into_dest(\n         &mut self,\n         destination: Place<'tcx>,\n         mut block: BasicBlock,\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<()> {\n-        debug!(\"expr_into_dest(destination={:?}, block={:?}, expr={:?})\", destination, block, expr);\n-\n         // since we frequently have to reference `self` from within a\n         // closure, where `self` would be shadowed, it's easier to\n         // just use the name `this` uniformly\n@@ -366,7 +365,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             None => {\n                                 let place_builder = place_builder.clone();\n                                 this.consume_by_copy_or_move(\n-                                    place_builder.field(n, *ty).into_place(this.tcx, &this.upvars),\n+                                    place_builder.field(n, *ty).into_place(this),\n                                 )\n                             }\n                         })"}, {"sha": "4fddc24301aba360c40811888843e540e672836e", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -220,10 +220,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let cause_matched_place = FakeReadCause::ForMatchedPlace(None);\n         let source_info = self.source_info(scrutinee_span);\n \n-        if let Ok(scrutinee_builder) =\n-            scrutinee_place_builder.clone().try_upvars_resolved(self.tcx, &self.upvars)\n-        {\n-            let scrutinee_place = scrutinee_builder.into_place(self.tcx, &self.upvars);\n+        if let Ok(scrutinee_builder) = scrutinee_place_builder.clone().try_upvars_resolved(self) {\n+            let scrutinee_place = scrutinee_builder.into_place(self);\n             self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place);\n         }\n \n@@ -246,7 +244,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             .map(|arm| {\n                 let arm = &self.thir[arm];\n                 let arm_has_guard = arm.guard.is_some();\n-                let arm_candidate = Candidate::new(scrutinee.clone(), &arm.pattern, arm_has_guard);\n+                let arm_candidate =\n+                    Candidate::new(scrutinee.clone(), &arm.pattern, arm_has_guard, self);\n                 (arm, arm_candidate)\n             })\n             .collect()\n@@ -349,9 +348,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let mut opt_scrutinee_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n                     let scrutinee_place: Place<'tcx>;\n                     if let Ok(scrutinee_builder) =\n-                        scrutinee_place_builder.clone().try_upvars_resolved(this.tcx, &this.upvars)\n+                        scrutinee_place_builder.clone().try_upvars_resolved(this)\n                     {\n-                        scrutinee_place = scrutinee_builder.into_place(this.tcx, &this.upvars);\n+                        scrutinee_place = scrutinee_builder.into_place(this);\n                         opt_scrutinee_place = Some((Some(&scrutinee_place), scrutinee_span));\n                     }\n                     let scope = this.declare_bindings(\n@@ -584,7 +583,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         initializer: PlaceBuilder<'tcx>,\n         set_match_place: bool,\n     ) -> BlockAnd<()> {\n-        let mut candidate = Candidate::new(initializer.clone(), &irrefutable_pat, false);\n+        let mut candidate = Candidate::new(initializer.clone(), &irrefutable_pat, false, self);\n         let fake_borrow_temps = self.lower_match_tree(\n             block,\n             irrefutable_pat.span,\n@@ -601,12 +600,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             while let Some(next) = {\n                 for binding in &candidate_ref.bindings {\n                     let local = self.var_local_id(binding.var_id, OutsideGuard);\n-\n-                    let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n-                        VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n-                    )))) = self.local_decls[local].local_info else {\n-                        bug!(\"Let binding to non-user variable.\")\n-                    };\n                     // `try_upvars_resolved` may fail if it is unable to resolve the given\n                     // `PlaceBuilder` inside a closure. In this case, we don't want to include\n                     // a scrutinee place. `scrutinee_place_builder` will fail for destructured\n@@ -621,10 +614,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     //    let (v1, v2) = foo;\n                     // };\n                     // ```\n-                    if let Ok(match_pair_resolved) =\n-                        initializer.clone().try_upvars_resolved(self.tcx, &self.upvars)\n-                    {\n-                        let place = match_pair_resolved.into_place(self.tcx, &self.upvars);\n+                    if let Ok(match_pair_resolved) = initializer.clone().try_upvars_resolved(self) {\n+                        let place = match_pair_resolved.into_place(self);\n+\n+                        let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                            VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n+                        )))) = self.local_decls[local].local_info else {\n+                            bug!(\"Let binding to non-user variable.\")\n+                        };\n                         *match_place = Some(place);\n                     }\n                 }\n@@ -654,6 +651,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// scope for the bindings in these patterns, if such a scope had to be\n     /// created. NOTE: Declaring the bindings should always be done in their\n     /// drop scope.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub(crate) fn declare_bindings(\n         &mut self,\n         mut visibility_scope: Option<SourceScope>,\n@@ -662,7 +660,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<&Place<'tcx>>, Span)>,\n     ) -> Option<SourceScope> {\n-        debug!(\"declare_bindings: pattern={:?}\", pattern);\n         self.visit_primary_bindings(\n             &pattern,\n             UserTypeProjections::none(),\n@@ -868,11 +865,16 @@ struct Candidate<'pat, 'tcx> {\n }\n \n impl<'tcx, 'pat> Candidate<'pat, 'tcx> {\n-    fn new(place: PlaceBuilder<'tcx>, pattern: &'pat Pat<'tcx>, has_guard: bool) -> Self {\n+    fn new(\n+        place: PlaceBuilder<'tcx>,\n+        pattern: &'pat Pat<'tcx>,\n+        has_guard: bool,\n+        cx: &Builder<'_, 'tcx>,\n+    ) -> Self {\n         Candidate {\n             span: pattern.span,\n             has_guard,\n-            match_pairs: smallvec![MatchPair { place, pattern }],\n+            match_pairs: smallvec![MatchPair::new(place, pattern, cx)],\n             bindings: Vec::new(),\n             ascriptions: Vec::new(),\n             subcandidates: Vec::new(),\n@@ -1048,6 +1050,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// if `x.0` matches `false` (for the third arm). In the (impossible at\n     /// runtime) case when `x.0` is now `true`, we branch to\n     /// `otherwise_block`.\n+    #[instrument(skip(self, fake_borrows), level = \"debug\")]\n     fn match_candidates<'pat>(\n         &mut self,\n         span: Span,\n@@ -1057,11 +1060,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidates: &mut [&mut Candidate<'pat, 'tcx>],\n         fake_borrows: &mut Option<FxIndexSet<Place<'tcx>>>,\n     ) {\n-        debug!(\n-            \"matched_candidate(span={:?}, candidates={:?}, start_block={:?}, otherwise_block={:?})\",\n-            span, candidates, start_block, otherwise_block,\n-        );\n-\n         // Start by simplifying candidates. Once this process is complete, all\n         // the match pairs which remain require some form of test, whether it\n         // be a switch or pattern comparison.\n@@ -1380,6 +1378,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         )\n     }\n \n+    #[instrument(\n+        skip(self, otherwise, or_span, place, fake_borrows, candidate, pats),\n+        level = \"debug\"\n+    )]\n     fn test_or_pattern<'pat>(\n         &mut self,\n         candidate: &mut Candidate<'pat, 'tcx>,\n@@ -1389,10 +1391,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         place: PlaceBuilder<'tcx>,\n         fake_borrows: &mut Option<FxIndexSet<Place<'tcx>>>,\n     ) {\n-        debug!(\"test_or_pattern:\\ncandidate={:#?}\\npats={:#?}\", candidate, pats);\n+        debug!(\"candidate={:#?}\\npats={:#?}\", candidate, pats);\n         let mut or_candidates: Vec<_> = pats\n             .iter()\n-            .map(|pat| Candidate::new(place.clone(), pat, candidate.has_guard))\n+            .map(|pat| Candidate::new(place.clone(), pat, candidate.has_guard, self))\n             .collect();\n         let mut or_candidate_refs: Vec<_> = or_candidates.iter_mut().collect();\n         let otherwise = if candidate.otherwise_block.is_some() {\n@@ -1605,9 +1607,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // Insert a Shallow borrow of any places that is switched on.\n         if let Some(fb) = fake_borrows && let Ok(match_place_resolved) =\n-            match_place.clone().try_upvars_resolved(self.tcx, &self.upvars)\n+            match_place.clone().try_upvars_resolved(self)\n         {\n-            let resolved_place = match_place_resolved.into_place(self.tcx, &self.upvars);\n+            let resolved_place = match_place_resolved.into_place(self);\n             fb.insert(resolved_place);\n         }\n \n@@ -1634,9 +1636,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             candidates = rest;\n         }\n         // at least the first candidate ought to be tested\n-        assert!(total_candidate_count > candidates.len());\n-        debug!(\"test_candidates: tested_candidates: {}\", total_candidate_count - candidates.len());\n-        debug!(\"test_candidates: untested_candidates: {}\", candidates.len());\n+        assert!(\n+            total_candidate_count > candidates.len(),\n+            \"{}, {:#?}\",\n+            total_candidate_count,\n+            candidates\n+        );\n+        debug!(\"tested_candidates: {}\", total_candidate_count - candidates.len());\n+        debug!(\"untested_candidates: {}\", candidates.len());\n \n         // HACK(matthewjasper) This is a closure so that we can let the test\n         // create its blocks before the rest of the match. This currently\n@@ -1783,8 +1790,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let expr_span = expr.span;\n         let expr_place_builder = unpack!(block = self.lower_scrutinee(block, expr, expr_span));\n         let wildcard = Pat::wildcard_from_ty(pat.ty);\n-        let mut guard_candidate = Candidate::new(expr_place_builder.clone(), &pat, false);\n-        let mut otherwise_candidate = Candidate::new(expr_place_builder.clone(), &wildcard, false);\n+        let mut guard_candidate = Candidate::new(expr_place_builder.clone(), &pat, false, self);\n+        let mut otherwise_candidate =\n+            Candidate::new(expr_place_builder.clone(), &wildcard, false, self);\n         let fake_borrow_temps = self.lower_match_tree(\n             block,\n             pat.span,\n@@ -1794,8 +1802,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n         let mut opt_expr_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n         let expr_place: Place<'tcx>;\n-        if let Ok(expr_builder) = expr_place_builder.try_upvars_resolved(self.tcx, &self.upvars) {\n-            expr_place = expr_builder.into_place(self.tcx, &self.upvars);\n+        if let Ok(expr_builder) = expr_place_builder.try_upvars_resolved(self) {\n+            expr_place = expr_builder.into_place(self);\n             opt_expr_place = Some((Some(&expr_place), expr_span));\n         }\n         let otherwise_post_guard_block = otherwise_candidate.pre_binding_block.unwrap();\n@@ -2209,6 +2217,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// first local is a binding for occurrences of `var` in the guard, which\n     /// will have type `&T`. The second local is a binding for occurrences of\n     /// `var` in the arm body, which will have type `T`.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn declare_binding(\n         &mut self,\n         source_info: SourceInfo,\n@@ -2223,19 +2232,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n         pat_span: Span,\n     ) {\n-        debug!(\n-            \"declare_binding(var_id={:?}, name={:?}, mode={:?}, var_ty={:?}, \\\n-             visibility_scope={:?}, source_info={:?})\",\n-            var_id, name, mode, var_ty, visibility_scope, source_info\n-        );\n-\n         let tcx = self.tcx;\n         let debug_source_info = SourceInfo { span: source_info.span, scope: visibility_scope };\n         let binding_mode = match mode {\n             BindingMode::ByValue => ty::BindingMode::BindByValue(mutability),\n             BindingMode::ByRef(_) => ty::BindingMode::BindByReference(mutability),\n         };\n-        debug!(\"declare_binding: user_ty={:?}\", user_ty);\n         let local = LocalDecl::<'tcx> {\n             mutability,\n             ty: var_ty,\n@@ -2285,7 +2287,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         } else {\n             LocalsForNode::One(for_arm_body)\n         };\n-        debug!(\"declare_binding: vars={:?}\", locals);\n+        debug!(?locals);\n         self.var_indices.insert(var_id, locals);\n     }\n \n@@ -2302,8 +2304,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let (matching, failure) = self.in_if_then_scope(*let_else_scope, |this| {\n             let scrutinee = unpack!(block = this.lower_scrutinee(block, init, initializer_span));\n             let pat = Pat { ty: init.ty, span: else_block_span, kind: PatKind::Wild };\n-            let mut wildcard = Candidate::new(scrutinee.clone(), &pat, false);\n-            let mut candidate = Candidate::new(scrutinee.clone(), pattern, false);\n+            let mut wildcard = Candidate::new(scrutinee.clone(), &pat, false, this);\n+            let mut candidate = Candidate::new(scrutinee.clone(), pattern, false, this);\n             let fake_borrow_temps = this.lower_match_tree(\n                 block,\n                 initializer_span,"}, {"sha": "828f32db3618e5eeabc04d126b2057ccff6088c0", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -37,12 +37,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// only generates a single switch. If this happens this method returns\n     /// `true`.\n+    #[instrument(skip(self, candidate), level = \"debug\")]\n     pub(super) fn simplify_candidate<'pat>(\n         &mut self,\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) -> bool {\n         // repeatedly simplify match pairs until fixed point is reached\n-        debug!(?candidate, \"simplify_candidate\");\n+        debug!(\"{candidate:#?}\");\n \n         // existing_bindings and new_bindings exists to keep the semantics in order.\n         // Reversing the binding order for bindings after `@` changes the binding order in places\n@@ -131,7 +132,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) -> Vec<Candidate<'pat, 'tcx>> {\n         pats.iter()\n             .map(|box pat| {\n-                let mut candidate = Candidate::new(place.clone(), pat, candidate.has_guard);\n+                let mut candidate = Candidate::new(place.clone(), pat, candidate.has_guard, self);\n                 self.simplify_candidate(&mut candidate);\n                 candidate\n             })\n@@ -155,17 +156,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ascription: thir::Ascription { ref annotation, variance },\n             } => {\n                 // Apply the type ascription to the value at `match_pair.place`, which is the\n-                if let Ok(place_resolved) =\n-                    match_pair.place.clone().try_upvars_resolved(self.tcx, &self.upvars)\n-                {\n+                if let Ok(place_resolved) = match_pair.place.clone().try_upvars_resolved(self) {\n                     candidate.ascriptions.push(Ascription {\n                         annotation: annotation.clone(),\n-                        source: place_resolved.into_place(self.tcx, &self.upvars),\n+                        source: place_resolved.into_place(self),\n                         variance,\n                     });\n                 }\n \n-                candidate.match_pairs.push(MatchPair::new(match_pair.place, subpattern));\n+                candidate.match_pairs.push(MatchPair::new(match_pair.place, subpattern, self));\n \n                 Ok(())\n             }\n@@ -184,20 +183,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ref subpattern,\n                 is_primary: _,\n             } => {\n-                if let Ok(place_resolved) =\n-                    match_pair.place.clone().try_upvars_resolved(self.tcx, &self.upvars)\n-                {\n+                if let Ok(place_resolved) = match_pair.place.clone().try_upvars_resolved(self) {\n                     candidate.bindings.push(Binding {\n                         span: match_pair.pattern.span,\n-                        source: place_resolved.into_place(self.tcx, &self.upvars),\n+                        source: place_resolved.into_place(self),\n                         var_id: var,\n                         binding_mode: mode,\n                     });\n                 }\n \n                 if let Some(subpattern) = subpattern.as_ref() {\n                     // this is the `x @ P` case; have to keep matching against `P` now\n-                    candidate.match_pairs.push(MatchPair::new(match_pair.place, subpattern));\n+                    candidate.match_pairs.push(MatchPair::new(match_pair.place, subpattern, self));\n                 }\n \n                 Ok(())\n@@ -308,7 +305,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             PatKind::Deref { ref subpattern } => {\n                 let place_builder = match_pair.place.deref();\n-                candidate.match_pairs.push(MatchPair::new(place_builder, subpattern));\n+                candidate.match_pairs.push(MatchPair::new(place_builder, subpattern, self));\n                 Ok(())\n             }\n "}, {"sha": "b597ecfaa4d6d28b66ca9d844fffa7daea1023cf", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -144,6 +144,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, make_target_blocks, place_builder), level = \"debug\")]\n     pub(super) fn perform_test(\n         &mut self,\n         match_start_span: Span,\n@@ -153,19 +154,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         test: &Test<'tcx>,\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n     ) {\n-        let place: Place<'tcx>;\n-        if let Ok(test_place_builder) = place_builder.try_upvars_resolved(self.tcx, &self.upvars) {\n-            place = test_place_builder.into_place(self.tcx, &self.upvars);\n-        } else {\n-            return;\n-        }\n-        debug!(\n-            \"perform_test({:?}, {:?}: {:?}, {:?})\",\n-            block,\n-            place,\n-            place.ty(&self.local_decls, self.tcx),\n-            test\n-        );\n+        let place = place_builder.into_place(self);\n+        let place_ty = place.ty(&self.local_decls, self.tcx);\n+        debug!(?place, ?place_ty,);\n \n         let source_info = self.source_info(test.span);\n         match test.kind {\n@@ -733,14 +724,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n         // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n-        let elem =\n-            ProjectionElem::Downcast(Some(adt_def.variant(variant_index).name), variant_index);\n-        let downcast_place = match_pair.place.project(elem); // `(x as Variant)`\n+        let downcast_place = match_pair.place.downcast(adt_def, variant_index); // `(x as Variant)`\n         let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n             // e.g., `(x as Variant).0`\n             let place = downcast_place.clone().field(subpattern.field, subpattern.pattern.ty);\n             // e.g., `(x as Variant).0 @ P1`\n-            MatchPair::new(place, &subpattern.pattern)\n+            MatchPair::new(place, &subpattern.pattern, self)\n         });\n \n         candidate.match_pairs.extend(consequent_match_pairs);"}, {"sha": "b854ba47f8f610e4d154a43f321e7a264d333442", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -1,9 +1,11 @@\n+use crate::build::expr::as_place::PlaceBase;\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::matches::MatchPair;\n use crate::build::Builder;\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n use rustc_middle::ty;\n+use rustc_middle::ty::TypeVisitable;\n use smallvec::SmallVec;\n use std::convert::TryInto;\n \n@@ -17,7 +19,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             .iter()\n             .map(|fieldpat| {\n                 let place = place.clone().field(fieldpat.field, fieldpat.pattern.ty);\n-                MatchPair::new(place, &fieldpat.pattern)\n+                MatchPair::new(place, &fieldpat.pattern, self)\n             })\n             .collect()\n     }\n@@ -31,23 +33,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         suffix: &'pat [Box<Pat<'tcx>>],\n     ) {\n         let tcx = self.tcx;\n-        let (min_length, exact_size) = if let Ok(place_resolved) =\n-            place.clone().try_upvars_resolved(tcx, &self.upvars)\n-        {\n-            match place_resolved.into_place(tcx, &self.upvars).ty(&self.local_decls, tcx).ty.kind()\n-            {\n-                ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n-                _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n-            }\n-        } else {\n-            ((prefix.len() + suffix.len()).try_into().unwrap(), false)\n-        };\n+        let (min_length, exact_size) =\n+            if let Ok(place_resolved) = place.clone().try_upvars_resolved(self) {\n+                match place_resolved.into_place(self).ty(&self.local_decls, tcx).ty.kind() {\n+                    ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n+                    _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n+                }\n+            } else {\n+                ((prefix.len() + suffix.len()).try_into().unwrap(), false)\n+            };\n \n         match_pairs.extend(prefix.iter().enumerate().map(|(idx, subpattern)| {\n             let elem =\n                 ProjectionElem::ConstantIndex { offset: idx as u64, min_length, from_end: false };\n             let place = place.clone().project(elem);\n-            MatchPair::new(place, subpattern)\n+            MatchPair::new(place, subpattern, self)\n         }));\n \n         if let Some(subslice_pat) = opt_slice {\n@@ -57,7 +57,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 to: if exact_size { min_length - suffix_len } else { suffix_len },\n                 from_end: !exact_size,\n             });\n-            match_pairs.push(MatchPair::new(subslice, subslice_pat));\n+            match_pairs.push(MatchPair::new(subslice, subslice_pat, self));\n         }\n \n         match_pairs.extend(suffix.iter().rev().enumerate().map(|(idx, subpattern)| {\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 from_end: !exact_size,\n             };\n             let place = place.clone().project(elem);\n-            MatchPair::new(place, subpattern)\n+            MatchPair::new(place, subpattern, self)\n         }));\n     }\n \n@@ -96,10 +96,29 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n-    pub(crate) fn new(\n+    pub(in crate::build) fn new(\n         place: PlaceBuilder<'tcx>,\n         pattern: &'pat Pat<'tcx>,\n+        cx: &Builder<'_, 'tcx>,\n     ) -> MatchPair<'pat, 'tcx> {\n+        // Force the place type to the pattern's type.\n+        // FIXME(oli-obk): can we use this to simplify slice/array pattern hacks?\n+        let mut place = match place.try_upvars_resolved(cx) {\n+            Ok(val) | Err(val) => val,\n+        };\n+\n+        // Only add the OpaqueCast projection if the given place is an opaque type and the\n+        // expected type from the pattern is not.\n+        let may_need_cast = match place.base() {\n+            PlaceBase::Local(local) => {\n+                let ty = Place::ty_from(local, place.projection(), &cx.local_decls, cx.tcx).ty;\n+                ty != pattern.ty && ty.has_opaque_types()\n+            }\n+            _ => true,\n+        };\n+        if may_need_cast {\n+            place = place.project(ProjectionElem::OpaqueCast(pattern.ty));\n+        }\n         MatchPair { place, pattern }\n     }\n }"}, {"sha": "2c7d6a572f45b3e6c5e3c586907cad4281487e08", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -553,6 +553,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n+    #[instrument(skip(self, f), level = \"debug\")]\n     pub(crate) fn in_scope<F, R>(\n         &mut self,\n         region_scope: (region::Scope, SourceInfo),\n@@ -562,7 +563,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     where\n         F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>,\n     {\n-        debug!(\"in_scope(region_scope={:?})\", region_scope);\n         let source_scope = self.source_scope;\n         let tcx = self.tcx;\n         if let LintLevel::Explicit(current_hir_id) = lint_level {\n@@ -589,7 +589,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let rv = unpack!(block = f(self));\n         unpack!(block = self.pop_scope(region_scope, block));\n         self.source_scope = source_scope;\n-        debug!(\"in_scope: exiting region_scope={:?} block={:?}\", region_scope, block);\n+        debug!(?block);\n         block.and(rv)\n     }\n "}, {"sha": "3f8a9d21cd8d1dfb34a0d155e0e3f0d62d00877a", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -48,6 +48,8 @@ impl<'tcx> Cx<'tcx> {\n             _ => None,\n         };\n \n+        trace!(?expr.ty);\n+\n         // Now apply adjustments, if any.\n         for adjustment in self.typeck_results.expr_adjustments(hir_expr) {\n             trace!(?expr, ?adjustment);\n@@ -56,6 +58,8 @@ impl<'tcx> Cx<'tcx> {\n                 self.apply_adjustment(hir_expr, expr, adjustment, adjustment_span.unwrap_or(span));\n         }\n \n+        trace!(?expr.ty, \"after adjustments\");\n+\n         // Next, wrap this up in the expr's scope.\n         expr = Expr {\n             temp_lifetime,"}, {"sha": "6bb33b5890be8bbe0ab37f6c5eb7527cb251158f", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -200,6 +200,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Box<Pat<'tcx>> {\n         let mut ty = self.typeck_results.node_type(pat.hir_id);\n         let mut span = pat.span;"}, {"sha": "02e047afaf31f4255e45d2364f2790dfdca63268", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -842,7 +842,15 @@ fn is_useful<'p, 'tcx>(\n             }\n         }\n     } else {\n-        let ty = v.head().ty();\n+        let mut ty = v.head().ty();\n+\n+        // Opaque types can't get destructured/split, but the patterns can\n+        // actually hint at hidden types, so we use the patterns' types instead.\n+        if let ty::Opaque(..) = ty.kind() {\n+            if let Some(row) = rows.first() {\n+                ty = row.head().ty();\n+            }\n+        }\n         let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);\n         debug!(\"v.head: {:?}, v.span: {:?}\", v.head(), v.head().span());\n         let pcx = &PatCtxt { cx, ty, span: v.head().span(), is_top_level, is_non_exhaustive };"}, {"sha": "702ca2eaf5c4da689fca4ce23be6ffe14ad1eb52", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -893,7 +893,7 @@ where\n             }\n             ty::Slice(ety) => self.open_drop_for_array(*ety, None),\n \n-            _ => bug!(\"open drop from non-ADT `{:?}`\", ty),\n+            _ => span_bug!(self.source_info.span, \"open drop from non-ADT `{:?}`\", ty),\n         }\n     }\n "}, {"sha": "7806e8f45d3ade55a4f6c907a90e0d515273e88a", "filename": "compiler/rustc_mir_dataflow/src/move_paths/abs_domain.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fabs_domain.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -48,6 +48,7 @@ impl<'tcx> Lift for PlaceElem<'tcx> {\n         match *self {\n             ProjectionElem::Deref => ProjectionElem::Deref,\n             ProjectionElem::Field(f, ty) => ProjectionElem::Field(f, ty.lift()),\n+            ProjectionElem::OpaqueCast(ty) => ProjectionElem::OpaqueCast(ty.lift()),\n             ProjectionElem::Index(ref i) => ProjectionElem::Index(i.lift()),\n             ProjectionElem::Subslice { from, to, from_end } => {\n                 ProjectionElem::Subslice { from, to, from_end }"}, {"sha": "9a50c0f988a568ac431906331fd54f9c624b2b32", "filename": "src/test/ui/type-alias-impl-trait/cross_inference_pattern_bug.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -1,8 +1,9 @@\n // compile-flags: --edition=2021\n+// check-pass\n #![feature(type_alias_impl_trait)]\n \n fn main() {\n-    type T = impl Copy; //~ ERROR unconstrained opaque type\n+    type T = impl Copy;\n     let foo: T = (1u32, 2u32);\n     let (a, b): (u32, u32) = foo;\n }"}, {"sha": "03b172e6de5706f8dcf6e1c38e289bed1df6f022", "filename": "src/test/ui/type-alias-impl-trait/cross_inference_pattern_bug.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8fd6d03e22fba2930ad377b87299de6a37076074/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fd6d03e22fba2930ad377b87299de6a37076074/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.stderr?ref=8fd6d03e22fba2930ad377b87299de6a37076074", "patch": "@@ -1,10 +0,0 @@\n-error: unconstrained opaque type\n-  --> $DIR/cross_inference_pattern_bug.rs:5:14\n-   |\n-LL |     type T = impl Copy;\n-   |              ^^^^^^^^^\n-   |\n-   = note: `T` must be used in combination with a concrete type within the same module\n-\n-error: aborting due to previous error\n-"}, {"sha": "b929122a6c23fccee8f2d15ea70ee4459b7885bf", "filename": "src/test/ui/type-alias-impl-trait/cross_inference_pattern_bug_no_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -1,13 +1,13 @@\n-// known-bug: #96572\n // compile-flags: --edition=2021 --crate-type=lib\n // rustc-env:RUST_BACKTRACE=0\n+// check-pass\n \n // tracked in https://github.com/rust-lang/rust/issues/96572\n \n #![feature(type_alias_impl_trait)]\n \n fn main() {\n-    type T = impl Copy;  // error: unconstrained opaque type\n+    type T = impl Copy;\n     let foo: T = (1u32, 2u32);\n-    let (a, b) = foo; // removing this line makes the code compile\n+    let (a, b) = foo; // this line used to make the code fail\n }"}, {"sha": "8aa1f495639951ff05e51d906d728a69dd8fd9bf", "filename": "src/test/ui/type-alias-impl-trait/cross_inference_pattern_bug_no_type.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8fd6d03e22fba2930ad377b87299de6a37076074/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fd6d03e22fba2930ad377b87299de6a37076074/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.stderr?ref=8fd6d03e22fba2930ad377b87299de6a37076074", "patch": "@@ -1,10 +0,0 @@\n-error: unconstrained opaque type\n-  --> $DIR/cross_inference_pattern_bug_no_type.rs:10:14\n-   |\n-LL |     type T = impl Copy;  // error: unconstrained opaque type\n-   |              ^^^^^^^^^\n-   |\n-   = note: `T` must be used in combination with a concrete type within the same module\n-\n-error: aborting due to previous error\n-"}, {"sha": "825710851b01f0dcab6c8bdb7cdd1f6fd9f916da", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-mismatch.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -0,0 +1,10 @@\n+#![feature(type_alias_impl_trait)]\n+\n+fn main() {\n+    type T = impl Copy;\n+    let foo: T = Some((1u32, 2u32));\n+    match foo {\n+        None => (),\n+        Some((a, b, c)) => (), //~ ERROR mismatched types\n+    }\n+}"}, {"sha": "728244a1844dbe8eccb6b8143e1966218814d372", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-mismatch.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.stderr?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -0,0 +1,15 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-96572-unconstrained-mismatch.rs:8:14\n+   |\n+LL |     match foo {\n+   |           --- this expression has type `T`\n+LL |         None => (),\n+LL |         Some((a, b, c)) => (),\n+   |              ^^^^^^^^^ expected a tuple with 2 elements, found one with 3 elements\n+   |\n+   = note: expected tuple `(u32, u32)`\n+              found tuple `(_, _, _)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "2c740ccc1aed42f748de72e9bce57eb50b02ab3a", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -0,0 +1,92 @@\n+#![feature(type_alias_impl_trait)]\n+// check-pass\n+\n+fn main() {\n+    type T = impl Copy;\n+    let foo: T = Some((1u32, 2u32));\n+    match foo {\n+        None => (),\n+        Some((a, b)) => (),\n+    }\n+}\n+\n+fn upvar() {\n+    #[derive(Copy, Clone)]\n+    struct Foo((u32, u32));\n+\n+    type T = impl Copy;\n+    let foo: T = Foo((1u32, 2u32));\n+    let x = move || {\n+        let Foo((a, b)) = foo;\n+    };\n+}\n+\n+fn enum_upvar() {\n+    type T = impl Copy;\n+    let foo: T = Some((1u32, 2u32));\n+    let x = move || {\n+        match foo {\n+            None => (),\n+            Some((a, b)) => (),\n+        }\n+    };\n+}\n+\n+fn r#struct() {\n+    #[derive(Copy, Clone)]\n+    struct Foo((u32, u32));\n+\n+    type U = impl Copy;\n+    let foo: U = Foo((1u32, 2u32));\n+    let Foo((a, b)) = foo;\n+}\n+\n+mod only_pattern {\n+    type T = impl Copy;\n+\n+    fn foo(foo: T) {\n+        let (mut x, mut y) = foo;\n+        x = 42;\n+        y = \"foo\";\n+    }\n+\n+    type U = impl Copy;\n+\n+    fn bar(bar: Option<U>) {\n+        match bar {\n+            Some((mut x, mut y)) => {\n+                x = 42;\n+                y = \"foo\";\n+            }\n+            None => {}\n+        }\n+    }\n+}\n+\n+mod only_pattern_rpit {\n+    #[allow(unconditional_recursion)]\n+    fn foo(b: bool) -> impl Copy {\n+        let (mut x, mut y) = foo(false);\n+        x = 42;\n+        y = \"foo\";\n+        if b {\n+            panic!()\n+        } else {\n+            foo(true)\n+        }\n+    }\n+\n+    fn bar(b: bool) -> Option<impl Copy> {\n+        if b {\n+            return None;\n+        }\n+        match bar(!b) {\n+            Some((mut x, mut y)) => {\n+                x = 42;\n+                y = \"foo\";\n+            }\n+            None => {}\n+        }\n+        None\n+    }\n+}"}, {"sha": "405f022868395dacf3f148419e46557d3baa4b74", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4136b59b7da8866762761ed29405a5c5f58a5e3d/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4136b59b7da8866762761ed29405a5c5f58a5e3d/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=4136b59b7da8866762761ed29405a5c5f58a5e3d", "patch": "@@ -260,6 +260,7 @@ fn check_place<'tcx>(tcx: TyCtxt<'tcx>, place: Place<'tcx>, span: Span, body: &B\n                 }\n             },\n             ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::OpaqueCast(..)\n             | ProjectionElem::Downcast(..)\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Deref"}]}