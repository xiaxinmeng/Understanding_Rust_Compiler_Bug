{"sha": "93ce1c1a597aba7049fe2a39737c8155dd4e2a50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzY2UxYzFhNTk3YWJhNzA0OWZlMmEzOTczN2M4MTU1ZGQ0ZTJhNTA=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-02-15T04:35:24Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-04-03T17:54:29Z"}, "message": "Add floating-point classification functions", "tree": {"sha": "1d86e9ee5603b5b56fc0095945f8c9cebb256472", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d86e9ee5603b5b56fc0095945f8c9cebb256472"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93ce1c1a597aba7049fe2a39737c8155dd4e2a50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93ce1c1a597aba7049fe2a39737c8155dd4e2a50", "html_url": "https://github.com/rust-lang/rust/commit/93ce1c1a597aba7049fe2a39737c8155dd4e2a50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93ce1c1a597aba7049fe2a39737c8155dd4e2a50/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e6d44086cb817cc81b5528d643bab53095773cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e6d44086cb817cc81b5528d643bab53095773cb", "html_url": "https://github.com/rust-lang/rust/commit/4e6d44086cb817cc81b5528d643bab53095773cb"}], "stats": {"total": 233, "additions": 163, "deletions": 70}, "files": [{"sha": "eb901a89ca33270937de73f03b9bb9e1e05d847e", "filename": "crates/core_simd/src/comparisons.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/93ce1c1a597aba7049fe2a39737c8155dd4e2a50/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ce1c1a597aba7049fe2a39737c8155dd4e2a50/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=93ce1c1a597aba7049fe2a39737c8155dd4e2a50", "patch": "@@ -0,0 +1,86 @@\n+use crate::LanesAtMost64;\n+\n+macro_rules! implement_mask_ops {\n+    { $($vector:ident => $mask:ident ($inner_mask_ty:ident, $inner_ty:ident),)* } => {\n+        $(\n+            impl<const LANES: usize> crate::$vector<LANES>\n+            where\n+                crate::$vector<LANES>: LanesAtMost64,\n+                crate::$inner_ty<LANES>: LanesAtMost64,\n+            {\n+                /// Test if each lane is equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_eq(self, other: Self) -> crate::$mask<LANES> {\n+                    unsafe {\n+                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_eq(self, other))\n+                            .into()\n+                    }\n+                }\n+\n+                /// Test if each lane is not equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_ne(self, other: Self) -> crate::$mask<LANES> {\n+                    unsafe {\n+                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_ne(self, other))\n+                            .into()\n+                    }\n+                }\n+\n+                /// Test if each lane is less than the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_lt(self, other: Self) -> crate::$mask<LANES> {\n+                    unsafe {\n+                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_lt(self, other))\n+                            .into()\n+                    }\n+                }\n+\n+                /// Test if each lane is greater than the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_gt(self, other: Self) -> crate::$mask<LANES> {\n+                    unsafe {\n+                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_gt(self, other))\n+                            .into()\n+                    }\n+                }\n+\n+                /// Test if each lane is less than or equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_le(self, other: Self) -> crate::$mask<LANES> {\n+                    unsafe {\n+                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_le(self, other))\n+                            .into()\n+                    }\n+                }\n+\n+                /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_ge(self, other: Self) -> crate::$mask<LANES> {\n+                    unsafe {\n+                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_ge(self, other))\n+                            .into()\n+                    }\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+implement_mask_ops! {\n+    SimdI8 => Mask8 (SimdMask8, SimdI8),\n+    SimdI16 => Mask16 (SimdMask16, SimdI16),\n+    SimdI32 => Mask32 (SimdMask32, SimdI32),\n+    SimdI64 => Mask64 (SimdMask64, SimdI64),\n+    SimdI128 => Mask128 (SimdMask128, SimdI128),\n+    SimdIsize => MaskSize (SimdMaskSize, SimdIsize),\n+\n+    SimdU8 => Mask8 (SimdMask8, SimdI8),\n+    SimdU16 => Mask16 (SimdMask16, SimdI16),\n+    SimdU32 => Mask32 (SimdMask32, SimdI32),\n+    SimdU64 => Mask64 (SimdMask64, SimdI64),\n+    SimdU128 => Mask128 (SimdMask128, SimdI128),\n+    SimdUsize => MaskSize (SimdMaskSize, SimdIsize),\n+\n+    SimdF32 => Mask32 (SimdMask32, SimdI32),\n+    SimdF64 => Mask64 (SimdMask64, SimdI64),\n+}"}, {"sha": "db3b9d0e4091ac6fb27dc9fe11290ee5be84a922", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/93ce1c1a597aba7049fe2a39737c8155dd4e2a50/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ce1c1a597aba7049fe2a39737c8155dd4e2a50/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=93ce1c1a597aba7049fe2a39737c8155dd4e2a50", "patch": "@@ -16,6 +16,7 @@ mod fmt;\n mod intrinsics;\n mod ops;\n mod round;\n+mod comparisons;\n \n mod math;\n "}, {"sha": "d88875deacac781bbdc1095fc4345b9488b2c6ca", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/93ce1c1a597aba7049fe2a39737c8155dd4e2a50/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ce1c1a597aba7049fe2a39737c8155dd4e2a50/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=93ce1c1a597aba7049fe2a39737c8155dd4e2a50", "patch": "@@ -75,6 +75,25 @@ macro_rules! define_mask {\n                     0\n                 }\n             }\n+\n+            /// Creates a mask from an integer vector.\n+            ///\n+            /// # Safety\n+            /// All lanes must be either 0 or -1.\n+            #[inline]\n+            pub unsafe fn from_int_unchecked(value: $type) -> Self {\n+                Self(value)\n+            }\n+\n+            /// Creates a mask from an integer vector.\n+            ///\n+            /// # Panics\n+            /// Panics if any lane is not 0 or -1.\n+            #[inline]\n+            pub fn from_int(value: $type) -> Self {\n+                use core::convert::TryInto;\n+                value.try_into().unwrap()\n+            }\n         }\n \n         impl<const $lanes: usize> core::convert::From<bool> for $name<$lanes>"}, {"sha": "945ee9377f16471d549dd2c480b940fb63bbb57d", "filename": "crates/core_simd/src/masks/mod.rs", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/93ce1c1a597aba7049fe2a39737c8155dd4e2a50/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ce1c1a597aba7049fe2a39737c8155dd4e2a50/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs?ref=93ce1c1a597aba7049fe2a39737c8155dd4e2a50", "patch": "@@ -360,73 +360,6 @@ define_opaque_mask! {\n     @bits crate::SimdIsize<LANES>\n }\n \n-macro_rules! implement_mask_ops {\n-    { $($vector:ident => $mask:ident ($inner_ty:ident),)* } => {\n-        $(\n-            impl<const LANES: usize> crate::$vector<LANES>\n-            where\n-                crate::$vector<LANES>: LanesAtMost64,\n-                crate::$inner_ty<LANES>: LanesAtMost64,\n-            {\n-                /// Test if each lane is equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_eq(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { $mask(crate::intrinsics::simd_eq(self, other)) }\n-                }\n-\n-                /// Test if each lane is not equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_ne(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { $mask(crate::intrinsics::simd_ne(self, other)) }\n-                }\n-\n-                /// Test if each lane is less than the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_lt(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { $mask(crate::intrinsics::simd_lt(self, other)) }\n-                }\n-\n-                /// Test if each lane is greater than the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_gt(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { $mask(crate::intrinsics::simd_gt(self, other)) }\n-                }\n-\n-                /// Test if each lane is less than or equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_le(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { $mask(crate::intrinsics::simd_le(self, other)) }\n-                }\n-\n-                /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_ge(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { $mask(crate::intrinsics::simd_ge(self, other)) }\n-                }\n-            }\n-        )*\n-    }\n-}\n-\n-implement_mask_ops! {\n-    SimdI8 => Mask8 (SimdI8),\n-    SimdI16 => Mask16 (SimdI16),\n-    SimdI32 => Mask32 (SimdI32),\n-    SimdI64 => Mask64 (SimdI64),\n-    SimdI128 => Mask128 (SimdI128),\n-    SimdIsize => MaskSize (SimdIsize),\n-\n-    SimdU8 => Mask8 (SimdI8),\n-    SimdU16 => Mask16 (SimdI16),\n-    SimdU32 => Mask32 (SimdI32),\n-    SimdU64 => Mask64 (SimdI64),\n-    SimdU128 => Mask128 (SimdI128),\n-    SimdUsize => MaskSize (SimdIsize),\n-\n-    SimdF32 => Mask32 (SimdI32),\n-    SimdF64 => Mask64 (SimdI64),\n-}\n-\n /// Vector of eight 8-bit masks\n pub type mask8x8 = Mask8<8>;\n "}, {"sha": "9d72e69ec47c0669500c8b3537c75a6d31197ada", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/93ce1c1a597aba7049fe2a39737c8155dd4e2a50/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ce1c1a597aba7049fe2a39737c8155dd4e2a50/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=93ce1c1a597aba7049fe2a39737c8155dd4e2a50", "patch": "@@ -4,7 +4,7 @@\n /// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n /// representation. Called from `define_float_vector!`.\n macro_rules! impl_float_vector {\n-    { $name:ident, $type:ty, $bits_ty:ident } => {\n+    { $name:ident, $type:ty, $bits_ty:ident, $mask_ty:ident, $mask_impl_ty:ident } => {\n         impl_vector! { $name, $type }\n \n         impl<const LANES: usize> $name<LANES>\n@@ -36,6 +36,60 @@ macro_rules! impl_float_vector {\n                 Self::from_bits(self.to_bits() & no_sign)\n             }\n         }\n+\n+        impl<const LANES: usize> $name<LANES>\n+        where\n+            Self: crate::LanesAtMost64,\n+            crate::$bits_ty<LANES>: crate::LanesAtMost64,\n+            crate::$mask_impl_ty<LANES>: crate::LanesAtMost64,\n+        {\n+            /// Returns true for each lane if it has a positive sign, including\n+            /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n+            #[inline]\n+            pub fn is_sign_positive(self) -> crate::$mask_ty<LANES> {\n+                let sign_bits = self.to_bits() & crate::$bits_ty::splat((!0 >> 1) + 1);\n+                sign_bits.lanes_gt(crate::$bits_ty::splat(0))\n+            }\n+\n+            /// Returns true for each lane if it has a negative sign, including\n+            /// `-0.0`, `NaN`s with negative sign bit and negative infinity.\n+            #[inline]\n+            pub fn is_sign_negative(self) -> crate::$mask_ty<LANES> {\n+                !self.is_sign_positive()\n+            }\n+\n+            /// Returns true for each lane if its value is `NaN`.\n+            #[inline]\n+            pub fn is_nan(self) -> crate::$mask_ty<LANES> {\n+                self.lanes_eq(self)\n+            }\n+\n+            /// Returns true for each lane if its value is positive infinity or negative infinity.\n+            #[inline]\n+            pub fn is_infinite(self) -> crate::$mask_ty<LANES> {\n+                self.abs().lanes_eq(Self::splat(<$type>::INFINITY))\n+            }\n+\n+            /// Returns true for each lane if its value is neither infinite nor `NaN`.\n+            #[inline]\n+            pub fn is_finite(self) -> crate::$mask_ty<LANES> {\n+                self.abs().lanes_lt(Self::splat(<$type>::INFINITY))\n+            }\n+\n+            /// Returns true for each lane if its value is subnormal.\n+            #[inline]\n+            pub fn is_subnormal(self) -> crate::$mask_ty<LANES> {\n+                let mantissa_mask = crate::$bits_ty::splat((1 << (<$type>::MANTISSA_DIGITS - 1)) - 1);\n+                self.abs().lanes_ne(Self::splat(0.0)) & (self.to_bits() & mantissa_mask).lanes_eq(crate::$bits_ty::splat(0))\n+            }\n+\n+            /// Returns true for each lane if its value is neither neither zero, infinite,\n+            /// subnormal, or `NaN`.\n+            #[inline]\n+            pub fn is_normal(self) -> crate::$mask_ty<LANES> {\n+                !(self.abs().lanes_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal())\n+            }\n+        }\n     };\n }\n \n@@ -46,7 +100,7 @@ pub struct SimdF32<const LANES: usize>([f32; LANES])\n where\n     Self: crate::LanesAtMost64;\n \n-impl_float_vector! { SimdF32, f32, SimdU32 }\n+impl_float_vector! { SimdF32, f32, SimdU32, Mask32, SimdI32 }\n \n from_transmute_x86! { unsafe f32x4 => __m128 }\n from_transmute_x86! { unsafe f32x8 => __m256 }\n@@ -58,7 +112,7 @@ pub struct SimdF64<const LANES: usize>([f64; LANES])\n where\n     Self: crate::LanesAtMost64;\n \n-impl_float_vector! { SimdF64, f64, SimdU64 }\n+impl_float_vector! { SimdF64, f64, SimdU64, Mask64, SimdI64 }\n \n from_transmute_x86! { unsafe f64x2 => __m128d }\n from_transmute_x86! { unsafe f64x4 => __m256d }"}]}