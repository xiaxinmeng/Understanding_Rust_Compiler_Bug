{"sha": "476442e48ce0dad5dfbb09a7ef874e09339224fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3NjQ0MmU0OGNlMGRhZDVkZmJiMDlhN2VmODc0ZTA5MzM5MjI0ZmM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-09T23:09:00Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-09T23:17:17Z"}, "message": "Alias-ify walk, typeck, metadata. Cuts another 80kb off rustc.", "tree": {"sha": "988d9f251dc96e42b1b58d1243a3733dbc577a75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/988d9f251dc96e42b1b58d1243a3733dbc577a75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/476442e48ce0dad5dfbb09a7ef874e09339224fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/476442e48ce0dad5dfbb09a7ef874e09339224fc", "html_url": "https://github.com/rust-lang/rust/commit/476442e48ce0dad5dfbb09a7ef874e09339224fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/476442e48ce0dad5dfbb09a7ef874e09339224fc/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "071ed380fb74d2e6a01aebdae0e9ae8ba8b4a9ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/071ed380fb74d2e6a01aebdae0e9ae8ba8b4a9ee", "html_url": "https://github.com/rust-lang/rust/commit/071ed380fb74d2e6a01aebdae0e9ae8ba8b4a9ee"}], "stats": {"total": 303, "additions": 153, "deletions": 150}, "files": [{"sha": "d61edacad5aaf3ca15371b419633f89e083ebdbd", "filename": "src/comp/middle/capture.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/476442e48ce0dad5dfbb09a7ef874e09339224fc/src%2Fcomp%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/476442e48ce0dad5dfbb09a7ef874e09339224fc/src%2Fcomp%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcapture.rs?ref=476442e48ce0dad5dfbb09a7ef874e09339224fc", "patch": "@@ -17,7 +17,7 @@ fn current_context(&env e) -> ast.def_id {\n     ret e.current_context.(Vec.len(e.current_context) - 1u);\n }\n \n-fn enter_item(@env e, @ast.item i) {\n+fn enter_item(@env e, &@ast.item i) {\n     alt (i.node) {\n         case (ast.item_fn(?name, _, _, ?id, _)) {\n             Vec.push(e.current_context, id);\n@@ -29,7 +29,7 @@ fn enter_item(@env e, @ast.item i) {\n     }\n }\n \n-fn leave_item(@env e, @ast.item i) {\n+fn leave_item(@env e, &@ast.item i) {\n     alt (i.node) {\n         case (ast.item_fn(?name, _, _, ?id, _)) {\n             Vec.pop(e.current_context);\n@@ -41,7 +41,7 @@ fn leave_item(@env e, @ast.item i) {\n     }\n }\n \n-fn walk_expr(@env e, @ast.expr x) {\n+fn walk_expr(@env e, &@ast.expr x) {\n     alt (x.node) {\n         case (ast.expr_for(?d, _, _, _)) {\n             alt (d.node) {"}, {"sha": "dee9046d77f517e3e4cd56172b43012369505b85", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/476442e48ce0dad5dfbb09a7ef874e09339224fc/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/476442e48ce0dad5dfbb09a7ef874e09339224fc/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=476442e48ce0dad5dfbb09a7ef874e09339224fc", "patch": "@@ -61,26 +61,26 @@ tag abbrev_ctxt {\n mod Encode {\n \n     type ctxt = rec(\n-        fn(ast.def_id) -> str ds,           // Def -> str Callback.\n+        fn(&ast.def_id) -> str ds,          // Def -> str Callback.\n         ty.ctxt tcx,                        // The type context.\n         abbrev_ctxt abbrevs\n     );\n \n-    fn cx_uses_abbrevs(@ctxt cx) -> bool {\n+    fn cx_uses_abbrevs(&@ctxt cx) -> bool {\n         alt (cx.abbrevs) {\n             case (ac_no_abbrevs)     { ret false; }\n             case (ac_use_abbrevs(_)) { ret true; }\n         }\n     }\n \n-    fn ty_str(@ctxt cx, ty.t t) -> str {\n+    fn ty_str(&@ctxt cx, &ty.t t) -> str {\n         assert (!cx_uses_abbrevs(cx));\n         auto sw = IO.string_writer();\n         enc_ty(sw.get_writer(), cx, t);\n         ret sw.get_str();\n     }\n \n-    fn enc_ty(IO.writer w, @ctxt cx, ty.t t) {\n+    fn enc_ty(&IO.writer w, &@ctxt cx, &ty.t t) {\n         alt (cx.abbrevs) {\n             case (ac_no_abbrevs) { enc_sty(w, cx, ty.struct(cx.tcx, t)); }\n             case (ac_use_abbrevs(?abbrevs)) {\n@@ -121,7 +121,7 @@ mod Encode {\n         }\n     }\n \n-    fn enc_mt(IO.writer w, @ctxt cx, &ty.mt mt) {\n+    fn enc_mt(&IO.writer w, &@ctxt cx, &ty.mt mt) {\n         alt (mt.mut) {\n             case (ast.imm)       { }\n             case (ast.mut)       { w.write_char('m'); }\n@@ -130,7 +130,7 @@ mod Encode {\n         enc_ty(w, cx, mt.ty);\n     }\n \n-    fn enc_sty(IO.writer w, @ctxt cx, ty.sty st) {\n+    fn enc_sty(&IO.writer w, &@ctxt cx, &ty.sty st) {\n         alt (st) {\n             case (ty.ty_nil) { w.write_char('n'); }\n             case (ty.ty_bool) { w.write_char('b'); }\n@@ -231,14 +231,14 @@ mod Encode {\n         }\n     }\n \n-    fn enc_proto(IO.writer w, ast.proto proto) {\n+    fn enc_proto(&IO.writer w, ast.proto proto) {\n         alt (proto) {\n             case (ast.proto_iter) { w.write_char('W'); }\n             case (ast.proto_fn) { w.write_char('F'); }\n         }\n     }\n \n-    fn enc_ty_fn(IO.writer w, @ctxt cx, vec[ty.arg] args, ty.t out) {\n+    fn enc_ty_fn(&IO.writer w, &@ctxt cx, &vec[ty.arg] args, &ty.t out) {\n         w.write_char('[');\n         for (ty.arg arg in args) {\n             if (arg.mode == ty.mo_alias) { w.write_char('&'); }\n@@ -252,14 +252,14 @@ mod Encode {\n \n \n // Returns a Plain Old LLVM String.\n-fn C_postr(str s) -> ValueRef {\n+fn C_postr(&str s) -> ValueRef {\n     ret llvm.LLVMConstString(Str.buf(s), Str.byte_len(s), False);\n }\n \n \n // Path table encoding\n \n-fn encode_name(&EBML.writer ebml_w, str name) {\n+fn encode_name(&EBML.writer ebml_w, &str name) {\n     EBML.start_tag(ebml_w, tag_paths_data_name);\n     ebml_w.writer.write(Str.bytes(name));\n     EBML.end_tag(ebml_w);\n@@ -272,8 +272,8 @@ fn encode_def_id(&EBML.writer ebml_w, &ast.def_id id) {\n }\n \n fn encode_tag_variant_paths(&EBML.writer ebml_w,\n-                            vec[ast.variant] variants,\n-                            vec[str] path,\n+                            &vec[ast.variant] variants,\n+                            &vec[str] path,\n                             &mutable vec[tup(str, uint)] index) {\n     for (ast.variant variant in variants) {\n         add_to_index(ebml_w, path, index, variant.node.name);\n@@ -285,16 +285,16 @@ fn encode_tag_variant_paths(&EBML.writer ebml_w,\n }\n \n fn add_to_index(&EBML.writer ebml_w,\n-                vec[str] path,\n+                &vec[str] path,\n                 &mutable vec[tup(str, uint)] index,\n-                str name) {\n+                &str name) {\n     auto full_path = path + vec(name);\n     index += vec(tup(Str.connect(full_path, \".\"), ebml_w.writer.tell()));\n }\n \n fn encode_native_module_item_paths(&EBML.writer ebml_w,\n                                    &ast.native_mod nmod,\n-                                   vec[str] path,\n+                                   &vec[str] path,\n                                    &mutable vec[tup(str, uint)] index) {\n     for (@ast.native_item nitem in nmod.items) {\n         alt (nitem.node) {\n@@ -318,7 +318,7 @@ fn encode_native_module_item_paths(&EBML.writer ebml_w,\n \n fn encode_module_item_paths(&EBML.writer ebml_w,\n                             &ast._mod module,\n-                            vec[str] path,\n+                            &vec[str] path,\n                             &mutable vec[tup(str, uint)] index) {\n     // TODO: only encode exported items\n     for (@ast.item it in module.items) {\n@@ -382,7 +382,7 @@ fn encode_module_item_paths(&EBML.writer ebml_w,\n     }\n }\n \n-fn encode_item_paths(&EBML.writer ebml_w, @ast.crate crate)\n+fn encode_item_paths(&EBML.writer ebml_w, &@ast.crate crate)\n         -> vec[tup(str, uint)] {\n     let vec[tup(str, uint)] index = vec();\n     let vec[str] path = vec();\n@@ -401,23 +401,23 @@ fn encode_kind(&EBML.writer ebml_w, u8 c) {\n     EBML.end_tag(ebml_w);\n }\n \n-fn def_to_str(ast.def_id did) -> str {\n+fn def_to_str(&ast.def_id did) -> str {\n     ret #fmt(\"%d:%d\", did._0, did._1);\n }\n \n-fn encode_type_param_count(&EBML.writer ebml_w, vec[ast.ty_param] tps) {\n+fn encode_type_param_count(&EBML.writer ebml_w, &vec[ast.ty_param] tps) {\n     EBML.start_tag(ebml_w, tag_items_data_item_ty_param_count);\n     EBML.write_vint(ebml_w.writer, Vec.len[ast.ty_param](tps));\n     EBML.end_tag(ebml_w);\n }\n \n-fn encode_variant_id(&EBML.writer ebml_w, ast.def_id vid) {\n+fn encode_variant_id(&EBML.writer ebml_w, &ast.def_id vid) {\n     EBML.start_tag(ebml_w, tag_items_data_item_variant);\n     ebml_w.writer.write(Str.bytes(def_to_str(vid)));\n     EBML.end_tag(ebml_w);\n }\n \n-fn encode_type(@trans.crate_ctxt cx, &EBML.writer ebml_w, ty.t typ) {\n+fn encode_type(&@trans.crate_ctxt cx, &EBML.writer ebml_w, &ty.t typ) {\n     EBML.start_tag(ebml_w, tag_items_data_item_type);\n \n     auto f = def_to_str;\n@@ -427,14 +427,15 @@ fn encode_type(@trans.crate_ctxt cx, &EBML.writer ebml_w, ty.t typ) {\n     EBML.end_tag(ebml_w);\n }\n \n-fn encode_symbol(@trans.crate_ctxt cx, &EBML.writer ebml_w, ast.def_id did) {\n+fn encode_symbol(&@trans.crate_ctxt cx, &EBML.writer ebml_w,\n+                 &ast.def_id did) {\n     EBML.start_tag(ebml_w, tag_items_data_item_symbol);\n     ebml_w.writer.write(Str.bytes(cx.item_symbols.get(did)));\n     EBML.end_tag(ebml_w);\n }\n \n-fn encode_discriminant(@trans.crate_ctxt cx, &EBML.writer ebml_w,\n-                       ast.def_id did) {\n+fn encode_discriminant(&@trans.crate_ctxt cx, &EBML.writer ebml_w,\n+                       &ast.def_id did) {\n     EBML.start_tag(ebml_w, tag_items_data_item_symbol);\n     ebml_w.writer.write(Str.bytes(cx.discrim_symbols.get(did)));\n     EBML.end_tag(ebml_w);\n@@ -453,10 +454,10 @@ fn encode_obj_type_id(&EBML.writer ebml_w, &ast.def_id id) {\n }\n \n \n-fn encode_tag_variant_info(@trans.crate_ctxt cx, &EBML.writer ebml_w,\n-                           ast.def_id did, vec[ast.variant] variants,\n+fn encode_tag_variant_info(&@trans.crate_ctxt cx, &EBML.writer ebml_w,\n+                           &ast.def_id did, &vec[ast.variant] variants,\n                            &mutable vec[tup(int, uint)] index,\n-                           vec[ast.ty_param] ty_params) {\n+                           &vec[ast.ty_param] ty_params) {\n     for (ast.variant variant in variants) {\n         index += vec(tup(variant.node.id._1, ebml_w.writer.tell()));\n \n@@ -547,8 +548,8 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &EBML.writer ebml_w,\n     }\n }\n \n-fn encode_info_for_native_item(@trans.crate_ctxt cx, &EBML.writer ebml_w,\n-                               @ast.native_item nitem) {\n+fn encode_info_for_native_item(&@trans.crate_ctxt cx, &EBML.writer ebml_w,\n+                               &@ast.native_item nitem) {\n     EBML.start_tag(ebml_w, tag_items_data_item);\n     alt (nitem.node) {\n         case (ast.native_item_ty(_, ?did)) {\n@@ -567,7 +568,7 @@ fn encode_info_for_native_item(@trans.crate_ctxt cx, &EBML.writer ebml_w,\n     EBML.end_tag(ebml_w);\n }\n \n-fn encode_info_for_items(@trans.crate_ctxt cx, &EBML.writer ebml_w)\n+fn encode_info_for_items(&@trans.crate_ctxt cx, &EBML.writer ebml_w)\n         -> vec[tup(int, uint)] {\n     let vec[tup(int, uint)] index = vec();\n \n@@ -603,7 +604,7 @@ fn hash_path(&str s) -> uint {\n     ret h;\n }\n \n-fn create_index[T](vec[tup(T, uint)] index, fn(&T) -> uint hash_fn)\n+fn create_index[T](&vec[tup(T, uint)] index, fn(&T) -> uint hash_fn)\n         -> vec[vec[tup(T, uint)]] {\n     let vec[vec[tup(T, uint)]] buckets = vec();\n     for each (uint i in UInt.range(0u, 256u)) {\n@@ -619,8 +620,8 @@ fn create_index[T](vec[tup(T, uint)] index, fn(&T) -> uint hash_fn)\n     ret buckets;\n }\n \n-fn encode_index[T](&EBML.writer ebml_w, vec[vec[tup(T, uint)]] buckets,\n-                          fn(IO.writer, &T) write_fn) {\n+fn encode_index[T](&EBML.writer ebml_w, &vec[vec[tup(T, uint)]] buckets,\n+                   fn(&IO.writer, &T) write_fn) {\n     auto writer = IO.new_writer_(ebml_w.writer);\n \n     EBML.start_tag(ebml_w, tag_index);\n@@ -650,16 +651,16 @@ fn encode_index[T](&EBML.writer ebml_w, vec[vec[tup(T, uint)]] buckets,\n     EBML.end_tag(ebml_w);\n }\n \n-fn write_str(IO.writer writer, &str s) {\n+fn write_str(&IO.writer writer, &str s) {\n     writer.write_str(s);\n }\n \n-fn write_int(IO.writer writer, &int n) {\n+fn write_int(&IO.writer writer, &int n) {\n     writer.write_be_uint(n as uint, 4u);\n }\n \n \n-fn encode_metadata(@trans.crate_ctxt cx, @ast.crate crate)\n+fn encode_metadata(&@trans.crate_ctxt cx, &@ast.crate crate)\n         -> ValueRef {\n     auto string_w = IO.string_writer();\n     auto buf_w = string_w.get_writer().get_buf_writer();\n@@ -690,7 +691,7 @@ fn encode_metadata(@trans.crate_ctxt cx, @ast.crate crate)\n     ret C_postr(string_w.get_str());\n }\n \n-fn write_metadata(@trans.crate_ctxt cx, @ast.crate crate) {\n+fn write_metadata(&@trans.crate_ctxt cx, &@ast.crate crate) {\n     auto llmeta = C_postr(\"\");\n     if (cx.sess.get_opts().shared) {\n         llmeta = encode_metadata(cx, crate);"}, {"sha": "7840a129102775081acb1c24bdec0efbdf7549ff", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/476442e48ce0dad5dfbb09a7ef874e09339224fc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/476442e48ce0dad5dfbb09a7ef874e09339224fc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=476442e48ce0dad5dfbb09a7ef874e09339224fc", "patch": "@@ -3569,7 +3569,7 @@ fn collect_upvars(@block_ctxt cx, &ast.block bloc, &ast.def_id initial_decl)\n         hashmap[ast.def_id,()] decls\n     );\n \n-    fn walk_expr(env e, @ast.expr expr) {\n+    fn walk_expr(env e, &@ast.expr expr) {\n         alt (expr.node) {\n             case (ast.expr_path(?path, ?d, _)) {\n                 alt (Option.get[ast.def](d)) {\n@@ -3589,7 +3589,7 @@ fn collect_upvars(@block_ctxt cx, &ast.block bloc, &ast.def_id initial_decl)\n         }\n     }\n \n-    fn walk_decl(env e, @ast.decl decl) {\n+    fn walk_decl(env e, &@ast.decl decl) {\n         alt (decl.node) {\n             case (ast.decl_local(?local)) {\n                 e.decls.insert(local.id, ());\n@@ -6949,7 +6949,7 @@ fn new_walk_ctxt() -> @walk_ctxt {\n     ret @rec(mutable path=path);\n }\n \n-fn enter_item(@walk_ctxt cx, @ast.item item) {\n+fn enter_item(@walk_ctxt cx, &@ast.item item) {\n     alt (item.node) {\n         case (ast.item_fn(?name, _, _, _, _)) {\n             Vec.push[str](cx.path, name);\n@@ -6964,7 +6964,7 @@ fn enter_item(@walk_ctxt cx, @ast.item item) {\n     }\n }\n \n-fn leave_item(@walk_ctxt cx, @ast.item item) {\n+fn leave_item(@walk_ctxt cx, &@ast.item item) {\n     alt (item.node) {\n         case (ast.item_fn(_, _, _, _, _)) {\n             Vec.pop[str](cx.path);\n@@ -6979,7 +6979,7 @@ fn leave_item(@walk_ctxt cx, @ast.item item) {\n     }\n }\n \n-fn collect_native_item(@crate_ctxt ccx, @walk_ctxt wcx, @ast.native_item i) {\n+fn collect_native_item(@crate_ctxt ccx, @walk_ctxt wcx, &@ast.native_item i) {\n     alt (i.node) {\n         case (ast.native_item_fn(?name, _, _, _, ?fid, ?ann)) {\n             ccx.native_items.insert(fid, i);\n@@ -6993,7 +6993,7 @@ fn collect_native_item(@crate_ctxt ccx, @walk_ctxt wcx, @ast.native_item i) {\n     }\n }\n \n-fn collect_item_1(@crate_ctxt ccx, @walk_ctxt wcx, @ast.item i) {\n+fn collect_item_1(@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item i) {\n     enter_item(wcx, i);\n \n     alt (i.node) {\n@@ -7019,7 +7019,7 @@ fn collect_item_1(@crate_ctxt ccx, @walk_ctxt wcx, @ast.item i) {\n     }\n }\n \n-fn collect_item_2(@crate_ctxt ccx, @walk_ctxt wcx, @ast.item i) {\n+fn collect_item_2(@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item i) {\n     enter_item(wcx, i);\n \n     alt (i.node) {\n@@ -7055,7 +7055,7 @@ fn collect_items(@crate_ctxt ccx, @ast.crate crate) {\n     walk.walk_crate(visitor2, *crate);\n }\n \n-fn collect_tag_ctor(@crate_ctxt ccx, @walk_ctxt wcx, @ast.item i) {\n+fn collect_tag_ctor(@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item i) {\n     enter_item(wcx, i);\n \n     alt (i.node) {\n@@ -7083,7 +7083,7 @@ fn collect_tag_ctors(@crate_ctxt ccx, @ast.crate crate) {\n \n // The constant translation pass.\n \n-fn trans_constant(@crate_ctxt ccx, @walk_ctxt wcx, @ast.item it) {\n+fn trans_constant(@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item it) {\n     enter_item(wcx, it);\n \n     alt (it.node) {"}, {"sha": "dfdf07d9c2f3af2c83541f748d3b01b743673efb", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/476442e48ce0dad5dfbb09a7ef874e09339224fc/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/476442e48ce0dad5dfbb09a7ef874e09339224fc/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=476442e48ce0dad5dfbb09a7ef874e09339224fc", "patch": "@@ -1046,7 +1046,7 @@ fn type_param(&ctxt cx, &t ty) -> Option.t[uint] {\n     ret none[uint];\n }\n \n-fn def_to_str(ast.def_id did) -> str {\n+fn def_to_str(&ast.def_id did) -> str {\n     ret #fmt(\"%d:%d\", did._0, did._1);\n }\n "}, {"sha": "1d888949463b3befea0005f9ebf3c83245c6513a", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 72, "deletions": 70, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/476442e48ce0dad5dfbb09a7ef874e09339224fc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/476442e48ce0dad5dfbb09a7ef874e09339224fc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=476442e48ce0dad5dfbb09a7ef874e09339224fc", "patch": "@@ -77,14 +77,14 @@ type fn_ctxt = rec(ty.t ret_ty,\n                    @crate_ctxt ccx);\n \n // Used for ast_ty_to_ty() below.\n-type ty_getter = fn(ast.def_id) -> ty.ty_param_count_and_ty;\n+type ty_getter = fn(&ast.def_id) -> ty.ty_param_count_and_ty;\n \n // Substitutes the user's explicit types for the parameters in a path\n // expression.\n fn substitute_ty_params(&@crate_ctxt ccx,\n-                        ty.t typ,\n+                        &ty.t typ,\n                         uint ty_param_count,\n-                        vec[ty.t] supplied,\n+                        &vec[ty.t] supplied,\n                         &span sp) -> ty.t {\n     fn substituter(@crate_ctxt ccx, vec[ty.t] supplied, ty.t typ) -> ty.t {\n         alt (struct(ccx.tcx, typ)) {\n@@ -112,7 +112,7 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n \n \n // Returns the type parameter count and the type for the given definition.\n-fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.span sp, &ast.def defn)\n+fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &ast.span sp, &ast.def defn)\n         -> ty_param_count_and_ty {\n     alt (defn) {\n         case (ast.def_arg(?id)) {\n@@ -177,8 +177,8 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.span sp, &ast.def defn)\n \n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n-fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n-        &span sp) -> ast.ann {\n+fn instantiate_path(&@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n+                    &span sp) -> ast.ann {\n     auto ty_param_count = tpt._0;\n     auto t = bind_params_in_type(fcx.ccx.tcx, tpt._1);\n \n@@ -224,25 +224,25 @@ fn ast_mode_to_mode(ast.mode mode) -> ty.mode {\n // Parses the programmer's textual representation of a type into our internal\n // notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID.\n-fn ast_ty_to_ty(ty.ctxt tcx, ty_getter getter, &@ast.ty ast_ty) -> ty.t {\n-    fn ast_arg_to_arg(ty.ctxt tcx,\n-                      ty_getter getter,\n+fn ast_ty_to_ty(&ty.ctxt tcx, &ty_getter getter, &@ast.ty ast_ty) -> ty.t {\n+    fn ast_arg_to_arg(&ty.ctxt tcx,\n+                      &ty_getter getter,\n                       &rec(ast.mode mode, @ast.ty ty) arg)\n             -> rec(ty.mode mode, ty.t ty) {\n         auto ty_mode = ast_mode_to_mode(arg.mode);\n         ret rec(mode=ty_mode, ty=ast_ty_to_ty(tcx, getter, arg.ty));\n     }\n \n-    fn ast_mt_to_mt(ty.ctxt tcx,\n-                    ty_getter getter,\n+    fn ast_mt_to_mt(&ty.ctxt tcx,\n+                    &ty_getter getter,\n                     &ast.mt mt) -> ty.mt {\n         ret rec(ty=ast_ty_to_ty(tcx, getter, mt.ty), mut=mt.mut);\n     }\n \n-    fn instantiate(ty.ctxt tcx,\n-                   ty_getter getter,\n-                   ast.def_id id,\n-                   vec[@ast.ty] args) -> ty.t {\n+    fn instantiate(&ty.ctxt tcx,\n+                   &ty_getter getter,\n+                   &ast.def_id id,\n+                   &vec[@ast.ty] args) -> ty.t {\n         // TODO: maybe record cname chains so we can do\n         // \"foo = int\" like OCaml?\n         auto params_opt_and_ty = getter(id);\n@@ -324,7 +324,7 @@ fn ast_ty_to_ty(ty.ctxt tcx, ty_getter getter, &@ast.ty ast_ty) -> ty.t {\n                     typ = instantiate(tcx, getter, id, path.node.types);\n                 }\n                 case (ast.def_ty_arg(?id)) { typ = ty.mk_param(tcx, id); }\n-                case (_)                   { \n+                case (_)                   {\n                     tcx.sess.span_err(ast_ty.span,\n                        \"found type name used as a variable\");\n                     fail; }\n@@ -362,7 +362,7 @@ fn ast_ty_to_ty(ty.ctxt tcx, ty_getter getter, &@ast.ty ast_ty) -> ty.t {\n // A convenience function to use a crate_ctxt to resolve names for\n // ast_ty_to_ty.\n fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> ty.t {\n-    fn getter(@crate_ctxt ccx, ast.def_id id) -> ty.ty_param_count_and_ty {\n+    fn getter(@crate_ctxt ccx, &ast.def_id id) -> ty.ty_param_count_and_ty {\n         ret ty.lookup_item_type(ccx.sess, ccx.tcx, ccx.type_cache, id);\n     }\n     auto f = bind getter(ccx, _);\n@@ -388,13 +388,13 @@ mod Collect {\n                     ty.ctxt tcx);\n     type env = rec(@ctxt cx, ast.native_abi abi);\n \n-    fn ty_of_fn_decl(@ctxt cx,\n-                     fn(&@ast.ty ast_ty) -> ty.t convert,\n-                     fn(&ast.arg a) -> arg ty_of_arg,\n+    fn ty_of_fn_decl(&@ctxt cx,\n+                     &fn(&@ast.ty ast_ty) -> ty.t convert,\n+                     &fn(&ast.arg a) -> arg ty_of_arg,\n                      &ast.fn_decl decl,\n                      ast.proto proto,\n-                     vec[ast.ty_param] ty_params,\n-                     ast.def_id def_id) -> ty.ty_param_count_and_ty {\n+                     &vec[ast.ty_param] ty_params,\n+                     &ast.def_id def_id) -> ty.ty_param_count_and_ty {\n         auto input_tys = Vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n         auto output_ty = convert(decl.output);\n         auto t_fn = ty.mk_fn(cx.tcx, proto, input_tys, output_ty);\n@@ -404,13 +404,13 @@ mod Collect {\n         ret tpt;\n     }\n \n-    fn ty_of_native_fn_decl(@ctxt cx,\n-                            fn(&@ast.ty ast_ty) -> ty.t convert,\n-                            fn(&ast.arg a) -> arg ty_of_arg,\n+    fn ty_of_native_fn_decl(&@ctxt cx,\n+                            &fn(&@ast.ty ast_ty) -> ty.t convert,\n+                            &fn(&ast.arg a) -> arg ty_of_arg,\n                             &ast.fn_decl decl,\n                             ast.native_abi abi,\n-                            vec[ast.ty_param] ty_params,\n-                            ast.def_id def_id) -> ty.ty_param_count_and_ty {\n+                            &vec[ast.ty_param] ty_params,\n+                            &ast.def_id def_id) -> ty.ty_param_count_and_ty {\n         auto input_tys = Vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n         auto output_ty = convert(decl.output);\n         auto t_fn = ty.mk_native_fn(cx.tcx, abi, input_tys, output_ty);\n@@ -420,7 +420,7 @@ mod Collect {\n         ret tpt;\n     }\n \n-    fn getter(@ctxt cx, ast.def_id id) -> ty.ty_param_count_and_ty {\n+    fn getter(@ctxt cx, &ast.def_id id) -> ty.ty_param_count_and_ty {\n \n         if (id._0 != cx.sess.get_targ_crate_num()) {\n             // This is a type we need to load in from the crate reader.\n@@ -458,9 +458,9 @@ mod Collect {\n     }\n \n     fn ty_of_obj(@ctxt cx,\n-                 ast.ident id,\n+                 &ast.ident id,\n                  &ast._obj obj_info,\n-                 vec[ast.ty_param] ty_params) -> ty.ty_param_count_and_ty {\n+                 &vec[ast.ty_param] ty_params) -> ty.ty_param_count_and_ty {\n         auto f = bind ty_of_method(cx, _);\n         auto methods = Vec.map[@ast.method,method](f, obj_info.methods);\n \n@@ -473,8 +473,8 @@ mod Collect {\n     fn ty_of_obj_ctor(@ctxt cx,\n                       &ast.ident id,\n                       &ast._obj obj_info,\n-                      ast.def_id obj_ty_id,\n-                      vec[ast.ty_param] ty_params)\n+                      &ast.def_id obj_ty_id,\n+                      &vec[ast.ty_param] ty_params)\n             -> ty.ty_param_count_and_ty {\n         auto t_obj = ty_of_obj(cx, id, obj_info, ty_params);\n         let vec[arg] t_inputs = vec();\n@@ -490,7 +490,7 @@ mod Collect {\n         ret tup(t_obj._0, t_fn);\n     }\n \n-    fn ty_of_item(@ctxt cx, @ast.item it) -> ty.ty_param_count_and_ty {\n+    fn ty_of_item(&@ctxt cx, &@ast.item it) -> ty.ty_param_count_and_ty {\n \n         auto get = bind getter(cx, _);\n         auto convert = bind ast_ty_to_ty(cx.tcx, get, _);\n@@ -557,7 +557,7 @@ mod Collect {\n         }\n     }\n \n-    fn ty_of_native_item(@ctxt cx, @ast.native_item it, ast.native_abi abi)\n+    fn ty_of_native_item(&@ctxt cx, &@ast.native_item it, ast.native_abi abi)\n             -> ty.ty_param_count_and_ty {\n         alt (it.node) {\n             case (ast.native_item_fn(?ident, ?lname, ?fn_decl,\n@@ -584,7 +584,7 @@ mod Collect {\n         }\n     }\n \n-    fn get_tag_variant_types(@ctxt cx, &ast.def_id tag_id,\n+    fn get_tag_variant_types(&@ctxt cx, &ast.def_id tag_id,\n                              &vec[ast.variant] variants,\n                              &vec[ast.ty_param] ty_params)\n             -> vec[ast.variant] {\n@@ -856,16 +856,17 @@ mod Collect {\n // Type unification\n \n mod Unify {\n-    fn simple(@fn_ctxt fcx, ty.t expected, ty.t actual) -> ty.Unify.result {\n+    fn simple(&@fn_ctxt fcx, &ty.t expected,\n+              &ty.t actual) -> ty.Unify.result {\n         // FIXME: horrid botch\n         let vec[mutable ty.t] param_substs =\n             vec(mutable ty.mk_nil(fcx.ccx.tcx));\n         Vec.pop(param_substs);\n         ret with_params(fcx, expected, actual, param_substs);\n     }\n \n-    fn with_params(@fn_ctxt fcx, ty.t expected, ty.t actual,\n-                   vec[mutable ty.t] param_substs) -> ty.Unify.result {\n+    fn with_params(&@fn_ctxt fcx, &ty.t expected, &ty.t actual,\n+                   &vec[mutable ty.t] param_substs) -> ty.Unify.result {\n         auto cache_key = tup(expected, actual, param_substs);\n         alt (fcx.ccx.unify_cache.find(cache_key)) {\n             case (some[ty.Unify.result](?r)) {\n@@ -947,7 +948,7 @@ tag autoderef_kind {\n     NO_AUTODEREF;\n }\n \n-fn strip_boxes(ty.ctxt tcx, ty.t t) -> ty.t {\n+fn strip_boxes(&ty.ctxt tcx, &ty.t t) -> ty.t {\n     auto t1 = t;\n     while (true) {\n         alt (struct(tcx, t1)) {\n@@ -958,7 +959,7 @@ fn strip_boxes(ty.ctxt tcx, ty.t t) -> ty.t {\n     fail;\n }\n \n-fn add_boxes(@crate_ctxt ccx, uint n, ty.t t) -> ty.t {\n+fn add_boxes(&@crate_ctxt ccx, uint n, &ty.t t) -> ty.t {\n     auto t1 = t;\n     while (n != 0u) {\n         t1 = ty.mk_imm_box(ccx.tcx, t1);\n@@ -968,7 +969,7 @@ fn add_boxes(@crate_ctxt ccx, uint n, ty.t t) -> ty.t {\n }\n \n \n-fn count_boxes(ty.ctxt tcx, ty.t t) -> uint {\n+fn count_boxes(&ty.ctxt tcx, &ty.t t) -> uint {\n     auto n = 0u;\n     auto t1 = t;\n     while (true) {\n@@ -987,12 +988,12 @@ fn count_boxes(ty.ctxt tcx, ty.t t) -> uint {\n type ty_param_substs_and_ty = tup(vec[ty.t], ty.t);\n \n mod Demand {\n-    fn simple(@fn_ctxt fcx, &span sp, ty.t expected, ty.t actual) -> ty.t {\n+    fn simple(&@fn_ctxt fcx, &span sp, &ty.t expected, &ty.t actual) -> ty.t {\n         let vec[ty.t] tps = vec();\n         ret full(fcx, sp, expected, actual, tps, NO_AUTODEREF)._1;\n     }\n \n-    fn autoderef(@fn_ctxt fcx, &span sp, ty.t expected, ty.t actual,\n+    fn autoderef(&@fn_ctxt fcx, &span sp, &ty.t expected, &ty.t actual,\n                  autoderef_kind adk) -> ty.t {\n         let vec[ty.t] tps = vec();\n         ret full(fcx, sp, expected, actual, tps, adk)._1;\n@@ -1001,8 +1002,8 @@ mod Demand {\n     // Requires that the two types unify, and prints an error message if they\n     // don't. Returns the unified type and the type parameter substitutions.\n \n-    fn full(@fn_ctxt fcx, &span sp, ty.t expected, ty.t actual,\n-            vec[ty.t] ty_param_substs_0, autoderef_kind adk)\n+    fn full(&@fn_ctxt fcx, &span sp, &ty.t expected, &ty.t actual,\n+            &vec[ty.t] ty_param_substs_0, autoderef_kind adk)\n             -> ty_param_substs_and_ty {\n \n         auto expected_1 = expected;\n@@ -1050,16 +1051,16 @@ mod Demand {\n \n \n // Returns true if the two types unify and false if they don't.\n-fn are_compatible(&@fn_ctxt fcx, ty.t expected, ty.t actual) -> bool {\n+fn are_compatible(&@fn_ctxt fcx, &ty.t expected, &ty.t actual) -> bool {\n     alt (Unify.simple(fcx, expected, actual)) {\n         case (ures_ok(_))        { ret true;  }\n         case (ures_err(_, _, _)) { ret false; }\n     }\n }\n \n // Returns the types of the arguments to a tag variant.\n-fn variant_arg_types(@crate_ctxt ccx, &span sp, ast.def_id vid,\n-                     vec[ty.t] tag_ty_params) -> vec[ty.t] {\n+fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast.def_id vid,\n+                     &vec[ty.t] tag_ty_params) -> vec[ty.t] {\n     auto ty_param_count = Vec.len[ty.t](tag_ty_params);\n \n     let vec[ty.t] result = vec();\n@@ -1106,7 +1107,8 @@ mod Pushdown {\n     //\n     // TODO: enforce this via a predicate.\n \n-    fn pushdown_pat(&@fn_ctxt fcx, ty.t expected, @ast.pat pat) -> @ast.pat {\n+    fn pushdown_pat(&@fn_ctxt fcx, &ty.t expected,\n+                    &@ast.pat pat) -> @ast.pat {\n         auto p_1;\n \n         alt (pat.node) {\n@@ -1168,12 +1170,12 @@ mod Pushdown {\n     // TODO: enforce this via a predicate.\n     // TODO: This function is incomplete.\n \n-    fn pushdown_expr(&@fn_ctxt fcx, ty.t expected, @ast.expr e)\n+    fn pushdown_expr(&@fn_ctxt fcx, &ty.t expected, &@ast.expr e)\n             -> @ast.expr {\n         be pushdown_expr_full(fcx, expected, e, NO_AUTODEREF);\n     }\n \n-    fn pushdown_expr_full(&@fn_ctxt fcx, ty.t expected, @ast.expr e,\n+    fn pushdown_expr_full(&@fn_ctxt fcx, &ty.t expected, &@ast.expr e,\n                           autoderef_kind adk) -> @ast.expr {\n         auto e_1;\n \n@@ -1496,7 +1498,7 @@ mod Pushdown {\n     }\n \n     // Push-down over typed blocks.\n-    fn pushdown_block(&@fn_ctxt fcx, ty.t expected, &ast.block bloc)\n+    fn pushdown_block(&@fn_ctxt fcx, &ty.t expected, &ast.block bloc)\n             -> ast.block {\n         alt (bloc.node.expr) {\n             case (some[@ast.expr](?e_0)) {\n@@ -1598,7 +1600,7 @@ fn resolve_local_types_in_block(&@fn_ctxt fcx, &ast.block block)\n \n // AST fragment checking\n \n-fn check_lit(@crate_ctxt ccx, @ast.lit lit) -> ty.t {\n+fn check_lit(@crate_ctxt ccx, &@ast.lit lit) -> ty.t {\n     alt (lit.node) {\n         case (ast.lit_str(_))           { ret ty.mk_str(ccx.tcx); }\n         case (ast.lit_char(_))          { ret ty.mk_char(ccx.tcx); }\n@@ -1615,7 +1617,7 @@ fn check_lit(@crate_ctxt ccx, @ast.lit lit) -> ty.t {\n     fail; // not reached\n }\n \n-fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n+fn check_pat(&@fn_ctxt fcx, &@ast.pat pat) -> @ast.pat {\n     auto new_pat;\n     alt (pat.node) {\n         case (ast.pat_wild(_)) {\n@@ -1689,7 +1691,7 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n }\n \n fn require_impure(&session.session sess,\n-      &ast.purity f_purity, &span sp) -> () {\n+                  &ast.purity f_purity, &span sp) -> () {\n     alt (f_purity) {\n         case (ast.impure_fn) {\n             ret;\n@@ -1707,7 +1709,8 @@ fn get_function_purity(@crate_ctxt ccx, &ast.def_id d_id) -> ast.purity {\n }\n \n fn require_pure_call(@crate_ctxt ccx,\n-    &ast.purity caller_purity, @ast.expr callee, &span sp) -> () {\n+                     &ast.purity caller_purity,\n+                     &@ast.expr callee, &span sp) -> () {\n     alt (caller_purity) {\n         case (ast.impure_fn) {\n             ret;\n@@ -1744,7 +1747,7 @@ fn require_pure_function(@crate_ctxt ccx, &ast.def_id d_id, &span sp) -> () {\n     }\n }\n \n-fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n+fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n     //fcx.ccx.sess.span_warn(expr.span, \"typechecking expr \" +\n     //                       util.common.expr_to_str(expr));\n \n@@ -1804,7 +1807,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n     }\n \n     // A generic function for checking assignment expressions\n-    fn check_assignment(&@fn_ctxt fcx, @ast.expr lhs, @ast.expr rhs)\n+    fn check_assignment(&@fn_ctxt fcx, &@ast.expr lhs, &@ast.expr rhs)\n         -> tup(@ast.expr, @ast.expr, ast.ann) {\n         auto lhs_0 = check_expr(fcx, lhs);\n         auto rhs_0 = check_expr(fcx, rhs);\n@@ -1820,7 +1823,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n     }\n \n     // A generic function for checking call expressions\n-    fn check_call(&@fn_ctxt fcx, @ast.expr f, vec[@ast.expr] args)\n+    fn check_call(&@fn_ctxt fcx, &@ast.expr f, &vec[@ast.expr] args)\n         -> tup(@ast.expr, vec[@ast.expr]) {\n \n         let vec[Option.t[@ast.expr]] args_opt_0 = vec();\n@@ -2686,7 +2689,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n     }\n }\n \n-fn next_ty_var(@crate_ctxt ccx) -> ty.t {\n+fn next_ty_var(&@crate_ctxt ccx) -> ty.t {\n     auto t = ty.mk_var(ccx.tcx, ccx.next_var_id);\n     ccx.next_var_id += 1;\n     ret t;\n@@ -2699,7 +2702,7 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n             auto t;\n \n             t = ty.mk_nil(fcx.ccx.tcx);\n-            \n+\n             alt (local.ty) {\n                 case (none[@ast.ty]) {\n                     // Auto slot. Do nothing for now.\n@@ -2712,7 +2715,7 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n                 }\n             }\n \n-            auto a_res = local.ann; \n+            auto a_res = local.ann;\n             alt (a_res) {\n                 case (ann_none) {\n                     a_res = triv_ann(t);\n@@ -2807,8 +2810,8 @@ fn check_block(&@fn_ctxt fcx, &ast.block block) -> ast.block {\n                                     a=plain_ann(fcx.ccx.tcx)));\n }\n \n-fn check_const(&@crate_ctxt ccx, &span sp, ast.ident ident, @ast.ty t,\n-               @ast.expr e, ast.def_id id, ast.ann ann) -> @ast.item {\n+fn check_const(&@crate_ctxt ccx, &span sp, &ast.ident ident, &@ast.ty t,\n+               &@ast.expr e, &ast.def_id id, &ast.ann ann) -> @ast.item {\n     // FIXME: this is kinda a kludge; we manufacture a fake \"function context\"\n     // for checking the initializer expression.\n     auto rty = ann_to_type(ann);\n@@ -2858,7 +2861,7 @@ fn check_fn(&@crate_ctxt ccx, &ast.fn_decl decl, ast.proto proto,\n               ccx.sess.span_err(body.span, \"Non-boolean return type in pred\");\n             }\n         }\n-        case (_) {} \n+        case (_) {}\n     }\n \n     auto block_wb = resolve_local_types_in_block(fcx, block_t);\n@@ -2894,7 +2897,7 @@ fn update_obj_fields(&@crate_ctxt ccx, @ast.item i) -> @crate_ctxt {\n     alt (i.node) {\n         case (ast.item_obj(_, ?ob, _, ?obj_def_ids, _)) {\n             let ast.def_id di = obj_def_ids.ty;\n-            ret @rec(obj_fields = ob.fields, \n+            ret @rec(obj_fields = ob.fields,\n                      this_obj = some[ast.def_id](di) with *ccx);\n         }\n         case (_) {\n@@ -2935,10 +2938,10 @@ fn eq_unify_cache_entry(&unify_cache_entry a, &unify_cache_entry b) -> bool {\n     ret true;\n }\n \n-fn mk_fn_purity_table(@ast.crate crate) -> @fn_purity_table {\n+fn mk_fn_purity_table(&@ast.crate crate) -> @fn_purity_table {\n     auto res = @new_def_hash[ast.purity]();\n \n-    fn do_one(@fn_purity_table t, @ast.item i) -> () {\n+    fn do_one(@fn_purity_table t, &@ast.item i) -> () {\n         alt (i.node) {\n             case (ast.item_fn(_, ?f, _, ?d_id, _)) {\n                 t.insert(d_id, f.decl.purity);\n@@ -2958,8 +2961,7 @@ fn mk_fn_purity_table(@ast.crate crate) -> @fn_purity_table {\n \n type typecheck_result = tup(@ast.crate, ty.type_cache);\n \n-fn check_crate(ty.ctxt tcx, @ast.crate crate)\n-        -> typecheck_result {\n+fn check_crate(&ty.ctxt tcx, &@ast.crate crate) -> typecheck_result {\n     auto sess = tcx.sess;\n     auto result = Collect.collect_item_types(sess, tcx, crate);\n "}, {"sha": "c8f5f43236e1f5d83f060d35b054b7e3a564831d", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/476442e48ce0dad5dfbb09a7ef874e09339224fc/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/476442e48ce0dad5dfbb09a7ef874e09339224fc/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=476442e48ce0dad5dfbb09a7ef874e09339224fc", "patch": "@@ -5,28 +5,28 @@ import std.Option.some;\n import std.Option.none;\n \n type ast_visitor =\n-    rec(fn () -> bool                 keep_going,\n-        fn () -> bool                 want_crate_directives,\n-        fn (&ast.crate c)             visit_crate_pre,\n-        fn (&ast.crate c)             visit_crate_post,\n-        fn (@ast.crate_directive cd)  visit_crate_directive_pre,\n-        fn (@ast.crate_directive cd)  visit_crate_directive_post,\n-        fn (@ast.view_item i)         visit_view_item_pre,\n-        fn (@ast.view_item i)         visit_view_item_post,\n-        fn (@ast.native_item i)       visit_native_item_pre,\n-        fn (@ast.native_item i)       visit_native_item_post,\n-        fn (@ast.item i)              visit_item_pre,\n-        fn (@ast.item i)              visit_item_post,\n-        fn (&ast.block b)             visit_block_pre,\n-        fn (&ast.block b)             visit_block_post,\n-        fn (@ast.stmt s)              visit_stmt_pre,\n-        fn (@ast.stmt s)              visit_stmt_post,\n-        fn (@ast.decl d)              visit_decl_pre,\n-        fn (@ast.decl d)              visit_decl_post,\n-        fn (@ast.expr e)              visit_expr_pre,\n-        fn (@ast.expr e)              visit_expr_post,\n-        fn (@ast.ty t)                visit_ty_pre,\n-        fn (@ast.ty t)                visit_ty_post);\n+    rec(fn () -> bool                  keep_going,\n+        fn () -> bool                  want_crate_directives,\n+        fn (&ast.crate c)              visit_crate_pre,\n+        fn (&ast.crate c)              visit_crate_post,\n+        fn (&@ast.crate_directive cd)  visit_crate_directive_pre,\n+        fn (&@ast.crate_directive cd)  visit_crate_directive_post,\n+        fn (&@ast.view_item i)         visit_view_item_pre,\n+        fn (&@ast.view_item i)         visit_view_item_post,\n+        fn (&@ast.native_item i)       visit_native_item_pre,\n+        fn (&@ast.native_item i)       visit_native_item_post,\n+        fn (&@ast.item i)              visit_item_pre,\n+        fn (&@ast.item i)              visit_item_post,\n+        fn (&ast.block b)              visit_block_pre,\n+        fn (&ast.block b)              visit_block_post,\n+        fn (&@ast.stmt s)              visit_stmt_pre,\n+        fn (&@ast.stmt s)              visit_stmt_post,\n+        fn (&@ast.decl d)              visit_decl_pre,\n+        fn (&@ast.decl d)              visit_decl_post,\n+        fn (&@ast.expr e)              visit_expr_pre,\n+        fn (&@ast.expr e)              visit_expr_post,\n+        fn (&@ast.ty t)                visit_ty_pre,\n+        fn (&@ast.ty t)                visit_ty_post);\n \n fn walk_crate(&ast_visitor v, &ast.crate c) {\n     if (!v.keep_going()) { ret; }\n@@ -409,15 +409,15 @@ fn walk_expr(&ast_visitor v, @ast.expr e) {\n fn def_keep_going() -> bool { ret true; }\n fn def_want_crate_directives() -> bool { ret false; }\n fn def_visit_crate(&ast.crate c) { }\n-fn def_visit_crate_directive(@ast.crate_directive c) { }\n-fn def_visit_view_item(@ast.view_item vi) { }\n-fn def_visit_native_item(@ast.native_item ni) { }\n-fn def_visit_item(@ast.item i) { }\n+fn def_visit_crate_directive(&@ast.crate_directive c) { }\n+fn def_visit_view_item(&@ast.view_item vi) { }\n+fn def_visit_native_item(&@ast.native_item ni) { }\n+fn def_visit_item(&@ast.item i) { }\n fn def_visit_block(&ast.block b) { }\n-fn def_visit_stmt(@ast.stmt s) { }\n-fn def_visit_decl(@ast.decl d) { }\n-fn def_visit_expr(@ast.expr e) { }\n-fn def_visit_ty(@ast.ty t) { }\n+fn def_visit_stmt(&@ast.stmt s) { }\n+fn def_visit_decl(&@ast.decl d) { }\n+fn def_visit_expr(&@ast.expr e) { }\n+fn def_visit_ty(&@ast.ty t) { }\n \n fn default_visitor() -> ast_visitor {\n "}]}