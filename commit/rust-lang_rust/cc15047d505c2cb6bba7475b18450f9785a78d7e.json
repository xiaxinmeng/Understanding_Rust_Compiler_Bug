{"sha": "cc15047d505c2cb6bba7475b18450f9785a78d7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMTUwNDdkNTA1YzJjYjZiYmE3NDc1YjE4NDUwZjk3ODVhNzhkN2U=", "commit": {"author": {"name": "ltdk", "email": "usr@ltdk.xyz", "date": "2021-05-07T02:14:57Z"}, "committer": {"name": "ltdk", "email": "usr@ltdk.xyz", "date": "2021-08-26T23:52:06Z"}, "message": "Add carrying_add, borrowing_sub, widening_mul, carrying_mul methods to integers", "tree": {"sha": "badde9b0562321ad309dc7fccffe55820a3d3d57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/badde9b0562321ad309dc7fccffe55820a3d3d57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc15047d505c2cb6bba7475b18450f9785a78d7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc15047d505c2cb6bba7475b18450f9785a78d7e", "html_url": "https://github.com/rust-lang/rust/commit/cc15047d505c2cb6bba7475b18450f9785a78d7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc15047d505c2cb6bba7475b18450f9785a78d7e/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad02dc46badee510bd3a2c093edf80fcaade91b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad02dc46badee510bd3a2c093edf80fcaade91b1", "html_url": "https://github.com/rust-lang/rust/commit/ad02dc46badee510bd3a2c093edf80fcaade91b1"}], "stats": {"total": 202, "additions": 202, "deletions": 0}, "files": [{"sha": "d667fff4b81ee8bf4c2c091906515c35e66bd360", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc15047d505c2cb6bba7475b18450f9785a78d7e/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc15047d505c2cb6bba7475b18450f9785a78d7e/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=cc15047d505c2cb6bba7475b18450f9785a78d7e", "patch": "@@ -76,6 +76,7 @@\n #![feature(const_alloc_layout)]\n #![feature(const_arguments_as_str)]\n #![feature(const_assert_type)]\n+#![feature(const_bigint_helper_methods)]\n #![feature(const_caller_location)]\n #![feature(const_cell_into_inner)]\n #![feature(const_discriminant)]"}, {"sha": "1a28f3dcb751b35891518635fdf9ef2b2842ffcb", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cc15047d505c2cb6bba7475b18450f9785a78d7e/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc15047d505c2cb6bba7475b18450f9785a78d7e/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=cc15047d505c2cb6bba7475b18450f9785a78d7e", "patch": "@@ -1307,6 +1307,33 @@ macro_rules! int_impl {\n             (a as Self, b)\n         }\n \n+        /// Calculates `self + rhs + carry` without the ability to overflow.\n+        ///\n+        /// Performs \"ternary addition\" which takes in an extra bit to add, and may return an\n+        /// additional bit of overflow. This allows for chaining together multiple additions\n+        /// to create \"big integers\" which represent larger values.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, false), (7, false));\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, true), (8, false));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, false), (\", stringify!($SelfT), \"::MIN, false));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, true), (\", stringify!($SelfT), \"::MIN + 1, false));\")]\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n+            let (sum, carry) = (self as $UnsignedT).carrying_add(rhs as $UnsignedT, carry);\n+            (sum as $SelfT, carry)\n+        }\n+\n         /// Calculates `self` - `rhs`\n         ///\n         /// Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow\n@@ -1331,6 +1358,33 @@ macro_rules! int_impl {\n             (a as Self, b)\n         }\n \n+        /// Calculates `self - rhs - borrow` without the ability to overflow.\n+        ///\n+        /// Performs \"ternary subtraction\" which takes in an extra bit to subtract, and may return\n+        /// an additional bit of overflow. This allows for chaining together multiple subtractions\n+        /// to create \"big integers\" which represent larger values.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, false), (3, false));\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, true), (2, false));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.borrowing_sub(1, false), (\", stringify!($SelfT), \"::MAX, false));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.borrowing_sub(1, true), (\", stringify!($SelfT), \"::MAX - 1, false));\")]\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n+            let (sum, borrow) = (self as $UnsignedT).borrowing_sub(rhs as $UnsignedT, borrow);\n+            (sum as $SelfT, borrow)\n+        }\n+\n         /// Calculates the multiplication of `self` and `rhs`.\n         ///\n         /// Returns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow"}, {"sha": "31ab3aab2bdc81cb2adc863b2cc167841a9b0bcc", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/cc15047d505c2cb6bba7475b18450f9785a78d7e/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc15047d505c2cb6bba7475b18450f9785a78d7e/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=cc15047d505c2cb6bba7475b18450f9785a78d7e", "patch": "@@ -89,27 +89,104 @@ depending on the target pointer size.\n     };\n }\n \n+macro_rules! widening_impl {\n+    ($SelfT:ty, $WideT:ty, $BITS:literal) => {\n+        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n+        ///\n+        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n+        /// of the result as two separate values, in that order.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// Please note that this example is shared between integer types.\n+        /// Which explains why `u32` is used here.\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n+        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n+            // note: longer-term this should be done via an intrinsic,\n+            //   but for now we can deal without an impl for u128/i128\n+            // SAFETY: overflow will be contained within the wider types\n+            let wide = unsafe { (self as $WideT).unchecked_mul(rhs as $WideT) };\n+            (wide as $SelfT, (wide >> $BITS) as $SelfT)\n+        }\n+\n+        /// Calculates the \"full multiplication\" `self * rhs + carry`\n+        /// without the possibility to overflow.\n+        ///\n+        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n+        /// of the result as two separate values, in that order.\n+        ///\n+        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n+        /// additional amount of overflow. This allows for chaining together multiple\n+        /// multiplications to create \"big integers\" which represent larger values.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// Please note that this example is shared between integer types.\n+        /// Which explains why `u32` is used here.\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n+        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n+        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n+        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n+            // note: longer-term this should be done via an intrinsic,\n+            //   but for now we can deal without an impl for u128/i128\n+            // SAFETY: overflow will be contained within the wider types\n+            let wide = unsafe {\n+                (self as $WideT).unchecked_mul(rhs as $WideT).unchecked_add(carry as $WideT)\n+            };\n+            (wide as $SelfT, (wide >> $BITS) as $SelfT)\n+        }\n+    };\n+}\n+\n #[lang = \"i8\"]\n impl i8 {\n+    widening_impl! { i8, i16, 8 }\n     int_impl! { i8, i8, u8, 8, 7, -128, 127, 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\",\n     \"[0x12]\", \"[0x12]\", \"\", \"\" }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n+    widening_impl! { i16, i32, 16 }\n     int_impl! { i16, i16, u16, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\", \"0x3412\",\n     \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n+    widening_impl! { i32, i64, 32 }\n     int_impl! { i32, i32, u32, 32, 31, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n     \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n+    widening_impl! { i64, i128, 64 }\n     int_impl! { i64, i64, u64, 64, 63, -9223372036854775808, 9223372036854775807, 12,\n     \"0xaa00000000006e1\", \"0x6e10aa\", \"0x1234567890123456\", \"0x5634129078563412\",\n     \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n@@ -131,6 +208,7 @@ impl i128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n+    widening_impl! { isize, i32, 16 }\n     int_impl! { isize, i16, usize, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\",\n     \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n@@ -139,6 +217,7 @@ impl isize {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n+    widening_impl! { isize, i64, 32 }\n     int_impl! { isize, i32, usize, 32, 31, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n     \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78]\",\n@@ -148,6 +227,7 @@ impl isize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n+    widening_impl! { isize, i128, 64 }\n     int_impl! { isize, i64, usize, 64, 63, -9223372036854775808, 9223372036854775807,\n     12, \"0xaa00000000006e1\", \"0x6e10aa\",  \"0x1234567890123456\", \"0x5634129078563412\",\n      \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n@@ -160,6 +240,7 @@ const ASCII_CASE_MASK: u8 = 0b0010_0000;\n \n #[lang = \"u8\"]\n impl u8 {\n+    widening_impl! { u8, u16, 8 }\n     uint_impl! { u8, u8, 8, 255, 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n     \"[0x12]\", \"\", \"\" }\n \n@@ -693,18 +774,21 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n+    widening_impl! { u16, u32, 16 }\n     uint_impl! { u16, u16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n }\n \n #[lang = \"u32\"]\n impl u32 {\n+    widening_impl! { u32, u64, 32 }\n     uint_impl! { u32, u32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n }\n \n #[lang = \"u64\"]\n impl u64 {\n+    widening_impl! { u64, u128, 64 }\n     uint_impl! { u64, u64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n     \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n@@ -727,13 +811,15 @@ impl u128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n+    widening_impl! { usize, u32, 16 }\n     uint_impl! { usize, u16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n+    widening_impl! { usize, u64, 32 }\n     uint_impl! { usize, u32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n@@ -742,6 +828,7 @@ impl usize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n+    widening_impl! { usize, u128, 64 }\n     uint_impl! { usize, u64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n     \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\","}, {"sha": "1324f63a8c023be4a51beea91dc0618cbaa36479", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cc15047d505c2cb6bba7475b18450f9785a78d7e/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc15047d505c2cb6bba7475b18450f9785a78d7e/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=cc15047d505c2cb6bba7475b18450f9785a78d7e", "patch": "@@ -1378,6 +1378,36 @@ macro_rules! uint_impl {\n             (a as Self, b)\n         }\n \n+        /// Calculates `self + rhs + carry` without the ability to overflow.\n+        ///\n+        /// Performs \"ternary addition\" which takes in an extra bit to add, and may return an\n+        /// additional bit of overflow. This allows for chaining together multiple additions\n+        /// to create \"big integers\" which represent larger values.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, false), (7, false));\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, true), (8, false));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, false), (0, true));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, true), (1, true));\")]\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n+            // note: longer-term this should be done via an intrinsic, but this has been shown\n+            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n+            let (a, b) = self.overflowing_add(rhs);\n+            let (c, d) = a.overflowing_add(carry as $SelfT);\n+            (c, b | d)\n+        }\n+\n         /// Calculates `self` - `rhs`\n         ///\n         /// Returns a tuple of the subtraction along with a boolean indicating\n@@ -1403,6 +1433,36 @@ macro_rules! uint_impl {\n             (a as Self, b)\n         }\n \n+        /// Calculates `self - rhs - borrow` without the ability to overflow.\n+        ///\n+        /// Performs \"ternary subtraction\" which takes in an extra bit to subtract, and may return\n+        /// an additional bit of overflow. This allows for chaining together multiple subtractions\n+        /// to create \"big integers\" which represent larger values.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, false), (3, false));\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, true), (2, false));\")]\n+        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".borrowing_sub(1, false), (\", stringify!($SelfT), \"::MAX, true));\")]\n+        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".borrowing_sub(1, true), (\", stringify!($SelfT), \"::MAX - 1, true));\")]\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n+            // note: longer-term this should be done via an intrinsic, but this has been shown\n+            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n+            let (a, b) = self.overflowing_sub(rhs);\n+            let (c, d) = a.overflowing_sub(borrow as $SelfT);\n+            (c, b | d)\n+        }\n+\n         /// Calculates the multiplication of `self` and `rhs`.\n         ///\n         /// Returns a tuple of the multiplication along with a boolean"}]}