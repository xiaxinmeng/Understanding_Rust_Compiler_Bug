{"sha": "0148b971c921a0831fbf3357e5936eec724e3566", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNDhiOTcxYzkyMWEwODMxZmJmMzM1N2U1OTM2ZWVjNzI0ZTM1NjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-18T19:45:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-18T19:45:42Z"}, "message": "Auto merge of #82263 - Dylan-DPC:rollup-cypm2uw, r=Dylan-DPC\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #81546 ([libtest] Run the test synchronously when hitting thread limit)\n - #82066 (Ensure valid TraitRefs are created for GATs)\n - #82112 (const_generics: Dont evaluate array length const when handling yet another error )\n - #82194 (In some limited cases, suggest `where` bounds for non-type params)\n - #82215 (Replace if-let and while-let with `if let` and `while let`)\n - #82218 (Make sure pdbs are copied along with exe and dlls when bootstrapping)\n - #82236 (avoid converting types into themselves (clippy::useless_conversion))\n - #82246 (Add long explanation for E0549)\n - #82248 (Optimize counting digits in line numbers during error reporting)\n - #82256 (Print -Ztime-passes (and misc stats/logs) on stderr, not stdout.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "55327092c7e615916a77097f6e9bcda60b139266", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55327092c7e615916a77097f6e9bcda60b139266"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0148b971c921a0831fbf3357e5936eec724e3566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0148b971c921a0831fbf3357e5936eec724e3566", "html_url": "https://github.com/rust-lang/rust/commit/0148b971c921a0831fbf3357e5936eec724e3566", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0148b971c921a0831fbf3357e5936eec724e3566/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb2effd44e667d133e31ef334e30d10195218ce6", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb2effd44e667d133e31ef334e30d10195218ce6", "html_url": "https://github.com/rust-lang/rust/commit/cb2effd44e667d133e31ef334e30d10195218ce6"}, {"sha": "efdcb4301be26f96ee6e2df18f7b47dcfe89b129", "url": "https://api.github.com/repos/rust-lang/rust/commits/efdcb4301be26f96ee6e2df18f7b47dcfe89b129", "html_url": "https://github.com/rust-lang/rust/commit/efdcb4301be26f96ee6e2df18f7b47dcfe89b129"}], "stats": {"total": 1268, "additions": 877, "deletions": 391}, "files": [{"sha": "7f712643d19adb832e7e0e00960e1e26acb6823c", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -914,6 +914,7 @@ impl<'a> State<'a> {\n \n     pub fn print_assoc_constraint(&mut self, constraint: &ast::AssocTyConstraint) {\n         self.print_ident(constraint.ident);\n+        constraint.gen_args.as_ref().map(|args| self.print_generic_args(args, false));\n         self.s.space();\n         match &constraint.kind {\n             ast::AssocTyConstraintKind::Equality { ty } => {"}, {"sha": "51f851dc9469fe10dc0a07fea8d21e20c8a71b4a", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -608,7 +608,7 @@ pub fn print_time_passes_entry(\n         (None, None) => String::new(),\n     };\n \n-    println!(\"time: {:>7}{}\\t{}\", duration_to_secs_str(dur), mem_string, what);\n+    eprintln!(\"time: {:>7}{}\\t{}\", duration_to_secs_str(dur), mem_string, what);\n }\n \n // Hack up our own formatting for the duration to make it easier for scripts"}, {"sha": "c4330694504c34e53a04f257bce6b2c66adcc6e0", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -290,6 +290,7 @@ E0543: include_str!(\"./error_codes/E0543.md\"),\n E0545: include_str!(\"./error_codes/E0545.md\"),\n E0546: include_str!(\"./error_codes/E0546.md\"),\n E0547: include_str!(\"./error_codes/E0547.md\"),\n+E0549: include_str!(\"./error_codes/E0549.md\"),\n E0550: include_str!(\"./error_codes/E0550.md\"),\n E0551: include_str!(\"./error_codes/E0551.md\"),\n E0552: include_str!(\"./error_codes/E0552.md\"),\n@@ -608,9 +609,6 @@ E0781: include_str!(\"./error_codes/E0781.md\"),\n //  E0540, // multiple rustc_deprecated attributes\n     E0544, // multiple stability levels\n //  E0548, // replaced with a generic attribute input check\n-    // rustc_deprecated attribute must be paired with either stable or unstable\n-    // attribute\n-    E0549,\n     E0553, // multiple rustc_const_unstable attributes\n //  E0555, // replaced with a generic attribute input check\n //  E0558, // replaced with a generic attribute input check"}, {"sha": "0161c9325c2111e573d91a609bfa8a102fe608b2", "filename": "compiler/rustc_error_codes/src/error_codes/E0162.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0162.md", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0162.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0162.md?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -1,6 +1,6 @@\n #### Note: this error code is no longer emitted by the compiler.\n \n-An if-let pattern attempts to match the pattern, and enters the body if the\n+An `if let` pattern attempts to match the pattern, and enters the body if the\n match was successful. If the match is irrefutable (when it cannot fail to\n match), use a regular `let`-binding instead. For instance:\n "}, {"sha": "7bcd6c0cbf379fe8a0b09bd6b7d0930001ffb389", "filename": "compiler/rustc_error_codes/src/error_codes/E0165.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0165.md", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0165.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0165.md?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -1,6 +1,6 @@\n #### Note: this error code is no longer emitted by the compiler.\n \n-A while-let pattern attempts to match the pattern, and enters the body if the\n+A `while let` pattern attempts to match the pattern, and enters the body if the\n match was successful. If the match is irrefutable (when it cannot fail to\n match), use a regular `let`-binding inside a `loop` instead. For instance:\n "}, {"sha": "d4b78e7e0d668d706a6aa45c8a0ef4415a1fdc9f", "filename": "compiler/rustc_error_codes/src/error_codes/E0549.md", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0549.md", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0549.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0549.md?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -0,0 +1,37 @@\n+A `rustc_deprecated` attribute wasn't paired with a `stable`/`unstable`\n+attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0549\n+#![feature(staged_api)]\n+#![stable(since = \"1.0.0\", feature = \"test\")]\n+\n+#[rustc_deprecated(\n+    since = \"1.0.1\",\n+    reason = \"explanation for deprecation\"\n+)] // invalid\n+fn _deprecated_fn() {}\n+```\n+\n+To fix this issue, you need to add also an attribute `stable` or `unstable`.\n+Example:\n+\n+```\n+#![feature(staged_api)]\n+#![stable(since = \"1.0.0\", feature = \"test\")]\n+\n+#[stable(since = \"1.0.0\", feature = \"test\")]\n+#[rustc_deprecated(\n+    since = \"1.0.1\",\n+    reason = \"explanation for deprecation\"\n+)] // ok!\n+fn _deprecated_fn() {}\n+```\n+\n+See the [How Rust is Made and \u201cNightly Rust\u201d][how-rust-made-nightly] appendix\n+of the Book and the [Stability attributes][stability-attributes] section of the\n+Rustc Dev Guide for more details.\n+\n+[how-rust-made-nightly]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\n+[stability-attributes]: https://rustc-dev-guide.rust-lang.org/stability.html"}, {"sha": "42c3d5e48fe86f040e041389c932e83504234c59", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -1713,7 +1713,18 @@ impl EmitterWriter {\n         let max_line_num_len = if self.ui_testing {\n             ANONYMIZED_LINE_NUM.len()\n         } else {\n-            self.get_max_line_num(span, children).to_string().len()\n+            // Instead of using .to_string().len(), we iteratively count the\n+            // number of digits to avoid allocation. This strategy has sizable\n+            // performance gains over the old string strategy.\n+            let mut n = self.get_max_line_num(span, children);\n+            let mut num_digits = 0;\n+            loop {\n+                num_digits += 1;\n+                n /= 10;\n+                if n == 0 {\n+                    break num_digits;\n+                }\n+            }\n         };\n \n         match self.emit_message_default(span, message, code, level, max_line_num_len, false) {"}, {"sha": "03524569ce7a9f726fc581dd5cffee3aefda03de", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -242,6 +242,7 @@ language_item_table! {\n \n     Deref,                   sym::deref,               deref_trait,                Target::Trait;\n     DerefMut,                sym::deref_mut,           deref_mut_trait,            Target::Trait;\n+    DerefTarget,             sym::deref_target,        deref_target,               Target::AssocTy;\n     Receiver,                sym::receiver,            receiver_trait,             Target::Trait;\n \n     Fn,                      kw::Fn,                   fn_trait,                   Target::Trait;"}, {"sha": "374a9eb41e5c72be10ab654acc630b304649d21e", "filename": "compiler/rustc_incremental/src/persist/file_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -109,7 +109,7 @@ fn report_format_mismatch(report_incremental_info: bool, file: &Path, message: &\n     debug!(\"read_file: {}\", message);\n \n     if report_incremental_info {\n-        println!(\n+        eprintln!(\n             \"[incremental] ignoring cache artifact `{}`: {}\",\n             file.file_name().unwrap().to_string_lossy(),\n             message"}, {"sha": "c7a6c1195c5033cef24a587f55c5e098d0530567", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -440,12 +440,12 @@ fn copy_files(sess: &Session, target_dir: &Path, source_dir: &Path) -> Result<bo\n     }\n \n     if sess.opts.debugging_opts.incremental_info {\n-        println!(\n+        eprintln!(\n             \"[incremental] session directory: \\\n                   {} files hard-linked\",\n             files_linked\n         );\n-        println!(\n+        eprintln!(\n             \"[incremental] session directory: \\\n                  {} files copied\",\n             files_copied"}, {"sha": "2b5649bb0594f57de4d749f630278bb4026c8288", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -170,7 +170,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n \n                 if prev_commandline_args_hash != expected_hash {\n                     if report_incremental_info {\n-                        println!(\n+                        eprintln!(\n                             \"[incremental] completely ignoring cache because of \\\n                                     differing commandline arguments\"\n                         );"}, {"sha": "11ee8fb17ad1b4abc01175e138d765b28e192bb1", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -55,6 +55,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {\n     fn to_trace(\n+        tcx: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -178,7 +179,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        let trace = ToTrace::to_trace(self.cause, a_is_expected, a, b);\n+        let trace = ToTrace::to_trace(self.infcx.tcx, self.cause, a_is_expected, a, b);\n         Trace { at: self, trace, a_is_expected }\n     }\n }\n@@ -251,6 +252,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n     fn to_trace(\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -262,6 +264,7 @@ impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::Region<'tcx> {\n     fn to_trace(\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -273,6 +276,7 @@ impl<'tcx> ToTrace<'tcx> for ty::Region<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for &'tcx Const<'tcx> {\n     fn to_trace(\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -284,6 +288,7 @@ impl<'tcx> ToTrace<'tcx> for &'tcx Const<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n     fn to_trace(\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -298,6 +303,7 @@ impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::PolyTraitRef<'tcx> {\n     fn to_trace(\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -309,3 +315,20 @@ impl<'tcx> ToTrace<'tcx> for ty::PolyTraitRef<'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> ToTrace<'tcx> for ty::ProjectionTy<'tcx> {\n+    fn to_trace(\n+        tcx: TyCtxt<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: Self,\n+        b: Self,\n+    ) -> TypeTrace<'tcx> {\n+        let a_ty = tcx.mk_projection(a.item_def_id, a.substs);\n+        let b_ty = tcx.mk_projection(b.item_def_id, b.substs);\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: Types(ExpectedFound::new(a_is_expected, a_ty, b_ty)),\n+        }\n+    }\n+}"}, {"sha": "ed5061125ba9ee7fa165efbb9ef004b563b3e17e", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -64,8 +64,8 @@ pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n     }\n \n     if sess.opts.debugging_opts.input_stats {\n-        println!(\"Lines of code:             {}\", sess.source_map().count_lines());\n-        println!(\"Pre-expansion node count:  {}\", count_nodes(&krate));\n+        eprintln!(\"Lines of code:             {}\", sess.source_map().count_lines());\n+        eprintln!(\"Pre-expansion node count:  {}\", count_nodes(&krate));\n     }\n \n     if let Some(ref s) = sess.opts.debugging_opts.show_span {\n@@ -394,7 +394,7 @@ fn configure_and_expand_inner<'a>(\n     // Done with macro expansion!\n \n     if sess.opts.debugging_opts.input_stats {\n-        println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n+        eprintln!(\"Post-expansion node count: {}\", count_nodes(&krate));\n     }\n \n     if sess.opts.debugging_opts.hir_stats {"}, {"sha": "8eeee19cc298af84ddca5da9c2bdafa037fd604a", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -1815,7 +1815,7 @@ declare_lint! {\n \n declare_lint! {\n     /// The `irrefutable_let_patterns` lint detects detects [irrefutable\n-    /// patterns] in [if-let] and [while-let] statements.\n+    /// patterns] in [`if let`] and [`while let`] statements.\n     ///\n     ///\n     ///\n@@ -1832,7 +1832,7 @@ declare_lint! {\n     /// ### Explanation\n     ///\n     /// There usually isn't a reason to have an irrefutable pattern in an\n-    /// if-let or while-let statement, because the pattern will always match\n+    /// `if let` or `while let` statement, because the pattern will always match\n     /// successfully. A [`let`] or [`loop`] statement will suffice. However,\n     /// when generating code with a macro, forbidding irrefutable patterns\n     /// would require awkward workarounds in situations where the macro\n@@ -1843,14 +1843,14 @@ declare_lint! {\n     /// See [RFC 2086] for more details.\n     ///\n     /// [irrefutable patterns]: https://doc.rust-lang.org/reference/patterns.html#refutability\n-    /// [if-let]: https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions\n-    /// [while-let]: https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops\n+    /// [`if let`]: https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions\n+    /// [`while let`]: https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops\n     /// [`let`]: https://doc.rust-lang.org/reference/statements.html#let-statements\n     /// [`loop`]: https://doc.rust-lang.org/reference/expressions/loop-expr.html#infinite-loops\n     /// [RFC 2086]: https://github.com/rust-lang/rfcs/blob/master/text/2086-allow-if-let-irrefutables.md\n     pub IRREFUTABLE_LET_PATTERNS,\n     Warn,\n-    \"detects irrefutable patterns in if-let and while-let statements\"\n+    \"detects irrefutable patterns in `if let` and `while let` statements\"\n }\n \n declare_lint! {"}, {"sha": "61265d7204c0b2773814a709f72fa4272597c8f4", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -695,23 +695,23 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n             }\n \n-            println!(\"metadata stats:\");\n-            println!(\"             dep bytes: {}\", dep_bytes);\n-            println!(\"     lib feature bytes: {}\", lib_feature_bytes);\n-            println!(\"       lang item bytes: {}\", lang_item_bytes);\n-            println!(\" diagnostic item bytes: {}\", diagnostic_item_bytes);\n-            println!(\"          native bytes: {}\", native_lib_bytes);\n-            println!(\"      source_map bytes: {}\", source_map_bytes);\n-            println!(\"            impl bytes: {}\", impl_bytes);\n-            println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n-            println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n-            println!(\" proc-macro-data-bytes: {}\", proc_macro_data_bytes);\n-            println!(\"             mir bytes: {}\", mir_bytes);\n-            println!(\"            item bytes: {}\", item_bytes);\n-            println!(\"           table bytes: {}\", tables_bytes);\n-            println!(\"         hygiene bytes: {}\", hygiene_bytes);\n-            println!(\"            zero bytes: {}\", zero_bytes);\n-            println!(\"           total bytes: {}\", total_bytes);\n+            eprintln!(\"metadata stats:\");\n+            eprintln!(\"             dep bytes: {}\", dep_bytes);\n+            eprintln!(\"     lib feature bytes: {}\", lib_feature_bytes);\n+            eprintln!(\"       lang item bytes: {}\", lang_item_bytes);\n+            eprintln!(\" diagnostic item bytes: {}\", diagnostic_item_bytes);\n+            eprintln!(\"          native bytes: {}\", native_lib_bytes);\n+            eprintln!(\"      source_map bytes: {}\", source_map_bytes);\n+            eprintln!(\"            impl bytes: {}\", impl_bytes);\n+            eprintln!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n+            eprintln!(\"  def-path table bytes: {}\", def_path_table_bytes);\n+            eprintln!(\" proc-macro-data-bytes: {}\", proc_macro_data_bytes);\n+            eprintln!(\"             mir bytes: {}\", mir_bytes);\n+            eprintln!(\"            item bytes: {}\", item_bytes);\n+            eprintln!(\"           table bytes: {}\", tables_bytes);\n+            eprintln!(\"         hygiene bytes: {}\", hygiene_bytes);\n+            eprintln!(\"            zero bytes: {}\", zero_bytes);\n+            eprintln!(\"           total bytes: {}\", total_bytes);\n         }\n \n         root"}, {"sha": "f41bb7e6d6350945d172f565e6851340cb90c457", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -75,6 +75,36 @@ impl<'tcx> TyS<'tcx> {\n     }\n }\n \n+pub fn suggest_arbitrary_trait_bound(\n+    generics: &hir::Generics<'_>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    param_name: &str,\n+    constraint: &str,\n+) -> bool {\n+    let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n+    match (param, param_name) {\n+        (Some(_), \"Self\") => return false,\n+        _ => {}\n+    }\n+    // Suggest a where clause bound for a non-type paremeter.\n+    let (action, prefix) = if generics.where_clause.predicates.is_empty() {\n+        (\"introducing a\", \" where \")\n+    } else {\n+        (\"extending the\", \", \")\n+    };\n+    err.span_suggestion_verbose(\n+        generics.where_clause.tail_span_for_suggestion(),\n+        &format!(\n+            \"consider {} `where` bound, but there might be an alternative better way to express \\\n+             this requirement\",\n+            action,\n+        ),\n+        format!(\"{}{}: {}\", prefix, param_name, constraint),\n+        Applicability::MaybeIncorrect,\n+    );\n+    true\n+}\n+\n /// Suggest restricting a type param with a new bound.\n pub fn suggest_constraining_type_param(\n     tcx: TyCtxt<'_>,"}, {"sha": "7fe1e848d525ade36979328e541fc19a210f693f", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -1,5 +1,6 @@\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty::diagnostics::suggest_constraining_type_param;\n+use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::{self, BoundRegionKind, Region, Ty, TyCtxt};\n use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n use rustc_errors::{pluralize, DiagnosticBuilder};\n@@ -405,14 +406,22 @@ impl<'tcx> TyCtxt<'tcx> {\n                         {\n                             // Synthesize the associated type restriction `Add<Output = Expected>`.\n                             // FIXME: extract this logic for use in other diagnostics.\n-                            let trait_ref = proj.trait_ref(self);\n+                            let (trait_ref, assoc_substs) = proj.trait_ref_and_own_substs(self);\n                             let path =\n                                 self.def_path_str_with_substs(trait_ref.def_id, trait_ref.substs);\n                             let item_name = self.item_name(proj.item_def_id);\n+                            let item_args = self.format_generic_args(assoc_substs);\n+\n                             let path = if path.ends_with('>') {\n-                                format!(\"{}, {} = {}>\", &path[..path.len() - 1], item_name, p)\n+                                format!(\n+                                    \"{}, {}{} = {}>\",\n+                                    &path[..path.len() - 1],\n+                                    item_name,\n+                                    item_args,\n+                                    p\n+                                )\n                             } else {\n-                                format!(\"{}<{} = {}>\", path, item_name, p)\n+                                format!(\"{}<{}{} = {}>\", path, item_name, item_args, p)\n                             };\n                             note = !suggest_constraining_type_param(\n                                 self,\n@@ -561,7 +570,7 @@ impl<T> Trait<T> for X {\n         ty: Ty<'tcx>,\n     ) -> bool {\n         let assoc = self.associated_item(proj_ty.item_def_id);\n-        let trait_ref = proj_ty.trait_ref(self);\n+        let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n         if let Some(item) = self.hir().get_if_local(body_owner_def_id) {\n             if let Some(hir_generics) = item.generics() {\n                 // Get the `DefId` for the type parameter corresponding to `A` in `<A as T>::Foo`.\n@@ -595,6 +604,7 @@ impl<T> Trait<T> for X {\n                             &trait_ref,\n                             pred.bounds,\n                             &assoc,\n+                            assoc_substs,\n                             ty,\n                             msg,\n                         ) {\n@@ -612,6 +622,7 @@ impl<T> Trait<T> for X {\n                             &trait_ref,\n                             param.bounds,\n                             &assoc,\n+                            assoc_substs,\n                             ty,\n                             msg,\n                         );\n@@ -697,6 +708,7 @@ impl<T> Trait<T> for X {\n                 db,\n                 self.def_span(def_id),\n                 &assoc,\n+                proj_ty.trait_ref_and_own_substs(self).1,\n                 values.found,\n                 &msg,\n             ) {\n@@ -861,6 +873,7 @@ fn foo(&self) -> Self::T { String::new() }\n         trait_ref: &ty::TraitRef<'tcx>,\n         bounds: hir::GenericBounds<'_>,\n         assoc: &ty::AssocItem,\n+        assoc_substs: &[ty::GenericArg<'tcx>],\n         ty: Ty<'tcx>,\n         msg: &str,\n     ) -> bool {\n@@ -870,7 +883,12 @@ fn foo(&self) -> Self::T { String::new() }\n                 // Relate the type param against `T` in `<A as T>::Foo`.\n                 ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id)\n                     && self.constrain_associated_type_structured_suggestion(\n-                        db, ptr.span, assoc, ty, msg,\n+                        db,\n+                        ptr.span,\n+                        assoc,\n+                        assoc_substs,\n+                        ty,\n+                        msg,\n                     )\n             }\n             _ => false,\n@@ -884,6 +902,7 @@ fn foo(&self) -> Self::T { String::new() }\n         db: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         assoc: &ty::AssocItem,\n+        assoc_substs: &[ty::GenericArg<'tcx>],\n         ty: Ty<'tcx>,\n         msg: &str,\n     ) -> bool {\n@@ -895,11 +914,20 @@ fn foo(&self) -> Self::T { String::new() }\n                 let span = Span::new(pos, pos, span.ctxt());\n                 (span, format!(\", {} = {}\", assoc.ident, ty))\n             } else {\n-                (span.shrink_to_hi(), format!(\"<{} = {}>\", assoc.ident, ty))\n+                let item_args = self.format_generic_args(assoc_substs);\n+                (span.shrink_to_hi(), format!(\"<{}{} = {}>\", assoc.ident, item_args, ty))\n             };\n             db.span_suggestion_verbose(span, msg, sugg, MaybeIncorrect);\n             return true;\n         }\n         false\n     }\n+\n+    fn format_generic_args(self, args: &[ty::GenericArg<'tcx>]) -> String {\n+        let mut item_args = String::new();\n+        FmtPrinter::new(self, &mut item_args, hir::def::Namespace::TypeNS)\n+            .path_generic_args(Ok, args)\n+            .expect(\"could not write to `String`.\");\n+        item_args\n+    }\n }"}, {"sha": "b7f62437fa5a86379a79f1728eb076100a914599", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -1289,8 +1289,22 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         self.skip_binder().projection_ty.item_def_id\n     }\n \n+    /// Returns the `DefId` of the trait of the associated item being projected.\n     #[inline]\n-    pub fn to_poly_trait_ref(&self, tcx: TyCtxt<'tcx>) -> PolyTraitRef<'tcx> {\n+    pub fn trait_def_id(&self, tcx: TyCtxt<'tcx>) -> DefId {\n+        self.skip_binder().projection_ty.trait_def_id(tcx)\n+    }\n+\n+    #[inline]\n+    pub fn projection_self_ty(&self) -> Binder<Ty<'tcx>> {\n+        self.map_bound(|predicate| predicate.projection_ty.self_ty())\n+    }\n+\n+    /// Get the [PolyTraitRef] required for this projection to be well formed.\n+    /// Note that for generic associated types the predicates of the associated\n+    /// type also need to be checked.\n+    #[inline]\n+    pub fn required_poly_trait_ref(&self, tcx: TyCtxt<'tcx>) -> PolyTraitRef<'tcx> {\n         // Note: unlike with `TraitRef::to_poly_trait_ref()`,\n         // `self.0.trait_ref` is permitted to have escaping regions.\n         // This is because here `self` has a `Binder` and so does our"}, {"sha": "29ec9c132a89c0b6e6c7761558ff9772dbf8a364", "filename": "compiler/rustc_middle/src/ty/query/stats.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fstats.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -67,29 +67,29 @@ pub fn print_stats(tcx: TyCtxt<'_>) {\n     if cfg!(debug_assertions) {\n         let hits: usize = queries.iter().map(|s| s.cache_hits).sum();\n         let results: usize = queries.iter().map(|s| s.entry_count).sum();\n-        println!(\"\\nQuery cache hit rate: {}\", hits as f64 / (hits + results) as f64);\n+        eprintln!(\"\\nQuery cache hit rate: {}\", hits as f64 / (hits + results) as f64);\n     }\n \n     let mut query_key_sizes = queries.clone();\n     query_key_sizes.sort_by_key(|q| q.key_size);\n-    println!(\"\\nLarge query keys:\");\n+    eprintln!(\"\\nLarge query keys:\");\n     for q in query_key_sizes.iter().rev().filter(|q| q.key_size > 8) {\n-        println!(\"   {} - {} x {} - {}\", q.name, q.key_size, q.entry_count, q.key_type);\n+        eprintln!(\"   {} - {} x {} - {}\", q.name, q.key_size, q.entry_count, q.key_type);\n     }\n \n     let mut query_value_sizes = queries.clone();\n     query_value_sizes.sort_by_key(|q| q.value_size);\n-    println!(\"\\nLarge query values:\");\n+    eprintln!(\"\\nLarge query values:\");\n     for q in query_value_sizes.iter().rev().filter(|q| q.value_size > 8) {\n-        println!(\"   {} - {} x {} - {}\", q.name, q.value_size, q.entry_count, q.value_type);\n+        eprintln!(\"   {} - {} x {} - {}\", q.name, q.value_size, q.entry_count, q.value_type);\n     }\n \n     if cfg!(debug_assertions) {\n         let mut query_cache_hits = queries.clone();\n         query_cache_hits.sort_by_key(|q| q.cache_hits);\n-        println!(\"\\nQuery cache hits:\");\n+        eprintln!(\"\\nQuery cache hits:\");\n         for q in query_cache_hits.iter().rev() {\n-            println!(\n+            eprintln!(\n                 \"   {} - {} ({}%)\",\n                 q.name,\n                 q.cache_hits,\n@@ -100,19 +100,19 @@ pub fn print_stats(tcx: TyCtxt<'_>) {\n \n     let mut query_value_count = queries.clone();\n     query_value_count.sort_by_key(|q| q.entry_count);\n-    println!(\"\\nQuery value count:\");\n+    eprintln!(\"\\nQuery value count:\");\n     for q in query_value_count.iter().rev() {\n-        println!(\"   {} - {}\", q.name, q.entry_count);\n+        eprintln!(\"   {} - {}\", q.name, q.entry_count);\n     }\n \n     let mut def_id_density: Vec<_> =\n         queries.iter().filter(|q| q.local_def_id_keys.is_some()).collect();\n     def_id_density.sort_by_key(|q| q.local_def_id_keys.unwrap());\n-    println!(\"\\nLocal DefId density:\");\n+    eprintln!(\"\\nLocal DefId density:\");\n     let total = tcx.hir().definitions().def_index_count() as f64;\n     for q in def_id_density.iter().rev() {\n         let local = q.local_def_id_keys.unwrap();\n-        println!(\"   {} - {} = ({}%)\", q.name, local, (local as f64 * 100.0) / total);\n+        eprintln!(\"   {} - {} = ({}%)\", q.name, local, (local as f64 * 100.0) / total);\n     }\n }\n "}, {"sha": "bbf64c69d83bd399f2ccb57e6cb3dbe465869693", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -17,7 +17,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable;\n-use rustc_span::symbol::{kw, Ident, Symbol};\n+use rustc_span::symbol::{kw, Symbol};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi;\n use std::borrow::Cow;\n@@ -1112,36 +1112,35 @@ pub struct ProjectionTy<'tcx> {\n }\n \n impl<'tcx> ProjectionTy<'tcx> {\n-    /// Construct a `ProjectionTy` by searching the trait from `trait_ref` for the\n-    /// associated item named `item_name`.\n-    pub fn from_ref_and_name(\n-        tcx: TyCtxt<'_>,\n-        trait_ref: ty::TraitRef<'tcx>,\n-        item_name: Ident,\n-    ) -> ProjectionTy<'tcx> {\n-        let item_def_id = tcx\n-            .associated_items(trait_ref.def_id)\n-            .find_by_name_and_kind(tcx, item_name, ty::AssocKind::Type, trait_ref.def_id)\n-            .unwrap()\n-            .def_id;\n+    pub fn trait_def_id(&self, tcx: TyCtxt<'tcx>) -> DefId {\n+        tcx.associated_item(self.item_def_id).container.id()\n+    }\n \n-        ProjectionTy { substs: trait_ref.substs, item_def_id }\n+    /// Extracts the underlying trait reference and own substs from this projection.\n+    /// For example, if this is a projection of `<T as StreamingIterator>::Item<'a>`,\n+    /// then this function would return a `T: Iterator` trait reference and `['a]` as the own substs\n+    pub fn trait_ref_and_own_substs(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> (ty::TraitRef<'tcx>, &'tcx [ty::GenericArg<'tcx>]) {\n+        let def_id = tcx.associated_item(self.item_def_id).container.id();\n+        let trait_generics = tcx.generics_of(def_id);\n+        (\n+            ty::TraitRef { def_id, substs: self.substs.truncate_to(tcx, trait_generics) },\n+            &self.substs[trait_generics.count()..],\n+        )\n     }\n \n     /// Extracts the underlying trait reference from this projection.\n     /// For example, if this is a projection of `<T as Iterator>::Item`,\n     /// then this function would return a `T: Iterator` trait reference.\n+    ///\n+    /// WARNING: This will drop the substs for generic associated types\n+    /// consider calling [Self::trait_ref_and_own_substs] to get those\n+    /// as well.\n     pub fn trait_ref(&self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n-        // FIXME: This method probably shouldn't exist at all, since it's not\n-        // clear what this method really intends to do. Be careful when\n-        // using this method since the resulting TraitRef additionally\n-        // contains the substs for the assoc_item, which strictly speaking\n-        // is not correct\n-        let def_id = tcx.associated_item(self.item_def_id).container.id();\n-        // Include substitutions for generic arguments of associated types\n-        let assoc_item = tcx.associated_item(self.item_def_id);\n-        let substs_assoc_item = self.substs.truncate_to(tcx, tcx.generics_of(assoc_item.def_id));\n-        ty::TraitRef { def_id, substs: substs_assoc_item }\n+        let def_id = self.trait_def_id(tcx);\n+        ty::TraitRef { def_id, substs: self.substs.truncate_to(tcx, tcx.generics_of(def_id)) }\n     }\n \n     pub fn self_ty(&self) -> Ty<'tcx> {\n@@ -1493,12 +1492,11 @@ impl<'tcx> ExistentialProjection<'tcx> {\n     /// For example, if this is a projection of `exists T. <T as Iterator>::Item == X`,\n     /// then this function would return a `exists T. T: Iterator` existential trait\n     /// reference.\n-    pub fn trait_ref(&self, tcx: TyCtxt<'_>) -> ty::ExistentialTraitRef<'tcx> {\n-        // FIXME(generic_associated_types): substs is the substs of the\n-        // associated type, which should be truncated to get the correct substs\n-        // for the trait.\n+    pub fn trait_ref(&self, tcx: TyCtxt<'tcx>) -> ty::ExistentialTraitRef<'tcx> {\n         let def_id = tcx.associated_item(self.item_def_id).container.id();\n-        ty::ExistentialTraitRef { def_id, substs: self.substs }\n+        let subst_count = tcx.generics_of(def_id).count() - 1;\n+        let substs = tcx.intern_substs(&self.substs[..subst_count]);\n+        ty::ExistentialTraitRef { def_id, substs }\n     }\n \n     pub fn with_self_ty(\n@@ -1517,6 +1515,20 @@ impl<'tcx> ExistentialProjection<'tcx> {\n             ty: self.ty,\n         }\n     }\n+\n+    pub fn erase_self_ty(\n+        tcx: TyCtxt<'tcx>,\n+        projection_predicate: ty::ProjectionPredicate<'tcx>,\n+    ) -> Self {\n+        // Assert there is a Self.\n+        projection_predicate.projection_ty.substs.type_at(0);\n+\n+        Self {\n+            item_def_id: projection_predicate.projection_ty.item_def_id,\n+            substs: tcx.intern_substs(&projection_predicate.projection_ty.substs[1..]),\n+            ty: projection_predicate.ty,\n+        }\n+    }\n }\n \n impl<'tcx> PolyExistentialProjection<'tcx> {"}, {"sha": "7a9bfaad88367528bb9544684c2d51828f80259a", "filename": "compiler/rustc_mir/src/transform/coverage/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -327,7 +327,7 @@ macro_rules! assert_successors {\n fn test_covgraph_goto_switchint() {\n     let mir_body = goto_switchint();\n     if false {\n-        println!(\"basic_blocks = {}\", debug_basic_blocks(&mir_body));\n+        eprintln!(\"basic_blocks = {}\", debug_basic_blocks(&mir_body));\n     }\n     let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n     print_coverage_graphviz(\"covgraph_goto_switchint \", &mir_body, &basic_coverage_blocks);\n@@ -583,11 +583,11 @@ fn test_find_loop_backedges_none() {\n     let mir_body = goto_switchint();\n     let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n     if false {\n-        println!(\n+        eprintln!(\n             \"basic_coverage_blocks = {:?}\",\n             basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n         );\n-        println!(\"successors = {:?}\", basic_coverage_blocks.successors);\n+        eprintln!(\"successors = {:?}\", basic_coverage_blocks.successors);\n     }\n     let backedges = graph::find_loop_backedges(&basic_coverage_blocks);\n     assert_eq!("}, {"sha": "e928f3c5d4d09d8d0b398b3957b11a821dc7f624", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -368,9 +368,9 @@ fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<\n fn irrefutable_let_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, source: hir::MatchSource) {\n     tcx.struct_span_lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, |lint| {\n         let msg = match source {\n-            hir::MatchSource::IfLetDesugar { .. } => \"irrefutable if-let pattern\",\n-            hir::MatchSource::WhileLetDesugar => \"irrefutable while-let pattern\",\n-            hir::MatchSource::IfLetGuardDesugar => \"irrefutable if-let guard\",\n+            hir::MatchSource::IfLetDesugar { .. } => \"irrefutable `if let` pattern\",\n+            hir::MatchSource::WhileLetDesugar => \"irrefutable `while let` pattern\",\n+            hir::MatchSource::IfLetGuardDesugar => \"irrefutable `if let` guard\",\n             _ => bug!(),\n         };\n         lint.build(msg).emit()"}, {"sha": "fa05df6805f51ee280573077614ce5366193f4bf", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -513,7 +513,7 @@ impl<'a> Parser<'a> {\n             token::Ident(..) if this.is_mistaken_not_ident_negation() => {\n                 make_it!(this, attrs, |this, _| this.recover_not_expr(lo))\n             }\n-            _ => return this.parse_dot_or_call_expr(Some(attrs.into())),\n+            _ => return this.parse_dot_or_call_expr(Some(attrs)),\n         }\n     }\n "}, {"sha": "bb2c7e98861cdaa1cb295929173677449d0eac76", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -97,7 +97,7 @@ impl<'a> Parser<'a> {\n             self.mk_stmt(lo, StmtKind::Empty)\n         } else if self.token != token::CloseDelim(token::Brace) {\n             // Remainder are line-expr stmts.\n-            let e = self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs.into()))?;\n+            let e = self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs))?;\n             self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))\n         } else {\n             self.error_outer_attrs(&attrs.take_for_recovery());\n@@ -131,7 +131,7 @@ impl<'a> Parser<'a> {\n             };\n \n             let expr = this.with_res(Restrictions::STMT_EXPR, |this| {\n-                let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n+                let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs)?;\n                 this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n             })?;\n             Ok((\n@@ -213,7 +213,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn recover_local_after_let(&mut self, lo: Span, attrs: AttrVec) -> PResult<'a, Stmt> {\n-        let local = self.parse_local(attrs.into())?;\n+        let local = self.parse_local(attrs)?;\n         Ok(self.mk_stmt(lo.to(self.prev_token.span), StmtKind::Local(local)))\n     }\n "}, {"sha": "9328f7cd9ec7b6b72fb6786a328dfc0197eb754c", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -45,7 +45,7 @@ impl NonConstExpr {\n                 return None;\n             }\n \n-            Self::Match(IfLetGuardDesugar) => bug!(\"if-let guard outside a `match` expression\"),\n+            Self::Match(IfLetGuardDesugar) => bug!(\"`if let` guard outside a `match` expression\"),\n \n             // All other expressions are allowed.\n             Self::Loop(Loop | While | WhileLet)"}, {"sha": "8d5a5bdf6b71248603af3c83de8419ce107375d2", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -66,13 +66,13 @@ impl<'k> StatCollector<'k> {\n \n         let mut total_size = 0;\n \n-        println!(\"\\n{}\\n\", title);\n+        eprintln!(\"\\n{}\\n\", title);\n \n-        println!(\"{:<18}{:>18}{:>14}{:>14}\", \"Name\", \"Accumulated Size\", \"Count\", \"Item Size\");\n-        println!(\"----------------------------------------------------------------\");\n+        eprintln!(\"{:<18}{:>18}{:>14}{:>14}\", \"Name\", \"Accumulated Size\", \"Count\", \"Item Size\");\n+        eprintln!(\"----------------------------------------------------------------\");\n \n         for (label, data) in stats {\n-            println!(\n+            eprintln!(\n                 \"{:<18}{:>18}{:>14}{:>14}\",\n                 label,\n                 to_readable_str(data.count * data.size),\n@@ -82,8 +82,8 @@ impl<'k> StatCollector<'k> {\n \n             total_size += data.count * data.size;\n         }\n-        println!(\"----------------------------------------------------------------\");\n-        println!(\"{:<18}{:>18}\\n\", \"Total\", to_readable_str(total_size));\n+        eprintln!(\"----------------------------------------------------------------\");\n+        eprintln!(\"{:<18}{:>18}\\n\", \"Total\", to_readable_str(total_size));\n     }\n }\n "}, {"sha": "6e0e1c5eeef1524c43c1bcece6f5c0422c2df50d", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -77,6 +77,12 @@ trait DefIdVisitor<'tcx> {\n     fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> ControlFlow<Self::BreakTy> {\n         self.skeleton().visit_trait(trait_ref)\n     }\n+    fn visit_projection_ty(\n+        &mut self,\n+        projection: ty::ProjectionTy<'tcx>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        self.skeleton().visit_projection_ty(projection)\n+    }\n     fn visit_predicates(\n         &mut self,\n         predicates: ty::GenericPredicates<'tcx>,\n@@ -101,14 +107,28 @@ where\n         if self.def_id_visitor.shallow() { ControlFlow::CONTINUE } else { substs.visit_with(self) }\n     }\n \n+    fn visit_projection_ty(\n+        &mut self,\n+        projection: ty::ProjectionTy<'tcx>,\n+    ) -> ControlFlow<V::BreakTy> {\n+        let (trait_ref, assoc_substs) =\n+            projection.trait_ref_and_own_substs(self.def_id_visitor.tcx());\n+        self.visit_trait(trait_ref)?;\n+        if self.def_id_visitor.shallow() {\n+            ControlFlow::CONTINUE\n+        } else {\n+            assoc_substs.iter().try_for_each(|subst| subst.visit_with(self))\n+        }\n+    }\n+\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<V::BreakTy> {\n         match predicate.kind().skip_binder() {\n             ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref }, _) => {\n                 self.visit_trait(trait_ref)\n             }\n             ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n                 ty.visit_with(self)?;\n-                self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx()))\n+                self.visit_projection_ty(projection_ty)\n             }\n             ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n                 ty.visit_with(self)\n@@ -197,7 +217,7 @@ where\n                     return ControlFlow::CONTINUE;\n                 }\n                 // This will also visit substs if necessary, so we don't need to recurse.\n-                return self.visit_trait(proj.trait_ref(tcx));\n+                return self.visit_projection_ty(proj);\n             }\n             ty::Dynamic(predicates, ..) => {\n                 // All traits in the list are considered the \"primary\" part of the type\n@@ -1203,10 +1223,9 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n             }\n \n             for (poly_predicate, _) in bounds.projection_bounds {\n-                let tcx = self.tcx;\n                 if self.visit(poly_predicate.skip_binder().ty).is_break()\n                     || self\n-                        .visit_trait(poly_predicate.skip_binder().projection_ty.trait_ref(tcx))\n+                        .visit_projection_ty(poly_predicate.skip_binder().projection_ty)\n                         .is_break()\n                 {\n                     return;"}, {"sha": "b13aa2f6ccbac36f84cb59f18882b9ab07be7308", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -964,29 +964,29 @@ impl<K: DepKind> DepGraph<K> {\n                                  ----------------------------------------------\\\n                                  ------------\";\n \n-        println!(\"[incremental]\");\n-        println!(\"[incremental] DepGraph Statistics\");\n-        println!(\"{}\", SEPARATOR);\n-        println!(\"[incremental]\");\n-        println!(\"[incremental] Total Node Count: {}\", total_node_count);\n-        println!(\"[incremental] Total Edge Count: {}\", total_edge_count);\n+        eprintln!(\"[incremental]\");\n+        eprintln!(\"[incremental] DepGraph Statistics\");\n+        eprintln!(\"{}\", SEPARATOR);\n+        eprintln!(\"[incremental]\");\n+        eprintln!(\"[incremental] Total Node Count: {}\", total_node_count);\n+        eprintln!(\"[incremental] Total Edge Count: {}\", total_edge_count);\n \n         if cfg!(debug_assertions) {\n             let total_edge_reads = current.total_read_count.load(Relaxed);\n             let total_duplicate_edge_reads = current.total_duplicate_read_count.load(Relaxed);\n \n-            println!(\"[incremental] Total Edge Reads: {}\", total_edge_reads);\n-            println!(\"[incremental] Total Duplicate Edge Reads: {}\", total_duplicate_edge_reads);\n+            eprintln!(\"[incremental] Total Edge Reads: {}\", total_edge_reads);\n+            eprintln!(\"[incremental] Total Duplicate Edge Reads: {}\", total_duplicate_edge_reads);\n         }\n \n-        println!(\"[incremental]\");\n+        eprintln!(\"[incremental]\");\n \n-        println!(\n+        eprintln!(\n             \"[incremental]  {:<36}| {:<17}| {:<12}| {:<17}|\",\n             \"Node Kind\", \"Node Frequency\", \"Node Count\", \"Avg. Edge Count\"\n         );\n \n-        println!(\n+        eprintln!(\n             \"[incremental] -------------------------------------\\\n                   |------------------\\\n                   |-------------\\\n@@ -997,7 +997,7 @@ impl<K: DepKind> DepGraph<K> {\n             let node_kind_ratio = (100.0 * (stat.node_counter as f64)) / (total_node_count as f64);\n             let node_kind_avg_edges = (stat.edge_counter as f64) / (stat.node_counter as f64);\n \n-            println!(\n+            eprintln!(\n                 \"[incremental]  {:<36}|{:>16.1}% |{:>12} |{:>17.1} |\",\n                 format!(\"{:?}\", stat.kind),\n                 node_kind_ratio,\n@@ -1006,8 +1006,8 @@ impl<K: DepKind> DepGraph<K> {\n             );\n         }\n \n-        println!(\"{}\", SEPARATOR);\n-        println!(\"[incremental]\");\n+        eprintln!(\"{}\", SEPARATOR);\n+        eprintln!(\"[incremental]\");\n     }\n \n     fn next_virtual_depnode_index(&self) -> DepNodeIndex {"}, {"sha": "823aa61c4705daae510050eea3c1b4e6ec2af85f", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -959,19 +959,19 @@ impl Session {\n     }\n \n     pub fn print_perf_stats(&self) {\n-        println!(\n+        eprintln!(\n             \"Total time spent computing symbol hashes:      {}\",\n             duration_to_secs_str(*self.perf_stats.symbol_hash_time.lock())\n         );\n-        println!(\n+        eprintln!(\n             \"Total queries canonicalized:                   {}\",\n             self.perf_stats.queries_canonicalized.load(Ordering::Relaxed)\n         );\n-        println!(\n+        eprintln!(\n             \"normalize_generic_arg_after_erasing_regions:   {}\",\n             self.perf_stats.normalize_generic_arg_after_erasing_regions.load(Ordering::Relaxed)\n         );\n-        println!(\n+        eprintln!(\n             \"normalize_projection_ty:                       {}\",\n             self.perf_stats.normalize_projection_ty.load(Ordering::Relaxed)\n         );"}, {"sha": "0aca677248b7291530e6f19f9b1e8e9f6ffb752a", "filename": "compiler/rustc_span/src/source_map/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -243,7 +243,7 @@ impl SourceMapExtension for SourceMap {\n         substring: &str,\n         n: usize,\n     ) -> Span {\n-        println!(\n+        eprintln!(\n             \"span_substr(file={:?}/{:?}, substring={:?}, n={})\",\n             file.name, file.start_pos, substring, n\n         );"}, {"sha": "3f24a33f7d57074be463fb87460f02063da359e9", "filename": "compiler/rustc_trait_selection/src/autoderef.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -6,7 +6,6 @@ use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::{self, TraitRef, Ty, TyCtxt, WithConstness};\n use rustc_middle::ty::{ToPredicate, TypeFoldable};\n use rustc_session::DiagnosticMessageId;\n-use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n \n #[derive(Copy, Clone, Debug)]\n@@ -146,11 +145,10 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n         let normalized_ty = fulfillcx.normalize_projection_type(\n             &self.infcx,\n             self.param_env,\n-            ty::ProjectionTy::from_ref_and_name(\n-                tcx,\n-                trait_ref,\n-                Ident::with_dummy_span(sym::Target),\n-            ),\n+            ty::ProjectionTy {\n+                item_def_id: tcx.lang_items().deref_target()?,\n+                substs: trait_ref.substs,\n+            },\n             cause,\n         );\n         if let Err(e) = fulfillcx.select_where_possible(&self.infcx) {"}, {"sha": "8a1be7ea1726d1c957bbedf25891b6d7ce282123", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -72,17 +72,16 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                 // We were unable to unify the abstract constant with\n                 // a constant found in the caller bounds, there are\n                 // now three possible cases here.\n-                //\n-                // - The substs are concrete enough that we can simply\n-                //   try and evaluate the given constant.\n-                // - The abstract const still references an inference\n-                //   variable, in this case we return `TooGeneric`.\n-                // - The abstract const references a generic parameter,\n-                //   this means that we emit an error here.\n                 #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n                 enum FailureKind {\n+                    /// The abstract const still references an inference\n+                    /// variable, in this case we return `TooGeneric`.\n                     MentionsInfer,\n+                    /// The abstract const references a generic parameter,\n+                    /// this means that we emit an error here.\n                     MentionsParam,\n+                    /// The substs are concrete enough that we can simply\n+                    /// try and evaluate the given constant.\n                     Concrete,\n                 }\n                 let mut failure_kind = FailureKind::Concrete;"}, {"sha": "e9aaa65256419773b1b91c922c3184cc18683e3e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -1589,8 +1589,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.emit_inference_failure_err(body_id, span, a.into(), vec![], ErrorCode::E0282)\n             }\n             ty::PredicateKind::Projection(data) => {\n-                let trait_ref = bound_predicate.rebind(data).to_poly_trait_ref(self.tcx);\n-                let self_ty = trait_ref.skip_binder().self_ty();\n+                let self_ty = data.projection_ty.self_ty();\n                 let ty = data.ty;\n                 if predicate.references_error() {\n                     return;"}, {"sha": "e6a1cf58fe3734c6c8bc98b3ae9dee588a9e0b4b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -200,22 +200,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             if let Some(def) = aty.ty_adt_def() {\n                 // We also want to be able to select the array's type's original\n                 // signature with no type arguments resolved\n-                flags.push((\n-                    sym::_Self,\n-                    Some(format!(\"[{}]\", self.tcx.type_of(def.did).to_string())),\n-                ));\n-                let tcx = self.tcx;\n-                if let Some(len) = len.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n-                    flags.push((\n-                        sym::_Self,\n-                        Some(format!(\"[{}; {}]\", self.tcx.type_of(def.did).to_string(), len)),\n-                    ));\n-                } else {\n-                    flags.push((\n-                        sym::_Self,\n-                        Some(format!(\"[{}; _]\", self.tcx.type_of(def.did).to_string())),\n-                    ));\n-                }\n+                let type_string = self.tcx.type_of(def.did).to_string();\n+                flags.push((sym::_Self, Some(format!(\"[{}]\", type_string))));\n+\n+                let len = len.val.try_to_value().and_then(|v| v.try_to_machine_usize(self.tcx));\n+                let string = match len {\n+                    Some(n) => format!(\"[{}; {}]\", type_string, n),\n+                    None => format!(\"[{}; _]\", type_string),\n+                };\n+                flags.push((sym::_Self, Some(string)));\n             }\n         }\n         if let ty::Dynamic(traits, _) = self_ty.kind() {"}, {"sha": "5c97791530d9989a9a3a030534984cc47444b504", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -17,8 +17,8 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n use rustc_middle::ty::{\n-    self, suggest_constraining_type_param, AdtKind, DefIdTree, Infer, InferTy, ToPredicate, Ty,\n-    TyCtxt, TypeFoldable, WithConstness,\n+    self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n+    Infer, InferTy, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n use rustc_middle::ty::{TypeAndMut, TypeckResults};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -334,7 +334,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let (param_ty, projection) = match self_ty.kind() {\n             ty::Param(_) => (true, None),\n             ty::Projection(projection) => (false, Some(projection)),\n-            _ => return,\n+            _ => (false, None),\n         };\n \n         // FIXME: Add check for trait bound that is already present, particularly `?Sized` so we\n@@ -453,6 +453,26 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n                 }\n \n+                hir::Node::Item(hir::Item {\n+                    kind:\n+                        hir::ItemKind::Struct(_, generics)\n+                        | hir::ItemKind::Enum(_, generics)\n+                        | hir::ItemKind::Union(_, generics)\n+                        | hir::ItemKind::Trait(_, _, generics, ..)\n+                        | hir::ItemKind::Impl(hir::Impl { generics, .. })\n+                        | hir::ItemKind::Fn(_, generics, _)\n+                        | hir::ItemKind::TyAlias(_, generics)\n+                        | hir::ItemKind::TraitAlias(generics, _)\n+                        | hir::ItemKind::OpaqueTy(hir::OpaqueTy { generics, .. }),\n+                    ..\n+                }) if !param_ty => {\n+                    // Missing generic type parameter bound.\n+                    let param_name = self_ty.to_string();\n+                    let constraint = trait_ref.print_only_trait_path().to_string();\n+                    if suggest_arbitrary_trait_bound(generics, &mut err, &param_name, &constraint) {\n+                        return;\n+                    }\n+                }\n                 hir::Node::Crate(..) => return,\n \n                 _ => {}"}, {"sha": "3d9f98273db79099eabe4ad60c0a9c1a25b7f8dc", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -6,6 +6,7 @@ use rustc_errors::ErrorReported;\n use rustc_infer::traits::{TraitEngine, TraitEngineExt as _, TraitObligation};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n+use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::ToPredicate;\n use rustc_middle::ty::{self, Binder, Const, Ty, TypeFoldable};\n use std::marker::PhantomData;\n@@ -633,9 +634,9 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 // only reason we can fail to make progress on\n                 // trait selection is because we don't have enough\n                 // information about the types in the trait.\n-                *stalled_on = trait_ref_infer_vars(\n+                *stalled_on = substs_infer_vars(\n                     self.selcx,\n-                    trait_obligation.predicate.map_bound(|pred| pred.trait_ref),\n+                    trait_obligation.predicate.map_bound(|pred| pred.trait_ref.substs),\n                 );\n \n                 debug!(\n@@ -663,9 +664,9 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n         match project::poly_project_and_unify_type(self.selcx, &project_obligation) {\n             Ok(Ok(Some(os))) => ProcessResult::Changed(mk_pending(os)),\n             Ok(Ok(None)) => {\n-                *stalled_on = trait_ref_infer_vars(\n+                *stalled_on = substs_infer_vars(\n                     self.selcx,\n-                    project_obligation.predicate.to_poly_trait_ref(tcx),\n+                    project_obligation.predicate.map_bound(|pred| pred.projection_ty.substs),\n                 );\n                 ProcessResult::Unchanged\n             }\n@@ -678,16 +679,15 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n     }\n }\n \n-/// Returns the set of inference variables contained in a trait ref.\n-fn trait_ref_infer_vars<'a, 'tcx>(\n+/// Returns the set of inference variables contained in `substs`.\n+fn substs_infer_vars<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n+    substs: ty::Binder<SubstsRef<'tcx>>,\n ) -> Vec<TyOrConstInferVar<'tcx>> {\n     selcx\n         .infcx()\n-        .resolve_vars_if_possible(trait_ref)\n-        .skip_binder()\n-        .substs\n+        .resolve_vars_if_possible(substs)\n+        .skip_binder() // ok because this check doesn't care about regions\n         .iter()\n         // FIXME(eddyb) try using `skip_current_subtree` to skip everything that\n         // doesn't contain inference variables, not just the outermost level."}, {"sha": "7de20e477fe0479769be5d14a9ecdaf44c00d2f0", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -292,11 +292,7 @@ fn predicate_references_self(\n             //\n             // This is ALT2 in issue #56288, see that for discussion of the\n             // possible alternatives.\n-            if data.projection_ty.trait_ref(tcx).substs[1..].iter().any(has_self_ty) {\n-                Some(sp)\n-            } else {\n-                None\n-            }\n+            if data.projection_ty.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n         }\n         ty::PredicateKind::WellFormed(..)\n         | ty::PredicateKind::ObjectSafe(..)"}, {"sha": "0af6d6459159e6d10bd73a586d6fddd20d3fda4f", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -741,11 +741,7 @@ fn project_type<'cx, 'tcx>(\n         return Err(ProjectionTyError::TraitSelectionError(SelectionError::Overflow));\n     }\n \n-    let obligation_trait_ref = &obligation.predicate.trait_ref(selcx.tcx());\n-\n-    debug!(?obligation_trait_ref);\n-\n-    if obligation_trait_ref.references_error() {\n+    if obligation.predicate.references_error() {\n         return Ok(ProjectedTy::Progress(Progress::error(selcx.tcx())));\n     }\n \n@@ -754,19 +750,19 @@ fn project_type<'cx, 'tcx>(\n     // Make sure that the following procedures are kept in order. ParamEnv\n     // needs to be first because it has highest priority, and Select checks\n     // the return value of push_candidate which assumes it's ran at last.\n-    assemble_candidates_from_param_env(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+    assemble_candidates_from_param_env(selcx, obligation, &mut candidates);\n \n-    assemble_candidates_from_trait_def(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+    assemble_candidates_from_trait_def(selcx, obligation, &mut candidates);\n \n-    assemble_candidates_from_object_ty(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+    assemble_candidates_from_object_ty(selcx, obligation, &mut candidates);\n \n     if let ProjectionTyCandidateSet::Single(ProjectionTyCandidate::Object(_)) = candidates {\n         // Avoid normalization cycle from selection (see\n         // `assemble_candidates_from_object_ty`).\n         // FIXME(lazy_normalization): Lazy normalization should save us from\n-        // having to do special case this.\n+        // having to special case this.\n     } else {\n-        assemble_candidates_from_impls(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+        assemble_candidates_from_impls(selcx, obligation, &mut candidates);\n     };\n \n     match candidates {\n@@ -792,14 +788,12 @@ fn project_type<'cx, 'tcx>(\n fn assemble_candidates_from_param_env<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_param_env(..)\");\n     assemble_candidates_from_predicates(\n         selcx,\n         obligation,\n-        obligation_trait_ref,\n         candidate_set,\n         ProjectionTyCandidate::ParamEnv,\n         obligation.param_env.caller_bounds().iter(),\n@@ -820,15 +814,14 @@ fn assemble_candidates_from_param_env<'cx, 'tcx>(\n fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_trait_def(..)\");\n \n     let tcx = selcx.tcx();\n     // Check whether the self-type is itself a projection.\n     // If so, extract what we know from the trait and try to come up with a good answer.\n-    let bounds = match *obligation_trait_ref.self_ty().kind() {\n+    let bounds = match *obligation.predicate.self_ty().kind() {\n         ty::Projection(ref data) => tcx.item_bounds(data.item_def_id).subst(tcx, data.substs),\n         ty::Opaque(def_id, substs) => tcx.item_bounds(def_id).subst(tcx, substs),\n         ty::Infer(ty::TyVar(_)) => {\n@@ -843,7 +836,6 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     assemble_candidates_from_predicates(\n         selcx,\n         obligation,\n-        obligation_trait_ref,\n         candidate_set,\n         ProjectionTyCandidate::TraitDef,\n         bounds.iter(),\n@@ -863,14 +855,13 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_object_ty(..)\");\n \n     let tcx = selcx.tcx();\n \n-    let self_ty = obligation_trait_ref.self_ty();\n+    let self_ty = obligation.predicate.self_ty();\n     let object_ty = selcx.infcx().shallow_resolve(self_ty);\n     let data = match object_ty.kind() {\n         ty::Dynamic(data, ..) => data,\n@@ -890,7 +881,6 @@ fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n     assemble_candidates_from_predicates(\n         selcx,\n         obligation,\n-        obligation_trait_ref,\n         candidate_set,\n         ProjectionTyCandidate::Object,\n         env_predicates,\n@@ -901,7 +891,6 @@ fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n     env_predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n@@ -921,8 +910,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n                 && infcx.probe(|_| {\n                     selcx.match_projection_projections(\n                         obligation,\n-                        obligation_trait_ref,\n-                        &data,\n+                        data,\n                         potentially_unnormalized_candidates,\n                     )\n                 });\n@@ -948,14 +936,13 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n fn assemble_candidates_from_impls<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n ) {\n     debug!(\"assemble_candidates_from_impls\");\n \n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n-    let poly_trait_ref = ty::Binder::dummy(*obligation_trait_ref);\n+    let poly_trait_ref = obligation.predicate.trait_ref(selcx.tcx()).to_poly_trait_ref();\n     let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n     let _ = selcx.infcx().commit_if_ok(|_| {\n         let impl_source = match selcx.select(&trait_obligation) {\n@@ -1410,25 +1397,25 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n         poly_cache_entry,\n     );\n \n-    let cache_trait_ref = cache_entry.projection_ty.trait_ref(infcx.tcx);\n-    let obligation_trait_ref = obligation.predicate.trait_ref(infcx.tcx);\n+    let cache_projection = cache_entry.projection_ty;\n+    let obligation_projection = obligation.predicate;\n     let mut nested_obligations = Vec::new();\n-    let cache_trait_ref = if potentially_unnormalized_candidate {\n+    let cache_projection = if potentially_unnormalized_candidate {\n         ensure_sufficient_stack(|| {\n             normalize_with_depth_to(\n                 selcx,\n                 obligation.param_env,\n                 obligation.cause.clone(),\n                 obligation.recursion_depth + 1,\n-                cache_trait_ref,\n+                cache_projection,\n                 &mut nested_obligations,\n             )\n         })\n     } else {\n-        cache_trait_ref\n+        cache_projection\n     };\n \n-    match infcx.at(cause, param_env).eq(cache_trait_ref, obligation_trait_ref) {\n+    match infcx.at(cause, param_env).eq(cache_projection, obligation_projection) {\n         Ok(InferOk { value: _, obligations }) => {\n             nested_obligations.extend(obligations);\n             assoc_ty_own_obligations(selcx, obligation, &mut nested_obligations);"}, {"sha": "45b5aff40a6d277b6c1bbf14497c4850451922cd", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -32,6 +32,7 @@ use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Constness;\n+use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::fast_reject;\n@@ -1254,32 +1255,33 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub(super) fn match_projection_projections(\n         &mut self,\n         obligation: &ProjectionTyObligation<'tcx>,\n-        obligation_trait_ref: &ty::TraitRef<'tcx>,\n-        data: &PolyProjectionPredicate<'tcx>,\n+        env_predicate: PolyProjectionPredicate<'tcx>,\n         potentially_unnormalized_candidates: bool,\n     ) -> bool {\n         let mut nested_obligations = Vec::new();\n-        let projection_ty = if potentially_unnormalized_candidates {\n+        let (infer_predicate, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n+            obligation.cause.span,\n+            LateBoundRegionConversionTime::HigherRankedType,\n+            env_predicate,\n+        );\n+        let infer_projection = if potentially_unnormalized_candidates {\n             ensure_sufficient_stack(|| {\n                 project::normalize_with_depth_to(\n                     self,\n                     obligation.param_env,\n                     obligation.cause.clone(),\n                     obligation.recursion_depth + 1,\n-                    data.map_bound(|data| data.projection_ty),\n+                    infer_predicate.projection_ty,\n                     &mut nested_obligations,\n                 )\n             })\n         } else {\n-            data.map_bound(|data| data.projection_ty)\n+            infer_predicate.projection_ty\n         };\n \n-        // FIXME(generic_associated_types): Compare the whole projections\n-        let data_poly_trait_ref = projection_ty.map_bound(|proj| proj.trait_ref(self.tcx()));\n-        let obligation_poly_trait_ref = ty::Binder::dummy(*obligation_trait_ref);\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n-            .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n+            .sup(obligation.predicate, infer_projection)\n             .map_or(false, |InferOk { obligations, value: () }| {\n                 self.evaluate_predicates_recursively(\n                     TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),"}, {"sha": "fdf5f697e61178910b203811739878a5ad88f265", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -779,14 +779,11 @@ impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>> {\n-        let trait_ref = self.projection_ty.trait_ref(interner.tcx);\n+        let (trait_ref, own_substs) = self.projection_ty.trait_ref_and_own_substs(interner.tcx);\n         chalk_solve::rust_ir::AliasEqBound {\n             trait_bound: trait_ref.lower_into(interner),\n             associated_ty_id: chalk_ir::AssocTypeId(self.projection_ty.item_def_id),\n-            parameters: self.projection_ty.substs[trait_ref.substs.len()..]\n-                .iter()\n-                .map(|arg| arg.lower_into(interner))\n-                .collect(),\n+            parameters: own_substs.iter().map(|arg| arg.lower_into(interner)).collect(),\n             value: self.ty.lower_into(interner),\n         }\n     }"}, {"sha": "947363fc3ed081307a8787be77b6baf7211074f4", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -985,10 +985,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         //\n         // We want to produce `<B as SuperTrait<i32>>::T == foo`.\n \n-        debug!(\n-            \"add_predicates_for_ast_type_binding(hir_ref_id {:?}, trait_ref {:?}, binding {:?}, bounds {:?}\",\n-            hir_ref_id, trait_ref, binding, bounds\n-        );\n+        debug!(?hir_ref_id, ?trait_ref, ?binding, ?bounds, \"add_predicates_for_ast_type_binding\",);\n         let tcx = self.tcx();\n \n         let candidate =\n@@ -1326,37 +1323,35 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         debug!(\"regular_traits: {:?}\", regular_traits);\n         debug!(\"auto_traits: {:?}\", auto_traits);\n \n-        // Transform a `PolyTraitRef` into a `PolyExistentialTraitRef` by\n-        // removing the dummy `Self` type (`trait_object_dummy_self`).\n-        let trait_ref_to_existential = |trait_ref: ty::TraitRef<'tcx>| {\n-            if trait_ref.self_ty() != dummy_self {\n-                // FIXME: There appears to be a missing filter on top of `expand_trait_aliases`,\n-                // which picks up non-supertraits where clauses - but also, the object safety\n-                // completely ignores trait aliases, which could be object safety hazards. We\n-                // `delay_span_bug` here to avoid an ICE in stable even when the feature is\n-                // disabled. (#66420)\n-                tcx.sess.delay_span_bug(\n-                    DUMMY_SP,\n-                    &format!(\n-                        \"trait_ref_to_existential called on {:?} with non-dummy Self\",\n-                        trait_ref,\n-                    ),\n-                );\n-            }\n-            ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref)\n-        };\n-\n         // Erase the `dummy_self` (`trait_object_dummy_self`) used above.\n-        let existential_trait_refs =\n-            regular_traits.iter().map(|i| i.trait_ref().map_bound(trait_ref_to_existential));\n+        let existential_trait_refs = regular_traits.iter().map(|i| {\n+            i.trait_ref().map_bound(|trait_ref: ty::TraitRef<'tcx>| {\n+                if trait_ref.self_ty() != dummy_self {\n+                    // FIXME: There appears to be a missing filter on top of `expand_trait_aliases`,\n+                    // which picks up non-supertraits where clauses - but also, the object safety\n+                    // completely ignores trait aliases, which could be object safety hazards. We\n+                    // `delay_span_bug` here to avoid an ICE in stable even when the feature is\n+                    // disabled. (#66420)\n+                    tcx.sess.delay_span_bug(\n+                        DUMMY_SP,\n+                        &format!(\n+                            \"trait_ref_to_existential called on {:?} with non-dummy Self\",\n+                            trait_ref,\n+                        ),\n+                    );\n+                }\n+                ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref)\n+            })\n+        });\n         let existential_projections = bounds.projection_bounds.iter().map(|(bound, _)| {\n             bound.map_bound(|b| {\n-                let trait_ref = trait_ref_to_existential(b.projection_ty.trait_ref(tcx));\n-                ty::ExistentialProjection {\n-                    ty: b.ty,\n-                    item_def_id: b.projection_ty.item_def_id,\n-                    substs: trait_ref.substs,\n+                if b.projection_ty.self_ty() != dummy_self {\n+                    tcx.sess.delay_span_bug(\n+                        DUMMY_SP,\n+                        &format!(\"trait_ref_to_existential called on {:?} with non-dummy Self\", b),\n+                    );\n                 }\n+                ty::ExistentialProjection::erase_self_ty(tcx, b)\n             })\n         });\n \n@@ -1473,7 +1468,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }),\n                     assoc_name,\n                 )\n-                .into_iter()\n             },\n             || param_name.to_string(),\n             assoc_name,"}, {"sha": "431e6d70ff35c7815db140bc3275daf8b7977626", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -208,7 +208,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             });\n \n         // Even if we can't infer the full signature, we may be able to\n-        // infer the kind. This can occur if there is a trait-reference\n+        // infer the kind. This can occur when we elaborate a predicate\n         // like `F : Fn<A>`. Note that due to subtyping we could encounter\n         // many viable options, so pick the most restrictive.\n         let expected_kind = self\n@@ -234,11 +234,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         debug!(\"deduce_sig_from_projection({:?})\", projection);\n \n-        let trait_ref = projection.to_poly_trait_ref(tcx);\n+        let trait_def_id = projection.trait_def_id(tcx);\n \n-        let is_fn = tcx.fn_trait_kind_from_lang_item(trait_ref.def_id()).is_some();\n+        let is_fn = tcx.fn_trait_kind_from_lang_item(trait_def_id).is_some();\n         let gen_trait = tcx.require_lang_item(LangItem::Generator, cause_span);\n-        let is_gen = gen_trait == trait_ref.def_id();\n+        let is_gen = gen_trait == trait_def_id;\n         if !is_fn && !is_gen {\n             debug!(\"deduce_sig_from_projection: not fn or generator\");\n             return None;\n@@ -256,7 +256,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         let input_tys = if is_fn {\n-            let arg_param_ty = trait_ref.skip_binder().substs.type_at(1);\n+            let arg_param_ty = projection.skip_binder().projection_ty.substs.type_at(1);\n             let arg_param_ty = self.resolve_vars_if_possible(arg_param_ty);\n             debug!(\"deduce_sig_from_projection: arg_param_ty={:?}\", arg_param_ty);\n \n@@ -662,9 +662,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // Check that this is a projection from the `Future` trait.\n-        let trait_ref = predicate.projection_ty.trait_ref(self.tcx);\n+        let trait_def_id = predicate.projection_ty.trait_def_id(self.tcx);\n         let future_trait = self.tcx.require_lang_item(LangItem::Future, Some(cause_span));\n-        if trait_ref.def_id != future_trait {\n+        if trait_def_id != future_trait {\n             debug!(\"deduce_future_output_from_projection: not a future\");\n             return None;\n         }"}, {"sha": "7f27325f7f96ffdb9840e502c1cb673bd63dbfba", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -769,9 +769,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .filter_map(move |obligation| {\n                 let bound_predicate = obligation.predicate.kind();\n                 match bound_predicate.skip_binder() {\n-                    ty::PredicateKind::Projection(data) => {\n-                        Some((bound_predicate.rebind(data).to_poly_trait_ref(self.tcx), obligation))\n-                    }\n+                    ty::PredicateKind::Projection(data) => Some((\n+                        bound_predicate.rebind(data).required_poly_trait_ref(self.tcx),\n+                        obligation,\n+                    )),\n                     ty::PredicateKind::Trait(data, _) => {\n                         Some((bound_predicate.rebind(data).to_poly_trait_ref(), obligation))\n                     }"}, {"sha": "0134266fab56d12c1388c58165426bfc70269c1b", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -23,6 +23,7 @@ use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::Obligation;\n \n use std::cmp::Ordering;\n+use std::iter;\n \n use super::probe::Mode;\n use super::{CandidateSource, MethodError, NoMatchData};\n@@ -648,21 +649,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             ty::PredicateKind::Projection(pred) => {\n                                 let pred = bound_predicate.rebind(pred);\n                                 // `<Foo as Iterator>::Item = String`.\n-                                let trait_ref =\n-                                    pred.skip_binder().projection_ty.trait_ref(self.tcx);\n-                                let assoc = self\n-                                    .tcx\n-                                    .associated_item(pred.skip_binder().projection_ty.item_def_id);\n-                                let ty = pred.skip_binder().ty;\n-                                let obligation = format!(\"{}::{} = {}\", trait_ref, assoc.ident, ty);\n-                                let quiet = format!(\n-                                    \"<_ as {}>::{} = {}\",\n-                                    trait_ref.print_only_trait_path(),\n-                                    assoc.ident,\n-                                    ty\n+                                let projection_ty = pred.skip_binder().projection_ty;\n+\n+                                let substs_with_infer_self = tcx.mk_substs(\n+                                    iter::once(tcx.mk_ty_var(ty::TyVid { index: 0 }).into())\n+                                        .chain(projection_ty.substs.iter().skip(1)),\n                                 );\n-                                bound_span_label(trait_ref.self_ty(), &obligation, &quiet);\n-                                Some((obligation, trait_ref.self_ty()))\n+\n+                                let quiet_projection_ty = ty::ProjectionTy {\n+                                    substs: substs_with_infer_self,\n+                                    item_def_id: projection_ty.item_def_id,\n+                                };\n+\n+                                let ty = pred.skip_binder().ty;\n+\n+                                let obligation = format!(\"{} = {}\", projection_ty, ty);\n+                                let quiet = format!(\"{} = {}\", quiet_projection_ty, ty);\n+\n+                                bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n+                                Some((obligation, projection_ty.self_ty()))\n                             }\n                             ty::PredicateKind::Trait(poly_trait_ref, _) => {\n                                 let p = poly_trait_ref.trait_ref;"}, {"sha": "529de1a2874841b6055b333fb6f2a240cc0a163f", "filename": "compiler/rustc_typeck/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -198,7 +198,7 @@ pub fn setup_constraining_predicates<'tcx>(\n                 //     `<<T as Bar>::Baz as Iterator>::Output = <U as Iterator>::Output`\n                 // Then the projection only applies if `T` is known, but it still\n                 // does not determine `U`.\n-                let inputs = parameters_for(&projection.projection_ty.trait_ref(tcx), true);\n+                let inputs = parameters_for(&projection.projection_ty, true);\n                 let relies_only_on_inputs = inputs.iter().all(|p| input_parameters.contains(&p));\n                 if !relies_only_on_inputs {\n                     continue;"}, {"sha": "2419771eae212fa79ef30efdcab1fdf0d951cd6e", "filename": "library/core/src/ops/deref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fderef.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -64,6 +64,7 @@ pub trait Deref {\n     /// The resulting type after dereferencing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_diagnostic_item = \"deref_target\"]\n+    #[cfg_attr(not(bootstrap), lang = \"deref_target\")]\n     type Target: ?Sized;\n \n     /// Dereferences the value."}, {"sha": "ae38030d49771c05d185ab08f7571332d028b6ff", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -506,7 +506,18 @@ pub fn run_test(\n         let supports_threads = !cfg!(target_os = \"emscripten\") && !cfg!(target_arch = \"wasm32\");\n         if concurrency == Concurrent::Yes && supports_threads {\n             let cfg = thread::Builder::new().name(name.as_slice().to_owned());\n-            Some(cfg.spawn(runtest).unwrap())\n+            let mut runtest = Arc::new(Mutex::new(Some(runtest)));\n+            let runtest2 = runtest.clone();\n+            match cfg.spawn(move || runtest2.lock().unwrap().take().unwrap()()) {\n+                Ok(handle) => Some(handle),\n+                Err(e) if e.kind() == io::ErrorKind::WouldBlock => {\n+                    // `ErrorKind::WouldBlock` means hitting the thread limit on some\n+                    // platforms, so run the test synchronously here instead.\n+                    Arc::get_mut(&mut runtest).unwrap().get_mut().unwrap().take().unwrap()();\n+                    None\n+                }\n+                Err(e) => panic!(\"failed to spawn thread to run test: {}\", e),\n+            }\n         } else {\n             runtest();\n             None"}, {"sha": "7d5e3d05b11facb56677a513a0eb94c55117bb86", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -27,7 +27,7 @@ use crate::config::TargetSelection;\n use crate::dist;\n use crate::native;\n use crate::tool::SourceType;\n-use crate::util::{exe, is_dylib, symlink_dir};\n+use crate::util::{exe, is_debug_info, is_dylib, symlink_dir};\n use crate::{Compiler, DependencyType, GitRepo, Mode};\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -1049,7 +1049,8 @@ impl Step for Assemble {\n         let src_libdir = builder.sysroot_libdir(build_compiler, host);\n         for f in builder.read_dir(&src_libdir) {\n             let filename = f.file_name().into_string().unwrap();\n-            if is_dylib(&filename) && !proc_macros.contains(&filename) {\n+            if (is_dylib(&filename) || is_debug_info(&filename)) && !proc_macros.contains(&filename)\n+            {\n                 builder.copy(&f.path(), &rustc_libdir.join(&filename));\n             }\n         }\n@@ -1166,6 +1167,7 @@ pub fn run_cargo(\n             if !(filename.ends_with(\".rlib\")\n                 || filename.ends_with(\".lib\")\n                 || filename.ends_with(\".a\")\n+                || is_debug_info(&filename)\n                 || is_dylib(&filename)\n                 || (is_check && filename.ends_with(\".rmeta\")))\n             {"}, {"sha": "b427420d577959f9e80cec4e5dc3d119c8df24c3", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -53,7 +53,7 @@ fn install_sh(\n }\n \n fn default_path(config: &Option<PathBuf>, default: &str) -> PathBuf {\n-    PathBuf::from(config.as_ref().cloned().unwrap_or_else(|| PathBuf::from(default)))\n+    config.as_ref().cloned().unwrap_or_else(|| PathBuf::from(default))\n }\n \n fn prepare_dir(mut path: PathBuf) -> String {"}, {"sha": "b4421a82714fcebd01bd65a7ed8ac9c70aa2215b", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -32,6 +32,12 @@ pub fn is_dylib(name: &str) -> bool {\n     name.ends_with(\".dylib\") || name.ends_with(\".so\") || name.ends_with(\".dll\")\n }\n \n+/// Returns `true` if the file name given looks like a debug info file\n+pub fn is_debug_info(name: &str) -> bool {\n+    // FIXME: consider split debug info on other platforms (e.g., Linux, macOS)\n+    name.ends_with(\".pdb\")\n+}\n+\n /// Returns the corresponding relative library directory that the compiler's\n /// dylibs will be found in.\n pub fn libdir(target: TargetSelection) -> &'static str {"}, {"sha": "e20c84ba053f6efac8fdd74b2905d3cd4d96c85e", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -161,7 +161,7 @@ impl<'tcx> DocContext<'tcx> {\n             }\n             Entry::Occupied(e) => e.into_mut(),\n         };\n-        *def_index = DefIndex::from(*def_index + 1);\n+        *def_index = *def_index + 1;\n \n         DefId { krate: crate_num, index: *def_index }\n     }"}, {"sha": "b248fcdefbe7f337c9ee8bf78f84e54e31a55565", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -182,7 +182,7 @@ fn from_clean_item_kind(item: clean::ItemKind, tcx: TyCtxt<'_>) -> ItemEnum {\n             bounds: g.into_iter().map(Into::into).collect(),\n             default: t.map(Into::into),\n         },\n-        StrippedItem(inner) => from_clean_item_kind(*inner, tcx).into(),\n+        StrippedItem(inner) => from_clean_item_kind(*inner, tcx),\n         PrimitiveItem(_) | KeywordItem(_) => {\n             panic!(\"{:?} is not supported for JSON output\", item)\n         }"}, {"sha": "8877c6cc9927b9111e1afaf0994a20f110c61343", "filename": "src/test/pretty/gat-bounds.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fpretty%2Fgat-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fpretty%2Fgat-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fgat-bounds.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -13,4 +13,6 @@ impl X for () {\n     type Y<T> where Self: Sized = u32;\n }\n \n+fn f<T: X<Y<()> = i32>>() {}\n+\n fn main() { }"}, {"sha": "29c1bc71d870459d5ebcd94f04b8eb4686efd809", "filename": "src/test/run-make/libtest-thread-limit/Makefile", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Frun-make%2Flibtest-thread-limit%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Frun-make%2Flibtest-thread-limit%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flibtest-thread-limit%2FMakefile?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -0,0 +1,7 @@\n+-include ../../run-make-fulldeps/tools.mk\n+\n+# only-linux\n+\n+all:\n+\t$(RUSTC) test.rs --test --target $(TARGET)\n+\t$(shell ulimit -p 0 && $(call RUN,test))"}, {"sha": "d899411a49ea0c9979eabb6691c5701d4c017c37", "filename": "src/test/run-make/libtest-thread-limit/test.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Frun-make%2Flibtest-thread-limit%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Frun-make%2Flibtest-thread-limit%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flibtest-thread-limit%2Ftest.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -0,0 +1,16 @@\n+#![feature(once_cell)]\n+\n+use std::{io::ErrorKind, lazy::SyncOnceCell, thread::{self, Builder, ThreadId}};\n+\n+static THREAD_ID: SyncOnceCell<ThreadId> = SyncOnceCell::new();\n+\n+#[test]\n+fn spawn_thread_would_block() {\n+    assert_eq!(Builder::new().spawn(|| unreachable!()).unwrap_err().kind(), ErrorKind::WouldBlock);\n+    THREAD_ID.set(thread::current().id()).unwrap();\n+}\n+\n+#[test]\n+fn run_in_same_thread() {\n+    assert_eq!(*THREAD_ID.get().unwrap(), thread::current().id());\n+}"}, {"sha": "28d57e92c37313b17bb483a17a1d533f1b470484", "filename": "src/test/ui/binding/if-let.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fbinding%2Fif-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fbinding%2Fif-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Fif-let.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -6,7 +6,7 @@ pub fn main() {\n     if let Some(y) = x {\n         assert_eq!(y, 3);\n     } else {\n-        panic!(\"if-let panicked\");\n+        panic!(\"`if let` panicked\");\n     }\n     let mut worked = false;\n     if let Some(_) = x {\n@@ -54,7 +54,7 @@ pub fn main() {\n         if let Foo::Two(b) = a {\n             assert_eq!(b, 42_usize);\n         } else {\n-            panic!(\"panic in nested if-let\");\n+            panic!(\"panic in nested `if let`\");\n         }\n     }\n }"}, {"sha": "6107a082237c6617708b5041820c955da4e4797b", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-single-variant-diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -16,7 +16,7 @@ fn main() {\n         // FIXME(project-rfc-2229#24): Change this to be a destructure pattern\n         // once this is fixed, to remove the warning.\n         if let SingleVariant::Point(ref mut x, _) = point {\n-            //~^ WARNING: irrefutable if-let pattern\n+            //~^ WARNING: irrefutable `if let` pattern\n             *x += 1;\n         }\n     };"}, {"sha": "5c7a56c7ceda48bf3d26bf7e049fb9ec0b801b15", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-single-variant-diagnostics.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -7,7 +7,7 @@ LL | #![feature(capture_disjoint_fields)]\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n \n-warning: irrefutable if-let pattern\n+warning: irrefutable `if let` pattern\n   --> $DIR/closure-origin-single-variant-diagnostics.rs:18:9\n    |\n LL | /         if let SingleVariant::Point(ref mut x, _) = point {"}, {"sha": "afef748ff46906a2f30a5d335446aa4f04f97885", "filename": "src/test/ui/const-generics/dont-evaluate-array-len-on-err-1.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fconst-generics%2Fdont-evaluate-array-len-on-err-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fconst-generics%2Fdont-evaluate-array-len-on-err-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdont-evaluate-array-len-on-err-1.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -0,0 +1,22 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+// This tests that during error handling for the \"trait not implemented\" error\n+// we dont try to evaluate std::mem::size_of::<Self::Assoc> causing an ICE\n+\n+struct Adt;\n+\n+trait Foo {\n+    type Assoc;\n+    fn foo()\n+    where\n+        [Adt; std::mem::size_of::<Self::Assoc>()]: ,\n+    {\n+        <[Adt; std::mem::size_of::<Self::Assoc>()] as Foo>::bar()\n+        //~^ Error: the trait bound\n+    }\n+\n+    fn bar() {}\n+}\n+\n+fn main() {}"}, {"sha": "d894fa90ba9e1c72a67bf84ea293541be55f9895", "filename": "src/test/ui/const-generics/dont-evaluate-array-len-on-err-1.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fconst-generics%2Fdont-evaluate-array-len-on-err-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fconst-generics%2Fdont-evaluate-array-len-on-err-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdont-evaluate-array-len-on-err-1.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `[Adt; _]: Foo` is not satisfied\n+  --> $DIR/dont-evaluate-array-len-on-err-1.rs:15:9\n+   |\n+LL |         <[Adt; std::mem::size_of::<Self::Assoc>()] as Foo>::bar()\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `[Adt; _]`\n+...\n+LL |     fn bar() {}\n+   |     -------- required by `Foo::bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "7208e388a16212a4fa334224f71d693958363e7f", "filename": "src/test/ui/expr/if/if-let.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-let.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -4,8 +4,8 @@ fn macros() {\n     macro_rules! foo{\n         ($p:pat, $e:expr, $b:block) => {{\n             if let $p = $e $b\n-            //~^ WARN irrefutable if-let\n-            //~| WARN irrefutable if-let\n+            //~^ WARN irrefutable `if let`\n+            //~| WARN irrefutable `if let`\n         }}\n     }\n     macro_rules! bar{\n@@ -23,27 +23,27 @@ fn macros() {\n }\n \n pub fn main() {\n-    if let a = 1 { //~ WARN irrefutable if-let\n+    if let a = 1 { //~ WARN irrefutable `if let`\n         println!(\"irrefutable pattern\");\n     }\n \n-    if let a = 1 { //~ WARN irrefutable if-let\n+    if let a = 1 { //~ WARN irrefutable `if let`\n         println!(\"irrefutable pattern\");\n     } else if true {\n-        println!(\"else-if in irrefutable if-let\");\n+        println!(\"else-if in irrefutable `if let`\");\n     } else {\n-        println!(\"else in irrefutable if-let\");\n+        println!(\"else in irrefutable `if let`\");\n     }\n \n     if let 1 = 2 {\n         println!(\"refutable pattern\");\n-    } else if let a = 1 { //~ WARN irrefutable if-let\n+    } else if let a = 1 { //~ WARN irrefutable `if let`\n         println!(\"irrefutable pattern\");\n     }\n \n     if true {\n         println!(\"if\");\n-    } else if let a = 1 { //~ WARN irrefutable if-let\n+    } else if let a = 1 { //~ WARN irrefutable `if let`\n         println!(\"irrefutable pattern\");\n     }\n }"}, {"sha": "468e913a773c05ae89aedce87796c99e0426d7cb", "filename": "src/test/ui/expr/if/if-let.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-let.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -1,4 +1,4 @@\n-warning: irrefutable if-let pattern\n+warning: irrefutable `if let` pattern\n   --> $DIR/if-let.rs:6:13\n    |\n LL |               if let $p = $e $b\n@@ -12,7 +12,7 @@ LL | |     });\n    = note: `#[warn(irrefutable_let_patterns)]` on by default\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-warning: irrefutable if-let pattern\n+warning: irrefutable `if let` pattern\n   --> $DIR/if-let.rs:6:13\n    |\n LL |               if let $p = $e $b\n@@ -25,27 +25,27 @@ LL | |     });\n    |\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-warning: irrefutable if-let pattern\n+warning: irrefutable `if let` pattern\n   --> $DIR/if-let.rs:26:5\n    |\n LL | /     if let a = 1 {\n LL | |         println!(\"irrefutable pattern\");\n LL | |     }\n    | |_____^\n \n-warning: irrefutable if-let pattern\n+warning: irrefutable `if let` pattern\n   --> $DIR/if-let.rs:30:5\n    |\n LL | /     if let a = 1 {\n LL | |         println!(\"irrefutable pattern\");\n LL | |     } else if true {\n-LL | |         println!(\"else-if in irrefutable if-let\");\n+LL | |         println!(\"else-if in irrefutable `if let`\");\n LL | |     } else {\n-LL | |         println!(\"else in irrefutable if-let\");\n+LL | |         println!(\"else in irrefutable `if let`\");\n LL | |     }\n    | |_____^\n \n-warning: irrefutable if-let pattern\n+warning: irrefutable `if let` pattern\n   --> $DIR/if-let.rs:40:12\n    |\n LL |       } else if let a = 1 {\n@@ -54,7 +54,7 @@ LL | |         println!(\"irrefutable pattern\");\n LL | |     }\n    | |_____^\n \n-warning: irrefutable if-let pattern\n+warning: irrefutable `if let` pattern\n   --> $DIR/if-let.rs:46:12\n    |\n LL |       } else if let a = 1 {"}, {"sha": "36db3d1bb9e4793da39e538383a55ea570befdc4", "filename": "src/test/ui/generic-associated-types/constraint-assoc-type-suggestion.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -0,0 +1,17 @@\n+// Test that correct syntax is used in suggestion to constrain associated type\n+\n+#![feature(generic_associated_types)]\n+//~^ WARNING the feature `generic_associated_types` is incomplete\n+\n+trait X {\n+    type Y<T>;\n+}\n+\n+fn f<T: X>(a: T::Y<i32>) {\n+    //~^ HELP consider constraining the associated type `<T as X>::Y<i32>` to `Vec<i32>`\n+    //~| SUGGESTION Y<i32> = Vec<i32>>\n+    let b: Vec<i32> = a;\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "ecf559d9e94a1867d2b6a993e049deb76a24c860", "filename": "src/test/ui/generic-associated-types/constraint-assoc-type-suggestion.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstraint-assoc-type-suggestion.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -0,0 +1,27 @@\n+warning: the feature `generic_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/constraint-assoc-type-suggestion.rs:3:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+\n+error[E0308]: mismatched types\n+  --> $DIR/constraint-assoc-type-suggestion.rs:13:23\n+   |\n+LL |     let b: Vec<i32> = a;\n+   |            --------   ^ expected struct `Vec`, found associated type\n+   |            |\n+   |            expected due to this\n+   |\n+   = note:       expected struct `Vec<i32>`\n+           found associated type `<T as X>::Y<i32>`\n+help: consider constraining the associated type `<T as X>::Y<i32>` to `Vec<i32>`\n+   |\n+LL | fn f<T: X<Y<i32> = Vec<i32>>>(a: T::Y<i32>) {\n+   |          ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "8094450e5e137dfb9c93bd1b9df2f449d95cfe54", "filename": "src/test/ui/generic-associated-types/generic-associated-type-bounds.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-type-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-type-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-type-bounds.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -0,0 +1,35 @@\n+// run-pass\n+\n+#![allow(incomplete_features)]\n+#![feature(generic_associated_types)]\n+\n+pub trait X {\n+    type Y<'a>;\n+    fn m(&self) -> Self::Y<'_>;\n+}\n+\n+impl X for () {\n+    type Y<'a> = &'a ();\n+\n+    fn m(&self) -> Self::Y<'_> {\n+        self\n+    }\n+}\n+\n+fn f(x: &impl for<'a> X<Y<'a> = &'a ()>) -> &() {\n+    x.m()\n+}\n+\n+fn g<T: for<'a> X<Y<'a> = &'a ()>>(x: &T) -> &() {\n+    x.m()\n+}\n+\n+fn h(x: &()) -> &() {\n+    x.m()\n+}\n+\n+fn main() {\n+    f(&());\n+    g(&());\n+    h(&());\n+}"}, {"sha": "5e73a8829862233ca6242d7087979ae55e8a79ec", "filename": "src/test/ui/generic-associated-types/issue-76535.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -1,11 +1,11 @@\n #![feature(generic_associated_types)]\n- //~^ WARNING the feature\n+//~^ WARNING the feature\n \n pub trait SubTrait {}\n \n pub trait SuperTrait {\n     type SubType<'a>: SubTrait;\n-      //~^ ERROR missing generics for associated\n+    //~^ ERROR missing generics for associated\n \n     fn get_sub<'a>(&'a mut self) -> Self::SubType<'a>;\n }\n@@ -36,6 +36,4 @@ impl SuperTrait for SuperStruct {\n \n fn main() {\n     let sub: Box<dyn SuperTrait<SubType = SubStruct>> = Box::new(SuperStruct::new(0));\n-      //~^ ERROR the trait\n-      //~| ERROR the trait\n }"}, {"sha": "17661e0d90a4aecf2b550d95f27498ba38f4ea3e", "filename": "src/test/ui/generic-associated-types/issue-76535.stderr", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -23,41 +23,6 @@ help: use angle brackets to add missing lifetime argument\n LL |     type SubType<'a><'a>: SubTrait;\n    |                 ^^^^\n \n-error[E0038]: the trait `SuperTrait` cannot be made into an object\n-  --> $DIR/issue-76535.rs:38:14\n-   |\n-LL |     let sub: Box<dyn SuperTrait<SubType = SubStruct>> = Box::new(SuperStruct::new(0));\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `SuperTrait` cannot be made into an object\n-   |\n-   = help: consider moving `get_sub` to another trait\n-note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/issue-76535.rs:10:37\n-   |\n-LL | pub trait SuperTrait {\n-   |           ---------- this trait cannot be made into an object...\n-...\n-LL |     fn get_sub<'a>(&'a mut self) -> Self::SubType<'a>;\n-   |                                     ^^^^^^^^^^^^^^^^^ ...because method `get_sub` references the `Self` type in its return type\n-\n-error[E0038]: the trait `SuperTrait` cannot be made into an object\n-  --> $DIR/issue-76535.rs:38:57\n-   |\n-LL |     let sub: Box<dyn SuperTrait<SubType = SubStruct>> = Box::new(SuperStruct::new(0));\n-   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `SuperTrait` cannot be made into an object\n-   |\n-   = help: consider moving `get_sub` to another trait\n-note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/issue-76535.rs:10:37\n-   |\n-LL | pub trait SuperTrait {\n-   |           ---------- this trait cannot be made into an object...\n-...\n-LL |     fn get_sub<'a>(&'a mut self) -> Self::SubType<'a>;\n-   |                                     ^^^^^^^^^^^^^^^^^ ...because method `get_sub` references the `Self` type in its return type\n-   = note: required because of the requirements on the impl of `CoerceUnsized<Box<dyn SuperTrait<SubType = SubStruct<'_>>>>` for `Box<SuperStruct>`\n-   = note: required by cast to type `Box<dyn SuperTrait<SubType = SubStruct<'_>>>`\n-\n-error: aborting due to 3 previous errors; 1 warning emitted\n+error: aborting due to previous error; 1 warning emitted\n \n-Some errors have detailed explanations: E0038, E0107.\n-For more information about an error, try `rustc --explain E0038`.\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "aeb33ca54641cc399daa00c0ef7209194e4aba85", "filename": "src/test/ui/generic-associated-types/issue-79422.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -19,7 +19,7 @@ impl<'a, T> RefCont<'a, T> for Box<T> {\n \n trait MapLike<K, V> {\n     type VRefCont<'a>: RefCont<'a, V>;\n-      //~^ ERROR missing generics\n+    //~^ ERROR missing generics\n     fn get<'a>(&'a self, key: &K) -> Option<Self::VRefCont<'a>>;\n }\n \n@@ -42,6 +42,5 @@ impl<K, V: Default> MapLike<K, V> for Source {\n fn main() {\n     let m = Box::new(std::collections::BTreeMap::<u8, u8>::new())\n         as Box<dyn MapLike<u8, u8, VRefCont = dyn RefCont<'_, u8>>>;\n-      //~^ ERROR the trait\n-      //~^^^ ERROR the trait\n+    //~^^ ERROR type mismatch resolving\n }"}, {"sha": "a119bff03e2906e68bf67f30895e0ea4e9b110a1", "filename": "src/test/ui/generic-associated-types/issue-79422.stderr", "status": "modified", "additions": 8, "deletions": 32, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -14,41 +14,17 @@ help: use angle brackets to add missing lifetime argument\n LL |     type VRefCont<'a><'a>: RefCont<'a, V>;\n    |                  ^^^^\n \n-error[E0038]: the trait `MapLike` cannot be made into an object\n-  --> $DIR/issue-79422.rs:44:12\n-   |\n-LL |         as Box<dyn MapLike<u8, u8, VRefCont = dyn RefCont<'_, u8>>>;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `MapLike` cannot be made into an object\n-   |\n-   = help: consider moving `get` to another trait\n-note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/issue-79422.rs:23:38\n-   |\n-LL | trait MapLike<K, V> {\n-   |       ------- this trait cannot be made into an object...\n-...\n-LL |     fn get<'a>(&'a self, key: &K) -> Option<Self::VRefCont<'a>>;\n-   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...because method `get` references the `Self` type in its return type\n-\n-error[E0038]: the trait `MapLike` cannot be made into an object\n+error[E0271]: type mismatch resolving `<BTreeMap<u8, u8> as MapLike<u8, u8>>::VRefCont<'static> == (dyn RefCont<'_, u8> + 'static)`\n   --> $DIR/issue-79422.rs:43:13\n    |\n LL |     let m = Box::new(std::collections::BTreeMap::<u8, u8>::new())\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `MapLike` cannot be made into an object\n-   |\n-   = help: consider moving `get` to another trait\n-note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/issue-79422.rs:23:38\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn RefCont`, found reference\n    |\n-LL | trait MapLike<K, V> {\n-   |       ------- this trait cannot be made into an object...\n-...\n-LL |     fn get<'a>(&'a self, key: &K) -> Option<Self::VRefCont<'a>>;\n-   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...because method `get` references the `Self` type in its return type\n-   = note: required because of the requirements on the impl of `CoerceUnsized<Box<dyn MapLike<u8, u8, VRefCont = (dyn RefCont<'_, u8> + 'static)>>>` for `Box<BTreeMap<u8, u8>>`\n-   = note: required by cast to type `Box<dyn MapLike<u8, u8, VRefCont = (dyn RefCont<'_, u8> + 'static)>>`\n+   = note: expected trait object `(dyn RefCont<'_, u8> + 'static)`\n+                 found reference `&'static u8`\n+   = note: required for the cast to the object type `dyn MapLike<u8, u8, VRefCont = (dyn RefCont<'_, u8> + 'static)>`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0038, E0107.\n-For more information about an error, try `rustc --explain E0038`.\n+Some errors have detailed explanations: E0107, E0271.\n+For more information about an error, try `rustc --explain E0107`."}, {"sha": "2de4c7b8492a34244977ccc8ec7618220b47ca92", "filename": "src/test/ui/generic-associated-types/method-unsatified-assoc-type-predicate.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -0,0 +1,35 @@\n+// Test that the predicate printed in an unresolved method error prints the\n+// generics for a generic associated type.\n+\n+#![feature(generic_associated_types)]\n+//~^ WARNING the feature `generic_associated_types` is incomplete\n+//~| NOTE `#[warn(incomplete_features)]` on by default\n+//~| NOTE see issue #44265\n+\n+trait X {\n+    type Y<T>;\n+}\n+\n+trait M {\n+    fn f(&self) {}\n+}\n+\n+impl<T: X<Y<i32> = i32>> M for T {}\n+\n+struct S;\n+//~^ NOTE method `f` not found for this\n+//~| NOTE doesn't satisfy `<S as X>::Y<i32> = i32`\n+//~| NOTE doesn't satisfy `S: M`\n+\n+impl X for S {\n+    type Y<T> = bool;\n+}\n+\n+fn f(a: S) {\n+    a.f();\n+    //~^ ERROR the method `f` exists for struct `S`, but its trait bounds were not satisfied\n+    //~| NOTE method cannot be called on `S` due to unsatisfied trait bounds\n+    //~| NOTE the following trait bounds were not satisfied:\n+}\n+\n+fn main() {}"}, {"sha": "c94155d13c344a78f3889f4a2d5cf3a645883a4e", "filename": "src/test/ui/generic-associated-types/method-unsatified-assoc-type-predicate.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -0,0 +1,29 @@\n+warning: the feature `generic_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/method-unsatified-assoc-type-predicate.rs:4:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+\n+error[E0599]: the method `f` exists for struct `S`, but its trait bounds were not satisfied\n+  --> $DIR/method-unsatified-assoc-type-predicate.rs:29:7\n+   |\n+LL | struct S;\n+   | ---------\n+   | |\n+   | method `f` not found for this\n+   | doesn't satisfy `<S as X>::Y<i32> = i32`\n+   | doesn't satisfy `S: M`\n+...\n+LL |     a.f();\n+   |       ^ method cannot be called on `S` due to unsatisfied trait bounds\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `<S as X>::Y<i32> = i32`\n+           which is required by `S: M`\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "0024e127a982c94f65899d927be8c4b733b6d735", "filename": "src/test/ui/generic-associated-types/projection-type-lifetime-mismatch.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-type-lifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-type-lifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-type-lifetime-mismatch.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -0,0 +1,36 @@\n+#![allow(incomplete_features)]\n+#![feature(generic_associated_types)]\n+\n+pub trait X {\n+    type Y<'a>;\n+    fn m(&self) -> Self::Y<'_>;\n+}\n+\n+impl X for () {\n+    type Y<'a> = &'a ();\n+\n+    fn m(&self) -> Self::Y<'_> {\n+        self\n+    }\n+}\n+\n+fn f(x: &impl for<'a> X<Y<'a> = &'a ()>) -> &'static () {\n+    x.m()\n+    //~^ ERROR explicit lifetime required\n+}\n+\n+fn g<T: for<'a> X<Y<'a> = &'a ()>>(x: &T) -> &'static () {\n+    x.m()\n+    //~^ ERROR explicit lifetime required\n+}\n+\n+fn h(x: &()) -> &'static () {\n+    x.m()\n+    //~^ ERROR explicit lifetime required\n+}\n+\n+fn main() {\n+    f(&());\n+    g(&());\n+    h(&());\n+}"}, {"sha": "13b765dfa57191e8d1aa59ea89233afa283c56b8", "filename": "src/test/ui/generic-associated-types/projection-type-lifetime-mismatch.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-type-lifetime-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-type-lifetime-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-type-lifetime-mismatch.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -0,0 +1,27 @@\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/projection-type-lifetime-mismatch.rs:18:5\n+   |\n+LL | fn f(x: &impl for<'a> X<Y<'a> = &'a ()>) -> &'static () {\n+   |         ------------------------------- help: add explicit lifetime `'static` to the type of `x`: `&'static impl for<'a> X<Y<'a> = &'a ()>`\n+LL |     x.m()\n+   |     ^^^^^ lifetime `'static` required\n+\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/projection-type-lifetime-mismatch.rs:23:5\n+   |\n+LL | fn g<T: for<'a> X<Y<'a> = &'a ()>>(x: &T) -> &'static () {\n+   |                                       -- help: add explicit lifetime `'static` to the type of `x`: `&'static T`\n+LL |     x.m()\n+   |     ^^^^^ lifetime `'static` required\n+\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/projection-type-lifetime-mismatch.rs:28:5\n+   |\n+LL | fn h(x: &()) -> &'static () {\n+   |         --- help: add explicit lifetime `'static` to the type of `x`: `&'static ()`\n+LL |     x.m()\n+   |     ^^^^^ lifetime `'static` required\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0621`."}, {"sha": "7bcc7ba752ad04b8c263c5ebf43ee93cea172f6d", "filename": "src/test/ui/generic-associated-types/unsatified-item-lifetime-bound.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatified-item-lifetime-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatified-item-lifetime-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatified-item-lifetime-bound.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -0,0 +1,28 @@\n+#![allow(incomplete_features)]\n+#![feature(generic_associated_types)]\n+\n+pub trait X {\n+    type Y<'a: 'static>;\n+    //~^ WARNING unnecessary lifetime parameter\n+}\n+\n+impl X for () {\n+    type Y<'a> = &'a ();\n+}\n+\n+struct B<'a, T: for<'r> X<Y<'r> = &'r ()>> {\n+    f: <T as X>::Y<'a>,\n+    //~^ ERROR lifetime bound not satisfied\n+}\n+\n+struct C<'a, T: X> {\n+    f: <T as X>::Y<'a>,\n+    //~^ ERROR lifetime bound not satisfied\n+}\n+\n+struct D<'a> {\n+    f: <() as X>::Y<'a>,\n+    //~^ ERROR lifetime bound not satisfied\n+}\n+\n+fn main() {}"}, {"sha": "1c81d33ccfe7280f423c70a63d716a7d2cbb3dfd", "filename": "src/test/ui/generic-associated-types/unsatified-item-lifetime-bound.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatified-item-lifetime-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatified-item-lifetime-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatified-item-lifetime-bound.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -0,0 +1,50 @@\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/unsatified-item-lifetime-bound.rs:5:12\n+   |\n+LL |     type Y<'a: 'static>;\n+   |            ^^^^^^^^^^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+\n+error[E0478]: lifetime bound not satisfied\n+  --> $DIR/unsatified-item-lifetime-bound.rs:14:8\n+   |\n+LL |     f: <T as X>::Y<'a>,\n+   |        ^^^^^^^^^^^^^^^\n+   |\n+note: lifetime parameter instantiated with the lifetime `'a` as defined on the struct at 13:10\n+  --> $DIR/unsatified-item-lifetime-bound.rs:13:10\n+   |\n+LL | struct B<'a, T: for<'r> X<Y<'r> = &'r ()>> {\n+   |          ^^\n+   = note: but lifetime parameter must outlive the static lifetime\n+\n+error[E0478]: lifetime bound not satisfied\n+  --> $DIR/unsatified-item-lifetime-bound.rs:19:8\n+   |\n+LL |     f: <T as X>::Y<'a>,\n+   |        ^^^^^^^^^^^^^^^\n+   |\n+note: lifetime parameter instantiated with the lifetime `'a` as defined on the struct at 18:10\n+  --> $DIR/unsatified-item-lifetime-bound.rs:18:10\n+   |\n+LL | struct C<'a, T: X> {\n+   |          ^^\n+   = note: but lifetime parameter must outlive the static lifetime\n+\n+error[E0478]: lifetime bound not satisfied\n+  --> $DIR/unsatified-item-lifetime-bound.rs:24:8\n+   |\n+LL |     f: <() as X>::Y<'a>,\n+   |        ^^^^^^^^^^^^^^^^\n+   |\n+note: lifetime parameter instantiated with the lifetime `'a` as defined on the struct at 23:10\n+  --> $DIR/unsatified-item-lifetime-bound.rs:23:10\n+   |\n+LL | struct D<'a> {\n+   |          ^^\n+   = note: but lifetime parameter must outlive the static lifetime\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0478`."}, {"sha": "1f3b73f96d8b9c2c965e32f41ddacf00cb9e0c0c", "filename": "src/test/ui/issues/issue-19991.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fissues%2Fissue-19991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fissues%2Fissue-19991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-19991.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -1,4 +1,4 @@\n-// Test if the sugared if-let construct correctly prints \"missing an else clause\" when an else\n+// Test if the sugared `if let` construct correctly prints \"missing an else clause\" when an else\n // clause does not exist, instead of the unsympathetic \"`match` arms have incompatible types\"\n \n fn main() {"}, {"sha": "e14e17c162233ac3008ef32752b00ed9d1395b1a", "filename": "src/test/ui/partialeq_help.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fpartialeq_help.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fpartialeq_help.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpartialeq_help.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -5,6 +5,10 @@ LL |     a == b;\n    |       ^^ no implementation for `&T == T`\n    |\n    = help: the trait `PartialEq<T>` is not implemented for `&T`\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+   |\n+LL | fn foo<T: PartialEq>(a: &T, b: T) where &T: PartialEq<T> {\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "c1cfa4695c9ee2be5b7bfe56368432773840e77f", "filename": "src/test/ui/pattern/usefulness/deny-irrefutable-let-patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdeny-irrefutable-let-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdeny-irrefutable-let-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdeny-irrefutable-let-patterns.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -1,9 +1,9 @@\n #![deny(irrefutable_let_patterns)]\n \n fn main() {\n-    if let _ = 5 {} //~ ERROR irrefutable if-let pattern\n+    if let _ = 5 {} //~ ERROR irrefutable `if let` pattern\n \n-    while let _ = 5 { //~ ERROR irrefutable while-let pattern\n+    while let _ = 5 { //~ ERROR irrefutable `while let` pattern\n         break;\n     }\n }"}, {"sha": "1de30f7db069814f21b7b4da08c33d376d7e17c7", "filename": "src/test/ui/pattern/usefulness/deny-irrefutable-let-patterns.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdeny-irrefutable-let-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdeny-irrefutable-let-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdeny-irrefutable-let-patterns.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -1,4 +1,4 @@\n-error: irrefutable if-let pattern\n+error: irrefutable `if let` pattern\n   --> $DIR/deny-irrefutable-let-patterns.rs:4:5\n    |\n LL |     if let _ = 5 {}\n@@ -10,7 +10,7 @@ note: the lint level is defined here\n LL | #![deny(irrefutable_let_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: irrefutable while-let pattern\n+error: irrefutable `while let` pattern\n   --> $DIR/deny-irrefutable-let-patterns.rs:6:5\n    |\n LL | /     while let _ = 5 {"}, {"sha": "d921367b91775f3c114471e5e16b170f1025d0f4", "filename": "src/test/ui/rfc-2294-if-let-guard/warns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Fwarns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Fwarns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Fwarns.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -5,7 +5,7 @@\n fn irrefutable_let_guard() {\n     match Some(()) {\n         Some(x) if let () = x => {}\n-        //~^ ERROR irrefutable if-let guard\n+        //~^ ERROR irrefutable `if let` guard\n         _ => {}\n     }\n }"}, {"sha": "33fa25d32fb1b4706dd398d7d2efafc886b5f913", "filename": "src/test/ui/rfc-2294-if-let-guard/warns.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Fwarns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Fwarns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2294-if-let-guard%2Fwarns.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -1,4 +1,4 @@\n-error: irrefutable if-let guard\n+error: irrefutable `if let` guard\n   --> $DIR/warns.rs:7:24\n    |\n LL |         Some(x) if let () = x => {}"}, {"sha": "0e8a774bce37fde91014a3f92690b8b41f0a6ad8", "filename": "src/test/ui/specialization/deafult-associated-type-bound-2.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-2.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -18,6 +18,10 @@ LL |     default type U = &'static B;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `&'static B == B`\n    |\n    = help: the trait `PartialEq<B>` is not implemented for `&'static B`\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+   |\n+LL | impl<B: 'static, T> X<B> for T where &'static B: PartialEq<B> {\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "03fb80bb90abcf6234c5c3c90fb791aaf78f9c6d", "filename": "src/test/ui/stability-attribute/stability-attribute-sanity.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -116,5 +116,5 @@ LL | #[rustc_deprecated(since = \"a\", reason = \"text\")]\n \n error: aborting due to 19 previous errors\n \n-Some errors have detailed explanations: E0539, E0541, E0542, E0543, E0546, E0547, E0550.\n+Some errors have detailed explanations: E0539, E0541, E0542, E0543, E0546, E0547, E0549, E0550.\n For more information about an error, try `rustc --explain E0539`."}, {"sha": "a2bc6fd09b5663e5a8866822383338a40e9b02d0", "filename": "src/test/ui/suggestions/suggest-change-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-change-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-change-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-change-mut.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -2,7 +2,7 @@\n \n use std::io::{BufRead, BufReader, Read, Write};\n \n-fn issue_81421<T: Read + Write>(mut stream: T) {\n+fn issue_81421<T: Read + Write>(mut stream: T) { //~ HELP consider introducing a `where` bound\n     let initial_message = format!(\"Hello world\");\n     let mut buffer: Vec<u8> = Vec::new();\n     let bytes_written = stream.write_all(initial_message.as_bytes());"}, {"sha": "9b8181647a0c15790715e665241946d0e47f7b5a", "filename": "src/test/ui/suggestions/suggest-change-mut.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-change-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-change-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-change-mut.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -9,6 +9,10 @@ help: consider removing the leading `&`-reference\n    |\n LL |         let mut stream_reader = BufReader::new(stream);\n    |                                               --\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+   |\n+LL | fn issue_81421<T: Read + Write>(mut stream: T) where &T: std::io::Read {\n+   |                                                ^^^^^^^^^^^^^^^^^^^^^^^\n help: consider changing this borrow's mutability\n    |\n LL |         let mut stream_reader = BufReader::new(&mut stream);"}, {"sha": "86d589ffa9e31f726d99384540d1b0770e5357ba", "filename": "src/test/ui/traits/suggest-where-clause.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Ftraits%2Fsuggest-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Ftraits%2Fsuggest-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-where-clause.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -35,6 +35,10 @@ LL |     <u64 as From<T>>::from;\n    |     ^^^^^^^^^^^^^^^^^^^^^^ the trait `From<T>` is not implemented for `u64`\n    |\n    = note: required by `from`\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+   |\n+LL | fn check<T: Iterator, U: ?Sized>() where u64: From<T> {\n+   |                                    ^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `u64: From<<T as Iterator>::Item>` is not satisfied\n   --> $DIR/suggest-where-clause.rs:18:5\n@@ -43,6 +47,10 @@ LL |     <u64 as From<<T as Iterator>::Item>>::from;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `From<<T as Iterator>::Item>` is not implemented for `u64`\n    |\n    = note: required by `from`\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+   |\n+LL | fn check<T: Iterator, U: ?Sized>() where u64: From<<T as Iterator>::Item> {\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `Misc<_>: From<T>` is not satisfied\n   --> $DIR/suggest-where-clause.rs:23:5"}, {"sha": "b9a49b47c8ff5911594d7b805de37357742f3d5d", "filename": "src/test/ui/while-let.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fwhile-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fwhile-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhile-let.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -5,8 +5,8 @@ fn macros() {\n     macro_rules! foo{\n         ($p:pat, $e:expr, $b:block) => {{\n             while let $p = $e $b\n-            //~^ WARN irrefutable while-let\n-            //~| WARN irrefutable while-let\n+            //~^ WARN irrefutable `while let`\n+            //~| WARN irrefutable `while let`\n         }}\n     }\n     macro_rules! bar{\n@@ -24,7 +24,7 @@ fn macros() {\n }\n \n pub fn main() {\n-    while let _a = 1 { //~ WARN irrefutable while-let\n+    while let _a = 1 { //~ WARN irrefutable `while let`\n         println!(\"irrefutable pattern\");\n         break;\n     }"}, {"sha": "6538b9fbe6f28654c975af55e6092af072350b55", "filename": "src/test/ui/while-let.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fwhile-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftest%2Fui%2Fwhile-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhile-let.stderr?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -1,4 +1,4 @@\n-warning: irrefutable while-let pattern\n+warning: irrefutable `while let` pattern\n   --> $DIR/while-let.rs:7:13\n    |\n LL |               while let $p = $e $b\n@@ -12,7 +12,7 @@ LL | |     });\n    = note: `#[warn(irrefutable_let_patterns)]` on by default\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-warning: irrefutable while-let pattern\n+warning: irrefutable `while let` pattern\n   --> $DIR/while-let.rs:7:13\n    |\n LL |               while let $p = $e $b\n@@ -25,7 +25,7 @@ LL | |     });\n    |\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-warning: irrefutable while-let pattern\n+warning: irrefutable `while let` pattern\n   --> $DIR/while-let.rs:27:5\n    |\n LL | /     while let _a = 1 {"}, {"sha": "1c9373a756c8896d3de7472131aa8839f3d16206", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0148b971c921a0831fbf3357e5936eec724e3566/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=0148b971c921a0831fbf3357e5936eec724e3566", "patch": "@@ -340,7 +340,7 @@ declare_clippy_lint! {\n     /// ```\n     pub WHILE_LET_ON_ITERATOR,\n     style,\n-    \"using a while-let loop instead of a for loop on an iterator\"\n+    \"using a `while let` loop instead of a for loop on an iterator\"\n }\n \n declare_clippy_lint! {"}]}