{"sha": "788c9ccc938ac0384fd06a071806502121af1a5a", "node_id": "C_kwDOAAsO6NoAKDc4OGM5Y2NjOTM4YWMwMzg0ZmQwNmEwNzE4MDY1MDIxMjFhZjFhNWE", "commit": {"author": {"name": "ThibsG", "email": "thibsg@pm.me", "date": "2021-09-12T09:40:14Z"}, "committer": {"name": "ThibsG", "email": "thibsg@pm.me", "date": "2021-11-20T08:40:11Z"}, "message": "Applying refactoring for simplified code", "tree": {"sha": "ea161811248f8427a0fcd38245a4328a2b6553ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea161811248f8427a0fcd38245a4328a2b6553ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/788c9ccc938ac0384fd06a071806502121af1a5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/788c9ccc938ac0384fd06a071806502121af1a5a", "html_url": "https://github.com/rust-lang/rust/commit/788c9ccc938ac0384fd06a071806502121af1a5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/788c9ccc938ac0384fd06a071806502121af1a5a/comments", "author": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91dd9c46de11b9abeb391d5b19707c5e7ddfef98", "url": "https://api.github.com/repos/rust-lang/rust/commits/91dd9c46de11b9abeb391d5b19707c5e7ddfef98", "html_url": "https://github.com/rust-lang/rust/commit/91dd9c46de11b9abeb391d5b19707c5e7ddfef98"}], "stats": {"total": 47, "additions": 22, "deletions": 25}, "files": [{"sha": "a5e6a8df03f30df40c2bc0f9d02351e6be9b630d", "filename": "clippy_lints/src/methods/search_is_some.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/788c9ccc938ac0384fd06a071806502121af1a5a/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788c9ccc938ac0384fd06a071806502121af1a5a/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs?ref=788c9ccc938ac0384fd06a071806502121af1a5a", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::{get_parent_expr_for_hir, is_trait_method, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::{self, Expr, ExprKind, HirId, PatKind};\n+use rustc_hir::{self, ExprKind, HirId, PatKind};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::hir::place::ProjectionKind;\n@@ -229,26 +229,23 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n             } else {\n                 // cases where a parent call is using the item\n                 // i.e.: suggest `.contains(&x)` for `.find(|x| [1, 2, 3].contains(x)).is_none()`\n-                let parent_expr = get_parent_expr_for_hir(self.cx, cmt.hir_id);\n-                if let Some(Expr { hir_id: _, kind, .. }) = parent_expr {\n-                    if let ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args, _) = kind {\n-                        let args_to_handle = args.iter().filter(|arg| arg.hir_id == cmt.hir_id).collect::<Vec<_>>();\n-                        if !args_to_handle.is_empty() {\n-                            for arg in &args_to_handle {\n-                                let arg_ty_kind = self.cx.typeck_results().expr_ty(arg).kind();\n-                                if matches!(arg_ty_kind, ty::Ref(_, _, Mutability::Not)) {\n-                                    let start_span = Span::new(self.next_pos, span.lo(), span.ctxt());\n-                                    let start_snip =\n-                                        snippet_with_applicability(self.cx, start_span, \"..\", &mut self.applicability);\n+                if let Some(parent_expr) = get_parent_expr_for_hir(self.cx, cmt.hir_id) {\n+                    if let ExprKind::Call(..) | ExprKind::MethodCall(..) = parent_expr.kind {\n+                        let expr = self.cx.tcx.hir().expect_expr(cmt.hir_id);\n+                        let arg_ty_kind = self.cx.typeck_results().expr_ty(expr).kind();\n \n-                                    self.suggestion_start.push_str(&format!(\"{}&{}\", start_snip, ident_str));\n-                                    self.next_pos = span.hi();\n-                                } else {\n-                                    self.applicability = Applicability::Unspecified;\n-                                }\n-                            }\n-                            return;\n+                        // Note: this should always be true, as `find` only gives us a reference which are not mutable\n+                        if matches!(arg_ty_kind, ty::Ref(_, _, Mutability::Not)) {\n+                            let start_span = Span::new(self.next_pos, span.lo(), span.ctxt());\n+                            let start_snip =\n+                                snippet_with_applicability(self.cx, start_span, \"..\", &mut self.applicability);\n+\n+                            self.suggestion_start.push_str(&format!(\"{}&{}\", start_snip, ident_str));\n+                            self.next_pos = span.hi();\n+                        } else {\n+                            self.applicability = Applicability::Unspecified;\n                         }\n+                        return;\n                     }\n                 }\n \n@@ -290,17 +287,17 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n                             },\n                             _ => false,\n                         },\n-                        ProjectionKind::Index => false, /* handled previously */\n-                        // note: unable to capture `Subslice` kind in tests\n-                        ProjectionKind::Subslice => false,\n+                        // handled previously\n+                        ProjectionKind::Index |\n+                            // note: unable to trigger `Subslice` kind in tests\n+                            ProjectionKind::Subslice => false,\n                         ProjectionKind::Deref => {\n                             // explicit deref for arrays should be avoided in the suggestion\n                             // i.e.: `|sub| *sub[1..4].len() == 3` is not expected\n                             match cmt.place.ty_before_projection(i).kind() {\n                                 // dereferencing an array (i.e.: `|sub| sub[1..4].len() == 3`)\n-                                ty::Ref(_, inner, _) => match inner.kind() {\n-                                    ty::Ref(_, innermost, _) if innermost.is_array() => true,\n-                                    _ => false,\n+                                ty::Ref(_, inner, _) => {\n+                                    matches!(inner.kind(), ty::Ref(_, innermost, _) if innermost.is_array())\n                                 },\n                                 _ => false,\n                             }"}]}