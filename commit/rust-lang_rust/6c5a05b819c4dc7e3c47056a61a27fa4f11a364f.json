{"sha": "6c5a05b819c4dc7e3c47056a61a27fa4f11a364f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNWEwNWI4MTljNGRjN2UzYzQ3MDU2YTYxYTI3ZmE0ZjExYTM2NGY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-30T01:11:03Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-30T01:11:41Z"}, "message": "rustc: Implement the block syntax discussed on the mailing list", "tree": {"sha": "f0f8e89877aceb4bb1c906925c270d38c01be372", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0f8e89877aceb4bb1c906925c270d38c01be372"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f", "html_url": "https://github.com/rust-lang/rust/commit/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c4e975099f22d6438af0fb3e69f79c433156422", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c4e975099f22d6438af0fb3e69f79c433156422", "html_url": "https://github.com/rust-lang/rust/commit/6c4e975099f22d6438af0fb3e69f79c433156422"}], "stats": {"total": 188, "additions": 144, "deletions": 44}, "files": [{"sha": "a1670c700ad26263d54809b3d5955f3df1e9abee", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=6c5a05b819c4dc7e3c47056a61a27fa4f11a364f", "patch": "@@ -39,6 +39,7 @@ type crate_ = rec(_mod module);\n \n type block = spanned[block_];\n type block_ = rec(vec[@stmt] stmts,\n+                  option.t[@expr] expr,\n                   hashmap[ident,uint] index);\n \n type pat = spanned[pat_];"}, {"sha": "b23fa0aad72d2d98a35bc561dc674c7fa799eee5", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 99, "deletions": 18, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=6c5a05b819c4dc7e3c47056a61a27fa4f11a364f", "patch": "@@ -761,7 +761,6 @@ impure fn parse_do_while_expr(parser p) -> @ast.expr {\n     expect (p, token.LPAREN);\n     auto cond = parse_expr(p);\n     expect(p, token.RPAREN);\n-    expect(p, token.SEMI);\n     hi = cond.span;\n     ret @spanned(lo, hi, ast.expr_do_while(body, cond, ast.ann_none));\n }\n@@ -891,7 +890,6 @@ impure fn parse_let(parser p) -> @ast.decl {\n     auto init = parse_initializer(p);\n \n     auto hi = p.get_span();\n-    expect(p, token.SEMI);\n \n     let ast.local local = rec(ty = some(ty),\n                               infer = false,\n@@ -911,7 +909,6 @@ impure fn parse_auto(parser p) -> @ast.decl {\n     auto init = parse_initializer(p);\n \n     auto hi = p.get_span();\n-    expect(p, token.SEMI);\n \n     let ast.local local = rec(ty = none[@ast.ty],\n                               infer = true,\n@@ -931,7 +928,6 @@ impure fn parse_stmt(parser p) -> @ast.stmt {\n             p.bump();\n             auto e = parse_expr(p);\n             auto hi = p.get_span();\n-            expect(p, token.SEMI);\n             ret @spanned(lo, hi, ast.stmt_log(e));\n         }\n \n@@ -941,7 +937,6 @@ impure fn parse_stmt(parser p) -> @ast.stmt {\n                 case (token.LPAREN) {\n                     auto e = parse_expr(p);\n                     auto hi = p.get_span();\n-                    expect(p, token.SEMI);\n                     ret @spanned(lo, hi, ast.stmt_check_expr(e));\n                 }\n                 case (_) {\n@@ -954,13 +949,11 @@ impure fn parse_stmt(parser p) -> @ast.stmt {\n             p.bump();\n             alt (p.peek()) {\n                 case (token.SEMI) {\n-                    p.bump();\n                     ret @spanned(lo, p.get_span(),\n                                  ast.stmt_ret(none[@ast.expr]));\n                 }\n                 case (_) {\n                     auto e = parse_expr(p);\n-                    expect(p, token.SEMI);\n                     ret @spanned(lo, e.span,\n                                  ast.stmt_ret(some[@ast.expr](e)));\n                 }\n@@ -1012,24 +1005,17 @@ impure fn parse_stmt(parser p) -> @ast.stmt {\n         case (_) {\n             auto e = parse_expr(p);\n             auto hi = p.get_span();\n-            expect(p, token.SEMI);\n             ret @spanned(lo, hi, ast.stmt_expr(e));\n         }\n     }\n     p.err(\"expected statement\");\n     fail;\n }\n \n-impure fn parse_block(parser p) -> ast.block {\n-    auto f = parse_stmt;\n-    // FIXME: passing parse_stmt as an lval doesn't work at the moment.\n-    auto stmts = parse_seq[@ast.stmt](token.LBRACE,\n-                                      token.RBRACE,\n-                                      none[token.token],\n-                                      f, p);\n+fn index_block(vec[@ast.stmt] stmts, option.t[@ast.expr] expr) -> ast.block_ {\n     auto index = new_str_hash[uint]();\n     auto u = 0u;\n-    for (@ast.stmt s in stmts.node) {\n+    for (@ast.stmt s in stmts) {\n         // FIXME: typestate bug requires we do this up top, not\n         // down below loop. Sigh.\n         u += 1u;\n@@ -1056,8 +1042,103 @@ impure fn parse_block(parser p) -> ast.block {\n             }\n         }\n     }\n-    let ast.block_ b = rec(stmts=stmts.node, index=index);\n-    ret spanned(stmts.span, stmts.span, b);\n+    ret rec(stmts=stmts, expr=expr, index=index);\n+}\n+\n+fn stmt_to_expr(@ast.stmt stmt) -> option.t[@ast.expr] {\n+    alt (stmt.node) {\n+        case (ast.stmt_expr(?e)) { ret some[@ast.expr](e); }\n+        case (_) { /* fall through */ }\n+    }\n+    ret none[@ast.expr];\n+}\n+\n+fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n+    alt (stmt.node) {\n+        case (ast.stmt_decl(_))                 { ret true; } // FIXME\n+        case (ast.stmt_ret(_))                  { ret true; }\n+        case (ast.stmt_log(_))                  { ret true; }\n+        case (ast.stmt_check_expr(_))           { ret true; }\n+        case (ast.stmt_expr(?e)) {\n+            alt (e.node) {\n+                case (ast.expr_vec(_,_))        { ret true; }\n+                case (ast.expr_tup(_,_))        { ret true; }\n+                case (ast.expr_rec(_,_))        { ret true; }\n+                case (ast.expr_call(_,_,_))     { ret true; }\n+                case (ast.expr_binary(_,_,_,_)) { ret true; }\n+                case (ast.expr_unary(_,_,_))    { ret true; }\n+                case (ast.expr_lit(_,_))        { ret true; }\n+                case (ast.expr_cast(_,_,_))     { ret true; }\n+                case (ast.expr_if(_,_,_,_))     { ret false; }\n+                case (ast.expr_while(_,_,_))    { ret false; }\n+                case (ast.expr_do_while(_,_,_)) { ret false; }\n+                case (ast.expr_alt(_,_,_))      { ret false; }\n+                case (ast.expr_block(_,_))      { ret false; }\n+                case (ast.expr_assign(_,_,_))   { ret true; }\n+                case (ast.expr_field(_,_,_))    { ret true; }\n+                case (ast.expr_index(_,_,_))    { ret true; }\n+                case (ast.expr_name(_,_,_))     { ret true; }\n+                case (_)                        { fail; }\n+            }\n+        }\n+        case (_)                                { fail; }\n+    }\n+}\n+\n+impure fn parse_block(parser p) -> ast.block {\n+    auto lo = p.get_span();\n+\n+    let vec[@ast.stmt] stmts = vec();\n+    let option.t[@ast.expr] expr = none[@ast.expr];\n+\n+    expect(p, token.LBRACE);\n+    while (p.peek() != token.RBRACE) {\n+        alt (p.peek()) {\n+            case (token.RBRACE) {\n+                // empty; fall through to next iteration\n+            }\n+            case (token.SEMI) {\n+                p.bump();\n+                // empty\n+            }\n+            case (_) {\n+                auto stmt = parse_stmt(p);\n+                alt (stmt_to_expr(stmt)) {\n+                    case (some[@ast.expr](?e)) {\n+                        alt (p.peek()) {\n+                            case (token.SEMI) {\n+                                p.bump();\n+                                stmts += vec(stmt);\n+                            }\n+                            case (token.RBRACE) { expr = some(e); }\n+                            case (?t) {\n+                                if (stmt_ends_with_semi(stmt)) {\n+                                    p.err(\"expected ';' or '}' after \" +\n+                                          \"expression but found \" +\n+                                          token.to_str(t));\n+                                    fail;\n+                                }\n+                                stmts += vec(stmt);\n+                            }\n+                        }\n+                    }\n+                    case (none[@ast.expr]) {\n+                        // Not an expression statement.\n+                        stmts += vec(stmt);\n+                        if (stmt_ends_with_semi(stmt)) {\n+                            expect(p, token.SEMI);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    p.bump();\n+    auto hi = p.get_span();\n+\n+    auto bloc = index_block(stmts, expr);\n+    ret spanned[ast.block_](lo, hi, bloc);\n }\n \n impure fn parse_ty_param(parser p) -> ast.ty_param {"}, {"sha": "c97dceb4009c947c768008eaa84fc728e8d510d1", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=6c5a05b819c4dc7e3c47056a61a27fa4f11a364f", "patch": "@@ -529,7 +529,19 @@ fn fold_block[ENV](&ENV env, ast_fold[ENV] fld, &block blk) -> block {\n     for (@ast.stmt s in blk.node.stmts) {\n         append[@ast.stmt](stmts, fold_stmt[ENV](env_, fld, s));\n     }\n-    ret respan(blk.span, rec(stmts=stmts with blk.node));\n+\n+    auto expr = none[@ast.expr];\n+    alt (blk.node.expr) {\n+        case (some[@ast.expr](?e)) {\n+            expr = some[@ast.expr](fold_expr[ENV](env_, fld, e));\n+        }\n+        case (none[@ast.expr]) {\n+            // empty\n+        }\n+    }\n+\n+    // FIXME: should we reindex?\n+    ret respan(blk.span, rec(stmts=stmts, expr=expr, index=blk.node.index));\n }\n \n fn fold_arg[ENV](&ENV env, ast_fold[ENV] fld, &arg a) -> arg {"}, {"sha": "8caaf5f73093f669495a4c96a1d9693144cc4864", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6c5a05b819c4dc7e3c47056a61a27fa4f11a364f", "patch": "@@ -1488,6 +1488,19 @@ impure fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n         }\n     }\n \n+    alt (b.node.expr) {\n+        case (some[@ast.expr](?e)) {\n+            r = trans_expr(bcx, e);\n+            bcx = r.bcx;\n+            if (is_terminated(bcx)) {\n+                ret r;\n+            }\n+        }\n+        case (none[@ast.expr]) {\n+            r = res(bcx, C_nil());\n+        }\n+    }\n+\n     bcx = trans_block_cleanups(bcx, bcx);\n     ret res(bcx, r.val);\n }"}, {"sha": "58f723bd8a7a8feac681b9dd3f7607624713ed2e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a05b819c4dc7e3c47056a61a27fa4f11a364f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=6c5a05b819c4dc7e3c47056a61a27fa4f11a364f", "patch": "@@ -398,19 +398,6 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n \n // Expression utilities\n \n-fn last_expr_of_block(&ast.block bloc) -> option.t[@ast.expr] {\n-    auto len = _vec.len[@ast.stmt](bloc.node.stmts);\n-    if (len == 0u) {\n-        ret none[@ast.expr];\n-    }\n-    auto last_stmt = bloc.node.stmts.(len - 1u);\n-    alt (last_stmt.node) {\n-        case (ast.stmt_expr(?e)) { ret some[@ast.expr](e); }\n-        case (_)                 { ret none[@ast.expr]; }\n-    }\n-}\n-\n-\n fn field_num(session.session sess, &span sp, &ast.ident id) -> uint {\n     let uint accum = 0u;\n     let uint i = 0u;\n@@ -546,7 +533,7 @@ fn stmt_ty(@ast.stmt s) -> @ty {\n }\n \n fn block_ty(&ast.block b) -> @ty {\n-    alt (last_expr_of_block(b)) {\n+    alt (b.node.expr) {\n         case (some[@ast.expr](?e)) { ret expr_ty(e); }\n         case (none[@ast.expr])     { ret plain_ty(ty_nil); }\n     }\n@@ -965,18 +952,12 @@ fn demand_expr(&fn_ctxt fcx, @ty expected, @ast.expr e) -> @ast.expr {\n \n // Type unification over typed blocks.\n fn demand_block(&fn_ctxt fcx, @ty expected, &ast.block bloc) -> ast.block {\n-    alt (last_expr_of_block(bloc)) {\n+    alt (bloc.node.expr) {\n         case (some[@ast.expr](?e_0)) {\n             auto e_1 = demand_expr(fcx, expected, e_0);\n-\n-            auto len = _vec.len[@ast.stmt](bloc.node.stmts);\n-            auto last_stmt_0 = bloc.node.stmts.(len - 1u);\n-            auto prev_stmts = _vec.pop[@ast.stmt](bloc.node.stmts);\n-            auto last_stmt_1 = @fold.respan[ast.stmt_](last_stmt_0.span,\n-                                                       ast.stmt_expr(e_1));\n-            auto stmts_1 = prev_stmts + vec(last_stmt_1);\n-\n-            auto block_ = rec(stmts=stmts_1, index=bloc.node.index);\n+            auto block_ = rec(stmts=bloc.node.stmts,\n+                              expr=some[@ast.expr](e_1),\n+                              index=bloc.node.index);\n             ret fold.respan[ast.block_](bloc.span, block_);\n         }\n         case (none[@ast.expr]) {\n@@ -1386,8 +1367,18 @@ fn check_block(&fn_ctxt fcx, &ast.block block) -> ast.block {\n     for (@ast.stmt s in block.node.stmts) {\n         append[@ast.stmt](stmts, check_stmt(fcx, s));\n     }\n+\n+    auto expr = none[@ast.expr];\n+    alt (block.node.expr) {\n+        case (none[@ast.expr]) { /* empty */ }\n+        case (some[@ast.expr](?e)) {\n+            expr = some[@ast.expr](check_expr(fcx, e));\n+        }\n+    }\n+\n     ret fold.respan[ast.block_](block.span,\n-                                rec(stmts=stmts, index=block.node.index));\n+                                rec(stmts=stmts, expr=expr,\n+                                    index=block.node.index));\n }\n \n fn check_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n@@ -1411,8 +1402,10 @@ fn check_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n                           locals = local_ty_table,\n                           ccx = ccx);\n \n+    // TODO: Make sure the type of the block agrees with the function type.\n     auto block_t = check_block(fcx, f.body);\n     auto block_wb = writeback(fcx, block_t);\n+\n     auto fn_t = rec(inputs=f.inputs, output=f.output, body=block_wb);\n     auto item = ast.item_fn(ident, fn_t, ty_params, id, fn_ann);\n     ret @fold.respan[ast.item_](sp, item);"}]}