{"sha": "053874eecc9806f36195c35a7fad9c8878b0788e", "node_id": "C_kwDOAAsO6NoAKDA1Mzg3NGVlY2M5ODA2ZjM2MTk1YzM1YTdmYWQ5Yzg4NzhiMDc4OGU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-08-25T02:25:44Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-09-01T21:26:17Z"}, "message": "Clean up THIR patterns.\n\n`thir::Pat::kind` is a `Box<PatKind>`, which doesn't follow the usual\npattern in AST/HIR/THIR which is that the \"kind\" enum for a node is\nstored inline within the parent struct.\n\nThis commit makes the `PatKind` directly inline within the `Pat`. This\nrequires using `Box<Pat>` in all the types that hold a `Pat.\n\nIdeally, `Pat` would be stored in `Thir` like `Expr` and `Stmt` and\nreferred to with a `PatId` rather than `Box<Pat>`. But this is hard to\ndo because lots of `Pat`s get created after the destruction of the `Cx`\nthat does normal THIR building. But this does get us a step closer to\n`PatId`, because all the `Box<Pat>` occurrences would be replaced with\n`PatId` if `PatId` ever happened.\n\nAt 128 bytes, `Pat` is large. Subsequent commits will shrink it.", "tree": {"sha": "d9cf807bb56580071d449dc21decb2da8f31a1ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9cf807bb56580071d449dc21decb2da8f31a1ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/053874eecc9806f36195c35a7fad9c8878b0788e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/053874eecc9806f36195c35a7fad9c8878b0788e", "html_url": "https://github.com/rust-lang/rust/commit/053874eecc9806f36195c35a7fad9c8878b0788e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/053874eecc9806f36195c35a7fad9c8878b0788e/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9af618b62e91b45d61f41548f24ba60b834e362b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9af618b62e91b45d61f41548f24ba60b834e362b", "html_url": "https://github.com/rust-lang/rust/commit/9af618b62e91b45d61f41548f24ba60b834e362b"}], "stats": {"total": 244, "additions": 123, "deletions": 121}, "files": [{"sha": "99d72f70ba68acc5977f571e645ccc4293ece3aa", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=053874eecc9806f36195c35a7fad9c8878b0788e", "patch": "@@ -180,7 +180,7 @@ pub enum StmtKind<'tcx> {\n         /// `let <PAT> = ...`\n         ///\n         /// If a type annotation is included, it is added as an ascription pattern.\n-        pattern: Pat<'tcx>,\n+        pattern: Box<Pat<'tcx>>,\n \n         /// `let pat: ty = <INIT>`\n         initializer: Option<ExprId>,\n@@ -301,7 +301,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Let {\n         expr: ExprId,\n-        pat: Pat<'tcx>,\n+        pat: Box<Pat<'tcx>>,\n     },\n     /// A `match` expression.\n     Match {\n@@ -467,7 +467,7 @@ pub struct FruInfo<'tcx> {\n /// A `match` arm.\n #[derive(Clone, Debug, HashStable)]\n pub struct Arm<'tcx> {\n-    pub pattern: Pat<'tcx>,\n+    pub pattern: Box<Pat<'tcx>>,\n     pub guard: Option<Guard<'tcx>>,\n     pub body: ExprId,\n     pub lint_level: LintLevel,\n@@ -479,7 +479,7 @@ pub struct Arm<'tcx> {\n #[derive(Clone, Debug, HashStable)]\n pub enum Guard<'tcx> {\n     If(ExprId),\n-    IfLet(Pat<'tcx>, ExprId),\n+    IfLet(Box<Pat<'tcx>>, ExprId),\n }\n \n #[derive(Copy, Clone, Debug, HashStable)]\n@@ -534,19 +534,19 @@ pub enum BindingMode {\n #[derive(Clone, Debug, HashStable)]\n pub struct FieldPat<'tcx> {\n     pub field: Field,\n-    pub pattern: Pat<'tcx>,\n+    pub pattern: Box<Pat<'tcx>>,\n }\n \n #[derive(Clone, Debug, HashStable)]\n pub struct Pat<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub span: Span,\n-    pub kind: Box<PatKind<'tcx>>,\n+    pub kind: PatKind<'tcx>,\n }\n \n impl<'tcx> Pat<'tcx> {\n     pub fn wildcard_from_ty(ty: Ty<'tcx>) -> Self {\n-        Pat { ty, span: DUMMY_SP, kind: Box::new(PatKind::Wild) }\n+        Pat { ty, span: DUMMY_SP, kind: PatKind::Wild }\n     }\n }\n \n@@ -581,7 +581,7 @@ pub enum PatKind<'tcx> {\n \n     AscribeUserType {\n         ascription: Ascription<'tcx>,\n-        subpattern: Pat<'tcx>,\n+        subpattern: Box<Pat<'tcx>>,\n     },\n \n     /// `x`, `ref x`, `x @ P`, etc.\n@@ -591,7 +591,7 @@ pub enum PatKind<'tcx> {\n         mode: BindingMode,\n         var: LocalVarId,\n         ty: Ty<'tcx>,\n-        subpattern: Option<Pat<'tcx>>,\n+        subpattern: Option<Box<Pat<'tcx>>>,\n         /// Is this the leftmost occurrence of the binding, i.e., is `var` the\n         /// `HirId` of this pattern?\n         is_primary: bool,\n@@ -614,7 +614,7 @@ pub enum PatKind<'tcx> {\n \n     /// `box P`, `&P`, `&mut P`, etc.\n     Deref {\n-        subpattern: Pat<'tcx>,\n+        subpattern: Box<Pat<'tcx>>,\n     },\n \n     /// One of the following:\n@@ -634,22 +634,22 @@ pub enum PatKind<'tcx> {\n     /// irrefutable when there is a slice pattern and both `prefix` and `suffix` are empty.\n     /// e.g., `&[ref xs @ ..]`.\n     Slice {\n-        prefix: Vec<Pat<'tcx>>,\n-        slice: Option<Pat<'tcx>>,\n-        suffix: Vec<Pat<'tcx>>,\n+        prefix: Vec<Box<Pat<'tcx>>>,\n+        slice: Option<Box<Pat<'tcx>>>,\n+        suffix: Vec<Box<Pat<'tcx>>>,\n     },\n \n     /// Fixed match against an array; irrefutable.\n     Array {\n-        prefix: Vec<Pat<'tcx>>,\n-        slice: Option<Pat<'tcx>>,\n-        suffix: Vec<Pat<'tcx>>,\n+        prefix: Vec<Box<Pat<'tcx>>>,\n+        slice: Option<Box<Pat<'tcx>>>,\n+        suffix: Vec<Box<Pat<'tcx>>>,\n     },\n \n     /// An or-pattern, e.g. `p | q`.\n     /// Invariant: `pats.len() >= 2`.\n     Or {\n-        pats: Vec<Pat<'tcx>>,\n+        pats: Vec<Box<Pat<'tcx>>>,\n     },\n }\n \n@@ -674,7 +674,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n         };\n         let mut start_or_comma = || start_or_continue(\", \");\n \n-        match *self.kind {\n+        match self.kind {\n             PatKind::Wild => write!(f, \"_\"),\n             PatKind::AscribeUserType { ref subpattern, .. } => write!(f, \"{}: _\", subpattern),\n             PatKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n@@ -695,7 +695,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n                 Ok(())\n             }\n             PatKind::Variant { ref subpatterns, .. } | PatKind::Leaf { ref subpatterns } => {\n-                let variant = match *self.kind {\n+                let variant = match self.kind {\n                     PatKind::Variant { adt_def, variant_index, .. } => {\n                         Some(adt_def.variant(variant_index))\n                     }\n@@ -714,7 +714,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n \n                         let mut printed = 0;\n                         for p in subpatterns {\n-                            if let PatKind::Wild = *p.pattern.kind {\n+                            if let PatKind::Wild = p.pattern.kind {\n                                 continue;\n                             }\n                             let name = variant.fields[p.field.index()].name;\n@@ -780,7 +780,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n                 }\n                 if let Some(ref slice) = *slice {\n                     write!(f, \"{}\", start_or_comma())?;\n-                    match *slice.kind {\n+                    match slice.kind {\n                         PatKind::Wild => {}\n                         _ => write!(f, \"{}\", slice)?,\n                     }\n@@ -809,8 +809,8 @@ mod size_asserts {\n     static_assert_size!(Block, 56);\n     static_assert_size!(Expr<'_>, 64);\n     static_assert_size!(ExprKind<'_>, 40);\n-    static_assert_size!(Pat<'_>, 24);\n+    static_assert_size!(Pat<'_>, 128);\n     static_assert_size!(PatKind<'_>, 112);\n-    static_assert_size!(Stmt<'_>, 72);\n-    static_assert_size!(StmtKind<'_>, 64);\n+    static_assert_size!(Stmt<'_>, 56);\n+    static_assert_size!(StmtKind<'_>, 48);\n }"}, {"sha": "5168c2120f43d60cb03338fe5532e39316b9bbeb", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=053874eecc9806f36195c35a7fad9c8878b0788e", "patch": "@@ -211,7 +211,7 @@ pub fn walk_arm<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, arm: &Arm<'\n \n pub fn walk_pat<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, pat: &Pat<'tcx>) {\n     use PatKind::*;\n-    match pat.kind.as_ref() {\n+    match &pat.kind {\n         AscribeUserType { subpattern, ascription: _ }\n         | Deref { subpattern }\n         | Binding {\n@@ -236,7 +236,7 @@ pub fn walk_pat<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, pat: &Pat<'\n                 visitor.visit_pat(&subpattern);\n             }\n             if let Some(pat) = slice {\n-                visitor.visit_pat(pat);\n+                visitor.visit_pat(&pat);\n             }\n             for subpattern in suffix {\n                 visitor.visit_pat(&subpattern);"}, {"sha": "ef976d6308b50afff2eaf1739c79085818a8c335", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=053874eecc9806f36195c35a7fad9c8878b0788e", "patch": "@@ -117,7 +117,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     lint_level,\n                     else_block,\n                 } => {\n-                    let ignores_expr_result = matches!(*pattern.kind, PatKind::Wild);\n+                    let ignores_expr_result = matches!(pattern.kind, PatKind::Wild);\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result });\n \n                     // Enter the remainder scope, i.e., the bindings' destruction scope.\n@@ -160,7 +160,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                                 ArmHasGuard(false),\n                                                 Some((None, initializer_span)),\n                                             );\n-                                            this.expr_into_pattern(block, pattern.clone(), init) // irrefutable pattern\n+                                            this.expr_into_pattern(block, (**pattern).clone(), init) // irrefutable pattern\n                                         }\n                                     })\n                                 },"}, {"sha": "72f8034bbc1760f5d07b9f94bef9633b2c4d1fbd", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=053874eecc9806f36195c35a7fad9c8878b0788e", "patch": "@@ -493,7 +493,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         irrefutable_pat: Pat<'tcx>,\n         initializer: &Expr<'tcx>,\n     ) -> BlockAnd<()> {\n-        match *irrefutable_pat.kind {\n+        match irrefutable_pat.kind {\n             // Optimize the case of `let x = ...` to write directly into `x`\n             PatKind::Binding { mode: BindingMode::ByValue, var, subpattern: None, .. } => {\n                 let place =\n@@ -518,13 +518,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // broken.\n             PatKind::AscribeUserType {\n                 subpattern:\n-                    Pat {\n+                    box Pat {\n                         kind:\n-                            box PatKind::Binding {\n-                                mode: BindingMode::ByValue,\n-                                var,\n-                                subpattern: None,\n-                                ..\n+                            PatKind::Binding {\n+                                mode: BindingMode::ByValue, var, subpattern: None, ..\n                             },\n                         ..\n                     },\n@@ -744,7 +741,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             \"visit_primary_bindings: pattern={:?} pattern_user_ty={:?}\",\n             pattern, pattern_user_ty\n         );\n-        match *pattern.kind {\n+        match pattern.kind {\n             PatKind::Binding {\n                 mutability,\n                 name,\n@@ -1330,7 +1327,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // All of the or-patterns have been sorted to the end, so if the first\n         // pattern is an or-pattern we only have or-patterns.\n-        match *first_candidate.match_pairs[0].pattern.kind {\n+        match first_candidate.match_pairs[0].pattern.kind {\n             PatKind::Or { .. } => (),\n             _ => {\n                 self.test_candidates(\n@@ -1350,7 +1347,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let mut otherwise = None;\n         for match_pair in match_pairs {\n-            let PatKind::Or { ref pats } = &*match_pair.pattern.kind else {\n+            let PatKind::Or { ref pats } = &match_pair.pattern.kind else {\n                 bug!(\"Or-patterns should have been sorted to the end\");\n             };\n             let or_span = match_pair.pattern.span;\n@@ -1384,7 +1381,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         candidate: &mut Candidate<'pat, 'tcx>,\n         otherwise: &mut Option<BasicBlock>,\n-        pats: &'pat [Pat<'tcx>],\n+        pats: &'pat [Box<Pat<'tcx>>],\n         or_span: Span,\n         place: PlaceBuilder<'tcx>,\n         fake_borrows: &mut Option<FxIndexSet<Place<'tcx>>>,\n@@ -2289,7 +2286,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let else_block_span = self.thir[else_block].span;\n         let (matching, failure) = self.in_if_then_scope(remainder_scope, |this| {\n             let scrutinee = unpack!(block = this.lower_scrutinee(block, init, initializer_span));\n-            let pat = Pat { ty: init.ty, span: else_block_span, kind: Box::new(PatKind::Wild) };\n+            let pat = Pat { ty: init.ty, span: else_block_span, kind: PatKind::Wild };\n             let mut wildcard = Candidate::new(scrutinee.clone(), &pat, false);\n             this.declare_bindings(\n                 visibility_scope,"}, {"sha": "b9954be377b36547e1ba46a4b8dcdc3babb30703", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=053874eecc9806f36195c35a7fad9c8878b0788e", "patch": "@@ -67,7 +67,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         loop {\n             let match_pairs = mem::take(&mut candidate.match_pairs);\n \n-            if let [MatchPair { pattern: Pat { kind: box PatKind::Or { pats }, .. }, place }] =\n+            if let [MatchPair { pattern: Pat { kind: PatKind::Or { pats }, .. }, place }] =\n                 &*match_pairs\n             {\n                 existing_bindings.extend_from_slice(&new_bindings);\n@@ -113,7 +113,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // late as possible.\n                 candidate\n                     .match_pairs\n-                    .sort_by_key(|pair| matches!(*pair.pattern.kind, PatKind::Or { .. }));\n+                    .sort_by_key(|pair| matches!(pair.pattern.kind, PatKind::Or { .. }));\n                 debug!(simplified = ?candidate, \"simplify_candidate\");\n                 return false; // if we were not able to simplify any, done.\n             }\n@@ -127,10 +127,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         candidate: &Candidate<'pat, 'tcx>,\n         place: PlaceBuilder<'tcx>,\n-        pats: &'pat [Pat<'tcx>],\n+        pats: &'pat [Box<Pat<'tcx>>],\n     ) -> Vec<Candidate<'pat, 'tcx>> {\n         pats.iter()\n-            .map(|pat| {\n+            .map(|box pat| {\n                 let mut candidate = Candidate::new(place.clone(), pat, candidate.has_guard);\n                 self.simplify_candidate(&mut candidate);\n                 candidate\n@@ -149,7 +149,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) -> Result<(), MatchPair<'pat, 'tcx>> {\n         let tcx = self.tcx;\n-        match *match_pair.pattern.kind {\n+        match match_pair.pattern.kind {\n             PatKind::AscribeUserType {\n                 ref subpattern,\n                 ascription: thir::Ascription { ref annotation, variance },\n@@ -254,7 +254,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         &mut candidate.match_pairs,\n                         &match_pair.place,\n                         prefix,\n-                        slice.as_ref(),\n+                        slice,\n                         suffix,\n                     );\n                     Ok(())\n@@ -294,7 +294,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     &mut candidate.match_pairs,\n                     &match_pair.place,\n                     prefix,\n-                    slice.as_ref(),\n+                    slice,\n                     suffix,\n                 );\n                 Ok(())"}, {"sha": "ce85f240603a8fb9f757f1e6e01fc33a6d457339", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=053874eecc9806f36195c35a7fad9c8878b0788e", "patch": "@@ -29,7 +29,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// It is a bug to call this with a not-fully-simplified pattern.\n     pub(super) fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n-        match *match_pair.pattern.kind {\n+        match match_pair.pattern.kind {\n             PatKind::Variant { adt_def, substs: _, variant_index: _, subpatterns: _ } => Test {\n                 span: match_pair.pattern.span,\n                 kind: TestKind::Switch {\n@@ -92,7 +92,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             return false;\n         };\n \n-        match *match_pair.pattern.kind {\n+        match match_pair.pattern.kind {\n             PatKind::Constant { value } => {\n                 options\n                     .entry(value)\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             return false;\n         };\n \n-        match *match_pair.pattern.kind {\n+        match match_pair.pattern.kind {\n             PatKind::Variant { adt_def: _, variant_index, .. } => {\n                 // We have a pattern testing for variant `variant_index`\n                 // set the corresponding index to true\n@@ -506,7 +506,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let (match_pair_index, match_pair) =\n             candidate.match_pairs.iter().enumerate().find(|&(_, mp)| mp.place == *test_place)?;\n \n-        match (&test.kind, &*match_pair.pattern.kind) {\n+        match (&test.kind, &match_pair.pattern.kind) {\n             // If we are performing a variant switch, then this\n             // informs variant patterns, but nothing else.\n             (\n@@ -569,7 +569,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             match_pair_index,\n                             candidate,\n                             prefix,\n-                            slice.as_ref(),\n+                            slice,\n                             suffix,\n                         );\n                         Some(0)\n@@ -607,7 +607,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             match_pair_index,\n                             candidate,\n                             prefix,\n-                            slice.as_ref(),\n+                            slice,\n                             suffix,\n                         );\n                         Some(0)\n@@ -678,7 +678,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // However, at this point we can still encounter or-patterns that were extracted\n                 // from previous calls to `sort_candidate`, so we need to manually address that\n                 // case to avoid panicking in `self.test()`.\n-                if let PatKind::Or { .. } = &*match_pair.pattern.kind {\n+                if let PatKind::Or { .. } = &match_pair.pattern.kind {\n                     return None;\n                 }\n \n@@ -708,9 +708,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         match_pair_index: usize,\n         candidate: &mut Candidate<'pat, 'tcx>,\n-        prefix: &'pat [Pat<'tcx>],\n-        opt_slice: Option<&'pat Pat<'tcx>>,\n-        suffix: &'pat [Pat<'tcx>],\n+        prefix: &'pat [Box<Pat<'tcx>>],\n+        opt_slice: &'pat Option<Box<Pat<'tcx>>>,\n+        suffix: &'pat [Box<Pat<'tcx>>],\n     ) {\n         let removed_place = candidate.match_pairs.remove(match_pair_index).place;\n         self.prefix_slice_suffix("}, {"sha": "06f24040f7be05d80cbd277c2f41dd947cb235d2", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=053874eecc9806f36195c35a7fad9c8878b0788e", "patch": "@@ -26,9 +26,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         match_pairs: &mut SmallVec<[MatchPair<'pat, 'tcx>; 1]>,\n         place: &PlaceBuilder<'tcx>,\n-        prefix: &'pat [Pat<'tcx>],\n-        opt_slice: Option<&'pat Pat<'tcx>>,\n-        suffix: &'pat [Pat<'tcx>],\n+        prefix: &'pat [Box<Pat<'tcx>>],\n+        opt_slice: &'pat Option<Box<Pat<'tcx>>>,\n+        suffix: &'pat [Box<Pat<'tcx>>],\n     ) {\n         let tcx = self.tcx;\n         let (min_length, exact_size) = if let Ok(place_resolved) ="}, {"sha": "17767f4218c04fdb55c54a15f307a6d523fd406e", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=053874eecc9806f36195c35a7fad9c8878b0788e", "patch": "@@ -1015,7 +1015,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let original_source_scope = self.source_scope;\n             let span = pattern.span;\n             self.set_correct_source_scope_for_arg(arg.hir_id, original_source_scope, span);\n-            match *pattern.kind {\n+            match pattern.kind {\n                 // Don't introduce extra copies for simple bindings\n                 PatKind::Binding {\n                     mutability,\n@@ -1052,7 +1052,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         Some((Some(&place), span)),\n                     );\n                     let place_builder = PlaceBuilder::from(local);\n-                    unpack!(block = self.place_into_pattern(block, pattern, place_builder, false));\n+                    unpack!(block = self.place_into_pattern(block, *pattern, place_builder, false));\n                 }\n             }\n             self.source_scope = original_source_scope;"}, {"sha": "495738ebe1c7ac9d392af26ac38f9e4bd6a309c1", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=053874eecc9806f36195c35a7fad9c8878b0788e", "patch": "@@ -214,7 +214,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &Pat<'tcx>) {\n         if self.in_union_destructure {\n-            match *pat.kind {\n+            match pat.kind {\n                 // binding to a variable allows getting stuff out of variable\n                 PatKind::Binding { .. }\n                 // match is conditional on having this value\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n             }\n         };\n \n-        match &*pat.kind {\n+        match &pat.kind {\n             PatKind::Leaf { .. } => {\n                 if let ty::Adt(adt_def, ..) = pat.ty.kind() {\n                     if adt_def.is_union() {"}, {"sha": "c4e238c7821ea1fda7af160b16403ee189f038c5", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=053874eecc9806f36195c35a7fad9c8878b0788e", "patch": "@@ -91,17 +91,17 @@ impl<'tcx> Cx<'tcx> {\n                                     span: ty.span,\n                                     inferred_ty: self.typeck_results.node_type(ty.hir_id),\n                                 };\n-                                pattern = Pat {\n+                                pattern = Box::new(Pat {\n                                     ty: pattern.ty,\n                                     span: pattern.span,\n-                                    kind: Box::new(PatKind::AscribeUserType {\n+                                    kind: PatKind::AscribeUserType {\n                                         ascription: Ascription {\n                                             annotation,\n                                             variance: ty::Variance::Covariant,\n                                         },\n                                         subpattern: pattern,\n-                                    }),\n-                                };\n+                                    },\n+                                });\n                             }\n                         }\n "}, {"sha": "ae53df1f9b9a4166353f93f22b96d54791dfe52f", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=053874eecc9806f36195c35a7fad9c8878b0788e", "patch": "@@ -78,7 +78,7 @@ impl<'tcx> Cx<'tcx> {\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n-    pub(crate) fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Pat<'tcx> {\n+    pub(crate) fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Box<Pat<'tcx>> {\n         let p = match self.tcx.hir().get(p.hir_id) {\n             Node::Pat(p) => p,\n             node => bug!(\"pattern became {:?}\", node),"}, {"sha": "5af5ce407c6b9e320ad607a74ca920242fcc63c5", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=053874eecc9806f36195c35a7fad9c8878b0788e", "patch": "@@ -26,7 +26,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         id: hir::HirId,\n         span: Span,\n         mir_structural_match_violation: bool,\n-    ) -> Pat<'tcx> {\n+    ) -> Box<Pat<'tcx>> {\n         self.tcx.infer_ctxt().enter(|infcx| {\n             let mut convert = ConstToPat::new(self, id, span, infcx);\n             convert.to_pat(cv, mir_structural_match_violation)\n@@ -156,7 +156,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         &mut self,\n         cv: mir::ConstantKind<'tcx>,\n         mir_structural_match_violation: bool,\n-    ) -> Pat<'tcx> {\n+    ) -> Box<Pat<'tcx>> {\n         trace!(self.treat_byte_string_as_slice);\n         // This method is just a wrapper handling a validity check; the heavy lifting is\n         // performed by the recursive `recur` method, which is not meant to be\n@@ -166,10 +166,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         // level of indirection can be eliminated\n \n         let inlined_const_as_pat =\n-            self.recur(cv, mir_structural_match_violation).unwrap_or_else(|_| Pat {\n-                span: self.span,\n-                ty: cv.ty(),\n-                kind: Box::new(PatKind::Constant { value: cv }),\n+            self.recur(cv, mir_structural_match_violation).unwrap_or_else(|_| {\n+                Box::new(Pat {\n+                    span: self.span,\n+                    ty: cv.ty(),\n+                    kind: PatKind::Constant { value: cv },\n+                })\n             });\n \n         if self.include_lint_checks && !self.saw_const_match_error.get() {\n@@ -271,7 +273,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         &self,\n         cv: mir::ConstantKind<'tcx>,\n         mir_structural_match_violation: bool,\n-    ) -> Result<Pat<'tcx>, FallbackToConstRef> {\n+    ) -> Result<Box<Pat<'tcx>>, FallbackToConstRef> {\n         let id = self.id;\n         let span = self.span;\n         let tcx = self.tcx();\n@@ -425,8 +427,8 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     let old = self.behind_reference.replace(true);\n                     let array = tcx.deref_mir_constant(self.param_env.and(cv));\n                     let val = PatKind::Deref {\n-                        subpattern: Pat {\n-                            kind: Box::new(PatKind::Array {\n+                        subpattern: Box::new(Pat {\n+                            kind: PatKind::Array {\n                                 prefix: tcx\n                                     .destructure_mir_constant(param_env, array)\n                                     .fields\n@@ -435,10 +437,10 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                                     .collect::<Result<_, _>>()?,\n                                 slice: None,\n                                 suffix: vec![],\n-                            }),\n+                            },\n                             span,\n                             ty: *pointee_ty,\n-                        },\n+                        }),\n                     };\n                     self.behind_reference.set(old);\n                     val\n@@ -451,8 +453,8 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     let old = self.behind_reference.replace(true);\n                     let array = tcx.deref_mir_constant(self.param_env.and(cv));\n                     let val = PatKind::Deref {\n-                        subpattern: Pat {\n-                            kind: Box::new(PatKind::Slice {\n+                        subpattern: Box::new(Pat {\n+                            kind: PatKind::Slice {\n                                 prefix: tcx\n                                     .destructure_mir_constant(param_env, array)\n                                     .fields\n@@ -461,10 +463,10 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                                     .collect::<Result<_, _>>()?,\n                                 slice: None,\n                                 suffix: vec![],\n-                            }),\n+                            },\n                             span,\n                             ty: tcx.mk_slice(elem_ty),\n-                        },\n+                        }),\n                     };\n                     self.behind_reference.set(old);\n                     val\n@@ -598,6 +600,6 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             );\n         }\n \n-        Ok(Pat { span, ty: cv.ty(), kind: Box::new(kind) })\n+        Ok(Box::new(Pat { span, ty: cv.ty(), kind }))\n     }\n }"}, {"sha": "fdd74d5221dd62cf0e2ddaaee0c20e2a82628e32", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=053874eecc9806f36195c35a7fad9c8878b0788e", "patch": "@@ -71,9 +71,9 @@ use std::ops::RangeInclusive;\n /// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n fn expand_or_pat<'p, 'tcx>(pat: &'p Pat<'tcx>) -> Vec<&'p Pat<'tcx>> {\n     fn expand<'p, 'tcx>(pat: &'p Pat<'tcx>, vec: &mut Vec<&'p Pat<'tcx>>) {\n-        if let PatKind::Or { pats } = pat.kind.as_ref() {\n+        if let PatKind::Or { pats } = &pat.kind {\n             for pat in pats {\n-                expand(pat, vec);\n+                expand(&pat, vec);\n             }\n         } else {\n             vec.push(pat)\n@@ -255,7 +255,7 @@ impl IntRange {\n             PatKind::Range(PatRange { lo: lo_const, hi: hi_const, end: RangeEnd::Included })\n         };\n \n-        Pat { ty, span: DUMMY_SP, kind: Box::new(kind) }\n+        Pat { ty, span: DUMMY_SP, kind }\n     }\n \n     /// Lint on likely incorrect range patterns (#63987)\n@@ -1297,7 +1297,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n         let mkpat = |pat| DeconstructedPat::from_pat(cx, pat);\n         let ctor;\n         let fields;\n-        match pat.kind.as_ref() {\n+        match &pat.kind {\n             PatKind::AscribeUserType { subpattern, .. } => return mkpat(subpattern),\n             PatKind::Binding { subpattern: Some(subpat), .. } => return mkpat(subpat),\n             PatKind::Binding { subpattern: None, .. } | PatKind::Wild => {\n@@ -1342,9 +1342,9 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                         fields = Fields::singleton(cx, pat);\n                     }\n                     ty::Adt(adt, _) => {\n-                        ctor = match pat.kind.as_ref() {\n+                        ctor = match pat.kind {\n                             PatKind::Leaf { .. } => Single,\n-                            PatKind::Variant { variant_index, .. } => Variant(*variant_index),\n+                            PatKind::Variant { variant_index, .. } => Variant(variant_index),\n                             _ => bug!(),\n                         };\n                         let variant = &adt.variant(ctor.variant_index_for_adt(*adt));\n@@ -1429,7 +1429,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                     FixedLen(prefix.len() + suffix.len())\n                 };\n                 ctor = Slice(Slice::new(array_len, kind));\n-                fields = Fields::from_iter(cx, prefix.iter().chain(suffix).map(mkpat));\n+                fields = Fields::from_iter(cx, prefix.iter().chain(suffix).map(|p| mkpat(&*p)));\n             }\n             PatKind::Or { .. } => {\n                 ctor = Or;\n@@ -1442,15 +1442,15 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n \n     pub(crate) fn to_pat(&self, cx: &MatchCheckCtxt<'p, 'tcx>) -> Pat<'tcx> {\n         let is_wildcard = |pat: &Pat<'_>| {\n-            matches!(*pat.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n+            matches!(pat.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n         };\n-        let mut subpatterns = self.iter_fields().map(|p| p.to_pat(cx));\n-        let pat = match &self.ctor {\n+        let mut subpatterns = self.iter_fields().map(|p| Box::new(p.to_pat(cx)));\n+        let kind = match &self.ctor {\n             Single | Variant(_) => match self.ty.kind() {\n                 ty::Tuple(..) => PatKind::Leaf {\n                     subpatterns: subpatterns\n                         .enumerate()\n-                        .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n+                        .map(|(i, pattern)| FieldPat { field: Field::new(i), pattern })\n                         .collect(),\n                 },\n                 ty::Adt(adt_def, _) if adt_def.is_box() => {\n@@ -1506,7 +1506,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                         }\n                         let suffix: Vec<_> = subpatterns.collect();\n                         let wild = Pat::wildcard_from_ty(self.ty);\n-                        PatKind::Slice { prefix, slice: Some(wild), suffix }\n+                        PatKind::Slice { prefix, slice: Some(Box::new(wild)), suffix }\n                     }\n                 }\n             }\n@@ -1523,7 +1523,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n             }\n         };\n \n-        Pat { ty: self.ty, span: DUMMY_SP, kind: Box::new(pat) }\n+        Pat { ty: self.ty, span: DUMMY_SP, kind }\n     }\n \n     pub(super) fn is_or_pat(&self) -> bool {"}, {"sha": "c10fc607d1076645314f862f98806c9b603fb61b", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=053874eecc9806f36195c35a7fad9c8878b0788e", "patch": "@@ -49,7 +49,7 @@ pub(crate) fn pat_from_hir<'a, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     pat: &'tcx hir::Pat<'tcx>,\n-) -> Pat<'tcx> {\n+) -> Box<Pat<'tcx>> {\n     let mut pcx = PatCtxt::new(tcx, param_env, typeck_results);\n     let result = pcx.lower_pattern(pat);\n     if !pcx.errors.is_empty() {\n@@ -74,7 +74,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         self\n     }\n \n-    pub(crate) fn lower_pattern(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n+    pub(crate) fn lower_pattern(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Box<Pat<'tcx>> {\n         // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n         // pattern has the type that results *after* dereferencing. For example, in this code:\n         //\n@@ -97,13 +97,13 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         let unadjusted_pat = self.lower_pattern_unadjusted(pat);\n         self.typeck_results.pat_adjustments().get(pat.hir_id).unwrap_or(&vec![]).iter().rev().fold(\n             unadjusted_pat,\n-            |pat, ref_ty| {\n+            |pat: Box<_>, ref_ty| {\n                 debug!(\"{:?}: wrapping pattern with type {:?}\", pat, ref_ty);\n-                Pat {\n+                Box::new(Pat {\n                     span: pat.span,\n                     ty: *ref_ty,\n-                    kind: Box::new(PatKind::Deref { subpattern: pat }),\n-                }\n+                    kind: PatKind::Deref { subpattern: pat },\n+                })\n             },\n         )\n     }\n@@ -113,7 +113,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> (PatKind<'tcx>, Option<Ascription<'tcx>>) {\n         match self.lower_lit(expr) {\n-            PatKind::AscribeUserType { ascription, subpattern: Pat { kind: box kind, .. } } => {\n+            PatKind::AscribeUserType { ascription, subpattern: box Pat { kind, .. } } => {\n                 (kind, Some(ascription))\n             }\n             kind => (kind, None),\n@@ -196,7 +196,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n+    fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Box<Pat<'tcx>> {\n         let mut ty = self.typeck_results.node_type(pat.hir_id);\n \n         let kind = match pat.kind {\n@@ -228,7 +228,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 // constants somewhere. Have them on the range pattern.\n                 for end in &[lo, hi] {\n                     if let Some((_, Some(ascription))) = end {\n-                        let subpattern = Pat { span: pat.span, ty, kind: Box::new(kind) };\n+                        let subpattern = Box::new(Pat { span: pat.span, ty, kind });\n                         kind =\n                             PatKind::AscribeUserType { ascription: ascription.clone(), subpattern };\n                     }\n@@ -322,7 +322,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             hir::PatKind::Or(ref pats) => PatKind::Or { pats: self.lower_patterns(pats) },\n         };\n \n-        Pat { span: pat.span, ty, kind: Box::new(kind) }\n+        Box::new(Pat { span: pat.span, ty, kind })\n     }\n \n     fn lower_tuple_subpats(\n@@ -340,11 +340,14 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n-    fn lower_patterns(&mut self, pats: &'tcx [hir::Pat<'tcx>]) -> Vec<Pat<'tcx>> {\n+    fn lower_patterns(&mut self, pats: &'tcx [hir::Pat<'tcx>]) -> Vec<Box<Pat<'tcx>>> {\n         pats.iter().map(|p| self.lower_pattern(p)).collect()\n     }\n \n-    fn lower_opt_pattern(&mut self, pat: &'tcx Option<&'tcx hir::Pat<'tcx>>) -> Option<Pat<'tcx>> {\n+    fn lower_opt_pattern(\n+        &mut self,\n+        pat: &'tcx Option<&'tcx hir::Pat<'tcx>>,\n+    ) -> Option<Box<Pat<'tcx>>> {\n         pat.as_ref().map(|p| self.lower_pattern(p))\n     }\n \n@@ -441,7 +444,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 inferred_ty: self.typeck_results.node_type(hir_id),\n             };\n             kind = PatKind::AscribeUserType {\n-                subpattern: Pat { span, ty, kind: Box::new(kind) },\n+                subpattern: Box::new(Pat { span, ty, kind }),\n                 ascription: Ascription { annotation, variance: ty::Variance::Covariant },\n             };\n         }\n@@ -453,11 +456,11 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// it to `const_to_pat`. Any other path (like enum variants without fields)\n     /// is converted to the corresponding pattern via `lower_variant_or_leaf`.\n     #[instrument(skip(self), level = \"debug\")]\n-    fn lower_path(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) -> Pat<'tcx> {\n+    fn lower_path(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) -> Box<Pat<'tcx>> {\n         let ty = self.typeck_results.node_type(id);\n         let res = self.typeck_results.qpath_res(qpath, id);\n \n-        let pat_from_kind = |kind| Pat { span, ty, kind: Box::new(kind) };\n+        let pat_from_kind = |kind| Box::new(Pat { span, ty, kind });\n \n         let (def_id, is_associated_const) = match res {\n             Res::Def(DefKind::Const, def_id) => (def_id, false),\n@@ -509,19 +512,19 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                         span,\n                         inferred_ty: self.typeck_results().node_type(id),\n                     };\n-                    Pat {\n+                    Box::new(Pat {\n                         span,\n-                        kind: Box::new(PatKind::AscribeUserType {\n+                        kind: PatKind::AscribeUserType {\n                             subpattern: pattern,\n                             ascription: Ascription {\n                                 annotation,\n                                 /// Note that use `Contravariant` here. See the\n                                 /// `variance` field documentation for details.\n                                 variance: ty::Variance::Contravariant,\n                             },\n-                        }),\n+                        },\n                         ty: const_.ty(),\n-                    }\n+                    })\n                 } else {\n                     pattern\n                 }\n@@ -569,7 +572,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                     _ => bug!(\"Expected either ConstKind::Param or ConstKind::Unevaluated\"),\n                 }\n             }\n-            mir::ConstantKind::Val(_, _) => *self.const_to_pat(value, id, span, false).kind,\n+            mir::ConstantKind::Val(_, _) => self.const_to_pat(value, id, span, false).kind,\n         }\n     }\n \n@@ -580,7 +583,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     fn lower_lit(&mut self, expr: &'tcx hir::Expr<'tcx>) -> PatKind<'tcx> {\n         let (lit, neg) = match expr.kind {\n             hir::ExprKind::Path(ref qpath) => {\n-                return *self.lower_path(qpath, expr.hir_id, expr.span).kind;\n+                return self.lower_path(qpath, expr.hir_id, expr.span).kind;\n             }\n             hir::ExprKind::ConstBlock(ref anon_const) => {\n                 return self.lower_inline_const(anon_const, expr.hir_id, expr.span);\n@@ -598,7 +601,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         let lit_input =\n             LitToConstInput { lit: &lit.node, ty: self.typeck_results.expr_ty(expr), neg };\n         match self.tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n-            Ok(constant) => *self.const_to_pat(constant, expr.hir_id, lit.span, false).kind,\n+            Ok(constant) => self.const_to_pat(constant, expr.hir_id, lit.span, false).kind,\n             Err(LitToConstError::Reported) => PatKind::Wild,\n             Err(LitToConstError::TypeError) => bug!(\"lower_lit: had type error\"),\n         }"}, {"sha": "6cbccb4bf291e29afce7b7bc2b53749c80f5a82a", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053874eecc9806f36195c35a7fad9c8878b0788e/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=053874eecc9806f36195c35a7fad9c8878b0788e", "patch": "@@ -155,7 +155,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                     return true;\n                 }\n \n-                match pat.kind.as_ref() {\n+                match pat.kind {\n                     thir::PatKind::Constant { value } => value.has_param_types_or_consts(),\n                     thir::PatKind::Range(thir::PatRange { lo, hi, .. }) => {\n                         lo.has_param_types_or_consts() || hi.has_param_types_or_consts()"}]}