{"sha": "ac2520128dc348529afc99263f82f255d39e047d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMjUyMDEyOGRjMzQ4NTI5YWZjOTkyNjNmODJmMjU1ZDM5ZTA0N2Q=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-03T14:28:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-03T14:28:27Z"}, "message": "Merge #10135\n\n10135: minor: fix some clippy lints r=lnicola a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "864d97eb78d282e38c9f0a26cb149152dc3fcab5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/864d97eb78d282e38c9f0a26cb149152dc3fcab5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac2520128dc348529afc99263f82f255d39e047d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhMjELCRBK7hj4Ov3rIwAAiOcIAAwyeZAGBBTQ9qAOCKTg9cL5\nWTPEG0eyZKM4UBpwph8C1+uRuFZcfhizuzSKtrArGsMVC40nOyv4N35P5sQFgoys\nFLPlDO5uwNShJYioVdyPSRlggaxlh8EnPgGPOqq/004Q4vqYqtTRMYcfwcWn/G4o\nR1lVCTaQWlL5gYpPWL3u5uuEpHv+3MPb173SeHw0awEgaaU7Nrpqs433hJUaKUC0\nIy26GBsXU9lSIjeXZMDI7FsT2pK7M96JqIVC6VzfdY32Xr9fo5JcwWFNSQrUot4W\nQdQj2H8k0Iq8fmdUP3NAzoQnNjR1iy7+3DwsrSCakYMGr80I+6Xd4DmR8p3Xew8=\n=2p6O\n-----END PGP SIGNATURE-----\n", "payload": "tree 864d97eb78d282e38c9f0a26cb149152dc3fcab5\nparent 726f34cb421f906efeaecfae4f763bf26def23ef\nparent 36a5ce97902ea1b3a51eeffda4cd9e8b7ae69398\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1630679307 +0000\ncommitter GitHub <noreply@github.com> 1630679307 +0000\n\nMerge #10135\n\n10135: minor: fix some clippy lints r=lnicola a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac2520128dc348529afc99263f82f255d39e047d", "html_url": "https://github.com/rust-lang/rust/commit/ac2520128dc348529afc99263f82f255d39e047d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac2520128dc348529afc99263f82f255d39e047d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "726f34cb421f906efeaecfae4f763bf26def23ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/726f34cb421f906efeaecfae4f763bf26def23ef", "html_url": "https://github.com/rust-lang/rust/commit/726f34cb421f906efeaecfae4f763bf26def23ef"}, {"sha": "36a5ce97902ea1b3a51eeffda4cd9e8b7ae69398", "url": "https://api.github.com/repos/rust-lang/rust/commits/36a5ce97902ea1b3a51eeffda4cd9e8b7ae69398", "html_url": "https://github.com/rust-lang/rust/commit/36a5ce97902ea1b3a51eeffda4cd9e8b7ae69398"}], "stats": {"total": 240, "additions": 102, "deletions": 138}, "files": [{"sha": "565d0c02cfef4eeb0fe8d912ea24511fcdc9abb9", "filename": "crates/base_db/src/input.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fbase_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fbase_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Finput.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -521,8 +521,8 @@ impl fmt::Display for CyclicDependenciesError {\n         write!(\n             f,\n             \"cyclic deps: {} -> {}, alternative path: {}\",\n-            render(&self.from()),\n-            render(&self.to()),\n+            render(self.from()),\n+            render(self.to()),\n             path\n         )\n     }"}, {"sha": "a636d865025f10b1731db0c91a5254d758f7714e", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -339,12 +339,7 @@ impl CargoActor {\n                         cargo_metadata::Message::CompilerMessage(msg) => {\n                             self.sender.send(CargoMessage::Diagnostic(msg.message)).unwrap()\n                         }\n-\n-                        cargo_metadata::Message::CompilerArtifact(_)\n-                        | cargo_metadata::Message::BuildScriptExecuted(_)\n-                        | cargo_metadata::Message::BuildFinished(_)\n-                        | cargo_metadata::Message::TextLine(_)\n-                        | _ => (),\n+                        _ => (),\n                     },\n                     JsonMessage::Rustc(message) => {\n                         self.sender.send(CargoMessage::Diagnostic(message)).unwrap()"}, {"sha": "a3f4a6551328a29152d68b823658b44dea537c96", "filename": "crates/hir/src/has_source.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fhas_source.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -60,9 +60,9 @@ impl HasSource for Adt {\n     type Ast = ast::Adt;\n     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n         match self {\n-            Adt::Struct(s) => Some(s.source(db)?.map(|s| ast::Adt::Struct(s))),\n-            Adt::Union(u) => Some(u.source(db)?.map(|u| ast::Adt::Union(u))),\n-            Adt::Enum(e) => Some(e.source(db)?.map(|e| ast::Adt::Enum(e))),\n+            Adt::Struct(s) => Some(s.source(db)?.map(ast::Adt::Struct)),\n+            Adt::Union(u) => Some(u.source(db)?.map(ast::Adt::Union)),\n+            Adt::Enum(e) => Some(e.source(db)?.map(ast::Adt::Enum)),\n         }\n     }\n }"}, {"sha": "62c634b549f1fe732f8f36f55f97f9f323903756", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -2960,9 +2960,9 @@ impl ScopeDef {\n impl From<ItemInNs> for ScopeDef {\n     fn from(item: ItemInNs) -> Self {\n         match item {\n-            ItemInNs::Types(id) => ScopeDef::ModuleDef(id.into()),\n-            ItemInNs::Values(id) => ScopeDef::ModuleDef(id.into()),\n-            ItemInNs::Macros(id) => ScopeDef::MacroDef(id.into()),\n+            ItemInNs::Types(id) => ScopeDef::ModuleDef(id),\n+            ItemInNs::Values(id) => ScopeDef::ModuleDef(id),\n+            ItemInNs::Macros(id) => ScopeDef::MacroDef(id),\n         }\n     }\n }"}, {"sha": "b81332c68fa5745d82e6795e51dc65e2fab8bcaf", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -872,7 +872,7 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn is_unsafe_ident_pat(&self, ident_pat: &ast::IdentPat) -> bool {\n-        if !ident_pat.ref_token().is_some() {\n+        if ident_pat.ref_token().is_none() {\n             return false;\n         }\n "}, {"sha": "d385bcaf66fc1fb7811abfd7cb66c9e5055b5144", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -264,8 +264,7 @@ impl<'a> Ctx<'a> {\n         let name = Name::new_tuple_field(idx);\n         let visibility = self.lower_visibility(field);\n         let type_ref = self.lower_type_ref_opt(field.ty());\n-        let res = Field { name, type_ref, visibility };\n-        res\n+        Field { name, type_ref, visibility }\n     }\n \n     fn lower_union(&mut self, union: &ast::Union) -> Option<FileItemTreeId<Union>> {"}, {"sha": "b376f9a2531e35160df876c4dafddb54d19ec4cc", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -384,7 +384,7 @@ impl DefCollector<'_> {\n         self.unresolved_imports.extend(partial_resolved);\n         self.resolve_imports();\n \n-        let unresolved_imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n+        let unresolved_imports = std::mem::take(&mut self.unresolved_imports);\n         // show unresolved imports in completion, etc\n         for directive in &unresolved_imports {\n             self.record_resolved_import(directive)\n@@ -417,7 +417,7 @@ impl DefCollector<'_> {\n     fn reseed_with_unresolved_attribute(&mut self) -> ReachedFixedPoint {\n         cov_mark::hit!(unresolved_attribute_fallback);\n \n-        let mut unresolved_macros = std::mem::replace(&mut self.unresolved_macros, Vec::new());\n+        let mut unresolved_macros = std::mem::take(&mut self.unresolved_macros);\n         let pos = unresolved_macros.iter().position(|directive| {\n             if let MacroDirectiveKind::Attr { ast_id, mod_item, attr } = &directive.kind {\n                 self.skip_attrs.insert(ast_id.ast_id.with_value(*mod_item), attr.id);\n@@ -689,7 +689,7 @@ impl DefCollector<'_> {\n     /// Tries to resolve every currently unresolved import.\n     fn resolve_imports(&mut self) -> ReachedFixedPoint {\n         let mut res = ReachedFixedPoint::Yes;\n-        let imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n+        let imports = std::mem::take(&mut self.unresolved_imports);\n         let imports = imports\n             .into_iter()\n             .filter_map(|mut directive| {\n@@ -1005,7 +1005,7 @@ impl DefCollector<'_> {\n     }\n \n     fn resolve_macros(&mut self) -> ReachedFixedPoint {\n-        let mut macros = std::mem::replace(&mut self.unresolved_macros, Vec::new());\n+        let mut macros = std::mem::take(&mut self.unresolved_macros);\n         let mut resolved = Vec::new();\n         let mut res = ReachedFixedPoint::Yes;\n         macros.retain(|directive| {\n@@ -1279,13 +1279,12 @@ impl DefCollector<'_> {\n \n         for directive in &self.unresolved_imports {\n             if let ImportSource::Import { id: import, use_tree } = &directive.import.source {\n-                match (directive.import.path.segments().first(), &directive.import.path.kind) {\n-                    (Some(krate), PathKind::Plain | PathKind::Abs) => {\n-                        if diagnosed_extern_crates.contains(krate) {\n-                            continue;\n-                        }\n+                if let (Some(krate), PathKind::Plain | PathKind::Abs) =\n+                    (directive.import.path.segments().first(), &directive.import.path.kind)\n+                {\n+                    if diagnosed_extern_crates.contains(krate) {\n+                        continue;\n                     }\n-                    _ => {}\n                 }\n \n                 self.def_map.diagnostics.push(DefDiagnostic::unresolved_import(\n@@ -1579,13 +1578,13 @@ impl ModCollector<'_, '_> {\n                 {\n                     Ok((file_id, is_mod_rs, mod_dir)) => {\n                         let item_tree = db.file_item_tree(file_id.into());\n-                        if item_tree\n+                        let is_enabled = item_tree\n                             .top_level_attrs(db, self.def_collector.def_map.krate)\n                             .cfg()\n                             .map_or(true, |cfg| {\n                                 self.def_collector.cfg_options.check(&cfg) != Some(false)\n-                            })\n-                        {\n+                            });\n+                        if is_enabled {\n                             let module_id = self.push_child_module(\n                                 module.name.clone(),\n                                 ast_id,"}, {"sha": "81a40185bc2c40c32f7399c0abe58b7b154fa0f3", "filename": "crates/hir_expand/src/eager.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -107,7 +107,7 @@ pub fn expand_eager_macro(\n     mut diagnostic_sink: &mut dyn FnMut(mbe::ExpandError),\n ) -> Result<MacroCallId, ErrorEmitted> {\n     let parsed_args = diagnostic_sink.option_with(\n-        || Some(mbe::syntax_node_to_token_tree(&macro_call.value.token_tree()?.syntax()).0),\n+        || Some(mbe::syntax_node_to_token_tree(macro_call.value.token_tree()?.syntax()).0),\n         || err(\"malformed macro invocation\"),\n     )?;\n "}, {"sha": "8723e24bf650ee1a64859bfdbe3163944fa3cc16", "filename": "crates/hir_ty/src/chalk_db.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -205,10 +205,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                 let (datas, binders) = (*datas).as_ref().into_value_and_skipped_binders();\n                 let data = &datas.impl_traits[idx as usize];\n                 let bound = OpaqueTyDatumBound {\n-                    bounds: make_only_type_binders(\n-                        1,\n-                        data.bounds.skip_binders().iter().cloned().collect(),\n-                    ),\n+                    bounds: make_only_type_binders(1, data.bounds.skip_binders().to_vec()),\n                     where_clauses: make_only_type_binders(0, vec![]),\n                 };\n                 chalk_ir::Binders::new(binders, bound)\n@@ -309,7 +306,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         let sig_ty = substs.at(&Interner, 0).assert_ty_ref(&Interner).clone();\n         let sig = &sig_ty.callable_sig(self.db).expect(\"first closure param should be fn ptr\");\n         let io = rust_ir::FnDefInputsAndOutputDatum {\n-            argument_types: sig.params().iter().cloned().collect(),\n+            argument_types: sig.params().to_vec(),\n             return_type: sig.ret().clone(),\n         };\n         make_only_type_binders(0, io.shifted_in(&Interner))\n@@ -675,7 +672,7 @@ pub(crate) fn fn_def_datum_query(\n         inputs_and_output: make_only_type_binders(\n             0,\n             rust_ir::FnDefInputsAndOutputDatum {\n-                argument_types: sig.params().iter().cloned().collect(),\n+                argument_types: sig.params().to_vec(),\n                 return_type: sig.ret().clone(),\n             }\n             .shifted_in(&Interner),"}, {"sha": "c29fbd688a6622554e4135fe0c9945e410bba09d", "filename": "crates/hir_ty/src/chalk_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -242,7 +242,7 @@ impl TyExt for Ty {\n                         let substs = TyBuilder::type_params_subst(db, id.parent);\n                         let predicates = db\n                             .generic_predicates(id.parent)\n-                            .into_iter()\n+                            .iter()\n                             .map(|pred| pred.clone().substitute(&Interner, &substs))\n                             .filter(|wc| match &wc.skip_binders() {\n                                 WhereClause::Implemented(tr) => {"}, {"sha": "ea9b54af63c3dd3ed5d3dd370189a382bb5479bc", "filename": "crates/hir_ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -63,7 +63,7 @@ impl<'a> DeclValidator<'a> {\n             ModuleDefId::AdtId(adt) => self.validate_adt(adt),\n             ModuleDefId::ConstId(const_id) => self.validate_const(const_id),\n             ModuleDefId::StaticId(static_id) => self.validate_static(static_id),\n-            _ => return,\n+            _ => (),\n         }\n     }\n "}, {"sha": "ecaa3daeafdfab0f3cae2735dc82ddff80cc549e", "filename": "crates/hir_ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -82,10 +82,10 @@ pub(super) struct IntRange {\n impl IntRange {\n     #[inline]\n     fn is_integral(ty: &Ty) -> bool {\n-        match ty.kind(&Interner) {\n-            TyKind::Scalar(Scalar::Char | Scalar::Int(_) | Scalar::Uint(_) | Scalar::Bool) => true,\n-            _ => false,\n-        }\n+        matches!(\n+            ty.kind(&Interner),\n+            TyKind::Scalar(Scalar::Char | Scalar::Int(_) | Scalar::Uint(_) | Scalar::Bool)\n+        )\n     }\n \n     fn is_singleton(&self) -> bool {\n@@ -729,16 +729,12 @@ impl Fields {\n                         })\n                         .collect();\n \n-                    if let Some((adt, substs)) = pcx.ty.as_adt() {\n-                        if let hir_def::AdtId::EnumId(_) = adt {\n-                            let enum_variant = match ctor {\n-                                &Variant(id) => id,\n-                                _ => unreachable!(),\n-                            };\n-                            PatKind::Variant { substs: substs.clone(), enum_variant, subpatterns }\n-                        } else {\n-                            PatKind::Leaf { subpatterns }\n-                        }\n+                    if let Some((hir_def::AdtId::EnumId(_), substs)) = pcx.ty.as_adt() {\n+                        let enum_variant = match ctor {\n+                            &Variant(id) => id,\n+                            _ => unreachable!(),\n+                        };\n+                        PatKind::Variant { substs: substs.clone(), enum_variant, subpatterns }\n                     } else {\n                         PatKind::Leaf { subpatterns }\n                     }"}, {"sha": "b5d238116ffabc2c6d22e51de7ff6667e5d387a6", "filename": "crates/hir_ty/src/diagnostics/match_check/usefulness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -686,17 +686,17 @@ impl SubPatSet {\n                 SubPatSet::Empty => panic!(\"bug\"),\n                 SubPatSet::Full => {}\n                 SubPatSet::Seq { subpats } => {\n-                    for (_, sub_set) in subpats {\n+                    for sub_set in subpats.values() {\n                         fill_subpats(sub_set, unreachable_pats, cx);\n                     }\n                 }\n                 SubPatSet::Alt { subpats, pat, alt_count, .. } => {\n                     let expanded = pat.expand_or_pat(cx);\n-                    for i in 0..*alt_count {\n+                    for (i, &expanded) in expanded.iter().enumerate().take(*alt_count) {\n                         let sub_set = subpats.get(&i).unwrap_or(&SubPatSet::Empty);\n                         if sub_set.is_empty() {\n                             // Found an unreachable subpattern.\n-                            unreachable_pats.push(expanded[i]);\n+                            unreachable_pats.push(expanded);\n                         } else {\n                             fill_subpats(sub_set, unreachable_pats, cx);\n                         }"}, {"sha": "bce24b825c4ad40feed627431cb5b5334f645581", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -666,7 +666,7 @@ impl HirDisplay for Ty {\n                         let substs = generics.type_params_subst(f.db);\n                         let bounds =\n                             f.db.generic_predicates(id.parent)\n-                                .into_iter()\n+                                .iter()\n                                 .map(|pred| pred.clone().substitute(&Interner, &substs))\n                                 .filter(|wc| match &wc.skip_binders() {\n                                     WhereClause::Implemented(tr) => {"}, {"sha": "d305cda70f6181e91fc64f25e20cf19864730f45", "filename": "crates/hir_ty/src/infer/closure.rs", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -1,6 +1,6 @@\n //! Inference of closure parameter types based on the closure's expected type.\n \n-use chalk_ir::{cast::Cast, AliasTy, FnSubst, WhereClause};\n+use chalk_ir::{cast::Cast, AliasEq, AliasTy, FnSubst, WhereClause};\n use hir_def::{expr::ExprId, HasModule};\n use smallvec::SmallVec;\n \n@@ -42,46 +42,38 @@ impl InferenceContext<'_> {\n \n         let fn_traits: SmallVec<[ChalkTraitId; 3]> =\n             utils::fn_traits(self.db.upcast(), self.owner.module(self.db.upcast()).krate())\n-                .map(|tid| to_chalk_trait_id(tid))\n+                .map(to_chalk_trait_id)\n                 .collect();\n \n         let self_ty = TyKind::Error.intern(&Interner);\n         let bounds = dyn_ty.bounds.clone().substitute(&Interner, &[self_ty.cast(&Interner)]);\n         for bound in bounds.iter(&Interner) {\n             // NOTE(skip_binders): the extracted types are rebound by the returned `FnPointer`\n-            match bound.skip_binders() {\n-                WhereClause::AliasEq(eq) => match &eq.alias {\n-                    AliasTy::Projection(projection) => {\n-                        let assoc_data = self.db.associated_ty_data(projection.associated_ty_id);\n-                        if !fn_traits.contains(&assoc_data.trait_id) {\n-                            return None;\n-                        }\n+            if let WhereClause::AliasEq(AliasEq { alias: AliasTy::Projection(projection), ty }) =\n+                bound.skip_binders()\n+            {\n+                let assoc_data = self.db.associated_ty_data(projection.associated_ty_id);\n+                if !fn_traits.contains(&assoc_data.trait_id) {\n+                    return None;\n+                }\n \n-                        // Skip `Self`, get the type argument.\n-                        let arg = projection.substitution.as_slice(&Interner).get(1)?;\n-                        if let Some(subst) = arg.ty(&Interner)?.as_tuple() {\n-                            let generic_args = subst.as_slice(&Interner);\n-                            let mut sig_tys = Vec::new();\n-                            for arg in generic_args {\n-                                sig_tys.push(arg.ty(&Interner)?.clone());\n-                            }\n-                            sig_tys.push(eq.ty.clone());\n-\n-                            cov_mark::hit!(dyn_fn_param_informs_call_site_closure_signature);\n-                            return Some(FnPointer {\n-                                num_binders: bound.len(&Interner),\n-                                sig: FnSig {\n-                                    abi: (),\n-                                    safety: chalk_ir::Safety::Safe,\n-                                    variadic: false,\n-                                },\n-                                substitution: FnSubst(Substitution::from_iter(&Interner, sig_tys)),\n-                            });\n-                        }\n+                // Skip `Self`, get the type argument.\n+                let arg = projection.substitution.as_slice(&Interner).get(1)?;\n+                if let Some(subst) = arg.ty(&Interner)?.as_tuple() {\n+                    let generic_args = subst.as_slice(&Interner);\n+                    let mut sig_tys = Vec::new();\n+                    for arg in generic_args {\n+                        sig_tys.push(arg.ty(&Interner)?.clone());\n                     }\n-                    AliasTy::Opaque(_) => {}\n-                },\n-                _ => {}\n+                    sig_tys.push(ty.clone());\n+\n+                    cov_mark::hit!(dyn_fn_param_informs_call_site_closure_signature);\n+                    return Some(FnPointer {\n+                        num_binders: bound.len(&Interner),\n+                        sig: FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic: false },\n+                        substitution: FnSubst(Substitution::from_iter(&Interner, sig_tys)),\n+                    });\n+                }\n             }\n         }\n "}, {"sha": "ea71cdd8102229076bf1e185f6b4780620619897", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -63,7 +63,7 @@ impl<'a> InferenceContext<'a> {\n     /// Return the type after possible coercion.\n     pub(super) fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(expr, expected);\n-        let ty = if let Some(target) = expected.only_has_type(&mut self.table) {\n+        if let Some(target) = expected.only_has_type(&mut self.table) {\n             match self.coerce(Some(expr), &ty, &target) {\n                 Ok(res) => res.value,\n                 Err(_) => {\n@@ -77,9 +77,7 @@ impl<'a> InferenceContext<'a> {\n             }\n         } else {\n             ty\n-        };\n-\n-        ty\n+        }\n     }\n \n     fn callable_sig_from_fn_trait(&mut self, ty: &Ty, num_args: usize) -> Option<(Vec<Ty>, Ty)> {\n@@ -899,9 +897,7 @@ impl<'a> InferenceContext<'a> {\n         if let Some(builtin_rhs) = self.builtin_binary_op_rhs_expectation(op, lhs_ty.clone()) {\n             self.unify(&builtin_rhs, &rhs_ty);\n         }\n-        if let Some(builtin_ret) =\n-            self.builtin_binary_op_return_ty(op, lhs_ty.clone(), rhs_ty.clone())\n-        {\n+        if let Some(builtin_ret) = self.builtin_binary_op_return_ty(op, lhs_ty, rhs_ty) {\n             self.unify(&builtin_ret, &ret_ty);\n         }\n \n@@ -942,7 +938,7 @@ impl<'a> InferenceContext<'a> {\n             }\n         }\n \n-        let ty = if let Some(expr) = tail {\n+        if let Some(expr) = tail {\n             self.infer_expr_coerce(expr, expected)\n         } else {\n             // Citing rustc: if there is no explicit tail expression,\n@@ -961,8 +957,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 TyBuilder::unit()\n             }\n-        };\n-        ty\n+        }\n     }\n \n     fn infer_method_call(\n@@ -1032,7 +1027,7 @@ impl<'a> InferenceContext<'a> {\n         inputs: Vec<Ty>,\n     ) -> Vec<Ty> {\n         if let Some(expected_ty) = expected_output.to_option(&mut self.table) {\n-            let result = self.table.fudge_inference(|table| {\n+            self.table.fudge_inference(|table| {\n                 if table.try_unify(&expected_ty, &output).is_ok() {\n                     table.resolve_with_fallback(inputs, |var, kind, _, _| match kind {\n                         chalk_ir::VariableKind::Ty(tk) => var.to_ty(&Interner, tk).cast(&Interner),\n@@ -1046,8 +1041,7 @@ impl<'a> InferenceContext<'a> {\n                 } else {\n                     Vec::new()\n                 }\n-            });\n-            result\n+            })\n         } else {\n             Vec::new()\n         }"}, {"sha": "957cd829aacccce6afee507bc8049504f5536e0c", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -245,8 +245,7 @@ impl<'a> InferenceContext<'a> {\n             Pat::Wild => expected.clone(),\n             Pat::Range { start, end } => {\n                 let start_ty = self.infer_expr(*start, &Expectation::has_type(expected.clone()));\n-                let end_ty = self.infer_expr(*end, &Expectation::has_type(start_ty));\n-                end_ty\n+                self.infer_expr(*end, &Expectation::has_type(start_ty))\n             }\n             Pat::Lit(expr) => self.infer_expr(*expr, &Expectation::has_type(expected.clone())),\n             Pat::Box { inner } => match self.resolve_boxed_box() {\n@@ -297,10 +296,7 @@ fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n         // FIXME: ConstBlock/Path/Lit might actually evaluate to ref, but inference is unimplemented.\n         Pat::Path(..) => true,\n         Pat::ConstBlock(..) => true,\n-        Pat::Lit(expr) => match body[*expr] {\n-            Expr::Literal(Literal::String(..)) => false,\n-            _ => true,\n-        },\n+        Pat::Lit(expr) => !matches!(body[*expr], Expr::Literal(Literal::String(..))),\n         Pat::Bind {\n             mode: BindingAnnotation::Mutable | BindingAnnotation::Unannotated,\n             subpat: Some(subpat),"}, {"sha": "9f1253825ef4b4412e30fa45a6b2f5fd12203c85", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -460,12 +460,9 @@ impl<'a> InferenceTable<'a> {\n             self.new_type_var().inference_var(&Interner).expect(\"inference_var\");\n         let result = f(self);\n         self.rollback_to(snapshot);\n-\n-        let result = result\n-            .fold_with(&mut VarFudger { table: self, highest_known_var }, DebruijnIndex::INNERMOST)\n-            .expect(\"fold_with with VarFudger\");\n-\n         result\n+            .fold_with(&mut VarFudger { table: self, highest_known_var }, DebruijnIndex::INNERMOST)\n+            .expect(\"fold_with with VarFudger\")\n     }\n \n     /// This checks whether any of the free variables in the `canonicalized`"}, {"sha": "0e1afe866e23ca5e8b62597d8cf1e336494b1715", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -387,15 +387,17 @@ impl<'a> TyLoweringContext<'a> {\n         res: Option<TypeNs>,\n         remaining_segments: PathSegments<'_>,\n     ) -> (Ty, Option<TypeNs>) {\n-        if remaining_segments.len() == 1 {\n-            // resolve unselected assoc types\n-            let segment = remaining_segments.first().unwrap();\n-            (self.select_associated_type(res, segment), None)\n-        } else if remaining_segments.len() > 1 {\n-            // FIXME report error (ambiguous associated type)\n-            (TyKind::Error.intern(&Interner), None)\n-        } else {\n-            (ty, res)\n+        match remaining_segments.len() {\n+            0 => (ty, res),\n+            1 => {\n+                // resolve unselected assoc types\n+                let segment = remaining_segments.first().unwrap();\n+                (self.select_associated_type(res, segment), None)\n+            }\n+            _ => {\n+                // FIXME report error (ambiguous associated type)\n+                (TyKind::Error.intern(&Interner), None)\n+            }\n         }\n     }\n "}, {"sha": "a90e3bee68a65e2725d447e5682ca2243bdf37f5", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -141,7 +141,7 @@ impl TraitImpls {\n         let crate_def_map = db.crate_def_map(krate);\n         impls.collect_def_map(db, &crate_def_map);\n \n-        return Arc::new(impls);\n+        Arc::new(impls)\n     }\n \n     pub(crate) fn trait_impls_in_block_query(\n@@ -154,7 +154,7 @@ impl TraitImpls {\n         let block_def_map = db.block_def_map(block)?;\n         impls.collect_def_map(db, &block_def_map);\n \n-        return Some(Arc::new(impls));\n+        Some(Arc::new(impls))\n     }\n \n     fn collect_def_map(&mut self, db: &dyn HirDatabase, def_map: &DefMap) {"}, {"sha": "4b89fd5a85375e0974e9ee0a7dc792723c3a457f", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -130,8 +130,7 @@ fn solve(\n         let solution = if is_chalk_print() {\n             let logging_db =\n                 LoggingRustIrDatabaseLoggingOnDrop(LoggingRustIrDatabase::new(context));\n-            let solution = solver.solve_limited(&logging_db.0, goal, &should_continue);\n-            solution\n+            solver.solve_limited(&logging_db.0, goal, &should_continue)\n         } else {\n             solver.solve_limited(&context, goal, &should_continue)\n         };\n@@ -143,10 +142,11 @@ fn solve(\n \n     // don't set the TLS for Chalk unless Chalk debugging is active, to make\n     // extra sure we only use it for debugging\n-    let solution =\n-        if is_chalk_debug() { crate::tls::set_current_program(db, solve) } else { solve() };\n-\n-    solution\n+    if is_chalk_debug() {\n+        crate::tls::set_current_program(db, solve)\n+    } else {\n+        solve()\n+    }\n }\n \n struct LoggingRustIrDatabaseLoggingOnDrop<'a>(LoggingRustIrDatabase<Interner, ChalkContext<'a>>);"}, {"sha": "9cacc521d46e6e066a698ff74502a51282fe4fc9", "filename": "crates/hir_ty/src/walk.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fhir_ty%2Fsrc%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fwalk.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -86,11 +86,8 @@ impl TypeWalk for AliasTy {\n \n impl TypeWalk for GenericArg {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match &self.interned() {\n-            GenericArgData::Ty(ty) => {\n-                ty.walk(f);\n-            }\n-            _ => {}\n+        if let GenericArgData::Ty(ty) = &self.interned() {\n+            ty.walk(f);\n         }\n     }\n }"}, {"sha": "bf85186609fc205774c753d4cdcc49dffdf56336", "filename": "crates/mbe/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fmbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2520128dc348529afc99263f82f255d39e047d/crates%2Fmbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests.rs?ref=ac2520128dc348529afc99263f82f255d39e047d", "patch": "@@ -241,7 +241,7 @@ struct Struct {\n     field: ()\n }\n \"##;\n-    let source_file = ast::SourceFile::parse(&source).ok().unwrap();\n+    let source_file = ast::SourceFile::parse(source).ok().unwrap();\n     let item = source_file.items().next().unwrap();\n     let attr = item.attrs().nth(1).unwrap();\n \n@@ -258,7 +258,7 @@ struct Struct {\n     field: ()\n }\n \"##;\n-    let source_file = ast::SourceFile::parse(&source).ok().unwrap();\n+    let source_file = ast::SourceFile::parse(source).ok().unwrap();\n     let item = source_file.items().next().unwrap();\n     let attr = item.attrs().nth(1).unwrap();\n "}]}