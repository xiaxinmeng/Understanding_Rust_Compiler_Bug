{"sha": "15dd0a5acba78e7d086f0b9fe610e66f3369ed63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZGQwYTVhY2JhNzhlN2QwODZmMGI5ZmU2MTBlNjZmMzM2OWVkNjM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-30T20:02:46Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-30T20:02:46Z"}, "message": "rollup merge of #21385: nick29581/save-fix2\n\nr? @huonw", "tree": {"sha": "54cf696f258766f16eb11c0a319e7dcdaa198fab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54cf696f258766f16eb11c0a319e7dcdaa198fab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15dd0a5acba78e7d086f0b9fe610e66f3369ed63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15dd0a5acba78e7d086f0b9fe610e66f3369ed63", "html_url": "https://github.com/rust-lang/rust/commit/15dd0a5acba78e7d086f0b9fe610e66f3369ed63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15dd0a5acba78e7d086f0b9fe610e66f3369ed63/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "341e858bd882061b823dac236fd718d473f8ab2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/341e858bd882061b823dac236fd718d473f8ab2e", "html_url": "https://github.com/rust-lang/rust/commit/341e858bd882061b823dac236fd718d473f8ab2e"}, {"sha": "9ba99666f3f67a373f2f60dcffbff85128185425", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ba99666f3f67a373f2f60dcffbff85128185425", "html_url": "https://github.com/rust-lang/rust/commit/9ba99666f3f67a373f2f60dcffbff85128185425"}], "stats": {"total": 621, "additions": 499, "deletions": 122}, "files": [{"sha": "0dc871703f983c9dff1f98c095b8b3b2ded6c98d", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 97, "deletions": 70, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/15dd0a5acba78e7d086f0b9fe610e66f3369ed63/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15dd0a5acba78e7d086f0b9fe610e66f3369ed63/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=15dd0a5acba78e7d086f0b9fe610e66f3369ed63", "patch": "@@ -44,7 +44,7 @@ use syntax::codemap::*;\n use syntax::parse::token::{self, get_ident, keywords};\n use syntax::owned_slice::OwnedSlice;\n use syntax::visit::{self, Visitor};\n-use syntax::print::pprust::{path_to_string,ty_to_string};\n+use syntax::print::pprust::{path_to_string, ty_to_string};\n use syntax::ptr::P;\n \n use self::span_utils::SpanUtils;\n@@ -123,24 +123,36 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         let mut result: Vec<(Span, String)> = vec!();\n \n-\n         let mut segs = vec!();\n-        for (seg, span) in path.segments.iter().zip(spans.iter()) {\n+        for (i, (seg, span)) in path.segments.iter().zip(spans.iter()).enumerate() {\n             segs.push(seg.clone());\n             let sub_path = ast::Path{span: *span, // span for the last segment\n                                      global: path.global,\n                                      segments: segs};\n-            let qualname = path_to_string(&sub_path);\n+            let qualname = if i == 0 && path.global {\n+                format(\"::{}\", path_to_string(&sub_path))\n+            } else {\n+                path_to_string(&sub_path)\n+            };\n             result.push((*span, qualname));\n             segs = sub_path.segments;\n         }\n \n         result\n     }\n \n-    fn write_sub_paths(&mut self, path: &ast::Path) {\n+    // The global arg allows us to override the global-ness of the path (which\n+    // actually means 'does the path start with `::`', rather than 'is the path\n+    // semantically global). We use the override for `use` imports (etc.) where\n+    // the syntax is non-global, but the semantics are global.\n+    fn write_sub_paths(&mut self, path: &ast::Path, global: bool) {\n         let sub_paths = self.process_path_prefixes(path);\n-        for &(ref span, ref qualname) in sub_paths.iter() {\n+        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n+            let qualname = if i == 0 && global && !path.global {\n+                format!(\"::{}\", qualname)\n+            } else {\n+                qualname.clone()\n+            };\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n                                      &qualname[],\n@@ -149,16 +161,21 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     }\n \n     // As write_sub_paths, but does not process the last ident in the path (assuming it\n-    // will be processed elsewhere).\n-    fn write_sub_paths_truncated(&mut self, path: &ast::Path) {\n+    // will be processed elsewhere). See note on write_sub_paths about global.\n+    fn write_sub_paths_truncated(&mut self, path: &ast::Path, global: bool) {\n         let sub_paths = self.process_path_prefixes(path);\n         let len = sub_paths.len();\n         if len <= 1 {\n             return;\n         }\n \n-        let sub_paths = &sub_paths[.. (len-1)];\n-        for &(ref span, ref qualname) in sub_paths.iter() {\n+        let sub_paths = sub_paths[..len-1];\n+        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n+            let qualname = if i == 0 && global && !path.global {\n+                format!(\"::{}\", qualname)\n+            } else {\n+                qualname.clone()\n+            };\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n                                      &qualname[],\n@@ -276,9 +293,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         let mut scope_id;\n         // The qualname for a method is the trait name or name of the struct in an impl in\n-        // which the method is declared in followed by the method's name.\n-        let mut qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n-                                                    ast_util::local_def(method.id)) {\n+        // which the method is declared in, followed by the method's name.\n+        let qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n+                                                ast_util::local_def(method.id)) {\n             Some(impl_id) => match self.analysis.ty_cx.map.get(impl_id.node) {\n                 NodeItem(item) => {\n                     scope_id = item.id;\n@@ -296,7 +313,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                 },\n                                 None => {}\n                             }\n-                            result.push_str(\">::\");\n+                            result.push_str(\">\");\n                             result\n                         }\n                         _ => {\n@@ -321,8 +338,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     scope_id = def_id.node;\n                     match self.analysis.ty_cx.map.get(def_id.node) {\n                         NodeItem(_) => {\n-                            let mut result = ty::item_path_str(&self.analysis.ty_cx, def_id);\n-                            result.push_str(\"::\");\n+                            format!(\"::{}\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n                             result\n                         }\n                         _ => {\n@@ -340,7 +356,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             },\n         };\n \n-        qualname.push_str(get_ident(method.pe_ident()).get());\n+        let qualname = format!(\"{}::{}\", qualname, get_ident(method.pe_ident()).get());\n         let qualname = &qualname[];\n \n         // record the decl for this def (if it has one)\n@@ -435,7 +451,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     }\n \n     // Dump generic params bindings, then visit_generics\n-    fn process_generic_params(&mut self, generics:&ast::Generics,\n+    fn process_generic_params(&mut self,\n+                              generics:&ast::Generics,\n                               full_span: Span,\n                               prefix: &str,\n                               id: NodeId) {\n@@ -465,7 +482,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                   decl: &ast::FnDecl,\n                   ty_params: &ast::Generics,\n                   body: &ast::Block) {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Fn);\n         self.fmt.fn_str(item.span,\n@@ -497,7 +514,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                       mt: ast::Mutability,\n                       expr: &ast::Expr)\n     {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         // If the variable is immutable, save the initialising expression.\n         let value = match mt {\n@@ -525,7 +542,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                       typ: &ast::Ty,\n                       expr: &ast::Expr)\n     {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         let sub_span = self.span.sub_span_after_keyword(item.span,\n                                                         keywords::Const);\n@@ -547,7 +564,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                       item: &ast::Item,\n                       def: &ast::StructDef,\n                       ty_params: &ast::Generics) {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         let ctor_id = match def.ctor_id {\n             Some(node_id) => node_id,\n@@ -576,7 +593,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     item: &ast::Item,\n                     enum_definition: &ast::EnumDef,\n                     ty_params: &ast::Generics) {\n-        let enum_name = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let enum_name = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n         let val = self.span.snippet(item.span);\n         match self.span.sub_span_after_keyword(item.span, keywords::Enum) {\n             Some(sub_span) => self.fmt.enum_str(item.span,\n@@ -702,7 +719,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                      generics: &ast::Generics,\n                      trait_refs: &OwnedSlice<ast::TyParamBound>,\n                      methods: &Vec<ast::TraitItem>) {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n         self.fmt.trait_str(item.span,\n@@ -751,7 +768,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     fn process_mod(&mut self,\n                    item: &ast::Item,  // The module in question, represented as an item.\n                    m: &ast::Mod) {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         let cm = self.sess.codemap();\n         let filename = cm.span_to_filename(m.inner);\n@@ -798,7 +815,13 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                        sub_span,\n                                                        def_id,\n                                                        self.cur_scope),\n-            def::DefStaticMethod(declid, provenence) => {\n+            def::DefTy(def_id, _) => self.fmt.ref_str(recorder::TypeRef,\n+                                                      span,\n+                                                      sub_span,\n+                                                      def_id,\n+                                                      self.cur_scope),\n+            def::DefStaticMethod(declid, provenence) |\n+            def::DefMethod(declid, _, provenence) => {\n                 let sub_span = self.span.sub_span_for_meth_name(span);\n                 let defid = if declid.krate == ast::LOCAL_CRATE {\n                     let ti = ty::impl_or_trait_item(&self.analysis.ty_cx,\n@@ -840,13 +863,17 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                        Some(declid),\n                                        self.cur_scope);\n             },\n-            def::DefFn(def_id, _) => self.fmt.fn_call_str(span,\n-                                                          sub_span,\n-                                                          def_id,\n-                                                          self.cur_scope),\n+            def::DefFn(def_id, _) => {\n+                self.fmt.fn_call_str(span,\n+                                     sub_span,\n+                                     def_id,\n+                                     self.cur_scope)\n+            }\n             _ => self.sess.span_bug(span,\n-                                    &format!(\"Unexpected def kind while looking up path in '{}'\",\n-                                            self.span.snippet(span))[]),\n+                                    &format!(\"Unexpected def kind while looking \\\n+                                              up path in `{}`: `{:?}`\",\n+                                             self.span.snippet(span),\n+                                             *def)[]),\n         }\n         // modules or types in the path prefix\n         match *def {\n@@ -856,7 +883,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefConst(..) |\n             def::DefStruct(_) |\n             def::DefVariant(..) |\n-            def::DefFn(..) => self.write_sub_paths_truncated(path),\n+            def::DefFn(..) => self.write_sub_paths_truncated(path, false),\n             _ => {},\n         }\n     }\n@@ -870,21 +897,21 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             return\n         }\n \n-        let mut struct_def: Option<DefId> = None;\n-        match self.lookup_type_ref(ex.id) {\n-            Some(id) => {\n-                struct_def = Some(id);\n+        self.write_sub_paths_truncated(path, false);\n+\n+        let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, ex).sty;\n+        let struct_def = match *ty {\n+            ty::ty_struct(def_id, _) => {\n                 let sub_span = self.span.span_for_last_ident(path.span);\n                 self.fmt.ref_str(recorder::StructRef,\n                                  path.span,\n                                  sub_span,\n-                                 id,\n+                                 def_id,\n                                  self.cur_scope);\n-            },\n-            None => ()\n-        }\n-\n-        self.write_sub_paths_truncated(path);\n+                Some(def_id)\n+            }\n+            _ => None\n+        };\n \n         for field in fields.iter() {\n             match struct_def {\n@@ -1070,7 +1097,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                mod_id,\n                                                get_ident(ident).get(),\n                                                self.cur_scope);\n-                        self.write_sub_paths_truncated(path);\n+                        self.write_sub_paths_truncated(path, true);\n                     }\n                     ast::ViewPathGlob(ref path) => {\n                         // Make a comma-separated list of names of imported modules.\n@@ -1093,7 +1120,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                               item.id,\n                                               name_string.as_slice(),\n                                               self.cur_scope);\n-                        self.write_sub_paths(path);\n+                        self.write_sub_paths(path, true);\n                     }\n                     ast::ViewPathList(ref path, ref list) => {\n                         for plid in list.iter() {\n@@ -1117,28 +1144,28 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                             }\n                         }\n \n-                        self.write_sub_paths(path);\n+                        self.write_sub_paths(path, true);\n                     }\n                 }\n             }\n             ast::ItemExternCrate(ref s) => {\n-                let name = get_ident(item.ident);\n+                let name = get_ident(ident);\n                 let name = name.get();\n-                let s = match *s {\n+                let location = match *s {\n                     Some((ref s, _)) => s.get().to_string(),\n                     None => name.to_string(),\n                 };\n-                let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Crate);\n-                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n+                let alias_span = self.span.span_for_last_ident(i.span);\n+                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(id) {\n                     Some(cnum) => cnum,\n                     None => 0,\n                 };\n-                self.fmt.extern_crate_str(item.span,\n-                                          sub_span,\n-                                          item.id,\n+                self.fmt.extern_crate_str(i.span,\n+                                          alias_span,\n+                                          id,\n                                           cnum,\n                                           name,\n-                                          &s[],\n+                                          &location[],\n                                           self.cur_scope);\n             }\n             ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n@@ -1164,7 +1191,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.process_trait(item, generics, trait_refs, methods),\n             ast::ItemMod(ref m) => self.process_mod(item, m),\n             ast::ItemTy(ref ty, ref ty_params) => {\n-                let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n                 let value = ty_to_string(&**ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 self.fmt.typedef_str(item.span,\n@@ -1224,9 +1251,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                            ast_util::local_def(method_type.id)) {\n                     Some(def_id) => {\n                         scope_id = def_id.node;\n-                        let mut s = ty::item_path_str(&self.analysis.ty_cx, def_id);\n-                        s.push_str(\"::\");\n-                        s\n+                        format!(\"::{}::\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n                     },\n                     None => {\n                         self.sess.span_bug(method_type.span,\n@@ -1283,7 +1308,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     None => ()\n                 }\n \n-                self.write_sub_paths_truncated(path);\n+                self.write_sub_paths_truncated(path, false);\n \n                 visit::walk_path(self, path);\n             },\n@@ -1321,8 +1346,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 }\n \n                 self.visit_expr(&**sub_ex);\n-\n-                match ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty {\n+                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n+                match *ty {\n                     ty::ty_struct(def_id, _) => {\n                         let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n                         for f in fields.iter() {\n@@ -1336,9 +1361,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                 break;\n                             }\n                         }\n-                    },\n+                    }\n                     _ => self.sess.span_bug(ex.span,\n-                                            \"Expected struct type, but not ty_struct\"),\n+                                            &format!(\"Expected struct type, found {:?}\", ty)[]),\n                 }\n             },\n             ast::ExprTupField(ref sub_ex, idx) => {\n@@ -1348,12 +1373,13 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n                 self.visit_expr(&**sub_ex);\n \n-                match ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty {\n+                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n+                match *ty {\n                     ty::ty_struct(def_id, _) => {\n                         let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n                         for (i, f) in fields.iter().enumerate() {\n                             if i == idx.node {\n-                                let sub_span = self.span.span_for_last_ident(ex.span);\n+                                let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n                                 self.fmt.ref_str(recorder::VarRef,\n                                                  ex.span,\n                                                  sub_span,\n@@ -1362,9 +1388,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                 break;\n                             }\n                         }\n-                    },\n+                    }\n+                    ty::ty_tup(_) => {}\n                     _ => self.sess.span_bug(ex.span,\n-                                            \"Expected struct type, but not ty_struct\"),\n+                                            &format!(\"Expected struct or tuple \\\n+                                                      type, found {:?}\", ty)[]),\n                 }\n             },\n             ast::ExprClosure(_, _, ref decl, ref body) => {\n@@ -1440,7 +1468,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                           &value[],\n                                           \"\")\n                 }\n-                def::DefVariant(..) => {\n+                def::DefVariant(..) | def::DefTy(..) | def::DefStruct(..) => {\n                     paths_to_process.push((id, p.clone(), Some(ref_kind)))\n                 }\n                 // FIXME(nrc) what are these doing here?\n@@ -1568,8 +1596,7 @@ pub fn process_crate(sess: &Session,\n                         SpanUtils {\n                             sess: sess,\n                             err_count: Cell::new(0)\n-                        },\n-                        cratename.clone()),\n+                        }),\n         span: SpanUtils {\n             sess: sess,\n             err_count: Cell::new(0)"}, {"sha": "1378d40920808570c6ae64f2ba761e85bee149d3", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/15dd0a5acba78e7d086f0b9fe610e66f3369ed63/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15dd0a5acba78e7d086f0b9fe610e66f3369ed63/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=15dd0a5acba78e7d086f0b9fe610e66f3369ed63", "patch": "@@ -50,7 +50,6 @@ impl Recorder {\n pub struct FmtStrs<'a> {\n     pub recorder: Box<Recorder>,\n     span: SpanUtils<'a>,\n-    krate: String,\n }\n \n macro_rules! s { ($e:expr) => { format!(\"{}\", $e) }}\n@@ -63,7 +62,7 @@ macro_rules! svec {\n     })\n }\n \n-#[derive(Copy,Debug)]\n+#[derive(Copy, Debug, Eq, PartialEq)]\n pub enum Row {\n     Variable,\n     Enum,\n@@ -92,11 +91,10 @@ pub enum Row {\n }\n \n impl<'a> FmtStrs<'a> {\n-    pub fn new(rec: Box<Recorder>, span: SpanUtils<'a>, krate: String) -> FmtStrs<'a> {\n+    pub fn new(rec: Box<Recorder>, span: SpanUtils<'a>) -> FmtStrs<'a> {\n         FmtStrs {\n             recorder: rec,\n             span: span,\n-            krate: krate,\n         }\n     }\n \n@@ -177,16 +175,7 @@ impl<'a> FmtStrs<'a> {\n         });\n \n         let pairs = fields.iter().zip(values);\n-        let strs = pairs.map(|(f, v)| format!(\",{},\\\"{}\\\"\", f, escape(\n-            if *f == \"qualname\" && v.len() > 0 {\n-                let mut n = self.krate.clone();\n-                n.push_str(\"::\");\n-                n.push_str(v);\n-                n\n-            } else {\n-                String::from_str(v)\n-            }\n-        )));\n+        let strs = pairs.map(|(f, v)| format!(\",{},\\\"{}\\\"\", f, escape(String::from_str(v))));\n         Some(strs.fold(String::new(), |mut s, ss| {\n             s.push_str(&ss[]);\n             s\n@@ -507,13 +496,13 @@ impl<'a> FmtStrs<'a> {\n     }\n \n     pub fn extern_crate_str(&mut self,\n-                          span: Span,\n-                          sub_span: Option<Span>,\n-                          id: NodeId,\n-                          cnum: ast::CrateNum,\n-                          name: &str,\n-                          loc: &str,\n-                          parent: NodeId) {\n+                            span: Span,\n+                            sub_span: Option<Span>,\n+                            id: NodeId,\n+                            cnum: ast::CrateNum,\n+                            name: &str,\n+                            loc: &str,\n+                            parent: NodeId) {\n         self.check_and_record(ExternCrate,\n                               span,\n                               sub_span,"}, {"sha": "0e623ab1b7e04c87abf629bb4e160895e1121399", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/15dd0a5acba78e7d086f0b9fe610e66f3369ed63/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15dd0a5acba78e7d086f0b9fe610e66f3369ed63/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=15dd0a5acba78e7d086f0b9fe610e66f3369ed63", "patch": "@@ -37,7 +37,7 @@ impl<'a> SpanUtils<'a> {\n         let lo_pos_byte = self.sess.codemap().lookup_byte_offset(span.lo).pos;\n         let hi_pos_byte = self.sess.codemap().lookup_byte_offset(span.hi).pos;\n \n-        format!(\"file_name,{},file_line,{},file_col,{},extent_start,{},extent_start_bytes,{},\\\n+        format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},extent_start,{},extent_start_bytes,{},\\\n                  file_line_end,{},file_col_end,{},extent_end,{},extent_end_bytes,{}\",\n                 lo_loc.file.name,\n                 lo_loc.line, lo_loc.col.to_usize(), lo_pos.to_usize(), lo_pos_byte.to_usize(),\n@@ -205,6 +205,7 @@ impl<'a> SpanUtils<'a> {\n             bracket_count += match prev.tok {\n                 token::Lt => 1,\n                 token::Gt => -1,\n+                token::BinOp(token::Shl) => 2,\n                 token::BinOp(token::Shr) => -2,\n                 _ => 0\n             };\n@@ -296,13 +297,25 @@ impl<'a> SpanUtils<'a> {\n     pub fn sub_span_after_keyword(&self,\n                                   span: Span,\n                                   keyword: keywords::Keyword) -> Option<Span> {\n+        self.sub_span_after(span, |t| t.is_keyword(keyword))\n+    }\n+\n+    pub fn sub_span_after_token(&self,\n+                                span: Span,\n+                                tok: Token) -> Option<Span> {\n+        self.sub_span_after(span, |t| t == tok)\n+    }\n+\n+    fn sub_span_after<F: Fn(Token) -> bool>(&self,\n+                                            span: Span,\n+                                            f: F) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         loop {\n             let ts = toks.real_token();\n             if ts.tok == token::Eof {\n                 return None;\n             }\n-            if ts.tok.is_keyword(keyword) {\n+            if f(ts.tok) {\n                 let ts = toks.real_token();\n                 if ts.tok == token::Eof {\n                     return None\n@@ -313,6 +326,7 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n+\n     // Returns a list of the spans of idents in a patch.\n     // E.g., For foo::bar<x,t>::baz, we return [foo, bar, baz] (well, their spans)\n     pub fn spans_for_path_segments(&self, path: &ast::Path) -> Vec<Span> {"}, {"sha": "fe70ac1edef6e782569e9c14b92c698995d80d0a", "filename": "src/test/run-make/save-analysis/SameDir.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/15dd0a5acba78e7d086f0b9fe610e66f3369ed63/src%2Ftest%2Frun-make%2Fsave-analysis%2FSameDir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15dd0a5acba78e7d086f0b9fe610e66f3369ed63/src%2Ftest%2Frun-make%2Fsave-analysis%2FSameDir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2FSameDir.rs?ref=15dd0a5acba78e7d086f0b9fe610e66f3369ed63", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// sub-module in the same directory as the main crate file\n+\n+pub struct SameStruct {\n+    pub name: String\n+}"}, {"sha": "315f900868b45443131616e4672f97ed13764c8d", "filename": "src/test/run-make/save-analysis/SameDir3.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/15dd0a5acba78e7d086f0b9fe610e66f3369ed63/src%2Ftest%2Frun-make%2Fsave-analysis%2FSameDir3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15dd0a5acba78e7d086f0b9fe610e66f3369ed63/src%2Ftest%2Frun-make%2Fsave-analysis%2FSameDir3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2FSameDir3.rs?ref=15dd0a5acba78e7d086f0b9fe610e66f3369ed63", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn hello(x: isize) {\n+    println!(\"macro {} :-(\", x);\n+}"}, {"sha": "5ce7855da2af65b562570855a9b7e115c3128628", "filename": "src/test/run-make/save-analysis/SubDir/mod.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/15dd0a5acba78e7d086f0b9fe610e66f3369ed63/src%2Ftest%2Frun-make%2Fsave-analysis%2FSubDir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15dd0a5acba78e7d086f0b9fe610e66f3369ed63/src%2Ftest%2Frun-make%2Fsave-analysis%2FSubDir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2FSubDir%2Fmod.rs?ref=15dd0a5acba78e7d086f0b9fe610e66f3369ed63", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// sub-module in a sub-directory\n+\n+use sub::sub2 as msalias;\n+use sub::sub2;\n+use std::io::stdio::println;\n+\n+static yy: usize = 25us;\n+\n+mod sub {\n+    pub mod sub2 {\n+        use std::io::stdio::println;\n+        pub mod sub3 {\n+            use std::io::stdio::println;\n+            pub fn hello() {\n+                println(\"hello from module 3\");\n+            }\n+        }\n+        pub fn hello() {\n+            println(\"hello from a module\");\n+        }\n+\n+        pub struct nested_struct {\n+            pub field2: u32,\n+        }\n+    }\n+}\n+\n+pub struct SubStruct {\n+    pub name: String\n+}"}, {"sha": "da56e616fcf976274df83117adfd06633b2c4d2f", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 308, "deletions": 29, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/15dd0a5acba78e7d086f0b9fe610e66f3369ed63/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15dd0a5acba78e7d086f0b9fe610e66f3369ed63/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=15dd0a5acba78e7d086f0b9fe610e66f3369ed63", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,53 +8,332 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![ crate_name = \"test\" ]\n+#![allow(unstable)]\n #![feature(box_syntax)]\n \n-struct Foo {\n-    f: int\n+extern crate graphviz;\n+// A simple rust project\n+\n+extern crate \"flate\" as myflate;\n+\n+use graphviz::maybe_owned_vec::MaybeOwnedVector;\n+use std::collections::{HashMap,HashSet};\n+use std::cell::RefCell;\n+use std::io::stdio::println;\n+\n+\n+use sub::sub2 as msalias;\n+use sub::sub2;\n+use sub::sub2::nested_struct as sub_struct;\n+use std::num::Float;\n+use std::num::cast;\n+use std::num::{from_int,from_i8,from_i32};\n+\n+use std::mem::size_of;\n+\n+static uni: &'static str = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n+static yy: usize = 25us;\n+\n+static bob: Option<graphviz::maybe_owned_vec::MaybeOwnedVector<'static, isize>> = None;\n+\n+// buglink test - see issue #1337.\n+\n+fn test_alias<I: Iterator>(i: Option<<I as Iterator>::Item>) {\n+    let s = sub_struct{ field2: 45u32, };\n+\n+    // import tests\n+    fn foo(x: &Float) {}\n+    let _: Option<u8> = from_i32(45);\n+\n+    let x = 42us;\n+\n+    myflate::deflate_bytes(&[]);\n+\n+    let x = (3is, 4us);\n+    let y = x.1;\n+}\n+\n+struct TupStruct(int, int, Box<str>);\n+\n+fn test_tup_struct(x: TupStruct) -> int {\n+    x.1\n+}\n+\n+mod sub {\n+    pub mod sub2 {\n+        use std::io::stdio::println;\n+        pub mod sub3 {\n+            use std::io::stdio::println;\n+            pub fn hello() {\n+                println(\"hello from module 3\");\n+            }\n+        }\n+        pub fn hello() {\n+            println(\"hello from a module\");\n+        }\n+\n+        pub struct nested_struct {\n+            pub field2: u32,\n+        }\n+\n+        pub enum nested_enum {\n+            Nest2 = 2,\n+            Nest3 = 3\n+        }\n+    }\n+}\n+\n+pub mod SameDir;\n+pub mod SubDir;\n+\n+#[path = \"SameDir3.rs\"]\n+pub mod SameDir2;\n+\n+struct nofields;\n+\n+#[derive(Clone)]\n+struct some_fields {\n+    field1: u32,\n+}\n+\n+type SF = some_fields;\n+\n+trait SuperTrait {\n+}\n+\n+trait SomeTrait: SuperTrait {\n+    fn Method(&self, x: u32) -> u32;\n+\n+    fn prov(&self, x: u32) -> u32 {\n+        println(x.to_string().as_slice());\n+        42\n+    }\n+    fn provided_method(&self) -> u32 {\n+        42\n+    }\n+}\n+\n+trait SubTrait: SomeTrait {\n+    fn stat2(x: &Self) -> u32 {\n+        32\n+    }\n+}\n+\n+impl SomeTrait for some_fields {\n+    fn Method(&self, x: u32) -> u32 {\n+        println(x.to_string().as_slice());\n+        self.field1\n+    }\n+}\n+\n+impl SuperTrait for some_fields {\n+}\n+\n+impl SubTrait for some_fields {}\n+\n+impl some_fields {\n+    fn stat(x: u32) -> u32 {\n+        println(x.to_string().as_slice());\n+        42\n+    }\n+    fn stat2(x: &some_fields) -> u32 {\n+        42\n+    }\n+\n+    fn align_to<T>(&mut self) {\n+    }\n+\n+    fn test(&mut self) {\n+        self.align_to::<bool>();\n+    }\n }\n \n-impl Foo {\n-    fn bar(&self) -> int {\n-        println!(\"f is {}\", self.f);\n-        self.f\n+impl SuperTrait for nofields {\n+}\n+impl SomeTrait for nofields {\n+    fn Method(&self, x: u32) -> u32 {\n+        self.Method(x);\n+        43\n+    }\n+\n+    fn provided_method(&self) -> u32 {\n+        21\n     }\n }\n \n-trait Tr {\n-    fn tar(&self, x: Box<Foo>) -> Foo;\n+impl SubTrait for nofields {}\n+\n+impl SuperTrait for (Box<nofields>, Box<some_fields>) {}\n+\n+fn f_with_params<T: SomeTrait>(x: &T) {\n+    x.Method(41);\n }\n \n-impl Tr for Foo {\n-    fn tar(&self, x: Box<Foo>) -> Foo {\n-        Foo{ f: self.f + x.f }\n+type MyType = Box<some_fields>;\n+\n+enum SomeEnum<'a> {\n+    Ints(isize, isize),\n+    Floats(f64, f64),\n+    Strings(&'a str, &'a str, &'a str),\n+    MyTypes(MyType, MyType)\n+}\n+\n+#[derive(Copy)]\n+enum SomeOtherEnum {\n+    SomeConst1,\n+    SomeConst2,\n+    SomeConst3\n+}\n+\n+enum SomeStructEnum {\n+    EnumStruct{a:isize, b:isize},\n+    EnumStruct2{f1:MyType, f2:MyType},\n+    EnumStruct3{f1:MyType, f2:MyType, f3:SomeEnum<'static>}\n+}\n+\n+fn matchSomeEnum(val: SomeEnum) {\n+    match val {\n+        SomeEnum::Ints(int1, int2) => { println((int1+int2).to_string().as_slice()); }\n+        SomeEnum::Floats(float1, float2) => { println((float2*float1).to_string().as_slice()); }\n+        SomeEnum::Strings(_, _, s3) => { println(s3); }\n+        SomeEnum::MyTypes(mt1, mt2) => {\n+            println((mt1.field1 - mt2.field1).to_string().as_slice());\n+        }\n     }\n }\n \n-trait Tr2<X, Y: Tr> {\n-    fn squid(&self, y: &Y, z: Self) -> Box<X>;\n+fn matchSomeStructEnum(se: SomeStructEnum) {\n+    match se {\n+        SomeStructEnum::EnumStruct{a:a, ..} => println(a.to_string().as_slice()),\n+        SomeStructEnum::EnumStruct2{f1:f1, f2:f_2} => println(f_2.field1.to_string().as_slice()),\n+        SomeStructEnum::EnumStruct3{f1, ..} => println(f1.field1.to_string().as_slice()),\n+    }\n }\n \n-impl Tr2<Foo, Foo> for Foo {\n-    fn squid(&self, y: &Foo, z: Foo) -> Box<Foo> {\n-        box Foo { f: y.f + z.f + self.f }\n+\n+fn matchSomeStructEnum2(se: SomeStructEnum) {\n+    use SomeStructEnum::*;\n+    match se {\n+        EnumStruct{a: ref aaa, ..} => println(aaa.to_string().as_slice()),\n+        EnumStruct2{f1, f2: f2} => println(f1.field1.to_string().as_slice()),\n+        EnumStruct3{f1, f3: SomeEnum::Ints(_, _), f2} => println(f1.field1.to_string().as_slice()),\n+        _ => {},\n     }\n }\n \n-enum En {\n-    Var1,\n-    Var2,\n-    Var3(int, int, Foo)\n+fn matchSomeOtherEnum(val: SomeOtherEnum) {\n+    use SomeOtherEnum::{SomeConst2, SomeConst3};\n+    match val {\n+        SomeOtherEnum::SomeConst1 => { println(\"I'm const1.\"); }\n+        SomeConst2 | SomeConst3 => { println(\"I'm const2 or const3.\"); }\n+    }\n }\n \n-fn main() {\n-    let x = Foo { f: 237 };\n-    let _f = x.bar();\n-    let en = En::Var2;\n+fn hello<X: SomeTrait>((z, a) : (u32, String), ex: X) {\n+    SameDir2::hello(43);\n+\n+    println(yy.to_string().as_slice());\n+    let (x, y): (u32, u32) = (5, 3);\n+    println(x.to_string().as_slice());\n+    println(z.to_string().as_slice());\n+    let x: u32 = x;\n+    println(x.to_string().as_slice());\n+    let x = \"hello\";\n+    println(x);\n+\n+    let x = 32.0f32;\n+    let _ = (x + ((x * x) + 1.0).sqrt()).ln();\n \n-    let _ = match en {\n-        En::Var1 => x.bar(),\n-        En::Var2 => 34,\n-        En::Var3(x, y, f) => f.bar()\n+    let s: Box<SomeTrait> = box some_fields {field1: 43};\n+    let s2: Box<some_fields> =  box some_fields {field1: 43};\n+    let s3 = box nofields;\n+\n+    s.Method(43);\n+    s3.Method(43);\n+    s2.Method(43);\n+\n+    ex.prov(43);\n+\n+    let y: u32 = 56;\n+    // static method on struct\n+    let r = some_fields::stat(y);\n+    // trait static method, calls override\n+    let r = SubTrait::stat2(&*s2);\n+    // trait static method, calls default\n+    let r = SubTrait::stat2(&*s3);\n+\n+    let s4 = s3 as Box<SomeTrait>;\n+    s4.Method(43);\n+\n+    s4.provided_method();\n+    s2.prov(45);\n+\n+    let closure = |&: x: u32, s: &SomeTrait| {\n+        s.Method(23);\n+        return x + y;\n+    };\n+\n+    let z = closure(10, &*s);\n+}\n+\n+pub struct blah {\n+    used_link_args: RefCell<[&'static str; 0]>,\n+}\n+\n+fn main() { // foo\n+    let s = box some_fields {field1: 43};\n+    hello((43, \"a\".to_string()), *s);\n+    sub::sub2::hello();\n+    sub2::sub3::hello();\n+\n+    let h = sub2::sub3::hello;\n+    h();\n+\n+    // utf8 chars\n+    let ut = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n+\n+    // For some reason, this pattern of macro_rules foiled our generated code\n+    // avoiding strategy.\n+    macro_rules! variable_str(($name:expr) => (\n+        some_fields {\n+            field1: $name,\n+        }\n+    ));\n+    let vs = variable_str!(32);\n+\n+    let mut candidates: RefCell<HashMap<&'static str, &'static str>> = RefCell::new(HashMap::new());\n+    let _ = blah {\n+        used_link_args: RefCell::new([]),\n     };\n+    let s1 = nofields;\n+    let s2 = SF { field1: 55};\n+    let s3: some_fields = some_fields{ field1: 55};\n+    let s4: msalias::nested_struct = sub::sub2::nested_struct{ field2: 55};\n+    let s4: msalias::nested_struct = sub2::nested_struct{ field2: 55};\n+    println(s2.field1.to_string().as_slice());\n+    let s5: MyType = box some_fields{ field1: 55};\n+    let s = SameDir::SameStruct{name: \"Bob\".to_string()};\n+    let s = SubDir::SubStruct{name:\"Bob\".to_string()};\n+    let s6: SomeEnum = SomeEnum::MyTypes(box s2.clone(), s5);\n+    let s7: SomeEnum = SomeEnum::Strings(\"one\", \"two\", \"three\");\n+    matchSomeEnum(s6);\n+    matchSomeEnum(s7);\n+    let s8: SomeOtherEnum = SomeOtherEnum::SomeConst2;\n+    matchSomeOtherEnum(s8);\n+    let s9: SomeStructEnum =\n+        SomeStructEnum::EnumStruct2{f1: box some_fields{field1:10}, f2: box s2};\n+    matchSomeStructEnum(s9);\n+}\n+\n+impl Iterator for nofields {\n+    type Item = (usize, usize);\n+\n+    fn next(&mut self) -> Option<(usize, usize)> {\n+        panic!()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        panic!()\n+    }\n }"}]}