{"sha": "8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMDdmOGE0ZmFkM2U1OTM1ODM1NjEwMGM1Y2JkOWEzOWU2ZDY4YmQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-06T15:32:47Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-09T14:45:28Z"}, "message": "trans: Reify functions & methods to fn ptrs only where necessary.", "tree": {"sha": "1ffc455b56e7cb45c75d81272d312e653cbbb8f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ffc455b56e7cb45c75d81272d312e653cbbb8f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "html_url": "https://github.com/rust-lang/rust/commit/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c284099f5678da0d6cae52757fffe0c2c0eb2d1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c284099f5678da0d6cae52757fffe0c2c0eb2d1f", "html_url": "https://github.com/rust-lang/rust/commit/c284099f5678da0d6cae52757fffe0c2c0eb2d1f"}], "stats": {"total": 2005, "additions": 685, "deletions": 1320}, "files": [{"sha": "02dfeb80b928f0c5b18e3adc119806c7026742cc", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -148,11 +148,11 @@ impl<'tcx> Substs<'tcx> {\n         Substs { types: types, regions: regions }\n     }\n \n-    pub fn with_method_from(self,\n+    pub fn with_method_from(&self,\n                             meth_substs: &Substs<'tcx>)\n                             -> Substs<'tcx>\n     {\n-        let Substs { types, regions } = self;\n+        let Substs { types, regions } = self.clone();\n         let types = types.with_slice(FnSpace, meth_substs.types.get_slice(FnSpace));\n         let regions = regions.map(|r| {\n             r.with_slice(FnSpace, meth_substs.regions().get_slice(FnSpace))"}, {"sha": "8a2f0c0c093041fe9c6011386bd94031794c03a7", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -278,7 +278,7 @@ pub enum Vtable<'tcx, N> {\n #[derive(Clone, PartialEq, Eq)]\n pub struct VtableImplData<'tcx, N> {\n     pub impl_def_id: DefId,\n-    pub substs: subst::Substs<'tcx>,\n+    pub substs: &'tcx subst::Substs<'tcx>,\n     pub nested: Vec<N>\n }\n "}, {"sha": "e36307feddbf79b3a7ec68bdfcd414bbd19cf97a", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -948,7 +948,7 @@ fn confirm_impl_candidate<'cx,'tcx>(\n     for impl_item in &selcx.tcx().impl_items.borrow()[&impl_vtable.impl_def_id] {\n         if let ty::TypeTraitItem(ref assoc_ty) = impl_or_trait_items_map[&impl_item.def_id()] {\n             if assoc_ty.name == obligation.predicate.item_name {\n-                return (assoc_ty.ty.unwrap().subst(selcx.tcx(), &impl_vtable.substs),\n+                return (assoc_ty.ty.unwrap().subst(selcx.tcx(), impl_vtable.substs),\n                         impl_vtable.nested);\n             }\n         }"}, {"sha": "2ecfa119007b8c88bb8e141ab208270d64d17ba3", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -2305,7 +2305,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         impl_obligations.append(&mut substs.obligations);\n \n         VtableImplData { impl_def_id: impl_def_id,\n-                         substs: substs.value,\n+                         substs: self.tcx().mk_substs(substs.value),\n                          nested: impl_obligations }\n     }\n "}, {"sha": "903b7c80bafabee8633dabb94537a4537d67def1", "filename": "src/librustc/middle/traits/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -147,9 +147,10 @@ impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n     fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let substs = self.substs.fold_with(folder);\n         traits::VtableImplData {\n             impl_def_id: self.impl_def_id,\n-            substs: self.substs.fold_with(folder),\n+            substs: folder.tcx().mk_substs(substs),\n             nested: self.nested.fold_with(folder),\n         }\n     }"}, {"sha": "2b83aaccdc46bba7fa554266b9b27864723765ac", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -602,14 +602,14 @@ impl<'tcx> TyCtxt<'tcx> {\n #[derive(Debug)]\n pub struct ImplMethod<'tcx> {\n     pub method: Rc<ty::Method<'tcx>>,\n-    pub substs: Substs<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n     pub is_provided: bool\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n     pub fn get_impl_method(&self,\n                            impl_def_id: DefId,\n-                           substs: Substs<'tcx>,\n+                           substs: &'tcx Substs<'tcx>,\n                            name: Name)\n                            -> ImplMethod<'tcx>\n     {\n@@ -636,9 +636,10 @@ impl<'tcx> TyCtxt<'tcx> {\n                 if meth.name == name {\n                     let impl_to_trait_substs = self\n                         .make_substs_for_receiver_types(&trait_ref, meth);\n+                    let substs = impl_to_trait_substs.subst(self, substs);\n                     return ImplMethod {\n                         method: meth.clone(),\n-                        substs: impl_to_trait_substs.subst(self, &substs),\n+                        substs: self.mk_substs(substs),\n                         is_provided: true\n                     }\n                 }"}, {"sha": "4556611df594b3dbf533a484adc78ac3a1eea115", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -861,20 +861,10 @@ impl<'tcx> Debug for TypedConstVal<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n-pub enum ItemKind {\n-    Constant,\n-    /// This is any sort of callable (usually those that have a type of `fn(\u2026) -> \u2026`). This\n-    /// includes functions, constructors, but not methods which have their own ItemKind.\n-    Function,\n-    Method,\n-}\n-\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {\n     Item {\n         def_id: DefId,\n-        kind: ItemKind,\n         substs: &'tcx Substs<'tcx>,\n     },\n     Value {"}, {"sha": "8c435b45daeff14953d8e049184d75049f68dad8", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -12,7 +12,6 @@\n //! kind of thing.\n \n use build::Builder;\n-use hair::*;\n use rustc::middle::ty::Ty;\n use rustc::mir::repr::*;\n use std::u32;\n@@ -59,16 +58,4 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             });\n         temp\n     }\n-\n-    pub fn item_ref_operand(&mut self,\n-                            span: Span,\n-                            item_ref: ItemRef<'tcx>)\n-                            -> Operand<'tcx> {\n-        let literal = Literal::Item {\n-            def_id: item_ref.def_id,\n-            kind: item_ref.kind,\n-            substs: item_ref.substs,\n-        };\n-        self.literal_operand(span, item_ref.ty, literal)\n-    }\n }"}, {"sha": "3d14ad2374bb43e1fdff70b97d652fc3ee12e972", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -503,7 +503,6 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             ty: self.hir.tcx().lookup_item_type(funcdid).ty,\n             literal: Literal::Item {\n                 def_id: funcdid,\n-                kind: ItemKind::Function,\n                 substs: self.hir.tcx().mk_substs(Substs::empty())\n             }\n         }\n@@ -641,7 +640,6 @@ fn build_free<'tcx>(tcx: &TyCtxt<'tcx>,\n             ty: tcx.lookup_item_type(free_func).ty.subst(tcx, substs),\n             literal: Literal::Item {\n                 def_id: free_func,\n-                kind: ItemKind::Function,\n                 substs: substs\n             }\n         }),"}, {"sha": "cbd6bed81a68fcfd7f53e337d84d4fa245de2ed4", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -581,7 +581,6 @@ fn method_callee<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n         kind: ExprKind::Literal {\n             literal: Literal::Item {\n                 def_id: callee.def_id,\n-                kind: ItemKind::Method,\n                 substs: callee.substs,\n             },\n         },\n@@ -618,14 +617,13 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n     let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(expr.id).substs);\n     // Otherwise there may be def_map borrow conflicts\n     let def = cx.tcx.def_map.borrow()[&expr.id].full_def();\n-    let (def_id, kind) = match def {\n+    let def_id = match def {\n         // A regular function.\n-        Def::Fn(def_id) => (def_id, ItemKind::Function),\n-        Def::Method(def_id) => (def_id, ItemKind::Method),\n+        Def::Fn(def_id) | Def::Method(def_id) => def_id,\n         Def::Struct(def_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n             // A tuple-struct constructor. Should only be reached if not called in the same\n             // expression.\n-            ty::TyFnDef(..) => (def_id, ItemKind::Function),\n+            ty::TyFnDef(..) => def_id,\n             // A unit struct which is used as a value. We return a completely different ExprKind\n             // here to account for this special case.\n             ty::TyStruct(adt_def, substs) => return ExprKind::Adt {\n@@ -640,7 +638,7 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n         Def::Variant(enum_id, variant_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n             // A variant constructor. Should only be reached if not called in the same\n             // expression.\n-            ty::TyFnDef(..) => (variant_id, ItemKind::Function),\n+            ty::TyFnDef(..) => variant_id,\n             // A unit variant, similar special case to the struct case above.\n             ty::TyEnum(adt_def, substs) => {\n                 debug_assert!(adt_def.did == enum_id);\n@@ -660,7 +658,7 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n             if let Some(v) = cx.try_const_eval_literal(expr) {\n                 return ExprKind::Literal { literal: v };\n             } else {\n-                (def_id, ItemKind::Constant)\n+                def_id\n             }\n         }\n \n@@ -677,7 +675,7 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n                 &format!(\"def `{:?}` not yet implemented\", def)),\n     };\n     ExprKind::Literal {\n-        literal: Literal::Item { def_id: def_id, kind: kind, substs: substs }\n+        literal: Literal::Item { def_id: def_id, substs: substs }\n     }\n }\n "}, {"sha": "6a22dce7af9d262f985ac78fe03e4681e0c9673d", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -14,7 +14,7 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc::mir::repr::{BinOp, BorrowKind, Field, Literal, Mutability, UnOp, ItemKind,\n+use rustc::mir::repr::{BinOp, BorrowKind, Field, Literal, Mutability, UnOp,\n     TypedConstVal};\n use rustc::middle::const_eval::ConstVal;\n use rustc::middle::def_id::DefId;\n@@ -28,14 +28,6 @@ use self::cx::Cx;\n \n pub mod cx;\n \n-#[derive(Clone, Debug)]\n-pub struct ItemRef<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub kind: ItemKind,\n-    pub def_id: DefId,\n-    pub substs: &'tcx Substs<'tcx>,\n-}\n-\n #[derive(Clone, Debug)]\n pub struct Block<'tcx> {\n     pub extent: CodeExtent,"}, {"sha": "98e9a1c98ad84387ef62cbef0b1890082a842901", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -50,7 +50,6 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                           expr_ty(bcx, &out.expr),\n                                           out_datum,\n                                           cleanup::CustomScope(temp_scope),\n-                                          callee::DontAutorefArg,\n                                           &mut inputs);\n             if out.is_rw {\n                 ext_inputs.push(*inputs.last().unwrap());\n@@ -64,7 +63,6 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                               expr_ty(bcx, &out.expr),\n                                               out_datum,\n                                               cleanup::CustomScope(temp_scope),\n-                                              callee::DontAutorefArg,\n                                               &mut ext_inputs);\n                 ext_constraints.push(i.to_string());\n             }\n@@ -80,7 +78,6 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                     expr_ty(bcx, &input),\n                                     in_datum,\n                                     cleanup::CustomScope(temp_scope),\n-                                    callee::DontAutorefArg,\n                                     &mut inputs);\n     }\n     inputs.extend_from_slice(&ext_inputs[..]);"}, {"sha": "5088dabfbe78ea02b86b229dd8cb7905a7f9a235", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -195,16 +195,14 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_ty: Ty<'tcx>,\n                                 name: &str,\n-                                did: DefId)\n+                                attrs: &[ast::Attribute])\n                                 -> ValueRef {\n     if let Some(n) = ccx.externs().borrow().get(name) {\n         return *n;\n     }\n \n     let f = declare::declare_rust_fn(ccx, name, fn_ty);\n-\n-    let attrs = ccx.sess().cstore.item_attrs(did);\n-    attributes::from_fn_attrs(ccx, &attrs[..], f);\n+    attributes::from_fn_attrs(ccx, &attrs, f);\n \n     ccx.externs().borrow_mut().insert(name.to_string(), f);\n     f\n@@ -621,8 +619,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                                 source: Ty<'tcx>,\n                                 target: Ty<'tcx>,\n-                                old_info: Option<ValueRef>,\n-                                param_substs: &'tcx Substs<'tcx>)\n+                                old_info: Option<ValueRef>)\n                                 -> ValueRef {\n     let (source, target) = ccx.tcx().struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n@@ -641,7 +638,7 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                 def_id: principal.def_id(),\n                 substs: substs,\n             });\n-            consts::ptrcast(meth::get_vtable(ccx, trait_ref, param_substs),\n+            consts::ptrcast(meth::get_vtable(ccx, trait_ref),\n                             Type::vtable_ptr(ccx))\n         }\n         _ => ccx.sess().bug(&format!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n@@ -668,7 +665,7 @@ pub fn unsize_thin_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             assert!(common::type_is_sized(bcx.tcx(), a));\n             let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), b).ptr_to();\n             (PointerCast(bcx, src, ptr_ty),\n-             unsized_info(bcx.ccx(), a, b, None, bcx.fcx.param_substs))\n+             unsized_info(bcx.ccx(), a, b, None))\n         }\n         _ => bcx.sess().bug(\"unsize_thin_ptr: called on bad types\"),\n     }\n@@ -900,29 +897,31 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                     did: DefId,\n-                                     t: Ty<'tcx>)\n-                                     -> ValueRef {\n-    let name = ccx.sess().cstore.item_symbol(did);\n-    match t.sty {\n-        ty::TyFnDef(_, _, ref fn_ty) => {\n-            match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n-                Abi::Rust | Abi::RustCall => {\n-                    get_extern_rust_fn(ccx, t, &name[..], did)\n-                }\n+pub fn get_extern_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               def_id: DefId)\n+                               -> datum::Datum<'tcx, datum::Rvalue> {\n+    let name = ccx.sess().cstore.item_symbol(def_id);\n+    let attrs = ccx.sess().cstore.item_attrs(def_id);\n+    let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    match ty.sty {\n+        ty::TyFnDef(_, _, fty) => {\n+            let abi = fty.abi;\n+            let fty = infer::normalize_associated_type(ccx.tcx(), fty);\n+            let ty = ccx.tcx().mk_fn_ptr(fty);\n+            let llfn = match ccx.sess().target.target.adjust_abi(abi) {\n                 Abi::RustIntrinsic | Abi::PlatformIntrinsic => {\n-                    ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n+                    ccx.sess().bug(\"unexpected intrinsic in get_extern_fn\")\n+                }\n+                Abi::Rust | Abi::RustCall => {\n+                    get_extern_rust_fn(ccx, ty, &name, &attrs)\n                 }\n                 _ => {\n-                    let attrs = ccx.sess().cstore.item_attrs(did);\n-                    foreign::register_foreign_item_fn(ccx, fn_ty.abi, t, &name, &attrs)\n+                    foreign::register_foreign_item_fn(ccx, abi, ty, &name, &attrs)\n                 }\n-            }\n-        }\n-        _ => {\n-            get_extern_const(ccx, did, t)\n+            };\n+            datum::immediate_rvalue(llfn, ty)\n         }\n+        _ => unreachable!(\"get_extern_fn: expected fn item type, found {}\", ty)\n     }\n }\n \n@@ -2685,8 +2684,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n                                                                .as_local_node_id(start_def_id) {\n                     get_item_val(ccx, start_node_id)\n                 } else {\n-                    let start_fn_type = ccx.tcx().lookup_item_type(start_def_id).ty;\n-                    trans_external_path(ccx, start_def_id, start_fn_type)\n+                    get_extern_fn(ccx, start_def_id).val\n                 };\n                 let args = {\n                     let opaque_rust_main ="}, {"sha": "05e5ac808d0301301723210db7ededa8ce6cf9c9", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 277, "deletions": 400, "changes": 677, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -14,15 +14,13 @@\n //! and methods are represented as just a fn ptr and not a full\n //! closure.\n \n-pub use self::AutorefArg::*;\n pub use self::CalleeData::*;\n pub use self::CallArgs::*;\n \n use arena::TypedArena;\n use back::link;\n use llvm::{self, ValueRef, get_params};\n use middle::cstore::LOCAL_CRATE;\n-use middle::def::Def;\n use middle::def_id::DefId;\n use middle::infer;\n use middle::subst;\n@@ -32,14 +30,13 @@ use trans::adt;\n use trans::base;\n use trans::base::*;\n use trans::build::*;\n-use trans::callee;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::common::{self, Block, Result, NodeIdAndSpan, ExprId, CrateContext,\n                     ExprOrMethodCall, FunctionContext, MethodCallKey};\n use trans::consts;\n use trans::datum::*;\n-use trans::debuginfo::{DebugLoc, ToDebugLoc};\n+use trans::debuginfo::DebugLoc;\n use trans::declare;\n use trans::expr;\n use trans::glue;\n@@ -52,177 +49,148 @@ use trans::type_::Type;\n use trans::type_of;\n use trans::Disr;\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use middle::ty::MethodCall;\n use rustc_front::hir;\n \n use syntax::abi::Abi;\n use syntax::ast;\n+use syntax::codemap::DUMMY_SP;\n use syntax::errors;\n use syntax::ptr::P;\n \n-#[derive(Copy, Clone)]\n-pub struct MethodData {\n-    pub llfn: ValueRef,\n-    pub llself: ValueRef,\n-}\n-\n pub enum CalleeData<'tcx> {\n-    // Constructor for enum variant/tuple-like-struct\n-    // i.e. Some, Ok\n+    /// Constructor for enum variant/tuple-like-struct.\n     NamedTupleConstructor(Disr),\n \n-    // Represents a (possibly monomorphized) top-level fn item or method\n-    // item. Note that this is just the fn-ptr and is not a Rust closure\n-    // value (which is a pair).\n-    Fn(/* llfn */ ValueRef),\n+    /// Function pointer.\n+    Fn(ValueRef),\n \n-    Intrinsic(ast::NodeId, subst::Substs<'tcx>),\n+    Intrinsic(ast::NodeId, &'tcx subst::Substs<'tcx>),\n \n-    TraitItem(MethodData)\n+    /// Trait object found in the vtable at that index.\n+    Virtual(usize)\n }\n \n-pub struct Callee<'blk, 'tcx: 'blk> {\n-    pub bcx: Block<'blk, 'tcx>,\n+pub struct Callee<'tcx> {\n     pub data: CalleeData<'tcx>,\n     pub ty: Ty<'tcx>\n }\n \n-fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n-                     -> Callee<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_callee\");\n-    debug!(\"callee::trans(expr={:?})\", expr);\n-\n-    // pick out special kinds of expressions that can be called:\n-    match expr.node {\n-        hir::ExprPath(..) => {\n-            return trans_def(bcx, bcx.def(expr.id), expr);\n+impl<'tcx> Callee<'tcx> {\n+    /// Function pointer.\n+    pub fn ptr(datum: Datum<'tcx, Rvalue>) -> Callee<'tcx> {\n+        Callee {\n+            data: Fn(datum.val),\n+            ty: datum.ty\n         }\n-        _ => {}\n     }\n \n-    // any other expressions are closures:\n-    return datum_callee(bcx, expr);\n-\n-    fn datum_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n-                                -> Callee<'blk, 'tcx> {\n-        let DatumBlock { bcx, datum, .. } = expr::trans(bcx, expr);\n-        match datum.ty.sty {\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-                Callee {\n-                    bcx: bcx,\n-                    ty: datum.ty,\n-                    data: Fn(datum.to_llscalarish(bcx))\n-                }\n-            }\n-            _ => {\n-                bcx.tcx().sess.span_bug(\n-                    expr.span,\n-                    &format!(\"type of callee is neither bare-fn nor closure: {}\",\n-                             datum.ty));\n-            }\n-        }\n+    /// Trait or impl method call.\n+    pub fn method_call<'blk>(bcx: Block<'blk, 'tcx>,\n+                             method_call: ty::MethodCall)\n+                             -> Callee<'tcx> {\n+        let method = bcx.tcx().tables.borrow().method_map[&method_call];\n+        Callee::method(bcx, method)\n     }\n \n-    fn fn_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, datum: Datum<'tcx, Rvalue>)\n-                             -> Callee<'blk, 'tcx> {\n-        Callee {\n-            bcx: bcx,\n-            data: Fn(datum.val),\n-            ty: datum.ty\n-        }\n+    /// Trait or impl method.\n+    pub fn method<'blk>(bcx: Block<'blk, 'tcx>,\n+                        method: ty::MethodCallee<'tcx>) -> Callee<'tcx> {\n+        let substs = bcx.tcx().mk_substs(bcx.fcx.monomorphize(&method.substs));\n+        let ty = bcx.fcx.monomorphize(&method.ty);\n+        Callee::def(bcx.ccx(), method.def_id, substs, ty)\n     }\n \n-    fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             def: Def,\n-                             ref_expr: &hir::Expr)\n-                             -> Callee<'blk, 'tcx> {\n-        debug!(\"trans_def(def={:?}, ref_expr={:?})\", def, ref_expr);\n-        let expr_ty = common::node_id_type(bcx, ref_expr.id);\n-        match def {\n-            Def::Fn(did) if {\n-                let maybe_def_id = inline::get_local_instance(bcx.ccx(), did);\n-                let maybe_ast_node = maybe_def_id.and_then(|def_id| {\n-                    let node_id = bcx.tcx().map.as_local_node_id(def_id).unwrap();\n-                    bcx.tcx().map.find(node_id)\n-                });\n-                match maybe_ast_node {\n-                    Some(hir_map::NodeStructCtor(_)) => true,\n-                    _ => false\n-                }\n-            } => {\n-                Callee {\n-                    bcx: bcx,\n+    /// Function or method definition.\n+    pub fn def<'a>(ccx: &CrateContext<'a, 'tcx>,\n+                   def_id: DefId,\n+                   substs: &'tcx subst::Substs<'tcx>,\n+                   ty: Ty<'tcx>)\n+                   -> Callee<'tcx> {\n+        let tcx = ccx.tcx();\n+\n+        if substs.self_ty().is_some() {\n+            // Only trait methods can have a Self parameter.\n+            let method_item = tcx.impl_or_trait_item(def_id);\n+            let trait_id = method_item.container().id();\n+            let trait_ref = ty::Binder(substs.to_trait_ref(tcx, trait_id));\n+            let vtbl = common::fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n+            return meth::callee_for_trait_impl(ccx, def_id, substs,\n+                                               trait_id, ty, vtbl);\n+        }\n+\n+        let maybe_node_id = inline::get_local_instance(ccx, def_id)\n+            .and_then(|def_id| tcx.map.as_local_node_id(def_id));\n+        let maybe_ast_node = maybe_node_id.and_then(|node_id| {\n+            tcx.map.find(node_id)\n+        });\n+        match maybe_ast_node {\n+            Some(hir_map::NodeStructCtor(_)) => {\n+                return Callee {\n                     data: NamedTupleConstructor(Disr(0)),\n-                    ty: expr_ty\n-                }\n-            }\n-            Def::Fn(did) if match expr_ty.sty {\n-                ty::TyFnDef(_, _, ref f) => f.abi == Abi::RustIntrinsic ||\n-                                            f.abi == Abi::PlatformIntrinsic,\n-                _ => false\n-            } => {\n-                let substs = common::node_id_substs(bcx.ccx(),\n-                                                    ExprId(ref_expr.id),\n-                                                    bcx.fcx.param_substs);\n-                let def_id = inline::maybe_instantiate_inline(bcx.ccx(), did);\n-                let node_id = bcx.tcx().map.as_local_node_id(def_id).unwrap();\n-                Callee { bcx: bcx, data: Intrinsic(node_id, substs), ty: expr_ty }\n-            }\n-            Def::Fn(did) => {\n-                fn_callee(bcx, trans_fn_ref(bcx.ccx(), did, ExprId(ref_expr.id),\n-                                            bcx.fcx.param_substs))\n-            }\n-            Def::Method(meth_did) => {\n-                let method_item = bcx.tcx().impl_or_trait_item(meth_did);\n-                let fn_datum = match method_item.container() {\n-                    ty::ImplContainer(_) => {\n-                        trans_fn_ref(bcx.ccx(), meth_did,\n-                                     ExprId(ref_expr.id),\n-                                     bcx.fcx.param_substs)\n-                    }\n-                    ty::TraitContainer(trait_did) => {\n-                        meth::trans_static_method_callee(bcx.ccx(),\n-                                                         meth_did,\n-                                                         trait_did,\n-                                                         ref_expr.id,\n-                                                         bcx.fcx.param_substs)\n-                    }\n+                    ty: ty\n                 };\n-                fn_callee(bcx, fn_datum)\n             }\n-            Def::Variant(tid, vid) => {\n-                let vinfo = bcx.tcx().lookup_adt_def(tid).variant_with_id(vid);\n+            Some(hir_map::NodeVariant(_)) => {\n+                let vinfo = common::inlined_variant_def(ccx, maybe_node_id.unwrap());\n                 assert_eq!(vinfo.kind(), ty::VariantKind::Tuple);\n \n-                Callee {\n-                    bcx: bcx,\n+                return Callee {\n                     data: NamedTupleConstructor(Disr::from(vinfo.disr_val)),\n-                    ty: expr_ty\n-                }\n+                    ty: ty\n+                };\n             }\n-            Def::Struct(..) => {\n-                Callee {\n-                    bcx: bcx,\n-                    data: NamedTupleConstructor(Disr(0)),\n-                    ty: expr_ty\n+            Some(hir_map::NodeForeignItem(fi)) => {\n+                let abi = tcx.map.get_foreign_abi(fi.id);\n+                if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n+                    return Callee {\n+                        data: Intrinsic(fi.id, substs),\n+                        ty: ty\n+                    };\n                 }\n             }\n-            Def::Static(..) |\n-            Def::Const(..) |\n-            Def::AssociatedConst(..) |\n-            Def::Local(..) |\n-            Def::Upvar(..) => {\n-                datum_callee(bcx, ref_expr)\n-            }\n-            Def::Mod(..) | Def::ForeignMod(..) | Def::Trait(..) |\n-            Def::Enum(..) | Def::TyAlias(..) | Def::PrimTy(..) |\n-            Def::AssociatedTy(..) | Def::Label(..) | Def::TyParam(..) |\n-            Def::SelfTy(..) | Def::Err => {\n-                bcx.tcx().sess.span_bug(\n-                    ref_expr.span,\n-                    &format!(\"cannot translate def {:?} \\\n-                             to a callable thing!\", def));\n+            _ => {}\n+        }\n+        Callee::ptr(trans_fn_ref_with_substs(ccx, def_id, Some(ty), substs))\n+    }\n+\n+    /// This behemoth of a function translates function calls. Unfortunately, in\n+    /// order to generate more efficient LLVM output at -O0, it has quite a complex\n+    /// signature (refactoring this into two functions seems like a good idea).\n+    ///\n+    /// In particular, for lang items, it is invoked with a dest of None, and in\n+    /// that case the return value contains the result of the fn. The lang item must\n+    /// not return a structural type or else all heck breaks loose.\n+    ///\n+    /// For non-lang items, `dest` is always Some, and hence the result is written\n+    /// into memory somewhere. Nonetheless we return the actual return value of the\n+    /// function.\n+    pub fn call<'a, 'blk>(self, bcx: Block<'blk, 'tcx>,\n+                          debug_loc: DebugLoc,\n+                          args: CallArgs<'a, 'tcx>,\n+                          dest: Option<expr::Dest>)\n+                          -> Result<'blk, 'tcx> {\n+        trans_call_inner(bcx, debug_loc, self, args, dest)\n+    }\n+\n+    /// Turn the callee into a function pointer.\n+    pub fn reify<'a>(self, ccx: &CrateContext<'a, 'tcx>)\n+                     -> Datum<'tcx, Rvalue> {\n+        match self.data {\n+            Fn(llfn) => {\n+                let fn_ptr_ty = match self.ty.sty {\n+                    ty::TyFnDef(_, _, f) => ccx.tcx().mk_ty(ty::TyFnPtr(f)),\n+                    _ => self.ty\n+                };\n+                immediate_rvalue(llfn, fn_ptr_ty)\n             }\n+            Virtual(idx) => meth::trans_object_shim(ccx, self.ty, idx),\n+            NamedTupleConstructor(_) => match self.ty.sty {\n+                ty::TyFnDef(def_id, substs, _) => {\n+                    return trans_fn_ref_with_substs(ccx, def_id, Some(self.ty), substs);\n+                }\n+                _ => unreachable!(\"expected fn item type, found {}\", self.ty)\n+            },\n+            Intrinsic(..) => unreachable!(\"intrinsic {} getting reified\", self.ty)\n         }\n     }\n }\n@@ -241,7 +209,17 @@ pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            def_id,\n            node,\n            substs);\n-    trans_fn_ref_with_substs(ccx, def_id, node, param_substs, substs)\n+    let ref_ty = match node {\n+        ExprId(0) => return trans_fn_ref_with_substs(ccx, def_id, None, substs),\n+        ExprId(id) => ccx.tcx().node_id_to_type(id),\n+        MethodCallKey(method_call) => {\n+            ccx.tcx().tables.borrow().method_map[&method_call].ty\n+        }\n+    };\n+    let ref_ty = monomorphize::apply_param_substs(ccx.tcx(),\n+                                                  param_substs,\n+                                                  &ref_ty);\n+    trans_fn_ref_with_substs(ccx, def_id, Some(ref_ty), substs)\n }\n \n /// Translates an adapter that implements the `Fn` trait for a fn\n@@ -290,29 +268,24 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n     // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n-    let (opt_def_id_and_substs, sig) =\n-        match bare_fn_ty.sty {\n-            ty::TyFnDef(def_id, substs,\n-                        &ty::BareFnTy { unsafety: hir::Unsafety::Normal,\n-                                        abi: Abi::Rust,\n-                                        ref sig }) => {\n-                (Some((def_id, substs)), sig)\n-            }\n-            ty::TyFnPtr(&ty::BareFnTy { unsafety: hir::Unsafety::Normal,\n-                                        abi: Abi::Rust,\n-                                        ref sig }) => {\n-                (None, sig)\n-            }\n+    let sig = match bare_fn_ty.sty {\n+        ty::TyFnDef(_, _,\n+                    &ty::BareFnTy { unsafety: hir::Unsafety::Normal,\n+                                    abi: Abi::Rust,\n+                                    ref sig }) |\n+        ty::TyFnPtr(&ty::BareFnTy { unsafety: hir::Unsafety::Normal,\n+                                    abi: Abi::Rust,\n+                                    ref sig }) => sig,\n \n-            _ => {\n-                tcx.sess.bug(&format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                                      bare_fn_ty));\n-            }\n-        };\n+        _ => {\n+            tcx.sess.bug(&format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n+                                    bare_fn_ty));\n+        }\n+    };\n     let sig = tcx.erase_late_bound_regions(sig);\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n     let tuple_input_ty = tcx.mk_tup(sig.inputs.to_vec());\n-    let bare_tuple_fn = ty::BareFnTy {\n+    let tuple_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n         unsafety: hir::Unsafety::Normal,\n         abi: Abi::RustCall,\n         sig: ty::Binder(ty::FnSig {\n@@ -321,11 +294,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n             output: sig.output,\n             variadic: false\n         })\n-    };\n-    let tuple_fn_ty = match opt_def_id_and_substs {\n-        Some((def_id, substs)) => tcx.mk_fn_def(def_id, substs, bare_tuple_fn),\n-        None => tcx.mk_fn_ptr(bare_tuple_fn),\n-    };\n+    });\n     debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n \n     //\n@@ -350,11 +319,18 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llargs = get_params(fcx.llfn);\n \n     let self_idx = fcx.arg_offset();\n-    // the first argument (`self`) will be ptr to the fn pointer\n-    let llfnpointer = if is_by_ref {\n-        Load(bcx, llargs[self_idx])\n-    } else {\n-        llargs[self_idx]\n+    let llfnpointer = match bare_fn_ty.sty {\n+        ty::TyFnDef(def_id, substs, _) => {\n+            // Function definitions have to be turned into a pointer.\n+            Callee::def(ccx, def_id, substs, bare_fn_ty).reify(ccx).val\n+        }\n+\n+        // the first argument (`self`) will be ptr to the fn pointer\n+        _ => if is_by_ref {\n+            Load(bcx, llargs[self_idx])\n+        } else {\n+            llargs[self_idx]\n+        }\n     };\n \n     assert!(!fcx.needs_ret_allocas);\n@@ -363,13 +339,11 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\"))\n     );\n \n-    bcx = trans_call_inner(bcx, DebugLoc::None, |bcx, _| {\n-        Callee {\n-            bcx: bcx,\n-            data: Fn(llfnpointer),\n-            ty: bare_fn_ty\n-        }\n-    }, ArgVals(&llargs[(self_idx + 1)..]), dest).bcx;\n+    let callee = Callee {\n+        data: Fn(llfnpointer),\n+        ty: bare_fn_ty\n+    };\n+    bcx = callee.call(bcx, DebugLoc::None, ArgVals(&llargs[(self_idx + 1)..]), dest).bcx;\n \n     finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n \n@@ -388,30 +362,25 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n /// - `node`: node id of the reference to the fn/method, if applicable.\n ///   This parameter may be zero; but, if so, the resulting value may not\n ///   have the right type, so it must be cast before being used.\n-/// - `param_substs`: if the `node` is in a polymorphic function, these\n-///   are the substitutions required to monomorphize its type\n+/// - `ref_ty`: monotype of the reference to the fn/method, if applicable.\n+///   This parameter may be None; but, if so, the resulting value may not\n+///   have the right type, so it must be cast before being used.\n /// - `substs`: values for each of the fn/method's parameters\n pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     ccx: &CrateContext<'a, 'tcx>,\n     def_id: DefId,\n-    node: ExprOrMethodCall,\n-    param_substs: &'tcx subst::Substs<'tcx>,\n-    substs: subst::Substs<'tcx>)\n+    ref_ty: Option<Ty<'tcx>>,\n+    substs: &'tcx subst::Substs<'tcx>)\n     -> Datum<'tcx, Rvalue>\n {\n     let _icx = push_ctxt(\"trans_fn_ref_with_substs\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_fn_ref_with_substs(def_id={:?}, node={:?}, \\\n-            param_substs={:?}, substs={:?})\",\n-           def_id,\n-           node,\n-           param_substs,\n-           substs);\n+    debug!(\"trans_fn_ref_with_substs(def_id={:?}, ref_ty={:?}, substs={:?})\",\n+           def_id, ref_ty, substs);\n \n     assert!(!substs.types.needs_infer());\n     assert!(!substs.types.has_escaping_regions());\n-    let substs = substs.erase_regions();\n \n     // Check whether this fn has an inlined copy and, if so, redirect\n     // def_id to the local id of the inlined copy.\n@@ -446,43 +415,45 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n         // Should be either intra-crate or inlined.\n         assert_eq!(def_id.krate, LOCAL_CRATE);\n \n-        let substs = tcx.mk_substs(substs);\n-        let (val, fn_ty, must_cast) =\n+        let substs = tcx.mk_substs(substs.clone().erase_regions());\n+        let (mut val, fn_ty, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, substs);\n-        if must_cast && node != ExprId(0) {\n-            // Monotype of the REFERENCE to the function (type params\n-            // are subst'd)\n-            let ref_ty = match node {\n-                ExprId(id) => tcx.node_id_to_type(id),\n-                MethodCallKey(method_call) => {\n-                    tcx.tables.borrow().method_map[&method_call].ty\n-                }\n-            };\n-            let ref_ty = monomorphize::apply_param_substs(tcx,\n-                                                          param_substs,\n-                                                          &ref_ty);\n-            let llptrty = type_of::type_of(ccx, ref_ty);\n+        let fn_ty = ref_ty.unwrap_or(fn_ty);\n+        let fn_ptr_ty = match fn_ty.sty {\n+            ty::TyFnDef(_, _, fty) => {\n+                // Create a fn pointer with the substituted signature.\n+                tcx.mk_ty(ty::TyFnPtr(fty))\n+            }\n+            _ => unreachable!(\"expected fn item type, found {}\", fn_ty)\n+        };\n+        if must_cast && ref_ty.is_some() {\n+            let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n             if llptrty != common::val_ty(val) {\n-                let val = consts::ptrcast(val, llptrty);\n-                return Datum::new(val, ref_ty, Rvalue::new(ByValue));\n+                val = consts::ptrcast(val, llptrty);\n             }\n         }\n-        return Datum::new(val, fn_ty, Rvalue::new(ByValue));\n+        return immediate_rvalue(val, fn_ptr_ty);\n     }\n \n-    // Type scheme of the function item (may have type params)\n-    let fn_type_scheme = tcx.lookup_item_type(def_id);\n-    let fn_type = infer::normalize_associated_type(tcx, &fn_type_scheme.ty);\n-\n     // Find the actual function pointer.\n-    let mut val = {\n-        if let Some(node_id) = ccx.tcx().map.as_local_node_id(def_id) {\n-            // Internal reference.\n-            get_item_val(ccx, node_id)\n-        } else {\n-            // External reference.\n-            trans_external_path(ccx, def_id, fn_type)\n-        }\n+    let local_node = ccx.tcx().map.as_local_node_id(def_id);\n+    let mut datum = if let Some(node_id) = local_node {\n+        // Type scheme of the function item (may have type params)\n+        let fn_type_scheme = tcx.lookup_item_type(def_id);\n+        let fn_type = match fn_type_scheme.ty.sty {\n+            ty::TyFnDef(_, _, fty) => {\n+                // Create a fn pointer with the normalized signature.\n+                tcx.mk_fn_ptr(infer::normalize_associated_type(tcx, fty))\n+            }\n+            _ => unreachable!(\"expected fn item type, found {}\",\n+                              fn_type_scheme.ty)\n+        };\n+\n+        // Internal reference.\n+        immediate_rvalue(get_item_val(ccx, node_id), fn_type)\n+    } else {\n+        // External reference.\n+        get_extern_fn(ccx, def_id)\n     };\n \n     // This is subtle and surprising, but sometimes we have to bitcast\n@@ -508,92 +479,36 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     // This can occur on either a crate-local or crate-external\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n-    let llptrty = type_of::type_of(ccx, fn_type);\n-    if common::val_ty(val) != llptrty {\n+    let llptrty = type_of::type_of(ccx, datum.ty);\n+    if common::val_ty(datum.val) != llptrty {\n         debug!(\"trans_fn_ref_with_substs(): casting pointer!\");\n-        val = consts::ptrcast(val, llptrty);\n+        datum.val = consts::ptrcast(datum.val, llptrty);\n     } else {\n         debug!(\"trans_fn_ref_with_substs(): not casting pointer!\");\n     }\n \n-    Datum::new(val, fn_type, Rvalue::new(ByValue))\n+    datum\n }\n \n // ______________________________________________________________________\n // Translating calls\n \n-pub fn trans_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  call_expr: &hir::Expr,\n-                                  f: &hir::Expr,\n-                                  args: CallArgs<'a, 'tcx>,\n-                                  dest: expr::Dest)\n-                                  -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_call\");\n-    trans_call_inner(bcx,\n-                     call_expr.debug_loc(),\n-                     |bcx, _| trans(bcx, f),\n-                     args,\n-                     Some(dest)).bcx\n-}\n-\n-pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                         call_expr: &hir::Expr,\n-                                         rcvr: &hir::Expr,\n-                                         args: CallArgs<'a, 'tcx>,\n-                                         dest: expr::Dest)\n-                                         -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_method_call\");\n-    debug!(\"trans_method_call(call_expr={:?})\", call_expr);\n-    let method_call = MethodCall::expr(call_expr.id);\n-    trans_call_inner(\n-        bcx,\n-        call_expr.debug_loc(),\n-        |cx, arg_cleanup_scope| {\n-            meth::trans_method_callee(cx, method_call, Some(rcvr), arg_cleanup_scope)\n-        },\n-        args,\n-        Some(dest)).bcx\n-}\n-\n pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    did: DefId,\n                                    args: &[ValueRef],\n                                    dest: Option<expr::Dest>,\n                                    debug_loc: DebugLoc)\n                                    -> Result<'blk, 'tcx> {\n-    callee::trans_call_inner(bcx, debug_loc, |bcx, _| {\n-        let datum = trans_fn_ref_with_substs(bcx.ccx(),\n-                                             did,\n-                                             ExprId(0),\n-                                             bcx.fcx.param_substs,\n-                                             subst::Substs::trans_empty());\n-        Callee {\n-            bcx: bcx,\n-            data: Fn(datum.val),\n-            ty: datum.ty\n-        }\n-    }, ArgVals(args), dest)\n+    let datum = trans_fn_ref(bcx.ccx(), did, ExprId(0), bcx.fcx.param_substs);\n+    Callee::ptr(datum).call(bcx, debug_loc, ArgVals(args), dest)\n }\n \n-/// This behemoth of a function translates function calls. Unfortunately, in\n-/// order to generate more efficient LLVM output at -O0, it has quite a complex\n-/// signature (refactoring this into two functions seems like a good idea).\n-///\n-/// In particular, for lang items, it is invoked with a dest of None, and in\n-/// that case the return value contains the result of the fn. The lang item must\n-/// not return a structural type or else all heck breaks loose.\n-///\n-/// For non-lang items, `dest` is always Some, and hence the result is written\n-/// into memory somewhere. Nonetheless we return the actual return value of the\n-/// function.\n-pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                           debug_loc: DebugLoc,\n-                                           get_callee: F,\n-                                           args: CallArgs<'a, 'tcx>,\n-                                           dest: Option<expr::Dest>)\n-                                           -> Result<'blk, 'tcx> where\n-    F: FnOnce(Block<'blk, 'tcx>, cleanup::ScopeId) -> Callee<'blk, 'tcx>,\n-{\n+fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                    debug_loc: DebugLoc,\n+                                    callee: Callee<'tcx>,\n+                                    args: CallArgs<'a, 'tcx>,\n+                                    dest: Option<expr::Dest>)\n+                                    -> Result<'blk, 'tcx> {\n     // Introduce a temporary cleanup scope that will contain cleanups\n     // for the arguments while they are being evaluated. The purpose\n     // this cleanup is to ensure that, should a panic occur while\n@@ -603,27 +518,17 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     // scope will ever execute.\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n-    let arg_cleanup_scope = fcx.push_custom_cleanup_scope();\n-\n-    let callee = get_callee(bcx, cleanup::CustomScope(arg_cleanup_scope));\n-    let mut bcx = callee.bcx;\n \n     let (abi, ret_ty) = match callee.ty.sty {\n         ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n             let sig = bcx.tcx().erase_late_bound_regions(&f.sig);\n             let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n             (f.abi, sig.output)\n         }\n-        _ => panic!(\"expected bare rust fn or closure in trans_call_inner\")\n+        _ => panic!(\"expected fn item or ptr in Callee::call\")\n     };\n \n-    let (llfn, llself) = match callee.data {\n-        Fn(llfn) => {\n-            (llfn, None)\n-        }\n-        TraitItem(d) => {\n-            (d.llfn, Some(d.llself))\n-        }\n+    match callee.data {\n         Intrinsic(node, substs) => {\n             assert!(abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic);\n             assert!(dest.is_some());\n@@ -635,14 +540,15 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                 }\n             };\n \n+            let arg_cleanup_scope = fcx.push_custom_cleanup_scope();\n             return intrinsic::trans_intrinsic_call(bcx, node, callee.ty,\n                                                    arg_cleanup_scope, args,\n-                                                   dest.unwrap(), substs,\n+                                                   dest.unwrap(),\n+                                                   substs,\n                                                    call_info);\n         }\n         NamedTupleConstructor(disr) => {\n             assert!(dest.is_some());\n-            fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n \n             return base::trans_named_tuple_constructor(bcx,\n                                                        callee.ty,\n@@ -651,7 +557,8 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                                        dest.unwrap(),\n                                                        debug_loc);\n         }\n-    };\n+        _ => {}\n+    }\n \n     // Intrinsics should not become actual functions.\n     // We trans them in place in `trans_intrinsic_call`\n@@ -691,6 +598,8 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         llvm::LLVMGetUndef(Type::nil(ccx).ptr_to().to_ref())\n     };\n \n+    let arg_cleanup_scope = fcx.push_custom_cleanup_scope();\n+\n     // The code below invokes the function, using either the Rust\n     // conventions (if it is a rust fn) or the native conventions\n     // (otherwise).  The important part is that, when all is said\n@@ -714,27 +623,33 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n \n-        // Push a trait object's self.\n-        if let Some(llself) = llself {\n-            llargs.push(llself);\n-        }\n+        let arg_start = llargs.len();\n \n         // Push the arguments.\n         bcx = trans_args(bcx,\n                          args,\n                          callee.ty,\n                          &mut llargs,\n                          cleanup::CustomScope(arg_cleanup_scope),\n-                         llself.is_some(),\n                          abi);\n \n         fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n+        let datum = match callee.data {\n+            Fn(f) => immediate_rvalue(f, callee.ty),\n+            Virtual(idx) => {\n+                // The data and vtable pointers were split by trans_arg_datum.\n+                let vtable = llargs.remove(arg_start + 1);\n+                meth::get_virtual_method(bcx, vtable, idx, callee.ty)\n+            }\n+            _ => unreachable!()\n+        };\n+\n         // Invoke the actual rust fn and update bcx/llresult.\n         let (llret, b) = base::invoke(bcx,\n-                                      llfn,\n+                                      datum.val,\n                                       &llargs[..],\n-                                      callee.ty,\n+                                      datum.ty,\n                                       debug_loc);\n         bcx = b;\n         llresult = llret;\n@@ -757,16 +672,17 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         assert!(dest.is_some());\n \n         let mut llargs = Vec::new();\n-        let arg_tys = match args {\n-            ArgExprs(a) => a.iter().map(|x| common::expr_ty_adjusted(bcx, &x)).collect(),\n-            _ => panic!(\"expected arg exprs.\")\n+        let (llfn, arg_tys) = match (callee.data, &args) {\n+            (Fn(f), &ArgExprs(a)) => {\n+                (f, a.iter().map(|x| common::expr_ty_adjusted(bcx, &x)).collect())\n+            }\n+            _ => panic!(\"expected fn ptr and arg exprs.\")\n         };\n         bcx = trans_args(bcx,\n                          args,\n                          callee.ty,\n                          &mut llargs,\n                          cleanup::CustomScope(arg_cleanup_scope),\n-                         false,\n                          abi);\n         fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n@@ -803,23 +719,22 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n }\n \n pub enum CallArgs<'a, 'tcx> {\n-    // Supply value of arguments as a list of expressions that must be\n-    // translated. This is used in the common case of `foo(bar, qux)`.\n+    /// Supply value of arguments as a list of expressions that must be\n+    /// translated. This is used in the common case of `foo(bar, qux)`.\n     ArgExprs(&'a [P<hir::Expr>]),\n \n-    // Supply value of arguments as a list of LLVM value refs; frequently\n-    // used with lang items and so forth, when the argument is an internal\n-    // value.\n+    /// Supply value of arguments as a list of LLVM value refs; frequently\n+    /// used with lang items and so forth, when the argument is an internal\n+    /// value.\n     ArgVals(&'a [ValueRef]),\n \n-    // For overloaded operators: `(lhs, Option(rhs, rhs_id), autoref)`. `lhs`\n-    // is the left-hand-side and `rhs/rhs_id` is the datum/expr-id of\n-    // the right-hand-side argument (if any). `autoref` indicates whether the `rhs`\n-    // arguments should be auto-referenced\n-    ArgOverloadedOp(Datum<'tcx, Expr>, Option<(Datum<'tcx, Expr>, ast::NodeId)>, bool),\n+    /// For overloaded operators: `(lhs, Option(rhs))`.\n+    /// `lhs` is the left-hand-side and `rhs` is the datum\n+    /// of the right-hand-side argument (if any).\n+    ArgOverloadedOp(Datum<'tcx, Expr>, Option<Datum<'tcx, Expr>>),\n \n-    // Supply value of arguments as a list of expressions that must be\n-    // translated, for overloaded call operators.\n+    /// Supply value of arguments as a list of expressions that must be\n+    /// translated, for overloaded call operators.\n     ArgOverloadedCall(Vec<&'a hir::Expr>),\n }\n \n@@ -828,24 +743,20 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                              arg_exprs: &[P<hir::Expr>],\n                              fn_ty: Ty<'tcx>,\n                              llargs: &mut Vec<ValueRef>,\n-                             arg_cleanup_scope: cleanup::ScopeId,\n-                             ignore_self: bool)\n+                             arg_cleanup_scope: cleanup::ScopeId)\n                              -> Block<'blk, 'tcx>\n {\n     let sig = bcx.tcx().erase_late_bound_regions(&fn_ty.fn_sig());\n     let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n     let args = sig.inputs;\n \n     // Translate the `self` argument first.\n-    if !ignore_self {\n-        let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_exprs[0]));\n-        bcx = trans_arg_datum(bcx,\n-                              args[0],\n-                              arg_datum,\n-                              arg_cleanup_scope,\n-                              DontAutorefArg,\n-                              llargs);\n-    }\n+    let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_exprs[0]));\n+    bcx = trans_arg_datum(bcx,\n+                          args[0],\n+                          arg_datum,\n+                          arg_cleanup_scope,\n+                          llargs);\n \n     // Now untuple the rest of the arguments.\n     let tuple_expr = &arg_exprs[1];\n@@ -873,7 +784,6 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                                       field_type,\n                                       arg_datum,\n                                       arg_cleanup_scope,\n-                                      DontAutorefArg,\n                                       llargs);\n             }\n         }\n@@ -891,23 +801,19 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n                               arg_exprs: Vec<&hir::Expr>,\n                               fn_ty: Ty<'tcx>,\n                               llargs: &mut Vec<ValueRef>,\n-                              arg_cleanup_scope: cleanup::ScopeId,\n-                              ignore_self: bool)\n+                              arg_cleanup_scope: cleanup::ScopeId)\n                               -> Block<'blk, 'tcx> {\n     // Translate the `self` argument first.\n     let sig = bcx.tcx().erase_late_bound_regions(&fn_ty.fn_sig());\n     let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n     let arg_tys = sig.inputs;\n \n-    if !ignore_self {\n-        let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n-        bcx = trans_arg_datum(bcx,\n-                              arg_tys[0],\n-                              arg_datum,\n-                              arg_cleanup_scope,\n-                              DontAutorefArg,\n-                              llargs);\n-    }\n+    let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n+    bcx = trans_arg_datum(bcx,\n+                          arg_tys[0],\n+                          arg_datum,\n+                          arg_cleanup_scope,\n+                          llargs);\n \n     // Now untuple the rest of the arguments.\n     let tuple_type = arg_tys[1];\n@@ -920,7 +826,6 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n                                       field_type,\n                                       arg_datum,\n                                       arg_cleanup_scope,\n-                                      DontAutorefArg,\n                                       llargs);\n             }\n         }\n@@ -938,7 +843,6 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                   fn_ty: Ty<'tcx>,\n                                   llargs: &mut Vec<ValueRef>,\n                                   arg_cleanup_scope: cleanup::ScopeId,\n-                                  ignore_self: bool,\n                                   abi: Abi)\n                                   -> Block<'blk, 'tcx> {\n     debug!(\"trans_args(abi={})\", abi);\n@@ -963,15 +867,11 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                                  arg_exprs,\n                                                  fn_ty,\n                                                  llargs,\n-                                                 arg_cleanup_scope,\n-                                                 ignore_self)\n+                                                 arg_cleanup_scope)\n             }\n \n             let num_formal_args = arg_tys.len();\n             for (i, arg_expr) in arg_exprs.iter().enumerate() {\n-                if i == 0 && ignore_self {\n-                    continue;\n-                }\n                 let arg_ty = if i >= num_formal_args {\n                     assert!(variadic);\n                     common::expr_ty_adjusted(cx, &arg_expr)\n@@ -982,7 +882,6 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                 let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_expr));\n                 bcx = trans_arg_datum(bcx, arg_ty, arg_datum,\n                                       arg_cleanup_scope,\n-                                      DontAutorefArg,\n                                       llargs);\n             }\n         }\n@@ -991,22 +890,19 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                               arg_exprs,\n                                               fn_ty,\n                                               llargs,\n-                                              arg_cleanup_scope,\n-                                              ignore_self)\n+                                              arg_cleanup_scope)\n         }\n-        ArgOverloadedOp(lhs, rhs, autoref) => {\n+        ArgOverloadedOp(lhs, rhs) => {\n             assert!(!variadic);\n \n             bcx = trans_arg_datum(bcx, arg_tys[0], lhs,\n                                   arg_cleanup_scope,\n-                                  DontAutorefArg,\n                                   llargs);\n \n-            if let Some((rhs, rhs_id)) = rhs {\n+            if let Some(rhs) = rhs {\n                 assert_eq!(arg_tys.len(), 2);\n                 bcx = trans_arg_datum(bcx, arg_tys[1], rhs,\n                                       arg_cleanup_scope,\n-                                      if autoref { DoAutorefArg(rhs_id) } else { DontAutorefArg },\n                                       llargs);\n             } else {\n                 assert_eq!(arg_tys.len(), 1);\n@@ -1020,17 +916,10 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     bcx\n }\n \n-#[derive(Copy, Clone)]\n-pub enum AutorefArg {\n-    DontAutorefArg,\n-    DoAutorefArg(ast::NodeId)\n-}\n-\n pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    formal_arg_ty: Ty<'tcx>,\n                                    arg_datum: Datum<'tcx, Expr>,\n                                    arg_cleanup_scope: cleanup::ScopeId,\n-                                   autoref_arg: AutorefArg,\n                                    llargs: &mut Vec<ValueRef>)\n                                    -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_arg_datum\");\n@@ -1044,37 +933,25 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     debug!(\"   arg datum: {}\", arg_datum.to_string(bcx.ccx()));\n \n-    let mut val;\n-    // FIXME(#3548) use the adjustments table\n-    match autoref_arg {\n-        DoAutorefArg(arg_id) => {\n-            // We will pass argument by reference\n-            // We want an lvalue, so that we can pass by reference and\n-            let arg_datum = unpack_datum!(\n-                bcx, arg_datum.to_lvalue_datum(bcx, \"arg\", arg_id));\n-            val = arg_datum.val;\n-        }\n-        DontAutorefArg if common::type_is_fat_ptr(bcx.tcx(), arg_datum_ty) &&\n-                !bcx.fcx.type_needs_drop(arg_datum_ty) => {\n-            val = arg_datum.val\n-        }\n-        DontAutorefArg => {\n-            // Make this an rvalue, since we are going to be\n-            // passing ownership.\n-            let arg_datum = unpack_datum!(\n-                bcx, arg_datum.to_rvalue_datum(bcx, \"arg\"));\n-\n-            // Now that arg_datum is owned, get it into the appropriate\n-            // mode (ref vs value).\n-            let arg_datum = unpack_datum!(\n-                bcx, arg_datum.to_appropriate_datum(bcx));\n-\n-            // Technically, ownership of val passes to the callee.\n-            // However, we must cleanup should we panic before the\n-            // callee is actually invoked.\n-            val = arg_datum.add_clean(bcx.fcx, arg_cleanup_scope);\n-        }\n-    }\n+    let mut val = if common::type_is_fat_ptr(bcx.tcx(), arg_datum_ty) &&\n+                     !bcx.fcx.type_needs_drop(arg_datum_ty) {\n+        arg_datum.val\n+    } else {\n+        // Make this an rvalue, since we are going to be\n+        // passing ownership.\n+        let arg_datum = unpack_datum!(\n+            bcx, arg_datum.to_rvalue_datum(bcx, \"arg\"));\n+\n+        // Now that arg_datum is owned, get it into the appropriate\n+        // mode (ref vs value).\n+        let arg_datum = unpack_datum!(\n+            bcx, arg_datum.to_appropriate_datum(bcx));\n+\n+        // Technically, ownership of val passes to the callee.\n+        // However, we must cleanup should we panic before the\n+        // callee is actually invoked.\n+        arg_datum.add_clean(bcx.fcx, arg_cleanup_scope)\n+    };\n \n     if type_of::arg_is_indirect(ccx, formal_arg_ty) && formal_arg_ty != arg_datum_ty {\n         // this could happen due to e.g. subtyping"}, {"sha": "95ca250e8444525f812696a08731ee10780a6252", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 9, "deletions": 29, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -17,7 +17,7 @@ use trans::adt;\n use trans::attributes;\n use trans::base::*;\n use trans::build::*;\n-use trans::callee::{self, ArgVals, Callee, TraitItem, MethodData};\n+use trans::callee::{self, ArgVals, Callee};\n use trans::cleanup::{CleanupMethods, CustomScope, ScopeId};\n use trans::common::*;\n use trans::datum::{self, Datum, rvalue_scratch_datum, Rvalue};\n@@ -271,24 +271,8 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n \n     // If the closure is a Fn closure, but a FnOnce is needed (etc),\n     // then adapt the self type\n-    let closure_kind = ccx.tcx().closure_kind(closure_def_id);\n-    trans_closure_adapter_shim(ccx,\n-                               closure_def_id,\n-                               substs,\n-                               closure_kind,\n-                               trait_closure_kind,\n-                               llfn)\n-}\n+    let llfn_closure_kind = ccx.tcx().closure_kind(closure_def_id);\n \n-fn trans_closure_adapter_shim<'a, 'tcx>(\n-    ccx: &'a CrateContext<'a, 'tcx>,\n-    closure_def_id: DefId,\n-    substs: ty::ClosureSubsts<'tcx>,\n-    llfn_closure_kind: ty::ClosureKind,\n-    trait_closure_kind: ty::ClosureKind,\n-    llfn: ValueRef)\n-    -> ValueRef\n-{\n     let _icx = push_ctxt(\"trans_closure_adapter_shim\");\n     let tcx = ccx.tcx();\n \n@@ -393,7 +377,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n                       &block_arena);\n     let mut bcx = init_function(&fcx, false, ret_ty);\n \n-    let llargs = get_params(fcx.llfn);\n+    let mut llargs = get_params(fcx.llfn);\n \n     // the first argument (`self`) will be the (by value) closure env.\n     let self_scope = fcx.push_custom_cleanup_scope();\n@@ -408,21 +392,17 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     debug!(\"trans_fn_once_adapter_shim: env_datum={}\",\n            bcx.val_to_string(env_datum.val));\n+    llargs[self_idx] = env_datum.val;\n \n     let dest =\n         fcx.llretslotptr.get().map(\n             |_| expr::SaveIn(fcx.get_ret_slot(bcx, ret_ty, \"ret_slot\")));\n \n-    let callee_data = TraitItem(MethodData { llfn: llreffn,\n-                                             llself: env_datum.val });\n-\n-    bcx = callee::trans_call_inner(bcx, DebugLoc::None, |bcx, _| {\n-        Callee {\n-            bcx: bcx,\n-            data: callee_data,\n-            ty: llref_fn_ty\n-        }\n-    }, ArgVals(&llargs[(self_idx + 1)..]), dest).bcx;\n+    let callee = Callee {\n+        data: callee::Fn(llreffn),\n+        ty: llref_fn_ty\n+    };\n+    bcx = callee.call(bcx, DebugLoc::None, ArgVals(&llargs[self_idx..]), dest).bcx;\n \n     fcx.pop_and_trans_custom_cleanup_scope(bcx, self_scope);\n "}, {"sha": "abfd127f38860d9ff4026fbf813423cbc01d17ce", "filename": "src/librustc_trans/trans/collector.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -542,14 +542,9 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         debug!(\"visiting operand {:?}\", *operand);\n \n         let callee = match *operand {\n-            mir::Operand::Constant(mir::Constant {\n-                literal: mir::Literal::Item {\n-                    def_id,\n-                    kind,\n-                    substs\n-                },\n-                ..\n-            }) if is_function_or_method(kind) => Some((def_id, substs)),\n+            mir::Operand::Constant(mir::Constant { ty: &ty::TyS {\n+                sty: ty::TyFnDef(def_id, substs, _), ..\n+            }, .. }) => Some((def_id, substs)),\n             _ => None\n         };\n \n@@ -588,14 +583,6 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n         self.super_operand(operand);\n \n-        fn is_function_or_method(item_kind: mir::ItemKind) -> bool {\n-            match item_kind {\n-                mir::ItemKind::Constant => false,\n-                mir::ItemKind::Function |\n-                mir::ItemKind::Method   => true\n-            }\n-        }\n-\n         fn can_result_in_trans_item<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                               def_id: DefId)\n                                               -> bool {\n@@ -690,7 +677,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         if can_have_local_instance(ccx, destructor_did) {\n             let trans_item = create_fn_trans_item(ccx,\n                                                   destructor_did,\n-                                                  ccx.tcx().mk_substs(substs),\n+                                                  substs,\n                                                   &Substs::trans_empty());\n             output.push(trans_item);\n         }\n@@ -833,9 +820,9 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         {\n             let callee_substs = impl_substs.with_method_from(&rcvr_substs);\n             let impl_method = tcx.get_impl_method(impl_did,\n-                                                  callee_substs,\n+                                                  tcx.mk_substs(callee_substs),\n                                                   trait_method.name);\n-            Some((impl_method.method.def_id, tcx.mk_substs(impl_method.substs)))\n+            Some((impl_method.method.def_id, impl_method.substs))\n         }\n         // If we have a closure or a function pointer, we will also encounter\n         // the concrete closure/function somewhere else (during closure or fn\n@@ -993,10 +980,9 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                         // create translation items\n                         .filter_map(|impl_method| {\n                             if can_have_local_instance(ccx, impl_method.method.def_id) {\n-                                let substs = ccx.tcx().mk_substs(impl_method.substs);\n                                 Some(create_fn_trans_item(ccx,\n                                                           impl_method.method.def_id,\n-                                                          substs,\n+                                                          impl_method.substs,\n                                                           &Substs::trans_empty()))\n                             } else {\n                                 None\n@@ -1175,12 +1161,12 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     // The substitutions we have are on the impl, so we grab\n                     // the method type from the impl to substitute into.\n                     let mth = tcx.get_impl_method(impl_def_id,\n-                                                  callee_substs.clone(),\n+                                                  callee_substs,\n                                                   default_impl.name);\n \n                     assert!(mth.is_provided);\n \n-                    let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n+                    let predicates = mth.method.predicates.predicates.subst(tcx, mth.substs);\n                     if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n                         continue;\n                     }"}, {"sha": "34ef4f4acec5e4d763eaa6b19f530f6081256bed", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -1228,7 +1228,7 @@ pub enum ExprOrMethodCall {\n pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 node: ExprOrMethodCall,\n                                 param_substs: &subst::Substs<'tcx>)\n-                                -> subst::Substs<'tcx> {\n+                                -> &'tcx subst::Substs<'tcx> {\n     let tcx = ccx.tcx();\n \n     let substs = match node {\n@@ -1245,9 +1245,9 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               node, substs));\n     }\n \n-    monomorphize::apply_param_substs(tcx,\n-                                     param_substs,\n-                                     &substs.erase_regions())\n+    ccx.tcx().mk_substs(monomorphize::apply_param_substs(tcx,\n+                                                         param_substs,\n+                                                         &substs.erase_regions()))\n }\n \n pub fn langcall(bcx: Block,"}, {"sha": "6c47cab64effe7f2a2ec1111e7a4e620ff8086ae", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -28,6 +28,7 @@ use middle::def::Def;\n use middle::def_id::DefId;\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n+use trans::callee::Callee;\n use trans::collector::{self, TransItem};\n use trans::common::{self, type_is_sized, ExprOrMethodCall, node_id_substs, C_nil, const_get_elt};\n use trans::common::{CrateContext, C_integral, C_floating, C_bool, C_str_slice, C_bytes, val_ty};\n@@ -211,7 +212,7 @@ fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let arg_ids = args.iter().map(|arg| arg.pat.id);\n     let fn_args = arg_ids.zip(arg_vals.iter().cloned()).collect();\n \n-    let substs = ccx.tcx().mk_substs(node_id_substs(ccx, node, param_substs));\n+    let substs = node_id_substs(ccx, node, param_substs);\n     match fn_like.body().expr {\n         Some(ref expr) => {\n             const_expr(ccx, &expr, substs, Some(&fn_args), trueconst).map(|(res, _)| res)\n@@ -355,8 +356,16 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let opt_adj = cx.tcx().tables.borrow().adjustments.get(&e.id).cloned();\n     match opt_adj {\n         Some(AdjustReifyFnPointer) => {\n-            // FIXME(#19925) once fn item types are\n-            // zero-sized, we'll need to do something here\n+            match ety.sty {\n+                ty::TyFnDef(def_id, substs, _) => {\n+                    let datum = Callee::def(cx, def_id, substs, ety).reify(cx);\n+                    llconst = datum.val;\n+                    ety_adjusted = datum.ty;\n+                }\n+                _ => {\n+                    unreachable!(\"{} cannot be reified to a fn ptr\", ety)\n+                }\n+            }\n         }\n         Some(AdjustUnsafeFnPointer) | Some(AdjustMutToConstPointer) => {\n             // purely a type-level thing\n@@ -413,8 +422,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     .expect(\"consts: unsizing got non-pointer target type\").ty;\n                 let ptr_ty = type_of::in_memory_type_of(cx, unsized_ty).ptr_to();\n                 let base = ptrcast(base, ptr_ty);\n-                let info = base::unsized_info(cx, pointee_ty, unsized_ty,\n-                                              old_info, param_substs);\n+                let info = base::unsized_info(cx, pointee_ty, unsized_ty, old_info);\n \n                 if old_info.is_none() {\n                     let prev_const = cx.const_unsized().borrow_mut()\n@@ -894,9 +902,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         cx.sess().span_bug(e.span, \"const fn argument not found\")\n                     }\n                 }\n-                Def::Fn(..) | Def::Method(..) => {\n-                    expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n-                }\n+                Def::Fn(..) | Def::Method(..) => C_nil(cx),\n                 Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                     load_const(cx, try!(get_const_val(cx, def_id, e, param_substs)),\n                                ety)\n@@ -908,23 +914,14 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             let repr = adt::represent_type(cx, ety);\n                             adt::trans_const(cx, &repr, Disr::from(vinfo.disr_val), &[])\n                         }\n-                        ty::VariantKind::Tuple => {\n-                            expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n-                        }\n+                        ty::VariantKind::Tuple => C_nil(cx),\n                         ty::VariantKind::Struct => {\n                             cx.sess().span_bug(e.span, \"path-expr refers to a dict variant!\")\n                         }\n                     }\n                 }\n-                Def::Struct(..) => {\n-                    if let ty::TyFnDef(..) = ety.sty {\n-                        // Tuple struct.\n-                        expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n-                    } else {\n-                        // Unit struct.\n-                        C_null(type_of::type_of(cx, ety))\n-                    }\n-                }\n+                // Unit struct or ctor.\n+                Def::Struct(..) => C_null(type_of::type_of(cx, ety)),\n                 _ => {\n                     cx.sess().span_bug(e.span, \"expected a const, fn, struct, \\\n                                                 or variant def\")"}, {"sha": "ae03f58bce0cf81d01bd1edc69eb479203ce82a9", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 107, "deletions": 203, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -56,17 +56,17 @@ use llvm::{self, ValueRef, TypeKind};\n use middle::const_qualif::ConstQualif;\n use middle::def::Def;\n use middle::subst::Substs;\n-use trans::{_match, adt, asm, base, callee, closure, consts, controlflow};\n+use trans::{_match, adt, asm, base, closure, consts, controlflow};\n use trans::base::*;\n use trans::build::*;\n+use trans::callee::{Callee, ArgExprs, ArgOverloadedCall, ArgOverloadedOp};\n use trans::cleanup::{self, CleanupMethods, DropHintMethods};\n use trans::common::*;\n use trans::datum::*;\n use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n use trans::declare;\n use trans::glue;\n use trans::machine;\n-use trans::meth;\n use trans::tvec;\n use trans::type_of;\n use trans::Disr;\n@@ -85,7 +85,6 @@ use rustc_front::hir;\n \n use syntax::{ast, codemap};\n use syntax::parse::token::InternedString;\n-use syntax::ptr::P;\n use std::mem;\n \n // Destinations\n@@ -349,11 +348,7 @@ fn adjustment_required<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     match adjustment {\n-        AdjustReifyFnPointer => {\n-            // FIXME(#19925) once fn item types are\n-            // zero-sized, we'll need to return true here\n-            false\n-        }\n+        AdjustReifyFnPointer => true,\n         AdjustUnsafeFnPointer | AdjustMutToConstPointer => {\n             // purely a type-level thing\n             false\n@@ -388,8 +383,15 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            adjustment);\n     match adjustment {\n         AdjustReifyFnPointer => {\n-            // FIXME(#19925) once fn item types are\n-            // zero-sized, we'll need to do something here\n+            match datum.ty.sty {\n+                ty::TyFnDef(def_id, substs, _) => {\n+                    datum = Callee::def(bcx.ccx(), def_id, substs, datum.ty)\n+                        .reify(bcx.ccx()).to_expr_datum();\n+                }\n+                _ => {\n+                    unreachable!(\"{} cannot be reified to a fn ptr\", datum.ty)\n+                }\n+            }\n         }\n         AdjustUnsafeFnPointer | AdjustMutToConstPointer => {\n             // purely a type-level thing\n@@ -492,8 +494,7 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 (val, None)\n             };\n \n-            let info = unsized_info(bcx.ccx(), inner_source, inner_target,\n-                                    old_info, bcx.fcx.param_substs);\n+            let info = unsized_info(bcx.ccx(), inner_source, inner_target, old_info);\n \n             // Compute the base pointer. This doesn't change the pointer value,\n             // but merely its type.\n@@ -785,15 +786,10 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let index_expr_debug_loc = index_expr.debug_loc();\n \n     // Check for overloaded index.\n-    let method_ty = ccx.tcx()\n-                       .tables\n-                       .borrow()\n-                       .method_map\n-                       .get(&method_call)\n-                       .map(|method| method.ty);\n-    let elt_datum = match method_ty {\n-        Some(method_ty) => {\n-            let method_ty = monomorphize_type(bcx, method_ty);\n+    let method = ccx.tcx().tables.borrow().method_map.get(&method_call).cloned();\n+    let elt_datum = match method {\n+        Some(method) => {\n+            let method_ty = monomorphize_type(bcx, method.ty);\n \n             let base_datum = unpack_datum!(bcx, trans(bcx, base));\n \n@@ -811,19 +807,16 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 Some(elt_tm) => elt_tm.ty,\n             };\n \n-            // Overloaded. Evaluate `trans_overloaded_op`, which will\n-            // invoke the user's index() method, which basically yields\n-            // a `&T` pointer.  We can then proceed down the normal\n-            // path (below) to dereference that `&T`.\n+            // Overloaded. Invoke the index() method, which basically\n+            // yields a `&T` pointer.  We can then proceed down the\n+            // normal path (below) to dereference that `&T`.\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_index_elt\");\n-            unpack_result!(bcx,\n-                           trans_overloaded_op(bcx,\n-                                               index_expr,\n-                                               method_call,\n-                                               base_datum,\n-                                               Some((ix_datum, idx.id)),\n-                                               Some(SaveIn(scratch.val)),\n-                                               false));\n+\n+            bcx = Callee::method(bcx, method)\n+                .call(bcx, index_expr_debug_loc,\n+                      ArgOverloadedOp(base_datum, Some(ix_datum)),\n+                      Some(SaveIn(scratch.val))).bcx;\n+\n             let datum = scratch.to_expr_datum();\n             let lval = Lvalue::new(\"expr::trans_index overload\");\n             if type_is_sized(bcx.tcx(), elt_ty) {\n@@ -899,24 +892,18 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let _icx = push_ctxt(\"trans_def_lvalue\");\n     match def {\n-        Def::Fn(..) | Def::Method(..) |\n-        Def::Struct(..) | Def::Variant(..) => {\n-            let datum = trans_def_fn_unadjusted(bcx.ccx(), ref_expr, def,\n-                                                bcx.fcx.param_substs);\n-            DatumBlock::new(bcx, datum.to_expr_datum())\n-        }\n         Def::Static(did, _) => {\n             let const_ty = expr_ty(bcx, ref_expr);\n             let val = get_static_val(bcx.ccx(), did, const_ty);\n             let lval = Lvalue::new(\"expr::trans_def\");\n             DatumBlock::new(bcx, Datum::new(val, const_ty, LvalueExpr(lval)))\n         }\n-        Def::Const(_) | Def::AssociatedConst(_) => {\n-            bcx.sess().span_bug(ref_expr.span,\n-                \"constant expression should not reach expr::trans_def\")\n+        Def::Local(..) | Def::Upvar(..) => {\n+            DatumBlock::new(bcx, trans_local_var(bcx, def).to_expr_datum())\n         }\n         _ => {\n-            DatumBlock::new(bcx, trans_local_var(bcx, def).to_expr_datum())\n+            bcx.sess().span_bug(ref_expr.span,\n+                &format!(\"{:?} should not reach expr::trans_def\", def))\n         }\n     }\n }\n@@ -1024,17 +1011,18 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         hir::ExprAssignOp(op, ref dst, ref src) => {\n-            let has_method_map = bcx.tcx()\n-                                    .tables\n-                                    .borrow()\n-                                    .method_map\n-                                    .contains_key(&MethodCall::expr(expr.id));\n+            let method = bcx.tcx().tables\n+                                  .borrow()\n+                                  .method_map\n+                                  .get(&MethodCall::expr(expr.id)).cloned();\n \n-            if has_method_map {\n+            if let Some(method) = method {\n                 let dst = unpack_datum!(bcx, trans(bcx, &dst));\n                 let src_datum = unpack_datum!(bcx, trans(bcx, &src));\n-                trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), dst,\n-                                    Some((src_datum, src.id)), None, false).bcx\n+\n+                Callee::method(bcx, method)\n+                    .call(bcx, expr.debug_loc(),\n+                          ArgOverloadedOp(dst, Some(src_datum)), None).bcx\n             } else {\n                 trans_assign_op(bcx, expr, op, &dst, &src)\n             }\n@@ -1061,6 +1049,9 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n \n+    // Entry into the method table if this is an overloaded call/op.\n+    let method_call = MethodCall::expr(expr.id);\n+\n     match expr.node {\n         hir::ExprType(ref e, _) => {\n             trans_into(bcx, &e, dest)\n@@ -1144,47 +1135,54 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         &expr.attrs).unwrap_or(bcx)\n         }\n         hir::ExprCall(ref f, ref args) => {\n-            if bcx.tcx().is_method_call(expr.id) {\n-                trans_overloaded_call(bcx,\n-                                      expr,\n-                                      &f,\n-                                      &args[..],\n-                                      Some(dest))\n+            let method = bcx.tcx().tables.borrow().method_map.get(&method_call).cloned();\n+            let (callee, args) = if let Some(method) = method {\n+                let mut all_args = vec![&**f];\n+                all_args.extend(args.iter().map(|e| &**e));\n+\n+                (Callee::method(bcx, method), ArgOverloadedCall(all_args))\n             } else {\n-                callee::trans_call(bcx,\n-                                   expr,\n-                                   &f,\n-                                   callee::ArgExprs(&args[..]),\n-                                   dest)\n-            }\n+                let f = unpack_datum!(bcx, trans(bcx, f));\n+                (match f.ty.sty {\n+                    ty::TyFnDef(def_id, substs, _) => {\n+                        Callee::def(bcx.ccx(), def_id, substs, f.ty)\n+                    }\n+                    ty::TyFnPtr(_) => {\n+                        let f = unpack_datum!(bcx,\n+                            f.to_rvalue_datum(bcx, \"callee\"));\n+                        Callee::ptr(f)\n+                    }\n+                    _ => {\n+                        bcx.tcx().sess.span_bug(expr.span,\n+                            &format!(\"type of callee is not a fn: {}\", f.ty));\n+                    }\n+                }, ArgExprs(&args))\n+            };\n+            callee.call(bcx, expr.debug_loc(), args, Some(dest)).bcx\n         }\n         hir::ExprMethodCall(_, _, ref args) => {\n-            callee::trans_method_call(bcx,\n-                                      expr,\n-                                      &args[0],\n-                                      callee::ArgExprs(&args[..]),\n-                                      dest)\n+            Callee::method_call(bcx, method_call)\n+                .call(bcx, expr.debug_loc(), ArgExprs(&args), Some(dest)).bcx\n         }\n-        hir::ExprBinary(op, ref lhs, ref rhs) => {\n+        hir::ExprBinary(op, ref lhs, ref rhs_expr) => {\n             // if not overloaded, would be RvalueDatumExpr\n             let lhs = unpack_datum!(bcx, trans(bcx, &lhs));\n-            let rhs_datum = unpack_datum!(bcx, trans(bcx, &rhs));\n-            trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), lhs,\n-                                Some((rhs_datum, rhs.id)), Some(dest),\n-                                !rustc_front::util::is_by_value_binop(op.node)).bcx\n+            let mut rhs = unpack_datum!(bcx, trans(bcx, &rhs_expr));\n+            if !rustc_front::util::is_by_value_binop(op.node) {\n+                rhs = unpack_datum!(bcx, auto_ref(bcx, rhs, rhs_expr));\n+            }\n+\n+            Callee::method_call(bcx, method_call)\n+                .call(bcx, expr.debug_loc(),\n+                      ArgOverloadedOp(lhs, Some(rhs)), Some(dest)).bcx\n         }\n-        hir::ExprUnary(op, ref subexpr) => {\n+        hir::ExprUnary(_, ref subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n             let arg = unpack_datum!(bcx, trans(bcx, &subexpr));\n-            trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id),\n-                                arg, None, Some(dest), !rustc_front::util::is_by_value_unop(op)).bcx\n-        }\n-        hir::ExprIndex(ref base, ref idx) => {\n-            // if not overloaded, would be RvalueDatumExpr\n-            let base = unpack_datum!(bcx, trans(bcx, &base));\n-            let idx_datum = unpack_datum!(bcx, trans(bcx, &idx));\n-            trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), base,\n-                                Some((idx_datum, idx.id)), Some(dest), true).bcx\n+\n+            Callee::method_call(bcx, method_call)\n+                .call(bcx, expr.debug_loc(),\n+                      ArgOverloadedOp(arg, None), Some(dest)).bcx\n         }\n         hir::ExprCast(..) => {\n             // Trait casts used to come this way, now they should be coercions.\n@@ -1218,26 +1216,22 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         Ignore => { return bcx; }\n     };\n \n+    let ty = expr_ty(bcx, ref_expr);\n+    if let ty::TyFnDef(..) = ty.sty {\n+        // Zero-sized function or ctor.\n+        return bcx;\n+    }\n+\n     match def {\n         Def::Variant(tid, vid) => {\n             let variant = bcx.tcx().lookup_adt_def(tid).variant_with_id(vid);\n-            if let ty::VariantKind::Tuple = variant.kind() {\n-                // N-ary variant.\n-                let llfn = callee::trans_fn_ref(bcx.ccx(), vid,\n-                                                ExprId(ref_expr.id),\n-                                                bcx.fcx.param_substs).val;\n-                Store(bcx, llfn, lldest);\n-                return bcx;\n-            } else {\n-                // Nullary variant.\n-                let ty = expr_ty(bcx, ref_expr);\n-                let repr = adt::represent_type(bcx.ccx(), ty);\n-                adt::trans_set_discr(bcx, &repr, lldest, Disr::from(variant.disr_val));\n-                return bcx;\n-            }\n+            // Nullary variant.\n+            let ty = expr_ty(bcx, ref_expr);\n+            let repr = adt::represent_type(bcx.ccx(), ty);\n+            adt::trans_set_discr(bcx, &repr, lldest, Disr::from(variant.disr_val));\n+            bcx\n         }\n         Def::Struct(..) => {\n-            let ty = expr_ty(bcx, ref_expr);\n             match ty.sty {\n                 ty::TyStruct(def, _) if def.has_dtor() => {\n                     let repr = adt::represent_type(bcx.ccx(), ty);\n@@ -1255,41 +1249,6 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                         ref_expr: &hir::Expr,\n-                                         def: Def,\n-                                         param_substs: &'tcx Substs<'tcx>)\n-                                         -> Datum<'tcx, Rvalue> {\n-    let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n-\n-    match def {\n-        Def::Fn(did) |\n-        Def::Struct(did) | Def::Variant(_, did) => {\n-            callee::trans_fn_ref(ccx, did, ExprId(ref_expr.id), param_substs)\n-        }\n-        Def::Method(method_did) => {\n-            match ccx.tcx().impl_or_trait_item(method_did).container() {\n-                ty::ImplContainer(_) => {\n-                    callee::trans_fn_ref(ccx, method_did,\n-                                         ExprId(ref_expr.id),\n-                                         param_substs)\n-                }\n-                ty::TraitContainer(trait_did) => {\n-                    meth::trans_static_method_callee(ccx, method_did,\n-                                                     trait_did, ref_expr.id,\n-                                                     param_substs)\n-                }\n-            }\n-        }\n-        _ => {\n-            ccx.tcx().sess.span_bug(ref_expr.span, &format!(\n-                    \"trans_def_fn_unadjusted invoked on: {:?} for {:?}\",\n-                    def,\n-                    ref_expr));\n-        }\n-    }\n-}\n-\n /// Translates a reference to a local variable or argument. This always results in an lvalue datum.\n pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    def: Def)\n@@ -1898,51 +1857,6 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   expr: &hir::Expr,\n-                                   method_call: MethodCall,\n-                                   lhs: Datum<'tcx, Expr>,\n-                                   rhs: Option<(Datum<'tcx, Expr>, ast::NodeId)>,\n-                                   dest: Option<Dest>,\n-                                   autoref: bool)\n-                                   -> Result<'blk, 'tcx> {\n-    callee::trans_call_inner(bcx,\n-                             expr.debug_loc(),\n-                             |bcx, arg_cleanup_scope| {\n-                                meth::trans_method_callee(bcx,\n-                                                          method_call,\n-                                                          None,\n-                                                          arg_cleanup_scope)\n-                             },\n-                             callee::ArgOverloadedOp(lhs, rhs, autoref),\n-                             dest)\n-}\n-\n-fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                         expr: &hir::Expr,\n-                                         callee: &'a hir::Expr,\n-                                         args: &'a [P<hir::Expr>],\n-                                         dest: Option<Dest>)\n-                                         -> Block<'blk, 'tcx> {\n-    debug!(\"trans_overloaded_call {}\", expr.id);\n-    let method_call = MethodCall::expr(expr.id);\n-    let mut all_args = vec!(callee);\n-    all_args.extend(args.iter().map(|e| &**e));\n-    unpack_result!(bcx,\n-                   callee::trans_call_inner(bcx,\n-                                            expr.debug_loc(),\n-                                            |bcx, arg_cleanup_scope| {\n-                                                meth::trans_method_callee(\n-                                                    bcx,\n-                                                    method_call,\n-                                                    None,\n-                                                    arg_cleanup_scope)\n-                                            },\n-                                            callee::ArgOverloadedCall(all_args),\n-                                            dest));\n-    bcx\n-}\n-\n pub fn cast_is_noop<'tcx>(tcx: &TyCtxt<'tcx>,\n                           expr: &hir::Expr,\n                           t_in: Ty<'tcx>,\n@@ -2179,18 +2093,12 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n \n     // Check for overloaded deref.\n-    let method_ty = ccx.tcx()\n-                       .tables\n-                       .borrow()\n-                       .method_map\n-                       .get(&method_call).map(|method| method.ty);\n-\n-    let datum = match method_ty {\n-        Some(method_ty) => {\n-            let method_ty = monomorphize_type(bcx, method_ty);\n-\n-            // Overloaded. Evaluate `trans_overloaded_op`, which will\n-            // invoke the user's deref() method, which basically\n+    let method = ccx.tcx().tables.borrow().method_map.get(&method_call).cloned();\n+    let datum = match method {\n+        Some(method) => {\n+            let method_ty = monomorphize_type(bcx, method.ty);\n+\n+            // Overloaded. Invoke the deref() method, which basically\n             // converts from the `Smaht<T>` pointer that we have into\n             // a `&T` pointer.  We can then proceed down the normal\n             // path (below) to dereference that `&T`.\n@@ -2205,9 +2113,10 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 ccx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n \n-            unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,\n-                                                    datum, None, Some(SaveIn(scratch.val)),\n-                                                    false));\n+            bcx = Callee::method(bcx, method)\n+                .call(bcx, expr.debug_loc(),\n+                      ArgOverloadedOp(datum, None),\n+                      Some(SaveIn(scratch.val))).bcx;\n             scratch.to_expr_datum()\n         }\n         None => {\n@@ -2524,18 +2433,13 @@ fn expr_kind(tcx: &TyCtxt, expr: &hir::Expr) -> ExprKind {\n     match expr.node {\n         hir::ExprPath(..) => {\n             match tcx.resolve_expr(expr) {\n-                Def::Struct(..) | Def::Variant(..) => {\n-                    if let ty::TyFnDef(..) = tcx.node_id_to_type(expr.id).sty {\n-                        // ctor function\n-                        ExprKind::RvalueDatum\n-                    } else {\n-                        ExprKind::RvalueDps\n-                    }\n+                // Put functions and ctors with the ADTs, as they\n+                // are zero-sized, so DPS is the cheapest option.\n+                Def::Struct(..) | Def::Variant(..) |\n+                Def::Fn(..) | Def::Method(..) => {\n+                    ExprKind::RvalueDps\n                 }\n \n-                // Fn pointers are just scalar values.\n-                Def::Fn(..) | Def::Method(..) => ExprKind::RvalueDatum,\n-\n                 // Note: there is actually a good case to be made that\n                 // DefArg's, particularly those of immediate type, ought to\n                 // considered rvalues."}, {"sha": "d5f8cff495600397c853f0cf9e65c5933441350b", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -356,27 +356,18 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         &unsized_args\n     };\n \n-    bcx = callee::trans_call_inner(bcx, DebugLoc::None, |bcx, _| {\n-        let trait_ref = ty::Binder(ty::TraitRef {\n-            def_id: tcx.lang_items.drop_trait().unwrap(),\n-            substs: tcx.mk_substs(Substs::trans_empty().with_self_ty(t))\n-        });\n-        let vtbl = match fulfill_obligation(bcx.ccx(), DUMMY_SP, trait_ref) {\n-            traits::VtableImpl(data) => data,\n-            _ => tcx.sess.bug(&format!(\"dtor for {:?} is not an impl???\", t))\n-        };\n-        let dtor_did = def.destructor().unwrap();\n-        let datum = callee::trans_fn_ref_with_substs(bcx.ccx(),\n-                                                     dtor_did,\n-                                                     ExprId(0),\n-                                                     bcx.fcx.param_substs,\n-                                                     vtbl.substs);\n-        callee::Callee {\n-            bcx: bcx,\n-            data: callee::Fn(datum.val),\n-            ty: datum.ty\n-        }\n-    }, callee::ArgVals(args), Some(expr::Ignore)).bcx;\n+    let trait_ref = ty::Binder(ty::TraitRef {\n+        def_id: tcx.lang_items.drop_trait().unwrap(),\n+        substs: tcx.mk_substs(Substs::trans_empty().with_self_ty(t))\n+    });\n+    let vtbl = match fulfill_obligation(bcx.ccx(), DUMMY_SP, trait_ref) {\n+        traits::VtableImpl(data) => data,\n+        _ => tcx.sess.bug(&format!(\"dtor for {:?} is not an impl???\", t))\n+    };\n+    let dtor_did = def.destructor().unwrap();\n+    bcx = callee::Callee::ptr(callee::trans_fn_ref_with_substs(\n+            bcx.ccx(), dtor_did, None, vtbl.substs))\n+        .call(bcx, DebugLoc::None, callee::ArgVals(args), Some(expr::Ignore)).bcx;\n \n     bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n }"}, {"sha": "dff6652e5419bc1821ae9754f3a5a57533558cbf", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -163,7 +163,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                             cleanup_scope: cleanup::CustomScopeIndex,\n                                             args: callee::CallArgs<'a, 'tcx>,\n                                             dest: expr::Dest,\n-                                            substs: subst::Substs<'tcx>,\n+                                            substs: &'tcx subst::Substs<'tcx>,\n                                             call_info: NodeIdAndSpan)\n                                             -> Result<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n@@ -364,7 +364,6 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              callee_ty,\n                              &mut llargs,\n                              cleanup::CustomScope(cleanup_scope),\n-                             false,\n                              Abi::RustIntrinsic);\n \n     fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n@@ -1397,7 +1396,7 @@ fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n     (bcx: Block<'blk, 'tcx>,\n      name: &str,\n-     substs: subst::Substs<'tcx>,\n+     substs: &'tcx subst::Substs<'tcx>,\n      callee_ty: Ty<'tcx>,\n      args: Option<&[P<hir::Expr>]>,\n      llargs: &[ValueRef],\n@@ -1505,11 +1504,7 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n             None => bcx.sess().span_bug(call_info.span,\n                                         \"intrinsic call with unexpected argument shape\"),\n         };\n-        let vector = match consts::const_expr(\n-            bcx.ccx(),\n-            vector,\n-            tcx.mk_substs(substs),\n-            None,\n+        let vector = match consts::const_expr(bcx.ccx(), vector, substs, None,\n             consts::TrueConst::Yes, // this should probably help simd error reporting\n         ) {\n             Ok((vector, _)) => vector,"}, {"sha": "78b86dafa18ad83dd31172f1930d6036fb916f5e", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 82, "deletions": 271, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -18,9 +18,8 @@ use middle::subst;\n use middle::traits;\n use trans::base::*;\n use trans::build::*;\n-use trans::callee::*;\n-use trans::callee;\n-use trans::cleanup;\n+use trans::callee::{Callee, Virtual, ArgVals,\n+                    trans_fn_pointer_shim, trans_fn_ref_with_substs};\n use trans::closure;\n use trans::common::*;\n use trans::consts;\n@@ -30,11 +29,9 @@ use trans::declare;\n use trans::expr;\n use trans::glue;\n use trans::machine;\n-use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of::*;\n use middle::ty::{self, Ty, TyCtxt};\n-use middle::ty::MethodCall;\n \n use syntax::ast;\n use syntax::attr;\n@@ -92,263 +89,99 @@ pub fn trans_impl(ccx: &CrateContext,\n     }\n }\n \n-pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                       method_call: MethodCall,\n-                                       self_expr: Option<&hir::Expr>,\n-                                       arg_cleanup_scope: cleanup::ScopeId)\n-                                       -> Callee<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"meth::trans_method_callee\");\n-\n-    let method = bcx.tcx().tables.borrow().method_map[&method_call];\n-\n-    match bcx.tcx().impl_or_trait_item(method.def_id).container() {\n-        ty::ImplContainer(_) => {\n-            debug!(\"trans_method_callee: static, {:?}\", method.def_id);\n-            let datum = callee::trans_fn_ref(bcx.ccx(),\n-                                             method.def_id,\n-                                             MethodCallKey(method_call),\n-                                             bcx.fcx.param_substs);\n-            Callee {\n-                bcx: bcx,\n-                data: Fn(datum.val),\n-                ty: datum.ty\n-            }\n-        }\n-\n-        ty::TraitContainer(trait_def_id) => {\n-            let trait_ref = method.substs.to_trait_ref(bcx.tcx(), trait_def_id);\n-            let trait_ref = ty::Binder(bcx.monomorphize(&trait_ref));\n-            let span = bcx.tcx().map.span(method_call.expr_id);\n-            debug!(\"method_call={:?} trait_ref={:?} trait_ref id={:?} substs={:?}\",\n-                   method_call,\n-                   trait_ref,\n-                   trait_ref.0.def_id,\n-                   trait_ref.0.substs);\n-            let origin = fulfill_obligation(bcx.ccx(), span, trait_ref);\n-            debug!(\"origin = {:?}\", origin);\n-            trans_monomorphized_callee(bcx,\n-                                       method_call,\n-                                       self_expr,\n-                                       trait_def_id,\n-                                       method.def_id,\n-                                       method.ty,\n-                                       origin,\n-                                       arg_cleanup_scope)\n-        }\n-    }\n-}\n-\n-pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                            method_id: DefId,\n-                                            trait_id: DefId,\n-                                            expr_id: ast::NodeId,\n-                                            param_substs: &'tcx subst::Substs<'tcx>)\n-                                            -> Datum<'tcx, Rvalue>\n-{\n-    let _icx = push_ctxt(\"meth::trans_static_method_callee\");\n-    let tcx = ccx.tcx();\n-\n-    debug!(\"trans_static_method_callee(method_id={:?}, trait_id={}, \\\n-            expr_id={})\",\n-           method_id,\n-           tcx.item_path_str(trait_id),\n-           expr_id);\n-\n-    let mname = tcx.item_name(method_id);\n-\n-    debug!(\"trans_static_method_callee: method_id={:?}, expr_id={}, \\\n-            name={}\", method_id, expr_id, mname);\n-\n-    // Find the substitutions for the fn itself. This includes\n-    // type parameters that belong to the trait but also some that\n-    // belong to the method:\n-    let rcvr_substs = node_id_substs(ccx, ExprId(expr_id), param_substs);\n-    debug!(\"rcvr_substs={:?}\", rcvr_substs);\n-    let trait_ref = ty::Binder(rcvr_substs.to_trait_ref(tcx, trait_id));\n-    let vtbl = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n-\n-    // Now that we know which impl is being used, we can dispatch to\n-    // the actual function:\n-    match vtbl {\n-        traits::VtableImpl(traits::VtableImplData {\n-            impl_def_id: impl_did,\n-            substs: impl_substs,\n-            nested: _ }) =>\n-        {\n-            let callee_substs = impl_substs.with_method_from(&rcvr_substs);\n-            let mth = tcx.get_impl_method(impl_did, callee_substs, mname);\n-            trans_fn_ref_with_substs(ccx, mth.method.def_id, ExprId(expr_id),\n-                                     param_substs,\n-                                     mth.substs)\n-        }\n-        traits::VtableObject(ref data) => {\n-            let idx = traits::get_vtable_index_of_object_method(tcx, data, method_id);\n-            trans_object_shim(ccx,\n-                              data.upcast_trait_ref.clone(),\n-                              method_id,\n-                              idx)\n-        }\n-        _ => {\n-            // FIXME(#20847): handle at least VtableFnPointer\n-            tcx.sess.bug(&format!(\"static call to invalid vtable: {:?}\",\n-                                 vtbl));\n-        }\n-    }\n-}\n-\n-fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                          method_call: MethodCall,\n-                                          self_expr: Option<&hir::Expr>,\n-                                          trait_id: DefId,\n-                                          method_id: DefId,\n-                                          method_ty: Ty<'tcx>,\n-                                          vtable: traits::Vtable<'tcx, ()>,\n-                                          arg_cleanup_scope: cleanup::ScopeId)\n-                                          -> Callee<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n+/// Compute the appropriate callee, give na method's ID, trait ID,\n+/// substitutions and a Vtable for that trait.\n+pub fn callee_for_trait_impl<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                       method_id: DefId,\n+                                       substs: &'tcx subst::Substs<'tcx>,\n+                                       trait_id: DefId,\n+                                       method_ty: Ty<'tcx>,\n+                                       vtable: traits::Vtable<'tcx, ()>)\n+                                       -> Callee<'tcx> {\n+    let _icx = push_ctxt(\"meth::callee_for_trait_impl\");\n     match vtable {\n         traits::VtableImpl(vtable_impl) => {\n-            let ccx = bcx.ccx();\n             let impl_did = vtable_impl.impl_def_id;\n-            let mname = match ccx.tcx().impl_or_trait_item(method_id) {\n-                ty::MethodTraitItem(method) => method.name,\n-                _ => {\n-                    bcx.tcx().sess.bug(\"can't monomorphize a non-method trait \\\n-                                        item\")\n-                }\n-            };\n+            let mname = ccx.tcx().item_name(method_id);\n             // create a concatenated set of substitutions which includes\n             // those from the impl and those from the method:\n-            let meth_substs = node_id_substs(ccx,\n-                                             MethodCallKey(method_call),\n-                                             bcx.fcx.param_substs);\n-            let impl_substs = vtable_impl.substs.with_method_from(&meth_substs);\n-            let mth = bcx.tcx().get_impl_method(impl_did, impl_substs, mname);\n-            // translate the function\n-            let datum = trans_fn_ref_with_substs(bcx.ccx(),\n-                                                 mth.method.def_id,\n-                                                 MethodCallKey(method_call),\n-                                                 bcx.fcx.param_substs,\n-                                                 mth.substs);\n-\n-            Callee { bcx: bcx, data: Fn(datum.val), ty: datum.ty }\n+            let impl_substs = vtable_impl.substs.with_method_from(&substs);\n+            let substs = ccx.tcx().mk_substs(impl_substs);\n+            let mth = ccx.tcx().get_impl_method(impl_did, substs, mname);\n+\n+            // Translate the function, bypassing Callee::def.\n+            // That is because default methods have the same ID as the\n+            // trait method used to look up the impl method that ended\n+            // up here, so calling Callee::def would infinitely recurse.\n+            Callee::ptr(trans_fn_ref_with_substs(ccx, mth.method.def_id,\n+                                                 Some(method_ty), mth.substs))\n         }\n         traits::VtableClosure(vtable_closure) => {\n             // The substitutions should have no type parameters remaining\n             // after passing through fulfill_obligation\n-            let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n-            let llfn = closure::trans_closure_method(bcx.ccx(),\n+            let trait_closure_kind = ccx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n+            let llfn = closure::trans_closure_method(ccx,\n                                                      vtable_closure.closure_def_id,\n                                                      vtable_closure.substs,\n                                                      trait_closure_kind);\n-            Callee {\n-                bcx: bcx,\n-                data: Fn(llfn),\n-                ty: monomorphize_type(bcx, method_ty)\n-            }\n+            let fn_ptr_ty = match method_ty.sty {\n+                ty::TyFnDef(_, _, fty) => ccx.tcx().mk_ty(ty::TyFnPtr(fty)),\n+                _ => unreachable!(\"expected fn item type, found {}\",\n+                                  method_ty)\n+            };\n+            Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n         }\n         traits::VtableFnPointer(fn_ty) => {\n-            let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n-            let llfn = trans_fn_pointer_shim(bcx.ccx(), trait_closure_kind, fn_ty);\n-            Callee {\n-                bcx: bcx,\n-                data: Fn(llfn),\n-                ty: monomorphize_type(bcx, method_ty)\n-            }\n+            let trait_closure_kind = ccx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n+            let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n+            let fn_ptr_ty = match method_ty.sty {\n+                ty::TyFnDef(_, _, fty) => ccx.tcx().mk_ty(ty::TyFnPtr(fty)),\n+                _ => unreachable!(\"expected fn item type, found {}\",\n+                                  method_ty)\n+            };\n+            Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n         }\n         traits::VtableObject(ref data) => {\n-            let idx = traits::get_vtable_index_of_object_method(bcx.tcx(), data, method_id);\n-            if let Some(self_expr) = self_expr {\n-                if let ty::TyFnDef(_, _, ref fty) = monomorphize_type(bcx, method_ty).sty {\n-                    let ty = opaque_method_ty(bcx.tcx(), fty);\n-                    return trans_trait_callee(bcx, ty, idx, self_expr, arg_cleanup_scope);\n-                }\n+            Callee {\n+                data: Virtual(traits::get_vtable_index_of_object_method(\n+                    ccx.tcx(), data, method_id)),\n+                ty: method_ty\n             }\n-            let datum = trans_object_shim(bcx.ccx(),\n-                                          data.upcast_trait_ref.clone(),\n-                                          method_id,\n-                                          idx);\n-            Callee { bcx: bcx, data: Fn(datum.val), ty: datum.ty }\n         }\n         traits::VtableBuiltin(..) |\n         traits::VtableDefaultImpl(..) |\n         traits::VtableParam(..) => {\n-            bcx.sess().bug(\n+            ccx.sess().bug(\n                 &format!(\"resolved vtable bad vtable {:?} in trans\",\n                         vtable));\n         }\n     }\n }\n \n-/// Create a method callee where the method is coming from a trait object (e.g., Box<Trait> type).\n-/// In this case, we must pull the fn pointer out of the vtable that is packaged up with the\n-/// object. Objects are represented as a pair, so we first evaluate the self expression and then\n-/// extract the self data and vtable out of the pair.\n-fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  opaque_fn_ty: Ty<'tcx>,\n-                                  vtable_index: usize,\n-                                  self_expr: &hir::Expr,\n-                                  arg_cleanup_scope: cleanup::ScopeId)\n-                                  -> Callee<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"meth::trans_trait_callee\");\n-    let mut bcx = bcx;\n-\n-    // Translate self_datum and take ownership of the value by\n-    // converting to an rvalue.\n-    let self_datum = unpack_datum!(\n-        bcx, expr::trans(bcx, self_expr));\n-\n-    let llval = if bcx.fcx.type_needs_drop(self_datum.ty) {\n-        let self_datum = unpack_datum!(\n-            bcx, self_datum.to_rvalue_datum(bcx, \"trait_callee\"));\n-\n-        // Convert to by-ref since `trans_trait_callee_from_llval` wants it\n-        // that way.\n-        let self_datum = unpack_datum!(\n-            bcx, self_datum.to_ref_datum(bcx));\n-\n-        // Arrange cleanup in case something should go wrong before the\n-        // actual call occurs.\n-        self_datum.add_clean(bcx.fcx, arg_cleanup_scope)\n-    } else {\n-        // We don't have to do anything about cleanups for &Trait and &mut Trait.\n-        assert!(self_datum.kind.is_by_ref());\n-        self_datum.val\n-    };\n-\n-    let llself = Load(bcx, expr::get_dataptr(bcx, llval));\n-    let llvtable = Load(bcx, expr::get_meta(bcx, llval));\n-    trans_trait_callee_from_llval(bcx, opaque_fn_ty, vtable_index, llself, llvtable)\n-}\n-\n-/// Same as `trans_trait_callee()` above, except that it is given a by-ref pointer to the object\n-/// pair.\n-fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                             opaque_fn_ty: Ty<'tcx>,\n-                                             vtable_index: usize,\n-                                             llself: ValueRef,\n-                                             llvtable: ValueRef)\n-                                             -> Callee<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"meth::trans_trait_callee\");\n+/// Extracts a method from a trait object's vtable, at the\n+/// specified index, and casts it to the given type.\n+pub fn get_virtual_method<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      llvtable: ValueRef,\n+                                      vtable_index: usize,\n+                                      method_ty: Ty<'tcx>)\n+                                      -> Datum<'tcx, Rvalue> {\n+    let _icx = push_ctxt(\"meth::get_virtual_method\");\n     let ccx = bcx.ccx();\n \n     // Load the data pointer from the object.\n-    debug!(\"trans_trait_callee_from_llval(callee_ty={}, vtable_index={}, llself={}, llvtable={})\",\n-           opaque_fn_ty,\n+    debug!(\"get_virtual_method(callee_ty={}, vtable_index={}, llvtable={})\",\n+           method_ty,\n            vtable_index,\n-           bcx.val_to_string(llself),\n            bcx.val_to_string(llvtable));\n \n-    // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n     let mptr = Load(bcx, GEPi(bcx, llvtable, &[vtable_index + VTABLE_OFFSET]));\n \n-    Callee {\n-        bcx: bcx,\n-        data: TraitItem(MethodData {\n-            llfn: PointerCast(bcx, mptr, type_of(ccx, opaque_fn_ty)),\n-            llself: PointerCast(bcx, llself, Type::i8p(ccx)),\n-        }),\n-        ty: opaque_fn_ty\n+    // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n+    if let ty::TyFnDef(_, _, fty) = method_ty.sty {\n+        let opaque_ty = opaque_method_ty(ccx.tcx(), fty);\n+        immediate_rvalue(PointerCast(bcx, mptr, type_of(ccx, opaque_ty)), opaque_ty)\n+    } else {\n+        immediate_rvalue(mptr, method_ty)\n     }\n }\n \n@@ -373,41 +206,24 @@ fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n ///\n /// In fact, all virtual calls can be thought of as normal trait calls\n /// that go through this shim function.\n-pub fn trans_object_shim<'a, 'tcx>(\n-    ccx: &'a CrateContext<'a, 'tcx>,\n-    upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n-    method_id: DefId,\n-    vtable_index: usize)\n-    -> Datum<'tcx, Rvalue>\n-{\n+pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n+                                   method_ty: Ty<'tcx>,\n+                                   vtable_index: usize)\n+                                   -> Datum<'tcx, Rvalue> {\n     let _icx = push_ctxt(\"trans_object_shim\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_object_shim(upcast_trait_ref={:?}, method_id={:?})\",\n-           upcast_trait_ref,\n-           method_id);\n+    debug!(\"trans_object_shim(vtable_index={}, method_ty={:?})\",\n+           vtable_index,\n+           method_ty);\n \n-    // Upcast to the trait in question and extract out the substitutions.\n-    let upcast_trait_ref = tcx.erase_late_bound_regions(&upcast_trait_ref);\n-    let object_substs = upcast_trait_ref.substs.clone().erase_regions();\n-    debug!(\"trans_object_shim: object_substs={:?}\", object_substs);\n+    let ret_ty = tcx.erase_late_bound_regions(&method_ty.fn_ret());\n+    let ret_ty = infer::normalize_associated_type(tcx, &ret_ty);\n \n-    // Lookup the type of this method as declared in the trait and apply substitutions.\n-    let method_ty = match tcx.impl_or_trait_item(method_id) {\n-        ty::MethodTraitItem(method) => method,\n-        _ => {\n-            tcx.sess.bug(\"can't create a method shim for a non-method item\")\n-        }\n+    let shim_fn_ty = match method_ty.sty {\n+        ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n+        _ => unreachable!(\"expected fn item type, found {}\", method_ty)\n     };\n-    let fty = monomorphize::apply_param_substs(tcx, &object_substs, &method_ty.fty);\n-\n-    let ret_ty = ccx.tcx().erase_late_bound_regions(&fty.sig.output());\n-    let ret_ty = infer::normalize_associated_type(ccx.tcx(), &ret_ty);\n-\n-    let method_fn_ty = opaque_method_ty(tcx, &fty);\n-    let shim_fn_ty = tcx.mk_fn_ptr(fty);\n-    debug!(\"trans_object_shim: shim_fn_ty={:?} method_fn_ty={:?}\",\n-           shim_fn_ty, method_fn_ty);\n \n     //\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, shim_fn_ty, \"object_shim\");\n@@ -444,14 +260,11 @@ pub fn trans_object_shim<'a, 'tcx>(\n     debug!(\"trans_object_shim: method_offset_in_vtable={}\",\n            vtable_index);\n \n-    bcx = trans_call_inner(bcx,\n-                           DebugLoc::None,\n-                           |bcx, _| trans_trait_callee_from_llval(bcx,\n-                                                                  method_fn_ty,\n-                                                                  vtable_index,\n-                                                                  llself, llvtable),\n-                           ArgVals(&llargs[(self_idx + 2)..]),\n-                           dest).bcx;\n+    let callee = Callee {\n+        data: Virtual(vtable_index),\n+        ty: method_ty\n+    };\n+    bcx = callee.call(bcx, DebugLoc::None, ArgVals(&llargs[self_idx..]), dest).bcx;\n \n     finish_fn(&fcx, bcx, ret_ty, DebugLoc::None);\n \n@@ -465,8 +278,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n /// `trait_ref` would map `T:Trait`.\n pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                            trait_ref: ty::PolyTraitRef<'tcx>,\n-                            param_substs: &'tcx subst::Substs<'tcx>)\n+                            trait_ref: ty::PolyTraitRef<'tcx>)\n                             -> ValueRef\n {\n     let tcx = ccx.tcx();\n@@ -502,8 +314,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             Some(mth) => {\n                                 trans_fn_ref_with_substs(ccx,\n                                                          mth.method.def_id,\n-                                                         ExprId(0),\n-                                                         param_substs,\n+                                                         None,\n                                                          mth.substs).val\n                             }\n                             None => nullptr\n@@ -566,7 +377,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     impl_id: DefId,\n-                                    substs: subst::Substs<'tcx>)\n+                                    substs: &'tcx subst::Substs<'tcx>)\n                                     -> Vec<Option<ty::util::ImplMethod<'tcx>>>\n {\n     let tcx = ccx.tcx();\n@@ -617,7 +428,7 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             // The substitutions we have are on the impl, so we grab\n             // the method type from the impl to substitute into.\n-            let mth = tcx.get_impl_method(impl_id, substs.clone(), name);\n+            let mth = tcx.get_impl_method(impl_id, substs, name);\n \n             debug!(\"get_vtable_methods: mth={:?}\", mth);\n \n@@ -627,7 +438,7 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // method could then never be called, so we do not want to\n             // try and trans it, in that case. Issue #23435.\n             if mth.is_provided {\n-                let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n+                let predicates = mth.method.predicates.predicates.subst(tcx, mth.substs);\n                 if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n                     debug!(\"get_vtable_methods: predicates do not hold\");\n                     return None;"}, {"sha": "50283c0959c3f37a5f613d2456119b0822aef196", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 76, "deletions": 70, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -9,73 +9,27 @@\n // except according to those terms.\n \n use llvm::{BasicBlockRef, ValueRef, OperandBundleDef};\n-use rustc::middle::ty::{self, Ty};\n+use rustc::middle::ty;\n use rustc::mir::repr as mir;\n use syntax::abi::Abi;\n use trans::adt;\n use trans::attributes;\n use trans::base;\n use trans::build;\n+use trans::callee::{Callee, Fn, Virtual};\n use trans::common::{self, Block, BlockAndBuilder};\n use trans::debuginfo::DebugLoc;\n use trans::Disr;\n use trans::foreign;\n+use trans::meth;\n use trans::type_of;\n use trans::glue;\n use trans::type_::Type;\n \n use super::{MirContext, drop};\n use super::operand::OperandValue::{FatPtr, Immediate, Ref};\n-use super::operand::OperandRef;\n-\n-#[derive(PartialEq, Eq)]\n-enum AbiStyle {\n-    Foreign,\n-    RustCall,\n-    Rust\n-}\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n-    fn abi_style(&self, fn_ty: Ty<'tcx>) -> AbiStyle {\n-        match fn_ty.sty {\n-            ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n-                // We do not translate intrinsics here (they shouldn\u2019t be functions)\n-                assert!(f.abi != Abi::RustIntrinsic && f.abi != Abi::PlatformIntrinsic);\n-\n-                match f.abi {\n-                    Abi::Rust => AbiStyle::Rust,\n-                    Abi::RustCall => AbiStyle::RustCall,\n-                    _ => AbiStyle::Foreign\n-                }\n-            }\n-            _ => unreachable!()\n-        }\n-    }\n-\n-    fn arg_operands(&mut self,\n-                    bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                    abi_style: AbiStyle,\n-                    args: &[mir::Operand<'tcx>])\n-                    -> Vec<OperandRef<'tcx>>\n-    {\n-        match abi_style {\n-            AbiStyle::Foreign | AbiStyle::Rust => {\n-                args.iter().map(|arg| self.trans_operand(bcx, arg)).collect()\n-            }\n-            AbiStyle::RustCall => match args.split_last() {\n-                None => vec![],\n-                Some((tup, self_ty)) => {\n-                    // we can reorder safely because of MIR\n-                    let untupled_args = self.trans_operand_untupled(bcx, tup);\n-                    self_ty\n-                        .iter().map(|arg| self.trans_operand(bcx, arg))\n-                        .chain(untupled_args.into_iter())\n-                        .collect()\n-                }\n-            }\n-        }\n-    }\n-\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n         debug!(\"trans_block({:?})\", bb);\n \n@@ -198,19 +152,32 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::Terminator::Call { ref func, ref args, ref destination, ref cleanup } => {\n-                // Create the callee. This will always be a fn ptr and hence a kind of scalar.\n+                // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n-                let attrs = attributes::from_fn_type(bcx.ccx(), callee.ty);\n                 let debugloc = DebugLoc::None;\n                 // The arguments we'll be passing. Plus one to account for outptr, if used.\n                 let mut llargs = Vec::with_capacity(args.len() + 1);\n                 // Types of the arguments. We do not preallocate, because this vector is only\n                 // filled when `is_foreign` is `true` and foreign calls are minority of the cases.\n                 let mut arg_tys = Vec::new();\n \n+                let (callee, fty) = match callee.ty.sty {\n+                    ty::TyFnDef(def_id, substs, f) => {\n+                        (Callee::def(bcx.ccx(), def_id, substs, callee.ty), f)\n+                    }\n+                    ty::TyFnPtr(f) => {\n+                        (Callee {\n+                            data: Fn(callee.immediate()),\n+                            ty: callee.ty\n+                        }, f)\n+                    }\n+                    _ => unreachable!(\"{} is not callable\", callee.ty)\n+                };\n+\n+                // We do not translate intrinsics here (they shouldn\u2019t be functions)\n+                assert!(fty.abi != Abi::RustIntrinsic && fty.abi != Abi::PlatformIntrinsic);\n                 // Foreign-ABI functions are translated differently\n-                let abi_style = self.abi_style(callee.ty);\n-                let is_foreign = abi_style == AbiStyle::Foreign;\n+                let is_foreign = fty.abi != Abi::Rust && fty.abi != Abi::RustCall;\n \n                 // Prepare the return value destination\n                 let (ret_dest_ty, must_copy_dest) = if let Some((ref d, _)) = *destination {\n@@ -226,19 +193,58 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     (None, false)\n                 };\n \n-                // Process the rest of the args.\n-                for operand in self.arg_operands(&bcx, abi_style, args) {\n-                    match operand.val {\n-                        Ref(llval) | Immediate(llval) => llargs.push(llval),\n-                        FatPtr(b, e) => {\n-                            llargs.push(b);\n-                            llargs.push(e);\n+                // Split the rust-call tupled arguments off.\n+                let (args, rest) = if fty.abi == Abi::RustCall && !args.is_empty() {\n+                    let (tup, args) = args.split_last().unwrap();\n+                    // we can reorder safely because of MIR\n+                    (args, self.trans_operand_untupled(&bcx, tup))\n+                } else {\n+                    (&args[..], vec![])\n+                };\n+\n+                let datum = {\n+                    let mut arg_ops = args.iter().map(|arg| {\n+                        self.trans_operand(&bcx, arg)\n+                    }).chain(rest.into_iter());\n+\n+                    // Get the actual pointer we can call.\n+                    // This can involve vtable accesses or reification.\n+                    let datum = if let Virtual(idx) = callee.data {\n+                        assert!(!is_foreign);\n+\n+                        // Grab the first argument which is a trait object.\n+                        let vtable = match arg_ops.next().unwrap().val {\n+                            FatPtr(data, vtable) => {\n+                                llargs.push(data);\n+                                vtable\n+                            }\n+                            _ => unreachable!(\"expected FatPtr for Virtual call\")\n+                        };\n+\n+                        bcx.with_block(|bcx| {\n+                            meth::get_virtual_method(bcx, vtable, idx, callee.ty)\n+                        })\n+                    } else {\n+                        callee.reify(bcx.ccx())\n+                    };\n+\n+                    // Process the rest of the args.\n+                    for operand in arg_ops {\n+                        match operand.val {\n+                            Ref(llval) | Immediate(llval) => llargs.push(llval),\n+                            FatPtr(b, e) => {\n+                                llargs.push(b);\n+                                llargs.push(e);\n+                            }\n+                        }\n+                        if is_foreign {\n+                            arg_tys.push(operand.ty);\n                         }\n                     }\n-                    if is_foreign {\n-                        arg_tys.push(operand.ty);\n-                    }\n-                }\n+\n+                    datum\n+                };\n+                let attrs = attributes::from_fn_type(bcx.ccx(), datum.ty);\n \n                 // Many different ways to call a function handled here\n                 match (is_foreign, cleanup, destination) {\n@@ -247,7 +253,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n                         let unreachable_blk = self.unreachable_block();\n-                        bcx.invoke(callee.immediate(),\n+                        bcx.invoke(datum.val,\n                                    &llargs[..],\n                                    unreachable_blk.llbb,\n                                    landingpad.llbb(),\n@@ -260,7 +266,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     (false, &Some(cleanup), &Some((_, success))) => {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n-                        let invokeret = bcx.invoke(callee.immediate(),\n+                        let invokeret = bcx.invoke(datum.val,\n                                                    &llargs[..],\n                                                    self.llblock(success),\n                                                    landingpad.llbb(),\n@@ -283,15 +289,15 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         });\n                     },\n                     (false, _, &None) => {\n-                        bcx.call(callee.immediate(),\n+                        bcx.call(datum.val,\n                                  &llargs[..],\n                                  cleanup_bundle.as_ref(),\n                                  Some(attrs));\n                         // no need to drop args, because the call never returns\n                         bcx.unreachable();\n                     }\n                     (false, _, &Some((_, target))) => {\n-                        let llret = bcx.call(callee.immediate(),\n+                        let llret = bcx.call(datum.val,\n                                              &llargs[..],\n                                              cleanup_bundle.as_ref(),\n                                              Some(attrs));\n@@ -313,8 +319,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             .expect(\"return destination is not set\");\n                         bcx = bcx.map_block(|bcx| {\n                             foreign::trans_native_call(bcx,\n-                                                       callee.ty,\n-                                                       callee.immediate(),\n+                                                       datum.ty,\n+                                                       datum.val,\n                                                        dest.llval,\n                                                        &llargs[..],\n                                                        arg_tys,"}, {"sha": "a0615a6cf5b18041c5e57e78e30cc3e10c3e9a95", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -10,14 +10,14 @@\n \n use back::abi;\n use llvm::ValueRef;\n-use middle::subst::Substs;\n use middle::ty::{Ty, TypeFoldable};\n-use rustc::middle::const_eval::ConstVal;\n+use rustc::middle::const_eval::{self, ConstVal};\n use rustc::mir::repr as mir;\n use trans::common::{self, BlockAndBuilder, C_bool, C_bytes, C_floating_f64, C_integral,\n-                    C_str_slice};\n+                    C_str_slice, C_nil, C_undef};\n use trans::consts;\n use trans::expr;\n+use trans::inline;\n use trans::type_of;\n \n use super::operand::{OperandRef, OperandValue};\n@@ -32,7 +32,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           -> OperandRef<'tcx>\n     {\n         let ccx = bcx.ccx();\n-        let val = self.trans_constval_inner(bcx, cv, ty, bcx.fcx().param_substs);\n+        let val = self.trans_constval_inner(bcx, cv, ty);\n         let val = if common::type_is_immediate(ccx, ty) {\n             OperandValue::Immediate(val)\n         } else if common::type_is_fat_ptr(bcx.tcx(), ty) {\n@@ -55,8 +55,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     fn trans_constval_inner(&mut self,\n                             bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                             cv: &ConstVal,\n-                            ty: Ty<'tcx>,\n-                            param_substs: &'tcx Substs<'tcx>)\n+                            ty: Ty<'tcx>)\n                             -> ValueRef\n     {\n         let ccx = bcx.ccx();\n@@ -75,8 +74,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     expr::trans(bcx, expr).datum.val\n                 })\n             },\n-            ConstVal::Function(did) =>\n-                self.trans_fn_ref(bcx, ty, param_substs, did).immediate()\n+            ConstVal::Function(_) => C_nil(ccx)\n         }\n     }\n \n@@ -85,13 +83,31 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           constant: &mir::Constant<'tcx>)\n                           -> OperandRef<'tcx>\n     {\n+        let ty = bcx.monomorphize(&constant.ty);\n         match constant.literal {\n-            mir::Literal::Item { def_id, kind, substs } => {\n+            mir::Literal::Item { def_id, substs } => {\n+                // Shortcut for zero-sized types, including function item\n+                // types, which would not work with lookup_const_by_id.\n+                if common::type_is_zero_size(bcx.ccx(), ty) {\n+                    let llty = type_of::type_of(bcx.ccx(), ty);\n+                    return OperandRef {\n+                        val: OperandValue::Immediate(C_undef(llty)),\n+                        ty: ty\n+                    };\n+                }\n+\n                 let substs = bcx.tcx().mk_substs(bcx.monomorphize(&substs));\n-                self.trans_item_ref(bcx, constant.ty, kind, substs, def_id)\n+                let def_id = inline::maybe_instantiate_inline(bcx.ccx(), def_id);\n+                let expr = const_eval::lookup_const_by_id(bcx.tcx(), def_id, None, Some(substs))\n+                            .expect(\"def was const, but lookup_const_by_id failed\");\n+                // FIXME: this is falling back to translating from HIR. This is not easy to fix,\n+                // because we would have somehow adapt const_eval to work on MIR rather than HIR.\n+                let d = bcx.with_block(|bcx| {\n+                    expr::trans(bcx, expr)\n+                });\n+                OperandRef::from_rvalue_datum(d.datum.to_rvalue_datum(d.bcx, \"\").datum)\n             }\n             mir::Literal::Value { ref value } => {\n-                let ty = bcx.monomorphize(&constant.ty);\n                 self.trans_constval(bcx, value, ty)\n             }\n         }"}, {"sha": "5b6af4757197f999bf152eb16a6f85783cd30605", "filename": "src/librustc_trans/trans/mir/did.rs", "status": "removed", "additions": 0, "deletions": 171, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/c284099f5678da0d6cae52757fffe0c2c0eb2d1f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c284099f5678da0d6cae52757fffe0c2c0eb2d1f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs?ref=c284099f5678da0d6cae52757fffe0c2c0eb2d1f", "patch": "@@ -1,171 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Code for translating references to other items (DefIds).\n-\n-use syntax::codemap::DUMMY_SP;\n-use rustc::front::map;\n-use rustc::middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::middle::subst::Substs;\n-use rustc::middle::const_eval;\n-use rustc::middle::def_id::DefId;\n-use rustc::middle::traits;\n-use rustc::mir::repr::ItemKind;\n-use trans::common::{BlockAndBuilder, fulfill_obligation};\n-use trans::base;\n-use trans::closure;\n-use trans::expr;\n-use trans::monomorphize;\n-use trans::meth;\n-use trans::inline;\n-\n-use super::MirContext;\n-use super::operand::{OperandRef, OperandValue};\n-\n-impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n-    /// Translate reference to item.\n-    pub fn trans_item_ref(&mut self,\n-                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                          ty: Ty<'tcx>,\n-                          kind: ItemKind,\n-                          substs: &'tcx Substs<'tcx>,\n-                          did: DefId)\n-                          -> OperandRef<'tcx> {\n-        debug!(\"trans_item_ref(ty={:?}, kind={:?}, substs={:?}, did={})\",\n-            ty, kind, substs, bcx.tcx().item_path_str(did));\n-\n-        match kind {\n-            ItemKind::Function => self.trans_fn_ref(bcx, ty, substs, did),\n-            ItemKind::Method => match bcx.tcx().impl_or_trait_item(did).container() {\n-                ty::ImplContainer(_) => self.trans_fn_ref(bcx, ty, substs, did),\n-                ty::TraitContainer(tdid) => self.trans_trait_method(bcx, ty, did, tdid, substs)\n-            },\n-            ItemKind::Constant => {\n-                let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n-                let expr = const_eval::lookup_const_by_id(bcx.tcx(), did, None, Some(substs))\n-                            .expect(\"def was const, but lookup_const_by_id failed\");\n-                // FIXME: this is falling back to translating from HIR. This is not easy to fix,\n-                // because we would have somehow adapt const_eval to work on MIR rather than HIR.\n-                let d = bcx.with_block(|bcx| {\n-                    expr::trans(bcx, expr)\n-                });\n-                OperandRef::from_rvalue_datum(d.datum.to_rvalue_datum(d.bcx, \"\").datum)\n-            }\n-        }\n-    }\n-\n-    /// Translates references to a function-like items.\n-    ///\n-    /// That includes regular functions, non-static methods, struct and enum variant constructors,\n-    /// closures and possibly more.\n-    ///\n-    /// This is an adaptation of callee::trans_fn_ref_with_substs.\n-    pub fn trans_fn_ref(&mut self,\n-                        bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                        ty: Ty<'tcx>,\n-                        substs: &'tcx Substs<'tcx>,\n-                        did: DefId)\n-                        -> OperandRef<'tcx> {\n-        debug!(\"trans_fn_ref(ty={:?}, substs={:?}, did={})\",\n-            ty, substs, bcx.tcx().item_path_str(did));\n-\n-        let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n-\n-        if !substs.types.is_empty() || is_named_tuple_constructor(bcx.tcx(), did) {\n-            let (val, fn_ty, _) = monomorphize::monomorphic_fn(bcx.ccx(), did, substs);\n-            // FIXME: cast fnptr to proper type if necessary\n-            OperandRef {\n-                ty: fn_ty,\n-                val: OperandValue::Immediate(val)\n-            }\n-        } else {\n-            let val = if let Some(node_id) = bcx.tcx().map.as_local_node_id(did) {\n-                base::get_item_val(bcx.ccx(), node_id)\n-            } else {\n-                base::trans_external_path(bcx.ccx(), did, ty)\n-            };\n-            // FIXME: cast fnptr to proper type if necessary\n-            OperandRef {\n-                ty: ty,\n-                val: OperandValue::Immediate(val)\n-            }\n-        }\n-    }\n-\n-    /// Translates references to trait methods.\n-    ///\n-    /// This is an adaptation of meth::trans_static_method_callee\n-    pub fn trans_trait_method(&mut self,\n-                              bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                              ty: Ty<'tcx>,\n-                              method_id: DefId,\n-                              trait_id: DefId,\n-                              substs: &'tcx Substs<'tcx>)\n-                              -> OperandRef<'tcx> {\n-        debug!(\"trans_static_method(ty={:?}, method={}, trait={}, substs={:?})\",\n-                ty,\n-                bcx.tcx().item_path_str(method_id),\n-                bcx.tcx().item_path_str(trait_id),\n-                substs);\n-\n-        let ccx = bcx.ccx();\n-        let tcx = bcx.tcx();\n-        let trait_ref = ty::Binder(substs.to_trait_ref(tcx, trait_id));\n-        let vtbl = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n-        match vtbl {\n-            traits::VtableImpl(traits::VtableImplData {\n-                impl_def_id, substs: impl_substs, ..\n-            }) => {\n-                assert!(!impl_substs.types.needs_infer());\n-\n-                let mname = tcx.item_name(method_id);\n-\n-                let callee_substs = impl_substs.with_method_from(substs);\n-                let mth = tcx.get_impl_method(impl_def_id, callee_substs, mname);\n-                let mth_substs = tcx.mk_substs(mth.substs);\n-                self.trans_fn_ref(bcx, ty, mth_substs, mth.method.def_id)\n-            },\n-            traits::VtableClosure(data) => {\n-                let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n-                let llfn = closure::trans_closure_method(bcx.ccx(),\n-                                                         data.closure_def_id,\n-                                                         data.substs,\n-                                                         trait_closure_kind);\n-                OperandRef {\n-                    ty: ty,\n-                    val: OperandValue::Immediate(llfn)\n-                }\n-            },\n-            traits::VtableObject(ref data) => {\n-                let idx = traits::get_vtable_index_of_object_method(tcx, data, method_id);\n-                OperandRef::from_rvalue_datum(\n-                    meth::trans_object_shim(ccx, data.upcast_trait_ref.clone(), method_id, idx)\n-                )\n-            }\n-            _ => {\n-                tcx.sess.bug(&format!(\"static call to invalid vtable: {:?}\", vtbl));\n-            }\n-        }\n-   }\n-}\n-\n-fn is_named_tuple_constructor(tcx: &TyCtxt, def_id: DefId) -> bool {\n-    let node_id = match tcx.map.as_local_node_id(def_id) {\n-        Some(n) => n,\n-        None => { return false; }\n-    };\n-    match tcx.map.find(node_id).expect(\"local item should be in ast map\") {\n-        map::NodeVariant(v) => {\n-            v.node.data.is_tuple()\n-        }\n-        map::NodeStructCtor(_) => true,\n-        _ => false\n-    }\n-}"}, {"sha": "4ad2e035945f3baaac56dbfaf2487732ece9a781", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -196,7 +196,6 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n mod analyze;\n mod block;\n mod constant;\n-mod did;\n mod drop;\n mod lvalue;\n mod operand;"}, {"sha": "ce10ed425f63afe92ff8b15425ee77910d5cc47e", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -15,6 +15,7 @@ use rustc::mir::repr as mir;\n \n use trans::asm;\n use trans::base;\n+use trans::callee::Callee;\n use trans::common::{self, BlockAndBuilder, Result};\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n@@ -193,9 +194,20 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let cast_ty = bcx.monomorphize(&cast_ty);\n \n                 let val = match *kind {\n-                    mir::CastKind::ReifyFnPointer |\n+                    mir::CastKind::ReifyFnPointer => {\n+                        match operand.ty.sty {\n+                            ty::TyFnDef(def_id, substs, _) => {\n+                                OperandValue::Immediate(\n+                                    Callee::def(bcx.ccx(), def_id, substs, operand.ty)\n+                                        .reify(bcx.ccx()).val)\n+                            }\n+                            _ => {\n+                                unreachable!(\"{} cannot be reified to a fn ptr\", operand.ty)\n+                            }\n+                        }\n+                    }\n                     mir::CastKind::UnsafeFnPointer => {\n-                        // these are no-ops at the LLVM level\n+                        // this is a no-op at the LLVM level\n                         operand.val\n                     }\n                     mir::CastKind::Unsize => {"}, {"sha": "b78bf9bfc3fb27f15552eb161f1c98e348acb7aa", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f07f8a4fad3e59358356100c5cbd9a39e6d68bd/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=8f07f8a4fad3e59358356100c5cbd9a39e6d68bd", "patch": "@@ -190,7 +190,8 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             }\n         }\n \n-        ty::TyFnDef(..) | ty::TyFnPtr(_) => Type::i8p(cx),\n+        ty::TyFnDef(..) => Type::nil(cx),\n+        ty::TyFnPtr(_) => Type::i8p(cx),\n \n         ty::TyArray(ty, size) => {\n             let llty = sizing_type_of(cx, ty);\n@@ -395,9 +396,8 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TySlice(ty) => in_memory_type_of(cx, ty),\n       ty::TyStr | ty::TyTrait(..) => Type::i8(cx),\n \n-      ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n-        // FIXME(#19925) once fn item types are\n-        // zero-sized, we'll need to do something here\n+      ty::TyFnDef(..) => Type::nil(cx),\n+      ty::TyFnPtr(f) => {\n         if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n             let sig = cx.tcx().erase_late_bound_regions(&f.sig);\n             let sig = infer::normalize_associated_type(cx.tcx(), &sig);"}]}