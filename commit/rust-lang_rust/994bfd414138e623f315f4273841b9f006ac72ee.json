{"sha": "994bfd414138e623f315f4273841b9f006ac72ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NGJmZDQxNDEzOGU2MjNmMzE1ZjQyNzM4NDFiOWYwMDZhYzcyZWU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-02-26T17:07:16Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-03-11T17:59:28Z"}, "message": "Update Cargo submodule\n\nRequired moving all fulldeps tests depending on `rand` to different locations as\nnow there's multiple `rand` crates that can't be implicitly linked against.", "tree": {"sha": "55d54030a429044706fae052c2d72e857d8320f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55d54030a429044706fae052c2d72e857d8320f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/994bfd414138e623f315f4273841b9f006ac72ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/994bfd414138e623f315f4273841b9f006ac72ee", "html_url": "https://github.com/rust-lang/rust/commit/994bfd414138e623f315f4273841b9f006ac72ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/994bfd414138e623f315f4273841b9f006ac72ee/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fedce67cd21dc08ece5a484fe1a060346acac98a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fedce67cd21dc08ece5a484fe1a060346acac98a", "html_url": "https://github.com/rust-lang/rust/commit/fedce67cd21dc08ece5a484fe1a060346acac98a"}], "stats": {"total": 1418, "additions": 675, "deletions": 743}, "files": [{"sha": "3252fda970b05c76785163fd4c298a4c52019552", "filename": "src/Cargo.lock", "status": "modified", "additions": 341, "deletions": 361, "changes": 702, "blob_url": "https://github.com/rust-lang/rust/blob/994bfd414138e623f315f4273841b9f006ac72ee/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/994bfd414138e623f315f4273841b9f006ac72ee/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=994bfd414138e623f315f4273841b9f006ac72ee"}, {"sha": "586216b9a5886157b3ceafa670a060bb8ce19170", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/994bfd414138e623f315f4273841b9f006ac72ee/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994bfd414138e623f315f4273841b9f006ac72ee/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=994bfd414138e623f315f4273841b9f006ac72ee", "patch": "@@ -775,7 +775,9 @@ impl<'a> Builder<'a> {\n         // be resolved because MinGW has the import library. The downside is we\n         // don't get newer functions from Windows, but we don't use any of them\n         // anyway.\n-        cargo.env(\"WINAPI_NO_BUNDLED_LIBRARIES\", \"1\");\n+        if mode != Mode::Tool {\n+            cargo.env(\"WINAPI_NO_BUNDLED_LIBRARIES\", \"1\");\n+        }\n \n         if self.is_very_verbose() {\n             cargo.arg(\"-v\");"}, {"sha": "3bf919b0c0016e3c689b87146e5a0ba30c940f22", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/994bfd414138e623f315f4273841b9f006ac72ee/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/994bfd414138e623f315f4273841b9f006ac72ee/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=994bfd414138e623f315f4273841b9f006ac72ee", "patch": "@@ -12,7 +12,7 @@ core = { path = \"../libcore\" }\n std_unicode = { path = \"../libstd_unicode\" }\n \n [dev-dependencies]\n-rand = \"0.3\"\n+rand = \"0.4\"\n \n [[test]]\n name = \"collectionstests\""}, {"sha": "5c979d82e55dc701cfbcf2f8ca0211349ea4b6c5", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/994bfd414138e623f315f4273841b9f006ac72ee/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994bfd414138e623f315f4273841b9f006ac72ee/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=994bfd414138e623f315f4273841b9f006ac72ee", "patch": "@@ -8,9 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::panic;\n+use std::cmp;\n use std::collections::BinaryHeap;\n use std::collections::binary_heap::{Drain, PeekMut};\n+use std::panic::{self, AssertUnwindSafe};\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+\n+use rand::{thread_rng, Rng};\n \n #[test]\n fn test_iterator() {\n@@ -300,3 +304,80 @@ fn assert_covariance() {\n         d\n     }\n }\n+\n+// old binaryheap failed this test\n+//\n+// Integrity means that all elements are present after a comparison panics,\n+// even if the order may not be correct.\n+//\n+// Destructors must be called exactly once per element.\n+#[test]\n+fn panic_safe() {\n+    static DROP_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+    #[derive(Eq, PartialEq, Ord, Clone, Debug)]\n+    struct PanicOrd<T>(T, bool);\n+\n+    impl<T> Drop for PanicOrd<T> {\n+        fn drop(&mut self) {\n+            // update global drop count\n+            DROP_COUNTER.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    impl<T: PartialOrd> PartialOrd for PanicOrd<T> {\n+        fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n+            if self.1 || other.1 {\n+                panic!(\"Panicking comparison\");\n+            }\n+            self.0.partial_cmp(&other.0)\n+        }\n+    }\n+    let mut rng = thread_rng();\n+    const DATASZ: usize = 32;\n+    const NTEST: usize = 10;\n+\n+    // don't use 0 in the data -- we want to catch the zeroed-out case.\n+    let data = (1..DATASZ + 1).collect::<Vec<_>>();\n+\n+    // since it's a fuzzy test, run several tries.\n+    for _ in 0..NTEST {\n+        for i in 1..DATASZ + 1 {\n+            DROP_COUNTER.store(0, Ordering::SeqCst);\n+\n+            let mut panic_ords: Vec<_> = data.iter()\n+                                             .filter(|&&x| x != i)\n+                                             .map(|&x| PanicOrd(x, false))\n+                                             .collect();\n+            let panic_item = PanicOrd(i, true);\n+\n+            // heapify the sane items\n+            rng.shuffle(&mut panic_ords);\n+            let mut heap = BinaryHeap::from(panic_ords);\n+            let inner_data;\n+\n+            {\n+                // push the panicking item to the heap and catch the panic\n+                let thread_result = {\n+                    let mut heap_ref = AssertUnwindSafe(&mut heap);\n+                    panic::catch_unwind(move || {\n+                        heap_ref.push(panic_item);\n+                    })\n+                };\n+                assert!(thread_result.is_err());\n+\n+                // Assert no elements were dropped\n+                let drops = DROP_COUNTER.load(Ordering::SeqCst);\n+                assert!(drops == 0, \"Must not drop items. drops={}\", drops);\n+                inner_data = heap.clone().into_vec();\n+                drop(heap);\n+            }\n+            let drops = DROP_COUNTER.load(Ordering::SeqCst);\n+            assert_eq!(drops, DATASZ);\n+\n+            let mut data_sorted = inner_data.into_iter().map(|p| p.0).collect::<Vec<_>>();\n+            data_sorted.sort();\n+            assert_eq!(data_sorted, data);\n+        }\n+    }\n+}"}, {"sha": "d9e9d91cea88a06d5a39d74363610a3991945477", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/994bfd414138e623f315f4273841b9f006ac72ee/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994bfd414138e623f315f4273841b9f006ac72ee/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=994bfd414138e623f315f4273841b9f006ac72ee", "patch": "@@ -8,9 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::cell::Cell;\n use std::cmp::Ordering::{Equal, Greater, Less};\n+use std::cmp::Ordering;\n use std::mem;\n+use std::panic;\n use std::rc::Rc;\n+use std::sync::atomic::Ordering::Relaxed;\n+use std::sync::atomic::{ATOMIC_USIZE_INIT, AtomicUsize};\n+use std::thread;\n \n use rand::{Rng, thread_rng};\n \n@@ -1341,3 +1347,162 @@ fn test_copy_from_slice_dst_shorter() {\n     let mut dst = [0; 3];\n     dst.copy_from_slice(&src);\n }\n+\n+const MAX_LEN: usize = 80;\n+\n+static DROP_COUNTS: [AtomicUsize; MAX_LEN] = [\n+    // FIXME #5244: AtomicUsize is not Copy.\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+];\n+\n+static VERSIONS: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+#[derive(Clone, Eq)]\n+struct DropCounter {\n+    x: u32,\n+    id: usize,\n+    version: Cell<usize>,\n+}\n+\n+impl PartialEq for DropCounter {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.partial_cmp(other) == Some(Ordering::Equal)\n+    }\n+}\n+\n+impl PartialOrd for DropCounter {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.version.set(self.version.get() + 1);\n+        other.version.set(other.version.get() + 1);\n+        VERSIONS.fetch_add(2, Relaxed);\n+        self.x.partial_cmp(&other.x)\n+    }\n+}\n+\n+impl Ord for DropCounter {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.partial_cmp(other).unwrap()\n+    }\n+}\n+\n+impl Drop for DropCounter {\n+    fn drop(&mut self) {\n+        DROP_COUNTS[self.id].fetch_add(1, Relaxed);\n+        VERSIONS.fetch_sub(self.version.get(), Relaxed);\n+    }\n+}\n+\n+macro_rules! test {\n+    ($input:ident, $func:ident) => {\n+        let len = $input.len();\n+\n+        // Work out the total number of comparisons required to sort\n+        // this array...\n+        let mut count = 0usize;\n+        $input.to_owned().$func(|a, b| { count += 1; a.cmp(b) });\n+\n+        // ... and then panic on each and every single one.\n+        for panic_countdown in 0..count {\n+            // Refresh the counters.\n+            VERSIONS.store(0, Relaxed);\n+            for i in 0..len {\n+                DROP_COUNTS[i].store(0, Relaxed);\n+            }\n+\n+            let v = $input.to_owned();\n+            let _ = thread::spawn(move || {\n+                let mut v = v;\n+                let mut panic_countdown = panic_countdown;\n+                v.$func(|a, b| {\n+                    if panic_countdown == 0 {\n+                        SILENCE_PANIC.with(|s| s.set(true));\n+                        panic!();\n+                    }\n+                    panic_countdown -= 1;\n+                    a.cmp(b)\n+                })\n+            }).join();\n+\n+            // Check that the number of things dropped is exactly\n+            // what we expect (i.e. the contents of `v`).\n+            for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n+                let count = c.load(Relaxed);\n+                assert!(count == 1,\n+                        \"found drop count == {} for i == {}, len == {}\",\n+                        count, i, len);\n+            }\n+\n+            // Check that the most recent versions of values were dropped.\n+            assert_eq!(VERSIONS.load(Relaxed), 0);\n+        }\n+    }\n+}\n+\n+thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n+fn panic_safe() {\n+    let prev = panic::take_hook();\n+    panic::set_hook(Box::new(move |info| {\n+        if !SILENCE_PANIC.with(|s| s.get()) {\n+            prev(info);\n+        }\n+    }));\n+\n+    let mut rng = thread_rng();\n+\n+    for len in (1..20).chain(70..MAX_LEN) {\n+        for &modulus in &[5, 20, 50] {\n+            for &has_runs in &[false, true] {\n+                let mut input = (0..len)\n+                    .map(|id| {\n+                        DropCounter {\n+                            x: rng.next_u32() % modulus,\n+                            id: id,\n+                            version: Cell::new(0),\n+                        }\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                if has_runs {\n+                    for c in &mut input {\n+                        c.x = c.id as u32;\n+                    }\n+\n+                    for _ in 0..5 {\n+                        let a = rng.gen::<usize>() % len;\n+                        let b = rng.gen::<usize>() % len;\n+                        if a < b {\n+                            input[a..b].reverse();\n+                        } else {\n+                            input.swap(a, b);\n+                        }\n+                    }\n+                }\n+\n+                test!(input, sort_by);\n+                test!(input, sort_unstable_by);\n+            }\n+        }\n+    }\n+}"}, {"sha": "24529f7a9d8d42161d2a943ad95878e9f4569e98", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/994bfd414138e623f315f4273841b9f006ac72ee/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/994bfd414138e623f315f4273841b9f006ac72ee/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=994bfd414138e623f315f4273841b9f006ac72ee", "patch": "@@ -16,3 +16,6 @@ path = \"../libcore/tests/lib.rs\"\n [[bench]]\n name = \"corebenches\"\n path = \"../libcore/benches/lib.rs\"\n+\n+[dev-dependencies]\n+rand = \"0.4\""}, {"sha": "d08d6b3215d8b9932ec12f3ad92bcf6f9e9a6f4d", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/994bfd414138e623f315f4273841b9f006ac72ee/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994bfd414138e623f315f4273841b9f006ac72ee/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=994bfd414138e623f315f4273841b9f006ac72ee", "patch": "@@ -50,6 +50,7 @@\n \n extern crate core;\n extern crate test;\n+extern crate rand;\n \n mod any;\n mod array;"}, {"sha": "04567e25e25ba243a3b1fc3c766f848fa56e20c8", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/994bfd414138e623f315f4273841b9f006ac72ee/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994bfd414138e623f315f4273841b9f006ac72ee/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=994bfd414138e623f315f4273841b9f006ac72ee", "patch": "@@ -23,6 +23,7 @@ mod strategy {\n     mod dragon;\n     mod grisu;\n }\n+mod random;\n \n pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n     match decode(v).1 {"}, {"sha": "315ac4d7d99f53650a3a61c07307078bef959df9", "filename": "src/libcore/tests/num/flt2dec/random.rs", "status": "renamed", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/994bfd414138e623f315f4273841b9f006ac72ee/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994bfd414138e623f315f4273841b9f006ac72ee/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=994bfd414138e623f315f4273841b9f006ac72ee", "patch": "@@ -8,12 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:--test\n-\n-#![feature(rustc_private, flt2dec)]\n-\n-extern crate core;\n-extern crate rand;\n+#![cfg(not(target_arch = \"wasm32\"))]\n \n use std::i16;\n use std::mem;\n@@ -24,8 +19,9 @@ use core::num::flt2dec::strategy::grisu::format_exact_opt;\n use core::num::flt2dec::strategy::grisu::format_shortest_opt;\n use core::num::flt2dec::{decode, DecodableFloat, FullDecoded, Decoded};\n \n-use rand::{Rand, XorShiftRng};\n+use rand::{self, Rand, XorShiftRng};\n use rand::distributions::{IndependentSample, Range};\n+\n pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n     match decode(v).1 {\n         FullDecoded::Finite(decoded) => decoded,\n@@ -161,3 +157,4 @@ fn exact_f64_random_equivalence_test() {\n                                              |d, buf| fallback(d, buf, i16::MIN), k, 1_000);\n     }\n }\n+", "previous_filename": "src/test/run-pass-fulldeps/flt2dec.rs"}, {"sha": "53fdfa0682742454284a2ea9bdea79970d335a6c", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/994bfd414138e623f315f4273841b9f006ac72ee/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994bfd414138e623f315f4273841b9f006ac72ee/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=994bfd414138e623f315f4273841b9f006ac72ee", "patch": "@@ -10,7 +10,6 @@\n \n use core::result::Result::{Ok, Err};\n \n-\n #[test]\n fn test_position() {\n     let b = [1, 2, 3, 5, 5];\n@@ -481,3 +480,73 @@ fn test_rotate_right() {\n         assert_eq!(a[(i + 42) % N], i);\n     }\n }\n+\n+#[test]\n+#[cfg(not(target_arch = \"wasm32\"))]\n+fn sort_unstable() {\n+    use core::cmp::Ordering::{Equal, Greater, Less};\n+    use core::slice::heapsort;\n+    use rand::{Rng, XorShiftRng};\n+\n+    let mut v = [0; 600];\n+    let mut tmp = [0; 600];\n+    let mut rng = XorShiftRng::new_unseeded();\n+\n+    for len in (2..25).chain(500..510) {\n+        let v = &mut v[0..len];\n+        let tmp = &mut tmp[0..len];\n+\n+        for &modulus in &[5, 10, 100, 1000] {\n+            for _ in 0..100 {\n+                for i in 0..len {\n+                    v[i] = rng.gen::<i32>() % modulus;\n+                }\n+\n+                // Sort in default order.\n+                tmp.copy_from_slice(v);\n+                tmp.sort_unstable();\n+                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in ascending order.\n+                tmp.copy_from_slice(v);\n+                tmp.sort_unstable_by(|a, b| a.cmp(b));\n+                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in descending order.\n+                tmp.copy_from_slice(v);\n+                tmp.sort_unstable_by(|a, b| b.cmp(a));\n+                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n+\n+                // Test heapsort using `<` operator.\n+                tmp.copy_from_slice(v);\n+                heapsort(tmp, |a, b| a < b);\n+                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Test heapsort using `>` operator.\n+                tmp.copy_from_slice(v);\n+                heapsort(tmp, |a, b| a > b);\n+                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n+            }\n+        }\n+    }\n+\n+    // Sort using a completely random comparison function.\n+    // This will reorder the elements *somehow*, but won't panic.\n+    for i in 0..v.len() {\n+        v[i] = i as i32;\n+    }\n+    v.sort_unstable_by(|_, _| *rng.choose(&[Less, Equal, Greater]).unwrap());\n+    v.sort_unstable();\n+    for i in 0..v.len() {\n+        assert_eq!(v[i], i as i32);\n+    }\n+\n+    // Should not panic.\n+    [0i32; 0].sort_unstable();\n+    [(); 10].sort_unstable();\n+    [(); 100].sort_unstable();\n+\n+    let mut v = [0xDEADBEEFu64];\n+    v.sort_unstable();\n+    assert!(v == [0xDEADBEEF]);\n+}"}, {"sha": "120175988533b5645ef18716bb01a97485feebea", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/994bfd414138e623f315f4273841b9f006ac72ee/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/994bfd414138e623f315f4273841b9f006ac72ee/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=994bfd414138e623f315f4273841b9f006ac72ee", "patch": "@@ -26,7 +26,7 @@ std_unicode = { path = \"../libstd_unicode\" }\n unwind = { path = \"../libunwind\" }\n \n [dev-dependencies]\n-rand = \"0.3\"\n+rand = \"0.4\"\n \n [target.x86_64-apple-darwin.dependencies]\n rustc_asan = { path = \"../librustc_asan\" }"}, {"sha": "d4376523691a10cdf23e5887fdf065f7dd41afa4", "filename": "src/libstd/tests/env.rs", "status": "renamed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/994bfd414138e623f315f4273841b9f006ac72ee/src%2Flibstd%2Ftests%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994bfd414138e623f315f4273841b9f006ac72ee/src%2Flibstd%2Ftests%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftests%2Fenv.rs?ref=994bfd414138e623f315f4273841b9f006ac72ee", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: --test\n-\n-#![feature(rustc_private, std_panic)]\n-\n extern crate rand;\n \n use std::env::*;", "previous_filename": "src/test/run-pass-fulldeps/env.rs"}, {"sha": "6139a7d3201c5193d46e5381b6525b47349846d0", "filename": "src/test/run-pass-fulldeps/binary-heap-panic-safe.rs", "status": "removed", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/fedce67cd21dc08ece5a484fe1a060346acac98a/src%2Ftest%2Frun-pass-fulldeps%2Fbinary-heap-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fedce67cd21dc08ece5a484fe1a060346acac98a/src%2Ftest%2Frun-pass-fulldeps%2Fbinary-heap-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fbinary-heap-panic-safe.rs?ref=fedce67cd21dc08ece5a484fe1a060346acac98a", "patch": "@@ -1,101 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(rustc_private, std_panic)]\n-\n-extern crate rand;\n-\n-use rand::{thread_rng, Rng};\n-use std::panic::{self, AssertUnwindSafe};\n-\n-use std::collections::BinaryHeap;\n-use std::cmp;\n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n-\n-static DROP_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n-\n-// old binaryheap failed this test\n-//\n-// Integrity means that all elements are present after a comparison panics,\n-// even if the order may not be correct.\n-//\n-// Destructors must be called exactly once per element.\n-fn test_integrity() {\n-    #[derive(Eq, PartialEq, Ord, Clone, Debug)]\n-    struct PanicOrd<T>(T, bool);\n-\n-    impl<T> Drop for PanicOrd<T> {\n-        fn drop(&mut self) {\n-            // update global drop count\n-            DROP_COUNTER.fetch_add(1, Ordering::SeqCst);\n-        }\n-    }\n-\n-    impl<T: PartialOrd> PartialOrd for PanicOrd<T> {\n-        fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n-            if self.1 || other.1 {\n-                panic!(\"Panicking comparison\");\n-            }\n-            self.0.partial_cmp(&other.0)\n-        }\n-    }\n-    let mut rng = thread_rng();\n-    const DATASZ: usize = 32;\n-    const NTEST: usize = 10;\n-\n-    // don't use 0 in the data -- we want to catch the zeroed-out case.\n-    let data = (1..DATASZ + 1).collect::<Vec<_>>();\n-\n-    // since it's a fuzzy test, run several tries.\n-    for _ in 0..NTEST {\n-        for i in 1..DATASZ + 1 {\n-            DROP_COUNTER.store(0, Ordering::SeqCst);\n-\n-            let mut panic_ords: Vec<_> = data.iter()\n-                                             .filter(|&&x| x != i)\n-                                             .map(|&x| PanicOrd(x, false))\n-                                             .collect();\n-            let panic_item = PanicOrd(i, true);\n-\n-            // heapify the sane items\n-            rng.shuffle(&mut panic_ords);\n-            let mut heap = BinaryHeap::from(panic_ords);\n-            let inner_data;\n-\n-            {\n-                // push the panicking item to the heap and catch the panic\n-                let thread_result = {\n-                    let mut heap_ref = AssertUnwindSafe(&mut heap);\n-                    panic::catch_unwind(move || {\n-                        heap_ref.push(panic_item);\n-                    })\n-                };\n-                assert!(thread_result.is_err());\n-\n-                // Assert no elements were dropped\n-                let drops = DROP_COUNTER.load(Ordering::SeqCst);\n-                assert!(drops == 0, \"Must not drop items. drops={}\", drops);\n-                inner_data = heap.clone().into_vec();\n-                drop(heap);\n-            }\n-            let drops = DROP_COUNTER.load(Ordering::SeqCst);\n-            assert_eq!(drops, DATASZ);\n-\n-            let mut data_sorted = inner_data.into_iter().map(|p| p.0).collect::<Vec<_>>();\n-            data_sorted.sort();\n-            assert_eq!(data_sorted, data);\n-        }\n-    }\n-}\n-\n-fn main() {\n-    test_integrity();\n-}\n-"}, {"sha": "af8a691aa3ec6468ad254a25cea1c1301759451e", "filename": "src/test/run-pass-fulldeps/sort-unstable.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/fedce67cd21dc08ece5a484fe1a060346acac98a/src%2Ftest%2Frun-pass-fulldeps%2Fsort-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fedce67cd21dc08ece5a484fe1a060346acac98a/src%2Ftest%2Frun-pass-fulldeps%2Fsort-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fsort-unstable.rs?ref=fedce67cd21dc08ece5a484fe1a060346acac98a", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(rustc_private, sort_internals)]\n-\n-extern crate core;\n-extern crate rand;\n-\n-use std::cmp::Ordering::{Equal, Greater, Less};\n-use core::slice::heapsort;\n-\n-use rand::{Rng, XorShiftRng};\n-\n-fn main() {\n-    let mut v = [0; 600];\n-    let mut tmp = [0; 600];\n-    let mut rng = XorShiftRng::new_unseeded();\n-\n-    for len in (2..25).chain(500..510) {\n-        let v = &mut v[0..len];\n-        let tmp = &mut tmp[0..len];\n-\n-        for &modulus in &[5, 10, 100, 1000] {\n-            for _ in 0..100 {\n-                for i in 0..len {\n-                    v[i] = rng.gen::<i32>() % modulus;\n-                }\n-\n-                // Sort in default order.\n-                tmp.copy_from_slice(v);\n-                tmp.sort_unstable();\n-                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n-\n-                // Sort in ascending order.\n-                tmp.copy_from_slice(v);\n-                tmp.sort_unstable_by(|a, b| a.cmp(b));\n-                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n-\n-                // Sort in descending order.\n-                tmp.copy_from_slice(v);\n-                tmp.sort_unstable_by(|a, b| b.cmp(a));\n-                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n-\n-                // Test heapsort using `<` operator.\n-                tmp.copy_from_slice(v);\n-                heapsort(tmp, |a, b| a < b);\n-                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n-\n-                // Test heapsort using `>` operator.\n-                tmp.copy_from_slice(v);\n-                heapsort(tmp, |a, b| a > b);\n-                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n-            }\n-        }\n-    }\n-\n-    // Sort using a completely random comparison function.\n-    // This will reorder the elements *somehow*, but won't panic.\n-    for i in 0..v.len() {\n-        v[i] = i as i32;\n-    }\n-    v.sort_unstable_by(|_, _| *rng.choose(&[Less, Equal, Greater]).unwrap());\n-    v.sort_unstable();\n-    for i in 0..v.len() {\n-        assert_eq!(v[i], i as i32);\n-    }\n-\n-    // Should not panic.\n-    [0i32; 0].sort_unstable();\n-    [(); 10].sort_unstable();\n-    [(); 100].sort_unstable();\n-\n-    let mut v = [0xDEADBEEFu64];\n-    v.sort_unstable();\n-    assert!(v == [0xDEADBEEF]);\n-}"}, {"sha": "adc72aa0ea23b5fed2f1ed33535e5269165ca50d", "filename": "src/test/run-pass-fulldeps/vector-sort-panic-safe.rs", "status": "removed", "additions": 0, "deletions": 181, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/fedce67cd21dc08ece5a484fe1a060346acac98a/src%2Ftest%2Frun-pass-fulldeps%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fedce67cd21dc08ece5a484fe1a060346acac98a/src%2Ftest%2Frun-pass-fulldeps%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fvector-sort-panic-safe.rs?ref=fedce67cd21dc08ece5a484fe1a060346acac98a", "patch": "@@ -1,181 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-emscripten no threads support\n-\n-#![feature(rustc_private)]\n-#![feature(sort_unstable)]\n-\n-extern crate rand;\n-\n-use rand::{thread_rng, Rng};\n-use std::cell::Cell;\n-use std::cmp::Ordering;\n-use std::panic;\n-use std::sync::atomic::{ATOMIC_USIZE_INIT, AtomicUsize};\n-use std::sync::atomic::Ordering::Relaxed;\n-use std::thread;\n-\n-const MAX_LEN: usize = 80;\n-\n-static DROP_COUNTS: [AtomicUsize; MAX_LEN] = [\n-    // FIXME #5244: AtomicUsize is not Copy.\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n-];\n-\n-static VERSIONS: AtomicUsize = ATOMIC_USIZE_INIT;\n-\n-#[derive(Clone, Eq)]\n-struct DropCounter {\n-    x: u32,\n-    id: usize,\n-    version: Cell<usize>,\n-}\n-\n-impl PartialEq for DropCounter {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.partial_cmp(other) == Some(Ordering::Equal)\n-    }\n-}\n-\n-impl PartialOrd for DropCounter {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        self.version.set(self.version.get() + 1);\n-        other.version.set(other.version.get() + 1);\n-        VERSIONS.fetch_add(2, Relaxed);\n-        self.x.partial_cmp(&other.x)\n-    }\n-}\n-\n-impl Ord for DropCounter {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.partial_cmp(other).unwrap()\n-    }\n-}\n-\n-impl Drop for DropCounter {\n-    fn drop(&mut self) {\n-        DROP_COUNTS[self.id].fetch_add(1, Relaxed);\n-        VERSIONS.fetch_sub(self.version.get(), Relaxed);\n-    }\n-}\n-\n-macro_rules! test {\n-    ($input:ident, $func:ident) => {\n-        let len = $input.len();\n-\n-        // Work out the total number of comparisons required to sort\n-        // this array...\n-        let mut count = 0usize;\n-        $input.to_owned().$func(|a, b| { count += 1; a.cmp(b) });\n-\n-        // ... and then panic on each and every single one.\n-        for panic_countdown in 0..count {\n-            // Refresh the counters.\n-            VERSIONS.store(0, Relaxed);\n-            for i in 0..len {\n-                DROP_COUNTS[i].store(0, Relaxed);\n-            }\n-\n-            let v = $input.to_owned();\n-            let _ = thread::spawn(move || {\n-                let mut v = v;\n-                let mut panic_countdown = panic_countdown;\n-                v.$func(|a, b| {\n-                    if panic_countdown == 0 {\n-                        SILENCE_PANIC.with(|s| s.set(true));\n-                        panic!();\n-                    }\n-                    panic_countdown -= 1;\n-                    a.cmp(b)\n-                })\n-            }).join();\n-\n-            // Check that the number of things dropped is exactly\n-            // what we expect (i.e. the contents of `v`).\n-            for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n-                let count = c.load(Relaxed);\n-                assert!(count == 1,\n-                        \"found drop count == {} for i == {}, len == {}\",\n-                        count, i, len);\n-            }\n-\n-            // Check that the most recent versions of values were dropped.\n-            assert_eq!(VERSIONS.load(Relaxed), 0);\n-        }\n-    }\n-}\n-\n-thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n-\n-fn main() {\n-    let prev = panic::take_hook();\n-    panic::set_hook(Box::new(move |info| {\n-        if !SILENCE_PANIC.with(|s| s.get()) {\n-            prev(info);\n-        }\n-    }));\n-\n-    let mut rng = thread_rng();\n-\n-    for len in (1..20).chain(70..MAX_LEN) {\n-        for &modulus in &[5, 20, 50] {\n-            for &has_runs in &[false, true] {\n-                let mut input = (0..len)\n-                    .map(|id| {\n-                        DropCounter {\n-                            x: rng.next_u32() % modulus,\n-                            id: id,\n-                            version: Cell::new(0),\n-                        }\n-                    })\n-                    .collect::<Vec<_>>();\n-\n-                if has_runs {\n-                    for c in &mut input {\n-                        c.x = c.id as u32;\n-                    }\n-\n-                    for _ in 0..5 {\n-                        let a = rng.gen::<usize>() % len;\n-                        let b = rng.gen::<usize>() % len;\n-                        if a < b {\n-                            input[a..b].reverse();\n-                        } else {\n-                            input.swap(a, b);\n-                        }\n-                    }\n-                }\n-\n-                test!(input, sort_by);\n-                test!(input, sort_unstable_by);\n-            }\n-        }\n-    }\n-}"}, {"sha": "5f83bb4044f32b60d06717c609610f67411fc671", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=994bfd414138e623f315f4273841b9f006ac72ee", "patch": "@@ -1 +1 @@\n-Subproject commit 1d6dfea44f97199d5d5c177c7dadcde393eaff9a\n+Subproject commit 5f83bb4044f32b60d06717c609610f67411fc671"}, {"sha": "22c6af28ceae52d90f32fb2e8bcb25ed363c9dff", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/994bfd414138e623f315f4273841b9f006ac72ee/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994bfd414138e623f315f4273841b9f006ac72ee/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=994bfd414138e623f315f4273841b9f006ac72ee", "patch": "@@ -91,6 +91,7 @@ static WHITELIST: &'static [Crate] = &[\n     Crate(\"redox_termios\"),\n     Crate(\"regex\"),\n     Crate(\"regex-syntax\"),\n+    Crate(\"remove_dir_all\"),\n     Crate(\"rustc-demangle\"),\n     Crate(\"smallvec\"),\n     Crate(\"stable_deref_trait\"),\n@@ -99,6 +100,7 @@ static WHITELIST: &'static [Crate] = &[\n     Crate(\"terminon\"),\n     Crate(\"termion\"),\n     Crate(\"thread_local\"),\n+    Crate(\"ucd-util\"),\n     Crate(\"unicode-width\"),\n     Crate(\"unreachable\"),\n     Crate(\"utf8-ranges\"),"}]}