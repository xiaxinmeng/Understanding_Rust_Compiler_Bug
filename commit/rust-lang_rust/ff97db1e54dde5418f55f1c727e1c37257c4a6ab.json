{"sha": "ff97db1e54dde5418f55f1c727e1c37257c4a6ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmOTdkYjFlNTRkZGU1NDE4ZjU1ZjFjNzI3ZTFjMzcyNTdjNGE2YWI=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-03-19T07:41:43Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-05-18T13:41:32Z"}, "message": "Apply review feedback", "tree": {"sha": "5680cda70cd21c2d6b1f17bbf80a261e618fe67a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5680cda70cd21c2d6b1f17bbf80a261e618fe67a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff97db1e54dde5418f55f1c727e1c37257c4a6ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff97db1e54dde5418f55f1c727e1c37257c4a6ab", "html_url": "https://github.com/rust-lang/rust/commit/ff97db1e54dde5418f55f1c727e1c37257c4a6ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ab0f2d3c5a85563b98c4896116e3d53154fff9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ab0f2d3c5a85563b98c4896116e3d53154fff9c", "html_url": "https://github.com/rust-lang/rust/commit/8ab0f2d3c5a85563b98c4896116e3d53154fff9c"}], "stats": {"total": 324, "additions": 185, "deletions": 139}, "files": [{"sha": "c9a3401cac0ad87f380fbd3f216485c48f8053a7", "filename": "src/librustc_builtin_macros/asm.rs", "status": "modified", "additions": 66, "deletions": 59, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Flibrustc_builtin_macros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Flibrustc_builtin_macros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fasm.rs?ref=ff97db1e54dde5418f55f1c727e1c37257c4a6ab", "patch": "@@ -80,47 +80,14 @@ fn parse_args<'a>(\n             break;\n         } // accept trailing commas\n \n-        let span_start = p.token.span;\n-\n         // Parse options\n         if p.eat(&token::Ident(sym::options, false)) {\n-            p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n-\n-            while !p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n-                if p.eat(&token::Ident(sym::pure, false)) {\n-                    args.options |= InlineAsmOptions::PURE;\n-                } else if p.eat(&token::Ident(sym::nomem, false)) {\n-                    args.options |= InlineAsmOptions::NOMEM;\n-                } else if p.eat(&token::Ident(sym::readonly, false)) {\n-                    args.options |= InlineAsmOptions::READONLY;\n-                } else if p.eat(&token::Ident(sym::preserves_flags, false)) {\n-                    args.options |= InlineAsmOptions::PRESERVES_FLAGS;\n-                } else if p.eat(&token::Ident(sym::noreturn, false)) {\n-                    args.options |= InlineAsmOptions::NORETURN;\n-                } else {\n-                    p.expect(&token::Ident(sym::nostack, false))?;\n-                    args.options |= InlineAsmOptions::NOSTACK;\n-                }\n-\n-                // Allow trailing commas\n-                if p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n-                    break;\n-                }\n-                p.expect(&token::Comma)?;\n-            }\n-\n-            let new_span = span_start.to(p.prev_token.span);\n-            if let Some(options_span) = args.options_span {\n-                ecx.struct_span_err(new_span, \"asm options cannot be specified twice\")\n-                    .span_label(options_span, \"previously here\")\n-                    .span_label(new_span, \"duplicate options\")\n-                    .emit();\n-            } else {\n-                args.options_span = Some(new_span);\n-            }\n+            parse_options(&mut p, &mut args)?;\n             continue;\n         }\n \n+        let span_start = p.token.span;\n+\n         // Parse operand names\n         let name = if p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq) {\n             let (ident, _) = p.token.ident().unwrap();\n@@ -131,29 +98,6 @@ fn parse_args<'a>(\n             None\n         };\n \n-        fn parse_reg<'a>(\n-            p: &mut Parser<'a>,\n-            explicit_reg: &mut bool,\n-        ) -> Result<ast::InlineAsmRegOrRegClass, DiagnosticBuilder<'a>> {\n-            p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n-            let result = match p.token.kind {\n-                token::Ident(name, false) => ast::InlineAsmRegOrRegClass::RegClass(name),\n-                token::Literal(token::Lit { kind: token::LitKind::Str, symbol, suffix: _ }) => {\n-                    *explicit_reg = true;\n-                    ast::InlineAsmRegOrRegClass::Reg(symbol)\n-                }\n-                _ => {\n-                    return Err(p.struct_span_err(\n-                        p.token.span,\n-                        \"expected register class or explicit register\",\n-                    ));\n-                }\n-            };\n-            p.bump();\n-            p.expect(&token::CloseDelim(token::DelimToken::Paren))?;\n-            Ok(result)\n-        };\n-\n         let mut explicit_reg = false;\n         let op = if p.eat(&token::Ident(kw::In, false)) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n@@ -319,6 +263,69 @@ fn parse_args<'a>(\n     Ok(args)\n }\n \n+fn parse_options<'a>(p: &mut Parser<'a>, args: &mut AsmArgs) -> Result<(), DiagnosticBuilder<'a>> {\n+    let span_start = p.prev_token.span;\n+\n+    p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n+\n+    while !p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n+        if p.eat(&token::Ident(sym::pure, false)) {\n+            args.options |= InlineAsmOptions::PURE;\n+        } else if p.eat(&token::Ident(sym::nomem, false)) {\n+            args.options |= InlineAsmOptions::NOMEM;\n+        } else if p.eat(&token::Ident(sym::readonly, false)) {\n+            args.options |= InlineAsmOptions::READONLY;\n+        } else if p.eat(&token::Ident(sym::preserves_flags, false)) {\n+            args.options |= InlineAsmOptions::PRESERVES_FLAGS;\n+        } else if p.eat(&token::Ident(sym::noreturn, false)) {\n+            args.options |= InlineAsmOptions::NORETURN;\n+        } else {\n+            p.expect(&token::Ident(sym::nostack, false))?;\n+            args.options |= InlineAsmOptions::NOSTACK;\n+        }\n+\n+        // Allow trailing commas\n+        if p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n+            break;\n+        }\n+        p.expect(&token::Comma)?;\n+    }\n+\n+    let new_span = span_start.to(p.prev_token.span);\n+    if let Some(options_span) = args.options_span {\n+        p.struct_span_err(new_span, \"asm options cannot be specified multiple times\")\n+            .span_label(options_span, \"previously here\")\n+            .span_label(new_span, \"duplicate options\")\n+            .emit();\n+    } else {\n+        args.options_span = Some(new_span);\n+    }\n+\n+    Ok(())\n+}\n+\n+fn parse_reg<'a>(\n+    p: &mut Parser<'a>,\n+    explicit_reg: &mut bool,\n+) -> Result<ast::InlineAsmRegOrRegClass, DiagnosticBuilder<'a>> {\n+    p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n+    let result = match p.token.kind {\n+        token::Ident(name, false) => ast::InlineAsmRegOrRegClass::RegClass(name),\n+        token::Literal(token::Lit { kind: token::LitKind::Str, symbol, suffix: _ }) => {\n+            *explicit_reg = true;\n+            ast::InlineAsmRegOrRegClass::Reg(symbol)\n+        }\n+        _ => {\n+            return Err(\n+                p.struct_span_err(p.token.span, \"expected register class or explicit register\")\n+            );\n+        }\n+    };\n+    p.bump();\n+    p.expect(&token::CloseDelim(token::DelimToken::Paren))?;\n+    Ok(result)\n+}\n+\n fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast::Expr> {\n     let msg = \"asm template must be a string literal\";\n     let template_sp = args.template.span;"}, {"sha": "b98ed99d04e79c3a342e4d7e4556d5b6e38c9a1a", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=ff97db1e54dde5418f55f1c727e1c37257c4a6ab", "patch": "@@ -239,8 +239,10 @@ impl ExprVisitor<'tcx> {\n                     &format!(\"type `{}`\", self.tables.expr_ty_adjusted(in_expr)),\n                 );\n                 err.span_label(expr.span, &format!(\"type `{}`\", ty));\n-                err.note(\"asm inout arguments must have the same type\");\n-                err.note(\"unless they are both pointers or integers of the same size\");\n+                err.note(\n+                    \"asm inout arguments must have the same type, \\\n+                    unless they are both pointers or integers of the same size\",\n+                );\n                 err.emit();\n             }\n \n@@ -271,7 +273,16 @@ impl ExprVisitor<'tcx> {\n             }\n         };\n \n-        // Check whether the selected type requires a target feature.\n+        // Check whether the selected type requires a target feature. Note that\n+        // this is different from the feature check we did earlier in AST\n+        // lowering. While AST lowering checked that this register class is\n+        // usable at all with the currently enabled features, some types may\n+        // only be usable with a register class when a certain feature is\n+        // enabled. We check this here since it depends on the results of typeck.\n+        //\n+        // Also note that this check isn't run when the operand type is never\n+        // (!). In that case we still need the earlier check in AST lowering to\n+        // verify that the register class is usable at all.\n         if let Some(feature) = feature {\n             if !self.tcx.sess.target_features.contains(&Symbol::intern(feature)) {\n                 let msg = &format!(\"`{}` target feature is not enabled\", feature);"}, {"sha": "16bc5d670d8bb495e2c304d1631a1063d1ae5569", "filename": "src/librustc_target/asm/aarch64.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Flibrustc_target%2Fasm%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Flibrustc_target%2Fasm%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Faarch64.rs?ref=ff97db1e54dde5418f55f1c727e1c37257c4a6ab", "patch": "@@ -24,13 +24,10 @@ impl AArch64InlineAsmRegClass {\n         ty: InlineAsmType,\n     ) -> Option<(char, &'static str, Option<&'static str>)> {\n         match self {\n-            Self::reg => {\n-                if ty.size().bits() <= 32 {\n-                    Some(('w', \"w0\", None))\n-                } else {\n-                    None\n-                }\n-            }\n+            Self::reg => match ty.size().bits() {\n+                64 => None,\n+                _ => Some(('w', \"w0\", None)),\n+            },\n             Self::vreg | Self::vreg_low16 => match ty.size().bits() {\n                 8 => Some(('b', \"b0\", None)),\n                 16 => Some(('h', \"h0\", None)),\n@@ -57,8 +54,8 @@ impl AArch64InlineAsmRegClass {\n             Self::reg => types! { _: I8, I16, I32, I64, F32, F64; },\n             Self::vreg | Self::vreg_low16 => types! {\n                 \"fp\": I8, I16, I32, I64, F32, F64,\n-                VecI8(8), VecI16(4), VecI32(2), VecI64(1), VecF32(2), VecF64(1),\n-                VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2);\n+                    VecI8(8), VecI16(4), VecI32(2), VecI64(1), VecF32(2), VecF64(1),\n+                    VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2);\n             },\n         }\n     }\n@@ -128,12 +125,12 @@ def_regs! {\n         v29: vreg = [\"v29\", \"b29\", \"h29\", \"s29\", \"d29\", \"q29\"],\n         v30: vreg = [\"v30\", \"b30\", \"h30\", \"s30\", \"d30\", \"q30\"],\n         v31: vreg = [\"v31\", \"b31\", \"h31\", \"s31\", \"d31\", \"q31\"],\n-        \"the frame pointer cannot be used as an operand for inline asm\" =\n-            [\"x29\", \"fp\"],\n-        \"the stack pointer cannot be used as an operand for inline asm\" =\n-            [\"sp\", \"wsp\"],\n-        \"the zero register cannot be used as an operand for inline asm\" =\n-            [\"xzr\", \"wzr\"],\n+        #error = [\"x29\", \"fp\"] =>\n+            \"the frame pointer cannot be used as an operand for inline asm\",\n+        #error = [\"sp\", \"wsp\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+        #error = [\"xzr\", \"wzr\"] =>\n+            \"the zero register cannot be used as an operand for inline asm\",\n     }\n }\n "}, {"sha": "0ceb15e297f5e1543dfdc1f6995f749ffdaf7bbc", "filename": "src/librustc_target/asm/arm.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Flibrustc_target%2Fasm%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Flibrustc_target%2Fasm%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Farm.rs?ref=ff97db1e54dde5418f55f1c727e1c37257c4a6ab", "patch": "@@ -149,12 +149,12 @@ def_regs! {\n         q13: qreg = [\"q13\"],\n         q14: qreg = [\"q14\"],\n         q15: qreg = [\"q15\"],\n-        \"the frame pointer cannot be used as an operand for inline asm\" =\n-            [\"r11\", \"fp\"],\n-        \"the stack pointer cannot be used as an operand for inline asm\" =\n-            [\"r13\", \"sp\"],\n-        \"the program pointer cannot be used as an operand for inline asm\" =\n-            [\"r15\", \"pc\"],\n+        #error = [\"r11\", \"fp\"] =>\n+            \"the frame pointer cannot be used as an operand for inline asm\",\n+        #error = [\"r13\", \"sp\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+        #error = [\"r15\", \"pc\"] =>\n+            \"the program pointer cannot be used as an operand for inline asm\",\n     }\n }\n \n@@ -231,6 +231,15 @@ impl ArmInlineAsmReg {\n                 }\n             };\n         }\n+\n+        // ARM's floating-point register file is interesting in that it can be\n+        // viewed as 16 128-bit registers, 32 64-bit registers or 32 32-bit\n+        // registers. Because these views overlap, the registers of different\n+        // widths will conflict (e.g. d0 overlaps with s0 and s1, and q1\n+        // overlaps with d2 and d3).\n+        //\n+        // See section E1.3.1 of the ARM Architecture Reference Manual for\n+        // ARMv8-A for more details.\n         reg_conflicts! {\n             q0 : d0 d1 : s0 s1 s2 s3,\n             q1 : d2 d3 : s4 s5 s6 s7,"}, {"sha": "dda6e7cd5cd6a5cd336278a0cd40c5db96f9f88f", "filename": "src/librustc_target/asm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Flibrustc_target%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Flibrustc_target%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fmod.rs?ref=ff97db1e54dde5418f55f1c727e1c37257c4a6ab", "patch": "@@ -57,7 +57,7 @@ macro_rules! def_regs {\n             $reg:ident: $class:ident $(, $extra_class:ident)* = [$reg_name:literal $(, $alias:literal)*] $(% $filter:ident)?,\n         )*\n         $(\n-            $error:literal = [$($bad_reg:literal),+],\n+            #error = [$($bad_reg:literal),+] => $error:literal,\n         )*\n     }) => {\n         #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]"}, {"sha": "f9b132c208775b9ef2b6fa68497f03f20b472410", "filename": "src/librustc_target/asm/riscv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Flibrustc_target%2Fasm%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Flibrustc_target%2Fasm%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Friscv.rs?ref=ff97db1e54dde5418f55f1c727e1c37257c4a6ab", "patch": "@@ -115,16 +115,16 @@ def_regs! {\n         f29: freg = [\"f29\", \"ft9\"],\n         f30: freg = [\"f30\", \"ft10\"],\n         f31: freg = [\"f31\", \"ft11\"],\n-        \"the frame pointer cannot be used as an operand for inline asm\" =\n-            [\"x8\", \"s0\", \"fp\"],\n-        \"the stack pointer cannot be used as an operand for inline asm\" =\n-            [\"x2\", \"sp\"],\n-        \"the global pointer cannot be used as an operand for inline asm\" =\n-            [\"x3\", \"gp\"],\n-        \"the thread pointer cannot be used as an operand for inline asm\" =\n-            [\"x4\", \"tp\"],\n-        \"the zero register cannot be used as an operand for inline asm\" =\n-            [\"x0\", \"zero\"],\n+        #error = [\"x8\", \"s0\", \"fp\"] =>\n+            \"the frame pointer cannot be used as an operand for inline asm\",\n+        #error = [\"x2\", \"sp\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+        #error = [\"x3\", \"gp\"] =>\n+            \"the global pointer cannot be used as an operand for inline asm\",\n+        #error = [\"x4\", \"tp\"] =>\n+            \"the thread pointer cannot be used as an operand for inline asm\" ,\n+        #error = [\"x0\", \"zero\"] =>\n+            \"the zero register cannot be used as an operand for inline asm\",\n     }\n }\n "}, {"sha": "d10bcb40ba009262d7225d989cd447f94e1f0761", "filename": "src/librustc_target/asm/x86.rs", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Flibrustc_target%2Fasm%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Flibrustc_target%2Fasm%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fx86.rs?ref=ff97db1e54dde5418f55f1c727e1c37257c4a6ab", "patch": "@@ -62,16 +62,13 @@ impl X86InlineAsmRegClass {\n                 _ => None,\n             },\n             Self::xmm_reg => None,\n-            Self::ymm_reg => {\n-                if ty.size().bits() <= 128 {\n-                    Some(('x', \"xmm0\", None))\n-                } else {\n-                    None\n-                }\n-            }\n+            Self::ymm_reg => match ty.size().bits() {\n+                256 => None,\n+                _ => Some(('x', \"xmm0\", None)),\n+            },\n             Self::zmm_reg => match ty.size().bits() {\n-                256 => Some(('y', \"ymm0\", None)),\n                 512 => None,\n+                256 => Some(('y', \"ymm0\", None)),\n                 _ => Some(('x', \"xmm0\", None)),\n             },\n             Self::kreg => None,\n@@ -108,18 +105,18 @@ impl X86InlineAsmRegClass {\n             }\n             Self::xmm_reg => types! {\n                 \"sse\": I32, I64, F32, F64,\n-                VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2);\n+                  VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2);\n             },\n             Self::ymm_reg => types! {\n                 \"avx\": I32, I64, F32, F64,\n-                VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2),\n-                VecI8(32), VecI16(16), VecI32(8), VecI64(4), VecF32(8), VecF64(4);\n+                    VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2),\n+                    VecI8(32), VecI16(16), VecI32(8), VecI64(4), VecF32(8), VecF64(4);\n             },\n             Self::zmm_reg => types! {\n                 \"avx512f\": I32, I64, F32, F64,\n-                VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2),\n-                VecI8(32), VecI16(16), VecI32(8), VecI64(4), VecF32(8), VecF64(4),\n-                VecI8(64), VecI16(32), VecI32(16), VecI64(8), VecF32(16), VecF64(8);\n+                    VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2),\n+                    VecI8(32), VecI16(16), VecI32(8), VecI64(4), VecF32(8), VecF64(4),\n+                    VecI8(64), VecI16(32), VecI32(16), VecI64(8), VecF32(16), VecF64(8);\n             },\n             Self::kreg => types! {\n                 \"avx512f\": I8, I16;\n@@ -227,19 +224,20 @@ def_regs! {\n         k5: kreg = [\"k5\"],\n         k6: kreg = [\"k6\"],\n         k7: kreg = [\"k7\"],\n-        \"high byte registers are not currently supported as operands for inline asm\" =\n-            [\"ah\", \"bh\", \"ch\", \"dh\"],\n-        \"the frame pointer cannot be used as an operand for inline asm\" =\n-            [\"bp\", \"bpl\", \"ebp\", \"rbp\"],\n-        \"the stack pointer cannot be used as an operand for inline asm\" =\n-            [\"sp\", \"spl\", \"esp\", \"rsp\"],\n-        \"the instruction pointer cannot be used as an operand for inline asm\" =\n-            [\"ip\", \"eip\", \"rip\"],\n-        \"x87 registers are not currently supported as operands for inline asm\" =\n-            [\"st\", \"st(0)\", \"st(1)\", \"st(2)\", \"st(3)\", \"st(4)\", \"st(5)\", \"st(6)\", \"st(7)\"],\n-        \"MMX registers are not currently supported as operands for inline asm\" =\n-            [\"mm0\", \"mm1\", \"mm2\", \"mm3\", \"mm4\", \"mm5\", \"mm6\", \"mm7\"],\n-        \"the k0 AVX mask register cannot be used as an operand for inline asm\" = [\"k0\"],\n+        #error = [\"ah\", \"bh\", \"ch\", \"dh\"] =>\n+            \"high byte registers are not currently supported as operands for inline asm\",\n+        #error = [\"bp\", \"bpl\", \"ebp\", \"rbp\"] =>\n+            \"the frame pointer cannot be used as an operand for inline asm\",\n+        #error = [\"sp\", \"spl\", \"esp\", \"rsp\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+        #error = [\"ip\", \"eip\", \"rip\"] =>\n+            \"the instruction pointer cannot be used as an operand for inline asm\",\n+        #error = [\"st\", \"st(0)\", \"st(1)\", \"st(2)\", \"st(3)\", \"st(4)\", \"st(5)\", \"st(6)\", \"st(7)\"] =>\n+            \"x87 registers are not currently supported as operands for inline asm\",\n+        #error = [\"mm0\", \"mm1\", \"mm2\", \"mm3\", \"mm4\", \"mm5\", \"mm6\", \"mm7\"] =>\n+            \"MMX registers are not currently supported as operands for inline asm\",\n+        #error = [\"k0\"] =>\n+            \"the k0 AVX mask register cannot be used as an operand for inline asm\",\n     }\n }\n \n@@ -316,6 +314,15 @@ impl X86InlineAsmReg {\n                 }\n             };\n         }\n+\n+        // XMM*, YMM* and ZMM* are all different views of the same register.\n+        //\n+        // See section 15.5 of the combined Intel\u00ae 64 and IA-32 Architectures\n+        // Software Developer\u2019s Manual for more details.\n+        //\n+        // We don't need to specify conflicts for [x,y,z]mm[16-31] since these\n+        // registers are only available with AVX-512, so we just specify them\n+        // as aliases directly.\n         reg_conflicts! {\n             xmm0 : ymm0 : zmm0,\n             xmm1 : ymm1 : zmm1,"}, {"sha": "2b1f018f3642eedc253a3cab86e43c924803905f", "filename": "src/test/ui/asm/parse-error.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs?ref=ff97db1e54dde5418f55f1c727e1c37257c4a6ab", "patch": "@@ -35,7 +35,10 @@ fn main() {\n         asm!(\"\", options(nomem, foo));\n         //~^ ERROR expected one of\n         asm!(\"\", options(), options());\n-        //~^ ERROR asm options cannot be specified twice\n+        //~^ ERROR asm options cannot be specified multiple times\n+        asm!(\"\", options(), options(), options());\n+        //~^ ERROR asm options cannot be specified multiple times\n+        //~^^ ERROR asm options cannot be specified multiple times\n         asm!(\"{}\", options(), const foo);\n         //~^ ERROR arguments are not allowed after options\n         asm!(\"{a}\", a = const foo, a = const bar);"}, {"sha": "94eb9d29862c9757cf1de007e5609cdbd00efb76", "filename": "src/test/ui/asm/parse-error.stderr", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr?ref=ff97db1e54dde5418f55f1c727e1c37257c4a6ab", "patch": "@@ -82,65 +82,81 @@ error: expected one of `)`, `nomem`, `noreturn`, `nostack`, `preserves_flags`, `\n LL |         asm!(\"\", options(nomem, foo));\n    |                                 ^^^ expected one of 7 possible tokens\n \n-error: asm options cannot be specified twice\n+error: asm options cannot be specified multiple times\n   --> $DIR/parse-error.rs:37:29\n    |\n LL |         asm!(\"\", options(), options());\n    |                  ---------  ^^^^^^^^^ duplicate options\n    |                  |\n    |                  previously here\n \n+error: asm options cannot be specified multiple times\n+  --> $DIR/parse-error.rs:39:29\n+   |\n+LL |         asm!(\"\", options(), options(), options());\n+   |                  ---------  ^^^^^^^^^ duplicate options\n+   |                  |\n+   |                  previously here\n+\n+error: asm options cannot be specified multiple times\n+  --> $DIR/parse-error.rs:39:40\n+   |\n+LL |         asm!(\"\", options(), options(), options());\n+   |                  ---------             ^^^^^^^^^ duplicate options\n+   |                  |\n+   |                  previously here\n+\n error: arguments are not allowed after options\n-  --> $DIR/parse-error.rs:39:31\n+  --> $DIR/parse-error.rs:42:31\n    |\n LL |         asm!(\"{}\", options(), const foo);\n    |                    ---------  ^^^^^^^^^ argument\n    |                    |\n    |                    previous options\n \n error: duplicate argument named `a`\n-  --> $DIR/parse-error.rs:41:36\n+  --> $DIR/parse-error.rs:44:36\n    |\n LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                     -------------  ^^^^^^^^^^^^^ duplicate argument\n    |                     |\n    |                     previously here\n \n error: argument never used\n-  --> $DIR/parse-error.rs:41:36\n+  --> $DIR/parse-error.rs:44:36\n    |\n LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                                    ^^^^^^^^^^^^^ argument never used\n \n error: explicit register arguments cannot have names\n-  --> $DIR/parse-error.rs:44:18\n+  --> $DIR/parse-error.rs:47:18\n    |\n LL |         asm!(\"\", a = in(\"eax\") foo);\n    |                  ^^^^^^^^^^^^^^^^^\n \n error: named arguments cannot follow explicit register arguments\n-  --> $DIR/parse-error.rs:46:36\n+  --> $DIR/parse-error.rs:49:36\n    |\n LL |         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n    |                     -------------  ^^^^^^^^^^^^^ named argument\n    |                     |\n    |                     explicit register argument\n \n error: named arguments cannot follow explicit register arguments\n-  --> $DIR/parse-error.rs:48:36\n+  --> $DIR/parse-error.rs:51:36\n    |\n LL |         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n    |                     -------------  ^^^^^^^^^^^^^ named argument\n    |                     |\n    |                     explicit register argument\n \n error: positional arguments cannot follow named arguments or explicit register arguments\n-  --> $DIR/parse-error.rs:50:36\n+  --> $DIR/parse-error.rs:53:36\n    |\n LL |         asm!(\"{1}\", in(\"eax\") foo, const bar);\n    |                     -------------  ^^^^^^^^^ positional argument\n    |                     |\n    |                     explicit register argument\n \n-error: aborting due to 22 previous errors\n+error: aborting due to 24 previous errors\n "}, {"sha": "ccc795d1013aff854c870f5abf42dd33bc7dfa88", "filename": "src/test/ui/asm/type-check-3.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff97db1e54dde5418f55f1c727e1c37257c4a6ab/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.stderr?ref=ff97db1e54dde5418f55f1c727e1c37257c4a6ab", "patch": "@@ -83,8 +83,7 @@ LL |         asm!(\"{:r}\", inout(reg) 0u16 => val_i8);\n    |                                 |\n    |                                 type `u16`\n    |\n-   = note: asm inout arguments must have the same type\n-   = note: unless they are both pointers or integers of the same size\n+   = note: asm inout arguments must have the same type, unless they are both pointers or integers of the same size\n \n error: incompatible types for asm inout argument\n   --> $DIR/type-check-3.rs:59:33\n@@ -94,8 +93,7 @@ LL |         asm!(\"{:r}\", inout(reg) 0u32 => val_f32);\n    |                                 |\n    |                                 type `u32`\n    |\n-   = note: asm inout arguments must have the same type\n-   = note: unless they are both pointers or integers of the same size\n+   = note: asm inout arguments must have the same type, unless they are both pointers or integers of the same size\n \n error: incompatible types for asm inout argument\n   --> $DIR/type-check-3.rs:61:33\n@@ -105,8 +103,7 @@ LL |         asm!(\"{:r}\", inout(reg) 0u32 => val_ptr);\n    |                                 |\n    |                                 type `u32`\n    |\n-   = note: asm inout arguments must have the same type\n-   = note: unless they are both pointers or integers of the same size\n+   = note: asm inout arguments must have the same type, unless they are both pointers or integers of the same size\n \n error: incompatible types for asm inout argument\n   --> $DIR/type-check-3.rs:63:33\n@@ -116,8 +113,7 @@ LL |         asm!(\"{:r}\", inout(reg) main => val_u32);\n    |                                 |\n    |                                 type `fn()`\n    |\n-   = note: asm inout arguments must have the same type\n-   = note: unless they are both pointers or integers of the same size\n+   = note: asm inout arguments must have the same type, unless they are both pointers or integers of the same size\n \n error: aborting due to 9 previous errors; 4 warnings emitted\n "}]}