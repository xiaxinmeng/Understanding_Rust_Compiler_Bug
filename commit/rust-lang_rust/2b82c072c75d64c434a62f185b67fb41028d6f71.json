{"sha": "2b82c072c75d64c434a62f185b67fb41028d6f71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiODJjMDcyYzc1ZDY0YzQzNGE2MmYxODViNjdmYjQxMDI4ZDZmNzE=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2015-08-07T10:06:43Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2015-08-07T11:41:17Z"}, "message": "StrSearcher: Improve inner loop in TwoWaySearcher::next, next_back\n\nThe innermost loop of TwoWaySearcher checks the boundary of the haystack\nvs position + needle.len(), and it checks the last byte of the needle\nagainst the byteset.\n\nIf these two steps are combined by using the indexing of the last\nneedle byte's position as bounds check, the algorithm improves its\nthroughput. We improve the innermost loop by reducing the number of\ninstructions used, and elminating the panic case for the checked\nindexing that was previously used.\n\nSelected benchmarks from the external/workspace testsuite. Benchmarks\nimprove across the board.\n\n```\nbefore:\n\ntest bb_in_aa::twoway_find                  ... bench:       4,229 ns/iter (+/- 1,305) = 23646 MB/s\ntest bb_in_aa::twoway_rfind                 ... bench:       3,873 ns/iter (+/- 101) = 25819 MB/s\ntest short_1let_long::twoway_find           ... bench:       7,075 ns/iter (+/- 29) = 360 MB/s\ntest short_1let_long::twoway_rfind          ... bench:       6,640 ns/iter (+/- 79) = 384 MB/s\ntest short_2let_long::twoway_find           ... bench:       3,823 ns/iter (+/- 16) = 667 MB/s\ntest short_2let_long::twoway_rfind          ... bench:       3,774 ns/iter (+/- 44) = 675 MB/s\ntest short_3let_long::twoway_find           ... bench:       3,582 ns/iter (+/- 47) = 712 MB/s\ntest short_3let_long::twoway_rfind          ... bench:       3,616 ns/iter (+/- 34) = 705 MB/s\n\nwith this commit:\n\ntest bb_in_aa::twoway_find                  ... bench:       2,952 ns/iter (+/- 20) = 33875 MB/s\ntest bb_in_aa::twoway_rfind                 ... bench:       2,939 ns/iter (+/- 99) = 34025 MB/s\ntest short_1let_long::twoway_find           ... bench:       4,593 ns/iter (+/- 4) = 555 MB/s\ntest short_1let_long::twoway_rfind          ... bench:       4,592 ns/iter (+/- 76) = 555 MB/s\ntest short_2let_long::twoway_find           ... bench:       2,804 ns/iter (+/- 3) = 909 MB/s\ntest short_2let_long::twoway_rfind          ... bench:       2,807 ns/iter (+/- 40) = 908 MB/s\ntest short_3let_long::twoway_find           ... bench:       3,105 ns/iter (+/- 120) = 821 MB/s\ntest short_3let_long::twoway_rfind          ... bench:       3,019 ns/iter (+/- 50) = 844 MB/s\n```\n\n- `bb_in_aa`: fast skip due to byteset filter loop improves.\n- 1/2/3let: Searches for 1, 2, or 3 ascii bytes improves.", "tree": {"sha": "41ccaf1137be41b422dfcaf8b4c5b954131bb5f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41ccaf1137be41b422dfcaf8b4c5b954131bb5f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b82c072c75d64c434a62f185b67fb41028d6f71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b82c072c75d64c434a62f185b67fb41028d6f71", "html_url": "https://github.com/rust-lang/rust/commit/2b82c072c75d64c434a62f185b67fb41028d6f71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b82c072c75d64c434a62f185b67fb41028d6f71/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ebae85bb8eac495bbc4a463319b23404fdc63a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ebae85bb8eac495bbc4a463319b23404fdc63a6", "html_url": "https://github.com/rust-lang/rust/commit/7ebae85bb8eac495bbc4a463319b23404fdc63a6"}], "stats": {"total": 32, "additions": 22, "deletions": 10}, "files": [{"sha": "0ea3b38a3cf29c9ced18fb362a722a209722c768", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2b82c072c75d64c434a62f185b67fb41028d6f71/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b82c072c75d64c434a62f185b67fb41028d6f71/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=2b82c072c75d64c434a62f185b67fb41028d6f71", "patch": "@@ -906,19 +906,25 @@ impl TwoWaySearcher {\n     {\n         // `next()` uses `self.position` as its cursor\n         let old_pos = self.position;\n+        let needle_last = needle.len() - 1;\n         'search: loop {\n             // Check that we have room to search in\n-            if needle.len() > haystack.len() - self.position {\n-                self.position = haystack.len();\n-                return S::rejecting(old_pos, self.position);\n-            }\n+            // position + needle_last can not overflow if we assume slices\n+            // are bounded by isize's range.\n+            let tail_byte = match haystack.get(self.position + needle_last) {\n+                Some(&b) => b,\n+                None => {\n+                    self.position = haystack.len();\n+                    return S::rejecting(old_pos, self.position);\n+                }\n+            };\n \n             if S::use_early_reject() && old_pos != self.position {\n                 return S::rejecting(old_pos, self.position);\n             }\n \n             // Quickly skip by large portions unrelated to our substring\n-            if !self.byteset_contains(haystack[self.position + needle.len() - 1]) {\n+            if !self.byteset_contains(tail_byte) {\n                 self.position += needle.len();\n                 if !long_period {\n                     self.memory = 0;\n@@ -986,17 +992,23 @@ impl TwoWaySearcher {\n         let old_end = self.end;\n         'search: loop {\n             // Check that we have room to search in\n-            if needle.len() > self.end {\n-                self.end = 0;\n-                return S::rejecting(0, old_end);\n-            }\n+            // end - needle.len() will wrap around when there is no more room,\n+            // but due to slice length limits it can never wrap all the way back\n+            // into the length of haystack.\n+            let front_byte = match haystack.get(self.end.wrapping_sub(needle.len())) {\n+                Some(&b) => b,\n+                None => {\n+                    self.end = 0;\n+                    return S::rejecting(0, old_end);\n+                }\n+            };\n \n             if S::use_early_reject() && old_end != self.end {\n                 return S::rejecting(self.end, old_end);\n             }\n \n             // Quickly skip by large portions unrelated to our substring\n-            if !self.byteset_contains(haystack[self.end - needle.len()]) {\n+            if !self.byteset_contains(front_byte) {\n                 self.end -= needle.len();\n                 if !long_period {\n                     self.memory_back = needle.len();"}]}