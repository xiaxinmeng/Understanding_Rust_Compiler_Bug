{"sha": "bf38ba260d43171051249b08cfd9466a518804d6", "node_id": "C_kwDOAAsO6NoAKGJmMzhiYTI2MGQ0MzE3MTA1MTI0OWIwOGNmZDk0NjZhNTE4ODA0ZDY", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-21T12:06:26Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-18T14:59:27Z"}, "message": "Separate `AnonymousCreateParameter` and `ReportElidedInPath`.", "tree": {"sha": "073af2a7d03671a83239a761fa9ac94f0464b01a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/073af2a7d03671a83239a761fa9ac94f0464b01a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf38ba260d43171051249b08cfd9466a518804d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf38ba260d43171051249b08cfd9466a518804d6", "html_url": "https://github.com/rust-lang/rust/commit/bf38ba260d43171051249b08cfd9466a518804d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf38ba260d43171051249b08cfd9466a518804d6/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "237e267b8050bac6e24d412f0d577c5ca9d57ca1", "url": "https://api.github.com/repos/rust-lang/rust/commits/237e267b8050bac6e24d412f0d577c5ca9d57ca1", "html_url": "https://github.com/rust-lang/rust/commit/237e267b8050bac6e24d412f0d577c5ca9d57ca1"}], "stats": {"total": 155, "additions": 93, "deletions": 62}, "files": [{"sha": "74999067cd44d83e79e92133a51509b9905f490a", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 93, "deletions": 62, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/bf38ba260d43171051249b08cfd9466a518804d6/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf38ba260d43171051249b08cfd9466a518804d6/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=bf38ba260d43171051249b08cfd9466a518804d6", "patch": "@@ -238,14 +238,14 @@ enum LifetimeRibKind {\n     /// `body_id` is an anonymous constant and `lifetime_ref` is non-static.\n     AnonConst,\n \n-    /// For **Modern** cases, create a new anonymous region parameter\n-    /// and reference that.\n+    /// Create a new anonymous region parameter and reference it.\n     ///\n-    /// For **Dyn Bound** cases, pass responsibility to\n-    /// `resolve_lifetime` code.\n-    ///\n-    /// For **Deprecated** cases, report an error.\n-    AnonymousCreateParameter(NodeId),\n+    /// If `report_in_path`, report an error when encountering lifetime elision in a path:\n+    /// ```ignore\n+    /// struct Foo<'a> { .. }\n+    /// fn foo(x: Foo) {}\n+    /// ```\n+    AnonymousCreateParameter { binder: NodeId, report_in_path: bool },\n \n     /// Give a hard error when either `&` or `'_` is written. Used to\n     /// rule out things like `where T: Foo<'_>`. Does not imply an\n@@ -764,7 +764,10 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         // return type.\n                         this.with_lifetime_rib(\n                             if async_node_id.is_some() {\n-                                LifetimeRibKind::AnonymousCreateParameter(fn_id)\n+                                LifetimeRibKind::AnonymousCreateParameter {\n+                                    binder: fn_id,\n+                                    report_in_path: true,\n+                                }\n                             } else {\n                                 LifetimeRibKind::AnonymousPassThrough(fn_id, false)\n                             },\n@@ -791,7 +794,9 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                                 );\n                                 match rib.kind {\n                                     LifetimeRibKind::Item => break,\n-                                    LifetimeRibKind::AnonymousCreateParameter(binder) => {\n+                                    LifetimeRibKind::AnonymousCreateParameter {\n+                                        binder, ..\n+                                    } => {\n                                         if let Some(earlier_fresh) =\n                                             this.r.extra_lifetime_params_map.get(&binder)\n                                         {\n@@ -1295,7 +1300,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                     }\n                                     // An anonymous lifetime is legal here, go ahead.\n                                     LifetimeRibKind::AnonymousPassThrough(_, false)\n-                                    | LifetimeRibKind::AnonymousCreateParameter(_) => {\n+                                    | LifetimeRibKind::AnonymousCreateParameter { .. } => {\n                                         Some(LifetimeUseSet::One { use_span: ident.span, use_ctxt })\n                                     }\n                                     _ => None,\n@@ -1350,8 +1355,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         for i in (0..self.lifetime_ribs.len()).rev() {\n             let rib = &mut self.lifetime_ribs[i];\n             match rib.kind {\n-                LifetimeRibKind::AnonymousCreateParameter(item_node_id) => {\n-                    self.create_fresh_lifetime(lifetime.id, lifetime.ident, item_node_id);\n+                LifetimeRibKind::AnonymousCreateParameter { binder, .. } => {\n+                    let res = self.create_fresh_lifetime(lifetime.id, lifetime.ident, binder);\n+                    self.record_lifetime_res(lifetime.id, res);\n                     return;\n                 }\n                 LifetimeRibKind::AnonymousReportError => {\n@@ -1408,7 +1414,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n-    fn create_fresh_lifetime(&mut self, id: NodeId, ident: Ident, item_node_id: NodeId) {\n+    fn create_fresh_lifetime(\n+        &mut self,\n+        id: NodeId,\n+        ident: Ident,\n+        item_node_id: NodeId,\n+    ) -> LifetimeRes {\n         debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n         debug!(?ident.span);\n         let item_def_id = self.r.local_def_id(item_node_id);\n@@ -1423,12 +1434,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         debug!(?def_id);\n \n         let region = LifetimeRes::Fresh { param: def_id, binder: item_node_id };\n-        self.record_lifetime_res(id, region);\n         self.r.extra_lifetime_params_map.entry(item_node_id).or_insert_with(Vec::new).push((\n             ident,\n             def_node_id,\n             region,\n         ));\n+        region\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n@@ -1471,14 +1482,31 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 continue;\n             }\n \n-            let missing = match source {\n+            let mut should_lint = match source {\n                 PathSource::Trait(..) | PathSource::TraitItem(..) | PathSource::Type => true,\n                 PathSource::Expr(..)\n                 | PathSource::Pat\n                 | PathSource::Struct\n                 | PathSource::TupleStruct(..) => false,\n             };\n-            let mut res = LifetimeRes::Error;\n+\n+            let elided_lifetime_span = if segment.has_generic_args {\n+                // If there are brackets, but not generic arguments, then use the opening bracket\n+                segment.args_span.with_hi(segment.args_span.lo() + BytePos(1))\n+            } else {\n+                // If there are no brackets, use the identifier span.\n+                // HACK: we use find_ancestor_inside to properly suggest elided spans in paths\n+                // originating from macros, since the segment's span might be from a macro arg.\n+                segment.ident.span.find_ancestor_inside(path_span).unwrap_or(path_span)\n+            };\n+            let ident = Ident::new(kw::UnderscoreLifetime, elided_lifetime_span);\n+\n+            let node_ids = self.r.next_node_ids(expected_lifetimes);\n+            self.record_lifetime_res(\n+                segment_id,\n+                LifetimeRes::ElidedAnchor { start: node_ids.start, end: node_ids.end },\n+            );\n+\n             for rib in self.lifetime_ribs.iter().rev() {\n                 match rib.kind {\n                     // In create-parameter mode we error here because we don't want to support\n@@ -1487,7 +1515,39 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     //\n                     //     impl Foo for std::cell::Ref<u32> // note lack of '_\n                     //     async fn foo(_: std::cell::Ref<u32>) { ... }\n-                    LifetimeRibKind::AnonymousCreateParameter(_) => {\n+                    LifetimeRibKind::AnonymousCreateParameter { report_in_path: true, .. } => {\n+                        let sess = self.r.session;\n+                        let mut err = rustc_errors::struct_span_err!(\n+                            sess,\n+                            path_span,\n+                            E0726,\n+                            \"implicit elided lifetime not allowed here\"\n+                        );\n+                        rustc_errors::add_elided_lifetime_in_path_suggestion(\n+                            sess.source_map(),\n+                            &mut err,\n+                            expected_lifetimes,\n+                            path_span,\n+                            !segment.has_generic_args,\n+                            elided_lifetime_span,\n+                        );\n+                        err.note(\"assuming a `'static` lifetime...\");\n+                        err.emit();\n+                        should_lint = false;\n+                        for i in 0..expected_lifetimes {\n+                            let id = node_ids.start.plus(i);\n+                            self.record_lifetime_res(id, LifetimeRes::Error);\n+                        }\n+                        break;\n+                    }\n+                    LifetimeRibKind::AnonymousCreateParameter { binder, .. } => {\n+                        let res = self.create_fresh_lifetime(node_ids.start, ident, binder);\n+                        self.record_lifetime_res(node_ids.start, res);\n+                        for i in 1..expected_lifetimes {\n+                            let id = node_ids.start.plus(i);\n+                            let res = self.create_fresh_lifetime(id, ident, binder);\n+                            self.record_lifetime_res(id, res);\n+                        }\n                         break;\n                     }\n                     // `PassThrough` is the normal case.\n@@ -1497,62 +1557,30 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     // lifetime. Instead, we simply create an implicit lifetime, which will be checked\n                     // later, at which point a suitable error will be emitted.\n                     LifetimeRibKind::AnonymousPassThrough(binder, _) => {\n-                        res = LifetimeRes::Anonymous { binder, elided: true };\n+                        let res = LifetimeRes::Anonymous { binder, elided: true };\n+                        self.record_lifetime_res(node_ids.start, res);\n+                        for i in 1..expected_lifetimes {\n+                            let id = node_ids.start.plus(i);\n+                            self.record_lifetime_res(id, res);\n+                        }\n                         break;\n                     }\n                     LifetimeRibKind::AnonymousReportError | LifetimeRibKind::Item => {\n                         // FIXME(cjgillot) This resolution is wrong, but this does not matter\n                         // since these cases are erroneous anyway.  Lifetime resolution should\n                         // emit a \"missing lifetime specifier\" diagnostic.\n-                        res = LifetimeRes::Anonymous { binder: DUMMY_NODE_ID, elided: true };\n+                        let res = LifetimeRes::Anonymous { binder: DUMMY_NODE_ID, elided: true };\n+                        for i in 0..expected_lifetimes {\n+                            let id = node_ids.start.plus(i);\n+                            self.record_lifetime_res(id, res);\n+                        }\n                         break;\n                     }\n                     _ => {}\n                 }\n             }\n \n-            let node_ids = self.r.next_node_ids(expected_lifetimes);\n-            self.record_lifetime_res(\n-                segment_id,\n-                LifetimeRes::ElidedAnchor { start: node_ids.start, end: node_ids.end },\n-            );\n-            for i in 0..expected_lifetimes {\n-                let id = node_ids.start.plus(i);\n-                self.record_lifetime_res(id, res);\n-            }\n-\n-            if !missing {\n-                continue;\n-            }\n-\n-            let elided_lifetime_span = if segment.has_generic_args {\n-                // If there are brackets, but not generic arguments, then use the opening bracket\n-                segment.args_span.with_hi(segment.args_span.lo() + BytePos(1))\n-            } else {\n-                // If there are no brackets, use the identifier span.\n-                // HACK: we use find_ancestor_inside to properly suggest elided spans in paths\n-                // originating from macros, since the segment's span might be from a macro arg.\n-                segment.ident.span.find_ancestor_inside(path_span).unwrap_or(path_span)\n-            };\n-            if let LifetimeRes::Error = res {\n-                let sess = self.r.session;\n-                let mut err = rustc_errors::struct_span_err!(\n-                    sess,\n-                    path_span,\n-                    E0726,\n-                    \"implicit elided lifetime not allowed here\"\n-                );\n-                rustc_errors::add_elided_lifetime_in_path_suggestion(\n-                    sess.source_map(),\n-                    &mut err,\n-                    expected_lifetimes,\n-                    path_span,\n-                    !segment.has_generic_args,\n-                    elided_lifetime_span,\n-                );\n-                err.note(\"assuming a `'static` lifetime...\");\n-                err.emit();\n-            } else {\n+            if should_lint {\n                 self.r.lint_buffer.buffer_lint_with_diagnostic(\n                     lint::builtin::ELIDED_LIFETIMES_IN_PATHS,\n                     segment_id,\n@@ -2155,7 +2183,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // Dummy self type for better errors if `Self` is used in the trait path.\n                 this.with_self_rib(Res::SelfTy { trait_: None, alias_to: None }, |this| {\n                     this.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousCreateParameter(item_id),\n+                        LifetimeRibKind::AnonymousCreateParameter {\n+                            binder: item_id,\n+                            report_in_path: true\n+                        },\n                         |this| {\n                             // Resolve the trait reference, if necessary.\n                             this.with_optional_trait_ref("}]}