{"sha": "5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNmZjYWQ2NDQ5YWFiYWQzYzI5YzY1YzE3MzhmOGVhYjg5YzAzY2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-19T22:48:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-19T22:48:40Z"}, "message": "Auto merge of #75563 - richkadel:llvm-coverage-map-gen-5.4, r=wesleywiser\n\nMoved coverage counter injection from BasicBlock to Statement.\n\nAs discussed on Zulip: https://rust-lang.zulipchat.com/#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Implement.20LLVM-compatible.20source-based.20cod.20compiler-team.23278", "tree": {"sha": "7badd7a71a5dd6d2bf0ab45c145201d58f415fd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7badd7a71a5dd6d2bf0ab45c145201d58f415fd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "html_url": "https://github.com/rust-lang/rust/commit/5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32c654a9795b0d88541e56ba9da4150e34f1d5f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/32c654a9795b0d88541e56ba9da4150e34f1d5f9", "html_url": "https://github.com/rust-lang/rust/commit/32c654a9795b0d88541e56ba9da4150e34f1d5f9"}, {"sha": "d129ac2655451ca894bceeb58a4d5c26a86c4caa", "url": "https://api.github.com/repos/rust-lang/rust/commits/d129ac2655451ca894bceeb58a4d5c26a86c4caa", "html_url": "https://github.com/rust-lang/rust/commit/d129ac2655451ca894bceeb58a4d5c26a86c4caa"}], "stats": {"total": 1187, "additions": 400, "deletions": 787}, "files": [{"sha": "1399d0c020f16d8f7e86c36deb7fe2a54380f438", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -1949,70 +1949,6 @@ extern \"rust-intrinsic\" {\n     #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"41079\")]\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n-    /// Internal placeholder for injecting code coverage counters when the \"instrument-coverage\"\n-    /// option is enabled. The source code region information is extracted prior to code generation,\n-    /// and added to the \"coverage map\", which is injected into the generated code as additional\n-    /// data. This intrinsic then triggers the generation of LLVM intrinsic call\n-    /// `instrprof.increment`, using the remaining args (`function_source_hash` and `index`).\n-    #[cfg(not(bootstrap))]\n-    #[lang = \"count_code_region\"]\n-    pub fn count_code_region(\n-        function_source_hash: u64,\n-        index: u32,\n-        file_name: &'static str,\n-        start_line: u32,\n-        start_col: u32,\n-        end_line: u32,\n-        end_col: u32,\n-    );\n-\n-    /// Internal marker for code coverage expressions, injected into the MIR when the\n-    /// \"instrument-coverage\" option is enabled. This intrinsic is not converted into a\n-    /// backend intrinsic call, but its arguments are extracted during the production of a\n-    /// \"coverage map\", which is injected into the generated code, as additional data.\n-    /// This marker identifies a code region and two other counters or counter expressions\n-    /// whose sum is the number of times the code region was executed.\n-    #[cfg(not(bootstrap))]\n-    #[lang = \"coverage_counter_add\"]\n-    pub fn coverage_counter_add(\n-        index: u32,\n-        left_index: u32,\n-        right_index: u32,\n-        file_name: &'static str,\n-        start_line: u32,\n-        start_col: u32,\n-        end_line: u32,\n-        end_col: u32,\n-    );\n-\n-    /// This marker identifies a code region and two other counters or counter expressions\n-    /// whose difference is the number of times the code region was executed.\n-    /// (See `coverage_counter_add` for more information.)\n-    #[cfg(not(bootstrap))]\n-    #[lang = \"coverage_counter_subtract\"]\n-    pub fn coverage_counter_subtract(\n-        index: u32,\n-        left_index: u32,\n-        right_index: u32,\n-        file_name: &'static str,\n-        start_line: u32,\n-        start_col: u32,\n-        end_line: u32,\n-        end_col: u32,\n-    );\n-\n-    /// This marker identifies a code region to be added to the \"coverage map\" to indicate source\n-    /// code that can never be reached.\n-    /// (See `coverage_counter_add` for more information.)\n-    #[cfg(not(bootstrap))]\n-    pub fn coverage_unreachable(\n-        file_name: &'static str,\n-        start_line: u32,\n-        start_col: u32,\n-        end_line: u32,\n-        end_col: u32,\n-    );\n-\n     /// See documentation of `<*const T>::guaranteed_eq` for details.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     pub fn ptr_guaranteed_eq<T>(ptr: *const T, other: *const T) -> bool;"}, {"sha": "4ece08f62930045fc699e0d4b8390caf0dd785af", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -1117,7 +1117,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         hash: &'ll Value,\n         num_counters: &'ll Value,\n         index: &'ll Value,\n-    ) -> &'ll Value {\n+    ) {\n         debug!(\n             \"instrprof_increment() with args ({:?}, {:?}, {:?}, {:?})\",\n             fn_name, hash, num_counters, index\n@@ -1128,13 +1128,13 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let args = self.check_call(\"call\", llfn, args);\n \n         unsafe {\n-            llvm::LLVMRustBuildCall(\n+            let _ = llvm::LLVMRustBuildCall(\n                 self.llbuilder,\n                 llfn,\n                 args.as_ptr() as *const &llvm::Value,\n                 args.len() as c_uint,\n                 None,\n-            )\n+            );\n         }\n     }\n "}, {"sha": "ec6c177614d4e54ae536e7d4564bb3c4940b06b1", "filename": "src/librustc_codegen_llvm/coverageinfo/mapgen.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -3,14 +3,16 @@ use crate::coverageinfo;\n use crate::llvm;\n \n use llvm::coverageinfo::CounterMappingRegion;\n-use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression, Region};\n+use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods};\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_llvm::RustString;\n-use tracing::debug;\n+use rustc_middle::mir::coverage::CodeRegion;\n \n use std::ffi::CString;\n \n+use tracing::debug;\n+\n /// Generates and exports the Coverage Map.\n ///\n /// This Coverage Map complies with Coverage Mapping Format version 3 (zero-based encoded as 2),\n@@ -91,7 +93,7 @@ impl CoverageMapGenerator {\n     fn write_coverage_mappings(\n         &mut self,\n         expressions: Vec<CounterExpression>,\n-        counter_regions: impl Iterator<Item = (Counter, &'tcx Region<'tcx>)>,\n+        counter_regions: impl Iterator<Item = (Counter, &'a CodeRegion)>,\n         coverage_mappings_buffer: &RustString,\n     ) {\n         let mut counter_regions = counter_regions.collect::<Vec<_>>();\n@@ -104,22 +106,22 @@ impl CoverageMapGenerator {\n         let mut current_file_name = None;\n         let mut current_file_id = 0;\n \n-        // Convert the list of (Counter, Region) pairs to an array of `CounterMappingRegion`, sorted\n+        // Convert the list of (Counter, CodeRegion) pairs to an array of `CounterMappingRegion`, sorted\n         // by filename and position. Capture any new files to compute the `CounterMappingRegion`s\n         // `file_id` (indexing files referenced by the current function), and construct the\n         // function-specific `virtual_file_mapping` from `file_id` to its index in the module's\n         // `filenames` array.\n         counter_regions.sort_unstable_by_key(|(_counter, region)| *region);\n         for (counter, region) in counter_regions {\n-            let Region { file_name, start_line, start_col, end_line, end_col } = *region;\n-            let same_file = current_file_name.as_ref().map_or(false, |p| p == file_name);\n+            let CodeRegion { file_name, start_line, start_col, end_line, end_col } = *region;\n+            let same_file = current_file_name.as_ref().map_or(false, |p| *p == file_name);\n             if !same_file {\n                 if current_file_name.is_some() {\n                     current_file_id += 1;\n                 }\n-                current_file_name = Some(file_name.to_string());\n-                let c_filename =\n-                    CString::new(file_name).expect(\"null error converting filename to C string\");\n+                current_file_name = Some(file_name);\n+                let c_filename = CString::new(file_name.to_string())\n+                    .expect(\"null error converting filename to C string\");\n                 debug!(\"  file_id: {} = '{:?}'\", current_file_id, c_filename);\n                 let (filenames_index, _) = self.filenames.insert_full(c_filename);\n                 virtual_file_mapping.push(filenames_index as u32);"}, {"sha": "2bd37bf9c4f9ca1d299643b0bf04f3b55cf95b33", "filename": "src/librustc_codegen_llvm/coverageinfo/mod.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -5,34 +5,38 @@ use crate::common::CodegenCx;\n \n use libc::c_uint;\n use llvm::coverageinfo::CounterMappingRegion;\n-use rustc_codegen_ssa::coverageinfo::map::{CounterExpression, ExprKind, FunctionCoverage, Region};\n+use rustc_codegen_ssa::coverageinfo::map::{CounterExpression, FunctionCoverage};\n use rustc_codegen_ssa::traits::{\n     BaseTypeMethods, CoverageInfoBuilderMethods, CoverageInfoMethods, MiscMethods, StaticMethods,\n };\n use rustc_data_structures::fx::FxHashMap;\n use rustc_llvm::RustString;\n+use rustc_middle::mir::coverage::{\n+    CodeRegion, CounterValueReference, ExpressionOperandId, InjectedExpressionIndex, Op,\n+};\n use rustc_middle::ty::Instance;\n-use tracing::debug;\n \n use std::cell::RefCell;\n use std::ffi::CString;\n \n+use tracing::debug;\n+\n pub mod mapgen;\n \n const COVMAP_VAR_ALIGN_BYTES: usize = 8;\n \n /// A context object for maintaining all state needed by the coverageinfo module.\n pub struct CrateCoverageContext<'tcx> {\n     // Coverage region data for each instrumented function identified by DefId.\n-    pub(crate) function_coverage_map: RefCell<FxHashMap<Instance<'tcx>, FunctionCoverage<'tcx>>>,\n+    pub(crate) function_coverage_map: RefCell<FxHashMap<Instance<'tcx>, FunctionCoverage>>,\n }\n \n impl<'tcx> CrateCoverageContext<'tcx> {\n     pub fn new() -> Self {\n         Self { function_coverage_map: Default::default() }\n     }\n \n-    pub fn take_function_coverage_map(&self) -> FxHashMap<Instance<'tcx>, FunctionCoverage<'tcx>> {\n+    pub fn take_function_coverage_map(&self) -> FxHashMap<Instance<'tcx>, FunctionCoverage> {\n         self.function_coverage_map.replace(FxHashMap::default())\n     }\n }\n@@ -58,11 +62,11 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         &mut self,\n         instance: Instance<'tcx>,\n         function_source_hash: u64,\n-        id: u32,\n-        region: Region<'tcx>,\n+        id: CounterValueReference,\n+        region: CodeRegion,\n     ) {\n         debug!(\n-            \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, id={}, \\\n+            \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, id={:?}, \\\n              at {:?}\",\n             instance, function_source_hash, id, region,\n         );\n@@ -76,25 +80,25 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn add_counter_expression_region(\n         &mut self,\n         instance: Instance<'tcx>,\n-        id_descending_from_max: u32,\n-        lhs: u32,\n-        op: ExprKind,\n-        rhs: u32,\n-        region: Region<'tcx>,\n+        id: InjectedExpressionIndex,\n+        lhs: ExpressionOperandId,\n+        op: Op,\n+        rhs: ExpressionOperandId,\n+        region: CodeRegion,\n     ) {\n         debug!(\n-            \"adding counter expression to coverage_regions: instance={:?}, id={}, {} {:?} {}, \\\n+            \"adding counter expression to coverage_regions: instance={:?}, id={:?}, {:?} {:?} {:?}, \\\n              at {:?}\",\n-            instance, id_descending_from_max, lhs, op, rhs, region,\n+            instance, id, lhs, op, rhs, region,\n         );\n         let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n         coverage_regions\n             .entry(instance)\n             .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_counter_expression(id_descending_from_max, lhs, op, rhs, region);\n+            .add_counter_expression(id, lhs, op, rhs, region);\n     }\n \n-    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: Region<'tcx>) {\n+    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion) {\n         debug!(\n             \"adding unreachable code to coverage_regions: instance={:?}, at {:?}\",\n             instance, region,"}, {"sha": "bb79a52dcf95cb58d3db0cab740db796e671720c", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -11,22 +11,18 @@ use rustc_ast as ast;\n use rustc_codegen_ssa::base::{compare_simd_types, to_immediate, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n-use rustc_codegen_ssa::coverageinfo;\n use rustc_codegen_ssa::glue;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::MemFlags;\n use rustc_hir as hir;\n-use rustc_middle::mir::coverage;\n-use rustc_middle::mir::Operand;\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_span::{sym, symbol::kw, Span, Symbol};\n use rustc_target::abi::{self, HasDataLayout, LayoutOf, Primitive};\n use rustc_target::spec::PanicStrategy;\n-use tracing::debug;\n \n use std::cmp::Ordering;\n use std::iter;\n@@ -83,85 +79,13 @@ fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: Symbol) -> Option<&'ll Va\n }\n \n impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n-    fn is_codegen_intrinsic(\n-        &mut self,\n-        intrinsic: Symbol,\n-        args: &Vec<Operand<'tcx>>,\n-        caller_instance: ty::Instance<'tcx>,\n-    ) -> bool {\n-        let mut is_codegen_intrinsic = true;\n-        // Set `is_codegen_intrinsic` to `false` to bypass `codegen_intrinsic_call()`.\n-\n-        // FIXME(richkadel): Make sure to add coverage analysis tests on a crate with\n-        // external crate dependencies, where:\n-        //   1. Both binary and dependent crates are compiled with `-Zinstrument-coverage`\n-        //   2. Only binary is compiled with `-Zinstrument-coverage`\n-        //   3. Only dependent crates are compiled with `-Zinstrument-coverage`\n-        match intrinsic {\n-            sym::count_code_region => {\n-                use coverage::count_code_region_args::*;\n-                self.add_counter_region(\n-                    caller_instance,\n-                    op_to_u64(&args[FUNCTION_SOURCE_HASH]),\n-                    op_to_u32(&args[COUNTER_ID]),\n-                    coverageinfo::Region::new(\n-                        op_to_str_slice(&args[FILE_NAME]),\n-                        op_to_u32(&args[START_LINE]),\n-                        op_to_u32(&args[START_COL]),\n-                        op_to_u32(&args[END_LINE]),\n-                        op_to_u32(&args[END_COL]),\n-                    ),\n-                );\n-            }\n-            sym::coverage_counter_add | sym::coverage_counter_subtract => {\n-                is_codegen_intrinsic = false;\n-                use coverage::coverage_counter_expression_args::*;\n-                self.add_counter_expression_region(\n-                    caller_instance,\n-                    op_to_u32(&args[EXPRESSION_ID]),\n-                    op_to_u32(&args[LEFT_ID]),\n-                    if intrinsic == sym::coverage_counter_add {\n-                        coverageinfo::ExprKind::Add\n-                    } else {\n-                        coverageinfo::ExprKind::Subtract\n-                    },\n-                    op_to_u32(&args[RIGHT_ID]),\n-                    coverageinfo::Region::new(\n-                        op_to_str_slice(&args[FILE_NAME]),\n-                        op_to_u32(&args[START_LINE]),\n-                        op_to_u32(&args[START_COL]),\n-                        op_to_u32(&args[END_LINE]),\n-                        op_to_u32(&args[END_COL]),\n-                    ),\n-                );\n-            }\n-            sym::coverage_unreachable => {\n-                is_codegen_intrinsic = false;\n-                use coverage::coverage_unreachable_args::*;\n-                self.add_unreachable_region(\n-                    caller_instance,\n-                    coverageinfo::Region::new(\n-                        op_to_str_slice(&args[FILE_NAME]),\n-                        op_to_u32(&args[START_LINE]),\n-                        op_to_u32(&args[START_COL]),\n-                        op_to_u32(&args[END_LINE]),\n-                        op_to_u32(&args[END_COL]),\n-                    ),\n-                );\n-            }\n-            _ => {}\n-        }\n-        is_codegen_intrinsic\n-    }\n-\n     fn codegen_intrinsic_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         args: &[OperandRef<'tcx, &'ll Value>],\n         llresult: &'ll Value,\n         span: Span,\n-        caller_instance: ty::Instance<'tcx>,\n     ) {\n         let tcx = self.tcx;\n         let callee_ty = instance.ty(tcx, ty::ParamEnv::reveal_all());\n@@ -213,21 +137,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let llfn = self.get_intrinsic(&(\"llvm.debugtrap\"));\n                 self.call(llfn, &[], None)\n             }\n-            sym::count_code_region => {\n-                use coverage::count_code_region_args::*;\n-                let coverageinfo = tcx.coverageinfo(caller_instance.def_id());\n-\n-                let fn_name = self.create_pgo_func_name_var(caller_instance);\n-                let hash = args[FUNCTION_SOURCE_HASH].immediate();\n-                let num_counters = self.const_u32(coverageinfo.num_counters);\n-                let index = args[COUNTER_ID].immediate();\n-                debug!(\n-                    \"translating Rust intrinsic `count_code_region()` to LLVM intrinsic: \\\n-                    instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n-                    fn_name, hash, num_counters, index,\n-                );\n-                self.instrprof_increment(fn_name, hash, num_counters, index)\n-            }\n             sym::va_start => self.va_start(args[0].immediate()),\n             sym::va_end => self.va_end(args[0].immediate()),\n             sym::va_copy => {\n@@ -2238,15 +2147,3 @@ fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n         _ => None,\n     }\n }\n-\n-fn op_to_str_slice<'tcx>(op: &Operand<'tcx>) -> &'tcx str {\n-    Operand::value_from_const(op).try_to_str_slice().expect(\"Value is &str\")\n-}\n-\n-fn op_to_u32<'tcx>(op: &Operand<'tcx>) -> u32 {\n-    Operand::scalar_from_const(op).to_u32().expect(\"Scalar is u32\")\n-}\n-\n-fn op_to_u64<'tcx>(op: &Operand<'tcx>) -> u64 {\n-    Operand::scalar_from_const(op).to_u64().expect(\"Scalar is u64\")\n-}"}, {"sha": "a266d179a421b6a520c84704efcca52a0ac11fca", "filename": "src/librustc_codegen_ssa/coverageinfo/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fffi.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -1,4 +1,4 @@\n-use super::map::{CounterValueReference, MappedExpressionIndex};\n+use rustc_middle::mir::coverage::{CounterValueReference, MappedExpressionIndex};\n \n /// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L91)\n #[derive(Copy, Clone, Debug)]"}, {"sha": "814e43c5fa5e978ed85805633df533bc9ff388ee", "filename": "src/librustc_codegen_ssa/coverageinfo/map.rs", "status": "modified", "additions": 41, "deletions": 90, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -1,66 +1,19 @@\n pub use super::ffi::*;\n \n use rustc_index::vec::IndexVec;\n+use rustc_middle::mir::coverage::{\n+    CodeRegion, CounterValueReference, ExpressionOperandId, InjectedExpressionIndex,\n+    MappedExpressionIndex, Op,\n+};\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::TyCtxt;\n \n-use std::cmp::Ord;\n-\n-rustc_index::newtype_index! {\n-    pub struct ExpressionOperandId {\n-        DEBUG_FORMAT = \"ExpressionOperandId({})\",\n-        MAX = 0xFFFF_FFFF,\n-    }\n-}\n-\n-rustc_index::newtype_index! {\n-    pub struct CounterValueReference {\n-        DEBUG_FORMAT = \"CounterValueReference({})\",\n-        MAX = 0xFFFF_FFFF,\n-    }\n-}\n-\n-rustc_index::newtype_index! {\n-    pub struct InjectedExpressionIndex {\n-        DEBUG_FORMAT = \"InjectedExpressionIndex({})\",\n-        MAX = 0xFFFF_FFFF,\n-    }\n-}\n-\n-rustc_index::newtype_index! {\n-    pub struct MappedExpressionIndex {\n-        DEBUG_FORMAT = \"MappedExpressionIndex({})\",\n-        MAX = 0xFFFF_FFFF,\n-    }\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct Region<'tcx> {\n-    pub file_name: &'tcx str,\n-    pub start_line: u32,\n-    pub start_col: u32,\n-    pub end_line: u32,\n-    pub end_col: u32,\n-}\n-\n-impl<'tcx> Region<'tcx> {\n-    pub fn new(\n-        file_name: &'tcx str,\n-        start_line: u32,\n-        start_col: u32,\n-        end_line: u32,\n-        end_col: u32,\n-    ) -> Self {\n-        Self { file_name, start_line, start_col, end_line, end_col }\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n-pub struct ExpressionRegion<'tcx> {\n+pub struct ExpressionRegion {\n     lhs: ExpressionOperandId,\n-    op: ExprKind,\n+    op: Op,\n     rhs: ExpressionOperandId,\n-    region: Region<'tcx>,\n+    region: CodeRegion,\n }\n \n /// Collects all of the coverage regions associated with (a) injected counters, (b) counter\n@@ -75,15 +28,15 @@ pub struct ExpressionRegion<'tcx> {\n /// only whitespace or comments). According to LLVM Code Coverage Mapping documentation, \"A count\n /// for a gap area is only used as the line execution count if there are no other regions on a\n /// line.\"\n-pub struct FunctionCoverage<'tcx> {\n+pub struct FunctionCoverage {\n     source_hash: u64,\n-    counters: IndexVec<CounterValueReference, Option<Region<'tcx>>>,\n-    expressions: IndexVec<InjectedExpressionIndex, Option<ExpressionRegion<'tcx>>>,\n-    unreachable_regions: Vec<Region<'tcx>>,\n+    counters: IndexVec<CounterValueReference, Option<CodeRegion>>,\n+    expressions: IndexVec<InjectedExpressionIndex, Option<ExpressionRegion>>,\n+    unreachable_regions: Vec<CodeRegion>,\n }\n \n-impl<'tcx> FunctionCoverage<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n+impl FunctionCoverage {\n+    pub fn new<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n         let coverageinfo = tcx.coverageinfo(instance.def_id());\n         Self {\n             source_hash: 0, // will be set with the first `add_counter()`\n@@ -96,15 +49,13 @@ impl<'tcx> FunctionCoverage<'tcx> {\n     /// Adds a code region to be counted by an injected counter intrinsic.\n     /// The source_hash (computed during coverage instrumentation) should also be provided, and\n     /// should be the same for all counters in a given function.\n-    pub fn add_counter(&mut self, source_hash: u64, id: u32, region: Region<'tcx>) {\n+    pub fn add_counter(&mut self, source_hash: u64, id: CounterValueReference, region: CodeRegion) {\n         if self.source_hash == 0 {\n             self.source_hash = source_hash;\n         } else {\n             debug_assert_eq!(source_hash, self.source_hash);\n         }\n-        self.counters[CounterValueReference::from(id)]\n-            .replace(region)\n-            .expect_none(\"add_counter called with duplicate `id`\");\n+        self.counters[id].replace(region).expect_none(\"add_counter called with duplicate `id`\");\n     }\n \n     /// Both counters and \"counter expressions\" (or simply, \"expressions\") can be operands in other\n@@ -123,24 +74,20 @@ impl<'tcx> FunctionCoverage<'tcx> {\n     /// counters and expressions have been added.\n     pub fn add_counter_expression(\n         &mut self,\n-        id_descending_from_max: u32,\n-        lhs: u32,\n-        op: ExprKind,\n-        rhs: u32,\n-        region: Region<'tcx>,\n+        expression_id: InjectedExpressionIndex,\n+        lhs: ExpressionOperandId,\n+        op: Op,\n+        rhs: ExpressionOperandId,\n+        region: CodeRegion,\n     ) {\n-        let expression_id = ExpressionOperandId::from(id_descending_from_max);\n-        let lhs = ExpressionOperandId::from(lhs);\n-        let rhs = ExpressionOperandId::from(rhs);\n-\n-        let expression_index = self.expression_index(expression_id);\n+        let expression_index = self.expression_index(u32::from(expression_id));\n         self.expressions[expression_index]\n             .replace(ExpressionRegion { lhs, op, rhs, region })\n             .expect_none(\"add_counter_expression called with duplicate `id_descending_from_max`\");\n     }\n \n     /// Add a region that will be marked as \"unreachable\", with a constant \"zero counter\".\n-    pub fn add_unreachable_region(&mut self, region: Region<'tcx>) {\n+    pub fn add_unreachable_region(&mut self, region: CodeRegion) {\n         self.unreachable_regions.push(region)\n     }\n \n@@ -153,9 +100,9 @@ impl<'tcx> FunctionCoverage<'tcx> {\n     /// Generate an array of CounterExpressions, and an iterator over all `Counter`s and their\n     /// associated `Regions` (from which the LLVM-specific `CoverageMapGenerator` will create\n     /// `CounterMappingRegion`s.\n-    pub fn get_expressions_and_counter_regions(\n-        &'tcx self,\n-    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'tcx Region<'tcx>)>) {\n+    pub fn get_expressions_and_counter_regions<'a>(\n+        &'a self,\n+    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'a CodeRegion)>) {\n         assert!(self.source_hash != 0);\n \n         let counter_regions = self.counter_regions();\n@@ -167,7 +114,7 @@ impl<'tcx> FunctionCoverage<'tcx> {\n         (counter_expressions, counter_regions)\n     }\n \n-    fn counter_regions(&'tcx self) -> impl Iterator<Item = (Counter, &'tcx Region<'tcx>)> {\n+    fn counter_regions<'a>(&'a self) -> impl Iterator<Item = (Counter, &'a CodeRegion)> {\n         self.counters.iter_enumerated().filter_map(|(index, entry)| {\n             // Option::map() will return None to filter out missing counters. This may happen\n             // if, for example, a MIR-instrumented counter is removed during an optimization.\n@@ -178,8 +125,8 @@ impl<'tcx> FunctionCoverage<'tcx> {\n     }\n \n     fn expressions_with_regions(\n-        &'tcx self,\n-    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'tcx Region<'tcx>)>) {\n+        &'a self,\n+    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'a CodeRegion)>) {\n         let mut counter_expressions = Vec::with_capacity(self.expressions.len());\n         let mut expression_regions = Vec::with_capacity(self.expressions.len());\n         let mut new_indexes =\n@@ -204,7 +151,7 @@ impl<'tcx> FunctionCoverage<'tcx> {\n                         .as_ref()\n                         .map(|_| Counter::counter_value_reference(index))\n                 } else {\n-                    let index = self.expression_index(id);\n+                    let index = self.expression_index(u32::from(id));\n                     self.expressions\n                         .get(index)\n                         .expect(\"expression id is out of range\")\n@@ -232,23 +179,27 @@ impl<'tcx> FunctionCoverage<'tcx> {\n                 // been assigned a `new_index`.\n                 let mapped_expression_index =\n                     MappedExpressionIndex::from(counter_expressions.len());\n-                counter_expressions.push(CounterExpression::new(lhs_counter, op, rhs_counter));\n+                counter_expressions.push(CounterExpression::new(\n+                    lhs_counter,\n+                    match op {\n+                        Op::Add => ExprKind::Add,\n+                        Op::Subtract => ExprKind::Subtract,\n+                    },\n+                    rhs_counter,\n+                ));\n                 new_indexes[original_index] = mapped_expression_index;\n                 expression_regions.push((Counter::expression(mapped_expression_index), region));\n             }\n         }\n         (counter_expressions, expression_regions.into_iter())\n     }\n \n-    fn unreachable_regions(&'tcx self) -> impl Iterator<Item = (Counter, &'tcx Region<'tcx>)> {\n+    fn unreachable_regions<'a>(&'a self) -> impl Iterator<Item = (Counter, &'a CodeRegion)> {\n         self.unreachable_regions.iter().map(|region| (Counter::zero(), region))\n     }\n \n-    fn expression_index(\n-        &self,\n-        id_descending_from_max: ExpressionOperandId,\n-    ) -> InjectedExpressionIndex {\n-        debug_assert!(id_descending_from_max.index() >= self.counters.len());\n-        InjectedExpressionIndex::from(u32::MAX - u32::from(id_descending_from_max))\n+    fn expression_index(&self, id_descending_from_max: u32) -> InjectedExpressionIndex {\n+        debug_assert!(id_descending_from_max >= self.counters.len() as u32);\n+        InjectedExpressionIndex::from(u32::MAX - id_descending_from_max)\n     }\n }"}, {"sha": "569fd3f1a516d00198685a0f074417df8b80eca1", "filename": "src/librustc_codegen_ssa/coverageinfo/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -1,5 +1,2 @@\n pub mod ffi;\n pub mod map;\n-\n-pub use map::ExprKind;\n-pub use map::Region;"}, {"sha": "a4e039de4df587dcc101a7571afbfc4f876cb15b", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -647,17 +647,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if intrinsic.is_some() && intrinsic != Some(sym::drop_in_place) {\n             let intrinsic = intrinsic.unwrap();\n-\n-            // `is_codegen_intrinsic()` allows the backend implementation to perform compile-time\n-            // operations before converting the `args` to backend values.\n-            if !bx.is_codegen_intrinsic(intrinsic, &args, self.instance) {\n-                // If the intrinsic call was fully addressed by the `is_codegen_intrinsic()` call\n-                // (as a compile-time operation), return immediately. This avoids the need to\n-                // convert the arguments, the call to `codegen_intrinsic_call()`, and the return\n-                // value handling.\n-                return;\n-            }\n-\n             let dest = match ret_dest {\n                 _ if fn_abi.ret.is_indirect() => llargs[0],\n                 ReturnDest::Nothing => {\n@@ -702,7 +691,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 &args,\n                 dest,\n                 terminator.source_info.span,\n-                self.instance,\n             );\n \n             if let ReturnDest::IndirectOperand(dst, _) = ret_dest {"}, {"sha": "a2ad27b925c3472de89a43b9b2e074572842b51a", "filename": "src/librustc_codegen_ssa/mir/coverageinfo.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fcoverageinfo.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -0,0 +1,35 @@\n+use crate::traits::*;\n+\n+use rustc_middle::mir::coverage::*;\n+use rustc_middle::mir::Coverage;\n+\n+use super::FunctionCx;\n+\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    pub fn codegen_coverage(&self, bx: &mut Bx, coverage: Coverage) {\n+        let Coverage { kind, code_region } = coverage;\n+        match kind {\n+            CoverageKind::Counter { function_source_hash, id } => {\n+                bx.add_counter_region(self.instance, function_source_hash, id, code_region);\n+\n+                let coverageinfo = bx.tcx().coverageinfo(self.instance.def_id());\n+\n+                let fn_name = bx.create_pgo_func_name_var(self.instance);\n+                let hash = bx.const_u64(function_source_hash);\n+                let num_counters = bx.const_u32(coverageinfo.num_counters);\n+                let id = bx.const_u32(u32::from(id));\n+                debug!(\n+                    \"codegen intrinsic instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n+                    fn_name, hash, num_counters, id,\n+                );\n+                bx.instrprof_increment(fn_name, hash, num_counters, id);\n+            }\n+            CoverageKind::Expression { id, lhs, op, rhs } => {\n+                bx.add_counter_expression_region(self.instance, id, lhs, op, rhs, code_region);\n+            }\n+            CoverageKind::Unreachable => {\n+                bx.add_unreachable_region(self.instance, code_region);\n+            }\n+        }\n+    }\n+}"}, {"sha": "26e6c3547026850b4e25c0a4ce38f728958f26ae", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -484,6 +484,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n mod analyze;\n mod block;\n pub mod constant;\n+pub mod coverageinfo;\n pub mod debuginfo;\n pub mod operand;\n pub mod place;"}, {"sha": "6f74ba77d4c1670dea1921909f81d18cef250a9e", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -111,6 +111,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n                 bx\n             }\n+            mir::StatementKind::Coverage(box ref coverage) => {\n+                self.codegen_coverage(&mut bx, coverage.clone());\n+                bx\n+            }\n             mir::StatementKind::FakeRead(..)\n             | mir::StatementKind::Retag { .. }\n             | mir::StatementKind::AscribeUserType(..)"}, {"sha": "5ffc83c5f99a85a691c57bd014c63f66018c6293", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -271,7 +271,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n         hash: Self::Value,\n         num_counters: Self::Value,\n         index: Self::Value,\n-    ) -> Self::Value;\n+    );\n \n     fn call(\n         &mut self,"}, {"sha": "b74e4e459016fb30ff42ed2096e69e3e56e59a48", "filename": "src/librustc_codegen_ssa/traits/coverageinfo.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -1,5 +1,5 @@\n use super::BackendTypes;\n-use crate::coverageinfo::{ExprKind, Region};\n+use rustc_middle::mir::coverage::*;\n use rustc_middle::ty::Instance;\n \n pub trait CoverageInfoMethods: BackendTypes {\n@@ -13,19 +13,19 @@ pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n         &mut self,\n         instance: Instance<'tcx>,\n         function_source_hash: u64,\n-        index: u32,\n-        region: Region<'tcx>,\n+        id: CounterValueReference,\n+        region: CodeRegion,\n     );\n \n     fn add_counter_expression_region(\n         &mut self,\n         instance: Instance<'tcx>,\n-        index: u32,\n-        lhs: u32,\n-        op: ExprKind,\n-        rhs: u32,\n-        region: Region<'tcx>,\n+        id: InjectedExpressionIndex,\n+        lhs: ExpressionOperandId,\n+        op: Op,\n+        rhs: ExpressionOperandId,\n+        region: CodeRegion,\n     );\n \n-    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: Region<'tcx>);\n+    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion);\n }"}, {"sha": "9d48e233de6558f251629bdf04641277ebfd61ff", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -1,8 +1,7 @@\n use super::BackendTypes;\n use crate::mir::operand::OperandRef;\n-use rustc_middle::mir::Operand;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::{Span, Symbol};\n+use rustc_span::Span;\n use rustc_target::abi::call::FnAbi;\n \n pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n@@ -16,19 +15,8 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n         args: &[OperandRef<'tcx, Self::Value>],\n         llresult: Self::Value,\n         span: Span,\n-        caller_instance: ty::Instance<'tcx>,\n     );\n \n-    /// Intrinsic-specific pre-codegen processing, if any is required. Some intrinsics are handled\n-    /// at compile time and do not generate code. Returns true if codegen is required or false if\n-    /// the intrinsic does not need code generation.\n-    fn is_codegen_intrinsic(\n-        &mut self,\n-        intrinsic: Symbol,\n-        args: &Vec<Operand<'tcx>>,\n-        caller_instance: ty::Instance<'tcx>,\n-    ) -> bool;\n-\n     fn abort(&mut self);\n     fn assume(&mut self, val: Self::Value);\n     fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value;"}, {"sha": "91db58054b61fde3e8a5d8b497d4a07b8a32b109", "filename": "src/librustc_hir/fake_lang_items.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/32c654a9795b0d88541e56ba9da4150e34f1d5f9/src%2Flibrustc_hir%2Ffake_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c654a9795b0d88541e56ba9da4150e34f1d5f9/src%2Flibrustc_hir%2Ffake_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Ffake_lang_items.rs?ref=32c654a9795b0d88541e56ba9da4150e34f1d5f9", "patch": "@@ -1,37 +0,0 @@\n-//! Validity checking for fake lang items\n-\n-use crate::def_id::DefId;\n-use crate::{lang_items, LangItem, LanguageItems};\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_span::symbol::{sym, Symbol};\n-\n-use lazy_static::lazy_static;\n-\n-macro_rules! fake_lang_items {\n-    ($($item:ident, $name:ident, $method:ident;)*) => (\n-\n-lazy_static! {\n-    pub static ref FAKE_ITEMS_REFS: FxHashMap<Symbol, LangItem> = {\n-        let mut map = FxHashMap::default();\n-        $(map.insert(sym::$name, lang_items::$item);)*\n-        map\n-    };\n-}\n-\n-impl LanguageItems {\n-    pub fn is_fake_lang_item(&self, item_def_id: DefId) -> bool {\n-        let did = Some(item_def_id);\n-\n-        $(self.$method() == did)||*\n-    }\n-}\n-\n-) }\n-\n-fake_lang_items! {\n-//  Variant name,                      Symbol,                    Method name,\n-    CountCodeRegionFnLangItem,         count_code_region,         count_code_region_fn;\n-    CoverageCounterAddFnLangItem,      coverage_counter_add,      coverage_counter_add_fn;\n-    CoverageCounterSubtractFnLangItem, coverage_counter_subtract, coverage_counter_subtract_fn;\n-}"}, {"sha": "978f73760ecb5e6eb1cc74e7789acaa527f4947b", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -303,11 +303,6 @@ language_item_table! {\n \n     TryTraitLangItem,              kw::Try,                 try_trait,               Target::Trait;\n \n-    // language items related to source code coverage instrumentation (-Zinstrument-coverage)\n-    CountCodeRegionFnLangItem,         sym::count_code_region,         count_code_region_fn,         Target::Fn;\n-    CoverageCounterAddFnLangItem,      sym::coverage_counter_add,      coverage_counter_add_fn,      Target::Fn;\n-    CoverageCounterSubtractFnLangItem, sym::coverage_counter_subtract, coverage_counter_subtract_fn, Target::Fn;\n-\n     // Language items from AST lowering\n     TryFromError,                  sym::from_error,         from_error_fn,           Target::Method(MethodKind::Trait { body: false });\n     TryFromOk,                     sym::from_ok,            from_ok_fn,              Target::Method(MethodKind::Trait { body: false });"}, {"sha": "19ea1de5683f6d623e2e2339077c6217f12c8f64", "filename": "src/librustc_hir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_hir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_hir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flib.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -19,7 +19,6 @@ mod arena;\n pub mod def;\n pub mod definitions;\n pub use rustc_span::def_id;\n-pub mod fake_lang_items;\n mod hir;\n pub mod hir_id;\n pub mod intravisit;"}, {"sha": "ce311c2ee52bd5793f4eca30f28add1da4ae21ba", "filename": "src/librustc_middle/mir/coverage/mod.rs", "status": "modified", "additions": 102, "deletions": 31, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -1,34 +1,105 @@\n //! Metadata from source code coverage analysis and instrumentation.\n \n-/// Positional arguments to `libcore::count_code_region()`\n-pub mod count_code_region_args {\n-    pub const FUNCTION_SOURCE_HASH: usize = 0;\n-    pub const COUNTER_ID: usize = 1;\n-    pub const FILE_NAME: usize = 2;\n-    pub const START_LINE: usize = 3;\n-    pub const START_COL: usize = 4;\n-    pub const END_LINE: usize = 5;\n-    pub const END_COL: usize = 6;\n-}\n-\n-/// Positional arguments to `libcore::coverage_counter_add()` and\n-/// `libcore::coverage_counter_subtract()`\n-pub mod coverage_counter_expression_args {\n-    pub const EXPRESSION_ID: usize = 0;\n-    pub const LEFT_ID: usize = 1;\n-    pub const RIGHT_ID: usize = 2;\n-    pub const FILE_NAME: usize = 3;\n-    pub const START_LINE: usize = 4;\n-    pub const START_COL: usize = 5;\n-    pub const END_LINE: usize = 6;\n-    pub const END_COL: usize = 7;\n-}\n-\n-/// Positional arguments to `libcore::coverage_unreachable()`\n-pub mod coverage_unreachable_args {\n-    pub const FILE_NAME: usize = 0;\n-    pub const START_LINE: usize = 1;\n-    pub const START_COL: usize = 2;\n-    pub const END_LINE: usize = 3;\n-    pub const END_COL: usize = 4;\n+use rustc_macros::HashStable;\n+use rustc_span::Symbol;\n+\n+use std::cmp::Ord;\n+use std::fmt::{self, Debug, Formatter};\n+\n+rustc_index::newtype_index! {\n+    pub struct ExpressionOperandId {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"ExpressionOperandId({})\",\n+        MAX = 0xFFFF_FFFF,\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct CounterValueReference {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"CounterValueReference({})\",\n+        MAX = 0xFFFF_FFFF,\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct InjectedExpressionIndex {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"InjectedExpressionIndex({})\",\n+        MAX = 0xFFFF_FFFF,\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct MappedExpressionIndex {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"MappedExpressionIndex({})\",\n+        MAX = 0xFFFF_FFFF,\n+    }\n+}\n+\n+impl From<CounterValueReference> for ExpressionOperandId {\n+    #[inline]\n+    fn from(v: CounterValueReference) -> ExpressionOperandId {\n+        ExpressionOperandId::from(v.as_u32())\n+    }\n+}\n+\n+impl From<InjectedExpressionIndex> for ExpressionOperandId {\n+    #[inline]\n+    fn from(v: InjectedExpressionIndex) -> ExpressionOperandId {\n+        ExpressionOperandId::from(v.as_u32())\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n+pub enum CoverageKind {\n+    Counter {\n+        function_source_hash: u64,\n+        id: CounterValueReference,\n+    },\n+    Expression {\n+        id: InjectedExpressionIndex,\n+        lhs: ExpressionOperandId,\n+        op: Op,\n+        rhs: ExpressionOperandId,\n+    },\n+    Unreachable,\n+}\n+\n+impl CoverageKind {\n+    pub fn as_operand_id(&self) -> ExpressionOperandId {\n+        match *self {\n+            CoverageKind::Counter { id, .. } => ExpressionOperandId::from(id),\n+            CoverageKind::Expression { id, .. } => ExpressionOperandId::from(id),\n+            CoverageKind::Unreachable => {\n+                bug!(\"Unreachable coverage cannot be part of an expression\")\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct CodeRegion {\n+    pub file_name: Symbol,\n+    pub start_line: u32,\n+    pub start_col: u32,\n+    pub end_line: u32,\n+    pub end_col: u32,\n+}\n+\n+impl Debug for CodeRegion {\n+    fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n+        write!(\n+            fmt,\n+            \"{}:{}:{} - {}:{}\",\n+            self.file_name, self.start_line, self.start_col, self.end_line, self.end_col\n+        )\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n+pub enum Op {\n+    Subtract,\n+    Add,\n }"}, {"sha": "9cce8ee2c5d2174fc9e68ac8c40fe5b31c8e07d7", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -2,6 +2,7 @@\n //!\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/index.html\n \n+use crate::mir::coverage::{CodeRegion, CoverageKind};\n use crate::mir::interpret::{Allocation, ConstValue, GlobalAlloc, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n@@ -25,7 +26,6 @@ use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::graph::{self, GraphSuccessors};\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_macros::HashStable;\n use rustc_serialize::{Decodable, Encodable};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n@@ -1400,6 +1400,12 @@ pub enum StatementKind<'tcx> {\n     /// - `Bivariant` -- no effect\n     AscribeUserType(Box<(Place<'tcx>, UserTypeProjection)>, ty::Variance),\n \n+    /// Marks the start of a \"coverage region\", injected with '-Zinstrument-coverage'. A\n+    /// `CoverageInfo` statement carries metadata about the coverage region, used to inject a coverage\n+    /// map into the binary. The `Counter` kind also generates executable code, to increment a\n+    /// counter varible at runtime, each time the code region is executed.\n+    Coverage(Box<Coverage>),\n+\n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n }\n@@ -1495,11 +1501,18 @@ impl Debug for Statement<'_> {\n             AscribeUserType(box (ref place, ref c_ty), ref variance) => {\n                 write!(fmt, \"AscribeUserType({:?}, {:?}, {:?})\", place, variance, c_ty)\n             }\n+            Coverage(box ref coverage) => write!(fmt, \"{:?}\", coverage),\n             Nop => write!(fmt, \"nop\"),\n         }\n     }\n }\n \n+#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n+pub struct Coverage {\n+    pub kind: CoverageKind,\n+    pub code_region: CodeRegion,\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Places\n "}, {"sha": "6515ae31b46ff2a0209db38420a9365868a6bb2d", "filename": "src/librustc_middle/mir/visit.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fvisit.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -134,6 +134,12 @@ macro_rules! make_mir_visitor {\n                 self.super_ascribe_user_ty(place, variance, user_ty, location);\n             }\n \n+            fn visit_coverage(&mut self,\n+                              coverage: & $($mutability)? Coverage,\n+                              location: Location) {\n+                self.super_coverage(coverage, location);\n+            }\n+\n             fn visit_retag(&mut self,\n                            kind: & $($mutability)? RetagKind,\n                            place: & $($mutability)? Place<'tcx>,\n@@ -389,6 +395,12 @@ macro_rules! make_mir_visitor {\n                     ) => {\n                         self.visit_ascribe_user_ty(place, variance, user_ty, location);\n                     }\n+                    StatementKind::Coverage(coverage) => {\n+                        self.visit_coverage(\n+                            coverage,\n+                            location\n+                        )\n+                    }\n                     StatementKind::Nop => {}\n                 }\n             }\n@@ -739,6 +751,11 @@ macro_rules! make_mir_visitor {\n                 self.visit_user_type_projection(user_ty);\n             }\n \n+            fn super_coverage(&mut self,\n+                              _kind: & $($mutability)? Coverage,\n+                              _location: Location) {\n+            }\n+\n             fn super_retag(&mut self,\n                            _kind: & $($mutability)? RetagKind,\n                            place: & $($mutability)? Place<'tcx>,\n@@ -1133,6 +1150,8 @@ pub enum NonUseContext {\n     StorageDead,\n     /// User type annotation assertions for NLL.\n     AscribeUserTy,\n+    /// Coverage code region and counter metadata.\n+    Coverage,\n     /// The data of an user variable, for debug info.\n     VarDebugInfo,\n }"}, {"sha": "605e3545dea7812bcfb4367592c777fae11646cb", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -271,6 +271,7 @@ CloneTypeFoldableAndLiftImpls! {\n     bool,\n     usize,\n     ::rustc_target::abi::VariantIdx,\n+    u32,\n     u64,\n     String,\n     crate::middle::region::Scope,\n@@ -289,6 +290,10 @@ CloneTypeFoldableAndLiftImpls! {\n     ::rustc_hir::Unsafety,\n     ::rustc_target::asm::InlineAsmRegOrRegClass,\n     ::rustc_target::spec::abi::Abi,\n+    crate::mir::coverage::ExpressionOperandId,\n+    crate::mir::coverage::CounterValueReference,\n+    crate::mir::coverage::InjectedExpressionIndex,\n+    crate::mir::coverage::MappedExpressionIndex,\n     crate::mir::Local,\n     crate::mir::Promoted,\n     crate::traits::Reveal,"}, {"sha": "6574e584406f0da8b076131a59b88c1c54d9c018", "filename": "src/librustc_mir/borrow_check/def_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fborrow_check%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fborrow_check%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdef_use.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -72,7 +72,8 @@ pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n         PlaceContext::MutatingUse(MutatingUseContext::Drop) =>\n             Some(DefUse::Drop),\n \n-        // Debug info is neither def nor use.\n+        // Coverage and debug info are neither def nor use.\n+        PlaceContext::NonUse(NonUseContext::Coverage) |\n         PlaceContext::NonUse(NonUseContext::VarDebugInfo) => None,\n     }\n }"}, {"sha": "c84ccafaff5b86e372b45fbce39cf287db053e91", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -93,6 +93,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 }\n             }\n             StatementKind::Nop\n+            | StatementKind::Coverage(..)\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Retag { .. }\n             | StatementKind::StorageLive(..) => {"}, {"sha": "9a28321a6cc364cacb10b6c00de07e8b8a44eb9c", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -644,6 +644,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 }\n             }\n             StatementKind::Nop\n+            | StatementKind::Coverage(..)\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Retag { .. }\n             | StatementKind::StorageLive(..) => {"}, {"sha": "168a352591d0e12b400ff93bede87ef594513303", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -1532,6 +1532,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             | StatementKind::StorageDead(..)\n             | StatementKind::LlvmInlineAsm { .. }\n             | StatementKind::Retag { .. }\n+            | StatementKind::Coverage(..)\n             | StatementKind::Nop => {}\n         }\n     }"}, {"sha": "aeb7ffe3e3b8dde555b4ba63a12b9ff0b6b4a9bc", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -302,6 +302,7 @@ impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n             | mir::StatementKind::StorageLive(..)\n             | mir::StatementKind::Retag { .. }\n             | mir::StatementKind::AscribeUserType(..)\n+            | mir::StatementKind::Coverage(..)\n             | mir::StatementKind::Nop => {}\n         }\n     }"}, {"sha": "0e7cd1bb0e45bf782f51e723db088130cae8213e", "filename": "src/librustc_mir/dataflow/impls/init_locals.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Finit_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Finit_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Finit_locals.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -99,6 +99,7 @@ where\n             PlaceContext::NonUse(\n                 NonUseContext::StorageLive\n                 | NonUseContext::AscribeUserTy\n+                | NonUseContext::Coverage\n                 | NonUseContext::VarDebugInfo,\n             )\n             | PlaceContext::NonMutatingUse("}, {"sha": "21623e3cad5876666848482edaf48bea14996929", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -145,6 +145,7 @@ impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir,\n             // Nothing to do for these. Match exhaustively so this fails to compile when new\n             // variants are added.\n             StatementKind::AscribeUserType(..)\n+            | StatementKind::Coverage(..)\n             | StatementKind::FakeRead(..)\n             | StatementKind::Nop\n             | StatementKind::Retag(..)"}, {"sha": "e567063e0d5997db17e1a194c97972e73fae3799", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -318,6 +318,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             }\n             StatementKind::Retag { .. }\n             | StatementKind::AscribeUserType(..)\n+            | StatementKind::Coverage(..)\n             | StatementKind::Nop => {}\n         }\n     }"}, {"sha": "b37dcd42f4c7114c984c7bd9bf9edfc604aa1dc6", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -440,11 +440,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // These just return their argument\n                 self.copy_op(args[0], dest)?;\n             }\n-            // FIXME(#73156): Handle source code coverage in const eval\n-            sym::count_code_region\n-            | sym::coverage_counter_add\n-            | sym::coverage_counter_subtract\n-            | sym::coverage_unreachable => (),\n             _ => return Ok(false),\n         }\n "}, {"sha": "156da84f2910ad3a6e3c37f4d1e7da15abb35df0", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -118,6 +118,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Statements we do not track.\n             AscribeUserType(..) => {}\n \n+            // Currently, Miri discards Coverage statements. Coverage statements are only injected\n+            // via an optional compile time MIR pass and have no side effects. Since Coverage\n+            // statements don't exist at the source level, it is safe for Miri to ignore them, even\n+            // for undefined behavior (UB) checks.\n+            //\n+            // A coverage counter inside a const expression (for example, a counter injected in a\n+            // const function) is discarded when the const is evaluated at compile time. Whether\n+            // this should change, and/or how to implement a const eval counter, is a subject of the\n+            // following issue:\n+            //\n+            // FIXME(#73156): Handle source code coverage in const eval\n+            Coverage(..) => {}\n+\n             // Defined to do nothing. These are added by optimization passes, to avoid changing the\n             // size of MIR constantly.\n             Nop => {}"}, {"sha": "4812ef5a89455a19496c233f932daa0b1134ca7f", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -485,6 +485,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n             | StatementKind::StorageDead(_)\n             | StatementKind::Retag { .. }\n             | StatementKind::AscribeUserType(..)\n+            | StatementKind::Coverage(..)\n             | StatementKind::Nop => {}\n         }\n     }"}, {"sha": "c3e04e698dbade569ee59df9f65158c6f8bdd5ba", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -114,6 +114,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             | StatementKind::StorageDead(..)\n             | StatementKind::Retag { .. }\n             | StatementKind::AscribeUserType(..)\n+            | StatementKind::Coverage(..)\n             | StatementKind::Nop => {\n                 // safe (at least as emitted during MIR construction)\n             }"}, {"sha": "52c5f4e25cf6caa90269772c2a2045ab07bc838c", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -1443,6 +1443,7 @@ impl Visitor<'tcx> for EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n             | StatementKind::StorageDead(_)\n             | StatementKind::Retag(..)\n             | StatementKind::AscribeUserType(..)\n+            | StatementKind::Coverage(..)\n             | StatementKind::Nop => {}\n         }\n     }"}, {"sha": "f60e6da714a657a0063d431327797ed076513850", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 99, "deletions": 279, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -1,23 +1,16 @@\n use crate::transform::{MirPass, MirSource};\n-use crate::util::patch::MirPatch;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_hir::lang_items;\n use rustc_middle::hir;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::mir;\n use rustc_middle::mir::coverage::*;\n-use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::mir::traversal;\n-use rustc_middle::mir::{\n-    BasicBlock, BasicBlockData, CoverageInfo, Operand, Place, SourceInfo, SourceScope,\n-    StatementKind, Terminator, TerminatorKind,\n-};\n-use rustc_middle::ty;\n+use rustc_middle::mir::visit::Visitor;\n+use rustc_middle::mir::{BasicBlock, Coverage, CoverageInfo, Location, Statement, StatementKind};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{FnDef, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::DefId;\n-use rustc_span::{FileName, Pos, RealFileName, Span};\n+use rustc_span::{FileName, Pos, RealFileName, Span, Symbol};\n \n /// Inserts call to count_code_region() as a placeholder to be replaced during code generation with\n /// the intrinsic llvm.instrprof.increment.\n@@ -29,16 +22,29 @@ pub(crate) fn provide(providers: &mut Providers) {\n     providers.coverageinfo = |tcx, def_id| coverageinfo_from_mir(tcx, def_id);\n }\n \n+struct CoverageVisitor {\n+    info: CoverageInfo,\n+}\n+\n+impl Visitor<'_> for CoverageVisitor {\n+    fn visit_coverage(&mut self, coverage: &Coverage, _location: Location) {\n+        match coverage.kind {\n+            CoverageKind::Counter { id, .. } => {\n+                let counter_id = u32::from(id);\n+                self.info.num_counters = std::cmp::max(self.info.num_counters, counter_id + 1);\n+            }\n+            CoverageKind::Expression { id, .. } => {\n+                let expression_index = u32::MAX - u32::from(id);\n+                self.info.num_expressions =\n+                    std::cmp::max(self.info.num_expressions, expression_index + 1);\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, mir_def_id: DefId) -> CoverageInfo {\n     let mir_body = tcx.optimized_mir(mir_def_id);\n-    // FIXME(richkadel): The current implementation assumes the MIR for the given DefId\n-    // represents a single function. Validate and/or correct if inlining (which should be disabled\n-    // if -Zinstrument-coverage is enabled) and/or monomorphization invalidates these assumptions.\n-    let count_code_region_fn = tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None);\n-    let coverage_counter_add_fn =\n-        tcx.require_lang_item(lang_items::CoverageCounterAddFnLangItem, None);\n-    let coverage_counter_subtract_fn =\n-        tcx.require_lang_item(lang_items::CoverageCounterSubtractFnLangItem, None);\n \n     // The `num_counters` argument to `llvm.instrprof.increment` is the number of injected\n     // counters, with each counter having a counter ID from `0..num_counters-1`. MIR optimization\n@@ -49,49 +55,11 @@ fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, mir_def_id: DefId) -> Coverage\n     // `num_expressions` is the number of counter expressions added to the MIR body. Both\n     // `num_counters` and `num_expressions` are used to initialize new vectors, during backend\n     // code generate, to lookup counters and expressions by simple u32 indexes.\n-    let mut num_counters: u32 = 0;\n-    let mut num_expressions: u32 = 0;\n-    for terminator in\n-        traversal::preorder(mir_body).map(|(_, data)| data).filter_map(call_terminators)\n-    {\n-        if let TerminatorKind::Call { func: Operand::Constant(func), args, .. } = &terminator.kind {\n-            match func.literal.ty.kind {\n-                FnDef(id, _) if id == count_code_region_fn => {\n-                    let counter_id_arg =\n-                        args.get(count_code_region_args::COUNTER_ID).expect(\"arg found\");\n-                    let counter_id = mir::Operand::scalar_from_const(counter_id_arg)\n-                        .to_u32()\n-                        .expect(\"counter_id arg is u32\");\n-                    num_counters = std::cmp::max(num_counters, counter_id + 1);\n-                }\n-                FnDef(id, _)\n-                    if id == coverage_counter_add_fn || id == coverage_counter_subtract_fn =>\n-                {\n-                    let expression_id_arg = args\n-                        .get(coverage_counter_expression_args::EXPRESSION_ID)\n-                        .expect(\"arg found\");\n-                    let id_descending_from_max = mir::Operand::scalar_from_const(expression_id_arg)\n-                        .to_u32()\n-                        .expect(\"expression_id arg is u32\");\n-                    // Counter expressions are initially assigned IDs descending from `u32::MAX`, so\n-                    // the range of expression IDs is disjoint from the range of counter IDs. This\n-                    // way, both counters and expressions can be operands in other expressions.\n-                    let expression_index = u32::MAX - id_descending_from_max;\n-                    num_expressions = std::cmp::max(num_expressions, expression_index + 1);\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-    CoverageInfo { num_counters, num_expressions }\n-}\n+    let mut coverage_visitor =\n+        CoverageVisitor { info: CoverageInfo { num_counters: 0, num_expressions: 0 } };\n \n-fn call_terminators(data: &'tcx BasicBlockData<'tcx>) -> Option<&'tcx Terminator<'tcx>> {\n-    let terminator = data.terminator();\n-    match terminator.kind {\n-        TerminatorKind::Call { .. } => Some(terminator),\n-        _ => None,\n-    }\n+    coverage_visitor.visit_body(mir_body);\n+    coverage_visitor.info\n }\n \n impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n@@ -104,19 +72,6 @@ impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n     }\n }\n \n-/// Distinguishes the expression operators.\n-enum Op {\n-    Add,\n-    Subtract,\n-}\n-\n-struct InjectedCall<'tcx> {\n-    func: Operand<'tcx>,\n-    args: Vec<Operand<'tcx>>,\n-    span: Span,\n-    inject_at: Span,\n-}\n-\n struct Instrumentor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     mir_def_id: DefId,\n@@ -143,21 +98,21 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n     }\n \n     /// Counter IDs start from zero and go up.\n-    fn next_counter(&mut self) -> u32 {\n+    fn next_counter(&mut self) -> CounterValueReference {\n         assert!(self.num_counters < u32::MAX - self.num_expressions);\n         let next = self.num_counters;\n         self.num_counters += 1;\n-        next\n+        CounterValueReference::from(next)\n     }\n \n     /// Expression IDs start from u32::MAX and go down because a CounterExpression can reference\n     /// (add or subtract counts) of both Counter regions and CounterExpression regions. The counter\n     /// expression operand IDs must be unique across both types.\n-    fn next_expression(&mut self) -> u32 {\n+    fn next_expression(&mut self) -> InjectedExpressionIndex {\n         assert!(self.num_counters < u32::MAX - self.num_expressions);\n         let next = u32::MAX - self.num_expressions;\n         self.num_expressions += 1;\n-        next\n+        InjectedExpressionIndex::from(next)\n     }\n \n     fn function_source_hash(&mut self) -> u64 {\n@@ -172,24 +127,14 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n     }\n \n     fn inject_counters(&mut self) {\n-        let mir_body = &self.mir_body;\n         let body_span = self.hir_body.value.span;\n         debug!(\"instrumenting {:?}, span: {:?}\", self.mir_def_id, body_span);\n \n         // FIXME(richkadel): As a first step, counters are only injected at the top of each\n         // function. The complete solution will inject counters at each conditional code branch.\n-        let _ignore = mir_body;\n-        let id = self.next_counter();\n-        let function_source_hash = self.function_source_hash();\n-        let scope = rustc_middle::mir::OUTERMOST_SOURCE_SCOPE;\n-        let is_cleanup = false;\n-        let next_block = rustc_middle::mir::START_BLOCK;\n-        self.inject_call(\n-            self.make_counter(id, function_source_hash, body_span),\n-            scope,\n-            is_cleanup,\n-            next_block,\n-        );\n+        let block = rustc_middle::mir::START_BLOCK;\n+        let counter = self.make_counter();\n+        self.inject_statement(counter, body_span, block);\n \n         // FIXME(richkadel): The next step to implement source based coverage analysis will be\n         // instrumenting branches within functions, and some regions will be counted by \"counter\n@@ -198,211 +143,86 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         let fake_use = false;\n         if fake_use {\n             let add = false;\n-            let lhs = 1;\n+            let fake_counter = CoverageKind::Counter {\n+                function_source_hash: self.function_source_hash(),\n+                id: CounterValueReference::from_u32(1),\n+            };\n+            let fake_expression = CoverageKind::Expression {\n+                id: InjectedExpressionIndex::from(u32::MAX - 1),\n+                lhs: ExpressionOperandId::from_u32(1),\n+                op: Op::Add,\n+                rhs: ExpressionOperandId::from_u32(2),\n+            };\n+\n+            let lhs = fake_counter.as_operand_id();\n             let op = if add { Op::Add } else { Op::Subtract };\n-            let rhs = 2;\n+            let rhs = fake_expression.as_operand_id();\n \n-            let scope = rustc_middle::mir::OUTERMOST_SOURCE_SCOPE;\n-            let is_cleanup = false;\n-            let next_block = rustc_middle::mir::START_BLOCK;\n+            let block = rustc_middle::mir::START_BLOCK;\n \n-            let id = self.next_expression();\n-            self.inject_call(\n-                self.make_expression(id, body_span, lhs, op, rhs),\n-                scope,\n-                is_cleanup,\n-                next_block,\n-            );\n+            let expression = self.make_expression(lhs, op, rhs);\n+            self.inject_statement(expression, body_span, block);\n         }\n     }\n \n-    fn make_counter(&self, id: u32, function_source_hash: u64, span: Span) -> InjectedCall<'tcx> {\n-        let inject_at = span.shrink_to_lo();\n-\n-        let func = function_handle(\n-            self.tcx,\n-            self.tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None),\n-            inject_at,\n-        );\n-\n-        let mut args = Vec::new();\n-\n-        use count_code_region_args::*;\n-        debug_assert_eq!(FUNCTION_SOURCE_HASH, args.len());\n-        args.push(self.const_u64(function_source_hash, inject_at));\n-\n-        debug_assert_eq!(COUNTER_ID, args.len());\n-        args.push(self.const_u32(id, inject_at));\n-\n-        InjectedCall { func, args, span, inject_at }\n+    fn make_counter(&mut self) -> CoverageKind {\n+        CoverageKind::Counter {\n+            function_source_hash: self.function_source_hash(),\n+            id: self.next_counter(),\n+        }\n     }\n \n     fn make_expression(\n-        &self,\n-        id: u32,\n-        span: Span,\n-        lhs: u32,\n+        &mut self,\n+        lhs: ExpressionOperandId,\n         op: Op,\n-        rhs: u32,\n-    ) -> InjectedCall<'tcx> {\n-        let inject_at = span.shrink_to_lo();\n-\n-        let func = function_handle(\n-            self.tcx,\n-            self.tcx.require_lang_item(\n-                match op {\n-                    Op::Add => lang_items::CoverageCounterAddFnLangItem,\n-                    Op::Subtract => lang_items::CoverageCounterSubtractFnLangItem,\n-                },\n-                None,\n-            ),\n-            inject_at,\n-        );\n-\n-        let mut args = Vec::new();\n-\n-        use coverage_counter_expression_args::*;\n-        debug_assert_eq!(EXPRESSION_ID, args.len());\n-        args.push(self.const_u32(id, inject_at));\n-\n-        debug_assert_eq!(LEFT_ID, args.len());\n-        args.push(self.const_u32(lhs, inject_at));\n-\n-        debug_assert_eq!(RIGHT_ID, args.len());\n-        args.push(self.const_u32(rhs, inject_at));\n-\n-        InjectedCall { func, args, span, inject_at }\n+        rhs: ExpressionOperandId,\n+    ) -> CoverageKind {\n+        CoverageKind::Expression { id: self.next_expression(), lhs, op, rhs }\n     }\n \n-    fn inject_call(\n-        &mut self,\n-        call: InjectedCall<'tcx>,\n-        scope: SourceScope,\n-        is_cleanup: bool,\n-        next_block: BasicBlock,\n-    ) {\n-        let InjectedCall { func, mut args, span, inject_at } = call;\n-        debug!(\n-            \"  injecting {}call to {:?}({:?}) at: {:?}, scope: {:?}\",\n-            if is_cleanup { \"cleanup \" } else { \"\" },\n-            func,\n-            args,\n-            inject_at,\n-            scope,\n-        );\n-\n-        let mut patch = MirPatch::new(self.mir_body);\n-\n-        let (file_name, start_line, start_col, end_line, end_col) = self.code_region(&span);\n-\n-        // FIXME(richkadel): Note that `const_str()` results in the creation of an `Allocation` to\n-        // hold one copy of each unique filename. It looks like that `Allocation` may translate into\n-        // the creation of an `@alloc` in LLVM IR that is never actually used by runtime code.\n-        //\n-        // Example LLVM IR:\n-        //\n-        // @alloc4 = private unnamed_addr constant <{ [43 x i8] }> \\\n-        //   <{ [43 x i8] c\"C:\\\\msys64\\\\home\\\\richkadel\\\\rust\\\\rust_basic.rs\" }>, align 1\n-        //\n-        // Can I flag the alloc as something not to be added to codegen? Or somehow remove it before\n-        // it gets added to the LLVM IR? Do we need some kind of reference counting to know it's\n-        // not used by any runtime code?\n-        //\n-        // This question is moot if I convert the Call Terminators to Statements, I believe:\n-        // https://rust-lang.zulipchat.com/#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Implement.20LLVM-compatible.20source-based.20cod.20compiler-team.23278/near/206731748\n-        args.push(self.const_str(&file_name, inject_at));\n-        args.push(self.const_u32(start_line, inject_at));\n-        args.push(self.const_u32(start_col, inject_at));\n-        args.push(self.const_u32(end_line, inject_at));\n-        args.push(self.const_u32(end_col, inject_at));\n-\n-        let temp = patch.new_temp(self.tcx.mk_unit(), inject_at);\n-        let new_block = patch.new_block(placeholder_block(inject_at, scope, is_cleanup));\n-        patch.patch_terminator(\n-            new_block,\n-            TerminatorKind::Call {\n-                func,\n-                args,\n-                // new_block will swapped with the next_block, after applying patch\n-                destination: Some((Place::from(temp), new_block)),\n-                cleanup: None,\n-                from_hir_call: false,\n-                fn_span: inject_at,\n-            },\n-        );\n-\n-        patch.add_statement(new_block.start_location(), StatementKind::StorageLive(temp));\n-        patch.add_statement(next_block.start_location(), StatementKind::StorageDead(temp));\n-\n-        patch.apply(self.mir_body);\n-\n-        // To insert the `new_block` in front of the first block in the counted branch (the\n-        // `next_block`), just swap the indexes, leaving the rest of the graph unchanged.\n-        self.mir_body.basic_blocks_mut().swap(next_block, new_block);\n-    }\n+    fn inject_statement(&mut self, coverage_kind: CoverageKind, span: Span, block: BasicBlock) {\n+        let code_region = make_code_region(self.tcx, &span);\n+        debug!(\"  injecting statement {:?} covering {:?}\", coverage_kind, code_region);\n \n-    /// Convert the Span into its file name, start line and column, and end line and column\n-    fn code_region(&self, span: &Span) -> (String, u32, u32, u32, u32) {\n-        let source_map = self.tcx.sess.source_map();\n-        let start = source_map.lookup_char_pos(span.lo());\n-        let end = if span.hi() == span.lo() {\n-            start.clone()\n-        } else {\n-            let end = source_map.lookup_char_pos(span.hi());\n-            debug_assert_eq!(\n-                start.file.name,\n-                end.file.name,\n-                \"Region start ({:?} -> {:?}) and end ({:?} -> {:?}) don't come from the same source file!\",\n-                span.lo(),\n-                start,\n-                span.hi(),\n-                end\n-            );\n-            end\n+        let data = &mut self.mir_body[block];\n+        let source_info = data.terminator().source_info;\n+        let statement = Statement {\n+            source_info,\n+            kind: StatementKind::Coverage(box Coverage { kind: coverage_kind, code_region }),\n         };\n-        match &start.file.name {\n-            FileName::Real(RealFileName::Named(path)) => (\n-                path.to_string_lossy().to_string(),\n-                start.line as u32,\n-                start.col.to_u32() + 1,\n-                end.line as u32,\n-                end.col.to_u32() + 1,\n-            ),\n-            _ => {\n-                bug!(\"start.file.name should be a RealFileName, but it was: {:?}\", start.file.name)\n-            }\n-        }\n-    }\n-\n-    fn const_str(&self, value: &str, span: Span) -> Operand<'tcx> {\n-        Operand::const_from_str(self.tcx, value, span)\n-    }\n-\n-    fn const_u32(&self, value: u32, span: Span) -> Operand<'tcx> {\n-        Operand::const_from_scalar(self.tcx, self.tcx.types.u32, Scalar::from_u32(value), span)\n-    }\n-\n-    fn const_u64(&self, value: u64, span: Span) -> Operand<'tcx> {\n-        Operand::const_from_scalar(self.tcx, self.tcx.types.u64, Scalar::from_u64(value), span)\n+        data.statements.push(statement);\n     }\n }\n \n-fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Operand<'tcx> {\n-    let ret_ty = tcx.fn_sig(fn_def_id).output();\n-    let ret_ty = ret_ty.no_bound_vars().unwrap();\n-    let substs = tcx.mk_substs(::std::iter::once(ty::subst::GenericArg::from(ret_ty)));\n-    Operand::function_handle(tcx, fn_def_id, substs, span)\n-}\n-\n-fn placeholder_block(span: Span, scope: SourceScope, is_cleanup: bool) -> BasicBlockData<'tcx> {\n-    BasicBlockData {\n-        statements: vec![],\n-        terminator: Some(Terminator {\n-            source_info: SourceInfo { span, scope },\n-            // this gets overwritten by the counter Call\n-            kind: TerminatorKind::Unreachable,\n-        }),\n-        is_cleanup,\n+/// Convert the Span into its file name, start line and column, and end line and column\n+fn make_code_region<'tcx>(tcx: TyCtxt<'tcx>, span: &Span) -> CodeRegion {\n+    let source_map = tcx.sess.source_map();\n+    let start = source_map.lookup_char_pos(span.lo());\n+    let end = if span.hi() == span.lo() {\n+        start.clone()\n+    } else {\n+        let end = source_map.lookup_char_pos(span.hi());\n+        debug_assert_eq!(\n+            start.file.name,\n+            end.file.name,\n+            \"Region start ({:?} -> {:?}) and end ({:?} -> {:?}) don't come from the same source file!\",\n+            span.lo(),\n+            start,\n+            span.hi(),\n+            end\n+        );\n+        end\n+    };\n+    match &start.file.name {\n+        FileName::Real(RealFileName::Named(path)) => CodeRegion {\n+            file_name: Symbol::intern(&path.to_string_lossy()),\n+            start_line: start.line as u32,\n+            start_col: start.col.to_u32() + 1,\n+            end_line: end.line as u32,\n+            end_col: end.col.to_u32() + 1,\n+        },\n+        _ => bug!(\"start.file.name should be a RealFileName, but it was: {:?}\", start.file.name),\n     }\n }\n "}, {"sha": "26db4600a2bb15c5f7a2ab9213b14533fae9bec3", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -273,6 +273,7 @@ fn check_statement(\n         | StatementKind::StorageDead(_)\n         | StatementKind::Retag { .. }\n         | StatementKind::AscribeUserType(..)\n+        | StatementKind::Coverage(..)\n         | StatementKind::Nop => Ok(()),\n     }\n }"}, {"sha": "0bad1e5037a0bec2c5ebebef54a5e078f3b2bcda", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -38,6 +38,7 @@ impl RemoveNoopLandingPads {\n                 | StatementKind::StorageLive(_)\n                 | StatementKind::StorageDead(_)\n                 | StatementKind::AscribeUserType(..)\n+                | StatementKind::Coverage(..)\n                 | StatementKind::Nop => {\n                     // These are all nops in a landing pad\n                 }"}, {"sha": "d5ce82ae28f28d6a71179f40b2e556f9fed71369", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -3,7 +3,6 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::fake_lang_items::FAKE_ITEMS_REFS;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::lang_items;\n use rustc_hir::weak_lang_items::WEAK_ITEMS_REFS;\n@@ -71,20 +70,11 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n }\n \n impl<'a, 'tcx> Context<'a, 'tcx> {\n-    fn register(&mut self, name: Symbol, span: Span, hir_id: hir::HirId) {\n+    fn register(&mut self, name: Symbol, span: Span) {\n         if let Some(&item) = WEAK_ITEMS_REFS.get(&name) {\n             if self.items.require(item).is_err() {\n                 self.items.missing.push(item);\n             }\n-        } else if let Some(&item) = FAKE_ITEMS_REFS.get(&name) {\n-            // Ensure \"fake lang items\" are registered. These are `extern` lang items that are\n-            // injected into the MIR automatically (such as source code coverage counters), but are\n-            // never actually linked; therefore, unlike \"weak lang items\", they cannot by registered\n-            // when used, because they never appear to be used.\n-            if self.items.items[item as usize].is_none() {\n-                let item_def_id = self.tcx.hir().local_def_id(hir_id).to_def_id();\n-                self.items.items[item as usize] = Some(item_def_id);\n-            }\n         } else {\n             struct_span_err!(self.tcx.sess, span, E0264, \"unknown external lang item: `{}`\", name)\n                 .emit();\n@@ -102,7 +92,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n         let check_name = |attr, sym| self.tcx.sess.check_name(attr, sym);\n         if let Some((lang_item, _)) = hir::lang_items::extract(check_name, &i.attrs) {\n-            self.register(lang_item, i.span, i.hir_id);\n+            self.register(lang_item, i.span);\n         }\n         intravisit::walk_foreign_item(self, i)\n     }"}, {"sha": "3883d86520fee7334b17a63cc7e732ea30198d34", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -379,10 +379,6 @@ symbols! {\n         core_intrinsics,\n         cosf32,\n         cosf64,\n-        count_code_region,\n-        coverage_counter_add,\n-        coverage_counter_subtract,\n-        coverage_unreachable,\n         crate_id,\n         crate_in_paths,\n         crate_local,"}, {"sha": "47cea8649ef3dfb12b0bbf6aa0aba69dd999f7e0", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -379,47 +379,6 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n \n             sym::nontemporal_store => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n \n-            sym::count_code_region => (\n-                0,\n-                vec![\n-                    tcx.types.u64,\n-                    tcx.types.u32,\n-                    tcx.mk_static_str(),\n-                    tcx.types.u32,\n-                    tcx.types.u32,\n-                    tcx.types.u32,\n-                    tcx.types.u32,\n-                ],\n-                tcx.mk_unit(),\n-            ),\n-\n-            sym::coverage_counter_add | sym::coverage_counter_subtract => (\n-                0,\n-                vec![\n-                    tcx.types.u32,\n-                    tcx.types.u32,\n-                    tcx.types.u32,\n-                    tcx.mk_static_str(),\n-                    tcx.types.u32,\n-                    tcx.types.u32,\n-                    tcx.types.u32,\n-                    tcx.types.u32,\n-                ],\n-                tcx.mk_unit(),\n-            ),\n-\n-            sym::coverage_unreachable => (\n-                0,\n-                vec![\n-                    tcx.mk_static_str(),\n-                    tcx.types.u32,\n-                    tcx.types.u32,\n-                    tcx.types.u32,\n-                    tcx.types.u32,\n-                ],\n-                tcx.mk_unit(),\n-            ),\n-\n             other => {\n                 struct_span_err!(\n                     tcx.sess,"}, {"sha": "01d837d155ab773f9926519fba7871f297b1749c", "filename": "src/test/mir-opt/instrument_coverage.bar.InstrumentCoverage.diff", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Ftest%2Fmir-opt%2Finstrument_coverage.bar.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Ftest%2Fmir-opt%2Finstrument_coverage.bar.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage.bar.InstrumentCoverage.diff?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -3,32 +3,10 @@\n   \n   fn bar() -> bool {\n       let mut _0: bool;                    // return place in scope 0 at /the/src/instrument_coverage.rs:19:13: 19:17\n-+     let mut _1: ();                      // in scope 0 at /the/src/instrument_coverage.rs:19:18: 19:18\n   \n       bb0: {\n-+         StorageLive(_1);                 // scope 0 at /the/src/instrument_coverage.rs:19:18: 19:18\n-+         _1 = const std::intrinsics::count_code_region(const 10208505205182607101_u64, const 0_u32, const \"/the/src/instrument_coverage.rs\", const 19_u32, const 18_u32, const 21_u32, const 2_u32) -> bb2; // scope 0 at /the/src/instrument_coverage.rs:19:18: 19:18\n-+                                          // ty::Const\n-+                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, &'static str, u32, u32, u32, u32) {std::intrinsics::count_code_region}\n-+                                          // + val: Value(Scalar(<ZST>))\n-+                                          // mir::Constant\n-+                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, &'static str, u32, u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n-+                                          // ty::Const\n-+                                          // + ty: &str\n-+                                          // + val: Value(Slice { data: Allocation { bytes: [47, 116, 104, 101, 47, 115, 114, 99, 47, 105, 110, 115, 116, 114, 117, 109, 101, 110, 116, 95, 99, 111, 118, 101, 114, 97, 103, 101, 46, 114, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2147483647], len: Size { raw: 31 } }, size: Size { raw: 31 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 31 })\n-+                                          // mir::Constant\n-+                                          // + span: /the/src/instrument_coverage.rs:19:18: 19:18\n-+                                          // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [47, 116, 104, 101, 47, 115, 114, 99, 47, 105, 110, 115, 116, 114, 117, 109, 101, 110, 116, 95, 99, 111, 118, 101, 114, 97, 103, 101, 46, 114, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2147483647], len: Size { raw: 31 } }, size: Size { raw: 31 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 31 }) }\n-+     }\n-+ \n-+     bb1 (cleanup): {\n-+         resume;                          // scope 0 at /the/src/instrument_coverage.rs:19:1: 21:2\n-+     }\n-+ \n-+     bb2: {\n-+         StorageDead(_1);                 // scope 0 at /the/src/instrument_coverage.rs:20:5: 20:9\n           _0 = const true;                 // scope 0 at /the/src/instrument_coverage.rs:20:5: 20:9\n++         Coverage { kind: Counter { function_source_hash: 10208505205182607101, id: CounterValueReference(0) }, code_region: /the/src/instrument_coverage.rs:19:18 - 21:2 }; // scope 0 at /the/src/instrument_coverage.rs:21:2: 21:2\n           return;                          // scope 0 at /the/src/instrument_coverage.rs:21:2: 21:2\n       }\n   }"}, {"sha": "c3831cb2bb4258098b8e1580538641a5c9860761", "filename": "src/test/mir-opt/instrument_coverage.main.InstrumentCoverage.diff", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Ftest%2Fmir-opt%2Finstrument_coverage.main.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Ftest%2Fmir-opt%2Finstrument_coverage.main.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage.main.InstrumentCoverage.diff?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -6,24 +6,10 @@\n       let mut _1: ();                      // in scope 0 at /the/src/instrument_coverage.rs:10:1: 16:2\n       let mut _2: bool;                    // in scope 0 at /the/src/instrument_coverage.rs:12:12: 12:17\n       let mut _3: !;                       // in scope 0 at /the/src/instrument_coverage.rs:12:18: 14:10\n-+     let mut _4: ();                      // in scope 0 at /the/src/instrument_coverage.rs:10:11: 10:11\n   \n       bb0: {\n--         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at /the/src/instrument_coverage.rs:11:5: 15:6\n-+         StorageLive(_4);                 // scope 0 at /the/src/instrument_coverage.rs:10:11: 10:11\n-+         _4 = const std::intrinsics::count_code_region(const 16004455475339839479_u64, const 0_u32, const \"/the/src/instrument_coverage.rs\", const 10_u32, const 11_u32, const 16_u32, const 2_u32) -> bb7; // scope 0 at /the/src/instrument_coverage.rs:10:11: 10:11\n-+                                          // ty::Const\n-+                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, &'static str, u32, u32, u32, u32) {std::intrinsics::count_code_region}\n-+                                          // + val: Value(Scalar(<ZST>))\n-+                                          // mir::Constant\n-+                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u64, u32, &'static str, u32, u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n-+                                          // ty::Const\n-+                                          // + ty: &str\n-+                                          // + val: Value(Slice { data: Allocation { bytes: [47, 116, 104, 101, 47, 115, 114, 99, 47, 105, 110, 115, 116, 114, 117, 109, 101, 110, 116, 95, 99, 111, 118, 101, 114, 97, 103, 101, 46, 114, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2147483647], len: Size { raw: 31 } }, size: Size { raw: 31 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 31 })\n-+                                          // mir::Constant\n-+                                          // + span: /the/src/instrument_coverage.rs:10:11: 10:11\n-+                                          // + literal: Const { ty: &str, val: Value(Slice { data: Allocation { bytes: [47, 116, 104, 101, 47, 115, 114, 99, 47, 105, 110, 115, 116, 114, 117, 109, 101, 110, 116, 95, 99, 111, 118, 101, 114, 97, 103, 101, 46, 114, 115], relocations: Relocations(SortedMap { data: [] }), init_mask: InitMask { blocks: [2147483647], len: Size { raw: 31 } }, size: Size { raw: 31 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, start: 0, end: 31 }) }\n++         Coverage { kind: Counter { function_source_hash: 16004455475339839479, id: CounterValueReference(0) }, code_region: /the/src/instrument_coverage.rs:10:11 - 16:2 }; // scope 0 at /the/src/instrument_coverage.rs:11:5: 15:6\n+          falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at /the/src/instrument_coverage.rs:11:5: 15:6\n       }\n   \n       bb1: {\n@@ -72,11 +58,6 @@\n                                            // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n           StorageDead(_2);                 // scope 0 at /the/src/instrument_coverage.rs:15:5: 15:6\n           return;                          // scope 0 at /the/src/instrument_coverage.rs:16:2: 16:2\n-+     }\n-+ \n-+     bb7: {\n-+         StorageDead(_4);                 // scope 0 at /the/src/instrument_coverage.rs:11:5: 15:6\n-+         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at /the/src/instrument_coverage.rs:11:5: 15:6\n       }\n   }\n   "}, {"sha": "d9c8e8d43a46936aaa6a442688e10b2cc31ad3a1", "filename": "src/test/mir-opt/instrument_coverage.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6fcad6449aabad3c29c65c1738f8eab89c03ce/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage.rs?ref=5f6fcad6449aabad3c29c65c1738f8eab89c03ce", "patch": "@@ -1,5 +1,5 @@\n-// Test that the initial version of Rust coverage injects count_code_region() placeholder calls,\n-// at the top of each function. The placeholders are later converted into LLVM instrprof.increment\n+// Test that the initial version of Rust coverage injects Coverage statements at the top of each\n+// function. The Coverage Counter statements are later converted into LLVM instrprof.increment\n // intrinsics, during codegen.\n \n // needs-profiler-support"}]}