{"sha": "cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkYjc2MzRmMGM4N2Q3YmQyNTc3M2I3YTBhMGZkZTNiYzI2MzIyZGU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-24T18:19:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-24T18:19:59Z"}, "message": "Rollup merge of #65625 - petrochenkov:cstore, r=Mark-Simulacrum,Zoxc\n\nTurn crate store into a resolver output\n\nCrate store (`CStore`) is a vector of data (`CrateMetadata`) associated with extern crates loaded during the current compilation session.\n\nAll crates are loaded in the resolver when resolving either paths pointing to extern prelude or `extern crate` items. (There are also a couple of crates like panic runtime that are loaded kind of like implicit `extern crate`s, but that also happens in resolve.)\n\nThe use of `CStore` from `rustc_plugin` (which is outside of the resolver) was unnecessary because legacy plugins are not added to the crate store and don't use `CrateNum`s.\n\nSo, `CStore` can be produced by the resolver instead of being kept in some really global data (`rustc_interface::Compiler`) like now.\n\nAs a result of crate store being more \"local\" we can now remove some locks and `Lrc`s.", "tree": {"sha": "850e02b482576d035a42dc9a8e6ae059c40237bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/850e02b482576d035a42dc9a8e6ae059c40237bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdsetPCRBK7hj4Ov3rIwAAdHIIACdmM9PcPibZCSTlyE2g0U3z\nFKXTVqUvdx4xNhrPvsiVnTd5Y6bMbJ/T0E+ejQkUVZJWYL1gnP2vnc1yQxrfeKLe\nLl7jKYPmSM2ItvkAISE4MpNf/K60Yg+o/WragqrYz/oqbcSeuRildAnCFn9gN2s5\n7v6BrBBfm/uex1hUUV5N3J2dD4fFpRsyZabrltxO7ujw4bnEC+TQmVyG6x37fYBh\ngZ4QMpC5K2u2XOIr2n127mREBba0kIhwXetMb5GOE6IyqCo+fqpUQAqVeZ60MN9t\nMK0ftl8ArYlYTq2+Dc6ngGVK8Oyj/ZHgBbFp/xCYqXbBQ1U+Zw3wrHGvlYzXl5w=\n=TMe7\n-----END PGP SIGNATURE-----\n", "payload": "tree 850e02b482576d035a42dc9a8e6ae059c40237bd\nparent 8e0007f829661e57d008d2e908c95f6e84b04b25\nparent 94216ce3adfdb7d6c206505fca736d274a98ad2b\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1571941199 +0200\ncommitter GitHub <noreply@github.com> 1571941199 +0200\n\nRollup merge of #65625 - petrochenkov:cstore, r=Mark-Simulacrum,Zoxc\n\nTurn crate store into a resolver output\n\nCrate store (`CStore`) is a vector of data (`CrateMetadata`) associated with extern crates loaded during the current compilation session.\n\nAll crates are loaded in the resolver when resolving either paths pointing to extern prelude or `extern crate` items. (There are also a couple of crates like panic runtime that are loaded kind of like implicit `extern crate`s, but that also happens in resolve.)\n\nThe use of `CStore` from `rustc_plugin` (which is outside of the resolver) was unnecessary because legacy plugins are not added to the crate store and don't use `CrateNum`s.\n\nSo, `CStore` can be produced by the resolver instead of being kept in some really global data (`rustc_interface::Compiler`) like now.\n\nAs a result of crate store being more \"local\" we can now remove some locks and `Lrc`s.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "html_url": "https://github.com/rust-lang/rust/commit/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e0007f829661e57d008d2e908c95f6e84b04b25", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e0007f829661e57d008d2e908c95f6e84b04b25", "html_url": "https://github.com/rust-lang/rust/commit/8e0007f829661e57d008d2e908c95f6e84b04b25"}, {"sha": "94216ce3adfdb7d6c206505fca736d274a98ad2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/94216ce3adfdb7d6c206505fca736d274a98ad2b", "html_url": "https://github.com/rust-lang/rust/commit/94216ce3adfdb7d6c206505fca736d274a98ad2b"}], "stats": {"total": 761, "additions": 346, "deletions": 415}, "files": [{"sha": "002e6874466bbd12321c6256411c24d1499879c2", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -83,8 +83,6 @@ pub struct LoweringContext<'a> {\n     /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n     sess: &'a Session,\n \n-    cstore: &'a dyn CrateStore,\n-\n     resolver: &'a mut dyn Resolver,\n \n     /// HACK(Centril): there is a cyclic dependency between the parser and lowering\n@@ -160,6 +158,8 @@ pub struct LoweringContext<'a> {\n }\n \n pub trait Resolver {\n+    fn cstore(&self) -> &dyn CrateStore;\n+\n     /// Obtains resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n \n@@ -240,7 +240,6 @@ impl<'a> ImplTraitContext<'a> {\n \n pub fn lower_crate(\n     sess: &Session,\n-    cstore: &dyn CrateStore,\n     dep_graph: &DepGraph,\n     krate: &Crate,\n     resolver: &mut dyn Resolver,\n@@ -256,7 +255,6 @@ pub fn lower_crate(\n     LoweringContext {\n         crate_root: sess.parse_sess.injected_crate_name.try_get().copied(),\n         sess,\n-        cstore,\n         resolver,\n         nt_to_tokenstream,\n         items: BTreeMap::new(),\n@@ -980,7 +978,7 @@ impl<'a> LoweringContext<'a> {\n         if id.is_local() {\n             self.resolver.definitions().def_key(id.index)\n         } else {\n-            self.cstore.def_key(id)\n+            self.resolver.cstore().def_key(id)\n         }\n     }\n \n@@ -1727,8 +1725,8 @@ impl<'a> LoweringContext<'a> {\n                             return n;\n                         }\n                         assert!(!def_id.is_local());\n-                        let item_generics =\n-                            self.cstore.item_generics_cloned_untracked(def_id, self.sess);\n+                        let item_generics = self.resolver.cstore()\n+                            .item_generics_cloned_untracked(def_id, self.sess);\n                         let n = item_generics.own_counts().lifetimes;\n                         self.type_def_lifetime_params.insert(def_id, n);\n                         n"}, {"sha": "d5558db2397e797cd14f4297ebc0bc1a07fa2eb1", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -16,7 +16,7 @@ use syntax::ast;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_target::spec::Target;\n-use rustc_data_structures::sync::{self, MetadataRef, Lrc};\n+use rustc_data_structures::sync::{self, MetadataRef};\n use rustc_macros::HashStable;\n \n pub use self::NativeLibraryKind::*;\n@@ -191,6 +191,8 @@ pub trait MetadataLoader {\n                           -> Result<MetadataRef, String>;\n }\n \n+pub type MetadataLoaderDyn = dyn MetadataLoader + Sync;\n+\n /// A store of Rust crates, through which their metadata can be accessed.\n ///\n /// Note that this trait should probably not be expanding today. All new\n@@ -201,13 +203,13 @@ pub trait MetadataLoader {\n /// (it'd break incremental compilation) and should only be called pre-HIR (e.g.\n /// during resolve)\n pub trait CrateStore {\n-    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<dyn Any>;\n+    fn crate_data_as_any(&self, cnum: CrateNum) -> &dyn Any;\n \n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey;\n     fn def_path(&self, def: DefId) -> hir_map::DefPath;\n     fn def_path_hash(&self, def: DefId) -> hir_map::DefPathHash;\n-    fn def_path_table(&self, cnum: CrateNum) -> Lrc<DefPathTable>;\n+    fn def_path_table(&self, cnum: CrateNum) -> &DefPathTable;\n \n     // \"queries\" used in resolve that aren't tracked for incremental compilation\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol;"}, {"sha": "f99298281fecc5e5b7e203d5827ca148e955a4e8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -1027,7 +1027,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     interners: CtxtInterners<'tcx>,\n \n-    cstore: &'tcx CrateStoreDyn,\n+    cstore: Box<CrateStoreDyn>,\n \n     pub sess: &'tcx Session,\n \n@@ -1195,11 +1195,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn create_global_ctxt(\n         s: &'tcx Session,\n         lint_store: Lrc<lint::LintStore>,\n-        cstore: &'tcx CrateStoreDyn,\n         local_providers: ty::query::Providers<'tcx>,\n         extern_providers: ty::query::Providers<'tcx>,\n         arenas: &'tcx AllArenas,\n-        resolutions: ty::Resolutions,\n+        resolutions: ty::ResolverOutputs,\n         hir: hir_map::Map<'tcx>,\n         on_disk_query_result_cache: query::OnDiskCache<'tcx>,\n         crate_name: &str,\n@@ -1213,34 +1212,28 @@ impl<'tcx> TyCtxt<'tcx> {\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n         let dep_graph = hir.dep_graph.clone();\n-        let max_cnum = cstore.crates_untracked().iter().map(|c| c.as_usize()).max().unwrap_or(0);\n+        let cstore = resolutions.cstore;\n+        let crates = cstore.crates_untracked();\n+        let max_cnum = crates.iter().map(|c| c.as_usize()).max().unwrap_or(0);\n         let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n         providers[LOCAL_CRATE] = local_providers;\n \n         let def_path_hash_to_def_id = if s.opts.build_dep_graph() {\n-            let upstream_def_path_tables: Vec<(CrateNum, Lrc<_>)> = cstore\n-                .crates_untracked()\n+            let def_path_tables = crates\n                 .iter()\n                 .map(|&cnum| (cnum, cstore.def_path_table(cnum)))\n-                .collect();\n-\n-            let def_path_tables = || {\n-                upstream_def_path_tables\n-                    .iter()\n-                    .map(|&(cnum, ref rc)| (cnum, &**rc))\n-                    .chain(iter::once((LOCAL_CRATE, hir.definitions().def_path_table())))\n-            };\n+                .chain(iter::once((LOCAL_CRATE, hir.definitions().def_path_table())));\n \n             // Precompute the capacity of the hashmap so we don't have to\n             // re-allocate when populating it.\n-            let capacity = def_path_tables().map(|(_, t)| t.size()).sum::<usize>();\n+            let capacity = def_path_tables.clone().map(|(_, t)| t.size()).sum::<usize>();\n \n             let mut map: FxHashMap<_, _> = FxHashMap::with_capacity_and_hasher(\n                 capacity,\n                 ::std::default::Default::default()\n             );\n \n-            for (cnum, def_path_table) in def_path_tables() {\n+            for (cnum, def_path_table) in def_path_tables {\n                 def_path_table.add_def_path_hashes_to(cnum, &mut map);\n             }\n \n@@ -1417,8 +1410,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     // Note that this is *untracked* and should only be used within the query\n     // system if the result is otherwise tracked through queries\n-    pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Lrc<dyn Any> {\n-        self.cstore.crate_data_as_rc_any(cnum)\n+    pub fn crate_data_as_any(self, cnum: CrateNum) -> &'tcx dyn Any {\n+        self.cstore.crate_data_as_any(cnum)\n     }\n \n     #[inline(always)]\n@@ -1428,7 +1421,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         StableHashingContext::new(self.sess,\n                                   krate,\n                                   self.hir().definitions(),\n-                                  self.cstore)\n+                                  &*self.cstore)\n     }\n \n     // This method makes sure that we have a DepNode and a Fingerprint for"}, {"sha": "90450494a141911fb19fb3faad2b1729ceac7df0", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -15,6 +15,7 @@ use rustc_macros::HashStable;\n use crate::ich::Fingerprint;\n use crate::ich::StableHashingContext;\n use crate::infer::canonical::Canonical;\n+use crate::middle::cstore::CrateStoreDyn;\n use crate::middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n use crate::mir::Body;\n@@ -119,8 +120,9 @@ mod sty;\n \n // Data types\n \n-#[derive(Clone)]\n-pub struct Resolutions {\n+pub struct ResolverOutputs {\n+    pub definitions: hir_map::Definitions,\n+    pub cstore: Box<CrateStoreDyn>,\n     pub extern_crate_map: NodeMap<CrateNum>,\n     pub trait_map: TraitMap,\n     pub maybe_unused_trait_imports: NodeSet,"}, {"sha": "e09b600afd4e5a4955bc76e0ef6a78f5f2de877d", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -56,7 +56,7 @@ use std::sync::Arc;\n use std::ffi::CStr;\n \n use rustc::dep_graph::DepGraph;\n-use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n use rustc::session::Session;\n use rustc::session::config::{OutputFilenames, OutputType, PrintRequest, OptLevel};\n use rustc::ty::{self, TyCtxt};\n@@ -260,7 +260,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n         target_features(sess)\n     }\n \n-    fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync> {\n+    fn metadata_loader(&self) -> Box<MetadataLoaderDyn> {\n         box metadata::LlvmMetadataLoader\n     }\n "}, {"sha": "0e2c3731eae6d23b10751fc51a08779eb63c5960", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -14,7 +14,7 @@ use rustc::util::common::ErrorReported;\n use rustc::session::config::{OutputFilenames, PrintRequest};\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n-use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n use rustc::dep_graph::DepGraph;\n \n pub use rustc_data_structures::sync::MetadataRef;\n@@ -26,7 +26,7 @@ pub trait CodegenBackend {\n     fn print_passes(&self) {}\n     fn print_version(&self) {}\n \n-    fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync>;\n+    fn metadata_loader(&self) -> Box<MetadataLoaderDyn>;\n     fn provide(&self, _providers: &mut Providers<'_>);\n     fn provide_extern(&self, _providers: &mut Providers<'_>);\n     fn codegen_crate<'tcx>("}, {"sha": "15adf7e4add73ac640d0514729ca8e9a4043a82f", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -36,11 +36,11 @@ use rustc::session::config::nightly_options;\n use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n use rustc::lint;\n+use rustc::middle::cstore::MetadataLoader;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::ty::TyCtxt;\n use rustc::util::common::{set_time_depth, time, print_time_passes_entry, ErrorReported};\n use rustc_metadata::locator;\n-use rustc_metadata::cstore::CStore;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_interface::interface;\n use rustc_interface::util::get_codegen_sysroot;\n@@ -277,7 +277,7 @@ pub fn run_compiler(\n             compiler.output_file(),\n         ).and_then(|| RustcDefaultCalls::list_metadata(\n             sess,\n-            compiler.cstore(),\n+            &*compiler.codegen_backend().metadata_loader(),\n             &matches,\n             compiler.input()\n         ));\n@@ -614,7 +614,7 @@ fn show_content_with_pager(content: &String) {\n \n impl RustcDefaultCalls {\n     pub fn list_metadata(sess: &Session,\n-                         cstore: &CStore,\n+                         metadata_loader: &dyn MetadataLoader,\n                          matches: &getopts::Matches,\n                          input: &Input)\n                          -> Compilation {\n@@ -626,7 +626,7 @@ impl RustcDefaultCalls {\n                     let mut v = Vec::new();\n                     locator::list_file_metadata(&sess.target.target,\n                                                 path,\n-                                                cstore,\n+                                                metadata_loader,\n                                                 &mut v)\n                             .unwrap();\n                     println!(\"{}\", String::from_utf8(v).unwrap());"}, {"sha": "e014e4ed0fdc1cbe6fdb960fc012f2f2e2c1a3c7", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -11,7 +11,6 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_data_structures::OnDrop;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use rustc_metadata::cstore::CStore;\n use std::path::PathBuf;\n use std::result;\n use std::sync::{Arc, Mutex};\n@@ -37,7 +36,6 @@ pub struct Compiler {\n     pub(crate) output_dir: Option<PathBuf>,\n     pub(crate) output_file: Option<PathBuf>,\n     pub(crate) queries: Queries,\n-    pub(crate) cstore: Lrc<CStore>,\n     pub(crate) crate_name: Option<String>,\n     pub(crate) register_lints: Option<Box<dyn Fn(&Session, &mut lint::LintStore) + Send + Sync>>,\n }\n@@ -49,9 +47,6 @@ impl Compiler {\n     pub fn codegen_backend(&self) -> &Lrc<Box<dyn CodegenBackend>> {\n         &self.codegen_backend\n     }\n-    pub fn cstore(&self) -> &Lrc<CStore> {\n-        &self.cstore\n-    }\n     pub fn source_map(&self) -> &Lrc<SourceMap> {\n         &self.source_map\n     }\n@@ -160,13 +155,10 @@ where\n         config.lint_caps,\n     );\n \n-    let cstore = Lrc::new(CStore::new(codegen_backend.metadata_loader()));\n-\n     let compiler = Compiler {\n         sess,\n         codegen_backend,\n         source_map,\n-        cstore,\n         input: config.input,\n         input_path: config.input_path,\n         output_dir: config.output_dir,"}, {"sha": "58936172c5bcec0cd73a73b4d16528caf0046f5d", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 40, "deletions": 97, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -9,8 +9,8 @@ use rustc::hir::lowering::lower_crate;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::lint;\n use rustc::middle::{self, reachable, resolve_lifetime, stability};\n-use rustc::middle::cstore::CrateStore;\n-use rustc::ty::{self, AllArenas, Resolutions, TyCtxt, GlobalCtxt};\n+use rustc::middle::cstore::{CrateStore, MetadataLoader, MetadataLoaderDyn};\n+use rustc::ty::{self, AllArenas, ResolverOutputs, TyCtxt, GlobalCtxt};\n use rustc::ty::steal::Steal;\n use rustc::traits;\n use rustc::util::common::{time, ErrorReported};\n@@ -23,8 +23,7 @@ use rustc_codegen_utils::link::filename_for_metadata;\n use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n use rustc_data_structures::sync::{Lrc, ParallelIterator, par_iter};\n use rustc_incremental;\n-use rustc_metadata::creader::CrateLoader;\n-use rustc_metadata::cstore::{self, CStore};\n+use rustc_metadata::cstore;\n use rustc_mir as mir;\n use rustc_passes::{self, ast_validation, hir_stats, layout_test};\n use rustc_plugin as plugin;\n@@ -46,12 +45,10 @@ use syntax_ext;\n use rustc_serialize::json;\n use tempfile::Builder as TempFileBuilder;\n \n+use std::{env, fs, iter, mem};\n use std::any::Any;\n-use std::env;\n use std::ffi::OsString;\n-use std::fs;\n use std::io::{self, Write};\n-use std::iter;\n use std::path::PathBuf;\n use std::cell::RefCell;\n use std::rc::Rc;\n@@ -105,7 +102,7 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n declare_box_region_type!(\n     pub BoxedResolver,\n     for(),\n-    (&mut Resolver<'_>) -> (Result<ast::Crate>, ExpansionResult)\n+    (&mut Resolver<'_>) -> (Result<ast::Crate>, ResolverOutputs)\n );\n \n /// Runs the \"early phases\" of the compiler: initial `cfg` processing,\n@@ -118,7 +115,7 @@ declare_box_region_type!(\n pub fn configure_and_expand(\n     sess: Lrc<Session>,\n     lint_store: Lrc<lint::LintStore>,\n-    cstore: Lrc<CStore>,\n+    metadata_loader: Box<MetadataLoaderDyn>,\n     krate: ast::Crate,\n     crate_name: &str,\n     plugin_info: PluginInfo,\n@@ -131,16 +128,14 @@ pub fn configure_and_expand(\n     let crate_name = crate_name.to_string();\n     let (result, resolver) = BoxedResolver::new(static move || {\n         let sess = &*sess;\n-        let crate_loader = CrateLoader::new(sess, &*cstore, &crate_name);\n         let resolver_arenas = Resolver::arenas();\n         let res = configure_and_expand_inner(\n             sess,\n             &lint_store,\n-            &*cstore,\n             krate,\n             &crate_name,\n             &resolver_arenas,\n-            &crate_loader,\n+            &*metadata_loader,\n             plugin_info,\n         );\n         let mut resolver = match res {\n@@ -154,68 +149,16 @@ pub fn configure_and_expand(\n             }\n         };\n         box_region_allow_access!(for(), (&mut Resolver<'_>), (&mut resolver));\n-        ExpansionResult::from_owned_resolver(resolver)\n+        resolver.into_outputs()\n     });\n     result.map(|k| (k, resolver))\n }\n \n-pub struct ExpansionResult {\n-    pub defs: Steal<hir::map::Definitions>,\n-    pub resolutions: Steal<Resolutions>,\n-}\n-\n-impl ExpansionResult {\n-    fn from_owned_resolver(\n-        resolver: Resolver<'_>,\n-    ) -> Self {\n-        ExpansionResult {\n-            defs: Steal::new(resolver.definitions),\n-            resolutions: Steal::new(Resolutions {\n-                extern_crate_map: resolver.extern_crate_map,\n-                export_map: resolver.export_map,\n-                trait_map: resolver.trait_map,\n-                glob_map: resolver.glob_map,\n-                maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n-                maybe_unused_extern_crates: resolver.maybe_unused_extern_crates,\n-                extern_prelude: resolver.extern_prelude.iter().map(|(ident, entry)| {\n-                    (ident.name, entry.introduced_by_item)\n-                }).collect(),\n-            }),\n-        }\n-    }\n-\n-    pub fn from_resolver_ref(\n-        resolver: &Resolver<'_>,\n-    ) -> Self {\n-        ExpansionResult {\n-            defs: Steal::new(resolver.definitions.clone()),\n-            resolutions: Steal::new(Resolutions {\n-                extern_crate_map: resolver.extern_crate_map.clone(),\n-                export_map: resolver.export_map.clone(),\n-                trait_map: resolver.trait_map.clone(),\n-                glob_map: resolver.glob_map.clone(),\n-                maybe_unused_trait_imports: resolver.maybe_unused_trait_imports.clone(),\n-                maybe_unused_extern_crates: resolver.maybe_unused_extern_crates.clone(),\n-                extern_prelude: resolver.extern_prelude.iter().map(|(ident, entry)| {\n-                    (ident.name, entry.introduced_by_item)\n-                }).collect(),\n-            }),\n-        }\n-    }\n-}\n-\n impl BoxedResolver {\n-    pub fn to_expansion_result(\n-        resolver: Rc<RefCell<BoxedResolver>>,\n-    ) -> ExpansionResult {\n+    pub fn to_resolver_outputs(resolver: Rc<RefCell<BoxedResolver>>) -> ResolverOutputs {\n         match Rc::try_unwrap(resolver) {\n             Ok(resolver) => resolver.into_inner().complete(),\n-            Err(resolver) => {\n-                let resolver = &*resolver;\n-                resolver.borrow_mut().access(|resolver| {\n-                    ExpansionResult::from_resolver_ref(resolver)\n-                })\n-            }\n+            Err(resolver) => resolver.borrow_mut().access(|resolver| resolver.clone_outputs()),\n         }\n     }\n }\n@@ -226,7 +169,7 @@ pub struct PluginInfo {\n \n pub fn register_plugins<'a>(\n     sess: &'a Session,\n-    cstore: &'a CStore,\n+    metadata_loader: &'a dyn MetadataLoader,\n     register_lints: impl Fn(&Session, &mut lint::LintStore),\n     mut krate: ast::Crate,\n     crate_name: &str,\n@@ -274,9 +217,8 @@ pub fn register_plugins<'a>(\n     let registrars = time(sess, \"plugin loading\", || {\n         plugin::load::load_plugins(\n             sess,\n-            &cstore,\n+            metadata_loader,\n             &krate,\n-            crate_name,\n             Some(sess.opts.debugging_opts.extra_plugins.clone()),\n         )\n     });\n@@ -313,11 +255,10 @@ pub fn register_plugins<'a>(\n fn configure_and_expand_inner<'a>(\n     sess: &'a Session,\n     lint_store: &'a lint::LintStore,\n-    cstore: &'a CStore,\n     mut krate: ast::Crate,\n     crate_name: &str,\n     resolver_arenas: &'a ResolverArenas<'a>,\n-    crate_loader: &'a CrateLoader<'a>,\n+    metadata_loader: &'a MetadataLoaderDyn,\n     plugin_info: PluginInfo,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n     time(sess, \"pre-AST-expansion lint checks\", || {\n@@ -331,10 +272,9 @@ fn configure_and_expand_inner<'a>(\n \n     let mut resolver = Resolver::new(\n         sess,\n-        cstore,\n         &krate,\n         crate_name,\n-        crate_loader,\n+        metadata_loader,\n         &resolver_arenas,\n     );\n     syntax_ext::register_builtin_macros(&mut resolver, sess.edition());\n@@ -534,15 +474,14 @@ fn configure_and_expand_inner<'a>(\n pub fn lower_to_hir(\n     sess: &Session,\n     lint_store: &lint::LintStore,\n-    cstore: &CStore,\n     resolver: &mut Resolver<'_>,\n     dep_graph: &DepGraph,\n     krate: &ast::Crate,\n ) -> Result<hir::map::Forest> {\n     // Lower AST to HIR.\n     let hir_forest = time(sess, \"lowering AST -> HIR\", || {\n         let nt_to_tokenstream = syntax::parse::nt_to_tokenstream;\n-        let hir_crate = lower_crate(sess, cstore, &dep_graph, &krate, resolver, nt_to_tokenstream);\n+        let hir_crate = lower_crate(sess, &dep_graph, &krate, resolver, nt_to_tokenstream);\n \n         if sess.opts.debugging_opts.hir_stats {\n             hir_stats::print_hir_stats(&hir_crate);\n@@ -648,8 +587,12 @@ fn escape_dep_filename(filename: &FileName) -> String {\n     filename.to_string().replace(\" \", \"\\\\ \")\n }\n \n-fn write_out_deps(compiler: &Compiler, outputs: &OutputFilenames, out_filenames: &[PathBuf]) {\n-    let sess = &compiler.sess;\n+fn write_out_deps(\n+    sess: &Session,\n+    boxed_resolver: &Steal<Rc<RefCell<BoxedResolver>>>,\n+    outputs: &OutputFilenames,\n+    out_filenames: &[PathBuf],\n+) {\n     // Write out dependency rules to the dep-info file if requested\n     if !sess.opts.output_types.contains_key(&OutputType::DepInfo) {\n         return;\n@@ -668,18 +611,20 @@ fn write_out_deps(compiler: &Compiler, outputs: &OutputFilenames, out_filenames:\n             .collect();\n \n         if sess.binary_dep_depinfo() {\n-            for cnum in compiler.cstore.crates_untracked() {\n-                let source = compiler.cstore.crate_source_untracked(cnum);\n-                if let Some((path, _)) = source.dylib {\n-                    files.push(escape_dep_filename(&FileName::Real(path)));\n+            boxed_resolver.borrow().borrow_mut().access(|resolver| {\n+                for cnum in resolver.cstore().crates_untracked() {\n+                    let source = resolver.cstore().crate_source_untracked(cnum);\n+                    if let Some((path, _)) = source.dylib {\n+                        files.push(escape_dep_filename(&FileName::Real(path)));\n+                    }\n+                    if let Some((path, _)) = source.rlib {\n+                        files.push(escape_dep_filename(&FileName::Real(path)));\n+                    }\n+                    if let Some((path, _)) = source.rmeta {\n+                        files.push(escape_dep_filename(&FileName::Real(path)));\n+                    }\n                 }\n-                if let Some((path, _)) = source.rlib {\n-                    files.push(escape_dep_filename(&FileName::Real(path)));\n-                }\n-                if let Some((path, _)) = source.rmeta {\n-                    files.push(escape_dep_filename(&FileName::Real(path)));\n-                }\n-            }\n+            });\n         }\n \n         let mut file = fs::File::create(&deps_filename)?;\n@@ -717,6 +662,7 @@ pub fn prepare_outputs(\n     sess: &Session,\n     compiler: &Compiler,\n     krate: &ast::Crate,\n+    boxed_resolver: &Steal<Rc<RefCell<BoxedResolver>>>,\n     crate_name: &str\n ) -> Result<OutputFilenames> {\n     // FIXME: rustdoc passes &[] instead of &krate.attrs here\n@@ -758,7 +704,7 @@ pub fn prepare_outputs(\n         }\n     }\n \n-    write_out_deps(compiler, &outputs, &output_paths);\n+    write_out_deps(sess, boxed_resolver, &outputs, &output_paths);\n \n     let only_dep_info = sess.opts.output_types.contains_key(&OutputType::DepInfo)\n         && sess.opts.output_types.len() == 1;\n@@ -823,26 +769,24 @@ pub fn create_global_ctxt(\n     compiler: &Compiler,\n     lint_store: Lrc<lint::LintStore>,\n     mut hir_forest: hir::map::Forest,\n-    defs: hir::map::Definitions,\n-    resolutions: Resolutions,\n+    mut resolver_outputs: ResolverOutputs,\n     outputs: OutputFilenames,\n     crate_name: &str,\n ) -> BoxedGlobalCtxt {\n     let sess = compiler.session().clone();\n-    let cstore = compiler.cstore.clone();\n     let codegen_backend = compiler.codegen_backend().clone();\n     let crate_name = crate_name.to_string();\n+    let defs = mem::take(&mut resolver_outputs.definitions);\n \n     let ((), result) = BoxedGlobalCtxt::new(static move || {\n         let sess = &*sess;\n-        let cstore = &*cstore;\n \n         let global_ctxt: Option<GlobalCtxt<'_>>;\n         let arenas = AllArenas::new();\n \n         // Construct the HIR map.\n         let hir_map = time(sess, \"indexing HIR\", || {\n-            hir::map::map_crate(sess, cstore, &mut hir_forest, &defs)\n+            hir::map::map_crate(sess, &*resolver_outputs.cstore, &mut hir_forest, &defs)\n         });\n \n         let query_result_on_disk_cache = time(sess, \"load query result cache\", || {\n@@ -860,11 +804,10 @@ pub fn create_global_ctxt(\n         let gcx = TyCtxt::create_global_ctxt(\n             sess,\n             lint_store,\n-            cstore,\n             local_providers,\n             extern_providers,\n             &arenas,\n-            resolutions,\n+            resolver_outputs,\n             hir_map,\n             query_result_on_disk_cache,\n             &crate_name,"}, {"sha": "ea51e63725ea2f117ec4c0b7354fb6660374fca3", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -1,5 +1,5 @@\n use crate::interface::{Compiler, Result};\n-use crate::passes::{self, BoxedResolver, ExpansionResult, BoxedGlobalCtxt, PluginInfo};\n+use crate::passes::{self, BoxedResolver, BoxedGlobalCtxt, PluginInfo};\n \n use rustc_incremental::DepGraphFuture;\n use rustc_data_structures::sync::Lrc;\n@@ -11,6 +11,7 @@ use rustc::session::Session;\n use rustc::lint::LintStore;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::ty::steal::Steal;\n+use rustc::ty::ResolverOutputs;\n use rustc::dep_graph::DepGraph;\n use std::cell::{Ref, RefMut, RefCell};\n use std::rc::Rc;\n@@ -81,7 +82,7 @@ pub(crate) struct Queries {\n     register_plugins: Query<(ast::Crate, PluginInfo, Lrc<LintStore>)>,\n     expansion: Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n-    lower_to_hir: Query<(Steal<hir::map::Forest>, ExpansionResult)>,\n+    lower_to_hir: Query<(Steal<hir::map::Forest>, Steal<ResolverOutputs>)>,\n     prepare_outputs: Query<OutputFilenames>,\n     global_ctxt: Query<BoxedGlobalCtxt>,\n     ongoing_codegen: Query<Box<dyn Any>>,\n@@ -118,7 +119,7 @@ impl Compiler {\n             let empty: &(dyn Fn(&Session, &mut lint::LintStore) + Sync + Send) = &|_, _| {};\n             let result = passes::register_plugins(\n                 self.session(),\n-                self.cstore(),\n+                &*self.codegen_backend().metadata_loader(),\n                 self.register_lints\n                     .as_ref()\n                     .map(|p| &**p)\n@@ -164,7 +165,7 @@ impl Compiler {\n             passes::configure_and_expand(\n                 self.sess.clone(),\n                 lint_store.clone(),\n-                self.cstore().clone(),\n+                self.codegen_backend().metadata_loader(),\n                 krate,\n                 &crate_name,\n                 plugin_info,\n@@ -191,7 +192,9 @@ impl Compiler {\n         })\n     }\n \n-    pub fn lower_to_hir(&self) -> Result<&Query<(Steal<hir::map::Forest>, ExpansionResult)>> {\n+    pub fn lower_to_hir(\n+        &self,\n+    ) -> Result<&Query<(Steal<hir::map::Forest>, Steal<ResolverOutputs>)>> {\n         self.queries.lower_to_hir.compute(|| {\n             let expansion_result = self.expansion()?;\n             let peeked = expansion_result.peek();\n@@ -202,23 +205,22 @@ impl Compiler {\n                 passes::lower_to_hir(\n                     self.session(),\n                     lint_store,\n-                    self.cstore(),\n                     resolver,\n                     &*self.dep_graph()?.peek(),\n                     &krate\n                 )\n             })?);\n-            Ok((hir, BoxedResolver::to_expansion_result(resolver)))\n+            Ok((hir, Steal::new(BoxedResolver::to_resolver_outputs(resolver))))\n         })\n     }\n \n     pub fn prepare_outputs(&self) -> Result<&Query<OutputFilenames>> {\n         self.queries.prepare_outputs.compute(|| {\n-            let krate = self.expansion()?;\n-            let krate = krate.peek();\n+            let expansion_result = self.expansion()?;\n+            let (krate, boxed_resolver, _) = &*expansion_result.peek();\n             let crate_name = self.crate_name()?;\n             let crate_name = crate_name.peek();\n-            passes::prepare_outputs(self.session(), self, &krate.0, &*crate_name)\n+            passes::prepare_outputs(self.session(), self, &krate, &boxed_resolver, &crate_name)\n         })\n     }\n \n@@ -229,13 +231,12 @@ impl Compiler {\n             let lint_store = self.expansion()?.peek().2.clone();\n             let hir = self.lower_to_hir()?;\n             let hir = hir.peek();\n-            let (ref hir_forest, ref expansion) = *hir;\n+            let (hir_forest, resolver_outputs) = &*hir;\n             Ok(passes::create_global_ctxt(\n                 self,\n                 lint_store,\n                 hir_forest.steal(),\n-                expansion.defs.steal(),\n-                expansion.resolutions.steal(),\n+                resolver_outputs.steal(),\n                 outputs,\n                 &crate_name))\n         })"}, {"sha": "f0a68058de8ca89e414d553f6669d509c1134bb5", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 57, "deletions": 160, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -3,7 +3,7 @@\n use crate::cstore::{self, CStore, MetadataBlob};\n use crate::locator::{self, CratePaths};\n use crate::schema::{CrateRoot, CrateDep};\n-use rustc_data_structures::sync::{Lrc, RwLock, Lock, AtomicCell};\n+use rustc_data_structures::sync::{RwLock, Lock, AtomicCell};\n \n use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::svh::Svh;\n@@ -14,21 +14,20 @@ use rustc::session::{Session, CrateDisambiguator};\n use rustc::session::config::{Sanitizer, self};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc::session::search_paths::PathKind;\n-use rustc::middle::cstore::{CrateSource, ExternCrate, ExternCrateSource};\n+use rustc::middle::cstore::{CrateSource, ExternCrate, ExternCrateSource, MetadataLoaderDyn};\n use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n use rustc::hir::map::Definitions;\n use rustc::hir::def_id::LOCAL_CRATE;\n \n-use std::ops::Deref;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::attr;\n use syntax_expand::allocator::{global_allocator_spans, AllocatorKind};\n use syntax::symbol::{Symbol, sym};\n-use syntax::{span_err, span_fatal};\n+use syntax::span_fatal;\n use syntax_pos::{Span, DUMMY_SP};\n use log::{debug, info, log_enabled};\n use proc_macro::bridge::client::ProcMacro;\n@@ -39,9 +38,12 @@ crate struct Library {\n }\n \n pub struct CrateLoader<'a> {\n+    // Immutable configuration.\n     sess: &'a Session,\n-    cstore: &'a CStore,\n+    metadata_loader: &'a MetadataLoaderDyn,\n     local_crate_name: Symbol,\n+    // Mutable output.\n+    cstore: CStore,\n }\n \n fn dump_crates(cstore: &CStore) {\n@@ -58,29 +60,6 @@ fn dump_crates(cstore: &CStore) {\n     });\n }\n \n-// Extra info about a crate loaded for plugins or exported macros.\n-struct ExtensionCrate {\n-    metadata: PMDSource,\n-    dylib: Option<PathBuf>,\n-    target_only: bool,\n-}\n-\n-enum PMDSource {\n-    Registered(Lrc<cstore::CrateMetadata>),\n-    Owned(Library),\n-}\n-\n-impl Deref for PMDSource {\n-    type Target = MetadataBlob;\n-\n-    fn deref(&self) -> &MetadataBlob {\n-        match *self {\n-            PMDSource::Registered(ref cmd) => &cmd.blob,\n-            PMDSource::Owned(ref lib) => &lib.metadata\n-        }\n-    }\n-}\n-\n enum LoadResult {\n     Previous(CrateNum),\n     Loaded(Library),\n@@ -99,14 +78,27 @@ impl<'a> LoadError<'a> {\n }\n \n impl<'a> CrateLoader<'a> {\n-    pub fn new(sess: &'a Session, cstore: &'a CStore, local_crate_name: &str) -> Self {\n+    pub fn new(\n+        sess: &'a Session,\n+        metadata_loader: &'a MetadataLoaderDyn,\n+        local_crate_name: &str,\n+    ) -> Self {\n         CrateLoader {\n             sess,\n-            cstore,\n+            metadata_loader,\n             local_crate_name: Symbol::intern(local_crate_name),\n+            cstore: Default::default(),\n         }\n     }\n \n+    pub fn cstore(&self) -> &CStore {\n+        &self.cstore\n+    }\n+\n+    pub fn into_cstore(self) -> CStore {\n+        self.cstore\n+    }\n+\n     fn existing_match(&self, name: Symbol, hash: Option<&Svh>, kind: PathKind)\n                       -> Option<CrateNum> {\n         let mut ret = None;\n@@ -187,14 +179,14 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn register_crate(\n-        &self,\n+        &mut self,\n         host_lib: Option<Library>,\n         root: Option<&CratePaths>,\n         span: Span,\n         lib: Library,\n         dep_kind: DepKind,\n         name: Symbol\n-    ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n+    ) -> CrateNum {\n         let _prof_timer = self.sess.prof.generic_activity(\"metadata_register_crate\");\n \n         let Library { source, metadata } = lib;\n@@ -248,9 +240,9 @@ impl<'a> CrateLoader<'a> {\n             crate_root.def_path_table.decode((&metadata, self.sess))\n         });\n \n-        let cmeta = cstore::CrateMetadata {\n+        self.cstore.set_crate_data(cnum, cstore::CrateMetadata {\n             extern_crate: Lock::new(None),\n-            def_path_table: Lrc::new(def_path_table),\n+            def_path_table,\n             trait_impls,\n             root: crate_root,\n             blob: metadata,\n@@ -264,11 +256,9 @@ impl<'a> CrateLoader<'a> {\n             private_dep,\n             raw_proc_macros,\n             dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n-        };\n+        });\n \n-        let cmeta = Lrc::new(cmeta);\n-        self.cstore.set_crate_data(cnum, cmeta.clone());\n-        (cnum, cmeta)\n+        cnum\n     }\n \n     fn load_proc_macro<'b>(\n@@ -327,22 +317,22 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn resolve_crate<'b>(\n-        &'b self,\n+        &'b mut self,\n         name: Symbol,\n         span: Span,\n         dep_kind: DepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n-    ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n+    ) -> CrateNum {\n         self.maybe_resolve_crate(name, span, dep_kind, dep).unwrap_or_else(|err| err.report())\n     }\n \n     fn maybe_resolve_crate<'b>(\n-        &'b self,\n+        &'b mut self,\n         name: Symbol,\n         span: Span,\n         mut dep_kind: DepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n-    ) -> Result<(CrateNum, Lrc<cstore::CrateMetadata>), LoadError<'b>> {\n+    ) -> Result<CrateNum, LoadError<'b>> {\n         info!(\"resolving crate `{}`\", name);\n         let (root, hash, extra_filename, path_kind) = match dep {\n             Some((root, dep)) =>\n@@ -370,7 +360,7 @@ impl<'a> CrateLoader<'a> {\n                 rejected_via_filename: vec![],\n                 should_match_name: true,\n                 is_proc_macro: Some(false),\n-                metadata_loader: &*self.cstore.metadata_loader,\n+                metadata_loader: self.metadata_loader,\n             };\n \n             self.load(&mut locate_ctxt).map(|r| (r, None)).or_else(|| {\n@@ -388,7 +378,7 @@ impl<'a> CrateLoader<'a> {\n                 data.dep_kind.with_lock(|data_dep_kind| {\n                     *data_dep_kind = cmp::max(*data_dep_kind, dep_kind);\n                 });\n-                Ok((cnum, data))\n+                Ok(cnum)\n             }\n             (LoadResult::Loaded(library), host_library) => {\n                 Ok(self.register_crate(host_library, root, span, library, dep_kind, name))\n@@ -466,7 +456,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     // Go through the crate metadata and load any crates that it references\n-    fn resolve_crate_deps(&self,\n+    fn resolve_crate_deps(&mut self,\n                           root: &CratePaths,\n                           crate_root: &CrateRoot<'_>,\n                           metadata: &MetadataBlob,\n@@ -492,73 +482,10 @@ impl<'a> CrateLoader<'a> {\n                 DepKind::MacrosOnly => DepKind::MacrosOnly,\n                 _ => dep.kind,\n             };\n-            self.resolve_crate(dep.name, span, dep_kind, Some((root, &dep))).0\n+            self.resolve_crate(dep.name, span, dep_kind, Some((root, &dep)))\n         })).collect()\n     }\n \n-    fn read_extension_crate(&self, name: Symbol, span: Span) -> ExtensionCrate {\n-        info!(\"read extension crate `{}`\", name);\n-        let target_triple = self.sess.opts.target_triple.clone();\n-        let host_triple = TargetTriple::from_triple(config::host_triple());\n-        let is_cross = target_triple != host_triple;\n-        let mut target_only = false;\n-        let mut locate_ctxt = locator::Context {\n-            sess: self.sess,\n-            span,\n-            crate_name: name,\n-            hash: None,\n-            extra_filename: None,\n-            filesearch: self.sess.host_filesearch(PathKind::Crate),\n-            target: &self.sess.host,\n-            triple: host_triple,\n-            root: None,\n-            rejected_via_hash: vec![],\n-            rejected_via_triple: vec![],\n-            rejected_via_kind: vec![],\n-            rejected_via_version: vec![],\n-            rejected_via_filename: vec![],\n-            should_match_name: true,\n-            is_proc_macro: None,\n-            metadata_loader: &*self.cstore.metadata_loader,\n-        };\n-        let library = self.load(&mut locate_ctxt).or_else(|| {\n-            if !is_cross {\n-                return None\n-            }\n-            // Try loading from target crates. This will abort later if we\n-            // try to load a plugin registrar function,\n-            target_only = true;\n-\n-            locate_ctxt.target = &self.sess.target.target;\n-            locate_ctxt.triple = target_triple;\n-            locate_ctxt.filesearch = self.sess.target_filesearch(PathKind::Crate);\n-\n-            self.load(&mut locate_ctxt)\n-        });\n-        let library = match library {\n-            Some(l) => l,\n-            None => locate_ctxt.report_errs(),\n-        };\n-\n-        let (dylib, metadata) = match library {\n-            LoadResult::Previous(cnum) => {\n-                let data = self.cstore.get_crate_data(cnum);\n-                (data.source.dylib.clone(), PMDSource::Registered(data))\n-            }\n-            LoadResult::Loaded(library) => {\n-                let dylib = library.source.dylib.clone();\n-                let metadata = PMDSource::Owned(library);\n-                (dylib, metadata)\n-            }\n-        };\n-\n-        ExtensionCrate {\n-            metadata,\n-            dylib: dylib.map(|p| p.0),\n-            target_only,\n-        }\n-    }\n-\n     fn dlsym_proc_macros(&self,\n                          path: &Path,\n                          disambiguator: CrateDisambiguator,\n@@ -590,42 +517,7 @@ impl<'a> CrateLoader<'a> {\n         decls\n     }\n \n-    /// Look for a plugin registrar. Returns library path, crate\n-    /// SVH and DefIndex of the registrar function.\n-    pub fn find_plugin_registrar(&self,\n-                                 span: Span,\n-                                 name: Symbol)\n-                                 -> Option<(PathBuf, CrateDisambiguator)> {\n-        let ekrate = self.read_extension_crate(name, span);\n-\n-        if ekrate.target_only {\n-            // Need to abort before syntax expansion.\n-            let message = format!(\"plugin `{}` is not available for triple `{}` \\\n-                                   (only found {})\",\n-                                  name,\n-                                  config::host_triple(),\n-                                  self.sess.opts.target_triple);\n-            span_fatal!(self.sess, span, E0456, \"{}\", &message);\n-        }\n-\n-        let root = ekrate.metadata.get_root();\n-        match ekrate.dylib.as_ref() {\n-            Some(dylib) => {\n-                Some((dylib.to_path_buf(), root.disambiguator))\n-            }\n-            None => {\n-                span_err!(self.sess, span, E0457,\n-                          \"plugin `{}` only found in rlib format, but must be available \\\n-                           in dylib format\",\n-                          name);\n-                // No need to abort because the loading code will just ignore this\n-                // empty dylib.\n-                None\n-            }\n-        }\n-    }\n-\n-    fn inject_panic_runtime(&self, krate: &ast::Crate) {\n+    fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n         // If we're only compiling an rlib, then there's no need to select a\n         // panic runtime, so we just skip this section entirely.\n         let any_non_rlib = self.sess.crate_types.borrow().iter().any(|ct| {\n@@ -687,7 +579,8 @@ impl<'a> CrateLoader<'a> {\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n-        let (cnum, data) = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+        let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+        let data = self.cstore.get_crate_data(cnum);\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n@@ -706,7 +599,7 @@ impl<'a> CrateLoader<'a> {\n                                   &|data| data.root.needs_panic_runtime);\n     }\n \n-    fn inject_sanitizer_runtime(&self) {\n+    fn inject_sanitizer_runtime(&mut self) {\n         if let Some(ref sanitizer) = self.sess.opts.debugging_opts.sanitizer {\n             // Sanitizers can only be used on some tested platforms with\n             // executables linked to `std`\n@@ -791,7 +684,8 @@ impl<'a> CrateLoader<'a> {\n                 });\n                 info!(\"loading sanitizer: {}\", name);\n \n-                let data = self.resolve_crate(name, DUMMY_SP, DepKind::Explicit, None).1;\n+                let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Explicit, None);\n+                let data = self.cstore.get_crate_data(cnum);\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n                 if !data.root.sanitizer_runtime {\n@@ -804,14 +698,15 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn inject_profiler_runtime(&self) {\n+    fn inject_profiler_runtime(&mut self) {\n         if self.sess.opts.debugging_opts.profile ||\n            self.sess.opts.cg.profile_generate.enabled()\n         {\n             info!(\"loading profiler\");\n \n             let name = Symbol::intern(\"profiler_builtins\");\n-            let data = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None).1;\n+            let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+            let data = self.cstore.get_crate_data(cnum);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n             if !data.root.profiler_runtime {\n@@ -957,10 +852,8 @@ impl<'a> CrateLoader<'a> {\n             data.dependencies.borrow_mut().push(krate);\n         });\n     }\n-}\n \n-impl<'a> CrateLoader<'a> {\n-    pub fn postprocess(&self, krate: &ast::Crate) {\n+    pub fn postprocess(&mut self, krate: &ast::Crate) {\n         self.inject_sanitizer_runtime();\n         self.inject_profiler_runtime();\n         self.inject_allocator_crate(krate);\n@@ -971,7 +864,11 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    pub fn process_extern_crate(&self, item: &ast::Item, definitions: &Definitions) -> CrateNum {\n+    pub fn process_extern_crate(\n+        &mut self,\n+        item: &ast::Item,\n+        definitions: &Definitions,\n+    ) -> CrateNum {\n         match item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 debug!(\"resolving extern crate stmt. ident: {} orig_name: {:?}\",\n@@ -990,7 +887,7 @@ impl<'a> CrateLoader<'a> {\n                     DepKind::Explicit\n                 };\n \n-                let cnum = self.resolve_crate(name, item.span, dep_kind, None).0;\n+                let cnum = self.resolve_crate(name, item.span, dep_kind, None);\n \n                 let def_id = definitions.opt_local_def_id(item.id).unwrap();\n                 let path_len = definitions.def_path(def_id.index).data.len();\n@@ -1010,8 +907,8 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    pub fn process_path_extern(&self, name: Symbol, span: Span) -> CrateNum {\n-        let cnum = self.resolve_crate(name, span, DepKind::Explicit, None).0;\n+    pub fn process_path_extern(&mut self, name: Symbol, span: Span) -> CrateNum {\n+        let cnum = self.resolve_crate(name, span, DepKind::Explicit, None);\n \n         self.update_extern_crate(\n             cnum,\n@@ -1028,8 +925,8 @@ impl<'a> CrateLoader<'a> {\n         cnum\n     }\n \n-    pub fn maybe_process_path_extern(&self, name: Symbol, span: Span) -> Option<CrateNum> {\n-        let cnum = self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()?.0;\n+    pub fn maybe_process_path_extern(&mut self, name: Symbol, span: Span) -> Option<CrateNum> {\n+        let cnum = self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()?;\n \n         self.update_extern_crate(\n             cnum,"}, {"sha": "6b06cf575edcf5557aeddaf70335f4f4e7e809de", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -5,12 +5,13 @@ use crate::schema;\n use rustc::dep_graph::DepNodeIndex;\n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::map::definitions::DefPathTable;\n-use rustc::middle::cstore::{CrateSource, DepKind, ExternCrate, MetadataLoader};\n+use rustc::middle::cstore::{CrateSource, DepKind, ExternCrate};\n use rustc::mir::interpret::AllocDecodingState;\n use rustc_index::vec::IndexVec;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::sync::{Lrc, RwLock, Lock, MetadataRef, AtomicCell};\n use syntax::ast;\n+use syntax::edition::Edition;\n use syntax_expand::base::SyntaxExtension;\n use syntax_pos;\n use proc_macro::bridge::client::ProcMacro;\n@@ -36,7 +37,7 @@ crate struct ImportedSourceFile {\n     pub translated_source_file: Lrc<syntax_pos::SourceFile>,\n }\n \n-pub struct CrateMetadata {\n+crate struct CrateMetadata {\n     /// The primary crate data - binary metadata blob.\n     crate blob: MetadataBlob,\n \n@@ -53,7 +54,7 @@ pub struct CrateMetadata {\n     /// hashmap, which gives the reverse mapping. This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n-    crate def_path_table: Lrc<DefPathTable>,\n+    crate def_path_table: DefPathTable,\n     /// Trait impl data.\n     /// FIXME: Used only from queries and can use query cache,\n     /// so pre-decoding can probably be avoided.\n@@ -94,50 +95,48 @@ pub struct CrateMetadata {\n     crate extern_crate: Lock<Option<ExternCrate>>,\n }\n \n+#[derive(Clone)]\n pub struct CStore {\n-    metas: RwLock<IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>>,\n-    crate metadata_loader: Box<dyn MetadataLoader + Sync>,\n+    metas: IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>,\n }\n \n pub enum LoadedMacro {\n-    MacroDef(ast::Item),\n+    MacroDef(ast::Item, Edition),\n     ProcMacro(SyntaxExtension),\n }\n \n-impl CStore {\n-    pub fn new(metadata_loader: Box<dyn MetadataLoader + Sync>) -> CStore {\n+impl Default for CStore {\n+    fn default() -> Self {\n         CStore {\n             // We add an empty entry for LOCAL_CRATE (which maps to zero) in\n             // order to make array indices in `metas` match with the\n             // corresponding `CrateNum`. This first entry will always remain\n             // `None`.\n-            metas: RwLock::new(IndexVec::from_elem_n(None, 1)),\n-            metadata_loader,\n+            metas: IndexVec::from_elem_n(None, 1),\n         }\n     }\n+}\n \n-    crate fn alloc_new_crate_num(&self) -> CrateNum {\n-        let mut metas = self.metas.borrow_mut();\n-        let cnum = CrateNum::new(metas.len());\n-        metas.push(None);\n-        cnum\n+impl CStore {\n+    crate fn alloc_new_crate_num(&mut self) -> CrateNum {\n+        self.metas.push(None);\n+        CrateNum::new(self.metas.len() - 1)\n     }\n \n-    crate fn get_crate_data(&self, cnum: CrateNum) -> Lrc<CrateMetadata> {\n-        self.metas.borrow()[cnum].clone()\n+    crate fn get_crate_data(&self, cnum: CrateNum) -> &CrateMetadata {\n+        self.metas[cnum].as_ref()\n             .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum))\n     }\n \n-    crate fn set_crate_data(&self, cnum: CrateNum, data: Lrc<CrateMetadata>) {\n-        let mut metas = self.metas.borrow_mut();\n-        assert!(metas[cnum].is_none(), \"Overwriting crate metadata entry\");\n-        metas[cnum] = Some(data);\n+    crate fn set_crate_data(&mut self, cnum: CrateNum, data: CrateMetadata) {\n+        assert!(self.metas[cnum].is_none(), \"Overwriting crate metadata entry\");\n+        self.metas[cnum] = Some(Lrc::new(data));\n     }\n \n     crate fn iter_crate_data<I>(&self, mut i: I)\n-        where I: FnMut(CrateNum, &Lrc<CrateMetadata>)\n+        where I: FnMut(CrateNum, &CrateMetadata)\n     {\n-        for (k, v) in self.metas.borrow().iter_enumerated() {\n+        for (k, v) in self.metas.iter_enumerated() {\n             if let &Some(ref v) = v {\n                 i(k, v);\n             }\n@@ -168,7 +167,7 @@ impl CStore {\n \n     crate fn do_postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n-        for (num, v) in self.metas.borrow().iter_enumerated() {\n+        for (num, v) in self.metas.iter_enumerated() {\n             if let &Some(_) = v {\n                 self.push_dependencies_in_postorder(&mut ordering, num);\n             }"}, {"sha": "d942a19194a1443d69a35a34a52daf3502f0c152", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -29,7 +29,6 @@ use std::sync::Arc;\n use syntax::ast;\n use syntax::attr;\n use syntax::source_map;\n-use syntax::edition::Edition;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n use syntax::source_map::Spanned;\n@@ -54,7 +53,7 @@ macro_rules! provide {\n                 let ($def_id, $other) = def_id_arg.into_args();\n                 assert!(!$def_id.is_local());\n \n-                let $cdata = $tcx.crate_data_as_rc_any($def_id.krate);\n+                let $cdata = $tcx.crate_data_as_any($def_id.krate);\n                 let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n                     .expect(\"CrateStore created data is not a CrateMetadata\");\n \n@@ -411,10 +410,6 @@ impl cstore::CStore {\n         }\n     }\n \n-    pub fn crate_edition_untracked(&self, cnum: CrateNum) -> Edition {\n-        self.get_crate_data(cnum).root.edition\n-    }\n-\n     pub fn struct_field_names_untracked(&self, def: DefId, sess: &Session) -> Vec<Spanned<Symbol>> {\n         self.get_crate_data(def.krate).get_struct_field_names(def.index, sess)\n     }\n@@ -470,7 +465,7 @@ impl cstore::CStore {\n             }),\n             vis: source_map::respan(local_span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n             tokens: None,\n-        })\n+        }, data.root.edition)\n     }\n \n     pub fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssocItem {\n@@ -483,8 +478,8 @@ impl cstore::CStore {\n }\n \n impl CrateStore for cstore::CStore {\n-    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<dyn Any> {\n-        self.get_crate_data(krate)\n+    fn crate_data_as_any(&self, cnum: CrateNum) -> &dyn Any {\n+        self.get_crate_data(cnum)\n     }\n \n     fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics {\n@@ -525,8 +520,8 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(def.krate).def_path_hash(def.index)\n     }\n \n-    fn def_path_table(&self, cnum: CrateNum) -> Lrc<DefPathTable> {\n-        self.get_crate_data(cnum).def_path_table.clone()\n+    fn def_path_table(&self, cnum: CrateNum) -> &DefPathTable {\n+        &self.get_crate_data(cnum).def_path_table\n     }\n \n     fn crates_untracked(&self) -> Vec<CrateNum>"}, {"sha": "a5298402dd4115b95839ce89a65d2704d422bf92", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 82, "deletions": 4, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -212,20 +212,21 @@\n //! no means all of the necessary details. Take a look at the rest of\n //! metadata::locator or metadata::creader for all the juicy details!\n \n-use crate::cstore::{MetadataBlob, CStore};\n+use crate::cstore::MetadataBlob;\n use crate::creader::Library;\n use crate::schema::{METADATA_HEADER, rustc_version};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n use rustc::middle::cstore::{CrateSource, MetadataLoader};\n-use rustc::session::{config, Session};\n+use rustc::session::{config, Session, CrateDisambiguator};\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use rustc::session::search_paths::PathKind;\n use rustc::util::nodemap::FxHashMap;\n \n use errors::DiagnosticBuilder;\n+use syntax::{span_err, span_fatal};\n use syntax::symbol::{Symbol, sym};\n use syntax::struct_span_err;\n use syntax_pos::Span;\n@@ -911,10 +912,87 @@ fn get_metadata_section_imp(target: &Target,\n     }\n }\n \n+/// Look for a plugin registrar. Returns its library path and crate disambiguator.\n+pub fn find_plugin_registrar(\n+    sess: &Session,\n+    metadata_loader: &dyn MetadataLoader,\n+    span: Span,\n+    name: Symbol,\n+) -> Option<(PathBuf, CrateDisambiguator)> {\n+    info!(\"find plugin registrar `{}`\", name);\n+    let target_triple = sess.opts.target_triple.clone();\n+    let host_triple = TargetTriple::from_triple(config::host_triple());\n+    let is_cross = target_triple != host_triple;\n+    let mut target_only = false;\n+    let mut locate_ctxt = Context {\n+        sess,\n+        span,\n+        crate_name: name,\n+        hash: None,\n+        extra_filename: None,\n+        filesearch: sess.host_filesearch(PathKind::Crate),\n+        target: &sess.host,\n+        triple: host_triple,\n+        root: None,\n+        rejected_via_hash: vec![],\n+        rejected_via_triple: vec![],\n+        rejected_via_kind: vec![],\n+        rejected_via_version: vec![],\n+        rejected_via_filename: vec![],\n+        should_match_name: true,\n+        is_proc_macro: None,\n+        metadata_loader,\n+    };\n+\n+    let library = locate_ctxt.maybe_load_library_crate().or_else(|| {\n+        if !is_cross {\n+            return None\n+        }\n+        // Try loading from target crates. This will abort later if we\n+        // try to load a plugin registrar function,\n+        target_only = true;\n+\n+        locate_ctxt.target = &sess.target.target;\n+        locate_ctxt.triple = target_triple;\n+        locate_ctxt.filesearch = sess.target_filesearch(PathKind::Crate);\n+\n+        locate_ctxt.maybe_load_library_crate()\n+    });\n+    let library = match library {\n+        Some(l) => l,\n+        None => locate_ctxt.report_errs(),\n+    };\n+\n+    if target_only {\n+        // Need to abort before syntax expansion.\n+        let message = format!(\"plugin `{}` is not available for triple `{}` \\\n+                                (only found {})\",\n+                                name,\n+                                config::host_triple(),\n+                                sess.opts.target_triple);\n+        span_fatal!(sess, span, E0456, \"{}\", &message);\n+    }\n+\n+    match library.source.dylib {\n+        Some(dylib) => {\n+            Some((dylib.0, library.metadata.get_root().disambiguator))\n+        }\n+        None => {\n+            span_err!(sess, span, E0457,\n+                        \"plugin `{}` only found in rlib format, but must be available \\\n+                        in dylib format\",\n+                        name);\n+            // No need to abort because the loading code will just ignore this\n+            // empty dylib.\n+            None\n+        }\n+    }\n+}\n+\n /// A diagnostic function for dumping crate metadata to an output stream.\n pub fn list_file_metadata(target: &Target,\n                           path: &Path,\n-                          cstore: &CStore,\n+                          metadata_loader: &dyn MetadataLoader,\n                           out: &mut dyn io::Write)\n                           -> io::Result<()> {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n@@ -925,7 +1003,7 @@ pub fn list_file_metadata(target: &Target,\n     } else {\n         CrateFlavor::Dylib\n     };\n-    match get_metadata_section(target, flavor, path, &*cstore.metadata_loader) {\n+    match get_metadata_section(target, flavor, path, metadata_loader) {\n         Ok(metadata) => metadata.list_crate_metadata(out),\n         Err(msg) => write!(out, \"{}\\n\", msg),\n     }"}, {"sha": "8ceb56b0fd2b4c4004f2d809664499e95bbf133a", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -1,8 +1,8 @@\n //! Used by `rustc` when loading a plugin.\n \n+use rustc::middle::cstore::MetadataLoader;\n use rustc::session::Session;\n-use rustc_metadata::creader::CrateLoader;\n-use rustc_metadata::cstore::CStore;\n+use rustc_metadata::locator;\n use crate::registry::Registry;\n \n use std::borrow::ToOwned;\n@@ -25,7 +25,7 @@ pub struct PluginRegistrar {\n \n struct PluginLoader<'a> {\n     sess: &'a Session,\n-    reader: CrateLoader<'a>,\n+    metadata_loader: &'a dyn MetadataLoader,\n     plugins: Vec<PluginRegistrar>,\n }\n \n@@ -37,11 +37,10 @@ fn call_malformed_plugin_attribute(sess: &Session, span: Span) {\n \n /// Read plugin metadata and dynamically load registrar functions.\n pub fn load_plugins(sess: &Session,\n-                    cstore: &CStore,\n+                    metadata_loader: &dyn MetadataLoader,\n                     krate: &ast::Crate,\n-                    crate_name: &str,\n                     addl_plugins: Option<Vec<String>>) -> Vec<PluginRegistrar> {\n-    let mut loader = PluginLoader::new(sess, cstore, crate_name);\n+    let mut loader = PluginLoader { sess, metadata_loader, plugins: Vec::new() };\n \n     // do not report any error now. since crate attributes are\n     // not touched by expansion, every use of plugin without\n@@ -80,16 +79,8 @@ pub fn load_plugins(sess: &Session,\n }\n \n impl<'a> PluginLoader<'a> {\n-    fn new(sess: &'a Session, cstore: &'a CStore, crate_name: &str) -> Self {\n-        PluginLoader {\n-            sess,\n-            reader: CrateLoader::new(sess, cstore, crate_name),\n-            plugins: vec![],\n-        }\n-    }\n-\n     fn load_plugin(&mut self, span: Span, name: Symbol, args: Vec<ast::NestedMetaItem>) {\n-        let registrar = self.reader.find_plugin_registrar(span, name);\n+        let registrar = locator::find_plugin_registrar(self.sess, self.metadata_loader, span, name);\n \n         if let Some((lib, disambiguator)) = registrar {\n             let symbol = self.sess.generate_plugin_registrar_symbol(disambiguator);"}, {"sha": "c0fb8e33a819eb6ec0bc6313a20e9c4447edbe52", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -110,9 +110,9 @@ impl<'a> Resolver<'a> {\n         }\n \n         let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n-            (self.cstore.crate_name_untracked(def_id.krate), None)\n+            (self.cstore().crate_name_untracked(def_id.krate), None)\n         } else {\n-            let def_key = self.cstore.def_key(def_id);\n+            let def_key = self.cstore().def_key(def_id);\n             (def_key.disambiguated_data.data.get_opt_name().unwrap(),\n              Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n         };\n@@ -153,9 +153,8 @@ impl<'a> Resolver<'a> {\n             return Some(ext.clone());\n         }\n \n-        let ext = Lrc::new(match self.cstore.load_macro_untracked(def_id, &self.session) {\n-            LoadedMacro::MacroDef(item) =>\n-                self.compile_macro(&item, self.cstore.crate_edition_untracked(def_id.krate)),\n+        let ext = Lrc::new(match self.cstore().load_macro_untracked(def_id, &self.session) {\n+            LoadedMacro::MacroDef(item, edition) => self.compile_macro(&item, edition),\n             LoadedMacro::ProcMacro(ext) => ext,\n         });\n \n@@ -177,7 +176,7 @@ impl<'a> Resolver<'a> {\n \n     crate fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n         let def_id = module.def_id().expect(\"unpopulated module without a def-id\");\n-        for child in self.cstore.item_children_untracked(def_id, self.session) {\n+        for child in self.cstore().item_children_untracked(def_id, self.session) {\n             let child = child.map_id(|_| panic!(\"unexpected id\"));\n             BuildReducedGraphVisitor { r: self, parent_scope: ParentScope::module(module) }\n                 .build_reduced_graph_for_external_crate_res(child);\n@@ -885,19 +884,19 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 bug!(\"unexpected resolution: {:?}\", res)\n         }\n         // Record some extra data for better diagnostics.\n+        let cstore = self.r.cstore();\n         match res {\n             Res::Def(DefKind::Struct, def_id) | Res::Def(DefKind::Union, def_id) => {\n-                let field_names =\n-                    self.r.cstore.struct_field_names_untracked(def_id, self.r.session);\n+                let field_names = cstore.struct_field_names_untracked(def_id, self.r.session);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Res::Def(DefKind::Method, def_id) => {\n-                if self.r.cstore.associated_item_cloned_untracked(def_id).method_has_self_argument {\n+                if cstore.associated_item_cloned_untracked(def_id).method_has_self_argument {\n                     self.r.has_self.insert(def_id);\n                 }\n             }\n             Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n-                let parent = self.r.cstore.def_key(def_id).parent;\n+                let parent = cstore.def_key(def_id).parent;\n                 if let Some(struct_def_id) = parent.map(|index| DefId { index, ..def_id }) {\n                     self.r.struct_constructors.insert(struct_def_id, (res, vis));\n                 }"}, {"sha": "1c67395fbf0b2536a668de6fe26bd5bac1620373", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 66, "deletions": 20, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -21,14 +21,14 @@ use Determinacy::*;\n \n use rustc::hir::map::Definitions;\n use rustc::hir::{self, PrimTy, Bool, Char, Float, Int, Uint, Str};\n-use rustc::middle::cstore::CrateStore;\n+use rustc::middle::cstore::{CrateStore, MetadataLoaderDyn};\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::{self, DefKind, PartialRes, CtorKind, CtorOf, NonMacroAttrKind, ExportMap};\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::{TraitMap, GlobMap};\n-use rustc::ty::{self, DefIdTree};\n+use rustc::ty::{self, DefIdTree, ResolverOutputs};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n use rustc::span_bug;\n \n@@ -829,14 +829,13 @@ pub struct ExternPreludeEntry<'a> {\n /// This is the visitor that walks the whole crate.\n pub struct Resolver<'a> {\n     session: &'a Session,\n-    cstore: &'a CStore,\n \n-    pub definitions: Definitions,\n+    definitions: Definitions,\n \n-    pub graph_root: Module<'a>,\n+    graph_root: Module<'a>,\n \n     prelude: Option<Module<'a>>,\n-    pub extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'a>>,\n+    extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'a>>,\n \n     /// N.B., this is used only for better diagnostics, not name resolution itself.\n     has_self: FxHashSet<DefId>,\n@@ -869,9 +868,9 @@ pub struct Resolver<'a> {\n     label_res_map: NodeMap<NodeId>,\n \n     /// `CrateNum` resolutions of `extern crate` items.\n-    pub extern_crate_map: NodeMap<CrateNum>,\n-    pub export_map: ExportMap<NodeId>,\n-    pub trait_map: TraitMap,\n+    extern_crate_map: NodeMap<CrateNum>,\n+    export_map: ExportMap<NodeId>,\n+    trait_map: TraitMap,\n \n     /// A map from nodes to anonymous modules.\n     /// Anonymous modules are pseudo-modules that are implicitly created around items\n@@ -898,11 +897,11 @@ pub struct Resolver<'a> {\n     underscore_disambiguator: u32,\n \n     /// Maps glob imports to the names of items actually imported.\n-    pub glob_map: GlobMap,\n+    glob_map: GlobMap,\n \n     used_imports: FxHashSet<(NodeId, Namespace)>,\n-    pub maybe_unused_trait_imports: NodeSet,\n-    pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n+    maybe_unused_trait_imports: NodeSet,\n+    maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n \n     /// Privacy errors are delayed until the end in order to deduplicate them.\n     privacy_errors: Vec<PrivacyError<'a>>,\n@@ -916,11 +915,11 @@ pub struct Resolver<'a> {\n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n \n-    crate_loader: &'a CrateLoader<'a>,\n+    crate_loader: CrateLoader<'a>,\n     macro_names: FxHashSet<Ident>,\n     builtin_macros: FxHashMap<Name, SyntaxExtension>,\n     macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n-    pub all_macros: FxHashMap<Name, Res>,\n+    all_macros: FxHashMap<Name, Res>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n     dummy_ext_bang: Lrc<SyntaxExtension>,\n     dummy_ext_derive: Lrc<SyntaxExtension>,\n@@ -1015,14 +1014,18 @@ impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n         match id.krate {\n             LOCAL_CRATE => self.definitions.def_key(id.index).parent,\n-            _ => self.cstore.def_key(id).parent,\n+            _ => self.cstore().def_key(id).parent,\n         }.map(|index| DefId { index, ..id })\n     }\n }\n \n /// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n /// the resolver is no longer needed as all the relevant information is inline.\n impl<'a> hir::lowering::Resolver for Resolver<'a> {\n+    fn cstore(&self) -> &dyn CrateStore {\n+        self.cstore()\n+    }\n+\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n@@ -1083,10 +1086,9 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n \n impl<'a> Resolver<'a> {\n     pub fn new(session: &'a Session,\n-               cstore: &'a CStore,\n                krate: &Crate,\n                crate_name: &str,\n-               crate_loader: &'a CrateLoader<'a>,\n+               metadata_loader: &'a MetadataLoaderDyn,\n                arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n         let root_def_id = DefId::local(CRATE_DEF_INDEX);\n@@ -1147,8 +1149,6 @@ impl<'a> Resolver<'a> {\n         Resolver {\n             session,\n \n-            cstore,\n-\n             definitions,\n \n             // The outermost module has def ID 0; this is not reflected in the\n@@ -1202,7 +1202,7 @@ impl<'a> Resolver<'a> {\n                 vis: ty::Visibility::Public,\n             }),\n \n-            crate_loader,\n+            crate_loader: CrateLoader::new(session, metadata_loader, crate_name),\n             macro_names: FxHashSet::default(),\n             builtin_macros: Default::default(),\n             macro_use_prelude: FxHashMap::default(),\n@@ -1236,6 +1236,42 @@ impl<'a> Resolver<'a> {\n         Default::default()\n     }\n \n+    pub fn into_outputs(self) -> ResolverOutputs {\n+        ResolverOutputs {\n+            definitions: self.definitions,\n+            cstore: Box::new(self.crate_loader.into_cstore()),\n+            extern_crate_map: self.extern_crate_map,\n+            export_map: self.export_map,\n+            trait_map: self.trait_map,\n+            glob_map: self.glob_map,\n+            maybe_unused_trait_imports: self.maybe_unused_trait_imports,\n+            maybe_unused_extern_crates: self.maybe_unused_extern_crates,\n+            extern_prelude: self.extern_prelude.iter().map(|(ident, entry)| {\n+                (ident.name, entry.introduced_by_item)\n+            }).collect(),\n+        }\n+    }\n+\n+    pub fn clone_outputs(&self) -> ResolverOutputs {\n+        ResolverOutputs {\n+            definitions: self.definitions.clone(),\n+            cstore: Box::new(self.cstore().clone()),\n+            extern_crate_map: self.extern_crate_map.clone(),\n+            export_map: self.export_map.clone(),\n+            trait_map: self.trait_map.clone(),\n+            glob_map: self.glob_map.clone(),\n+            maybe_unused_trait_imports: self.maybe_unused_trait_imports.clone(),\n+            maybe_unused_extern_crates: self.maybe_unused_extern_crates.clone(),\n+            extern_prelude: self.extern_prelude.iter().map(|(ident, entry)| {\n+                (ident.name, entry.introduced_by_item)\n+            }).collect(),\n+        }\n+    }\n+\n+    pub fn cstore(&self) -> &CStore {\n+        self.crate_loader.cstore()\n+    }\n+\n     fn non_macro_attr(&self, mark_used: bool) -> Lrc<SyntaxExtension> {\n         self.non_macro_attrs[mark_used as usize].clone()\n     }\n@@ -2808,6 +2844,16 @@ impl<'a> Resolver<'a> {\n         seg.id = self.session.next_node_id();\n         seg\n     }\n+\n+    // For rustdoc.\n+    pub fn graph_root(&self) -> Module<'a> {\n+        self.graph_root\n+    }\n+\n+    // For rustdoc.\n+    pub fn all_macros(&self) -> &FxHashMap<Name, Res> {\n+        &self.all_macros\n+    }\n }\n \n fn names_to_string(names: &[Name]) -> String {"}, {"sha": "31340ddd68372f18455ab587247f4eaea20d3d69", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -1344,7 +1344,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 if res != Res::Err {\n                     if let Some(def_id) = res.opt_def_id() {\n                         if !def_id.is_local() {\n-                            this.cstore.export_macros_untracked(def_id.krate);\n+                            this.cstore().export_macros_untracked(def_id.krate);\n                         }\n                     }\n                     reexports.push(Export {"}, {"sha": "a6a8fec429e20ec80030a282350a18e6bf274738", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -479,8 +479,8 @@ fn build_static(cx: &DocContext<'_>, did: DefId, mutable: bool) -> clean::Static\n \n fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemEnum {\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n-    match cx.cstore.load_macro_untracked(did, cx.sess()) {\n-        LoadedMacro::MacroDef(def) => {\n+    match cx.enter_resolver(|r| r.cstore().load_macro_untracked(did, cx.sess())) {\n+        LoadedMacro::MacroDef(def, _) => {\n             let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.kind {\n                 let tts: Vec<_> = def.stream().into_trees().collect();\n                 tts.chunks(4).map(|arm| arm[0].span()).collect()"}, {"sha": "b227f432a4e98d3b0b24ec111f7fdfd8208831d6", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -12,7 +12,6 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_interface::interface;\n use rustc_driver::abort_on_err;\n use rustc_resolve as resolve;\n-use rustc_metadata::cstore::CStore;\n \n use syntax::source_map;\n use syntax::attr;\n@@ -43,7 +42,6 @@ pub struct DocContext<'tcx> {\n \n     pub tcx: TyCtxt<'tcx>,\n     pub resolver: Rc<RefCell<interface::BoxedResolver>>,\n-    pub cstore: Lrc<CStore>,\n     /// Later on moved into `html::render::CACHE_KEY`\n     pub renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n@@ -117,9 +115,7 @@ impl<'tcx> DocContext<'tcx> {\n                     .def_path_table()\n                     .next_id()\n             } else {\n-                self.cstore\n-                    .def_path_table(crate_num)\n-                    .next_id()\n+                self.enter_resolver(|r| r.cstore().def_path_table(crate_num).next_id())\n             };\n \n             DefId {\n@@ -376,7 +372,6 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             let mut ctxt = DocContext {\n                 tcx,\n                 resolver,\n-                cstore: compiler.cstore().clone(),\n                 external_traits: Default::default(),\n                 active_extern_traits: Default::default(),\n                 renderinfo: RefCell::new(renderinfo),"}, {"sha": "caa7f08f68cffb3fb15840ab08108ab8ba229e7b", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -432,13 +432,13 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n     let path = ast::Path::from_ident(Ident::from_str(path_str));\n     cx.enter_resolver(|resolver| {\n         if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n-            &path, None, &ParentScope::module(resolver.graph_root), false, false\n+            &path, None, &ParentScope::module(resolver.graph_root()), false, false\n         ) {\n             if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n                 return Some(res.map_id(|_| panic!(\"unexpected id\")));\n             }\n         }\n-        if let Some(res) = resolver.all_macros.get(&Symbol::intern(path_str)) {\n+        if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n             return Some(res.map_id(|_| panic!(\"unexpected id\")));\n         }\n         None"}, {"sha": "eb96c61060b391d1baa4597258aa3bd75161a9d0", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "patch": "@@ -9,14 +9,14 @@ extern crate rustc_target;\n extern crate rustc_driver;\n \n use std::any::Any;\n-use std::sync::{Arc, mpsc};\n+use std::sync::Arc;\n use std::path::Path;\n use syntax::symbol::Symbol;\n use rustc::session::Session;\n use rustc::session::config::OutputFilenames;\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n-use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoader, MetadataLoaderDyn};\n use rustc::dep_graph::DepGraph;\n use rustc::util::common::ErrorReported;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -41,7 +41,7 @@ impl MetadataLoader for NoLlvmMetadataLoader {\n struct TheBackend;\n \n impl CodegenBackend for TheBackend {\n-    fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync> {\n+    fn metadata_loader(&self) -> Box<MetadataLoaderDyn> {\n         Box::new(NoLlvmMetadataLoader)\n     }\n "}]}