{"sha": "a437936d49081faa82227c7d216ff3b0d6363ed3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0Mzc5MzZkNDkwODFmYWE4MjIyN2M3ZDIxNmZmM2IwZDYzNjNlZDM=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-21T16:48:36Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-21T17:23:05Z"}, "message": "all: put often used DefPaths into utils as consts\n\nAlso remove the \"use xxx;\" blocks to ensure import paths don't change.\nThey don't work anyway since stuff may still be re-exported at the old\nlocation, while we need the \"canonical\" location for the type checks.\n\nPlus, the test suite catches all these cases.", "tree": {"sha": "20bf1d611bf527395f2b2216bcd6127b8b674d2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20bf1d611bf527395f2b2216bcd6127b8b674d2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a437936d49081faa82227c7d216ff3b0d6363ed3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a437936d49081faa82227c7d216ff3b0d6363ed3", "html_url": "https://github.com/rust-lang/rust/commit/a437936d49081faa82227c7d216ff3b0d6363ed3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a437936d49081faa82227c7d216ff3b0d6363ed3/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "707e95f2e5b9f6e20998508d99959dd1642d26ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/707e95f2e5b9f6e20998508d99959dd1642d26ec", "html_url": "https://github.com/rust-lang/rust/commit/707e95f2e5b9f6e20998508d99959dd1642d26ec"}], "stats": {"total": 46, "additions": 19, "deletions": 27}, "files": [{"sha": "70cf32e5093d841789fec53131051ed3981d325e", "filename": "src/methods.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a437936d49081faa82227c7d216ff3b0d6363ed3/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a437936d49081faa82227c7d216ff3b0d6363ed3/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=a437936d49081faa82227c7d216ff3b0d6363ed3", "patch": "@@ -3,6 +3,7 @@ use rustc::lint::*;\n use rustc::middle::ty;\n \n use utils::{span_lint, match_def_path, walk_ptrs_ty};\n+use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n \n #[derive(Copy,Clone)]\n pub struct MethodsPass;\n@@ -16,30 +17,23 @@ declare_lint!(pub STR_TO_STRING, Warn,\n declare_lint!(pub STRING_TO_STRING, Warn,\n               \"calling `String.to_string()` which is a no-op\");\n \n-#[allow(unused_imports)]\n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        {\n-            // In case stuff gets moved around\n-            use core::option::Option;\n-            use core::result::Result;\n-            use collections::string::String;\n-        }\n         if let ExprMethodCall(ref ident, _, ref args) = expr.node {\n             let ref obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(&*args[0])).sty;\n             if ident.node.name == \"unwrap\" {\n                 if let ty::TyEnum(did, _) = *obj_ty {\n-                    if match_def_path(cx, did.did, &[\"core\", \"option\", \"Option\"]) {\n+                    if match_def_path(cx, did.did, &OPTION_PATH) {\n                         span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n                                   \"used unwrap() on an Option value. If you don't want \\\n                                    to handle the None case gracefully, consider using\n                                    expect() to provide a better panic message\");\n                     }\n-                    else if match_def_path(cx, did.did, &[\"core\", \"result\", \"Result\"]) {\n+                    else if match_def_path(cx, did.did, &RESULT_PATH) {\n                         span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n                                   \"used unwrap() on a Result value. Graceful handling \\\n                                    of Err values is preferred\");\n@@ -51,7 +45,7 @@ impl LintPass for MethodsPass {\n                     span_lint(cx, STR_TO_STRING, expr.span, \"`str.to_owned()` is faster\");\n                 }\n                 else if let ty::TyStruct(did, _) = *obj_ty {\n-                    if match_def_path(cx, did.did, &[\"collections\", \"string\", \"String\"]) {\n+                    if match_def_path(cx, did.did, &STRING_PATH) {\n                         span_lint(cx, STRING_TO_STRING, expr.span,\n                                   \"`String.to_string()` is a no-op\")\n                     }"}, {"sha": "cdf4ecb48e569ac21bbba33584d23c2ff2f41841", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a437936d49081faa82227c7d216ff3b0d6363ed3/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a437936d49081faa82227c7d216ff3b0d6363ed3/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=a437936d49081faa82227c7d216ff3b0d6363ed3", "patch": "@@ -7,6 +7,7 @@ use syntax::ast::*;\n use rustc::middle::ty;\n \n use utils::{span_lint, match_def_path};\n+use utils::{STRING_PATH, VEC_PATH};\n \n declare_lint! {\n     pub PTR_ARG,\n@@ -42,27 +43,21 @@ impl LintPass for PtrArg {\n     }\n }\n \n-#[allow(unused_imports)]\n fn check_fn(cx: &Context, decl: &FnDecl) {\n-    {\n-        // In case stuff gets moved around\n-        use collections::vec::Vec;\n-        use collections::string::String;\n-    }\n     for arg in &decl.inputs {\n         if arg.ty.node == TyInfer {  // \"self\" arguments\n             continue;\n         }\n         let ref sty = cx.tcx.pat_ty(&*arg.pat).sty;\n         if let &ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = sty {\n             if let ty::TyStruct(did, _) = ty.sty {\n-                if match_def_path(cx, did.did, &[\"collections\", \"vec\", \"Vec\"]) {\n+                if match_def_path(cx, did.did, &VEC_PATH) {\n                     span_lint(cx, PTR_ARG, arg.ty.span,\n                               \"writing `&Vec<_>` instead of `&[_]` involves one more reference \\\n                                and cannot be used with non-Vec-based slices. Consider changing \\\n                                the type to `&[...]`\");\n                 }\n-                else if match_def_path(cx, did.did, &[\"collections\", \"string\", \"String\"]) {\n+                else if match_def_path(cx, did.did, &STRING_PATH) {\n                     span_lint(cx, PTR_ARG, arg.ty.span,\n                               \"writing `&String` instead of `&str` involves a new object \\\n                                where a slice will do. Consider changing the type to `&str`\");"}, {"sha": "c4fbca9344f1a1af681d97bf80b93efebf01fee7", "filename": "src/strings.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a437936d49081faa82227c7d216ff3b0d6363ed3/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a437936d49081faa82227c7d216ff3b0d6363ed3/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=a437936d49081faa82227c7d216ff3b0d6363ed3", "patch": "@@ -10,6 +10,7 @@ use syntax::codemap::Spanned;\n \n use eq_op::is_exp_equal;\n use utils::{match_def_path, span_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::STRING_PATH;\n \n declare_lint! {\n     pub STRING_ADD_ASSIGN,\n@@ -63,7 +64,7 @@ impl LintPass for StringAdd {\n fn is_string(cx: &Context, e: &Expr) -> bool {\n     let ty = walk_ptrs_ty(cx.tcx.expr_ty(e));\n     if let TyStruct(did, _) = ty.sty {\n-        match_def_path(cx, did.did, &[\"collections\", \"string\", \"String\"])\n+        match_def_path(cx, did.did, &STRING_PATH)\n     } else { false }\n }\n "}, {"sha": "57649adee8b76ffc02cff4737e648229b46e4328", "filename": "src/types.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a437936d49081faa82227c7d216ff3b0d6363ed3/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a437936d49081faa82227c7d216ff3b0d6363ed3/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=a437936d49081faa82227c7d216ff3b0d6363ed3", "patch": "@@ -6,6 +6,7 @@ use rustc::middle::ty;\n use syntax::codemap::ExpnInfo;\n \n use utils::{in_macro, match_def_path, snippet, span_lint, span_help_and_lint, in_external_macro};\n+use utils::{LL_PATH, VEC_PATH};\n \n /// Handles all the linting of funky types\n #[allow(missing_copy_implementations)]\n@@ -17,22 +18,16 @@ declare_lint!(pub LINKEDLIST, Warn,\n               \"usage of LinkedList, usually a vector is faster, or a more specialized data \\\n                structure like a RingBuf\");\n \n-#[allow(unused_imports)]\n impl LintPass for TypePass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(BOX_VEC, LINKEDLIST)\n     }\n \n     fn check_ty(&mut self, cx: &Context, ast_ty: &ast::Ty) {\n-        {\n-            // In case stuff gets moved around\n-            use collections::vec::Vec;\n-            use collections::linked_list::LinkedList;\n-        }\n         if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&ast_ty.id) {\n             if let ty::TyBox(ref inner) = ty.sty {\n                 if let ty::TyStruct(did, _) = inner.sty {\n-                    if match_def_path(cx, did.did, &[\"collections\", \"vec\", \"Vec\"]) {\n+                    if match_def_path(cx, did.did, &VEC_PATH) {\n                         span_help_and_lint(\n                             cx, BOX_VEC, ast_ty.span,\n                             \"you seem to be trying to use `Box<Vec<T>>`. Did you mean to use `Vec<T>`?\",\n@@ -41,7 +36,7 @@ impl LintPass for TypePass {\n                 }\n             }\n             if let ty::TyStruct(did, _) = ty.sty {\n-                if match_def_path(cx, did.did, &[\"collections\", \"linked_list\", \"LinkedList\"]) {\n+                if match_def_path(cx, did.did, &LL_PATH) {\n                     span_help_and_lint(\n                         cx, LINKEDLIST, ast_ty.span,\n                         \"I see you're using a LinkedList! Perhaps you meant some other data structure?\","}, {"sha": "fe5c1433c84000ce87a8c8a4f9f10c931ab83508", "filename": "src/utils.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a437936d49081faa82227c7d216ff3b0d6363ed3/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a437936d49081faa82227c7d216ff3b0d6363ed3/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=a437936d49081faa82227c7d216ff3b0d6363ed3", "patch": "@@ -6,6 +6,13 @@ use rustc::ast_map::Node::NodeExpr;\n use rustc::middle::ty;\n use std::borrow::Cow;\n \n+// module DefPaths for certain structs/enums we check for\n+pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n+pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n+pub const VEC_PATH:    [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n+pub const LL_PATH:     [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n+\n /// returns true if the macro that expanded the crate was outside of\n /// the current crate or was a compiler plugin\n pub fn in_macro(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {"}]}