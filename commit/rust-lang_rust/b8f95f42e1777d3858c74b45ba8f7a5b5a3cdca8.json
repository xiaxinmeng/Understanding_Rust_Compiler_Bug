{"sha": "b8f95f42e1777d3858c74b45ba8f7a5b5a3cdca8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4Zjk1ZjQyZTE3NzdkMzg1OGM3NGI0NWJhOGY3YTViNWEzY2RjYTg=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2019-07-27T21:50:26Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2019-07-28T21:33:10Z"}, "message": "Support destructuring patterns", "tree": {"sha": "eea9b89f4b455ef8b29d4588f849d9eba09329df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eea9b89f4b455ef8b29d4588f849d9eba09329df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8f95f42e1777d3858c74b45ba8f7a5b5a3cdca8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8f95f42e1777d3858c74b45ba8f7a5b5a3cdca8", "html_url": "https://github.com/rust-lang/rust/commit/b8f95f42e1777d3858c74b45ba8f7a5b5a3cdca8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8f95f42e1777d3858c74b45ba8f7a5b5a3cdca8/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de278d164906d6d29974790c5a4db28303692484", "url": "https://api.github.com/repos/rust-lang/rust/commits/de278d164906d6d29974790c5a4db28303692484", "html_url": "https://github.com/rust-lang/rust/commit/de278d164906d6d29974790c5a4db28303692484"}], "stats": {"total": 358, "additions": 311, "deletions": 47}, "files": [{"sha": "a524e014f10a82c810759b154f7624612e45a93f", "filename": "crates/ra_ide_api/src/inlay_hints.rs", "status": "modified", "additions": 305, "deletions": 47, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/b8f95f42e1777d3858c74b45ba8f7a5b5a3cdca8/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8f95f42e1777d3858c74b45ba8f7a5b5a3cdca8/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs?ref=b8f95f42e1777d3858c74b45ba8f7a5b5a3cdca8", "patch": "@@ -1,17 +1,22 @@\n use crate::{db::RootDatabase, FileId};\n use hir::{HirDisplay, SourceAnalyzer, Ty};\n-use ra_syntax::ast::Pat;\n use ra_syntax::{\n     algo::visit::{visitor, Visitor},\n-    ast::{self, PatKind, TypeAscriptionOwner},\n-    AstNode, SmolStr, SourceFile, SyntaxNode, TextRange,\n+    ast::{\n+        AstNode, ForExpr, IfExpr, LambdaExpr, LetStmt, MatchArmList, Pat, PatKind, SourceFile,\n+        TypeAscriptionOwner, WhileExpr,\n+    },\n+    SmolStr, SyntaxKind, SyntaxNode, TextRange,\n };\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum InlayKind {\n     LetBindingType,\n     ClosureParameterType,\n     ForExpressionBindingType,\n+    IfExpressionType,\n+    WhileLetExpressionType,\n+    MatchArmType,\n }\n \n #[derive(Debug)]\n@@ -35,35 +40,62 @@ fn get_inlay_hints(\n     node: &SyntaxNode,\n ) -> Option<Vec<InlayHint>> {\n     visitor()\n-        .visit(|let_statement: ast::LetStmt| {\n+        .visit(|let_statement: LetStmt| {\n             if let_statement.ascribed_type().is_some() {\n                 return None;\n             }\n+            let pat = let_statement.pat()?;\n             let analyzer = SourceAnalyzer::new(db, file_id, let_statement.syntax(), None);\n-            Some(get_pat_hints(db, &analyzer, let_statement.pat()?, InlayKind::LetBindingType))\n+            Some(get_pat_hints(db, &analyzer, pat, InlayKind::LetBindingType, false))\n         })\n-        .visit(|closure_parameter: ast::LambdaExpr| {\n+        .visit(|closure_parameter: LambdaExpr| {\n             let analyzer = SourceAnalyzer::new(db, file_id, closure_parameter.syntax(), None);\n             closure_parameter.param_list().map(|param_list| {\n                 param_list\n                     .params()\n                     .filter(|closure_param| closure_param.ascribed_type().is_none())\n                     .filter_map(|closure_param| closure_param.pat())\n                     .map(|root_pat| {\n-                        get_pat_hints(db, &analyzer, root_pat, InlayKind::ClosureParameterType)\n+                        get_pat_hints(\n+                            db,\n+                            &analyzer,\n+                            root_pat,\n+                            InlayKind::ClosureParameterType,\n+                            false,\n+                        )\n                     })\n                     .flatten()\n                     .collect()\n             })\n         })\n-        .visit(|for_expression: ast::ForExpr| {\n+        .visit(|for_expression: ForExpr| {\n+            let pat = for_expression.pat()?;\n             let analyzer = SourceAnalyzer::new(db, file_id, for_expression.syntax(), None);\n-            Some(get_pat_hints(\n-                db,\n-                &analyzer,\n-                for_expression.pat()?,\n-                InlayKind::ForExpressionBindingType,\n-            ))\n+            Some(get_pat_hints(db, &analyzer, pat, InlayKind::ForExpressionBindingType, false))\n+        })\n+        .visit(|if_expr: IfExpr| {\n+            let pat = if_expr.condition()?.pat()?;\n+            let analyzer = SourceAnalyzer::new(db, file_id, if_expr.syntax(), None);\n+            Some(get_pat_hints(db, &analyzer, pat, InlayKind::IfExpressionType, true))\n+        })\n+        .visit(|while_expr: WhileExpr| {\n+            let pat = while_expr.condition()?.pat()?;\n+            let analyzer = SourceAnalyzer::new(db, file_id, while_expr.syntax(), None);\n+            Some(get_pat_hints(db, &analyzer, pat, InlayKind::WhileLetExpressionType, true))\n+        })\n+        .visit(|match_arm_list: MatchArmList| {\n+            let analyzer = SourceAnalyzer::new(db, file_id, match_arm_list.syntax(), None);\n+            Some(\n+                match_arm_list\n+                    .arms()\n+                    .map(|match_arm| match_arm.pats())\n+                    .flatten()\n+                    .map(|root_pat| {\n+                        get_pat_hints(db, &analyzer, root_pat, InlayKind::MatchArmType, true)\n+                    })\n+                    .flatten()\n+                    .collect(),\n+            )\n         })\n         .accept(&node)?\n }\n@@ -73,9 +105,13 @@ fn get_pat_hints(\n     analyzer: &SourceAnalyzer,\n     root_pat: Pat,\n     kind: InlayKind,\n+    skip_root_pat_hint: bool,\n ) -> Vec<InlayHint> {\n+    let original_pat = &root_pat.clone();\n+\n     get_leaf_pats(root_pat)\n         .into_iter()\n+        .filter(|pat| !skip_root_pat_hint || pat != original_pat)\n         .filter_map(|pat| {\n             get_node_displayable_type(db, &analyzer, &pat)\n                 .map(|pat_type| (pat.syntax().text_range(), pat_type))\n@@ -108,6 +144,27 @@ fn get_leaf_pats(root_pat: Pat) -> Vec<Pat> {\n                     pats_to_process.push_back(arg_pat);\n                 }\n             }\n+            PatKind::StructPat(struct_pat) => {\n+                if let Some(pat_list) = struct_pat.field_pat_list() {\n+                    pats_to_process.extend(\n+                        pat_list\n+                            .field_pats()\n+                            .filter_map(|field_pat| {\n+                                field_pat\n+                                    .pat()\n+                                    .filter(|pat| pat.syntax().kind() != SyntaxKind::BIND_PAT)\n+                            })\n+                            .chain(pat_list.bind_pats().map(|bind_pat| {\n+                                bind_pat.pat().unwrap_or_else(|| Pat::from(bind_pat))\n+                            })),\n+                    );\n+                }\n+            }\n+            PatKind::TupleStructPat(tuple_struct_pat) => {\n+                for arg_pat in tuple_struct_pat.args() {\n+                    pats_to_process.push_back(arg_pat);\n+                }\n+            }\n             _ => (),\n         }\n     }\n@@ -134,10 +191,20 @@ mod tests {\n     use insta::assert_debug_snapshot_matches;\n \n     #[test]\n-    fn test_inlay_hints() {\n+    fn let_statement() {\n         let (analysis, file_id) = single_file(\n             r#\"\n-struct OuterStruct {}\n+#[derive(PartialEq)]\n+enum CustomOption<T> {\n+    None,\n+    Some(T),\n+}\n+\n+#[derive(PartialEq)]\n+struct Test {\n+    a: CustomOption<u32>,\n+    b: u8,\n+}\n \n fn main() {\n     struct InnerStruct {}\n@@ -148,91 +215,282 @@ fn main() {\n     let _ = 22;\n     let test = \"test\";\n     let test = InnerStruct {};\n-    let test = OuterStruct {};\n \n     let test = vec![222];\n     let test: Vec<_> = (0..3).collect();\n+    let test = (0..3).collect::<Vec<i128>>();\n+    let test = (0..3).collect::<Vec<_>>();\n \n     let mut test = Vec::new();\n     test.push(333);\n \n-    let test = test.into_iter().map(|i| i * i).collect::<Vec<_>>();\n-    let test = test.into_iter().map(|i| i * i).collect::<Vec<u128>>();\n-\n-    let _ = (0..23).map(|i: u32| {\n-        let i_squared = i * i;\n-        i_squared\n-    });\n-\n     let test = (42, 'a');\n     let (a, (b, c, (d, e), f)) = (2, (3, 4, (6.6, 7.7), 5));\n-\n-    let test = Some((2, 3));\n-    for (i, j) in test {}\n-}\n-\"#,\n+}\"#,\n         );\n \n         assert_debug_snapshot_matches!(analysis.inlay_hints(file_id).unwrap(), @r#\"[\n     InlayHint {\n-        range: [71; 75),\n+        range: [193; 197),\n         kind: LetBindingType,\n         label: \"i32\",\n     },\n     InlayHint {\n-        range: [114; 122),\n+        range: [236; 244),\n         kind: LetBindingType,\n         label: \"i32\",\n     },\n     InlayHint {\n-        range: [153; 157),\n+        range: [275; 279),\n         kind: LetBindingType,\n         label: \"&str\",\n     },\n     InlayHint {\n-        range: [207; 211),\n+        range: [539; 543),\n         kind: LetBindingType,\n-        label: \"OuterStruct\",\n+        label: \"(i32, char)\",\n     },\n     InlayHint {\n-        range: [538; 547),\n+        range: [566; 567),\n         kind: LetBindingType,\n-        label: \"u32\",\n+        label: \"i32\",\n     },\n     InlayHint {\n-        range: [592; 596),\n+        range: [570; 571),\n         kind: LetBindingType,\n-        label: \"(i32, char)\",\n+        label: \"i32\",\n     },\n     InlayHint {\n-        range: [619; 620),\n+        range: [573; 574),\n         kind: LetBindingType,\n         label: \"i32\",\n     },\n     InlayHint {\n-        range: [623; 624),\n+        range: [584; 585),\n         kind: LetBindingType,\n         label: \"i32\",\n     },\n     InlayHint {\n-        range: [626; 627),\n+        range: [577; 578),\n+        kind: LetBindingType,\n+        label: \"f64\",\n+    },\n+    InlayHint {\n+        range: [580; 581),\n         kind: LetBindingType,\n+        label: \"f64\",\n+    },\n+]\"#\n+        );\n+    }\n+\n+    #[test]\n+    fn closure_parameter() {\n+        let (analysis, file_id) = single_file(\n+            r#\"\n+fn main() {\n+    let mut start = 0;\n+    (0..2).for_each(|increment| {\n+        start += increment;\n+    })\n+}\"#,\n+        );\n+\n+        assert_debug_snapshot_matches!(analysis.inlay_hints(file_id).unwrap(), @r#\"[\n+    InlayHint {\n+        range: [21; 30),\n+        kind: LetBindingType,\n+        label: \"i32\",\n+    },\n+    InlayHint {\n+        range: [57; 66),\n+        kind: ClosureParameterType,\n         label: \"i32\",\n     },\n+]\"#\n+        );\n+    }\n+\n+    #[test]\n+    fn for_expression() {\n+        let (analysis, file_id) = single_file(\n+            r#\"\n+fn main() {\n+    let mut start = 0;\n+    for increment in 0..2 {\n+        start += increment;\n+    }\n+}\"#,\n+        );\n+\n+        assert_debug_snapshot_matches!(analysis.inlay_hints(file_id).unwrap(), @r#\"[\n     InlayHint {\n-        range: [637; 638),\n+        range: [21; 30),\n         kind: LetBindingType,\n         label: \"i32\",\n     },\n     InlayHint {\n-        range: [630; 631),\n+        range: [44; 53),\n+        kind: ForExpressionBindingType,\n+        label: \"i32\",\n+    },\n+]\"#\n+        );\n+    }\n+\n+    #[test]\n+    fn if_expr() {\n+        let (analysis, file_id) = single_file(\n+            r#\"\n+#[derive(PartialEq)]\n+enum CustomOption<T> {\n+    None,\n+    Some(T),\n+}\n+\n+#[derive(PartialEq)]\n+struct Test {\n+    a: CustomOption<u32>,\n+    b: u8,\n+}\n+\n+fn main() {\n+    let test = CustomOption::Some(Test { a: CustomOption::Some(3), b: 1 });\n+    if let CustomOption::None = &test {};\n+    if let test = &test {};\n+    if let CustomOption::Some(test) = &test {};\n+    if let CustomOption::Some(Test { a, b }) = &test {};\n+    if let CustomOption::Some(Test { a: x, b: y }) = &test {};\n+    if let CustomOption::Some(Test { a: CustomOption::Some(x), b: y }) = &test {};\n+    if let CustomOption::Some(Test { a: CustomOption::None, b: y }) = &test {};\n+    if let CustomOption::Some(Test { b: y, .. }) = &test {};\n+    \n+    if test == CustomOption::None {}\n+}\"#,\n+        );\n+\n+        assert_debug_snapshot_matches!(analysis.inlay_hints(file_id).unwrap(), @r#\"[\n+    InlayHint {\n+        range: [166; 170),\n         kind: LetBindingType,\n-        label: \"f64\",\n+        label: \"CustomOption<Test>\",\n+    },\n+    InlayHint {\n+        range: [334; 338),\n+        kind: IfExpressionType,\n+        label: \"&Test\",\n+    },\n+    InlayHint {\n+        range: [389; 390),\n+        kind: IfExpressionType,\n+        label: \"&CustomOption<u32>\",\n+    },\n+    InlayHint {\n+        range: [392; 393),\n+        kind: IfExpressionType,\n+        label: \"&u8\",\n+    },\n+    InlayHint {\n+        range: [531; 532),\n+        kind: IfExpressionType,\n+        label: \"&u32\",\n     },\n+]\"#\n+        );\n+    }\n+\n+    #[test]\n+    fn while_expr() {\n+        let (analysis, file_id) = single_file(\n+            r#\"\n+#[derive(PartialEq)]\n+enum CustomOption<T> {\n+    None,\n+    Some(T),\n+}\n+\n+#[derive(PartialEq)]\n+struct Test {\n+    a: CustomOption<u32>,\n+    b: u8,\n+}\n+\n+fn main() {\n+    let test = CustomOption::Some(Test { a: CustomOption::Some(3), b: 1 });\n+    while let CustomOption::None = &test {};\n+    while let test = &test {};\n+    while let CustomOption::Some(test) = &test {};\n+    while let CustomOption::Some(Test { a, b }) = &test {};\n+    while let CustomOption::Some(Test { a: x, b: y }) = &test {};\n+    while let CustomOption::Some(Test { a: CustomOption::Some(x), b: y }) = &test {};\n+    while let CustomOption::Some(Test { a: CustomOption::None, b: y }) = &test {};\n+    while let CustomOption::Some(Test { b: y, .. }) = &test {};\n+    \n+    while test == CustomOption::None {}\n+}\"#,\n+        );\n+\n+        assert_debug_snapshot_matches!(analysis.inlay_hints(file_id).unwrap(), @r#\"[\n     InlayHint {\n-        range: [633; 634),\n+        range: [166; 170),\n         kind: LetBindingType,\n-        label: \"f64\",\n+        label: \"CustomOption<Test>\",\n+    },\n+]\"#\n+        );\n+    }\n+\n+    #[test]\n+    fn match_arm_list() {\n+        let (analysis, file_id) = single_file(\n+            r#\"\n+#[derive(PartialEq)]\n+enum CustomOption<T> { \n+    None,\n+    Some(T),\n+}\n+\n+#[derive(PartialEq)]\n+struct Test {\n+    a: CustomOption<u32>,\n+    b: u8,\n+}\n+\n+fn main() {\n+    match CustomOption::Some(Test { a: CustomOption::Some(3), b: 1 }) {\n+        CustomOption::None => (),\n+        test => (),\n+        CustomOption::Some(test) => (),\n+        CustomOption::Some(Test { a, b }) => (),\n+        CustomOption::Some(Test { a: x, b: y }) => (),\n+        CustomOption::Some(Test { a: CustomOption::Some(x), b: y }) => (),\n+        CustomOption::Some(Test { a: CustomOption::None, b: y }) => (),\n+        CustomOption::Some(Test { b: y, .. }) => (),\n+        _ => {}\n+    }\n+}\"#,\n+        );\n+\n+        assert_debug_snapshot_matches!(analysis.inlay_hints(file_id).unwrap(), @r#\"[\n+    InlayHint {\n+        range: [312; 316),\n+        kind: MatchArmType,\n+        label: \"Test\",\n+    },\n+    InlayHint {\n+        range: [359; 360),\n+        kind: MatchArmType,\n+        label: \"CustomOption<u32>\",\n+    },\n+    InlayHint {\n+        range: [362; 363),\n+        kind: MatchArmType,\n+        label: \"u8\",\n+    },\n+    InlayHint {\n+        range: [485; 486),\n+        kind: MatchArmType,\n+        label: \"u32\",\n     },\n ]\"#\n         );"}, {"sha": "9006aa316f161ca3f8b6d79c36686b7da5cf58fd", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8f95f42e1777d3858c74b45ba8f7a5b5a3cdca8/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8f95f42e1777d3858c74b45ba8f7a5b5a3cdca8/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=b8f95f42e1777d3858c74b45ba8f7a5b5a3cdca8", "patch": "@@ -900,6 +900,9 @@ pub fn handle_inlay_hints(\n                 ra_ide_api::InlayKind::ForExpressionBindingType => {\n                     InlayKind::ForExpressionBindingType\n                 }\n+                ra_ide_api::InlayKind::IfExpressionType => InlayKind::IfExpressionType,\n+                ra_ide_api::InlayKind::WhileLetExpressionType => InlayKind::WhileLetExpressionType,\n+                ra_ide_api::InlayKind::MatchArmType => InlayKind::MatchArmType,\n             },\n         })\n         .collect())"}, {"sha": "57043864382049a8bb0b83205255f57fe3863634", "filename": "crates/ra_lsp_server/src/req.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8f95f42e1777d3858c74b45ba8f7a5b5a3cdca8/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8f95f42e1777d3858c74b45ba8f7a5b5a3cdca8/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Freq.rs?ref=b8f95f42e1777d3858c74b45ba8f7a5b5a3cdca8", "patch": "@@ -216,6 +216,9 @@ pub enum InlayKind {\n     LetBindingType,\n     ClosureParameterType,\n     ForExpressionBindingType,\n+    IfExpressionType,\n+    WhileLetExpressionType,\n+    MatchArmType,\n }\n \n #[derive(Debug, Deserialize, Serialize)]"}]}