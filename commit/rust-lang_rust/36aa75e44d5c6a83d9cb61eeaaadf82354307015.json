{"sha": "36aa75e44d5c6a83d9cb61eeaaadf82354307015", "node_id": "C_kwDOAAsO6NoAKDM2YWE3NWU0NGQ1YzZhODNkOWNiNjFlZWFhYWRmODIzNTQzMDcwMTU", "commit": {"author": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-03-30T09:38:22Z"}, "committer": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-04-05T07:14:04Z"}, "message": "Complete reads and writes synchronously or abort", "tree": {"sha": "caad2b53117be3cdf76b8616dff8ba8f5fa6db27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caad2b53117be3cdf76b8616dff8ba8f5fa6db27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36aa75e44d5c6a83d9cb61eeaaadf82354307015", "comment_count": 1, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+p/jD6jrzmnSIWJLcTRy8vRWJ94FAmJL7EUACgkQcTRy8vRW\nJ941HQ//QuWfI8PdAzfNYTr7w1O75XorwtujJ2DTwNH/datlWFt9R/AlxApK0+pX\n+j0ya9EPcvhW/iutXMWBlRTmo5Qj10Y+2/zjxccgkZZWbVnr89QKqV3/4uu8KCrJ\nqxx1oIRkQR3acQmNvR3wUoun5poXC9IeT55zzLXc+zc2JGVIe3hus6bxmhQ5Nh7G\n1wPBA0iswJjcMRmoJPDjtcrjVSBHKF2KEDOhEwxLN7PpjHWeC+MJfnRAjTrm2wCi\nzayfo7E9pgZ/S8VPqqbXDmaaK8DzH9uOafYl1F9XVh4cI/nhKxf54DV7gZAa1Kxt\nVwxuTzJXP2LzhdnnzJMVuBiODyh6ODUFmMFh4xZIEaRB9XQuGTTRLROtiBhTiDpk\nMoJ7MB3n2tb4pAOYr9pSev9BxAq6Gsle776Trw7x7xDRfD2qUBG+6XMn29p/tSBB\n9WhEd8Y+HGITiqCqZWJpT9l/Ix+47Nou/cioCWGhNuX/X+5IAc+nv6Odjs11Lu5n\nXd9oo7AZWuGWFIKdDGSG7eDTkb4EF+KEHX5esdpu8+wAcDnRQnG+l4CXfchqKst7\nI6ytewqTCd044ocSS7/FtHD4+Er/17aGVPVCs0w9t5/FnE1i4LsgrECBqcTB3w+y\n3suc4jNgfFIOacmW0VWbUp5EtRVZH0tUuQ1Ao5+rlTMIpTpCWFc=\n=mJfd\n-----END PGP SIGNATURE-----", "payload": "tree caad2b53117be3cdf76b8616dff8ba8f5fa6db27\nparent 66faaa817ac28a64c05964cd0aa4999d793a1d1c\nauthor Chris Denton <christophersdenton@gmail.com> 1648633102 +0100\ncommitter Chris Denton <christophersdenton@gmail.com> 1649142844 +0100\n\nComplete reads and writes synchronously or abort\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36aa75e44d5c6a83d9cb61eeaaadf82354307015", "html_url": "https://github.com/rust-lang/rust/commit/36aa75e44d5c6a83d9cb61eeaaadf82354307015", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36aa75e44d5c6a83d9cb61eeaaadf82354307015/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66faaa817ac28a64c05964cd0aa4999d793a1d1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/66faaa817ac28a64c05964cd0aa4999d793a1d1c", "html_url": "https://github.com/rust-lang/rust/commit/66faaa817ac28a64c05964cd0aa4999d793a1d1c"}], "stats": {"total": 203, "additions": 137, "deletions": 66}, "files": [{"sha": "1528db7362e64d44f032536ba4aef2a43fa677bf", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/36aa75e44d5c6a83d9cb61eeaaadf82354307015/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36aa75e44d5c6a83d9cb61eeaaadf82354307015/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=36aa75e44d5c6a83d9cb61eeaaadf82354307015", "patch": "@@ -274,6 +274,9 @@ pub const STATUS_SUCCESS: NTSTATUS = 0x00000000;\n pub const STATUS_DELETE_PENDING: NTSTATUS = 0xc0000056_u32 as _;\n pub const STATUS_INVALID_PARAMETER: NTSTATUS = 0xc000000d_u32 as _;\n \n+pub const STATUS_PENDING: NTSTATUS = 0x103 as _;\n+pub const STATUS_END_OF_FILE: NTSTATUS = 0xC0000011_u32 as _;\n+\n // Equivalent to the `NT_SUCCESS` C preprocessor macro.\n // See: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values\n pub fn nt_success(status: NTSTATUS) -> bool {\n@@ -338,6 +341,12 @@ pub type LPOVERLAPPED_COMPLETION_ROUTINE = unsafe extern \"system\" fn(\n     lpOverlapped: *mut OVERLAPPED,\n );\n \n+type IO_APC_ROUTINE = unsafe extern \"system\" fn(\n+    ApcContext: *mut c_void,\n+    IoStatusBlock: *mut IO_STATUS_BLOCK,\n+    Reserved: ULONG,\n+);\n+\n #[repr(C)]\n #[cfg(not(target_pointer_width = \"64\"))]\n pub struct WSADATA {\n@@ -1274,6 +1283,32 @@ compat_fn! {\n     ) -> NTSTATUS {\n         panic!(\"`NtCreateFile` not available\");\n     }\n+    pub fn NtReadFile(\n+        FileHandle: BorrowedHandle<'_>,\n+        Event: HANDLE,\n+        ApcRoutine: Option<IO_APC_ROUTINE>,\n+        ApcContext: *mut c_void,\n+        IoStatusBlock: &mut IO_STATUS_BLOCK,\n+        Buffer: *mut crate::mem::MaybeUninit<u8>,\n+        Length: ULONG,\n+        ByteOffset: Option<&LARGE_INTEGER>,\n+        Key: Option<&ULONG>\n+    ) -> NTSTATUS {\n+        panic!(\"`NtReadFile` not available\");\n+    }\n+    pub fn NtWriteFile(\n+        FileHandle: BorrowedHandle<'_>,\n+        Event: HANDLE,\n+        ApcRoutine: Option<IO_APC_ROUTINE>,\n+        ApcContext: *mut c_void,\n+        IoStatusBlock: &mut IO_STATUS_BLOCK,\n+        Buffer: *const u8,\n+        Length: ULONG,\n+        ByteOffset: Option<&LARGE_INTEGER>,\n+        Key: Option<&ULONG>\n+    ) -> NTSTATUS {\n+        panic!(\"`NtWriteFile` not available\");\n+    }\n     pub fn RtlNtStatusToDosError(\n         Status: NTSTATUS\n     ) -> ULONG {"}, {"sha": "c3e1b9587a4a816f1e690b6f57c0fdd6ffc69f3a", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 102, "deletions": 66, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/36aa75e44d5c6a83d9cb61eeaaadf82354307015/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36aa75e44d5c6a83d9cb61eeaaadf82354307015/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=36aa75e44d5c6a83d9cb61eeaaadf82354307015", "patch": "@@ -74,20 +74,10 @@ impl FromRawHandle for Handle {\n \n impl Handle {\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        let mut read = 0;\n-        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n-        let res = cvt(unsafe {\n-            c::ReadFile(\n-                self.as_handle(),\n-                buf.as_mut_ptr() as c::LPVOID,\n-                len,\n-                &mut read,\n-                ptr::null_mut(),\n-            )\n-        });\n+        let res = unsafe { self.synchronous_read(buf.as_mut_ptr().cast(), buf.len(), None) };\n \n         match res {\n-            Ok(_) => Ok(read as usize),\n+            Ok(read) => Ok(read as usize),\n \n             // The special treatment of BrokenPipe is to deal with Windows\n             // pipe semantics, which yields this error when *reading* from\n@@ -109,42 +99,23 @@ impl Handle {\n     }\n \n     pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n-        let mut read = 0;\n-        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n-        let res = unsafe {\n-            let mut overlapped: c::OVERLAPPED = mem::zeroed();\n-            overlapped.Offset = offset as u32;\n-            overlapped.OffsetHigh = (offset >> 32) as u32;\n-            cvt(c::ReadFile(\n-                self.as_handle(),\n-                buf.as_mut_ptr() as c::LPVOID,\n-                len,\n-                &mut read,\n-                &mut overlapped,\n-            ))\n-        };\n+        let res =\n+            unsafe { self.synchronous_read(buf.as_mut_ptr().cast(), buf.len(), Some(offset)) };\n+\n         match res {\n-            Ok(_) => Ok(read as usize),\n+            Ok(read) => Ok(read as usize),\n             Err(ref e) if e.raw_os_error() == Some(c::ERROR_HANDLE_EOF as i32) => Ok(0),\n             Err(e) => Err(e),\n         }\n     }\n \n     pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        let mut read = 0;\n-        let len = cmp::min(buf.remaining(), <c::DWORD>::MAX as usize) as c::DWORD;\n-        let res = cvt(unsafe {\n-            c::ReadFile(\n-                self.as_handle(),\n-                buf.unfilled_mut().as_mut_ptr() as c::LPVOID,\n-                len,\n-                &mut read,\n-                ptr::null_mut(),\n-            )\n-        });\n+        let res = unsafe {\n+            self.synchronous_read(buf.unfilled_mut().as_mut_ptr(), buf.remaining(), None)\n+        };\n \n         match res {\n-            Ok(_) => {\n+            Ok(read) => {\n                 // Safety: `read` bytes were written to the initialized portion of the buffer\n                 unsafe {\n                     buf.assume_init(read as usize);\n@@ -221,18 +192,7 @@ impl Handle {\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        let mut amt = 0;\n-        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n-        cvt(unsafe {\n-            c::WriteFile(\n-                self.as_handle(),\n-                buf.as_ptr() as c::LPVOID,\n-                len,\n-                &mut amt,\n-                ptr::null_mut(),\n-            )\n-        })?;\n-        Ok(amt as usize)\n+        unsafe { self.synchronous_write(&buf, None) }\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n@@ -245,21 +205,7 @@ impl Handle {\n     }\n \n     pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n-        let mut written = 0;\n-        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n-        unsafe {\n-            let mut overlapped: c::OVERLAPPED = mem::zeroed();\n-            overlapped.Offset = offset as u32;\n-            overlapped.OffsetHigh = (offset >> 32) as u32;\n-            cvt(c::WriteFile(\n-                self.as_handle(),\n-                buf.as_ptr() as c::LPVOID,\n-                len,\n-                &mut written,\n-                &mut overlapped,\n-            ))?;\n-        }\n-        Ok(written as usize)\n+        unsafe { self.synchronous_write(&buf, Some(offset)) }\n     }\n \n     pub fn try_clone(&self) -> io::Result<Self> {\n@@ -274,6 +220,96 @@ impl Handle {\n     ) -> io::Result<Self> {\n         Ok(Self(self.0.duplicate(access, inherit, options)?))\n     }\n+\n+    /// Performs a synchronous read.\n+    ///\n+    /// If the handle is opened for asynchronous I/O then this abort the process.\n+    /// See #81357.\n+    ///\n+    /// If `offset` is `None` then the current file position is used.\n+    unsafe fn synchronous_read(\n+        &self,\n+        buf: *mut mem::MaybeUninit<u8>,\n+        len: usize,\n+        offset: Option<u64>,\n+    ) -> io::Result<usize> {\n+        let mut io_status = c::IO_STATUS_BLOCK::default();\n+\n+        // The length is clamped at u32::MAX.\n+        let len = cmp::min(len, c::DWORD::MAX as usize) as c::DWORD;\n+        let status = c::NtReadFile(\n+            self.as_handle(),\n+            ptr::null_mut(),\n+            None,\n+            ptr::null_mut(),\n+            &mut io_status,\n+            buf,\n+            len,\n+            offset.map(|n| n as _).as_ref(),\n+            None,\n+        );\n+        match status {\n+            // If the operation has not completed then abort the process.\n+            // Doing otherwise means that the buffer and stack may be written to\n+            // after this function returns.\n+            c::STATUS_PENDING => {\n+                eprintln!(\"I/O error: operation failed to complete synchronously\");\n+                crate::process::abort();\n+            }\n+\n+            // Return `Ok(0)` when there's nothing more to read.\n+            c::STATUS_END_OF_FILE => Ok(0),\n+\n+            // Success!\n+            status if c::nt_success(status) => Ok(io_status.Information),\n+\n+            status => {\n+                let error = c::RtlNtStatusToDosError(status);\n+                Err(io::Error::from_raw_os_error(error as _))\n+            }\n+        }\n+    }\n+\n+    /// Performs a synchronous write.\n+    ///\n+    /// If the handle is opened for asynchronous I/O then this abort the process.\n+    /// See #81357.\n+    ///\n+    /// If `offset` is `None` then the current file position is used.\n+    unsafe fn synchronous_write(&self, buf: &[u8], offset: Option<u64>) -> io::Result<usize> {\n+        let mut io_status = c::IO_STATUS_BLOCK::default();\n+\n+        // The length is clamped at u32::MAX.\n+        let len = cmp::min(buf.len(), c::DWORD::MAX as usize) as c::DWORD;\n+        let status = c::NtWriteFile(\n+            self.as_handle(),\n+            ptr::null_mut(),\n+            None,\n+            ptr::null_mut(),\n+            &mut io_status,\n+            buf.as_ptr(),\n+            len,\n+            offset.map(|n| n as _).as_ref(),\n+            None,\n+        );\n+        match status {\n+            // If the operation has not completed then abort the process.\n+            // Doing otherwise means that the buffer maybe read and the stack\n+            // written to after this function returns.\n+            c::STATUS_PENDING => {\n+                eprintln!(\"I/O error: operation failed to complete synchronously\");\n+                crate::process::abort();\n+            }\n+\n+            // Success!\n+            status if c::nt_success(status) => Ok(io_status.Information),\n+\n+            status => {\n+                let error = c::RtlNtStatusToDosError(status);\n+                Err(io::Error::from_raw_os_error(error as _))\n+            }\n+        }\n+    }\n }\n \n impl<'a> Read for &'a Handle {"}]}