{"sha": "d09466ceb1374bd0ff1c490bfd50133b8ca67558", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwOTQ2NmNlYjEzNzRiZDBmZjFjNDkwYmZkNTAxMzNiOGNhNjc1NTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-30T19:24:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-30T19:24:17Z"}, "message": "Auto merge of #56381 - kennytm:rollup, r=kennytm\n\nRollup of 19 pull requests\n\nSuccessful merges:\n\n - #55011 (Add libstd Cargo feature \"panic_immediate_abort\")\n - #55821 (Use sort_by_cached_key when the key function is not trivial/free)\n - #56014 (add test for issue #21335)\n - #56131 (Assorted tweaks)\n - #56214 (Implement chalk unification routines)\n - #56216 (Add TryFrom<&[T]> for [T; $N] where T: Copy)\n - #56268 (Reuse the `P` in `InvocationCollector::fold_{,opt_}expr`.)\n - #56324 (Use raw_entry for more efficient interning)\n - #56336 (Clean up and streamline the pretty-printer)\n - #56337 (Fix const_fn ICE with non-const function pointer)\n - #56339 (Remove not used option)\n - #56341 (Rename conversion util; remove duplicate util in librustc_codegen_llvm.)\n - #56349 (rustc 1.30.0's linker flavor inference is a non-backwards compat change to -Clinker)\n - #56355 (Add inline attributes and add unit to CommonTypes)\n - #56360 (Optimize local linkchecker program)\n - #56364 (Fix panic with outlives in existential type)\n - #56365 (Stabilize self_struct_ctor feature.)\n - #56367 (Moved some feature gate tests to correct location)\n - #56373 (Update books)", "tree": {"sha": "f7d8b25b1458f3510341df1ff85dba2a910fecf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7d8b25b1458f3510341df1ff85dba2a910fecf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d09466ceb1374bd0ff1c490bfd50133b8ca67558", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d09466ceb1374bd0ff1c490bfd50133b8ca67558", "html_url": "https://github.com/rust-lang/rust/commit/d09466ceb1374bd0ff1c490bfd50133b8ca67558", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d09466ceb1374bd0ff1c490bfd50133b8ca67558/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d48ab693d1ce99f30c0cf9abdf45c209824fe825", "url": "https://api.github.com/repos/rust-lang/rust/commits/d48ab693d1ce99f30c0cf9abdf45c209824fe825", "html_url": "https://github.com/rust-lang/rust/commit/d48ab693d1ce99f30c0cf9abdf45c209824fe825"}, {"sha": "a6c477152026f9b652bbca3fd1dbe13c7a47ffdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf", "html_url": "https://github.com/rust-lang/rust/commit/a6c477152026f9b652bbca3fd1dbe13c7a47ffdf"}], "stats": {"total": 2764, "additions": 1908, "deletions": 856}, "files": [{"sha": "4a136cff1cdf241a8445e39cfdec15fb6936cb9a", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -65,3 +65,6 @@\n [submodule \"src/doc/rustc-guide\"]\n \tpath = src/doc/rustc-guide\n \turl = https://github.com/rust-lang/rustc-guide.git\n+[submodule \"src/doc/edition-guide\"]\n+\tpath = src/doc/edition-guide\n+\turl = https://github.com/rust-lang-nursery/edition-guide"}, {"sha": "18a2b950e59664ddd472958f4638049442031835", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -70,6 +70,7 @@ macro_rules! book {\n book!(\n     Nomicon, \"src/doc/nomicon\", \"nomicon\";\n     Reference, \"src/doc/reference\", \"reference\";\n+    EditionGuide, \"src/doc/edition-guide\", \"edition-guide\";\n     RustdocBook, \"src/doc/rustdoc\", \"rustdoc\";\n     RustcBook, \"src/doc/rustc\", \"rustc\";\n     RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\";"}, {"sha": "ad895867b675199a7f597ce7045a56875a7e516a", "filename": "src/doc/edition-guide", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -0,0 +1 @@\n+Subproject commit ad895867b675199a7f597ce7045a56875a7e516a"}, {"sha": "b7eb4a087207af2405c0669fa577f8545b894c66", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -1 +1 @@\n-Subproject commit f8a4e96feb2e5a6ed1ef170ad40e3509a7755cb4\n+Subproject commit b7eb4a087207af2405c0669fa577f8545b894c66"}, {"sha": "b4742c48a32ff7f13f26d536a2677b031f94a882", "filename": "src/doc/unstable-book/src/language-features/self-struct-ctor.md", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d48ab693d1ce99f30c0cf9abdf45c209824fe825/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fself-struct-ctor.md", "raw_url": "https://github.com/rust-lang/rust/raw/d48ab693d1ce99f30c0cf9abdf45c209824fe825/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fself-struct-ctor.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fself-struct-ctor.md?ref=d48ab693d1ce99f30c0cf9abdf45c209824fe825", "patch": "@@ -1,33 +0,0 @@\n-# `self_struct_ctor`\n-\n-The tracking issue for this feature is: [#51994]\n-[#51994]: https://github.com/rust-lang/rust/issues/51994\n-\n-------------------------\n-\n-The `self_struct_ctor` feature gate lets you use the special `Self`\n-identifier as a constructor and a pattern.\n-\n-A simple example is:\n-\n-```rust\n-#![feature(self_struct_ctor)]\n-\n-struct ST(i32, i32);\n-\n-impl ST {\n-    fn new() -> Self {\n-        ST(0, 1)\n-    }\n-\n-    fn ctor() -> Self {\n-        Self(1,2)           // constructed by `Self`, it is the same as `ST(1, 2)`\n-    }\n-\n-    fn pattern(self) {\n-        match self {\n-            Self(x, y) => println!(\"{} {}\", x, y), // used as a pattern\n-        }\n-    }\n-}\n-```"}, {"sha": "0b25d911a299cf84ded7246311d691e74493c2ce", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -618,6 +618,8 @@ impl String {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> {\n+        // This isn't done via collect::<Result<_, _>>() for performance reasons.\n+        // FIXME: the function can be simplified again when #48994 is closed.\n         let mut ret = String::with_capacity(v.len());\n         for c in decode_utf16(v.iter().cloned()) {\n             if let Ok(c) = c {"}, {"sha": "955cab1d93f769ebac5a7e9700faa4e430db57fc", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -298,6 +298,7 @@ pub struct DroplessArena {\n unsafe impl Send for DroplessArena {}\n \n impl Default for DroplessArena {\n+    #[inline]\n     fn default() -> DroplessArena {\n         DroplessArena {\n             ptr: Cell::new(0 as *mut u8),\n@@ -319,6 +320,7 @@ impl DroplessArena {\n         false\n     }\n \n+    #[inline]\n     fn align(&self, align: usize) {\n         let final_address = ((self.ptr.get() as usize) + align - 1) & !(align - 1);\n         self.ptr.set(final_address as *mut u8);"}, {"sha": "7fd61f07d5e7f64fad114813541003baeee4b859", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -21,3 +21,7 @@ path = \"../libcore/benches/lib.rs\"\n \n [dev-dependencies]\n rand = \"0.5\"\n+\n+[features]\n+# Make panics and failed asserts immediately abort without formatting any message\n+panic_immediate_abort = []"}, {"sha": "26e7a79d35df606e15d969c26ae9258370ccb6c3", "filename": "src/libcore/array.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -148,6 +148,15 @@ macro_rules! array_impls {\n                 }\n             }\n \n+            #[unstable(feature = \"try_from\", issue = \"33417\")]\n+            impl<'a, T> TryFrom<&'a [T]> for [T; $N] where T: Copy {\n+                type Error = TryFromSliceError;\n+\n+                fn try_from(slice: &[T]) -> Result<[T; $N], TryFromSliceError> {\n+                    <&Self>::try_from(slice).map(|r| *r)\n+                }\n+            }\n+\n             #[unstable(feature = \"try_from\", issue = \"33417\")]\n             impl<'a, T> TryFrom<&'a [T]> for &'a [T; $N] {\n                 type Error = TryFromSliceError;"}, {"sha": "805be431328e208bd7f0be755c91a7ee50618f65", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -1989,6 +1989,19 @@ big endian.\n ```\n let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -2008,6 +2021,19 @@ little endian.\n ```\n let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -2037,6 +2063,19 @@ let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"bi\n         \", $le_bytes, \"\n     });\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -3614,6 +3653,7 @@ assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\n assert_eq!(\", stringify!($SelfT), \"::max_value().checked_next_power_of_two(), None);\",\n $EndFeature, \"\n ```\"),\n+            #[inline]\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             pub fn checked_next_power_of_two(self) -> Option<Self> {\n                 self.one_less_than_next_power_of_two().checked_add(1)\n@@ -3719,6 +3759,19 @@ big endian.\n ```\n let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -3738,6 +3791,19 @@ little endian.\n ```\n let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -3767,6 +3833,19 @@ let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"bi\n         \", $le_bytes, \"\n     });\n assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+#![feature(try_from)]\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]"}, {"sha": "aa18a60fc0f6df7665d1f81a277f98961a9f823d", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -39,9 +39,16 @@\n use fmt;\n use panic::{Location, PanicInfo};\n \n-#[cold] #[inline(never)] // this is the slow path, always\n+#[cold]\n+// never inline unless panic_immediate_abort to avoid code\n+// bloat at the call sites as much as possible\n+#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n #[lang = \"panic\"]\n pub fn panic(expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n+    if cfg!(feature = \"panic_immediate_abort\") {\n+        unsafe { super::intrinsics::abort() }\n+    }\n+\n     // Use Arguments::new_v1 instead of format_args!(\"{}\", expr) to potentially\n     // reduce size overhead. The format_args! macro uses str's Display trait to\n     // write expr, which calls Formatter::pad, which must accommodate string\n@@ -52,16 +59,27 @@ pub fn panic(expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n     panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), &(file, line, col))\n }\n \n-#[cold] #[inline(never)]\n+#[cold]\n+#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n #[lang = \"panic_bounds_check\"]\n fn panic_bounds_check(file_line_col: &(&'static str, u32, u32),\n                      index: usize, len: usize) -> ! {\n+    if cfg!(feature = \"panic_immediate_abort\") {\n+        unsafe { super::intrinsics::abort() }\n+    }\n+\n     panic_fmt(format_args!(\"index out of bounds: the len is {} but the index is {}\",\n                            len, index), file_line_col)\n }\n \n-#[cold] #[inline(never)]\n+#[cold]\n+#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n+#[cfg_attr(    feature=\"panic_immediate_abort\" ,inline)]\n pub fn panic_fmt(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32)) -> ! {\n+    if cfg!(feature = \"panic_immediate_abort\") {\n+        unsafe { super::intrinsics::abort() }\n+    }\n+\n     // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n     #[allow(improper_ctypes)] // PanicInfo contains a trait object which is not FFI safe\n     extern \"Rust\" {"}, {"sha": "dc8baa112bb59a79ec38d1dbb81a6dc8369bd822", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -67,7 +67,6 @@ use syntax::ast;\n use syntax::ast::*;\n use syntax::errors;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n-use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::source_map::{self, respan, CompilerDesugaringKind, Spanned};\n@@ -3628,7 +3627,6 @@ impl<'a> LoweringContext<'a> {\n                     ParamMode::Optional,\n                     ImplTraitContext::disallowed(),\n                 );\n-                self.check_self_struct_ctor_feature(&qpath);\n                 hir::PatKind::TupleStruct(\n                     qpath,\n                     pats.iter().map(|x| self.lower_pat(x)).collect(),\n@@ -3643,7 +3641,6 @@ impl<'a> LoweringContext<'a> {\n                     ParamMode::Optional,\n                     ImplTraitContext::disallowed(),\n                 );\n-                self.check_self_struct_ctor_feature(&qpath);\n                 hir::PatKind::Path(qpath)\n             }\n             PatKind::Struct(ref path, ref fields, etc) => {\n@@ -4039,7 +4036,6 @@ impl<'a> LoweringContext<'a> {\n                     ParamMode::Optional,\n                     ImplTraitContext::disallowed(),\n                 );\n-                self.check_self_struct_ctor_feature(&qpath);\n                 hir::ExprKind::Path(qpath)\n             }\n             ExprKind::Break(opt_label, ref opt_expr) => {\n@@ -5102,18 +5098,6 @@ impl<'a> LoweringContext<'a> {\n                                             ThinVec::new()));\n         P(self.expr_call(e.span, from_err, hir_vec![e]))\n     }\n-\n-    fn check_self_struct_ctor_feature(&self, qp: &hir::QPath) {\n-        if let hir::QPath::Resolved(_, ref p) = qp {\n-            if p.segments.len() == 1 &&\n-               p.segments[0].ident.name == keywords::SelfType.name() &&\n-               !self.sess.features_untracked().self_struct_ctor {\n-                emit_feature_err(&self.sess.parse_sess, \"self_struct_ctor\",\n-                                 p.span, GateIssue::Language,\n-                                 \"`Self` struct constructors are unstable\");\n-            }\n-        }\n-    }\n }\n \n fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body>) -> Vec<hir::BodyId> {"}, {"sha": "9a0ceddcf1b4a6d920832498b234d1648ddd635c", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -25,6 +25,7 @@ use hir;\n use hir::{PatKind, GenericBound, TraitBoundModifier, RangeEnd};\n use hir::{GenericParam, GenericParamKind, GenericArg};\n \n+use std::borrow::Cow;\n use std::cell::Cell;\n use std::io::{self, Write, Read};\n use std::iter::Peekable;\n@@ -209,7 +210,7 @@ pub fn to_string<F>(ann: &dyn PpAnn, f: F) -> String\n     String::from_utf8(wr).unwrap()\n }\n \n-pub fn visibility_qualified(vis: &hir::Visibility, w: &str) -> String {\n+pub fn visibility_qualified<S: Into<Cow<'static, str>>>(vis: &hir::Visibility, w: S) -> String {\n     to_string(NO_ANN, |s| {\n         s.print_visibility(vis)?;\n         s.s.word(w)\n@@ -226,12 +227,13 @@ impl<'a> State<'a> {\n         self.s.word(\" \")\n     }\n \n-    pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> {\n+    pub fn word_nbsp<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n         self.s.word(w)?;\n         self.nbsp()\n     }\n \n-    pub fn head(&mut self, w: &str) -> io::Result<()> {\n+    pub fn head<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n+        let w = w.into();\n         // outer-box is consistent\n         self.cbox(indent_unit)?;\n         // head-box is inconsistent\n@@ -303,7 +305,7 @@ impl<'a> State<'a> {\n     pub fn synth_comment(&mut self, text: String) -> io::Result<()> {\n         self.s.word(\"/*\")?;\n         self.s.space()?;\n-        self.s.word(&text[..])?;\n+        self.s.word(text)?;\n         self.s.space()?;\n         self.s.word(\"*/\")\n     }\n@@ -468,7 +470,7 @@ impl<'a> State<'a> {\n                 self.end() // end the outer fn box\n             }\n             hir::ForeignItemKind::Static(ref t, m) => {\n-                self.head(&visibility_qualified(&item.vis, \"static\"))?;\n+                self.head(visibility_qualified(&item.vis, \"static\"))?;\n                 if m {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -480,7 +482,7 @@ impl<'a> State<'a> {\n                 self.end() // end the outer cbox\n             }\n             hir::ForeignItemKind::Type => {\n-                self.head(&visibility_qualified(&item.vis, \"type\"))?;\n+                self.head(visibility_qualified(&item.vis, \"type\"))?;\n                 self.print_name(item.name)?;\n                 self.s.word(\";\")?;\n                 self.end()?; // end the head-ibox\n@@ -495,7 +497,7 @@ impl<'a> State<'a> {\n                               default: Option<hir::BodyId>,\n                               vis: &hir::Visibility)\n                               -> io::Result<()> {\n-        self.s.word(&visibility_qualified(vis, \"\"))?;\n+        self.s.word(visibility_qualified(vis, \"\"))?;\n         self.word_space(\"const\")?;\n         self.print_ident(ident)?;\n         self.word_space(\":\")?;\n@@ -534,7 +536,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Item(item))?;\n         match item.node {\n             hir::ItemKind::ExternCrate(orig_name) => {\n-                self.head(&visibility_qualified(&item.vis, \"extern crate\"))?;\n+                self.head(visibility_qualified(&item.vis, \"extern crate\"))?;\n                 if let Some(orig_name) = orig_name {\n                     self.print_name(orig_name)?;\n                     self.s.space()?;\n@@ -547,7 +549,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end outer head-block\n             }\n             hir::ItemKind::Use(ref path, kind) => {\n-                self.head(&visibility_qualified(&item.vis, \"use\"))?;\n+                self.head(visibility_qualified(&item.vis, \"use\"))?;\n                 self.print_path(path, false)?;\n \n                 match kind {\n@@ -566,7 +568,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end outer head-block\n             }\n             hir::ItemKind::Static(ref ty, m, expr) => {\n-                self.head(&visibility_qualified(&item.vis, \"static\"))?;\n+                self.head(visibility_qualified(&item.vis, \"static\"))?;\n                 if m == hir::MutMutable {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -582,7 +584,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer cbox\n             }\n             hir::ItemKind::Const(ref ty, expr) => {\n-                self.head(&visibility_qualified(&item.vis, \"const\"))?;\n+                self.head(visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_name(item.name)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n@@ -609,7 +611,7 @@ impl<'a> State<'a> {\n                 self.ann.nested(self, Nested::Body(body))?;\n             }\n             hir::ItemKind::Mod(ref _mod) => {\n-                self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n+                self.head(visibility_qualified(&item.vis, \"mod\"))?;\n                 self.print_name(item.name)?;\n                 self.nbsp()?;\n                 self.bopen()?;\n@@ -618,18 +620,18 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::ForeignMod(ref nmod) => {\n                 self.head(\"extern\")?;\n-                self.word_nbsp(&nmod.abi.to_string())?;\n+                self.word_nbsp(nmod.abi.to_string())?;\n                 self.bopen()?;\n                 self.print_foreign_mod(nmod, &item.attrs)?;\n                 self.bclose(item.span)?;\n             }\n             hir::ItemKind::GlobalAsm(ref ga) => {\n-                self.head(&visibility_qualified(&item.vis, \"global asm\"))?;\n-                self.s.word(&ga.asm.as_str())?;\n+                self.head(visibility_qualified(&item.vis, \"global asm\"))?;\n+                self.s.word(ga.asm.as_str().get())?;\n                 self.end()?\n             }\n             hir::ItemKind::Ty(ref ty, ref generics) => {\n-                self.head(&visibility_qualified(&item.vis, \"type\"))?;\n+                self.head(visibility_qualified(&item.vis, \"type\"))?;\n                 self.print_name(item.name)?;\n                 self.print_generic_params(&generics.params)?;\n                 self.end()?; // end the inner ibox\n@@ -642,7 +644,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer ibox\n             }\n             hir::ItemKind::Existential(ref exist) => {\n-                self.head(&visibility_qualified(&item.vis, \"existential type\"))?;\n+                self.head(visibility_qualified(&item.vis, \"existential type\"))?;\n                 self.print_name(item.name)?;\n                 self.print_generic_params(&exist.generics.params)?;\n                 self.end()?; // end the inner ibox\n@@ -668,11 +670,11 @@ impl<'a> State<'a> {\n                 self.print_enum_def(enum_definition, params, item.name, item.span, &item.vis)?;\n             }\n             hir::ItemKind::Struct(ref struct_def, ref generics) => {\n-                self.head(&visibility_qualified(&item.vis, \"struct\"))?;\n+                self.head(visibility_qualified(&item.vis, \"struct\"))?;\n                 self.print_struct(struct_def, generics, item.name, item.span, true)?;\n             }\n             hir::ItemKind::Union(ref struct_def, ref generics) => {\n-                self.head(&visibility_qualified(&item.vis, \"union\"))?;\n+                self.head(visibility_qualified(&item.vis, \"union\"))?;\n                 self.print_struct(struct_def, generics, item.name, item.span, true)?;\n             }\n             hir::ItemKind::Impl(unsafety,\n@@ -795,7 +797,7 @@ impl<'a> State<'a> {\n                           span: syntax_pos::Span,\n                           visibility: &hir::Visibility)\n                           -> io::Result<()> {\n-        self.head(&visibility_qualified(visibility, \"enum\"))?;\n+        self.head(visibility_qualified(visibility, \"enum\"))?;\n         self.print_name(name)?;\n         self.print_generic_params(&generics.params)?;\n         self.print_where_clause(&generics.where_clause)?;\n@@ -1587,14 +1589,14 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_usize(&mut self, i: usize) -> io::Result<()> {\n-        self.s.word(&i.to_string())\n+        self.s.word(i.to_string())\n     }\n \n     pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n         if ident.is_raw_guess() {\n-            self.s.word(&format!(\"r#{}\", ident.name))?;\n+            self.s.word(format!(\"r#{}\", ident.name))?;\n         } else {\n-            self.s.word(&ident.as_str())?;\n+            self.s.word(ident.as_str().get())?;\n         }\n         self.ann.post(self, AnnNode::Name(&ident.name))\n     }\n@@ -2010,7 +2012,7 @@ impl<'a> State<'a> {\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(indent_unit)?;\n             if let Some(arg_name) = arg_names.get(i) {\n-                s.s.word(&arg_name.as_str())?;\n+                s.s.word(arg_name.as_str().get())?;\n                 s.s.word(\":\")?;\n                 s.s.space()?;\n             } else if let Some(body_id) = body_id {\n@@ -2073,7 +2075,8 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_bounds(&mut self, prefix: &str, bounds: &[hir::GenericBound]) -> io::Result<()> {\n+    pub fn print_bounds(&mut self, prefix: &'static str, bounds: &[hir::GenericBound])\n+                        -> io::Result<()> {\n         if !bounds.is_empty() {\n             self.s.word(prefix)?;\n             let mut first = true;\n@@ -2322,7 +2325,7 @@ impl<'a> State<'a> {\n             Some(Abi::Rust) => Ok(()),\n             Some(abi) => {\n                 self.word_nbsp(\"extern\")?;\n-                self.word_nbsp(&abi.to_string())\n+                self.word_nbsp(abi.to_string())\n             }\n             None => Ok(()),\n         }\n@@ -2332,7 +2335,7 @@ impl<'a> State<'a> {\n         match opt_abi {\n             Some(abi) => {\n                 self.word_nbsp(\"extern\")?;\n-                self.word_nbsp(&abi.to_string())\n+                self.word_nbsp(abi.to_string())\n             }\n             None => Ok(()),\n         }\n@@ -2342,7 +2345,7 @@ impl<'a> State<'a> {\n                                 header: hir::FnHeader,\n                                 vis: &hir::Visibility)\n                                 -> io::Result<()> {\n-        self.s.word(&visibility_qualified(vis, \"\"))?;\n+        self.s.word(visibility_qualified(vis, \"\"))?;\n \n         match header.constness {\n             hir::Constness::NotConst => {}\n@@ -2358,7 +2361,7 @@ impl<'a> State<'a> {\n \n         if header.abi != Abi::Rust {\n             self.word_nbsp(\"extern\")?;\n-            self.word_nbsp(&header.abi.to_string())?;\n+            self.word_nbsp(header.abi.to_string())?;\n         }\n \n         self.s.word(\"fn\")"}, {"sha": "70e922c6676e13262c3695332acc2fd06f67efa5", "filename": "src/librustc/infer/at.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -52,6 +52,7 @@ pub struct Trace<'a, 'gcx: 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    #[inline]\n     pub fn at(&'a self,\n               cause: &'a ObligationCause<'tcx>,\n               param_env: ty::ParamEnv<'tcx>)"}, {"sha": "972ba16f7e2c7e156d5ceb344a32ba1a059bd920", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 226, "deletions": 96, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -11,30 +11,41 @@\n //! This code is kind of an alternate way of doing subtyping,\n //! supertyping, and type equating, distinct from the `combine.rs`\n //! code but very similar in its effect and design. Eventually the two\n-//! ought to be merged. This code is intended for use in NLL.\n+//! ought to be merged. This code is intended for use in NLL and chalk.\n //!\n //! Here are the key differences:\n //!\n-//! - This code generally assumes that there are no unbound type\n-//!   inferences variables, because at NLL\n-//!   time types are fully inferred up-to regions.\n-//!   - Actually, to support user-given type annotations like\n-//!     `Vec<_>`, we do have some measure of support for type\n-//!     inference variables, but we impose some simplifying\n-//!     assumptions on them that would not be suitable for the infer\n-//!     code more generally. This could be fixed.\n+//! - This code may choose to bypass some checks (e.g. the occurs check)\n+//!   in the case where we know that there are no unbound type inference\n+//!   variables. This is the case for NLL, because at NLL time types are fully\n+//!   inferred up-to regions.\n //! - This code uses \"universes\" to handle higher-ranked regions and\n //!   not the leak-check. This is \"more correct\" than what rustc does\n //!   and we are generally migrating in this direction, but NLL had to\n //!   get there first.\n+//!\n+//! Also, this code assumes that there are no bound types at all, not even\n+//! free ones. This is ok because:\n+//! - we are not relating anything quantified over some type variable\n+//! - we will have instantiated all the bound type vars already (the one\n+//!   thing we relate in chalk are basically domain goals and their\n+//!   constituents)\n \n use crate::infer::InferCtxt;\n use crate::ty::fold::{TypeFoldable, TypeVisitor};\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use crate::ty::subst::Kind;\n use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::error::TypeError;\n+use crate::traits::DomainGoal;\n use rustc_data_structures::fx::FxHashMap;\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum NormalizationStrategy {\n+    Lazy,\n+    Eager,\n+}\n+\n pub struct TypeRelating<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n@@ -75,6 +86,10 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// delegate.\n     fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n \n+    /// Push a domain goal that will need to be proved for the two types to\n+    /// be related. Used for lazy normalization.\n+    fn push_domain_goal(&mut self, domain_goal: DomainGoal<'tcx>);\n+\n     /// Creates a new universe index. Used when instantiating placeholders.\n     fn create_next_universe(&mut self) -> ty::UniverseIndex;\n \n@@ -105,6 +120,13 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// relate `Foo<'?0>` with `Foo<'a>` (and probably add an outlives\n     /// relation stating that `'?0: 'a`).\n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx>;\n+\n+    /// Define the normalization strategy to use, eager or lazy.\n+    fn normalization() -> NormalizationStrategy;\n+\n+    /// Enable some optimizations if we do not expect inference variables\n+    /// in the RHS of the relation.\n+    fn forbid_inference_vars() -> bool;\n }\n \n #[derive(Clone, Debug)]\n@@ -242,15 +264,79 @@ where\n         self.delegate.push_outlives(sup, sub);\n     }\n \n-    /// When we encounter a canonical variable `var` in the output,\n-    /// equate it with `kind`. If the variable has been previously\n-    /// equated, then equate it again.\n-    fn relate_var(&mut self, var_ty: Ty<'tcx>, value_ty: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"equate_var(var_ty={:?}, value_ty={:?})\", var_ty, value_ty);\n+    /// Relate a projection type and some value type lazily. This will always\n+    /// succeed, but we push an additional `ProjectionEq` goal depending\n+    /// on the value type:\n+    /// - if the value type is any type `T` which is not a projection, we push\n+    ///   `ProjectionEq(projection = T)`.\n+    /// - if the value type is another projection `other_projection`, we create\n+    ///   a new inference variable `?U` and push the two goals\n+    ///   `ProjectionEq(projection = ?U)`, `ProjectionEq(other_projection = ?U)`.\n+    fn relate_projection_ty(\n+        &mut self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        value_ty: ty::Ty<'tcx>\n+    ) -> Ty<'tcx> {\n+        use crate::infer::type_variable::TypeVariableOrigin;\n+        use crate::traits::WhereClause;\n+        use syntax_pos::DUMMY_SP;\n+\n+        match value_ty.sty {\n+            ty::Projection(other_projection_ty) => {\n+                let var = self.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n+                self.relate_projection_ty(projection_ty, var);\n+                self.relate_projection_ty(other_projection_ty, var);\n+                var\n+            }\n+\n+            _ => {\n+                let projection = ty::ProjectionPredicate {\n+                    projection_ty,\n+                    ty: value_ty,\n+                };\n+                self.delegate.push_domain_goal(\n+                    DomainGoal::Holds(WhereClause::ProjectionEq(projection))\n+                );\n+                value_ty\n+            }\n+        }\n+    }\n+\n+    /// Relate a type inference variable with a value type.\n+    fn relate_ty_var(\n+        &mut self,\n+        vid: ty::TyVid,\n+        value_ty: Ty<'tcx>\n+    ) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"relate_ty_var(vid={:?}, value_ty={:?})\", vid, value_ty);\n+\n+        match value_ty.sty {\n+            ty::Infer(ty::TyVar(value_vid)) => {\n+                // Two type variables: just equate them.\n+                self.infcx.type_variables.borrow_mut().equate(vid, value_vid);\n+                return Ok(value_ty);\n+            }\n+\n+            ty::Projection(projection_ty)\n+                if D::normalization() == NormalizationStrategy::Lazy =>\n+            {\n+                return Ok(self.relate_projection_ty(projection_ty, self.infcx.tcx.mk_var(vid)));\n+            }\n+\n+            _ => (),\n+        }\n+\n+        let generalized_ty = self.generalize_value(value_ty, vid)?;\n+        debug!(\"relate_ty_var: generalized_ty = {:?}\", generalized_ty);\n+\n+        if D::forbid_inference_vars() {\n+            // In NLL, we don't have type inference variables\n+            // floating around, so we can do this rather imprecise\n+            // variant of the occurs-check.\n+            assert!(!generalized_ty.has_infer_types());\n+        }\n \n-        let generalized_ty = self.generalize_value(value_ty);\n-        self.infcx\n-            .force_instantiate_unchecked(var_ty, generalized_ty);\n+        self.infcx.type_variables.borrow_mut().instantiate(vid, generalized_ty);\n \n         // The generalized values we extract from `canonical_var_values` have\n         // been fully instantiated and hence the set of scopes we have\n@@ -264,22 +350,27 @@ where\n         // Restore the old scopes now.\n         self.a_scopes = old_a_scopes;\n \n-        debug!(\"equate_var: complete, result = {:?}\", result);\n+        debug!(\"relate_ty_var: complete, result = {:?}\", result);\n         result\n     }\n \n-    fn generalize_value<T: Relate<'tcx>>(&mut self, value: T) -> T {\n-        TypeGeneralizer {\n-            tcx: self.infcx.tcx,\n+    fn generalize_value<T: Relate<'tcx>>(\n+        &mut self,\n+        value: T,\n+        for_vid: ty::TyVid\n+    ) -> RelateResult<'tcx, T> {\n+        let universe = self.infcx.probe_ty_var(for_vid).unwrap_err();\n+\n+        let mut generalizer = TypeGeneralizer {\n+            infcx: self.infcx,\n             delegate: &mut self.delegate,\n             first_free_index: ty::INNERMOST,\n             ambient_variance: self.ambient_variance,\n+            for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n+            universe,\n+        };\n \n-            // These always correspond to an `_` or `'_` written by\n-            // user, and those are always in the root universe.\n-            universe: ty::UniverseIndex::ROOT,\n-        }.relate(&value, &value)\n-            .unwrap()\n+        generalizer.relate(&value, &value)\n     }\n }\n \n@@ -327,11 +418,35 @@ where\n         Ok(r)\n     }\n \n-    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+    fn tys(&mut self, a: Ty<'tcx>, mut b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         let a = self.infcx.shallow_resolve(a);\n-        match a.sty {\n-            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n-                self.relate_var(a.into(), b.into())\n+\n+        if !D::forbid_inference_vars() {\n+            b = self.infcx.shallow_resolve(b);\n+        }\n+\n+        match (&a.sty, &b.sty) {\n+            (_, &ty::Infer(ty::TyVar(vid))) => {\n+                if D::forbid_inference_vars() {\n+                    // Forbid inference variables in the RHS.\n+                    bug!(\"unexpected inference var {:?}\", b)\n+                } else {\n+                    self.relate_ty_var(vid, a)\n+                }\n+            }\n+\n+            (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var(vid, b),\n+\n+            (&ty::Projection(projection_ty), _)\n+                if D::normalization() == NormalizationStrategy::Lazy =>\n+            {\n+                Ok(self.relate_projection_ty(projection_ty, b))\n+            }\n+\n+            (_, &ty::Projection(projection_ty))\n+                if D::normalization() == NormalizationStrategy::Lazy =>\n+            {\n+                Ok(self.relate_projection_ty(projection_ty, a))\n             }\n \n             _ => {\n@@ -340,7 +455,8 @@ where\n                     a, b, self.ambient_variance\n                 );\n \n-                relate::super_relate_tys(self, a, b)\n+                // Will also handle unification of `IntVar` and `FloatVar`.\n+                self.infcx.super_combine_tys(self, a, b)\n             }\n         }\n     }\n@@ -551,7 +667,7 @@ struct TypeGeneralizer<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n where\n     D: TypeRelatingDelegate<'tcx> + 'me,\n {\n-    tcx: TyCtxt<'me, 'gcx, 'tcx>,\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n \n     delegate: &'me mut D,\n \n@@ -561,6 +677,14 @@ where\n \n     first_free_index: ty::DebruijnIndex,\n \n+    /// The vid of the type variable that is in the process of being\n+    /// instantiated. If we find this within the value we are folding,\n+    /// that means we would have created a cyclic value.\n+    for_vid_sub_root: ty::TyVid,\n+\n+    /// The universe of the type variable that is in the process of being\n+    /// instantiated. If we find anything that this universe cannot name,\n+    /// we reject the relation.\n     universe: ty::UniverseIndex,\n }\n \n@@ -569,7 +693,7 @@ where\n     D: TypeRelatingDelegate<'tcx>,\n {\n     fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n-        self.tcx\n+        self.infcx.tcx\n     }\n \n     fn tag(&self) -> &'static str {\n@@ -609,17 +733,84 @@ where\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, _: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        use crate::infer::type_variable::TypeVariableValue;\n+\n         debug!(\"TypeGeneralizer::tys(a={:?})\", a,);\n \n         match a.sty {\n-            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n+            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_))\n+                if D::forbid_inference_vars() =>\n+            {\n                 bug!(\n                     \"unexpected inference variable encountered in NLL generalization: {:?}\",\n                     a\n                 );\n             }\n \n-            _ => relate::super_relate_tys(self, a, a),\n+            ty::Infer(ty::TyVar(vid)) => {\n+                let mut variables = self.infcx.type_variables.borrow_mut();\n+                let vid = variables.root_var(vid);\n+                let sub_vid = variables.sub_root_var(vid);\n+                if sub_vid == self.for_vid_sub_root {\n+                    // If sub-roots are equal, then `for_vid` and\n+                    // `vid` are related via subtyping.\n+                    debug!(\"TypeGeneralizer::tys: occurs check failed\");\n+                    return Err(TypeError::Mismatch);\n+                } else {\n+                    match variables.probe(vid) {\n+                        TypeVariableValue::Known { value: u } => {\n+                            drop(variables);\n+                            self.relate(&u, &u)\n+                        }\n+                        TypeVariableValue::Unknown { universe: _universe } => {\n+                            if self.ambient_variance == ty::Bivariant {\n+                                // FIXME: we may need a WF predicate (related to #54105).\n+                            }\n+\n+                            let origin = *variables.var_origin(vid);\n+\n+                            // Replacing with a new variable in the universe `self.universe`,\n+                            // it will be unified later with the original type variable in\n+                            // the universe `_universe`.\n+                            let new_var_id = variables.new_var(self.universe, false, origin);\n+\n+                            let u = self.tcx().mk_var(new_var_id);\n+                            debug!(\n+                                \"generalize: replacing original vid={:?} with new={:?}\",\n+                                vid,\n+                                u\n+                            );\n+                            return Ok(u);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            ty::Infer(ty::IntVar(_)) |\n+            ty::Infer(ty::FloatVar(_)) => {\n+                // No matter what mode we are in,\n+                // integer/floating-point types must be equal to be\n+                // relatable.\n+                Ok(a)\n+            }\n+\n+            ty::Placeholder(placeholder) => {\n+                if self.universe.cannot_name(placeholder.universe) {\n+                    debug!(\n+                        \"TypeGeneralizer::tys: root universe {:?} cannot name\\\n+                        placeholder in universe {:?}\",\n+                        self.universe,\n+                        placeholder.universe\n+                    );\n+                    Err(TypeError::Mismatch)\n+                } else {\n+                    Ok(a)\n+                }\n+            }\n+\n+            _ => {\n+                relate::super_relate_tys(self, a, a)\n+            }\n         }\n     }\n \n@@ -673,64 +864,3 @@ where\n         Ok(ty::Binder::bind(result))\n     }\n }\n-\n-impl InferCtxt<'_, '_, 'tcx> {\n-    /// A hacky sort of method used by the NLL type-relating code:\n-    ///\n-    /// - `var` must be some unbound type variable.\n-    /// - `value` must be a suitable type to use as its value.\n-    ///\n-    /// `var` will then be equated with `value`. Note that this\n-    /// sidesteps a number of important checks, such as the \"occurs\n-    /// check\" that prevents cyclic types, so it is important not to\n-    /// use this method during regular type-check.\n-    fn force_instantiate_unchecked(&self, var: Ty<'tcx>, value: Ty<'tcx>) {\n-        match (&var.sty, &value.sty) {\n-            (&ty::Infer(ty::TyVar(vid)), _) => {\n-                let mut type_variables = self.type_variables.borrow_mut();\n-\n-                // In NLL, we don't have type inference variables\n-                // floating around, so we can do this rather imprecise\n-                // variant of the occurs-check.\n-                assert!(!value.has_infer_types());\n-\n-                type_variables.instantiate(vid, value);\n-            }\n-\n-            (&ty::Infer(ty::IntVar(vid)), &ty::Int(value)) => {\n-                let mut int_unification_table = self.int_unification_table.borrow_mut();\n-                int_unification_table\n-                    .unify_var_value(vid, Some(ty::IntVarValue::IntType(value)))\n-                    .unwrap_or_else(|_| {\n-                        bug!(\"failed to unify int var `{:?}` with `{:?}`\", vid, value);\n-                    });\n-            }\n-\n-            (&ty::Infer(ty::IntVar(vid)), &ty::Uint(value)) => {\n-                let mut int_unification_table = self.int_unification_table.borrow_mut();\n-                int_unification_table\n-                    .unify_var_value(vid, Some(ty::IntVarValue::UintType(value)))\n-                    .unwrap_or_else(|_| {\n-                        bug!(\"failed to unify int var `{:?}` with `{:?}`\", vid, value);\n-                    });\n-            }\n-\n-            (&ty::Infer(ty::FloatVar(vid)), &ty::Float(value)) => {\n-                let mut float_unification_table = self.float_unification_table.borrow_mut();\n-                float_unification_table\n-                    .unify_var_value(vid, Some(ty::FloatVarValue(value)))\n-                    .unwrap_or_else(|_| {\n-                        bug!(\"failed to unify float var `{:?}` with `{:?}`\", vid, value)\n-                    });\n-            }\n-\n-            _ => {\n-                bug!(\n-                    \"force_instantiate_unchecked invoked with bad combination: var={:?} value={:?}\",\n-                    var,\n-                    value,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "7a1ee85acd42c809003ba72dd45b811b4205aaa4", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -25,6 +25,7 @@ pub struct OpportunisticTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> OpportunisticTypeResolver<'a, 'gcx, 'tcx> {\n+    #[inline]\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n         OpportunisticTypeResolver { infcx }\n     }"}, {"sha": "ab0094df0e219b8349d95e7450feca01890ee756", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -117,8 +117,9 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n                 self.reachable_symbols.insert(node_id);\n             }\n             Some(def) => {\n-                let def_id = def.def_id();\n-                if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                if let Some((node_id, def_id)) = def.opt_def_id().and_then(|def_id| {\n+                    self.tcx.hir.as_local_node_id(def_id).map(|node_id| (node_id, def_id))\n+                }) {\n                     if self.def_id_represents_local_inlined_item(def_id) {\n                         self.worklist.push(node_id);\n                     } else {"}, {"sha": "07054ee99af76fc9fc00ced43dee4da22b59997e", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -1573,7 +1573,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             .collect();\n \n         // ensure that we issue lints in a repeatable order\n-        def_ids.sort_by_key(|&def_id| self.tcx.def_path_hash(def_id));\n+        def_ids.sort_by_cached_key(|&def_id| self.tcx.def_path_hash(def_id));\n \n         for def_id in def_ids {\n             debug!("}, {"sha": "480d4a8e48f0e61320792a1633e37804a3d3a972", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -1286,8 +1286,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"print some performance-related statistics\"),\n     hir_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"print some statistics about AST and HIR\"),\n-    mir_stats: bool = (false, parse_bool, [UNTRACKED],\n-        \"print some statistics about MIR\"),\n     always_encode_mir: bool = (false, parse_bool, [TRACKED],\n         \"encode MIR of all functions into the crate metadata\"),\n     osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],"}, {"sha": "ab2fa68ab5f8927acb15cd992b53a3fc3160edbf", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -1052,6 +1052,7 @@ impl<'tcx,O> Obligation<'tcx,O> {\n }\n \n impl<'tcx> ObligationCause<'tcx> {\n+    #[inline]\n     pub fn new(span: Span,\n                body_id: ast::NodeId,\n                code: ObligationCauseCode<'tcx>)"}, {"sha": "2909daf22b3bab0933676b4df20e8854174e87c2", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -409,7 +409,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             .collect::<Vec<_>>();\n \n         // existential predicates need to be in a specific order\n-        associated_types.sort_by_key(|item| self.def_path_hash(item.def_id));\n+        associated_types.sort_by_cached_key(|item| self.def_path_hash(item.def_id));\n \n         let projection_predicates = associated_types.into_iter().map(|item| {\n             ty::ExistentialPredicate::Projection(ty::ExistentialProjection {"}, {"sha": "42a4de1682c391e71b0101a223b2120965aad385", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 112, "deletions": 112, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -53,6 +53,7 @@ use ty::CanonicalTy;\n use ty::CanonicalPolyFnSig;\n use util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n+use rustc_data_structures::interner::HashInterner;\n use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n                                            StableHasher, StableHasherResult,\n@@ -113,7 +114,7 @@ pub struct GlobalArenas<'tcx> {\n     const_allocs: TypedArena<interpret::Allocation>,\n }\n \n-type InternedSet<'tcx, T> = Lock<FxHashSet<Interned<'tcx, T>>>;\n+type InternedSet<'tcx, T> = Lock<FxHashMap<Interned<'tcx, T>, ()>>;\n \n pub struct CtxtInterners<'tcx> {\n     /// The arena that types, regions, etc are allocated from\n@@ -155,6 +156,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n     }\n \n     /// Intern a type\n+    #[inline(never)]\n     fn intern_ty(\n         local: &CtxtInterners<'tcx>,\n         global: &CtxtInterners<'gcx>,\n@@ -166,56 +168,45 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n         // determine that all contents are in the global tcx.\n         // See comments on Lift for why we can't use that.\n         if flags.flags.intersects(ty::TypeFlags::KEEP_IN_LOCAL_TCX) {\n-            let mut interner = local.type_.borrow_mut();\n-            if let Some(&Interned(ty)) = interner.get(&st) {\n-                return ty;\n-            }\n-\n-            let ty_struct = TyS {\n-                sty: st,\n-                flags: flags.flags,\n-                outer_exclusive_binder: flags.outer_exclusive_binder,\n-            };\n+            local.type_.borrow_mut().intern(st, |st| {\n+                let ty_struct = TyS {\n+                    sty: st,\n+                    flags: flags.flags,\n+                    outer_exclusive_binder: flags.outer_exclusive_binder,\n+                };\n \n-            // Make sure we don't end up with inference\n-            // types/regions in the global interner\n-            if local as *const _ as usize == global as *const _ as usize {\n-                bug!(\"Attempted to intern `{:?}` which contains \\\n-                      inference types/regions in the global type context\",\n-                     &ty_struct);\n-            }\n+                // Make sure we don't end up with inference\n+                // types/regions in the global interner\n+                if local as *const _ as usize == global as *const _ as usize {\n+                    bug!(\"Attempted to intern `{:?}` which contains \\\n+                        inference types/regions in the global type context\",\n+                        &ty_struct);\n+                }\n \n-            // Don't be &mut TyS.\n-            let ty: Ty<'tcx> = local.arena.alloc(ty_struct);\n-            interner.insert(Interned(ty));\n-            ty\n+                Interned(local.arena.alloc(ty_struct))\n+            }).0\n         } else {\n-            let mut interner = global.type_.borrow_mut();\n-            if let Some(&Interned(ty)) = interner.get(&st) {\n-                return ty;\n-            }\n-\n-            let ty_struct = TyS {\n-                sty: st,\n-                flags: flags.flags,\n-                outer_exclusive_binder: flags.outer_exclusive_binder,\n-            };\n+            global.type_.borrow_mut().intern(st, |st| {\n+                let ty_struct = TyS {\n+                    sty: st,\n+                    flags: flags.flags,\n+                    outer_exclusive_binder: flags.outer_exclusive_binder,\n+                };\n \n-            // This is safe because all the types the ty_struct can point to\n-            // already is in the global arena\n-            let ty_struct: TyS<'gcx> = unsafe {\n-                mem::transmute(ty_struct)\n-            };\n+                // This is safe because all the types the ty_struct can point to\n+                // already is in the global arena\n+                let ty_struct: TyS<'gcx> = unsafe {\n+                    mem::transmute(ty_struct)\n+                };\n \n-            // Don't be &mut TyS.\n-            let ty: Ty<'gcx> = global.arena.alloc(ty_struct);\n-            interner.insert(Interned(ty));\n-            ty\n+                Interned(global.arena.alloc(ty_struct))\n+            }).0\n         }\n     }\n }\n \n pub struct CommonTypes<'tcx> {\n+    pub unit: Ty<'tcx>,\n     pub bool: Ty<'tcx>,\n     pub char: Ty<'tcx>,\n     pub isize: Ty<'tcx>,\n@@ -825,14 +816,13 @@ impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n         let mk = |sty| CtxtInterners::intern_ty(interners, interners, sty);\n         let mk_region = |r| {\n-            if let Some(r) = interners.region.borrow().get(&r) {\n-                return r.0;\n-            }\n-            let r = interners.arena.alloc(r);\n-            interners.region.borrow_mut().insert(Interned(r));\n-            &*r\n+            interners.region.borrow_mut().intern(r, |r| {\n+                Interned(interners.arena.alloc(r))\n+            }).0\n         };\n+\n         CommonTypes {\n+            unit: mk(Tuple(List::empty())),\n             bool: mk(Bool),\n             char: mk(Char),\n             never: mk(Never),\n@@ -885,6 +875,7 @@ pub struct TyCtxt<'a, 'gcx: 'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> Deref for TyCtxt<'a, 'gcx, 'tcx> {\n     type Target = &'a GlobalCtxt<'gcx>;\n+    #[inline(always)]\n     fn deref(&self) -> &Self::Target {\n         &self.gcx\n     }\n@@ -950,14 +941,14 @@ pub struct GlobalCtxt<'tcx> {\n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n \n-    stability_interner: Lock<FxHashSet<&'tcx attr::Stability>>,\n+    stability_interner: Lock<FxHashMap<&'tcx attr::Stability, ()>>,\n \n     /// Stores the value of constants (and deduplicates the actual memory)\n-    allocation_interner: Lock<FxHashSet<&'tcx Allocation>>,\n+    allocation_interner: Lock<FxHashMap<&'tcx Allocation, ()>>,\n \n     pub alloc_map: Lock<interpret::AllocMap<'tcx, &'tcx Allocation>>,\n \n-    layout_interner: Lock<FxHashSet<&'tcx LayoutDetails>>,\n+    layout_interner: Lock<FxHashMap<&'tcx LayoutDetails, ()>>,\n \n     /// A general purpose channel to throw data out the back towards LLVM worker\n     /// threads.\n@@ -1040,16 +1031,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self,\n         alloc: Allocation,\n     ) -> &'gcx Allocation {\n-        let allocs = &mut self.allocation_interner.borrow_mut();\n-        if let Some(alloc) = allocs.get(&alloc) {\n-            return alloc;\n-        }\n-\n-        let interned = self.global_arenas.const_allocs.alloc(alloc);\n-        if let Some(prev) = allocs.replace(interned) { // insert into interner\n-            bug!(\"Tried to overwrite interned Allocation: {:#?}\", prev)\n-        }\n-        interned\n+        self.allocation_interner.borrow_mut().intern(alloc, |alloc| {\n+            self.global_arenas.const_allocs.alloc(alloc)\n+        })\n     }\n \n     /// Allocates a byte or string literal for `mir::interpret`, read-only\n@@ -1061,29 +1045,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n-        let mut stability_interner = self.stability_interner.borrow_mut();\n-        if let Some(st) = stability_interner.get(&stab) {\n-            return st;\n-        }\n-\n-        let interned = self.global_interners.arena.alloc(stab);\n-        if let Some(prev) = stability_interner.replace(interned) {\n-            bug!(\"Tried to overwrite interned Stability: {:?}\", prev)\n-        }\n-        interned\n+        self.stability_interner.borrow_mut().intern(stab, |stab| {\n+            self.global_interners.arena.alloc(stab)\n+        })\n     }\n \n     pub fn intern_layout(self, layout: LayoutDetails) -> &'gcx LayoutDetails {\n-        let mut layout_interner = self.layout_interner.borrow_mut();\n-        if let Some(layout) = layout_interner.get(&layout) {\n-            return layout;\n-        }\n-\n-        let interned = self.global_arenas.layout.alloc(layout);\n-        if let Some(prev) = layout_interner.replace(interned) {\n-            bug!(\"Tried to overwrite interned Layout: {:?}\", prev)\n-        }\n-        interned\n+        self.layout_interner.borrow_mut().intern(layout, |layout| {\n+            self.global_arenas.layout.alloc(layout)\n+        })\n     }\n \n     /// Returns a range of the start/end indices specified with the\n@@ -2193,7 +2163,7 @@ macro_rules! sty_debug_print {\n                 };\n                 $(let mut $variant = total;)*\n \n-                for &Interned(t) in tcx.interners.type_.borrow().iter() {\n+                for &Interned(t) in tcx.interners.type_.borrow().keys() {\n                     let variant = match t.sty {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n                             ty::Float(..) | ty::Str | ty::Never => continue,\n@@ -2252,6 +2222,13 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n /// An entry in an interner.\n struct Interned<'tcx, T: 'tcx+?Sized>(&'tcx T);\n \n+impl<'tcx, T: 'tcx+?Sized> Clone for Interned<'tcx, T> {\n+    fn clone(&self) -> Self {\n+        Interned(self.0)\n+    }\n+}\n+impl<'tcx, T: 'tcx+?Sized> Copy for Interned<'tcx, T> {}\n+\n // NB: An Interned<Ty> compares and hashes as a sty.\n impl<'tcx> PartialEq for Interned<'tcx, TyS<'tcx>> {\n     fn eq(&self, other: &Interned<'tcx, TyS<'tcx>>) -> bool {\n@@ -2372,37 +2349,28 @@ macro_rules! intern_method {\n                 // determine that all contents are in the global tcx.\n                 // See comments on Lift for why we can't use that.\n                 if ($keep_in_local_tcx)(&v) {\n-                    let mut interner = self.interners.$name.borrow_mut();\n-                    if let Some(&Interned(v)) = interner.get(key) {\n-                        return v;\n-                    }\n-\n-                    // Make sure we don't end up with inference\n-                    // types/regions in the global tcx.\n-                    if self.is_global() {\n-                        bug!(\"Attempted to intern `{:?}` which contains \\\n-                              inference types/regions in the global type context\",\n-                             v);\n-                    }\n-\n-                    let i = $alloc_method(&self.interners.arena, v);\n-                    interner.insert(Interned(i));\n-                    i\n+                    self.interners.$name.borrow_mut().intern_ref(key, || {\n+                        // Make sure we don't end up with inference\n+                        // types/regions in the global tcx.\n+                        if self.is_global() {\n+                            bug!(\"Attempted to intern `{:?}` which contains \\\n+                                inference types/regions in the global type context\",\n+                                v);\n+                        }\n+\n+                        Interned($alloc_method(&self.interners.arena, v))\n+                    }).0\n                 } else {\n-                    let mut interner = self.global_interners.$name.borrow_mut();\n-                    if let Some(&Interned(v)) = interner.get(key) {\n-                        return v;\n-                    }\n-\n-                    // This transmutes $alloc<'tcx> to $alloc<'gcx>\n-                    let v = unsafe {\n-                        mem::transmute(v)\n-                    };\n-                    let i: &$lt_tcx $ty = $alloc_method(&self.global_interners.arena, v);\n-                    // Cast to 'gcx\n-                    let i = unsafe { mem::transmute(i) };\n-                    interner.insert(Interned(i));\n-                    i\n+                    self.global_interners.$name.borrow_mut().intern_ref(key, || {\n+                        // This transmutes $alloc<'tcx> to $alloc<'gcx>\n+                        let v = unsafe {\n+                            mem::transmute(v)\n+                        };\n+                        let i: &$lt_tcx $ty = $alloc_method(&self.global_interners.arena, v);\n+                        // Cast to 'gcx\n+                        let i = unsafe { mem::transmute(i) };\n+                        Interned(i)\n+                    }).0\n                 }\n             }\n         }\n@@ -2515,6 +2483,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_fn_ptr(converted_sig)\n     }\n \n+    #[inline]\n     pub fn mk_ty(&self, st: TyKind<'tcx>) -> Ty<'tcx> {\n         CtxtInterners::intern_ty(&self.interners, &self.global_interners, st)\n     }\n@@ -2548,19 +2517,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn mk_str(self) -> Ty<'tcx> {\n         self.mk_ty(Str)\n     }\n \n+    #[inline]\n     pub fn mk_static_str(self) -> Ty<'tcx> {\n         self.mk_imm_ref(self.types.re_static, self.mk_str())\n     }\n \n+    #[inline]\n     pub fn mk_adt(self, def: &'tcx AdtDef, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n         self.mk_ty(Adt(def, substs))\n     }\n \n+    #[inline]\n     pub fn mk_foreign(self, def_id: DefId) -> Ty<'tcx> {\n         self.mk_ty(Foreign(def_id))\n     }\n@@ -2584,42 +2557,52 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(Adt(adt_def, substs))\n     }\n \n+    #[inline]\n     pub fn mk_ptr(self, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(RawPtr(tm))\n     }\n \n+    #[inline]\n     pub fn mk_ref(self, r: Region<'tcx>, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(Ref(r, tm.ty, tm.mutbl))\n     }\n \n+    #[inline]\n     pub fn mk_mut_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n     }\n \n+    #[inline]\n     pub fn mk_imm_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n     }\n \n+    #[inline]\n     pub fn mk_mut_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n     }\n \n+    #[inline]\n     pub fn mk_imm_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n     }\n \n+    #[inline]\n     pub fn mk_nil_ptr(self) -> Ty<'tcx> {\n         self.mk_imm_ptr(self.mk_unit())\n     }\n \n+    #[inline]\n     pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n         self.mk_ty(Array(ty, ty::Const::from_usize(self, n)))\n     }\n \n+    #[inline]\n     pub fn mk_slice(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(Slice(ty))\n     }\n \n+    #[inline]\n     pub fn intern_tup(self, ts: &[Ty<'tcx>]) -> Ty<'tcx> {\n         self.mk_ty(Tuple(self.intern_type_list(ts)))\n     }\n@@ -2628,10 +2611,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         iter.intern_with(|ts| self.mk_ty(Tuple(self.intern_type_list(ts))))\n     }\n \n+    #[inline]\n     pub fn mk_unit(self) -> Ty<'tcx> {\n-        self.intern_tup(&[])\n+        self.types.unit\n     }\n \n+    #[inline]\n     pub fn mk_diverging_default(self) -> Ty<'tcx> {\n         if self.features().never_type {\n             self.types.never\n@@ -2640,19 +2625,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn mk_bool(self) -> Ty<'tcx> {\n         self.mk_ty(Bool)\n     }\n \n+    #[inline]\n     pub fn mk_fn_def(self, def_id: DefId,\n                      substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(FnDef(def_id, substs))\n     }\n \n+    #[inline]\n     pub fn mk_fn_ptr(self, fty: PolyFnSig<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(FnPtr(fty))\n     }\n \n+    #[inline]\n     pub fn mk_dynamic(\n         self,\n         obj: ty::Binder<&'tcx List<ExistentialPredicate<'tcx>>>,\n@@ -2661,6 +2650,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(Dynamic(obj, reg))\n     }\n \n+    #[inline]\n     pub fn mk_projection(self,\n                          item_def_id: DefId,\n                          substs: &'tcx Substs<'tcx>)\n@@ -2671,11 +2661,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }))\n         }\n \n+    #[inline]\n     pub fn mk_closure(self, closure_id: DefId, closure_substs: ClosureSubsts<'tcx>)\n                       -> Ty<'tcx> {\n         self.mk_ty(Closure(closure_id, closure_substs))\n     }\n \n+    #[inline]\n     pub fn mk_generator(self,\n                         id: DefId,\n                         generator_substs: GeneratorSubsts<'tcx>,\n@@ -2684,32 +2676,39 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(Generator(id, generator_substs, movability))\n     }\n \n+    #[inline]\n     pub fn mk_generator_witness(self, types: ty::Binder<&'tcx List<Ty<'tcx>>>) -> Ty<'tcx> {\n         self.mk_ty(GeneratorWitness(types))\n     }\n \n+    #[inline]\n     pub fn mk_var(self, v: TyVid) -> Ty<'tcx> {\n         self.mk_infer(TyVar(v))\n     }\n \n+    #[inline]\n     pub fn mk_int_var(self, v: IntVid) -> Ty<'tcx> {\n         self.mk_infer(IntVar(v))\n     }\n \n+    #[inline]\n     pub fn mk_float_var(self, v: FloatVid) -> Ty<'tcx> {\n         self.mk_infer(FloatVar(v))\n     }\n \n+    #[inline]\n     pub fn mk_infer(self, it: InferTy) -> Ty<'tcx> {\n         self.mk_ty(Infer(it))\n     }\n \n+    #[inline]\n     pub fn mk_ty_param(self,\n                        index: u32,\n                        name: InternedString) -> Ty<'tcx> {\n         self.mk_ty(Param(ParamTy { idx: index, name: name }))\n     }\n \n+    #[inline]\n     pub fn mk_self_type(self) -> Ty<'tcx> {\n         self.mk_ty_param(0, keywords::SelfType.name().as_interned_str())\n     }\n@@ -2723,6 +2722,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn mk_opaque(self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(Opaque(def_id, substs))\n     }"}, {"sha": "20f64597b7876fcd7d9c1a6b749f60f7b5fc2b0b", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -374,6 +374,7 @@ pub struct RegionFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n+    #[inline]\n     pub fn new(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         skipped_regions: &'a mut bool,\n@@ -679,24 +680,31 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n // vars. See comment on `shift_vars_through_binders` method in\n // `subst.rs` for more details.\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+enum Direction {\n+    In,\n+    Out,\n+}\n+\n struct Shifter<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-\n     current_index: ty::DebruijnIndex,\n     amount: u32,\n+    direction: Direction,\n }\n \n impl Shifter<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, amount: u32) -> Self {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, amount: u32, direction: Direction) -> Self {\n         Shifter {\n             tcx,\n             current_index: ty::INNERMOST,\n             amount,\n+            direction,\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n+impl TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n@@ -712,7 +720,14 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n                 if self.amount == 0 || debruijn < self.current_index {\n                     r\n                 } else {\n-                    let shifted = ty::ReLateBound(debruijn.shifted_in(self.amount), br);\n+                    let debruijn = match self.direction {\n+                        Direction::In => debruijn.shifted_in(self.amount),\n+                        Direction::Out => {\n+                            assert!(debruijn.as_u32() >= self.amount);\n+                            debruijn.shifted_out(self.amount)\n+                        }\n+                    };\n+                    let shifted = ty::ReLateBound(debruijn, br);\n                     self.tcx.mk_region(shifted)\n                 }\n             }\n@@ -726,8 +741,15 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n                 if self.amount == 0 || debruijn < self.current_index {\n                     ty\n                 } else {\n+                    let debruijn = match self.direction {\n+                        Direction::In => debruijn.shifted_in(self.amount),\n+                        Direction::Out => {\n+                            assert!(debruijn.as_u32() >= self.amount);\n+                            debruijn.shifted_out(self.amount)\n+                        }\n+                    };\n                     self.tcx.mk_ty(\n-                        ty::Bound(debruijn.shifted_in(self.amount), bound_ty)\n+                        ty::Bound(debruijn, bound_ty)\n                     )\n                 }\n             }\n@@ -760,7 +782,18 @@ pub fn shift_vars<'a, 'gcx, 'tcx, T>(\n     debug!(\"shift_vars(value={:?}, amount={})\",\n            value, amount);\n \n-    value.fold_with(&mut Shifter::new(tcx, amount))\n+    value.fold_with(&mut Shifter::new(tcx, amount, Direction::In))\n+}\n+\n+pub fn shift_out_vars<'a, 'gcx, 'tcx, T>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    value: &T,\n+    amount: u32\n+) -> T where T: TypeFoldable<'tcx> {\n+    debug!(\"shift_out_vars(value={:?}, amount={})\",\n+           value, amount);\n+\n+    value.fold_with(&mut Shifter::new(tcx, amount, Direction::Out))\n }\n \n /// An \"escaping var\" is a bound var whose binder is not part of `t`. A bound var can be a"}, {"sha": "4633ab11663472df322e5b73b54b364889150771", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -1275,6 +1275,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         self.skip_binder().projection_ty.item_def_id\n     }\n \n+    #[inline]\n     pub fn to_poly_trait_ref(&self, tcx: TyCtxt<'_, '_, '_>) -> PolyTraitRef<'tcx> {\n         // Note: unlike with `TraitRef::to_poly_trait_ref()`,\n         // `self.0.trait_ref` is permitted to have escaping regions.\n@@ -1633,6 +1634,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// there are no where clauses in scope. Hidden types (like `impl\n     /// Trait`) are left hidden, so this is suitable for ordinary\n     /// type-checking.\n+    #[inline]\n     pub fn empty() -> Self {\n         Self::new(List::empty(), Reveal::UserFacing)\n     }\n@@ -1644,11 +1646,13 @@ impl<'tcx> ParamEnv<'tcx> {\n     ///\n     /// N.B. If you want to have predicates in scope, use `ParamEnv::new`,\n     /// or invoke `param_env.with_reveal_all()`.\n+    #[inline]\n     pub fn reveal_all() -> Self {\n         Self::new(List::empty(), Reveal::All)\n     }\n \n     /// Construct a trait environment with the given set of predicates.\n+    #[inline]\n     pub fn new(caller_bounds: &'tcx List<ty::Predicate<'tcx>>,\n                reveal: Reveal)\n                -> Self {\n@@ -2148,6 +2152,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n+    #[inline]\n     pub fn variant_descr(&self) -> &'static str {\n         match self.adt_kind() {\n             AdtKind::Struct => \"struct\","}, {"sha": "1b64a686794c0a4de2da60fb605b61fc0a3be18c", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 293, "deletions": 2, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -25,6 +25,7 @@ use std::rc::Rc;\n use std::iter;\n use rustc_target::spec::abi;\n use hir as ast;\n+use traits;\n \n pub type RelateResult<'tcx, T> = Result<T, TypeError<'tcx>>;\n \n@@ -371,6 +372,10 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             bug!(\"var types encountered in super_relate_tys\")\n         }\n \n+        (ty::Bound(..), _) | (_, ty::Bound(..)) => {\n+            bug!(\"bound types encountered in super_relate_tys\")\n+        }\n+\n         (&ty::Error, _) | (_, &ty::Error) =>\n         {\n             Ok(tcx.types.err)\n@@ -394,6 +399,10 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(a)\n         }\n \n+        (ty::Placeholder(p1), ty::Placeholder(p2)) if p1 == p2 => {\n+            Ok(a)\n+        }\n+\n         (&ty::Adt(a_def, a_substs), &ty::Adt(b_def, b_substs))\n             if a_def == b_def =>\n         {\n@@ -556,8 +565,13 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_fn_ptr(fty))\n         }\n \n-        (&ty::Projection(ref a_data), &ty::Projection(ref b_data)) =>\n-        {\n+        (ty::UnnormalizedProjection(a_data), ty::UnnormalizedProjection(b_data)) => {\n+            let projection_ty = relation.relate(a_data, b_data)?;\n+            Ok(tcx.mk_ty(ty::UnnormalizedProjection(projection_ty)))\n+        }\n+\n+        // these two are already handled downstream in case of lazy normalization\n+        (ty::Projection(a_data), ty::Projection(b_data)) => {\n             let projection_ty = relation.relate(a_data, b_data)?;\n             Ok(tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs))\n         }\n@@ -710,6 +724,283 @@ impl<'tcx> Relate<'tcx> for Kind<'tcx> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for ty::TraitPredicate<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::TraitPredicate<'tcx>,\n+        b: &ty::TraitPredicate<'tcx>\n+    ) -> RelateResult<'tcx, ty::TraitPredicate<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        Ok(ty::TraitPredicate {\n+            trait_ref: relation.relate(&a.trait_ref, &b.trait_ref)?,\n+        })\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::ProjectionPredicate<'tcx>,\n+        b: &ty::ProjectionPredicate<'tcx>,\n+    ) -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        Ok(ty::ProjectionPredicate {\n+            projection_ty: relation.relate(&a.projection_ty, &b.projection_ty)?,\n+            ty: relation.relate(&a.ty, &b.ty)?,\n+        })\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::WhereClause<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::WhereClause<'tcx>,\n+        b: &traits::WhereClause<'tcx>\n+    ) -> RelateResult<'tcx, traits::WhereClause<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::WhereClause::*;\n+        match (a, b) {\n+            (Implemented(a_pred), Implemented(b_pred)) => {\n+                Ok(Implemented(relation.relate(a_pred, b_pred)?))\n+            }\n+\n+            (ProjectionEq(a_pred), ProjectionEq(b_pred)) => {\n+                Ok(ProjectionEq(relation.relate(a_pred, b_pred)?))\n+            }\n+\n+            (RegionOutlives(a_pred), RegionOutlives(b_pred)) => {\n+                Ok(RegionOutlives(ty::OutlivesPredicate(\n+                    relation.relate(&a_pred.0, &b_pred.0)?,\n+                    relation.relate(&a_pred.1, &b_pred.1)?,\n+                )))\n+            }\n+\n+            (TypeOutlives(a_pred), TypeOutlives(b_pred)) => {\n+                Ok(TypeOutlives(ty::OutlivesPredicate(\n+                    relation.relate(&a_pred.0, &b_pred.0)?,\n+                    relation.relate(&a_pred.1, &b_pred.1)?,\n+                )))\n+            }\n+\n+            _ =>  Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::WellFormed<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::WellFormed<'tcx>,\n+        b: &traits::WellFormed<'tcx>\n+    ) -> RelateResult<'tcx, traits::WellFormed<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::WellFormed::*;\n+        match (a, b) {\n+            (Trait(a_pred), Trait(b_pred)) => Ok(Trait(relation.relate(a_pred, b_pred)?)),\n+            (Ty(a_ty), Ty(b_ty)) => Ok(Ty(relation.relate(a_ty, b_ty)?)),\n+            _ =>  Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::FromEnv<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::FromEnv<'tcx>,\n+        b: &traits::FromEnv<'tcx>\n+    ) -> RelateResult<'tcx, traits::FromEnv<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::FromEnv::*;\n+        match (a, b) {\n+            (Trait(a_pred), Trait(b_pred)) => Ok(Trait(relation.relate(a_pred, b_pred)?)),\n+            (Ty(a_ty), Ty(b_ty)) => Ok(Ty(relation.relate(a_ty, b_ty)?)),\n+            _ =>  Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::DomainGoal<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::DomainGoal<'tcx>,\n+        b: &traits::DomainGoal<'tcx>\n+    ) -> RelateResult<'tcx, traits::DomainGoal<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::DomainGoal::*;\n+        match (a, b) {\n+            (Holds(a_wc), Holds(b_wc)) => Ok(Holds(relation.relate(a_wc, b_wc)?)),\n+            (WellFormed(a_wf), WellFormed(b_wf)) => Ok(WellFormed(relation.relate(a_wf, b_wf)?)),\n+            (FromEnv(a_fe), FromEnv(b_fe)) => Ok(FromEnv(relation.relate(a_fe, b_fe)?)),\n+\n+            (Normalize(a_pred), Normalize(b_pred)) => {\n+                Ok(Normalize(relation.relate(a_pred, b_pred)?))\n+            }\n+\n+            _ =>  Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::Goal<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::Goal<'tcx>,\n+        b: &traits::Goal<'tcx>\n+    ) -> RelateResult<'tcx, traits::Goal<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::GoalKind::*;\n+        match (a, b) {\n+            (Implies(a_clauses, a_goal), Implies(b_clauses, b_goal)) => {\n+                let clauses = relation.relate(a_clauses, b_clauses)?;\n+                let goal = relation.relate(a_goal, b_goal)?;\n+                Ok(relation.tcx().mk_goal(Implies(clauses, goal)))\n+            }\n+\n+            (And(a_left, a_right), And(b_left, b_right)) => {\n+                let left = relation.relate(a_left, b_left)?;\n+                let right = relation.relate(a_right, b_right)?;\n+                Ok(relation.tcx().mk_goal(And(left, right)))\n+            }\n+\n+            (Not(a_goal), Not(b_goal)) => {\n+                let goal = relation.relate(a_goal, b_goal)?;\n+                Ok(relation.tcx().mk_goal(Not(goal)))\n+            }\n+\n+            (DomainGoal(a_goal), DomainGoal(b_goal)) => {\n+                let goal = relation.relate(a_goal, b_goal)?;\n+                Ok(relation.tcx().mk_goal(DomainGoal(goal)))\n+            }\n+\n+            (Quantified(a_qkind, a_goal), Quantified(b_qkind, b_goal))\n+                if a_qkind == b_qkind =>\n+            {\n+                let goal = relation.relate(a_goal, b_goal)?;\n+                Ok(relation.tcx().mk_goal(Quantified(*a_qkind, goal)))\n+            }\n+\n+            (CannotProve, CannotProve) => Ok(*a),\n+\n+            _ => Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::Goals<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::Goals<'tcx>,\n+        b: &traits::Goals<'tcx>\n+    ) -> RelateResult<'tcx, traits::Goals<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        if a.len() != b.len() {\n+            return Err(TypeError::Mismatch);\n+        }\n+\n+        let tcx = relation.tcx();\n+        let goals = a.iter().zip(b.iter()).map(|(a, b)| relation.relate(a, b));\n+        Ok(tcx.mk_goals(goals)?)\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::Clause<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::Clause<'tcx>,\n+        b: &traits::Clause<'tcx>\n+    ) -> RelateResult<'tcx, traits::Clause<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::Clause::*;\n+        match (a, b) {\n+            (Implies(a_clause), Implies(b_clause)) => {\n+                let clause = relation.relate(a_clause, b_clause)?;\n+                Ok(Implies(clause))\n+            }\n+\n+            (ForAll(a_clause), ForAll(b_clause)) => {\n+                let clause = relation.relate(a_clause, b_clause)?;\n+                Ok(ForAll(clause))\n+            }\n+\n+            _ => Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::Clauses<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::Clauses<'tcx>,\n+        b: &traits::Clauses<'tcx>\n+    ) -> RelateResult<'tcx, traits::Clauses<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        if a.len() != b.len() {\n+            return Err(TypeError::Mismatch);\n+        }\n+\n+        let tcx = relation.tcx();\n+        let clauses = a.iter().zip(b.iter()).map(|(a, b)| relation.relate(a, b));\n+        Ok(tcx.mk_clauses(clauses)?)\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::ProgramClause<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::ProgramClause<'tcx>,\n+        b: &traits::ProgramClause<'tcx>\n+    ) -> RelateResult<'tcx, traits::ProgramClause<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        Ok(traits::ProgramClause {\n+            goal: relation.relate(&a.goal, &b.goal)?,\n+            hypotheses: relation.relate(&a.hypotheses, &b.hypotheses)?,\n+            category: traits::ProgramClauseCategory::Other,\n+        })\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::Environment<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::Environment<'tcx>,\n+        b: &traits::Environment<'tcx>\n+    ) -> RelateResult<'tcx, traits::Environment<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        Ok(traits::Environment {\n+            clauses: relation.relate(&a.clauses, &b.clauses)?,\n+        })\n+    }\n+}\n+\n+impl<'tcx, G> Relate<'tcx> for traits::InEnvironment<'tcx, G>\n+    where G: Relate<'tcx>\n+{\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::InEnvironment<'tcx, G>,\n+        b: &traits::InEnvironment<'tcx, G>\n+    ) -> RelateResult<'tcx, traits::InEnvironment<'tcx, G>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        Ok(traits::InEnvironment {\n+            environment: relation.relate(&a.environment, &b.environment)?,\n+            goal: relation.relate(&a.goal, &b.goal)?,\n+        })\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Error handling\n "}, {"sha": "1416cb17feaedf9832f70e4783a9d5ecd0f5f9a1", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -667,6 +667,7 @@ impl<'tcx> TraitRef<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn self_ty(&self) -> Ty<'tcx> {\n         self.substs.type_at(0)\n     }\n@@ -978,15 +979,18 @@ impl<'tcx> FnSig<'tcx> {\n pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n \n impl<'tcx> PolyFnSig<'tcx> {\n+    #[inline]\n     pub fn inputs(&self) -> Binder<&'tcx [Ty<'tcx>]> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs())\n     }\n+    #[inline]\n     pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs()[index])\n     }\n     pub fn inputs_and_output(&self) -> ty::Binder<&'tcx List<Ty<'tcx>>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs_and_output)\n     }\n+    #[inline]\n     pub fn output(&self) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.output())\n     }\n@@ -1548,6 +1552,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn is_ty_var(&self) -> bool {\n         match self.sty {\n             Infer(TyVar(_)) => true,\n@@ -1732,6 +1737,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn is_integral(&self) -> bool {\n         match self.sty {\n             Infer(IntVar(_)) | Int(_) | Uint(_) => true,\n@@ -1762,6 +1768,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn is_fp(&self) -> bool {\n         match self.sty {\n             Infer(FloatVar(_)) | Float(_) => true,\n@@ -1845,6 +1852,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn ty_adt_def(&self) -> Option<&'tcx AdtDef> {\n         match self.sty {\n             Adt(adt, _) => Some(adt),"}, {"sha": "4eb920324bd003070634fae5c4d5a2ce6fe2940e", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -23,7 +23,7 @@ use llvm_util;\n use ModuleLlvm;\n use rustc_codegen_ssa::{ModuleCodegen, CompiledModule};\n use rustc::util::common::time_ext;\n-use rustc_fs_util::{path2cstr, link_or_copy};\n+use rustc_fs_util::{path_to_c_string, link_or_copy};\n use rustc_data_structures::small_c_str::SmallCStr;\n use errors::{self, Handler, FatalError};\n use type_::Type;\n@@ -80,7 +80,7 @@ pub fn write_output_file(\n         output: &Path,\n         file_type: llvm::FileType) -> Result<(), FatalError> {\n     unsafe {\n-        let output_c = path2cstr(output);\n+        let output_c = path_to_c_string(output);\n         let result = llvm::LLVMRustWriteOutputFile(target, pm, m, output_c.as_ptr(), file_type);\n         if result.into_result().is_err() {\n             let msg = format!(\"could not write output to {}\", output.display());\n@@ -211,7 +211,7 @@ pub(crate) fn save_temp_bitcode(\n         let ext = format!(\"{}.bc\", name);\n         let cgu = Some(&module.name[..]);\n         let path = cgcx.output_filenames.temp_path_ext(&ext, cgu);\n-        let cstr = path2cstr(&path);\n+        let cstr = path_to_c_string(&path);\n         let llmod = module.module_llvm.llmod();\n         llvm::LLVMWriteBitcodeToFile(llmod, cstr.as_ptr());\n     }\n@@ -324,7 +324,7 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n \n     if config.emit_no_opt_bc {\n         let out = cgcx.output_filenames.temp_path_ext(\"no-opt.bc\", module_name);\n-        let out = path2cstr(&out);\n+        let out = path_to_c_string(&out);\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n@@ -530,7 +530,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             || -> Result<(), FatalError> {\n             if config.emit_ir {\n                 let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n-                let out = path2cstr(&out);\n+                let out = path_to_c_string(&out);\n \n                 extern \"C\" fn demangle_callback(input_ptr: *const c_char,\n                                                 input_len: size_t,"}, {"sha": "47e92fbe87d31bb8b3b9739f937c280aff262ae1", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -39,7 +39,7 @@ use rustc::ty::layout::{self, Align, HasDataLayout, Integer, IntegerExt, LayoutO\n                         PrimitiveExt, Size, TyLayout};\n use rustc::session::config;\n use rustc::util::nodemap::FxHashMap;\n-use rustc_fs_util::path2cstr;\n+use rustc_fs_util::path_to_c_string;\n use rustc_data_structures::small_c_str::SmallCStr;\n \n use libc::{c_uint, c_longlong};\n@@ -892,7 +892,7 @@ pub fn compile_unit_metadata(tcx: TyCtxt,\n     };\n \n     fn path_to_mdstring(llcx: &'ll llvm::Context, path: &Path) -> &'ll Value {\n-        let path_str = path2cstr(path);\n+        let path_str = path_to_c_string(path);\n         unsafe {\n             llvm::LLVMMDStringInContext(llcx,\n                                         path_str.as_ptr(),"}, {"sha": "d5c73fecf814a80cf7c0b947d364dece00d57732", "filename": "src/librustc_codegen_llvm/llvm/archive_ro.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -10,10 +10,10 @@\n \n //! A wrapper around LLVM's archive (.a) code\n \n-use std::ffi::CString;\n use std::path::Path;\n use std::slice;\n use std::str;\n+use rustc_fs_util::path_to_c_string;\n \n pub struct ArchiveRO {\n     pub raw: &'static mut super::Archive,\n@@ -38,24 +38,12 @@ impl ArchiveRO {\n     /// raised.\n     pub fn open(dst: &Path) -> Result<ArchiveRO, String> {\n         return unsafe {\n-            let s = path2cstr(dst);\n+            let s = path_to_c_string(dst);\n             let ar = super::LLVMRustOpenArchive(s.as_ptr()).ok_or_else(|| {\n                 super::last_error().unwrap_or_else(|| \"failed to open archive\".to_owned())\n             })?;\n             Ok(ArchiveRO { raw: ar })\n         };\n-\n-        #[cfg(unix)]\n-        fn path2cstr(p: &Path) -> CString {\n-            use std::os::unix::prelude::*;\n-            use std::ffi::OsStr;\n-            let p: &OsStr = p.as_ref();\n-            CString::new(p.as_bytes()).unwrap()\n-        }\n-        #[cfg(windows)]\n-        fn path2cstr(p: &Path) -> CString {\n-            CString::new(p.to_str().unwrap()).unwrap()\n-        }\n     }\n \n     pub fn iter(&self) -> Iter {"}, {"sha": "5605f64c2e72c2d62304c2d3f61a256da0543520", "filename": "src/librustc_codegen_llvm/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_codegen_llvm%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_codegen_llvm%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmetadata.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -18,7 +18,7 @@ use rustc_data_structures::owning_ref::OwningRef;\n use std::path::Path;\n use std::ptr;\n use std::slice;\n-use rustc_fs_util::path2cstr;\n+use rustc_fs_util::path_to_c_string;\n \n pub use rustc_data_structures::sync::MetadataRef;\n \n@@ -57,7 +57,7 @@ impl MetadataLoader for LlvmMetadataLoader {\n                           filename: &Path)\n                           -> Result<MetadataRef, String> {\n         unsafe {\n-            let buf = path2cstr(filename);\n+            let buf = path_to_c_string(filename);\n             let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr())\n                 .ok_or_else(|| format!(\"error reading library: '{}'\", filename.display()))?;\n             let of = ObjectFile::new(mb)"}, {"sha": "24a70dc797771a2fa70001710f5bddde91624f65", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -161,7 +161,11 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                 LinkerFlavor::Lld(_) => \"lld\",\n             }), flavor)),\n             (Some(linker), None) => {\n-                let stem = linker.file_stem().and_then(|stem| stem.to_str()).unwrap_or_else(|| {\n+                let stem = if linker.extension().and_then(|ext| ext.to_str()) == Some(\"exe\") {\n+                    linker.file_stem().and_then(|stem| stem.to_str())\n+                } else {\n+                    linker.to_str()\n+                }.unwrap_or_else(|| {\n                     sess.fatal(\"couldn't extract file stem from specified linker\");\n                 }).to_owned();\n "}, {"sha": "29e5aefee7f0bbbf35a81dd982d34aa710d6c001", "filename": "src/librustc_data_structures/interner.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_data_structures%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_data_structures%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Finterner.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::hash::Hash;\n+use std::hash::BuildHasher;\n+use std::hash::Hasher;\n+use std::collections::HashMap;\n+use std::collections::hash_map::RawEntryMut;\n+use std::borrow::Borrow;\n+\n+pub trait HashInterner<K: Eq + Hash> {\n+    fn intern_ref<Q: ?Sized, F: FnOnce() -> K>(&mut self, value: &Q, make: F) -> K\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq;\n+\n+    fn intern<Q, F: FnOnce(Q) -> K>(&mut self, value: Q, make: F) -> K\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq;\n+}\n+\n+impl<K: Eq + Hash + Copy, S: BuildHasher> HashInterner<K> for HashMap<K, (), S> {\n+    #[inline]\n+    fn intern_ref<Q: ?Sized, F: FnOnce() -> K>(&mut self, value: &Q, make: F) -> K\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n+    {\n+        let mut hasher = self.hasher().build_hasher();\n+        value.hash(&mut hasher);\n+        let hash = hasher.finish();\n+        let entry = self.raw_entry_mut().from_key_hashed_nocheck(hash, value);\n+\n+        match entry {\n+            RawEntryMut::Occupied(e) => *e.key(),\n+            RawEntryMut::Vacant(e) => {\n+                let v = make();\n+                e.insert_hashed_nocheck(hash, v, ());\n+                v\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn intern<Q, F: FnOnce(Q) -> K>(&mut self, value: Q, make: F) -> K\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n+    {\n+        let mut hasher = self.hasher().build_hasher();\n+        value.hash(&mut hasher);\n+        let hash = hasher.finish();\n+        let entry = self.raw_entry_mut().from_key_hashed_nocheck(hash, &value);\n+\n+        match entry {\n+            RawEntryMut::Occupied(e) => *e.key(),\n+            RawEntryMut::Vacant(e) => {\n+                let v = make(value);\n+                e.insert_hashed_nocheck(hash, v, ());\n+                v\n+            }\n+        }\n+    }\n+}"}, {"sha": "96cb235a933627c4d593400696b0cfa317439b62", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -29,6 +29,7 @@\n #![feature(nll)]\n #![feature(allow_internal_unstable)]\n #![feature(vec_resize_with)]\n+#![feature(hash_raw_entry)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]\n@@ -66,6 +67,7 @@ pub mod flock;\n pub mod fx;\n pub mod graph;\n pub mod indexed_vec;\n+pub mod interner;\n pub mod obligation_forest;\n pub mod owning_ref;\n pub mod ptr_key;"}, {"sha": "fb8093d1d77a73e3110cf731c75d5fa8f18c724c", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -530,7 +530,7 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n                 s.s.space()?;\n                 s.s.word(\"as\")?;\n                 s.s.space()?;\n-                s.s.word(&self.tables.get().expr_ty(expr).to_string())?;\n+                s.s.word(self.tables.get().expr_ty(expr).to_string())?;\n                 s.pclose()\n             }\n             _ => Ok(()),"}, {"sha": "1b0ff4f861c7be6c65cde0c1a143160db0328e9d", "filename": "src/librustc_fs_util/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_fs_util%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_fs_util%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_fs_util%2Flib.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -116,13 +116,13 @@ pub fn rename_or_copy_remove<P: AsRef<Path>, Q: AsRef<Path>>(p: P,\n }\n \n #[cfg(unix)]\n-pub fn path2cstr(p: &Path) -> CString {\n-    use std::os::unix::prelude::*;\n+pub fn path_to_c_string(p: &Path) -> CString {\n+    use std::os::unix::ffi::OsStrExt;\n     use std::ffi::OsStr;\n     let p: &OsStr = p.as_ref();\n     CString::new(p.as_bytes()).unwrap()\n }\n #[cfg(windows)]\n-pub fn path2cstr(p: &Path) -> CString {\n+pub fn path_to_c_string(p: &Path) -> CString {\n     CString::new(p.to_str().unwrap()).unwrap()\n }"}, {"sha": "225e2841fb0ac15dd4e7c837f589d9541c431e6e", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -10,10 +10,11 @@\n \n use borrow_check::nll::constraints::OutlivesConstraint;\n use borrow_check::nll::type_check::{BorrowCheckContext, Locations};\n-use rustc::infer::nll_relate::{TypeRelating, TypeRelatingDelegate};\n+use rustc::infer::nll_relate::{TypeRelating, TypeRelatingDelegate, NormalizationStrategy};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::mir::ConstraintCategory;\n use rustc::traits::query::Fallible;\n+use rustc::traits::DomainGoal;\n use rustc::ty::relate::TypeRelation;\n use rustc::ty::{self, Ty};\n \n@@ -38,7 +39,7 @@ pub(super) fn relate_types<'tcx>(\n     TypeRelating::new(\n         infcx,\n         NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n-        v,\n+        v\n     ).relate(&a, &b)?;\n     Ok(())\n }\n@@ -115,4 +116,16 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, '_, 'tcx> {\n                 });\n         }\n     }\n+\n+    fn push_domain_goal(&mut self, _: DomainGoal<'tcx>) {\n+        bug!(\"should never be invoked with eager normalization\")\n+    }\n+\n+    fn normalization() -> NormalizationStrategy {\n+        NormalizationStrategy::Eager\n+    }\n+\n+    fn forbid_inference_vars() -> bool {\n+        true\n+    }\n }"}, {"sha": "3a6ee6da42215b21c45f2b2f40a6c2ea245205e9", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -985,7 +985,7 @@ fn collect_and_partition_mono_items<'a, 'tcx>(\n                 output.push_str(\" @@\");\n                 let mut empty = Vec::new();\n                 let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n-                cgus.as_mut_slice().sort_by_key(|&(ref name, _)| name.clone());\n+                cgus.as_mut_slice().sort_by_cached_key(|&(ref name, _)| name.clone());\n                 cgus.dedup();\n                 for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n                     output.push_str(\" \");"}, {"sha": "bcee6d75b5a4a84974ee2dfdcc6d8c0dc94619bb", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 137, "deletions": 122, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -895,145 +895,160 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             let mut is_shuffle = false;\n             let mut is_const_fn = false;\n             let mut is_promotable_const_fn = false;\n-            if let ty::FnDef(def_id, _) = fn_ty.sty {\n-                callee_def_id = Some(def_id);\n-                match self.tcx.fn_sig(def_id).abi() {\n-                    Abi::RustIntrinsic |\n-                    Abi::PlatformIntrinsic => {\n-                        assert!(!self.tcx.is_const_fn(def_id));\n-                        match &self.tcx.item_name(def_id).as_str()[..] {\n-                            | \"size_of\"\n-                            | \"min_align_of\"\n-                            | \"needs_drop\"\n-                            | \"type_id\"\n-                            | \"bswap\"\n-                            | \"bitreverse\"\n-                            | \"ctpop\"\n-                            | \"cttz\"\n-                            | \"cttz_nonzero\"\n-                            | \"ctlz\"\n-                            | \"ctlz_nonzero\"\n-                            | \"overflowing_add\"\n-                            | \"overflowing_sub\"\n-                            | \"overflowing_mul\"\n-                            | \"unchecked_shl\"\n-                            | \"unchecked_shr\"\n-                            | \"rotate_left\"\n-                            | \"rotate_right\"\n-                            | \"add_with_overflow\"\n-                            | \"sub_with_overflow\"\n-                            | \"mul_with_overflow\"\n-                            // no need to check feature gates, intrinsics are only callable from the\n-                            // libstd or with forever unstable feature gates\n-                            => is_const_fn = true,\n-                            // special intrinsic that can be called diretly without an intrinsic\n-                            // feature gate needs a language feature gate\n-                            \"transmute\" => {\n-                                // never promote transmute calls\n-                                if self.mode != Mode::Fn {\n-                                    is_const_fn = true;\n-                                    // const eval transmute calls only with the feature gate\n-                                    if !self.tcx.features().const_transmute {\n-                                        emit_feature_err(\n-                                            &self.tcx.sess.parse_sess, \"const_transmute\",\n-                                            self.span, GateIssue::Language,\n-                                            &format!(\"The use of std::mem::transmute() \\\n-                                            is gated in {}s\", self.mode));\n+            match fn_ty.sty {\n+                ty::FnDef(def_id, _) => {\n+                    callee_def_id = Some(def_id);\n+                    match self.tcx.fn_sig(def_id).abi() {\n+                        Abi::RustIntrinsic |\n+                        Abi::PlatformIntrinsic => {\n+                            assert!(!self.tcx.is_const_fn(def_id));\n+                            match &self.tcx.item_name(def_id).as_str()[..] {\n+                                | \"size_of\"\n+                                | \"min_align_of\"\n+                                | \"needs_drop\"\n+                                | \"type_id\"\n+                                | \"bswap\"\n+                                | \"bitreverse\"\n+                                | \"ctpop\"\n+                                | \"cttz\"\n+                                | \"cttz_nonzero\"\n+                                | \"ctlz\"\n+                                | \"ctlz_nonzero\"\n+                                | \"overflowing_add\"\n+                                | \"overflowing_sub\"\n+                                | \"overflowing_mul\"\n+                                | \"unchecked_shl\"\n+                                | \"unchecked_shr\"\n+                                | \"rotate_left\"\n+                                | \"rotate_right\"\n+                                | \"add_with_overflow\"\n+                                | \"sub_with_overflow\"\n+                                | \"mul_with_overflow\"\n+                                // no need to check feature gates, intrinsics are only callable\n+                                // from the libstd or with forever unstable feature gates\n+                                => is_const_fn = true,\n+                                // special intrinsic that can be called diretly without an intrinsic\n+                                // feature gate needs a language feature gate\n+                                \"transmute\" => {\n+                                    // never promote transmute calls\n+                                    if self.mode != Mode::Fn {\n+                                        is_const_fn = true;\n+                                        // const eval transmute calls only with the feature gate\n+                                        if !self.tcx.features().const_transmute {\n+                                            emit_feature_err(\n+                                                &self.tcx.sess.parse_sess, \"const_transmute\",\n+                                                self.span, GateIssue::Language,\n+                                                &format!(\"The use of std::mem::transmute() \\\n+                                                is gated in {}s\", self.mode));\n+                                        }\n                                     }\n                                 }\n-                            }\n \n-                            name if name.starts_with(\"simd_shuffle\") => {\n-                                is_shuffle = true;\n-                            }\n+                                name if name.starts_with(\"simd_shuffle\") => {\n+                                    is_shuffle = true;\n+                                }\n \n-                            _ => {}\n-                        }\n-                    }\n-                    _ => {\n-                        // in normal functions we only care about promotion\n-                        if self.mode == Mode::Fn {\n-                            // never promote const fn calls of\n-                            // functions without #[rustc_promotable]\n-                            if self.tcx.is_promotable_const_fn(def_id) {\n-                                is_const_fn = true;\n-                                is_promotable_const_fn = true;\n-                            } else if self.tcx.is_const_fn(def_id) {\n-                                is_const_fn = true;\n+                                _ => {}\n                             }\n-                        } else {\n-                            // stable const fn or unstable const fns with their feature gate\n-                            // active\n-                            if self.tcx.is_const_fn(def_id) {\n-                                is_const_fn = true;\n-                            } else if self.is_const_panic_fn(def_id) {\n-                                // check the const_panic feature gate\n-                                // FIXME: cannot allow this inside `allow_internal_unstable` because\n-                                // that would make `panic!` insta stable in constants, since the\n-                                // macro is marked with the attr\n-                                if self.tcx.features().const_panic {\n+                        }\n+                        _ => {\n+                            // in normal functions we only care about promotion\n+                            if self.mode == Mode::Fn {\n+                                // never promote const fn calls of\n+                                // functions without #[rustc_promotable]\n+                                if self.tcx.is_promotable_const_fn(def_id) {\n                                     is_const_fn = true;\n-                                } else {\n-                                    // don't allow panics in constants without the feature gate\n-                                    emit_feature_err(\n-                                        &self.tcx.sess.parse_sess,\n-                                        \"const_panic\",\n-                                        self.span,\n-                                        GateIssue::Language,\n-                                        &format!(\"panicking in {}s is unstable\", self.mode),\n-                                    );\n-                                }\n-                            } else if let Some(feature) = self.tcx.is_unstable_const_fn(def_id) {\n-                                // check `#[unstable]` const fns or `#[rustc_const_unstable]`\n-                                // functions without the feature gate active in this crate to report\n-                                // a better error message than the one below\n-                                if self.span.allows_unstable() {\n-                                    // `allow_internal_unstable` can make such calls stable\n+                                    is_promotable_const_fn = true;\n+                                } else if self.tcx.is_const_fn(def_id) {\n                                     is_const_fn = true;\n-                                } else {\n-                                    let mut err = self.tcx.sess.struct_span_err(self.span,\n-                                        &format!(\"`{}` is not yet stable as a const fn\",\n-                                                self.tcx.item_path_str(def_id)));\n-                                    help!(&mut err,\n-                                        \"in Nightly builds, add `#![feature({})]` \\\n-                                        to the crate attributes to enable\",\n-                                        feature);\n-                                    err.emit();\n                                 }\n                             } else {\n-                                // FIXME(#24111) Remove this check when const fn stabilizes\n-                                let (msg, note) = if let UnstableFeatures::Disallow =\n-                                        self.tcx.sess.opts.unstable_features {\n-                                    (format!(\"calls in {}s are limited to \\\n-                                            tuple structs and tuple variants\",\n-                                            self.mode),\n-                                    Some(\"a limited form of compile-time function \\\n-                                        evaluation is available on a nightly \\\n-                                        compiler via `const fn`\"))\n+                                // stable const fn or unstable const fns with their feature gate\n+                                // active\n+                                if self.tcx.is_const_fn(def_id) {\n+                                    is_const_fn = true;\n+                                } else if self.is_const_panic_fn(def_id) {\n+                                    // check the const_panic feature gate\n+                                    // FIXME: cannot allow this inside `allow_internal_unstable`\n+                                    // because that would make `panic!` insta stable in constants,\n+                                    // since the macro is marked with the attr\n+                                    if self.tcx.features().const_panic {\n+                                        is_const_fn = true;\n+                                    } else {\n+                                        // don't allow panics in constants without the feature gate\n+                                        emit_feature_err(\n+                                            &self.tcx.sess.parse_sess,\n+                                            \"const_panic\",\n+                                            self.span,\n+                                            GateIssue::Language,\n+                                            &format!(\"panicking in {}s is unstable\", self.mode),\n+                                        );\n+                                    }\n+                                } else if let Some(feat) = self.tcx.is_unstable_const_fn(def_id) {\n+                                    // check `#[unstable]` const fns or `#[rustc_const_unstable]`\n+                                    // functions without the feature gate active in this crate to\n+                                    // report a better error message than the one below\n+                                    if self.span.allows_unstable() {\n+                                        // `allow_internal_unstable` can make such calls stable\n+                                        is_const_fn = true;\n+                                    } else {\n+                                        let mut err = self.tcx.sess.struct_span_err(self.span,\n+                                            &format!(\"`{}` is not yet stable as a const fn\",\n+                                                    self.tcx.item_path_str(def_id)));\n+                                        help!(&mut err,\n+                                            \"in Nightly builds, add `#![feature({})]` \\\n+                                            to the crate attributes to enable\",\n+                                            feat);\n+                                        err.emit();\n+                                    }\n                                 } else {\n-                                    (format!(\"calls in {}s are limited \\\n-                                            to constant functions, \\\n-                                            tuple structs and tuple variants\",\n-                                            self.mode),\n-                                    None)\n-                                };\n-                                let mut err = struct_span_err!(\n-                                    self.tcx.sess,\n-                                    self.span,\n-                                    E0015,\n-                                    \"{}\",\n-                                    msg,\n-                                );\n-                                if let Some(note) = note {\n-                                    err.span_note(self.span, note);\n+                                    // FIXME(#24111) Remove this check when const fn stabilizes\n+                                    let (msg, note) = if let UnstableFeatures::Disallow =\n+                                            self.tcx.sess.opts.unstable_features {\n+                                        (format!(\"calls in {}s are limited to \\\n+                                                tuple structs and tuple variants\",\n+                                                self.mode),\n+                                        Some(\"a limited form of compile-time function \\\n+                                            evaluation is available on a nightly \\\n+                                            compiler via `const fn`\"))\n+                                    } else {\n+                                        (format!(\"calls in {}s are limited \\\n+                                                to constant functions, \\\n+                                                tuple structs and tuple variants\",\n+                                                self.mode),\n+                                        None)\n+                                    };\n+                                    let mut err = struct_span_err!(\n+                                        self.tcx.sess,\n+                                        self.span,\n+                                        E0015,\n+                                        \"{}\",\n+                                        msg,\n+                                    );\n+                                    if let Some(note) = note {\n+                                        err.span_note(self.span, note);\n+                                    }\n+                                    err.emit();\n                                 }\n-                                err.emit();\n                             }\n                         }\n                     }\n+                },\n+                ty::FnPtr(_) => {\n+                    if self.mode != Mode::Fn {\n+                        let mut err = self.tcx.sess.struct_span_err(\n+                            self.span,\n+                            &format!(\"function pointers are not allowed in const fn\"));\n+                        err.emit();\n+                    }\n+                },\n+                _ => {\n+                    self.not_const();\n+                    return\n                 }\n             }\n \n+\n             let constant_arguments = callee_def_id.and_then(|id| {\n                 args_required_const(self.tcx, id)\n             });"}, {"sha": "6d9abbf5af2ac1ca564203ed7b8f47ae49be6661", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -969,7 +969,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                             Some(poly_projection_predicate.skip_binder()\n                                                           .projection_ty.trait_ref(self.tcx))\n                         }\n-                        ty::Predicate::TypeOutlives(..) => None,\n+                        ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => None,\n                         _ => bug!(\"unexpected predicate: {:?}\", predicate),\n                     };\n                     if let Some(trait_ref) = trait_ref {"}, {"sha": "58a8d2abd9962960384e1f818f4a4958b017673a", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 74, "deletions": 45, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -9,13 +9,25 @@\n // except according to those terms.\n \n mod program_clauses;\n-\n-use chalk_engine::fallible::Fallible as ChalkEngineFallible;\n-use chalk_engine::{context, hh::HhGoal, DelayedLiteral, Literal, ExClause};\n+mod resolvent_ops;\n+mod unify;\n+\n+use chalk_engine::fallible::{Fallible, NoSolution};\n+use chalk_engine::{\n+    context,\n+    hh::HhGoal,\n+    DelayedLiteral,\n+    Literal,\n+    ExClause\n+};\n+use rustc::infer::{InferCtxt, LateBoundRegionConversionTime};\n use rustc::infer::canonical::{\n-    Canonical, CanonicalVarValues, OriginalQueryValues, QueryRegionConstraint, QueryResponse,\n+    Canonical,\n+    CanonicalVarValues,\n+    OriginalQueryValues,\n+    QueryResponse,\n+    Certainty,\n };\n-use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc::traits::{\n     DomainGoal,\n     ExClauseFold,\n@@ -27,14 +39,15 @@ use rustc::traits::{\n     Environment,\n     InEnvironment,\n };\n+use rustc::ty::{self, TyCtxt};\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::subst::{Kind, UnpackedKind};\n-use rustc::ty::{self, TyCtxt};\n+use syntax_pos::DUMMY_SP;\n \n use std::fmt::{self, Debug};\n use std::marker::PhantomData;\n \n-use syntax_pos::DUMMY_SP;\n+use self::unify::*;\n \n #[derive(Copy, Clone, Debug)]\n crate struct ChalkArenas<'gcx> {\n@@ -55,10 +68,12 @@ crate struct ChalkInferenceContext<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n #[derive(Copy, Clone, Debug)]\n crate struct UniverseMap;\n \n+crate type RegionConstraint<'tcx> = ty::OutlivesPredicate<Kind<'tcx>, ty::Region<'tcx>>;\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n crate struct ConstrainedSubst<'tcx> {\n     subst: CanonicalVarValues<'tcx>,\n-    constraints: Vec<QueryRegionConstraint<'tcx>>,\n+    constraints: Vec<RegionConstraint<'tcx>>,\n }\n \n BraceStructTypeFoldableImpl! {\n@@ -86,7 +101,7 @@ impl context::Context for ChalkArenas<'tcx> {\n \n     type GoalInEnvironment = InEnvironment<'tcx, Goal<'tcx>>;\n \n-    type RegionConstraint = QueryRegionConstraint<'tcx>;\n+    type RegionConstraint = RegionConstraint<'tcx>;\n \n     type Substitution = CanonicalVarValues<'tcx>;\n \n@@ -104,7 +119,7 @@ impl context::Context for ChalkArenas<'tcx> {\n \n     type ProgramClauses = Vec<Clause<'tcx>>;\n \n-    type UnificationResult = InferOk<'tcx, ()>;\n+    type UnificationResult = UnificationResult<'tcx>;\n \n     fn goal_in_environment(\n         env: &Environment<'tcx>,\n@@ -118,9 +133,34 @@ impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n     fn make_solution(\n         &self,\n         _root_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-        _simplified_answers: impl context::AnswerStream<ChalkArenas<'gcx>>,\n+        mut simplified_answers: impl context::AnswerStream<ChalkArenas<'gcx>>,\n     ) -> Option<Canonical<'gcx, QueryResponse<'gcx, ()>>> {\n-        unimplemented!()\n+        use chalk_engine::SimplifiedAnswer;\n+\n+        if simplified_answers.peek_answer().is_none() {\n+            return None;\n+        }\n+\n+        let SimplifiedAnswer { subst, ambiguous } = simplified_answers\n+            .next_answer()\n+            .unwrap();\n+\n+        let ambiguous = simplified_answers.peek_answer().is_some() || ambiguous;\n+\n+        Some(subst.unchecked_map(|subst| {\n+            QueryResponse {\n+                var_values: subst.subst,\n+                region_constraints: subst.constraints\n+                    .into_iter()\n+                    .map(|c| ty::Binder::bind(c))\n+                    .collect(),\n+                certainty: match ambiguous {\n+                    true => Certainty::Ambiguous,\n+                    false => Certainty::Proven,\n+                },\n+                value: (),\n+            }\n+        }))\n     }\n }\n \n@@ -197,7 +237,7 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n \n     fn is_trivial_substitution(\n         u_canon: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-        canonical_subst: &Canonical<'tcx, ConstrainedSubst<'tcx>>,\n+        canonical_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n     ) -> bool {\n         let subst = &canonical_subst.value.subst;\n         assert_eq!(u_canon.variables.len(), subst.var_values.len());\n@@ -282,30 +322,6 @@ impl context::InferenceTable<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     }\n }\n \n-impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n-    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n-{\n-    fn resolvent_clause(\n-        &mut self,\n-        _environment: &Environment<'tcx>,\n-        _goal: &DomainGoal<'tcx>,\n-        _subst: &CanonicalVarValues<'tcx>,\n-        _clause: &Clause<'tcx>,\n-    ) -> chalk_engine::fallible::Fallible<Canonical<'gcx, ChalkExClause<'gcx>>> {\n-        panic!()\n-    }\n-\n-    fn apply_answer_subst(\n-        &mut self,\n-        _ex_clause: ChalkExClause<'tcx>,\n-        _selected_goal: &InEnvironment<'tcx, Goal<'tcx>>,\n-        _answer_table_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-        _canonical_answer_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n-    ) -> chalk_engine::fallible::Fallible<ChalkExClause<'tcx>> {\n-        panic!()\n-    }\n-}\n-\n impl context::TruncateOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n {\n@@ -376,7 +392,7 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     fn canonicalize_constrained_subst(\n         &mut self,\n         subst: CanonicalVarValues<'tcx>,\n-        constraints: Vec<QueryRegionConstraint<'tcx>>,\n+        constraints: Vec<RegionConstraint<'tcx>>,\n     ) -> Canonical<'gcx, ConstrainedSubst<'gcx>> {\n         self.infcx.canonicalize_response(&ConstrainedSubst { subst, constraints })\n     }\n@@ -400,11 +416,13 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n \n     fn unify_parameters(\n         &mut self,\n-        _environment: &Environment<'tcx>,\n-        _a: &Kind<'tcx>,\n-        _b: &Kind<'tcx>,\n-    ) -> ChalkEngineFallible<InferOk<'tcx, ()>> {\n-        panic!()\n+        environment: &Environment<'tcx>,\n+        a: &Kind<'tcx>,\n+        b: &Kind<'tcx>,\n+    ) -> Fallible<UnificationResult<'tcx>> {\n+        self.infcx.commit_if_ok(|_| {\n+            unify(self.infcx, *environment, a, b).map_err(|_| NoSolution)\n+        })\n     }\n \n     fn sink_answer_subset(\n@@ -421,11 +439,22 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         panic!(\"lift\")\n     }\n \n-    fn into_ex_clause(&mut self, _result: InferOk<'tcx, ()>, _ex_clause: &mut ChalkExClause<'tcx>) {\n-        panic!(\"TBD\")\n+    fn into_ex_clause(\n+        &mut self,\n+        result: UnificationResult<'tcx>,\n+        ex_clause: &mut ChalkExClause<'tcx>\n+    ) {\n+        into_ex_clause(result, ex_clause);\n     }\n }\n \n+crate fn into_ex_clause(result: UnificationResult<'tcx>, ex_clause: &mut ChalkExClause<'tcx>) {\n+    ex_clause.subgoals.extend(\n+        result.goals.into_iter().map(Literal::Positive)\n+    );\n+    ex_clause.constraints.extend(result.constraints);\n+}\n+\n type ChalkHhGoal<'tcx> = HhGoal<ChalkArenas<'tcx>>;\n \n type ChalkExClause<'tcx> = ExClause<ChalkArenas<'tcx>>;"}, {"sha": "df6458a766d4e89f128697551a741469333627a0", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -0,0 +1,241 @@\n+use chalk_engine::fallible::{Fallible, NoSolution};\n+use chalk_engine::{\n+    context,\n+    Literal,\n+    ExClause\n+};\n+use rustc::infer::{InferCtxt, LateBoundRegionConversionTime};\n+use rustc::infer::canonical::{Canonical, CanonicalVarValues};\n+use rustc::traits::{\n+    DomainGoal,\n+    Goal,\n+    GoalKind,\n+    Clause,\n+    ProgramClause,\n+    Environment,\n+    InEnvironment,\n+};\n+use rustc::ty::{self, Ty};\n+use rustc::ty::subst::Kind;\n+use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n+use syntax_pos::DUMMY_SP;\n+\n+use super::{ChalkInferenceContext, ChalkArenas, ChalkExClause, ConstrainedSubst};\n+use super::unify::*;\n+\n+impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n+    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n+{\n+    fn resolvent_clause(\n+        &mut self,\n+        environment: &Environment<'tcx>,\n+        goal: &DomainGoal<'tcx>,\n+        subst: &CanonicalVarValues<'tcx>,\n+        clause: &Clause<'tcx>,\n+    ) -> Fallible<Canonical<'gcx, ChalkExClause<'gcx>>> {\n+        use chalk_engine::context::UnificationOps;\n+\n+        self.infcx.probe(|_| {\n+            let ProgramClause {\n+                goal: consequence,\n+                hypotheses,\n+                ..\n+            } = match clause {\n+                Clause::Implies(program_clause) => *program_clause,\n+                Clause::ForAll(program_clause) => self.infcx.replace_bound_vars_with_fresh_vars(\n+                    DUMMY_SP,\n+                    LateBoundRegionConversionTime::HigherRankedType,\n+                    program_clause\n+                ).0,\n+            };\n+\n+            let result = unify(self.infcx, *environment, goal, &consequence)\n+                .map_err(|_| NoSolution)?;\n+\n+            let mut ex_clause = ExClause {\n+                subst: subst.clone(),\n+                delayed_literals: vec![],\n+                constraints: vec![],\n+                subgoals: vec![],\n+            };\n+\n+            self.into_ex_clause(result, &mut ex_clause);\n+\n+            ex_clause.subgoals.extend(\n+                hypotheses.iter().map(|g| match g {\n+                    GoalKind::Not(g) => Literal::Negative(environment.with(*g)),\n+                    g => Literal::Positive(environment.with(*g)),\n+                })\n+            );\n+\n+            let canonical_ex_clause = self.canonicalize_ex_clause(&ex_clause);\n+            Ok(canonical_ex_clause)\n+        })\n+    }\n+\n+    fn apply_answer_subst(\n+        &mut self,\n+        ex_clause: ChalkExClause<'tcx>,\n+        selected_goal: &InEnvironment<'tcx, Goal<'tcx>>,\n+        answer_table_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n+        canonical_answer_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+    ) -> Fallible<ChalkExClause<'tcx>> {\n+        let (answer_subst, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n+            DUMMY_SP,\n+            canonical_answer_subst\n+        );\n+\n+        let mut substitutor = AnswerSubstitutor {\n+            infcx: self.infcx,\n+            environment: selected_goal.environment,\n+            answer_subst: answer_subst.subst,\n+            binder_index: ty::INNERMOST,\n+            ex_clause,\n+        };\n+\n+        substitutor.relate(&answer_table_goal.value, &selected_goal)\n+            .map_err(|_| NoSolution)?;\n+\n+        let mut ex_clause = substitutor.ex_clause;\n+        ex_clause.constraints.extend(answer_subst.constraints);\n+        Ok(ex_clause)\n+    }\n+}\n+\n+struct AnswerSubstitutor<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+    environment: Environment<'tcx>,\n+    answer_subst: CanonicalVarValues<'tcx>,\n+    binder_index: ty::DebruijnIndex,\n+    ex_clause: ChalkExClause<'tcx>,\n+}\n+\n+impl AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n+    fn unify_free_answer_var(\n+        &mut self,\n+        answer_var: ty::BoundVar,\n+        pending: Kind<'tcx>\n+    ) -> RelateResult<'tcx, ()> {\n+        let answer_param = &self.answer_subst.var_values[answer_var];\n+        let pending = &ty::fold::shift_out_vars(\n+            self.infcx.tcx,\n+            &pending,\n+            self.binder_index.as_u32()\n+        );\n+\n+        super::into_ex_clause(\n+            unify(self.infcx, self.environment, answer_param, pending)?,\n+            &mut self.ex_clause\n+        );\n+\n+        Ok(())\n+    }\n+}\n+\n+impl TypeRelation<'cx, 'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> ty::TyCtxt<'cx, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"chalk_context::answer_substitutor\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        _variance: ty::Variance,\n+        a: &T,\n+        b: &T,\n+    ) -> RelateResult<'tcx, T> {\n+        // We don't care about variance.\n+        self.relate(a, b)\n+    }\n+\n+    fn binders<T: Relate<'tcx>>(\n+        &mut self,\n+        a: &ty::Binder<T>,\n+        b: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>> {\n+        self.binder_index.shift_in(1);\n+        let result = self.relate(a.skip_binder(), b.skip_binder())?;\n+        self.binder_index.shift_out(1);\n+        Ok(ty::Binder::bind(result))\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        let b = self.infcx.shallow_resolve(b);\n+\n+        if let &ty::Bound(debruijn, bound_ty) = &a.sty {\n+            // Free bound var\n+            if debruijn == self.binder_index {\n+                self.unify_free_answer_var(bound_ty.var, b.into())?;\n+                return Ok(b);\n+            }\n+        }\n+\n+        match (&a.sty, &b.sty) {\n+            (&ty::Bound(a_debruijn, a_bound), &ty::Bound(b_debruijn, b_bound)) => {\n+                assert_eq!(a_debruijn, b_debruijn);\n+                assert_eq!(a_bound.var, b_bound.var);\n+                Ok(a)\n+            }\n+\n+            // Those should have been canonicalized away.\n+            (ty::Placeholder(..), _) => {\n+                bug!(\"unexpected placeholder ty in `AnswerSubstitutor`: {:?} \", a);\n+            }\n+\n+            // Everything else should just be a perfect match as well,\n+            // and we forbid inference variables.\n+            _ => match ty::relate::super_relate_tys(self, a, b) {\n+                Ok(ty) => Ok(ty),\n+                Err(err) => bug!(\"type mismatch in `AnswerSubstitutor`: {}\", err),\n+            }\n+        }\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        let b = match b {\n+            &ty::ReVar(vid) => self.infcx\n+                .borrow_region_constraints()\n+                .opportunistic_resolve_var(self.infcx.tcx, vid),\n+\n+            other => other,\n+        };\n+\n+        if let &ty::ReLateBound(debruijn, bound) = a {\n+            // Free bound region\n+            if debruijn == self.binder_index {\n+                self.unify_free_answer_var(bound.assert_bound_var(), b.into())?;\n+                return Ok(b);\n+            }\n+        }\n+\n+        match (a, b) {\n+            (&ty::ReLateBound(a_debruijn, a_bound), &ty::ReLateBound(b_debruijn, b_bound)) => {\n+                assert_eq!(a_debruijn, b_debruijn);\n+                assert_eq!(a_bound.assert_bound_var(), b_bound.assert_bound_var());\n+            }\n+\n+            (ty::ReStatic, ty::ReStatic) |\n+            (ty::ReErased, ty::ReErased) |\n+            (ty::ReEmpty, ty::ReEmpty) => (),\n+\n+            (&ty::ReFree(a_free), &ty::ReFree(b_free)) => {\n+                assert_eq!(a_free, b_free);\n+            }\n+\n+            _ => bug!(\"unexpected regions in `AnswerSubstitutor`: {:?}, {:?}\", a, b),\n+        }\n+\n+        Ok(a)\n+    }\n+}"}, {"sha": "3a9c3918d137e81d5b85c1565a4f0bd510f4fe86", "filename": "src/librustc_traits/chalk_context/unify.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -0,0 +1,98 @@\n+use rustc::infer::nll_relate::{TypeRelating, TypeRelatingDelegate, NormalizationStrategy};\n+use rustc::infer::{InferCtxt, RegionVariableOrigin};\n+use rustc::traits::{DomainGoal, Goal, Environment, InEnvironment};\n+use rustc::ty::relate::{Relate, TypeRelation, RelateResult};\n+use rustc::ty;\n+use syntax_pos::DUMMY_SP;\n+\n+crate struct UnificationResult<'tcx> {\n+    crate goals: Vec<InEnvironment<'tcx, Goal<'tcx>>>,\n+    crate constraints: Vec<super::RegionConstraint<'tcx>>,\n+}\n+\n+crate fn unify<'me, 'gcx, 'tcx, T: Relate<'tcx>>(\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+    environment: Environment<'tcx>,\n+    a: &T,\n+    b: &T\n+) -> RelateResult<'tcx, UnificationResult<'tcx>> {\n+    let mut delegate = ChalkTypeRelatingDelegate::new(\n+        infcx,\n+        environment\n+    );\n+\n+    TypeRelating::new(\n+        infcx,\n+        &mut delegate,\n+        ty::Variance::Invariant\n+    ).relate(a, b)?;\n+\n+    Ok(UnificationResult {\n+        goals: delegate.goals,\n+        constraints: delegate.constraints,\n+    })\n+}\n+\n+struct ChalkTypeRelatingDelegate<'me, 'gcx: 'tcx, 'tcx: 'me> {\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+    environment: Environment<'tcx>,\n+    goals: Vec<InEnvironment<'tcx, Goal<'tcx>>>,\n+    constraints: Vec<super::RegionConstraint<'tcx>>,\n+}\n+\n+impl ChalkTypeRelatingDelegate<'me, 'gcx, 'tcx> {\n+    fn new(\n+        infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+        environment: Environment<'tcx>,\n+    ) -> Self {\n+        Self {\n+            infcx,\n+            environment,\n+            goals: Vec::new(),\n+            constraints: Vec::new(),\n+        }\n+    }\n+}\n+\n+impl TypeRelatingDelegate<'tcx> for &mut ChalkTypeRelatingDelegate<'_, '_, 'tcx> {\n+    fn create_next_universe(&mut self) -> ty::UniverseIndex {\n+        self.infcx.create_next_universe()\n+    }\n+\n+    fn next_existential_region_var(&mut self) -> ty::Region<'tcx> {\n+        self.infcx.next_region_var(RegionVariableOrigin::MiscVariable(DUMMY_SP))\n+    }\n+\n+    fn next_placeholder_region(\n+        &mut self,\n+        placeholder: ty::PlaceholderRegion\n+    ) -> ty::Region<'tcx> {\n+        self.infcx.tcx.mk_region(ty::RePlaceholder(placeholder))\n+    }\n+\n+    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n+        self.infcx.next_region_var_in_universe(\n+            RegionVariableOrigin::MiscVariable(DUMMY_SP),\n+            universe\n+        )\n+    }\n+\n+    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n+        self.constraints.push(ty::OutlivesPredicate(sup.into(), sub));\n+    }\n+\n+    fn push_domain_goal(&mut self, domain_goal: DomainGoal<'tcx>) {\n+        let goal = self.environment.with(\n+            self.infcx.tcx.mk_goal(domain_goal.into_goal())\n+        );\n+        self.goals.push(goal);\n+    }\n+\n+    fn normalization() -> NormalizationStrategy {\n+        NormalizationStrategy::Lazy\n+    }\n+\n+    fn forbid_inference_vars() -> bool {\n+        false\n+    }\n+}"}, {"sha": "103331894ff1eebbc655a811ef9a5c819264a010", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -185,7 +185,7 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n             Some(orig_name) => format!(\"use {} as {};\", orig_name, item.name),\n             None => format!(\"use {};\", item.name),\n         };\n-        let replacement = visibility_qualified(&item.vis, &base_replacement);\n+        let replacement = visibility_qualified(&item.vis, base_replacement);\n         tcx.struct_span_lint_node(lint, id, extern_crate.span, msg)\n             .span_suggestion_short_with_applicability(\n                 extern_crate.span,"}, {"sha": "cbd642dd6ad918a435fb567ac40359b8863afaf3", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -86,7 +86,7 @@ impl<T: Encodable> Encodable for VecDeque<T> {\n impl<T:Decodable> Decodable for VecDeque<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<VecDeque<T>, D::Error> {\n         d.read_seq(|d, len| {\n-            let mut deque: VecDeque<T> = VecDeque::new();\n+            let mut deque: VecDeque<T> = VecDeque::with_capacity(len);\n             for i in 0..len {\n                 deque.push_back(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n             }"}, {"sha": "c1446218367e474e6d577445fcf1fb4796cf9150", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -47,6 +47,9 @@ backtrace = []\n panic-unwind = [\"panic_unwind\"]\n profiler = [\"profiler_builtins\"]\n \n+# Make panics and failed asserts immediately abort without formatting any message\n+panic_immediate_abort = [\"core/panic_immediate_abort\"]\n+\n # An off-by-default feature which enables a linux-syscall-like ABI for libstd to\n # interoperate with the host environment. Currently not well documented and\n # requires rebuilding the standard library to use it."}, {"sha": "349aa029ba8cb9a69aefa2890793677dbe7a0901", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -849,6 +849,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// let mut map: HashMap<&str, i32> = HashMap::new();\n     /// map.reserve(10);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n         match self.reserve_internal(additional, Infallible) {\n@@ -880,6 +881,7 @@ impl<K, V, S> HashMap<K, V, S>\n         self.reserve_internal(additional, Fallible)\n     }\n \n+    #[inline]\n     fn reserve_internal(&mut self, additional: usize, fallibility: Fallibility)\n         -> Result<(), CollectionAllocErr> {\n \n@@ -1571,6 +1573,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// so that the map now contains keys which compare equal, search may start\n     /// acting erratically, with two keys randomly masking each other. Implementations\n     /// are free to assume this doesn't happen (within the limits of memory-safety).\n+    #[inline(always)]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn raw_entry_mut(&mut self) -> RawEntryBuilderMut<K, V, S> {\n         self.reserve(1);\n@@ -1911,6 +1914,7 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n     }\n \n     /// Create a `RawEntryMut` from the given key and its hash.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> RawEntryMut<'a, K, V, S>\n         where K: Borrow<Q>,\n@@ -1919,6 +1923,7 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n         self.from_hash(hash, |q| q.borrow().eq(k))\n     }\n \n+    #[inline]\n     fn search<F>(self, hash: u64, is_match: F, compare_hashes: bool)  -> RawEntryMut<'a, K, V, S>\n         where for<'b> F: FnMut(&'b K) -> bool,\n     {\n@@ -1941,6 +1946,7 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n         }\n     }\n     /// Create a `RawEntryMut` from the given hash.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_hash<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>\n         where for<'b> F: FnMut(&'b K) -> bool,\n@@ -2215,6 +2221,7 @@ impl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n \n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n+    #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&'a mut K, &'a mut V) {\n         let hash = SafeHash::new(hash);"}, {"sha": "479e6dccb90dd1d51ec00c3783a32f2777689069", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -329,6 +329,7 @@ impl<K, V, M> Put<K, V> for FullBucket<K, V, M>\n }\n \n impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n+    #[inline]\n     pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> {\n         Bucket::at_index(table, hash.inspect() as usize)\n     }\n@@ -342,6 +343,7 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n         }\n     }\n \n+    #[inline]\n     pub fn at_index(table: M, ib_index: usize) -> Bucket<K, V, M> {\n         // if capacity is 0, then the RawBucket will be populated with bogus pointers.\n         // This is an uncommon case though, so avoid it in release builds.\n@@ -654,6 +656,7 @@ impl<K, V, M> GapThenFull<K, V, M>\n \n // Returns a Layout which describes the allocation required for a hash table,\n // and the offset of the array of (key, value) pairs in the allocation.\n+#[inline(always)]\n fn calculate_layout<K, V>(capacity: usize) -> Result<(Layout, usize), LayoutErr> {\n     let hashes = Layout::array::<HashUint>(capacity)?;\n     let pairs = Layout::array::<(K, V)>(capacity)?;\n@@ -722,6 +725,7 @@ impl<K, V> RawTable<K, V> {\n         }\n     }\n \n+    #[inline(always)]\n     fn raw_bucket_at(&self, index: usize) -> RawBucket<K, V> {\n         let (_, pairs_offset) = calculate_layout::<K, V>(self.capacity())\n             .unwrap_or_else(|_| unsafe { hint::unreachable_unchecked() });"}, {"sha": "4930d3566081494061fa617082b8badf6b0cbe4c", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -334,9 +334,17 @@ pub fn rust_begin_panic(info: &PanicInfo) -> ! {\n #[unstable(feature = \"libstd_sys_internals\",\n            reason = \"used by the panic! macro\",\n            issue = \"0\")]\n-#[inline(never)] #[cold]\n+#[cold]\n+// If panic_immediate_abort, inline the abort call,\n+// otherwise avoid inlining because of it is cold path.\n+#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n+#[cfg_attr(    feature=\"panic_immediate_abort\" ,inline)]\n pub fn begin_panic_fmt(msg: &fmt::Arguments,\n                        file_line_col: &(&'static str, u32, u32)) -> ! {\n+    if cfg!(feature = \"panic_immediate_abort\") {\n+        unsafe { intrinsics::abort() }\n+    }\n+\n     let (file, line, col) = *file_line_col;\n     let info = PanicInfo::internal_constructor(\n         Some(msg),\n@@ -398,8 +406,15 @@ fn continue_panic_fmt(info: &PanicInfo) -> ! {\n            reason = \"used by the panic! macro\",\n            issue = \"0\")]\n #[cfg_attr(not(test), lang = \"begin_panic\")]\n-#[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n+// never inline unless panic_immediate_abort to avoid code\n+// bloat at the call sites as much as possible\n+#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n+#[cold]\n pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u32)) -> ! {\n+    if cfg!(feature = \"panic_immediate_abort\") {\n+        unsafe { intrinsics::abort() }\n+    }\n+\n     // Note that this should be the only allocation performed in this code path.\n     // Currently this means that panic!() on OOM will invoke this code path,\n     // but then again we're not really ready for panic on OOM anyway. If"}, {"sha": "68a96293891a0c0bbce93e0c9ad83d9c8e95f85b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -1201,50 +1201,62 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        let mut expr = self.cfg.configure_expr(expr).into_inner();\n-        expr.node = self.cfg.configure_expr_kind(expr.node);\n-\n-        // ignore derives so they remain unused\n-        let (attr, expr, after_derive) = self.classify_nonitem(expr);\n-\n-        if attr.is_some() {\n-            // collect the invoc regardless of whether or not attributes are permitted here\n-            // expansion will eat the attribute so it won't error later\n-            attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n-\n-            // AstFragmentKind::Expr requires the macro to emit an expression\n-            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n-                                     AstFragmentKind::Expr, after_derive).make_expr();\n-        }\n+        let expr = self.cfg.configure_expr(expr);\n+        expr.map(|mut expr| {\n+            expr.node = self.cfg.configure_expr_kind(expr.node);\n+\n+            // ignore derives so they remain unused\n+            let (attr, expr, after_derive) = self.classify_nonitem(expr);\n+\n+            if attr.is_some() {\n+                // Collect the invoc regardless of whether or not attributes are permitted here\n+                // expansion will eat the attribute so it won't error later.\n+                attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n+\n+                // AstFragmentKind::Expr requires the macro to emit an expression.\n+                return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n+                                         AstFragmentKind::Expr, after_derive)\n+                    .make_expr()\n+                    .into_inner()\n+            }\n \n-        if let ast::ExprKind::Mac(mac) = expr.node {\n-            self.check_attributes(&expr.attrs);\n-            self.collect_bang(mac, expr.span, AstFragmentKind::Expr).make_expr()\n-        } else {\n-            P(noop_fold_expr(expr, self))\n-        }\n+            if let ast::ExprKind::Mac(mac) = expr.node {\n+                self.check_attributes(&expr.attrs);\n+                self.collect_bang(mac, expr.span, AstFragmentKind::Expr)\n+                    .make_expr()\n+                    .into_inner()\n+            } else {\n+                noop_fold_expr(expr, self)\n+            }\n+        })\n     }\n \n     fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        let mut expr = configure!(self, expr).into_inner();\n-        expr.node = self.cfg.configure_expr_kind(expr.node);\n+        let expr = configure!(self, expr);\n+        expr.filter_map(|mut expr| {\n+            expr.node = self.cfg.configure_expr_kind(expr.node);\n \n-        // ignore derives so they remain unused\n-        let (attr, expr, after_derive) = self.classify_nonitem(expr);\n+            // Ignore derives so they remain unused.\n+            let (attr, expr, after_derive) = self.classify_nonitem(expr);\n \n-        if attr.is_some() {\n-            attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n+            if attr.is_some() {\n+                attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n-            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n-                                     AstFragmentKind::OptExpr, after_derive).make_opt_expr();\n-        }\n+                return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n+                                         AstFragmentKind::OptExpr, after_derive)\n+                    .make_opt_expr()\n+                    .map(|expr| expr.into_inner())\n+            }\n \n-        if let ast::ExprKind::Mac(mac) = expr.node {\n-            self.check_attributes(&expr.attrs);\n-            self.collect_bang(mac, expr.span, AstFragmentKind::OptExpr).make_opt_expr()\n-        } else {\n-            Some(P(noop_fold_expr(expr, self)))\n-        }\n+            if let ast::ExprKind::Mac(mac) = expr.node {\n+                self.check_attributes(&expr.attrs);\n+                self.collect_bang(mac, expr.span, AstFragmentKind::OptExpr)\n+                    .make_opt_expr()\n+                    .map(|expr| expr.into_inner())\n+            } else {\n+                Some(noop_fold_expr(expr, self))\n+            }\n+        })\n     }\n \n     fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {"}, {"sha": "2402de5a816b71492afb8e7707cfd0a0cd135015", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -475,9 +475,6 @@ declare_features! (\n     // Non-builtin attributes in inner attribute position\n     (active, custom_inner_attributes, \"1.30.0\", Some(54726), None),\n \n-    // Self struct constructor  (RFC 2302)\n-    (active, self_struct_ctor, \"1.30.0\", Some(51994), None),\n-\n     // allow mixing of bind-by-move in patterns and references to\n     // those identifiers in guards, *if* we are using MIR-borrowck\n     // (aka NLL). Essentially this means you need to be on\n@@ -688,9 +685,11 @@ declare_features! (\n     (accepted, macro_literal_matcher, \"1.31.0\", Some(35625), None),\n     // Use `?` as the Kleene \"at most one\" operator\n     (accepted, macro_at_most_once_rep, \"1.32.0\", Some(48075), None),\n+    // Self struct constructor  (RFC 2302)\n+    (accepted, self_struct_ctor, \"1.32.0\", Some(51994), None),\n );\n \n-// If you change this, please modify src/doc/unstable-book as well. You must\n+// If you change this, please modify `src/doc/unstable-book` as well. You must\n // move that documentation into the relevant place in the other docs, and\n // remove the chapter on the flag.\n "}, {"sha": "f13bb7df0b44402228bc80842b078beaf69de8f0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -2791,7 +2791,7 @@ impl<'a> Parser<'a> {\n                             s.print_usize(float.trunc() as usize)?;\n                             s.pclose()?;\n                             s.s.word(\".\")?;\n-                            s.s.word(fstr.splitn(2, \".\").last().unwrap())\n+                            s.s.word(fstr.splitn(2, \".\").last().unwrap().to_string())\n                         });\n                         err.span_suggestion_with_applicability(\n                             lo.to(self.prev_span),"}, {"sha": "aaed56da29d5f5e5173a7b150084cc0d94d5d88b", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 162, "deletions": 147, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -140,13 +140,14 @@\n //! calculation, SCAN will write \"infinity\" to the size and let PRINT consume\n //! it.\n //!\n-//! In this implementation (following the paper, again) the SCAN process is\n-//! the method called `Printer::pretty_print`, and the 'PRINT' process is the method\n-//! called `Printer::print`.\n+//! In this implementation (following the paper, again) the SCAN process is the\n+//! methods called `Printer::pretty_print_*`, and the 'PRINT' process is the\n+//! method called `Printer::print`.\n \n use std::collections::VecDeque;\n use std::fmt;\n use std::io;\n+use std::borrow::Cow;\n \n /// How to break. Described in more detail in the module docs.\n #[derive(Clone, Copy, PartialEq)]\n@@ -169,7 +170,10 @@ pub struct BeginToken {\n \n #[derive(Clone)]\n pub enum Token {\n-    String(String, isize),\n+    // In practice a string token contains either a `&'static str` or a\n+    // `String`. `Cow` is overkill for this because we never modify the data,\n+    // but it's more convenient than rolling our own more specialized type.\n+    String(Cow<'static, str>, isize),\n     Break(BreakToken),\n     Begin(BeginToken),\n     End,\n@@ -309,84 +313,86 @@ impl<'a> Printer<'a> {\n     pub fn last_token(&mut self) -> Token {\n         self.buf[self.right].token.clone()\n     }\n-    /// be very careful with this!\n+\n+    /// Be very careful with this!\n     pub fn replace_last_token(&mut self, t: Token) {\n         self.buf[self.right].token = t;\n     }\n-    pub fn pretty_print(&mut self, token: Token) -> io::Result<()> {\n-        debug!(\"pp Vec<{},{}>\", self.left, self.right);\n-        match token {\n-          Token::Eof => {\n-            if !self.scan_stack.is_empty() {\n-                self.check_stack(0);\n-                self.advance_left()?;\n-            }\n-            self.indent(0);\n-            Ok(())\n-          }\n-          Token::Begin(b) => {\n-            if self.scan_stack.is_empty() {\n-                self.left_total = 1;\n-                self.right_total = 1;\n-                self.left = 0;\n-                self.right = 0;\n-            } else {\n-                self.advance_right();\n-            }\n-            debug!(\"pp Begin({})/buffer Vec<{},{}>\",\n-                   b.offset, self.left, self.right);\n-            self.buf[self.right] = BufEntry { token: token, size: -self.right_total };\n-            let right = self.right;\n-            self.scan_push(right);\n-            Ok(())\n-          }\n-          Token::End => {\n-            if self.scan_stack.is_empty() {\n-                debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n-                self.print(token, 0)\n-            } else {\n-                debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n-                self.advance_right();\n-                self.buf[self.right] = BufEntry { token: token, size: -1 };\n-                let right = self.right;\n-                self.scan_push(right);\n-                Ok(())\n-            }\n-          }\n-          Token::Break(b) => {\n-            if self.scan_stack.is_empty() {\n-                self.left_total = 1;\n-                self.right_total = 1;\n-                self.left = 0;\n-                self.right = 0;\n-            } else {\n-                self.advance_right();\n-            }\n-            debug!(\"pp Break({})/buffer Vec<{},{}>\",\n-                   b.offset, self.left, self.right);\n+\n+    fn pretty_print_eof(&mut self) -> io::Result<()> {\n+        if !self.scan_stack.is_empty() {\n             self.check_stack(0);\n+            self.advance_left()?;\n+        }\n+        self.indent(0);\n+        Ok(())\n+    }\n+\n+    fn pretty_print_begin(&mut self, b: BeginToken) -> io::Result<()> {\n+        if self.scan_stack.is_empty() {\n+            self.left_total = 1;\n+            self.right_total = 1;\n+            self.left = 0;\n+            self.right = 0;\n+        } else {\n+            self.advance_right();\n+        }\n+        debug!(\"pp Begin({})/buffer Vec<{},{}>\",\n+               b.offset, self.left, self.right);\n+        self.buf[self.right] = BufEntry { token: Token::Begin(b), size: -self.right_total };\n+        let right = self.right;\n+        self.scan_push(right);\n+        Ok(())\n+    }\n+\n+    fn pretty_print_end(&mut self) -> io::Result<()> {\n+        if self.scan_stack.is_empty() {\n+            debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n+            self.print_end()\n+        } else {\n+            debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n+            self.advance_right();\n+            self.buf[self.right] = BufEntry { token: Token::End, size: -1 };\n             let right = self.right;\n             self.scan_push(right);\n-            self.buf[self.right] = BufEntry { token: token, size: -self.right_total };\n-            self.right_total += b.blank_space;\n             Ok(())\n-          }\n-          Token::String(s, len) => {\n-            if self.scan_stack.is_empty() {\n-                debug!(\"pp String('{}')/print Vec<{},{}>\",\n-                       s, self.left, self.right);\n-                self.print(Token::String(s, len), len)\n-            } else {\n-                debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n-                       s, self.left, self.right);\n-                self.advance_right();\n-                self.buf[self.right] = BufEntry { token: Token::String(s, len), size: len };\n-                self.right_total += len;\n-                self.check_stream()\n-            }\n-          }\n         }\n     }\n+\n+    fn pretty_print_break(&mut self, b: BreakToken) -> io::Result<()> {\n+        if self.scan_stack.is_empty() {\n+            self.left_total = 1;\n+            self.right_total = 1;\n+            self.left = 0;\n+            self.right = 0;\n+        } else {\n+            self.advance_right();\n+        }\n+        debug!(\"pp Break({})/buffer Vec<{},{}>\",\n+               b.offset, self.left, self.right);\n+        self.check_stack(0);\n+        let right = self.right;\n+        self.scan_push(right);\n+        self.buf[self.right] = BufEntry { token: Token::Break(b), size: -self.right_total };\n+        self.right_total += b.blank_space;\n+        Ok(())\n+    }\n+\n+    fn pretty_print_string(&mut self, s: Cow<'static, str>, len: isize) -> io::Result<()> {\n+        if self.scan_stack.is_empty() {\n+            debug!(\"pp String('{}')/print Vec<{},{}>\",\n+                   s, self.left, self.right);\n+            self.print_string(s, len)\n+        } else {\n+            debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n+                   s, self.left, self.right);\n+            self.advance_right();\n+            self.buf[self.right] = BufEntry { token: Token::String(s, len), size: len };\n+            self.right_total += len;\n+            self.check_stream()\n+        }\n+    }\n+\n     pub fn check_stream(&mut self) -> io::Result<()> {\n         debug!(\"check_stream Vec<{}, {}> with left_total={}, right_total={}\",\n                self.left, self.right, self.left_total, self.right_total);\n@@ -405,19 +411,24 @@ impl<'a> Printer<'a> {\n         }\n         Ok(())\n     }\n+\n     pub fn scan_push(&mut self, x: usize) {\n         debug!(\"scan_push {}\", x);\n         self.scan_stack.push_front(x);\n     }\n+\n     pub fn scan_pop(&mut self) -> usize {\n         self.scan_stack.pop_front().unwrap()\n     }\n+\n     pub fn scan_top(&mut self) -> usize {\n         *self.scan_stack.front().unwrap()\n     }\n+\n     pub fn scan_pop_bottom(&mut self) -> usize {\n         self.scan_stack.pop_back().unwrap()\n     }\n+\n     pub fn advance_right(&mut self) {\n         self.right += 1;\n         self.right %= self.buf_max_len;\n@@ -427,6 +438,7 @@ impl<'a> Printer<'a> {\n         }\n         assert_ne!(self.right, self.left);\n     }\n+\n     pub fn advance_left(&mut self) -> io::Result<()> {\n         debug!(\"advance_left Vec<{},{}>, sizeof({})={}\", self.left, self.right,\n                self.left, self.buf[self.left].size);\n@@ -461,6 +473,7 @@ impl<'a> Printer<'a> {\n \n         Ok(())\n     }\n+\n     pub fn check_stack(&mut self, k: isize) {\n         if !self.scan_stack.is_empty() {\n             let x = self.scan_top();\n@@ -488,17 +501,20 @@ impl<'a> Printer<'a> {\n             }\n         }\n     }\n+\n     pub fn print_newline(&mut self, amount: isize) -> io::Result<()> {\n         debug!(\"NEWLINE {}\", amount);\n         let ret = write!(self.out, \"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n         ret\n     }\n+\n     pub fn indent(&mut self, amount: isize) {\n         debug!(\"INDENT {}\", amount);\n         self.pending_indentation += amount;\n     }\n+\n     pub fn get_top(&mut self) -> PrintStackElem {\n         match self.print_stack.last() {\n             Some(el) => *el,\n@@ -508,62 +524,50 @@ impl<'a> Printer<'a> {\n             }\n         }\n     }\n-    pub fn print_str(&mut self, s: &str) -> io::Result<()> {\n-        while self.pending_indentation > 0 {\n-            write!(self.out, \" \")?;\n-            self.pending_indentation -= 1;\n+\n+    pub fn print_begin(&mut self, b: BeginToken, l: isize) -> io::Result<()> {\n+        if l > self.space {\n+            let col = self.margin - self.space + b.offset;\n+            debug!(\"print Begin -> push broken block at col {}\", col);\n+            self.print_stack.push(PrintStackElem {\n+                offset: col,\n+                pbreak: PrintStackBreak::Broken(b.breaks)\n+            });\n+        } else {\n+            debug!(\"print Begin -> push fitting block\");\n+            self.print_stack.push(PrintStackElem {\n+                offset: 0,\n+                pbreak: PrintStackBreak::Fits\n+            });\n         }\n-        write!(self.out, \"{}\", s)\n+        Ok(())\n     }\n-    pub fn print(&mut self, token: Token, l: isize) -> io::Result<()> {\n-        debug!(\"print {} {} (remaining line space={})\", token, l,\n-               self.space);\n-        debug!(\"{}\", buf_str(&self.buf,\n-                             self.left,\n-                             self.right,\n-                             6));\n-        match token {\n-          Token::Begin(b) => {\n-            if l > self.space {\n-                let col = self.margin - self.space + b.offset;\n-                debug!(\"print Begin -> push broken block at col {}\", col);\n-                self.print_stack.push(PrintStackElem {\n-                    offset: col,\n-                    pbreak: PrintStackBreak::Broken(b.breaks)\n-                });\n-            } else {\n-                debug!(\"print Begin -> push fitting block\");\n-                self.print_stack.push(PrintStackElem {\n-                    offset: 0,\n-                    pbreak: PrintStackBreak::Fits\n-                });\n-            }\n-            Ok(())\n-          }\n-          Token::End => {\n-            debug!(\"print End -> pop End\");\n-            let print_stack = &mut self.print_stack;\n-            assert!(!print_stack.is_empty());\n-            print_stack.pop().unwrap();\n-            Ok(())\n-          }\n-          Token::Break(b) => {\n-            let top = self.get_top();\n-            match top.pbreak {\n-              PrintStackBreak::Fits => {\n+\n+    pub fn print_end(&mut self) -> io::Result<()> {\n+        debug!(\"print End -> pop End\");\n+        let print_stack = &mut self.print_stack;\n+        assert!(!print_stack.is_empty());\n+        print_stack.pop().unwrap();\n+        Ok(())\n+    }\n+\n+    pub fn print_break(&mut self, b: BreakToken, l: isize) -> io::Result<()> {\n+        let top = self.get_top();\n+        match top.pbreak {\n+            PrintStackBreak::Fits => {\n                 debug!(\"print Break({}) in fitting block\", b.blank_space);\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n                 Ok(())\n-              }\n-              PrintStackBreak::Broken(Breaks::Consistent) => {\n+            }\n+            PrintStackBreak::Broken(Breaks::Consistent) => {\n                 debug!(\"print Break({}+{}) in consistent block\",\n                        top.offset, b.offset);\n                 let ret = self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n                 ret\n-              }\n-              PrintStackBreak::Broken(Breaks::Inconsistent) => {\n+            }\n+            PrintStackBreak::Broken(Breaks::Inconsistent) => {\n                 if l > self.space {\n                     debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n                            top.offset, b.offset);\n@@ -577,31 +581,48 @@ impl<'a> Printer<'a> {\n                     self.space -= b.blank_space;\n                     Ok(())\n                 }\n-              }\n             }\n-          }\n-          Token::String(ref s, len) => {\n-            debug!(\"print String({})\", s);\n-            assert_eq!(l, len);\n-            // assert!(l <= space);\n-            self.space -= len;\n-            self.print_str(s)\n-          }\n-          Token::Eof => {\n-            // Eof should never get here.\n-            panic!();\n-          }\n+        }\n+    }\n+\n+    pub fn print_string(&mut self, s: Cow<'static, str>, len: isize) -> io::Result<()> {\n+        debug!(\"print String({})\", s);\n+        // assert!(len <= space);\n+        self.space -= len;\n+        while self.pending_indentation > 0 {\n+            write!(self.out, \" \")?;\n+            self.pending_indentation -= 1;\n+        }\n+        write!(self.out, \"{}\", s)\n+    }\n+\n+    pub fn print(&mut self, token: Token, l: isize) -> io::Result<()> {\n+        debug!(\"print {} {} (remaining line space={})\", token, l,\n+               self.space);\n+        debug!(\"{}\", buf_str(&self.buf,\n+                             self.left,\n+                             self.right,\n+                             6));\n+        match token {\n+            Token::Begin(b) => self.print_begin(b, l),\n+            Token::End => self.print_end(),\n+            Token::Break(b) => self.print_break(b, l),\n+            Token::String(s, len) => {\n+                assert_eq!(len, l);\n+                self.print_string(s, len)\n+            }\n+            Token::Eof => panic!(), // Eof should never get here.\n         }\n     }\n \n     // Convenience functions to talk to the printer.\n \n     /// \"raw box\"\n     pub fn rbox(&mut self, indent: usize, b: Breaks) -> io::Result<()> {\n-        self.pretty_print(Token::Begin(BeginToken {\n+        self.pretty_print_begin(BeginToken {\n             offset: indent as isize,\n             breaks: b\n-        }))\n+        })\n     }\n \n     /// Inconsistent breaking box\n@@ -615,30 +636,24 @@ impl<'a> Printer<'a> {\n     }\n \n     pub fn break_offset(&mut self, n: usize, off: isize) -> io::Result<()> {\n-        self.pretty_print(Token::Break(BreakToken {\n+        self.pretty_print_break(BreakToken {\n             offset: off,\n             blank_space: n as isize\n-        }))\n+        })\n     }\n \n     pub fn end(&mut self) -> io::Result<()> {\n-        self.pretty_print(Token::End)\n+        self.pretty_print_end()\n     }\n \n     pub fn eof(&mut self) -> io::Result<()> {\n-        self.pretty_print(Token::Eof)\n-    }\n-\n-    pub fn word(&mut self, wrd: &str) -> io::Result<()> {\n-        self.pretty_print(Token::String(wrd.to_string(), wrd.len() as isize))\n-    }\n-\n-    pub fn huge_word(&mut self, wrd: &str) -> io::Result<()> {\n-        self.pretty_print(Token::String(wrd.to_string(), SIZE_INFINITY))\n+        self.pretty_print_eof()\n     }\n \n-    pub fn zero_word(&mut self, wrd: &str) -> io::Result<()> {\n-        self.pretty_print(Token::String(wrd.to_string(), 0))\n+    pub fn word<S: Into<Cow<'static, str>>>(&mut self, wrd: S) -> io::Result<()> {\n+        let s = wrd.into();\n+        let len = s.len() as isize;\n+        self.pretty_print_string(s, len)\n     }\n \n     fn spaces(&mut self, n: usize) -> io::Result<()> {"}, {"sha": "14ad4b5c6f8159475b23ac5ba31b5d4775e51ce5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -29,6 +29,7 @@ use syntax_pos::{DUMMY_SP, FileName};\n use tokenstream::{self, TokenStream, TokenTree};\n \n use std::ascii;\n+use std::borrow::Cow;\n use std::io::{self, Write, Read};\n use std::iter::Peekable;\n use std::vec;\n@@ -444,7 +445,7 @@ pub trait PrintState<'a> {\n     fn cur_lit(&mut self) -> Option<&comments::Literal>;\n     fn bump_lit(&mut self) -> Option<comments::Literal>;\n \n-    fn word_space(&mut self, w: &str) -> io::Result<()> {\n+    fn word_space<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n         self.writer().word(w)?;\n         self.writer().space()\n     }\n@@ -539,7 +540,7 @@ pub trait PrintState<'a> {\n             comments::Mixed => {\n                 assert_eq!(cmnt.lines.len(), 1);\n                 self.writer().zerobreak()?;\n-                self.writer().word(&cmnt.lines[0])?;\n+                self.writer().word(cmnt.lines[0].clone())?;\n                 self.writer().zerobreak()\n             }\n             comments::Isolated => {\n@@ -548,7 +549,7 @@ pub trait PrintState<'a> {\n                     // Don't print empty lines because they will end up as trailing\n                     // whitespace\n                     if !line.is_empty() {\n-                        self.writer().word(&line[..])?;\n+                        self.writer().word(line.clone())?;\n                     }\n                     self.writer().hardbreak()?;\n                 }\n@@ -559,13 +560,13 @@ pub trait PrintState<'a> {\n                     self.writer().word(\" \")?;\n                 }\n                 if cmnt.lines.len() == 1 {\n-                    self.writer().word(&cmnt.lines[0])?;\n+                    self.writer().word(cmnt.lines[0].clone())?;\n                     self.writer().hardbreak()\n                 } else {\n                     self.ibox(0)?;\n                     for line in &cmnt.lines {\n                         if !line.is_empty() {\n-                            self.writer().word(&line[..])?;\n+                            self.writer().word(line.clone())?;\n                         }\n                         self.writer().hardbreak()?;\n                     }\n@@ -610,39 +611,39 @@ pub trait PrintState<'a> {\n     fn print_literal(&mut self, lit: &ast::Lit) -> io::Result<()> {\n         self.maybe_print_comment(lit.span.lo())?;\n         if let Some(ltrl) = self.next_lit(lit.span.lo()) {\n-            return self.writer().word(&ltrl.lit);\n+            return self.writer().word(ltrl.lit.clone());\n         }\n         match lit.node {\n             ast::LitKind::Str(st, style) => self.print_string(&st.as_str(), style),\n             ast::LitKind::Byte(byte) => {\n                 let mut res = String::from(\"b'\");\n                 res.extend(ascii::escape_default(byte).map(|c| c as char));\n                 res.push('\\'');\n-                self.writer().word(&res[..])\n+                self.writer().word(res)\n             }\n             ast::LitKind::Char(ch) => {\n                 let mut res = String::from(\"'\");\n                 res.extend(ch.escape_default());\n                 res.push('\\'');\n-                self.writer().word(&res[..])\n+                self.writer().word(res)\n             }\n             ast::LitKind::Int(i, t) => {\n                 match t {\n                     ast::LitIntType::Signed(st) => {\n-                        self.writer().word(&st.val_to_string(i as i128))\n+                        self.writer().word(st.val_to_string(i as i128))\n                     }\n                     ast::LitIntType::Unsigned(ut) => {\n-                        self.writer().word(&ut.val_to_string(i))\n+                        self.writer().word(ut.val_to_string(i))\n                     }\n                     ast::LitIntType::Unsuffixed => {\n-                        self.writer().word(&i.to_string())\n+                        self.writer().word(i.to_string())\n                     }\n                 }\n             }\n             ast::LitKind::Float(ref f, t) => {\n-                self.writer().word(&format!(\"{}{}\", &f, t.ty_to_string()))\n+                self.writer().word(format!(\"{}{}\", &f, t.ty_to_string()))\n             }\n-            ast::LitKind::FloatUnsuffixed(ref f) => self.writer().word(&f.as_str()),\n+            ast::LitKind::FloatUnsuffixed(ref f) => self.writer().word(f.as_str().get()),\n             ast::LitKind::Bool(val) => {\n                 if val { self.writer().word(\"true\") } else { self.writer().word(\"false\") }\n             }\n@@ -652,7 +653,7 @@ pub trait PrintState<'a> {\n                     escaped.extend(ascii::escape_default(ch)\n                                          .map(|c| c as char));\n                 }\n-                self.writer().word(&format!(\"b\\\"{}\\\"\", escaped))\n+                self.writer().word(format!(\"b\\\"{}\\\"\", escaped))\n             }\n         }\n     }\n@@ -669,7 +670,7 @@ pub trait PrintState<'a> {\n                          string=st))\n             }\n         };\n-        self.writer().word(&st[..])\n+        self.writer().word(st)\n     }\n \n     fn print_inner_attributes(&mut self,\n@@ -727,7 +728,7 @@ pub trait PrintState<'a> {\n             if segment.ident.name != keywords::CrateRoot.name() &&\n                segment.ident.name != keywords::DollarCrate.name()\n             {\n-                self.writer().word(&segment.ident.as_str())?;\n+                self.writer().word(segment.ident.as_str().get())?;\n             } else if segment.ident.name == keywords::DollarCrate.name() {\n                 self.print_dollar_crate(segment.ident.span.ctxt())?;\n             }\n@@ -746,7 +747,7 @@ pub trait PrintState<'a> {\n         }\n         self.maybe_print_comment(attr.span.lo())?;\n         if attr.is_sugared_doc {\n-            self.writer().word(&attr.value_str().unwrap().as_str())?;\n+            self.writer().word(attr.value_str().unwrap().as_str().get())?;\n             self.writer().hardbreak()\n         } else {\n             match attr.style {\n@@ -807,7 +808,7 @@ pub trait PrintState<'a> {\n     fn print_tt(&mut self, tt: tokenstream::TokenTree) -> io::Result<()> {\n         match tt {\n             TokenTree::Token(_, ref tk) => {\n-                self.writer().word(&token_to_string(tk))?;\n+                self.writer().word(token_to_string(tk))?;\n                 match *tk {\n                     parse::token::DocComment(..) => {\n                         self.writer().hardbreak()\n@@ -816,11 +817,11 @@ pub trait PrintState<'a> {\n                 }\n             }\n             TokenTree::Delimited(_, ref delimed) => {\n-                self.writer().word(&token_to_string(&delimed.open_token()))?;\n+                self.writer().word(token_to_string(&delimed.open_token()))?;\n                 self.writer().space()?;\n                 self.print_tts(delimed.stream())?;\n                 self.writer().space()?;\n-                self.writer().word(&token_to_string(&delimed.close_token()))\n+                self.writer().word(token_to_string(&delimed.close_token()))\n             },\n         }\n     }\n@@ -889,12 +890,13 @@ impl<'a> State<'a> {\n         self.s.cbox(u)\n     }\n \n-    pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> {\n+    pub fn word_nbsp<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n         self.s.word(w)?;\n         self.nbsp()\n     }\n \n-    pub fn head(&mut self, w: &str) -> io::Result<()> {\n+    pub fn head<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n+        let w = w.into();\n         // outer-box is consistent\n         self.cbox(INDENT_UNIT)?;\n         // head-box is inconsistent\n@@ -956,7 +958,7 @@ impl<'a> State<'a> {\n     pub fn synth_comment(&mut self, text: String) -> io::Result<()> {\n         self.s.word(\"/*\")?;\n         self.s.space()?;\n-        self.s.word(&text[..])?;\n+        self.s.word(text)?;\n         self.s.space()?;\n         self.s.word(\"*/\")\n     }\n@@ -1129,7 +1131,7 @@ impl<'a> State<'a> {\n                 self.end() // end the outer fn box\n             }\n             ast::ForeignItemKind::Static(ref t, m) => {\n-                self.head(&visibility_qualified(&item.vis, \"static\"))?;\n+                self.head(visibility_qualified(&item.vis, \"static\"))?;\n                 if m {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -1141,7 +1143,7 @@ impl<'a> State<'a> {\n                 self.end() // end the outer cbox\n             }\n             ast::ForeignItemKind::Ty => {\n-                self.head(&visibility_qualified(&item.vis, \"type\"))?;\n+                self.head(visibility_qualified(&item.vis, \"type\"))?;\n                 self.print_ident(item.ident)?;\n                 self.s.word(\";\")?;\n                 self.end()?; // end the head-ibox\n@@ -1164,7 +1166,7 @@ impl<'a> State<'a> {\n                               vis: &ast::Visibility)\n                               -> io::Result<()>\n     {\n-        self.s.word(&visibility_qualified(vis, \"\"))?;\n+        self.s.word(visibility_qualified(vis, \"\"))?;\n         self.word_space(\"const\")?;\n         self.print_ident(ident)?;\n         self.word_space(\":\")?;\n@@ -1203,7 +1205,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Item(item))?;\n         match item.node {\n             ast::ItemKind::ExternCrate(orig_name) => {\n-                self.head(&visibility_qualified(&item.vis, \"extern crate\"))?;\n+                self.head(visibility_qualified(&item.vis, \"extern crate\"))?;\n                 if let Some(orig_name) = orig_name {\n                     self.print_name(orig_name)?;\n                     self.s.space()?;\n@@ -1216,14 +1218,14 @@ impl<'a> State<'a> {\n                 self.end()?; // end outer head-block\n             }\n             ast::ItemKind::Use(ref tree) => {\n-                self.head(&visibility_qualified(&item.vis, \"use\"))?;\n+                self.head(visibility_qualified(&item.vis, \"use\"))?;\n                 self.print_use_tree(tree)?;\n                 self.s.word(\";\")?;\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n             ast::ItemKind::Static(ref ty, m, ref expr) => {\n-                self.head(&visibility_qualified(&item.vis, \"static\"))?;\n+                self.head(visibility_qualified(&item.vis, \"static\"))?;\n                 if m == ast::Mutability::Mutable {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -1239,7 +1241,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer cbox\n             }\n             ast::ItemKind::Const(ref ty, ref expr) => {\n-                self.head(&visibility_qualified(&item.vis, \"const\"))?;\n+                self.head(visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_ident(item.ident)?;\n                 self.word_space(\":\")?;\n                 self.print_type(ty)?;\n@@ -1264,7 +1266,7 @@ impl<'a> State<'a> {\n                 self.print_block_with_attrs(body, &item.attrs)?;\n             }\n             ast::ItemKind::Mod(ref _mod) => {\n-                self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n+                self.head(visibility_qualified(&item.vis, \"mod\"))?;\n                 self.print_ident(item.ident)?;\n \n                 if _mod.inline || self.is_expanded {\n@@ -1281,18 +1283,18 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::ForeignMod(ref nmod) => {\n                 self.head(\"extern\")?;\n-                self.word_nbsp(&nmod.abi.to_string())?;\n+                self.word_nbsp(nmod.abi.to_string())?;\n                 self.bopen()?;\n                 self.print_foreign_mod(nmod, &item.attrs)?;\n                 self.bclose(item.span)?;\n             }\n             ast::ItemKind::GlobalAsm(ref ga) => {\n-                self.head(&visibility_qualified(&item.vis, \"global_asm!\"))?;\n-                self.s.word(&ga.asm.as_str())?;\n+                self.head(visibility_qualified(&item.vis, \"global_asm!\"))?;\n+                self.s.word(ga.asm.as_str().get())?;\n                 self.end()?;\n             }\n             ast::ItemKind::Ty(ref ty, ref generics) => {\n-                self.head(&visibility_qualified(&item.vis, \"type\"))?;\n+                self.head(visibility_qualified(&item.vis, \"type\"))?;\n                 self.print_ident(item.ident)?;\n                 self.print_generic_params(&generics.params)?;\n                 self.end()?; // end the inner ibox\n@@ -1305,7 +1307,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer ibox\n             }\n             ast::ItemKind::Existential(ref bounds, ref generics) => {\n-                self.head(&visibility_qualified(&item.vis, \"existential type\"))?;\n+                self.head(visibility_qualified(&item.vis, \"existential type\"))?;\n                 self.print_ident(item.ident)?;\n                 self.print_generic_params(&generics.params)?;\n                 self.end()?; // end the inner ibox\n@@ -1326,11 +1328,11 @@ impl<'a> State<'a> {\n                 )?;\n             }\n             ast::ItemKind::Struct(ref struct_def, ref generics) => {\n-                self.head(&visibility_qualified(&item.vis, \"struct\"))?;\n+                self.head(visibility_qualified(&item.vis, \"struct\"))?;\n                 self.print_struct(struct_def, generics, item.ident, item.span, true)?;\n             }\n             ast::ItemKind::Union(ref struct_def, ref generics) => {\n-                self.head(&visibility_qualified(&item.vis, \"union\"))?;\n+                self.head(visibility_qualified(&item.vis, \"union\"))?;\n                 self.print_struct(struct_def, generics, item.ident, item.span, true)?;\n             }\n             ast::ItemKind::Impl(unsafety,\n@@ -1479,7 +1481,7 @@ impl<'a> State<'a> {\n                           generics: &ast::Generics, ident: ast::Ident,\n                           span: syntax_pos::Span,\n                           visibility: &ast::Visibility) -> io::Result<()> {\n-        self.head(&visibility_qualified(visibility, \"enum\"))?;\n+        self.head(visibility_qualified(visibility, \"enum\"))?;\n         self.print_ident(ident)?;\n         self.print_generic_params(&generics.params)?;\n         self.print_where_clause(&generics.where_clause)?;\n@@ -1514,9 +1516,9 @@ impl<'a> State<'a> {\n             ast::VisibilityKind::Restricted { ref path, .. } => {\n                 let path = to_string(|s| s.print_path(path, false, 0));\n                 if path == \"self\" || path == \"super\" {\n-                    self.word_nbsp(&format!(\"pub({})\", path))\n+                    self.word_nbsp(format!(\"pub({})\", path))\n                 } else {\n-                    self.word_nbsp(&format!(\"pub(in {})\", path))\n+                    self.word_nbsp(format!(\"pub(in {})\", path))\n                 }\n             }\n             ast::VisibilityKind::Inherited => Ok(())\n@@ -2415,19 +2417,19 @@ impl<'a> State<'a> {\n \n     pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n         if ident.is_raw_guess() {\n-            self.s.word(&format!(\"r#{}\", ident))?;\n+            self.s.word(format!(\"r#{}\", ident))?;\n         } else {\n-            self.s.word(&ident.as_str())?;\n+            self.s.word(ident.as_str().get())?;\n         }\n         self.ann.post(self, AnnNode::Ident(&ident))\n     }\n \n     pub fn print_usize(&mut self, i: usize) -> io::Result<()> {\n-        self.s.word(&i.to_string())\n+        self.s.word(i.to_string())\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n-        self.s.word(&name.as_str())?;\n+        self.s.word(name.as_str().get())?;\n         self.ann.post(self, AnnNode::Name(&name))\n     }\n \n@@ -2851,10 +2853,8 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_type_bounds(&mut self,\n-                        prefix: &str,\n-                        bounds: &[ast::GenericBound])\n-                        -> io::Result<()> {\n+    pub fn print_type_bounds(&mut self, prefix: &'static str, bounds: &[ast::GenericBound])\n+                             -> io::Result<()> {\n         if !bounds.is_empty() {\n             self.s.word(prefix)?;\n             let mut first = true;\n@@ -3146,7 +3146,7 @@ impl<'a> State<'a> {\n             Some(Abi::Rust) => Ok(()),\n             Some(abi) => {\n                 self.word_nbsp(\"extern\")?;\n-                self.word_nbsp(&abi.to_string())\n+                self.word_nbsp(abi.to_string())\n             }\n             None => Ok(())\n         }\n@@ -3157,7 +3157,7 @@ impl<'a> State<'a> {\n         match opt_abi {\n             Some(abi) => {\n                 self.word_nbsp(\"extern\")?;\n-                self.word_nbsp(&abi.to_string())\n+                self.word_nbsp(abi.to_string())\n             }\n             None => Ok(())\n         }\n@@ -3166,7 +3166,7 @@ impl<'a> State<'a> {\n     pub fn print_fn_header_info(&mut self,\n                                 header: ast::FnHeader,\n                                 vis: &ast::Visibility) -> io::Result<()> {\n-        self.s.word(&visibility_qualified(vis, \"\"))?;\n+        self.s.word(visibility_qualified(vis, \"\"))?;\n \n         match header.constness.node {\n             ast::Constness::NotConst => {}\n@@ -3178,7 +3178,7 @@ impl<'a> State<'a> {\n \n         if header.abi != Abi::Rust {\n             self.word_nbsp(\"extern\")?;\n-            self.word_nbsp(&header.abi.to_string())?;\n+            self.word_nbsp(header.abi.to_string())?;\n         }\n \n         self.s.word(\"fn\")"}, {"sha": "9fbc64758da4dc773cfd5dbf57d2d52e1863c1d2", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -72,7 +72,7 @@ impl<T: 'static> P<T> {\n         *self.ptr\n     }\n \n-    /// Transform the inner value, consuming `self` and producing a new `P<T>`.\n+    /// Produce a new `P<T>` from `self` without reallocating.\n     pub fn map<F>(mut self, f: F) -> P<T> where\n         F: FnOnce(T) -> T,\n     {\n@@ -88,8 +88,30 @@ impl<T: 'static> P<T> {\n             ptr::write(p, f(ptr::read(p)));\n \n             // Recreate self from the raw pointer.\n-            P {\n-                ptr: Box::from_raw(p)\n+            P { ptr: Box::from_raw(p) }\n+        }\n+    }\n+\n+    /// Optionally produce a new `P<T>` from `self` without reallocating.\n+    pub fn filter_map<F>(mut self, f: F) -> Option<P<T>> where\n+        F: FnOnce(T) -> Option<T>,\n+    {\n+        let p: *mut T = &mut *self.ptr;\n+\n+        // Leak self in case of panic.\n+        // FIXME(eddyb) Use some sort of \"free guard\" that\n+        // only deallocates, without dropping the pointee,\n+        // in case the call the `f` below ends in a panic.\n+        mem::forget(self);\n+\n+        unsafe {\n+            if let Some(v) = f(ptr::read(p)) {\n+                ptr::write(p, v);\n+\n+                // Recreate self from the raw pointer.\n+                Some(P { ptr: Box::from_raw(p) })\n+            } else {\n+                None\n             }\n         }\n     }"}, {"sha": "34fb71e4ddf68242380b2823d29049bc46a3a6a9", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -587,6 +587,7 @@ impl fmt::Debug for SpanData {\n }\n \n impl MultiSpan {\n+    #[inline]\n     pub fn new() -> MultiSpan {\n         MultiSpan {\n             primary_spans: vec![],"}, {"sha": "741877bb4c88fdc94e99d6678edcb7208c9e659a", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -492,6 +492,10 @@ impl LocalInternedString {\n             symbol: Symbol::intern(self.string)\n         }\n     }\n+\n+    pub fn get(&self) -> &'static str {\n+        self.string\n+    }\n }\n \n impl<U: ?Sized> ::std::convert::AsRef<U> for LocalInternedString"}, {"sha": "d7f67577b04ceff6c54598ca2aa36c152f954186", "filename": "src/test/run-make/llvm-outputs/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Frun-make%2Fllvm-outputs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Frun-make%2Fllvm-outputs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-outputs%2FMakefile?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -0,0 +1,5 @@\n+-include ../../run-make-fulldeps/tools.mk\n+\n+all:\n+\techo 'fn main() {}' | $(BARE_RUSTC) - --out-dir=$(TMPDIR)/random_directory_that_does_not_exist_ir/ --emit=llvm-ir\n+\techo 'fn main() {}' | $(BARE_RUSTC) - --out-dir=$(TMPDIR)/random_directory_that_does_not_exist_bc/ --emit=llvm-bc"}, {"sha": "1ec20c50034bdc4bfe5b0af0b620885349a14cd1", "filename": "src/test/run-pass/rfcs/rfc-2302-self-struct-ctor.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2302-self-struct-ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2302-self-struct-ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfcs%2Frfc-2302-self-struct-ctor.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(self_struct_ctor)]\n-\n #![allow(dead_code)]\n \n use std::fmt::Display;"}, {"sha": "9d1a8b59463e7ecb07d866c9cf0dcd6e8f82e53f", "filename": "src/test/ui/consts/issue-56164.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -0,0 +1,13 @@\n+#![feature(const_fn)]\n+\n+const fn foo() { (||{})() }\n+//~^ ERROR calls in constant functions are limited to constant functions, tuple structs and tuple\n+// variants\n+\n+const fn bad(input: fn()) {\n+    input()\n+    //~^ ERROR function pointers are not allowed in const fn\n+}\n+\n+fn main() {\n+}"}, {"sha": "d3e9ce379aed702fcc6e51c39ada44b1029c4f53", "filename": "src/test/ui/consts/issue-56164.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -0,0 +1,15 @@\n+error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/issue-56164.rs:3:18\n+   |\n+LL | const fn foo() { (||{})() }\n+   |                  ^^^^^^^^\n+\n+error: function pointers are not allowed in const fn\n+  --> $DIR/issue-56164.rs:8:5\n+   |\n+LL |     input()\n+   |     ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0015`."}, {"sha": "7c9f7dd040207fd80f106eef2329923477b50875", "filename": "src/test/ui/feature-gates/feature-gate-custom_test_frameworks.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_test_frameworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_test_frameworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_test_frameworks.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "previous_filename": "src/test/ui/feature-gate-custom_test_frameworks.rs"}, {"sha": "bfcbab500671f2b643943f5d6e827033d37afe84", "filename": "src/test/ui/feature-gates/feature-gate-custom_test_frameworks.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_test_frameworks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_test_frameworks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_test_frameworks.stderr?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "previous_filename": "src/test/ui/feature-gate-custom_test_frameworks.stderr"}, {"sha": "6207d99dc36aa443735b737949e1219e9954b6dc", "filename": "src/test/ui/feature-gates/feature-gate-doc_cfg-cfg-rustdoc.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-doc_cfg-cfg-rustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-doc_cfg-cfg-rustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-doc_cfg-cfg-rustdoc.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "previous_filename": "src/test/ui/feature-gate-doc_cfg-cfg-rustdoc.rs"}, {"sha": "be2c263af042deab1aaca34bcc1b58228a5aee07", "filename": "src/test/ui/feature-gates/feature-gate-doc_cfg-cfg-rustdoc.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-doc_cfg-cfg-rustdoc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-doc_cfg-cfg-rustdoc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-doc_cfg-cfg-rustdoc.stderr?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "previous_filename": "src/test/ui/feature-gate-doc_cfg-cfg-rustdoc.stderr"}, {"sha": "98eab3949132046005f628d9dc0dd95455c91a21", "filename": "src/test/ui/feature-gates/feature-gate-self-struct-ctor.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d48ab693d1ce99f30c0cf9abdf45c209824fe825/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self-struct-ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48ab693d1ce99f30c0cf9abdf45c209824fe825/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self-struct-ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self-struct-ctor.rs?ref=d48ab693d1ce99f30c0cf9abdf45c209824fe825", "patch": "@@ -1,22 +0,0 @@\n-struct ST1(i32, i32);\n-\n-impl ST1 {\n-    fn ctor() -> Self {\n-        Self(1,2)\n-        //~^ ERROR: `Self` struct constructors are unstable (see issue #51994) [E0658]\n-    }\n-}\n-\n-struct ST2;\n-\n-impl ST2 {\n-    fn ctor() -> Self {\n-        Self\n-        //~^ ERROR: `Self` struct constructors are unstable (see issue #51994) [E0658]\n-    }\n-}\n-\n-fn main() {\n-    let _ = ST1::ctor();\n-    let _ = ST2::ctor();\n-}"}, {"sha": "6061a0db76ec54a38f31f07300b80456072915a6", "filename": "src/test/ui/feature-gates/feature-gate-self-struct-ctor.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d48ab693d1ce99f30c0cf9abdf45c209824fe825/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self-struct-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d48ab693d1ce99f30c0cf9abdf45c209824fe825/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self-struct-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self-struct-ctor.stderr?ref=d48ab693d1ce99f30c0cf9abdf45c209824fe825", "patch": "@@ -1,19 +0,0 @@\n-error[E0658]: `Self` struct constructors are unstable (see issue #51994)\n-  --> $DIR/feature-gate-self-struct-ctor.rs:5:9\n-   |\n-LL |         Self(1,2)\n-   |         ^^^^\n-   |\n-   = help: add #![feature(self_struct_ctor)] to the crate attributes to enable\n-\n-error[E0658]: `Self` struct constructors are unstable (see issue #51994)\n-  --> $DIR/feature-gate-self-struct-ctor.rs:14:9\n-   |\n-LL |         Self\n-   |         ^^^^\n-   |\n-   = help: add #![feature(self_struct_ctor)] to the crate attributes to enable\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "b283e28651487c427bec09e160c8ab4806bcbd94", "filename": "src/test/ui/feature-gates/feature-gate-underscore_const_names.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-underscore_const_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-underscore_const_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-underscore_const_names.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "previous_filename": "src/test/ui/feature-gate-underscore_const_names.rs"}, {"sha": "ab90ef8f11f7cf22bcc5ef847013210b9ff5bb59", "filename": "src/test/ui/feature-gates/feature-gate-underscore_const_names.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-underscore_const_names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-underscore_const_names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-underscore_const_names.stderr?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "previous_filename": "src/test/ui/feature-gate-underscore_const_names.stderr"}, {"sha": "7f1f22fa38fb1f1254256a16b824c17c70fbbf31", "filename": "src/test/ui/feature-gates/feature-gate-unsized_locals.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_locals.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "previous_filename": "src/test/ui/feature-gate-unsized_locals.rs"}, {"sha": "a0440a373d2fc939e8696a1f83a0ac5bf1a74241", "filename": "src/test/ui/feature-gates/feature-gate-unsized_locals.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_locals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_locals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsized_locals.stderr?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "previous_filename": "src/test/ui/feature-gate-unsized_locals.stderr"}, {"sha": "bd222b7fe980ed64acc1101c8ac92c62a8d6ac46", "filename": "src/test/ui/issues/issue-56202.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Fissues%2Fissue-56202.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Fissues%2Fissue-56202.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56202.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -0,0 +1,17 @@\n+// compile-pass\n+\n+trait FooTrait {}\n+\n+trait BarTrait {\n+    fn foo<T: FooTrait>(_: T) -> Self;\n+}\n+\n+struct FooStruct(u32);\n+\n+impl BarTrait for FooStruct {\n+    fn foo<T: FooTrait>(_: T) -> Self {\n+        Self(u32::default())\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b50fc68bed6be587c24f1d525165931dfd543fb6", "filename": "src/test/ui/keyword/keyword-self-as-identifier.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-self-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-self-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-self-as-identifier.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -10,5 +10,4 @@\n \n fn main() {\n     let Self = 22; //~ ERROR cannot find unit struct/variant or constant `Self` in this scope\n-        //~^ ERROR `Self` struct constructors are unstable (see issue #51994)\n }"}, {"sha": "c47f4aeabefd81f2cdcf53cceaef157cc3fdbefe", "filename": "src/test/ui/keyword/keyword-self-as-identifier.stderr", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-self-as-identifier.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-self-as-identifier.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-self-as-identifier.stderr?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -4,15 +4,6 @@ error[E0531]: cannot find unit struct/variant or constant `Self` in this scope\n LL |     let Self = 22; //~ ERROR cannot find unit struct/variant or constant `Self` in this scope\n    |         ^^^^ not found in this scope\n \n-error[E0658]: `Self` struct constructors are unstable (see issue #51994)\n-  --> $DIR/keyword-self-as-identifier.rs:12:9\n-   |\n-LL |     let Self = 22; //~ ERROR cannot find unit struct/variant or constant `Self` in this scope\n-   |         ^^^^\n-   |\n-   = help: add #![feature(self_struct_ctor)] to the crate attributes to enable\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors occurred: E0531, E0658.\n-For more information about an error, try `rustc --explain E0531`.\n+For more information about this error, try `rustc --explain E0531`."}, {"sha": "8331ae0b307d95ebd222685fdf2147be7be246c8", "filename": "src/test/ui/self/self_type_keyword-2.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Fself%2Fself_type_keyword-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Fself%2Fself_type_keyword-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fself_type_keyword-2.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -13,14 +13,11 @@ use self::Self as Foo; //~ ERROR unresolved import `self::Self`\n pub fn main() {\n     let Self = 5;\n     //~^ ERROR cannot find unit struct/variant or constant `Self` in this scope\n-    //~^^ ERROR `Self` struct constructors are unstable (see issue #51994)\n \n     match 15 {\n         Self => (),\n         //~^ ERROR cannot find unit struct/variant or constant `Self` in this scope\n-        //~^^ ERROR `Self` struct constructors are unstable (see issue #51994)\n         Foo { x: Self } => (),\n         //~^ ERROR cannot find unit struct/variant or constant `Self` in this scope\n-        //~^^ ERROR `Self` struct constructors are unstable (see issue #51994)\n     }\n }"}, {"sha": "972e5bdddc6733493e530b2b1015c11bbac8336b", "filename": "src/test/ui/self/self_type_keyword-2.stderr", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Fself%2Fself_type_keyword-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftest%2Fui%2Fself%2Fself_type_keyword-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fself_type_keyword-2.stderr?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -11,42 +11,18 @@ LL |     let Self = 5;\n    |         ^^^^ not found in this scope\n \n error[E0531]: cannot find unit struct/variant or constant `Self` in this scope\n-  --> $DIR/self_type_keyword-2.rs:19:9\n+  --> $DIR/self_type_keyword-2.rs:18:9\n    |\n LL |         Self => (),\n    |         ^^^^ not found in this scope\n \n error[E0531]: cannot find unit struct/variant or constant `Self` in this scope\n-  --> $DIR/self_type_keyword-2.rs:22:18\n+  --> $DIR/self_type_keyword-2.rs:20:18\n    |\n LL |         Foo { x: Self } => (),\n    |                  ^^^^ not found in this scope\n \n-error[E0658]: `Self` struct constructors are unstable (see issue #51994)\n-  --> $DIR/self_type_keyword-2.rs:14:9\n-   |\n-LL |     let Self = 5;\n-   |         ^^^^\n-   |\n-   = help: add #![feature(self_struct_ctor)] to the crate attributes to enable\n-\n-error[E0658]: `Self` struct constructors are unstable (see issue #51994)\n-  --> $DIR/self_type_keyword-2.rs:19:9\n-   |\n-LL |         Self => (),\n-   |         ^^^^\n-   |\n-   = help: add #![feature(self_struct_ctor)] to the crate attributes to enable\n-\n-error[E0658]: `Self` struct constructors are unstable (see issue #51994)\n-  --> $DIR/self_type_keyword-2.rs:22:18\n-   |\n-LL |         Foo { x: Self } => (),\n-   |                  ^^^^\n-   |\n-   = help: add #![feature(self_struct_ctor)] to the crate attributes to enable\n-\n-error: aborting due to 7 previous errors\n+error: aborting due to 4 previous errors\n \n-Some errors occurred: E0432, E0531, E0658.\n+Some errors occurred: E0432, E0531.\n For more information about an error, try `rustc --explain E0432`."}, {"sha": "11c83819eaa93527b6152d0fd7c061195c5c1dfa", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09466ceb1374bd0ff1c490bfd50133b8ca67558/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=d09466ceb1374bd0ff1c490bfd50133b8ca67558", "patch": "@@ -24,12 +24,12 @@\n //! A few whitelisted exceptions are allowed as there's known bugs in rustdoc,\n //! but this should catch the majority of \"broken link\" cases.\n \n+use std::collections::hash_map::Entry;\n+use std::collections::{HashMap, HashSet};\n use std::env;\n-use std::fs::File;\n-use std::io::prelude::*;\n+use std::fs;\n use std::path::{Path, PathBuf, Component};\n-use std::collections::{HashMap, HashSet};\n-use std::collections::hash_map::Entry;\n+use std::rc::Rc;\n \n use Redirect::*;\n \n@@ -63,7 +63,7 @@ enum Redirect {\n }\n \n struct FileEntry {\n-    source: String,\n+    source: Rc<String>,\n     ids: HashSet<String>,\n }\n \n@@ -113,7 +113,7 @@ fn walk(cache: &mut Cache, root: &Path, dir: &Path, errors: &mut bool) {\n                 let entry = cache.get_mut(&pretty_path).unwrap();\n                 // we don't need the source anymore,\n                 // so drop to reduce memory-usage\n-                entry.source = String::new();\n+                entry.source = Rc::new(String::new());\n             }\n         }\n     }\n@@ -287,24 +287,24 @@ fn load_file(cache: &mut Cache,\n              root: &Path,\n              file: &Path,\n              redirect: Redirect)\n-             -> Result<(PathBuf, String), LoadError> {\n-    let mut contents = String::new();\n+             -> Result<(PathBuf, Rc<String>), LoadError> {\n     let pretty_file = PathBuf::from(file.strip_prefix(root).unwrap_or(&file));\n \n-    let maybe_redirect = match cache.entry(pretty_file.clone()) {\n+    let (maybe_redirect, contents) = match cache.entry(pretty_file.clone()) {\n         Entry::Occupied(entry) => {\n-            contents = entry.get().source.clone();\n-            None\n+            (None, entry.get().source.clone())\n         }\n         Entry::Vacant(entry) => {\n-            let mut fp = File::open(file).map_err(|err| {\n-                if let FromRedirect(true) = redirect {\n-                    LoadError::BrokenRedirect(file.to_path_buf(), err)\n-                } else {\n-                    LoadError::IOError(err)\n+            let contents = match fs::read_to_string(file) {\n+                Ok(s) => Rc::new(s),\n+                Err(err) => {\n+                    return Err(if let FromRedirect(true) = redirect {\n+                        LoadError::BrokenRedirect(file.to_path_buf(), err)\n+                    } else {\n+                        LoadError::IOError(err)\n+                    })\n                 }\n-            })?;\n-            fp.read_to_string(&mut contents).map_err(|err| LoadError::IOError(err))?;\n+            };\n \n             let maybe = maybe_redirect(&contents);\n             if maybe.is_some() {\n@@ -317,7 +317,7 @@ fn load_file(cache: &mut Cache,\n                     ids: HashSet::new(),\n                 });\n             }\n-            maybe\n+            (maybe, contents)\n         }\n     };\n     match maybe_redirect.map(|url| file.parent().unwrap().join(url)) {"}]}