{"sha": "abf0ec83833095196627f2f292f44976594304ce", "node_id": "C_kwDOAAsO6NoAKGFiZjBlYzgzODMzMDk1MTk2NjI3ZjJmMjkyZjQ0OTc2NTk0MzA0Y2U", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-29T07:27:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-29T07:27:14Z"}, "message": "Auto merge of #95257 - compiler-errors:fn-borrow, r=lcnr\n\nAdd suggestion to borrow `Fn` and `FnMut` params/opaque/closures instead of move\n\nI think that Closure/ParamTy/Opaque are all \"opaque\" enough that it's meaningful to suggest borrowing them instead of moving them at their usage sites when we see a move error. See the attached issue for example.\n\nIs this suggestion too general? I could perhaps use the move site information to limit this to places like fn calls, but I don't know enough about mir borrowck to know if that's an easy change.\n\nFixes #90828", "tree": {"sha": "0ed806ebbf8b461faecfaedb308ccb12dd400faa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ed806ebbf8b461faecfaedb308ccb12dd400faa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abf0ec83833095196627f2f292f44976594304ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abf0ec83833095196627f2f292f44976594304ce", "html_url": "https://github.com/rust-lang/rust/commit/abf0ec83833095196627f2f292f44976594304ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abf0ec83833095196627f2f292f44976594304ce/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14328e654a92ca4c62f0d7d407b6757a47c541fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/14328e654a92ca4c62f0d7d407b6757a47c541fb", "html_url": "https://github.com/rust-lang/rust/commit/14328e654a92ca4c62f0d7d407b6757a47c541fb"}, {"sha": "ac95e8018655fcdc2a0429789cc7aa3770208c7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac95e8018655fcdc2a0429789cc7aa3770208c7a", "html_url": "https://github.com/rust-lang/rust/commit/ac95e8018655fcdc2a0429789cc7aa3770208c7a"}], "stats": {"total": 343, "additions": 271, "deletions": 72}, "files": [{"sha": "883f711b201a97c837faab91470a18378fb08656", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 155, "deletions": 69, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/abf0ec83833095196627f2f292f44976594304ce/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0ec83833095196627f2f292f44976594304ce/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=abf0ec83833095196627f2f292f44976594304ce", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::mir::{\n     FakeReadCause, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{self, suggest_constraining_type_params, PredicateKind, Ty};\n+use rustc_middle::ty::{self, subst::Subst, suggest_constraining_type_params, PredicateKind, Ty};\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, MultiSpan, Span};\n@@ -151,6 +151,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         .args_or_use()\n                 })\n                 .collect::<Vec<Span>>();\n+\n             let reinits = maybe_reinitialized_locations.len();\n             if reinits == 1 {\n                 err.span_label(reinit_spans[0], \"this reinitialization might get skipped\");\n@@ -276,76 +277,23 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n \n-            if needs_note {\n-                let opt_name =\n-                    self.describe_place_with_options(place.as_ref(), IncludingDowncast(true));\n-                let note_msg = match opt_name {\n-                    Some(ref name) => format!(\"`{}`\", name),\n-                    None => \"value\".to_owned(),\n-                };\n-\n-                // Try to find predicates on *generic params* that would allow copying `ty`\n-                let tcx = self.infcx.tcx;\n-                let generics = tcx.generics_of(self.mir_def_id());\n-                if let Some(hir_generics) = tcx\n-                    .typeck_root_def_id(self.mir_def_id().to_def_id())\n-                    .as_local()\n-                    .and_then(|def_id| tcx.hir().get_generics(def_id))\n-                {\n-                    let predicates: Result<Vec<_>, _> = tcx.infer_ctxt().enter(|infcx| {\n-                        let mut fulfill_cx =\n-                            <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n-\n-                        let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n-                        let cause = ObligationCause::new(\n-                            span,\n-                            self.mir_hir_id(),\n-                            rustc_infer::traits::ObligationCauseCode::MiscObligation,\n-                        );\n-                        fulfill_cx.register_bound(\n-                            &infcx,\n-                            self.param_env,\n-                            // Erase any region vids from the type, which may not be resolved\n-                            infcx.tcx.erase_regions(ty),\n-                            copy_did,\n-                            cause,\n-                        );\n-                        // Select all, including ambiguous predicates\n-                        let errors = fulfill_cx.select_all_or_error(&infcx);\n-\n-                        // Only emit suggestion if all required predicates are on generic\n-                        errors\n-                            .into_iter()\n-                            .map(|err| match err.obligation.predicate.kind().skip_binder() {\n-                                PredicateKind::Trait(predicate) => {\n-                                    match predicate.self_ty().kind() {\n-                                        ty::Param(param_ty) => Ok((\n-                                            generics.type_param(param_ty, tcx),\n-                                            predicate.trait_ref.print_only_trait_path().to_string(),\n-                                        )),\n-                                        _ => Err(()),\n-                                    }\n-                                }\n-                                _ => Err(()),\n-                            })\n-                            .collect()\n-                    });\n-\n-                    if let Ok(predicates) = predicates {\n-                        suggest_constraining_type_params(\n-                            tcx,\n-                            hir_generics,\n-                            &mut err,\n-                            predicates.iter().map(|(param, constraint)| {\n-                                (param.name.as_str(), &**constraint, None)\n-                            }),\n-                        );\n-                    }\n-                }\n+            let opt_name =\n+                self.describe_place_with_options(place.as_ref(), IncludingDowncast(true));\n+            let note_msg = match opt_name {\n+                Some(ref name) => format!(\"`{}`\", name),\n+                None => \"value\".to_owned(),\n+            };\n+            if self.suggest_borrow_fn_like(&mut err, ty, &move_site_vec, &note_msg) {\n+                // Suppress the next suggestion since we don't want to put more bounds onto\n+                // something that already has `Fn`-like bounds (or is a closure), so we can't\n+                // restrict anyways.\n+            } else {\n+                self.suggest_adding_copy_bounds(&mut err, ty, span);\n+            }\n \n+            if needs_note {\n                 let span = if let Some(local) = place.as_local() {\n-                    let decl = &self.body.local_decls[local];\n-                    Some(decl.source_info.span)\n+                    Some(self.body.local_decls[local].source_info.span)\n                 } else {\n                     None\n                 };\n@@ -373,6 +321,144 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    fn suggest_borrow_fn_like(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        ty: Ty<'tcx>,\n+        move_sites: &[MoveSite],\n+        value_name: &str,\n+    ) -> bool {\n+        let tcx = self.infcx.tcx;\n+\n+        // Find out if the predicates show that the type is a Fn or FnMut\n+        let find_fn_kind_from_did = |predicates: &[(ty::Predicate<'tcx>, Span)], substs| {\n+            predicates.iter().find_map(|(pred, _)| {\n+                let pred = if let Some(substs) = substs {\n+                    pred.subst(tcx, substs).kind().skip_binder()\n+                } else {\n+                    pred.kind().skip_binder()\n+                };\n+                if let ty::PredicateKind::Trait(pred) = pred && pred.self_ty() == ty {\n+                    if Some(pred.def_id()) == tcx.lang_items().fn_trait() {\n+                        return Some(hir::Mutability::Not);\n+                    } else if Some(pred.def_id()) == tcx.lang_items().fn_mut_trait() {\n+                        return Some(hir::Mutability::Mut);\n+                    }\n+                }\n+                None\n+            })\n+        };\n+\n+        // If the type is opaque/param/closure, and it is Fn or FnMut, let's suggest (mutably)\n+        // borrowing the type, since `&mut F: FnMut` iff `F: FnMut` and similarly for `Fn`.\n+        // These types seem reasonably opaque enough that they could be substituted with their\n+        // borrowed variants in a function body when we see a move error.\n+        let borrow_level = match ty.kind() {\n+            ty::Param(_) => find_fn_kind_from_did(\n+                tcx.explicit_predicates_of(self.mir_def_id().to_def_id()).predicates,\n+                None,\n+            ),\n+            ty::Opaque(did, substs) => {\n+                find_fn_kind_from_did(tcx.explicit_item_bounds(*did), Some(*substs))\n+            }\n+            ty::Closure(_, substs) => match substs.as_closure().kind() {\n+                ty::ClosureKind::Fn => Some(hir::Mutability::Not),\n+                ty::ClosureKind::FnMut => Some(hir::Mutability::Mut),\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+\n+        let Some(borrow_level) = borrow_level else { return false; };\n+        let sugg = move_sites\n+            .iter()\n+            .map(|move_site| {\n+                let move_out = self.move_data.moves[(*move_site).moi];\n+                let moved_place = &self.move_data.move_paths[move_out.path].place;\n+                let move_spans = self.move_spans(moved_place.as_ref(), move_out.source);\n+                let move_span = move_spans.args_or_use();\n+                let suggestion = if borrow_level == hir::Mutability::Mut {\n+                    \"&mut \".to_string()\n+                } else {\n+                    \"&\".to_string()\n+                };\n+                (move_span.shrink_to_lo(), suggestion)\n+            })\n+            .collect();\n+        err.multipart_suggestion_verbose(\n+            &format!(\n+                \"consider {}borrowing {value_name}\",\n+                if borrow_level == hir::Mutability::Mut { \"mutably \" } else { \"\" }\n+            ),\n+            sugg,\n+            Applicability::MaybeIncorrect,\n+        );\n+        true\n+    }\n+\n+    fn suggest_adding_copy_bounds(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) {\n+        let tcx = self.infcx.tcx;\n+        let generics = tcx.generics_of(self.mir_def_id());\n+\n+        let Some(hir_generics) = tcx\n+            .typeck_root_def_id(self.mir_def_id().to_def_id())\n+            .as_local()\n+            .and_then(|def_id| tcx.hir().get_generics(def_id))\n+        else { return; };\n+        // Try to find predicates on *generic params* that would allow copying `ty`\n+        let predicates: Result<Vec<_>, _> = tcx.infer_ctxt().enter(|infcx| {\n+            let mut fulfill_cx = <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n+\n+            let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n+            let cause = ObligationCause::new(\n+                span,\n+                self.mir_hir_id(),\n+                rustc_infer::traits::ObligationCauseCode::MiscObligation,\n+            );\n+            fulfill_cx.register_bound(\n+                &infcx,\n+                self.param_env,\n+                // Erase any region vids from the type, which may not be resolved\n+                infcx.tcx.erase_regions(ty),\n+                copy_did,\n+                cause,\n+            );\n+            // Select all, including ambiguous predicates\n+            let errors = fulfill_cx.select_all_or_error(&infcx);\n+\n+            // Only emit suggestion if all required predicates are on generic\n+            errors\n+                .into_iter()\n+                .map(|err| match err.obligation.predicate.kind().skip_binder() {\n+                    PredicateKind::Trait(predicate) => match predicate.self_ty().kind() {\n+                        ty::Param(param_ty) => Ok((\n+                            generics.type_param(param_ty, tcx),\n+                            predicate.trait_ref.print_only_trait_path().to_string(),\n+                        )),\n+                        _ => Err(()),\n+                    },\n+                    _ => Err(()),\n+                })\n+                .collect()\n+        });\n+\n+        if let Ok(predicates) = predicates {\n+            suggest_constraining_type_params(\n+                tcx,\n+                hir_generics,\n+                err,\n+                predicates\n+                    .iter()\n+                    .map(|(param, constraint)| (param.name.as_str(), &**constraint, None)),\n+            );\n+        }\n+    }\n+\n     pub(crate) fn report_move_out_while_borrowed(\n         &mut self,\n         location: Location,"}, {"sha": "515e0cf01429d51563467852f6d1d08d92e07958", "filename": "src/test/ui/chalkify/closure.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fchalkify%2Fclosure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fchalkify%2Fclosure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fclosure.stderr?ref=abf0ec83833095196627f2f292f44976594304ce", "patch": "@@ -12,6 +12,10 @@ note: closure cannot be moved more than once as it is not `Copy` due to moving t\n    |\n LL |         a = 1;\n    |         ^\n+help: consider mutably borrowing `b`\n+   |\n+LL |     let mut c = &mut b;\n+   |                 ++++\n \n error: aborting due to previous error\n "}, {"sha": "83d282aadb9153dce4f0dd7cd542f463e54772f4", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-multi-variant-diagnostics.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-multi-variant-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-multi-variant-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-multi-variant-diagnostics.stderr?ref=abf0ec83833095196627f2f292f44976594304ce", "patch": "@@ -11,6 +11,10 @@ note: closure cannot be moved more than once as it is not `Copy` due to moving t\n    |\n LL |         if let MultiVariant::Point(ref mut x, _) = point {\n    |                                                    ^^^^^\n+help: consider mutably borrowing `c`\n+   |\n+LL |     let a = &mut c;\n+   |             ++++\n \n error: aborting due to previous error\n "}, {"sha": "46323b75210cb417a70ee620f364f96e0d6b5086", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-single-variant-diagnostics.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr?ref=abf0ec83833095196627f2f292f44976594304ce", "patch": "@@ -11,6 +11,10 @@ note: closure cannot be moved more than once as it is not `Copy` due to moving t\n    |\n LL |         let SingleVariant::Point(ref mut x, _) = point;\n    |                                                  ^^^^^\n+help: consider mutably borrowing `c`\n+   |\n+LL |     let b = &mut c;\n+   |             ++++\n \n error: aborting due to previous error\n "}, {"sha": "25029cc7bd8b899c93341d0dda08c5203486652c", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-struct-diagnostics.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-struct-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-struct-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-struct-diagnostics.stderr?ref=abf0ec83833095196627f2f292f44976594304ce", "patch": "@@ -11,6 +11,10 @@ note: closure cannot be moved more than once as it is not `Copy` due to moving t\n    |\n LL |         x.y.a += 1;\n    |         ^^^^^\n+help: consider mutably borrowing `hello`\n+   |\n+LL |     let b = &mut hello;\n+   |             ++++\n \n error: aborting due to previous error\n "}, {"sha": "06ef7baf9c068b84f62ab7cb042a2e8bc1dc0dad", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-tuple-diagnostics-1.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-tuple-diagnostics-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-tuple-diagnostics-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-tuple-diagnostics-1.stderr?ref=abf0ec83833095196627f2f292f44976594304ce", "patch": "@@ -11,6 +11,10 @@ note: closure cannot be moved more than once as it is not `Copy` due to moving t\n    |\n LL |         x.0 += 1;\n    |         ^^^\n+help: consider mutably borrowing `hello`\n+   |\n+LL |     let b = &mut hello;\n+   |             ++++\n \n error: aborting due to previous error\n "}, {"sha": "51771ced7f22f527fb0a18ac1187e5fba32d4fb7", "filename": "src/test/ui/moves/borrow-closures-instead-of-move.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fmoves%2Fborrow-closures-instead-of-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fmoves%2Fborrow-closures-instead-of-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fborrow-closures-instead-of-move.rs?ref=abf0ec83833095196627f2f292f44976594304ce", "patch": "@@ -0,0 +1,36 @@\n+fn takes_fn(f: impl Fn()) {\n+    loop {\n+        takes_fnonce(f);\n+        //~^ ERROR use of moved value\n+        //~| HELP consider borrowing\n+    }\n+}\n+\n+fn takes_fn_mut(m: impl FnMut()) {\n+    if maybe() {\n+        takes_fnonce(m);\n+        //~^ HELP consider mutably borrowing\n+    }\n+    takes_fnonce(m);\n+    //~^ ERROR use of moved value\n+}\n+\n+fn has_closure() {\n+    let mut x = 0;\n+    let mut closure = || {\n+        x += 1;\n+    };\n+    takes_fnonce(closure);\n+    //~^ HELP consider mutably borrowing\n+    closure();\n+    //~^ ERROR borrow of moved value\n+}\n+\n+fn maybe() -> bool {\n+    false\n+}\n+\n+// Could also be Fn[Mut], here it doesn't matter\n+fn takes_fnonce(_: impl FnOnce()) {}\n+\n+fn main() {}"}, {"sha": "3146b6959001eb7c90793711f26044e01a63166e", "filename": "src/test/ui/moves/borrow-closures-instead-of-move.stderr", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fmoves%2Fborrow-closures-instead-of-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fmoves%2Fborrow-closures-instead-of-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fborrow-closures-instead-of-move.stderr?ref=abf0ec83833095196627f2f292f44976594304ce", "patch": "@@ -0,0 +1,53 @@\n+error[E0382]: use of moved value: `f`\n+  --> $DIR/borrow-closures-instead-of-move.rs:3:22\n+   |\n+LL | fn takes_fn(f: impl Fn()) {\n+   |             - move occurs because `f` has type `impl Fn()`, which does not implement the `Copy` trait\n+LL |     loop {\n+LL |         takes_fnonce(f);\n+   |                      ^ value moved here, in previous iteration of loop\n+   |\n+help: consider borrowing `f`\n+   |\n+LL |         takes_fnonce(&f);\n+   |                      +\n+\n+error[E0382]: use of moved value: `m`\n+  --> $DIR/borrow-closures-instead-of-move.rs:14:18\n+   |\n+LL | fn takes_fn_mut(m: impl FnMut()) {\n+   |                 - move occurs because `m` has type `impl FnMut()`, which does not implement the `Copy` trait\n+LL |     if maybe() {\n+LL |         takes_fnonce(m);\n+   |                      - value moved here\n+...\n+LL |     takes_fnonce(m);\n+   |                  ^ value used here after move\n+   |\n+help: consider mutably borrowing `m`\n+   |\n+LL |         takes_fnonce(&mut m);\n+   |                      ++++\n+\n+error[E0382]: borrow of moved value: `closure`\n+  --> $DIR/borrow-closures-instead-of-move.rs:25:5\n+   |\n+LL |     takes_fnonce(closure);\n+   |                  ------- value moved here\n+LL |\n+LL |     closure();\n+   |     ^^^^^^^ value borrowed here after move\n+   |\n+note: closure cannot be moved more than once as it is not `Copy` due to moving the variable `x` out of its environment\n+  --> $DIR/borrow-closures-instead-of-move.rs:21:9\n+   |\n+LL |         x += 1;\n+   |         ^\n+help: consider mutably borrowing `closure`\n+   |\n+LL |     takes_fnonce(&mut closure);\n+   |                  ++++\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "4759b45892cc40d3a614ab0b2c61532efba1073e", "filename": "src/test/ui/moves/moves-based-on-type-no-recursive-stack-closure.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.stderr?ref=abf0ec83833095196627f2f292f44976594304ce", "patch": "@@ -17,10 +17,10 @@ LL |     let mut r = R {c: Box::new(f)};\n LL |     f(&mut r, false)\n    |     ^ value borrowed here after move\n    |\n-help: consider further restricting this bound\n+help: consider mutably borrowing `f`\n    |\n-LL | fn conspirator<F>(mut f: F) where F: FnMut(&mut R, bool) + Copy {\n-   |                                                          ++++++\n+LL |     let mut r = R {c: Box::new(&mut f)};\n+   |                                ++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "93e011ccec4fab83aa1490311dbd3c4c02915dbd", "filename": "src/test/ui/not-copy-closure.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fnot-copy-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abf0ec83833095196627f2f292f44976594304ce/src%2Ftest%2Fui%2Fnot-copy-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnot-copy-closure.stderr?ref=abf0ec83833095196627f2f292f44976594304ce", "patch": "@@ -11,6 +11,10 @@ note: closure cannot be moved more than once as it is not `Copy` due to moving t\n    |\n LL |         a += 1;\n    |         ^\n+help: consider mutably borrowing `hello`\n+   |\n+LL |     let b = &mut hello;\n+   |             ++++\n \n error: aborting due to previous error\n "}]}