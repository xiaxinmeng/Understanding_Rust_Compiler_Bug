{"sha": "b22db3fca47580fff95bbb029f6199dae938afcf", "node_id": "C_kwDOAAsO6NoAKGIyMmRiM2ZjYTQ3NTgwZmZmOTViYmIwMjlmNjE5OWRhZTkzOGFmY2Y", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-22T21:44:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-22T21:44:42Z"}, "message": "Rollup merge of #109423 - fmease:iat-selection-erase-regions-in-self-ty, r=compiler-errors\n\nUse region-erased self type during IAT selection\n\nSplit off from #109410 as discussed.\nFixes #109299.\n\nRe UI test: I use a reproducer of #109299 that contains a name resolution error instead of reproducer [`regionck-2.rs`](https://github.com/rust-lang/rust/blob/fc7ed4af165c27ab5914b93251194f826920cc65/tests/ui/associated-inherent-types/regionck-2.rs) (as found in the `AliasKind::Inherent` PR) since it would (incorrectly) pass typeck in this PR due to the lack of regionck and I'd rather not make *that* a regression test (with or without `known-bug`).\n\n``@rustbot`` label F-inherent_associated_types\n\nr? ``@compiler-errors``", "tree": {"sha": "858154970cd485987719d2a543919006268c7fba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/858154970cd485987719d2a543919006268c7fba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b22db3fca47580fff95bbb029f6199dae938afcf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkG3bKCRBK7hj4Ov3rIwAA3WwIAB0zA1yf+nLOMb/KOQwV4REA\nnQYhAo73qjlBZFbdjquG+TQeawmygSKyN1omWsilOi4j1mVepcBJcBnBc83NS2lb\nMRUOGFBNfqDdQgFRx3d8uPUgLJ7bkq4htevcaasOCRw+EddU3k2wasOpeDlJ22WG\n3FqUPP96aEzBeZwi6nkWxYzmM6gKaKxjVzocmjlKr1S16KTjJNPqMJbhbEAJp+SO\n4Qw5jpxskQ5tdr5CYCH7XtOpfK3Pt76ykGDmNvgBH7NeR9zMmIbZQGdHycva2amk\nbiel/1MLC9ut/HsBSXiGcQy4ONxvt/dwn9ENSKLqg5Xp4wSz1he4kuRSXxA+0M0=\n=kpba\n-----END PGP SIGNATURE-----\n", "payload": "tree 858154970cd485987719d2a543919006268c7fba\nparent 2ee07a19b777149b6723011b361a6324c593438b\nparent 293f21c876278df7943eea889dacd977155a2f62\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1679521482 +0100\ncommitter GitHub <noreply@github.com> 1679521482 +0100\n\nRollup merge of #109423 - fmease:iat-selection-erase-regions-in-self-ty, r=compiler-errors\n\nUse region-erased self type during IAT selection\n\nSplit off from #109410 as discussed.\nFixes #109299.\n\nRe UI test: I use a reproducer of #109299 that contains a name resolution error instead of reproducer [`regionck-2.rs`](https://github.com/rust-lang/rust/blob/fc7ed4af165c27ab5914b93251194f826920cc65/tests/ui/associated-inherent-types/regionck-2.rs) (as found in the `AliasKind::Inherent` PR) since it would (incorrectly) pass typeck in this PR due to the lack of regionck and I'd rather not make *that* a regression test (with or without `known-bug`).\n\n``@rustbot`` label F-inherent_associated_types\n\nr? ``@compiler-errors``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b22db3fca47580fff95bbb029f6199dae938afcf", "html_url": "https://github.com/rust-lang/rust/commit/b22db3fca47580fff95bbb029f6199dae938afcf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b22db3fca47580fff95bbb029f6199dae938afcf/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ee07a19b777149b6723011b361a6324c593438b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ee07a19b777149b6723011b361a6324c593438b", "html_url": "https://github.com/rust-lang/rust/commit/2ee07a19b777149b6723011b361a6324c593438b"}, {"sha": "293f21c876278df7943eea889dacd977155a2f62", "url": "https://api.github.com/repos/rust-lang/rust/commits/293f21c876278df7943eea889dacd977155a2f62", "html_url": "https://github.com/rust-lang/rust/commit/293f21c876278df7943eea889dacd977155a2f62"}], "stats": {"total": 132, "additions": 101, "deletions": 31}, "files": [{"sha": "894995c1bfca7c37b9257b7fda2689e0da05fa37", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 51, "deletions": 31, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b22db3fca47580fff95bbb029f6199dae938afcf/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22db3fca47580fff95bbb029f6199dae938afcf/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=b22db3fca47580fff95bbb029f6199dae938afcf", "patch": "@@ -31,6 +31,7 @@ use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::middle::stability::AllowUnstable;\n+use rustc_middle::ty::fold::FnMutDelegate;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::DynKind;\n use rustc_middle::ty::GenericParamDefKind;\n@@ -2225,47 +2226,66 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let param_env = tcx.param_env(block.owner.to_def_id());\n         let cause = ObligationCause::misc(span, block.owner.def_id);\n+\n         let mut fulfillment_errors = Vec::new();\n-        let mut applicable_candidates: Vec<_> = candidates\n-            .iter()\n-            .filter_map(|&(impl_, (assoc_item, def_scope))| {\n-                infcx.probe(|_| {\n-                    let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n+        let mut applicable_candidates: Vec<_> = infcx.probe(|_| {\n+            let universe = infcx.create_next_universe();\n+\n+            // Regions are not considered during selection.\n+            let self_ty = tcx.replace_escaping_bound_vars_uncached(\n+                self_ty,\n+                FnMutDelegate {\n+                    regions: &mut |_| tcx.lifetimes.re_erased,\n+                    types: &mut |bv| {\n+                        tcx.mk_placeholder(ty::PlaceholderType { universe, name: bv.kind })\n+                    },\n+                    consts: &mut |bv, ty| {\n+                        tcx.mk_const(ty::PlaceholderConst { universe, name: bv }, ty)\n+                    },\n+                },\n+            );\n \n-                    let impl_ty = tcx.type_of(impl_);\n-                    let impl_substs = infcx.fresh_item_substs(impl_);\n-                    let impl_ty = impl_ty.subst(tcx, impl_substs);\n-                    let impl_ty = ocx.normalize(&cause, param_env, impl_ty);\n+            candidates\n+                .iter()\n+                .filter_map(|&(impl_, (assoc_item, def_scope))| {\n+                    infcx.probe(|_| {\n+                        let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n \n-                    // Check that the Self-types can be related.\n-                    // FIXME(fmease): Should we use `eq` here?\n-                    ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).ok()?;\n+                        let impl_ty = tcx.type_of(impl_);\n+                        let impl_substs = infcx.fresh_item_substs(impl_);\n+                        let impl_ty = impl_ty.subst(tcx, impl_substs);\n+                        let impl_ty = ocx.normalize(&cause, param_env, impl_ty);\n \n-                    // Check whether the impl imposes obligations we have to worry about.\n-                    let impl_bounds = tcx.predicates_of(impl_);\n-                    let impl_bounds = impl_bounds.instantiate(tcx, impl_substs);\n+                        // Check that the Self-types can be related.\n+                        // FIXME(fmease): Should we use `eq` here?\n+                        ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).ok()?;\n \n-                    let impl_bounds = ocx.normalize(&cause, param_env, impl_bounds);\n+                        // Check whether the impl imposes obligations we have to worry about.\n+                        let impl_bounds = tcx.predicates_of(impl_);\n+                        let impl_bounds = impl_bounds.instantiate(tcx, impl_substs);\n \n-                    let impl_obligations = traits::predicates_for_generics(\n-                        |_, _| cause.clone(),\n-                        param_env,\n-                        impl_bounds,\n-                    );\n+                        let impl_bounds = ocx.normalize(&cause, param_env, impl_bounds);\n \n-                    ocx.register_obligations(impl_obligations);\n+                        let impl_obligations = traits::predicates_for_generics(\n+                            |_, _| cause.clone(),\n+                            param_env,\n+                            impl_bounds,\n+                        );\n \n-                    let mut errors = ocx.select_where_possible();\n-                    if !errors.is_empty() {\n-                        fulfillment_errors.append(&mut errors);\n-                        return None;\n-                    }\n+                        ocx.register_obligations(impl_obligations);\n+\n+                        let mut errors = ocx.select_where_possible();\n+                        if !errors.is_empty() {\n+                            fulfillment_errors.append(&mut errors);\n+                            return None;\n+                        }\n \n-                    // FIXME(fmease): Unsolved vars can escape this InferCtxt snapshot.\n-                    Some((assoc_item, def_scope, infcx.resolve_vars_if_possible(impl_substs)))\n+                        // FIXME(fmease): Unsolved vars can escape this InferCtxt snapshot.\n+                        Some((assoc_item, def_scope, infcx.resolve_vars_if_possible(impl_substs)))\n+                    })\n                 })\n-            })\n-            .collect();\n+                .collect()\n+        });\n \n         if applicable_candidates.len() > 1 {\n             return Err(self.complain_about_ambiguous_inherent_assoc_type("}, {"sha": "6f95273116b78af569216574bb78c975cede43e2", "filename": "tests/ui/associated-inherent-types/issue-109299-1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b22db3fca47580fff95bbb029f6199dae938afcf/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22db3fca47580fff95bbb029f6199dae938afcf/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.rs?ref=b22db3fca47580fff95bbb029f6199dae938afcf", "patch": "@@ -0,0 +1,12 @@\n+#![feature(inherent_associated_types, non_lifetime_binders, type_alias_impl_trait)]\n+#![allow(incomplete_features)]\n+\n+struct Lexer<T>(T);\n+\n+impl Lexer<i32> {\n+    type Cursor = ();\n+}\n+\n+type X = impl for<T> Fn() -> Lexer<T>::Cursor; //~ ERROR associated type `Cursor` not found for `Lexer<T>` in the current scope\n+\n+fn main() {}"}, {"sha": "dc59b56ee207dc1fec88cca04487dd9af07e481a", "filename": "tests/ui/associated-inherent-types/issue-109299-1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b22db3fca47580fff95bbb029f6199dae938afcf/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b22db3fca47580fff95bbb029f6199dae938afcf/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.stderr?ref=b22db3fca47580fff95bbb029f6199dae938afcf", "patch": "@@ -0,0 +1,15 @@\n+error[E0220]: associated type `Cursor` not found for `Lexer<T>` in the current scope\n+  --> $DIR/issue-109299-1.rs:10:40\n+   |\n+LL | struct Lexer<T>(T);\n+   | --------------- associated item `Cursor` not found for this struct\n+...\n+LL | type X = impl for<T> Fn() -> Lexer<T>::Cursor;\n+   |                                        ^^^^^^ associated item not found in `Lexer<T>`\n+   |\n+   = note: the associated type was found for\n+           - `Lexer<i32>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0220`."}, {"sha": "84e4f9e72527aa21025ab3b061ceb17b1a47afbd", "filename": "tests/ui/associated-inherent-types/issue-109299.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b22db3fca47580fff95bbb029f6199dae938afcf/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22db3fca47580fff95bbb029f6199dae938afcf/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.rs?ref=b22db3fca47580fff95bbb029f6199dae938afcf", "patch": "@@ -0,0 +1,12 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Lexer<'d>(&'d ());\n+\n+impl Lexer<'d> { //~ ERROR use of undeclared lifetime name `'d`\n+    type Cursor = ();\n+}\n+\n+fn test(_: Lexer::Cursor) {}\n+\n+fn main() {}"}, {"sha": "63f50732d3c50985b420dfa33b4686e6f88c97d5", "filename": "tests/ui/associated-inherent-types/issue-109299.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b22db3fca47580fff95bbb029f6199dae938afcf/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b22db3fca47580fff95bbb029f6199dae938afcf/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.stderr?ref=b22db3fca47580fff95bbb029f6199dae938afcf", "patch": "@@ -0,0 +1,11 @@\n+error[E0261]: use of undeclared lifetime name `'d`\n+  --> $DIR/issue-109299.rs:6:12\n+   |\n+LL | impl Lexer<'d> {\n+   |     -      ^^ undeclared lifetime\n+   |     |\n+   |     help: consider introducing lifetime `'d` here: `<'d>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0261`."}]}