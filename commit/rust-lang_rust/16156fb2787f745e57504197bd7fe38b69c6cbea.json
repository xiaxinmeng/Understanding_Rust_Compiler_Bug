{"sha": "16156fb2787f745e57504197bd7fe38b69c6cbea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MTU2ZmIyNzg3Zjc0NWU1NzUwNDE5N2JkN2ZlMzhiNjljNmNiZWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-30T11:44:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-30T11:44:36Z"}, "message": "Auto merge of #83674 - Dylan-DPC:rollup-bcuc1hl, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #83568 (update comment at MaybeUninit::uninit_array)\n - #83571 (Constantify some slice methods)\n - #83579 (Improve pointer arithmetic docs)\n - #83645 (Wrap non-pre code blocks)\n - #83656 (Add a regression test for issue-82865)\n - #83662 (Update books)\n - #83667 (Suggest box/pin/arc ing receiver on method calls)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8629975b2f2fb968c84444d7090f746f0a7a98e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8629975b2f2fb968c84444d7090f746f0a7a98e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16156fb2787f745e57504197bd7fe38b69c6cbea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16156fb2787f745e57504197bd7fe38b69c6cbea", "html_url": "https://github.com/rust-lang/rust/commit/16156fb2787f745e57504197bd7fe38b69c6cbea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16156fb2787f745e57504197bd7fe38b69c6cbea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "689e8470ffa7aeca17cfee428704a4d6c4148c11", "url": "https://api.github.com/repos/rust-lang/rust/commits/689e8470ffa7aeca17cfee428704a4d6c4148c11", "html_url": "https://github.com/rust-lang/rust/commit/689e8470ffa7aeca17cfee428704a4d6c4148c11"}, {"sha": "5b467787b625d83d5cf210e70d56487e53ce4255", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b467787b625d83d5cf210e70d56487e53ce4255", "html_url": "https://github.com/rust-lang/rust/commit/5b467787b625d83d5cf210e70d56487e53ce4255"}], "stats": {"total": 520, "additions": 287, "deletions": 233}, "files": [{"sha": "30d60514063d993b29f6c1de36075c9d8c288b89", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 16, "deletions": 57, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -6,7 +6,7 @@ use crate::astconv::AstConv as _;\n use crate::check::cast;\n use crate::check::coercion::CoerceMany;\n use crate::check::fatally_break_rust;\n-use crate::check::method::{probe, MethodError, SelfSource};\n+use crate::check::method::SelfSource;\n use crate::check::report_unexpected_variant_res;\n use crate::check::BreakableCtxt;\n use crate::check::Diverges;\n@@ -30,7 +30,6 @@ use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder,\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, QPath};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -461,7 +460,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.resolve_lang_item_path(lang_item, expr.span, expr.hir_id).1\n     }\n \n-    fn check_expr_path(&self, qpath: &hir::QPath<'_>, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n+    fn check_expr_path(\n+        &self,\n+        qpath: &'tcx hir::QPath<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id, expr.span);\n         let ty = match res {\n@@ -947,7 +950,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             Err(error) => {\n                 if segment.ident.name != kw::Empty {\n-                    self.report_extended_method_error(segment, span, args, rcvr_t, error);\n+                    if let Some(mut err) = self.report_method_error(\n+                        span,\n+                        rcvr_t,\n+                        segment.ident,\n+                        SelfSource::MethodCall(&args[0]),\n+                        error,\n+                        Some(args),\n+                    ) {\n+                        err.emit();\n+                    }\n                 }\n                 Err(())\n             }\n@@ -964,59 +976,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n-    fn report_extended_method_error(\n-        &self,\n-        segment: &hir::PathSegment<'_>,\n-        span: Span,\n-        args: &'tcx [hir::Expr<'tcx>],\n-        rcvr_t: Ty<'tcx>,\n-        error: MethodError<'tcx>,\n-    ) {\n-        let rcvr = &args[0];\n-        let try_alt_rcvr = |err: &mut DiagnosticBuilder<'_>, new_rcvr_t| {\n-            if let Some(new_rcvr_t) = new_rcvr_t {\n-                if let Ok(pick) = self.lookup_probe(\n-                    span,\n-                    segment.ident,\n-                    new_rcvr_t,\n-                    rcvr,\n-                    probe::ProbeScope::AllTraits,\n-                ) {\n-                    debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n-                    // Make sure the method is defined for the *actual* receiver:\n-                    // we don't want to treat `Box<Self>` as a receiver if\n-                    // it only works because of an autoderef to `&self`\n-                    if pick.autoderefs == 0 {\n-                        err.span_label(\n-                            pick.item.ident.span,\n-                            &format!(\"the method is available for `{}` here\", new_rcvr_t),\n-                        );\n-                    }\n-                }\n-            }\n-        };\n-\n-        if let Some(mut err) = self.report_method_error(\n-            span,\n-            rcvr_t,\n-            segment.ident,\n-            SelfSource::MethodCall(rcvr),\n-            error,\n-            Some(args),\n-        ) {\n-            if let ty::Adt(..) = rcvr_t.kind() {\n-                // Try alternative arbitrary self types that could fulfill this call.\n-                // FIXME: probe for all types that *could* be arbitrary self-types, not\n-                // just this list.\n-                try_alt_rcvr(&mut err, self.tcx.mk_lang_item(rcvr_t, LangItem::OwnedBox));\n-                try_alt_rcvr(&mut err, self.tcx.mk_lang_item(rcvr_t, LangItem::Pin));\n-                try_alt_rcvr(&mut err, self.tcx.mk_diagnostic_item(rcvr_t, sym::Arc));\n-                try_alt_rcvr(&mut err, self.tcx.mk_diagnostic_item(rcvr_t, sym::Rc));\n-            }\n-            err.emit();\n-        }\n-    }\n-\n     fn check_expr_cast(\n         &self,\n         e: &'tcx hir::Expr<'tcx>,"}, {"sha": "a7a412f06becc706a24d9f6c294162de27bc6f78", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -905,12 +905,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Resolves an associated value path into a base type and associated constant, or method\n     /// resolution. The newly resolved definition is written into `type_dependent_defs`.\n-    pub fn resolve_ty_and_res_ufcs<'b>(\n+    pub fn resolve_ty_and_res_ufcs(\n         &self,\n-        qpath: &'b QPath<'b>,\n+        qpath: &'tcx QPath<'tcx>,\n         hir_id: hir::HirId,\n         span: Span,\n-    ) -> (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment<'b>]) {\n+    ) -> (Res, Option<Ty<'tcx>>, &'tcx [hir::PathSegment<'tcx>]) {\n         debug!(\"resolve_ty_and_res_ufcs: qpath={:?} hir_id={:?} span={:?}\", qpath, hir_id, span);\n         let (ty, qself, item_segment) = match *qpath {\n             QPath::Resolved(ref opt_qself, ref path) => {"}, {"sha": "c74fd25f76d37fae78ec4b90866169e0305fe998", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -45,6 +45,7 @@ pub struct MethodCallee<'tcx> {\n     pub sig: ty::FnSig<'tcx>,\n }\n \n+#[derive(Debug)]\n pub enum MethodError<'tcx> {\n     // Did not find an applicable method, but we did find various near-misses that may work.\n     NoMatch(NoMatchData<'tcx>),\n@@ -66,6 +67,7 @@ pub enum MethodError<'tcx> {\n \n // Contains a list of static methods that may apply, a list of unsatisfied trait predicates which\n // could lead to matches if satisfied, and a list of not-in-scope traits which may work.\n+#[derive(Debug)]\n pub struct NoMatchData<'tcx> {\n     pub static_candidates: Vec<CandidateSource>,\n     pub unsatisfied_predicates: Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>)>,"}, {"sha": "72eff009473a11b26b2c6d8ad6b4392cc0cc417a", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 78, "deletions": 9, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -68,12 +68,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn report_method_error<'b>(\n+    pub fn report_method_error(\n         &self,\n         span: Span,\n         rcvr_ty: Ty<'tcx>,\n         item_name: Ident,\n-        source: SelfSource<'b>,\n+        source: SelfSource<'tcx>,\n         error: MethodError<'tcx>,\n         args: Option<&'tcx [hir::Expr<'tcx>]>,\n     ) -> Option<DiagnosticBuilder<'_>> {\n@@ -323,8 +323,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 err.span_suggestion(\n                                     lit.span,\n                                     &format!(\n-                                        \"you must specify a concrete type for \\\n-                                              this numeric value, like `{}`\",\n+                                        \"you must specify a concrete type for this numeric value, \\\n+                                         like `{}`\",\n                                         concrete_type\n                                     ),\n                                     format!(\"{}_{}\", snippet, concrete_type),\n@@ -975,17 +975,78 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_traits_to_import<'b>(\n+    fn suggest_traits_to_import(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         rcvr_ty: Ty<'tcx>,\n         item_name: Ident,\n-        source: SelfSource<'b>,\n+        source: SelfSource<'tcx>,\n         valid_out_of_scope_traits: Vec<DefId>,\n         unsatisfied_predicates: &[(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>)],\n     ) {\n-        if self.suggest_valid_traits(err, valid_out_of_scope_traits) {\n+        let mut alt_rcvr_sugg = false;\n+        if let SelfSource::MethodCall(rcvr) = source {\n+            info!(?span, ?item_name, ?rcvr_ty, ?rcvr);\n+            if let ty::Adt(..) = rcvr_ty.kind() {\n+                // Try alternative arbitrary self types that could fulfill this call.\n+                // FIXME: probe for all types that *could* be arbitrary self-types, not\n+                // just this list.\n+                for (rcvr_ty, post) in &[\n+                    (rcvr_ty, \"\"),\n+                    (self.tcx.mk_mut_ref(&ty::ReErased, rcvr_ty), \"&mut \"),\n+                    (self.tcx.mk_imm_ref(&ty::ReErased, rcvr_ty), \"&\"),\n+                ] {\n+                    for (rcvr_ty, pre) in &[\n+                        (self.tcx.mk_lang_item(rcvr_ty, LangItem::OwnedBox), \"Box::new\"),\n+                        (self.tcx.mk_lang_item(rcvr_ty, LangItem::Pin), \"Pin::new\"),\n+                        (self.tcx.mk_diagnostic_item(rcvr_ty, sym::Arc), \"Arc::new\"),\n+                        (self.tcx.mk_diagnostic_item(rcvr_ty, sym::Rc), \"Rc::new\"),\n+                    ] {\n+                        if let Some(new_rcvr_t) = *rcvr_ty {\n+                            if let Ok(pick) = self.lookup_probe(\n+                                span,\n+                                item_name,\n+                                new_rcvr_t,\n+                                rcvr,\n+                                crate::check::method::probe::ProbeScope::AllTraits,\n+                            ) {\n+                                debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n+                                // Make sure the method is defined for the *actual* receiver:\n+                                // we don't want to treat `Box<Self>` as a receiver if\n+                                // it only works because of an autoderef to `&self`\n+                                if pick.autoderefs == 0\n+                                    // We don't want to suggest a container type when the missing method is\n+                                    // `.clone()`, otherwise we'd suggest `Arc::new(foo).clone()`, which is\n+                                    // far from what the user really wants.\n+                                    && Some(pick.item.container.id()) != self.tcx.lang_items().clone_trait()\n+                                {\n+                                    err.span_label(\n+                                        pick.item.ident.span,\n+                                        &format!(\n+                                            \"the method is available for `{}` here\",\n+                                            new_rcvr_t\n+                                        ),\n+                                    );\n+                                    err.multipart_suggestion(\n+                                        \"consider wrapping the receiver expression with the \\\n+                                         appropriate type\",\n+                                        vec![\n+                                            (rcvr.span.shrink_to_lo(), format!(\"{}({}\", pre, post)),\n+                                            (rcvr.span.shrink_to_hi(), \")\".to_string()),\n+                                        ],\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                    // We don't care about the other suggestions.\n+                                    alt_rcvr_sugg = true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if !alt_rcvr_sugg && self.suggest_valid_traits(err, valid_out_of_scope_traits) {\n             return;\n         }\n \n@@ -1075,6 +1136,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 \"the method might not be found because of this arbitrary self type\",\n             );\n         }\n+        if alt_rcvr_sugg {\n+            return;\n+        }\n \n         if !candidates.is_empty() {\n             // Sort from most relevant to least relevant.\n@@ -1284,7 +1348,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Checks whether there is a local type somewhere in the chain of\n     /// autoderefs of `rcvr_ty`.\n-    fn type_derefs_to_local(&self, span: Span, rcvr_ty: Ty<'tcx>, source: SelfSource<'_>) -> bool {\n+    fn type_derefs_to_local(\n+        &self,\n+        span: Span,\n+        rcvr_ty: Ty<'tcx>,\n+        source: SelfSource<'tcx>,\n+    ) -> bool {\n         fn is_local(ty: Ty<'_>) -> bool {\n             match ty.kind() {\n                 ty::Adt(def, _) => def.did.is_local(),\n@@ -1310,7 +1379,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub enum SelfSource<'a> {\n     QPath(&'a hir::Ty<'a>),\n     MethodCall(&'a hir::Expr<'a> /* rcvr */),"}, {"sha": "53593b9bab4b82a184704ebbc1c2d611e91e1109", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -861,7 +861,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_tuple_struct(\n         &self,\n         pat: &'tcx Pat<'tcx>,\n-        qpath: &hir::QPath<'_>,\n+        qpath: &'tcx hir::QPath<'tcx>,\n         subpats: &'tcx [&'tcx Pat<'tcx>],\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,"}, {"sha": "337f0e847bb5619606ac0aa27b7dc39e326155a5", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -319,9 +319,9 @@ impl<T> MaybeUninit<T> {\n     /// Create a new array of `MaybeUninit<T>` items, in an uninitialized state.\n     ///\n     /// Note: in a future Rust version this method may become unnecessary\n-    /// when array literal syntax allows\n-    /// [repeating const expressions](https://github.com/rust-lang/rust/issues/49147).\n-    /// The example below could then use `let mut buf = [MaybeUninit::<u8>::uninit(); 32];`.\n+    /// when Rust allows\n+    /// [inline const expressions](https://github.com/rust-lang/rust/issues/76001).\n+    /// The example below could then use `let mut buf = [const { MaybeUninit::<u8>::uninit() }; 32];`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "25b8f435accf24aace4e214dcc65a2370def3cda", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -184,8 +184,7 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -210,6 +209,7 @@ impl<T: ?Sized> *const T {\n     /// enables more aggressive compiler optimizations.\n     ///\n     /// [`wrapping_offset`]: #method.wrapping_offset\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -245,9 +245,8 @@ impl<T: ?Sized> *const T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_offset((y as isize) - (x as isize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -265,10 +264,8 @@ impl<T: ?Sized> *const T {\n     /// `x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())` is always the same as `x`. In other\n     /// words, leaving the allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`offset`]: #method.offset\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -314,8 +311,7 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and other pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * Both pointers must be *derived from* a pointer to the same object.\n     ///   (See below for an example.)\n@@ -345,6 +341,7 @@ impl<T: ?Sized> *const T {\n     /// such large allocations either.)\n     ///\n     /// [`add`]: #method.add\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Panics\n     ///\n@@ -468,8 +465,7 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -494,6 +490,7 @@ impl<T: ?Sized> *const T {\n     /// enables more aggressive compiler optimizations.\n     ///\n     /// [`wrapping_add`]: #method.wrapping_add\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -532,8 +529,7 @@ impl<T: ?Sized> *const T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n     ///\n@@ -558,6 +554,7 @@ impl<T: ?Sized> *const T {\n     /// enables more aggressive compiler optimizations.\n     ///\n     /// [`wrapping_sub`]: #method.wrapping_sub\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -594,9 +591,8 @@ impl<T: ?Sized> *const T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_add((y as usize) - (x as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -614,10 +610,8 @@ impl<T: ?Sized> *const T {\n     /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n     /// allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`add`]: #method.add\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -659,9 +653,8 @@ impl<T: ?Sized> *const T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_sub((x as usize) - (y as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -679,10 +672,8 @@ impl<T: ?Sized> *const T {\n     /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n     /// allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`sub`]: #method.sub\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -997,7 +988,7 @@ impl<T> *const [T] {\n     /// * The pointer must be [valid] for reads for `ptr.len() * mem::size_of::<T>()` many bytes,\n     ///   and it must be properly aligned. This means in particular:\n     ///\n-    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///     * The entire memory range of this slice must be contained within a single [allocated object]!\n     ///       Slices can never span across multiple allocated objects.\n     ///\n     ///     * The pointer must be aligned even for zero-length slices. One\n@@ -1019,6 +1010,7 @@ impl<T> *const [T] {\n     /// See also [`slice::from_raw_parts`][].\n     ///\n     /// [valid]: crate::ptr#safety\n+    /// [allocated object]: crate::ptr#allocated-object\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n     pub unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {"}, {"sha": "6412bd41a8c092192d1a9ad5b8490885bc7d6242", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -55,6 +55,14 @@\n //! has size 0, i.e., even if memory is not actually touched. Consider using\n //! [`NonNull::dangling`] in such cases.\n //!\n+//! ## Allocated object\n+//!\n+//! For several operations, such as [`offset`] or field projections (`expr.field`), the notion of an\n+//! \"allocated object\" becomes relevant. An allocated object is a contiguous region of memory.\n+//! Common examples of allocated objects include stack-allocated variables (each variable is a\n+//! separate allocated object), heap allocations (each allocation created by the global allocator is\n+//! a separate allocated object), and `static` variables.\n+//!\n //! [aliasing]: ../../nomicon/aliasing.html\n //! [book]: ../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n //! [ub]: ../../reference/behavior-considered-undefined.html"}, {"sha": "732e1273b4be8ab9b402fdc4e729d8927924ccd8", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -189,8 +189,7 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -215,6 +214,7 @@ impl<T: ?Sized> *mut T {\n     /// enables more aggressive compiler optimizations.\n     ///\n     /// [`wrapping_offset`]: #method.wrapping_offset\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -251,9 +251,8 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_offset((y as isize) - (x as isize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -271,10 +270,8 @@ impl<T: ?Sized> *mut T {\n     /// `x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())` is always the same as `x`. In other\n     /// words, leaving the allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`offset`]: #method.offset\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -485,8 +482,7 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and other pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * Both pointers must be *derived from* a pointer to the same object.\n     ///   (See below for an example.)\n@@ -516,6 +512,7 @@ impl<T: ?Sized> *mut T {\n     /// such large allocations either.)\n     ///\n     /// [`add`]: #method.add\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Panics\n     ///\n@@ -575,8 +572,7 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n@@ -639,8 +635,7 @@ impl<T: ?Sized> *mut T {\n     /// Behavior:\n     ///\n     /// * Both the starting and resulting pointer must be either in bounds or one\n-    ///   byte past the end of the same allocated object. Note that in Rust,\n-    ///   every (stack-allocated) variable is considered a separate allocated object.\n+    ///   byte past the end of the same [allocated object].\n     ///\n     /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n     ///\n@@ -665,6 +660,7 @@ impl<T: ?Sized> *mut T {\n     /// enables more aggressive compiler optimizations.\n     ///\n     /// [`wrapping_sub`]: #method.wrapping_sub\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -701,9 +697,8 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_add((y as usize) - (x as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -721,10 +716,8 @@ impl<T: ?Sized> *mut T {\n     /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n     /// allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`add`]: #method.add\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -766,9 +759,8 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same allocated object that `self` points to.\n-    /// It may *not* be used to access a different allocated object. Note that in Rust, every\n-    /// (stack-allocated) variable is considered a separate allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_sub((x as usize) - (y as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -786,10 +778,8 @@ impl<T: ?Sized> *mut T {\n     /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n     /// allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`sub`]: #method.sub\n+    /// [allocated object]: crate::ptr#allocated-object\n     ///\n     /// # Examples\n     ///\n@@ -1261,7 +1251,7 @@ impl<T> *mut [T] {\n     /// * The pointer must be [valid] for reads for `ptr.len() * mem::size_of::<T>()` many bytes,\n     ///   and it must be properly aligned. This means in particular:\n     ///\n-    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///     * The entire memory range of this slice must be contained within a single [allocated object]!\n     ///       Slices can never span across multiple allocated objects.\n     ///\n     ///     * The pointer must be aligned even for zero-length slices. One\n@@ -1283,6 +1273,7 @@ impl<T> *mut [T] {\n     /// See also [`slice::from_raw_parts`][].\n     ///\n     /// [valid]: crate::ptr#safety\n+    /// [allocated object]: crate::ptr#allocated-object\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n     pub unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {\n@@ -1311,7 +1302,7 @@ impl<T> *mut [T] {\n     /// * The pointer must be [valid] for reads and writes for `ptr.len() * mem::size_of::<T>()`\n     ///   many bytes, and it must be properly aligned. This means in particular:\n     ///\n-    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///     * The entire memory range of this slice must be contained within a single [allocated object]!\n     ///       Slices can never span across multiple allocated objects.\n     ///\n     ///     * The pointer must be aligned even for zero-length slices. One\n@@ -1333,6 +1324,7 @@ impl<T> *mut [T] {\n     /// See also [`slice::from_raw_parts_mut`][].\n     ///\n     /// [valid]: crate::ptr#safety\n+    /// [allocated object]: crate::ptr#allocated-object\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n     pub unsafe fn as_uninit_slice_mut<'a>(self) -> Option<&'a mut [MaybeUninit<T>]> {"}, {"sha": "e4b1bffcfe01089ebd3fc789d10d59263dc13486", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -148,8 +148,9 @@ impl<T> [T] {\n     /// assert_eq!(None, w.first());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n     #[inline]\n-    pub fn first(&self) -> Option<&T> {\n+    pub const fn first(&self) -> Option<&T> {\n         if let [first, ..] = self { Some(first) } else { None }\n     }\n \n@@ -166,8 +167,9 @@ impl<T> [T] {\n     /// assert_eq!(x, &[5, 1, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n     #[inline]\n-    pub fn first_mut(&mut self) -> Option<&mut T> {\n+    pub const fn first_mut(&mut self) -> Option<&mut T> {\n         if let [first, ..] = self { Some(first) } else { None }\n     }\n \n@@ -184,8 +186,9 @@ impl<T> [T] {\n     /// }\n     /// ```\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n+    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n     #[inline]\n-    pub fn split_first(&self) -> Option<(&T, &[T])> {\n+    pub const fn split_first(&self) -> Option<(&T, &[T])> {\n         if let [first, tail @ ..] = self { Some((first, tail)) } else { None }\n     }\n \n@@ -204,8 +207,9 @@ impl<T> [T] {\n     /// assert_eq!(x, &[3, 4, 5]);\n     /// ```\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n+    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n     #[inline]\n-    pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n+    pub const fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n         if let [first, tail @ ..] = self { Some((first, tail)) } else { None }\n     }\n \n@@ -222,8 +226,9 @@ impl<T> [T] {\n     /// }\n     /// ```\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n+    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n     #[inline]\n-    pub fn split_last(&self) -> Option<(&T, &[T])> {\n+    pub const fn split_last(&self) -> Option<(&T, &[T])> {\n         if let [init @ .., last] = self { Some((last, init)) } else { None }\n     }\n \n@@ -242,8 +247,9 @@ impl<T> [T] {\n     /// assert_eq!(x, &[4, 5, 3]);\n     /// ```\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n+    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n     #[inline]\n-    pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n+    pub const fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n         if let [init @ .., last] = self { Some((last, init)) } else { None }\n     }\n \n@@ -259,8 +265,9 @@ impl<T> [T] {\n     /// assert_eq!(None, w.last());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n     #[inline]\n-    pub fn last(&self) -> Option<&T> {\n+    pub const fn last(&self) -> Option<&T> {\n         if let [.., last] = self { Some(last) } else { None }\n     }\n \n@@ -277,8 +284,9 @@ impl<T> [T] {\n     /// assert_eq!(x, &[0, 1, 10]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n     #[inline]\n-    pub fn last_mut(&mut self) -> Option<&mut T> {\n+    pub const fn last_mut(&mut self) -> Option<&mut T> {\n         if let [.., last] = self { Some(last) } else { None }\n     }\n "}, {"sha": "b54090a99ec7c4b46a5203a9c927fdbc311bb1f5", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -1 +1 @@\n-Subproject commit fc2f690fc16592abbead2360cfc0a42f5df78052\n+Subproject commit b54090a99ec7c4b46a5203a9c927fdbc311bb1f5"}, {"sha": "d3f2ace94d51610cf3e3c265705bb8416d37f8e4", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -1 +1 @@\n-Subproject commit f61685755fad7d3b88b4645adfbf461d500563a2\n+Subproject commit d3f2ace94d51610cf3e3c265705bb8416d37f8e4"}, {"sha": "fd97729e2d82f8b08d68a31c9bfdf0c37a7fd542", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -1 +1 @@\n-Subproject commit d10a0af8dca25d9d548ca6a369fd66ad06acb3c9\n+Subproject commit fd97729e2d82f8b08d68a31c9bfdf0c37a7fd542"}, {"sha": "29d91f591c90dd18fdca6d23f1a9caf9c139d0d7", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -1 +1 @@\n-Subproject commit eead22c6c030fa4f3a167d1798658c341199e2ae\n+Subproject commit 29d91f591c90dd18fdca6d23f1a9caf9c139d0d7"}, {"sha": "0687daac28939c476df51778f5a1d1aff1a3fddf", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -1 +1 @@\n-Subproject commit 67ebd4b55dba44edfc351621cef6e5e758169c55\n+Subproject commit 0687daac28939c476df51778f5a1d1aff1a3fddf"}, {"sha": "f5a034a0d24c535035608f5dfcdb84d1e7968313", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -424,7 +424,9 @@ nav.sub {\n \ttext-overflow: ellipsis;\n \tmargin: 0;\n }\n-.docblock-short code {\n+/* Wrap non-pre code blocks (`text`) but not (```text```). */\n+.docblock > :not(pre) > code,\n+.docblock-short > :not(pre) > code {\n \twhite-space: pre-wrap;\n }\n "}, {"sha": "0d1fe684f60e223042e2e1a02b8f2112f9cae7de", "filename": "src/test/ui/async-await/pin-needed-to-poll.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.rs?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -0,0 +1,47 @@\n+use std::{\n+    future::Future,\n+    pin::Pin,\n+    task::{Context, Poll},\n+};\n+\n+struct Sleep;\n+\n+impl Future for Sleep {\n+    type Output = ();\n+\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        Poll::Ready(())\n+    }\n+}\n+\n+impl Drop for Sleep {\n+    fn drop(&mut self) {}\n+}\n+\n+fn sleep() -> Sleep {\n+    Sleep\n+}\n+\n+\n+struct MyFuture {\n+    sleep: Sleep,\n+}\n+\n+impl MyFuture {\n+    fn new() -> Self {\n+        Self {\n+            sleep: sleep(),\n+        }\n+    }\n+}\n+\n+impl Future for MyFuture {\n+    type Output = ();\n+\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        self.sleep.poll(cx)\n+        //~^ ERROR no method named `poll` found for struct `Sleep` in the current scope\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0756a4d59c19b1fe3d19f16d72d540a7bb1d9e70", "filename": "src/test/ui/async-await/pin-needed-to-poll.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.stderr?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -0,0 +1,22 @@\n+error[E0599]: no method named `poll` found for struct `Sleep` in the current scope\n+  --> $DIR/pin-needed-to-poll.rs:42:20\n+   |\n+LL | struct Sleep;\n+   | ------------- method `poll` not found for this\n+...\n+LL |         self.sleep.poll(cx)\n+   |                    ^^^^ method not found in `Sleep`\n+   | \n+  ::: $SRC_DIR/core/src/future/future.rs:LL:COL\n+   |\n+LL |     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n+   |        ---- the method is available for `Pin<&mut Sleep>` here\n+   |\n+help: consider wrapping the receiver expression with the appropriate type\n+   |\n+LL |         Pin::new(&mut self.sleep).poll(cx)\n+   |         ^^^^^^^^^^^^^           ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "79095452f9d02230a361e3c945109469081c9483", "filename": "src/test/ui/copy-a-resource.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcopy-a-resource.stderr?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -6,14 +6,6 @@ LL | struct Foo {\n ...\n LL |     let _y = x.clone();\n    |                ^^^^^ method not found in `Foo`\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<Foo>` here\n-   |        the method is available for `Rc<Foo>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:"}, {"sha": "fd993d0f9d8854059c3bac4facd829919c742dad", "filename": "src/test/ui/derives/derive-assoc-type-not-impl.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -12,14 +12,6 @@ LL | struct NotClone;\n ...\n LL |     Bar::<NotClone> { x: 1 }.clone();\n    |                              ^^^^^ method cannot be called on `Bar<NotClone>` due to unsatisfied trait bounds\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<Bar<NotClone>>` here\n-   |        the method is available for `Rc<Bar<NotClone>>` here\n    |\n    = note: the following trait bounds were not satisfied:\n            `NotClone: Clone`"}, {"sha": "b3bc946292f70ce7c54eb63422a366057d48acb6", "filename": "src/test/ui/issues/issue-2823.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -6,14 +6,6 @@ LL | struct C {\n ...\n LL |     let _d = c.clone();\n    |                ^^^^^ method not found in `C`\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<C>` here\n-   |        the method is available for `Rc<C>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:"}, {"sha": "4dd6b4bbb68bebe0c6f39d8f841fed16d5fb0358", "filename": "src/test/ui/issues/issue-69725.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -8,14 +8,6 @@ LL |     let _ = Struct::<A>::new().clone();\n    |\n LL | pub struct Struct<A>(A);\n    | ------------------------ doesn't satisfy `Struct<A>: Clone`\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<Struct<A>>` here\n-   |        the method is available for `Rc<Struct<A>>` here\n    |\n    = note: the following trait bounds were not satisfied:\n            `A: Clone`"}, {"sha": "99af04e7cd97e2b3d743d9f61eafac399ffd9f2c", "filename": "src/test/ui/non-copyable-void.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fnon-copyable-void.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fnon-copyable-void.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-copyable-void.stderr?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -3,14 +3,6 @@ error[E0599]: no method named `clone` found for enum `c_void` in the current sco\n    |\n LL |         let _z = (*y).clone();\n    |                       ^^^^^ method not found in `c_void`\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<c_void>` here\n-   |        the method is available for `Rc<c_void>` here\n \n error: aborting due to previous error\n "}, {"sha": "4674c16eb433a12230ddbef3768fdd7cd4929e8e", "filename": "src/test/ui/noncopyable-class.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnoncopyable-class.stderr?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -6,14 +6,6 @@ LL | struct Foo {\n ...\n LL |     let _y = x.clone();\n    |                ^^^^^ method not found in `Foo`\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<Foo>` here\n-   |        the method is available for `Rc<Foo>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:"}, {"sha": "07d88c413bfa84b57a5bdaa32555d9ce1283a8a7", "filename": "src/test/ui/resolve/issue-82865.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fresolve%2Fissue-82865.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fresolve%2Fissue-82865.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-82865.rs?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -0,0 +1,13 @@\n+// Regression test for #82865.\n+\n+#![feature(decl_macro)]\n+\n+use x::y::z; //~ ERROR: failed to resolve: maybe a missing crate `x`?\n+\n+macro mac () {\n+    Box::z //~ ERROR: no function or associated item\n+}\n+\n+fn main() {\n+    mac!();\n+}"}, {"sha": "027d7a0e0e448188147d87602f87a019e81456e1", "filename": "src/test/ui/resolve/issue-82865.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fresolve%2Fissue-82865.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fresolve%2Fissue-82865.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-82865.stderr?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -0,0 +1,21 @@\n+error[E0433]: failed to resolve: maybe a missing crate `x`?\n+  --> $DIR/issue-82865.rs:5:5\n+   |\n+LL | use x::y::z;\n+   |     ^ maybe a missing crate `x`?\n+\n+error[E0599]: no function or associated item named `z` found for struct `Box<_, _>` in the current scope\n+  --> $DIR/issue-82865.rs:8:10\n+   |\n+LL |     Box::z\n+   |          ^ function or associated item not found in `Box<_, _>`\n+...\n+LL |     mac!();\n+   |     ------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0433, E0599.\n+For more information about an error, try `rustc --explain E0433`."}, {"sha": "b804ddfb024bf310ccb36d1d4e853f549cf3c07a", "filename": "src/test/ui/self/point-at-arbitrary-self-type-method.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.stderr?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -9,6 +9,11 @@ LL |     fn foo(self: Box<Self>) {}\n ...\n LL |     A.foo();\n    |       ^^^ method not found in `A`\n+   |\n+help: consider wrapping the receiver expression with the appropriate type\n+   |\n+LL |     Box::new(A).foo();\n+   |     ^^^^^^^^^ ^\n \n error: aborting due to previous error\n "}, {"sha": "e1ed0e42f985c4be2cc6603e11afa237e01eff99", "filename": "src/test/ui/self/point-at-arbitrary-self-type-trait-method.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.stderr?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -10,6 +10,11 @@ LL | struct A;\n ...\n LL |     A.foo()\n    |       ^^^ method not found in `A`\n+   |\n+help: consider wrapping the receiver expression with the appropriate type\n+   |\n+LL |     Box::new(A).foo()\n+   |     ^^^^^^^^^ ^\n \n error: aborting due to previous error\n "}, {"sha": "916a6c2bf12af6277f3affdfbb205a216295f3dc", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.nll.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/689e8470ffa7aeca17cfee428704a4d6c4148c11/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/689e8470ffa7aeca17cfee428704a4d6c4148c11/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr?ref=689e8470ffa7aeca17cfee428704a4d6c4148c11", "patch": "@@ -1,11 +0,0 @@\n-error[E0261]: use of undeclared lifetime name `'a`\n-  --> $DIR/missing-lifetimes-in-signature.rs:36:11\n-   |\n-LL | fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n-   |        -  ^^ undeclared lifetime\n-   |        |\n-   |        help: consider introducing lifetime `'a` here: `'a,`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0261`."}, {"sha": "01e36a4a62a1bcc01715166670471d9f3f1e6d38", "filename": "src/test/ui/traits/negative-impls/explicitly-unimplemented-error-message.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Fexplicitly-unimplemented-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Fexplicitly-unimplemented-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Fexplicitly-unimplemented-error-message.stderr?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -6,14 +6,6 @@ LL | struct Qux;\n ...\n LL |     Qux.clone();\n    |         ^^^^^ method not found in `Qux`\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<Qux>` here\n-   |        the method is available for `Rc<Qux>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the trait `Clone` defines an item `clone`, but is explicitely unimplemented"}, {"sha": "546394664dfe8ecd8bdaafc038b6b4a688a26fcd", "filename": "src/test/ui/union/union-derive-clone.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -25,14 +25,6 @@ LL | struct CloneNoCopy;\n ...\n LL |     let w = u.clone();\n    |               ^^^^^ method cannot be called on `U5<CloneNoCopy>` due to unsatisfied trait bounds\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<U5<CloneNoCopy>>` here\n-   |        the method is available for `Rc<U5<CloneNoCopy>>` here\n    |\n    = note: the following trait bounds were not satisfied:\n            `CloneNoCopy: Copy`"}, {"sha": "6a355dd2562862003d8bc26663c1ef93cddb6cbd", "filename": "src/test/ui/unique-object-noncopyable.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -10,14 +10,6 @@ LL |   trait Foo {\n LL |       let _z = y.clone();\n    |                  ^^^^^ method cannot be called on `Box<dyn Foo>` due to unsatisfied trait bounds\n    | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |       fn clone(&self) -> Self;\n-   |          -----\n-   |          |\n-   |          the method is available for `Arc<Box<dyn Foo>>` here\n-   |          the method is available for `Rc<Box<dyn Foo>>` here\n-   | \n   ::: $SRC_DIR/alloc/src/boxed.rs:LL:COL\n    |\n LL | / pub struct Box<"}, {"sha": "a4421bcf8097e6ff17cde0c2f78cda6907ad7eb3", "filename": "src/test/ui/unique-pinned-nocopy.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16156fb2787f745e57504197bd7fe38b69c6cbea/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr?ref=16156fb2787f745e57504197bd7fe38b69c6cbea", "patch": "@@ -7,14 +7,6 @@ LL |   struct R {\n LL |       let _j = i.clone();\n    |                  ^^^^^ method cannot be called on `Box<R>` due to unsatisfied trait bounds\n    | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |       fn clone(&self) -> Self;\n-   |          -----\n-   |          |\n-   |          the method is available for `Arc<Box<R>>` here\n-   |          the method is available for `Rc<Box<R>>` here\n-   | \n   ::: $SRC_DIR/alloc/src/boxed.rs:LL:COL\n    |\n LL | / pub struct Box<"}]}