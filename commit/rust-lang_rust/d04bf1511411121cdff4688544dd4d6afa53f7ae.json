{"sha": "d04bf1511411121cdff4688544dd4d6afa53f7ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNGJmMTUxMTQxMTEyMWNkZmY0Njg4NTQ0ZGQ0ZDZhZmE1M2Y3YWU=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-09-22T06:59:23Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-09-22T06:59:23Z"}, "message": "Merge branch 'master' into unneeded_wildcard_pattern", "tree": {"sha": "47abaa2b8f5ccabea6df5515578efaf7e42f9a87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47abaa2b8f5ccabea6df5515578efaf7e42f9a87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d04bf1511411121cdff4688544dd4d6afa53f7ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d04bf1511411121cdff4688544dd4d6afa53f7ae", "html_url": "https://github.com/rust-lang/rust/commit/d04bf1511411121cdff4688544dd4d6afa53f7ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d04bf1511411121cdff4688544dd4d6afa53f7ae/comments", "author": null, "committer": null, "parents": [{"sha": "fed1709f46791c0b46b6460740d15f0f5b89d8d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/fed1709f46791c0b46b6460740d15f0f5b89d8d5", "html_url": "https://github.com/rust-lang/rust/commit/fed1709f46791c0b46b6460740d15f0f5b89d8d5"}, {"sha": "d07d001b74f384e34d5f670c34e45bdc9a372ca2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d07d001b74f384e34d5f670c34e45bdc9a372ca2", "html_url": "https://github.com/rust-lang/rust/commit/d07d001b74f384e34d5f670c34e45bdc9a372ca2"}], "stats": {"total": 1635, "additions": 1246, "deletions": 389}, "files": [{"sha": "6d190286e0ada7577e7a8c3f94cde0ca7552f8c8", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1050,12 +1050,14 @@ Released 2018-09-13\n [`mem_discriminant_non_enum`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_discriminant_non_enum\n [`mem_forget`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_forget\n [`mem_replace_option_with_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_replace_option_with_none\n+[`mem_replace_with_uninit`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_replace_with_uninit\n [`min_max`]: https://rust-lang.github.io/rust-clippy/master/index.html#min_max\n [`misaligned_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#misaligned_transmute\n [`misrefactored_assign_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#misrefactored_assign_op\n [`missing_const_for_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_const_for_fn\n [`missing_docs_in_private_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_docs_in_private_items\n [`missing_inline_in_public_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_inline_in_public_items\n+[`missing_safety_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_safety_doc\n [`mistyped_literal_suffixes`]: https://rust-lang.github.io/rust-clippy/master/index.html#mistyped_literal_suffixes\n [`mixed_case_hex_literals`]: https://rust-lang.github.io/rust-clippy/master/index.html#mixed_case_hex_literals\n [`module_inception`]: https://rust-lang.github.io/rust-clippy/master/index.html#module_inception"}, {"sha": "915396b901cd6a4e65810e9a57a64cc4e3cd0833", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -6,7 +6,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 314 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are 316 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "423e13e9dd5afdd3df7c985f0651bb3e34f15b8a", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -27,7 +27,7 @@ semver = \"0.9.0\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n toml = \"0.5.3\"\n unicode-normalization = \"0.1\"\n-pulldown-cmark = \"0.5.3\"\n+pulldown-cmark = \"0.6.0\"\n url = { version =  \"2.1.0\", features = [\"serde\"] } # cargo requires serde feat in its url dep\n # see https://github.com/rust-lang/rust/pull/63587#issuecomment-522343864\n if_chain = \"1.0.0\""}, {"sha": "a56d751b22d2b4df0084eaa96d8f660c49ee0f6f", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -216,13 +216,13 @@ fn lint_misrefactored_assign_op(\n                         long\n                     ),\n                     format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n-                    Applicability::MachineApplicable,\n+                    Applicability::MaybeIncorrect,\n                 );\n                 db.span_suggestion(\n                     expr.span,\n                     \"or\",\n                     long,\n-                    Applicability::MachineApplicable, // snippet\n+                    Applicability::MaybeIncorrect, // snippet\n                 );\n             }\n         },"}, {"sha": "86d83bf9602ed47a838582575fb320c499118dae", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 83, "deletions": 28, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -34,6 +34,40 @@ declare_clippy_lint! {\n     \"presence of `_`, `::` or camel-case outside backticks in documentation\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for the doc comments of publicly visible\n+    /// unsafe functions and warns if there is no `# Safety` section.\n+    ///\n+    /// **Why is this bad?** Unsafe functions should document their safety\n+    /// preconditions, so that users can be sure they are using them safely.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples**:\n+    /// ```rust\n+    ///# type Universe = ();\n+    /// /// This function should really be documented\n+    /// pub unsafe fn start_apocalypse(u: &mut Universe) {\n+    ///     unimplemented!();\n+    /// }\n+    /// ```\n+    ///\n+    /// At least write a line about safety:\n+    ///\n+    /// ```rust\n+    ///# type Universe = ();\n+    /// /// # Safety\n+    /// ///\n+    /// /// This function should not be called before the horsemen are ready.\n+    /// pub unsafe fn start_apocalypse(u: &mut Universe) {\n+    ///     unimplemented!();\n+    /// }\n+    /// ```\n+    pub MISSING_SAFETY_DOC,\n+    style,\n+    \"`pub unsafe fn` without `# Safety` docs\"\n+}\n+\n #[allow(clippy::module_name_repetitions)]\n #[derive(Clone)]\n pub struct DocMarkdown {\n@@ -46,15 +80,28 @@ impl DocMarkdown {\n     }\n }\n \n-impl_lint_pass!(DocMarkdown => [DOC_MARKDOWN]);\n+impl_lint_pass!(DocMarkdown => [DOC_MARKDOWN, MISSING_SAFETY_DOC]);\n \n impl EarlyLintPass for DocMarkdown {\n     fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &ast::Crate) {\n         check_attrs(cx, &self.valid_idents, &krate.attrs);\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n-        check_attrs(cx, &self.valid_idents, &item.attrs);\n+        if check_attrs(cx, &self.valid_idents, &item.attrs) {\n+            return;\n+        }\n+        // no safety header\n+        if let ast::ItemKind::Fn(_, ref header, ..) = item.node {\n+            if item.vis.node.is_pub() && header.unsafety == ast::Unsafety::Unsafe {\n+                span_lint(\n+                    cx,\n+                    MISSING_SAFETY_DOC,\n+                    item.span,\n+                    \"unsafe function's docs miss `# Safety` section\",\n+                );\n+            }\n+        }\n     }\n }\n \n@@ -115,7 +162,7 @@ pub fn strip_doc_comment_decoration(comment: &str, span: Span) -> (String, Vec<(\n     panic!(\"not a doc-comment: {}\", comment);\n }\n \n-pub fn check_attrs<'a>(cx: &EarlyContext<'_>, valid_idents: &FxHashSet<String>, attrs: &'a [ast::Attribute]) {\n+pub fn check_attrs<'a>(cx: &EarlyContext<'_>, valid_idents: &FxHashSet<String>, attrs: &'a [ast::Attribute]) -> bool {\n     let mut doc = String::new();\n     let mut spans = vec![];\n \n@@ -129,7 +176,7 @@ pub fn check_attrs<'a>(cx: &EarlyContext<'_>, valid_idents: &FxHashSet<String>,\n             }\n         } else if attr.check_name(sym!(doc)) {\n             // ignore mix of sugared and non-sugared doc\n-            return;\n+            return true; // don't trigger the safety check\n         }\n     }\n \n@@ -140,57 +187,64 @@ pub fn check_attrs<'a>(cx: &EarlyContext<'_>, valid_idents: &FxHashSet<String>,\n         current += offset_copy;\n     }\n \n-    if !doc.is_empty() {\n-        let parser = pulldown_cmark::Parser::new(&doc).into_offset_iter();\n-        // Iterate over all `Events` and combine consecutive events into one\n-        let events = parser.coalesce(|previous, current| {\n-            use pulldown_cmark::Event::*;\n-\n-            let previous_range = previous.1;\n-            let current_range = current.1;\n-\n-            match (previous.0, current.0) {\n-                (Text(previous), Text(current)) => {\n-                    let mut previous = previous.to_string();\n-                    previous.push_str(&current);\n-                    Ok((Text(previous.into()), previous_range))\n-                },\n-                (previous, current) => Err(((previous, previous_range), (current, current_range))),\n-            }\n-        });\n-        check_doc(cx, valid_idents, events, &spans);\n+    if doc.is_empty() {\n+        return false;\n     }\n+\n+    let parser = pulldown_cmark::Parser::new(&doc).into_offset_iter();\n+    // Iterate over all `Events` and combine consecutive events into one\n+    let events = parser.coalesce(|previous, current| {\n+        use pulldown_cmark::Event::*;\n+\n+        let previous_range = previous.1;\n+        let current_range = current.1;\n+\n+        match (previous.0, current.0) {\n+            (Text(previous), Text(current)) => {\n+                let mut previous = previous.to_string();\n+                previous.push_str(&current);\n+                Ok((Text(previous.into()), previous_range))\n+            },\n+            (previous, current) => Err(((previous, previous_range), (current, current_range))),\n+        }\n+    });\n+    check_doc(cx, valid_idents, events, &spans)\n }\n \n fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize>)>>(\n     cx: &EarlyContext<'_>,\n     valid_idents: &FxHashSet<String>,\n     events: Events,\n     spans: &[(usize, Span)],\n-) {\n+) -> bool {\n+    // true if a safety header was found\n     use pulldown_cmark::Event::*;\n     use pulldown_cmark::Tag::*;\n \n+    let mut safety_header = false;\n     let mut in_code = false;\n     let mut in_link = None;\n+    let mut in_heading = false;\n \n     for (event, range) in events {\n         match event {\n             Start(CodeBlock(_)) => in_code = true,\n             End(CodeBlock(_)) => in_code = false,\n             Start(Link(_, url, _)) => in_link = Some(url),\n             End(Link(..)) => in_link = None,\n-            Start(_tag) | End(_tag) => (),         // We don't care about other tags\n-            Html(_html) | InlineHtml(_html) => (), // HTML is weird, just ignore it\n-            SoftBreak | HardBreak | TaskListMarker(_) | Code(_) => (),\n+            Start(Heading(_)) => in_heading = true,\n+            End(Heading(_)) => in_heading = false,\n+            Start(_tag) | End(_tag) => (), // We don't care about other tags\n+            Html(_html) => (),             // HTML is weird, just ignore it\n+            SoftBreak | HardBreak | TaskListMarker(_) | Code(_) | Rule => (),\n             FootnoteReference(text) | Text(text) => {\n                 if Some(&text) == in_link.as_ref() {\n                     // Probably a link of the form `<http://example.com>`\n                     // Which are represented as a link to \"http://example.com\" with\n                     // text \"http://example.com\" by pulldown-cmark\n                     continue;\n                 }\n-\n+                safety_header |= in_heading && text.trim() == \"Safety\";\n                 if !in_code {\n                     let index = match spans.binary_search_by(|c| c.0.cmp(&range.start)) {\n                         Ok(o) => o,\n@@ -207,6 +261,7 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n             },\n         }\n     }\n+    safety_header\n }\n \n fn check_text(cx: &EarlyContext<'_>, valid_idents: &FxHashSet<String>, text: &str, span: Span) {"}, {"sha": "023fd5693183a07e8331445a5468bf8f8132c38f", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{is_copy, match_def_path, paths, span_note_and_lint};\n+use crate::utils::{is_copy, match_def_path, paths, qpath_res, span_note_and_lint};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -114,7 +114,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DropForgetRef {\n             if let ExprKind::Call(ref path, ref args) = expr.node;\n             if let ExprKind::Path(ref qpath) = path.node;\n             if args.len() == 1;\n-            if let Some(def_id) = cx.tables.qpath_res(qpath, path.hir_id).opt_def_id();\n+            if let Some(def_id) = qpath_res(cx, qpath, path.hir_id).opt_def_id();\n             then {\n                 let lint;\n                 let msg;"}, {"sha": "477f0e76025866c27926c0e51b4ef0da35180a39", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -140,7 +140,8 @@ fn write_output_string(write_args: &HirVec<Expr>) -> Option<String> {\n         if output_args.len() > 0;\n         if let ExprKind::AddrOf(_, ref output_string_expr) = output_args[0].node;\n         if let ExprKind::Array(ref string_exprs) = output_string_expr.node;\n-        if string_exprs.len() > 0;\n+        // we only want to provide an automatic suggestion for simple (non-format) strings\n+        if string_exprs.len() == 1;\n         if let ExprKind::Lit(ref lit) = string_exprs[0].node;\n         if let LitKind::Str(ref write_output, _) = lit.node;\n         then {"}, {"sha": "b332148cbddcd29f22a586bf6b8b2e6e04163168", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,6 +1,6 @@\n use std::convert::TryFrom;\n \n-use crate::utils::{iter_input_pats, snippet, snippet_opt, span_lint, type_is_unsafe_function};\n+use crate::utils::{iter_input_pats, qpath_res, snippet, snippet_opt, span_lint, type_is_unsafe_function};\n use matches::matches;\n use rustc::hir;\n use rustc::hir::def::Res;\n@@ -318,7 +318,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n     fn check_arg(&self, ptr: &hir::Expr) {\n         if let hir::ExprKind::Path(ref qpath) = ptr.node {\n-            if let Res::Local(id) = self.cx.tables.qpath_res(qpath, ptr.hir_id) {\n+            if let Res::Local(id) = qpath_res(self.cx, qpath, ptr.hir_id) {\n                 if self.ptrs.contains(&id) {\n                     span_lint(\n                         self.cx,"}, {"sha": "4b1b57b4808a7287a9e2aeb47efa2c422ac10ec2", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{higher, snippet, span_lint_and_then};\n+use crate::utils::{higher, qpath_res, snippet, span_lint_and_then};\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::def::Res;\n@@ -145,7 +145,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if_chain! {\n             if let hir::ExprKind::Path(ref qpath) = expr.node;\n-            if let Res::Local(local_id) = self.cx.tables.qpath_res(qpath, expr.hir_id);\n+            if let Res::Local(local_id) = qpath_res(self.cx, qpath, expr.hir_id);\n             if self.id == local_id;\n             then {\n                 self.used = true;\n@@ -170,7 +170,7 @@ fn check_assign<'a, 'tcx>(\n         if let hir::StmtKind::Semi(ref expr) = expr.node;\n         if let hir::ExprKind::Assign(ref var, ref value) = expr.node;\n         if let hir::ExprKind::Path(ref qpath) = var.node;\n-        if let Res::Local(local_id) = cx.tables.qpath_res(qpath, var.hir_id);\n+        if let Res::Local(local_id) = qpath_res(cx, qpath, var.hir_id);\n         if decl == local_id;\n         then {\n             let mut v = UsedVisitor {"}, {"sha": "2caa065b937991c47201ac37e5b121600ee287e8", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -667,6 +667,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         shadow::SHADOW_UNRELATED,\n         strings::STRING_ADD_ASSIGN,\n         trait_bounds::TYPE_REPETITION_IN_BOUNDS,\n+        types::CAST_LOSSLESS,\n         types::CAST_POSSIBLE_TRUNCATION,\n         types::CAST_POSSIBLE_WRAP,\n         types::CAST_PRECISION_LOSS,\n@@ -708,6 +709,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         copies::IFS_SAME_COND,\n         copies::IF_SAME_THEN_ELSE,\n         derive::DERIVE_HASH_XOR_EQ,\n+        doc::MISSING_SAFETY_DOC,\n         double_comparison::DOUBLE_COMPARISONS,\n         double_parens::DOUBLE_PARENS,\n         drop_bounds::DROP_BOUNDS,\n@@ -781,6 +783,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         matches::SINGLE_MATCH,\n         mem_discriminant::MEM_DISCRIMINANT_NON_ENUM,\n         mem_replace::MEM_REPLACE_OPTION_WITH_NONE,\n+        mem_replace::MEM_REPLACE_WITH_UNINIT,\n         methods::CHARS_LAST_CMP,\n         methods::CHARS_NEXT_CMP,\n         methods::CLONE_DOUBLE_REF,\n@@ -891,7 +894,6 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         types::ABSURD_EXTREME_COMPARISONS,\n         types::BORROWED_BOX,\n         types::BOX_VEC,\n-        types::CAST_LOSSLESS,\n         types::CAST_PTR_ALIGNMENT,\n         types::CAST_REF_TO_MUT,\n         types::CHAR_LIT_AS_U8,\n@@ -930,6 +932,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_EXPR,\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT,\n         collapsible_if::COLLAPSIBLE_IF,\n+        doc::MISSING_SAFETY_DOC,\n         enum_variants::ENUM_VARIANT_NAMES,\n         enum_variants::MODULE_INCEPTION,\n         eq_op::OP_REF,\n@@ -1074,7 +1077,6 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         transmute::TRANSMUTE_PTR_TO_REF,\n         transmute::USELESS_TRANSMUTE,\n         types::BORROWED_BOX,\n-        types::CAST_LOSSLESS,\n         types::CHAR_LIT_AS_U8,\n         types::OPTION_OPTION,\n         types::TYPE_COMPLEXITY,\n@@ -1118,6 +1120,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         loops::REVERSE_RANGE_LOOP,\n         loops::WHILE_IMMUTABLE_CONDITION,\n         mem_discriminant::MEM_DISCRIMINANT_NON_ENUM,\n+        mem_replace::MEM_REPLACE_WITH_UNINIT,\n         methods::CLONE_DOUBLE_REF,\n         methods::INTO_ITER_ON_ARRAY,\n         methods::TEMPORARY_CSTRING_AS_PTR,"}, {"sha": "0032cfd1985bc945f5c39e99853a0023f8212e3e", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -11,7 +11,7 @@ use rustc::{declare_lint_pass, declare_tool_lint};\n // use rustc::middle::region::CodeExtent;\n use crate::consts::{constant, Constant};\n use crate::utils::usage::mutated_variables;\n-use crate::utils::{is_type_diagnostic_item, sext, sugg};\n+use crate::utils::{is_type_diagnostic_item, qpath_res, sext, sugg};\n use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::cmt_;\n use rustc::middle::mem_categorization::Categorization;\n@@ -754,7 +754,7 @@ fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: HirId) -> bo\n         if let ExprKind::Path(ref qpath) = expr.node;\n         if let QPath::Resolved(None, ref path) = *qpath;\n         if path.segments.len() == 1;\n-        if let Res::Local(local_id) = cx.tables.qpath_res(qpath, expr.hir_id);\n+        if let Res::Local(local_id) = qpath_res(cx, qpath, expr.hir_id);\n         // our variable!\n         if local_id == var;\n         then {\n@@ -1272,7 +1272,7 @@ fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx\n                     let start_snippet = snippet(cx, start.span, \"_\");\n                     let end_snippet = snippet(cx, end.span, \"_\");\n                     let dots = if limits == ast::RangeLimits::Closed {\n-                        \"...\"\n+                        \"..=\"\n                     } else {\n                         \"..\"\n                     };\n@@ -1618,7 +1618,7 @@ fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<HirId>\n         if let ExprKind::Path(ref qpath) = bound.node;\n         if let QPath::Resolved(None, _) = *qpath;\n         then {\n-            let res = cx.tables.qpath_res(qpath, bound.hir_id);\n+            let res = qpath_res(cx, qpath, bound.hir_id);\n             if let Res::Local(node_id) = res {\n                 let node_str = cx.tcx.hir().get(node_id);\n                 if_chain! {\n@@ -1762,7 +1762,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                     if self.prefer_mutable {\n                         self.indexed_mut.insert(seqvar.segments[0].ident.name);\n                     }\n-                    let res = self.cx.tables.qpath_res(seqpath, seqexpr.hir_id);\n+                    let res = qpath_res(self.cx, seqpath, seqexpr.hir_id);\n                     match res {\n                         Res::Local(hir_id) => {\n                             let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n@@ -1824,7 +1824,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n             if let QPath::Resolved(None, ref path) = *qpath;\n             if path.segments.len() == 1;\n             then {\n-                if let Res::Local(local_id) = self.cx.tables.qpath_res(qpath, expr.hir_id) {\n+                if let Res::Local(local_id) = qpath_res(self.cx, qpath, expr.hir_id) {\n                     if local_id == self.var {\n                         self.nonindex = true;\n                     } else {\n@@ -2163,7 +2163,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n \n fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<HirId> {\n     if let ExprKind::Path(ref qpath) = expr.node {\n-        let path_res = cx.tables.qpath_res(qpath, expr.hir_id);\n+        let path_res = qpath_res(cx, qpath, expr.hir_id);\n         if let Res::Local(node_id) = path_res {\n             return Some(node_id);\n         }\n@@ -2355,7 +2355,7 @@ impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n         if_chain! {\n             if let ExprKind::Path(ref qpath) = ex.node;\n             if let QPath::Resolved(None, _) = *qpath;\n-            let res = self.cx.tables.qpath_res(qpath, ex.hir_id);\n+            let res = qpath_res(self.cx, qpath, ex.hir_id);\n             then {\n                 match res {\n                     Res::Local(node_id) => {"}, {"sha": "9d457f453e6284e4d63db889c180fbf622381c07", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_def_path, paths, span_lint};\n+use crate::utils::{match_def_path, paths, qpath_res, span_lint};\n use rustc::hir::{Expr, ExprKind};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n@@ -29,7 +29,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprKind::Call(ref path_expr, ref args) = e.node {\n             if let ExprKind::Path(ref qpath) = path_expr.node {\n-                if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n+                if let Some(def_id) = qpath_res(cx, qpath, path_expr.hir_id).opt_def_id() {\n                     if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n                         let forgot_ty = cx.tables.expr_ty(&args[0]);\n "}, {"sha": "3e1155806b9efa1c2c1c1bc5a97a2140699b6e8a", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 95, "deletions": 31, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,4 +1,6 @@\n-use crate::utils::{match_def_path, match_qpath, paths, snippet_with_applicability, span_lint_and_sugg};\n+use crate::utils::{\n+    match_def_path, match_qpath, paths, snippet_with_applicability, span_help_and_lint, span_lint_and_sugg,\n+};\n use if_chain::if_chain;\n use rustc::hir::{Expr, ExprKind, MutMutable, QPath};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -32,7 +34,40 @@ declare_clippy_lint! {\n     \"replacing an `Option` with `None` instead of `take()`\"\n }\n \n-declare_lint_pass!(MemReplace => [MEM_REPLACE_OPTION_WITH_NONE]);\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `mem::replace(&mut _, mem::uninitialized())`\n+    /// and `mem::replace(&mut _, mem::zeroed())`.\n+    ///\n+    /// **Why is this bad?** This will lead to undefined behavior even if the\n+    /// value is overwritten later, because the uninitialized value may be\n+    /// observed in the case of a panic.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```\n+    /// use std::mem;\n+    ///# fn may_panic(v: Vec<i32>) -> Vec<i32> { v }\n+    ///\n+    /// #[allow(deprecated, invalid_value)]\n+    /// fn myfunc (v: &mut Vec<i32>) {\n+    ///     let taken_v = unsafe { mem::replace(v, mem::uninitialized()) };\n+    ///     let new_v = may_panic(taken_v); // undefined behavior on panic\n+    ///     mem::forget(mem::replace(v, new_v));\n+    /// }\n+    /// ```\n+    ///\n+    /// The [take_mut](https://docs.rs/take_mut) crate offers a sound solution,\n+    /// at the cost of either lazily creating a replacement value or aborting\n+    /// on panic, to ensure that the uninitialized value cannot be observed.\n+    pub MEM_REPLACE_WITH_UNINIT,\n+    correctness,\n+    \"`mem::replace(&mut _, mem::uninitialized())` or `mem::replace(&mut _, mem::zeroed())`\"\n+}\n+\n+declare_lint_pass!(MemReplace =>\n+    [MEM_REPLACE_OPTION_WITH_NONE, MEM_REPLACE_WITH_UNINIT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n@@ -45,37 +80,66 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n             if match_def_path(cx, def_id, &paths::MEM_REPLACE);\n \n             // Check that second argument is `Option::None`\n-            if let ExprKind::Path(ref replacement_qpath) = func_args[1].node;\n-            if match_qpath(replacement_qpath, &paths::OPTION_NONE);\n-\n             then {\n-                // Since this is a late pass (already type-checked),\n-                // and we already know that the second argument is an\n-                // `Option`, we do not need to check the first\n-                // argument's type. All that's left is to get\n-                // replacee's path.\n-                let replaced_path = match func_args[0].node {\n-                    ExprKind::AddrOf(MutMutable, ref replaced) => {\n-                        if let ExprKind::Path(QPath::Resolved(None, ref replaced_path)) = replaced.node {\n-                            replaced_path\n-                        } else {\n-                            return\n-                        }\n-                    },\n-                    ExprKind::Path(QPath::Resolved(None, ref replaced_path)) => replaced_path,\n-                    _ => return,\n-                };\n+                if let ExprKind::Path(ref replacement_qpath) = func_args[1].node {\n+                    if match_qpath(replacement_qpath, &paths::OPTION_NONE) {\n \n-                let mut applicability = Applicability::MachineApplicable;\n-                span_lint_and_sugg(\n-                    cx,\n-                    MEM_REPLACE_OPTION_WITH_NONE,\n-                    expr.span,\n-                    \"replacing an `Option` with `None`\",\n-                    \"consider `Option::take()` instead\",\n-                    format!(\"{}.take()\", snippet_with_applicability(cx, replaced_path.span, \"\", &mut applicability)),\n-                    applicability,\n-                );\n+                        // Since this is a late pass (already type-checked),\n+                        // and we already know that the second argument is an\n+                        // `Option`, we do not need to check the first\n+                        // argument's type. All that's left is to get\n+                        // replacee's path.\n+                        let replaced_path = match func_args[0].node {\n+                            ExprKind::AddrOf(MutMutable, ref replaced) => {\n+                                if let ExprKind::Path(QPath::Resolved(None, ref replaced_path)) = replaced.node {\n+                                    replaced_path\n+                                } else {\n+                                    return\n+                                }\n+                            },\n+                            ExprKind::Path(QPath::Resolved(None, ref replaced_path)) => replaced_path,\n+                            _ => return,\n+                        };\n+\n+                        let mut applicability = Applicability::MachineApplicable;\n+                        span_lint_and_sugg(\n+                            cx,\n+                            MEM_REPLACE_OPTION_WITH_NONE,\n+                            expr.span,\n+                            \"replacing an `Option` with `None`\",\n+                            \"consider `Option::take()` instead\",\n+                            format!(\"{}.take()\", snippet_with_applicability(cx, replaced_path.span, \"\", &mut applicability)),\n+                            applicability,\n+                        );\n+                    }\n+                }\n+                if let ExprKind::Call(ref repl_func, ref repl_args) = func_args[1].node {\n+                    if_chain! {\n+                        if repl_args.is_empty();\n+                        if let ExprKind::Path(ref repl_func_qpath) = repl_func.node;\n+                        if let Some(repl_def_id) = cx.tables.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n+                        then {\n+                            if match_def_path(cx, repl_def_id, &paths::MEM_UNINITIALIZED) {\n+                                span_help_and_lint(\n+                                    cx,\n+                                    MEM_REPLACE_WITH_UNINIT,\n+                                    expr.span,\n+                                    \"replacing with `mem::uninitialized()`\",\n+                                    \"consider using the `take_mut` crate instead\",\n+                                );\n+                            } else if match_def_path(cx, repl_def_id, &paths::MEM_ZEROED) &&\n+                                    !cx.tables.expr_ty(&func_args[1]).is_primitive() {\n+                                span_help_and_lint(\n+                                    cx,\n+                                    MEM_REPLACE_WITH_UNINIT,\n+                                    expr.span,\n+                                    \"replacing with `mem::zeroed()`\",\n+                                    \"consider using a default value or the `take_mut` crate instead\",\n+                                );\n+                            }\n+                        }\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "571e664d4d476fcadf671ce081ce6ff3414f95dd", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{has_drop, snippet_opt, span_lint, span_lint_and_sugg};\n+use crate::utils::{has_drop, qpath_res, snippet_opt, span_lint, span_lint_and_sugg};\n use rustc::hir::def::{DefKind, Res};\n use rustc::hir::{BinOpKind, BlockCheckMode, Expr, ExprKind, Stmt, StmtKind, UnsafeSource};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -67,7 +67,7 @@ fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n         },\n         ExprKind::Call(ref callee, ref args) => {\n             if let ExprKind::Path(ref qpath) = callee.node {\n-                let res = cx.tables.qpath_res(qpath, callee.hir_id);\n+                let res = qpath_res(cx, qpath, callee.hir_id);\n                 match res {\n                     Res::Def(DefKind::Struct, ..) | Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(..), _) => {\n                         !has_drop(cx, cx.tables.expr_ty(expr)) && args.iter().all(|arg| has_no_effect(cx, arg))\n@@ -145,7 +145,7 @@ fn reduce_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<Vec\n         },\n         ExprKind::Call(ref callee, ref args) => {\n             if let ExprKind::Path(ref qpath) = callee.node {\n-                let res = cx.tables.qpath_res(qpath, callee.hir_id);\n+                let res = qpath_res(cx, qpath, callee.hir_id);\n                 match res {\n                     Res::Def(DefKind::Struct, ..) | Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(..), _)\n                         if !has_drop(cx, cx.tables.expr_ty(expr)) =>"}, {"sha": "992baa05e78e7050c37d86960922748e070487f1", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -14,7 +14,7 @@ use rustc_errors::Applicability;\n use rustc_typeck::hir_ty_to_ty;\n use syntax_pos::{InnerSpan, Span, DUMMY_SP};\n \n-use crate::utils::{in_constant, is_copy, span_lint_and_then};\n+use crate::utils::{in_constant, is_copy, qpath_res, span_lint_and_then};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for declaration of `const` items which is interior\n@@ -195,7 +195,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n             }\n \n             // Make sure it is a const item.\n-            match cx.tables.qpath_res(qpath, expr.hir_id) {\n+            match qpath_res(cx, qpath, expr.hir_id) {\n                 Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => {},\n                 _ => return,\n             };"}, {"sha": "d029267e034dc7de4339d45bd4304cdad1d56def", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -252,13 +252,13 @@ fn find_stmt_assigns_to<'a, 'tcx: 'a>(\n     stmts\n         .rev()\n         .find_map(|stmt| {\n-            if let mir::StatementKind::Assign(\n+            if let mir::StatementKind::Assign(box (\n                 mir::Place {\n                     base: mir::PlaceBase::Local(local),\n                     ..\n                 },\n                 v,\n-            ) = &stmt.kind\n+            )) = &stmt.kind\n             {\n                 if *local == to {\n                     return Some(v);\n@@ -269,10 +269,10 @@ fn find_stmt_assigns_to<'a, 'tcx: 'a>(\n         })\n         .and_then(|v| {\n             if by_ref {\n-                if let mir::Rvalue::Ref(_, _, ref place) = **v {\n+                if let mir::Rvalue::Ref(_, _, ref place) = v {\n                     return base_local_and_movability(cx, mir, place);\n                 }\n-            } else if let mir::Rvalue::Use(mir::Operand::Copy(ref place)) = **v {\n+            } else if let mir::Rvalue::Use(mir::Operand::Copy(ref place)) = v {\n                 return base_local_and_movability(cx, mir, place);\n             }\n             None\n@@ -291,7 +291,6 @@ fn base_local_and_movability<'tcx>(\n     use rustc::mir::Place;\n     use rustc::mir::PlaceBase;\n     use rustc::mir::PlaceRef;\n-    use rustc::mir::Projection;\n \n     // Dereference. You cannot move things out from a borrowed value.\n     let mut deref = false;\n@@ -303,7 +302,7 @@ fn base_local_and_movability<'tcx>(\n         mut projection,\n     } = place.as_ref();\n     if let PlaceBase::Local(local) = place_base {\n-        while let Some(box Projection { base, elem }) = projection {\n+        while let [base @ .., elem] = projection {\n             projection = base;\n             deref = matches!(elem, mir::ProjectionElem::Deref);\n             field = !field"}, {"sha": "5696c2be12a8c6bb801d249f68509d48a3794108", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -24,7 +24,7 @@ use crate::consts::{constant, Constant};\n use crate::utils::paths;\n use crate::utils::{\n     clip, comparisons, differing_macro_contexts, higher, in_constant, int_bits, last_path_segment, match_def_path,\n-    match_path, multispan_sugg, same_tys, sext, snippet, snippet_opt, snippet_with_applicability,\n+    match_path, multispan_sugg, qpath_res, same_tys, sext, snippet, snippet_opt, snippet_with_applicability,\n     snippet_with_macro_callsite, span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, unsext,\n };\n \n@@ -218,7 +218,7 @@ fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath, path: &[&str])\n             _ => None,\n         });\n         if let TyKind::Path(ref qpath) = ty.node;\n-        if let Some(did) = cx.tables.qpath_res(qpath, ty.hir_id).opt_def_id();\n+        if let Some(did) = qpath_res(cx, qpath, ty.hir_id).opt_def_id();\n         if match_def_path(cx, did, path);\n         then {\n             return true;\n@@ -240,7 +240,7 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n     match hir_ty.node {\n         TyKind::Path(ref qpath) if !is_local => {\n             let hir_id = hir_ty.hir_id;\n-            let res = cx.tables.qpath_res(qpath, hir_id);\n+            let res = qpath_res(cx, qpath, hir_id);\n             if let Some(def_id) = res.opt_def_id() {\n                 if Some(def_id) == cx.tcx.lang_items().owned_box() {\n                     if match_type_parameter(cx, qpath, &paths::VEC) {\n@@ -263,7 +263,7 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n                         });\n                         // ty is now _ at this point\n                         if let TyKind::Path(ref ty_qpath) = ty.node;\n-                        let res = cx.tables.qpath_res(ty_qpath, ty.hir_id);\n+                        let res = qpath_res(cx, ty_qpath, ty.hir_id);\n                         if let Some(def_id) = res.opt_def_id();\n                         if Some(def_id) == cx.tcx.lang_items().owned_box();\n                         // At this point, we know ty is Box<T>, now get T\n@@ -369,7 +369,7 @@ fn check_ty_rptr(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool, lt:\n     match mut_ty.ty.node {\n         TyKind::Path(ref qpath) => {\n             let hir_id = mut_ty.ty.hir_id;\n-            let def = cx.tables.qpath_res(qpath, hir_id);\n+            let def = qpath_res(cx, qpath, hir_id);\n             if_chain! {\n                 if let Some(def_id) = def.opt_def_id();\n                 if Some(def_id) == cx.tcx.lang_items().owned_box();\n@@ -765,7 +765,7 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub CAST_LOSSLESS,\n-    complexity,\n+    pedantic,\n     \"casts using `as` that are known to be lossless, e.g., `x as u64` where `x: u8`\"\n }\n "}, {"sha": "9165f8d74d7831bc1f2e453a2b58100db5d1260f", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -273,6 +273,19 @@ pub fn path_to_res(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<(def::Res)\n     }\n }\n \n+pub fn qpath_res(cx: &LateContext<'_, '_>, qpath: &hir::QPath, id: hir::HirId) -> Res {\n+    match qpath {\n+        hir::QPath::Resolved(_, path) => path.res,\n+        hir::QPath::TypeRelative(..) => {\n+            if cx.tcx.has_typeck_tables(id.owner_def_id()) {\n+                cx.tcx.typeck_tables_of(id.owner_def_id()).qpath_res(qpath, id)\n+            } else {\n+                Res::Err\n+            }\n+        },\n+    }\n+}\n+\n /// Convenience function to get the `DefId` of a trait by path.\n /// It could be a trait or trait alias.\n pub fn get_trait_def_id(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<DefId> {"}, {"sha": "cda3d2024d2e67a57b479cb9404416c4f9e52fa6", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -52,6 +52,8 @@ pub const MEM_FORGET: [&str; 3] = [\"core\", \"mem\", \"forget\"];\n pub const MEM_MAYBEUNINIT: [&str; 4] = [\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\"];\n pub const MEM_MAYBEUNINIT_UNINIT: [&str; 5] = [\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\", \"uninit\"];\n pub const MEM_REPLACE: [&str; 3] = [\"core\", \"mem\", \"replace\"];\n+pub const MEM_UNINITIALIZED: [&str; 3] = [\"core\", \"mem\", \"uninitialized\"];\n+pub const MEM_ZEROED: [&str; 3] = [\"core\", \"mem\", \"zeroed\"];\n pub const MUTEX: [&str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n pub const OPEN_OPTIONS: [&str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n pub const OPS_MODULE: [&str; 2] = [\"core\", \"ops\"];"}, {"sha": "af6c3e297014d0ee1b105a5a07e361fe5d0c9d3b", "filename": "doc/adding_lints.md", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -7,20 +7,22 @@ creating an example lint from scratch.\n To get started, we will create a lint that detects functions called `foo`,\n because that's clearly a non-descriptive name.\n \n-* [Setup](#Setup)\n-* [Testing](#Testing)\n-* [Rustfix tests](#Rustfix-tests)\n-* [Edition 2018 tests](#Edition-2018-tests)\n-* [Lint declaration](#Lint-declaration)\n-* [Lint passes](#Lint-passes)\n-* [Emitting a lint](#Emitting-a-lint)\n-* [Adding the lint logic](#Adding-the-lint-logic)\n-* [Author lint](#Author-lint)\n-* [Documentation](#Documentation)\n-* [Running rustfmt](#Running-rustfmt)\n-* [Debugging](#Debugging)\n-* [PR Checklist](#PR-Checklist)\n-* [Cheatsheet](#Cheatsheet)\n+- [Adding a new lint](#adding-a-new-lint)\n+  - [Setup](#setup)\n+  - [Testing](#testing)\n+  - [Rustfix tests](#rustfix-tests)\n+  - [Edition 2018 tests](#edition-2018-tests)\n+  - [Testing manually](#testing-manually)\n+  - [Lint declaration](#lint-declaration)\n+  - [Lint passes](#lint-passes)\n+  - [Emitting a lint](#emitting-a-lint)\n+  - [Adding the lint logic](#adding-the-lint-logic)\n+  - [Author lint](#author-lint)\n+  - [Documentation](#documentation)\n+  - [Running rustfmt](#running-rustfmt)\n+  - [Debugging](#debugging)\n+  - [PR Checklist](#pr-checklist)\n+  - [Cheatsheet](#cheatsheet)\n \n ### Setup\n \n@@ -309,7 +311,7 @@ If you have trouble implementing your lint, there is also the internal `author`\n lint to generate Clippy code that detects the offending pattern. It does not\n work for all of the Rust syntax, but can give a good starting point.\n \n-The quickest way to use it, is the [Rust playground][play].rust-lang.org).\n+The quickest way to use it, is the [Rust playground: play.rust-lang.org][Play].\n Put the code you want to lint into the editor and add the `#[clippy::author]`\n attribute above the item. Then run Clippy via `Tools -> Clippy` and you should\n see the generated code in the output below."}, {"sha": "359d2f8530cbbc8be025408ee5e7f02f629c9309", "filename": "src/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -247,8 +247,9 @@ You can use tool lints to allow or deny lints from your code, eg.:\n \n pub fn main() {\n     rustc_driver::init_rustc_env_logger();\n+    rustc_driver::install_ice_hook();\n     exit(\n-        rustc_driver::report_ices_to_stderr_if_any(move || {\n+        rustc_driver::catch_fatal_errors(move || {\n             use std::env;\n \n             if std::env::args().any(|a| a == \"--version\" || a == \"-V\") {"}, {"sha": "e6bcbfadf4fc202f0340c8015920710db0a40ba0", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -6,7 +6,7 @@ pub use lint::Lint;\n pub use lint::LINT_LEVELS;\n \n // begin lint list, do not remove this comment, it\u2019s used in `update_lints`\n-pub const ALL_LINTS: [Lint; 314] = [\n+pub const ALL_LINTS: [Lint; 316] = [\n     Lint {\n         name: \"absurd_extreme_comparisons\",\n         group: \"correctness\",\n@@ -121,7 +121,7 @@ pub const ALL_LINTS: [Lint; 314] = [\n     },\n     Lint {\n         name: \"cast_lossless\",\n-        group: \"complexity\",\n+        group: \"pedantic\",\n         desc: \"casts using `as` that are known to be lossless, e.g., `x as u64` where `x: u8`\",\n         deprecation: None,\n         module: \"types\",\n@@ -1043,6 +1043,13 @@ pub const ALL_LINTS: [Lint; 314] = [\n         deprecation: None,\n         module: \"mem_replace\",\n     },\n+    Lint {\n+        name: \"mem_replace_with_uninit\",\n+        group: \"correctness\",\n+        desc: \"`mem::replace(&mut _, mem::uninitialized())` or `mem::replace(&mut _, mem::zeroed())`\",\n+        deprecation: None,\n+        module: \"mem_replace\",\n+    },\n     Lint {\n         name: \"min_max\",\n         group: \"correctness\",\n@@ -1078,6 +1085,13 @@ pub const ALL_LINTS: [Lint; 314] = [\n         deprecation: None,\n         module: \"missing_inline\",\n     },\n+    Lint {\n+        name: \"missing_safety_doc\",\n+        group: \"style\",\n+        desc: \"`pub unsafe fn` without `# Safety` docs\",\n+        deprecation: None,\n+        module: \"doc\",\n+    },\n     Lint {\n         name: \"mistyped_literal_suffixes\",\n         group: \"correctness\",\n@@ -1977,7 +1991,7 @@ pub const ALL_LINTS: [Lint; 314] = [\n     Lint {\n         name: \"unneeded_wildcard_pattern\",\n         group: \"complexity\",\n-        desc: \"tuple patterns with a wildcard pattern (`_`) is next to a rest pattern (`..`) pattern\",\n+        desc: \"tuple patterns with a wildcard pattern (`_`) is next to a rest pattern (`..`)\",\n         deprecation: None,\n         module: \"misc_early\",\n     },"}, {"sha": "944f3c2c0138f99554c88f0a8c856bc4f18848c0", "filename": "tests/dogfood.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,24 +1,27 @@\n #[test]\n-fn dogfood() {\n+fn dogfood_clippy() {\n+    // run clippy on itself and fail the test if lint warnings are reported\n     if option_env!(\"RUSTC_TEST_SUITE\").is_some() || cfg!(windows) {\n         return;\n     }\n     let root_dir = std::path::PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n-    let clippy_cmd = std::path::Path::new(&root_dir)\n+    let clippy_binary = std::path::Path::new(&root_dir)\n         .join(\"target\")\n         .join(env!(\"PROFILE\"))\n         .join(\"cargo-clippy\");\n \n-    let output = std::process::Command::new(clippy_cmd)\n+    let output = std::process::Command::new(clippy_binary)\n         .current_dir(root_dir)\n         .env(\"CLIPPY_DOGFOOD\", \"1\")\n+        .env(\"CARGO_INCREMENTAL\", \"0\")\n         .arg(\"clippy-preview\")\n         .arg(\"--all-targets\")\n         .arg(\"--all-features\")\n         .arg(\"--\")\n         .args(&[\"-D\", \"clippy::all\"])\n         .args(&[\"-D\", \"clippy::internal\"])\n         .args(&[\"-D\", \"clippy::pedantic\"])\n+        .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n         .output()\n         .unwrap();\n     println!(\"status: {}\", output.status);\n@@ -29,12 +32,13 @@ fn dogfood() {\n }\n \n #[test]\n-fn dogfood_tests() {\n+fn dogfood_subprojects() {\n+    // run clippy on remaining subprojects and fail the test if lint warnings are reported\n     if option_env!(\"RUSTC_TEST_SUITE\").is_some() || cfg!(windows) {\n         return;\n     }\n     let root_dir = std::path::PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n-    let clippy_cmd = std::path::Path::new(&root_dir)\n+    let clippy_binary = std::path::Path::new(&root_dir)\n         .join(\"target\")\n         .join(env!(\"PROFILE\"))\n         .join(\"cargo-clippy\");\n@@ -47,13 +51,15 @@ fn dogfood_tests() {\n         \"clippy_dev\",\n         \"rustc_tools_util\",\n     ] {\n-        let output = std::process::Command::new(&clippy_cmd)\n+        let output = std::process::Command::new(&clippy_binary)\n             .current_dir(root_dir.join(d))\n             .env(\"CLIPPY_DOGFOOD\", \"1\")\n+            .env(\"CARGO_INCREMENTAL\", \"0\")\n             .arg(\"clippy\")\n             .arg(\"--\")\n             .args(&[\"-D\", \"clippy::all\"])\n             .args(&[\"-D\", \"clippy::pedantic\"])\n+            .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n             .output()\n             .unwrap();\n         println!(\"status: {}\", output.status);"}, {"sha": "4531943299cd1206aa0388229522e40334d92ad9", "filename": "tests/ui/deref_addrof_double_trigger.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fderef_addrof_double_trigger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fderef_addrof_double_trigger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_addrof_double_trigger.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,5 +1,7 @@\n+// This test can't work with run-rustfix because it needs two passes of test+fix\n+\n #[warn(clippy::deref_addrof)]\n-#[allow(unused_variables)]\n+#[allow(unused_variables, unused_mut)]\n fn main() {\n     let a = 10;\n "}, {"sha": "2c55a4ed6acdb269663a7d92b482a65d3c3e9370", "filename": "tests/ui/deref_addrof_double_trigger.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fderef_addrof_double_trigger.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fderef_addrof_double_trigger.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_addrof_double_trigger.stderr?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,19 +1,19 @@\n error: immediately dereferencing a reference\n-  --> $DIR/deref_addrof_double_trigger.rs:8:14\n+  --> $DIR/deref_addrof_double_trigger.rs:10:14\n    |\n LL |     let b = **&&a;\n    |              ^^^^ help: try this: `&a`\n    |\n    = note: `-D clippy::deref-addrof` implied by `-D warnings`\n \n error: immediately dereferencing a reference\n-  --> $DIR/deref_addrof_double_trigger.rs:12:17\n+  --> $DIR/deref_addrof_double_trigger.rs:14:17\n    |\n LL |         let y = *&mut x;\n    |                 ^^^^^^^ help: try this: `x`\n \n error: immediately dereferencing a reference\n-  --> $DIR/deref_addrof_double_trigger.rs:19:18\n+  --> $DIR/deref_addrof_double_trigger.rs:21:18\n    |\n LL |         let y = **&mut &mut x;\n    |                  ^^^^^^^^^^^^ help: try this: `&mut x`"}, {"sha": "7b26e86b40b8d1a74392af6d7a8849b8ea8bd9eb", "filename": "tests/ui/doc_unsafe.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fdoc_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fdoc_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc_unsafe.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -0,0 +1,25 @@\n+/// This is not sufficiently documented\n+pub unsafe fn destroy_the_planet() {\n+    unimplemented!();\n+}\n+\n+/// This one is\n+///\n+/// # Safety\n+///\n+/// This function shouldn't be called unless the horsemen are ready\n+pub unsafe fn apocalypse(universe: &mut ()) {\n+    unimplemented!();\n+}\n+\n+/// This is a private function, so docs aren't necessary\n+unsafe fn you_dont_see_me() {\n+    unimplemented!();\n+}\n+\n+fn main() {\n+    you_dont_see_me();\n+    destroy_the_planet();\n+    let mut universe = ();\n+    apocalypse(&mut universe);\n+}"}, {"sha": "d6d1cd2d4faf469ec97b2e5d51ba9446a4e7dde0", "filename": "tests/ui/doc_unsafe.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fdoc_unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fdoc_unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc_unsafe.stderr?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -0,0 +1,12 @@\n+error: unsafe function's docs miss `# Safety` section\n+  --> $DIR/doc_unsafe.rs:2:1\n+   |\n+LL | / pub unsafe fn destroy_the_planet() {\n+LL | |     unimplemented!();\n+LL | | }\n+   | |_^\n+   |\n+   = note: `-D clippy::missing-safety-doc` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "c93f520bee24b8763ec4d2c43fdef4615993ce11", "filename": "tests/ui/eq_op.rs", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feq_op.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -2,7 +2,8 @@\n #[warn(clippy::eq_op)]\n #[allow(clippy::identity_op, clippy::double_parens, clippy::many_single_char_names)]\n #[allow(clippy::no_effect, unused_variables, clippy::unnecessary_operation, clippy::short_circuit_statement)]\n-#[warn(clippy::nonminimal_bool)]\n+#[allow(clippy::nonminimal_bool)]\n+#[allow(unused)]\n fn main() {\n     // simple values and comparisons\n     1 == 1;\n@@ -50,42 +51,6 @@ fn main() {\n     2*a.len() == 2*a.len(); // ok, functions\n     a.pop() == a.pop(); // ok, functions\n \n-    use std::ops::BitAnd;\n-    struct X(i32);\n-    impl BitAnd for X {\n-        type Output = X;\n-        fn bitand(self, rhs: X) -> X {\n-            X(self.0 & rhs.0)\n-        }\n-    }\n-    impl<'a> BitAnd<&'a X> for X {\n-        type Output = X;\n-        fn bitand(self, rhs: &'a X) -> X {\n-            X(self.0 & rhs.0)\n-        }\n-    }\n-    let x = X(1);\n-    let y = X(2);\n-    let z = x & &y;\n-\n-    #[derive(Copy, Clone)]\n-    struct Y(i32);\n-    impl BitAnd for Y {\n-        type Output = Y;\n-        fn bitand(self, rhs: Y) -> Y {\n-            Y(self.0 & rhs.0)\n-        }\n-    }\n-    impl<'a> BitAnd<&'a Y> for Y {\n-        type Output = Y;\n-        fn bitand(self, rhs: &'a Y) -> Y {\n-            Y(self.0 & rhs.0)\n-        }\n-    }\n-    let x = Y(1);\n-    let y = Y(2);\n-    let z = x & &y;\n-\n     check_ignore_macro();\n \n     // named constants"}, {"sha": "e37c0c22907ed8af5c041a3c761a0c616c9e28e6", "filename": "tests/ui/eq_op.stderr", "status": "modified", "additions": 28, "deletions": 76, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Feq_op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Feq_op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feq_op.stderr?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,214 +1,166 @@\n-error: this boolean expression can be simplified\n-  --> $DIR/eq_op.rs:35:5\n-   |\n-LL |     true && true;\n-   |     ^^^^^^^^^^^^ help: try: `true`\n-   |\n-   = note: `-D clippy::nonminimal-bool` implied by `-D warnings`\n-\n-error: this boolean expression can be simplified\n-  --> $DIR/eq_op.rs:37:5\n-   |\n-LL |     true || true;\n-   |     ^^^^^^^^^^^^ help: try: `true`\n-\n-error: this boolean expression can be simplified\n-  --> $DIR/eq_op.rs:43:5\n-   |\n-LL |     a == b && b == a;\n-   |     ^^^^^^^^^^^^^^^^ help: try: `a == b`\n-\n-error: this boolean expression can be simplified\n-  --> $DIR/eq_op.rs:44:5\n-   |\n-LL |     a != b && b != a;\n-   |     ^^^^^^^^^^^^^^^^ help: try: `a != b`\n-\n-error: this boolean expression can be simplified\n-  --> $DIR/eq_op.rs:45:5\n-   |\n-LL |     a < b && b > a;\n-   |     ^^^^^^^^^^^^^^ help: try: `a < b`\n-\n-error: this boolean expression can be simplified\n-  --> $DIR/eq_op.rs:46:5\n-   |\n-LL |     a <= b && b >= a;\n-   |     ^^^^^^^^^^^^^^^^ help: try: `a <= b`\n-\n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:8:5\n+  --> $DIR/eq_op.rs:9:5\n    |\n LL |     1 == 1;\n    |     ^^^^^^\n    |\n    = note: `-D clippy::eq-op` implied by `-D warnings`\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:9:5\n+  --> $DIR/eq_op.rs:10:5\n    |\n LL |     \"no\" == \"no\";\n    |     ^^^^^^^^^^^^\n \n error: equal expressions as operands to `!=`\n-  --> $DIR/eq_op.rs:11:5\n+  --> $DIR/eq_op.rs:12:5\n    |\n LL |     false != false;\n    |     ^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `<`\n-  --> $DIR/eq_op.rs:12:5\n+  --> $DIR/eq_op.rs:13:5\n    |\n LL |     1.5 < 1.5;\n    |     ^^^^^^^^^\n \n error: equal expressions as operands to `>=`\n-  --> $DIR/eq_op.rs:13:5\n+  --> $DIR/eq_op.rs:14:5\n    |\n LL |     1u64 >= 1u64;\n    |     ^^^^^^^^^^^^\n \n error: equal expressions as operands to `&`\n-  --> $DIR/eq_op.rs:16:5\n+  --> $DIR/eq_op.rs:17:5\n    |\n LL |     (1 as u64) & (1 as u64);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `^`\n-  --> $DIR/eq_op.rs:17:5\n+  --> $DIR/eq_op.rs:18:5\n    |\n LL |     1 ^ ((((((1))))));\n    |     ^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `<`\n-  --> $DIR/eq_op.rs:20:5\n+  --> $DIR/eq_op.rs:21:5\n    |\n LL |     (-(2) < -(2));\n    |     ^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:21:5\n+  --> $DIR/eq_op.rs:22:5\n    |\n LL |     ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&`\n-  --> $DIR/eq_op.rs:21:6\n+  --> $DIR/eq_op.rs:22:6\n    |\n LL |     ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n    |      ^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&`\n-  --> $DIR/eq_op.rs:21:27\n+  --> $DIR/eq_op.rs:22:27\n    |\n LL |     ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n    |                           ^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:22:5\n+  --> $DIR/eq_op.rs:23:5\n    |\n LL |     (1 * 2) + (3 * 4) == 1 * 2 + 3 * 4;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `!=`\n-  --> $DIR/eq_op.rs:25:5\n+  --> $DIR/eq_op.rs:26:5\n    |\n LL |     ([1] != [1]);\n    |     ^^^^^^^^^^^^\n \n error: equal expressions as operands to `!=`\n-  --> $DIR/eq_op.rs:26:5\n+  --> $DIR/eq_op.rs:27:5\n    |\n LL |     ((1, 2) != (1, 2));\n    |     ^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:30:5\n+  --> $DIR/eq_op.rs:31:5\n    |\n LL |     1 + 1 == 2;\n    |     ^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:31:5\n+  --> $DIR/eq_op.rs:32:5\n    |\n LL |     1 - 1 == 0;\n    |     ^^^^^^^^^^\n \n error: equal expressions as operands to `-`\n-  --> $DIR/eq_op.rs:31:5\n+  --> $DIR/eq_op.rs:32:5\n    |\n LL |     1 - 1 == 0;\n    |     ^^^^^\n \n error: equal expressions as operands to `-`\n-  --> $DIR/eq_op.rs:33:5\n+  --> $DIR/eq_op.rs:34:5\n    |\n LL |     1 - 1;\n    |     ^^^^^\n \n error: equal expressions as operands to `/`\n-  --> $DIR/eq_op.rs:34:5\n+  --> $DIR/eq_op.rs:35:5\n    |\n LL |     1 / 1;\n    |     ^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:35:5\n+  --> $DIR/eq_op.rs:36:5\n    |\n LL |     true && true;\n    |     ^^^^^^^^^^^^\n \n error: equal expressions as operands to `||`\n-  --> $DIR/eq_op.rs:37:5\n+  --> $DIR/eq_op.rs:38:5\n    |\n LL |     true || true;\n    |     ^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:43:5\n+  --> $DIR/eq_op.rs:44:5\n    |\n LL |     a == b && b == a;\n    |     ^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:44:5\n+  --> $DIR/eq_op.rs:45:5\n    |\n LL |     a != b && b != a;\n    |     ^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:45:5\n+  --> $DIR/eq_op.rs:46:5\n    |\n LL |     a < b && b > a;\n    |     ^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:46:5\n+  --> $DIR/eq_op.rs:47:5\n    |\n LL |     a <= b && b >= a;\n    |     ^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:49:5\n+  --> $DIR/eq_op.rs:50:5\n    |\n LL |     a == a;\n    |     ^^^^^^\n \n-error: taken reference of right operand\n-  --> $DIR/eq_op.rs:87:13\n-   |\n-LL |     let z = x & &y;\n-   |             ^^^^--\n-   |                 |\n-   |                 help: use the right value directly: `y`\n-   |\n-   = note: `-D clippy::op-ref` implied by `-D warnings`\n-\n error: equal expressions as operands to `/`\n-  --> $DIR/eq_op.rs:95:20\n+  --> $DIR/eq_op.rs:60:20\n    |\n LL |     const D: u32 = A / A;\n    |                    ^^^^^\n \n-error: aborting due to 34 previous errors\n+error: aborting due to 27 previous errors\n "}, {"sha": "f21e8ef935bd02f71fb0cab1c48983afcbe06589", "filename": "tests/ui/explicit_write_non_rustfix.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fexplicit_write_non_rustfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fexplicit_write_non_rustfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_write_non_rustfix.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -0,0 +1,8 @@\n+#![allow(unused_imports, clippy::blacklisted_name)]\n+#![warn(clippy::explicit_write)]\n+\n+fn main() {\n+    use std::io::Write;\n+    let bar = \"bar\";\n+    writeln!(std::io::stderr(), \"foo {}\", bar).unwrap();\n+}"}, {"sha": "77cadb99bb5510601922ea7034a003a2826669a2", "filename": "tests/ui/explicit_write_non_rustfix.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fexplicit_write_non_rustfix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fexplicit_write_non_rustfix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_write_non_rustfix.stderr?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -0,0 +1,10 @@\n+error: use of `writeln!(stderr(), ...).unwrap()`. Consider using `eprintln!` instead\n+  --> $DIR/explicit_write_non_rustfix.rs:7:5\n+   |\n+LL |     writeln!(std::io::stderr(), \"foo {}\", bar).unwrap();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::explicit-write` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/ui/for_loop.stdout", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fed1709f46791c0b46b6460740d15f0f5b89d8d5/tests%2Fui%2Ffor_loop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fed1709f46791c0b46b6460740d15f0f5b89d8d5/tests%2Fui%2Ffor_loop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop.stdout?ref=fed1709f46791c0b46b6460740d15f0f5b89d8d5"}, {"sha": "3075638ef94bfa0e828be1a3568761721180f320", "filename": "tests/ui/for_loop_fixable.fixed", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ffor_loop_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ffor_loop_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_fixable.fixed?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -0,0 +1,304 @@\n+// run-rustfix\n+\n+#![allow(dead_code, unused)]\n+\n+use std::collections::*;\n+\n+#[warn(clippy::all)]\n+struct Unrelated(Vec<u8>);\n+impl Unrelated {\n+    fn next(&self) -> std::slice::Iter<u8> {\n+        self.0.iter()\n+    }\n+\n+    fn iter(&self) -> std::slice::Iter<u8> {\n+        self.0.iter()\n+    }\n+}\n+\n+#[warn(\n+    clippy::needless_range_loop,\n+    clippy::explicit_iter_loop,\n+    clippy::explicit_into_iter_loop,\n+    clippy::iter_next_loop,\n+    clippy::reverse_range_loop,\n+    clippy::for_kv_map\n+)]\n+#[allow(\n+    clippy::linkedlist,\n+    clippy::shadow_unrelated,\n+    clippy::unnecessary_mut_passed,\n+    clippy::cognitive_complexity,\n+    clippy::similar_names\n+)]\n+#[allow(clippy::many_single_char_names, unused_variables, clippy::into_iter_on_array)]\n+fn main() {\n+    const MAX_LEN: usize = 42;\n+    let mut vec = vec![1, 2, 3, 4];\n+\n+    for i in (0..10).rev() {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in (0..=10).rev() {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in (0..MAX_LEN).rev() {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in 5..=5 {\n+        // not an error, this is the range with only one element \u201c5\u201d\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in 0..10 {\n+        // not an error, the start index is less than the end index\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in -10..0 {\n+        // not an error\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in (10..0).map(|x| x * 2) {\n+        // not an error, it can't be known what arbitrary methods do to a range\n+        println!(\"{}\", i);\n+    }\n+\n+    // testing that the empty range lint folds constants\n+    for i in (5 + 4..10).rev() {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in ((3 - 1)..(5 + 2)).rev() {\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in (2 * 2)..(2 * 3) {\n+        // no error, 4..6 is fine\n+        println!(\"{}\", i);\n+    }\n+\n+    let x = 42;\n+    for i in x..10 {\n+        // no error, not constant-foldable\n+        println!(\"{}\", i);\n+    }\n+\n+    // See #601\n+    for i in 0..10 {\n+        // no error, id_col does not exist outside the loop\n+        let mut id_col = vec![0f64; 10];\n+        id_col[i] = 1f64;\n+    }\n+\n+    for _v in &vec {}\n+\n+    for _v in &mut vec {}\n+\n+    let out_vec = vec![1, 2, 3];\n+    for _v in out_vec {}\n+\n+    let array = [1, 2, 3];\n+    for _v in &array {}\n+\n+    for _v in &vec {} // these are fine\n+    for _v in &mut vec {} // these are fine\n+\n+    for _v in &[1, 2, 3] {}\n+\n+    for _v in (&mut [1, 2, 3]).iter() {} // no error\n+\n+    for _v in &[0; 32] {}\n+\n+    for _v in [0; 33].iter() {} // no error\n+\n+    let ll: LinkedList<()> = LinkedList::new();\n+    for _v in &ll {}\n+\n+    let vd: VecDeque<()> = VecDeque::new();\n+    for _v in &vd {}\n+\n+    let bh: BinaryHeap<()> = BinaryHeap::new();\n+    for _v in &bh {}\n+\n+    let hm: HashMap<(), ()> = HashMap::new();\n+    for _v in &hm {}\n+\n+    let bt: BTreeMap<(), ()> = BTreeMap::new();\n+    for _v in &bt {}\n+\n+    let hs: HashSet<()> = HashSet::new();\n+    for _v in &hs {}\n+\n+    let bs: BTreeSet<()> = BTreeSet::new();\n+    for _v in &bs {}\n+\n+    let u = Unrelated(vec![]);\n+    for _v in u.next() {} // no error\n+    for _v in u.iter() {} // no error\n+\n+    let mut out = vec![];\n+    vec.iter().cloned().map(|x| out.push(x)).collect::<Vec<_>>();\n+    let _y = vec.iter().cloned().map(|x| out.push(x)).collect::<Vec<_>>(); // this is fine\n+\n+    // Loop with explicit counter variable\n+\n+    // Potential false positives\n+    let mut _index = 0;\n+    _index = 1;\n+    for _v in &vec {\n+        _index += 1\n+    }\n+\n+    let mut _index = 0;\n+    _index += 1;\n+    for _v in &vec {\n+        _index += 1\n+    }\n+\n+    let mut _index = 0;\n+    if true {\n+        _index = 1\n+    }\n+    for _v in &vec {\n+        _index += 1\n+    }\n+\n+    let mut _index = 0;\n+    let mut _index = 1;\n+    for _v in &vec {\n+        _index += 1\n+    }\n+\n+    let mut _index = 0;\n+    for _v in &vec {\n+        _index += 1;\n+        _index += 1\n+    }\n+\n+    let mut _index = 0;\n+    for _v in &vec {\n+        _index *= 2;\n+        _index += 1\n+    }\n+\n+    let mut _index = 0;\n+    for _v in &vec {\n+        _index = 1;\n+        _index += 1\n+    }\n+\n+    let mut _index = 0;\n+\n+    for _v in &vec {\n+        let mut _index = 0;\n+        _index += 1\n+    }\n+\n+    let mut _index = 0;\n+    for _v in &vec {\n+        _index += 1;\n+        _index = 0;\n+    }\n+\n+    let mut _index = 0;\n+    for _v in &vec {\n+        for _x in 0..1 {\n+            _index += 1;\n+        }\n+        _index += 1\n+    }\n+\n+    let mut _index = 0;\n+    for x in &vec {\n+        if *x == 1 {\n+            _index += 1\n+        }\n+    }\n+\n+    let mut _index = 0;\n+    if true {\n+        _index = 1\n+    };\n+    for _v in &vec {\n+        _index += 1\n+    }\n+\n+    let mut _index = 1;\n+    if false {\n+        _index = 0\n+    };\n+    for _v in &vec {\n+        _index += 1\n+    }\n+\n+    let mut index = 0;\n+    {\n+        let mut _x = &mut index;\n+    }\n+    for _v in &vec {\n+        _index += 1\n+    }\n+\n+    let mut index = 0;\n+    for _v in &vec {\n+        index += 1\n+    }\n+    println!(\"index: {}\", index);\n+\n+    fn f<T>(_: &T, _: &T) -> bool {\n+        unimplemented!()\n+    }\n+    fn g<T>(_: &mut [T], _: usize, _: usize) {\n+        unimplemented!()\n+    }\n+    for i in 1..vec.len() {\n+        if f(&vec[i - 1], &vec[i]) {\n+            g(&mut vec, i - 1, i);\n+        }\n+    }\n+\n+    for mid in 1..vec.len() {\n+        let (_, _) = vec.split_at(mid);\n+    }\n+}\n+\n+fn partition<T: PartialOrd + Send>(v: &mut [T]) -> usize {\n+    let pivot = v.len() - 1;\n+    let mut i = 0;\n+    for j in 0..pivot {\n+        if v[j] <= v[pivot] {\n+            v.swap(i, j);\n+            i += 1;\n+        }\n+    }\n+    v.swap(i, pivot);\n+    i\n+}\n+\n+#[warn(clippy::needless_range_loop)]\n+pub fn manual_copy_same_destination(dst: &mut [i32], d: usize, s: usize) {\n+    // Same source and destination - don't trigger lint\n+    for i in 0..dst.len() {\n+        dst[d + i] = dst[s + i];\n+    }\n+}\n+\n+mod issue_2496 {\n+    pub trait Handle {\n+        fn new_for_index(index: usize) -> Self;\n+        fn index(&self) -> usize;\n+    }\n+\n+    pub fn test<H: Handle>() -> H {\n+        for x in 0..5 {\n+            let next_handle = H::new_for_index(x);\n+            println!(\"{}\", next_handle.index());\n+        }\n+        unimplemented!()\n+    }\n+}"}, {"sha": "2201596fd6a674ed61644b2abeb1182da051ee9a", "filename": "tests/ui/for_loop_fixable.rs", "status": "renamed", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ffor_loop_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ffor_loop_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_fixable.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,8 +1,8 @@\n-use std::collections::*;\n-use std::rc::Rc;\n+// run-rustfix\n+\n+#![allow(dead_code, unused)]\n \n-static STATIC: [usize; 4] = [0, 1, 8, 16];\n-const CONST: [usize; 4] = [0, 1, 8, 16];\n+use std::collections::*;\n \n #[warn(clippy::all)]\n struct Unrelated(Vec<u8>);\n@@ -48,10 +48,6 @@ fn main() {\n         println!(\"{}\", i);\n     }\n \n-    for i in 5..5 {\n-        println!(\"{}\", i);\n-    }\n-\n     for i in 5..=5 {\n         // not an error, this is the range with only one element \u201c5\u201d\n         println!(\"{}\", i);\n@@ -81,10 +77,6 @@ fn main() {\n         println!(\"{}\", i);\n     }\n \n-    for i in (5 + 2)..(8 - 1) {\n-        println!(\"{}\", i);\n-    }\n-\n     for i in (2 * 2)..(2 * 3) {\n         // no error, 4..6 is fine\n         println!(\"{}\", i);\n@@ -145,8 +137,6 @@ fn main() {\n     let bs: BTreeSet<()> = BTreeSet::new();\n     for _v in bs.iter() {}\n \n-    for _v in vec.iter().next() {}\n-\n     let u = Unrelated(vec![]);\n     for _v in u.next() {} // no error\n     for _v in u.iter() {} // no error\n@@ -275,17 +265,8 @@ fn main() {\n     for mid in 1..vec.len() {\n         let (_, _) = vec.split_at(mid);\n     }\n-\n-    const ZERO: usize = 0;\n-\n-    for i in ZERO..vec.len() {\n-        if f(&vec[i], &vec[i]) {\n-            panic!(\"at the disco\");\n-        }\n-    }\n }\n \n-#[allow(dead_code)]\n fn partition<T: PartialOrd + Send>(v: &mut [T]) -> usize {\n     let pivot = v.len() - 1;\n     let mut i = 0;", "previous_filename": "tests/ui/for_loop.rs"}, {"sha": "6d6fa3ac7af956b553990de88639d47dcf828812", "filename": "tests/ui/for_loop_fixable.stderr", "status": "renamed", "additions": 20, "deletions": 52, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ffor_loop_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ffor_loop_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_fixable.stderr?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,5 +1,5 @@\n error: this range is empty so this for loop will never run\n-  --> $DIR/for_loop.rs:39:14\n+  --> $DIR/for_loop_fixable.rs:39:14\n    |\n LL |     for i in 10..0 {\n    |              ^^^^^\n@@ -11,17 +11,17 @@ LL |     for i in (0..10).rev() {\n    |              ^^^^^^^^^^^^^\n \n error: this range is empty so this for loop will never run\n-  --> $DIR/for_loop.rs:43:14\n+  --> $DIR/for_loop_fixable.rs:43:14\n    |\n LL |     for i in 10..=0 {\n    |              ^^^^^^\n help: consider using the following if you are attempting to iterate over this range in reverse\n    |\n-LL |     for i in (0...10).rev() {\n+LL |     for i in (0..=10).rev() {\n    |              ^^^^^^^^^^^^^^\n \n error: this range is empty so this for loop will never run\n-  --> $DIR/for_loop.rs:47:14\n+  --> $DIR/for_loop_fixable.rs:47:14\n    |\n LL |     for i in MAX_LEN..0 {\n    |              ^^^^^^^^^^\n@@ -31,13 +31,7 @@ LL |     for i in (0..MAX_LEN).rev() {\n    |              ^^^^^^^^^^^^^^^^^^\n \n error: this range is empty so this for loop will never run\n-  --> $DIR/for_loop.rs:51:14\n-   |\n-LL |     for i in 5..5 {\n-   |              ^^^^\n-\n-error: this range is empty so this for loop will never run\n-  --> $DIR/for_loop.rs:76:14\n+  --> $DIR/for_loop_fixable.rs:72:14\n    |\n LL |     for i in 10..5 + 4 {\n    |              ^^^^^^^^^\n@@ -47,7 +41,7 @@ LL |     for i in (5 + 4..10).rev() {\n    |              ^^^^^^^^^^^^^^^^^\n \n error: this range is empty so this for loop will never run\n-  --> $DIR/for_loop.rs:80:14\n+  --> $DIR/for_loop_fixable.rs:76:14\n    |\n LL |     for i in (5 + 2)..(3 - 1) {\n    |              ^^^^^^^^^^^^^^^^\n@@ -56,113 +50,87 @@ help: consider using the following if you are attempting to iterate over this ra\n LL |     for i in ((3 - 1)..(5 + 2)).rev() {\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: this range is empty so this for loop will never run\n-  --> $DIR/for_loop.rs:84:14\n-   |\n-LL |     for i in (5 + 2)..(8 - 1) {\n-   |              ^^^^^^^^^^^^^^^^\n-\n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop.rs:106:15\n+  --> $DIR/for_loop_fixable.rs:98:15\n    |\n LL |     for _v in vec.iter() {}\n    |               ^^^^^^^^^^ help: to write this more concisely, try: `&vec`\n    |\n    = note: `-D clippy::explicit-iter-loop` implied by `-D warnings`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop.rs:108:15\n+  --> $DIR/for_loop_fixable.rs:100:15\n    |\n LL |     for _v in vec.iter_mut() {}\n    |               ^^^^^^^^^^^^^^ help: to write this more concisely, try: `&mut vec`\n \n error: it is more concise to loop over containers instead of using explicit iteration methods`\n-  --> $DIR/for_loop.rs:111:15\n+  --> $DIR/for_loop_fixable.rs:103:15\n    |\n LL |     for _v in out_vec.into_iter() {}\n    |               ^^^^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `out_vec`\n    |\n    = note: `-D clippy::explicit-into-iter-loop` implied by `-D warnings`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop.rs:114:15\n+  --> $DIR/for_loop_fixable.rs:106:15\n    |\n LL |     for _v in array.into_iter() {}\n    |               ^^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `&array`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop.rs:119:15\n+  --> $DIR/for_loop_fixable.rs:111:15\n    |\n LL |     for _v in [1, 2, 3].iter() {}\n    |               ^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `&[1, 2, 3]`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop.rs:123:15\n+  --> $DIR/for_loop_fixable.rs:115:15\n    |\n LL |     for _v in [0; 32].iter() {}\n    |               ^^^^^^^^^^^^^^ help: to write this more concisely, try: `&[0; 32]`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop.rs:128:15\n+  --> $DIR/for_loop_fixable.rs:120:15\n    |\n LL |     for _v in ll.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&ll`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop.rs:131:15\n+  --> $DIR/for_loop_fixable.rs:123:15\n    |\n LL |     for _v in vd.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&vd`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop.rs:134:15\n+  --> $DIR/for_loop_fixable.rs:126:15\n    |\n LL |     for _v in bh.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&bh`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop.rs:137:15\n+  --> $DIR/for_loop_fixable.rs:129:15\n    |\n LL |     for _v in hm.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&hm`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop.rs:140:15\n+  --> $DIR/for_loop_fixable.rs:132:15\n    |\n LL |     for _v in bt.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&bt`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop.rs:143:15\n+  --> $DIR/for_loop_fixable.rs:135:15\n    |\n LL |     for _v in hs.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&hs`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop.rs:146:15\n+  --> $DIR/for_loop_fixable.rs:138:15\n    |\n LL |     for _v in bs.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&bs`\n \n-error: you are iterating over `Iterator::next()` which is an Option; this will compile but is probably not what you want\n-  --> $DIR/for_loop.rs:148:15\n-   |\n-LL |     for _v in vec.iter().next() {}\n-   |               ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::iter-next-loop` implied by `-D warnings`\n-\n-error: the loop variable `i` is only used to index `vec`.\n-  --> $DIR/for_loop.rs:281:14\n-   |\n-LL |     for i in ZERO..vec.len() {\n-   |              ^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::needless-range-loop` implied by `-D warnings`\n-help: consider using an iterator\n-   |\n-LL |     for <item> in &vec {\n-   |         ^^^^^^    ^^^^\n-\n-error: aborting due to 22 previous errors\n+error: aborting due to 18 previous errors\n ", "previous_filename": "tests/ui/for_loop.stderr"}, {"sha": "5d94647e0dbfeb34808e3332356f517547c363e8", "filename": "tests/ui/for_loop_unfixable.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ffor_loop_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ffor_loop_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_unfixable.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -0,0 +1,41 @@\n+// Tests from for_loop.rs that don't have suggestions\n+\n+#[warn(\n+    clippy::needless_range_loop,\n+    clippy::explicit_iter_loop,\n+    clippy::explicit_into_iter_loop,\n+    clippy::iter_next_loop,\n+    clippy::reverse_range_loop,\n+    clippy::for_kv_map\n+)]\n+#[allow(\n+    clippy::linkedlist,\n+    clippy::shadow_unrelated,\n+    clippy::unnecessary_mut_passed,\n+    clippy::cognitive_complexity,\n+    clippy::similar_names,\n+    unused,\n+    dead_code\n+)]\n+#[allow(clippy::many_single_char_names, unused_variables, clippy::into_iter_on_array)]\n+fn main() {\n+    for i in 5..5 {\n+        println!(\"{}\", i);\n+    }\n+\n+    let vec = vec![1, 2, 3, 4];\n+\n+    for _v in vec.iter().next() {}\n+\n+    for i in (5 + 2)..(8 - 1) {\n+        println!(\"{}\", i);\n+    }\n+\n+    const ZERO: usize = 0;\n+\n+    for i in ZERO..vec.len() {\n+        if f(&vec[i], &vec[i]) {\n+            panic!(\"at the disco\");\n+        }\n+    }\n+}"}, {"sha": "e88bfffaae6e608dfd8991c413f6b0051f829a33", "filename": "tests/ui/for_loop_unfixable.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ffor_loop_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ffor_loop_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_unfixable.stderr?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -0,0 +1,9 @@\n+error[E0425]: cannot find function `f` in this scope\n+  --> $DIR/for_loop_unfixable.rs:37:12\n+   |\n+LL |         if f(&vec[i], &vec[i]) {\n+   |            ^ help: a local variable with a similar name exists: `i`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "d9c9c2096d97c364f62fb2f686ce7e9b280b3a0c", "filename": "tests/ui/ice-4545.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fice-4545.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fice-4545.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fice-4545.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -0,0 +1,14 @@\n+fn repro() {\n+    trait Foo {\n+        type Bar;\n+    }\n+\n+    #[allow(dead_code)]\n+    struct Baz<T: Foo> {\n+        field: T::Bar,\n+    }\n+}\n+\n+fn main() {\n+    repro();\n+}"}, {"sha": "dd3fc56e98bcf2b668a2c8fe372cedc7ef8f36b2", "filename": "tests/ui/identity_conversion.fixed", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fidentity_conversion.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fidentity_conversion.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fidentity_conversion.fixed?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -0,0 +1,58 @@\n+// run-rustfix\n+\n+#![deny(clippy::identity_conversion)]\n+\n+fn test_generic<T: Copy>(val: T) -> T {\n+    let _ = val;\n+    val\n+}\n+\n+fn test_generic2<T: Copy + Into<i32> + Into<U>, U: From<T>>(val: T) {\n+    // ok\n+    let _: i32 = val.into();\n+    let _: U = val.into();\n+    let _ = U::from(val);\n+}\n+\n+fn test_questionmark() -> Result<(), ()> {\n+    {\n+        let _: i32 = 0i32;\n+        Ok(Ok(()))\n+    }??;\n+    Ok(())\n+}\n+\n+fn test_issue_3913() -> Result<(), std::io::Error> {\n+    use std::fs;\n+    use std::path::Path;\n+\n+    let path = Path::new(\".\");\n+    for _ in fs::read_dir(path)? {}\n+\n+    Ok(())\n+}\n+\n+fn main() {\n+    test_generic(10i32);\n+    test_generic2::<i32, i32>(10i32);\n+    test_questionmark().unwrap();\n+    test_issue_3913().unwrap();\n+\n+    let _: String = \"foo\".into();\n+    let _: String = From::from(\"foo\");\n+    let _ = String::from(\"foo\");\n+    #[allow(clippy::identity_conversion)]\n+    {\n+        let _: String = \"foo\".into();\n+        let _ = String::from(\"foo\");\n+        let _ = \"\".lines().into_iter();\n+    }\n+\n+    let _: String = \"foo\".to_string();\n+    let _: String = \"foo\".to_string();\n+    let _ = \"foo\".to_string();\n+    let _ = format!(\"A: {:04}\", 123);\n+    let _ = \"\".lines();\n+    let _ = vec![1, 2, 3].into_iter();\n+    let _: String = format!(\"Hello {}\", \"world\");\n+}"}, {"sha": "875ed7db373b6000d0ca4c14af50fcbe480aa084", "filename": "tests/ui/identity_conversion.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fidentity_conversion.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n #![deny(clippy::identity_conversion)]\n \n fn test_generic<T: Copy>(val: T) -> T {"}, {"sha": "3cabe53bf2b787cbc11d061a09264d3bc639e018", "filename": "tests/ui/identity_conversion.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fidentity_conversion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fidentity_conversion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fidentity_conversion.stderr?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,65 +1,65 @@\n error: identical conversion\n-  --> $DIR/identity_conversion.rs:4:13\n+  --> $DIR/identity_conversion.rs:6:13\n    |\n LL |     let _ = T::from(val);\n    |             ^^^^^^^^^^^^ help: consider removing `T::from()`: `val`\n    |\n note: lint level defined here\n-  --> $DIR/identity_conversion.rs:1:9\n+  --> $DIR/identity_conversion.rs:3:9\n    |\n LL | #![deny(clippy::identity_conversion)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: identical conversion\n-  --> $DIR/identity_conversion.rs:5:5\n+  --> $DIR/identity_conversion.rs:7:5\n    |\n LL |     val.into()\n    |     ^^^^^^^^^^ help: consider removing `.into()`: `val`\n \n error: identical conversion\n-  --> $DIR/identity_conversion.rs:17:22\n+  --> $DIR/identity_conversion.rs:19:22\n    |\n LL |         let _: i32 = 0i32.into();\n    |                      ^^^^^^^^^^^ help: consider removing `.into()`: `0i32`\n \n error: identical conversion\n-  --> $DIR/identity_conversion.rs:49:21\n+  --> $DIR/identity_conversion.rs:51:21\n    |\n LL |     let _: String = \"foo\".to_string().into();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into()`: `\"foo\".to_string()`\n \n error: identical conversion\n-  --> $DIR/identity_conversion.rs:50:21\n+  --> $DIR/identity_conversion.rs:52:21\n    |\n LL |     let _: String = From::from(\"foo\".to_string());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `From::from()`: `\"foo\".to_string()`\n \n error: identical conversion\n-  --> $DIR/identity_conversion.rs:51:13\n+  --> $DIR/identity_conversion.rs:53:13\n    |\n LL |     let _ = String::from(\"foo\".to_string());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `String::from()`: `\"foo\".to_string()`\n \n error: identical conversion\n-  --> $DIR/identity_conversion.rs:52:13\n+  --> $DIR/identity_conversion.rs:54:13\n    |\n LL |     let _ = String::from(format!(\"A: {:04}\", 123));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `String::from()`: `format!(\"A: {:04}\", 123)`\n \n error: identical conversion\n-  --> $DIR/identity_conversion.rs:53:13\n+  --> $DIR/identity_conversion.rs:55:13\n    |\n LL |     let _ = \"\".lines().into_iter();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into_iter()`: `\"\".lines()`\n \n error: identical conversion\n-  --> $DIR/identity_conversion.rs:54:13\n+  --> $DIR/identity_conversion.rs:56:13\n    |\n LL |     let _ = vec![1, 2, 3].into_iter().into_iter();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into_iter()`: `vec![1, 2, 3].into_iter()`\n \n error: identical conversion\n-  --> $DIR/identity_conversion.rs:55:21\n+  --> $DIR/identity_conversion.rs:57:21\n    |\n LL |     let _: String = format!(\"Hello {}\", \"world\").into();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into()`: `format!(\"Hello {}\", \"world\")`"}, {"sha": "dd42f06664e155f926e85ea49236286bc79a915e", "filename": "tests/ui/implicit_return.fixed", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fimplicit_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fimplicit_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.fixed?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -0,0 +1,102 @@\n+// run-rustfix\n+\n+#![warn(clippy::implicit_return)]\n+#![allow(clippy::needless_return, unused)]\n+\n+fn test_end_of_fn() -> bool {\n+    if true {\n+        // no error!\n+        return true;\n+    }\n+\n+    return true\n+}\n+\n+#[allow(clippy::needless_bool)]\n+fn test_if_block() -> bool {\n+    if true {\n+        return true\n+    } else {\n+        return false\n+    }\n+}\n+\n+#[allow(clippy::match_bool)]\n+#[rustfmt::skip]\n+fn test_match(x: bool) -> bool {\n+    match x {\n+        true => return false,\n+        false => { return true },\n+    }\n+}\n+\n+#[allow(clippy::match_bool, clippy::needless_return)]\n+fn test_match_with_unreachable(x: bool) -> bool {\n+    match x {\n+        true => return false,\n+        false => unreachable!(),\n+    }\n+}\n+\n+#[allow(clippy::never_loop)]\n+fn test_loop() -> bool {\n+    loop {\n+        return true;\n+    }\n+}\n+\n+#[allow(clippy::never_loop)]\n+fn test_loop_with_block() -> bool {\n+    loop {\n+        {\n+            return true;\n+        }\n+    }\n+}\n+\n+#[allow(clippy::never_loop)]\n+fn test_loop_with_nests() -> bool {\n+    loop {\n+        if true {\n+            return true;\n+        } else {\n+            let _ = true;\n+        }\n+    }\n+}\n+\n+#[allow(clippy::redundant_pattern_matching)]\n+fn test_loop_with_if_let() -> bool {\n+    loop {\n+        if let Some(x) = Some(true) {\n+            return x;\n+        }\n+    }\n+}\n+\n+fn test_closure() {\n+    #[rustfmt::skip]\n+    let _ = || { return true };\n+    let _ = || return true;\n+}\n+\n+fn test_panic() -> bool {\n+    panic!()\n+}\n+\n+fn test_return_macro() -> String {\n+    return format!(\"test {}\", \"test\")\n+}\n+\n+fn main() {\n+    let _ = test_end_of_fn();\n+    let _ = test_if_block();\n+    let _ = test_match(true);\n+    let _ = test_match_with_unreachable(true);\n+    let _ = test_loop();\n+    let _ = test_loop_with_block();\n+    let _ = test_loop_with_nests();\n+    let _ = test_loop_with_if_let();\n+    test_closure();\n+    let _ = test_return_macro();\n+}"}, {"sha": "5abbf6a5583ea1f8352daae10d9b21910c7e80ef", "filename": "tests/ui/implicit_return.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,4 +1,7 @@\n+// run-rustfix\n+\n #![warn(clippy::implicit_return)]\n+#![allow(clippy::needless_return, unused)]\n \n fn test_end_of_fn() -> bool {\n     if true {"}, {"sha": "21822344437bcfb15553673a56e7b1fb78fe3632", "filename": "tests/ui/implicit_return.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fimplicit_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fimplicit_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.stderr?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,67 +1,67 @@\n error: missing return statement\n-  --> $DIR/implicit_return.rs:9:5\n+  --> $DIR/implicit_return.rs:12:5\n    |\n LL |     true\n    |     ^^^^ help: add `return` as shown: `return true`\n    |\n    = note: `-D clippy::implicit-return` implied by `-D warnings`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:15:9\n+  --> $DIR/implicit_return.rs:18:9\n    |\n LL |         true\n    |         ^^^^ help: add `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:17:9\n+  --> $DIR/implicit_return.rs:20:9\n    |\n LL |         false\n    |         ^^^^^ help: add `return` as shown: `return false`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:25:17\n+  --> $DIR/implicit_return.rs:28:17\n    |\n LL |         true => false,\n    |                 ^^^^^ help: add `return` as shown: `return false`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:26:20\n+  --> $DIR/implicit_return.rs:29:20\n    |\n LL |         false => { true },\n    |                    ^^^^ help: add `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:41:9\n+  --> $DIR/implicit_return.rs:44:9\n    |\n LL |         break true;\n    |         ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:49:13\n+  --> $DIR/implicit_return.rs:52:13\n    |\n LL |             break true;\n    |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:58:13\n+  --> $DIR/implicit_return.rs:61:13\n    |\n LL |             break true;\n    |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:76:18\n+  --> $DIR/implicit_return.rs:79:18\n    |\n LL |     let _ = || { true };\n    |                  ^^^^ help: add `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:77:16\n+  --> $DIR/implicit_return.rs:80:16\n    |\n LL |     let _ = || true;\n    |                ^^^^ help: add `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:85:5\n+  --> $DIR/implicit_return.rs:88:5\n    |\n LL |     format!(\"test {}\", \"test\")\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add `return` as shown: `return format!(\"test {}\", \"test\")`"}, {"sha": "fe21a71a42c2648f650bf612b37210e3b7e8f59c", "filename": "tests/ui/inline_fn_without_body.fixed", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Finline_fn_without_body.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Finline_fn_without_body.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finline_fn_without_body.fixed?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -0,0 +1,17 @@\n+// run-rustfix\n+\n+#![warn(clippy::inline_fn_without_body)]\n+#![allow(clippy::inline_always)]\n+\n+trait Foo {\n+    fn default_inline();\n+\n+    fn always_inline();\n+\n+    fn never_inline();\n+\n+    #[inline]\n+    fn has_body() {}\n+}\n+\n+fn main() {}"}, {"sha": "50746989466504118e3633aaf79c06fa3dd9ee4e", "filename": "tests/ui/inline_fn_without_body.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finline_fn_without_body.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n #![warn(clippy::inline_fn_without_body)]\n #![allow(clippy::inline_always)]\n "}, {"sha": "32d35e209b01baf52ac56968a94ef8019d98bb4c", "filename": "tests/ui/inline_fn_without_body.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Finline_fn_without_body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Finline_fn_without_body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finline_fn_without_body.stderr?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,5 +1,5 @@\n error: use of `#[inline]` on trait method `default_inline` which has no body\n-  --> $DIR/inline_fn_without_body.rs:5:5\n+  --> $DIR/inline_fn_without_body.rs:7:5\n    |\n LL |       #[inline]\n    |  _____-^^^^^^^^\n@@ -9,15 +9,15 @@ LL | |     fn default_inline();\n    = note: `-D clippy::inline-fn-without-body` implied by `-D warnings`\n \n error: use of `#[inline]` on trait method `always_inline` which has no body\n-  --> $DIR/inline_fn_without_body.rs:8:5\n+  --> $DIR/inline_fn_without_body.rs:10:5\n    |\n LL |       #[inline(always)]\n    |  _____-^^^^^^^^^^^^^^^^\n LL | |     fn always_inline();\n    | |____- help: remove\n \n error: use of `#[inline]` on trait method `never_inline` which has no body\n-  --> $DIR/inline_fn_without_body.rs:11:5\n+  --> $DIR/inline_fn_without_body.rs:13:5\n    |\n LL |       #[inline(never)]\n    |  _____-^^^^^^^^^^^^^^^"}, {"sha": "5a62957cdb47bac38fb98f519002bfcd548dc66e", "filename": "tests/ui/non_copy_const.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnon_copy_const.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,4 +1,3 @@\n-#![feature(const_string_new, const_vec_new)]\n #![allow(clippy::ref_in_deref, dead_code)]\n \n use std::borrow::Cow;"}, {"sha": "2f325f9e3dfd2dadce4f4be555f900b26b33a5b8", "filename": "tests/ui/non_copy_const.stderr", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fnon_copy_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fnon_copy_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnon_copy_const.stderr?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,5 +1,5 @@\n error: a const item should never be interior mutable\n-  --> $DIR/non_copy_const.rs:10:1\n+  --> $DIR/non_copy_const.rs:9:1\n    |\n LL | const ATOMIC: AtomicUsize = AtomicUsize::new(5); //~ ERROR interior mutable\n    | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -9,23 +9,23 @@ LL | const ATOMIC: AtomicUsize = AtomicUsize::new(5); //~ ERROR interior mutable\n    = note: `#[deny(clippy::declare_interior_mutable_const)]` on by default\n \n error: a const item should never be interior mutable\n-  --> $DIR/non_copy_const.rs:11:1\n+  --> $DIR/non_copy_const.rs:10:1\n    |\n LL | const CELL: Cell<usize> = Cell::new(6); //~ ERROR interior mutable\n    | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    | |\n    | help: make this a static item: `static`\n \n error: a const item should never be interior mutable\n-  --> $DIR/non_copy_const.rs:12:1\n+  --> $DIR/non_copy_const.rs:11:1\n    |\n LL | const ATOMIC_TUPLE: ([AtomicUsize; 1], Vec<AtomicUsize>, u8) = ([ATOMIC], Vec::new(), 7);\n    | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    | |\n    | help: make this a static item: `static`\n \n error: a const item should never be interior mutable\n-  --> $DIR/non_copy_const.rs:17:9\n+  --> $DIR/non_copy_const.rs:16:9\n    |\n LL |         const $name: $ty = $e;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n@@ -34,49 +34,49 @@ LL | declare_const!(_ONCE: Once = Once::new()); //~ ERROR interior mutable\n    | ------------------------------------------ in this macro invocation\n \n error: a const item should never be interior mutable\n-  --> $DIR/non_copy_const.rs:41:5\n+  --> $DIR/non_copy_const.rs:40:5\n    |\n LL |     const ATOMIC: AtomicUsize; //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a const item should never be interior mutable\n-  --> $DIR/non_copy_const.rs:45:5\n+  --> $DIR/non_copy_const.rs:44:5\n    |\n LL |     const INPUT: T;\n    |     ^^^^^^^^^^^^^^^\n    |\n help: consider requiring `T` to be `Copy`\n-  --> $DIR/non_copy_const.rs:45:18\n+  --> $DIR/non_copy_const.rs:44:18\n    |\n LL |     const INPUT: T;\n    |                  ^\n \n error: a const item should never be interior mutable\n-  --> $DIR/non_copy_const.rs:48:5\n+  --> $DIR/non_copy_const.rs:47:5\n    |\n LL |     const ASSOC: Self::NonCopyType;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider requiring `<Self as Trait<T>>::NonCopyType` to be `Copy`\n-  --> $DIR/non_copy_const.rs:48:18\n+  --> $DIR/non_copy_const.rs:47:18\n    |\n LL |     const ASSOC: Self::NonCopyType;\n    |                  ^^^^^^^^^^^^^^^^^\n \n error: a const item should never be interior mutable\n-  --> $DIR/non_copy_const.rs:52:5\n+  --> $DIR/non_copy_const.rs:51:5\n    |\n LL |     const AN_INPUT: T = Self::INPUT;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider requiring `T` to be `Copy`\n-  --> $DIR/non_copy_const.rs:52:21\n+  --> $DIR/non_copy_const.rs:51:21\n    |\n LL |     const AN_INPUT: T = Self::INPUT;\n    |                     ^\n \n error: a const item should never be interior mutable\n-  --> $DIR/non_copy_const.rs:17:9\n+  --> $DIR/non_copy_const.rs:16:9\n    |\n LL |         const $name: $ty = $e;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n@@ -85,49 +85,49 @@ LL |     declare_const!(ANOTHER_INPUT: T = Self::INPUT); //~ ERROR interior muta\n    |     ----------------------------------------------- in this macro invocation\n \n error: a const item should never be interior mutable\n-  --> $DIR/non_copy_const.rs:61:5\n+  --> $DIR/non_copy_const.rs:60:5\n    |\n LL |     const SELF_2: Self;\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n help: consider requiring `Self` to be `Copy`\n-  --> $DIR/non_copy_const.rs:61:19\n+  --> $DIR/non_copy_const.rs:60:19\n    |\n LL |     const SELF_2: Self;\n    |                   ^^^^\n \n error: a const item should never be interior mutable\n-  --> $DIR/non_copy_const.rs:82:5\n+  --> $DIR/non_copy_const.rs:81:5\n    |\n LL |     const ASSOC_3: AtomicUsize = AtomicUsize::new(14); //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a const item should never be interior mutable\n-  --> $DIR/non_copy_const.rs:85:5\n+  --> $DIR/non_copy_const.rs:84:5\n    |\n LL |     const U_SELF: U = U::SELF_2;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider requiring `U` to be `Copy`\n-  --> $DIR/non_copy_const.rs:85:19\n+  --> $DIR/non_copy_const.rs:84:19\n    |\n LL |     const U_SELF: U = U::SELF_2;\n    |                   ^\n \n error: a const item should never be interior mutable\n-  --> $DIR/non_copy_const.rs:88:5\n+  --> $DIR/non_copy_const.rs:87:5\n    |\n LL |     const T_ASSOC: T::NonCopyType = T::ASSOC;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider requiring `<T as Trait<u32>>::NonCopyType` to be `Copy`\n-  --> $DIR/non_copy_const.rs:88:20\n+  --> $DIR/non_copy_const.rs:87:20\n    |\n LL |     const T_ASSOC: T::NonCopyType = T::ASSOC;\n    |                    ^^^^^^^^^^^^^^\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:95:5\n+  --> $DIR/non_copy_const.rs:94:5\n    |\n LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^\n@@ -136,119 +136,119 @@ LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:96:16\n+  --> $DIR/non_copy_const.rs:95:16\n    |\n LL |     assert_eq!(ATOMIC.load(Ordering::SeqCst), 5); //~ ERROR interior mutability\n    |                ^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:99:22\n+  --> $DIR/non_copy_const.rs:98:22\n    |\n LL |     let _once_ref = &ONCE_INIT; //~ ERROR interior mutability\n    |                      ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:100:25\n+  --> $DIR/non_copy_const.rs:99:25\n    |\n LL |     let _once_ref_2 = &&ONCE_INIT; //~ ERROR interior mutability\n    |                         ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:101:27\n+  --> $DIR/non_copy_const.rs:100:27\n    |\n LL |     let _once_ref_4 = &&&&ONCE_INIT; //~ ERROR interior mutability\n    |                           ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:102:26\n+  --> $DIR/non_copy_const.rs:101:26\n    |\n LL |     let _once_mut = &mut ONCE_INIT; //~ ERROR interior mutability\n    |                          ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:113:14\n+  --> $DIR/non_copy_const.rs:112:14\n    |\n LL |     let _ = &ATOMIC_TUPLE; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:114:14\n+  --> $DIR/non_copy_const.rs:113:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:115:19\n+  --> $DIR/non_copy_const.rs:114:19\n    |\n LL |     let _ = &(&&&&ATOMIC_TUPLE).0; //~ ERROR interior mutability\n    |                   ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:116:14\n+  --> $DIR/non_copy_const.rs:115:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:117:13\n+  --> $DIR/non_copy_const.rs:116:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0].load(Ordering::SeqCst); //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:123:13\n+  --> $DIR/non_copy_const.rs:122:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:128:5\n+  --> $DIR/non_copy_const.rs:127:5\n    |\n LL |     CELL.set(2); //~ ERROR interior mutability\n    |     ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:129:16\n+  --> $DIR/non_copy_const.rs:128:16\n    |\n LL |     assert_eq!(CELL.get(), 6); //~ ERROR interior mutability\n    |                ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:142:5\n+  --> $DIR/non_copy_const.rs:141:5\n    |\n LL |     u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a const item with interior mutability should not be borrowed\n-  --> $DIR/non_copy_const.rs:143:16\n+  --> $DIR/non_copy_const.rs:142:16\n    |\n LL |     assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n    |                ^^^^^^^^^^^"}, {"sha": "6605c967c8e7e6323d659f0a7c645e0cd59832c2", "filename": "tests/ui/op_ref.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fop_ref.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,6 +1,8 @@\n #![allow(unused_variables, clippy::blacklisted_name)]\n-\n+#![warn(clippy::op_ref)]\n+#![allow(clippy::many_single_char_names)]\n use std::collections::HashSet;\n+use std::ops::BitAnd;\n \n fn main() {\n     let tracked_fds: HashSet<i32> = HashSet::new();\n@@ -18,4 +20,39 @@ fn main() {\n     if b < &a {\n         println!(\"OK\");\n     }\n+\n+    struct X(i32);\n+    impl BitAnd for X {\n+        type Output = X;\n+        fn bitand(self, rhs: X) -> X {\n+            X(self.0 & rhs.0)\n+        }\n+    }\n+    impl<'a> BitAnd<&'a X> for X {\n+        type Output = X;\n+        fn bitand(self, rhs: &'a X) -> X {\n+            X(self.0 & rhs.0)\n+        }\n+    }\n+    let x = X(1);\n+    let y = X(2);\n+    let z = x & &y;\n+\n+    #[derive(Copy, Clone)]\n+    struct Y(i32);\n+    impl BitAnd for Y {\n+        type Output = Y;\n+        fn bitand(self, rhs: Y) -> Y {\n+            Y(self.0 & rhs.0)\n+        }\n+    }\n+    impl<'a> BitAnd<&'a Y> for Y {\n+        type Output = Y;\n+        fn bitand(self, rhs: &'a Y) -> Y {\n+            Y(self.0 & rhs.0)\n+        }\n+    }\n+    let x = Y(1);\n+    let y = Y(2);\n+    let z = x & &y;\n }"}, {"sha": "0f6a45f905c8e15ced40977c9403fb3dbfdc64d6", "filename": "tests/ui/op_ref.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fop_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fop_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fop_ref.stderr?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,5 +1,5 @@\n error: needlessly taken reference of both operands\n-  --> $DIR/op_ref.rs:10:15\n+  --> $DIR/op_ref.rs:12:15\n    |\n LL |     let foo = &5 - &6;\n    |               ^^^^^^^\n@@ -11,12 +11,20 @@ LL |     let foo = 5 - 6;\n    |               ^   ^\n \n error: taken reference of right operand\n-  --> $DIR/op_ref.rs:18:8\n+  --> $DIR/op_ref.rs:20:8\n    |\n LL |     if b < &a {\n    |        ^^^^--\n    |            |\n    |            help: use the right value directly: `a`\n \n-error: aborting due to 2 previous errors\n+error: taken reference of right operand\n+  --> $DIR/op_ref.rs:57:13\n+   |\n+LL |     let z = x & &y;\n+   |             ^^^^--\n+   |                 |\n+   |                 help: use the right value directly: `y`\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "346972b7bb4e0d95e1353040c58c4ed714e8e01b", "filename": "tests/ui/repl_uninit.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Frepl_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Frepl_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frepl_uninit.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -0,0 +1,35 @@\n+#![allow(deprecated, invalid_value)]\n+#![warn(clippy::all)]\n+\n+use std::mem;\n+\n+fn might_panic<X>(x: X) -> X {\n+    // in practice this would be a possibly-panicky operation\n+    x\n+}\n+\n+fn main() {\n+    let mut v = vec![0i32; 4];\n+    // the following is UB if `might_panic` panics\n+    unsafe {\n+        let taken_v = mem::replace(&mut v, mem::uninitialized());\n+        let new_v = might_panic(taken_v);\n+        std::mem::forget(mem::replace(&mut v, new_v));\n+    }\n+\n+    unsafe {\n+        let taken_v = mem::replace(&mut v, mem::zeroed());\n+        let new_v = might_panic(taken_v);\n+        std::mem::forget(mem::replace(&mut v, new_v));\n+    }\n+\n+    // this is silly but OK, because usize is a primitive type\n+    let mut u: usize = 42;\n+    let uref = &mut u;\n+    let taken_u = unsafe { mem::replace(uref, mem::zeroed()) };\n+    *uref = taken_u + 1;\n+\n+    // this is still not OK, because uninit\n+    let taken_u = unsafe { mem::replace(uref, mem::uninitialized()) };\n+    *uref = taken_u + 1;\n+}"}, {"sha": "c1f55d7601e5ccce9592e5653330435d7f114832", "filename": "tests/ui/repl_uninit.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Frepl_uninit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Frepl_uninit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frepl_uninit.stderr?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -0,0 +1,27 @@\n+error: replacing with `mem::uninitialized()`\n+  --> $DIR/repl_uninit.rs:15:23\n+   |\n+LL |         let taken_v = mem::replace(&mut v, mem::uninitialized());\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::mem-replace-with-uninit` implied by `-D warnings`\n+   = help: consider using the `take_mut` crate instead\n+\n+error: replacing with `mem::zeroed()`\n+  --> $DIR/repl_uninit.rs:21:23\n+   |\n+LL |         let taken_v = mem::replace(&mut v, mem::zeroed());\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a default value or the `take_mut` crate instead\n+\n+error: replacing with `mem::uninitialized()`\n+  --> $DIR/repl_uninit.rs:33:28\n+   |\n+LL |     let taken_u = unsafe { mem::replace(uref, mem::uninitialized()) };\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using the `take_mut` crate instead\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "b1622e45f3b36350bf28fff811232c0b2ecce23e", "filename": "tests/ui/types.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ftypes.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ftypes.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypes.fixed?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![allow(dead_code, unused_variables)]\n+#![warn(clippy::all, clippy::pedantic)]\n \n // should not warn on lossy casting in constant types\n // because not supported yet"}, {"sha": "30463f9e2a1739351c098817466aa36c079ee343", "filename": "tests/ui/types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypes.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![allow(dead_code, unused_variables)]\n+#![warn(clippy::all, clippy::pedantic)]\n \n // should not warn on lossy casting in constant types\n // because not supported yet"}, {"sha": "daba766856df59b6d78d5e27055a103edc670937", "filename": "tests/ui/types.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ftypes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Ftypes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypes.stderr?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,5 +1,5 @@\n error: casting i32 to i64 may become silently lossy if you later change the type\n-  --> $DIR/types.rs:13:22\n+  --> $DIR/types.rs:14:22\n    |\n LL |     let c_i64: i64 = c as i64;\n    |                      ^^^^^^^^ help: try: `i64::from(c)`"}, {"sha": "901337885260bdb2d27e06d5c6ae647d0c6768ae", "filename": "tests/ui/use_self.fixed", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.fixed?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -313,3 +313,22 @@ mod rustfix {\n         }\n     }\n }\n+\n+mod issue3567 {\n+    struct TestStruct {}\n+    impl TestStruct {\n+        fn from_something() -> Self {\n+            Self {}\n+        }\n+    }\n+\n+    trait Test {\n+        fn test() -> TestStruct;\n+    }\n+\n+    impl Test for TestStruct {\n+        fn test() -> TestStruct {\n+            Self::from_something()\n+        }\n+    }\n+}"}, {"sha": "e6900b915341e6a7adc8302a1fffdf43af637b02", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -313,3 +313,22 @@ mod rustfix {\n         }\n     }\n }\n+\n+mod issue3567 {\n+    struct TestStruct {}\n+    impl TestStruct {\n+        fn from_something() -> Self {\n+            Self {}\n+        }\n+    }\n+\n+    trait Test {\n+        fn test() -> TestStruct;\n+    }\n+\n+    impl Test for TestStruct {\n+        fn test() -> TestStruct {\n+            TestStruct::from_something()\n+        }\n+    }\n+}"}, {"sha": "d1bfb0e230d897e82384def75d9b060a9f8fe7e4", "filename": "tests/ui/use_self.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.stderr?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -216,5 +216,11 @@ error: unnecessary structure name repetition\n LL |             nested::A {};\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n-error: aborting due to 35 previous errors\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:331:13\n+   |\n+LL |             TestStruct::from_something()\n+   |             ^^^^^^^^^^ help: use the applicable keyword: `Self`\n+\n+error: aborting due to 36 previous errors\n "}, {"sha": "01c861282dcb05e4b446447c0c145c0c2ed88d07", "filename": "tests/ui/wildcard_enum_match_arm.fixed", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fwildcard_enum_match_arm.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fwildcard_enum_match_arm.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.fixed?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -0,0 +1,65 @@\n+// run-rustfix\n+\n+#![deny(clippy::wildcard_enum_match_arm)]\n+#![allow(unreachable_code, unused_variables)]\n+\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+enum Color {\n+    Red,\n+    Green,\n+    Blue,\n+    Rgb(u8, u8, u8),\n+    Cyan,\n+}\n+\n+impl Color {\n+    fn is_monochrome(self) -> bool {\n+        match self {\n+            Color::Red | Color::Green | Color::Blue => true,\n+            Color::Rgb(r, g, b) => r | g == 0 || r | b == 0 || g | b == 0,\n+            Color::Cyan => false,\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let color = Color::Rgb(0, 0, 127);\n+    match color {\n+        Color::Red => println!(\"Red\"),\n+        Color::Green | Color::Blue | Color::Rgb(..) | Color::Cyan => eprintln!(\"Not red\"),\n+    };\n+    match color {\n+        Color::Red => println!(\"Red\"),\n+        _not_red @ Color::Green | _not_red @ Color::Blue | _not_red @ Color::Rgb(..) | _not_red @ Color::Cyan => eprintln!(\"Not red\"),\n+    };\n+    let _str = match color {\n+        Color::Red => \"Red\".to_owned(),\n+        not_red @ Color::Green | not_red @ Color::Blue | not_red @ Color::Rgb(..) | not_red @ Color::Cyan => format!(\"{:?}\", not_red),\n+    };\n+    match color {\n+        Color::Red => {},\n+        Color::Green => {},\n+        Color::Blue => {},\n+        Color::Cyan => {},\n+        c if c.is_monochrome() => {},\n+        Color::Rgb(_, _, _) => {},\n+    };\n+    let _str = match color {\n+        Color::Red => \"Red\",\n+        c @ Color::Green | c @ Color::Blue | c @ Color::Rgb(_, _, _) | c @ Color::Cyan => \"Not red\",\n+    };\n+    match color {\n+        Color::Rgb(r, _, _) if r > 0 => \"Some red\",\n+        Color::Red | Color::Green | Color::Blue | Color::Rgb(..) | Color::Cyan => \"No red\",\n+    };\n+    match color {\n+        Color::Red | Color::Green | Color::Blue | Color::Cyan => {},\n+        Color::Rgb(..) => {},\n+    };\n+    let x: u8 = unimplemented!();\n+    match x {\n+        0 => {},\n+        140 => {},\n+        _ => {},\n+    };\n+}"}, {"sha": "d33c68a6c7dd67a28b233d96d37fc0b70e8fdb89", "filename": "tests/ui/wildcard_enum_match_arm.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fwildcard_enum_match_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fwildcard_enum_match_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.rs?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,4 +1,7 @@\n+// run-rustfix\n+\n #![deny(clippy::wildcard_enum_match_arm)]\n+#![allow(unreachable_code, unused_variables)]\n \n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n enum Color {"}, {"sha": "df90bad15ce12e86b619a30ce7c93513f6b84ee8", "filename": "tests/ui/wildcard_enum_match_arm.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d04bf1511411121cdff4688544dd4d6afa53f7ae/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.stderr?ref=d04bf1511411121cdff4688544dd4d6afa53f7ae", "patch": "@@ -1,29 +1,29 @@\n error: wildcard match will miss any future added variants.\n-  --> $DIR/wildcard_enum_match_arm.rs:26:9\n+  --> $DIR/wildcard_enum_match_arm.rs:29:9\n    |\n LL |         _ => eprintln!(\"Not red\"),\n    |         ^ help: try this: `Color::Green | Color::Blue | Color::Rgb(..) | Color::Cyan`\n    |\n note: lint level defined here\n-  --> $DIR/wildcard_enum_match_arm.rs:1:9\n+  --> $DIR/wildcard_enum_match_arm.rs:3:9\n    |\n LL | #![deny(clippy::wildcard_enum_match_arm)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: wildcard match will miss any future added variants.\n-  --> $DIR/wildcard_enum_match_arm.rs:30:9\n+  --> $DIR/wildcard_enum_match_arm.rs:33:9\n    |\n LL |         _not_red => eprintln!(\"Not red\"),\n    |         ^^^^^^^^ help: try this: `_not_red @ Color::Green | _not_red @ Color::Blue | _not_red @ Color::Rgb(..) | _not_red @ Color::Cyan`\n \n error: wildcard match will miss any future added variants.\n-  --> $DIR/wildcard_enum_match_arm.rs:34:9\n+  --> $DIR/wildcard_enum_match_arm.rs:37:9\n    |\n LL |         not_red => format!(\"{:?}\", not_red),\n    |         ^^^^^^^ help: try this: `not_red @ Color::Green | not_red @ Color::Blue | not_red @ Color::Rgb(..) | not_red @ Color::Cyan`\n \n error: wildcard match will miss any future added variants.\n-  --> $DIR/wildcard_enum_match_arm.rs:50:9\n+  --> $DIR/wildcard_enum_match_arm.rs:53:9\n    |\n LL |         _ => \"No red\",\n    |         ^ help: try this: `Color::Red | Color::Green | Color::Blue | Color::Rgb(..) | Color::Cyan`"}]}