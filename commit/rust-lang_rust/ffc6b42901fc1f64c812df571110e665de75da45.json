{"sha": "ffc6b42901fc1f64c812df571110e665de75da45", "node_id": "C_kwDOAAsO6NoAKGZmYzZiNDI5MDFmYzFmNjRjODEyZGY1NzExMTBlNjY1ZGU3NWRhNDU", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-08-10T10:17:13Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-08-10T10:17:13Z"}, "message": "fix: infer byte string pattern as `&[u8]` when matched against slices", "tree": {"sha": "76c2a39f30c4b2d9f1680a9519119a2dfad5b9ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76c2a39f30c4b2d9f1680a9519119a2dfad5b9ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffc6b42901fc1f64c812df571110e665de75da45", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmLzhc8ACgkQ4laYqTBY\nYXGfchAAs7P03kDbMON3gT5BDEm+tvdcxUlbjR1d1S6Uu9ywi4sQrHOeCF903+Ui\n4XSq4qt/M7N9T87zUNB9a7c8rmKxdIdLwaW2fS1sQViZ5cGRMzaSeOduDshHxrW7\n0UVbyHzdSBfMP147qzvDUxAbiS6tggTfCy7Q1Ce67mcgjuxZ8XAd0q7KGVAL/BCJ\nfsNR2cVivTbKQITCLOXSqyP47BOPh9ZttesTyRk2mNCHWC4yjgIJIr9XdKV2tzKC\npyhRUTxSLcV3hUvNfTK+oKsXg2YnusgCHYHbKuEl4bH3lso8jSO+UF6EV5ROerI8\nlnA30kwUpYP0nUlBq+jADgNoaFEhnr81xGPnCTIy7W7rPAZaWhoFJjMJd85lYWjk\nSFnN+ycSsY3e6LEMIrw1DDsW9Qws15lO1fNgSuE/8hqoFPrkXV0rJaP5uoOUCa7W\naTalZ9afAyuvw9u2GExN8Ph9l6Nkju/LvQ4VSYx7hhWRbJ8o1CkJDePg8h1XvmNg\nMloBQ+OtyYamVMJ9UdhUSsw22jxonEEe80b2iQJjQdPrJgVFYd2BCCp21I3KVPFX\nGT3ZG8tNNBtTVuEW9GntorbDNl4JawvJy2Fj7g/Wo+BlykME3FUH1d0EfF6VyMd1\nrINIALPcVyxU8hWmCwEidGTjKaY7EdmZlI/jXQHCC9dey5PYBXM=\n=bxdn\n-----END PGP SIGNATURE-----", "payload": "tree 76c2a39f30c4b2d9f1680a9519119a2dfad5b9ff\nparent e1e93c44389d822514e89ab4f2f31be30a7126d6\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1660126633 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1660126633 +0900\n\nfix: infer byte string pattern as `&[u8]` when matched against slices\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffc6b42901fc1f64c812df571110e665de75da45", "html_url": "https://github.com/rust-lang/rust/commit/ffc6b42901fc1f64c812df571110e665de75da45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffc6b42901fc1f64c812df571110e665de75da45/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1e93c44389d822514e89ab4f2f31be30a7126d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1e93c44389d822514e89ab4f2f31be30a7126d6", "html_url": "https://github.com/rust-lang/rust/commit/e1e93c44389d822514e89ab4f2f31be30a7126d6"}], "stats": {"total": 78, "additions": 74, "deletions": 4}, "files": [{"sha": "53259d66dec640f91e023674a94e2e8e2e3dedc8", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ffc6b42901fc1f64c812df571110e665de75da45/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc6b42901fc1f64c812df571110e665de75da45/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=ffc6b42901fc1f64c812df571110e665de75da45", "patch": "@@ -14,8 +14,9 @@ use crate::{\n     consteval::intern_const_scalar,\n     infer::{BindingMode, Expectation, InferenceContext, TypeMismatch},\n     lower::lower_to_chalk_mutability,\n-    static_lifetime, ConcreteConst, ConstValue, Interner, Substitution, Ty, TyBuilder, TyExt,\n-    TyKind,\n+    primitive::UintTy,\n+    static_lifetime, ConcreteConst, ConstValue, Interner, Scalar, Substitution, Ty, TyBuilder,\n+    TyExt, TyKind,\n };\n \n use super::PatLike;\n@@ -294,7 +295,29 @@ impl<'a> InferenceContext<'a> {\n                 let start_ty = self.infer_expr(*start, &Expectation::has_type(expected.clone()));\n                 self.infer_expr(*end, &Expectation::has_type(start_ty))\n             }\n-            Pat::Lit(expr) => self.infer_expr(*expr, &Expectation::has_type(expected.clone())),\n+            &Pat::Lit(expr) => {\n+                // FIXME: using `Option` here is a workaround until we can use if-let chains in stable.\n+                let mut pat_ty = None;\n+\n+                // Like slice patterns, byte string patterns can denote both `&[u8; N]` and `&[u8]`.\n+                if let Expr::Literal(Literal::ByteString(_)) = self.body[expr] {\n+                    if let Some((inner, ..)) = expected.as_reference() {\n+                        let inner = self.resolve_ty_shallow(inner);\n+                        if matches!(inner.kind(Interner), TyKind::Slice(_)) {\n+                            let elem_ty = TyKind::Scalar(Scalar::Uint(UintTy::U8)).intern(Interner);\n+                            let slice_ty = TyKind::Slice(elem_ty).intern(Interner);\n+                            let ty = TyKind::Ref(Mutability::Not, static_lifetime(), slice_ty)\n+                                .intern(Interner);\n+                            self.write_expr_ty(expr, ty.clone());\n+                            pat_ty = Some(ty);\n+                        }\n+                    }\n+                }\n+\n+                pat_ty.unwrap_or_else(|| {\n+                    self.infer_expr(expr, &Expectation::has_type(expected.clone()))\n+                })\n+            }\n             Pat::Box { inner } => match self.resolve_boxed_box() {\n                 Some(box_adt) => {\n                     let (inner_ty, alloc_ty) = match expected.as_adt() {\n@@ -343,7 +366,9 @@ fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n         // FIXME: ConstBlock/Path/Lit might actually evaluate to ref, but inference is unimplemented.\n         Pat::Path(..) => true,\n         Pat::ConstBlock(..) => true,\n-        Pat::Lit(expr) => !matches!(body[*expr], Expr::Literal(Literal::String(..))),\n+        Pat::Lit(expr) => {\n+            !matches!(body[*expr], Expr::Literal(Literal::String(..) | Literal::ByteString(..)))\n+        }\n         Pat::Bind {\n             mode: BindingAnnotation::Mutable | BindingAnnotation::Unannotated,\n             subpat: Some(subpat),"}, {"sha": "94efe7bc11a8be577ee80081540ed8123683c558", "filename": "crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ffc6b42901fc1f64c812df571110e665de75da45/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc6b42901fc1f64c812df571110e665de75da45/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=ffc6b42901fc1f64c812df571110e665de75da45", "patch": "@@ -315,6 +315,51 @@ fn infer_pattern_match_string_literal() {\n     );\n }\n \n+#[test]\n+fn infer_pattern_match_byte_string_literal() {\n+    check_infer_with_mismatches(\n+        r#\"\n+        //- minicore: index\n+        struct S;\n+        impl<T, const N: usize> core::ops::Index<S> for [T; N] {\n+            type Output = [u8];\n+            fn index(&self, index: core::ops::RangeFull) -> &Self::Output {\n+                loop {}\n+            }\n+        }\n+        fn test(v: [u8; 3]) {\n+            if let b\"foo\" = &v[S] {}\n+            if let b\"foo\" = &v {}\n+        }\n+        \"#,\n+        expect![[r#\"\n+            105..109 'self': &[T; N]\n+            111..116 'index': {unknown}\n+            157..180 '{     ...     }': &[u8]\n+            167..174 'loop {}': !\n+            172..174 '{}': ()\n+            191..192 'v': [u8; 3]\n+            203..261 '{     ...v {} }': ()\n+            209..233 'if let...[S] {}': ()\n+            212..230 'let b\"... &v[S]': bool\n+            216..222 'b\"foo\"': &[u8]\n+            216..222 'b\"foo\"': &[u8]\n+            225..230 '&v[S]': &[u8]\n+            226..227 'v': [u8; 3]\n+            226..230 'v[S]': [u8]\n+            228..229 'S': S\n+            231..233 '{}': ()\n+            238..259 'if let... &v {}': ()\n+            241..256 'let b\"foo\" = &v': bool\n+            245..251 'b\"foo\"': &[u8; 3]\n+            245..251 'b\"foo\"': &[u8; 3]\n+            254..256 '&v': &[u8; 3]\n+            255..256 'v': [u8; 3]\n+            257..259 '{}': ()\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn infer_pattern_match_or() {\n     check_infer_with_mismatches("}]}