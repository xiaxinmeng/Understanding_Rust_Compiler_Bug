{"sha": "4a589b1c3ab6514c91cbf825228ab31712299b48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNTg5YjFjM2FiNjUxNGM5MWNiZjgyNTIyOGFiMzE3MTIyOTliNDg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-05T11:23:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-05T11:23:12Z"}, "message": "Merge #8326\n\n8326: Rewrite reorder fields assist to use mutable syntax trees r=matklad a=Veykril\n\nThis also instead uses `Either` to use the typed `RecordPat` and `RecordExpr` nodes, this unfortunately gives a bit of code duplication\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "aa18825a061c44f9ad5f8c2d6e0bf639b55620c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa18825a061c44f9ad5f8c2d6e0bf639b55620c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a589b1c3ab6514c91cbf825228ab31712299b48", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgavMgCRBK7hj4Ov3rIwAAdHIIAGeX69rrZO6S5EAMEfXYuvzn\nJCkQKEKNOoqZOnqBgUpGtbJPY+1vlUOyeV9cmziMRd8RDTj2RxrX79ERS4HpmESr\niDPrAX4u+dRtqJZusZV1JxP5tlf+ggFYuz295nQosRN5aFdc7qWDVPpK55xsgFDO\nj4+L3IGZt30PddAMfalgiKGQyp4bSzgc2m4A8lM5YyumgrNzUZQSMeAbZxzTmAWz\nIsHijndEn/iyJlwX+TiYQ1wvGFCrxL6V98HhF8E6gNUZ2bLwvsjM31DEhIvQ/Sy6\nlz2aCYMXRk6stcRep8t2p2XIJrOgDxM4F9UqiwB0JvUr6tJKTUZxIZI51jLMn2c=\n=8yC1\n-----END PGP SIGNATURE-----\n", "payload": "tree aa18825a061c44f9ad5f8c2d6e0bf639b55620c2\nparent 9bf7ca59e9f16ef58adee2ae8fca01d0b6ac5a26\nparent df1320d8c413392860cef554b235b96a9fbad753\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617621792 +0000\ncommitter GitHub <noreply@github.com> 1617621792 +0000\n\nMerge #8326\n\n8326: Rewrite reorder fields assist to use mutable syntax trees r=matklad a=Veykril\n\nThis also instead uses `Either` to use the typed `RecordPat` and `RecordExpr` nodes, this unfortunately gives a bit of code duplication\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a589b1c3ab6514c91cbf825228ab31712299b48", "html_url": "https://github.com/rust-lang/rust/commit/4a589b1c3ab6514c91cbf825228ab31712299b48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a589b1c3ab6514c91cbf825228ab31712299b48/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bf7ca59e9f16ef58adee2ae8fca01d0b6ac5a26", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bf7ca59e9f16ef58adee2ae8fca01d0b6ac5a26", "html_url": "https://github.com/rust-lang/rust/commit/9bf7ca59e9f16ef58adee2ae8fca01d0b6ac5a26"}, {"sha": "df1320d8c413392860cef554b235b96a9fbad753", "url": "https://api.github.com/repos/rust-lang/rust/commits/df1320d8c413392860cef554b235b96a9fbad753", "html_url": "https://github.com/rust-lang/rust/commit/df1320d8c413392860cef554b235b96a9fbad753"}], "stats": {"total": 89, "additions": 50, "deletions": 39}, "files": [{"sha": "1a95135ca1dca8982bf19eff04f0f96c022f0eea", "filename": "crates/ide_assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 50, "deletions": 39, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/4a589b1c3ab6514c91cbf825228ab31712299b48/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a589b1c3ab6514c91cbf825228ab31712299b48/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=4a589b1c3ab6514c91cbf825228ab31712299b48", "patch": "@@ -1,6 +1,8 @@\n+use either::Either;\n+use itertools::Itertools;\n use rustc_hash::FxHashMap;\n \n-use syntax::{algo, ast, match_ast, AstNode, SyntaxKind::*, SyntaxNode};\n+use syntax::{ast, ted, AstNode};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -22,60 +24,70 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n pub(crate) fn reorder_fields(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let record = ctx\n         .find_node_at_offset::<ast::RecordExpr>()\n-        .map(|it| it.syntax().clone())\n-        .or_else(|| ctx.find_node_at_offset::<ast::RecordPat>().map(|it| it.syntax().clone()))?;\n-\n-    let path = record.children().find_map(ast::Path::cast)?;\n+        .map(Either::Left)\n+        .or_else(|| ctx.find_node_at_offset::<ast::RecordPat>().map(Either::Right))?;\n \n+    let path = record.as_ref().either(|it| it.path(), |it| it.path())?;\n     let ranks = compute_fields_ranks(&path, &ctx)?;\n+    let get_rank_of_field =\n+        |of: Option<_>| *ranks.get(&of.unwrap_or_default()).unwrap_or(&usize::MAX);\n \n-    let fields: Vec<SyntaxNode> = {\n-        let field_kind = match record.kind() {\n-            RECORD_EXPR => RECORD_EXPR_FIELD,\n-            RECORD_PAT => RECORD_PAT_FIELD,\n-            _ => {\n-                stdx::never!();\n-                return None;\n-            }\n-        };\n-        record.children().flat_map(|n| n.children()).filter(|n| n.kind() == field_kind).collect()\n+    let field_list = match &record {\n+        Either::Left(it) => Either::Left(it.record_expr_field_list()?),\n+        Either::Right(it) => Either::Right(it.record_pat_field_list()?),\n     };\n-\n-    let sorted_fields = {\n-        let mut fields = fields.clone();\n-        fields.sort_by_key(|node| *ranks.get(&get_field_name(node)).unwrap_or(&usize::max_value()));\n-        fields\n+    let fields = match field_list {\n+        Either::Left(it) => Either::Left((\n+            it.fields()\n+                .sorted_unstable_by_key(|field| {\n+                    get_rank_of_field(field.field_name().map(|it| it.to_string()))\n+                })\n+                .collect::<Vec<_>>(),\n+            it,\n+        )),\n+        Either::Right(it) => Either::Right((\n+            it.fields()\n+                .sorted_unstable_by_key(|field| {\n+                    get_rank_of_field(field.field_name().map(|it| it.to_string()))\n+                })\n+                .collect::<Vec<_>>(),\n+            it,\n+        )),\n     };\n \n-    if sorted_fields == fields {\n+    let is_sorted = fields.as_ref().either(\n+        |(sorted, field_list)| field_list.fields().zip(sorted).all(|(a, b)| a == *b),\n+        |(sorted, field_list)| field_list.fields().zip(sorted).all(|(a, b)| a == *b),\n+    );\n+    if is_sorted {\n         cov_mark::hit!(reorder_sorted_fields);\n         return None;\n     }\n-\n-    let target = record.text_range();\n+    let target = record.as_ref().either(AstNode::syntax, AstNode::syntax).text_range();\n     acc.add(\n         AssistId(\"reorder_fields\", AssistKind::RefactorRewrite),\n         \"Reorder record fields\",\n         target,\n-        |edit| {\n-            let mut rewriter = algo::SyntaxRewriter::default();\n-            for (old, new) in fields.iter().zip(&sorted_fields) {\n-                rewriter.replace(old, new);\n+        |builder| match fields {\n+            Either::Left((sorted, field_list)) => {\n+                replace(builder.make_ast_mut(field_list).fields(), sorted)\n+            }\n+            Either::Right((sorted, field_list)) => {\n+                replace(builder.make_ast_mut(field_list).fields(), sorted)\n             }\n-            edit.rewrite(rewriter);\n         },\n     )\n }\n \n-fn get_field_name(node: &SyntaxNode) -> String {\n-    let res = match_ast! {\n-        match node {\n-            ast::RecordExprField(field) => field.field_name().map(|it| it.to_string()),\n-            ast::RecordPatField(field) => field.field_name().map(|it| it.to_string()),\n-            _ => None,\n-        }\n-    };\n-    res.unwrap_or_default()\n+fn replace<T: AstNode + PartialEq>(\n+    fields: impl Iterator<Item = T>,\n+    sorted_fields: impl IntoIterator<Item = T>,\n+) {\n+    fields.zip(sorted_fields).filter(|(field, sorted)| field != sorted).for_each(\n+        |(field, sorted_field)| {\n+            ted::replace(field.syntax(), sorted_field.syntax().clone_for_update());\n+        },\n+    );\n }\n \n fn compute_fields_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<FxHashMap<String, usize>> {\n@@ -86,7 +98,7 @@ fn compute_fields_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<FxHashM\n \n     let res = strukt\n         .fields(ctx.db())\n-        .iter()\n+        .into_iter()\n         .enumerate()\n         .map(|(idx, field)| (field.name(ctx.db()).to_string(), idx))\n         .collect();\n@@ -137,7 +149,6 @@ const test: Foo = Foo { foo: 1, bar: 0 };\n \"#,\n         )\n     }\n-\n     #[test]\n     fn reorder_struct_pattern() {\n         check_assist("}]}