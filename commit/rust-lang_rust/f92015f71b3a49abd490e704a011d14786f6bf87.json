{"sha": "f92015f71b3a49abd490e704a011d14786f6bf87", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MjAxNWY3MWIzYTQ5YWJkNDkwZTcwNGEwMTFkMTQ3ODZmNmJmODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-21T17:30:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-21T17:30:57Z"}, "message": "auto merge of #16499 : cmr/rust/struct-undef-repr, r=pcwalton\n\nr? @pcwalton", "tree": {"sha": "11b1e392547013ab52c249d511d3c0a3ae8180e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11b1e392547013ab52c249d511d3c0a3ae8180e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f92015f71b3a49abd490e704a011d14786f6bf87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f92015f71b3a49abd490e704a011d14786f6bf87", "html_url": "https://github.com/rust-lang/rust/commit/f92015f71b3a49abd490e704a011d14786f6bf87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f92015f71b3a49abd490e704a011d14786f6bf87/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4444aec1423b2f9431f30e1dc121d239c16ed71c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4444aec1423b2f9431f30e1dc121d239c16ed71c", "html_url": "https://github.com/rust-lang/rust/commit/4444aec1423b2f9431f30e1dc121d239c16ed71c"}, {"sha": "01d2efaffe421b21f17dc7bd736d249fa1abbb0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/01d2efaffe421b21f17dc7bd736d249fa1abbb0e", "html_url": "https://github.com/rust-lang/rust/commit/01d2efaffe421b21f17dc7bd736d249fa1abbb0e"}], "stats": {"total": 724, "additions": 505, "deletions": 219}, "files": [{"sha": "0ded9db3ad08b4aea9c0c81951c4e1068f5e9548", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -263,12 +263,13 @@ Rust code:\n \n ~~~~no_run\n \n+#[repr(C)]\n struct RustObject {\n     a: i32,\n     // other members\n }\n \n-extern fn callback(target: *mut RustObject, a:i32) {\n+extern \"C\" fn callback(target: *mut RustObject, a:i32) {\n     println!(\"I'm called from C with value {0}\", a);\n     unsafe {\n         // Update the value in RustObject with the value received from the callback\n@@ -506,16 +507,16 @@ to define a block for all windows systems, not just x86 ones.\n \n # Interoperability with foreign code\n \n-Rust guarantees that the layout of a `struct` is compatible with the platform's representation in C.\n-A `#[packed]` attribute is available, which will lay out the struct members without padding.\n-However, there are currently no guarantees about the layout of an `enum`.\n+Rust guarantees that the layout of a `struct` is compatible with the platform's representation in C\n+only if the `#[repr(C)]` attribute is applied to it.  `#[repr(C, packed)]` can be used to lay out\n+struct members without padding.  `#[repr(C)]` can also be applied to an enum.\n \n-Rust's owned and managed boxes use non-nullable pointers as handles which point to the contained\n+Rust's owned boxes (`Box<T>`) use non-nullable pointers as handles which point to the contained\n object. However, they should not be manually created because they are managed by internal\n-allocators. References can safely be assumed to be non-nullable pointers directly to the\n-type. However, breaking the borrow checking or mutability rules is not guaranteed to be safe, so\n-prefer using raw pointers (`*`) if that's needed because the compiler can't make as many assumptions\n-about them.\n+allocators. References can safely be assumed to be non-nullable pointers directly to the type.\n+However, breaking the borrow checking or mutability rules is not guaranteed to be safe, so prefer\n+using raw pointers (`*`) if that's needed because the compiler can't make as many assumptions about\n+them.\n \n Vectors and strings share the same basic memory layout, and utilities are available in the `vec` and\n `str` modules for working with C APIs. However, strings are not terminated with `\\0`. If you need a"}, {"sha": "4bbcba6c2f30073cd0456e526ac852fb7d50c2dc", "filename": "src/doc/rust.md", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -1308,6 +1308,9 @@ struct Cookie;\n let c = [Cookie, Cookie, Cookie, Cookie];\n ~~~~\n \n+The precise memory layout of a structure is not specified. One can specify a\n+particular layout using the [`repr` attribute](#ffi-attributes).\n+\n By using the `struct_inherit` feature gate, structures may use single inheritance. A Structure may only\n inherit from a single other structure, called the _super-struct_. The inheriting structure (sub-struct)\n acts as if all fields in the super-struct were present in the sub-struct. Fields declared in a sub-struct\n@@ -1941,6 +1944,23 @@ interpreted:\n - `linkage` - on a static, this specifies the [linkage\n   type](http://llvm.org/docs/LangRef.html#linkage-types).\n \n+On `enum`s:\n+\n+- `repr` - on C-like enums, this sets the underlying type used for\n+  representation. Takes one argument, which is the primitive\n+  type this enum should be represented for, or `C`, which specifies that it\n+  should be the default `enum` size of the C ABI for that platform. Note that\n+  enum representation in C is undefined, and this may be incorrect when the C\n+  code is compiled with certain flags.\n+\n+On `struct`s:\n+\n+- `repr` - specifies the representation to use for this struct. Takes a list\n+  of options. The currently accepted ones are `C` and `packed`, which may be\n+  combined. `C` will use a C ABI comptible struct layout, and `packed` will\n+  remove any padding between fields (note that this is very fragile and may\n+  break platforms which require aligned access).\n+\n ### Miscellaneous attributes\n \n - `export_name` - on statics and functions, this determines the name of the\n@@ -1958,12 +1978,6 @@ interpreted:\n   crate at compile-time and use any syntax extensions or lints that the crate\n   defines. They can both be specified, `#[phase(link, plugin)]` to use a crate\n   both at runtime and compiletime.\n-- `repr` - on C-like enums, this sets the underlying type used for\n-  representation. Useful for FFI. Takes one argument, which is the primitive\n-  type this enum should be represented for, or `C`, which specifies that it\n-  should be the default `enum` size of the C ABI for that platform. Note that\n-  enum representation in C is undefined, and this may be incorrect when the C\n-  code is compiled with certain flags.\n - `simd` - on certain tuple structs, derive the arithmetic operators, which\n   lower to the target's SIMD instructions, if any; the `simd` feature gate\n   is necessary to use this attribute."}, {"sha": "42418ccbc1a6fad0b11e4498a703752529c830fb", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -40,6 +40,7 @@\n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n@@ -48,22 +49,26 @@ pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n                  pub i16, pub i16, pub i16, pub i16);\n \n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n \n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct i64x2(pub i64, pub i64);\n \n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n@@ -72,25 +77,30 @@ pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n                  pub u16, pub u16, pub u16, pub u16);\n \n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n \n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct u64x2(pub u64, pub u64);\n \n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n \n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct f64x2(pub f64, pub f64);"}, {"sha": "64537ea12d983ec58c3a041f54c4f8c771fa8e65", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -15,6 +15,7 @@ use std::rt::stack;\n use std::raw;\n #[cfg(target_arch = \"x86_64\")]\n use std::simd;\n+use libc;\n \n // FIXME #7761: Registers is boxed so that it is 16-byte aligned, for storing\n // SSE regs.  It would be marginally better not to do this. In C++ we\n@@ -69,7 +70,7 @@ impl Context {\n         // overflow). Additionally, their coroutine stacks are listed as being\n         // zero-length, so that's how we detect what's what here.\n         let stack_base: *const uint = stack.start();\n-        let bounds = if sp as uint == stack_base as uint {\n+        let bounds = if sp as libc::uintptr_t == stack_base as libc::uintptr_t {\n             None\n         } else {\n             Some((stack_base as uint, sp as uint))\n@@ -166,7 +167,7 @@ fn new_regs() -> Box<Registers> {\n #[cfg(target_arch = \"x86\")]\n fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n                          procedure: raw::Procedure, sp: *mut uint) {\n-\n+    let sp = sp as *mut uint;\n     // x86 has interesting stack alignment requirements, so do some alignment\n     // plus some offsetting to figure out what the actual stack should be.\n     let sp = align_down(sp);\n@@ -188,13 +189,15 @@ fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n // windows requires saving more registers (both general and XMM), so the windows\n // register context must be larger.\n #[cfg(windows, target_arch = \"x86_64\")]\n+#[repr(C)]\n struct Registers {\n-    gpr:[uint, ..14],\n+    gpr:[libc::uintptr_t, ..14],\n     _xmm:[simd::u32x4, ..10]\n }\n #[cfg(not(windows), target_arch = \"x86_64\")]\n+#[repr(C)]\n struct Registers {\n-    gpr:[uint, ..10],\n+    gpr:[libc::uintptr_t, ..10],\n     _xmm:[simd::u32x4, ..6]\n }\n \n@@ -234,30 +237,30 @@ fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n     unsafe { *sp = 0; }\n \n     rtdebug!(\"creating call frame\");\n-    rtdebug!(\"fptr {:#x}\", fptr as uint);\n+    rtdebug!(\"fptr {:#x}\", fptr as libc::uintptr_t);\n     rtdebug!(\"arg {:#x}\", arg);\n     rtdebug!(\"sp {}\", sp);\n \n     // These registers are frobbed by rust_bootstrap_green_task into the right\n     // location so we can invoke the \"real init function\", `fptr`.\n-    regs.gpr[RUSTRT_R12] = arg as uint;\n-    regs.gpr[RUSTRT_R13] = procedure.code as uint;\n-    regs.gpr[RUSTRT_R14] = procedure.env as uint;\n-    regs.gpr[RUSTRT_R15] = fptr as uint;\n+    regs.gpr[RUSTRT_R12] = arg as libc::uintptr_t;\n+    regs.gpr[RUSTRT_R13] = procedure.code as libc::uintptr_t;\n+    regs.gpr[RUSTRT_R14] = procedure.env as libc::uintptr_t;\n+    regs.gpr[RUSTRT_R15] = fptr as libc::uintptr_t;\n \n     // These registers are picked up by the regular context switch paths. These\n     // will put us in \"mostly the right context\" except for frobbing all the\n     // arguments to the right place. We have the small trampoline code inside of\n     // rust_bootstrap_green_task to do that.\n-    regs.gpr[RUSTRT_RSP] = sp as uint;\n-    regs.gpr[RUSTRT_IP] = rust_bootstrap_green_task as uint;\n+    regs.gpr[RUSTRT_RSP] = sp as libc::uintptr_t;\n+    regs.gpr[RUSTRT_IP] = rust_bootstrap_green_task as libc::uintptr_t;\n \n     // Last base pointer on the stack should be 0\n     regs.gpr[RUSTRT_RBP] = 0;\n }\n \n #[cfg(target_arch = \"arm\")]\n-type Registers = [uint, ..32];\n+type Registers = [libc::uintptr_t, ..32];\n \n #[cfg(target_arch = \"arm\")]\n fn new_regs() -> Box<Registers> { box {[0, .. 32]} }\n@@ -277,17 +280,17 @@ fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n     // ARM uses the same technique as x86_64 to have a landing pad for the start\n     // of all new green tasks. Neither r1/r2 are saved on a context switch, so\n     // the shim will copy r3/r4 into r1/r2 and then execute the function in r5\n-    regs[0] = arg as uint;              // r0\n-    regs[3] = procedure.code as uint;   // r3\n-    regs[4] = procedure.env as uint;    // r4\n-    regs[5] = fptr as uint;             // r5\n-    regs[13] = sp as uint;                          // #52 sp, r13\n-    regs[14] = rust_bootstrap_green_task as uint;   // #56 pc, r14 --> lr\n+    regs[0] = arg as libc::uintptr_t;              // r0\n+    regs[3] = procedure.code as libc::uintptr_t;   // r3\n+    regs[4] = procedure.env as libc::uintptr_t;    // r4\n+    regs[5] = fptr as libc::uintptr_t;             // r5\n+    regs[13] = sp as libc::uintptr_t;                          // #52 sp, r13\n+    regs[14] = rust_bootstrap_green_task as libc::uintptr_t;   // #56 pc, r14 --> lr\n }\n \n #[cfg(target_arch = \"mips\")]\n #[cfg(target_arch = \"mipsel\")]\n-type Registers = [uint, ..32];\n+type Registers = [libc::uintptr_t, ..32];\n \n #[cfg(target_arch = \"mips\")]\n #[cfg(target_arch = \"mipsel\")]\n@@ -304,12 +307,12 @@ fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n     // The final return address. 0 indicates the bottom of the stack\n     unsafe { *sp = 0; }\n \n-    regs[4] = arg as uint;\n-    regs[5] = procedure.code as uint;\n-    regs[6] = procedure.env as uint;\n-    regs[29] = sp as uint;\n-    regs[25] = fptr as uint;\n-    regs[31] = fptr as uint;\n+    regs[4] = arg as libc::uintptr_t;\n+    regs[5] = procedure.code as libc::uintptr_t;\n+    regs[6] = procedure.env as libc::uintptr_t;\n+    regs[29] = sp as libc::uintptr_t;\n+    regs[25] = fptr as libc::uintptr_t;\n+    regs[31] = fptr as libc::uintptr_t;\n }\n \n fn align_down(sp: *mut uint) -> *mut uint {"}, {"sha": "4673e7b3ba2092b318b807fe42f140528ebae3fd", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -68,7 +68,8 @@ impl Stack {\n \n         // FIXME: Using the FFI to call a C macro. Slow\n         stk.valgrind_id = unsafe {\n-            rust_valgrind_stack_register(stk.start(), stk.end())\n+            rust_valgrind_stack_register(stk.start() as *const libc::uintptr_t,\n+                                         stk.end() as *const libc::uintptr_t)\n         };\n         return stk;\n     }"}, {"sha": "859a2bce9728e181e2dae95da4ed27376bcddde1", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 120, "deletions": 18, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -334,6 +334,7 @@ pub mod types {\n                 __variant1,\n                 __variant2,\n             }\n+\n             pub enum FILE {}\n             pub enum fpos_t {}\n         }\n@@ -369,6 +370,7 @@ pub mod types {\n \n                 pub type pthread_t = c_ulong;\n \n+                #[repr(C)]\n                 pub struct glob_t {\n                     pub gl_pathc: size_t,\n                     pub gl_pathv: *mut *mut c_char,\n@@ -381,11 +383,13 @@ pub mod types {\n                     pub __unused5: *mut c_void,\n                 }\n \n+                #[repr(C)]\n                 pub struct timeval {\n                     pub tv_sec: time_t,\n                     pub tv_usec: suseconds_t,\n                 }\n \n+                #[repr(C)]\n                 pub struct timespec {\n                     pub tv_sec: time_t,\n                     pub tv_nsec: c_long,\n@@ -402,42 +406,51 @@ pub mod types {\n                 pub type sa_family_t = u16;\n                 pub type in_port_t = u16;\n                 pub type in_addr_t = u32;\n+                #[repr(C)]\n                 pub struct sockaddr {\n                     pub sa_family: sa_family_t,\n                     pub sa_data: [u8, ..14],\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_storage {\n                     pub ss_family: sa_family_t,\n                     pub __ss_align: i64,\n                     pub __ss_pad2: [u8, ..112],\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_in {\n                     pub sin_family: sa_family_t,\n                     pub sin_port: in_port_t,\n                     pub sin_addr: in_addr,\n                     pub sin_zero: [u8, ..8],\n                 }\n+                #[repr(C)]\n                 pub struct in_addr {\n                     pub s_addr: in_addr_t,\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_in6 {\n                     pub sin6_family: sa_family_t,\n                     pub sin6_port: in_port_t,\n                     pub sin6_flowinfo: u32,\n                     pub sin6_addr: in6_addr,\n                     pub sin6_scope_id: u32,\n                 }\n+                #[repr(C)]\n                 pub struct in6_addr {\n                     pub s6_addr: [u16, ..8]\n                 }\n+                #[repr(C)]\n                 pub struct ip_mreq {\n                     pub imr_multiaddr: in_addr,\n                     pub imr_interface: in_addr,\n                 }\n+                #[repr(C)]\n                 pub struct ip6_mreq {\n                     pub ipv6mr_multiaddr: in6_addr,\n                     pub ipv6mr_interface: c_uint,\n                 }\n+                #[repr(C)]\n                 pub struct addrinfo {\n                     pub ai_flags: c_int,\n                     pub ai_family: c_int,\n@@ -459,6 +472,7 @@ pub mod types {\n \n                     pub ai_next: *mut addrinfo,\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_un {\n                     pub sun_family: sa_family_t,\n                     pub sun_path: [c_char, ..108]\n@@ -493,8 +507,8 @@ pub mod types {\n             pub mod c99 {\n                 pub type c_longlong = i64;\n                 pub type c_ulonglong = u64;\n-                pub type intptr_t = int;\n-                pub type uintptr_t = uint;\n+                pub type intptr_t = i32;\n+                pub type uintptr_t = u32;\n             }\n             #[cfg(target_arch = \"x86\")]\n             #[cfg(target_arch = \"mips\")]\n@@ -533,6 +547,7 @@ pub mod types {\n                 pub type blksize_t = i32;\n                 pub type blkcnt_t = i32;\n \n+                #[repr(C)]\n                 pub struct stat {\n                     pub st_dev: dev_t,\n                     pub __pad1: c_short,\n@@ -556,11 +571,13 @@ pub mod types {\n                     pub __unused5: c_long,\n                 }\n \n+                #[repr(C)]\n                 pub struct utimbuf {\n                     pub actime: time_t,\n                     pub modtime: time_t,\n                 }\n \n+                #[repr(C)]\n                 pub struct pthread_attr_t {\n                     pub __size: [u32, ..9]\n                 }\n@@ -575,6 +592,7 @@ pub mod types {\n                 pub type blksize_t = u32;\n                 pub type blkcnt_t = u32;\n \n+                #[repr(C)]\n                 pub struct stat {\n                     pub st_dev: c_ulonglong,\n                     pub __pad0: [c_uchar, ..4],\n@@ -597,11 +615,13 @@ pub mod types {\n                     pub st_ino: c_ulonglong,\n                 }\n \n+                #[repr(C)]\n                 pub struct utimbuf {\n                     pub actime: time_t,\n                     pub modtime: time_t,\n                 }\n \n+                #[repr(C)]\n                 pub struct pthread_attr_t {\n                     pub __size: [u32, ..9]\n                 }\n@@ -618,6 +638,7 @@ pub mod types {\n                 pub type blksize_t = i32;\n                 pub type blkcnt_t = i32;\n \n+                #[repr(C)]\n                 pub struct stat {\n                     pub st_dev: c_ulong,\n                     pub st_pad1: [c_long, ..3],\n@@ -641,11 +662,13 @@ pub mod types {\n                     pub st_pad5: [c_long, ..14],\n                 }\n \n+                #[repr(C)]\n                 pub struct utimbuf {\n                     pub actime: time_t,\n                     pub modtime: time_t,\n                 }\n \n+                #[repr(C)]\n                 pub struct pthread_attr_t {\n                     pub __size: [u32, ..9]\n                 }\n@@ -679,8 +702,8 @@ pub mod types {\n             pub mod c99 {\n                 pub type c_longlong = i64;\n                 pub type c_ulonglong = u64;\n-                pub type intptr_t = int;\n-                pub type uintptr_t = uint;\n+                pub type intptr_t = i64;\n+                pub type uintptr_t = u64;\n             }\n             pub mod posix88 {\n                 pub type off_t = i64;\n@@ -702,6 +725,7 @@ pub mod types {\n                 pub type nlink_t = u64;\n                 pub type blksize_t = i64;\n                 pub type blkcnt_t = i64;\n+                #[repr(C)]\n                 pub struct stat {\n                     pub st_dev: dev_t,\n                     pub st_ino: ino_t,\n@@ -723,11 +747,13 @@ pub mod types {\n                     pub __unused: [c_long, ..3],\n                 }\n \n+                #[repr(C)]\n                 pub struct utimbuf {\n                     pub actime: time_t,\n                     pub modtime: time_t,\n                 }\n \n+                #[repr(C)]\n                 pub struct pthread_attr_t {\n                     pub __size: [u64, ..7]\n                 }\n@@ -752,6 +778,7 @@ pub mod types {\n \n                 pub type pthread_t = uintptr_t;\n \n+                #[repr(C)]\n                 pub struct glob_t {\n                     pub gl_pathc:  size_t,\n                     pub __unused1: size_t,\n@@ -768,11 +795,13 @@ pub mod types {\n                     pub __unused8: *mut c_void,\n                 }\n \n+                #[repr(C)]\n                 pub struct timeval {\n                     pub tv_sec: time_t,\n                     pub tv_usec: suseconds_t,\n                 }\n \n+                #[repr(C)]\n                 pub struct timespec {\n                     pub tv_sec: time_t,\n                     pub tv_nsec: c_long,\n@@ -789,28 +818,33 @@ pub mod types {\n                 pub type sa_family_t = u8;\n                 pub type in_port_t = u16;\n                 pub type in_addr_t = u32;\n+                #[repr(C)]\n                 pub struct sockaddr {\n                     pub sa_len: u8,\n                     pub sa_family: sa_family_t,\n                     pub sa_data: [u8, ..14],\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_storage {\n                     pub ss_len: u8,\n                     pub ss_family: sa_family_t,\n                     pub __ss_pad1: [u8, ..6],\n                     pub __ss_align: i64,\n                     pub __ss_pad2: [u8, ..112],\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_in {\n                     pub sin_len: u8,\n                     pub sin_family: sa_family_t,\n                     pub sin_port: in_port_t,\n                     pub sin_addr: in_addr,\n                     pub sin_zero: [u8, ..8],\n                 }\n+                #[repr(C)]\n                 pub struct in_addr {\n                     pub s_addr: in_addr_t,\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_in6 {\n                     pub sin6_len: u8,\n                     pub sin6_family: sa_family_t,\n@@ -819,17 +853,21 @@ pub mod types {\n                     pub sin6_addr: in6_addr,\n                     pub sin6_scope_id: u32,\n                 }\n+                #[repr(C)]\n                 pub struct in6_addr {\n                     pub s6_addr: [u16, ..8]\n                 }\n+                #[repr(C)]\n                 pub struct ip_mreq {\n                     pub imr_multiaddr: in_addr,\n                     pub imr_interface: in_addr,\n                 }\n+                #[repr(C)]\n                 pub struct ip6_mreq {\n                     pub ipv6mr_multiaddr: in6_addr,\n                     pub ipv6mr_interface: c_uint,\n                 }\n+                #[repr(C)]\n                 pub struct addrinfo {\n                     pub ai_flags: c_int,\n                     pub ai_family: c_int,\n@@ -840,6 +878,7 @@ pub mod types {\n                     pub ai_addr: *mut sockaddr,\n                     pub ai_next: *mut addrinfo,\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_un {\n                     pub sun_len: u8,\n                     pub sun_family: sa_family_t,\n@@ -872,8 +911,8 @@ pub mod types {\n             pub mod c99 {\n                 pub type c_longlong = i64;\n                 pub type c_ulonglong = u64;\n-                pub type intptr_t = int;\n-                pub type uintptr_t = uint;\n+                pub type intptr_t = i64;\n+                pub type uintptr_t = u64;\n             }\n             pub mod posix88 {\n                 pub type off_t = i64;\n@@ -898,6 +937,7 @@ pub mod types {\n                 pub type blksize_t = i64;\n                 pub type blkcnt_t = i64;\n                 pub type fflags_t = u32;\n+                #[repr(C)]\n                 pub struct stat {\n                     pub st_dev: dev_t,\n                     pub st_ino: ino_t,\n@@ -923,6 +963,7 @@ pub mod types {\n                     pub __unused: [uint8_t, ..2],\n                 }\n \n+                #[repr(C)]\n                 pub struct utimbuf {\n                     pub actime: time_t,\n                     pub modtime: time_t,\n@@ -950,6 +991,7 @@ pub mod types {\n \n                 pub type pthread_t = uintptr_t;\n \n+                #[repr(C)]\n                 pub struct glob_t {\n                     pub gl_pathc:  size_t,\n                     pub __unused1: size_t,\n@@ -966,11 +1008,13 @@ pub mod types {\n                     pub __unused8: *mut c_void,\n                 }\n \n+                #[repr(C)]\n                 pub struct timeval {\n                     pub tv_sec: time_t,\n                     pub tv_usec: suseconds_t,\n                 }\n \n+                #[repr(C)]\n                 pub struct timespec {\n                     pub tv_sec: time_t,\n                     pub tv_nsec: c_long,\n@@ -987,28 +1031,33 @@ pub mod types {\n                 pub type sa_family_t = u8;\n                 pub type in_port_t = u16;\n                 pub type in_addr_t = u32;\n+                #[repr(C)]\n                 pub struct sockaddr {\n                     pub sa_len: u8,\n                     pub sa_family: sa_family_t,\n                     pub sa_data: [u8, ..14],\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_storage {\n                     pub ss_len: u8,\n                     pub ss_family: sa_family_t,\n                     pub __ss_pad1: [u8, ..6],\n                     pub __ss_align: i64,\n                     pub __ss_pad2: [u8, ..112],\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_in {\n                     pub sin_len: u8,\n                     pub sin_family: sa_family_t,\n                     pub sin_port: in_port_t,\n                     pub sin_addr: in_addr,\n                     pub sin_zero: [u8, ..8],\n                 }\n+                #[repr(C)]\n                 pub struct in_addr {\n                     pub s_addr: in_addr_t,\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_in6 {\n                     pub sin6_len: u8,\n                     pub sin6_family: sa_family_t,\n@@ -1017,17 +1066,21 @@ pub mod types {\n                     pub sin6_addr: in6_addr,\n                     pub sin6_scope_id: u32,\n                 }\n+                #[repr(C)]\n                 pub struct in6_addr {\n                     pub s6_addr: [u16, ..8]\n                 }\n+                #[repr(C)]\n                 pub struct ip_mreq {\n                     pub imr_multiaddr: in_addr,\n                     pub imr_interface: in_addr,\n                 }\n+                #[repr(C)]\n                 pub struct ip6_mreq {\n                     pub ipv6mr_multiaddr: in6_addr,\n                     pub ipv6mr_interface: c_uint,\n                 }\n+                #[repr(C)]\n                 pub struct addrinfo {\n                     pub ai_flags: c_int,\n                     pub ai_family: c_int,\n@@ -1038,6 +1091,7 @@ pub mod types {\n                     pub ai_addr: *mut sockaddr,\n                     pub ai_next: *mut addrinfo,\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_un {\n                     pub sun_len: u8,\n                     pub sun_family: sa_family_t,\n@@ -1070,8 +1124,8 @@ pub mod types {\n             pub mod c99 {\n                 pub type c_longlong = i64;\n                 pub type c_ulonglong = u64;\n-                pub type intptr_t = int;\n-                pub type uintptr_t = uint;\n+                pub type intptr_t = i64;\n+                pub type uintptr_t = u64;\n             }\n             pub mod posix88 {\n                 pub type off_t = i64;\n@@ -1098,6 +1152,7 @@ pub mod types {\n                 pub type blkcnt_t = i64;\n                 pub type fflags_t = u32;\n \n+                #[repr(C)]\n                 pub struct stat {\n                     pub st_ino: ino_t,\n                     pub st_nlink: nlink_t,\n@@ -1122,6 +1177,7 @@ pub mod types {\n                     pub st_qspare1: int64_t,\n                     pub st_qspare2: int64_t,\n                 }\n+                #[repr(C)]\n                 pub struct utimbuf {\n                     pub actime: time_t,\n                     pub modtime: time_t,\n@@ -1149,6 +1205,7 @@ pub mod types {\n \n                 // pub Note: this is the struct called stat64 in win32. Not stat,\n                 // nor stati64.\n+                #[repr(C)]\n                 pub struct stat {\n                     pub st_dev: dev_t,\n                     pub st_ino: ino_t,\n@@ -1164,16 +1221,19 @@ pub mod types {\n                 }\n \n                 // note that this is called utimbuf64 in win32\n+                #[repr(C)]\n                 pub struct utimbuf {\n                     pub actime: time64_t,\n                     pub modtime: time64_t,\n                 }\n \n+                #[repr(C)]\n                 pub struct timeval {\n                     pub tv_sec: c_long,\n                     pub tv_usec: c_long,\n                 }\n \n+                #[repr(C)]\n                 pub struct timespec {\n                     pub tv_sec: time_t,\n                     pub tv_nsec: c_long,\n@@ -1184,49 +1244,59 @@ pub mod types {\n \n             pub mod bsd44 {\n                 use types::os::arch::c95::{c_char, c_int, c_uint, size_t};\n+                use types::os::arch::c99::uintptr_t;\n \n-                pub type SOCKET = uint;\n+                pub type SOCKET = uintptr_t;\n                 pub type socklen_t = c_int;\n                 pub type sa_family_t = u16;\n                 pub type in_port_t = u16;\n                 pub type in_addr_t = u32;\n+                #[repr(C)]\n                 pub struct sockaddr {\n                     pub sa_family: sa_family_t,\n                     pub sa_data: [u8, ..14],\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_storage {\n                     pub ss_family: sa_family_t,\n                     pub __ss_pad1: [u8, ..6],\n                     pub __ss_align: i64,\n                     pub __ss_pad2: [u8, ..112],\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_in {\n                     pub sin_family: sa_family_t,\n                     pub sin_port: in_port_t,\n                     pub sin_addr: in_addr,\n                     pub sin_zero: [u8, ..8],\n                 }\n+                #[repr(C)]\n                 pub struct in_addr {\n                     pub s_addr: in_addr_t,\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_in6 {\n                     pub sin6_family: sa_family_t,\n                     pub sin6_port: in_port_t,\n                     pub sin6_flowinfo: u32,\n                     pub sin6_addr: in6_addr,\n                     pub sin6_scope_id: u32,\n                 }\n+                #[repr(C)]\n                 pub struct in6_addr {\n                     pub s6_addr: [u16, ..8]\n                 }\n+                #[repr(C)]\n                 pub struct ip_mreq {\n                     pub imr_multiaddr: in_addr,\n                     pub imr_interface: in_addr,\n                 }\n+                #[repr(C)]\n                 pub struct ip6_mreq {\n                     pub ipv6mr_multiaddr: in6_addr,\n                     pub ipv6mr_interface: c_uint,\n                 }\n+                #[repr(C)]\n                 pub struct addrinfo {\n                     pub ai_flags: c_int,\n                     pub ai_family: c_int,\n@@ -1237,6 +1307,7 @@ pub mod types {\n                     pub ai_addr: *mut sockaddr,\n                     pub ai_next: *mut addrinfo,\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_un {\n                     pub sun_family: sa_family_t,\n                     pub sun_path: [c_char, ..108]\n@@ -1286,8 +1357,8 @@ pub mod types {\n             pub mod c99 {\n                 pub type c_longlong = i64;\n                 pub type c_ulonglong = u64;\n-                pub type intptr_t = int;\n-                pub type uintptr_t = uint;\n+                pub type intptr_t = i32;\n+                pub type uintptr_t = u32;\n             }\n \n             pub mod posix88 {\n@@ -1319,7 +1390,7 @@ pub mod types {\n                 use types::os::arch::c95::{c_char, c_int, c_uint, size_t};\n                 use types::os::arch::c95::{c_long, c_ulong};\n                 use types::os::arch::c95::{wchar_t};\n-                use types::os::arch::c99::{c_ulonglong, c_longlong};\n+                use types::os::arch::c99::{c_ulonglong, c_longlong, uintptr_t};\n \n                 pub type BOOL = c_int;\n                 pub type BYTE = u8;\n@@ -1353,6 +1424,7 @@ pub mod types {\n                 pub type LPWCH = *mut WCHAR;\n                 pub type LPCH = *mut CHAR;\n \n+                #[repr(C)]\n                 pub struct SECURITY_ATTRIBUTES {\n                     pub nLength: DWORD,\n                     pub lpSecurityDescriptor: LPVOID,\n@@ -1376,6 +1448,7 @@ pub mod types {\n                 pub type time64_t = i64;\n                 pub type int64 = i64;\n \n+                #[repr(C)]\n                 pub struct STARTUPINFO {\n                     pub cb: DWORD,\n                     pub lpReserved: LPWSTR,\n@@ -1398,6 +1471,7 @@ pub mod types {\n                 }\n                 pub type LPSTARTUPINFO = *mut STARTUPINFO;\n \n+                #[repr(C)]\n                 pub struct PROCESS_INFORMATION {\n                     pub hProcess: HANDLE,\n                     pub hThread: HANDLE,\n@@ -1406,13 +1480,14 @@ pub mod types {\n                 }\n                 pub type LPPROCESS_INFORMATION = *mut PROCESS_INFORMATION;\n \n+                #[repr(C)]\n                 pub struct SYSTEM_INFO {\n                     pub wProcessorArchitecture: WORD,\n                     pub wReserved: WORD,\n                     pub dwPageSize: DWORD,\n                     pub lpMinimumApplicationAddress: LPVOID,\n                     pub lpMaximumApplicationAddress: LPVOID,\n-                    pub dwActiveProcessorMask: uint,\n+                    pub dwActiveProcessorMask: uintptr_t,\n                     pub dwNumberOfProcessors: DWORD,\n                     pub dwProcessorType: DWORD,\n                     pub dwAllocationGranularity: DWORD,\n@@ -1421,6 +1496,7 @@ pub mod types {\n                 }\n                 pub type LPSYSTEM_INFO = *mut SYSTEM_INFO;\n \n+                #[repr(C)]\n                 pub struct MEMORY_BASIC_INFORMATION {\n                     pub BaseAddress: LPVOID,\n                     pub AllocationBase: LPVOID,\n@@ -1432,6 +1508,7 @@ pub mod types {\n                 }\n                 pub type LPMEMORY_BASIC_INFORMATION = *mut MEMORY_BASIC_INFORMATION;\n \n+                #[repr(C)]\n                 pub struct OVERLAPPED {\n                     pub Internal: *mut c_ulong,\n                     pub InternalHigh: *mut c_ulong,\n@@ -1442,27 +1519,31 @@ pub mod types {\n \n                 pub type LPOVERLAPPED = *mut OVERLAPPED;\n \n+                #[repr(C)]\n                 pub struct FILETIME {\n                     pub dwLowDateTime: DWORD,\n                     pub dwHighDateTime: DWORD,\n                 }\n \n                 pub type LPFILETIME = *mut FILETIME;\n \n+                #[repr(C)]\n                 pub struct GUID {\n                     pub Data1: DWORD,\n                     pub Data2: WORD,\n                     pub Data3: WORD,\n                     pub Data4: [BYTE, ..8],\n                 }\n \n+                #[repr(C)]\n                 pub struct WSAPROTOCOLCHAIN {\n                     pub ChainLen: c_int,\n                     pub ChainEntries: [DWORD, ..MAX_PROTOCOL_CHAIN as uint],\n                 }\n \n                 pub type LPWSAPROTOCOLCHAIN = *mut WSAPROTOCOLCHAIN;\n \n+                #[repr(C)]\n                 pub struct WSAPROTOCOL_INFO {\n                     pub dwServiceFlags1: DWORD,\n                     pub dwServiceFlags2: DWORD,\n@@ -1505,6 +1586,7 @@ pub mod types {\n \n                 pub type pthread_t = uintptr_t;\n \n+                #[repr(C)]\n                 pub struct glob_t {\n                     pub gl_pathc:  size_t,\n                     pub __unused1: c_int,\n@@ -1521,11 +1603,13 @@ pub mod types {\n                     pub __unused8: *mut c_void,\n                 }\n \n+                #[repr(C)]\n                 pub struct timeval {\n                     pub tv_sec: time_t,\n                     pub tv_usec: suseconds_t,\n                 }\n \n+                #[repr(C)]\n                 pub struct timespec {\n                     pub tv_sec: time_t,\n                     pub tv_nsec: c_long,\n@@ -1543,28 +1627,33 @@ pub mod types {\n                 pub type sa_family_t = u8;\n                 pub type in_port_t = u16;\n                 pub type in_addr_t = u32;\n+                #[repr(C)]\n                 pub struct sockaddr {\n                     pub sa_len: u8,\n                     pub sa_family: sa_family_t,\n                     pub sa_data: [u8, ..14],\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_storage {\n                     pub ss_len: u8,\n                     pub ss_family: sa_family_t,\n                     pub __ss_pad1: [u8, ..6],\n                     pub __ss_align: i64,\n                     pub __ss_pad2: [u8, ..112],\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_in {\n                     pub sin_len: u8,\n                     pub sin_family: sa_family_t,\n                     pub sin_port: in_port_t,\n                     pub sin_addr: in_addr,\n                     pub sin_zero: [u8, ..8],\n                 }\n+                #[repr(C)]\n                 pub struct in_addr {\n                     pub s_addr: in_addr_t,\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_in6 {\n                     pub sin6_len: u8,\n                     pub sin6_family: sa_family_t,\n@@ -1573,17 +1662,21 @@ pub mod types {\n                     pub sin6_addr: in6_addr,\n                     pub sin6_scope_id: u32,\n                 }\n+                #[repr(C)]\n                 pub struct in6_addr {\n                     pub s6_addr: [u16, ..8]\n                 }\n+                #[repr(C)]\n                 pub struct ip_mreq {\n                     pub imr_multiaddr: in_addr,\n                     pub imr_interface: in_addr,\n                 }\n+                #[repr(C)]\n                 pub struct ip6_mreq {\n                     pub ipv6mr_multiaddr: in6_addr,\n                     pub ipv6mr_interface: c_uint,\n                 }\n+                #[repr(C)]\n                 pub struct addrinfo {\n                     pub ai_flags: c_int,\n                     pub ai_family: c_int,\n@@ -1594,6 +1687,7 @@ pub mod types {\n                     pub ai_addr: *mut sockaddr,\n                     pub ai_next: *mut addrinfo,\n                 }\n+                #[repr(C)]\n                 pub struct sockaddr_un {\n                     pub sun_len: u8,\n                     pub sun_family: sa_family_t,\n@@ -1627,8 +1721,8 @@ pub mod types {\n             pub mod c99 {\n                 pub type c_longlong = i64;\n                 pub type c_ulonglong = u64;\n-                pub type intptr_t = int;\n-                pub type uintptr_t = uint;\n+                pub type intptr_t = i32;\n+                pub type uintptr_t = u32;\n             }\n             pub mod posix88 {\n                 pub type off_t = i64;\n@@ -1651,6 +1745,7 @@ pub mod types {\n                 pub type blksize_t = i64;\n                 pub type blkcnt_t = i32;\n \n+                #[repr(C)]\n                 pub struct stat {\n                     pub st_dev: dev_t,\n                     pub st_mode: mode_t,\n@@ -1676,11 +1771,13 @@ pub mod types {\n                     pub st_qspare: [int64_t, ..2],\n                 }\n \n+                #[repr(C)]\n                 pub struct utimbuf {\n                     pub actime: time_t,\n                     pub modtime: time_t,\n                 }\n \n+                #[repr(C)]\n                 pub struct pthread_attr_t {\n                     pub __sig: c_long,\n                     pub __opaque: [c_char, ..36]\n@@ -1691,6 +1788,7 @@ pub mod types {\n             pub mod bsd44 {\n             }\n             pub mod extra {\n+                #[repr(C)]\n                 pub struct mach_timebase_info {\n                     pub numer: u32,\n                     pub denom: u32,\n@@ -1724,8 +1822,8 @@ pub mod types {\n             pub mod c99 {\n                 pub type c_longlong = i64;\n                 pub type c_ulonglong = u64;\n-                pub type intptr_t = int;\n-                pub type uintptr_t = uint;\n+                pub type intptr_t = i64;\n+                pub type uintptr_t = u64;\n             }\n             pub mod posix88 {\n                 pub type off_t = i64;\n@@ -1749,6 +1847,7 @@ pub mod types {\n                 pub type blksize_t = i64;\n                 pub type blkcnt_t = i32;\n \n+                #[repr(C)]\n                 pub struct stat {\n                     pub st_dev: dev_t,\n                     pub st_mode: mode_t,\n@@ -1774,11 +1873,13 @@ pub mod types {\n                     pub st_qspare: [int64_t, ..2],\n                 }\n \n+                #[repr(C)]\n                 pub struct utimbuf {\n                     pub actime: time_t,\n                     pub modtime: time_t,\n                 }\n \n+                #[repr(C)]\n                 pub struct pthread_attr_t {\n                     pub __sig: c_long,\n                     pub __opaque: [c_char, ..56]\n@@ -1789,6 +1890,7 @@ pub mod types {\n             pub mod bsd44 {\n             }\n             pub mod extra {\n+                #[repr(C)]\n                 pub struct mach_timebase_info {\n                     pub numer: u32,\n                     pub denom: u32,\n@@ -4300,7 +4402,7 @@ pub mod funcs {\n                 pub fn glob(pattern: *const c_char,\n                             flags: c_int,\n                             errfunc: ::Nullable<extern \"C\" fn(epath: *const c_char,\n-                                                              errno: int) -> int>,\n+                                                              errno: c_int) -> int>,\n                             pglob: *mut glob_t);\n                 pub fn globfree(pglob: *mut glob_t);\n             }"}, {"sha": "fa7da1de914b4489a380faac44e0e6c08386221c", "filename": "src/libnative/io/c_unix.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibnative%2Fio%2Fc_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibnative%2Fio%2Fc_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_unix.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -91,6 +91,7 @@ extern {\n mod select {\n     pub static FD_SETSIZE: uint = 1024;\n \n+    #[repr(C)]\n     pub struct fd_set {\n         fds_bits: [i32, ..(FD_SETSIZE / 32)]\n     }\n@@ -106,12 +107,14 @@ mod select {\n #[cfg(target_os = \"linux\")]\n mod select {\n     use std::uint;\n+    use libc;\n \n     pub static FD_SETSIZE: uint = 1024;\n \n+    #[repr(C)]\n     pub struct fd_set {\n         // FIXME: shouldn't this be a c_ulong?\n-        fds_bits: [uint, ..(FD_SETSIZE / uint::BITS)]\n+        fds_bits: [libc::uintptr_t, ..(FD_SETSIZE / uint::BITS)]\n     }\n \n     pub fn fd_set(set: &mut fd_set, fd: i32) {\n@@ -139,6 +142,7 @@ mod signal {\n     // This definition is not as accurate as it could be, {pid, uid, status} is\n     // actually a giant union. Currently we're only interested in these fields,\n     // however.\n+    #[repr(C)]\n     pub struct siginfo {\n         si_signo: libc::c_int,\n         si_errno: libc::c_int,\n@@ -148,17 +152,21 @@ mod signal {\n         pub status: libc::c_int,\n     }\n \n+    #[repr(C)]\n     pub struct sigaction {\n         pub sa_handler: extern fn(libc::c_int),\n         pub sa_mask: sigset_t,\n         pub sa_flags: libc::c_ulong,\n         sa_restorer: *mut libc::c_void,\n     }\n \n+    #[repr(C)]\n     #[cfg(target_word_size = \"32\")]\n     pub struct sigset_t {\n         __val: [libc::c_ulong, ..32],\n     }\n+\n+    #[repr(C)]\n     #[cfg(target_word_size = \"64\")]\n     pub struct sigset_t {\n         __val: [libc::c_ulong, ..16],\n@@ -182,6 +190,7 @@ mod signal {\n     // This definition is not as accurate as it could be, {pid, uid, status} is\n     // actually a giant union. Currently we're only interested in these fields,\n     // however.\n+    #[repr(C)]\n     pub struct siginfo {\n         si_signo: libc::c_int,\n         si_code: libc::c_int,\n@@ -191,6 +200,7 @@ mod signal {\n         pub status: libc::c_int,\n     }\n \n+    #[repr(C)]\n     pub struct sigaction {\n         pub sa_flags: libc::c_uint,\n         pub sa_handler: extern fn(libc::c_int),\n@@ -199,6 +209,7 @@ mod signal {\n         sa_resv: [libc::c_int, ..1],\n     }\n \n+    #[repr(C)]\n     pub struct sigset_t {\n         __val: [libc::c_ulong, ..32],\n     }\n@@ -225,12 +236,14 @@ mod signal {\n     pub type sigset_t = u32;\n     #[cfg(target_os = \"freebsd\")]\n     #[cfg(target_os = \"dragonfly\")]\n+    #[repr(C)]\n     pub struct sigset_t {\n         bits: [u32, ..4],\n     }\n \n     // This structure has more fields, but we're not all that interested in\n     // them.\n+    #[repr(C)]\n     pub struct siginfo {\n         pub si_signo: libc::c_int,\n         pub si_errno: libc::c_int,\n@@ -242,6 +255,7 @@ mod signal {\n \n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"ios\")]\n+    #[repr(C)]\n     pub struct sigaction {\n         pub sa_handler: extern fn(libc::c_int),\n         sa_tramp: *mut libc::c_void,\n@@ -251,6 +265,7 @@ mod signal {\n \n     #[cfg(target_os = \"freebsd\")]\n     #[cfg(target_os = \"dragonfly\")]\n+    #[repr(C)]\n     pub struct sigaction {\n         pub sa_handler: extern fn(libc::c_int),\n         pub sa_flags: libc::c_int,"}, {"sha": "80b4764014673e2901bf155f99985857d4d4ba99", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -27,7 +27,6 @@\n \n use metadata::csearch;\n use middle::def::*;\n-use middle::trans::adt; // for `adt::is_ffi_safe`\n use middle::typeck::astconv::ast_ty_to_ty;\n use middle::typeck::infer;\n use middle::{typeck, ty, def, pat_util, stability};\n@@ -362,12 +361,17 @@ impl LintPass for CTypes {\n                                          \"found rust type `uint` in foreign module, while \\\n                                           libc::c_uint or libc::c_ulong should be used\");\n                         }\n-                        def::DefTy(def_id) => {\n-                            if !adt::is_ffi_safe(cx.tcx, def_id) {\n+                        def::DefTy(..) => {\n+                            let tty = match cx.tcx.ast_ty_to_ty_cache.borrow().find(&ty.id) {\n+                                Some(&ty::atttce_resolved(t)) => t,\n+                                _ => fail!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n+                            };\n+\n+                            if !ty::is_ffi_safe(cx.tcx, tty) {\n                                 cx.span_lint(CTYPES, ty.span,\n-                                             \"found enum type without foreign-function-safe\n+                                             \"found type without foreign-function-safe\n                                              representation annotation in foreign module, consider \\\n-                                             adding a #[repr(...)] attribute to the enumeration\");\n+                                             adding a #[repr(...)] attribute to the type\");\n                             }\n                         }\n                         _ => ()\n@@ -770,9 +774,10 @@ impl LintPass for NonCamelCaseTypes {\n             }\n         }\n \n-        let has_extern_repr = it.attrs.iter().fold(attr::ReprAny, |acc, attr| {\n-            attr::find_repr_attr(cx.tcx.sess.diagnostic(), attr, acc)\n-        }) == attr::ReprExtern;\n+        let has_extern_repr = it.attrs.iter().map(|attr| {\n+            attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr).iter()\n+                .any(|r| r == &attr::ReprExtern)\n+        }).any(|x| x);\n         if has_extern_repr { return }\n \n         match it.node {\n@@ -783,6 +788,7 @@ impl LintPass for NonCamelCaseTypes {\n                 check_case(cx, \"trait\", it.ident, it.span)\n             }\n             ast::ItemEnum(ref enum_definition, _) => {\n+                if has_extern_repr { return }\n                 check_case(cx, \"type\", it.ident, it.span);\n                 for variant in enum_definition.variants.iter() {\n                     check_case(cx, \"variant\", variant.node.name, variant.span);"}, {"sha": "0dfdf455743560f093b0fe77381595a4fbedac6b", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -195,9 +195,10 @@ impl<'a> MarkSymbolVisitor<'a> {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n                     ast::ItemStruct(..) => {\n-                        let has_extern_repr = item.attrs.iter().fold(attr::ReprAny, |acc, attr| {\n-                            attr::find_repr_attr(self.tcx.sess.diagnostic(), attr, acc)\n-                        }) == attr::ReprExtern;\n+                        let has_extern_repr = item.attrs.iter().fold(false, |acc, attr| {\n+                            acc || attr::find_repr_attrs(self.tcx.sess.diagnostic(), attr)\n+                                         .iter().any(|&x| x == attr::ReprExtern)\n+                        });\n \n                         visit::walk_item(self, &*item, MarkSymbolVisitorContext {\n                             struct_has_extern_repr: has_extern_repr,"}, {"sha": "483937edd9f7c1962eb65599bfbb08a577295755", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -46,6 +46,8 @@\n #![allow(unsigned_negate)]\n \n use libc::c_ulonglong;\n+use std::collections::Map;\n+use std::num::Int;\n use std::rc::Rc;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n@@ -178,7 +180,8 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n         }\n         ty::ty_enum(def_id, ref substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n-            let hint = ty::lookup_repr_hint(cx.tcx(), def_id);\n+            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id).as_slice().get(0)\n+                .unwrap_or(&attr::ReprAny);\n \n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n \n@@ -266,36 +269,6 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n     }\n }\n \n-/// Determine, without doing translation, whether an ADT must be FFI-safe.\n-/// For use in lint or similar, where being sound but slightly incomplete is acceptable.\n-pub fn is_ffi_safe(tcx: &ty::ctxt, def_id: ast::DefId) -> bool {\n-    match ty::get(ty::lookup_item_type(tcx, def_id).ty).sty {\n-        ty::ty_enum(def_id, _) => {\n-            let variants = ty::enum_variants(tcx, def_id);\n-            // Univariant => like struct/tuple.\n-            if variants.len() <= 1 {\n-                return true;\n-            }\n-            let hint = ty::lookup_repr_hint(tcx, def_id);\n-            // Appropriate representation explicitly selected?\n-            if hint.is_ffi_safe() {\n-                return true;\n-            }\n-            // Option<Box<T>> and similar are used in FFI.  Rather than try to\n-            // resolve type parameters and recognize this case exactly, this\n-            // overapproximates -- assuming that if a non-C-like enum is being\n-            // used in FFI then the user knows what they're doing.\n-            if variants.iter().any(|vi| !vi.args.is_empty()) {\n-                return true;\n-            }\n-            false\n-        }\n-        // struct, tuple, etc.\n-        // (is this right in the present of typedefs?)\n-        _ => true\n-    }\n-}\n-\n // this should probably all be in ty\n struct Case {\n     discr: Disr,\n@@ -427,6 +400,9 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n         }\n         attr::ReprAny => {\n             attempts = choose_shortest;\n+        },\n+        attr::ReprPacked => {\n+            cx.tcx.sess.bug(\"range_to_inttype: found ReprPacked on an enum\");\n         }\n     }\n     for &ity in attempts.iter() {"}, {"sha": "2b768c811e7158c8bf899948ec13ddb52aa6aa4b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 80, "deletions": 15, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -482,7 +482,7 @@ pub struct t { inner: *const t_opaque }\n \n impl fmt::Show for t {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        \"*t_opaque\".fmt(f)\n+        write!(f, \"{}\", get(*self))\n     }\n }\n \n@@ -791,6 +791,13 @@ pub enum sty {\n     ty_int(ast::IntTy),\n     ty_uint(ast::UintTy),\n     ty_float(ast::FloatTy),\n+    /// Substs here, possibly against intuition, *may* contain `ty_param`s.\n+    /// That is, even after substitution it is possible that there are type\n+    /// variables. This happens when the `ty_enum` corresponds to an enum\n+    /// definition and not a concerete use of it. To get the correct `ty_enum`\n+    /// from the tcx, use the `NodeId` from the `ast::Ty` and look it up in\n+    /// the `ast_ty_to_ty_cache`. This is probably true for `ty_struct` as\n+    /// well.`\n     ty_enum(DefId, Substs),\n     ty_box(t),\n     ty_uniq(t),\n@@ -1981,7 +1988,8 @@ def_type_content_sets!(\n         // ReachesManaged /* see [1] below */  = 0b0000_0100__0000_0000__0000,\n         ReachesMutable                      = 0b0000_1000__0000_0000__0000,\n         ReachesNoSync                       = 0b0001_0000__0000_0000__0000,\n-        ReachesAll                          = 0b0001_1111__0000_0000__0000,\n+        ReachesFfiUnsafe                    = 0b0010_0000__0000_0000__0000,\n+        ReachesAll                          = 0b0011_1111__0000_0000__0000,\n \n         // Things that cause values to *move* rather than *copy*\n         Moves                               = 0b0000_0000__0000_1011__0000,\n@@ -2218,38 +2226,44 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n         cache.insert(ty_id, TC::None);\n \n         let result = match get(ty).sty {\n+            // uint and int are ffi-unsafe\n+            ty_uint(ast::TyU) | ty_int(ast::TyI) => {\n+                TC::ReachesFfiUnsafe\n+            }\n+\n             // Scalar and unique types are sendable, and durable\n             ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n             ty_bare_fn(_) | ty::ty_char | ty_str => {\n                 TC::None\n             }\n \n             ty_closure(ref c) => {\n-                closure_contents(cx, &**c)\n+                closure_contents(cx, &**c) | TC::ReachesFfiUnsafe\n             }\n \n             ty_box(typ) => {\n-                tc_ty(cx, typ, cache).managed_pointer()\n+                tc_ty(cx, typ, cache).managed_pointer() | TC::ReachesFfiUnsafe\n             }\n \n             ty_uniq(typ) => {\n-                match get(typ).sty {\n+                TC::ReachesFfiUnsafe | match get(typ).sty {\n                     ty_str => TC::OwnsOwned,\n                     _ => tc_ty(cx, typ, cache).owned_pointer(),\n                 }\n             }\n \n             ty_trait(box ty::TyTrait { bounds, .. }) => {\n-                object_contents(cx, bounds)\n+                object_contents(cx, bounds) | TC::ReachesFfiUnsafe\n             }\n \n             ty_ptr(ref mt) => {\n                 tc_ty(cx, mt.ty, cache).unsafe_pointer()\n             }\n \n             ty_rptr(r, ref mt) => {\n-                match get(mt.ty).sty {\n+                TC::ReachesFfiUnsafe | match get(mt.ty).sty {\n                     ty_str => borrowed_contents(r, ast::MutImmutable),\n+                    ty_vec(..) => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(r, mt.mutbl)),\n                     _ => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(r, mt.mutbl)),\n                 }\n             }\n@@ -2263,6 +2277,11 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 let mut res =\n                     TypeContents::union(flds.as_slice(),\n                                         |f| tc_mt(cx, f.mt, cache));\n+\n+                if !lookup_repr_hints(cx, did).contains(&attr::ReprExtern) {\n+                    res = res | TC::ReachesFfiUnsafe;\n+                }\n+\n                 if ty::has_dtor(cx, did) {\n                     res = res | TC::OwnsDtor;\n                 }\n@@ -2292,9 +2311,49 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                             tc_ty(cx, *arg_ty, cache)\n                         })\n                     });\n+\n                 if ty::has_dtor(cx, did) {\n                     res = res | TC::OwnsDtor;\n                 }\n+\n+                if variants.len() != 0 {\n+                    let repr_hints = lookup_repr_hints(cx, did);\n+                    if repr_hints.len() > 1 {\n+                        // this is an error later on, but this type isn't safe\n+                        res = res | TC::ReachesFfiUnsafe;\n+                    }\n+\n+                    match repr_hints.as_slice().get(0) {\n+                        Some(h) => if !h.is_ffi_safe() {\n+                            res = res | TC::ReachesFfiUnsafe;\n+                        },\n+                        // ReprAny\n+                        None => {\n+                            res = res | TC::ReachesFfiUnsafe;\n+\n+                            // We allow ReprAny enums if they are eligible for\n+                            // the nullable pointer optimization and the\n+                            // contained type is an `extern fn`\n+\n+                            if variants.len() == 2 {\n+                                let mut data_idx = 0;\n+\n+                                if variants.get(0).args.len() == 0 {\n+                                    data_idx = 1;\n+                                }\n+\n+                                if variants.get(data_idx).args.len() == 1 {\n+                                    match get(*variants.get(data_idx).args.get(0)).sty {\n+                                        ty_bare_fn(..) => { res = res - TC::ReachesFfiUnsafe; }\n+                                        _ => { }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+\n                 apply_lang_items(cx, did, res)\n             }\n \n@@ -2446,6 +2505,10 @@ pub fn type_moves_by_default(cx: &ctxt, ty: t) -> bool {\n     type_contents(cx, ty).moves_by_default(cx)\n }\n \n+pub fn is_ffi_safe(cx: &ctxt, ty: t) -> bool {\n+    !type_contents(cx, ty).intersects(TC::ReachesFfiUnsafe)\n+}\n+\n // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n     fn type_requires(cx: &ctxt, seen: &mut Vec<DefId>,\n@@ -3968,7 +4031,7 @@ pub fn substd_enum_variants(cx: &ctxt,\n                          -> Vec<Rc<VariantInfo>> {\n     enum_variants(cx, id).iter().map(|variant_info| {\n         let substd_args = variant_info.args.iter()\n-            .map(|aty| aty.subst(cx, substs)).collect();\n+            .map(|aty| aty.subst(cx, substs)).collect::<Vec<_>>();\n \n         let substd_ctor_ty = variant_info.ctor_ty.subst(cx, substs);\n \n@@ -4191,24 +4254,26 @@ pub fn has_attr(tcx: &ctxt, did: DefId, attr: &str) -> bool {\n     found\n }\n \n-/// Determine whether an item is annotated with `#[packed]`\n+/// Determine whether an item is annotated with `#[repr(packed)]`\n pub fn lookup_packed(tcx: &ctxt, did: DefId) -> bool {\n-    has_attr(tcx, did, \"packed\")\n+    lookup_repr_hints(tcx, did).contains(&attr::ReprPacked)\n }\n \n /// Determine whether an item is annotated with `#[simd]`\n pub fn lookup_simd(tcx: &ctxt, did: DefId) -> bool {\n     has_attr(tcx, did, \"simd\")\n }\n \n-// Obtain the representation annotation for a definition.\n-pub fn lookup_repr_hint(tcx: &ctxt, did: DefId) -> attr::ReprAttr {\n-    let mut acc = attr::ReprAny;\n+/// Obtain the representation annotation for a struct definition.\n+pub fn lookup_repr_hints(tcx: &ctxt, did: DefId) -> Vec<attr::ReprAttr> {\n+    let mut acc = Vec::new();\n+\n     ty::each_attr(tcx, did, |meta| {\n-        acc = attr::find_repr_attr(tcx.sess.diagnostic(), meta, acc);\n+        acc.extend(attr::find_repr_attrs(tcx.sess.diagnostic(), meta).move_iter());\n         true\n     });\n-    return acc;\n+\n+    acc\n }\n \n // Look up a field ID, whether or not it's local"}, {"sha": "ea17691d17d366bf4d61e37fc62ffdced1ce5f5c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -4217,13 +4217,13 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                     let inh = blank_inherited_fields(ccx);\n                     let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n                     let declty = match hint {\n-                        attr::ReprAny | attr::ReprExtern => ty::mk_int(),\n+                        attr::ReprAny | attr::ReprPacked | attr::ReprExtern => ty::mk_int(),\n                         attr::ReprInt(_, attr::SignedInt(ity)) => {\n                             ty::mk_mach_int(ity)\n                         }\n                         attr::ReprInt(_, attr::UnsignedInt(ity)) => {\n                             ty::mk_mach_uint(ity)\n-                        }\n+                        },\n                     };\n                     check_const_with_ty(&fcx, e.span, &*e, declty);\n                     // check_expr (from check_const pass) doesn't guarantee\n@@ -4262,6 +4262,9 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                             \"discriminant type specified here\");\n                     }\n                 }\n+                attr::ReprPacked => {\n+                    ccx.tcx.sess.bug(\"range_to_inttype: found ReprPacked on an enum\");\n+                }\n             }\n             disr_vals.push(current_disr_val);\n \n@@ -4275,7 +4278,9 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n         return variants;\n     }\n \n-    let hint = ty::lookup_repr_hint(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id });\n+    let hint = *ty::lookup_repr_hints(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n+                    .as_slice().get(0).unwrap_or(&attr::ReprAny);\n+\n     if hint != attr::ReprAny && vs.len() <= 1 {\n         if vs.len() == 1 {\n             span_err!(ccx.tcx.sess, sp, E0083,"}, {"sha": "305c18480f6690911110129febeb7134b644b2cf", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -65,6 +65,7 @@ static HOEDOWN_EXTENSIONS: libc::c_uint =\n \n type hoedown_document = libc::c_void;  // this is opaque to us\n \n+#[repr(C)]\n struct hoedown_renderer {\n     opaque: *mut hoedown_html_renderer_state,\n     blockcode: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n@@ -78,6 +79,7 @@ struct hoedown_renderer {\n     other: [libc::size_t, ..28],\n }\n \n+#[repr(C)]\n struct hoedown_html_renderer_state {\n     opaque: *mut libc::c_void,\n     toc_data: html_toc_data,\n@@ -87,6 +89,7 @@ struct hoedown_html_renderer_state {\n                                           *mut libc::c_void)>,\n }\n \n+#[repr(C)]\n struct html_toc_data {\n     header_count: libc::c_int,\n     current_level: libc::c_int,\n@@ -100,6 +103,7 @@ struct MyOpaque {\n     toc_builder: Option<TocBuilder>,\n }\n \n+#[repr(C)]\n struct hoedown_buffer {\n     data: *const u8,\n     size: libc::size_t,"}, {"sha": "8d2305a8a8068296db23f6a4d96a828ab3ccff80", "filename": "src/librustrt/libunwind.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -72,6 +72,7 @@ pub static unwinder_private_data_size: uint = 5;\n #[cfg(target_arch = \"mipsel\")]\n pub static unwinder_private_data_size: uint = 2;\n \n+#[repr(C)]\n pub struct _Unwind_Exception {\n     pub exception_class: _Unwind_Exception_Class,\n     pub exception_cleanup: _Unwind_Exception_Cleanup_Fn,"}, {"sha": "e7b031c6b51801ac676635f71c8070e8252daf6a", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -103,6 +103,7 @@ pub type uv_buf_len_t = libc::size_t;\n pub type uv_buf_len_t = libc::c_ulong;\n \n // see libuv/include/uv-unix.h\n+#[repr(C)]\n #[cfg(unix)]\n pub struct uv_buf_t {\n     pub base: *mut u8,\n@@ -114,6 +115,7 @@ pub type uv_os_socket_t = c_int;\n \n // see libuv/include/uv-win.h\n #[cfg(windows)]\n+#[repr(C)]\n pub struct uv_buf_t {\n     pub len: uv_buf_len_t,\n     pub base: *mut u8,\n@@ -135,6 +137,7 @@ pub enum uv_poll_event {\n     UV_WRITABLE = 2,\n }\n \n+#[repr(C)]\n pub struct uv_process_options_t {\n     pub exit_cb: uv_exit_cb,\n     pub file: *const libc::c_char,\n@@ -178,11 +181,13 @@ pub type uv_tty_t = c_void;\n pub type uv_signal_t = c_void;\n pub type uv_shutdown_t = c_void;\n \n+#[repr(C)]\n pub struct uv_timespec_t {\n     pub tv_sec: libc::c_long,\n     pub tv_nsec: libc::c_long\n }\n \n+#[repr(C)]\n pub struct uv_stat_t {\n     pub st_dev: libc::uint64_t,\n     pub st_mode: libc::uint64_t,\n@@ -373,14 +378,14 @@ pub unsafe fn free_req(v: *mut c_void) {\n #[test]\n fn handle_sanity_check() {\n     unsafe {\n-        assert_eq!(UV_HANDLE_TYPE_MAX as uint, rust_uv_handle_type_max());\n+        assert_eq!(UV_HANDLE_TYPE_MAX as libc::uintptr_t, rust_uv_handle_type_max());\n     }\n }\n \n #[test]\n fn request_sanity_check() {\n     unsafe {\n-        assert_eq!(UV_REQ_TYPE_MAX as uint, rust_uv_req_type_max());\n+        assert_eq!(UV_REQ_TYPE_MAX as libc::uintptr_t, rust_uv_req_type_max());\n     }\n }\n "}, {"sha": "769ad2a8468d9f15ea501e5b2b1c59f3cf22eed9", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -146,6 +146,7 @@ mod darwin_fd_limit {\n \n     use libc;\n     type rlim_t = libc::uint64_t;\n+    #[repr(C)]\n     struct rlimit {\n         rlim_cur: rlim_t,\n         rlim_max: rlim_t"}, {"sha": "7780c61e8667194f030e2691bf0881bdc602d46a", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -59,7 +59,7 @@ use libc::c_char;\n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n     unsafe {\n-        return rust_get_num_cpus();\n+        return rust_get_num_cpus() as uint;\n     }\n \n     extern {"}, {"sha": "1b005f49b8818ba78fb44cc1946828d8e80e2da1", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -701,6 +701,7 @@ mod imp {\n     static IMAGE_FILE_MACHINE_IA64: libc::DWORD = 0x0200;\n     static IMAGE_FILE_MACHINE_AMD64: libc::DWORD = 0x8664;\n \n+    #[cfg(stage0)]\n     #[packed]\n     struct SYMBOL_INFO {\n         SizeOfStruct: libc::c_ulong,\n@@ -723,6 +724,30 @@ mod imp {\n         Name: [libc::c_char, ..MAX_SYM_NAME],\n     }\n \n+    #[cfg(not(stage0))]\n+    #[repr(C, packed)]\n+    struct SYMBOL_INFO {\n+        SizeOfStruct: libc::c_ulong,\n+        TypeIndex: libc::c_ulong,\n+        Reserved: [u64, ..2],\n+        Index: libc::c_ulong,\n+        Size: libc::c_ulong,\n+        ModBase: u64,\n+        Flags: libc::c_ulong,\n+        Value: u64,\n+        Address: u64,\n+        Register: libc::c_ulong,\n+        Scope: libc::c_ulong,\n+        Tag: libc::c_ulong,\n+        NameLen: libc::c_ulong,\n+        MaxNameLen: libc::c_ulong,\n+        // note that windows has this as 1, but it basically just means that\n+        // the name is inline at the end of the struct. For us, we just bump\n+        // the struct size up to MAX_SYM_NAME.\n+        Name: [libc::c_char, ..MAX_SYM_NAME],\n+    }\n+\n+\n     #[repr(C)]\n     enum ADDRESS_MODE {\n         AddrMode1616,\n@@ -772,6 +797,7 @@ mod imp {\n \n         static MAXIMUM_SUPPORTED_EXTENSION: uint = 512;\n \n+        #[repr(C)]\n         pub struct CONTEXT {\n             ContextFlags: libc::DWORD,\n             Dr0: libc::DWORD,\n@@ -800,6 +826,7 @@ mod imp {\n             ExtendedRegisters: [u8, ..MAXIMUM_SUPPORTED_EXTENSION],\n         }\n \n+        #[repr(C)]\n         pub struct FLOATING_SAVE_AREA {\n             ControlWord: libc::DWORD,\n             StatusWord: libc::DWORD,\n@@ -829,6 +856,7 @@ mod imp {\n         use libc::{c_longlong, c_ulonglong};\n         use libc::types::os::arch::extra::{WORD, DWORD, DWORDLONG};\n \n+        #[repr(C)]\n         pub struct CONTEXT {\n             P1Home: DWORDLONG,\n             P2Home: DWORDLONG,\n@@ -886,11 +914,13 @@ mod imp {\n             LastExceptionFromRip: DWORDLONG,\n         }\n \n+        #[repr(C)]\n         pub struct M128A {\n             Low:  c_ulonglong,\n             High: c_longlong\n         }\n \n+        #[repr(C)]\n         pub struct FLOATING_SAVE_AREA {\n             _Dummy: [u8, ..512] // FIXME: Fill this out\n         }\n@@ -907,6 +937,7 @@ mod imp {\n         }\n     }\n \n+    #[repr(C)]\n     struct Cleanup {\n         handle: libc::HANDLE,\n         SymCleanup: SymCleanupFn,"}, {"sha": "4b2a3073755eb5c08f0e59a9d5cff1770ff0ba7e", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -418,19 +418,14 @@ pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[Gc<MetaItem>]) {\n }\n \n \n-/// Fold this over attributes to parse #[repr(...)] forms.\n+/// Parse #[repr(...)] forms.\n ///\n /// Valid repr contents: any of the primitive integral type names (see\n-/// `int_type_of_word`, below) to specify the discriminant type; and `C`, to use\n-/// the same discriminant size that the corresponding C enum would.  These are\n-/// not allowed on univariant or zero-variant enums, which have no discriminant.\n-///\n-/// If a discriminant type is so specified, then the discriminant will be\n-/// present (before fields, if any) with that type; representation\n-/// optimizations which would remove it will not be done.\n-pub fn find_repr_attr(diagnostic: &SpanHandler, attr: &Attribute, acc: ReprAttr)\n-    -> ReprAttr {\n-    let mut acc = acc;\n+/// `int_type_of_word`, below) to specify enum discriminant type; `C`, to use\n+/// the same discriminant size that the corresponding C enum would or C\n+/// structure layout, and `packed` to remove padding.\n+pub fn find_repr_attrs(diagnostic: &SpanHandler, attr: &Attribute) -> Vec<ReprAttr> {\n+    let mut acc = Vec::new();\n     match attr.node.value.node {\n         ast::MetaList(ref s, ref items) if s.equiv(&(\"repr\")) => {\n             mark_used(attr);\n@@ -439,28 +434,26 @@ pub fn find_repr_attr(diagnostic: &SpanHandler, attr: &Attribute, acc: ReprAttr)\n                     ast::MetaWord(ref word) => {\n                         let hint = match word.get() {\n                             // Can't use \"extern\" because it's not a lexical identifier.\n-                            \"C\" => ReprExtern,\n+                            \"C\" => Some(ReprExtern),\n+                            \"packed\" => Some(ReprPacked),\n                             _ => match int_type_of_word(word.get()) {\n-                                Some(ity) => ReprInt(item.span, ity),\n+                                Some(ity) => Some(ReprInt(item.span, ity)),\n                                 None => {\n                                     // Not a word we recognize\n                                     diagnostic.span_err(item.span,\n                                                         \"unrecognized representation hint\");\n-                                    ReprAny\n+                                    None\n                                 }\n                             }\n                         };\n-                        if hint != ReprAny {\n-                            if acc == ReprAny {\n-                                acc = hint;\n-                            } else if acc != hint {\n-                                diagnostic.span_warn(item.span,\n-                                                     \"conflicting representation hint ignored\")\n-                            }\n+\n+                        match hint {\n+                            Some(h) => acc.push(h),\n+                            None => { }\n                         }\n                     }\n                     // Not a word:\n-                    _ => diagnostic.span_err(item.span, \"unrecognized representation hint\")\n+                    _ => diagnostic.span_err(item.span, \"unrecognized enum representation hint\")\n                 }\n             }\n         }\n@@ -490,15 +483,17 @@ fn int_type_of_word(s: &str) -> Option<IntType> {\n pub enum ReprAttr {\n     ReprAny,\n     ReprInt(Span, IntType),\n-    ReprExtern\n+    ReprExtern,\n+    ReprPacked,\n }\n \n impl ReprAttr {\n     pub fn is_ffi_safe(&self) -> bool {\n         match *self {\n             ReprAny => false,\n             ReprInt(_sp, ity) => ity.is_ffi_safe(),\n-            ReprExtern => true\n+            ReprExtern => true,\n+            ReprPacked => false\n         }\n     }\n }\n@@ -523,7 +518,7 @@ impl IntType {\n             SignedInt(ast::TyI16) | UnsignedInt(ast::TyU16) |\n             SignedInt(ast::TyI32) | UnsignedInt(ast::TyU32) |\n             SignedInt(ast::TyI64) | UnsignedInt(ast::TyU64) => true,\n-            _ => false\n+            SignedInt(ast::TyI) | UnsignedInt(ast::TyU) => false\n         }\n     }\n }"}, {"sha": "0e3b531e4581c90455bf9bfadb160cfd20b276d6", "filename": "src/test/auxiliary/extern-crosscrate-source.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -24,17 +24,17 @@ pub mod rustrt {\n     }\n }\n \n-pub fn fact(n: uint) -> uint {\n+pub fn fact(n: libc::uintptr_t) -> libc::uintptr_t {\n     unsafe {\n         println!(\"n = {}\", n);\n         rustrt::rust_dbg_call(cb, n)\n     }\n }\n \n pub extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n-    if data == 1u {\n+    if data == 1 {\n         data\n     } else {\n-        fact(data - 1u) * data\n+        fact(data - 1) * data\n     }\n }"}, {"sha": "86f5f93e3cf08d56745114631b2abb4251c46a2c", "filename": "src/test/auxiliary/packed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fauxiliary%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fauxiliary%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fpacked.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[packed]\n+#[repr(packed)]\n pub struct S {\n     a: u8,\n     b: u32"}, {"sha": "d4a40ade72c3262a3cc5c4f08e9261cc9542ef8e", "filename": "src/test/compile-fail/issue-14309.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fcompile-fail%2Fissue-14309.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fcompile-fail%2Fissue-14309.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14309.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(ctypes)]\n+#![allow(dead_code)]\n+\n+struct A {\n+    x: i32\n+}\n+\n+#[repr(C, packed)]\n+struct B {\n+    x: i32,\n+    y: A\n+}\n+\n+#[repr(C)]\n+struct C {\n+    x: i32\n+}\n+\n+type A2 = A;\n+type B2 = B;\n+type C2 = C;\n+\n+#[repr(C)]\n+struct D {\n+    x: C,\n+    y: A\n+}\n+\n+extern \"C\" {\n+    fn foo(x: A); //~ ERROR found type without foreign-function-safe\n+    fn bar(x: B); //~ ERROR foreign-function-safe\n+    fn baz(x: C);\n+    fn qux(x: A2); //~ ERROR foreign-function-safe\n+    fn quux(x: B2); //~ ERROR foreign-function-safe\n+    fn corge(x: C2);\n+    fn fred(x: D); //~ ERROR foreign-function-safe\n+}\n+\n+fn main() { }"}, {"sha": "d45a3b027a79439a3bb831d2d8956dcea2ae27f5", "filename": "src/test/compile-fail/lint-ctypes-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -18,9 +18,9 @@ enum T { E, F, G }\n \n extern {\n    fn zf(x: Z);\n-   fn uf(x: U);\n-   fn bf(x: B); //~ ERROR found enum type without foreign-function-safe\n-   fn tf(x: T); //~ ERROR found enum type without foreign-function-safe\n+   fn uf(x: U); //~ ERROR found type without foreign-function-safe\n+   fn bf(x: B); //~ ERROR found type without foreign-function-safe\n+   fn tf(x: T); //~ ERROR found type without foreign-function-safe\n }\n \n pub fn main() { }"}, {"sha": "7a1ff5744888dfa89e29eabc1a82e2b866f52eb9", "filename": "src/test/compile-fail/packed-struct-generic-transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -19,7 +19,7 @@ extern crate debug;\n \n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n struct Foo<T,S> {\n     bar: T,\n     baz: S"}, {"sha": "f92cc4b13440c89e47c0538f48775f9d3e81d3f0", "filename": "src/test/compile-fail/packed-struct-transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -19,7 +19,7 @@ extern crate debug;\n \n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n struct Foo {\n     bar: u8,\n     baz: uint"}, {"sha": "ef23e7ee87666a3a62d12100e1a7dabd195014f9", "filename": "src/test/debuginfo/c-style-enum-in-composite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fdebuginfo%2Fc-style-enum-in-composite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fdebuginfo%2Fc-style-enum-in-composite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fc-style-enum-in-composite.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -87,7 +87,7 @@ struct PaddedStruct {\n     e: i16\n }\n \n-#[packed]\n+#[repr(packed)]\n struct PackedStruct {\n     a: i16,\n     b: AnEnum,"}, {"sha": "00a560edbf01af121309c7b609443cc767c0361e", "filename": "src/test/debuginfo/packed-struct-with-destructor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fdebuginfo%2Fpacked-struct-with-destructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fdebuginfo%2Fpacked-struct-with-destructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpacked-struct-with-destructor.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -77,7 +77,7 @@\n \n #![allow(unused_variable)]\n \n-#[packed]\n+#[repr(packed)]\n struct Packed {\n     x: i16,\n     y: i32,\n@@ -88,7 +88,7 @@ impl Drop for Packed {\n     fn drop(&mut self) {}\n }\n \n-#[packed]\n+#[repr(packed)]\n struct PackedInPacked {\n     a: i32,\n     b: Packed,\n@@ -113,15 +113,15 @@ impl Drop for Unpacked {\n     fn drop(&mut self) {}\n }\n \n-#[packed]\n+#[repr(packed)]\n struct UnpackedInPacked {\n     a: i16,\n     b: Unpacked,\n     c: Unpacked,\n     d: i64\n }\n \n-#[packed]\n+#[repr(packed)]\n struct PackedInPackedWithDrop {\n     a: i32,\n     b: Packed,\n@@ -144,7 +144,7 @@ impl Drop for PackedInUnpackedWithDrop {\n     fn drop(&mut self) {}\n }\n \n-#[packed]\n+#[repr(packed)]\n struct UnpackedInPackedWithDrop {\n     a: i16,\n     b: Unpacked,"}, {"sha": "bf2213509cf7c42af92d3ef5ca8d2468ce48e15d", "filename": "src/test/debuginfo/packed-struct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpacked-struct.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -63,14 +63,14 @@\n \n #![allow(unused_variable)]\n \n-#[packed]\n+#[repr(packed)]\n struct Packed {\n     x: i16,\n     y: i32,\n     z: i64\n }\n \n-#[packed]\n+#[repr(packed)]\n struct PackedInPacked {\n     a: i32,\n     b: Packed,\n@@ -95,7 +95,7 @@ struct Unpacked {\n }\n \n // layout (64 bit): aabb bbbb bbbb bbbb bbbb bbbb bbcc cccc cccc cccc cccc cccc ccdd dddd dd\n-#[packed]\n+#[repr(packed)]\n struct UnpackedInPacked {\n     a: i16,\n     b: Unpacked,"}, {"sha": "8d8daed1393c7f21a2edaa752f1cc13285e0d179", "filename": "src/test/run-make/extern-fn-with-packed-struct/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[packed]\n+#[repr(packed)]\n #[deriving(PartialEq, Show)]\n struct Foo {\n     a: i8,"}, {"sha": "93a5752d004aa65f52d048e0abb7af4b744170d9", "filename": "src/test/run-pass/extern-call-deep.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -22,22 +22,22 @@ mod rustrt {\n }\n \n extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n-    if data == 1u {\n+    if data == 1 {\n         data\n     } else {\n-        count(data - 1u) + 1u\n+        count(data - 1) + 1\n     }\n }\n \n-fn count(n: uint) -> uint {\n+fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n     unsafe {\n         println!(\"n = {}\", n);\n         rustrt::rust_dbg_call(cb, n)\n     }\n }\n \n pub fn main() {\n-    let result = count(1000u);\n+    let result = count(1000);\n     println!(\"result = {}\", result);\n-    assert_eq!(result, 1000u);\n+    assert_eq!(result, 1000);\n }"}, {"sha": "bc5ccc30c527c5298c472a046419b371b645b100", "filename": "src/test/run-pass/extern-call-deep2.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -23,14 +23,14 @@ mod rustrt {\n }\n \n extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n-    if data == 1u {\n+    if data == 1 {\n         data\n     } else {\n-        count(data - 1u) + 1u\n+        count(data - 1) + 1\n     }\n }\n \n-fn count(n: uint) -> uint {\n+fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n     unsafe {\n         println!(\"n = {}\", n);\n         rustrt::rust_dbg_call(cb, n)\n@@ -41,8 +41,8 @@ pub fn main() {\n     // Make sure we're on a task with small Rust stacks (main currently\n     // has a large stack)\n     task::spawn(proc() {\n-        let result = count(1000u);\n+        let result = count(1000);\n         println!(\"result = {}\", result);\n-        assert_eq!(result, 1000u);\n+        assert_eq!(result, 1000);\n     });\n }"}, {"sha": "52697d96b32d97edd9f6477710aa560ae33ffa57", "filename": "src/test/run-pass/extern-call-indirect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fextern-call-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fextern-call-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-indirect.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -22,22 +22,22 @@ mod rustrt {\n }\n \n extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n-    if data == 1u {\n+    if data == 1 {\n         data\n     } else {\n-        fact(data - 1u) * data\n+        fact(data - 1) * data\n     }\n }\n \n-fn fact(n: uint) -> uint {\n+fn fact(n: libc::uintptr_t) -> libc::uintptr_t {\n     unsafe {\n         println!(\"n = {}\", n);\n         rustrt::rust_dbg_call(cb, n)\n     }\n }\n \n pub fn main() {\n-    let result = fact(10u);\n+    let result = fact(10);\n     println!(\"result = {}\", result);\n-    assert_eq!(result, 3628800u);\n+    assert_eq!(result, 3628800);\n }"}, {"sha": "ae9430370d52077900fe61a82adb771bd7f591a8", "filename": "src/test/run-pass/extern-call-scrub.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -27,14 +27,14 @@ mod rustrt {\n }\n \n extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n-    if data == 1u {\n+    if data == 1 {\n         data\n     } else {\n-        count(data - 1u) + count(data - 1u)\n+        count(data - 1) + count(data - 1)\n     }\n }\n \n-fn count(n: uint) -> uint {\n+fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n     unsafe {\n         println!(\"n = {}\", n);\n         rustrt::rust_dbg_call(cb, n)\n@@ -45,8 +45,8 @@ pub fn main() {\n     // Make sure we're on a task with small Rust stacks (main currently\n     // has a large stack)\n     task::spawn(proc() {\n-        let result = count(12u);\n+        let result = count(12);\n         println!(\"result = {}\", result);\n-        assert_eq!(result, 2048u);\n+        assert_eq!(result, 2048);\n     });\n }"}, {"sha": "18e20332adc91e1693cf6c5c7dae6c9a127c4759", "filename": "src/test/run-pass/extern-crosscrate.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -11,16 +11,17 @@\n //aux-build:extern-crosscrate-source.rs\n \n extern crate externcallback;\n+extern crate libc;\n \n-fn fact(n: uint) -> uint {\n+fn fact(n: libc::uintptr_t) -> libc::uintptr_t {\n     unsafe {\n         println!(\"n = {}\", n);\n         externcallback::rustrt::rust_dbg_call(externcallback::cb, n)\n     }\n }\n \n pub fn main() {\n-    let result = fact(10u);\n+    let result = fact(10);\n     println!(\"result = {}\", result);\n-    assert_eq!(result, 3628800u);\n+    assert_eq!(result, 3628800);\n }"}, {"sha": "87d96880e4bd340a07fa837b0c03315d1b4c7abe", "filename": "src/test/run-pass/extern-stress.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-stress.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -26,24 +26,24 @@ mod rustrt {\n }\n \n extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n-    if data == 1u {\n+    if data == 1 {\n         data\n     } else {\n         task::deschedule();\n-        count(data - 1u) + count(data - 1u)\n+        count(data - 1) + count(data - 1)\n     }\n }\n \n-fn count(n: uint) -> uint {\n+fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n     unsafe {\n         rustrt::rust_dbg_call(cb, n)\n     }\n }\n \n pub fn main() {\n-    for _ in range(0, 100u) {\n+    for _ in range(0u, 100) {\n         task::spawn(proc() {\n-            assert_eq!(count(5u), 16u);\n+            assert_eq!(count(5), 16);\n         });\n     }\n }"}, {"sha": "7fb68e9f8a03863e92a93e70034d3e387229a2ac", "filename": "src/test/run-pass/extern-yield.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-yield.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -23,14 +23,14 @@ mod rustrt {\n }\n \n extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n-    if data == 1u {\n+    if data == 1 {\n         data\n     } else {\n-        count(data - 1u) + count(data - 1u)\n+        count(data - 1) + count(data - 1)\n     }\n }\n \n-fn count(n: uint) -> uint {\n+fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n     unsafe {\n         task::deschedule();\n         rustrt::rust_dbg_call(cb, n)\n@@ -40,9 +40,9 @@ fn count(n: uint) -> uint {\n pub fn main() {\n     for _ in range(0, 10u) {\n         task::spawn(proc() {\n-            let result = count(5u);\n+            let result = count(5);\n             println!(\"result = {}\", result);\n-            assert_eq!(result, 16u);\n+            assert_eq!(result, 16);\n         });\n     }\n }"}, {"sha": "c6c74fe3fda1d59aac5fca873a4c64d78b904091", "filename": "src/test/run-pass/packed-struct-borrow-element.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-struct-borrow-element.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-struct-borrow-element.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-borrow-element.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[packed]\n+#[repr(packed)]\n struct Foo {\n     bar: u8,\n     baz: uint"}, {"sha": "999e4aeeb5977ebacedd0d5195f56da419496a0d", "filename": "src/test/run-pass/packed-struct-generic-layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -10,7 +10,7 @@\n \n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n struct S<T, S> {\n     a: T,\n     b: u8,"}, {"sha": "45791332bbedfae08a6b635a1cf3da428ef73c86", "filename": "src/test/run-pass/packed-struct-generic-size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -10,7 +10,7 @@\n \n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n struct S<T, S> {\n     a: T,\n     b: u8,"}, {"sha": "b4fbf0820cd46b0badead839ab53af6d727bc7e1", "filename": "src/test/run-pass/packed-struct-layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-struct-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-struct-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-layout.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -10,13 +10,13 @@\n \n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n struct S4 {\n     a: u8,\n     b: [u8, .. 3],\n }\n \n-#[packed]\n+#[repr(packed)]\n struct S5 {\n     a: u8,\n     b: u32"}, {"sha": "46ffed0cba9684004caddf2f751bfb65b4c0c0b9", "filename": "src/test/run-pass/packed-struct-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-struct-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-struct-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-match.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[packed]\n+#[repr(packed)]\n struct Foo {\n     bar: u8,\n     baz: uint"}, {"sha": "cfea444d7ffc7ee5100eb6afc29f5690d4748d0d", "filename": "src/test/run-pass/packed-struct-size.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -12,19 +12,19 @@\n use std::mem;\n use std::gc::Gc;\n \n-#[packed]\n+#[repr(packed)]\n struct S4 {\n     a: u8,\n     b: [u8, .. 3],\n }\n \n-#[packed]\n+#[repr(packed)]\n struct S5 {\n     a: u8,\n     b: u32\n }\n \n-#[packed]\n+#[repr(packed)]\n struct S13 {\n     a: i64,\n     b: f32,\n@@ -36,14 +36,14 @@ enum Foo {\n     Baz = 2\n }\n \n-#[packed]\n+#[repr(packed)]\n struct S3_Foo {\n     a: u8,\n     b: u16,\n     c: Foo\n }\n \n-#[packed]\n+#[repr(packed)]\n struct S7_Option {\n     a: f32,\n     b: u8,"}, {"sha": "c20e62351a618ef3ce2d781e0060184cbf9f61cc", "filename": "src/test/run-pass/packed-struct-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -12,7 +12,7 @@\n \n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n #[deriving(PartialEq, Show)]\n struct Foo {\n     bar: u8,"}, {"sha": "5fb43503ccb26b0ccfff993b6959783ea9a5064d", "filename": "src/test/run-pass/packed-tuple-struct-layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-layout.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -10,10 +10,10 @@\n \n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n struct S4(u8,[u8, .. 3]);\n \n-#[packed]\n+#[repr(packed)]\n struct S5(u8,u32);\n \n pub fn main() {"}, {"sha": "f23166288fb55a687df0efe576df890395fda693", "filename": "src/test/run-pass/packed-tuple-struct-size.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92015f71b3a49abd490e704a011d14786f6bf87/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs?ref=f92015f71b3a49abd490e704a011d14786f6bf87", "patch": "@@ -12,24 +12,24 @@\n use std::gc::Gc;\n use std::mem;\n \n-#[packed]\n+#[repr(packed)]\n struct S4(u8,[u8, .. 3]);\n \n-#[packed]\n+#[repr(packed)]\n struct S5(u8, u32);\n \n-#[packed]\n+#[repr(packed)]\n struct S13(i64, f32, u8);\n \n enum Foo {\n     Bar = 1,\n     Baz = 2\n }\n \n-#[packed]\n+#[repr(packed)]\n struct S3_Foo(u8, u16, Foo);\n \n-#[packed]\n+#[repr(packed)]\n struct S7_Option(f32, u8, u16, Option<Gc<f64>>);\n \n pub fn main() {"}]}