{"sha": "d542e67827e0ad1a3df5fd248d9c09997b5dcbba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NDJlNjc4MjdlMGFkMWEzZGY1ZmQyNDhkOWMwOTk5N2I1ZGNiYmE=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-07T01:22:49Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-07T01:26:47Z"}, "message": "Do some cleanup of the allocation code.", "tree": {"sha": "5dc8f632a130d1e8ae36b59a9dd7b3215b33a0e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5dc8f632a130d1e8ae36b59a9dd7b3215b33a0e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d542e67827e0ad1a3df5fd248d9c09997b5dcbba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d542e67827e0ad1a3df5fd248d9c09997b5dcbba", "html_url": "https://github.com/rust-lang/rust/commit/d542e67827e0ad1a3df5fd248d9c09997b5dcbba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d542e67827e0ad1a3df5fd248d9c09997b5dcbba/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "107442d99496dbb037bc965d94904f21740f726f", "url": "https://api.github.com/repos/rust-lang/rust/commits/107442d99496dbb037bc965d94904f21740f726f", "html_url": "https://github.com/rust-lang/rust/commit/107442d99496dbb037bc965d94904f21740f726f"}], "stats": {"total": 91, "additions": 42, "deletions": 49}, "files": [{"sha": "ff297c5dcd484def007a47e624dbda7a6e86f812", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 39, "deletions": 47, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d542e67827e0ad1a3df5fd248d9c09997b5dcbba/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d542e67827e0ad1a3df5fd248d9c09997b5dcbba/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d542e67827e0ad1a3df5fd248d9c09997b5dcbba", "patch": "@@ -62,6 +62,12 @@ enum dest {\n     ignore,\n }\n \n+// Heap selectors. Indicate which heap something should go on.\n+enum heap {\n+    heap_shared,\n+    heap_exchange,\n+}\n+\n fn dest_str(ccx: @crate_ctxt, d: dest) -> str {\n     alt d {\n       by_val(v) { #fmt[\"by_val(%s)\", val_str(ccx.tn, *v)] }\n@@ -341,75 +347,61 @@ fn opaque_box_body(bcx: block,\n     PointerCast(bcx, bodyptr, T_ptr(type_of(ccx, body_t)))\n }\n \n-// trans_malloc_boxed_raw: expects an unboxed type and returns a pointer to\n+// malloc_raw: expects an unboxed type and returns a pointer to\n // enough space for a box of that type.  This includes a rust_opaque_box\n // header.\n-fn malloc_boxed_raw(bcx: block, t: ty::t,\n-                    &static_ti: option<@tydesc_info>) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"trans_malloc_boxed_raw\");\n+fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n-    // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n-    // wants.\n-    let box_ptr = ty::mk_imm_box(ccx.tcx, t);\n-    let llty = type_of(ccx, box_ptr);\n+    let (mk_fn, upcall) = alt heap {\n+      heap_shared { (ty::mk_imm_box, ccx.upcalls.malloc) }\n+      heap_exchange {\n+        (ty::mk_imm_uniq, ccx.upcalls.exchange_malloc )\n+      }\n+    };\n+\n+    // Grab the TypeRef type of box_ptr_ty.\n+    let box_ptr_ty = mk_fn(bcx.tcx(), t);\n+    let llty = type_of(ccx, box_ptr_ty);\n \n     // Get the tydesc for the body:\n+    let mut static_ti = none;\n     let lltydesc = get_tydesc(ccx, t, static_ti);\n     lazily_emit_all_tydesc_glue(ccx, copy static_ti);\n \n     // Allocate space:\n-    let rval = Call(bcx, ccx.upcalls.malloc, [lltydesc]);\n+    let rval = Call(bcx, upcall, [lltydesc]);\n     ret PointerCast(bcx, rval, llty);\n }\n \n-// trans_malloc_boxed: usefully wraps trans_malloc_box_raw; allocates a box,\n-// initializes the reference count to 1, and pulls out the body and rc\n-fn malloc_boxed(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n-    let _icx = bcx.insn_ctxt(\"trans_malloc_boxed\");\n-    let mut ti = none;\n-    let box = malloc_boxed_raw(bcx, t, ti);\n-    let box_no_addrspace = non_gc_box_cast(\n-        bcx, box, ty::mk_imm_box(bcx.tcx(), t));\n-    let body = GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]);\n+// malloc_general: usefully wraps malloc_raw; allocates a box,\n+// and pulls out the body\n+fn malloc_general(bcx: block, t: ty::t, heap: heap) ->\n+    {box: ValueRef, body: ValueRef} {\n+    let _icx = bcx.insn_ctxt(\"malloc_general\");\n+    let mk_ty = alt heap { heap_shared { ty::mk_imm_box }\n+                           heap_exchange { ty::mk_imm_uniq } };\n+    let box = malloc_raw(bcx, t, heap);\n+    let non_gc_box = non_gc_box_cast(bcx, box, mk_ty(bcx.tcx(), t));\n+    let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]);\n     ret {box: box, body: body};\n }\n \n-fn malloc_unique_raw(bcx: block, t: ty::t) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"malloc_unique_box_raw\");\n-    let ccx = bcx.ccx();\n-\n-    // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n-    // wants.\n-    let box_ptr = ty::mk_imm_uniq(ccx.tcx, t);\n-    let llty = type_of(ccx, box_ptr);\n-\n-    // Get the tydesc for the body:\n-    let mut static_ti = none;\n-    let lltydesc = get_tydesc(ccx, t, static_ti);\n-    lazily_emit_all_tydesc_glue(ccx, static_ti);\n-\n-    // Allocate space:\n-    let rval = Call(bcx, ccx.upcalls.exchange_malloc, [lltydesc]);\n-    ret PointerCast(bcx, rval, llty);\n+fn malloc_boxed(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n+    malloc_general(bcx, t, heap_shared)\n }\n-\n fn malloc_unique(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n-    let _icx = bcx.insn_ctxt(\"malloc_unique_box\");\n-    let box = malloc_unique_raw(bcx, t);\n-    let non_gc_box = non_gc_box_cast(bcx, box, ty::mk_imm_uniq(bcx.tcx(), t));\n-    let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]);\n-    ret {box: box, body: body};\n+    malloc_general(bcx, t, heap_exchange)\n }\n \n fn malloc_unique_dyn_raw(bcx: block, t: ty::t, size: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"malloc_unique_box_raw\");\n+    let _icx = bcx.insn_ctxt(\"malloc_unique_dyn_raw\");\n     let ccx = bcx.ccx();\n \n-    // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n-    // wants.\n-    let box_ptr = ty::mk_imm_uniq(ccx.tcx, t);\n-    let llty = type_of(ccx, box_ptr);\n+    // Grab the TypeRef type of box_ptr_ty.\n+    let box_ptr_ty = ty::mk_imm_uniq(ccx.tcx, t);\n+    let llty = type_of(ccx, box_ptr_ty);\n \n     // Get the tydesc for the body:\n     let mut static_ti = none;\n@@ -423,7 +415,7 @@ fn malloc_unique_dyn_raw(bcx: block, t: ty::t, size: ValueRef) -> ValueRef {\n \n fn malloc_unique_dyn(bcx: block, t: ty::t, size: ValueRef\n                     ) -> {box: ValueRef, body: ValueRef} {\n-    let _icx = bcx.insn_ctxt(\"malloc_unique_box\");\n+    let _icx = bcx.insn_ctxt(\"malloc_unique_dyn\");\n     let box = malloc_unique_dyn_raw(bcx, t, size);\n     let body = GEPi(bcx, box, [0u, abi::box_field_body]);\n     ret {box: box, body: body};"}, {"sha": "88cd126b1e4d375669adf0946ff9176ac3149791", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d542e67827e0ad1a3df5fd248d9c09997b5dcbba/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d542e67827e0ad1a3df5fd248d9c09997b5dcbba/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=d542e67827e0ad1a3df5fd248d9c09997b5dcbba", "patch": "@@ -175,11 +175,12 @@ fn allocate_cbox(bcx: block,\n     let mut temp_cleanups = [];\n     let (bcx, box) = alt ck {\n       ty::ck_box {\n-        let box = malloc_boxed_raw(bcx, cdata_ty, ti);\n+        get_tydesc(ccx, cdata_ty, ti);\n+        let box = malloc_raw(bcx, cdata_ty, heap_shared);\n         (bcx, box)\n       }\n       ty::ck_uniq {\n-        let box = malloc_unique_raw(bcx, cdata_ty);\n+        let box = malloc_raw(bcx, cdata_ty, heap_exchange);\n         (bcx, box)\n       }\n       ty::ck_block {"}]}