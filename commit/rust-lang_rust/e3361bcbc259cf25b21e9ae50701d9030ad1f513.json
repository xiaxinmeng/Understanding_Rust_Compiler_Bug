{"sha": "e3361bcbc259cf25b21e9ae50701d9030ad1f513", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMzYxYmNiYzI1OWNmMjViMjFlOWFlNTA3MDFkOTAzMGFkMWY1MTM=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-06-27T23:10:23Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-06-28T05:14:13Z"}, "message": "adjust fold to fold over interpolated items/exprs/etc.\n\nCloses #15221", "tree": {"sha": "9a564b371927385f4b9e4fd899eaee18bbae3196", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a564b371927385f4b9e4fd899eaee18bbae3196"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3361bcbc259cf25b21e9ae50701d9030ad1f513", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3361bcbc259cf25b21e9ae50701d9030ad1f513", "html_url": "https://github.com/rust-lang/rust/commit/e3361bcbc259cf25b21e9ae50701d9030ad1f513", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3361bcbc259cf25b21e9ae50701d9030ad1f513/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f73b7874ed2ba3be02cbf8c767aaecd6840bbe9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f73b7874ed2ba3be02cbf8c767aaecd6840bbe9", "html_url": "https://github.com/rust-lang/rust/commit/2f73b7874ed2ba3be02cbf8c767aaecd6840bbe9"}], "stats": {"total": 89, "additions": 70, "deletions": 19}, "files": [{"sha": "b9cedb7a7797a065a9b32a34e137ef12b1310972", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3361bcbc259cf25b21e9ae50701d9030ad1f513/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3361bcbc259cf25b21e9ae50701d9030ad1f513/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e3361bcbc259cf25b21e9ae50701d9030ad1f513", "patch": "@@ -1281,7 +1281,7 @@ mod test {\n             0)\n     }\n \n-    // FIXME #9384, match variable hygiene. Should expand into\n+    // match variable hygiene. Should expand into\n     // fn z() {match 8 {x_1 => {match 9 {x_2 | x_2 if x_2 == x_1 => x_2 + x_1}}}}\n     #[test] fn issue_9384(){\n         run_renaming_test(\n@@ -1293,7 +1293,7 @@ mod test {\n             0)\n     }\n \n-    // FIXME #15221, somehow pats aren't getting labeled correctly?\n+    // interpolated nodes weren't getting labeled.\n     // should expand into\n     // fn main(){let g1_1 = 13; g1_1}}\n     #[test] fn pat_expand_issue_15221(){"}, {"sha": "c6177ce31f5f874a8282020d717a6ca2f1c792bf", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 68, "deletions": 17, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e3361bcbc259cf25b21e9ae50701d9030ad1f513/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3361bcbc259cf25b21e9ae50701d9030ad1f513/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e3361bcbc259cf25b21e9ae50701d9030ad1f513", "patch": "@@ -389,36 +389,80 @@ fn fold_arg_<T: Folder>(a: &Arg, fld: &mut T) -> Arg {\n     }\n }\n \n-// build a new vector of tts by appling the Folder's fold_ident to\n-// all of the identifiers in the token trees.\n-pub fn fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> Vec<TokenTree> {\n-    tts.iter().map(|tt| {\n-        match *tt {\n-            TTTok(span, ref tok) =>\n-            TTTok(span,maybe_fold_ident(tok,fld)),\n-            TTDelim(ref tts) => TTDelim(Rc::new(fold_tts(tts.as_slice(), fld))),\n-            TTSeq(span, ref pattern, ref sep, is_optional) =>\n+pub fn fold_tt<T: Folder>(tt: &TokenTree, fld: &mut T) -> TokenTree {\n+    match *tt {\n+        TTTok(span, ref tok) =>\n+            TTTok(span, fold_token(tok,fld)),\n+        TTDelim(ref tts) => TTDelim(Rc::new(fold_tts(tts.as_slice(), fld))),\n+        TTSeq(span, ref pattern, ref sep, is_optional) =>\n             TTSeq(span,\n                   Rc::new(fold_tts(pattern.as_slice(), fld)),\n-                  sep.as_ref().map(|tok|maybe_fold_ident(tok,fld)),\n+                  sep.as_ref().map(|tok| fold_token(tok,fld)),\n                   is_optional),\n-            TTNonterminal(sp,ref ident) =>\n+        TTNonterminal(sp,ref ident) =>\n             TTNonterminal(sp,fld.fold_ident(*ident))\n-        }\n-    }).collect()\n+    }\n+}\n+\n+pub fn fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> Vec<TokenTree> {\n+    tts.iter().map(|tt| fold_tt(tt,fld)).collect()\n }\n \n-// apply ident folder if it's an ident, otherwise leave it alone\n-fn maybe_fold_ident<T: Folder>(t: &token::Token, fld: &mut T) -> token::Token {\n+\n+// apply ident folder if it's an ident, apply other folds to interpolated nodes\n+fn fold_token<T: Folder>(t: &token::Token, fld: &mut T) -> token::Token {\n     match *t {\n         token::IDENT(id, followed_by_colons) => {\n             token::IDENT(fld.fold_ident(id), followed_by_colons)\n         }\n         token::LIFETIME(id) => token::LIFETIME(fld.fold_ident(id)),\n+        token::INTERPOLATED(ref nt) => token::INTERPOLATED(fold_interpolated(nt,fld)),\n         _ => (*t).clone()\n     }\n }\n \n+// apply folder to elements of interpolated nodes\n+//\n+// NB: this can occur only when applying a fold to partially expanded code, where\n+// parsed pieces have gotten implanted ito *other* macro invocations. This is relevant\n+// for macro hygiene, but possibly not elsewhere.\n+//\n+// One problem here occurs because the types for fold_item, fold_stmt, etc. allow the\n+// folder to return *multiple* items; this is a problem for the nodes here, because\n+// they insist on having exactly one piece. One solution would be to mangle the fold\n+// trait to include one-to-many and one-to-one versions of these entry points, but that\n+// would probably confuse a lot of people and help very few. Instead, I'm just going\n+// to put in dynamic checks. I think the performance impact of this will be pretty much\n+// nonexistent. The danger is that someone will apply a fold to a partially expanded\n+// node, and will be confused by the fact that their \"fold_item\" or \"fold_stmt\" isn't\n+// getting called on NtItem or NtStmt nodes. Hopefully they'll wind up reading this\n+// comment, and doing something appropriate.\n+//\n+// BTW, design choice: I considered just changing the type of, e.g., NtItem to contain\n+// multiple items, but decided against it when I looked at parse_item_or_view_item and\n+// tried to figure out what I would do with multiple items there....\n+fn fold_interpolated<T: Folder>(nt : &token::Nonterminal, fld: &mut T) -> token::Nonterminal {\n+    match *nt {\n+        token::NtItem(item) =>\n+            token::NtItem(fld.fold_item(item)\n+                          .expect_one(\"expected fold to produce exactly one item\")),\n+        token::NtBlock(block) => token::NtBlock(fld.fold_block(block)),\n+        token::NtStmt(stmt) =>\n+            token::NtStmt(fld.fold_stmt(stmt)\n+                          .expect_one(\"expected fold to produce exactly one statement\")),\n+        token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n+        token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n+        token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n+        token::NtIdent(ref id, is_mod_name) =>\n+            token::NtIdent(box fld.fold_ident(**id),is_mod_name),\n+        token::NtMeta(meta_item) => token::NtMeta(fold_meta_item_(meta_item,fld)),\n+        token::NtPath(ref path) => token::NtPath(box fld.fold_path(*path)),\n+        token::NtTT(tt) => token::NtTT(box (GC) fold_tt(tt,fld)),\n+        // it looks to me like we can leave out the matchers: token::NtMatchers(matchers)\n+        _ => (*nt).clone()\n+    }\n+}\n+\n pub fn noop_fold_fn_decl<T: Folder>(decl: &FnDecl, fld: &mut T) -> P<FnDecl> {\n     P(FnDecl {\n         inputs: decl.inputs.iter().map(|x| fold_arg_(x, fld)).collect(), // bad copy\n@@ -672,8 +716,15 @@ pub fn noop_fold_crate<T: Folder>(c: Crate, folder: &mut T) -> Crate {\n     }\n }\n \n+// fold one item into possibly many items\n pub fn noop_fold_item<T: Folder>(i: &Item,\n                                  folder: &mut T) -> SmallVector<Gc<Item>> {\n+    SmallVector::one(box(GC) noop_fold_item_(i,folder))\n+}\n+\n+\n+// fold one item into exactly one item\n+pub fn noop_fold_item_<T: Folder>(i: &Item, folder: &mut T) -> Item {\n     let id = folder.new_id(i.id); // Needs to be first, for ast_map.\n     let node = folder.fold_item_underscore(&i.node);\n     let ident = match node {\n@@ -684,14 +735,14 @@ pub fn noop_fold_item<T: Folder>(i: &Item,\n         _ => i.ident\n     };\n \n-    SmallVector::one(box(GC) Item {\n+    Item {\n         id: id,\n         ident: folder.fold_ident(ident),\n         attrs: i.attrs.iter().map(|e| folder.fold_attribute(*e)).collect(),\n         node: node,\n         vis: i.vis,\n         span: folder.new_span(i.span)\n-    })\n+    }\n }\n \n pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem,"}]}