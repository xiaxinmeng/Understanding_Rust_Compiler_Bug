{"sha": "ec44d48ae396e596f07ecc496f95da2b5ec36223", "node_id": "C_kwDOAAsO6NoAKGVjNDRkNDhhZTM5NmU1OTZmMDdlY2M0OTZmOTVkYTJiNWVjMzYyMjM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-02-24T20:42:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-24T20:42:18Z"}, "message": "Rollup merge of #94316 - nnethercote:improve-string-literal-unescaping, r=petrochenkov\n\nImprove string literal unescaping\n\nSome easy wins that affect a few popular crates.\n\nr? ```@matklad```", "tree": {"sha": "68f265f8007e2242475c399d3f9e19d60b5386f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68f265f8007e2242475c399d3f9e19d60b5386f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec44d48ae396e596f07ecc496f95da2b5ec36223", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiF+2qCRBK7hj4Ov3rIwAAnsEIABA3ewydcovD/RMHguZEGszc\n86CxrzTcc38qthT8G0RqTL0B0TUB1rNQQzpQVxPQqscAgnpgLHp2osxxJWek6HV+\n+i3qI3gQrTS5yMUw/s36rr1+LYyUZaQfJTF4nY+Wg9M9GFqojbXygeK6LFo/ufhJ\nHYszwJRsYMPIjoH/KJaa4Wf/hEy8XWyNyTqeIq3brfRYTK3UHLHu8NM/vUzpEnRU\nXRLs9b2DsDO3SL7e+qLi8QvC05yDsMHVvRpQtEPvQhDW5u0CV0zUqbB6XQXyLfgU\nYzYEDV6xvjkP7o0lQru0K4oQKWBbQZly9Zpf1H3wfkW8KOxfDByCoA+lpVRp7Zk=\n=4iMQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 68f265f8007e2242475c399d3f9e19d60b5386f2\nparent 9e7131a0d37f6342322cecf7d4dbec6fef92d925\nparent 44308dc3489e39958b2ce6dd297b895514b6f425\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1645735338 +0100\ncommitter GitHub <noreply@github.com> 1645735338 +0100\n\nRollup merge of #94316 - nnethercote:improve-string-literal-unescaping, r=petrochenkov\n\nImprove string literal unescaping\n\nSome easy wins that affect a few popular crates.\n\nr? ```@matklad```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec44d48ae396e596f07ecc496f95da2b5ec36223", "html_url": "https://github.com/rust-lang/rust/commit/ec44d48ae396e596f07ecc496f95da2b5ec36223", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec44d48ae396e596f07ecc496f95da2b5ec36223/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e7131a0d37f6342322cecf7d4dbec6fef92d925", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e7131a0d37f6342322cecf7d4dbec6fef92d925", "html_url": "https://github.com/rust-lang/rust/commit/9e7131a0d37f6342322cecf7d4dbec6fef92d925"}, {"sha": "44308dc3489e39958b2ce6dd297b895514b6f425", "url": "https://api.github.com/repos/rust-lang/rust/commits/44308dc3489e39958b2ce6dd297b895514b6f425", "html_url": "https://github.com/rust-lang/rust/commit/44308dc3489e39958b2ce6dd297b895514b6f425"}], "stats": {"total": 85, "additions": 45, "deletions": 40}, "files": [{"sha": "21183121e15a0df25ed56a4dc1943d28d3b1ffab", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec44d48ae396e596f07ecc496f95da2b5ec36223/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec44d48ae396e596f07ecc496f95da2b5ec36223/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=ec44d48ae396e596f07ecc496f95da2b5ec36223", "patch": "@@ -16,6 +16,7 @@\n #![feature(min_specialization)]\n #![recursion_limit = \"256\"]\n #![feature(slice_internals)]\n+#![feature(stmt_expr_attributes)]\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "224afbd553fb8eca0d5fd9efe15f4f7372bfea92", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ec44d48ae396e596f07ecc496f95da2b5ec36223/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec44d48ae396e596f07ecc496f95da2b5ec36223/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=ec44d48ae396e596f07ecc496f95da2b5ec36223", "patch": "@@ -56,25 +56,30 @@ impl LitKind {\n                 // new symbol because the string in the LitKind is different to the\n                 // string in the token.\n                 let s = symbol.as_str();\n-                let symbol =\n-                    if s.contains(&['\\\\', '\\r']) {\n-                        let mut buf = String::with_capacity(s.len());\n-                        let mut error = Ok(());\n-                        unescape_literal(&s, Mode::Str, &mut |_, unescaped_char| {\n-                            match unescaped_char {\n-                                Ok(c) => buf.push(c),\n-                                Err(err) => {\n-                                    if err.is_fatal() {\n-                                        error = Err(LitError::LexerError);\n-                                    }\n+                let symbol = if s.contains(&['\\\\', '\\r']) {\n+                    let mut buf = String::with_capacity(s.len());\n+                    let mut error = Ok(());\n+                    // Force-inlining here is aggressive but the closure is\n+                    // called on every char in the string, so it can be\n+                    // hot in programs with many long strings.\n+                    unescape_literal(\n+                        &s,\n+                        Mode::Str,\n+                        &mut #[inline(always)]\n+                        |_, unescaped_char| match unescaped_char {\n+                            Ok(c) => buf.push(c),\n+                            Err(err) => {\n+                                if err.is_fatal() {\n+                                    error = Err(LitError::LexerError);\n                                 }\n                             }\n-                        });\n-                        error?;\n-                        Symbol::intern(&buf)\n-                    } else {\n-                        symbol\n-                    };\n+                        },\n+                    );\n+                    error?;\n+                    Symbol::intern(&buf)\n+                } else {\n+                    symbol\n+                };\n                 LitKind::Str(symbol, ast::StrStyle::Cooked)\n             }\n             token::StrRaw(n) => {"}, {"sha": "97f9588ae1ef557a280a1cf1c93234c8d3b0c2ee", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ec44d48ae396e596f07ecc496f95da2b5ec36223/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec44d48ae396e596f07ecc496f95da2b5ec36223/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=ec44d48ae396e596f07ecc496f95da2b5ec36223", "patch": "@@ -159,26 +159,8 @@ impl Mode {\n     }\n }\n \n-fn scan_escape(first_char: char, chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n-    if first_char != '\\\\' {\n-        // Previous character was not a slash, and we don't expect it to be\n-        // an escape-only character.\n-        return match first_char {\n-            '\\t' | '\\n' => Err(EscapeError::EscapeOnlyChar),\n-            '\\r' => Err(EscapeError::BareCarriageReturn),\n-            '\\'' if mode.in_single_quotes() => Err(EscapeError::EscapeOnlyChar),\n-            '\"' if mode.in_double_quotes() => Err(EscapeError::EscapeOnlyChar),\n-            _ => {\n-                if mode.is_bytes() && !first_char.is_ascii() {\n-                    // Byte literal can't be a non-ascii character.\n-                    return Err(EscapeError::NonAsciiCharInByte);\n-                }\n-                Ok(first_char)\n-            }\n-        };\n-    }\n-\n-    // Previous character is '\\\\', try to unescape it.\n+fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n+    // Previous character was '\\\\', unescape what follows.\n \n     let second_char = chars.next().ok_or(EscapeError::LoneSlash)?;\n \n@@ -270,9 +252,24 @@ fn scan_escape(first_char: char, chars: &mut Chars<'_>, mode: Mode) -> Result<ch\n     Ok(res)\n }\n \n+#[inline]\n+fn ascii_check(first_char: char, mode: Mode) -> Result<char, EscapeError> {\n+    if mode.is_bytes() && !first_char.is_ascii() {\n+        // Byte literal can't be a non-ascii character.\n+        Err(EscapeError::NonAsciiCharInByte)\n+    } else {\n+        Ok(first_char)\n+    }\n+}\n+\n fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n     let first_char = chars.next().ok_or(EscapeError::ZeroChars)?;\n-    let res = scan_escape(first_char, chars, mode)?;\n+    let res = match first_char {\n+        '\\\\' => scan_escape(chars, mode),\n+        '\\n' | '\\t' | '\\'' => Err(EscapeError::EscapeOnlyChar),\n+        '\\r' => Err(EscapeError::BareCarriageReturn),\n+        _ => ascii_check(first_char, mode),\n+    }?;\n     if chars.next().is_some() {\n         return Err(EscapeError::MoreThanOneChar);\n     }\n@@ -303,12 +300,14 @@ where\n                         skip_ascii_whitespace(&mut chars, start, callback);\n                         continue;\n                     }\n-                    _ => scan_escape(first_char, &mut chars, mode),\n+                    _ => scan_escape(&mut chars, mode),\n                 }\n             }\n             '\\n' => Ok('\\n'),\n             '\\t' => Ok('\\t'),\n-            _ => scan_escape(first_char, &mut chars, mode),\n+            '\"' => Err(EscapeError::EscapeOnlyChar),\n+            '\\r' => Err(EscapeError::BareCarriageReturn),\n+            _ => ascii_check(first_char, mode),\n         };\n         let end = initial_len - chars.as_str().len();\n         callback(start..end, unescaped_char);"}]}