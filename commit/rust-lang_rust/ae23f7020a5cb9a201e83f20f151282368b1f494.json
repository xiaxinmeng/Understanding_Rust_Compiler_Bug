{"sha": "ae23f7020a5cb9a201e83f20f151282368b1f494", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMjNmNzAyMGE1Y2I5YTIwMWU4M2YyMGYxNTEyODIzNjhiMWY0OTQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-09T14:48:18Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-09T15:25:31Z"}, "message": "const-prop: use overflowing_unary_op for overflowing checking of unary ops", "tree": {"sha": "f1caac26adc6f817c660dbb5845a294f979d971a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1caac26adc6f817c660dbb5845a294f979d971a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae23f7020a5cb9a201e83f20f151282368b1f494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae23f7020a5cb9a201e83f20f151282368b1f494", "html_url": "https://github.com/rust-lang/rust/commit/ae23f7020a5cb9a201e83f20f151282368b1f494", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae23f7020a5cb9a201e83f20f151282368b1f494/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d2f6ae00149e4fdfeb9eedc9cb7433f6e67cf42", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d2f6ae00149e4fdfeb9eedc9cb7433f6e67cf42", "html_url": "https://github.com/rust-lang/rust/commit/7d2f6ae00149e4fdfeb9eedc9cb7433f6e67cf42"}], "stats": {"total": 34, "additions": 17, "deletions": 17}, "files": [{"sha": "d09165f904ab278902700da9b3fc877c95a36a34", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ae23f7020a5cb9a201e83f20f151282368b1f494/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23f7020a5cb9a201e83f20f151282368b1f494/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=ae23f7020a5cb9a201e83f20f151282368b1f494", "patch": "@@ -518,18 +518,19 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn check_unary_op(&mut self, arg: &Operand<'tcx>, source_info: SourceInfo) -> Option<()> {\n+    fn check_unary_op(\n+        &mut self,\n+        op: UnOp,\n+        arg: &Operand<'tcx>,\n+        source_info: SourceInfo,\n+    ) -> Option<()> {\n         self.use_ecx(source_info, |this| {\n-            let ty = arg.ty(&this.local_decls, this.tcx);\n-\n-            if ty.is_integral() {\n-                let arg = this.ecx.eval_operand(arg, None)?;\n-                let prim = this.ecx.read_immediate(arg)?;\n-                // Need to do overflow check here: For actual CTFE, MIR\n-                // generation emits code that does this before calling the op.\n-                if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n-                    throw_panic!(OverflowNeg)\n-                }\n+            let val = this.ecx.read_immediate(this.ecx.eval_operand(arg, None)?)?;\n+            let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, val)?;\n+\n+            if overflow {\n+                assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n+                throw_panic!(OverflowNeg);\n             }\n \n             Ok(())\n@@ -574,11 +575,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         if !overflow_check {\n             self.use_ecx(source_info, |this| {\n                 let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n-                let (_, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n+                let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n \n                 if overflow {\n-                    let err = err_panic!(Overflow(op)).into();\n-                    return Err(err);\n+                    throw_panic!(Overflow(op));\n                 }\n \n                 Ok(())\n@@ -618,9 +618,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // Additional checking: if overflow checks are disabled (which is usually the case in\n             // release mode), then we need to do additional checking here to give lints to the user\n             // if an overflow would occur.\n-            Rvalue::UnaryOp(UnOp::Neg, arg) if !overflow_check => {\n-                trace!(\"checking UnaryOp(op = Neg, arg = {:?})\", arg);\n-                self.check_unary_op(arg, source_info)?;\n+            Rvalue::UnaryOp(op, arg) if !overflow_check => {\n+                trace!(\"checking UnaryOp(op = {:?}, arg = {:?})\", op, arg);\n+                self.check_unary_op(*op, arg, source_info)?;\n             }\n \n             // Additional checking: check for overflows on integer binary operations and report"}]}