{"sha": "2e53da5126b970b394205256446c36a585e0f35e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlNTNkYTUxMjZiOTcwYjM5NDIwNTI1NjQ0NmMzNmE1ODVlMGYzNWU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-08-30T23:20:16Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-08-30T23:20:16Z"}, "message": "Typecheck function preconditions\n\nIt turned out that function preconditions weren't getting checked\nat all, so you could write a constraint on a fn decl that was total\nnonsense. Fixed now.", "tree": {"sha": "d592a6f14442bb785873aea1ca8de40016ad6139", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d592a6f14442bb785873aea1ca8de40016ad6139"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e53da5126b970b394205256446c36a585e0f35e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e53da5126b970b394205256446c36a585e0f35e", "html_url": "https://github.com/rust-lang/rust/commit/2e53da5126b970b394205256446c36a585e0f35e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e53da5126b970b394205256446c36a585e0f35e/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f62add95da3ad499103f296f1d05a556b842315c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f62add95da3ad499103f296f1d05a556b842315c", "html_url": "https://github.com/rust-lang/rust/commit/f62add95da3ad499103f296f1d05a556b842315c"}], "stats": {"total": 157, "additions": 107, "deletions": 50}, "files": [{"sha": "74fff2e82bd6bd45f1d7030528309dc711eb4501", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 107, "deletions": 50, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/2e53da5126b970b394205256446c36a585e0f35e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e53da5126b970b394205256446c36a585e0f35e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=2e53da5126b970b394205256446c36a585e0f35e", "patch": "@@ -979,9 +979,9 @@ mod demand {\n     // Requires that the two types unify, and prints an error message if they\n     // don't. Returns the unified type and the type parameter substitutions.\n     fn full(fcx: &@fn_ctxt, sp: &span, expected: ty::t, actual: ty::t,\n-            ty_param_substs_0: &[ty::t], do_block_coerece: bool) ->\n+            ty_param_substs_0: &[ty::t], do_block_coerce: bool) ->\n        ty_param_substs_and_ty {\n-        if do_block_coerece {\n+        if do_block_coerce {\n             actual = do_fn_block_coerce(fcx, sp, actual, expected);\n         }\n \n@@ -1715,54 +1715,6 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         ret bot;\n     }\n \n-    // A generic function for checking the pred in a check\n-    // or if-check\n-    fn check_pred_expr(fcx: &@fn_ctxt, e: &@ast::expr) -> bool {\n-        let bot = check_expr_with(fcx, e, ty::mk_bool(fcx.ccx.tcx));\n-\n-        /* e must be a call expr where all arguments are either\n-           literals or slots */\n-        alt e.node {\n-          ast::expr_call(operator, operands) {\n-            if !ty::is_pred_ty(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, operator)) {\n-                    fcx.ccx.tcx.sess.span_fatal(operator.span,\n-                     ~\"Operator in constraint has non-boolean return type\");\n-            }\n-\n-            alt operator.node {\n-              ast::expr_path(oper_name) {\n-                alt fcx.ccx.tcx.def_map.find(operator.id) {\n-                  some(ast::def_fn(_, ast::pure_fn.)) {\n-                    // do nothing\n-                  }\n-                  _ {\n-                    fcx.ccx.tcx.sess.span_fatal(operator.span,\n-                                           ~\"Impure function as operator \\\n-                                       in constraint\");\n-                  }\n-                }\n-                for operand: @ast::expr in operands {\n-                    if !ast_util::is_constraint_arg(operand) {\n-                        let s =\n-                            ~\"Constraint args must be \\\n-                                              slot variables or literals\";\n-                        fcx.ccx.tcx.sess.span_fatal(e.span, s);\n-                    }\n-                }\n-              }\n-              _ {\n-                let s =\n-                    ~\"In a constraint, expected the \\\n-                                      constraint name to be an explicit name\";\n-                fcx.ccx.tcx.sess.span_fatal(e.span, s);\n-              }\n-            }\n-          }\n-          _ { fcx.ccx.tcx.sess.span_fatal(\n-              e.span, ~\"check on non-predicate\"); }\n-        }\n-        ret bot;\n-    }\n \n     // A generic function for checking the then and else in an if\n     // or if-check\n@@ -2604,6 +2556,110 @@ fn check_const(ccx: &@crate_ctxt, _sp: &span, e: &@ast::expr,\n     check_expr(fcx, e);\n }\n \n+// A generic function for checking the pred in a check\n+// or if-check\n+fn check_pred_expr(fcx: &@fn_ctxt, e: &@ast::expr) -> bool {\n+    let bot = check_expr_with(fcx, e, ty::mk_bool(fcx.ccx.tcx));\n+\n+    /* e must be a call expr where all arguments are either\n+    literals or slots */\n+    alt e.node {\n+      ast::expr_call(operator, operands) {\n+        if !ty::is_pred_ty(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, operator)) {\n+            fcx.ccx.tcx.sess.span_fatal(operator.span,\n+                 ~\"Operator in constraint has non-boolean return type\");\n+        }\n+\n+        alt operator.node {\n+          ast::expr_path(oper_name) {\n+            alt fcx.ccx.tcx.def_map.find(operator.id) {\n+              some(ast::def_fn(_, ast::pure_fn.)) {\n+                // do nothing\n+              }\n+              _ {\n+                fcx.ccx.tcx.sess.span_fatal(operator.span,\n+                                            ~\"Impure function as operator \\\n+in constraint\");\n+              }\n+            }\n+            for operand: @ast::expr in operands {\n+                if !ast_util::is_constraint_arg(operand) {\n+                    let s =\n+                        ~\"Constraint args must be \\\n+slot variables or literals\";\n+                    fcx.ccx.tcx.sess.span_fatal(e.span, s);\n+                }\n+            }\n+          }\n+          _ {\n+            let s =\n+                ~\"In a constraint, expected the \\\n+constraint name to be an explicit name\";\n+            fcx.ccx.tcx.sess.span_fatal(e.span, s);\n+          }\n+        }\n+      }\n+      _ { fcx.ccx.tcx.sess.span_fatal(\n+          e.span, ~\"check on non-predicate\"); }\n+    }\n+    ret bot;\n+}\n+\n+fn check_constraints(fcx: &@fn_ctxt, cs: [@ast::constr], args:[ast::arg]) {\n+    let c_args;\n+    let num_args = vec::len(args);\n+    for c: @ast::constr in cs {\n+        c_args = [];\n+        for a: @spanned<ast::fn_constr_arg> in c.node.args {\n+            c_args += [@(alt a.node {\n+              ast::carg_base. {\n+                // \"base\" should not occur in a fn type thing, as of\n+                // yet, b/c we don't allow constraints on the return type\n+\n+                fcx.ccx.tcx.sess.span_bug(a.span, ~\"check_constraints:\\\n+                    unexpected carg_base\");\n+              }\n+              ast::carg_lit(l) {\n+                let tmp_node_id = fcx.ccx.tcx.sess.next_node_id();\n+                {id:tmp_node_id, node: ast::expr_lit(l), span:a.span} }\n+              ast::carg_ident(i) {\n+                if i < num_args {\n+                    let p : ast::path_ =\n+                        {global:false, idents:[(args[i]).ident],\n+                         // Works b/c no higher-order polymorphism\n+                         types:[]};\n+                    /*\n+                    This is kludgy, and we probably shouldn't be assigning\n+                    node IDs here, but we're creating exprs that are\n+                    ephemeral, just for the purposes of typechecking. So\n+                    that's my justification.\n+                    */\n+                    let arg_occ_node_id = fcx.ccx.tcx.sess.next_node_id();\n+                    fcx.ccx.tcx.def_map.insert(arg_occ_node_id,\n+                                       ast::def_arg(local_def(args[i].id)));\n+                    {id:arg_occ_node_id,\n+                     node: ast::expr_path(respan(a.span, p)),\n+                     span:a.span}\n+                }\n+                else {\n+                    fcx.ccx.tcx.sess.span_bug(a.span, ~\"check_constraints:\\\n+                     carg_ident index out of bounds\");\n+                }\n+              }\n+            })]\n+        }\n+        let p_op: ast::expr_ = ast::expr_path(c.node.path);\n+        let oper: @ast::expr = @{id:c.node.id,\n+                                 node: p_op, span:c.span};\n+        // Another ephemeral expr\n+        let call_expr_id = fcx.ccx.tcx.sess.next_node_id();\n+        let call_expr = @{id: call_expr_id,\n+                          node: ast::expr_call(oper, c_args),\n+                          span: c.span};\n+        check_pred_expr(fcx, call_expr);\n+    }\n+}\n+\n fn check_fn(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n             old_fcx: &option::t<@fn_ctxt>) {\n     let decl = f.decl;\n@@ -2620,6 +2676,7 @@ fn check_fn(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n           next_var_id: gather_result.next_var_id,\n           mutable fixups: fixups,\n           ccx: ccx};\n+    check_constraints(fcx, decl.constraints, decl.inputs);\n     check_block(fcx, body);\n \n     // For non-iterator fns, we unify the tail expr's type with the"}]}