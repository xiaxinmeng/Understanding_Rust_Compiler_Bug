{"sha": "9c9615eb6f59acc394e338d529f22273fe3a1cd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljOTYxNWViNmY1OWFjYzM5NGUzMzhkNTI5ZjIyMjczZmUzYTFjZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-15T09:04:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-15T09:04:34Z"}, "message": "Auto merge of #29070 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #28906, #29022, #29047, #29058, #29059, #29060, #29062, #29066, #29068\n- Failed merges:", "tree": {"sha": "2907c5f2b902e75308ef94f7977f6641978a9e30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2907c5f2b902e75308ef94f7977f6641978a9e30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c9615eb6f59acc394e338d529f22273fe3a1cd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c9615eb6f59acc394e338d529f22273fe3a1cd7", "html_url": "https://github.com/rust-lang/rust/commit/9c9615eb6f59acc394e338d529f22273fe3a1cd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c9615eb6f59acc394e338d529f22273fe3a1cd7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa9a4213945d63d5505039429329694ddfe1875d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa9a4213945d63d5505039429329694ddfe1875d", "html_url": "https://github.com/rust-lang/rust/commit/fa9a4213945d63d5505039429329694ddfe1875d"}, {"sha": "7c7195d563cf342b61e6365af4c1d4a1ec7844e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c7195d563cf342b61e6365af4c1d4a1ec7844e3", "html_url": "https://github.com/rust-lang/rust/commit/7c7195d563cf342b61e6365af4c1d4a1ec7844e3"}], "stats": {"total": 271, "additions": 137, "deletions": 134}, "files": [{"sha": "e2a957e396191150bda46f9610b0a9a44d8f9714", "filename": "COMPILER_TESTS.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/COMPILER_TESTS.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/COMPILER_TESTS.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COMPILER_TESTS.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -1,6 +1,6 @@\n # Compiler Test Documentation\n \n-In the Rust project, we use a special set of comands embedded in\n+In the Rust project, we use a special set of commands embedded in\n comments to test the Rust compiler. There are two groups of commands:\n \n 1. Header commands"}, {"sha": "05c17606ce0342f705cfe52c36dd24d7cfa075f8", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -76,7 +76,7 @@ Cleanup through RAII-style destructors is more likely to work than in catch bloc\n \n ## Why aren't modules type-parametric?\n \n-We want to maintain the option to parametrize at runtime. We may eventually change this limitation, but initially this is how type parameters were implemented.\n+We want to maintain the option to parameterize at runtime. We may eventually change this limitation, but initially this is how type parameters were implemented.\n \n ## Why aren't values type-parametric? Why only items?\n "}, {"sha": "6cc41bd9533c76f6ed51157a57b57c484daa106c", "filename": "src/doc/nomicon/casts.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fcasts.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fcasts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fcasts.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -52,7 +52,7 @@ For numeric casts, there are quite a few cases to consider:\n     * zero-extend if the source is unsigned\n     * sign-extend if the source is signed\n * casting from a float to an integer will round the float towards zero\n-    * **[NOTE: currently this will cause Undefined Behaviour if the rounded\n+    * **[NOTE: currently this will cause Undefined Behavior if the rounded\n       value cannot be represented by the target integer type][float-int]**.\n       This includes Inf and NaN. This is a bug and will be fixed.\n * casting from an integer to float will produce the floating point\n@@ -61,7 +61,7 @@ For numeric casts, there are quite a few cases to consider:\n * casting from an f32 to an f64 is perfect and lossless\n * casting from an f64 to an f32 will produce the closest possible value\n   (rounding strategy unspecified)\n-    * **[NOTE: currently this will cause Undefined Behaviour if the value\n+    * **[NOTE: currently this will cause Undefined Behavior if the value\n       is finite but larger or smaller than the largest or smallest finite\n       value representable by f32][float-float]**. This is a bug and will\n       be fixed."}, {"sha": "95bcdc02ba0292da5b0522e09efb66657bfb2b0f", "filename": "src/doc/nomicon/dropck.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fdropck.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fdropck.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdropck.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -6,7 +6,7 @@ interacted with the *outlives* relationship in an inclusive manner. That is,\n when we talked about `'a: 'b`, it was ok for `'a` to live *exactly* as long as\n `'b`. At first glance, this seems to be a meaningless distinction. Nothing ever\n gets dropped at the same time as another, right? This is why we used the\n-following desugarring of `let` statements:\n+following desugaring of `let` statements:\n \n ```rust,ignore\n let x;"}, {"sha": "052e3c5fddc551ac81be5791c049ea302fff5d58", "filename": "src/doc/nomicon/exotic-sizes.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fexotic-sizes.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fexotic-sizes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fexotic-sizes.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -20,7 +20,7 @@ information that \"completes\" them (more on this below).\n There are two major DSTs exposed by the language: trait objects, and slices.\n \n A trait object represents some type that implements the traits it specifies.\n-The exact original type is *erased* in favour of runtime reflection\n+The exact original type is *erased* in favor of runtime reflection\n with a vtable containing all the information necessary to use the type.\n This is the information that completes a trait object: a pointer to its vtable.\n \n@@ -128,7 +128,7 @@ But neither of these tricks work today, so all Void types get you is\n the ability to be confident that certain situations are statically impossible.\n \n One final subtle detail about empty types is that raw pointers to them are\n-actually valid to construct, but dereferencing them is Undefined Behaviour\n+actually valid to construct, but dereferencing them is Undefined Behavior\n because that doesn't actually make sense. That is, you could model C's `void *`\n type with `*const Void`, but this doesn't necessarily gain anything over using\n e.g. `*const ()`, which *is* safe to randomly dereference."}, {"sha": "1f72a4c17247057e92ce65e1512cdafda3d87004", "filename": "src/doc/nomicon/leaking.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fleaking.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fleaking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fleaking.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -90,7 +90,7 @@ let mut vec = vec![Box::new(0); 4];\n println!(\"{}\", vec[0]);\n ```\n \n-This is pretty clearly Not Good. Unfortunately, we're kind've stuck between a\n+This is pretty clearly Not Good. Unfortunately, we're kind of stuck between a\n rock and a hard place: maintaining consistent state at every step has an\n enormous cost (and would negate any benefits of the API). Failing to maintain\n consistent state gives us Undefined Behavior in safe code (making the API\n@@ -248,4 +248,4 @@ let mut data = Box::new(0);\n ```\n \n Dang. Here the destructor running was pretty fundamental to the API, and it had\n-to be scrapped in favour of a completely different design.\n+to be scrapped in favor of a completely different design."}, {"sha": "978d0518729ea5705e37c19834a41b6337fb0e42", "filename": "src/doc/nomicon/meet-safe-and-unsafe.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fmeet-safe-and-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fmeet-safe-and-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fmeet-safe-and-unsafe.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -26,7 +26,7 @@ do some really crazy unsafe things.\n \n Safe Rust is the *true* Rust programming language. If all you do is write Safe\n Rust, you will never have to worry about type-safety or memory-safety. You will\n-never endure a null or dangling pointer, or any of that Undefined Behaviour\n+never endure a null or dangling pointer, or any of that Undefined Behavior\n nonsense.\n \n *That's totally awesome.*\n@@ -52,11 +52,11 @@ The only things that are different in Unsafe Rust are that you can:\n * Mutate statics\n \n That's it. The reason these operations are relegated to Unsafe is that misusing\n-any of these things will cause the ever dreaded Undefined Behaviour. Invoking\n-Undefined Behaviour gives the compiler full rights to do arbitrarily bad things\n-to your program. You definitely *should not* invoke Undefined Behaviour.\n+any of these things will cause the ever dreaded Undefined Behavior. Invoking\n+Undefined Behavior gives the compiler full rights to do arbitrarily bad things\n+to your program. You definitely *should not* invoke Undefined Behavior.\n \n-Unlike C, Undefined Behaviour is pretty limited in scope in Rust. All the core\n+Unlike C, Undefined Behavior is pretty limited in scope in Rust. All the core\n language cares about is preventing the following things:\n \n * Dereferencing null or dangling pointers\n@@ -71,9 +71,9 @@ language cares about is preventing the following things:\n * Unwinding into another language\n * Causing a [data race][race]\n \n-That's it. That's all the causes of Undefined Behaviour baked into Rust. Of\n+That's it. That's all the causes of Undefined Behavior baked into Rust. Of\n course, unsafe functions and traits are free to declare arbitrary other\n-constraints that a program must maintain to avoid Undefined Behaviour. However,\n+constraints that a program must maintain to avoid Undefined Behavior. However,\n generally violations of these constraints will just transitively lead to one of\n the above problems. Some additional constraints may also derive from compiler\n intrinsics that make special assumptions about how code can be optimized."}, {"sha": "f0732cf26562cf21459a5fc8bcffa574fc5d8386", "filename": "src/doc/nomicon/races.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fraces.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fraces.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fraces.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -6,7 +6,7 @@ Safe Rust guarantees an absence of data races, which are defined as:\n * one of them is a write\n * one of them is unsynchronized\n \n-A data race has Undefined Behaviour, and is therefore impossible to perform\n+A data race has Undefined Behavior, and is therefore impossible to perform\n in Safe Rust. Data races are *mostly* prevented through rust's ownership system:\n it's impossible to alias a mutable reference, so it's impossible to perform a\n data race. Interior mutability makes this more complicated, which is largely why\n@@ -53,7 +53,7 @@ thread::spawn(move || {\n // bounds checked, and there's no chance of the value getting changed\n // in the middle. However our program may panic if the thread we spawned\n // managed to increment before this ran. A race condition because correct\n-// program execution (panicing is rarely correct) depends on order of\n+// program execution (panicking is rarely correct) depends on order of\n // thread execution.\n println!(\"{}\", data[idx.load(Ordering::SeqCst)]);\n ```"}, {"sha": "f5d7023fad5de366e58844e0c5b579276f22baeb", "filename": "src/doc/nomicon/safe-unsafe-meaning.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -41,7 +41,7 @@ Some examples of unsafe functions:\n \n * `slice::get_unchecked` will perform unchecked indexing, allowing memory\n   safety to be freely violated.\n-* `ptr::offset` is an intrinsic that invokes Undefined Behaviour if it is\n+* `ptr::offset` is an intrinsic that invokes Undefined Behavior if it is\n   not \"in bounds\" as defined by LLVM.\n * `mem::transmute` reinterprets some value as having the given type,\n   bypassing type safety in arbitrary ways. (see [conversions] for details)\n@@ -59,9 +59,9 @@ As of Rust 1.0 there are exactly two unsafe traits:\n The need for unsafe traits boils down to the fundamental property of safe code:\n \n **No matter how completely awful Safe code is, it can't cause Undefined\n-Behaviour.**\n+Behavior.**\n \n-This means that Unsafe Rust, **the royal vanguard of Undefined Behaviour**, has to be\n+This means that Unsafe Rust, **the royal vanguard of Undefined Behavior**, has to be\n *super paranoid* about generic safe code. To be clear, Unsafe Rust is totally free to trust\n specific safe code. Anything else would degenerate into infinite spirals of\n paranoid despair. In particular it's generally regarded as ok to trust the standard library"}, {"sha": "134e47f18dcf0ccebf041854e4fa1af54460b1aa", "filename": "src/doc/nomicon/send-and-sync.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fsend-and-sync.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fsend-and-sync.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsend-and-sync.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -15,7 +15,7 @@ implement, and other unsafe code can assume that they are correctly\n implemented. Since they're *marker traits* (they have no associated items like\n methods), correctly implemented simply means that they have the intrinsic\n properties an implementor should have. Incorrectly implementing Send or Sync can\n-cause Undefined Behaviour.\n+cause Undefined Behavior.\n \n Send and Sync are also automatically derived traits. This means that, unlike\n every other trait, if a type is composed entirely of Send or Sync types, then it"}, {"sha": "f1478b7f668d33e67cd035d0e557d1d991a92431", "filename": "src/doc/nomicon/transmutes.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Ftransmutes.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Ftransmutes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Ftransmutes.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -8,7 +8,7 @@ horribly unsafe thing you can do in Rust. The railguards here are dental floss.\n \n `mem::transmute<T, U>` takes a value of type `T` and reinterprets it to have\n type `U`. The only restriction is that the `T` and `U` are verified to have the\n-same size. The ways to cause Undefined Behaviour with this are mind boggling.\n+same size. The ways to cause Undefined Behavior with this are mind boggling.\n \n * First and foremost, creating an instance of *any* type with an invalid state\n   is going to cause arbitrary chaos that can't really be predicted.\n@@ -26,7 +26,7 @@ same size. The ways to cause Undefined Behaviour with this are mind boggling.\n `mem::transmute_copy<T, U>` somehow manages to be *even more* wildly unsafe than\n this. It copies `size_of<U>` bytes out of an `&T` and interprets them as a `U`.\n The size check that `mem::transmute` has is gone (as it may be valid to copy\n-out a prefix), though it is Undefined Behaviour for `U` to be larger than `T`.\n+out a prefix), though it is Undefined Behavior for `U` to be larger than `T`.\n \n Also of course you can get most of the functionality of these functions using\n pointer casts."}, {"sha": "2c5ba79a5078f1820daba439f613085725df0896", "filename": "src/doc/nomicon/unbounded-lifetimes.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Funbounded-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Funbounded-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Funbounded-lifetimes.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -2,15 +2,15 @@\n \n Unsafe code can often end up producing references or lifetimes out of thin air.\n Such lifetimes come into the world as *unbounded*. The most common source of this\n-is derefencing a raw pointer, which produces a reference with an unbounded lifetime.\n+is dereferencing a raw pointer, which produces a reference with an unbounded lifetime.\n Such a lifetime becomes as big as context demands. This is in fact more powerful\n than simply becoming `'static`, because for instance `&'static &'a T`\n will fail to typecheck, but the unbound lifetime will perfectly mold into\n `&'a &'a T` as needed. However for most intents and purposes, such an unbounded\n lifetime can be regarded as `'static`.\n \n Almost no reference is `'static`, so this is probably wrong. `transmute` and\n-`transmute_copy` are the two other primary offenders. One should endeavour to\n+`transmute_copy` are the two other primary offenders. One should endeavor to\n bound an unbounded lifetime as quick as possible, especially across function\n boundaries.\n "}, {"sha": "c72ed8a76329982b2582202dbf4d4d1c5b83771f", "filename": "src/doc/nomicon/unchecked-uninit.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Funchecked-uninit.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Funchecked-uninit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Funchecked-uninit.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -38,7 +38,7 @@ dropping the old value: `write`, `copy`, and `copy_nonoverlapping`.\n   (this is equivalent to memcpy -- note that the argument order is reversed!)\n \n It should go without saying that these functions, if misused, will cause serious\n-havoc or just straight up Undefined Behaviour. The only things that these\n+havoc or just straight up Undefined Behavior. The only things that these\n functions *themselves* require is that the locations you want to read and write\n are allocated. However the ways writing arbitrary bits to arbitrary\n locations of memory can break things are basically uncountable!"}, {"sha": "05615d89bec77a530522a4e227bb0ea5309d92ee", "filename": "src/doc/nomicon/uninitialized.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Funinitialized.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Funinitialized.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Funinitialized.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -4,7 +4,7 @@ All runtime-allocated memory in a Rust program begins its life as\n *uninitialized*. In this state the value of the memory is an indeterminate pile\n of bits that may or may not even reflect a valid state for the type that is\n supposed to inhabit that location of memory. Attempting to interpret this memory\n-as a value of *any* type will cause Undefined Behaviour. Do Not Do This.\n+as a value of *any* type will cause Undefined Behavior. Do Not Do This.\n \n Rust provides mechanisms to work with uninitialized memory in checked (safe) and\n-unchecked (unsafe) ways.\n\\ No newline at end of file\n+unchecked (unsafe) ways."}, {"sha": "e81f06b83b2496d61b7238a15758e4c8f240b8ce", "filename": "src/doc/nomicon/unwinding.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Funwinding.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Funwinding.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Funwinding.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -42,7 +42,7 @@ should only panic for programming errors or *extreme* problems.\n \n Rust's unwinding strategy is not specified to be fundamentally compatible\n with any other language's unwinding. As such, unwinding into Rust from another\n-language, or unwinding into another language from Rust is Undefined Behaviour.\n+language, or unwinding into another language from Rust is Undefined Behavior.\n You must *absolutely* catch any panics at the FFI boundary! What you do at that\n point is up to you, but *something* must be done. If you fail to do this,\n at best, your application will crash and burn. At worst, your application *won't*"}, {"sha": "7ca369da0b886be266de71952bc08704f4bb6a49", "filename": "src/doc/nomicon/vec-layout.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fvec-layout.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fvec-layout.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fvec-layout.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -93,7 +93,7 @@ pub struct Vec<T> {\n If you don't care about the null-pointer optimization, then you can use the\n stable code. However we will be designing the rest of the code around enabling\n the optimization. In particular, `Unique::new` is unsafe to call, because\n-putting `null` inside of it is Undefined Behaviour. Our stable Unique doesn't\n+putting `null` inside of it is Undefined Behavior. Our stable Unique doesn't\n need `new` to be unsafe because it doesn't make any interesting guarantees about\n its contents.\n "}, {"sha": "5e747a8c71d41bd38daf0377bbe9a41df51d0d59", "filename": "src/doc/nomicon/vec-push-pop.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fvec-push-pop.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fvec-push-pop.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fvec-push-pop.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -34,7 +34,7 @@ Easy! How about `pop`? Although this time the index we want to access is\n initialized, Rust won't just let us dereference the location of memory to move\n the value out, because that would leave the memory uninitialized! For this we\n need `ptr::read`, which just copies out the bits from the target address and\n-intrprets it as a value of type T. This will leave the memory at this address\n+interprets it as a value of type T. This will leave the memory at this address\n logically uninitialized, even though there is in fact a perfectly good instance\n of T there.\n "}, {"sha": "fb337a891a8d42ddb50ac5ed224d931b2fee71ae", "filename": "src/doc/nomicon/vec-zsts.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fvec-zsts.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fnomicon%2Fvec-zsts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fvec-zsts.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -1,6 +1,6 @@\n % Handling Zero-Sized Types\n \n-It's time. We're going to fight the spectre that is zero-sized types. Safe Rust\n+It's time. We're going to fight the specter that is zero-sized types. Safe Rust\n *never* needs to care about this, but Vec is very intensive on raw pointers and\n raw allocations, which are exactly the two things that care about\n zero-sized types. We need to be careful of two things:"}, {"sha": "a9e12833906db57caaf8d9bd3cfe902e001eed9a", "filename": "src/doc/reference.md", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -419,10 +419,13 @@ The two values of the boolean type are written `true` and `false`.\n ### Symbols\n \n Symbols are a general class of printable [tokens](#tokens) that play structural\n-roles in a variety of grammar productions. They are cataloged here for\n-completeness as the set of remaining miscellaneous printable tokens that do not\n+roles in a variety of grammar productions. They are a\n+set of remaining miscellaneous printable tokens that do not\n otherwise appear as [unary operators](#unary-operator-expressions), [binary\n operators](#binary-operator-expressions), or [keywords][keywords].\n+They are catalogued in [the Symbols section][symbols] of the Grammar document.\n+\n+[symbols]: grammar.html#symbols\n \n \n ## Paths\n@@ -1073,7 +1076,7 @@ let p: Point = (41, 68);\n \n ### Structs\n \n-A _structure_ is a nominal [structure type](#structure-types) defined with the\n+A _struct_ is a nominal [struct type](#struct-types) defined with the\n keyword `struct`.\n \n An example of a `struct` item and its use:\n@@ -1084,7 +1087,7 @@ let p = Point {x: 10, y: 11};\n let px: i32 = p.x;\n ```\n \n-A _tuple structure_ is a nominal [tuple type](#tuple-types), also defined with\n+A _tuple struct_ is a nominal [tuple type](#tuple-types), also defined with\n the keyword `struct`. For example:\n \n ```\n@@ -1093,8 +1096,8 @@ let p = Point(10, 11);\n let px: i32 = match p { Point(x, _) => x };\n ```\n \n-A _unit-like struct_ is a structure without any fields, defined by leaving off\n-the list of fields entirely. Such a structure implicitly defines a constant of\n+A _unit-like struct_ is a struct without any fields, defined by leaving off\n+the list of fields entirely. Such a struct implicitly defines a constant of\n its type with the same name. For example:\n \n ```\n@@ -1112,7 +1115,7 @@ const Cookie: Cookie = Cookie {};\n let c = [Cookie, Cookie {}, Cookie, Cookie {}];\n ```\n \n-The precise memory layout of a structure is not specified. One can specify a\n+The precise memory layout of a struct is not specified. One can specify a\n particular layout using the [`repr` attribute](#ffi-attributes).\n \n ### Enumerations\n@@ -2401,7 +2404,7 @@ items.\n \n An _item declaration statement_ has a syntactic form identical to an\n [item](#items) declaration within a module. Declaring an item &mdash; a\n-function, enumeration, structure, type, static, trait, implementation or module\n+function, enumeration, struct, type, static, trait, implementation or module\n &mdash; locally within a statement block is simply a way of restricting its\n scope to a narrow region containing all of its uses; it is otherwise identical\n in meaning to declaring the item outside the statement block.\n@@ -2546,26 +2549,26 @@ comma:\n (0); // zero in parentheses\n ```\n \n-### Structure expressions\n+### Struct expressions\n \n-There are several forms of structure expressions. A _structure expression_\n-consists of the [path](#paths) of a [structure item](#structs), followed by\n+There are several forms of struct expressions. A _struct expression_\n+consists of the [path](#paths) of a [struct item](#structs), followed by\n a brace-enclosed list of one or more comma-separated name-value pairs,\n-providing the field values of a new instance of the structure. A field name\n+providing the field values of a new instance of the struct. A field name\n can be any identifier, and is separated from its value expression by a colon.\n-The location denoted by a structure field is mutable if and only if the\n-enclosing structure is mutable.\n+The location denoted by a struct field is mutable if and only if the\n+enclosing struct is mutable.\n \n-A _tuple structure expression_ consists of the [path](#paths) of a [structure\n+A _tuple struct expression_ consists of the [path](#paths) of a [struct\n item](#structs), followed by a parenthesized list of one or more\n-comma-separated expressions (in other words, the path of a structure item\n-followed by a tuple expression). The structure item must be a tuple structure\n+comma-separated expressions (in other words, the path of a struct item\n+followed by a tuple expression). The struct item must be a tuple struct\n item.\n \n-A _unit-like structure expression_ consists only of the [path](#paths) of a\n-[structure item](#structs).\n+A _unit-like struct expression_ consists only of the [path](#paths) of a\n+[struct item](#structs).\n \n-The following are examples of structure expressions:\n+The following are examples of struct expressions:\n \n ```\n # struct Point { x: f64, y: f64 }\n@@ -2578,14 +2581,14 @@ let u = game::User {name: \"Joe\", age: 35, score: 100_000};\n some_fn::<Cookie>(Cookie);\n ```\n \n-A structure expression forms a new value of the named structure type. Note\n-that for a given *unit-like* structure type, this will always be the same\n+A struct expression forms a new value of the named struct type. Note\n+that for a given *unit-like* struct type, this will always be the same\n value.\n \n-A structure expression can terminate with the syntax `..` followed by an\n+A struct expression can terminate with the syntax `..` followed by an\n expression to denote a functional update. The expression following `..` (the\n-base) must have the same structure type as the new structure type being formed.\n-The entire expression denotes the result of constructing a new structure (with\n+base) must have the same struct type as the new struct type being formed.\n+The entire expression denotes the result of constructing a new struct (with\n the same type as the base expression) with the given values for the fields that\n were explicitly specified and the values in the base expression for all other\n fields.\n@@ -2631,7 +2634,7 @@ the left-hand-side expression is an indirect [trait object](#trait-objects).\n A _field expression_ consists of an expression followed by a single dot and an\n identifier, when not immediately followed by a parenthesized expression-list\n (the latter is a [method call expression](#method-call-expressions)). A field\n-expression denotes a field of a [structure](#structure-types).\n+expression denotes a field of a [struct](#struct-types).\n \n ```{.ignore .field}\n mystruct.myfield;\n@@ -3350,17 +3353,17 @@ As you can see, the `vec!` macro allows you to create a `Vec<T>` easily. The\n All in-bounds elements of arrays and slices are always initialized, and access\n to an array or slice is always bounds-checked.\n \n-### Structure types\n+### Struct types\n \n A `struct` *type* is a heterogeneous product of other types, called the\n *fields* of the type.[^structtype]\n \n [^structtype]: `struct` types are analogous to `struct` types in C,\n     the *record* types of the ML family,\n-    or the *structure* types of the Lisp family.\n+    or the *struct* types of the Lisp family.\n \n New instances of a `struct` can be constructed with a [struct\n-expression](#structure-expressions).\n+expression](#struct-expressions).\n \n The memory layout of a `struct` is undefined by default to allow for compiler\n optimizations like field reordering, but it can be fixed with the\n@@ -3370,14 +3373,14 @@ have the same memory layout.\n \n The fields of a `struct` may be qualified by [visibility\n modifiers](#visibility-and-privacy), to allow access to data in a\n-structure outside a module.\n+struct outside a module.\n \n-A _tuple struct_ type is just like a structure type, except that the fields are\n+A _tuple struct_ type is just like a struct type, except that the fields are\n anonymous.\n \n-A _unit-like struct_ type is like a structure type, except that it has no\n-fields. The one value constructed by the associated [structure\n-expression](#structure-expressions) is the only value that inhabits such a\n+A _unit-like struct_ type is like a struct type, except that it has no\n+fields. The one value constructed by the associated [struct\n+expression](#struct-expressions) is the only value that inhabits such a\n type.\n \n ### Enumerated types\n@@ -3404,7 +3407,7 @@ named reference to an [`enum` item](#enumerations).\n ### Recursive types\n \n Nominal types &mdash; [enumerations](#enumerated-types) and\n-[structs](#structure-types) &mdash; may be recursive. That is, each `enum`\n+[structs](#struct-types) &mdash; may be recursive. That is, each `enum`\n constructor or `struct` field may refer, directly or indirectly, to the\n enclosing `enum` or `struct` type itself. Such recursion has restrictions:\n \n@@ -3706,7 +3709,7 @@ repeated sub-expression is a coercion site for coercion to type `U`.\n Each sub-expression is a coercion site to the respective type, e.g. the\n zeroth sub-expression is a coercion site to type `U_0`.\n \n-* Parenthesised sub-expressions (`(e)`): if the expression has type `U`, then\n+* Parenthesized sub-expressions (`(e)`): if the expression has type `U`, then\n the sub-expression is a coercion site to `U`.\n \n * Blocks: if a block has type `U`, then the last expression in the block (if\n@@ -4072,7 +4075,7 @@ that have since been removed):\n \n * SML, OCaml: algebraic data types, pattern matching, type inference,\n   semicolon statement separation\n-* C++: references, RAII, smart pointers, move semantics, monomorphisation,\n+* C++: references, RAII, smart pointers, move semantics, monomorphization,\n   memory model\n * ML Kit, Cyclone: region based memory management\n * Haskell (GHC): typeclasses, type families"}, {"sha": "c55b38b915b3d1d9e6241d324cee7fec6a003271", "filename": "src/doc/style/features/modules.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fstyle%2Ffeatures%2Fmodules.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fstyle%2Ffeatures%2Fmodules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Fmodules.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -17,12 +17,12 @@ Organize module headers as follows:\n Avoid using `#[path=\"...\"]` directives; make the file system and\n module hierarchy match, instead.\n \n-### Use the module hirearchy to organize APIs into coherent sections. [FIXME]\n+### Use the module hierarchy to organize APIs into coherent sections. [FIXME]\n \n > **[FIXME]** Flesh this out with examples; explain what a \"coherent\n > section\" is with examples.\n >\n-> The module hirearchy defines both the public and internal API of your module.\n+> The module hierarchy defines both the public and internal API of your module.\n > Breaking related functionality into submodules makes it understandable to both\n > users and contributors to the module.\n \n@@ -82,7 +82,7 @@ io/mod.rs\n ```\n \n While it is possible to define all of `io` within a single directory,\n-mirroring the module hirearchy in the directory structure makes\n+mirroring the module hierarchy in the directory structure makes\n submodules of `io::net` easier to find.\n \n ### Consider top-level definitions or reexports. [FIXME: needs RFC]\n@@ -104,13 +104,13 @@ while\n [`TcpStream`](https://doc.rust-lang.org/std/io/net/tcp/struct.TcpStream.html)\n is defined in `io/net/tcp.rs` and reexported in the `io` module.\n \n-### Use internal module hirearchies for organization. [FIXME: needs RFC]\n+### Use internal module hierarchies for organization. [FIXME: needs RFC]\n \n > **[FIXME]**\n > - Referencing internal modules from the standard library is subject to\n >   becoming outdated.\n \n-Internal module hirearchies (i.e., private submodules) may be used to\n+Internal module hierarchies (i.e., private submodules) may be used to\n hide implementation details that are not part of the module's API.\n \n For example, in [`std::io`](https://doc.rust-lang.org/std/io/), `mod mem`"}, {"sha": "feedd3937fc9dcac67e804cff5ced6af966c177e", "filename": "src/doc/style/features/traits/reuse.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Freuse.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Freuse.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Freuse.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -5,7 +5,7 @@\n > **[FIXME]** We probably want to discourage this, at least when used in a way\n > that is publicly exposed.\n \n-Traits that provide default implmentations for function can provide code reuse\n+Traits that provide default implementations for function can provide code reuse\n across types. For example, a `print` method can be defined across multiple\n types as follows:\n "}, {"sha": "28702d95b60a7ab06fbdccf3b31ca14d6d0723b3", "filename": "src/doc/trpl/dining-philosophers.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -13,7 +13,7 @@ Hoare in 1985.\n > dining room, furnished with a circular table, surrounded by five chairs, each\n > labelled by the name of the philosopher who was to sit in it. They sat\n > anticlockwise around the table. To the left of each philosopher there was\n-> laid a golden fork, and in the centre stood a large bowl of spaghetti, which\n+> laid a golden fork, and in the center stood a large bowl of spaghetti, which\n > was constantly replenished. A philosopher was expected to spend most of\n > their time thinking; but when they felt hungry, they went to the dining\n > room, sat down in their own chair, picked up their own fork on their left,"}, {"sha": "faa922acb3de282805cb17f898d2c08f92f6d72d", "filename": "src/doc/trpl/if-let.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Ftrpl%2Fif-let.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Ftrpl%2Fif-let.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif-let.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -41,7 +41,7 @@ If a [pattern][patterns] matches successfully, it binds any appropriate parts of\n the value to the identifiers in the pattern, then evaluates the expression. If\n the pattern doesn\u2019t match, nothing happens.\n \n-If you\u2019d rather to do something else when the pattern does not match, you can\n+If you want to do something else when the pattern does not match, you can\n use `else`:\n \n ```rust\n@@ -65,7 +65,7 @@ loop as long as a value matches a certain pattern. It turns code like this:\n loop {\n     match option {\n         Some(x) => println!(\"{}\", x),\n-        _ => break,\n+        None => break,\n     }\n }\n ```"}, {"sha": "c444f9f2fe53d420e5cbae1bbb63007e2c51d965", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -101,10 +101,10 @@ So, now that we've established that ranges are often not what you want, let's\n talk about what you do want instead.\n \n There are three broad classes of things that are relevant here: iterators,\n-*iterator adapters*, and *consumers*. Here's some definitions:\n+*iterator adaptors*, and *consumers*. Here's some definitions:\n \n * *iterators* give you a sequence of values.\n-* *iterator adapters* operate on an iterator, producing a new iterator with a\n+* *iterator adaptors* operate on an iterator, producing a new iterator with a\n   different output sequence.\n * *consumers* operate on an iterator, producing some final set of values.\n \n@@ -246,12 +246,12 @@ for num in nums.iter() {\n These two basic iterators should serve you well. There are some more\n advanced iterators, including ones that are infinite.\n \n-That's enough about iterators. Iterator adapters are the last concept\n+That's enough about iterators. Iterator adaptors are the last concept\n we need to talk about with regards to iterators. Let's get to it!\n \n-## Iterator adapters\n+## Iterator adaptors\n \n-*Iterator adapters* take an iterator and modify it somehow, producing\n+*Iterator adaptors* take an iterator and modify it somehow, producing\n a new iterator. The simplest one is called `map`:\n \n ```rust,ignore\n@@ -280,7 +280,7 @@ doesn't print any numbers:\n If you are trying to execute a closure on an iterator for its side effects,\n just use `for` instead.\n \n-There are tons of interesting iterator adapters. `take(n)` will return an\n+There are tons of interesting iterator adaptors. `take(n)` will return an\n iterator over the next `n` elements of the original iterator. Let's try it out\n with an infinite iterator:\n \n@@ -329,7 +329,7 @@ a few times, and then consume the result. Check it out:\n \n This will give you a vector containing `6`, `12`, `18`, `24`, and `30`.\n \n-This is just a small taste of what iterators, iterator adapters, and consumers\n+This is just a small taste of what iterators, iterator adaptors, and consumers\n can help you with. There are a number of really useful iterators, and you can\n write your own as well. Iterators provide a safe, efficient way to manipulate\n all kinds of lists. They're a little unusual at first, but if you play with"}, {"sha": "5c0bde02f960591f98fb3fe7e7f3dacf827acd93", "filename": "src/doc/trpl/rust-inside-other-languages.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Ftrpl%2Frust-inside-other-languages.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Ftrpl%2Frust-inside-other-languages.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Frust-inside-other-languages.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -108,7 +108,7 @@ fn process() {\n     let handles: Vec<_> = (0..10).map(|_| {\n         thread::spawn(|| {\n             let mut x = 0;\n-            for _ in (0..5_000_000) {\n+            for _ in 0..5_000_000 {\n                 x += 1\n             }\n             x"}, {"sha": "7e03bb72cad598e5b7972e850ba33a8f393d131b", "filename": "src/doc/trpl/syntax-index.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Ftrpl%2Fsyntax-index.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Ftrpl%2Fsyntax-index.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fsyntax-index.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -25,7 +25,7 @@\n * `pub`: denotes public visibility in `struct` fields, `impl` blocks, and modules.  See [Crates and Modules (Exporting a Public Interface)].\n * `ref`: by-reference binding.  See [Patterns (`ref` and `ref mut`)].\n * `return`: return from function.  See [Functions (Early Returns)].\n-* `Self`: implementer type alias.  See [Traits].\n+* `Self`: implementor type alias.  See [Traits].\n * `self`: method subject.  See [Method Syntax (Method Calls)].\n * `static`: global variable.  See [`const` and `static` (`static`)].\n * `struct`: structure definition.  See [Structs].\n@@ -68,7 +68,7 @@\n * `/` (`expr / expr`): arithmetic division.  Overloadable (`Div`).\n * `/=` (`var /= expr`): arithmetic division & assignment.\n * `:` (`pat: type`, `ident: type`): constraints.  See [Variable Bindings], [Functions], [Structs], [Traits].\n-* `:` (`ident: expr`): struct field initialiser.  See [Structs].\n+* `:` (`ident: expr`): struct field initializer.  See [Structs].\n * `:` (`'a: loop {\u2026}`): loop label.  See [Loops (Loops Labels)].\n * `;`: statement and item terminator.\n * `;` (`[\u2026; len]`): part of fixed-size array syntax.  See [Primitive Types (Arrays)].\n@@ -153,12 +153,12 @@\n <!-- Various things involving parens and tuples -->\n \n * `()`: empty tuple (*a.k.a.* unit), both literal and type.\n-* `(expr)`: parenthesised expression.\n+* `(expr)`: parenthesized expression.\n * `(expr,)`: single-element tuple expression.  See [Primitive Types (Tuples)].\n * `(type,)`: single-element tuple type.  See [Primitive Types (Tuples)].\n * `(expr, \u2026)`: tuple expression.  See [Primitive Types (Tuples)].\n * `(type, \u2026)`: tuple type.  See [Primitive Types (Tuples)].\n-* `expr(expr, \u2026)`: function call expression.  Also used to initialise tuple `struct`s and tuple `enum` variants.  See [Functions].\n+* `expr(expr, \u2026)`: function call expression.  Also used to initialize tuple `struct`s and tuple `enum` variants.  See [Functions].\n * `ident!(\u2026)`, `ident!{\u2026}`, `ident![\u2026]`: macro invocation.  See [Macros].\n * `expr.0`, `expr.1`, \u2026: tuple indexing.  See [Primitive Types (Tuple Indexing)].\n "}, {"sha": "f3a5d1dd886c82b86538372b525f35da1c8ebff7", "filename": "src/doc/trpl/variable-bindings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -221,7 +221,7 @@ Could not compile `hello`.\n To learn more, run the command again with --verbose.\n ```\n \n-Additionaly, variable bindings can be shadowed. This means that a later\n+Additionally, variable bindings can be shadowed. This means that a later\n variable binding with the same name as another binding, that's currently in\n scope, will override the previous binding.\n "}, {"sha": "996a590043a47c04b997bab097dfc0ee9cf02130", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -114,7 +114,7 @@ impl<T> RawVec<T> {\n \n     /// Reconstitutes a RawVec from a pointer and capacity.\n     ///\n-    /// # Undefined Behaviour\n+    /// # Undefined Behavior\n     ///\n     /// The ptr must be allocated, and with the given capacity. The\n     /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n@@ -248,7 +248,7 @@ impl<T> RawVec<T> {\n     ///\n     /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n-    /// code *you* write that relies on the behaviour of this function may break.\n+    /// code *you* write that relies on the behavior of this function may break.\n     ///\n     /// # Panics\n     ///\n@@ -302,12 +302,12 @@ impl<T> RawVec<T> {\n     /// Ensures that the buffer contains at least enough space to hold\n     /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n     /// enough capacity, will reallocate enough space plus comfortable slack\n-    /// space to get amortized `O(1)` behaviour. Will limit this behaviour\n+    /// space to get amortized `O(1)` behavior. Will limit this behavior\n     /// if it would needlessly cause itself to panic.\n     ///\n     /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n-    /// code *you* write that relies on the behaviour of this function may break.\n+    /// code *you* write that relies on the behavior of this function may break.\n     ///\n     /// This is ideal for implementing a bulk-push operation like `extend`.\n     ///\n@@ -430,7 +430,7 @@ impl<T> RawVec<T> {\n \n     /// Converts the entire buffer into `Box<[T]>`.\n     ///\n-    /// While it is not *strictly* Undefined Behaviour to call\n+    /// While it is not *strictly* Undefined Behavior to call\n     /// this procedure while some of the RawVec is unintialized,\n     /// it cetainly makes it trivial to trigger it.\n     ///"}, {"sha": "59ffc1bd36f821474deb3fb834371f20ece5f009", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -949,7 +949,7 @@ impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n     }\n }\n \n-/// Genericises over how to get the correct type of iterator from the correct type\n+/// Genericizes over how to get the correct type of iterator from the correct type\n /// of Node ownership.\n trait Traverse<N> {\n     fn traverse(node: N) -> Self;"}, {"sha": "4380f315ee7f12de54ae460c131e0c43f8c43e6c", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -818,7 +818,7 @@ impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Internal> where\n         }\n     }\n \n-    /// Handle an underflow in this node's child. We favour handling \"to the left\" because we know\n+    /// Handle an underflow in this node's child. We favor handling \"to the left\" because we know\n     /// we're empty, but our neighbour can be full. Handling to the left means when we choose to\n     /// steal, we pop off the end of our neighbour (always fast) and \"unshift\" ourselves\n     /// (always slow, but at least faster since we know we're half-empty)."}, {"sha": "eea21988aa36021a9201eb4697083bc241756892", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -94,7 +94,7 @@ pub trait Write {\n         self.write_str(unsafe { str::from_utf8_unchecked(&utf_8[..bytes_written]) })\n     }\n \n-    /// Glue for usage of the `write!` macro with implementers of this trait.\n+    /// Glue for usage of the `write!` macro with implementors of this trait.\n     ///\n     /// This method should generally not be invoked manually, but rather through\n     /// the `write!` macro itself.\n@@ -523,7 +523,7 @@ pub trait Binary {\n \n /// Format trait for the `x` character.\n ///\n-/// The `LowerHex` trait should format its output as a number in hexidecimal, with `a` through `f`\n+/// The `LowerHex` trait should format its output as a number in hexadecimal, with `a` through `f`\n /// in lower case.\n ///\n /// The alternate flag, `#`, adds a `0x` in front of the output.\n@@ -571,7 +571,7 @@ pub trait LowerHex {\n \n /// Format trait for the `X` character.\n ///\n-/// The `UpperHex` trait should format its output as a number in hexidecimal, with `A` through `F`\n+/// The `UpperHex` trait should format its output as a number in hexadecimal, with `A` through `F`\n /// in upper case.\n ///\n /// The alternate flag, `#`, adds a `0x` in front of the output.\n@@ -620,7 +620,7 @@ pub trait UpperHex {\n /// Format trait for the `p` character.\n ///\n /// The `Pointer` trait should format its output as a memory location. This is commonly presented\n-/// as hexidecimal.\n+/// as hexadecimal.\n ///\n /// For more information on formatters, see [the module-level documentation][module].\n ///"}, {"sha": "45b1c8a3599ca34c4b8aa88f40e389fa4cff1a4c", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -301,7 +301,7 @@ extern \"rust-intrinsic\" {\n     /// # Safety\n     ///\n     /// Beyond requiring that the program must be allowed to access both regions\n-    /// of memory, it is Undefined Behaviour for source and destination to\n+    /// of memory, it is Undefined Behavior for source and destination to\n     /// overlap. Care must also be taken with the ownership of `src` and\n     /// `dst`. This method semantically moves the values of `src` into `dst`.\n     /// However it does not drop the contents of `dst`, or prevent the contents"}, {"sha": "afd399bc5d627a8f13ce7a01d7fdc33ca615ac51", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -1453,7 +1453,7 @@ pub trait Iterator {\n ///\n /// This is an idiosyncratic helper to try to factor out the\n /// commonalities of {max,min}{,_by}. In particular, this avoids\n-/// having to implement optimisations several times.\n+/// having to implement optimizations several times.\n #[inline]\n fn select_fold1<I,B, FProj, FCmp>(mut it: I,\n                                   mut f_proj: FProj,"}, {"sha": "bb112327abf4b02f0075411958ca63a9af2c911b", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -279,7 +279,7 @@ macro_rules! unreachable {\n     });\n }\n \n-/// A standardised placeholder for marking unfinished code. It panics with the\n+/// A standardized placeholder for marking unfinished code. It panics with the\n /// message `\"not yet implemented\"` when executed.\n ///\n /// This can be useful if you are prototyping and are just looking to have your"}, {"sha": "f9480b4349d1107ece794503e96edbecfdff04f7", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -172,7 +172,7 @@ pub trait Copy : Clone {\n ///\n /// A somewhat surprising consequence of the definition is `&mut T` is\n /// `Sync` (if `T` is `Sync`) even though it seems that it might\n-/// provide unsynchronised mutation. The trick is a mutable reference\n+/// provide unsynchronized mutation. The trick is a mutable reference\n /// stored in an aliasable reference (that is, `& &mut T`) becomes\n /// read-only, as if it were a `& &T`, hence there is no risk of a data\n /// race.\n@@ -195,7 +195,7 @@ pub trait Copy : Clone {\n ///\n /// Any types with interior mutability must also use the `std::cell::UnsafeCell`\n /// wrapper around the value(s) which can be mutated when behind a `&`\n-/// reference; not doing this is undefined behaviour (for example,\n+/// reference; not doing this is undefined behavior (for example,\n /// `transmute`-ing from `&T` to `&mut T` is invalid).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sync\"]"}, {"sha": "a87d135e42592551f518118a93969ca1ad6e436a", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -37,7 +37,7 @@ pub use intrinsics::transmute;\n /// * You have two copies of a value (like when writing something like\n ///   [`mem::swap`][swap]), but need the destructor to only run once to\n ///   prevent a double `free`.\n-/// * Transferring resources across [FFI][ffi] boundries.\n+/// * Transferring resources across [FFI][ffi] boundaries.\n ///\n /// [swap]: fn.swap.html\n /// [ffi]: ../../book/ffi.html\n@@ -264,9 +264,9 @@ pub unsafe fn dropped<T>() -> T {\n /// This is useful for FFI functions and initializing arrays sometimes,\n /// but should generally be avoided.\n ///\n-/// # Undefined Behaviour\n+/// # Undefined Behavior\n ///\n-/// It is Undefined Behaviour to read uninitialized memory. Even just an\n+/// It is Undefined Behavior to read uninitialized memory. Even just an\n /// uninitialized boolean. For instance, if you branch on the value of such\n /// a boolean your program may take one, both, or neither of the branches.\n ///\n@@ -303,7 +303,7 @@ pub unsafe fn dropped<T>() -> T {\n ///\n ///     // DANGER ZONE: if anything panics or otherwise\n ///     // incorrectly reads the array here, we will have\n-///     // Undefined Behaviour.\n+///     // Undefined Behavior.\n ///\n ///     // It's ok to mutably iterate the data, since this\n ///     // doesn't involve reading it at all.\n@@ -340,7 +340,7 @@ pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::uninit()\n }\n \n-/// Swap the values at two mutable locations of the same type, without deinitialising or copying\n+/// Swap the values at two mutable locations of the same type, without deinitializing or copying\n /// either one.\n ///\n /// # Examples\n@@ -376,7 +376,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n }\n \n /// Replaces the value at a mutable location with a new one, returning the old value, without\n-/// deinitialising or copying either one.\n+/// deinitializing or copying either one.\n ///\n /// This is primarily used for transferring and swapping ownership of a value in a mutable\n /// location."}, {"sha": "960240d7f5fc874728195dd730016f1dd661a158", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -69,7 +69,7 @@ pub const fn null<T>() -> *const T { 0 as *const T }\n pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n /// Swaps the values at two mutable locations of the same type, without\n-/// deinitialising either. They may overlap, unlike `mem::swap` which is\n+/// deinitializing either. They may overlap, unlike `mem::swap` which is\n /// otherwise equivalent.\n ///\n /// # Safety\n@@ -247,7 +247,7 @@ impl<T: ?Sized> *mut T {\n     /// # Safety\n     ///\n     /// The offset must be in-bounds of the object, or one-byte-past-the-end.\n-    /// Otherwise `offset` invokes Undefined Behaviour, regardless of whether\n+    /// Otherwise `offset` invokes Undefined Behavior, regardless of whether\n     /// the pointer is used.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "84467be6eca5641d30e15a0a4240fc827b761ec1", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -94,7 +94,7 @@ impl<T> Clone for Slice<T> {\n /// Synthesizing a trait object with mismatched types\u2014one where the\n /// vtable does not correspond to the type of the value to which the\n /// data pointer points\u2014is highly likely to lead to undefined\n-/// behaviour.\n+/// behavior.\n ///\n /// # Examples\n ///"}, {"sha": "c0a85e0df067cb6e18a5791b19c0aea5ef0e1285", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -965,7 +965,7 @@ impl<'a> DoubleEndedIterator for Lines<'a> {\n #[allow(deprecated)]\n pub struct LinesAny<'a>(Lines<'a>);\n \n-/// A nameable, clonable fn type\n+/// A nameable, cloneable fn type\n #[derive(Clone)]\n struct LinesAnyMap;\n "}, {"sha": "ed767ab1e5cf97e3116deb0d01ad71b37cc04682", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -135,7 +135,7 @@ pub enum Count<'a> {\n }\n \n /// The parser structure for interpreting the input format string. This is\n-/// modelled as an iterator over `Piece` structures to form a stream of tokens\n+/// modeled as an iterator over `Piece` structures to form a stream of tokens\n /// being output.\n ///\n /// This is a recursive-descent parser for the sake of simplicity, and if"}, {"sha": "b82b7d122b3ce8205c760602202243faed391eeb", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -456,7 +456,7 @@ pub trait Labeller<'a,N,E> {\n     fn graph_id(&'a self) -> Id<'a>;\n \n     /// Maps `n` to a unique identifier with respect to `self`. The\n-    /// implementer is responsible for ensuring that the returned name\n+    /// implementor is responsible for ensuring that the returned name\n     /// is a valid DOT identifier.\n     fn node_id(&'a self, n: &N) -> Id<'a>;\n \n@@ -594,7 +594,7 @@ pub type Edges<'a,E> = Cow<'a,[E]>;\n /// that is bound by the self lifetime `'a`.\n ///\n /// The `nodes` and `edges` method each return instantiations of\n-/// `Cow<[T]>` to leave implementers the freedom to create\n+/// `Cow<[T]>` to leave implementors the freedom to create\n /// entirely new vectors or to pass back slices into internally owned\n /// vectors.\n pub trait GraphWalk<'a, N: Clone, E: Clone> {"}, {"sha": "83d82e433064346825374922611aec6259fc69a9", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -168,7 +168,7 @@ impl IndependentSample<f64> for GammaLargeShape {\n ///\n /// For `k > 0` integral, this distribution is the sum of the squares\n /// of `k` independent standard normal random variables. For other\n-/// `k`, this uses the equivalent characterisation `\u03c7\u00b2(k) = Gamma(k/2,\n+/// `k`, this uses the equivalent characterization `\u03c7\u00b2(k) = Gamma(k/2,\n /// 2)`.\n pub struct ChiSquared {\n     repr: ChiSquaredRepr,"}, {"sha": "0b7c5b0d840227313ded8c74dce1679b0938080d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -207,7 +207,7 @@ fn test_resize_policy() {\n /// The hashes are all keyed by the thread-local random number generator\n /// on creation by default. This means that the ordering of the keys is\n /// randomized, but makes the tables more resistant to\n-/// denial-of-service attacks (Hash DoS). This behaviour can be\n+/// denial-of-service attacks (Hash DoS). This behavior can be\n /// overridden with one of the constructors.\n ///\n /// It is required that the keys implement the `Eq` and `Hash` traits, although\n@@ -324,7 +324,7 @@ fn search_hashed<K, V, M, F>(table: M,\n     F: FnMut(&K) -> bool,\n {\n     // This is the only function where capacity can be zero. To avoid\n-    // undefined behaviour when Bucket::new gets the raw bucket in this\n+    // undefined behavior when Bucket::new gets the raw bucket in this\n     // case, immediately return the appropriate search result.\n     if table.capacity() == 0 {\n         return TableRef(table);"}, {"sha": "5b587dd921bb7e62e2213fbad35eeadab17cf33e", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -238,7 +238,7 @@ mod tests {\n \n         b.iter(|| {\n             let mut rd = &buf[..];\n-            for _ in (0 .. 8) {\n+            for _ in 0..8 {\n                 let _ = rd.read(&mut dst);\n                 test::black_box(&dst);\n             }\n@@ -252,7 +252,7 @@ mod tests {\n \n         b.iter(|| {\n             let mut wr = &mut buf[..];\n-            for _ in (0 .. 8) {\n+            for _ in 0..8 {\n                 let _ = wr.write_all(&src);\n                 test::black_box(&wr);\n             }\n@@ -266,7 +266,7 @@ mod tests {\n \n         b.iter(|| {\n             let mut rd = &buf[..];\n-            for _ in (0 .. 8) {\n+            for _ in 0..8 {\n                 let _ = rd.read(&mut dst);\n                 test::black_box(&dst);\n             }\n@@ -280,7 +280,7 @@ mod tests {\n \n         b.iter(|| {\n             let mut wr = &mut buf[..];\n-            for _ in (0 .. 8) {\n+            for _ in 0..8 {\n                 let _ = wr.write_all(&src);\n                 test::black_box(&wr);\n             }"}, {"sha": "a624b3521267af94106476098105af3f16a78ac6", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -137,7 +137,7 @@\n //! not.\n //!\n //! Slices can only be handled through some kind of *pointer*, and as\n-//! such come in many flavours such as:\n+//! such come in many flavors such as:\n //!\n //! * `&[T]` - *shared slice*\n //! * `&mut [T]` - *mutable slice*"}, {"sha": "c6499687304ecdf0dca93d59879eb44d78eb7532", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -235,7 +235,7 @@ impl TcpListener {\n     /// to this listener. The port allocated can be queried via the\n     /// `socket_addr` function.\n     ///\n-    /// The address type can be any implementer of `ToSocketAddrs` trait. See\n+    /// The address type can be any implementor of `ToSocketAddrs` trait. See\n     /// its documentation for concrete examples.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> {"}, {"sha": "08227cfb35322f00ead40d813010b853168bb206", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -84,7 +84,7 @@\n //!   }.\n //!   Generic conversions, used by savvy API authors to create\n //!   overloaded methods.\n-//! * `std::default::`[`Default`](../default/trait.Default).\n+//! * `std::default::`[`Default`](../default/trait.Default.html).\n //!   Types that have default values.\n //! * `std::iter::`{\n //!     [`Iterator`](../iter/trait.Iterator.html),"}, {"sha": "4e80fb2ceb09ed4ae4b1caac7cd88c0ddb2020ff", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -75,7 +75,7 @@ impl IntoInner<imp::Process> for Child {\n     fn into_inner(self) -> imp::Process { self.handle }\n }\n \n-/// A handle to a child procesess's stdin\n+/// A handle to a child process's stdin\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdin {\n     inner: AnonPipe"}, {"sha": "59b385b94810bedefe5d3e3b29c81488f116008e", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -343,7 +343,7 @@ pub fn args() -> Args {\n         let args = objc_msgSend(info, arguments_sel);\n \n         let cnt: usize = mem::transmute(objc_msgSend(args, count_sel));\n-        for i in (0..cnt) {\n+        for i in 0..cnt {\n             let tmp = objc_msgSend(args, object_at_sel, i);\n             let utf_c_str: *const libc::c_char =\n                 mem::transmute(objc_msgSend(tmp, utf8_sel));"}, {"sha": "1a9ea8bff08b3ea99d5f6244bbde5a8614d61ec6", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9615eb6f59acc394e338d529f22273fe3a1cd7/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=9c9615eb6f59acc394e338d529f22273fe3a1cd7", "patch": "@@ -225,7 +225,7 @@ fn main() {\n     offset_momentum(&mut bodies);\n     println!(\"{:.9}\", energy(&bodies));\n \n-    for _ in (0..n) {\n+    for _ in 0..n {\n         advance(&mut bodies, 0.01, &mut diff, &mut mag);\n     }\n "}]}