{"sha": "d53c483502216bd9b3b2ff0fa1ce463690492d7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1M2M0ODM1MDIyMTZiZDliM2IyZmYwZmExY2U0NjM2OTA0OTJkN2M=", "commit": {"author": {"name": "Falk H\u00fcffner", "email": "falk@hueffner.de", "date": "2021-09-05T20:55:29Z"}, "committer": {"name": "Falk H\u00fcffner", "email": "falk@hueffner.de", "date": "2021-09-09T16:14:47Z"}, "message": "Speed up integer log10.\n\nThis is achieved with a branchless bit-twiddling implementation of the\ncase x < 100_000, and using this as building block.\n\nBenchmark on an Intel i7-8700K (Coffee Lake):\n\nname                                   old ns/iter  new ns/iter  diff ns/iter   diff %  speedup\nnum::int_log::u8_log10_predictable     165          169                     4    2.42%   x 0.98\nnum::int_log::u8_log10_random          438          423                   -15   -3.42%   x 1.04\nnum::int_log::u8_log10_random_small    438          423                   -15   -3.42%   x 1.04\nnum::int_log::u16_log10_predictable    633          417                  -216  -34.12%   x 1.52\nnum::int_log::u16_log10_random         908          471                  -437  -48.13%   x 1.93\nnum::int_log::u16_log10_random_small   945          471                  -474  -50.16%   x 2.01\nnum::int_log::u32_log10_predictable    1,496        1,340                -156  -10.43%   x 1.12\nnum::int_log::u32_log10_random         1,076        873                  -203  -18.87%   x 1.23\nnum::int_log::u32_log10_random_small   1,145        874                  -271  -23.67%   x 1.31\nnum::int_log::u64_log10_predictable    4,005        3,171                -834  -20.82%   x 1.26\nnum::int_log::u64_log10_random         1,247        1,021                -226  -18.12%   x 1.22\nnum::int_log::u64_log10_random_small   1,265        921                  -344  -27.19%   x 1.37\nnum::int_log::u128_log10_predictable   39,667       39,579                -88   -0.22%   x 1.00\nnum::int_log::u128_log10_random        6,456        6,696                 240    3.72%   x 0.96\nnum::int_log::u128_log10_random_small  4,108        3,903                -205   -4.99%   x 1.05\n\nBenchmark on an M1 Mac Mini:\n\nname                                   old ns/iter  new ns/iter  diff ns/iter   diff %  speedup\nnum::int_log::u8_log10_predictable     143          130                   -13   -9.09%   x 1.10\nnum::int_log::u8_log10_random          375          325                   -50  -13.33%   x 1.15\nnum::int_log::u8_log10_random_small    376          325                   -51  -13.56%   x 1.16\nnum::int_log::u16_log10_predictable    500          322                  -178  -35.60%   x 1.55\nnum::int_log::u16_log10_random         794          405                  -389  -48.99%   x 1.96\nnum::int_log::u16_log10_random_small   1,035        405                  -630  -60.87%   x 2.56\nnum::int_log::u32_log10_predictable    1,144        894                  -250  -21.85%   x 1.28\nnum::int_log::u32_log10_random         832          786                   -46   -5.53%   x 1.06\nnum::int_log::u32_log10_random_small   832          787                   -45   -5.41%   x 1.06\nnum::int_log::u64_log10_predictable    2,681        2,057                -624  -23.27%   x 1.30\nnum::int_log::u64_log10_random         1,015        806                  -209  -20.59%   x 1.26\nnum::int_log::u64_log10_random_small   1,004        795                  -209  -20.82%   x 1.26\nnum::int_log::u128_log10_predictable   56,825       56,526               -299   -0.53%   x 1.01\nnum::int_log::u128_log10_random        9,056        8,861                -195   -2.15%   x 1.02\nnum::int_log::u128_log10_random_small  1,528        1,527                  -1   -0.07%   x 1.00\n\nThe 128 bit case remains ridiculously slow because llvm fails to optimize division by\na constant 128-bit value to multiplications. This could be worked around but it seems\npreferable to fix this in llvm.\n\nFrom u32 up, table lookup (like suggested here\nhttps://github.com/rust-lang/rust/issues/70887#issuecomment-881099813) is still\nfaster, but requires a hardware leading_zero to be viable, and might clog up the\ncache.", "tree": {"sha": "a871b54d3adb5f628b22a217b97c4b50c026f704", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a871b54d3adb5f628b22a217b97c4b50c026f704"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d53c483502216bd9b3b2ff0fa1ce463690492d7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d53c483502216bd9b3b2ff0fa1ce463690492d7c", "html_url": "https://github.com/rust-lang/rust/commit/d53c483502216bd9b3b2ff0fa1ce463690492d7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d53c483502216bd9b3b2ff0fa1ce463690492d7c/comments", "author": null, "committer": null, "parents": [{"sha": "0c26a3bc0ce507cbc2bee0b3368664760bedcf25", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c26a3bc0ce507cbc2bee0b3368664760bedcf25", "html_url": "https://github.com/rust-lang/rust/commit/0c26a3bc0ce507cbc2bee0b3368664760bedcf25"}], "stats": {"total": 110, "additions": 54, "deletions": 56}, "files": [{"sha": "d28552cf4aa4a28ff169bb7fe64222ccb5071b7b", "filename": "library/core/src/num/int_log10.rs", "status": "modified", "additions": 51, "deletions": 56, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/d53c483502216bd9b3b2ff0fa1ce463690492d7c/library%2Fcore%2Fsrc%2Fnum%2Fint_log10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53c483502216bd9b3b2ff0fa1ce463690492d7c/library%2Fcore%2Fsrc%2Fnum%2Fint_log10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_log10.rs?ref=d53c483502216bd9b3b2ff0fa1ce463690492d7c", "patch": "@@ -1,76 +1,71 @@\n mod unchecked {\n     // 0 < val <= u8::MAX\n     pub const fn u8(val: u8) -> u32 {\n-        if val >= 100 {\n-            2\n-        } else if val >= 10 {\n-            1\n-        } else {\n-            0\n-        }\n+        let val = val as u32;\n+\n+        // For better performance, avoid branches by assembling the solution\n+        // in the bits above the low 8 bits.\n+\n+        // Adding c1 to val gives 10 in the top bits for val < 10, 11 for val >= 10\n+        let c1 = 0b11_00000000 - 10; // 758\n+        // Adding c2 to val gives 01 in the top bits for val < 100, 10 for val >= 100\n+        let c2 = 0b10_00000000 - 100; // 412\n+\n+        // Value of top bits:\n+        //            +c1  +c2  1&2\n+        //     0..=9   10   01   00 = 0\n+        //   10..=99   11   01   01 = 1\n+        // 100..=255   11   10   10 = 2\n+        ((val + c1) & (val + c2)) >> 8\n     }\n \n-    // 0 < val <= u16::MAX\n-    pub const fn u16(val: u16) -> u32 {\n-        if val >= 10_000 {\n-            4\n-        } else if val >= 1000 {\n-            3\n-        } else if val >= 100 {\n-            2\n-        } else if val >= 10 {\n-            1\n-        } else {\n-            0\n-        }\n+    // 0 < val < 100_000\n+    const fn less_than_5(val: u32) -> u32 {\n+        // Similar to u8, when adding one of these constants to val,\n+        // we get two possible bit patterns above the low 17 bits,\n+        // depending on whether val is below or above the threshold.\n+        let c1 = 0b011_00000000000000000 - 10; // 393206\n+        let c2 = 0b100_00000000000000000 - 100; // 524188\n+        let c3 = 0b111_00000000000000000 - 1000; // 916504\n+        let c4 = 0b100_00000000000000000 - 10000; // 514288\n+\n+        // Value of top bits:\n+        //                +c1  +c2  1&2  +c3  +c4  3&4   ^\n+        //         0..=9  010  011  010  110  011  010  000 = 0\n+        //       10..=99  011  011  011  110  011  010  001 = 1\n+        //     100..=999  011  100  000  110  011  010  010 = 2\n+        //   1000..=9999  011  100  000  111  011  011  011 = 3\n+        // 10000..=99999  011  100  000  111  100  100  100 = 4\n+        (((val + c1) & (val + c2)) ^ ((val + c3) & (val + c4))) >> 17\n     }\n \n-    // 0 < val < 100_000_000\n-    const fn less_than_8(mut val: u32) -> u32 {\n-        let mut log = 0;\n-        if val >= 10_000 {\n-            val /= 10_000;\n-            log += 4;\n-        }\n-        log + if val >= 1000 {\n-            3\n-        } else if val >= 100 {\n-            2\n-        } else if val >= 10 {\n-            1\n-        } else {\n-            0\n-        }\n+    // 0 < val <= u16::MAX\n+    pub const fn u16(val: u16) -> u32 {\n+        less_than_5(val as u32)\n     }\n \n     // 0 < val <= u32::MAX\n     pub const fn u32(mut val: u32) -> u32 {\n         let mut log = 0;\n-        if val >= 100_000_000 {\n-            val /= 100_000_000;\n-            log += 8;\n-        }\n-        log + less_than_8(val)\n-    }\n-\n-    // 0 < val < 10_000_000_000_000_000\n-    const fn less_than_16(mut val: u64) -> u32 {\n-        let mut log = 0;\n-        if val >= 100_000_000 {\n-            val /= 100_000_000;\n-            log += 8;\n+        if val >= 100_000 {\n+            val /= 100_000;\n+            log += 5;\n         }\n-        log + less_than_8(val as u32)\n+        log + less_than_5(val)\n     }\n \n     // 0 < val <= u64::MAX\n     pub const fn u64(mut val: u64) -> u32 {\n         let mut log = 0;\n-        if val >= 10_000_000_000_000_000 {\n-            val /= 10_000_000_000_000_000;\n-            log += 16;\n+        if val >= 10_000_000_000 {\n+            val /= 10_000_000_000;\n+            log += 10;\n+        }\n+        if val >= 100_000 {\n+            val /= 100_000;\n+            log += 5;\n         }\n-        log + less_than_16(val)\n+        log + less_than_5(val as u32)\n     }\n \n     // 0 < val <= u128::MAX\n@@ -79,13 +74,13 @@ mod unchecked {\n         if val >= 100_000_000_000_000_000_000_000_000_000_000 {\n             val /= 100_000_000_000_000_000_000_000_000_000_000;\n             log += 32;\n-            return log + less_than_8(val as u32);\n+            return log + u32(val as u32);\n         }\n         if val >= 10_000_000_000_000_000 {\n             val /= 10_000_000_000_000_000;\n             log += 16;\n         }\n-        log + less_than_16(val as u64)\n+        log + u64(val as u64)\n     }\n \n     // 0 < val <= i8::MAX"}, {"sha": "3cd0073ddd8c24862770c7c2c783b8e6af02d9fb", "filename": "library/core/tests/num/int_log.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d53c483502216bd9b3b2ff0fa1ce463690492d7c/library%2Fcore%2Ftests%2Fnum%2Fint_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53c483502216bd9b3b2ff0fa1ce463690492d7c/library%2Fcore%2Ftests%2Fnum%2Fint_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fint_log.rs?ref=d53c483502216bd9b3b2ff0fa1ce463690492d7c", "patch": "@@ -96,6 +96,9 @@ fn checked_log10() {\n     for i in 1..=u16::MAX {\n         assert_eq!(i.checked_log10(), Some((i as f32).log10() as u32));\n     }\n+    for i in 1..=100_000u32 {\n+        assert_eq!(i.checked_log10(), Some((i as f32).log10() as u32));\n+    }\n }\n \n macro_rules! log10_loop {"}]}