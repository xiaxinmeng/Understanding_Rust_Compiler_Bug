{"sha": "c83218de12748a678e873813a6b8381f46fae590", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MzIxOGRlMTI3NDhhNjc4ZTg3MzgxM2E2YjgzODFmNDZmYWU1OTA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-04T22:14:28Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-04T22:15:09Z"}, "message": "core: Improve option docs a little", "tree": {"sha": "1672de7c6b253e7f3c80982776a14838e124b40d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1672de7c6b253e7f3c80982776a14838e124b40d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c83218de12748a678e873813a6b8381f46fae590", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c83218de12748a678e873813a6b8381f46fae590", "html_url": "https://github.com/rust-lang/rust/commit/c83218de12748a678e873813a6b8381f46fae590", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c83218de12748a678e873813a6b8381f46fae590/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edc317b8212fe1c29b5e7e2e4e260b9a4d72b447", "url": "https://api.github.com/repos/rust-lang/rust/commits/edc317b8212fe1c29b5e7e2e4e260b9a4d72b447", "html_url": "https://github.com/rust-lang/rust/commit/edc317b8212fe1c29b5e7e2e4e260b9a4d72b447"}], "stats": {"total": 136, "additions": 105, "deletions": 31}, "files": [{"sha": "1cdd4511e295ab88308966e335cd6b287606648f", "filename": "src/libcore/option.rs", "status": "modified", "additions": 105, "deletions": 31, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/c83218de12748a678e873813a6b8381f46fae590/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c83218de12748a678e873813a6b8381f46fae590/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=c83218de12748a678e873813a6b8381f46fae590", "patch": "@@ -1,12 +1,35 @@\n /*!\n- * Operations on the ubiquitous `option` type.\n- *\n- * Type `option` represents an optional value.\n- *\n- * Every `Option<T>` value can either be `Some(T)` or `none`. Where in other\n- * languages you might use a nullable type, in Rust you would use an option\n- * type.\n- */\n+\n+Operations on the ubiquitous `Option` type.\n+\n+Type `Option` represents an optional value.\n+\n+Every `Option<T>` value can either be `Some(T)` or `None`. Where in other\n+languages you might use a nullable type, in Rust you would use an option\n+type.\n+\n+Options are most commonly used with pattern matching to query the presence\n+of a value and take action, always accounting for the `None` case.\n+\n+# Example\n+\n+~~~\n+let msg = Some(~\"howdy\");\n+\n+// Take a reference to the contained string\n+match msg {\n+    Some(ref m) => io::println(m),\n+    None => ()\n+}\n+\n+// Remove the contained string, destroying the Option\n+let unwrapped_msg = match move msg {\n+    Some(move m) => m,\n+    None => ~\"default message\"\n+};\n+~~~\n+\n+*/\n \n // NB: transitionary, de-mode-ing.\n #[warn(deprecated_mode)];\n@@ -22,12 +45,19 @@ pub enum Option<T> {\n \n pub pure fn get<T: Copy>(opt: &Option<T>) -> T {\n     /*!\n-     * Gets the value out of an option\n-     *\n-     * # Failure\n-     *\n-     * Fails if the value equals `none`\n-     */\n+    Gets the value out of an option\n+\n+    # Failure\n+\n+    Fails if the value equals `None`\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged\n+    (calling `get` on `None` is akin to dereferencing a null pointer).\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n+    */\n \n     match *opt {\n       Some(copy x) => return x,\n@@ -37,11 +67,18 @@ pub pure fn get<T: Copy>(opt: &Option<T>) -> T {\n \n pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     /*!\n-     * Gets an immutable reference to the value inside an option.\n-     *\n-     * # Failure\n-     *\n-     * Fails if the value equals `none`\n+    Gets an immutable reference to the value inside an option.\n+\n+    # Failure\n+\n+    Fails if the value equals `None`\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged\n+    (calling `get` on `None` is akin to dereferencing a null pointer).\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n      */\n     match *opt {\n         Some(ref x) => x,\n@@ -154,20 +191,37 @@ pub pure fn iter<T>(opt: &Option<T>, f: fn(x: &T)) {\n #[inline(always)]\n pub pure fn unwrap<T>(opt: Option<T>) -> T {\n     /*!\n-     * Moves a value out of an option type and returns it.\n-     *\n-     * Useful primarily for getting strings, vectors and unique pointers out\n-     * of option types without copying them.\n+    Moves a value out of an option type and returns it.\n+\n+    Useful primarily for getting strings, vectors and unique pointers out\n+    of option types without copying them.\n+\n+    # Failure\n+\n+    Fails if the value equals `None`.\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged.\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n      */\n     match move opt {\n         Some(move x) => move x,\n         None => fail ~\"option::unwrap none\"\n     }\n }\n \n-/// The ubiquitous option dance.\n #[inline(always)]\n pub fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n+    /*!\n+    The option dance. Moves a value out of an option type and returns it,\n+    replacing the original with `None`.\n+\n+    # Failure\n+\n+    Fails if the value equals `None`.\n+     */\n     if opt.is_none() { fail ~\"option::swap_unwrap none\" }\n     unwrap(util::replace(opt, None))\n }\n@@ -201,18 +255,38 @@ impl<T> &Option<T> {\n     pure fn iter(f: fn(x: &T)) { iter(self, f) }\n     /// Maps a `some` value from one type to another by reference\n     pure fn map<U>(f: fn(x: &T) -> U) -> Option<U> { map(self, f) }\n-    /// Gets an immutable reference to the value inside a `some`.\n+    /**\n+    Gets an immutable reference to the value inside an option.\n+\n+    # Failure\n+\n+    Fails if the value equals `None`\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged\n+    (calling `get` on `None` is akin to dereferencing a null pointer).\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n+     */\n     pure fn get_ref() -> &self/T { get_ref(self) }\n }\n \n impl<T: Copy> Option<T> {\n     /**\n-     * Gets the value out of an option\n-     *\n-     * # Failure\n-     *\n-     * Fails if the value equals `none`\n-     */\n+    Gets the value out of an option\n+\n+    # Failure\n+\n+    Fails if the value equals `None`\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged\n+    (calling `get` on `None` is akin to dereferencing a null pointer).\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n+    */\n     pure fn get() -> T { get(&self) }\n     pure fn get_default(def: T) -> T { get_default(&self, def) }\n     /**"}]}