{"sha": "e1123674b1c719e0a5ced078c15a81a22e16dec0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMTIzNjc0YjFjNzE5ZTBhNWNlZDA3OGMxNWE4MWEyMmUxNmRlYzA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-04-06T19:53:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-04-15T11:06:29Z"}, "message": "extract code to build borrow-set into `borrow_check::borrow_set`\n\nAlso:\n\n- Extract common helper functions into a helper trait.\n- Kill a bit of dead code.", "tree": {"sha": "8f6c39fe029adc87e679b0ff86b88d8e98a9fc80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f6c39fe029adc87e679b0ff86b88d8e98a9fc80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1123674b1c719e0a5ced078c15a81a22e16dec0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1123674b1c719e0a5ced078c15a81a22e16dec0", "html_url": "https://github.com/rust-lang/rust/commit/e1123674b1c719e0a5ced078c15a81a22e16dec0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1123674b1c719e0a5ced078c15a81a22e16dec0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70592664b6b071af2fe03afb60ffb9cfab6feaf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/70592664b6b071af2fe03afb60ffb9cfab6feaf7", "html_url": "https://github.com/rust-lang/rust/commit/70592664b6b071af2fe03afb60ffb9cfab6feaf7"}], "stats": {"total": 729, "additions": 322, "deletions": 407}, "files": [{"sha": "a25c3afd63c24ba467a9a9c9a31e50439d31d26d", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 249, "deletions": 3, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/e1123674b1c719e0a5ced078c15a81a22e16dec0/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1123674b1c719e0a5ced078c15a81a22e16dec0/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=e1123674b1c719e0a5ced078c15a81a22e16dec0", "patch": "@@ -8,12 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::place_ext::PlaceExt;\n use dataflow::indexes::BorrowIndex;\n-use rustc::mir::{self, Location};\n-use rustc::ty::{Region, RegionKind};\n+use rustc::mir::traversal;\n+use rustc::mir::visit::{PlaceContext, Visitor};\n+use rustc::mir::{self, Location, Mir, Place};\n+use rustc::ty::{self, Region, RegionKind, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt;\n+use std::hash::Hash;\n use syntax_pos::Span;\n \n crate struct BorrowSet<'tcx> {\n@@ -71,8 +75,250 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n             mir::BorrowKind::Mut { .. } => \"mut \",\n         };\n         let region = format!(\"{}\", self.region);\n-        let region = if region.len() > 0 { format!(\"{} \", region) } else { region };\n+        let region = if region.len() > 0 {\n+            format!(\"{} \", region)\n+        } else {\n+            region\n+        };\n         write!(w, \"&{}{}{:?}\", region, kind, self.borrowed_place)\n     }\n }\n \n+impl<'tcx> BorrowSet<'tcx> {\n+    pub fn build(tcx: TyCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) -> Self {\n+        let mut visitor = GatherBorrows {\n+            tcx,\n+            mir,\n+            idx_vec: IndexVec::new(),\n+            location_map: FxHashMap(),\n+            activation_map: FxHashMap(),\n+            region_map: FxHashMap(),\n+            local_map: FxHashMap(),\n+            region_span_map: FxHashMap(),\n+            pending_activations: FxHashMap(),\n+        };\n+\n+        for (block, block_data) in traversal::preorder(mir) {\n+            visitor.visit_basic_block_data(block, block_data);\n+        }\n+\n+        // Double check: We should have found an activation for every pending\n+        // activation.\n+        assert_eq!(\n+            visitor\n+                .pending_activations\n+                .iter()\n+                .find(|&(_local, &borrow_index)| visitor.idx_vec[borrow_index]\n+                    .activation_location\n+                    .is_none()),\n+            None,\n+            \"never found an activation for this borrow!\",\n+        );\n+\n+        BorrowSet {\n+            borrows: visitor.idx_vec,\n+            location_map: visitor.location_map,\n+            activation_map: visitor.activation_map,\n+            region_map: visitor.region_map,\n+            local_map: visitor.local_map,\n+            region_span_map: visitor.region_span_map,\n+        }\n+    }\n+}\n+\n+struct GatherBorrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n+    location_map: FxHashMap<Location, BorrowIndex>,\n+    activation_map: FxHashMap<Location, FxHashSet<BorrowIndex>>,\n+    region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+    local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n+    region_span_map: FxHashMap<RegionKind, Span>,\n+\n+    /// When we encounter a 2-phase borrow statement, it will always\n+    /// be assigning into a temporary TEMP:\n+    ///\n+    ///    TEMP = &foo\n+    ///\n+    /// We add TEMP into this map with `b`, where `b` is the index of\n+    /// the borrow. When we find a later use of this activation, we\n+    /// remove from the map (and add to the \"tombstone\" set below).\n+    pending_activations: FxHashMap<mir::Local, BorrowIndex>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n+    fn visit_assign(\n+        &mut self,\n+        block: mir::BasicBlock,\n+        assigned_place: &mir::Place<'tcx>,\n+        rvalue: &mir::Rvalue<'tcx>,\n+        location: mir::Location,\n+    ) {\n+        if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n+            if borrowed_place.is_unsafe_place(self.tcx, self.mir) {\n+                return;\n+            }\n+\n+            let borrow = BorrowData {\n+                kind,\n+                region,\n+                reserve_location: location,\n+                activation_location: None,\n+                borrowed_place: borrowed_place.clone(),\n+                assigned_place: assigned_place.clone(),\n+            };\n+            let idx = self.idx_vec.push(borrow);\n+            self.location_map.insert(location, idx);\n+\n+            self.insert_as_pending_if_two_phase(location, &assigned_place, region, kind, idx);\n+\n+            insert(&mut self.region_map, &region, idx);\n+            if let Some(local) = borrowed_place.root_local() {\n+                insert(&mut self.local_map, &local, idx);\n+            }\n+        }\n+\n+        return self.super_assign(block, assigned_place, rvalue, location);\n+\n+        fn insert<'a, K, V>(map: &'a mut FxHashMap<K, FxHashSet<V>>, k: &K, v: V)\n+        where\n+            K: Clone + Eq + Hash,\n+            V: Eq + Hash,\n+        {\n+            map.entry(k.clone()).or_insert(FxHashSet()).insert(v);\n+        }\n+    }\n+\n+    fn visit_place(\n+        &mut self,\n+        place: &mir::Place<'tcx>,\n+        context: PlaceContext<'tcx>,\n+        location: Location,\n+    ) {\n+        self.super_place(place, context, location);\n+\n+        // We found a use of some temporary TEMP...\n+        if let Place::Local(temp) = place {\n+            // ... check whether we (earlier) saw a 2-phase borrow like\n+            //\n+            //     TMP = &mut place\n+            match self.pending_activations.get(temp) {\n+                Some(&borrow_index) => {\n+                    let borrow_data = &mut self.idx_vec[borrow_index];\n+\n+                    // Watch out: the use of TMP in the borrow\n+                    // itself doesn't count as an\n+                    // activation. =)\n+                    if borrow_data.reserve_location == location && context == PlaceContext::Store {\n+                        return;\n+                    }\n+\n+                    if let Some(other_activation) = borrow_data.activation_location {\n+                        span_bug!(\n+                            self.mir.source_info(location).span,\n+                            \"found two activations for 2-phase borrow temporary {:?}: \\\n+                             {:?} and {:?}\",\n+                            temp,\n+                            location,\n+                            other_activation,\n+                        );\n+                    }\n+\n+                    // Otherwise, this is the unique later use\n+                    // that we expect.\n+                    borrow_data.activation_location = Some(location);\n+                    self.activation_map\n+                        .entry(location)\n+                        .or_insert(FxHashSet())\n+                        .insert(borrow_index);\n+                }\n+\n+                None => {}\n+            }\n+        }\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: mir::Location) {\n+        if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n+            // double-check that we already registered a BorrowData for this\n+\n+            let borrow_index = self.location_map[&location];\n+            let borrow_data = &self.idx_vec[borrow_index];\n+            assert_eq!(borrow_data.reserve_location, location);\n+            assert_eq!(borrow_data.kind, kind);\n+            assert_eq!(borrow_data.region, region);\n+            assert_eq!(borrow_data.borrowed_place, *place);\n+        }\n+\n+        return self.super_rvalue(rvalue, location);\n+    }\n+\n+    fn visit_statement(\n+        &mut self,\n+        block: mir::BasicBlock,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        if let mir::StatementKind::EndRegion(region_scope) = statement.kind {\n+            self.region_span_map\n+                .insert(ty::ReScope(region_scope), statement.source_info.span);\n+        }\n+        return self.super_statement(block, statement, location);\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n+    /// Returns true if the borrow represented by `kind` is\n+    /// allowed to be split into separate Reservation and\n+    /// Activation phases.\n+    fn allow_two_phase_borrow(&self, kind: mir::BorrowKind) -> bool {\n+        self.tcx.two_phase_borrows()\n+            && (kind.allows_two_phase_borrow()\n+                || self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n+    }\n+\n+    /// If this is a two-phase borrow, then we will record it\n+    /// as \"pending\" until we find the activating use.\n+    fn insert_as_pending_if_two_phase(\n+        &mut self,\n+        start_location: Location,\n+        assigned_place: &mir::Place<'tcx>,\n+        region: Region<'tcx>,\n+        kind: mir::BorrowKind,\n+        borrow_index: BorrowIndex,\n+    ) {\n+        debug!(\n+            \"Borrows::insert_as_pending_if_two_phase({:?}, {:?}, {:?}, {:?})\",\n+            start_location, assigned_place, region, borrow_index,\n+        );\n+\n+        if !self.allow_two_phase_borrow(kind) {\n+            debug!(\"  -> {:?}\", start_location);\n+            return;\n+        }\n+\n+        // When we encounter a 2-phase borrow statement, it will always\n+        // be assigning into a temporary TEMP:\n+        //\n+        //    TEMP = &foo\n+        //\n+        // so extract `temp`.\n+        let temp = if let &mir::Place::Local(temp) = assigned_place {\n+            temp\n+        } else {\n+            span_bug!(\n+                self.mir.source_info(start_location).span,\n+                \"expected 2-phase borrow to assign to a local, not `{:?}`\",\n+                assigned_place,\n+            );\n+        };\n+\n+        // Insert `temp` into the list of pending activations. From\n+        // now on, we'll be on the lookout for a use of it. Note that\n+        // we are guaranteed that this use will come after the\n+        // assignment.\n+        let old_value = self.pending_activations.insert(temp, borrow_index);\n+        assert!(old_value.is_none());\n+    }\n+}"}, {"sha": "6efe0c39d07b8fcd50824047946549bbd258870b", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1123674b1c719e0a5ced078c15a81a22e16dec0/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1123674b1c719e0a5ced078c15a81a22e16dec0/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=e1123674b1c719e0a5ced078c15a81a22e16dec0", "patch": "@@ -54,6 +54,7 @@ use self::MutateMode::{JustWrite, WriteAndRead};\n crate mod borrow_set;\n mod error_reporting;\n mod flows;\n+crate mod place_ext;\n mod prefixes;\n \n pub(crate) mod nll;"}, {"sha": "f6ffe3c6d2314d5890e862687be1f28e3266b892", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e1123674b1c719e0a5ced078c15a81a22e16dec0/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1123674b1c719e0a5ced078c15a81a22e16dec0/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=e1123674b1c719e0a5ced078c15a81a22e16dec0", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::mir::ProjectionElem;\n+use rustc::mir::{Local, Mir, Place};\n+use rustc::ty::{self, TyCtxt};\n+\n+/// Extension methods for the `Place` type.\n+crate trait PlaceExt<'tcx> {\n+    /// True if this is a deref of a raw pointer.\n+    fn is_unsafe_place(&self, tcx: TyCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) -> bool;\n+\n+    /// If this is a place like `x.f.g`, returns the local\n+    /// `x`. Returns `None` if this is based in a static.\n+    fn root_local(&self) -> Option<Local>;\n+}\n+\n+impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n+    fn is_unsafe_place(&self, tcx: TyCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) -> bool {\n+        match self {\n+            Place::Local(_) => false,\n+            Place::Static(static_) => {\n+                tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable)\n+            }\n+            Place::Projection(proj) => match proj.elem {\n+                ProjectionElem::Field(..)\n+                | ProjectionElem::Downcast(..)\n+                | ProjectionElem::Subslice { .. }\n+                | ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Index(_) => proj.base.is_unsafe_place(tcx, mir),\n+                ProjectionElem::Deref => {\n+                    let ty = proj.base.ty(mir, tcx).to_ty(tcx);\n+                    match ty.sty {\n+                        ty::TyRawPtr(..) => true,\n+                        _ => proj.base.is_unsafe_place(tcx, mir),\n+                    }\n+                }\n+            },\n+        }\n+    }\n+\n+    fn root_local(&self) -> Option<Local> {\n+        let mut p = self;\n+        loop {\n+            match p {\n+                Place::Projection(pi) => p = &pi.base,\n+                Place::Static(_) => return None,\n+                Place::Local(l) => return Some(*l),\n+            }\n+        }\n+    }\n+}"}, {"sha": "79f2915e12c0f147405f3d7a990e2a3869cd9a88", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 12, "deletions": 404, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/e1123674b1c719e0a5ced078c15a81a22e16dec0/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1123674b1c719e0a5ced078c15a81a22e16dec0/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=e1123674b1c719e0a5ced078c15a81a22e16dec0", "patch": "@@ -9,18 +9,16 @@\n // except according to those terms.\n \n use borrow_check::borrow_set::{BorrowSet, BorrowData};\n+use borrow_check::place_ext::PlaceExt;\n \n use rustc;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n use rustc::mir::{self, Location, Place, Mir};\n-use rustc::mir::traversal;\n-use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::ty::{self, Region, TyCtxt};\n+use rustc::ty::{Region, TyCtxt};\n use rustc::ty::RegionKind;\n use rustc::ty::RegionKind::ReScope;\n-use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n@@ -34,7 +32,6 @@ use borrow_check::nll::ToRegionVid;\n \n use syntax_pos::Span;\n \n-use std::hash::Hash;\n use std::rc::Rc;\n \n /// `Borrows` stores the data used in the analyses that track the flow\n@@ -82,373 +79,15 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         let root_scope = body_id.map(|body_id| {\n             region::Scope::CallSite(tcx.hir.body(body_id).value.hir_id.local_id)\n         });\n-        let mut visitor = GatherBorrows {\n-            tcx,\n-            mir,\n-            idx_vec: IndexVec::new(),\n-            location_map: FxHashMap(),\n-            activation_map: FxHashMap(),\n-            region_map: FxHashMap(),\n-            local_map: FxHashMap(),\n-            region_span_map: FxHashMap(),\n-            nonlexical_regioncx: nonlexical_regioncx.clone(),\n-            pending_activations: FxHashMap(),\n-        };\n-        for (block, block_data) in traversal::preorder(mir) {\n-            visitor.visit_basic_block_data(block, block_data);\n-        }\n-\n-        // Double check: We should have found an activation for every pending\n-        // activation.\n-        assert_eq!(\n-            visitor\n-                .pending_activations\n-                .iter()\n-                .find(|&(_local, &borrow_index)| {\n-                    visitor.idx_vec[borrow_index].activation_location.is_none()\n-                }),\n-            None,\n-            \"never found an activation for this borrow!\",\n-        );\n-\n-        return Borrows { tcx: tcx,\n-                         mir: mir,\n-                         borrow_set: BorrowSet {\n-                             borrows: visitor.idx_vec,\n-                             location_map: visitor.location_map,\n-                             activation_map: visitor.activation_map,\n-                             region_map: visitor.region_map,\n-                             local_map: visitor.local_map,\n-                             region_span_map: visitor.region_span_map,\n-                         },\n-                         scope_tree,\n-                         root_scope,\n-                         nonlexical_regioncx };\n-\n-        struct GatherBorrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-            mir: &'a Mir<'tcx>,\n-            idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n-            location_map: FxHashMap<Location, BorrowIndex>,\n-            activation_map: FxHashMap<Location, FxHashSet<BorrowIndex>>,\n-            region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n-            local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n-            region_span_map: FxHashMap<RegionKind, Span>,\n-            nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n-\n-            /// When we encounter a 2-phase borrow statement, it will always\n-            /// be assigning into a temporary TEMP:\n-            ///\n-            ///    TEMP = &foo\n-            ///\n-            /// We add TEMP into this map with `b`, where `b` is the index of\n-            /// the borrow. When we find a later use of this activation, we\n-            /// remove from the map (and add to the \"tombstone\" set below).\n-            pending_activations: FxHashMap<mir::Local, BorrowIndex>,\n-        }\n-\n-        impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n-            fn visit_assign(&mut self,\n-                            block: mir::BasicBlock,\n-                            assigned_place: &mir::Place<'tcx>,\n-                            rvalue: &mir::Rvalue<'tcx>,\n-                            location: mir::Location) {\n-                fn root_local(mut p: &mir::Place<'_>) -> Option<mir::Local> {\n-                    loop { match p {\n-                        mir::Place::Projection(pi) => p = &pi.base,\n-                        mir::Place::Static(_) => return None,\n-                        mir::Place::Local(l) => return Some(*l)\n-                    }}\n-                }\n-\n-                if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n-                    if is_unsafe_place(self.tcx, self.mir, borrowed_place) { return; }\n-\n-                    let borrow = BorrowData {\n-                        kind,\n-                        region,\n-                        reserve_location: location,\n-                        activation_location: None,\n-                        borrowed_place: borrowed_place.clone(),\n-                        assigned_place: assigned_place.clone(),\n-                    };\n-                    let idx = self.idx_vec.push(borrow);\n-                    self.location_map.insert(location, idx);\n-\n-                    self.insert_as_pending_if_two_phase(\n-                        location,\n-                        &assigned_place,\n-                        region,\n-                        kind,\n-                        idx,\n-                    );\n-\n-                    insert(&mut self.region_map, &region, idx);\n-                    if let Some(local) = root_local(borrowed_place) {\n-                        insert(&mut self.local_map, &local, idx);\n-                    }\n-                }\n-\n-                return self.super_assign(block, assigned_place, rvalue, location);\n-\n-                fn insert<'a, K, V>(map: &'a mut FxHashMap<K, FxHashSet<V>>,\n-                                    k: &K,\n-                                    v: V)\n-                    where K: Clone+Eq+Hash, V: Eq+Hash\n-                {\n-                    map.entry(k.clone())\n-                        .or_insert(FxHashSet())\n-                        .insert(v);\n-                }\n-            }\n-\n-            fn visit_place(\n-                &mut self,\n-                place: &mir::Place<'tcx>,\n-                context: PlaceContext<'tcx>,\n-                location: Location,\n-            ) {\n-                self.super_place(place, context, location);\n-\n-                // We found a use of some temporary TEMP...\n-                if let Place::Local(temp) = place {\n-                    // ... check whether we (earlier) saw a 2-phase borrow like\n-                    //\n-                    //     TMP = &mut place\n-                    match self.pending_activations.get(temp) {\n-                        Some(&borrow_index) => {\n-                            let borrow_data = &mut self.idx_vec[borrow_index];\n-\n-                            // Watch out: the use of TMP in the borrow\n-                            // itself doesn't count as an\n-                            // activation. =)\n-                            if borrow_data.reserve_location == location\n-                                && context == PlaceContext::Store\n-                            {\n-                                return;\n-                            }\n-\n-                            if let Some(other_activation) = borrow_data.activation_location {\n-                                span_bug!(\n-                                    self.mir.source_info(location).span,\n-                                    \"found two activations for 2-phase borrow temporary {:?}: \\\n-                                     {:?} and {:?}\",\n-                                    temp,\n-                                    location,\n-                                    other_activation,\n-                                );\n-                            }\n-\n-                            // Otherwise, this is the unique later use\n-                            // that we expect.\n-                            borrow_data.activation_location = Some(location);\n-                            self.activation_map\n-                                .entry(location)\n-                                .or_insert(FxHashSet())\n-                                .insert(borrow_index);\n-                        }\n-\n-                        None => {}\n-                    }\n-                }\n-            }\n-\n-            fn visit_rvalue(&mut self,\n-                            rvalue: &mir::Rvalue<'tcx>,\n-                            location: mir::Location) {\n-                if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n-                    // double-check that we already registered a BorrowData for this\n-\n-                    let borrow_index = self.location_map[&location];\n-                    let borrow_data = &self.idx_vec[borrow_index];\n-                    assert_eq!(borrow_data.reserve_location, location);\n-                    assert_eq!(borrow_data.kind, kind);\n-                    assert_eq!(borrow_data.region, region);\n-                    assert_eq!(borrow_data.borrowed_place, *place);\n-                }\n-\n-                return self.super_rvalue(rvalue, location);\n-            }\n-\n-            fn visit_statement(&mut self,\n-                               block: mir::BasicBlock,\n-                               statement: &mir::Statement<'tcx>,\n-                               location: Location) {\n-                if let mir::StatementKind::EndRegion(region_scope) = statement.kind {\n-                    self.region_span_map.insert(ReScope(region_scope), statement.source_info.span);\n-                }\n-                return self.super_statement(block, statement, location);\n-            }\n-        }\n-\n-        /// A MIR visitor that determines if a specific place is used in a two-phase activating\n-        /// manner in a given chunk of MIR.\n-        struct ContainsUseOfPlace<'b, 'tcx: 'b> {\n-            target: &'b Place<'tcx>,\n-            use_found: bool,\n-        }\n-\n-        impl<'b, 'tcx: 'b> ContainsUseOfPlace<'b, 'tcx> {\n-            fn new(place: &'b Place<'tcx>) -> Self {\n-                Self { target: place, use_found: false }\n-            }\n-\n-            /// return whether `context` should be considered a \"use\" of a\n-            /// place found in that context. \"Uses\" activate associated\n-            /// borrows (at least when such uses occur while the borrow also\n-            /// has a reservation at the time).\n-            fn is_potential_use(context: PlaceContext) -> bool {\n-                match context {\n-                    // storage effects on a place do not activate it\n-                    PlaceContext::StorageLive | PlaceContext::StorageDead => false,\n-\n-                    // validation effects do not activate a place\n-                    //\n-                    // FIXME: Should they? Is it just another read? Or can we\n-                    // guarantee it won't dereference the stored address? How\n-                    // \"deep\" does validation go?\n-                    PlaceContext::Validate => false,\n-\n-                    // FIXME: This is here to not change behaviour from before\n-                    // AsmOutput existed, but it's not necessarily a pure overwrite.\n-                    // so it's possible this should activate the place.\n-                    PlaceContext::AsmOutput |\n-                    // pure overwrites of a place do not activate it. (note\n-                    // PlaceContext::Call is solely about dest place)\n-                    PlaceContext::Store | PlaceContext::Call => false,\n-\n-                    // reads of a place *do* activate it\n-                    PlaceContext::Move |\n-                    PlaceContext::Copy |\n-                    PlaceContext::Drop |\n-                    PlaceContext::Inspect |\n-                    PlaceContext::Borrow { .. } |\n-                    PlaceContext::Projection(..) => true,\n-                }\n-            }\n-        }\n-\n-        impl<'b, 'tcx: 'b> Visitor<'tcx> for ContainsUseOfPlace<'b, 'tcx> {\n-            fn visit_place(&mut self,\n-                           place: &mir::Place<'tcx>,\n-                           context: PlaceContext<'tcx>,\n-                           location: Location) {\n-                if Self::is_potential_use(context) && place == self.target {\n-                    self.use_found = true;\n-                    return;\n-                    // There is no need to keep checking the statement, we already found a use\n-                }\n-\n-                self.super_place(place, context, location);\n-            }\n-        }\n-\n-        impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n-            /// Returns true if the borrow represented by `kind` is\n-            /// allowed to be split into separate Reservation and\n-            /// Activation phases.\n-            fn allow_two_phase_borrow(&self, kind: mir::BorrowKind) -> bool {\n-                self.tcx.two_phase_borrows() &&\n-                    (kind.allows_two_phase_borrow() ||\n-                     self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n-            }\n-\n-            /// Returns true if the given location contains an NLL-activating use of the given place\n-            fn location_contains_use(&self, location: Location, place: &Place) -> bool {\n-                let mut use_checker = ContainsUseOfPlace::new(place);\n-                let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n-                    panic!(\"could not find block at location {:?}\", location);\n-                });\n-                if location.statement_index != block.statements.len() {\n-                    // This is a statement\n-                    let stmt = block.statements.get(location.statement_index).unwrap_or_else(|| {\n-                        panic!(\"could not find statement at location {:?}\");\n-                    });\n-                    use_checker.visit_statement(location.block, stmt, location);\n-                } else {\n-                    // This is a terminator\n-                    match block.terminator {\n-                        Some(ref term) => {\n-                            use_checker.visit_terminator(location.block, term, location);\n-                        }\n-                        None => {\n-                            // There is no way for Place to be used by the terminator if there is no\n-                            // terminator\n-                        }\n-                    }\n-                }\n-\n-                use_checker.use_found\n-            }\n-\n-            /// Determines if the provided region is terminated after the provided location.\n-            /// EndRegion statements terminate their enclosed region::Scope.\n-            /// We also consult with the NLL region inference engine, should one be available\n-            fn region_terminated_after(&self, region: Region<'tcx>, location: Location) -> bool {\n-                let block_data = &self.mir[location.block];\n-                if location.statement_index != block_data.statements.len() {\n-                    let stmt = &block_data.statements[location.statement_index];\n-                    if let mir::StatementKind::EndRegion(region_scope) = stmt.kind {\n-                        if &ReScope(region_scope) == region {\n-                            // We encountered an EndRegion statement that terminates the provided\n-                            // region\n-                            return true;\n-                        }\n-                    }\n-                }\n-                if let Some(ref regioncx) = self.nonlexical_regioncx {\n-                    if !regioncx.region_contains_point(region, location) {\n-                        // NLL says the region has ended already\n-                        return true;\n-                    }\n-                }\n-\n-                false\n-            }\n-\n-            /// If this is a two-phase borrow, then we will record it\n-            /// as \"pending\" until we find the activating use.\n-            fn insert_as_pending_if_two_phase(\n-                &mut self,\n-                start_location: Location,\n-                assigned_place: &mir::Place<'tcx>,\n-                region: Region<'tcx>,\n-                kind: mir::BorrowKind,\n-                borrow_index: BorrowIndex,\n-            ) {\n-                debug!(\n-                    \"Borrows::insert_as_pending_if_two_phase({:?}, {:?}, {:?}, {:?})\",\n-                    start_location, assigned_place, region, borrow_index,\n-                );\n-\n-                if !self.allow_two_phase_borrow(kind) {\n-                    debug!(\"  -> {:?}\", start_location);\n-                    return;\n-                }\n-\n-                // When we encounter a 2-phase borrow statement, it will always\n-                // be assigning into a temporary TEMP:\n-                //\n-                //    TEMP = &foo\n-                //\n-                // so extract `temp`.\n-                let temp = if let &mir::Place::Local(temp) = assigned_place {\n-                    temp\n-                } else {\n-                    span_bug!(\n-                        self.mir.source_info(start_location).span,\n-                        \"expected 2-phase borrow to assign to a local, not `{:?}`\",\n-                        assigned_place,\n-                    );\n-                };\n-\n-                // Insert `temp` into the list of pending activations. From\n-                // now on, we'll be on the lookout for a use of it. Note that\n-                // we are guaranteed that this use will come after the\n-                // assignment.\n-                let old_value = self.pending_activations.insert(temp, borrow_index);\n-                assert!(old_value.is_none());\n-            }\n+        let borrow_set = BorrowSet::build(tcx, mir);\n+\n+        Borrows {\n+            tcx: tcx,\n+            mir: mir,\n+            borrow_set,\n+            scope_tree,\n+            root_scope,\n+            nonlexical_regioncx,\n         }\n     }\n \n@@ -597,7 +236,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                 // propagate_call_return method.\n \n                 if let mir::Rvalue::Ref(region, _, ref place) = *rhs {\n-                    if is_unsafe_place(self.tcx, self.mir, place) { return; }\n+                    if place.is_unsafe_place(self.tcx, self.mir) { return; }\n                     let index = self.borrow_set.location_map.get(&location).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndex for location {:?}\", location);\n                     });\n@@ -744,34 +383,3 @@ impl<'a, 'gcx, 'tcx> InitialFlow for Borrows<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn is_unsafe_place<'a, 'gcx: 'tcx, 'tcx: 'a>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n-    place: &mir::Place<'tcx>\n-) -> bool {\n-    use self::mir::Place::*;\n-    use self::mir::ProjectionElem;\n-\n-    match *place {\n-        Local(_) => false,\n-        Static(ref static_) => tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable),\n-        Projection(ref proj) => {\n-            match proj.elem {\n-                ProjectionElem::Field(..) |\n-                ProjectionElem::Downcast(..) |\n-                ProjectionElem::Subslice { .. } |\n-                ProjectionElem::ConstantIndex { .. } |\n-                ProjectionElem::Index(_) => {\n-                    is_unsafe_place(tcx, mir, &proj.base)\n-                }\n-                ProjectionElem::Deref => {\n-                    let ty = proj.base.ty(mir, tcx).to_ty(tcx);\n-                    match ty.sty {\n-                        ty::TyRawPtr(..) => true,\n-                        _ => is_unsafe_place(tcx, mir, &proj.base),\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"}]}