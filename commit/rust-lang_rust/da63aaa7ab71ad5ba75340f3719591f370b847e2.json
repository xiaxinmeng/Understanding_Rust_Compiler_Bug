{"sha": "da63aaa7ab71ad5ba75340f3719591f370b847e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNjNhYWE3YWI3MWFkNWJhNzUzNDBmMzcxOTU5MWYzNzBiODQ3ZTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-10T14:56:13Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-20T19:04:52Z"}, "message": "extract `input_output` code into its own module\n\nNo functional change.", "tree": {"sha": "5532b1be8dee8d68118c94884cd0dc74e340675b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5532b1be8dee8d68118c94884cd0dc74e340675b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da63aaa7ab71ad5ba75340f3719591f370b847e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da63aaa7ab71ad5ba75340f3719591f370b847e2", "html_url": "https://github.com/rust-lang/rust/commit/da63aaa7ab71ad5ba75340f3719591f370b847e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da63aaa7ab71ad5ba75340f3719591f370b847e2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a66c6512aa473bcb8721e0423a1739bf8e976b91", "url": "https://api.github.com/repos/rust-lang/rust/commits/a66c6512aa473bcb8721e0423a1739bf8e976b91", "html_url": "https://github.com/rust-lang/rust/commit/a66c6512aa473bcb8721e0423a1739bf8e976b91"}], "stats": {"total": 152, "additions": 101, "deletions": 51}, "files": [{"sha": "b85573b9c07d2f1c922209d8fb2525c4f4078e24", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/da63aaa7ab71ad5ba75340f3719591f370b847e2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da63aaa7ab71ad5ba75340f3719591f370b847e2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=da63aaa7ab71ad5ba75340f3719591f370b847e2", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains code to equate the input/output types appearing\n+//! in the MIR with the expected input/output types from the function\n+//! signature. This requires a bit of processing, as the expected types\n+//! are supplied to us before normalization and may contain existential\n+//! `impl Trait` instances. In contrast, the input/output types found in\n+//! the MIR (specifically, in the special local variables for the\n+//! `RETURN_PLACE` the MIR arguments) are always fully normalize (and\n+//! contain revealed `impl Trait` values).\n+\n+use borrow_check::nll::universal_regions::UniversalRegions;\n+use rustc::ty::Ty;\n+use rustc::mir::*;\n+\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use super::{AtLocation, TypeChecker};\n+\n+impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n+    pub(super) fn equate_inputs_and_outputs(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        universal_regions: &UniversalRegions<'tcx>,\n+    ) {\n+        let &UniversalRegions {\n+            unnormalized_output_ty,\n+            unnormalized_input_tys,\n+            ..\n+        } = universal_regions;\n+\n+        let start_position = Location {\n+            block: START_BLOCK,\n+            statement_index: 0,\n+        };\n+\n+        // Equate expected input tys with those in the MIR.\n+        let argument_locals = (1..).map(Local::new);\n+        for (&unnormalized_input_ty, local) in unnormalized_input_tys.iter().zip(argument_locals) {\n+            let input_ty = self.normalize(&unnormalized_input_ty, start_position);\n+            let mir_input_ty = mir.local_decls[local].ty;\n+            self.equate_normalized_input_or_output(start_position, input_ty, mir_input_ty);\n+        }\n+\n+        // Return types are a bit more complex. They may contain existential `impl Trait`\n+        // types.\n+\n+        let output_ty = self.normalize(&unnormalized_output_ty, start_position);\n+        let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n+        self.equate_normalized_input_or_output(start_position, output_ty, mir_output_ty);\n+    }\n+\n+    fn equate_normalized_input_or_output(&mut self, location: Location, a: Ty<'tcx>, b: Ty<'tcx>) {\n+        debug!(\"equate_normalized_input_or_output(a={:?}, b={:?})\", a, b);\n+\n+        if let Err(terr) = self.eq_types(a, b, location.at_self()) {\n+            span_mirbug!(\n+                self,\n+                location,\n+                \"equate_normalized_input_or_output: `{:?}=={:?}` failed with `{:?}`\",\n+                a,\n+                b,\n+                terr\n+            );\n+        }\n+    }\n+}"}, {"sha": "48750b626114b5cee0dc1b82338fcb378f41c2a6", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 26, "deletions": 51, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/da63aaa7ab71ad5ba75340f3719591f370b847e2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da63aaa7ab71ad5ba75340f3719591f370b847e2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=da63aaa7ab71ad5ba75340f3719591f370b847e2", "patch": "@@ -36,7 +36,32 @@ use util::liveness::LivenessResults;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n \n+macro_rules! span_mirbug {\n+    ($context:expr, $elem:expr, $($message:tt)*) => ({\n+        $crate::borrow_check::nll::type_check::mirbug(\n+            $context.tcx(),\n+            $context.last_span,\n+            &format!(\n+                \"broken MIR in {:?} ({:?}): {}\",\n+                $context.body_id,\n+                $elem,\n+                format_args!($($message)*),\n+            ),\n+        )\n+    })\n+}\n+\n+macro_rules! span_mirbug_and_err {\n+    ($context:expr, $elem:expr, $($message:tt)*) => ({\n+        {\n+            span_mirbug!($context, $elem, $($message)*);\n+            $context.error()\n+        }\n+    })\n+}\n+\n mod liveness;\n+mod input_output;\n \n /// Type checks the given `mir` in the context of the inference\n /// context `infcx`. Returns any region constraints that have yet to\n@@ -88,18 +113,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         &mut |cx| {\n             liveness::generate(cx, mir, liveness, flow_inits, move_data);\n \n-            // Equate the input and output tys given by the user with\n-            // the ones found in the MIR.\n-            let &UniversalRegions {\n-                unnormalized_output_ty,\n-                unnormalized_input_tys,\n-                ..\n-            } = universal_regions;\n-            cx.equate_input_or_output(unnormalized_output_ty, mir.local_decls[RETURN_PLACE].ty);\n-            let arg_locals = (1..).map(Local::new);\n-            for (&input_ty, local) in unnormalized_input_tys.iter().zip(arg_locals) {\n-                cx.equate_input_or_output(input_ty, mir.local_decls[local].ty);\n-            }\n+            cx.equate_inputs_and_outputs(mir, universal_regions);\n         },\n     )\n }\n@@ -136,33 +150,13 @@ fn type_check_internal<'gcx, 'tcx>(\n     checker.constraints\n }\n \n-\n fn mirbug(tcx: TyCtxt, span: Span, msg: &str) {\n     // We sometimes see MIR failures (notably predicate failures) due to\n     // the fact that we check rvalue sized predicates here. So use `delay_span_bug`\n     // to avoid reporting bugs in those cases.\n     tcx.sess.diagnostic().delay_span_bug(span, msg);\n }\n \n-macro_rules! span_mirbug {\n-    ($context:expr, $elem:expr, $($message:tt)*) => ({\n-        mirbug($context.tcx(), $context.last_span,\n-               &format!(\"broken MIR in {:?} ({:?}): {}\",\n-                        $context.body_id,\n-                        $elem,\n-                        format_args!($($message)*)))\n-    })\n-}\n-\n-macro_rules! span_mirbug_and_err {\n-    ($context:expr, $elem:expr, $($message:tt)*) => ({\n-        {\n-            span_mirbug!($context, $elem, $($message)*);\n-            $context.error()\n-        }\n-    })\n-}\n-\n enum FieldAccessError {\n     OutOfRange { field_count: usize },\n }\n@@ -714,25 +708,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn equate_input_or_output(&mut self, unnormalized_a: Ty<'tcx>, b: Ty<'tcx>) {\n-        let start_position = Location {\n-            block: START_BLOCK,\n-            statement_index: 0,\n-        };\n-        let a = self.normalize(&unnormalized_a, start_position);\n-        if let Err(terr) = self.eq_types(a, b, start_position.at_self()) {\n-            span_mirbug!(\n-                self,\n-                start_position,\n-                \"bad input or output {:?} normalized to {:?} should equal {:?} but got error {:?}\",\n-                unnormalized_a,\n-                a,\n-                b,\n-                terr\n-            );\n-        }\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }"}]}