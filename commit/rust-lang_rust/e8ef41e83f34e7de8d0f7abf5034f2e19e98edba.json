{"sha": "e8ef41e83f34e7de8d0f7abf5034f2e19e98edba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZWY0MWU4M2YzNGU3ZGU4ZDBmN2FiZjUwMzRmMmUxOWU5OGVkYmE=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-27T17:41:13Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-04-28T09:14:48Z"}, "message": "Allow the QueryCache to specify storage.", "tree": {"sha": "b398c0755e5b385da942a44b9a9ecfdf11d4f084", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b398c0755e5b385da942a44b9a9ecfdf11d4f084"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8ef41e83f34e7de8d0f7abf5034f2e19e98edba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8ef41e83f34e7de8d0f7abf5034f2e19e98edba", "html_url": "https://github.com/rust-lang/rust/commit/e8ef41e83f34e7de8d0f7abf5034f2e19e98edba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8ef41e83f34e7de8d0f7abf5034f2e19e98edba/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb5615a4771ea3d54256f969dc84d2dfd38d812c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb5615a4771ea3d54256f969dc84d2dfd38d812c", "html_url": "https://github.com/rust-lang/rust/commit/fb5615a4771ea3d54256f969dc84d2dfd38d812c"}], "stats": {"total": 101, "additions": 62, "deletions": 39}, "files": [{"sha": "a9367dc40b7a24061ea8dfa47507653b4d99b603", "filename": "src/librustc_middle/ty/query/plumbing.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8ef41e83f34e7de8d0f7abf5034f2e19e98edba/src%2Flibrustc_middle%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ef41e83f34e7de8d0f7abf5034f2e19e98edba/src%2Flibrustc_middle%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fplumbing.rs?ref=e8ef41e83f34e7de8d0f7abf5034f2e19e98edba", "patch": "@@ -328,6 +328,10 @@ macro_rules! define_queries_inner {\n         $(impl<$tcx> QueryConfig<TyCtxt<$tcx>> for queries::$name<$tcx> {\n             type Key = $($K)*;\n             type Value = $V;\n+            type Stored = <\n+                query_storage!([$($modifiers)*][$($K)*, $V])\n+                as QueryStorage\n+            >::Stored;\n             const NAME: &'static str = stringify!($name);\n             const CATEGORY: ProfileCategory = $category;\n         }\n@@ -426,8 +430,10 @@ macro_rules! define_queries_inner {\n \n             $($(#[$attr])*\n             #[inline(always)]\n-            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> $V {\n-                self.at(DUMMY_SP).$name(key)\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*))\n+                -> <queries::$name<$tcx> as QueryConfig<TyCtxt<$tcx>>>::Stored\n+            {\n+                self.at(DUMMY_SP).$name(key.into_query_param())\n             })*\n \n             /// All self-profiling events generated by the query engine use\n@@ -463,7 +469,9 @@ macro_rules! define_queries_inner {\n         impl TyCtxtAt<$tcx> {\n             $($(#[$attr])*\n             #[inline(always)]\n-            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> $V {\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*))\n+                -> <queries::$name<$tcx> as QueryConfig<TyCtxt<$tcx>>>::Stored\n+            {\n                 get_query::<queries::$name<'_>, _>(self.tcx, self.span, key.into_query_param())\n             })*\n         }"}, {"sha": "7b9d75037c2f5e5a52c5b1606da53128833176be", "filename": "src/librustc_query_system/query/caches.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e8ef41e83f34e7de8d0f7abf5034f2e19e98edba/src%2Flibrustc_query_system%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ef41e83f34e7de8d0f7abf5034f2e19e98edba/src%2Flibrustc_query_system%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fcaches.rs?ref=e8ef41e83f34e7de8d0f7abf5034f2e19e98edba", "patch": "@@ -8,13 +8,21 @@ use std::default::Default;\n use std::hash::Hash;\n use std::marker::PhantomData;\n \n-pub trait CacheSelector<K: Hash, V> {\n-    type Cache: QueryCache<Key = K, Value = V>;\n+pub trait CacheSelector<K, V> {\n+    type Cache;\n }\n \n-pub trait QueryCache: Default {\n-    type Key: Hash;\n+pub trait QueryStorage: Default {\n     type Value;\n+    type Stored: Clone;\n+\n+    /// Store a value without putting it in the cache.\n+    /// This is meant to be used with cycle errors.\n+    fn store_nocache(&self, value: Self::Value) -> Self::Stored;\n+}\n+\n+pub trait QueryCache: QueryStorage {\n+    type Key: Hash;\n     type Sharded: Default;\n \n     /// Checks if the query is already computed and in the cache.\n@@ -30,7 +38,7 @@ pub trait QueryCache: Default {\n         on_miss: OnMiss,\n     ) -> R\n     where\n-        OnHit: FnOnce(&Self::Value, DepNodeIndex) -> R,\n+        OnHit: FnOnce(&Self::Stored, DepNodeIndex) -> R,\n         OnMiss: FnOnce(Self::Key, QueryLookup<'_, CTX, Self::Key, Self::Sharded>) -> R;\n \n     fn complete<CTX: QueryContext>(\n@@ -40,7 +48,7 @@ pub trait QueryCache: Default {\n         key: Self::Key,\n         value: Self::Value,\n         index: DepNodeIndex,\n-    );\n+    ) -> Self::Stored;\n \n     fn iter<R, L>(\n         &self,\n@@ -66,9 +74,18 @@ impl<K, V> Default for DefaultCache<K, V> {\n     }\n }\n \n+impl<K: Eq + Hash, V: Clone> QueryStorage for DefaultCache<K, V> {\n+    type Value = V;\n+    type Stored = V;\n+\n+    fn store_nocache(&self, value: Self::Value) -> Self::Stored {\n+        // We have no dedicated storage\n+        value\n+    }\n+}\n+\n impl<K: Eq + Hash, V: Clone> QueryCache for DefaultCache<K, V> {\n     type Key = K;\n-    type Value = V;\n     type Sharded = FxHashMap<K, (V, DepNodeIndex)>;\n \n     #[inline(always)]\n@@ -99,8 +116,9 @@ impl<K: Eq + Hash, V: Clone> QueryCache for DefaultCache<K, V> {\n         key: K,\n         value: V,\n         index: DepNodeIndex,\n-    ) {\n-        lock_sharded_storage.insert(key, (value, index));\n+    ) -> Self::Stored {\n+        lock_sharded_storage.insert(key, (value.clone(), index));\n+        value\n     }\n \n     fn iter<R, L>("}, {"sha": "710ec3bfb0b3c80a0242b00be1c62c364d14ef27", "filename": "src/librustc_query_system/query/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8ef41e83f34e7de8d0f7abf5034f2e19e98edba/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ef41e83f34e7de8d0f7abf5034f2e19e98edba/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fconfig.rs?ref=e8ef41e83f34e7de8d0f7abf5034f2e19e98edba", "patch": "@@ -20,15 +20,16 @@ pub trait QueryConfig<CTX> {\n     const CATEGORY: ProfileCategory;\n \n     type Key: Eq + Hash + Clone + Debug;\n-    type Value: Clone;\n+    type Value;\n+    type Stored: Clone;\n }\n \n pub trait QueryAccessors<CTX: QueryContext>: QueryConfig<CTX> {\n     const ANON: bool;\n     const EVAL_ALWAYS: bool;\n     const DEP_KIND: CTX::DepKind;\n \n-    type Cache: QueryCache<Key = Self::Key, Value = Self::Value>;\n+    type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n     fn query_state<'a>(tcx: CTX) -> &'a QueryState<CTX, Self::Cache>;"}, {"sha": "83513b7e11de9490cb9423aa9d6a90028745766d", "filename": "src/librustc_query_system/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8ef41e83f34e7de8d0f7abf5034f2e19e98edba/src%2Flibrustc_query_system%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ef41e83f34e7de8d0f7abf5034f2e19e98edba/src%2Flibrustc_query_system%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fmod.rs?ref=e8ef41e83f34e7de8d0f7abf5034f2e19e98edba", "patch": "@@ -7,7 +7,7 @@ pub use self::job::deadlock;\n pub use self::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n \n mod caches;\n-pub use self::caches::{CacheSelector, DefaultCacheSelector, QueryCache};\n+pub use self::caches::{CacheSelector, DefaultCacheSelector, QueryCache, QueryStorage};\n \n mod config;\n pub use self::config::{QueryAccessors, QueryConfig, QueryDescription};"}, {"sha": "0aeec269e617ac3c7de012d1e2ea5d8a3606da5d", "filename": "src/librustc_query_system/query/plumbing.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e8ef41e83f34e7de8d0f7abf5034f2e19e98edba/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ef41e83f34e7de8d0f7abf5034f2e19e98edba/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs?ref=e8ef41e83f34e7de8d0f7abf5034f2e19e98edba", "patch": "@@ -148,7 +148,6 @@ struct JobOwner<'tcx, CTX: QueryContext, C>\n where\n     C: QueryCache,\n     C::Key: Eq + Hash + Clone + Debug,\n-    C::Value: Clone,\n {\n     state: &'tcx QueryState<CTX, C>,\n     key: C::Key,\n@@ -159,7 +158,6 @@ impl<'tcx, CTX: QueryContext, C> JobOwner<'tcx, CTX, C>\n where\n     C: QueryCache,\n     C::Key: Eq + Hash + Clone + Debug,\n-    C::Value: Clone,\n {\n     /// Either gets a `JobOwner` corresponding the query, allowing us to\n     /// start executing the query, or returns with the result of the query.\n@@ -177,7 +175,7 @@ where\n         mut lookup: QueryLookup<'a, CTX, C::Key, C::Sharded>,\n     ) -> TryGetJob<'b, CTX, C>\n     where\n-        Q: QueryDescription<CTX, Key = C::Key, Value = C::Value, Cache = C>,\n+        Q: QueryDescription<CTX, Key = C::Key, Stored = C::Stored, Value = C::Value, Cache = C>,\n         CTX: QueryContext,\n     {\n         let lock = &mut *lookup.lock;\n@@ -229,7 +227,8 @@ where\n         // so we just return the error.\n         #[cfg(not(parallel_compiler))]\n         return TryGetJob::Cycle(cold_path(|| {\n-            Q::handle_cycle_error(tcx, latch.find_cycle_in_stack(tcx, span))\n+            let value = Q::handle_cycle_error(tcx, latch.find_cycle_in_stack(tcx, span));\n+            Q::query_state(tcx).cache.store_nocache(value)\n         }));\n \n         // With parallel queries we might just have to wait on some other\n@@ -239,7 +238,9 @@ where\n             let result = latch.wait_on(tcx, span);\n \n             if let Err(cycle) = result {\n-                return TryGetJob::Cycle(Q::handle_cycle_error(tcx, cycle));\n+                let value = Q::handle_cycle_error(tcx, cycle);\n+                let value = Q::query_state(tcx).cache.store_nocache(value);\n+                return TryGetJob::Cycle(value);\n             }\n \n             let cached = try_get_cached(\n@@ -261,26 +262,26 @@ where\n     /// Completes the query by updating the query cache with the `result`,\n     /// signals the waiter and forgets the JobOwner, so it won't poison the query\n     #[inline(always)]\n-    fn complete(self, tcx: CTX, result: &C::Value, dep_node_index: DepNodeIndex) {\n+    fn complete(self, tcx: CTX, result: C::Value, dep_node_index: DepNodeIndex) -> C::Stored {\n         // We can move out of `self` here because we `mem::forget` it below\n         let key = unsafe { ptr::read(&self.key) };\n         let state = self.state;\n \n         // Forget ourself so our destructor won't poison the query\n         mem::forget(self);\n \n-        let job = {\n-            let result = result.clone();\n+        let (job, result) = {\n             let mut lock = state.shards.get_shard_by_value(&key).lock();\n             let job = match lock.active.remove(&key).unwrap() {\n                 QueryResult::Started(job) => job,\n                 QueryResult::Poisoned => panic!(),\n             };\n-            state.cache.complete(tcx, &mut lock.cache, key, result, dep_node_index);\n-            job\n+            let result = state.cache.complete(tcx, &mut lock.cache, key, result, dep_node_index);\n+            (job, result)\n         };\n \n         job.signal_complete();\n+        result\n     }\n }\n \n@@ -297,7 +298,6 @@ where\n impl<'tcx, CTX: QueryContext, C: QueryCache> Drop for JobOwner<'tcx, CTX, C>\n where\n     C::Key: Eq + Hash + Clone + Debug,\n-    C::Value: Clone,\n {\n     #[inline(never)]\n     #[cold]\n@@ -331,7 +331,6 @@ pub struct CycleError<Q> {\n enum TryGetJob<'tcx, CTX: QueryContext, C: QueryCache>\n where\n     C::Key: Eq + Hash + Clone + Debug,\n-    C::Value: Clone,\n {\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n     NotYetStarted(JobOwner<'tcx, CTX, C>),\n@@ -340,10 +339,10 @@ where\n     /// Returns the result of the query and its dep-node index\n     /// if it succeeded or a cycle error if it failed.\n     #[cfg(parallel_compiler)]\n-    JobCompleted((C::Value, DepNodeIndex)),\n+    JobCompleted((C::Stored, DepNodeIndex)),\n \n     /// Trying to execute the query resulted in a cycle.\n-    Cycle(C::Value),\n+    Cycle(C::Stored),\n }\n \n /// Checks if the query is already computed and in the cache.\n@@ -362,7 +361,7 @@ fn try_get_cached<CTX, C, R, OnHit, OnMiss>(\n where\n     C: QueryCache,\n     CTX: QueryContext,\n-    OnHit: FnOnce(&C::Value, DepNodeIndex) -> R,\n+    OnHit: FnOnce(&C::Stored, DepNodeIndex) -> R,\n     OnMiss: FnOnce(C::Key, QueryLookup<'_, CTX, C::Key, C::Sharded>) -> R,\n {\n     state.cache.lookup(\n@@ -388,7 +387,7 @@ fn try_execute_query<Q, CTX>(\n     span: Span,\n     key: Q::Key,\n     lookup: QueryLookup<'_, CTX, Q::Key, <Q::Cache as QueryCache>::Sharded>,\n-) -> Q::Value\n+) -> Q::Stored\n where\n     Q: QueryDescription<CTX>,\n     CTX: QueryContext,\n@@ -427,9 +426,7 @@ where\n             tcx.store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n         }\n \n-        job.complete(tcx, &result, dep_node_index);\n-\n-        return result;\n+        return job.complete(tcx, result, dep_node_index);\n     }\n \n     let dep_node = Q::to_dep_node(tcx, &key);\n@@ -454,8 +451,7 @@ where\n             })\n         });\n         if let Some((result, dep_node_index)) = loaded {\n-            job.complete(tcx, &result, dep_node_index);\n-            return result;\n+            return job.complete(tcx, result, dep_node_index);\n         }\n     }\n \n@@ -558,7 +554,7 @@ fn force_query_with_job<Q, CTX>(\n     key: Q::Key,\n     job: JobOwner<'_, CTX, Q::Cache>,\n     dep_node: DepNode<CTX::DepKind>,\n-) -> (Q::Value, DepNodeIndex)\n+) -> (Q::Stored, DepNodeIndex)\n where\n     Q: QueryDescription<CTX>,\n     CTX: QueryContext,\n@@ -603,13 +599,13 @@ where\n         }\n     }\n \n-    job.complete(tcx, &result, dep_node_index);\n+    let result = job.complete(tcx, result, dep_node_index);\n \n     (result, dep_node_index)\n }\n \n #[inline(never)]\n-pub fn get_query<Q, CTX>(tcx: CTX, span: Span, key: Q::Key) -> Q::Value\n+pub fn get_query<Q, CTX>(tcx: CTX, span: Span, key: Q::Key) -> Q::Stored\n where\n     Q: QueryDescription<CTX>,\n     CTX: QueryContext,"}]}