{"sha": "e524781e5821c82e0c2031c2ad072d0345e102a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1MjQ3ODFlNTgyMWM4MmUwYzIwMzFjMmFkMDcyZDAzNDVlMTAyYTU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-14T14:45:44Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-15T02:10:21Z"}, "message": "Ported coherence.rs from oldvisit to <V:Visitor> trait API.", "tree": {"sha": "e6215a69052f2ee5de3f576630cd0b200b728b0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6215a69052f2ee5de3f576630cd0b200b728b0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e524781e5821c82e0c2031c2ad072d0345e102a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e524781e5821c82e0c2031c2ad072d0345e102a5", "html_url": "https://github.com/rust-lang/rust/commit/e524781e5821c82e0c2031c2ad072d0345e102a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e524781e5821c82e0c2031c2ad072d0345e102a5/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8d2141f03bc7fa0f66b76ff8870f35117ea2d21", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8d2141f03bc7fa0f66b76ff8870f35117ea2d21", "html_url": "https://github.com/rust-lang/rust/commit/e8d2141f03bc7fa0f66b76ff8870f35117ea2d21"}], "stats": {"total": 136, "additions": 73, "deletions": 63}, "files": [{"sha": "b659f6081b12a05d0d13994884d0789b642b626a", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 73, "deletions": 63, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/e524781e5821c82e0c2031c2ad072d0345e102a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e524781e5821c82e0c2031c2ad072d0345e102a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=e524781e5821c82e0c2031c2ad072d0345e102a5", "patch": "@@ -45,10 +45,7 @@ use syntax::ast_map;\n use syntax::ast_util::{def_id_of_def, local_def};\n use syntax::codemap::{span, dummy_sp};\n use syntax::opt_vec;\n-use syntax::oldvisit::{default_simple_visitor, default_visitor};\n-use syntax::oldvisit::{mk_simple_visitor, mk_vt, visit_crate, visit_item};\n-use syntax::oldvisit::{Visitor, SimpleVisitor};\n-use syntax::oldvisit::{visit_mod};\n+use syntax::visit;\n use syntax::parse;\n use util::ppaux::ty_to_str;\n \n@@ -168,31 +165,89 @@ pub struct CoherenceChecker {\n     base_type_def_ids: @mut HashMap<def_id,def_id>,\n }\n \n-impl CoherenceChecker {\n-    pub fn check_coherence(self, crate: &Crate) {\n-        // Check implementations and traits. This populates the tables\n-        // containing the inherent methods and extension methods. It also\n-        // builds up the trait inheritance table.\n-        visit_crate(crate, ((), mk_simple_visitor(@SimpleVisitor {\n-            visit_item: |item| {\n+struct CoherenceCheckVisitor { cc: CoherenceChecker }\n+\n+impl visit::Visitor<()> for CoherenceCheckVisitor {\n+    fn visit_item(&mut self, item:@item, _:()) {\n+\n //                debug!(\"(checking coherence) item '%s'\",\n-//                       self.crate_context.tcx.sess.str_of(item.ident));\n+//                       self.cc.crate_context.tcx.sess.str_of(item.ident));\n \n                 match item.node {\n                     item_impl(_, ref opt_trait, _, _) => {\n                         let opt_trait : ~[trait_ref] =\n                             opt_trait.iter()\n                                      .map(|x| (*x).clone())\n                                      .collect();\n-                        self.check_implementation(item, opt_trait);\n+                        self.cc.check_implementation(item, opt_trait);\n                     }\n                     _ => {\n                         // Nothing to do.\n                     }\n                 };\n-            },\n-            .. *default_simple_visitor()\n-        })));\n+\n+        visit::walk_item(self, item, ());\n+    }\n+}\n+\n+struct PrivilegedScopeVisitor { cc: CoherenceChecker }\n+\n+impl visit::Visitor<()> for PrivilegedScopeVisitor {\n+    fn visit_item(&mut self, item:@item, _:()) {\n+\n+                match item.node {\n+                    item_mod(ref module_) => {\n+                        // Then visit the module items.\n+                        visit::walk_mod(self, module_, ());\n+                    }\n+                    item_impl(_, None, ref ast_ty, _) => {\n+                        if !self.cc.ast_type_is_defined_in_local_crate(ast_ty) {\n+                            // This is an error.\n+                            let session = self.cc.crate_context.tcx.sess;\n+                            session.span_err(item.span,\n+                                             \"cannot associate methods with a type outside the \\\n+                                              crate the type is defined in; define and implement \\\n+                                              a trait or new type instead\");\n+                        }\n+                    }\n+                    item_impl(_, Some(ref trait_ref), _, _) => {\n+                        // `for_ty` is `Type` in `impl Trait for Type`\n+                        let for_ty =\n+                            ty::node_id_to_type(self.cc.crate_context.tcx,\n+                                                item.id);\n+                        if !type_is_defined_in_local_crate(for_ty) {\n+                            // This implementation is not in scope of its base\n+                            // type. This still might be OK if the trait is\n+                            // defined in the same crate.\n+\n+                            let trait_def_id =\n+                                self.cc.trait_ref_to_trait_def_id(trait_ref);\n+\n+                            if trait_def_id.crate != LOCAL_CRATE {\n+                                let session = self.cc.crate_context.tcx.sess;\n+                                session.span_err(item.span,\n+                                                 \"cannot provide an extension implementation \\\n+                                                  for a trait not defined in this crate\");\n+                            }\n+                        }\n+\n+                        visit::walk_item(self, item, ());\n+                    }\n+                    _ => {\n+                        visit::walk_item(self, item, ());\n+                    }\n+                }\n+    }\n+}\n+\n+impl CoherenceChecker {\n+    pub fn check_coherence(self, crate: &Crate) {\n+        // Check implementations and traits. This populates the tables\n+        // containing the inherent methods and extension methods. It also\n+        // builds up the trait inheritance table.\n+\n+        let mut visitor = CoherenceCheckVisitor { cc: self };\n+        visit::walk_crate(&mut visitor, crate, ());\n \n         // Check that there are no overlapping trait instances\n         self.check_implementation_coherence();\n@@ -486,53 +541,8 @@ impl CoherenceChecker {\n \n     // Privileged scope checking\n     pub fn check_privileged_scopes(self, crate: &Crate) {\n-        visit_crate(crate, ((), mk_vt(@Visitor {\n-            visit_item: |item, (_context, visitor)| {\n-                match item.node {\n-                    item_mod(ref module_) => {\n-                        // Then visit the module items.\n-                        visit_mod(module_, item.span, item.id, ((), visitor));\n-                    }\n-                    item_impl(_, None, ref ast_ty, _) => {\n-                        if !self.ast_type_is_defined_in_local_crate(ast_ty) {\n-                            // This is an error.\n-                            let session = self.crate_context.tcx.sess;\n-                            session.span_err(item.span,\n-                                             \"cannot associate methods with a type outside the \\\n-                                              crate the type is defined in; define and implement \\\n-                                              a trait or new type instead\");\n-                        }\n-                    }\n-                    item_impl(_, Some(ref trait_ref), _, _) => {\n-                        // `for_ty` is `Type` in `impl Trait for Type`\n-                        let for_ty =\n-                            ty::node_id_to_type(self.crate_context.tcx,\n-                                                item.id);\n-                        if !type_is_defined_in_local_crate(for_ty) {\n-                            // This implementation is not in scope of its base\n-                            // type. This still might be OK if the trait is\n-                            // defined in the same crate.\n-\n-                            let trait_def_id =\n-                                self.trait_ref_to_trait_def_id(trait_ref);\n-\n-                            if trait_def_id.crate != LOCAL_CRATE {\n-                                let session = self.crate_context.tcx.sess;\n-                                session.span_err(item.span,\n-                                                 \"cannot provide an extension implementation \\\n-                                                  for a trait not defined in this crate\");\n-                            }\n-                        }\n-\n-                        visit_item(item, ((), visitor));\n-                    }\n-                    _ => {\n-                        visit_item(item, ((), visitor));\n-                    }\n-                }\n-            },\n-            .. *default_visitor()\n-        })));\n+        let mut visitor = PrivilegedScopeVisitor{ cc: self };\n+        visit::walk_crate(&mut visitor, crate, ());\n     }\n \n     pub fn trait_ref_to_trait_def_id(&self, trait_ref: &trait_ref) -> def_id {"}]}