{"sha": "de95857129a8bdcc623f57f669b535ddf8a8db6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlOTU4NTcxMjlhOGJkY2M2MjNmNTdmNjY5YjUzNWRkZjhhOGRiNmU=", "commit": {"author": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-10-24T02:02:38Z"}, "committer": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-10-28T03:09:10Z"}, "message": "Don't panic for fatal errors in attribute parsing.", "tree": {"sha": "9b966982e5c9e5d9599e369059303f6457e9971a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b966982e5c9e5d9599e369059303f6457e9971a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de95857129a8bdcc623f57f669b535ddf8a8db6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de95857129a8bdcc623f57f669b535ddf8a8db6e", "html_url": "https://github.com/rust-lang/rust/commit/de95857129a8bdcc623f57f669b535ddf8a8db6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de95857129a8bdcc623f57f669b535ddf8a8db6e/comments", "author": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c141f47c2449a2f70e6d199104eb318b083def2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c141f47c2449a2f70e6d199104eb318b083def2a", "html_url": "https://github.com/rust-lang/rust/commit/c141f47c2449a2f70e6d199104eb318b083def2a"}], "stats": {"total": 110, "additions": 56, "deletions": 54}, "files": [{"sha": "d354a4ae2152710a472e40e03df8abef6bf28774", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de95857129a8bdcc623f57f669b535ddf8a8db6e/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de95857129a8bdcc623f57f669b535ddf8a8db6e/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=de95857129a8bdcc623f57f669b535ddf8a8db6e", "patch": "@@ -26,7 +26,7 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n                        tts: &[ast::TokenTree])\n                        -> Box<base::MacResult+'static> {\n     let mut p = cx.new_parser_from_tts(tts);\n-    let cfg = p.parse_meta_item();\n+    let cfg = panictry!(p.parse_meta_item());\n \n     if !panictry!(p.eat(&token::Eof)){\n         cx.span_err(sp, \"expected 1 cfg-pattern\");"}, {"sha": "a4c99018bb9cc73f08f3e6a912081715dde8185c", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de95857129a8bdcc623f57f669b535ddf8a8db6e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de95857129a8bdcc623f57f669b535ddf8a8db6e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=de95857129a8bdcc623f57f669b535ddf8a8db6e", "patch": "@@ -526,7 +526,7 @@ pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n         \"path\" => {\n             token::NtPath(Box::new(panictry!(p.parse_path(LifetimeAndTypesWithoutColons))))\n         },\n-        \"meta\" => token::NtMeta(p.parse_meta_item()),\n+        \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n         _ => {\n             panic!(p.span_fatal_help(sp,\n                             &format!(\"invalid fragment specifier `{}`\", name),"}, {"sha": "7b96135f1c3e1cbbddeb30ee751bc345ae7adec5", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/de95857129a8bdcc623f57f669b535ddf8a8db6e/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de95857129a8bdcc623f57f669b535ddf8a8db6e/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=de95857129a8bdcc623f57f669b535ddf8a8db6e", "patch": "@@ -12,20 +12,21 @@ use attr;\n use ast;\n use codemap::{spanned, Spanned, mk_sp, Span};\n use parse::common::*; //resolve bug?\n+use parse::PResult;\n use parse::token;\n use parse::parser::{Parser, TokenType};\n use ptr::P;\n \n impl<'a> Parser<'a> {\n     /// Parse attributes that appear before an item\n-    pub fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute> {\n+    pub fn parse_outer_attributes(&mut self) -> PResult<Vec<ast::Attribute>> {\n         let mut attrs: Vec<ast::Attribute> = Vec::new();\n         loop {\n             debug!(\"parse_outer_attributes: self.token={:?}\",\n                    self.token);\n             match self.token {\n               token::Pound => {\n-                attrs.push(self.parse_attribute(false));\n+                attrs.push(try!(self.parse_attribute(false)));\n               }\n               token::DocComment(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n@@ -35,32 +36,32 @@ impl<'a> Parser<'a> {\n                     self.span.hi\n                 );\n                 if attr.node.style != ast::AttrStyle::Outer {\n-                  panic!(self.fatal(\"expected outer comment\"));\n+                  return Err(self.fatal(\"expected outer comment\"));\n                 }\n                 attrs.push(attr);\n-                panictry!(self.bump());\n+                try!(self.bump());\n               }\n               _ => break\n             }\n         }\n-        return attrs;\n+        return Ok(attrs);\n     }\n \n     /// Matches `attribute = # ! [ meta_item ]`\n     ///\n     /// If permit_inner is true, then a leading `!` indicates an inner\n     /// attribute\n-    fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute {\n+    fn parse_attribute(&mut self, permit_inner: bool) -> PResult<ast::Attribute> {\n         debug!(\"parse_attributes: permit_inner={:?} self.token={:?}\",\n                permit_inner, self.token);\n         let (span, value, mut style) = match self.token {\n             token::Pound => {\n                 let lo = self.span.lo;\n-                panictry!(self.bump());\n+                try!(self.bump());\n \n                 if permit_inner { self.expected_tokens.push(TokenType::Token(token::Not)); }\n                 let style = if self.token == token::Not {\n-                    panictry!(self.bump());\n+                    try!(self.bump());\n                     if !permit_inner {\n                         let span = self.span;\n                         self.span_err(span,\n@@ -74,43 +75,43 @@ impl<'a> Parser<'a> {\n                     ast::AttrStyle::Outer\n                 };\n \n-                panictry!(self.expect(&token::OpenDelim(token::Bracket)));\n-                let meta_item = self.parse_meta_item();\n+                try!(self.expect(&token::OpenDelim(token::Bracket)));\n+                let meta_item = try!(self.parse_meta_item());\n                 let hi = self.span.hi;\n-                panictry!(self.expect(&token::CloseDelim(token::Bracket)));\n+                try!(self.expect(&token::CloseDelim(token::Bracket)));\n \n                 (mk_sp(lo, hi), meta_item, style)\n             }\n             _ => {\n                 let token_str = self.this_token_to_string();\n-                panic!(self.fatal(&format!(\"expected `#`, found `{}`\", token_str)));\n+                return Err(self.fatal(&format!(\"expected `#`, found `{}`\", token_str)));\n             }\n         };\n \n         if permit_inner && self.token == token::Semi {\n-            panictry!(self.bump());\n+            try!(self.bump());\n             self.span_warn(span, \"this inner attribute syntax is deprecated. \\\n                            The new syntax is `#![foo]`, with a bang and no semicolon\");\n             style = ast::AttrStyle::Inner;\n         }\n \n-        return Spanned {\n+        Ok(Spanned {\n             span: span,\n             node: ast::Attribute_ {\n                 id: attr::mk_attr_id(),\n                 style: style,\n                 value: value,\n                 is_sugared_doc: false\n             }\n-        };\n+        })\n     }\n \n     /// Parse attributes that appear after the opening of an item. These should\n     /// be preceded by an exclamation mark, but we accept and warn about one\n     /// terminated by a semicolon.\n \n     /// matches inner_attrs*\n-    pub fn parse_inner_attributes(&mut self) -> Vec<ast::Attribute> {\n+    pub fn parse_inner_attributes(&mut self) -> PResult<Vec<ast::Attribute>> {\n         let mut attrs: Vec<ast::Attribute> = vec![];\n         loop {\n             match self.token {\n@@ -120,7 +121,7 @@ impl<'a> Parser<'a> {\n                         break;\n                     }\n \n-                    let attr = self.parse_attribute(true);\n+                    let attr = try!(self.parse_attribute(true));\n                     assert!(attr.node.style == ast::AttrStyle::Inner);\n                     attrs.push(attr);\n                 }\n@@ -131,21 +132,21 @@ impl<'a> Parser<'a> {\n                     let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), str, lo, hi);\n                     if attr.node.style == ast::AttrStyle::Inner {\n                         attrs.push(attr);\n-                        panictry!(self.bump());\n+                        try!(self.bump());\n                     } else {\n                         break;\n                     }\n                 }\n                 _ => break\n             }\n         }\n-        attrs\n+        Ok(attrs)\n     }\n \n     /// matches meta_item = IDENT\n     /// | IDENT = lit\n     /// | IDENT meta_seq\n-    pub fn parse_meta_item(&mut self) -> P<ast::MetaItem> {\n+    pub fn parse_meta_item(&mut self) -> PResult<P<ast::MetaItem>> {\n         let nt_meta = match self.token {\n             token::Interpolated(token::NtMeta(ref e)) => {\n                 Some(e.clone())\n@@ -155,19 +156,19 @@ impl<'a> Parser<'a> {\n \n         match nt_meta {\n             Some(meta) => {\n-                panictry!(self.bump());\n-                return meta;\n+                try!(self.bump());\n+                return Ok(meta);\n             }\n             None => {}\n         }\n \n         let lo = self.span.lo;\n-        let ident = panictry!(self.parse_ident());\n+        let ident = try!(self.parse_ident());\n         let name = self.id_to_interned_str(ident);\n         match self.token {\n             token::Eq => {\n-                panictry!(self.bump());\n-                let lit = panictry!(self.parse_lit());\n+                try!(self.bump());\n+                let lit = try!(self.parse_lit());\n                 // FIXME #623 Non-string meta items are not serialized correctly;\n                 // just forbid them for now\n                 match lit.node {\n@@ -179,25 +180,25 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n                 let hi = self.span.hi;\n-                P(spanned(lo, hi, ast::MetaNameValue(name, lit)))\n+                Ok(P(spanned(lo, hi, ast::MetaNameValue(name, lit))))\n             }\n             token::OpenDelim(token::Paren) => {\n-                let inner_items = self.parse_meta_seq();\n+                let inner_items = try!(self.parse_meta_seq());\n                 let hi = self.span.hi;\n-                P(spanned(lo, hi, ast::MetaList(name, inner_items)))\n+                Ok(P(spanned(lo, hi, ast::MetaList(name, inner_items))))\n             }\n             _ => {\n                 let hi = self.last_span.hi;\n-                P(spanned(lo, hi, ast::MetaWord(name)))\n+                Ok(P(spanned(lo, hi, ast::MetaWord(name))))\n             }\n         }\n     }\n \n     /// matches meta_seq = ( COMMASEP(meta_item) )\n-    fn parse_meta_seq(&mut self) -> Vec<P<ast::MetaItem>> {\n-        panictry!(self.parse_seq(&token::OpenDelim(token::Paren),\n-                       &token::CloseDelim(token::Paren),\n-                       seq_sep_trailing_allowed(token::Comma),\n-                       |p| Ok(p.parse_meta_item()))).node\n+    fn parse_meta_seq(&mut self) -> PResult<Vec<P<ast::MetaItem>>> {\n+        self.parse_unspanned_seq(&token::OpenDelim(token::Paren),\n+                                 &token::CloseDelim(token::Paren),\n+                                 seq_sep_trailing_allowed(token::Comma),\n+                                 |p| p.parse_meta_item())\n     }\n }"}, {"sha": "bbecedf92ea0fd768279f07123b7ccd9de183d4d", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de95857129a8bdcc623f57f669b535ddf8a8db6e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de95857129a8bdcc623f57f669b535ddf8a8db6e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=de95857129a8bdcc623f57f669b535ddf8a8db6e", "patch": "@@ -82,7 +82,8 @@ pub fn parse_crate_attrs_from_file(\n     cfg: ast::CrateConfig,\n     sess: &ParseSess\n ) -> Vec<ast::Attribute> {\n-    new_parser_from_file(sess, cfg, input).parse_inner_attributes()\n+    // FIXME: maybe_aborted?\n+    panictry!(new_parser_from_file(sess, cfg, input).parse_inner_attributes())\n }\n \n pub fn parse_crate_from_source_str(name: String,\n@@ -106,7 +107,7 @@ pub fn parse_crate_attrs_from_source_str(name: String,\n                                            cfg,\n                                            name,\n                                            source);\n-    maybe_aborted(p.parse_inner_attributes(), p)\n+    maybe_aborted(panictry!(p.parse_inner_attributes()), p)\n }\n \n pub fn parse_expr_from_source_str(name: String,\n@@ -133,7 +134,7 @@ pub fn parse_meta_from_source_str(name: String,\n                                   sess: &ParseSess)\n                                   -> P<ast::MetaItem> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    maybe_aborted(p.parse_meta_item(), p)\n+    maybe_aborted(panictry!(p.parse_meta_item()), p)\n }\n \n pub fn parse_stmt_from_source_str(name: String,"}, {"sha": "d71ea4d105b3bc1cef7250f1f266e0e527832e65", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/de95857129a8bdcc623f57f669b535ddf8a8db6e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de95857129a8bdcc623f57f669b535ddf8a8db6e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=de95857129a8bdcc623f57f669b535ddf8a8db6e", "patch": "@@ -1174,7 +1174,7 @@ impl<'a> Parser<'a> {\n             seq_sep_none(),\n             |p| -> PResult<P<TraitItem>> {\n             maybe_whole!(no_clone p, NtTraitItem);\n-            let mut attrs = p.parse_outer_attributes();\n+            let mut attrs = try!(p.parse_outer_attributes());\n             let lo = p.span.lo;\n \n             let (name, node) = if try!(p.eat_keyword(keywords::Type)) {\n@@ -2956,7 +2956,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_arm_nopanic(&mut self) -> PResult<Arm> {\n         maybe_whole!(no_clone self, NtArm);\n \n-        let attrs = self.parse_outer_attributes();\n+        let attrs = try!(self.parse_outer_attributes());\n         let pats = try!(self.parse_pats());\n         let mut guard = None;\n         if try!(self.eat_keyword(keywords::If) ){\n@@ -3465,7 +3465,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let attrs = self.parse_outer_attributes();\n+        let attrs = try!(self.parse_outer_attributes());\n         let lo = self.span.lo;\n \n         Ok(Some(if self.check_keyword(keywords::Let) {\n@@ -3607,7 +3607,7 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n         try!(self.expect(&token::OpenDelim(token::Brace)));\n-        Ok((self.parse_inner_attributes(),\n+        Ok((try!(self.parse_inner_attributes()),\n          try!(self.parse_block_tail(lo, DefaultBlock))))\n     }\n \n@@ -4431,7 +4431,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_impl_item(&mut self) -> PResult<P<ImplItem>> {\n         maybe_whole!(no_clone self, NtImplItem);\n \n-        let mut attrs = self.parse_outer_attributes();\n+        let mut attrs = try!(self.parse_outer_attributes());\n         let lo = self.span.lo;\n         let vis = try!(self.parse_visibility());\n         let (name, node) = if try!(self.eat_keyword(keywords::Type)) {\n@@ -4608,7 +4608,7 @@ impl<'a> Parser<'a> {\n             generics.where_clause = try!(self.parse_where_clause());\n \n             try!(self.expect(&token::OpenDelim(token::Brace)));\n-            let attrs = self.parse_inner_attributes();\n+            let attrs = try!(self.parse_inner_attributes());\n \n             let mut impl_items = vec![];\n             while !try!(self.eat(&token::CloseDelim(token::Brace))) {\n@@ -4727,7 +4727,7 @@ impl<'a> Parser<'a> {\n             &token::CloseDelim(token::Paren),\n             seq_sep_trailing_allowed(token::Comma),\n             |p| {\n-                let attrs = p.parse_outer_attributes();\n+                let attrs = try!(p.parse_outer_attributes());\n                 let lo = p.span.lo;\n                 let struct_field_ = ast::StructField_ {\n                     kind: UnnamedField(try!(p.parse_visibility())),\n@@ -4769,7 +4769,7 @@ impl<'a> Parser<'a> {\n     /// Parse an element of a struct definition\n     fn parse_struct_decl_field(&mut self, allow_pub: bool) -> PResult<StructField> {\n \n-        let attrs = self.parse_outer_attributes();\n+        let attrs = try!(self.parse_outer_attributes());\n \n         if try!(self.eat_keyword(keywords::Pub) ){\n             if !allow_pub {\n@@ -4841,7 +4841,7 @@ impl<'a> Parser<'a> {\n             let mod_inner_lo = self.span.lo;\n             let old_owns_directory = self.owns_directory;\n             self.owns_directory = true;\n-            let attrs = self.parse_inner_attributes();\n+            let attrs = try!(self.parse_inner_attributes());\n             let m = try!(self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo));\n             self.owns_directory = old_owns_directory;\n             self.pop_mod_path();\n@@ -4990,7 +4990,7 @@ impl<'a> Parser<'a> {\n                                               Some(name),\n                                               id_sp);\n         let mod_inner_lo = p0.span.lo;\n-        let mod_attrs = p0.parse_inner_attributes();\n+        let mod_attrs = try!(p0.parse_inner_attributes());\n         let m0 = try!(p0.parse_mod_items(&token::Eof, mod_inner_lo));\n         self.sess.included_mod_stack.borrow_mut().pop();\n         Ok((ast::ItemMod(m0), mod_attrs))\n@@ -5093,7 +5093,7 @@ impl<'a> Parser<'a> {\n \n         let abi = opt_abi.unwrap_or(abi::C);\n \n-        attrs.extend(self.parse_inner_attributes());\n+        attrs.extend(try!(self.parse_inner_attributes()));\n \n         let mut foreign_items = vec![];\n         while let Some(item) = try!(self.parse_foreign_item()) {\n@@ -5143,7 +5143,7 @@ impl<'a> Parser<'a> {\n         let mut all_nullary = true;\n         let mut any_disr = None;\n         while self.token != token::CloseDelim(token::Brace) {\n-            let variant_attrs = self.parse_outer_attributes();\n+            let variant_attrs = try!(self.parse_outer_attributes());\n             let vlo = self.span.lo;\n \n             let struct_def;\n@@ -5505,7 +5505,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a foreign item.\n     fn parse_foreign_item(&mut self) -> PResult<Option<P<ForeignItem>>> {\n-        let attrs = self.parse_outer_attributes();\n+        let attrs = try!(self.parse_outer_attributes());\n         let lo = self.span.lo;\n         let visibility = try!(self.parse_visibility());\n \n@@ -5605,7 +5605,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_item_nopanic(&mut self) -> PResult<Option<P<Item>>> {\n-        let attrs = self.parse_outer_attributes();\n+        let attrs = try!(self.parse_outer_attributes());\n         self.parse_item_(attrs, true)\n     }\n \n@@ -5724,7 +5724,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_crate_mod(&mut self) -> PResult<Crate> {\n         let lo = self.span.lo;\n         Ok(ast::Crate {\n-            attrs: self.parse_inner_attributes(),\n+            attrs: try!(self.parse_inner_attributes()),\n             module: try!(self.parse_mod_items(&token::Eof, lo)),\n             config: self.cfg.clone(),\n             span: mk_sp(lo, self.span.lo),"}]}