{"sha": "b8c446eab808a16ea6e878171762d5a1a58ac927", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YzQ0NmVhYjgwOGExNmVhNmU4NzgxNzE3NjJkNWExYTU4YWM5Mjc=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-04-18T03:21:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-18T03:21:17Z"}, "message": "Rollup merge of #41262 - jonhoo:compiler-barrier-rename, r=alexcrichton\n\nRename compiler_barrier to compiler_fence\n\nThis addresses concerns raised following the merge of #41092. Specifically:\n\n> The naming of these seems surprising: the multithreaded functions (and both the single and multithreaded intrinsics themselves) are fences, but this is a barrier. It's not incorrect, but the latter is both inconsistent with the existing functions and slightly confusing with another type in std (e.g., `Barrier`).\n\n`compiler_fence` carries the same semantic implication that this is a compiler-only operation, while being more in line with the fence/barrier concepts already in use in `std`.", "tree": {"sha": "0d81675631071a739589e5c435881e76aec64ef8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d81675631071a739589e5c435881e76aec64ef8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8c446eab808a16ea6e878171762d5a1a58ac927", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c446eab808a16ea6e878171762d5a1a58ac927", "html_url": "https://github.com/rust-lang/rust/commit/b8c446eab808a16ea6e878171762d5a1a58ac927", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8c446eab808a16ea6e878171762d5a1a58ac927/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "235fe8313fd0ffec665f1400da781ab2cb1e13f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/235fe8313fd0ffec665f1400da781ab2cb1e13f9", "html_url": "https://github.com/rust-lang/rust/commit/235fe8313fd0ffec665f1400da781ab2cb1e13f9"}, {"sha": "368d56010ae91a8b136c9eea5821ff3e5a7b79d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/368d56010ae91a8b136c9eea5821ff3e5a7b79d3", "html_url": "https://github.com/rust-lang/rust/commit/368d56010ae91a8b136c9eea5821ff3e5a7b79d3"}], "stats": {"total": 34, "additions": 17, "deletions": 17}, "files": [{"sha": "4232b146fb5ac8bdbec55bf128c57c8ebca4caff", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8c446eab808a16ea6e878171762d5a1a58ac927/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/b8c446eab808a16ea6e878171762d5a1a58ac927/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=b8c446eab808a16ea6e878171762d5a1a58ac927", "patch": "@@ -38,7 +38,7 @@\n - [collections](collections.md)\n - [collections_range](collections-range.md)\n - [command_envs](command-envs.md)\n-- [compiler_barriers](compiler-barriers.md)\n+- [compiler_fences](compiler-fences.md)\n - [compiler_builtins](compiler-builtins.md)\n - [compiler_builtins_lib](compiler-builtins-lib.md)\n - [concat_idents](concat-idents.md)"}, {"sha": "b1e36ab13d5aee82fe881e4833bd2e779a564a27", "filename": "src/doc/unstable-book/src/compiler-fences.md", "status": "renamed", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b8c446eab808a16ea6e878171762d5a1a58ac927/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-fences.md", "raw_url": "https://github.com/rust-lang/rust/raw/b8c446eab808a16ea6e878171762d5a1a58ac927/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-fences.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-fences.md?ref=b8c446eab808a16ea6e878171762d5a1a58ac927", "patch": "@@ -1,12 +1,12 @@\n-# `compiler_barriers`\n+# `compiler_fences`\n \n The tracking issue for this feature is: [#41091]\n \n [#41091]: https://github.com/rust-lang/rust/issues/41091\n \n ------------------------\n \n-The `compiler_barriers` feature exposes the `compiler_barrier` function\n+The `compiler_fences` feature exposes the `compiler_fence` function\n in `std::sync::atomic`. This function is conceptually similar to C++'s\n `atomic_signal_fence`, which can currently only be accessed in nightly\n Rust using the `atomic_singlethreadfence_*` instrinsic functions in\n@@ -17,18 +17,18 @@ Rust using the `atomic_singlethreadfence_*` instrinsic functions in\n unsafe { asm!(\"\" ::: \"memory\" : \"volatile\") };\n ```\n \n-A `compiler_barrier` restricts the kinds of memory re-ordering the\n+A `compiler_fence` restricts the kinds of memory re-ordering the\n compiler is allowed to do. Specifically, depending on the given ordering\n semantics, the compiler may be disallowed from moving reads or writes\n from before or after the call to the other side of the call to\n-`compiler_barrier`. Note that it does **not** prevent the *hardware*\n+`compiler_fence`. Note that it does **not** prevent the *hardware*\n from doing such re-ordering. This is not a problem in a single-threaded,\n execution context, but when other threads may modify memory at the same\n time, stronger synchronization primitives are required.\n \n ## Examples\n \n-`compiler_barrier` is generally only useful for preventing a thread from\n+`compiler_fence` is generally only useful for preventing a thread from\n racing *with itself*. That is, if a given thread is executing one piece\n of code, and is then interrupted, and starts executing code elsewhere\n (while still in the same thread, and conceptually still on the same\n@@ -37,7 +37,7 @@ handler is registered. In more low-level code, such situations can also\n arise when handling interrupts, when implementing green threads with\n pre-emption, etc.\n \n-To give a straightforward example of when a `compiler_barrier` is\n+To give a straightforward example of when a `compiler_fence` is\n necessary, consider the following example:\n \n ```rust\n@@ -67,22 +67,22 @@ remember that the compiler is free to swap the stores to\n after `IS_READY` is updated, then the signal handler will see\n `IS_READY=1`, but `IMPORTANT_VARIABLE=0`.\n \n-Using a `compiler_barrier`, we can remedy this situation:\n+Using a `compiler_fence`, we can remedy this situation:\n \n ```rust\n-#![feature(compiler_barriers)]\n+#![feature(compiler_fences)]\n # use std::sync::atomic::{AtomicBool, AtomicUsize};\n # use std::sync::atomic::{ATOMIC_BOOL_INIT, ATOMIC_USIZE_INIT};\n # use std::sync::atomic::Ordering;\n-use std::sync::atomic::compiler_barrier;\n+use std::sync::atomic::compiler_fence;\n \n static IMPORTANT_VARIABLE: AtomicUsize = ATOMIC_USIZE_INIT;\n static IS_READY: AtomicBool = ATOMIC_BOOL_INIT;\n \n fn main() {\n     IMPORTANT_VARIABLE.store(42, Ordering::Relaxed);\n     // prevent earlier writes from being moved beyond this point\n-    compiler_barrier(Ordering::Release);\n+    compiler_fence(Ordering::Release);\n     IS_READY.store(true, Ordering::Relaxed);\n }\n ", "previous_filename": "src/doc/unstable-book/src/compiler-barriers.md"}, {"sha": "fad58deecd4c0f26953e992f3c2b5e6975b67a10", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b8c446eab808a16ea6e878171762d5a1a58ac927/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c446eab808a16ea6e878171762d5a1a58ac927/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=b8c446eab808a16ea6e878171762d5a1a58ac927", "patch": "@@ -1591,11 +1591,11 @@ pub fn fence(order: Ordering) {\n }\n \n \n-/// A compiler memory barrier.\n+/// A compiler memory fence.\n ///\n-/// `compiler_barrier` does not emit any machine code, but prevents the compiler from re-ordering\n+/// `compiler_fence` does not emit any machine code, but prevents the compiler from re-ordering\n /// memory operations across this point. Which reorderings are disallowed is dictated by the given\n-/// [`Ordering`]. Note that `compiler_barrier` does *not* introduce inter-thread memory\n+/// [`Ordering`]. Note that `compiler_fence` does *not* introduce inter-thread memory\n /// synchronization; for that, a [`fence`] is needed.\n ///\n /// The re-ordering prevented by the different ordering semantics are:\n@@ -1617,15 +1617,15 @@ pub fn fence(order: Ordering) {\n /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n #[inline]\n-#[unstable(feature = \"compiler_barriers\", issue = \"41091\")]\n-pub fn compiler_barrier(order: Ordering) {\n+#[unstable(feature = \"compiler_fences\", issue = \"41091\")]\n+pub fn compiler_fence(order: Ordering) {\n     unsafe {\n         match order {\n             Acquire => intrinsics::atomic_singlethreadfence_acq(),\n             Release => intrinsics::atomic_singlethreadfence_rel(),\n             AcqRel => intrinsics::atomic_singlethreadfence_acqrel(),\n             SeqCst => intrinsics::atomic_singlethreadfence(),\n-            Relaxed => panic!(\"there is no such thing as a relaxed barrier\"),\n+            Relaxed => panic!(\"there is no such thing as a relaxed compiler fence\"),\n             __Nonexhaustive => panic!(\"invalid memory ordering\"),\n         }\n     }"}]}