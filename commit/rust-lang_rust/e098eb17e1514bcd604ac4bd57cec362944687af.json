{"sha": "e098eb17e1514bcd604ac4bd57cec362944687af", "node_id": "C_kwDOAAsO6NoAKGUwOThlYjE3ZTE1MTRiY2Q2MDRhYzRiZDU3Y2VjMzYyOTQ0Njg3YWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-21T04:19:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-21T04:19:03Z"}, "message": "Auto merge of #107143 - compiler-errors:rollup-zabvmo5, r=compiler-errors\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #104154 (Change `bindings_with_variant_name` to deny-by-default)\n - #104347 (diagnostics: suggest changing `s@self::{macro}`@::macro`` for exported)\n - #104672 (Unify stable and unstable sort implementations in same core module)\n - #107048 (check for x version updates)\n - #107061 (Implement some more new solver candidates and fix some bugs)\n - #107095 (rustdoc: remove redundant CSS selector `.sidebar .current`)\n - #107112 (Fix typo in opaque_types.rs)\n - #107124 (fix check macro expansion)\n - #107131 (rustdoc: use CSS inline layout for radio line instead of flexbox)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "5ed9ca15b097af81778b76c4e6167b633ead064d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ed9ca15b097af81778b76c4e6167b633ead064d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e098eb17e1514bcd604ac4bd57cec362944687af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e098eb17e1514bcd604ac4bd57cec362944687af", "html_url": "https://github.com/rust-lang/rust/commit/e098eb17e1514bcd604ac4bd57cec362944687af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e098eb17e1514bcd604ac4bd57cec362944687af/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0726909f6d219951ba15ac2f65656eff96bb1867", "url": "https://api.github.com/repos/rust-lang/rust/commits/0726909f6d219951ba15ac2f65656eff96bb1867", "html_url": "https://github.com/rust-lang/rust/commit/0726909f6d219951ba15ac2f65656eff96bb1867"}, {"sha": "34d4df5bd5e6efccbcf7b191ac5c7ed2e8ae67cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d4df5bd5e6efccbcf7b191ac5c7ed2e8ae67cd", "html_url": "https://github.com/rust-lang/rust/commit/34d4df5bd5e6efccbcf7b191ac5c7ed2e8ae67cd"}], "stats": {"total": 1496, "additions": 1086, "deletions": 410}, "files": [{"sha": "640d4d2ec26921936a761db093bb076249967c95", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -5608,6 +5608,7 @@ dependencies = [\n  \"lazy_static\",\n  \"miropt-test-tools\",\n  \"regex\",\n+ \"semver\",\n  \"termcolor\",\n  \"walkdir\",\n ]"}, {"sha": "68cdc6d7711d4eb840bb49ea3faef8a6c0f121f5", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -207,7 +207,12 @@ impl<I: Idx, T> IndexVec<I, T> {\n         &'a mut self,\n         range: R,\n     ) -> impl Iterator<Item = (I, T)> + 'a {\n-        self.raw.drain(range).enumerate().map(|(n, t)| (I::new(n), t))\n+        let begin = match range.start_bound() {\n+            std::ops::Bound::Included(i) => *i,\n+            std::ops::Bound::Excluded(i) => i.checked_add(1).unwrap(),\n+            std::ops::Bound::Unbounded => 0,\n+        };\n+        self.raw.drain(range).enumerate().map(move |(n, t)| (I::new(begin + n), t))\n     }\n \n     #[inline]"}, {"sha": "c54c66eab27998cdf0616e36d25404fdc417a143", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -479,7 +479,7 @@ where\n             }\n \n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, ref substs, .. }) => {\n-                // Skip lifetime paramters that are not captures.\n+                // Skip lifetime parameters that are not captures.\n                 let variances = self.tcx.variances_of(*def_id);\n \n                 for (v, s) in std::iter::zip(variances, substs.iter()) {\n@@ -492,7 +492,7 @@ where\n             ty::Alias(ty::Projection, proj)\n                 if self.tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder =>\n             {\n-                // Skip lifetime paramters that are not captures.\n+                // Skip lifetime parameters that are not captures.\n                 let variances = self.tcx.variances_of(proj.def_id);\n \n                 for (v, s) in std::iter::zip(variances, proj.substs.iter()) {"}, {"sha": "1ac97849ec6111661884323e84cc8dda5c0e1a9e", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -708,7 +708,7 @@ declare_lint! {\n     ///\n     /// ### Example\n     ///\n-    /// ```rust\n+    /// ```rust,compile_fail\n     /// pub enum Enum {\n     ///     Foo,\n     ///     Bar,\n@@ -743,7 +743,7 @@ declare_lint! {\n     /// [identifier pattern]: https://doc.rust-lang.org/reference/patterns.html#identifier-patterns\n     /// [path pattern]: https://doc.rust-lang.org/reference/patterns.html#path-patterns\n     pub BINDINGS_WITH_VARIANT_NAME,\n-    Warn,\n+    Deny,\n     \"detects pattern bindings with the same name as one of the matched variants\"\n }\n "}, {"sha": "8d104aa5cc592ccb4876108e706c3b6e9b27246a", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -2125,9 +2125,15 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n                 let source_map = self.r.session.source_map();\n \n+                // Make sure this is actually crate-relative.\n+                let is_definitely_crate = import\n+                    .module_path\n+                    .first()\n+                    .map_or(false, |f| f.ident.name != kw::SelfLower && f.ident.name != kw::Super);\n+\n                 // Add the import to the start, with a `{` if required.\n                 let start_point = source_map.start_point(after_crate_name);\n-                if let Ok(start_snippet) = source_map.span_to_snippet(start_point) {\n+                if is_definitely_crate && let Ok(start_snippet) = source_map.span_to_snippet(start_point) {\n                     corrections.push((\n                         start_point,\n                         if has_nested {\n@@ -2139,11 +2145,17 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                             format!(\"{{{}, {}\", import_snippet, start_snippet)\n                         },\n                     ));\n-                }\n \n-                // Add a `};` to the end if nested, matching the `{` added at the start.\n-                if !has_nested {\n-                    corrections.push((source_map.end_point(after_crate_name), \"};\".to_string()));\n+                    // Add a `};` to the end if nested, matching the `{` added at the start.\n+                    if !has_nested {\n+                        corrections.push((source_map.end_point(after_crate_name), \"};\".to_string()));\n+                    }\n+                } else {\n+                    // If the root import is module-relative, add the import separately\n+                    corrections.push((\n+                        import.use_span.shrink_to_lo(),\n+                        format!(\"use {module_name}::{import_snippet};\\n\"),\n+                    ));\n                 }\n             }\n "}, {"sha": "31c1bc9ecc062c7870242474521939b59e2279ee", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -1,7 +1,7 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n use super::infcx_ext::InferCtxtExt;\n-use super::{CanonicalResponse, EvalCtxt, Goal, QueryResult};\n+use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate_predicates;\n@@ -79,7 +79,7 @@ pub(super) enum CandidateSource {\n     AliasBound(usize),\n }\n \n-pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n+pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n     fn self_ty(self) -> Ty<'tcx>;\n \n     fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self;\n@@ -117,13 +117,43 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_pointer_sized_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_fn_trait_candidates(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        kind: ty::ClosureKind,\n+    ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_tuple_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn assemble_and_evaluate_candidates<G: GoalKind<'tcx>>(\n         &mut self,\n         goal: Goal<'tcx, G>,\n     ) -> Vec<Candidate<'tcx>> {\n+        debug_assert_eq!(goal, self.infcx.resolve_vars_if_possible(goal));\n+\n+        // HACK: `_: Trait` is ambiguous, because it may be satisfied via a builtin rule,\n+        // object bound, alias bound, etc. We are unable to determine this until we can at\n+        // least structually resolve the type one layer.\n+        if goal.predicate.self_ty().is_ty_var() {\n+            return vec![Candidate {\n+                source: CandidateSource::BuiltinImpl,\n+                result: self\n+                    .make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity))\n+                    .unwrap(),\n+            }];\n+        }\n+\n         let mut candidates = Vec::new();\n \n         self.assemble_candidates_after_normalizing_self_ty(goal, &mut candidates);\n@@ -169,6 +199,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 Ok((_, certainty)) => certainty,\n                 Err(NoSolution) => return,\n             };\n+            let normalized_ty = self.infcx.resolve_vars_if_possible(normalized_ty);\n \n             // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n             // This doesn't work as long as we use `CandidateSource` in winnowing.\n@@ -224,6 +255,12 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             || lang_items.clone_trait() == Some(trait_def_id)\n         {\n             G::consider_builtin_copy_clone_candidate(self, goal)\n+        } else if lang_items.pointer_sized() == Some(trait_def_id) {\n+            G::consider_builtin_pointer_sized_candidate(self, goal)\n+        } else if let Some(kind) = self.tcx().fn_trait_kind_from_def_id(trait_def_id) {\n+            G::consider_builtin_fn_trait_candidates(self, goal, kind)\n+        } else if lang_items.tuple_trait() == Some(trait_def_id) {\n+            G::consider_builtin_tuple_candidate(self, goal)\n         } else {\n             Err(NoSolution)\n         };"}, {"sha": "a6240666ed43a86add4c87951342777d75e2ab55", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -52,7 +52,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n             .drain(..)\n             .map(|obligation| FulfillmentError {\n                 obligation: obligation.clone(),\n-                code: FulfillmentErrorCode::CodeSelectionError(SelectionError::Unimplemented),\n+                code: FulfillmentErrorCode::CodeAmbiguity,\n                 root_obligation: obligation,\n             })\n             .collect()\n@@ -75,7 +75,9 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                     Err(NoSolution) => {\n                         errors.push(FulfillmentError {\n                             obligation: obligation.clone(),\n-                            code: FulfillmentErrorCode::CodeAmbiguity,\n+                            code: FulfillmentErrorCode::CodeSelectionError(\n+                                SelectionError::Unimplemented,\n+                            ),\n                             root_obligation: obligation,\n                         });\n                         continue;"}, {"sha": "e39fa05339286ab86d9d18e512eec92ae0448c3c", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -2,6 +2,7 @@ use crate::traits::{specialization_graph, translate_substs};\n \n use super::assembly::{self, Candidate, CandidateSource};\n use super::infcx_ext::InferCtxtExt;\n+use super::trait_goals::structural_traits;\n use super::{Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n@@ -11,9 +12,9 @@ use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n use rustc_infer::traits::Reveal;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n-use rustc_middle::ty::TypeVisitable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{ProjectionPredicate, TypeSuperVisitable, TypeVisitor};\n+use rustc_middle::ty::{ToPredicate, TypeVisitable};\n use rustc_span::DUMMY_SP;\n use std::iter;\n use std::ops::ControlFlow;\n@@ -351,6 +352,46 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     ) -> QueryResult<'tcx> {\n         bug!(\"`Copy`/`Clone` does not have an associated type: {:?}\", goal);\n     }\n+\n+    fn consider_builtin_pointer_sized_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`PointerSized` does not have an associated type: {:?}\", goal);\n+    }\n+\n+    fn consider_builtin_fn_trait_candidates(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        goal_kind: ty::ClosureKind,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(tupled_inputs_and_output) =\n+            structural_traits::extract_tupled_inputs_and_output_from_callable(\n+                ecx.tcx(),\n+                goal.predicate.self_ty(),\n+                goal_kind,\n+            )?\n+        {\n+            let pred = tupled_inputs_and_output\n+                .map_bound(|(inputs, output)| ty::ProjectionPredicate {\n+                    projection_ty: ecx\n+                        .tcx()\n+                        .mk_alias_ty(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs]),\n+                    term: output.into(),\n+                })\n+                .to_predicate(ecx.tcx());\n+            Self::consider_assumption(ecx, goal, pred)\n+        } else {\n+            ecx.make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity))\n+        }\n+    }\n+\n+    fn consider_builtin_tuple_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`Tuple` does not have an associated type: {:?}\", goal);\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code."}, {"sha": "9985d7181bb7dd000edebae5c2a0f695309e3b9d", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -4,16 +4,16 @@ use std::iter;\n \n use super::assembly::{self, Candidate, CandidateSource};\n use super::infcx_ext::InferCtxtExt;\n-use super::{EvalCtxt, Goal, QueryResult};\n+use super::{Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n-use rustc_middle::ty::TraitPredicate;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{TraitPredicate, TypeVisitable};\n use rustc_span::DUMMY_SP;\n \n-mod structural_traits;\n+pub mod structural_traits;\n \n impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     fn self_ty(self) -> Ty<'tcx> {\n@@ -127,6 +127,64 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             structural_traits::instantiate_constituent_tys_for_copy_clone_trait,\n         )\n     }\n+\n+    fn consider_builtin_pointer_sized_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        if goal.predicate.self_ty().has_non_region_infer() {\n+            return ecx.make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity));\n+        }\n+\n+        let tcx = ecx.tcx();\n+        let self_ty = tcx.erase_regions(goal.predicate.self_ty());\n+\n+        if let Ok(layout) = tcx.layout_of(goal.param_env.and(self_ty))\n+            &&  let usize_layout = tcx.layout_of(ty::ParamEnv::empty().and(tcx.types.usize)).unwrap().layout\n+            && layout.layout.size() == usize_layout.size()\n+            && layout.layout.align().abi == usize_layout.align().abi\n+        {\n+            // FIXME: We could make this faster by making a no-constraints response\n+            ecx.make_canonical_response(Certainty::Yes)\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n+    fn consider_builtin_fn_trait_candidates(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        goal_kind: ty::ClosureKind,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(tupled_inputs_and_output) =\n+            structural_traits::extract_tupled_inputs_and_output_from_callable(\n+                ecx.tcx(),\n+                goal.predicate.self_ty(),\n+                goal_kind,\n+            )?\n+        {\n+            let pred = tupled_inputs_and_output\n+                .map_bound(|(inputs, _)| {\n+                    ecx.tcx()\n+                        .mk_trait_ref(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs])\n+                })\n+                .to_predicate(ecx.tcx());\n+            Self::consider_assumption(ecx, goal, pred)\n+        } else {\n+            ecx.make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity))\n+        }\n+    }\n+\n+    fn consider_builtin_tuple_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        if let ty::Tuple(..) = goal.predicate.self_ty().kind() {\n+            ecx.make_canonical_response(Certainty::Yes)\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {"}, {"sha": "a11cd13cb0856b4df3ace3c1261baf9a69d9d4dc", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 55, "deletions": 11, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -1,6 +1,6 @@\n use rustc_hir::{Movability, Mutability};\n use rustc_infer::{infer::InferCtxt, traits::query::NoSolution};\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n \n // Calculates the constituent types of a type for `auto trait` purposes.\n //\n@@ -30,10 +30,7 @@ pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n         | ty::Foreign(..)\n         | ty::Alias(ty::Projection, ..)\n         | ty::Bound(..)\n-        | ty::Infer(ty::TyVar(_)) => {\n-            // FIXME: Do we need to mark anything as ambiguous here? Yeah?\n-            Err(NoSolution)\n-        }\n+        | ty::Infer(ty::TyVar(_)) => Err(NoSolution),\n \n         ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n \n@@ -101,9 +98,8 @@ pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n         | ty::Dynamic(..)\n         | ty::Foreign(..)\n         | ty::Alias(..)\n-        | ty::Param(_) => Err(NoSolution),\n-\n-        ty::Infer(ty::TyVar(_)) => bug!(\"FIXME: ambiguous\"),\n+        | ty::Param(_)\n+        | ty::Infer(ty::TyVar(_)) => Err(NoSolution),\n \n         ty::Placeholder(..)\n         | ty::Bound(..)\n@@ -151,9 +147,8 @@ pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n         | ty::Ref(_, _, Mutability::Mut)\n         | ty::Adt(_, _)\n         | ty::Alias(_, _)\n-        | ty::Param(_) => Err(NoSolution),\n-\n-        ty::Infer(ty::TyVar(_)) => bug!(\"FIXME: ambiguous\"),\n+        | ty::Param(_)\n+        | ty::Infer(ty::TyVar(_)) => Err(NoSolution),\n \n         ty::Placeholder(..)\n         | ty::Bound(..)\n@@ -177,3 +172,52 @@ pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n         }\n     }\n }\n+\n+pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    self_ty: Ty<'tcx>,\n+    goal_kind: ty::ClosureKind,\n+) -> Result<Option<ty::Binder<'tcx, (Ty<'tcx>, Ty<'tcx>)>>, NoSolution> {\n+    match *self_ty.kind() {\n+        ty::FnDef(def_id, substs) => Ok(Some(\n+            tcx.bound_fn_sig(def_id)\n+                .subst(tcx, substs)\n+                .map_bound(|sig| (tcx.mk_tup(sig.inputs().iter()), sig.output())),\n+        )),\n+        ty::FnPtr(sig) => {\n+            Ok(Some(sig.map_bound(|sig| (tcx.mk_tup(sig.inputs().iter()), sig.output()))))\n+        }\n+        ty::Closure(_, substs) => {\n+            let closure_substs = substs.as_closure();\n+            match closure_substs.kind_ty().to_opt_closure_kind() {\n+                Some(closure_kind) if closure_kind.extends(goal_kind) => {}\n+                None => return Ok(None),\n+                _ => return Err(NoSolution),\n+            }\n+            Ok(Some(closure_substs.sig().map_bound(|sig| (sig.inputs()[0], sig.output()))))\n+        }\n+        ty::Bool\n+        | ty::Char\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Adt(_, _)\n+        | ty::Foreign(_)\n+        | ty::Str\n+        | ty::Array(_, _)\n+        | ty::Slice(_)\n+        | ty::RawPtr(_)\n+        | ty::Ref(_, _, _)\n+        | ty::Dynamic(_, _, _)\n+        | ty::Generator(_, _, _)\n+        | ty::GeneratorWitness(_)\n+        | ty::Never\n+        | ty::Tuple(_)\n+        | ty::Alias(_, _)\n+        | ty::Param(_)\n+        | ty::Placeholder(_)\n+        | ty::Bound(_, _)\n+        | ty::Infer(_)\n+        | ty::Error(_) => Err(NoSolution),\n+    }\n+}"}, {"sha": "fecacc2bb639508836b4090fa22280a368051a67", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 39, "deletions": 309, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -19,10 +19,12 @@ use core::cmp::Ordering::{self, Less};\n use core::mem::{self, SizedTypeProperties};\n #[cfg(not(no_global_oom_handling))]\n use core::ptr;\n+#[cfg(not(no_global_oom_handling))]\n+use core::slice::sort;\n \n use crate::alloc::Allocator;\n #[cfg(not(no_global_oom_handling))]\n-use crate::alloc::Global;\n+use crate::alloc::{self, Global};\n #[cfg(not(no_global_oom_handling))]\n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n@@ -206,7 +208,7 @@ impl<T> [T] {\n     where\n         T: Ord,\n     {\n-        merge_sort(self, T::lt);\n+        stable_sort(self, T::lt);\n     }\n \n     /// Sorts the slice with a comparator function.\n@@ -262,7 +264,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T, &T) -> Ordering,\n     {\n-        merge_sort(self, |a, b| compare(a, b) == Less);\n+        stable_sort(self, |a, b| compare(a, b) == Less);\n     }\n \n     /// Sorts the slice with a key extraction function.\n@@ -305,7 +307,7 @@ impl<T> [T] {\n         F: FnMut(&T) -> K,\n         K: Ord,\n     {\n-        merge_sort(self, |a, b| f(a).lt(&f(b)));\n+        stable_sort(self, |a, b| f(a).lt(&f(b)));\n     }\n \n     /// Sorts the slice with a key extraction function.\n@@ -812,324 +814,52 @@ impl<T: Clone> ToOwned for [T] {\n // Sorting\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// Inserts `v[0]` into pre-sorted sequence `v[1..]` so that whole `v[..]` becomes sorted.\n-///\n-/// This is the integral subroutine of insertion sort.\n-#[cfg(not(no_global_oom_handling))]\n-fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n-where\n-    F: FnMut(&T, &T) -> bool,\n-{\n-    if v.len() >= 2 && is_less(&v[1], &v[0]) {\n-        unsafe {\n-            // There are three ways to implement insertion here:\n-            //\n-            // 1. Swap adjacent elements until the first one gets to its final destination.\n-            //    However, this way we copy data around more than is necessary. If elements are big\n-            //    structures (costly to copy), this method will be slow.\n-            //\n-            // 2. Iterate until the right place for the first element is found. Then shift the\n-            //    elements succeeding it to make room for it and finally place it into the\n-            //    remaining hole. This is a good method.\n-            //\n-            // 3. Copy the first element into a temporary variable. Iterate until the right place\n-            //    for it is found. As we go along, copy every traversed element into the slot\n-            //    preceding it. Finally, copy data from the temporary variable into the remaining\n-            //    hole. This method is very good. Benchmarks demonstrated slightly better\n-            //    performance than with the 2nd method.\n-            //\n-            // All methods were benchmarked, and the 3rd showed best results. So we chose that one.\n-            let tmp = mem::ManuallyDrop::new(ptr::read(&v[0]));\n-\n-            // Intermediate state of the insertion process is always tracked by `hole`, which\n-            // serves two purposes:\n-            // 1. Protects integrity of `v` from panics in `is_less`.\n-            // 2. Fills the remaining hole in `v` in the end.\n-            //\n-            // Panic safety:\n-            //\n-            // If `is_less` panics at any point during the process, `hole` will get dropped and\n-            // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n-            // initially held exactly once.\n-            let mut hole = InsertionHole { src: &*tmp, dest: &mut v[1] };\n-            ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n-\n-            for i in 2..v.len() {\n-                if !is_less(&v[i], &*tmp) {\n-                    break;\n-                }\n-                ptr::copy_nonoverlapping(&v[i], &mut v[i - 1], 1);\n-                hole.dest = &mut v[i];\n-            }\n-            // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n-        }\n-    }\n-\n-    // When dropped, copies from `src` into `dest`.\n-    struct InsertionHole<T> {\n-        src: *const T,\n-        dest: *mut T,\n-    }\n-\n-    impl<T> Drop for InsertionHole<T> {\n-        fn drop(&mut self) {\n-            unsafe {\n-                ptr::copy_nonoverlapping(self.src, self.dest, 1);\n-            }\n-        }\n-    }\n-}\n-\n-/// Merges non-decreasing runs `v[..mid]` and `v[mid..]` using `buf` as temporary storage, and\n-/// stores the result into `v[..]`.\n-///\n-/// # Safety\n-///\n-/// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n-/// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\n-#[cfg(not(no_global_oom_handling))]\n-unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n-where\n-    F: FnMut(&T, &T) -> bool,\n-{\n-    let len = v.len();\n-    let v = v.as_mut_ptr();\n-    let (v_mid, v_end) = unsafe { (v.add(mid), v.add(len)) };\n-\n-    // The merge process first copies the shorter run into `buf`. Then it traces the newly copied\n-    // run and the longer run forwards (or backwards), comparing their next unconsumed elements and\n-    // copying the lesser (or greater) one into `v`.\n-    //\n-    // As soon as the shorter run is fully consumed, the process is done. If the longer run gets\n-    // consumed first, then we must copy whatever is left of the shorter run into the remaining\n-    // hole in `v`.\n-    //\n-    // Intermediate state of the process is always tracked by `hole`, which serves two purposes:\n-    // 1. Protects integrity of `v` from panics in `is_less`.\n-    // 2. Fills the remaining hole in `v` if the longer run gets consumed first.\n-    //\n-    // Panic safety:\n-    //\n-    // If `is_less` panics at any point during the process, `hole` will get dropped and fill the\n-    // hole in `v` with the unconsumed range in `buf`, thus ensuring that `v` still holds every\n-    // object it initially held exactly once.\n-    let mut hole;\n-\n-    if mid <= len - mid {\n-        // The left run is shorter.\n-        unsafe {\n-            ptr::copy_nonoverlapping(v, buf, mid);\n-            hole = MergeHole { start: buf, end: buf.add(mid), dest: v };\n-        }\n-\n-        // Initially, these pointers point to the beginnings of their arrays.\n-        let left = &mut hole.start;\n-        let mut right = v_mid;\n-        let out = &mut hole.dest;\n-\n-        while *left < hole.end && right < v_end {\n-            // Consume the lesser side.\n-            // If equal, prefer the left run to maintain stability.\n-            unsafe {\n-                let to_copy = if is_less(&*right, &**left) {\n-                    get_and_increment(&mut right)\n-                } else {\n-                    get_and_increment(left)\n-                };\n-                ptr::copy_nonoverlapping(to_copy, get_and_increment(out), 1);\n-            }\n-        }\n-    } else {\n-        // The right run is shorter.\n-        unsafe {\n-            ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n-            hole = MergeHole { start: buf, end: buf.add(len - mid), dest: v_mid };\n-        }\n-\n-        // Initially, these pointers point past the ends of their arrays.\n-        let left = &mut hole.dest;\n-        let right = &mut hole.end;\n-        let mut out = v_end;\n-\n-        while v < *left && buf < *right {\n-            // Consume the greater side.\n-            // If equal, prefer the right run to maintain stability.\n-            unsafe {\n-                let to_copy = if is_less(&*right.sub(1), &*left.sub(1)) {\n-                    decrement_and_get(left)\n-                } else {\n-                    decrement_and_get(right)\n-                };\n-                ptr::copy_nonoverlapping(to_copy, decrement_and_get(&mut out), 1);\n-            }\n-        }\n-    }\n-    // Finally, `hole` gets dropped. If the shorter run was not fully consumed, whatever remains of\n-    // it will now be copied into the hole in `v`.\n-\n-    unsafe fn get_and_increment<T>(ptr: &mut *mut T) -> *mut T {\n-        let old = *ptr;\n-        *ptr = unsafe { ptr.add(1) };\n-        old\n-    }\n-\n-    unsafe fn decrement_and_get<T>(ptr: &mut *mut T) -> *mut T {\n-        *ptr = unsafe { ptr.sub(1) };\n-        *ptr\n-    }\n-\n-    // When dropped, copies the range `start..end` into `dest..`.\n-    struct MergeHole<T> {\n-        start: *mut T,\n-        end: *mut T,\n-        dest: *mut T,\n-    }\n-\n-    impl<T> Drop for MergeHole<T> {\n-        fn drop(&mut self) {\n-            // `T` is not a zero-sized type, and these are pointers into a slice's elements.\n-            unsafe {\n-                let len = self.end.sub_ptr(self.start);\n-                ptr::copy_nonoverlapping(self.start, self.dest, len);\n-            }\n-        }\n-    }\n-}\n-\n-/// This merge sort borrows some (but not all) ideas from TimSort, which is described in detail\n-/// [here](https://github.com/python/cpython/blob/main/Objects/listsort.txt).\n-///\n-/// The algorithm identifies strictly descending and non-descending subsequences, which are called\n-/// natural runs. There is a stack of pending runs yet to be merged. Each newly found run is pushed\n-/// onto the stack, and then some pairs of adjacent runs are merged until these two invariants are\n-/// satisfied:\n-///\n-/// 1. for every `i` in `1..runs.len()`: `runs[i - 1].len > runs[i].len`\n-/// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n-///\n-/// The invariants ensure that the total running time is *O*(*n* \\* log(*n*)) worst-case.\n+#[inline]\n #[cfg(not(no_global_oom_handling))]\n-fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n+fn stable_sort<T, F>(v: &mut [T], mut is_less: F)\n where\n     F: FnMut(&T, &T) -> bool,\n {\n-    // Slices of up to this length get sorted using insertion sort.\n-    const MAX_INSERTION: usize = 20;\n-    // Very short runs are extended using insertion sort to span at least this many elements.\n-    const MIN_RUN: usize = 10;\n-\n-    // Sorting has no meaningful behavior on zero-sized types.\n     if T::IS_ZST {\n+        // Sorting has no meaningful behavior on zero-sized types. Do nothing.\n         return;\n     }\n \n-    let len = v.len();\n-\n-    // Short arrays get sorted in-place via insertion sort to avoid allocations.\n-    if len <= MAX_INSERTION {\n-        if len >= 2 {\n-            for i in (0..len - 1).rev() {\n-                insert_head(&mut v[i..], &mut is_less);\n-            }\n-        }\n-        return;\n-    }\n-\n-    // Allocate a buffer to use as scratch memory. We keep the length 0 so we can keep in it\n-    // shallow copies of the contents of `v` without risking the dtors running on copies if\n-    // `is_less` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n-    // which will always have length at most `len / 2`.\n-    let mut buf = Vec::with_capacity(len / 2);\n+    let elem_alloc_fn = |len: usize| -> *mut T {\n+        // SAFETY: Creating the layout is safe as long as merge_sort never calls this with len >\n+        // v.len(). Alloc in general will only be used as 'shadow-region' to store temporary swap\n+        // elements.\n+        unsafe { alloc::alloc(alloc::Layout::array::<T>(len).unwrap_unchecked()) as *mut T }\n+    };\n \n-    // In order to identify natural runs in `v`, we traverse it backwards. That might seem like a\n-    // strange decision, but consider the fact that merges more often go in the opposite direction\n-    // (forwards). According to benchmarks, merging forwards is slightly faster than merging\n-    // backwards. To conclude, identifying runs by traversing backwards improves performance.\n-    let mut runs = vec![];\n-    let mut end = len;\n-    while end > 0 {\n-        // Find the next natural run, and reverse it if it's strictly descending.\n-        let mut start = end - 1;\n-        if start > 0 {\n-            start -= 1;\n-            unsafe {\n-                if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {\n-                    while start > 0 && is_less(v.get_unchecked(start), v.get_unchecked(start - 1)) {\n-                        start -= 1;\n-                    }\n-                    v[start..end].reverse();\n-                } else {\n-                    while start > 0 && !is_less(v.get_unchecked(start), v.get_unchecked(start - 1))\n-                    {\n-                        start -= 1;\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Insert some more elements into the run if it's too short. Insertion sort is faster than\n-        // merge sort on short sequences, so this significantly improves performance.\n-        while start > 0 && end - start < MIN_RUN {\n-            start -= 1;\n-            insert_head(&mut v[start..end], &mut is_less);\n+    let elem_dealloc_fn = |buf_ptr: *mut T, len: usize| {\n+        // SAFETY: Creating the layout is safe as long as merge_sort never calls this with len >\n+        // v.len(). The caller must ensure that buf_ptr was created by elem_alloc_fn with the same\n+        // len.\n+        unsafe {\n+            alloc::dealloc(buf_ptr as *mut u8, alloc::Layout::array::<T>(len).unwrap_unchecked());\n         }\n+    };\n \n-        // Push this run onto the stack.\n-        runs.push(Run { start, len: end - start });\n-        end = start;\n-\n-        // Merge some pairs of adjacent runs to satisfy the invariants.\n-        while let Some(r) = collapse(&runs) {\n-            let left = runs[r + 1];\n-            let right = runs[r];\n-            unsafe {\n-                merge(\n-                    &mut v[left.start..right.start + right.len],\n-                    left.len,\n-                    buf.as_mut_ptr(),\n-                    &mut is_less,\n-                );\n-            }\n-            runs[r] = Run { start: left.start, len: left.len + right.len };\n-            runs.remove(r + 1);\n+    let run_alloc_fn = |len: usize| -> *mut sort::TimSortRun {\n+        // SAFETY: Creating the layout is safe as long as merge_sort never calls this with an\n+        // obscene length or 0.\n+        unsafe {\n+            alloc::alloc(alloc::Layout::array::<sort::TimSortRun>(len).unwrap_unchecked())\n+                as *mut sort::TimSortRun\n         }\n-    }\n-\n-    // Finally, exactly one run must remain in the stack.\n-    debug_assert!(runs.len() == 1 && runs[0].start == 0 && runs[0].len == len);\n+    };\n \n-    // Examines the stack of runs and identifies the next pair of runs to merge. More specifically,\n-    // if `Some(r)` is returned, that means `runs[r]` and `runs[r + 1]` must be merged next. If the\n-    // algorithm should continue building a new run instead, `None` is returned.\n-    //\n-    // TimSort is infamous for its buggy implementations, as described here:\n-    // http://envisage-project.eu/timsort-specification-and-verification/\n-    //\n-    // The gist of the story is: we must enforce the invariants on the top four runs on the stack.\n-    // Enforcing them on just top three is not sufficient to ensure that the invariants will still\n-    // hold for *all* runs in the stack.\n-    //\n-    // This function correctly checks invariants for the top four runs. Additionally, if the top\n-    // run starts at index 0, it will always demand a merge operation until the stack is fully\n-    // collapsed, in order to complete the sort.\n-    #[inline]\n-    fn collapse(runs: &[Run]) -> Option<usize> {\n-        let n = runs.len();\n-        if n >= 2\n-            && (runs[n - 1].start == 0\n-                || runs[n - 2].len <= runs[n - 1].len\n-                || (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len)\n-                || (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len))\n-        {\n-            if n >= 3 && runs[n - 3].len < runs[n - 1].len { Some(n - 3) } else { Some(n - 2) }\n-        } else {\n-            None\n+    let run_dealloc_fn = |buf_ptr: *mut sort::TimSortRun, len: usize| {\n+        // SAFETY: The caller must ensure that buf_ptr was created by elem_alloc_fn with the same\n+        // len.\n+        unsafe {\n+            alloc::dealloc(\n+                buf_ptr as *mut u8,\n+                alloc::Layout::array::<sort::TimSortRun>(len).unwrap_unchecked(),\n+            );\n         }\n-    }\n+    };\n \n-    #[derive(Clone, Copy)]\n-    struct Run {\n-        start: usize,\n-        len: usize,\n-    }\n+    sort::merge_sort(v, &mut is_less, elem_alloc_fn, elem_dealloc_fn, run_alloc_fn, run_dealloc_fn);\n }"}, {"sha": "d93a3a57ecd27fdcdb94a4aa479a5e8ceb02be3c", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -29,13 +29,19 @@ use crate::slice;\n /// Pure rust memchr implementation, taken from rust-memchr\n pub mod memchr;\n \n+#[unstable(\n+    feature = \"slice_internals\",\n+    issue = \"none\",\n+    reason = \"exposed from core to be reused in std;\"\n+)]\n+pub mod sort;\n+\n mod ascii;\n mod cmp;\n mod index;\n mod iter;\n mod raw;\n mod rotate;\n-mod sort;\n mod specialize;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "2181f9a811855f7ac2a39352b481f0f865e193d5", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 514, "deletions": 0, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -5,6 +5,9 @@\n //!\n //! Unstable sorting is compatible with core because it doesn't allocate memory, unlike our\n //! stable sorting implementation.\n+//!\n+//! In addition it also contains the core logic of the stable sort used by `slice::sort` based on\n+//! TimSort.\n \n use crate::cmp;\n use crate::mem::{self, MaybeUninit, SizedTypeProperties};\n@@ -905,6 +908,7 @@ fn partition_at_index_loop<'a, T, F>(\n     }\n }\n \n+/// Reorder the slice such that the element at `index` is at its final sorted position.\n pub fn partition_at_index<T, F>(\n     v: &mut [T],\n     index: usize,\n@@ -949,3 +953,513 @@ where\n     let pivot = &mut pivot[0];\n     (left, pivot, right)\n }\n+\n+/// Inserts `v[0]` into pre-sorted sequence `v[1..]` so that whole `v[..]` becomes sorted.\n+///\n+/// This is the integral subroutine of insertion sort.\n+fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n+where\n+    F: FnMut(&T, &T) -> bool,\n+{\n+    if v.len() >= 2 && is_less(&v[1], &v[0]) {\n+        // SAFETY: Copy tmp back even if panic, and ensure unique observation.\n+        unsafe {\n+            // There are three ways to implement insertion here:\n+            //\n+            // 1. Swap adjacent elements until the first one gets to its final destination.\n+            //    However, this way we copy data around more than is necessary. If elements are big\n+            //    structures (costly to copy), this method will be slow.\n+            //\n+            // 2. Iterate until the right place for the first element is found. Then shift the\n+            //    elements succeeding it to make room for it and finally place it into the\n+            //    remaining hole. This is a good method.\n+            //\n+            // 3. Copy the first element into a temporary variable. Iterate until the right place\n+            //    for it is found. As we go along, copy every traversed element into the slot\n+            //    preceding it. Finally, copy data from the temporary variable into the remaining\n+            //    hole. This method is very good. Benchmarks demonstrated slightly better\n+            //    performance than with the 2nd method.\n+            //\n+            // All methods were benchmarked, and the 3rd showed best results. So we chose that one.\n+            let tmp = mem::ManuallyDrop::new(ptr::read(&v[0]));\n+\n+            // Intermediate state of the insertion process is always tracked by `hole`, which\n+            // serves two purposes:\n+            // 1. Protects integrity of `v` from panics in `is_less`.\n+            // 2. Fills the remaining hole in `v` in the end.\n+            //\n+            // Panic safety:\n+            //\n+            // If `is_less` panics at any point during the process, `hole` will get dropped and\n+            // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n+            // initially held exactly once.\n+            let mut hole = InsertionHole { src: &*tmp, dest: &mut v[1] };\n+            ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n+\n+            for i in 2..v.len() {\n+                if !is_less(&v[i], &*tmp) {\n+                    break;\n+                }\n+                ptr::copy_nonoverlapping(&v[i], &mut v[i - 1], 1);\n+                hole.dest = &mut v[i];\n+            }\n+            // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n+        }\n+    }\n+\n+    // When dropped, copies from `src` into `dest`.\n+    struct InsertionHole<T> {\n+        src: *const T,\n+        dest: *mut T,\n+    }\n+\n+    impl<T> Drop for InsertionHole<T> {\n+        fn drop(&mut self) {\n+            // SAFETY: The caller must ensure that src and dest are correctly set.\n+            unsafe {\n+                ptr::copy_nonoverlapping(self.src, self.dest, 1);\n+            }\n+        }\n+    }\n+}\n+\n+/// Merges non-decreasing runs `v[..mid]` and `v[mid..]` using `buf` as temporary storage, and\n+/// stores the result into `v[..]`.\n+///\n+/// # Safety\n+///\n+/// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n+/// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\n+unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n+where\n+    F: FnMut(&T, &T) -> bool,\n+{\n+    let len = v.len();\n+    let v = v.as_mut_ptr();\n+\n+    // SAFETY: mid and len must be in-bounds of v.\n+    let (v_mid, v_end) = unsafe { (v.add(mid), v.add(len)) };\n+\n+    // The merge process first copies the shorter run into `buf`. Then it traces the newly copied\n+    // run and the longer run forwards (or backwards), comparing their next unconsumed elements and\n+    // copying the lesser (or greater) one into `v`.\n+    //\n+    // As soon as the shorter run is fully consumed, the process is done. If the longer run gets\n+    // consumed first, then we must copy whatever is left of the shorter run into the remaining\n+    // hole in `v`.\n+    //\n+    // Intermediate state of the process is always tracked by `hole`, which serves two purposes:\n+    // 1. Protects integrity of `v` from panics in `is_less`.\n+    // 2. Fills the remaining hole in `v` if the longer run gets consumed first.\n+    //\n+    // Panic safety:\n+    //\n+    // If `is_less` panics at any point during the process, `hole` will get dropped and fill the\n+    // hole in `v` with the unconsumed range in `buf`, thus ensuring that `v` still holds every\n+    // object it initially held exactly once.\n+    let mut hole;\n+\n+    if mid <= len - mid {\n+        // The left run is shorter.\n+\n+        // SAFETY: buf must have enough capacity for `v[..mid]`.\n+        unsafe {\n+            ptr::copy_nonoverlapping(v, buf, mid);\n+            hole = MergeHole { start: buf, end: buf.add(mid), dest: v };\n+        }\n+\n+        // Initially, these pointers point to the beginnings of their arrays.\n+        let left = &mut hole.start;\n+        let mut right = v_mid;\n+        let out = &mut hole.dest;\n+\n+        while *left < hole.end && right < v_end {\n+            // Consume the lesser side.\n+            // If equal, prefer the left run to maintain stability.\n+\n+            // SAFETY: left and right must be valid and part of v same for out.\n+            unsafe {\n+                let to_copy = if is_less(&*right, &**left) {\n+                    get_and_increment(&mut right)\n+                } else {\n+                    get_and_increment(left)\n+                };\n+                ptr::copy_nonoverlapping(to_copy, get_and_increment(out), 1);\n+            }\n+        }\n+    } else {\n+        // The right run is shorter.\n+\n+        // SAFETY: buf must have enough capacity for `v[mid..]`.\n+        unsafe {\n+            ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n+            hole = MergeHole { start: buf, end: buf.add(len - mid), dest: v_mid };\n+        }\n+\n+        // Initially, these pointers point past the ends of their arrays.\n+        let left = &mut hole.dest;\n+        let right = &mut hole.end;\n+        let mut out = v_end;\n+\n+        while v < *left && buf < *right {\n+            // Consume the greater side.\n+            // If equal, prefer the right run to maintain stability.\n+\n+            // SAFETY: left and right must be valid and part of v same for out.\n+            unsafe {\n+                let to_copy = if is_less(&*right.sub(1), &*left.sub(1)) {\n+                    decrement_and_get(left)\n+                } else {\n+                    decrement_and_get(right)\n+                };\n+                ptr::copy_nonoverlapping(to_copy, decrement_and_get(&mut out), 1);\n+            }\n+        }\n+    }\n+    // Finally, `hole` gets dropped. If the shorter run was not fully consumed, whatever remains of\n+    // it will now be copied into the hole in `v`.\n+\n+    unsafe fn get_and_increment<T>(ptr: &mut *mut T) -> *mut T {\n+        let old = *ptr;\n+\n+        // SAFETY: ptr.add(1) must still be a valid pointer and part of `v`.\n+        *ptr = unsafe { ptr.add(1) };\n+        old\n+    }\n+\n+    unsafe fn decrement_and_get<T>(ptr: &mut *mut T) -> *mut T {\n+        // SAFETY: ptr.sub(1) must still be a valid pointer and part of `v`.\n+        *ptr = unsafe { ptr.sub(1) };\n+        *ptr\n+    }\n+\n+    // When dropped, copies the range `start..end` into `dest..`.\n+    struct MergeHole<T> {\n+        start: *mut T,\n+        end: *mut T,\n+        dest: *mut T,\n+    }\n+\n+    impl<T> Drop for MergeHole<T> {\n+        fn drop(&mut self) {\n+            // SAFETY: `T` is not a zero-sized type, and these are pointers into a slice's elements.\n+            unsafe {\n+                let len = self.end.sub_ptr(self.start);\n+                ptr::copy_nonoverlapping(self.start, self.dest, len);\n+            }\n+        }\n+    }\n+}\n+\n+/// This merge sort borrows some (but not all) ideas from TimSort, which used to be described in\n+/// detail [here](https://github.com/python/cpython/blob/main/Objects/listsort.txt). However Python\n+/// has switched to a Powersort based implementation.\n+///\n+/// The algorithm identifies strictly descending and non-descending subsequences, which are called\n+/// natural runs. There is a stack of pending runs yet to be merged. Each newly found run is pushed\n+/// onto the stack, and then some pairs of adjacent runs are merged until these two invariants are\n+/// satisfied:\n+///\n+/// 1. for every `i` in `1..runs.len()`: `runs[i - 1].len > runs[i].len`\n+/// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n+///\n+/// The invariants ensure that the total running time is *O*(*n* \\* log(*n*)) worst-case.\n+pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n+    v: &mut [T],\n+    is_less: &mut CmpF,\n+    elem_alloc_fn: ElemAllocF,\n+    elem_dealloc_fn: ElemDeallocF,\n+    run_alloc_fn: RunAllocF,\n+    run_dealloc_fn: RunDeallocF,\n+) where\n+    CmpF: FnMut(&T, &T) -> bool,\n+    ElemAllocF: Fn(usize) -> *mut T,\n+    ElemDeallocF: Fn(*mut T, usize),\n+    RunAllocF: Fn(usize) -> *mut TimSortRun,\n+    RunDeallocF: Fn(*mut TimSortRun, usize),\n+{\n+    // Slices of up to this length get sorted using insertion sort.\n+    const MAX_INSERTION: usize = 20;\n+    // Very short runs are extended using insertion sort to span at least this many elements.\n+    const MIN_RUN: usize = 10;\n+\n+    // The caller should have already checked that.\n+    debug_assert!(!T::IS_ZST);\n+\n+    let len = v.len();\n+\n+    // Short arrays get sorted in-place via insertion sort to avoid allocations.\n+    if len <= MAX_INSERTION {\n+        if len >= 2 {\n+            for i in (0..len - 1).rev() {\n+                insert_head(&mut v[i..], is_less);\n+            }\n+        }\n+        return;\n+    }\n+\n+    // Allocate a buffer to use as scratch memory. We keep the length 0 so we can keep in it\n+    // shallow copies of the contents of `v` without risking the dtors running on copies if\n+    // `is_less` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n+    // which will always have length at most `len / 2`.\n+    let buf = BufGuard::new(len / 2, elem_alloc_fn, elem_dealloc_fn);\n+    let buf_ptr = buf.buf_ptr;\n+\n+    let mut runs = RunVec::new(run_alloc_fn, run_dealloc_fn);\n+\n+    // In order to identify natural runs in `v`, we traverse it backwards. That might seem like a\n+    // strange decision, but consider the fact that merges more often go in the opposite direction\n+    // (forwards). According to benchmarks, merging forwards is slightly faster than merging\n+    // backwards. To conclude, identifying runs by traversing backwards improves performance.\n+    let mut end = len;\n+    while end > 0 {\n+        // Find the next natural run, and reverse it if it's strictly descending.\n+        let mut start = end - 1;\n+        if start > 0 {\n+            start -= 1;\n+\n+            // SAFETY: The v.get_unchecked must be fed with correct inbound indicies.\n+            unsafe {\n+                if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {\n+                    while start > 0 && is_less(v.get_unchecked(start), v.get_unchecked(start - 1)) {\n+                        start -= 1;\n+                    }\n+                    v[start..end].reverse();\n+                } else {\n+                    while start > 0 && !is_less(v.get_unchecked(start), v.get_unchecked(start - 1))\n+                    {\n+                        start -= 1;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Insert some more elements into the run if it's too short. Insertion sort is faster than\n+        // merge sort on short sequences, so this significantly improves performance.\n+        while start > 0 && end - start < MIN_RUN {\n+            start -= 1;\n+            insert_head(&mut v[start..end], is_less);\n+        }\n+\n+        // Push this run onto the stack.\n+        runs.push(TimSortRun { start, len: end - start });\n+        end = start;\n+\n+        // Merge some pairs of adjacent runs to satisfy the invariants.\n+        while let Some(r) = collapse(runs.as_slice()) {\n+            let left = runs[r + 1];\n+            let right = runs[r];\n+            // SAFETY: `buf_ptr` must hold enough capacity for the shorter of the two sides, and\n+            // neither side may be on length 0.\n+            unsafe {\n+                merge(&mut v[left.start..right.start + right.len], left.len, buf_ptr, is_less);\n+            }\n+            runs[r] = TimSortRun { start: left.start, len: left.len + right.len };\n+            runs.remove(r + 1);\n+        }\n+    }\n+\n+    // Finally, exactly one run must remain in the stack.\n+    debug_assert!(runs.len() == 1 && runs[0].start == 0 && runs[0].len == len);\n+\n+    // Examines the stack of runs and identifies the next pair of runs to merge. More specifically,\n+    // if `Some(r)` is returned, that means `runs[r]` and `runs[r + 1]` must be merged next. If the\n+    // algorithm should continue building a new run instead, `None` is returned.\n+    //\n+    // TimSort is infamous for its buggy implementations, as described here:\n+    // http://envisage-project.eu/timsort-specification-and-verification/\n+    //\n+    // The gist of the story is: we must enforce the invariants on the top four runs on the stack.\n+    // Enforcing them on just top three is not sufficient to ensure that the invariants will still\n+    // hold for *all* runs in the stack.\n+    //\n+    // This function correctly checks invariants for the top four runs. Additionally, if the top\n+    // run starts at index 0, it will always demand a merge operation until the stack is fully\n+    // collapsed, in order to complete the sort.\n+    #[inline]\n+    fn collapse(runs: &[TimSortRun]) -> Option<usize> {\n+        let n = runs.len();\n+        if n >= 2\n+            && (runs[n - 1].start == 0\n+                || runs[n - 2].len <= runs[n - 1].len\n+                || (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len)\n+                || (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len))\n+        {\n+            if n >= 3 && runs[n - 3].len < runs[n - 1].len { Some(n - 3) } else { Some(n - 2) }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // Extremely basic versions of Vec.\n+    // Their use is super limited and by having the code here, it allows reuse between the sort\n+    // implementations.\n+    struct BufGuard<T, ElemDeallocF>\n+    where\n+        ElemDeallocF: Fn(*mut T, usize),\n+    {\n+        buf_ptr: *mut T,\n+        capacity: usize,\n+        elem_dealloc_fn: ElemDeallocF,\n+    }\n+\n+    impl<T, ElemDeallocF> BufGuard<T, ElemDeallocF>\n+    where\n+        ElemDeallocF: Fn(*mut T, usize),\n+    {\n+        fn new<ElemAllocF>(\n+            len: usize,\n+            elem_alloc_fn: ElemAllocF,\n+            elem_dealloc_fn: ElemDeallocF,\n+        ) -> Self\n+        where\n+            ElemAllocF: Fn(usize) -> *mut T,\n+        {\n+            Self { buf_ptr: elem_alloc_fn(len), capacity: len, elem_dealloc_fn }\n+        }\n+    }\n+\n+    impl<T, ElemDeallocF> Drop for BufGuard<T, ElemDeallocF>\n+    where\n+        ElemDeallocF: Fn(*mut T, usize),\n+    {\n+        fn drop(&mut self) {\n+            (self.elem_dealloc_fn)(self.buf_ptr, self.capacity);\n+        }\n+    }\n+\n+    struct RunVec<RunAllocF, RunDeallocF>\n+    where\n+        RunAllocF: Fn(usize) -> *mut TimSortRun,\n+        RunDeallocF: Fn(*mut TimSortRun, usize),\n+    {\n+        buf_ptr: *mut TimSortRun,\n+        capacity: usize,\n+        len: usize,\n+        run_alloc_fn: RunAllocF,\n+        run_dealloc_fn: RunDeallocF,\n+    }\n+\n+    impl<RunAllocF, RunDeallocF> RunVec<RunAllocF, RunDeallocF>\n+    where\n+        RunAllocF: Fn(usize) -> *mut TimSortRun,\n+        RunDeallocF: Fn(*mut TimSortRun, usize),\n+    {\n+        fn new(run_alloc_fn: RunAllocF, run_dealloc_fn: RunDeallocF) -> Self {\n+            // Most slices can be sorted with at most 16 runs in-flight.\n+            const START_RUN_CAPACITY: usize = 16;\n+\n+            Self {\n+                buf_ptr: run_alloc_fn(START_RUN_CAPACITY),\n+                capacity: START_RUN_CAPACITY,\n+                len: 0,\n+                run_alloc_fn,\n+                run_dealloc_fn,\n+            }\n+        }\n+\n+        fn push(&mut self, val: TimSortRun) {\n+            if self.len == self.capacity {\n+                let old_capacity = self.capacity;\n+                let old_buf_ptr = self.buf_ptr;\n+\n+                self.capacity = self.capacity * 2;\n+                self.buf_ptr = (self.run_alloc_fn)(self.capacity);\n+\n+                // SAFETY: buf_ptr new and old were correctly allocated and old_buf_ptr has\n+                // old_capacity valid elements.\n+                unsafe {\n+                    ptr::copy_nonoverlapping(old_buf_ptr, self.buf_ptr, old_capacity);\n+                }\n+\n+                (self.run_dealloc_fn)(old_buf_ptr, old_capacity);\n+            }\n+\n+            // SAFETY: The invariant was just checked.\n+            unsafe {\n+                self.buf_ptr.add(self.len).write(val);\n+            }\n+            self.len += 1;\n+        }\n+\n+        fn remove(&mut self, index: usize) {\n+            if index >= self.len {\n+                panic!(\"Index out of bounds\");\n+            }\n+\n+            // SAFETY: buf_ptr needs to be valid and len invariant upheld.\n+            unsafe {\n+                // the place we are taking from.\n+                let ptr = self.buf_ptr.add(index);\n+\n+                // Shift everything down to fill in that spot.\n+                ptr::copy(ptr.add(1), ptr, self.len - index - 1);\n+            }\n+            self.len -= 1;\n+        }\n+\n+        fn as_slice(&self) -> &[TimSortRun] {\n+            // SAFETY: Safe as long as buf_ptr is valid and len invariant was upheld.\n+            unsafe { &*ptr::slice_from_raw_parts(self.buf_ptr, self.len) }\n+        }\n+\n+        fn len(&self) -> usize {\n+            self.len\n+        }\n+    }\n+\n+    impl<RunAllocF, RunDeallocF> core::ops::Index<usize> for RunVec<RunAllocF, RunDeallocF>\n+    where\n+        RunAllocF: Fn(usize) -> *mut TimSortRun,\n+        RunDeallocF: Fn(*mut TimSortRun, usize),\n+    {\n+        type Output = TimSortRun;\n+\n+        fn index(&self, index: usize) -> &Self::Output {\n+            if index < self.len {\n+                // SAFETY: buf_ptr and len invariant must be upheld.\n+                unsafe {\n+                    return &*(self.buf_ptr.add(index));\n+                }\n+            }\n+\n+            panic!(\"Index out of bounds\");\n+        }\n+    }\n+\n+    impl<RunAllocF, RunDeallocF> core::ops::IndexMut<usize> for RunVec<RunAllocF, RunDeallocF>\n+    where\n+        RunAllocF: Fn(usize) -> *mut TimSortRun,\n+        RunDeallocF: Fn(*mut TimSortRun, usize),\n+    {\n+        fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n+            if index < self.len {\n+                // SAFETY: buf_ptr and len invariant must be upheld.\n+                unsafe {\n+                    return &mut *(self.buf_ptr.add(index));\n+                }\n+            }\n+\n+            panic!(\"Index out of bounds\");\n+        }\n+    }\n+\n+    impl<RunAllocF, RunDeallocF> Drop for RunVec<RunAllocF, RunDeallocF>\n+    where\n+        RunAllocF: Fn(usize) -> *mut TimSortRun,\n+        RunDeallocF: Fn(*mut TimSortRun, usize),\n+    {\n+        fn drop(&mut self) {\n+            // As long as TimSortRun is Copy we don't need to drop them individually but just the\n+            // whole allocation.\n+            (self.run_dealloc_fn)(self.buf_ptr, self.capacity);\n+        }\n+    }\n+}\n+\n+/// Internal type used by merge_sort.\n+#[derive(Clone, Copy, Debug)]\n+pub struct TimSortRun {\n+    len: usize,\n+    start: usize,\n+}"}, {"sha": "a93f60da2adf2f1369f5069a7642a18a1501c228", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -497,7 +497,7 @@ ul.block, .block li {\n \tpadding-left: 24px;\n }\n \n-.sidebar a, .sidebar .current {\n+.sidebar a {\n \tcolor: var(--sidebar-link-color);\n }\n .sidebar .current,"}, {"sha": "4e9803fe2366d2adf3b0b46d905134d4520ba9ca", "filename": "src/librustdoc/html/static/css/settings.css", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -3,11 +3,6 @@\n \tposition: relative;\n }\n \n-.setting-line .choices {\n-\tdisplay: flex;\n-\tflex-wrap: wrap;\n-}\n-\n .setting-line .radio-line input,\n .setting-line .settings-toggle input {\n \tmargin-right: 0.3em;\n@@ -38,7 +33,7 @@\n \tmargin-bottom: 0.1em;\n \tmin-width: 3.8em;\n \tpadding: 0.3em;\n-\tdisplay: flex;\n+\tdisplay: inline-flex;\n \talign-items: center;\n \tcursor: pointer;\n }"}, {"sha": "cdf1dd366046c56c92d285239cef4ecc9101e251", "filename": "src/tools/tidy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -12,6 +12,7 @@ miropt-test-tools = { path = \"../miropt-test-tools\" }\n lazy_static = \"1\"\n walkdir = \"2\"\n ignore = \"0.4.18\"\n+semver = \"1.0\"\n termcolor = \"1.1.3\"\n \n [[bin]]"}, {"sha": "35000320d1abfcbe24610b55ab4a5df2f5f82a76", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -70,3 +70,4 @@ pub mod ui_tests;\n pub mod unit_tests;\n pub mod unstable_book;\n pub mod walk;\n+pub mod x_version;"}, {"sha": "505f9d724c8d3d450eae9115f271c6726106c497", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -60,7 +60,7 @@ fn main() {\n \n                 let handle = s.spawn(|| {\n                     let mut flag = false;\n-                    $p::check($($args),* , &mut flag);\n+                    $p::check($($args, )* &mut flag);\n                     if (flag) {\n                         bad.store(true, Ordering::Relaxed);\n                     }\n@@ -114,6 +114,8 @@ fn main() {\n         check!(alphabetical, &compiler_path);\n         check!(alphabetical, &library_path);\n \n+        check!(x_version, &root_path, &cargo);\n+\n         let collected = {\n             drain_handles(&mut handles);\n "}, {"sha": "c470d502a6548d31fcb298b9f4a022dee4598880", "filename": "src/tools/tidy/src/x_version.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/src%2Ftools%2Ftidy%2Fsrc%2Fx_version.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/src%2Ftools%2Ftidy%2Fsrc%2Fx_version.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fx_version.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -0,0 +1,68 @@\n+use semver::Version;\n+use std::path::Path;\n+use std::process::{Command, Stdio};\n+\n+pub fn check(root: &Path, cargo: &Path, bad: &mut bool) {\n+    let cargo_list = Command::new(cargo).args([\"install\", \"--list\"]).stdout(Stdio::piped()).spawn();\n+\n+    let child = match cargo_list {\n+        Ok(child) => child,\n+        Err(e) => return tidy_error!(bad, \"failed to run `cargo`: {}\", e),\n+    };\n+\n+    let cargo_list = child.wait_with_output().unwrap();\n+\n+    if cargo_list.status.success() {\n+        let exe_list = String::from_utf8_lossy(&cargo_list.stdout);\n+        let exe_list = exe_list.lines();\n+\n+        let mut installed: Option<Version> = None;\n+\n+        for line in exe_list {\n+            let mut iter = line.split_whitespace();\n+            if iter.next() == Some(\"x\") {\n+                if let Some(version) = iter.next() {\n+                    // Check this is the rust-lang/rust x tool installation since it should be\n+                    // installed at a path containing `src/tools/x`.\n+                    if let Some(path) = iter.next() {\n+                        if path.contains(&\"src/tools/x\") {\n+                            let version = version.strip_prefix(\"v\").unwrap();\n+                            installed = Some(Version::parse(version).unwrap());\n+                            break;\n+                        }\n+                    };\n+                }\n+            } else {\n+                continue;\n+            }\n+        }\n+        // Unwrap the some if x is installed, otherwise return because it's fine if x isn't installed.\n+        let installed = if let Some(i) = installed { i } else { return };\n+\n+        if let Some(expected) = get_x_wrapper_version(root, cargo) {\n+            if installed < expected {\n+                return println!(\n+                    \"Current version of x is {installed}, but the latest version is {expected}\\nConsider updating to the newer version of x by running `cargo install --path src/tools/x`\"\n+                );\n+            }\n+        } else {\n+            return tidy_error!(\n+                bad,\n+                \"Unable to parse the latest version of `x` at `src/tools/x/Cargo.toml`\"\n+            );\n+        }\n+    } else {\n+        return tidy_error!(bad, \"failed to check version of `x`: {}\", cargo_list.status);\n+    }\n+}\n+\n+// Parse latest version out of `x` Cargo.toml\n+fn get_x_wrapper_version(root: &Path, cargo: &Path) -> Option<Version> {\n+    let mut cmd = cargo_metadata::MetadataCommand::new();\n+    cmd.cargo_path(cargo)\n+        .manifest_path(root.join(\"src/tools/x/Cargo.toml\"))\n+        .no_deps()\n+        .features(cargo_metadata::CargoOpt::AllFeatures);\n+    let mut metadata = t!(cmd.exec());\n+    metadata.packages.pop().map(|x| x.version)\n+}"}, {"sha": "0e60c73b67a44e274dfc886d4d33e1b26f9262bb", "filename": "tests/ui/imports/issue-99695-b.fixed", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fimports%2Fissue-99695-b.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fimports%2Fissue-99695-b.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695-b.fixed?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -0,0 +1,20 @@\n+// run-rustfix\n+#![allow(unused, nonstandard_style)]\n+mod m {\n+\n+    mod p {\n+        #[macro_export]\n+        macro_rules! nu {\n+            {} => {};\n+        }\n+\n+        pub struct other_item;\n+    }\n+\n+    use ::nu;\n+pub use self::p::{other_item as _};\n+    //~^ ERROR unresolved import `self::p::nu` [E0432]\n+    //~| HELP a macro with this name exists at the root of the crate\n+}\n+\n+fn main() {}"}, {"sha": "031443a1f5df892f2bd5300112d66866cdae0d59", "filename": "tests/ui/imports/issue-99695-b.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fimports%2Fissue-99695-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fimports%2Fissue-99695-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695-b.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -0,0 +1,19 @@\n+// run-rustfix\n+#![allow(unused, nonstandard_style)]\n+mod m {\n+\n+    mod p {\n+        #[macro_export]\n+        macro_rules! nu {\n+            {} => {};\n+        }\n+\n+        pub struct other_item;\n+    }\n+\n+    pub use self::p::{nu, other_item as _};\n+    //~^ ERROR unresolved import `self::p::nu` [E0432]\n+    //~| HELP a macro with this name exists at the root of the crate\n+}\n+\n+fn main() {}"}, {"sha": "b6f5c726a5ca9ae342798754cfcbe999b795ddeb", "filename": "tests/ui/imports/issue-99695-b.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fimports%2Fissue-99695-b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fimports%2Fissue-99695-b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695-b.stderr?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -0,0 +1,16 @@\n+error[E0432]: unresolved import `self::p::nu`\n+  --> $DIR/issue-99695-b.rs:14:23\n+   |\n+LL |     pub use self::p::{nu, other_item as _};\n+   |                       ^^ no `nu` in `m::p`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL ~     use ::nu;\n+LL ~ pub use self::p::{other_item as _};\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "6bf228b23aad221d8fbf1a798186f38fb3ebd061", "filename": "tests/ui/imports/issue-99695.fixed", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fimports%2Fissue-99695.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fimports%2Fissue-99695.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695.fixed?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -0,0 +1,17 @@\n+// run-rustfix\n+#![allow(unused, nonstandard_style)]\n+mod m {\n+    #[macro_export]\n+    macro_rules! nu {\n+        {} => {};\n+    }\n+\n+    pub struct other_item;\n+\n+    use ::nu;\n+pub use self::{other_item as _};\n+    //~^ ERROR unresolved import `self::nu` [E0432]\n+    //~| HELP a macro with this name exists at the root of the crate\n+}\n+\n+fn main() {}"}, {"sha": "f7199f1497ab0877b12d9d9e8bb6520dc09fa75d", "filename": "tests/ui/imports/issue-99695.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fimports%2Fissue-99695.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fimports%2Fissue-99695.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![allow(unused, nonstandard_style)]\n+mod m {\n+    #[macro_export]\n+    macro_rules! nu {\n+        {} => {};\n+    }\n+\n+    pub struct other_item;\n+\n+    pub use self::{nu, other_item as _};\n+    //~^ ERROR unresolved import `self::nu` [E0432]\n+    //~| HELP a macro with this name exists at the root of the crate\n+}\n+\n+fn main() {}"}, {"sha": "0ef762e1c8230f81a1faf7ac670a6ccdf7c58ad2", "filename": "tests/ui/imports/issue-99695.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fimports%2Fissue-99695.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fimports%2Fissue-99695.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695.stderr?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -0,0 +1,16 @@\n+error[E0432]: unresolved import `self::nu`\n+  --> $DIR/issue-99695.rs:11:20\n+   |\n+LL |     pub use self::{nu, other_item as _};\n+   |                    ^^ no `nu` in `m`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL ~     use ::nu;\n+LL ~ pub use self::{other_item as _};\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "029855de2dea0e594b4d4b64019fc358c967f95d", "filename": "tests/ui/issues/issue-19100.fixed", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fissues%2Fissue-19100.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fissues%2Fissue-19100.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-19100.fixed?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -1,4 +1,3 @@\n-// run-pass\n // run-rustfix\n \n #![allow(non_snake_case)]\n@@ -16,11 +15,11 @@ impl Foo {\n         match self {\n             &\n Foo::Bar if true\n-//~^ WARN pattern binding `Bar` is named the same as one of the variants of the type `Foo`\n+//~^ ERROR pattern binding `Bar` is named the same as one of the variants of the type `Foo`\n => println!(\"bar\"),\n             &\n Foo::Baz if false\n-//~^ WARN pattern binding `Baz` is named the same as one of the variants of the type `Foo`\n+//~^ ERROR pattern binding `Baz` is named the same as one of the variants of the type `Foo`\n => println!(\"baz\"),\n _ => ()\n         }"}, {"sha": "bd9e4ea5b601b0c1f894dca181225a43d76ad40c", "filename": "tests/ui/issues/issue-19100.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fissues%2Fissue-19100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fissues%2Fissue-19100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-19100.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -1,4 +1,3 @@\n-// run-pass\n // run-rustfix\n \n #![allow(non_snake_case)]\n@@ -16,11 +15,11 @@ impl Foo {\n         match self {\n             &\n Bar if true\n-//~^ WARN pattern binding `Bar` is named the same as one of the variants of the type `Foo`\n+//~^ ERROR pattern binding `Bar` is named the same as one of the variants of the type `Foo`\n => println!(\"bar\"),\n             &\n Baz if false\n-//~^ WARN pattern binding `Baz` is named the same as one of the variants of the type `Foo`\n+//~^ ERROR pattern binding `Baz` is named the same as one of the variants of the type `Foo`\n => println!(\"baz\"),\n _ => ()\n         }"}, {"sha": "ebbf083b7dea8d1e1fa76ab98303a7fe2d22f02e", "filename": "tests/ui/issues/issue-19100.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fissues%2Fissue-19100.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fissues%2Fissue-19100.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-19100.stderr?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -1,17 +1,17 @@\n-warning[E0170]: pattern binding `Bar` is named the same as one of the variants of the type `Foo`\n-  --> $DIR/issue-19100.rs:18:1\n+error[E0170]: pattern binding `Bar` is named the same as one of the variants of the type `Foo`\n+  --> $DIR/issue-19100.rs:17:1\n    |\n LL | Bar if true\n    | ^^^ help: to match on the variant, qualify the path: `Foo::Bar`\n    |\n-   = note: `#[warn(bindings_with_variant_name)]` on by default\n+   = note: `#[deny(bindings_with_variant_name)]` on by default\n \n-warning[E0170]: pattern binding `Baz` is named the same as one of the variants of the type `Foo`\n-  --> $DIR/issue-19100.rs:22:1\n+error[E0170]: pattern binding `Baz` is named the same as one of the variants of the type `Foo`\n+  --> $DIR/issue-19100.rs:21:1\n    |\n LL | Baz if false\n    | ^^^ help: to match on the variant, qualify the path: `Foo::Baz`\n \n-warning: 2 warnings emitted\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0170`."}, {"sha": "5eccb8cd5d8d2cc59ea45992eac2ddd530285a9e", "filename": "tests/ui/lint/issue-30302.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Flint%2Fissue-30302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Flint%2Fissue-30302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fissue-30302.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -11,7 +11,7 @@ enum Stack<T> {\n fn is_empty<T>(s: Stack<T>) -> bool {\n     match s {\n         Nil => true,\n-//~^ WARN pattern binding `Nil` is named the same as one of the variants of the type `Stack`\n+//~^ ERROR pattern binding `Nil` is named the same as one of the variants of the type `Stack`\n         _ => false\n //~^ ERROR unreachable pattern\n     }"}, {"sha": "baf6c0d7a59d84da505cd17ade601b2efb33496e", "filename": "tests/ui/lint/issue-30302.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Flint%2Fissue-30302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Flint%2Fissue-30302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fissue-30302.stderr?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -1,10 +1,10 @@\n-warning[E0170]: pattern binding `Nil` is named the same as one of the variants of the type `Stack`\n+error[E0170]: pattern binding `Nil` is named the same as one of the variants of the type `Stack`\n   --> $DIR/issue-30302.rs:13:9\n    |\n LL |         Nil => true,\n    |         ^^^ help: to match on the variant, qualify the path: `Stack::Nil`\n    |\n-   = note: `#[warn(bindings_with_variant_name)]` on by default\n+   = note: `#[deny(bindings_with_variant_name)]` on by default\n \n error: unreachable pattern\n   --> $DIR/issue-30302.rs:15:9\n@@ -21,6 +21,6 @@ note: the lint level is defined here\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0170`."}, {"sha": "59dba536f24b61bf5635cad404d4ba8695bbedbf", "filename": "tests/ui/lint/lint-uppercase-variables.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Flint%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Flint%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Flint-uppercase-variables.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -21,18 +21,18 @@ fn main() {\n     match foo::Foo::Foo {\n         Foo => {}\n     //~^ ERROR variable `Foo` should have a snake case name\n-    //~^^ WARN `Foo` is named the same as one of the variants of the type `foo::Foo`\n+    //~^^ ERROR `Foo` is named the same as one of the variants of the type `foo::Foo`\n     //~^^^ WARN unused variable: `Foo`\n     }\n \n     let Foo = foo::Foo::Foo;\n     //~^ ERROR variable `Foo` should have a snake case name\n-    //~^^ WARN `Foo` is named the same as one of the variants of the type `foo::Foo`\n+    //~^^ ERROR `Foo` is named the same as one of the variants of the type `foo::Foo`\n     //~^^^ WARN unused variable: `Foo`\n \n     fn in_param(Foo: foo::Foo) {}\n     //~^ ERROR variable `Foo` should have a snake case name\n-    //~^^ WARN `Foo` is named the same as one of the variants of the type `foo::Foo`\n+    //~^^ ERROR `Foo` is named the same as one of the variants of the type `foo::Foo`\n     //~^^^ WARN unused variable: `Foo`\n \n     test(1);"}, {"sha": "42ec9364bc6e68f973295fb9258b34da958bc89d", "filename": "tests/ui/lint/lint-uppercase-variables.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Flint%2Flint-uppercase-variables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Flint%2Flint-uppercase-variables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Flint-uppercase-variables.stderr?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -1,18 +1,18 @@\n-warning[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `foo::Foo`\n+error[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `foo::Foo`\n   --> $DIR/lint-uppercase-variables.rs:22:9\n    |\n LL |         Foo => {}\n    |         ^^^ help: to match on the variant, qualify the path: `foo::Foo::Foo`\n    |\n-   = note: `#[warn(bindings_with_variant_name)]` on by default\n+   = note: `#[deny(bindings_with_variant_name)]` on by default\n \n-warning[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `foo::Foo`\n+error[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `foo::Foo`\n   --> $DIR/lint-uppercase-variables.rs:28:9\n    |\n LL |     let Foo = foo::Foo::Foo;\n    |         ^^^ help: to match on the variant, qualify the path: `foo::Foo::Foo`\n \n-warning[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `foo::Foo`\n+error[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `foo::Foo`\n   --> $DIR/lint-uppercase-variables.rs:33:17\n    |\n LL |     fn in_param(Foo: foo::Foo) {}\n@@ -85,6 +85,6 @@ error: variable `Foo` should have a snake case name\n LL |     fn in_param(Foo: foo::Foo) {}\n    |                 ^^^ help: convert the identifier to snake case (notice the capitalization): `foo`\n \n-error: aborting due to 6 previous errors; 6 warnings emitted\n+error: aborting due to 9 previous errors; 3 warnings emitted\n \n For more information about this error, try `rustc --explain E0170`."}, {"sha": "13427d2c9b208cb923b66d92cd25800f23d8c2e0", "filename": "tests/ui/pattern/issue-14221.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fpattern%2Fissue-14221.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fpattern%2Fissue-14221.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-14221.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -11,9 +11,9 @@ pub mod b {\n     pub fn key(e: ::E) -> &'static str {\n         match e {\n             A => \"A\",\n-//~^ WARN pattern binding `A` is named the same as one of the variants of the type `E`\n+//~^ ERROR pattern binding `A` is named the same as one of the variants of the type `E`\n             B => \"B\", //~ ERROR: unreachable pattern\n-//~^ WARN pattern binding `B` is named the same as one of the variants of the type `E`\n+//~^ ERROR pattern binding `B` is named the same as one of the variants of the type `E`\n         }\n     }\n }"}, {"sha": "7ea51b5f804c074abe85ce83a95ba042bbc67948", "filename": "tests/ui/pattern/issue-14221.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fpattern%2Fissue-14221.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fpattern%2Fissue-14221.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-14221.stderr?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -1,12 +1,12 @@\n-warning[E0170]: pattern binding `A` is named the same as one of the variants of the type `E`\n+error[E0170]: pattern binding `A` is named the same as one of the variants of the type `E`\n   --> $DIR/issue-14221.rs:13:13\n    |\n LL |             A => \"A\",\n    |             ^ help: to match on the variant, qualify the path: `E::A`\n    |\n-   = note: `#[warn(bindings_with_variant_name)]` on by default\n+   = note: `#[deny(bindings_with_variant_name)]` on by default\n \n-warning[E0170]: pattern binding `B` is named the same as one of the variants of the type `E`\n+error[E0170]: pattern binding `B` is named the same as one of the variants of the type `E`\n   --> $DIR/issue-14221.rs:15:13\n    |\n LL |             B => \"B\",\n@@ -27,6 +27,6 @@ note: the lint level is defined here\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error; 2 warnings emitted\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0170`."}, {"sha": "05d097eaf14e4a02a789cfc56f621dfedb80ad80", "filename": "tests/ui/pattern/issue-67776-match-same-name-enum-variant-refs.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fpattern%2Fissue-67776-match-same-name-enum-variant-refs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fpattern%2Fissue-67776-match-same-name-enum-variant-refs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-67776-match-same-name-enum-variant-refs.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -1,7 +1,5 @@\n // Test for issue #67776: binding named the same as enum variant\n-// should report a warning even when matching against a reference type\n-\n-// check-pass\n+// should report an error even when matching against a reference type\n \n #![allow(unused_variables)]\n #![allow(non_snake_case)]\n@@ -15,27 +13,27 @@ enum Foo {\n fn fn1(e: Foo) {\n     match e {\n         Bar => {},\n-        //~^ WARNING named the same as one of the variants of the type `Foo`\n+        //~^ ERROR named the same as one of the variants of the type `Foo`\n         Baz => {},\n-        //~^ WARNING named the same as one of the variants of the type `Foo`\n+        //~^ ERROR named the same as one of the variants of the type `Foo`\n     }\n }\n \n fn fn2(e: &Foo) {\n     match e {\n         Bar => {},\n-        //~^ WARNING named the same as one of the variants of the type `Foo`\n+        //~^ ERROR named the same as one of the variants of the type `Foo`\n         Baz => {},\n-        //~^ WARNING named the same as one of the variants of the type `Foo`\n+        //~^ ERROR named the same as one of the variants of the type `Foo`\n     }\n }\n \n fn fn3(e: &mut &&mut Foo) {\n     match e {\n         Bar => {},\n-        //~^ WARNING named the same as one of the variants of the type `Foo`\n+        //~^ ERROR named the same as one of the variants of the type `Foo`\n         Baz => {},\n-        //~^ WARNING named the same as one of the variants of the type `Foo`\n+        //~^ ERROR named the same as one of the variants of the type `Foo`\n     }\n }\n "}, {"sha": "da580c7accb97c6574e1b0ae0af332b8fb073973", "filename": "tests/ui/pattern/issue-67776-match-same-name-enum-variant-refs.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fpattern%2Fissue-67776-match-same-name-enum-variant-refs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fpattern%2Fissue-67776-match-same-name-enum-variant-refs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-67776-match-same-name-enum-variant-refs.stderr?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -1,41 +1,41 @@\n-warning[E0170]: pattern binding `Bar` is named the same as one of the variants of the type `Foo`\n-  --> $DIR/issue-67776-match-same-name-enum-variant-refs.rs:17:9\n+error[E0170]: pattern binding `Bar` is named the same as one of the variants of the type `Foo`\n+  --> $DIR/issue-67776-match-same-name-enum-variant-refs.rs:15:9\n    |\n LL |         Bar => {},\n    |         ^^^ help: to match on the variant, qualify the path: `Foo::Bar`\n    |\n-   = note: `#[warn(bindings_with_variant_name)]` on by default\n+   = note: `#[deny(bindings_with_variant_name)]` on by default\n \n-warning[E0170]: pattern binding `Baz` is named the same as one of the variants of the type `Foo`\n-  --> $DIR/issue-67776-match-same-name-enum-variant-refs.rs:19:9\n+error[E0170]: pattern binding `Baz` is named the same as one of the variants of the type `Foo`\n+  --> $DIR/issue-67776-match-same-name-enum-variant-refs.rs:17:9\n    |\n LL |         Baz => {},\n    |         ^^^ help: to match on the variant, qualify the path: `Foo::Baz`\n \n-warning[E0170]: pattern binding `Bar` is named the same as one of the variants of the type `Foo`\n-  --> $DIR/issue-67776-match-same-name-enum-variant-refs.rs:26:9\n+error[E0170]: pattern binding `Bar` is named the same as one of the variants of the type `Foo`\n+  --> $DIR/issue-67776-match-same-name-enum-variant-refs.rs:24:9\n    |\n LL |         Bar => {},\n    |         ^^^ help: to match on the variant, qualify the path: `Foo::Bar`\n \n-warning[E0170]: pattern binding `Baz` is named the same as one of the variants of the type `Foo`\n-  --> $DIR/issue-67776-match-same-name-enum-variant-refs.rs:28:9\n+error[E0170]: pattern binding `Baz` is named the same as one of the variants of the type `Foo`\n+  --> $DIR/issue-67776-match-same-name-enum-variant-refs.rs:26:9\n    |\n LL |         Baz => {},\n    |         ^^^ help: to match on the variant, qualify the path: `Foo::Baz`\n \n-warning[E0170]: pattern binding `Bar` is named the same as one of the variants of the type `Foo`\n-  --> $DIR/issue-67776-match-same-name-enum-variant-refs.rs:35:9\n+error[E0170]: pattern binding `Bar` is named the same as one of the variants of the type `Foo`\n+  --> $DIR/issue-67776-match-same-name-enum-variant-refs.rs:33:9\n    |\n LL |         Bar => {},\n    |         ^^^ help: to match on the variant, qualify the path: `Foo::Bar`\n \n-warning[E0170]: pattern binding `Baz` is named the same as one of the variants of the type `Foo`\n-  --> $DIR/issue-67776-match-same-name-enum-variant-refs.rs:37:9\n+error[E0170]: pattern binding `Baz` is named the same as one of the variants of the type `Foo`\n+  --> $DIR/issue-67776-match-same-name-enum-variant-refs.rs:35:9\n    |\n LL |         Baz => {},\n    |         ^^^ help: to match on the variant, qualify the path: `Foo::Baz`\n \n-warning: 6 warnings emitted\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0170`."}, {"sha": "d161ed284f6d9dd292ce523ffb1ebaa99e4c7e67", "filename": "tests/ui/suggestions/issue-88730.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fsuggestions%2Fissue-88730.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fsuggestions%2Fissue-88730.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-88730.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -1,9 +1,8 @@\n #![allow(unused, nonstandard_style)]\n-#![deny(bindings_with_variant_name)]\n \n // If an enum has two different variants,\n // then it cannot be matched upon in a function argument.\n-// It still gets a warning, but no suggestions.\n+// It still gets an error, but no suggestions.\n enum Foo {\n     C,\n     D,"}, {"sha": "0bd1b7ba4bacfdbe35e8f85a82a2b8b96fe115ac", "filename": "tests/ui/suggestions/issue-88730.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fsuggestions%2Fissue-88730.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Fsuggestions%2Fissue-88730.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-88730.stderr?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -1,17 +1,13 @@\n error[E0170]: pattern binding `C` is named the same as one of the variants of the type `Foo`\n-  --> $DIR/issue-88730.rs:12:8\n+  --> $DIR/issue-88730.rs:11:8\n    |\n LL | fn foo(C: Foo) {}\n    |        ^\n    |\n-note: the lint level is defined here\n-  --> $DIR/issue-88730.rs:2:9\n-   |\n-LL | #![deny(bindings_with_variant_name)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `#[deny(bindings_with_variant_name)]` on by default\n \n error[E0170]: pattern binding `C` is named the same as one of the variants of the type `Foo`\n-  --> $DIR/issue-88730.rs:15:9\n+  --> $DIR/issue-88730.rs:14:9\n    |\n LL |     let C = Foo::D;\n    |         ^"}, {"sha": "c0ecf1c91fb384681b3b27ff4d6145019a989101", "filename": "tests/ui/traits/new-solver/fn-trait-closure.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait-closure.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -Ztrait-solver=next\n+// known-bug: unknown\n+// failure-status: 101\n+// dont-check-compiler-stderr\n+\n+// This test will fail until we fix `FulfillmentCtxt::relationships`. That's\n+// because we create a type variable for closure upvar types, which is not\n+// constrained until after we try to do fallback on diverging type variables.\n+// Thus, we will call that function, which is unimplemented.\n+\n+fn require_fn(_: impl Fn() -> i32) {}\n+\n+fn main() {\n+    require_fn(|| -> i32 { 1i32 });\n+}"}, {"sha": "d566ead105c8627037706e6d43352aa81796d917", "filename": "tests/ui/traits/new-solver/fn-trait.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -0,0 +1,13 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+fn require_fn(_: impl Fn() -> i32) {}\n+\n+fn f() -> i32 {\n+    1i32\n+}\n+\n+fn main() {\n+    require_fn(f);\n+    require_fn(f as fn() -> i32);\n+}"}, {"sha": "15681cd132ec64b583380bbff700f3119bace75f", "filename": "tests/ui/traits/new-solver/pointer-sized.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.rs?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -0,0 +1,12 @@\n+#![feature(pointer_sized_trait)]\n+\n+use std::marker::PointerSized;\n+\n+fn require_pointer_sized(_: impl PointerSized) {}\n+\n+fn main() {\n+    require_pointer_sized(1usize);\n+    require_pointer_sized(1u16);\n+    //~^ ERROR `u16` needs to be a pointer-sized type\n+    require_pointer_sized(&1i16);\n+}"}, {"sha": "b250b1331bbf9ef1083cc1349d7b6e74ec91e7f7", "filename": "tests/ui/traits/new-solver/pointer-sized.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e098eb17e1514bcd604ac4bd57cec362944687af/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.stderr?ref=e098eb17e1514bcd604ac4bd57cec362944687af", "patch": "@@ -0,0 +1,24 @@\n+error[E0277]: `u16` needs to be a pointer-sized type\n+  --> $DIR/pointer-sized.rs:9:27\n+   |\n+LL |     require_pointer_sized(1u16);\n+   |     --------------------- ^^^^ the trait `PointerSized` is not implemented for `u16`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = note: the trait bound `u16: PointerSized` is not satisfied\n+note: required by a bound in `require_pointer_sized`\n+  --> $DIR/pointer-sized.rs:5:34\n+   |\n+LL | fn require_pointer_sized(_: impl PointerSized) {}\n+   |                                  ^^^^^^^^^^^^ required by this bound in `require_pointer_sized`\n+help: consider borrowing here\n+   |\n+LL |     require_pointer_sized(&1u16);\n+   |                           +\n+LL |     require_pointer_sized(&mut 1u16);\n+   |                           ++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}