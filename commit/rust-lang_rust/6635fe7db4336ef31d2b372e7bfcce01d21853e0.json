{"sha": "6635fe7db4336ef31d2b372e7bfcce01d21853e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MzVmZTdkYjQzMzZlZjMxZDJiMzcyZTdiZmNjZTAxZDIxODUzZTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-29T17:41:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-29T17:41:41Z"}, "message": "auto merge of #15989 : pcwalton/rust/borrowck-pattern-guards, r=pnkfelix\n\nthe CFG for match statements.\r\n\r\nThere were two bugs in issue #14684. One was simply that the borrow\r\ncheck didn't know about the correct CFG for match statements: the\r\npattern must be a predecessor of the guard. This disallows the bad\r\nbehavior if there are bindings in the pattern. But it isn't enough to\r\nprevent the memory safety problem, because of wildcards; thus, this\r\npatch introduces a more restrictive rule, which disallows assignments\r\nand mutable borrows inside guards outright.\r\n\r\nI discussed this with Niko and we decided this was the best plan of\r\naction.\r\n\r\nThis breaks code that performs mutable borrows in pattern guards. Most\r\ncommonly, the code looks like this:\r\n\r\n    impl Foo {\r\n        fn f(&mut self, ...) {}\r\n        fn g(&mut self, ...) {\r\n            match bar {\r\n                Baz if self.f(...) => { ... }\r\n                _ => { ... }\r\n            }\r\n        }\r\n    }\r\n\r\nChange this code to not use a guard. For example:\r\n\r\n    impl Foo {\r\n        fn f(&mut self, ...) {}\r\n        fn g(&mut self, ...) {\r\n            match bar {\r\n                Baz => {\r\n                    if self.f(...) {\r\n                        ...\r\n                    } else {\r\n                        ...\r\n                    }\r\n                }\r\n                _ => { ... }\r\n            }\r\n        }\r\n    }\r\n\r\nSometimes this can result in code duplication, but often it illustrates\r\na hidden memory safety problem.\r\n\r\nCloses #14684.\r\n\r\n[breaking-change]\r\n\r\nr? @pnkfelix", "tree": {"sha": "defdad9e214287bdf4071fcaac2bf886c94052c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/defdad9e214287bdf4071fcaac2bf886c94052c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6635fe7db4336ef31d2b372e7bfcce01d21853e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6635fe7db4336ef31d2b372e7bfcce01d21853e0", "html_url": "https://github.com/rust-lang/rust/commit/6635fe7db4336ef31d2b372e7bfcce01d21853e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6635fe7db4336ef31d2b372e7bfcce01d21853e0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b92536ff2f611027b7bc0953c9850b42ed3ddf41", "url": "https://api.github.com/repos/rust-lang/rust/commits/b92536ff2f611027b7bc0953c9850b42ed3ddf41", "html_url": "https://github.com/rust-lang/rust/commit/b92536ff2f611027b7bc0953c9850b42ed3ddf41"}, {"sha": "b2eb88843d1b727551464beea3438e9f0159ebad", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2eb88843d1b727551464beea3438e9f0159ebad", "html_url": "https://github.com/rust-lang/rust/commit/b2eb88843d1b727551464beea3438e9f0159ebad"}], "stats": {"total": 654, "additions": 383, "deletions": 271}, "files": [{"sha": "3350d8f548a86cee5dc5e0f48cb1b50d9b4867ea", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=6635fe7db4336ef31d2b372e7bfcce01d21853e0", "patch": "@@ -352,8 +352,13 @@ impl<'a> Parser<'a> {\n             None => {\n                 let tmp = self.cur.clone();\n                 match self.word() {\n-                    word if word.len() > 0 && self.consume('$') => {\n-                        CountIsName(word)\n+                    word if word.len() > 0 => {\n+                        if self.consume('$') {\n+                            CountIsName(word)\n+                        } else {\n+                            self.cur = tmp;\n+                            CountImplied\n+                        }\n                     }\n                     _ => {\n                         self.cur = tmp;"}, {"sha": "9cd46067c107b3b5a7eafa140a7a75e16f26f03e", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=6635fe7db4336ef31d2b372e7bfcce01d21853e0", "patch": "@@ -333,32 +333,37 @@ impl<'a> CFGBuilder<'a> {\n                 //    [discr]\n                 //       |\n                 //       v 2\n-                //    [guard1]\n+                //    [cond1]\n                 //      /  \\\n                 //     |    \\\n-                //     v 3  |\n-                //  [pat1]  |\n-                //     |\n-                //     v 4  |\n-                // [body1]  v\n-                //     |  [guard2]\n-                //     |    /   \\\n-                //     | [body2] \\\n-                //     |    |   ...\n-                //     |    |    |\n-                //     v 5  v    v\n-                //   [....expr....]\n+                //     v 3   \\\n+                //  [pat1]    \\\n+                //     |       |\n+                //     v 4     |\n+                //  [guard1]   |\n+                //     |       |\n+                //     |       |\n+                //     v 5     v\n+                //  [body1]  [cond2]\n+                //     |      /  \\\n+                //     |    ...  ...\n+                //     |     |    |\n+                //     v 6   v    v\n+                //  [.....expr.....]\n                 //\n                 let discr_exit = self.expr(discr.clone(), pred);         // 1\n \n                 let expr_exit = self.add_node(expr.id, []);\n-                let mut guard_exit = discr_exit;\n+                let mut cond_exit = discr_exit;\n                 for arm in arms.iter() {\n-                    guard_exit = self.opt_expr(arm.guard, guard_exit);   // 2\n+                    cond_exit = self.add_dummy_node([cond_exit]);        // 2\n                     let pats_exit = self.pats_any(arm.pats.as_slice(),\n-                                                  guard_exit);           // 3\n-                    let body_exit = self.expr(arm.body.clone(), pats_exit); // 4\n-                    self.add_contained_edge(body_exit, expr_exit);       // 5\n+                                                  cond_exit);            // 3\n+                    let guard_exit = self.opt_expr(arm.guard,\n+                                                   pats_exit);           // 4\n+                    let body_exit = self.expr(arm.body.clone(),\n+                                              guard_exit);               // 5\n+                    self.add_contained_edge(body_exit, expr_exit);       // 6\n                 }\n                 expr_exit\n             }"}, {"sha": "4d10676a5892ee8187e1eaacddb49c803dc77455", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=6635fe7db4336ef31d2b372e7bfcce01d21853e0", "patch": "@@ -11,6 +11,10 @@\n use middle::const_eval::{compare_const_vals, const_bool, const_float, const_nil, const_val};\n use middle::const_eval::{const_expr_to_pat, eval_const_expr, lookup_const_by_id};\n use middle::def::*;\n+use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Init};\n+use middle::expr_use_visitor::{JustWrite, LoanCause, MutateMode};\n+use middle::expr_use_visitor::{WriteAndRead};\n+use middle::mem_categorization::cmt;\n use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n@@ -143,7 +147,16 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n                                                 arm.pats.as_slice());\n             }\n \n-            // Second, check for unreachable arms.\n+            // Second, if there is a guard on each arm, make sure it isn't\n+            // assigning or borrowing anything mutably.\n+            for arm in arms.iter() {\n+                match arm.guard {\n+                    Some(guard) => check_for_mutation_in_guard(cx, &*guard),\n+                    None => {}\n+                }\n+            }\n+\n+            // Third, check for unreachable arms.\n             check_arms(cx, arms.as_slice());\n \n             // Finally, check if the whole match expression is exhaustive.\n@@ -903,3 +916,53 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         });\n     }\n }\n+\n+/// Ensures that a pattern guard doesn't borrow by mutable reference or\n+/// assign.\n+fn check_for_mutation_in_guard<'a>(cx: &'a MatchCheckCtxt<'a>, guard: &Expr) {\n+    let mut checker = MutationChecker {\n+        cx: cx,\n+    };\n+    let mut visitor = ExprUseVisitor::new(&mut checker, checker.cx.tcx);\n+    visitor.walk_expr(guard);\n+}\n+\n+struct MutationChecker<'a> {\n+    cx: &'a MatchCheckCtxt<'a>,\n+}\n+\n+impl<'a> Delegate for MutationChecker<'a> {\n+    fn consume(&mut self, _: NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n+    fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}\n+    fn borrow(&mut self,\n+              _: NodeId,\n+              span: Span,\n+              _: cmt,\n+              _: Region,\n+              kind: BorrowKind,\n+              _: LoanCause) {\n+        match kind {\n+            MutBorrow => {\n+                self.cx\n+                    .tcx\n+                    .sess\n+                    .span_err(span,\n+                              \"cannot mutably borrow in a pattern guard\")\n+            }\n+            ImmBorrow | UniqueImmBorrow => {}\n+        }\n+    }\n+    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+    fn mutate(&mut self, _: NodeId, span: Span, _: cmt, mode: MutateMode) {\n+        match mode {\n+            JustWrite | WriteAndRead => {\n+                self.cx\n+                    .tcx\n+                    .sess\n+                    .span_err(span, \"cannot assign in a pattern guard\")\n+            }\n+            Init => {}\n+        }\n+    }\n+}\n+"}, {"sha": "605811555a16819b70d69d99a42b614b4c6a0560", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=6635fe7db4336ef31d2b372e7bfcce01d21853e0", "patch": "@@ -292,7 +292,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         self.walk_expr(expr)\n     }\n \n-    fn walk_expr(&mut self, expr: &ast::Expr) {\n+    pub fn walk_expr(&mut self, expr: &ast::Expr) {\n         debug!(\"walk_expr(expr={})\", expr.repr(self.tcx()));\n \n         self.walk_adjustment(expr);"}, {"sha": "084ba46797ef9f0492f5fbea60da25496c89c83a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6635fe7db4336ef31d2b372e7bfcce01d21853e0", "patch": "@@ -1734,17 +1734,19 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n         }\n     }).peekable();\n     match s.struct_type {\n-        doctree::Plain if fields.peek().is_some() => {\n-            try!(write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\"));\n-            for field in fields {\n-                try!(write!(w, \"<tr><td id='structfield.{name}'>\\\n-                                  {stab}<code>{name}</code></td><td>\",\n-                              stab = ConciseStability(&field.stability),\n-                              name = field.name.get_ref().as_slice()));\n-                try!(document(w, field));\n-                try!(write!(w, \"</td></tr>\"));\n+        doctree::Plain => {\n+            if fields.peek().is_some() {\n+                try!(write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\"));\n+                for field in fields {\n+                    try!(write!(w, \"<tr><td id='structfield.{name}'>\\\n+                                      {stab}<code>{name}</code></td><td>\",\n+                                  stab = ConciseStability(&field.stability),\n+                                  name = field.name.get_ref().as_slice()));\n+                    try!(document(w, field));\n+                    try!(write!(w, \"</td></tr>\"));\n+                }\n+                try!(write!(w, \"</table>\"));\n             }\n-            try!(write!(w, \"</table>\"));\n         }\n         _ => {}\n     }"}, {"sha": "878994369d0d4320f4ca2661678f8301e1e3aa55", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 208, "deletions": 183, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6635fe7db4336ef31d2b372e7bfcce01d21853e0", "patch": "@@ -1954,19 +1954,6 @@ impl<'a> Parser<'a> {\n             token::BINOP(token::OR) |  token::OROR => {\n                 return self.parse_lambda_expr();\n             },\n-            _ if self.eat_keyword(keywords::Proc) => {\n-                let decl = self.parse_proc_decl();\n-                let body = self.parse_expr();\n-                let fakeblock = P(ast::Block {\n-                        view_items: Vec::new(),\n-                        stmts: Vec::new(),\n-                        expr: Some(body),\n-                        id: ast::DUMMY_NODE_ID,\n-                        rules: DefaultBlock,\n-                        span: body.span,\n-                    });\n-                return self.mk_expr(lo, body.span.hi, ExprProc(decl, fakeblock));\n-            },\n             // FIXME #13626: Should be able to stick in\n             // token::SELF_KEYWORD_NAME\n             token::IDENT(id @ ast::Ident{\n@@ -1978,48 +1965,6 @@ impl<'a> Parser<'a> {\n                 ex = ExprPath(path);\n                 hi = self.last_span.hi;\n             }\n-            _ if self.eat_keyword(keywords::If) => {\n-                return self.parse_if_expr();\n-            },\n-            _ if self.eat_keyword(keywords::For) => {\n-                return self.parse_for_expr(None);\n-            },\n-            _ if self.eat_keyword(keywords::While) => {\n-                return self.parse_while_expr();\n-            },\n-            _ if Parser::token_is_lifetime(&self.token) => {\n-                let lifetime = self.get_lifetime();\n-                self.bump();\n-                self.expect(&token::COLON);\n-                if self.eat_keyword(keywords::For) {\n-                    return self.parse_for_expr(Some(lifetime))\n-                } else if self.eat_keyword(keywords::Loop) {\n-                    return self.parse_loop_expr(Some(lifetime))\n-                } else {\n-                    self.fatal(\"expected `for` or `loop` after a label\")\n-                }\n-            },\n-            _ if self.eat_keyword(keywords::Loop) => {\n-                return self.parse_loop_expr(None);\n-            },\n-            _ if self.eat_keyword(keywords::Continue) => {\n-                let lo = self.span.lo;\n-                let ex = if Parser::token_is_lifetime(&self.token) {\n-                    let lifetime = self.get_lifetime();\n-                    self.bump();\n-                    ExprAgain(Some(lifetime))\n-                } else {\n-                    ExprAgain(None)\n-                };\n-                let hi = self.span.hi;\n-                return self.mk_expr(lo, hi, ex);\n-            },\n-            _ if self.eat_keyword(keywords::Match) => {\n-                return self.parse_match_expr();\n-            },\n-            _ if self.eat_keyword(keywords::Unsafe) => {\n-                return self.parse_block_expr(lo, UnsafeBlock(ast::UserProvided));\n-            },\n             token::LBRACKET => {\n                 self.bump();\n \n@@ -2057,88 +2002,158 @@ impl<'a> Parser<'a> {\n                 }\n                 hi = self.last_span.hi;\n             },\n-            _ if self.eat_keyword(keywords::Return) => {\n-                // RETURN expression\n-                if can_begin_expr(&self.token) {\n-                    let e = self.parse_expr();\n-                    hi = e.span.hi;\n-                    ex = ExprRet(Some(e));\n-                } else { ex = ExprRet(None); }\n-            },\n-            _ if self.eat_keyword(keywords::Break) => {\n-                // BREAK expression\n+            _ => {\n+                if self.eat_keyword(keywords::Proc) {\n+                    let decl = self.parse_proc_decl();\n+                    let body = self.parse_expr();\n+                    let fakeblock = P(ast::Block {\n+                            view_items: Vec::new(),\n+                            stmts: Vec::new(),\n+                            expr: Some(body),\n+                            id: ast::DUMMY_NODE_ID,\n+                            rules: DefaultBlock,\n+                            span: body.span,\n+                        });\n+                    return self.mk_expr(lo, body.span.hi, ExprProc(decl, fakeblock));\n+                }\n+                if self.eat_keyword(keywords::If) {\n+                    return self.parse_if_expr();\n+                }\n+                if self.eat_keyword(keywords::For) {\n+                    return self.parse_for_expr(None);\n+                }\n+                if self.eat_keyword(keywords::While) {\n+                    return self.parse_while_expr();\n+                }\n                 if Parser::token_is_lifetime(&self.token) {\n                     let lifetime = self.get_lifetime();\n                     self.bump();\n-                    ex = ExprBreak(Some(lifetime));\n-                } else {\n-                    ex = ExprBreak(None);\n+                    self.expect(&token::COLON);\n+                    if self.eat_keyword(keywords::For) {\n+                        return self.parse_for_expr(Some(lifetime))\n+                    }\n+                    if self.eat_keyword(keywords::Loop) {\n+                        return self.parse_loop_expr(Some(lifetime))\n+                    }\n+                    self.fatal(\"expected `for` or `loop` after a label\")\n                 }\n-                hi = self.span.hi;\n-            },\n-            _ if self.token == token::MOD_SEP ||\n-                is_ident(&self.token) && !self.is_keyword(keywords::True) &&\n-                !self.is_keyword(keywords::False) => {\n-                let pth = self.parse_path(LifetimeAndTypesWithColons).path;\n-\n-                // `!`, as an operator, is prefix, so we know this isn't that\n-                if self.token == token::NOT {\n-                    // MACRO INVOCATION expression\n-                    self.bump();\n-\n-                    let ket = token::close_delimiter_for(&self.token)\n-                        .unwrap_or_else(|| self.fatal(\"expected open delimiter\"));\n-                    self.bump();\n-\n-                    let tts = self.parse_seq_to_end(&ket,\n-                                                    seq_sep_none(),\n-                                                    |p| p.parse_token_tree());\n+                if self.eat_keyword(keywords::Loop) {\n+                    return self.parse_loop_expr(None);\n+                }\n+                if self.eat_keyword(keywords::Continue) {\n+                    let lo = self.span.lo;\n+                    let ex = if Parser::token_is_lifetime(&self.token) {\n+                        let lifetime = self.get_lifetime();\n+                        self.bump();\n+                        ExprAgain(Some(lifetime))\n+                    } else {\n+                        ExprAgain(None)\n+                    };\n                     let hi = self.span.hi;\n+                    return self.mk_expr(lo, hi, ex);\n+                }\n+                if self.eat_keyword(keywords::Match) {\n+                    return self.parse_match_expr();\n+                }\n+                if self.eat_keyword(keywords::Unsafe) {\n+                    return self.parse_block_expr(\n+                        lo,\n+                        UnsafeBlock(ast::UserProvided));\n+                }\n+                if self.eat_keyword(keywords::Return) {\n+                    // RETURN expression\n+                    if can_begin_expr(&self.token) {\n+                        let e = self.parse_expr();\n+                        hi = e.span.hi;\n+                        ex = ExprRet(Some(e));\n+                    } else {\n+                        ex = ExprRet(None);\n+                    }\n+                } else if self.eat_keyword(keywords::Break) {\n+                    // BREAK expression\n+                    if Parser::token_is_lifetime(&self.token) {\n+                        let lifetime = self.get_lifetime();\n+                        self.bump();\n+                        ex = ExprBreak(Some(lifetime));\n+                    } else {\n+                        ex = ExprBreak(None);\n+                    }\n+                    hi = self.span.hi;\n+                } else if self.token == token::MOD_SEP ||\n+                        is_ident(&self.token) &&\n+                        !self.is_keyword(keywords::True) &&\n+                        !self.is_keyword(keywords::False) {\n+                    let pth =\n+                        self.parse_path(LifetimeAndTypesWithColons).path;\n+\n+                    // `!`, as an operator, is prefix, so we know this isn't that\n+                    if self.token == token::NOT {\n+                        // MACRO INVOCATION expression\n+                        self.bump();\n \n-                    return self.mk_mac_expr(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT));\n-                } else if self.token == token::LBRACE {\n-                    // This is a struct literal, unless we're prohibited from\n-                    // parsing struct literals here.\n-                    if self.restriction != RESTRICT_NO_STRUCT_LITERAL {\n-                        // It's a struct literal.\n+                        let ket = token::close_delimiter_for(&self.token)\n+                            .unwrap_or_else(|| {\n+                                self.fatal(\"expected open delimiter\")\n+                            });\n                         self.bump();\n-                        let mut fields = Vec::new();\n-                        let mut base = None;\n \n-                        while self.token != token::RBRACE {\n-                            if self.eat(&token::DOTDOT) {\n-                                base = Some(self.parse_expr());\n-                                break;\n+                        let tts = self.parse_seq_to_end(\n+                            &ket,\n+                            seq_sep_none(),\n+                            |p| p.parse_token_tree());\n+                        let hi = self.span.hi;\n+\n+                        return self.mk_mac_expr(lo,\n+                                                hi,\n+                                                MacInvocTT(pth,\n+                                                           tts,\n+                                                           EMPTY_CTXT));\n+                    }\n+                    if self.token == token::LBRACE {\n+                        // This is a struct literal, unless we're prohibited\n+                        // from parsing struct literals here.\n+                        if self.restriction != RESTRICT_NO_STRUCT_LITERAL {\n+                            // It's a struct literal.\n+                            self.bump();\n+                            let mut fields = Vec::new();\n+                            let mut base = None;\n+\n+                            while self.token != token::RBRACE {\n+                                if self.eat(&token::DOTDOT) {\n+                                    base = Some(self.parse_expr());\n+                                    break;\n+                                }\n+\n+                                fields.push(self.parse_field());\n+                                self.commit_expr(fields.last().unwrap().expr,\n+                                                 &[token::COMMA],\n+                                                 &[token::RBRACE]);\n                             }\n \n-                            fields.push(self.parse_field());\n-                            self.commit_expr(fields.last().unwrap().expr,\n-                                             &[token::COMMA], &[token::RBRACE]);\n-                        }\n+                            if fields.len() == 0 && base.is_none() {\n+                                let last_span = self.last_span;\n+                                self.span_err(last_span,\n+                                              \"structure literal must either \\\n+                                              have at least one field or use \\\n+                                              functional structure update \\\n+                                              syntax\");\n+                            }\n \n-                        if fields.len() == 0 && base.is_none() {\n-                            let last_span = self.last_span;\n-                            self.span_err(last_span,\n-                                          \"structure literal must either have at \\\n-                                          least one field or use functional \\\n-                                          structure update syntax\");\n+                            hi = self.span.hi;\n+                            self.expect(&token::RBRACE);\n+                            ex = ExprStruct(pth, fields, base);\n+                            return self.mk_expr(lo, hi, ex);\n                         }\n-\n-                        hi = self.span.hi;\n-                        self.expect(&token::RBRACE);\n-                        ex = ExprStruct(pth, fields, base);\n-                        return self.mk_expr(lo, hi, ex);\n                     }\n-                }\n \n-            hi = pth.span.hi;\n-            ex = ExprPath(pth);\n-            },\n-            _ => {\n-                // other literal expression\n-                let lit = self.parse_lit();\n-                hi = lit.span.hi;\n-                ex = ExprLit(box(GC) lit);\n+                    hi = pth.span.hi;\n+                    ex = ExprPath(pth);\n+                } else {\n+                    // other literal expression\n+                    let lit = self.parse_lit();\n+                    hi = lit.span.hi;\n+                    ex = ExprLit(box(GC) lit);\n+                }\n             }\n         }\n \n@@ -2501,37 +2516,41 @@ impl<'a> Parser<'a> {\n               }\n             };\n           }\n-          token::IDENT(_, _) if self.is_keyword(keywords::Box) => {\n-            self.bump();\n+          token::IDENT(_, _) => {\n+              if self.is_keyword(keywords::Box) {\n+                self.bump();\n \n-            // Check for a place: `box(PLACE) EXPR`.\n-            if self.eat(&token::LPAREN) {\n-                // Support `box() EXPR` as the default.\n-                if !self.eat(&token::RPAREN) {\n-                    let place = self.parse_expr();\n-                    self.expect(&token::RPAREN);\n-                    let subexpression = self.parse_prefix_expr();\n-                    hi = subexpression.span.hi;\n-                    ex = ExprBox(place, subexpression);\n-                    return self.mk_expr(lo, hi, ex);\n+                // Check for a place: `box(PLACE) EXPR`.\n+                if self.eat(&token::LPAREN) {\n+                    // Support `box() EXPR` as the default.\n+                    if !self.eat(&token::RPAREN) {\n+                        let place = self.parse_expr();\n+                        self.expect(&token::RPAREN);\n+                        let subexpression = self.parse_prefix_expr();\n+                        hi = subexpression.span.hi;\n+                        ex = ExprBox(place, subexpression);\n+                        return self.mk_expr(lo, hi, ex);\n+                    }\n                 }\n-            }\n \n-            // Otherwise, we use the unique pointer default.\n-            let subexpression = self.parse_prefix_expr();\n-            hi = subexpression.span.hi;\n-            // HACK: turn `box [...]` into a boxed-vec\n-            ex = match subexpression.node {\n-                ExprVec(..) | ExprRepeat(..) => {\n-                    let last_span = self.last_span;\n-                    self.obsolete(last_span, ObsoleteOwnedVector);\n-                    ExprVstore(subexpression, ExprVstoreUniq)\n-                }\n-                ExprLit(lit) if lit_is_str(lit) => {\n-                    ExprVstore(subexpression, ExprVstoreUniq)\n-                }\n-                _ => self.mk_unary(UnUniq, subexpression)\n-            };\n+                // Otherwise, we use the unique pointer default.\n+                let subexpression = self.parse_prefix_expr();\n+                hi = subexpression.span.hi;\n+                // HACK: turn `box [...]` into a boxed-vec\n+                ex = match subexpression.node {\n+                    ExprVec(..) | ExprRepeat(..) => {\n+                        let last_span = self.last_span;\n+                        self.obsolete(last_span, ObsoleteOwnedVector);\n+                        ExprVstore(subexpression, ExprVstoreUniq)\n+                    }\n+                    ExprLit(lit) if lit_is_str(lit) => {\n+                        ExprVstore(subexpression, ExprVstoreUniq)\n+                    }\n+                    _ => self.mk_unary(UnUniq, subexpression)\n+                };\n+              } else {\n+                return self.parse_dot_or_call_expr()\n+              }\n           }\n           _ => return self.parse_dot_or_call_expr()\n         }\n@@ -3832,17 +3851,6 @@ impl<'a> Parser<'a> {\n                 }\n                 SelfStatic\n             }\n-            token::IDENT(..) if self.is_self_ident() => {\n-                let self_ident = self.expect_self_ident();\n-\n-                // Determine whether this is the fully explicit form, `self:\n-                // TYPE`.\n-                if self.eat(&token::COLON) {\n-                    SelfExplicit(self.parse_ty(false), self_ident)\n-                } else {\n-                    SelfValue(self_ident)\n-                }\n-            }\n             token::BINOP(token::STAR) => {\n                 // Possibly \"*self\" or \"*mut self\" -- not supported. Try to avoid\n                 // emitting cryptic \"unexpected token\" errors.\n@@ -3860,30 +3868,47 @@ impl<'a> Parser<'a> {\n                 // error case, making bogus self ident:\n                 SelfValue(special_idents::self_)\n             }\n-            _ if Parser::token_is_mutability(&self.token) &&\n-                    self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) => {\n-                mutbl_self = self.parse_mutability();\n-                let self_ident = self.expect_self_ident();\n-\n-                // Determine whether this is the fully explicit form, `self:\n-                // TYPE`.\n-                if self.eat(&token::COLON) {\n-                    SelfExplicit(self.parse_ty(false), self_ident)\n+            token::IDENT(..) => {\n+                if self.is_self_ident() {\n+                    let self_ident = self.expect_self_ident();\n+\n+                    // Determine whether this is the fully explicit form, `self:\n+                    // TYPE`.\n+                    if self.eat(&token::COLON) {\n+                        SelfExplicit(self.parse_ty(false), self_ident)\n+                    } else {\n+                        SelfValue(self_ident)\n+                    }\n+                } else if Parser::token_is_mutability(&self.token) &&\n+                        self.look_ahead(1, |t| {\n+                            token::is_keyword(keywords::Self, t)\n+                        }) {\n+                    mutbl_self = self.parse_mutability();\n+                    let self_ident = self.expect_self_ident();\n+\n+                    // Determine whether this is the fully explicit form,\n+                    // `self: TYPE`.\n+                    if self.eat(&token::COLON) {\n+                        SelfExplicit(self.parse_ty(false), self_ident)\n+                    } else {\n+                        SelfValue(self_ident)\n+                    }\n+                } else if Parser::token_is_mutability(&self.token) &&\n+                        self.look_ahead(1, |t| *t == token::TILDE) &&\n+                        self.look_ahead(2, |t| {\n+                            token::is_keyword(keywords::Self, t)\n+                        }) {\n+                    mutbl_self = self.parse_mutability();\n+                    self.bump();\n+                    drop(self.expect_self_ident());\n+                    let last_span = self.last_span;\n+                    self.obsolete(last_span, ObsoleteOwnedSelf);\n+                    SelfStatic\n                 } else {\n-                    SelfValue(self_ident)\n+                    SelfStatic\n                 }\n             }\n-            _ if Parser::token_is_mutability(&self.token) &&\n-                    self.look_ahead(1, |t| *t == token::TILDE) &&\n-                    self.look_ahead(2, |t| token::is_keyword(keywords::Self, t)) => {\n-                mutbl_self = self.parse_mutability();\n-                self.bump();\n-                drop(self.expect_self_ident());\n-                let last_span = self.last_span;\n-                self.obsolete(last_span, ObsoleteOwnedSelf);\n-                SelfStatic\n-            }\n-            _ => SelfStatic\n+            _ => SelfStatic,\n         };\n \n         let explicit_self_sp = mk_sp(lo, self.span.hi);"}, {"sha": "049bec3d37bef9a4c32d3f634b7fb9141623e274", "filename": "src/test/compile-fail/borrowck-lend-flow-match.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs?ref=6635fe7db4336ef31d2b372e7bfcce01d21853e0", "patch": "@@ -11,9 +11,6 @@\n #![allow(unused_variable)]\n #![allow(dead_assignment)]\n \n-fn cond() -> bool { fail!() }\n-fn link<'a>(v: &'a uint, w: &mut &'a uint) -> bool { *w = v; true }\n-\n fn separate_arms() {\n     // Here both arms perform assignments, but only is illegal.\n \n@@ -31,28 +28,4 @@ fn separate_arms() {\n     x.clone(); // just to prevent liveness warnings\n }\n \n-fn guard() {\n-    // Here the guard performs a borrow. This borrow \"infects\" all\n-    // subsequent arms (but not the prior ones).\n-\n-    let mut a = box 3u;\n-    let mut b = box 4u;\n-    let mut w = &*a;\n-    match 22i {\n-        _ if cond() => {\n-            b = box 5u;\n-        }\n-\n-        _ if link(&*b, &mut w) => {\n-            b = box 6u; //~ ERROR cannot assign\n-        }\n-\n-        _ => {\n-            b = box 7u; //~ ERROR cannot assign\n-        }\n-    }\n-\n-    b = box 8; //~ ERROR cannot assign\n-}\n-\n fn main() {}"}, {"sha": "8a904a3b5fb89924c043826bbc17b2591921a285", "filename": "src/test/compile-fail/borrowck-mutate-in-guard.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Ftest%2Fcompile-fail%2Fborrowck-mutate-in-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Ftest%2Fcompile-fail%2Fborrowck-mutate-in-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mutate-in-guard.rs?ref=6635fe7db4336ef31d2b372e7bfcce01d21853e0", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Enum<'a> {\n+    A(&'a int),\n+    B(bool),\n+}\n+\n+fn foo() -> int {\n+    let mut n = 42;\n+    let mut x = A(&mut n);\n+    match x {\n+        A(_) if { x = B(false); false } => 1,\n+        //~^ ERROR cannot assign in a pattern guard\n+        A(_) if { let y = &mut x; *y = B(false); false } => 1,\n+        //~^ ERROR cannot mutably borrow in a pattern guard\n+        //~^^ ERROR cannot assign in a pattern guard\n+        A(p) => *p,\n+        B(_) => 2,\n+    }\n+}\n+\n+fn main() {\n+    foo();\n+}\n+"}, {"sha": "f0907d8d708f2d51abaf72db6a48cfe5313b773c", "filename": "src/test/run-make/graphviz-flowgraph/f07.dot-expected.dot", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot?ref=6635fe7db4336ef31d2b372e7bfcce01d21853e0", "patch": "@@ -7,14 +7,15 @@ digraph block {\n     N5[label=\"expr 7777i\"];\n     N6[label=\"expr [7i, 77i, 777i, 7777i]\"];\n     N7[label=\"expr match [7i, 77i, 777i, 7777i] { [x, y, ..] => x + y }\"];\n-    N8[label=\"local x\"];\n-    N9[label=\"local y\"];\n-    N10[label=\"pat ..\"];\n-    N11[label=\"pat [x, y, ..]\"];\n-    N12[label=\"expr x\"];\n-    N13[label=\"expr y\"];\n-    N14[label=\"expr x + y\"];\n-    N15[label=\"block { match [7i, 77i, 777i, 7777i] { [x, y, ..] => x + y }; }\"];\n+    N8[label=\"(dummy_node)\"];\n+    N9[label=\"local x\"];\n+    N10[label=\"local y\"];\n+    N11[label=\"pat ..\"];\n+    N12[label=\"pat [x, y, ..]\"];\n+    N13[label=\"expr x\"];\n+    N14[label=\"expr y\"];\n+    N15[label=\"expr x + y\"];\n+    N16[label=\"block { match [7i, 77i, 777i, 7777i] { [x, y, ..] => x + y }; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -27,7 +28,8 @@ digraph block {\n     N11 -> N12;\n     N12 -> N13;\n     N13 -> N14;\n-    N14 -> N7;\n-    N7 -> N15;\n-    N15 -> N1;\n+    N14 -> N15;\n+    N15 -> N7;\n+    N7 -> N16;\n+    N16 -> N1;\n }"}, {"sha": "dbfa4dd6fe92c3208a4084b40836ddba91743249", "filename": "src/test/run-make/graphviz-flowgraph/f13.dot-expected.dot", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/6635fe7db4336ef31d2b372e7bfcce01d21853e0/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot?ref=6635fe7db4336ef31d2b372e7bfcce01d21853e0", "patch": "@@ -8,18 +8,20 @@ digraph block {\n     N6[label=\"local _y\"];\n     N7[label=\"expr x\"];\n     N8[label=\"expr match x { E13a => _y = 1, E13b(v) => _y = v + 1 }\"];\n-    N9[label=\"local E13a\"];\n-    N10[label=\"expr 1\"];\n-    N11[label=\"expr _y\"];\n-    N12[label=\"expr _y = 1\"];\n-    N13[label=\"local v\"];\n-    N14[label=\"pat E13b(v)\"];\n-    N15[label=\"expr v\"];\n-    N16[label=\"expr 1\"];\n-    N17[label=\"expr v + 1\"];\n-    N18[label=\"expr _y\"];\n-    N19[label=\"expr _y = v + 1\"];\n-    N20[label=\"block {\\l    let x = E13b(13);\\l    let _y;\\l    match x { E13a => _y = 1, E13b(v) => _y = v + 1 }\\l}\\l\"];\n+    N9[label=\"(dummy_node)\"];\n+    N10[label=\"local E13a\"];\n+    N11[label=\"expr 1\"];\n+    N12[label=\"expr _y\"];\n+    N13[label=\"expr _y = 1\"];\n+    N14[label=\"(dummy_node)\"];\n+    N15[label=\"local v\"];\n+    N16[label=\"pat E13b(v)\"];\n+    N17[label=\"expr v\"];\n+    N18[label=\"expr 1\"];\n+    N19[label=\"expr v + 1\"];\n+    N20[label=\"expr _y\"];\n+    N21[label=\"expr _y = v + 1\"];\n+    N22[label=\"block {\\l    let x = E13b(13);\\l    let _y;\\l    match x { E13a => _y = 1, E13b(v) => _y = v + 1 }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;\n@@ -30,15 +32,17 @@ digraph block {\n     N9 -> N10;\n     N10 -> N11;\n     N11 -> N12;\n-    N12 -> N8;\n-    N7 -> N13;\n-    N13 -> N14;\n+    N12 -> N13;\n+    N13 -> N8;\n+    N9 -> N14;\n     N14 -> N15;\n     N15 -> N16;\n     N16 -> N17;\n     N17 -> N18;\n     N18 -> N19;\n-    N19 -> N8;\n-    N8 -> N20;\n-    N20 -> N1;\n+    N19 -> N20;\n+    N20 -> N21;\n+    N21 -> N8;\n+    N8 -> N22;\n+    N22 -> N1;\n }"}]}