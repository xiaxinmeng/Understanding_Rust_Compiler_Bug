{"sha": "754aaea88c5f2899e628a54fed4643384219da29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1NGFhZWE4OGM1ZjI4OTllNjI4YTU0ZmVkNDY0MzM4NDIxOWRhMjk=", "commit": {"author": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-07-08T19:27:32Z"}, "committer": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-07-08T19:38:19Z"}, "message": "Remove snake_case names from ty.rs", "tree": {"sha": "f31689d5aa47072bde18957a46ee95fcdac0db22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f31689d5aa47072bde18957a46ee95fcdac0db22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/754aaea88c5f2899e628a54fed4643384219da29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/754aaea88c5f2899e628a54fed4643384219da29", "html_url": "https://github.com/rust-lang/rust/commit/754aaea88c5f2899e628a54fed4643384219da29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/754aaea88c5f2899e628a54fed4643384219da29/comments", "author": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d53921eff41f54586c370be1a72cb1b82d17e6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d53921eff41f54586c370be1a72cb1b82d17e6d", "html_url": "https://github.com/rust-lang/rust/commit/5d53921eff41f54586c370be1a72cb1b82d17e6d"}], "stats": {"total": 562, "additions": 277, "deletions": 285}, "files": [{"sha": "2a469ed69ef9a5b29b849ffda4b5f3c891c8a583", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -197,7 +197,7 @@ pub fn get_item_attrs(cstore: &cstore::CStore,\n \n pub fn get_struct_fields(cstore: &cstore::CStore,\n                          def: ast::DefId)\n-                      -> Vec<ty::field_ty> {\n+                      -> Vec<ty::FieldTy> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_struct_fields(cstore.intr.clone(), &*cdata, def.node)\n }"}, {"sha": "5ab22676ce051d8dcd3d96beffc3172bafb0ba1e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -1049,7 +1049,7 @@ fn struct_field_family_to_visibility(family: Family) -> ast::Visibility {\n }\n \n pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n-    -> Vec<ty::field_ty> {\n+    -> Vec<ty::FieldTy> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n     reader::tagged_docs(item, tag_item_field).filter_map(|an_item| {\n@@ -1059,7 +1059,7 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n             let did = item_def_id(an_item, cdata);\n             let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n             let origin_id =  translated_def_id(cdata, tagdoc);\n-            Some(ty::field_ty {\n+            Some(ty::FieldTy {\n                 name: name,\n                 id: did,\n                 vis: struct_field_family_to_visibility(f),\n@@ -1073,7 +1073,7 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n         let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n         let f = item_family(an_item);\n         let origin_id =  translated_def_id(cdata, tagdoc);\n-        ty::field_ty {\n+        ty::FieldTy {\n             name: special_idents::unnamed_field.name,\n             id: did,\n             vis: struct_field_family_to_visibility(f),"}, {"sha": "67ea3b2efb157b34e5f2c09365630284ea16a48b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -267,7 +267,7 @@ fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n }\n \n fn encode_struct_fields(rbml_w: &mut Encoder,\n-                        fields: &[ty::field_ty],\n+                        fields: &[ty::FieldTy],\n                         origin: DefId) {\n     for f in fields {\n         if f.name == special_idents::unnamed_field.name {\n@@ -636,7 +636,7 @@ fn encode_provided_source(rbml_w: &mut Encoder,\n /* Returns an index of items in this class */\n fn encode_info_for_struct(ecx: &EncodeContext,\n                           rbml_w: &mut Encoder,\n-                          fields: &[ty::field_ty],\n+                          fields: &[ty::FieldTy],\n                           global_index: &mut Vec<entry<i64>>)\n                           -> Vec<entry<i64>> {\n     /* Each class has its own index, since different classes"}, {"sha": "930f86a93cbaa7437d3885ef3968468b47562f2d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -525,7 +525,7 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n         assert_eq!(next(st), ':');\n         let len = parse_hex(st);\n         assert_eq!(next(st), '#');\n-        let key = ty::creader_cache_key {cnum: st.krate,\n+        let key = ty::CReaderCacheKey {cnum: st.krate,\n                                          pos: pos,\n                                          len: len };\n \n@@ -587,11 +587,11 @@ fn parse_mutability(st: &mut PState) -> ast::Mutability {\n     }\n }\n \n-fn parse_mt_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> ty::mt<'tcx> where\n+fn parse_mt_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> ty::TypeWithMutability<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     let m = parse_mutability(st);\n-    ty::mt { ty: parse_ty_(st, conv), mutbl: m }\n+    ty::TypeWithMutability { ty: parse_ty_(st, conv), mutbl: m }\n }\n \n fn parse_def_<F>(st: &mut PState, source: DefIdSource, conv: &mut F) -> ast::DefId where"}, {"sha": "865af4239b6b1b11ab5958a2326f3782a4193757", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -183,7 +183,7 @@ fn enc_mutability(w: &mut Encoder, mt: ast::Mutability) {\n }\n \n fn enc_mt<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n-                    mt: ty::mt<'tcx>) {\n+                    mt: ty::TypeWithMutability<'tcx>) {\n     enc_mutability(w, mt.mutbl);\n     enc_ty(w, cx, mt.ty);\n }"}, {"sha": "ad2ec37c2122a5a24d3617a10148644676c41cfc", "filename": "src/librustc/middle/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcast.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -36,9 +36,9 @@ pub enum CastTy<'tcx> {\n     /// Function Pointers\n     FnPtr,\n     /// Raw pointers\n-    Ptr(&'tcx ty::mt<'tcx>),\n+    Ptr(&'tcx ty::TypeWithMutability<'tcx>),\n     /// References\n-    RPtr(&'tcx ty::mt<'tcx>),\n+    RPtr(&'tcx ty::TypeWithMutability<'tcx>),\n }\n \n /// Cast Kind. See RFC 401 (or librustc_typeck/check/cast.rs)"}, {"sha": "339fecf8f8b235bc0cc3062887410cedbd1ceb37", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -535,7 +535,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n             }\n         }\n \n-        ty::TyRef(_, ty::mt { ty, mutbl }) => {\n+        ty::TyRef(_, ty::TypeWithMutability { ty, mutbl }) => {\n             match ty.sty {\n                ty::TyArray(_, n) => match ctor {\n                     &Single => {\n@@ -600,7 +600,7 @@ fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n \n-        ty::TyRef(_, ty::mt { ty, .. }) => match ty.sty {\n+        ty::TyRef(_, ty::TypeWithMutability { ty, .. }) => match ty.sty {\n             ty::TySlice(_) =>\n                 range_inclusive(0, max_slice_length).map(|length| Slice(length)).collect(),\n             _ => vec!(Single)\n@@ -808,7 +808,7 @@ pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usi\n     match ty.sty {\n         ty::TyTuple(ref fs) => fs.len(),\n         ty::TyBox(_) => 1,\n-        ty::TyRef(_, ty::mt { ty, .. }) => match ty.sty {\n+        ty::TyRef(_, ty::TypeWithMutability { ty, .. }) => match ty.sty {\n             ty::TySlice(_) => match *ctor {\n                 Slice(length) => length,\n                 ConstantValue(_) => 0,"}, {"sha": "54fc2daff2b8e55165f147b11e093f9d07669967", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -720,7 +720,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         // are properly handled.\n         self.walk_expr(with_expr);\n \n-        fn contains_field_named(field: &ty::field,\n+        fn contains_field_named(field: &ty::Field,\n                                 fields: &Vec<ast::Field>)\n                                 -> bool\n         {"}, {"sha": "197e90c20a0a0fc4b3545a01f05988a2a261eb2d", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n \n             ty::TyArray(t, _) |\n             ty::TySlice(t) |\n-            ty::TyRawPtr(ty::mt { ty: t, .. }) |\n+            ty::TyRawPtr(ty::TypeWithMutability { ty: t, .. }) |\n             ty::TyBox(t) => {\n                 self.accumulate_from_ty(t)\n             }"}, {"sha": "abc75720ee94fc61012855bf496bfa1550d7a08b", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -108,7 +108,7 @@ pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n         // All other cases of inference are errors\n         (&ty::TyInfer(_), _) |\n         (_, &ty::TyInfer(_)) => {\n-            Err(ty::terr_sorts(ty_relate::expected_found(relation, &a, &b)))\n+            Err(ty::Sorts(ty_relate::expected_found(relation, &a, &b)))\n         }\n \n \n@@ -278,7 +278,7 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n         };\n         let u = ty.fold_with(&mut generalize);\n         if generalize.cycle_detected {\n-            Err(ty::terr_cyclic_ty)\n+            Err(ty::CyclicTy)\n         } else {\n             Ok(u)\n         }\n@@ -363,12 +363,12 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n \n pub trait RelateResultCompare<'tcx, T> {\n     fn compare<F>(&self, t: T, f: F) -> RelateResult<'tcx, T> where\n-        F: FnOnce() -> ty::type_err<'tcx>;\n+        F: FnOnce() -> ty::TypeError<'tcx>;\n }\n \n impl<'tcx, T:Clone + PartialEq> RelateResultCompare<'tcx, T> for RelateResult<'tcx, T> {\n     fn compare<F>(&self, t: T, f: F) -> RelateResult<'tcx, T> where\n-        F: FnOnce() -> ty::type_err<'tcx>,\n+        F: FnOnce() -> ty::TypeError<'tcx>,\n     {\n         self.clone().and_then(|s| {\n             if s == t {\n@@ -381,16 +381,16 @@ impl<'tcx, T:Clone + PartialEq> RelateResultCompare<'tcx, T> for RelateResult<'t\n }\n \n fn int_unification_error<'tcx>(a_is_expected: bool, v: (ty::IntVarValue, ty::IntVarValue))\n-                               -> ty::type_err<'tcx>\n+                               -> ty::TypeError<'tcx>\n {\n     let (a, b) = v;\n-    ty::terr_int_mismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n+    ty::IntMismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n }\n \n fn float_unification_error<'tcx>(a_is_expected: bool,\n                                  v: (ast::FloatTy, ast::FloatTy))\n-                                 -> ty::type_err<'tcx>\n+                                 -> ty::TypeError<'tcx>\n {\n     let (a, b) = v;\n-    ty::terr_float_mismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n+    ty::FloatMismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n }"}, {"sha": "432c5bc14041631f0c63d9a82f3ec1ada1307161", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -220,17 +220,17 @@ pub trait ErrorReporting<'tcx> {\n     fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n                       -> Vec<RegionResolutionError<'tcx>>;\n \n-    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::type_err<'tcx>);\n+    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::TypeError<'tcx>);\n \n     fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace<'tcx>,\n-                                     terr: &ty::type_err<'tcx>);\n+                                     terr: &ty::TypeError<'tcx>);\n \n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String>;\n \n     fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + HasTypeFlags>(\n         &self,\n-        exp_found: &ty::expected_found<T>)\n+        exp_found: &ty::ExpectedFound<T>)\n         -> Option<String>;\n \n     fn report_concrete_failure(&self,\n@@ -260,7 +260,7 @@ pub trait ErrorReporting<'tcx> {\n \n     fn report_processed_errors(&self,\n                                var_origin: &[RegionVariableOrigin],\n-                               trace_origin: &[(TypeTrace<'tcx>, ty::type_err<'tcx>)],\n+                               trace_origin: &[(TypeTrace<'tcx>, ty::TypeError<'tcx>)],\n                                same_regions: &[SameRegions]);\n \n     fn give_suggestion(&self, same_regions: &[SameRegions]);\n@@ -351,7 +351,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     match free_regions_from_same_fn(self.tcx, sub, sup) {\n                         Some(ref same_frs) if trace.is_some() => {\n                             let trace = trace.unwrap();\n-                            let terr = ty::terr_regions_does_not_outlive(sup,\n+                            let terr = ty::RegionsDoesNotOutlive(sup,\n                                                                          sub);\n                             trace_origins.push((trace, terr));\n                             append_to_same_regions(&mut same_regions, same_frs);\n@@ -467,7 +467,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::type_err<'tcx>) {\n+    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::TypeError<'tcx>) {\n         let expected_found_str = match self.values_str(&trace.values) {\n             Some(v) => v,\n             None => {\n@@ -490,7 +490,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace<'tcx>,\n-                                     terr: &ty::type_err<'tcx>) {\n+                                     terr: &ty::TypeError<'tcx>) {\n         let span = trace.origin.span();\n         self.report_type_error(trace, terr);\n         self.tcx.note_and_explain_type_err(terr, span);\n@@ -508,7 +508,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + HasTypeFlags>(\n         &self,\n-        exp_found: &ty::expected_found<T>)\n+        exp_found: &ty::ExpectedFound<T>)\n         -> Option<String>\n     {\n         let expected = exp_found.expected.resolve(self);\n@@ -595,7 +595,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         match origin {\n             infer::Subtype(trace) |\n             infer::DefaultExistentialBound(trace) => {\n-                let terr = ty::terr_regions_does_not_outlive(sup, sub);\n+                let terr = ty::RegionsDoesNotOutlive(sup, sub);\n                 self.report_and_explain_type_error(trace, &terr);\n             }\n             infer::Reborrow(span) => {\n@@ -888,7 +888,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn report_processed_errors(&self,\n                                var_origins: &[RegionVariableOrigin],\n-                               trace_origins: &[(TypeTrace<'tcx>, ty::type_err<'tcx>)],\n+                               trace_origins: &[(TypeTrace<'tcx>, ty::TypeError<'tcx>)],\n                                same_regions: &[SameRegions]) {\n         for vo in var_origins {\n             self.report_inference_failure(vo.clone());"}, {"sha": "ec3d4012c0c166fae3d73d7653cc30e9ff9f0e61", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -85,11 +85,11 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                 Err((skol_br, tainted_region)) => {\n                     if self.a_is_expected {\n                         debug!(\"Not as polymorphic!\");\n-                        return Err(ty::terr_regions_insufficiently_polymorphic(skol_br,\n+                        return Err(ty::RegionsInsufficientlyPolymorphic(skol_br,\n                                                                                tainted_region));\n                     } else {\n                         debug!(\"Overly polymorphic!\");\n-                        return Err(ty::terr_regions_overly_polymorphic(skol_br,\n+                        return Err(ty::RegionsOverlyPolymorphic(skol_br,\n                                                                        tainted_region));\n                     }\n                 }"}, {"sha": "3175146ea7f281cecba138d37914502cfdc3978c", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -171,9 +171,9 @@ impl fmt::Display for TypeOrigin {\n /// See `error_reporting.rs` for more details\n #[derive(Clone, Debug)]\n pub enum ValuePairs<'tcx> {\n-    Types(ty::expected_found<Ty<'tcx>>),\n-    TraitRefs(ty::expected_found<ty::TraitRef<'tcx>>),\n-    PolyTraitRefs(ty::expected_found<ty::PolyTraitRef<'tcx>>),\n+    Types(ty::ExpectedFound<Ty<'tcx>>),\n+    TraitRefs(ty::ExpectedFound<ty::TraitRef<'tcx>>),\n+    PolyTraitRefs(ty::ExpectedFound<ty::PolyTraitRef<'tcx>>),\n }\n \n /// The trace designates the path through inference that we took to\n@@ -460,12 +460,12 @@ pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n fn expected_found<T>(a_is_expected: bool,\n                      a: T,\n                      b: T)\n-                     -> ty::expected_found<T>\n+                     -> ty::ExpectedFound<T>\n {\n     if a_is_expected {\n-        ty::expected_found {expected: a, found: b}\n+        ty::ExpectedFound {expected: a, found: b}\n     } else {\n-        ty::expected_found {expected: b, found: a}\n+        ty::ExpectedFound {expected: b, found: a}\n     }\n }\n \n@@ -913,7 +913,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         match higher_ranked::leak_check(self, skol_map, snapshot) {\n             Ok(()) => Ok(()),\n-            Err((br, r)) => Err(ty::terr_regions_insufficiently_polymorphic(br, r))\n+            Err((br, r)) => Err(ty::RegionsInsufficientlyPolymorphic(br, r))\n         }\n     }\n \n@@ -1198,7 +1198,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                      sp: Span,\n                                      mk_msg: M,\n                                      actual_ty: String,\n-                                     err: Option<&ty::type_err<'tcx>>) where\n+                                     err: Option<&ty::TypeError<'tcx>>) where\n         M: FnOnce(Option<String>, String) -> String,\n     {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n@@ -1209,7 +1209,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                    mk_msg: M,\n                                                    expected_ty: Option<Ty<'tcx>>,\n                                                    actual_ty: String,\n-                                                   err: Option<&ty::type_err<'tcx>>) where\n+                                                   err: Option<&ty::TypeError<'tcx>>) where\n         M: FnOnce(Option<String>, String) -> String,\n     {\n         debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n@@ -1235,7 +1235,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                  sp: Span,\n                                  mk_msg: M,\n                                  actual_ty: Ty<'tcx>,\n-                                 err: Option<&ty::type_err<'tcx>>) where\n+                                 err: Option<&ty::TypeError<'tcx>>) where\n         M: FnOnce(String) -> String,\n     {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n@@ -1254,10 +1254,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                    span: Span,\n                                    expected: Ty<'tcx>,\n                                    actual: Ty<'tcx>,\n-                                   err: &ty::type_err<'tcx>) {\n+                                   err: &ty::TypeError<'tcx>) {\n         let trace = TypeTrace {\n             origin: Misc(span),\n-            values: Types(ty::expected_found {\n+            values: Types(ty::ExpectedFound {\n                 expected: expected,\n                 found: actual\n             })\n@@ -1431,7 +1431,7 @@ impl<'tcx> TypeTrace<'tcx> {\n     pub fn dummy(tcx: &ty::ctxt<'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n-            values: Types(ty::expected_found {\n+            values: Types(ty::ExpectedFound {\n                 expected: tcx.types.err,\n                 found: tcx.types.err,\n             })"}, {"sha": "17168bb7fa6c7133a2eea0375ec98d0134da73b9", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -133,7 +133,7 @@ pub enum RegionResolutionError<'tcx> {\n     /// should put a lifetime. In those cases we process and put those errors\n     /// into `ProcessedErrors` before we do any reporting.\n     ProcessedErrors(Vec<RegionVariableOrigin>,\n-                    Vec<(TypeTrace<'tcx>, ty::type_err<'tcx>)>,\n+                    Vec<(TypeTrace<'tcx>, ty::TypeError<'tcx>)>,\n                     Vec<SameRegions>),\n }\n \n@@ -873,7 +873,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 if self.tcx.region_maps.nearest_common_ancestor(fr_scope, s_id) == fr_scope {\n                     Ok(s)\n                 } else {\n-                    Err(ty::terr_regions_no_overlap(b, a))\n+                    Err(ty::RegionsNoOverlap(b, a))\n                 }\n             }\n \n@@ -892,7 +892,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 if a == b {\n                     Ok(a)\n                 } else {\n-                    Err(ty::terr_regions_no_overlap(b, a))\n+                    Err(ty::RegionsNoOverlap(b, a))\n                 }\n             }\n         }\n@@ -949,7 +949,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         } else if r_id == scope_b {\n             Ok(ReScope(scope_a))\n         } else {\n-            Err(ty::terr_regions_no_overlap(region_a, region_b))\n+            Err(ty::RegionsNoOverlap(region_a, region_b))\n         }\n     }\n }"}, {"sha": "a25c45283f2afbe595ce38c3e4b0460913c9726b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -1614,7 +1614,7 @@ impl fmt::Debug for InteriorKind {\n \n fn element_kind(t: Ty) -> ElementKind {\n     match t.sty {\n-        ty::TyRef(_, ty::mt{ty, ..}) |\n+        ty::TyRef(_, ty::TypeWithMutability{ty, ..}) |\n         ty::TyBox(ty) => match ty.sty {\n             ty::TySlice(_) => VecElement,\n             _ => OtherElement"}, {"sha": "148b27adf64b241c475e3b84a6223767879c8a8e", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -155,7 +155,7 @@ pub enum SelectionError<'tcx> {\n     Unimplemented,\n     OutputTypeParameterMismatch(ty::PolyTraitRef<'tcx>,\n                                 ty::PolyTraitRef<'tcx>,\n-                                ty::type_err<'tcx>),\n+                                ty::TypeError<'tcx>),\n     TraitNotObjectSafe(ast::DefId),\n }\n "}, {"sha": "cd38e9d0d31bc529a6559d8b51cb23ae5142b4bf", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -51,7 +51,7 @@ pub enum ProjectionTyError<'tcx> {\n \n #[derive(Clone)]\n pub struct MismatchedProjectionTypes<'tcx> {\n-    pub err: ty::type_err<'tcx>\n+    pub err: ty::TypeError<'tcx>\n }\n \n #[derive(PartialEq, Eq, Debug)]"}, {"sha": "9926165d7e193951a1f230418153ebba69d51a28", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -1659,7 +1659,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::TyRef(_, ty::mt { ty: _, mutbl }) => {\n+            ty::TyRef(_, ty::TypeWithMutability { ty: _, mutbl }) => {\n                 // &mut T or &T\n                 match bound {\n                     ty::BoundCopy => {\n@@ -1851,8 +1851,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Some(vec![referent_ty])\n             }\n \n-            ty::TyRawPtr(ty::mt { ty: element_ty, ..}) |\n-            ty::TyRef(_, ty::mt { ty: element_ty, ..}) => {\n+            ty::TyRawPtr(ty::TypeWithMutability { ty: element_ty, ..}) |\n+            ty::TyRef(_, ty::TypeWithMutability { ty: element_ty, ..}) => {\n                 Some(vec![element_ty])\n             },\n "}, {"sha": "889615917cf75e37b07c5087278eb3bd6e68537f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 100, "deletions": 108, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME: (@jroesch) @eddyb should remove this when he renames ctxt\n #![allow(non_camel_case_types)]\n \n-pub use self::terr_vstore_kind::*;\n-pub use self::type_err::*;\n+pub use self::TypeError::*;\n pub use self::InferTy::*;\n pub use self::InferRegion::*;\n pub use self::ImplOrTraitItemId::*;\n@@ -109,9 +109,9 @@ pub struct CrateAnalysis {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct field<'tcx> {\n+pub struct Field<'tcx> {\n     pub name: ast::Name,\n-    pub mt: mt<'tcx>\n+    pub mt: TypeWithMutability<'tcx>\n }\n \n \n@@ -488,13 +488,13 @@ pub struct AssociatedType<'tcx> {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub struct mt<'tcx> {\n+pub struct TypeWithMutability<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub mutbl: ast::Mutability,\n }\n \n #[derive(Clone, Copy, Debug)]\n-pub struct field_ty {\n+pub struct FieldTy {\n     pub name: Name,\n     pub id: DefId,\n     pub vis: ast::Visibility,\n@@ -674,7 +674,7 @@ pub type MethodMap<'tcx> = FnvHashMap<MethodCall, MethodCallee<'tcx>>;\n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct creader_cache_key {\n+pub struct CReaderCacheKey {\n     pub cnum: CrateNum,\n     pub pos: usize,\n     pub len: usize\n@@ -864,7 +864,7 @@ pub struct ctxt<'tcx> {\n     pub map: ast_map::Map<'tcx>,\n     pub freevars: RefCell<FreevarMap>,\n     pub tcache: RefCell<DefIdMap<TypeScheme<'tcx>>>,\n-    pub rcache: RefCell<FnvHashMap<creader_cache_key, Ty<'tcx>>>,\n+    pub rcache: RefCell<FnvHashMap<CReaderCacheKey, Ty<'tcx>>>,\n     pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, TypeContents>>,\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n     pub enum_var_cache: RefCell<DefIdMap<Rc<Vec<Rc<VariantInfo<'tcx>>>>>>,\n@@ -873,7 +873,7 @@ pub struct ctxt<'tcx> {\n     pub lang_items: middle::lang_items::LanguageItems,\n     /// A mapping of fake provided method def_ids to the default implementation\n     pub provided_method_sources: RefCell<DefIdMap<ast::DefId>>,\n-    pub struct_fields: RefCell<DefIdMap<Rc<Vec<field_ty>>>>,\n+    pub struct_fields: RefCell<DefIdMap<Rc<Vec<FieldTy>>>>,\n \n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n@@ -1747,11 +1747,11 @@ pub enum TypeVariants<'tcx> {\n     TySlice(Ty<'tcx>),\n \n     /// A raw pointer. Written as `*mut T` or `*const T`\n-    TyRawPtr(mt<'tcx>),\n+    TyRawPtr(TypeWithMutability<'tcx>),\n \n     /// A reference; a pointer with an associated lifetime. Written as\n     /// `&a mut T` or `&'a T`.\n-    TyRef(&'tcx Region, mt<'tcx>),\n+    TyRef(&'tcx Region, TypeWithMutability<'tcx>),\n \n     /// If the def-id is Some(_), then this is the type of a specific\n     /// fn item. Otherwise, if None(_), it a fn pointer type.\n@@ -1945,50 +1945,42 @@ pub enum IntVarValue {\n }\n \n #[derive(Clone, Copy, Debug)]\n-pub enum terr_vstore_kind {\n-    terr_vec,\n-    terr_str,\n-    terr_fn,\n-    terr_trait\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-pub struct expected_found<T> {\n+pub struct ExpectedFound<T> {\n     pub expected: T,\n     pub found: T\n }\n \n // Data structures used in type unification\n #[derive(Clone, Copy, Debug)]\n-pub enum type_err<'tcx> {\n-    terr_mismatch,\n-    terr_unsafety_mismatch(expected_found<ast::Unsafety>),\n-    terr_abi_mismatch(expected_found<abi::Abi>),\n-    terr_mutability,\n-    terr_box_mutability,\n-    terr_ptr_mutability,\n-    terr_ref_mutability,\n-    terr_vec_mutability,\n-    terr_tuple_size(expected_found<usize>),\n-    terr_fixed_array_size(expected_found<usize>),\n-    terr_ty_param_size(expected_found<usize>),\n-    terr_arg_count,\n-    terr_regions_does_not_outlive(Region, Region),\n-    terr_regions_not_same(Region, Region),\n-    terr_regions_no_overlap(Region, Region),\n-    terr_regions_insufficiently_polymorphic(BoundRegion, Region),\n-    terr_regions_overly_polymorphic(BoundRegion, Region),\n-    terr_sorts(expected_found<Ty<'tcx>>),\n-    terr_integer_as_char,\n-    terr_int_mismatch(expected_found<IntVarValue>),\n-    terr_float_mismatch(expected_found<ast::FloatTy>),\n-    terr_traits(expected_found<ast::DefId>),\n-    terr_builtin_bounds(expected_found<BuiltinBounds>),\n-    terr_variadic_mismatch(expected_found<bool>),\n-    terr_cyclic_ty,\n-    terr_convergence_mismatch(expected_found<bool>),\n-    terr_projection_name_mismatched(expected_found<ast::Name>),\n-    terr_projection_bounds_length(expected_found<usize>),\n+pub enum TypeError<'tcx> {\n+    Mismatch,\n+    UnsafetyMismatch(ExpectedFound<ast::Unsafety>),\n+    AbiMismatch(ExpectedFound<abi::Abi>),\n+    Mutability,\n+    BoxMutability,\n+    PtrMutability,\n+    RefMutability,\n+    VecMutability,\n+    TupleSize(ExpectedFound<usize>),\n+    FixedArraySize(ExpectedFound<usize>),\n+    TyParamSize(ExpectedFound<usize>),\n+    ArgCount,\n+    RegionsDoesNotOutlive(Region, Region),\n+    RegionsNotSame(Region, Region),\n+    RegionsNoOverlap(Region, Region),\n+    RegionsInsufficientlyPolymorphic(BoundRegion, Region),\n+    RegionsOverlyPolymorphic(BoundRegion, Region),\n+    Sorts(ExpectedFound<Ty<'tcx>>),\n+    IntegerAsChar,\n+    IntMismatch(ExpectedFound<IntVarValue>),\n+    FloatMismatch(ExpectedFound<ast::FloatTy>),\n+    Traits(ExpectedFound<ast::DefId>),\n+    BuiltinBoundsMismatch(ExpectedFound<BuiltinBounds>),\n+    VariadicMismatch(ExpectedFound<bool>),\n+    CyclicTy,\n+    ConvergenceMismatch(ExpectedFound<bool>),\n+    ProjectionNameMismatched(ExpectedFound<ast::Name>),\n+    ProjectionBoundsLength(ExpectedFound<usize>),\n }\n \n /// Bounds suitable for an existentially quantified type parameter\n@@ -3573,28 +3565,28 @@ impl<'tcx> ctxt<'tcx> {\n         self.mk_ty(TyBox(ty))\n     }\n \n-    pub fn mk_ptr(&self, tm: mt<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_ptr(&self, tm: TypeWithMutability<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TyRawPtr(tm))\n     }\n \n-    pub fn mk_ref(&self, r: &'tcx Region, tm: mt<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_ref(&self, r: &'tcx Region, tm: TypeWithMutability<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TyRef(r, tm))\n     }\n \n     pub fn mk_mut_ref(&self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, mt {ty: ty, mutbl: ast::MutMutable})\n+        self.mk_ref(r, TypeWithMutability {ty: ty, mutbl: ast::MutMutable})\n     }\n \n     pub fn mk_imm_ref(&self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, mt {ty: ty, mutbl: ast::MutImmutable})\n+        self.mk_ref(r, TypeWithMutability {ty: ty, mutbl: ast::MutImmutable})\n     }\n \n     pub fn mk_mut_ptr(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(mt {ty: ty, mutbl: ast::MutMutable})\n+        self.mk_ptr(TypeWithMutability {ty: ty, mutbl: ast::MutMutable})\n     }\n \n     pub fn mk_imm_ptr(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(mt {ty: ty, mutbl: ast::MutImmutable})\n+        self.mk_ptr(TypeWithMutability {ty: ty, mutbl: ast::MutImmutable})\n     }\n \n     pub fn mk_nil_ptr(&self) -> Ty<'tcx> {\n@@ -4278,7 +4270,7 @@ impl<'tcx> TyS<'tcx> {\n         }\n \n         fn tc_mt<'tcx>(cx: &ctxt<'tcx>,\n-                       mt: mt<'tcx>,\n+                       mt: TypeWithMutability<'tcx>,\n                        cache: &mut FnvHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n         {\n             let mc = TC::ReachesMutable.when(mt.mutbl == MutMutable);\n@@ -4350,11 +4342,11 @@ impl<'tcx> TyS<'tcx> {\n         // Fast-path for primitive types\n         let result = match self.sty {\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n-            TyRawPtr(..) | TyBareFn(..) | TyRef(_, mt {\n+            TyRawPtr(..) | TyBareFn(..) | TyRef(_, TypeWithMutability {\n                 mutbl: ast::MutImmutable, ..\n             }) => Some(false),\n \n-            TyStr | TyBox(..) | TyRef(_, mt {\n+            TyStr | TyBox(..) | TyRef(_, TypeWithMutability {\n                 mutbl: ast::MutMutable, ..\n             }) => Some(true),\n \n@@ -4789,10 +4781,10 @@ impl<'tcx> TyS<'tcx> {\n     //\n     // The parameter `explicit` indicates if this is an *explicit* dereference.\n     // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n-    pub fn builtin_deref(&self, explicit: bool) -> Option<mt<'tcx>> {\n+    pub fn builtin_deref(&self, explicit: bool) -> Option<TypeWithMutability<'tcx>> {\n         match self.sty {\n             TyBox(ty) => {\n-                Some(mt {\n+                Some(TypeWithMutability {\n                     ty: ty,\n                     mutbl: ast::MutImmutable,\n                 })\n@@ -4931,10 +4923,10 @@ impl<'tcx> TyS<'tcx> {\n         match autoref {\n             None => self,\n             Some(AutoPtr(r, m)) => {\n-                cx.mk_ref(r, mt { ty: self, mutbl: m })\n+                cx.mk_ref(r, TypeWithMutability { ty: self, mutbl: m })\n             }\n             Some(AutoUnsafe(m)) => {\n-                cx.mk_ptr(mt { ty: self, mutbl: m })\n+                cx.mk_ptr(TypeWithMutability { ty: self, mutbl: m })\n             }\n         }\n     }\n@@ -4983,67 +4975,67 @@ impl<'tcx> TyS<'tcx> {\n /// in parentheses after some larger message. You should also invoke `note_and_explain_type_err()`\n /// afterwards to present additional details, particularly when it comes to lifetime-related\n /// errors.\n-impl<'tcx> fmt::Display for type_err<'tcx> {\n+impl<'tcx> fmt::Display for TypeError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            terr_cyclic_ty => write!(f, \"cyclic type of infinite size\"),\n-            terr_mismatch => write!(f, \"types differ\"),\n-            terr_unsafety_mismatch(values) => {\n+            CyclicTy => write!(f, \"cyclic type of infinite size\"),\n+            Mismatch => write!(f, \"types differ\"),\n+            UnsafetyMismatch(values) => {\n                 write!(f, \"expected {} fn, found {} fn\",\n                        values.expected,\n                        values.found)\n             }\n-            terr_abi_mismatch(values) => {\n+            AbiMismatch(values) => {\n                 write!(f, \"expected {} fn, found {} fn\",\n                        values.expected,\n                        values.found)\n             }\n-            terr_mutability => write!(f, \"values differ in mutability\"),\n-            terr_box_mutability => {\n+            Mutability => write!(f, \"values differ in mutability\"),\n+            BoxMutability => {\n                 write!(f, \"boxed values differ in mutability\")\n             }\n-            terr_vec_mutability => write!(f, \"vectors differ in mutability\"),\n-            terr_ptr_mutability => write!(f, \"pointers differ in mutability\"),\n-            terr_ref_mutability => write!(f, \"references differ in mutability\"),\n-            terr_ty_param_size(values) => {\n+            VecMutability => write!(f, \"vectors differ in mutability\"),\n+            PtrMutability => write!(f, \"pointers differ in mutability\"),\n+            RefMutability => write!(f, \"references differ in mutability\"),\n+            TyParamSize(values) => {\n                 write!(f, \"expected a type with {} type params, \\\n                            found one with {} type params\",\n                        values.expected,\n                        values.found)\n             }\n-            terr_fixed_array_size(values) => {\n+            FixedArraySize(values) => {\n                 write!(f, \"expected an array with a fixed size of {} elements, \\\n                            found one with {} elements\",\n                        values.expected,\n                        values.found)\n             }\n-            terr_tuple_size(values) => {\n+            TupleSize(values) => {\n                 write!(f, \"expected a tuple with {} elements, \\\n                            found one with {} elements\",\n                        values.expected,\n                        values.found)\n             }\n-            terr_arg_count => {\n+            ArgCount => {\n                 write!(f, \"incorrect number of function parameters\")\n             }\n-            terr_regions_does_not_outlive(..) => {\n+            RegionsDoesNotOutlive(..) => {\n                 write!(f, \"lifetime mismatch\")\n             }\n-            terr_regions_not_same(..) => {\n+            RegionsNotSame(..) => {\n                 write!(f, \"lifetimes are not the same\")\n             }\n-            terr_regions_no_overlap(..) => {\n+            RegionsNoOverlap(..) => {\n                 write!(f, \"lifetimes do not intersect\")\n             }\n-            terr_regions_insufficiently_polymorphic(br, _) => {\n+            RegionsInsufficientlyPolymorphic(br, _) => {\n                 write!(f, \"expected bound lifetime parameter {}, \\\n                            found concrete lifetime\", br)\n             }\n-            terr_regions_overly_polymorphic(br, _) => {\n+            RegionsOverlyPolymorphic(br, _) => {\n                 write!(f, \"expected concrete lifetime, \\\n                            found bound lifetime parameter {}\", br)\n             }\n-            terr_sorts(values) => tls::with(|tcx| {\n+            Sorts(values) => tls::with(|tcx| {\n                 // A naive approach to making sure that we're not reporting silly errors such as:\n                 // (expected closure, found closure).\n                 let expected_str = values.expected.sort_string(tcx);\n@@ -5054,12 +5046,12 @@ impl<'tcx> fmt::Display for type_err<'tcx> {\n                     write!(f, \"expected {}, found {}\", expected_str, found_str)\n                 }\n             }),\n-            terr_traits(values) => tls::with(|tcx| {\n+            Traits(values) => tls::with(|tcx| {\n                 write!(f, \"expected trait `{}`, found trait `{}`\",\n                        tcx.item_path_str(values.expected),\n                        tcx.item_path_str(values.found))\n             }),\n-            terr_builtin_bounds(values) => {\n+            BuiltinBoundsMismatch(values) => {\n                 if values.expected.is_empty() {\n                     write!(f, \"expected no bounds, found `{}`\",\n                            values.found)\n@@ -5072,35 +5064,35 @@ impl<'tcx> fmt::Display for type_err<'tcx> {\n                            values.found)\n                 }\n             }\n-            terr_integer_as_char => {\n+            IntegerAsChar => {\n                 write!(f, \"expected an integral type, found `char`\")\n             }\n-            terr_int_mismatch(ref values) => {\n+            IntMismatch(ref values) => {\n                 write!(f, \"expected `{:?}`, found `{:?}`\",\n                        values.expected,\n                        values.found)\n             }\n-            terr_float_mismatch(ref values) => {\n+            FloatMismatch(ref values) => {\n                 write!(f, \"expected `{:?}`, found `{:?}`\",\n                        values.expected,\n                        values.found)\n             }\n-            terr_variadic_mismatch(ref values) => {\n+            VariadicMismatch(ref values) => {\n                 write!(f, \"expected {} fn, found {} function\",\n                        if values.expected { \"variadic\" } else { \"non-variadic\" },\n                        if values.found { \"variadic\" } else { \"non-variadic\" })\n             }\n-            terr_convergence_mismatch(ref values) => {\n+            ConvergenceMismatch(ref values) => {\n                 write!(f, \"expected {} fn, found {} function\",\n                        if values.expected { \"converging\" } else { \"diverging\" },\n                        if values.found { \"converging\" } else { \"diverging\" })\n             }\n-            terr_projection_name_mismatched(ref values) => {\n+            ProjectionNameMismatched(ref values) => {\n                 write!(f, \"expected {}, found {}\",\n                        values.expected,\n                        values.found)\n             }\n-            terr_projection_bounds_length(ref values) => {\n+            ProjectionBoundsLength(ref values) => {\n                 write!(f, \"expected {} associated type bindings, found {}\",\n                        values.expected,\n                        values.found)\n@@ -5408,7 +5400,7 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn field_idx_strict(&self, name: ast::Name, fields: &[field])\n+    pub fn field_idx_strict(&self, name: ast::Name, fields: &[Field<'tcx>])\n                             -> usize {\n         let mut i = 0;\n         for f in fields { if f.name == name { return i; } i += 1; }\n@@ -5420,36 +5412,36 @@ impl<'tcx> ctxt<'tcx> {\n                   .collect::<Vec<String>>()));\n     }\n \n-    pub fn note_and_explain_type_err(&self, err: &type_err<'tcx>, sp: Span) {\n+    pub fn note_and_explain_type_err(&self, err: &TypeError<'tcx>, sp: Span) {\n         match *err {\n-            terr_regions_does_not_outlive(subregion, superregion) => {\n+            RegionsDoesNotOutlive(subregion, superregion) => {\n                 self.note_and_explain_region(\"\", subregion, \"...\");\n                 self.note_and_explain_region(\"...does not necessarily outlive \",\n                                            superregion, \"\");\n             }\n-            terr_regions_not_same(region1, region2) => {\n+            RegionsNotSame(region1, region2) => {\n                 self.note_and_explain_region(\"\", region1, \"...\");\n                 self.note_and_explain_region(\"...is not the same lifetime as \",\n                                            region2, \"\");\n             }\n-            terr_regions_no_overlap(region1, region2) => {\n+            RegionsNoOverlap(region1, region2) => {\n                 self.note_and_explain_region(\"\", region1, \"...\");\n                 self.note_and_explain_region(\"...does not overlap \",\n                                            region2, \"\");\n             }\n-            terr_regions_insufficiently_polymorphic(_, conc_region) => {\n+            RegionsInsufficientlyPolymorphic(_, conc_region) => {\n                 self.note_and_explain_region(\"concrete lifetime that was found is \",\n                                            conc_region, \"\");\n             }\n-            terr_regions_overly_polymorphic(_, ty::ReInfer(ty::ReVar(_))) => {\n+            RegionsOverlyPolymorphic(_, ty::ReInfer(ty::ReVar(_))) => {\n                 // don't bother to print out the message below for\n                 // inference variables, it's not very illuminating.\n             }\n-            terr_regions_overly_polymorphic(_, conc_region) => {\n+            RegionsOverlyPolymorphic(_, conc_region) => {\n                 self.note_and_explain_region(\"expected concrete lifetime is \",\n                                            conc_region, \"\");\n             }\n-            terr_sorts(values) => {\n+            Sorts(values) => {\n                 let expected_str = values.expected.sort_string(self);\n                 let found_str = values.found.sort_string(self);\n                 if expected_str == found_str && expected_str == \"closure\" {\n@@ -5960,7 +5952,7 @@ impl<'tcx> ctxt<'tcx> {\n \n     // Look up the list of field names and IDs for a given struct.\n     // Panics if the id is not bound to a struct.\n-    pub fn lookup_struct_fields(&self, did: ast::DefId) -> Vec<field_ty> {\n+    pub fn lookup_struct_fields(&self, did: ast::DefId) -> Vec<FieldTy> {\n         if did.krate == ast::LOCAL_CRATE {\n             let struct_fields = self.struct_fields.borrow();\n             match struct_fields.get(&did) {\n@@ -5984,11 +5976,11 @@ impl<'tcx> ctxt<'tcx> {\n     // Returns a list of fields corresponding to the struct's items. trans uses\n     // this. Takes a list of substs with which to instantiate field types.\n     pub fn struct_fields(&self, did: ast::DefId, substs: &Substs<'tcx>)\n-                         -> Vec<field<'tcx>> {\n+                         -> Vec<Field<'tcx>> {\n         self.lookup_struct_fields(did).iter().map(|f| {\n-           field {\n+           Field {\n                 name: f.name,\n-                mt: mt {\n+                mt: TypeWithMutability {\n                     ty: self.lookup_field_type(did, f.id, substs),\n                     mutbl: MutImmutable\n                 }\n@@ -6074,7 +6066,7 @@ impl<'tcx> ctxt<'tcx> {\n                                     }\n                                     UpvarCapture::ByRef(borrow) => {\n                                         tcx.mk_ref(tcx.mk_region(borrow.region),\n-                                            ty::mt {\n+                                            ty::TypeWithMutability {\n                                                 ty: freevar_ty,\n                                                 mutbl: borrow.kind.to_mutbl_lossy(),\n                                             })\n@@ -6427,7 +6419,7 @@ impl<'tcx> ctxt<'tcx> {\n                 h.as_str().hash(state);\n                 did.node.hash(state);\n             };\n-            let mt = |state: &mut SipHasher, mt: mt| {\n+            let mt = |state: &mut SipHasher, mt: TypeWithMutability| {\n                 mt.mutbl.hash(state);\n             };\n             let fn_sig = |state: &mut SipHasher, sig: &Binder<FnSig<'tcx>>| {\n@@ -7222,7 +7214,7 @@ impl<'tcx> HasTypeFlags for FnSig<'tcx> {\n     }\n }\n \n-impl<'tcx> HasTypeFlags for field<'tcx> {\n+impl<'tcx> HasTypeFlags for Field<'tcx> {\n     fn has_type_flags(&self, flags: TypeFlags) -> bool {\n         self.mt.ty.has_type_flags(flags)\n     }\n@@ -7251,7 +7243,7 @@ impl<'tcx> fmt::Debug for ClosureUpvar<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for field<'tcx> {\n+impl<'tcx> fmt::Debug for Field<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"field({},{})\", self.name, self.mt)\n     }"}, {"sha": "7f2897fb9f5c7ee816b1e7584d53937ef1866684", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -85,7 +85,7 @@ pub trait TypeFolder<'tcx> : Sized {\n         super_fold_ty(self, t)\n     }\n \n-    fn fold_mt(&mut self, t: &ty::mt<'tcx>) -> ty::mt<'tcx> {\n+    fn fold_mt(&mut self, t: &ty::TypeWithMutability<'tcx>) -> ty::TypeWithMutability<'tcx> {\n         super_fold_mt(self, t)\n     }\n \n@@ -251,8 +251,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureTy<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::mt<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::mt<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for ty::TypeWithMutability<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeWithMutability<'tcx> {\n         folder.fold_mt(self)\n     }\n }\n@@ -275,9 +275,9 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::field<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::field<'tcx> {\n-        ty::field {\n+impl<'tcx> TypeFoldable<'tcx> for ty::Field<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Field<'tcx> {\n+        ty::Field {\n             name: self.name,\n             mt: self.mt.fold_with(folder),\n         }\n@@ -685,9 +685,9 @@ pub fn super_fold_trait_ref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n }\n \n pub fn super_fold_mt<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                mt: &ty::mt<'tcx>)\n-                                                -> ty::mt<'tcx> {\n-    ty::mt {ty: mt.ty.fold_with(this),\n+                                                mt: &ty::TypeWithMutability<'tcx>)\n+                                                -> ty::TypeWithMutability<'tcx> {\n+    ty::TypeWithMutability {ty: mt.ty.fold_with(this),\n             mutbl: mt.mutbl}\n }\n "}, {"sha": "d2d9a0f6cbe3bb64a486e8b76800bc0d2df75059", "filename": "src/librustc/middle/ty_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_match.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n \n             (&ty::TyInfer(_), _) |\n             (_, &ty::TyInfer(_)) => {\n-                Err(ty::terr_sorts(ty_relate::expected_found(self, &a, &b)))\n+                Err(ty::Sorts(ty_relate::expected_found(self, &a, &b)))\n             }\n \n             (&ty::TyError, _) | (_, &ty::TyError) => {"}, {"sha": "2a66a41f372dd1562ac63f9d664b5142e378eba2", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -20,7 +20,7 @@ use std::rc::Rc;\n use syntax::abi;\n use syntax::ast;\n \n-pub type RelateResult<'tcx, T> = Result<T, ty::type_err<'tcx>>;\n+pub type RelateResult<'tcx, T> = Result<T, ty::TypeError<'tcx>>;\n \n #[derive(Clone, Debug)]\n pub enum Cause {\n@@ -89,27 +89,27 @@ pub trait Relate<'a,'tcx>: TypeFoldable<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Relate impls\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::mt<'tcx> {\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TypeWithMutability<'tcx> {\n     fn relate<R>(relation: &mut R,\n-                 a: &ty::mt<'tcx>,\n-                 b: &ty::mt<'tcx>)\n-                 -> RelateResult<'tcx, ty::mt<'tcx>>\n+                 a: &ty::TypeWithMutability<'tcx>,\n+                 b: &ty::TypeWithMutability<'tcx>)\n+                 -> RelateResult<'tcx, ty::TypeWithMutability<'tcx>>\n         where R: TypeRelation<'a,'tcx>\n     {\n         debug!(\"{}.mts({:?}, {:?})\",\n                relation.tag(),\n                a,\n                b);\n         if a.mutbl != b.mutbl {\n-            Err(ty::terr_mutability)\n+            Err(ty::Mutability)\n         } else {\n             let mutbl = a.mutbl;\n             let variance = match mutbl {\n                 ast::MutImmutable => ty::Covariant,\n                 ast::MutMutable => ty::Invariant,\n             };\n             let ty = try!(relation.relate_with_variance(variance, &a.ty, &b.ty));\n-            Ok(ty::mt {ty: ty, mutbl: mutbl})\n+            Ok(ty::TypeWithMutability {ty: ty, mutbl: mutbl})\n         }\n     }\n }\n@@ -186,7 +186,7 @@ fn relate_type_params<'a,'tcx:'a,R>(relation: &mut R,\n     where R: TypeRelation<'a,'tcx>\n {\n     if a_tys.len() != b_tys.len() {\n-        return Err(ty::terr_ty_param_size(expected_found(relation,\n+        return Err(ty::TyParamSize(expected_found(relation,\n                                                          &a_tys.len(),\n                                                          &b_tys.len())));\n     }\n@@ -256,7 +256,7 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::FnSig<'tcx> {\n         where R: TypeRelation<'a,'tcx>\n     {\n         if a.variadic != b.variadic {\n-            return Err(ty::terr_variadic_mismatch(\n+            return Err(ty::VariadicMismatch(\n                 expected_found(relation, &a.variadic, &b.variadic)));\n         }\n \n@@ -270,7 +270,7 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::FnSig<'tcx> {\n             (ty::FnDiverging, ty::FnDiverging) =>\n                 Ok(ty::FnDiverging),\n             (a, b) =>\n-                Err(ty::terr_convergence_mismatch(\n+                Err(ty::ConvergenceMismatch(\n                     expected_found(relation, &(a != ty::FnDiverging), &(b != ty::FnDiverging)))),\n         });\n \n@@ -287,7 +287,7 @@ fn relate_arg_vecs<'a,'tcx:'a,R>(relation: &mut R,\n     where R: TypeRelation<'a,'tcx>\n {\n     if a_args.len() != b_args.len() {\n-        return Err(ty::terr_arg_count);\n+        return Err(ty::ArgCount);\n     }\n \n     a_args.iter().zip(b_args)\n@@ -303,7 +303,7 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ast::Unsafety {\n         where R: TypeRelation<'a,'tcx>\n     {\n         if a != b {\n-            Err(ty::terr_unsafety_mismatch(expected_found(relation, a, b)))\n+            Err(ty::UnsafetyMismatch(expected_found(relation, a, b)))\n         } else {\n             Ok(*a)\n         }\n@@ -320,7 +320,7 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for abi::Abi {\n         if a == b {\n             Ok(*a)\n         } else {\n-            Err(ty::terr_abi_mismatch(expected_found(relation, a, b)))\n+            Err(ty::AbiMismatch(expected_found(relation, a, b)))\n         }\n     }\n }\n@@ -333,7 +333,7 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionTy<'tcx> {\n         where R: TypeRelation<'a,'tcx>\n     {\n         if a.item_name != b.item_name {\n-            Err(ty::terr_projection_name_mismatched(\n+            Err(ty::ProjectionNameMismatched(\n                 expected_found(relation, &a.item_name, &b.item_name)))\n         } else {\n             let trait_ref = try!(relation.relate(&a.trait_ref, &b.trait_ref));\n@@ -368,7 +368,7 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for Vec<ty::PolyProjectionPredicate<'tcx>> {\n         // so we can just iterate through the lists pairwise, so long as they are the\n         // same length.\n         if a.len() != b.len() {\n-            Err(ty::terr_projection_bounds_length(expected_found(relation, &a.len(), &b.len())))\n+            Err(ty::ProjectionBoundsLength(expected_found(relation, &a.len(), &b.len())))\n         } else {\n             a.iter().zip(b)\n                 .map(|(a, b)| relation.relate(a, b))\n@@ -412,7 +412,7 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::BuiltinBounds {\n         // Two sets of builtin bounds are only relatable if they are\n         // precisely the same (but see the coercion code).\n         if a != b {\n-            Err(ty::terr_builtin_bounds(expected_found(relation, a, b)))\n+            Err(ty::BuiltinBoundsMismatch(expected_found(relation, a, b)))\n         } else {\n             Ok(*a)\n         }\n@@ -428,7 +428,7 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TraitRef<'tcx> {\n     {\n         // Different traits cannot be related\n         if a.def_id != b.def_id {\n-            Err(ty::terr_traits(expected_found(relation, &a.def_id, &b.def_id)))\n+            Err(ty::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {\n             let substs = try!(relate_item_substs(relation, a.def_id, a.substs, b.substs));\n             Ok(ty::TraitRef { def_id: a.def_id, substs: relation.tcx().mk_substs(substs) })\n@@ -547,7 +547,7 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             if sz_a == sz_b {\n                 Ok(tcx.mk_array(t, sz_a))\n             } else {\n-                Err(ty::terr_fixed_array_size(expected_found(relation, &sz_a, &sz_b)))\n+                Err(ty::FixedArraySize(expected_found(relation, &sz_a, &sz_b)))\n             }\n         }\n \n@@ -565,10 +565,10 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n                                  .collect::<Result<_, _>>());\n                 Ok(tcx.mk_tup(ts))\n             } else if !(as_.is_empty() || bs.is_empty()) {\n-                Err(ty::terr_tuple_size(\n+                Err(ty::TupleSize(\n                     expected_found(relation, &as_.len(), &bs.len())))\n             } else {\n-                Err(ty::terr_sorts(expected_found(relation, &a, &b)))\n+                Err(ty::Sorts(expected_found(relation, &a, &b)))\n             }\n         }\n \n@@ -587,7 +587,7 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n \n         _ =>\n         {\n-            Err(ty::terr_sorts(expected_found(relation, &a, &b)))\n+            Err(ty::Sorts(expected_found(relation, &a, &b)))\n         }\n     }\n }\n@@ -652,7 +652,7 @@ impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Box<T>\n pub fn expected_found<'a,'tcx:'a,R,T>(relation: &mut R,\n                                       a: &T,\n                                       b: &T)\n-                                      -> ty::expected_found<T>\n+                                      -> ty::ExpectedFound<T>\n     where R: TypeRelation<'a,'tcx>, T: Clone\n {\n     expected_found_bool(relation.a_is_expected(), a, b)\n@@ -661,14 +661,14 @@ pub fn expected_found<'a,'tcx:'a,R,T>(relation: &mut R,\n pub fn expected_found_bool<T>(a_is_expected: bool,\n                               a: &T,\n                               b: &T)\n-                              -> ty::expected_found<T>\n+                              -> ty::ExpectedFound<T>\n     where T: Clone\n {\n     let a = a.clone();\n     let b = b.clone();\n     if a_is_expected {\n-        ty::expected_found {expected: a, found: b}\n+        ty::ExpectedFound {expected: a, found: b}\n     } else {\n-        ty::expected_found {expected: b, found: a}\n+        ty::ExpectedFound {expected: b, found: a}\n     }\n }"}, {"sha": "bf7681743f63ae8126308ddb0ac392383a4770e7", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -19,7 +19,7 @@ use middle::ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyBareFn};\n use middle::ty::{TyParam, TyRawPtr, TyRef, TyTuple};\n use middle::ty::TyClosure;\n use middle::ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n-use middle::ty::{self, mt, Ty, HasTypeFlags};\n+use middle::ty::{self, TypeWithMutability, Ty, HasTypeFlags};\n use middle::ty_fold::{self, TypeFoldable};\n \n use std::fmt;\n@@ -321,7 +321,7 @@ impl<'tcx> fmt::Debug for ty::TyS<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::mt<'tcx> {\n+impl<'tcx> fmt::Display for ty::TypeWithMutability<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}{}\",\n                if self.mutbl == ast::MutMutable { \"mut \" } else { \"\" },"}, {"sha": "83cfcb0b623176d0c252b166065f03e3df18859c", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -398,7 +398,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                     mut path: DiscrField) -> Option<DiscrField> {\n     match ty.sty {\n         // Fat &T/&mut T/Box<T> i.e. T is [T], str, or Trait\n-        ty::TyRef(_, ty::mt { ty, .. }) | ty::TyBox(ty) if !type_is_sized(tcx, ty) => {\n+        ty::TyRef(_, ty::TypeWithMutability { ty, .. }) | ty::TyBox(ty) if !type_is_sized(tcx, ty) => {\n             path.push(FAT_PTR_ADDR);\n             Some(path)\n         },\n@@ -415,7 +415,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n             assert_eq!(nonzero_fields.len(), 1);\n             let nonzero_field = tcx.lookup_field_type(did, nonzero_fields[0].id, substs);\n             match nonzero_field.sty {\n-                ty::TyRawPtr(ty::mt { ty, .. }) if !type_is_sized(tcx, ty) => {\n+                ty::TyRawPtr(ty::TypeWithMutability { ty, .. }) if !type_is_sized(tcx, ty) => {\n                     path.push_all(&[0, FAT_PTR_ADDR]);\n                     Some(path)\n                 },"}, {"sha": "3f0dd83975c8f4fe1bbdf11cef7f4bad8de63153", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -223,7 +223,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             // We can also mark the return value as `dereferenceable` in certain cases\n             match ret_ty.sty {\n                 // These are not really pointers but pairs, (pointer, len)\n-                ty::TyRef(_, ty::mt { ty: inner, .. })\n+                ty::TyRef(_, ty::TypeWithMutability { ty: inner, .. })\n                 | ty::TyBox(inner) if common::type_is_sized(ccx.tcx(), inner) => {\n                     let llret_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n                     attrs.ret(llvm::DereferenceableAttribute(llret_sz));"}, {"sha": "ba48a9f92a40f456fd8cfaa91d1bf939a8be2c12", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -130,8 +130,8 @@ pub fn type_is_sized<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n \n pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n-        ty::TyRawPtr(ty::mt{ty, ..}) |\n-        ty::TyRef(_, ty::mt{ty, ..}) |\n+        ty::TyRawPtr(ty::TypeWithMutability{ty, ..}) |\n+        ty::TyRef(_, ty::TypeWithMutability{ty, ..}) |\n         ty::TyBox(ty) => {\n             !type_is_sized(cx, ty)\n         }"}, {"sha": "785efd75ce332cb61c1f1d7af92f2a9971771d2e", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -621,7 +621,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             let len = unsafe { llvm::LLVMConstIntGetZExtValue(len) as u64 };\n             let len = match bt.sty {\n-                ty::TyBox(ty) | ty::TyRef(_, ty::mt{ty, ..}) => match ty.sty {\n+                ty::TyBox(ty) | ty::TyRef(_, ty::TypeWithMutability{ty, ..}) => match ty.sty {\n                     ty::TyStr => {\n                         assert!(len > 0);\n                         len - 1"}, {"sha": "ce9192d6ada2161dc35ee3d0aed906b4a3847fc5", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -206,7 +206,7 @@ impl<'tcx> TypeMap<'tcx> {\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n                 unique_type_id.push_str(&inner_type_id[..]);\n             },\n-            ty::TyRawPtr(ty::mt { ty: inner_type, mutbl } ) => {\n+            ty::TyRawPtr(ty::TypeWithMutability { ty: inner_type, mutbl } ) => {\n                 unique_type_id.push('*');\n                 if mutbl == ast::MutMutable {\n                     unique_type_id.push_str(\"mut\");\n@@ -216,7 +216,7 @@ impl<'tcx> TypeMap<'tcx> {\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n                 unique_type_id.push_str(&inner_type_id[..]);\n             },\n-            ty::TyRef(_, ty::mt { ty: inner_type, mutbl }) => {\n+            ty::TyRef(_, ty::TypeWithMutability { ty: inner_type, mutbl }) => {\n                 unique_type_id.push('&');\n                 if mutbl == ast::MutMutable {\n                     unique_type_id.push_str(\"mut\");\n@@ -561,7 +561,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 unique_type_id: UniqueTypeId,\n                                 span: Span)\n                                 -> MetadataCreationResult {\n-    let data_ptr_type = cx.tcx().mk_ptr(ty::mt {\n+    let data_ptr_type = cx.tcx().mk_ptr(ty::TypeWithMutability {\n         ty: element_type,\n         mutbl: ast::MutImmutable\n     });\n@@ -765,7 +765,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         trait_pointer_metadata(cx, t, None, unique_type_id),\n             false)\n         }\n-        ty::TyBox(ty) | ty::TyRawPtr(ty::mt{ty, ..}) | ty::TyRef(_, ty::mt{ty, ..}) => {\n+        ty::TyBox(ty) | ty::TyRawPtr(ty::TypeWithMutability{ty, ..}) | ty::TyRef(_, ty::TypeWithMutability{ty, ..}) => {\n             match ty.sty {\n                 ty::TySlice(typ) => {\n                     vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span)\n@@ -1113,7 +1113,7 @@ impl<'tcx> MemberDescriptionFactory<'tcx> {\n \n // Creates MemberDescriptions for the fields of a struct\n struct StructMemberDescriptionFactory<'tcx> {\n-    fields: Vec<ty::field<'tcx>>,\n+    fields: Vec<ty::Field<'tcx>>,\n     is_simd: bool,\n     span: Span,\n }"}, {"sha": "4b9b9cd664633d416bd44515375ead74c3cf8f12", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -77,7 +77,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             push_debuginfo_type_name(cx, inner_type, true, output);\n             output.push('>');\n         },\n-        ty::TyRawPtr(ty::mt { ty: inner_type, mutbl } ) => {\n+        ty::TyRawPtr(ty::TypeWithMutability { ty: inner_type, mutbl } ) => {\n             output.push('*');\n             match mutbl {\n                 ast::MutImmutable => output.push_str(\"const \"),\n@@ -86,7 +86,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             push_debuginfo_type_name(cx, inner_type, true, output);\n         },\n-        ty::TyRef(_, ty::mt { ty: inner_type, mutbl }) => {\n+        ty::TyRef(_, ty::TypeWithMutability { ty: inner_type, mutbl }) => {\n             output.push('&');\n             if mutbl == ast::MutMutable {\n                 output.push_str(\"mut \");"}, {"sha": "b40984444cfb27619d28b1f9c9c0576184baccd8", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -440,9 +440,9 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     match (&source.ty.sty, &target.ty.sty) {\n         (&ty::TyBox(a), &ty::TyBox(b)) |\n-        (&ty::TyRef(_, ty::mt { ty: a, .. }), &ty::TyRef(_, ty::mt { ty: b, .. })) |\n-        (&ty::TyRef(_, ty::mt { ty: a, .. }), &ty::TyRawPtr(ty::mt { ty: b, .. })) |\n-        (&ty::TyRawPtr(ty::mt { ty: a, .. }), &ty::TyRawPtr(ty::mt { ty: b, .. })) => {\n+        (&ty::TyRef(_, ty::TypeWithMutability { ty: a, .. }), &ty::TyRef(_, ty::TypeWithMutability { ty: b, .. })) |\n+        (&ty::TyRef(_, ty::TypeWithMutability { ty: a, .. }), &ty::TyRawPtr(ty::TypeWithMutability { ty: b, .. })) |\n+        (&ty::TyRawPtr(ty::TypeWithMutability { ty: a, .. }), &ty::TyRawPtr(ty::TypeWithMutability { ty: b, .. })) => {\n             let (inner_source, inner_target) = (a, b);\n \n             let (base, old_info) = if !type_is_sized(bcx.tcx(), inner_source) {\n@@ -707,7 +707,7 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                               base: &ast::Expr,\n                               get_idx: F)\n                               -> DatumBlock<'blk, 'tcx, Expr> where\n-    F: FnOnce(&'blk ty::ctxt<'tcx>, &[ty::field<'tcx>]) -> usize,\n+    F: FnOnce(&'blk ty::ctxt<'tcx>, &[ty::Field<'tcx>]) -> usize,\n {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rec_field\");\n@@ -1333,7 +1333,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                                   node_id_opt: Option<ast::NodeId>,\n                                   op: F)\n                                   -> R where\n-    F: FnOnce(ty::Disr, &[ty::field<'tcx>]) -> R,\n+    F: FnOnce(ty::Disr, &[ty::Field<'tcx>]) -> R,\n {\n     match ty.sty {\n         ty::TyStruct(did, substs) => {\n@@ -1344,9 +1344,9 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n \n         ty::TyTuple(ref v) => {\n             let fields: Vec<_> = v.iter().enumerate().map(|(i, &f)| {\n-                ty::field {\n+                ty::Field {\n                     name: token::intern(&i.to_string()),\n-                    mt: ty::mt {\n+                    mt: ty::TypeWithMutability {\n                         ty: f,\n                         mutbl: ast::MutImmutable\n                     }\n@@ -1994,7 +1994,7 @@ pub fn cast_is_noop<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n \n     match (t_in.builtin_deref(true), t_out.builtin_deref(true)) {\n-        (Some(ty::mt{ ty: t_in, .. }), Some(ty::mt{ ty: t_out, .. })) => {\n+        (Some(ty::TypeWithMutability{ ty: t_in, .. }), Some(ty::TypeWithMutability{ ty: t_out, .. })) => {\n             t_in == t_out\n         }\n         _ => {\n@@ -2275,8 +2275,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n \n-        ty::TyRawPtr(ty::mt { ty: content_ty, .. }) |\n-        ty::TyRef(_, ty::mt { ty: content_ty, .. }) => {\n+        ty::TyRawPtr(ty::TypeWithMutability { ty: content_ty, .. }) |\n+        ty::TyRef(_, ty::TypeWithMutability { ty: content_ty, .. }) => {\n             if type_is_sized(bcx.tcx(), content_ty) {\n                 let ptr = datum.to_llscalarish(bcx);\n "}, {"sha": "2db86459de4887f2af15f89412199bd85f742dd9", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -315,7 +315,7 @@ pub fn get_base_and_len<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n \n         // Only used for pattern matching.\n-        ty::TyBox(ty) | ty::TyRef(_, ty::mt{ty, ..}) => {\n+        ty::TyBox(ty) | ty::TyRef(_, ty::TypeWithMutability{ty, ..}) => {\n             let inner = if type_is_sized(bcx.tcx(), ty) {\n                 Load(bcx, llval)\n             } else {"}, {"sha": "63774a983ab38ae2720f4abd81d7da9460b4a11c", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -193,7 +193,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         ty::TyUint(t) => Type::uint_from_ty(cx, t),\n         ty::TyFloat(t) => Type::float_from_ty(cx, t),\n \n-        ty::TyBox(ty) | ty::TyRef(_, ty::mt{ty, ..}) | ty::TyRawPtr(ty::mt{ty, ..}) => {\n+        ty::TyBox(ty) | ty::TyRef(_, ty::TypeWithMutability{ty, ..}) | ty::TyRawPtr(ty::TypeWithMutability{ty, ..}) => {\n             if type_is_sized(cx.tcx(), ty) {\n                 Type::i8p(cx)\n             } else {\n@@ -352,7 +352,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           adt::incomplete_type_of(cx, &*repr, \"closure\")\n       }\n \n-      ty::TyBox(ty) | ty::TyRef(_, ty::mt{ty, ..}) | ty::TyRawPtr(ty::mt{ty, ..}) => {\n+      ty::TyBox(ty) | ty::TyRef(_, ty::TypeWithMutability{ty, ..}) | ty::TyRawPtr(ty::TypeWithMutability{ty, ..}) => {\n           if !type_is_sized(cx.tcx(), ty) {\n               if let ty::TyStr = ty.sty {\n                   // This means we get a nicer name in the output (str is always"}, {"sha": "c8f0a632fa5b7a1644ebdefa90051f49800a86b0", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -1556,7 +1556,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             }\n         }\n         ast::TyPtr(ref mt) => {\n-            tcx.mk_ptr(ty::mt {\n+            tcx.mk_ptr(ty::TypeWithMutability {\n                 ty: ast_ty_to_ty(this, rscope, &*mt.ty),\n                 mutbl: mt.mutbl\n             })\n@@ -1569,7 +1569,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                     rscope,\n                     ty::ObjectLifetimeDefault::Specific(r));\n             let t = ast_ty_to_ty(this, rscope1, &*mt.ty);\n-            tcx.mk_ref(tcx.mk_region(r), ty::mt {ty: t, mutbl: mt.mutbl})\n+            tcx.mk_ref(tcx.mk_region(r), ty::TypeWithMutability {ty: t, mutbl: mt.mutbl})\n         }\n         ast::TyTup(ref fields) => {\n             let flds = fields.iter()\n@@ -1755,7 +1755,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n                 ty::ByReferenceExplicitSelfCategory(region, mutability) => {\n                     (Some(this.tcx().mk_ref(\n                                       this.tcx().mk_region(region),\n-                                      ty::mt {\n+                                      ty::TypeWithMutability {\n                                         ty: self_info.untransformed_self_ty,\n                                         mutbl: mutability\n                                       })),"}, {"sha": "4b0f0f6e174c5ee91344e50b7c658466fa323b95", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -170,7 +170,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     // then `x` is assigned a value of type `&M T` where M is the mutability\n                     // and T is the expected type.\n                     let region_var = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n-                    let mt = ty::mt { ty: expected, mutbl: mutbl };\n+                    let mt = ty::TypeWithMutability { ty: expected, mutbl: mutbl };\n                     let region_ty = tcx.mk_ref(tcx.mk_region(region_var), mt);\n \n                     // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n@@ -272,7 +272,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         ast::PatRegion(ref inner, mutbl) => {\n             let inner_ty = fcx.infcx().next_ty_var();\n \n-            let mt = ty::mt { ty: inner_ty, mutbl: mutbl };\n+            let mt = ty::TypeWithMutability { ty: inner_ty, mutbl: mutbl };\n             let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n             let rptr_ty = tcx.mk_ref(tcx.mk_region(region), mt);\n \n@@ -301,7 +301,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 }),\n                 _ => {\n                     let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n-                    tcx.mk_ref(tcx.mk_region(region), ty::mt {\n+                    tcx.mk_ref(tcx.mk_region(region), ty::TypeWithMutability {\n                         ty: tcx.mk_slice(inner_ty),\n                         mutbl: expected_ty.builtin_deref(true).map(|mt| mt.mutbl)\n                                                               .unwrap_or(ast::MutImmutable)\n@@ -324,7 +324,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 let mutbl = expected_ty.builtin_deref(true)\n                     .map_or(ast::MutImmutable, |mt| mt.mutbl);\n \n-                let slice_ty = tcx.mk_ref(tcx.mk_region(region), ty::mt {\n+                let slice_ty = tcx.mk_ref(tcx.mk_region(region), ty::TypeWithMutability {\n                     ty: tcx.mk_slice(inner_ty),\n                     mutbl: mutbl\n                 });\n@@ -729,7 +729,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                                          span: Span,\n                                          fields: &'tcx [Spanned<ast::FieldPat>],\n-                                         struct_fields: &[ty::field<'tcx>],\n+                                         struct_fields: &[ty::Field<'tcx>],\n                                          struct_id: ast::DefId,\n                                          etc: bool) {\n     let tcx = pcx.fcx.ccx.tcx;"}, {"sha": "3a65b3fc082185043290d14e400eec80df6b735e", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -272,8 +272,8 @@ impl<'tcx> CastCheck<'tcx> {\n \n     fn check_ptr_ptr_cast<'a>(&self,\n                               fcx: &FnCtxt<'a, 'tcx>,\n-                              m_expr: &'tcx ty::mt<'tcx>,\n-                              m_cast: &'tcx ty::mt<'tcx>)\n+                              m_expr: &'tcx ty::TypeWithMutability<'tcx>,\n+                              m_cast: &'tcx ty::TypeWithMutability<'tcx>)\n                               -> Result<CastKind, CastError>\n     {\n         debug!(\"check_ptr_ptr_cast m_expr={:?} m_cast={:?}\",\n@@ -299,7 +299,7 @@ impl<'tcx> CastCheck<'tcx> {\n \n     fn check_fptr_ptr_cast<'a>(&self,\n                                fcx: &FnCtxt<'a, 'tcx>,\n-                               m_cast: &'tcx ty::mt<'tcx>)\n+                               m_cast: &'tcx ty::TypeWithMutability<'tcx>)\n                                -> Result<CastKind, CastError>\n     {\n         // fptr-ptr cast. must be to sized ptr\n@@ -313,7 +313,7 @@ impl<'tcx> CastCheck<'tcx> {\n \n     fn check_ptr_addr_cast<'a>(&self,\n                                fcx: &FnCtxt<'a, 'tcx>,\n-                               m_expr: &'tcx ty::mt<'tcx>)\n+                               m_expr: &'tcx ty::TypeWithMutability<'tcx>)\n                                -> Result<CastKind, CastError>\n     {\n         // ptr-addr cast. must be from sized ptr\n@@ -327,8 +327,8 @@ impl<'tcx> CastCheck<'tcx> {\n \n     fn check_ref_cast<'a>(&self,\n                           fcx: &FnCtxt<'a, 'tcx>,\n-                          m_expr: &'tcx ty::mt<'tcx>,\n-                          m_cast: &'tcx ty::mt<'tcx>)\n+                          m_expr: &'tcx ty::TypeWithMutability<'tcx>,\n+                          m_cast: &'tcx ty::TypeWithMutability<'tcx>)\n                           -> Result<CastKind, CastError>\n     {\n         // array-ptr-cast.\n@@ -353,7 +353,7 @@ impl<'tcx> CastCheck<'tcx> {\n \n     fn check_addr_ptr_cast<'a>(&self,\n                                fcx: &FnCtxt<'a, 'tcx>,\n-                               m_cast: &'tcx ty::mt<'tcx>)\n+                               m_cast: &'tcx ty::TypeWithMutability<'tcx>)\n                                -> Result<CastKind, CastError>\n     {\n         // ptr-addr cast. pointer must be thin."}, {"sha": "51e05f52f77c698937482d0aa4bd1b98ab5432d6", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -66,7 +66,7 @@ use middle::infer::{self, Coercion};\n use middle::traits::{self, ObligationCause};\n use middle::traits::{predicate_for_trait_def, report_selection_error};\n use middle::ty::{AutoDerefRef, AdjustDerefRef};\n-use middle::ty::{self, mt, Ty};\n+use middle::ty::{self, TypeWithMutability, Ty};\n use middle::ty_relate::RelateResult;\n use util::common::indent;\n \n@@ -202,7 +202,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 return None;\n             }\n             let ty = self.tcx().mk_ref(r_borrow,\n-                                        mt {ty: inner_ty, mutbl: mutbl_b});\n+                                        TypeWithMutability {ty: inner_ty, mutbl: mutbl_b});\n             if let Err(err) = self.subtype(ty, b) {\n                 if first_error.is_none() {\n                     first_error = Some(err);\n@@ -247,7 +247,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             (u, cu)\n         } else {\n             debug!(\"Missing Unsize or CoerceUnsized traits\");\n-            return Err(ty::terr_mismatch);\n+            return Err(ty::Mismatch);\n         };\n \n         // Note, we want to avoid unnecessary unsizing. We don't want to coerce to\n@@ -307,7 +307,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 // Uncertain or unimplemented.\n                 Ok(None) | Err(traits::Unimplemented) => {\n                     debug!(\"coerce_unsized: early return - can't prove obligation\");\n-                    return Err(ty::terr_mismatch);\n+                    return Err(ty::Mismatch);\n                 }\n \n                 // Object safety violations or miscellaneous.\n@@ -411,7 +411,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         };\n \n         // Check that the types which they point at are compatible.\n-        let a_unsafe = self.tcx().mk_ptr(ty::mt{ mutbl: mutbl_b, ty: mt_a.ty });\n+        let a_unsafe = self.tcx().mk_ptr(ty::TypeWithMutability{ mutbl: mutbl_b, ty: mt_a.ty });\n         try!(self.subtype(a_unsafe, b));\n         try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n \n@@ -472,6 +472,6 @@ fn coerce_mutbls<'tcx>(from_mutbl: ast::Mutability,\n         (ast::MutMutable, ast::MutMutable) |\n         (ast::MutImmutable, ast::MutImmutable) |\n         (ast::MutMutable, ast::MutImmutable) => Ok(None),\n-        (ast::MutImmutable, ast::MutMutable) => Err(ty::terr_mutability)\n+        (ast::MutImmutable, ast::MutMutable) => Err(ty::Mutability)\n     }\n }"}, {"sha": "e175fd9bcfdc78dfeba787c54aac64c880e88cba", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -32,7 +32,7 @@ pub fn suptype_with_fn<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                     ty_a: Ty<'tcx>,\n                                     ty_b: Ty<'tcx>,\n                                     handle_err: F) where\n-    F: FnOnce(Span, Ty<'tcx>, Ty<'tcx>, &ty::type_err<'tcx>),\n+    F: FnOnce(Span, Ty<'tcx>, Ty<'tcx>, &ty::TypeError<'tcx>),\n {\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx(), b_is_expected, infer::Misc(sp),"}, {"sha": "2b6705419d41ff738a44464b39a919bd4403c3d1", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -433,7 +433,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         };\n \n         match sig.0.inputs[0].sty {\n-            ty::TyRef(_, ty::mt {\n+            ty::TyRef(_, ty::TypeWithMutability {\n                 ty: _,\n                 mutbl: ast::MutMutable,\n             }) => {}"}, {"sha": "48bb02bd8a70b49866327d4ff089db08d47abe95", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -271,7 +271,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     // Trait method is fn(&self) or fn(&mut self), need an\n                     // autoref. Pull the region etc out of the type of first argument.\n                     match transformed_self_ty.sty {\n-                        ty::TyRef(region, ty::mt { mutbl, ty: _ }) => {\n+                        ty::TyRef(region, ty::TypeWithMutability { mutbl, ty: _ }) => {\n                             fcx.write_adjustment(self_expr.id,\n                                 ty::AdjustDerefRef(ty::AutoDerefRef {\n                                     autoderefs: autoderefs,"}, {"sha": "2b9dcf843cdeb072b7fca43f0f88b2f26b121cc6", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -311,11 +311,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 let lang_def_id = self.tcx().lang_items.slice_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyRawPtr(ty::mt { ty: _, mutbl: ast::MutImmutable }) => {\n+            ty::TyRawPtr(ty::TypeWithMutability { ty: _, mutbl: ast::MutImmutable }) => {\n                 let lang_def_id = self.tcx().lang_items.const_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyRawPtr(ty::mt { ty: _, mutbl: ast::MutMutable }) => {\n+            ty::TyRawPtr(ty::TypeWithMutability { ty: _, mutbl: ast::MutMutable }) => {\n                 let lang_def_id = self.tcx().lang_items.mut_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n@@ -951,7 +951,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         // Search through mutabilities in order to find one where pick works:\n         [ast::MutImmutable, ast::MutMutable].iter().filter_map(|&m| {\n-            let autoref_ty = tcx.mk_ref(region, ty::mt {\n+            let autoref_ty = tcx.mk_ref(region, ty::TypeWithMutability {\n                 ty: step.self_ty,\n                 mutbl: m\n             });"}, {"sha": "3a3a7bc76b5eca97f146deebaaa69b65e4c2a2f9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -1030,7 +1030,7 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n     }, t_expr, None);\n     match t_expr.sty {\n-        ty::TyRef(_, ty::mt { mutbl: mt, .. }) => {\n+        ty::TyRef(_, ty::TypeWithMutability { mutbl: mt, .. }) => {\n             let mtstr = match mt {\n                 ast::MutMutable => \"mut \",\n                 ast::MutImmutable => \"\"\n@@ -1577,7 +1577,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     origin: infer::TypeOrigin,\n                     sub: Ty<'tcx>,\n                     sup: Ty<'tcx>)\n-                    -> Result<(), ty::type_err<'tcx>> {\n+                    -> Result<(), ty::TypeError<'tcx>> {\n         infer::mk_subty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n@@ -1586,7 +1586,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                    origin: infer::TypeOrigin,\n                    sub: Ty<'tcx>,\n                    sup: Ty<'tcx>)\n-                   -> Result<(), ty::type_err<'tcx>> {\n+                   -> Result<(), ty::TypeError<'tcx>> {\n         infer::mk_eqty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n@@ -1601,7 +1601,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                  sp: Span,\n                                  mk_msg: M,\n                                  actual_ty: Ty<'tcx>,\n-                                 err: Option<&ty::type_err<'tcx>>) where\n+                                 err: Option<&ty::TypeError<'tcx>>) where\n         M: FnOnce(String) -> String,\n     {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n@@ -1611,7 +1611,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                    sp: Span,\n                                    e: Ty<'tcx>,\n                                    a: Ty<'tcx>,\n-                                   err: &ty::type_err<'tcx>) {\n+                                   err: &ty::TypeError<'tcx>) {\n         self.infcx().report_mismatched_types(sp, e, a, err)\n     }\n \n@@ -1675,7 +1675,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn lookup_field_ty(&self,\n                            span: Span,\n                            class_id: ast::DefId,\n-                           items: &[ty::field_ty],\n+                           items: &[ty::FieldTy],\n                            fieldname: ast::Name,\n                            substs: &subst::Substs<'tcx>)\n                            -> Option<Ty<'tcx>>\n@@ -1688,7 +1688,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn lookup_tup_field_ty(&self,\n                                span: Span,\n                                class_id: ast::DefId,\n-                               items: &[ty::field_ty],\n+                               items: &[ty::FieldTy],\n                                idx: usize,\n                                substs: &subst::Substs<'tcx>)\n                                -> Option<Ty<'tcx>>\n@@ -1895,7 +1895,7 @@ fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   base_expr: Option<&ast::Expr>,\n                                   base_ty: Ty<'tcx>,\n                                   lvalue_pref: LvaluePreference)\n-                                  -> Option<ty::mt<'tcx>>\n+                                  -> Option<ty::TypeWithMutability<'tcx>>\n {\n     // Try DerefMut first, if preferred.\n     let method = match (lvalue_pref, fcx.tcx().lang_items.deref_mut_trait()) {\n@@ -1926,7 +1926,7 @@ fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 method_call: Option<MethodCall>,\n                                                 method: Option<MethodCallee<'tcx>>)\n-                                                -> Option<ty::mt<'tcx>>\n+                                                -> Option<ty::TypeWithMutability<'tcx>>\n {\n     match method {\n         Some(method) => {\n@@ -2777,7 +2777,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 class_id: ast::DefId,\n                                                 node_id: ast::NodeId,\n                                                 substitutions: &'tcx subst::Substs<'tcx>,\n-                                                field_types: &[ty::field_ty],\n+                                                field_types: &[ty::FieldTy],\n                                                 ast_fields: &'tcx [ast::Field],\n                                                 check_completeness: bool,\n                                                 enum_id_opt: Option<ast::DefId>)  {\n@@ -3111,7 +3111,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                     hint,\n                                                     lvalue_pref);\n \n-        let tm = ty::mt { ty: fcx.expr_ty(&**oprnd), mutbl: mutbl };\n+        let tm = ty::TypeWithMutability { ty: fcx.expr_ty(&**oprnd), mutbl: mutbl };\n         let oprnd_t = if tm.ty.references_error() {\n             tcx.types.err\n         } else {\n@@ -4909,25 +4909,25 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"offset\" | \"arith_offset\" => {\n               (1,\n                vec!(\n-                  tcx.mk_ptr(ty::mt {\n+                  tcx.mk_ptr(ty::TypeWithMutability {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n                   ccx.tcx.types.isize\n                ),\n-               tcx.mk_ptr(ty::mt {\n+               tcx.mk_ptr(ty::TypeWithMutability {\n                    ty: param(ccx, 0),\n                    mutbl: ast::MutImmutable\n                }))\n             }\n             \"copy\" | \"copy_nonoverlapping\" => {\n               (1,\n                vec!(\n-                  tcx.mk_ptr(ty::mt {\n+                  tcx.mk_ptr(ty::TypeWithMutability {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n-                  tcx.mk_ptr(ty::mt {\n+                  tcx.mk_ptr(ty::TypeWithMutability {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n                   }),\n@@ -4938,11 +4938,11 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"volatile_copy_memory\" | \"volatile_copy_nonoverlapping_memory\" => {\n               (1,\n                vec!(\n-                  tcx.mk_ptr(ty::mt {\n+                  tcx.mk_ptr(ty::TypeWithMutability {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n                   }),\n-                  tcx.mk_ptr(ty::mt {\n+                  tcx.mk_ptr(ty::TypeWithMutability {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n@@ -4953,7 +4953,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"write_bytes\" | \"volatile_set_memory\" => {\n               (1,\n                vec!(\n-                  tcx.mk_ptr(ty::mt {\n+                  tcx.mk_ptr(ty::TypeWithMutability {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n                   }),"}, {"sha": "078c66fc2628eb7611ac92373979ec06bff7663b", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -450,11 +450,11 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n             let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env), true);\n \n-            let check_mutbl = |mt_a: ty::mt<'tcx>, mt_b: ty::mt<'tcx>,\n+            let check_mutbl = |mt_a: ty::TypeWithMutability<'tcx>, mt_b: ty::TypeWithMutability<'tcx>,\n                                mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n                 if (mt_a.mutbl, mt_b.mutbl) == (ast::MutImmutable, ast::MutMutable) {\n                     infcx.report_mismatched_types(span, mk_ptr(mt_b.ty),\n-                                                  target, &ty::terr_mutability);\n+                                                  target, &ty::Mutability);\n                 }\n                 (mt_a.ty, mt_b.ty, unsize_trait, None)\n             };"}, {"sha": "0190e5274c4beb77d40a9d0f01cab35070c2c4e6", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -100,14 +100,14 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                                   \"[T]\",\n                                                   item.span);\n                     }\n-                    ty::TyRawPtr(ty::mt { ty: _, mutbl: ast::MutImmutable }) => {\n+                    ty::TyRawPtr(ty::TypeWithMutability { ty: _, mutbl: ast::MutImmutable }) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.const_ptr_impl(),\n                                                   \"const_ptr\",\n                                                   \"*const T\",\n                                                   item.span);\n                     }\n-                    ty::TyRawPtr(ty::mt { ty: _, mutbl: ast::MutMutable }) => {\n+                    ty::TyRawPtr(ty::TypeWithMutability { ty: _, mutbl: ast::MutMutable }) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.mut_ptr_impl(),\n                                                   \"mut_ptr\","}, {"sha": "efbbae34e281d9a57762afe54414b61eb07dfc6f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -655,7 +655,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            struct_predicates: &ty::GenericPredicates<'tcx>,\n                            v: &ast::StructField,\n                            origin: ast::DefId)\n-                           -> ty::field_ty\n+                           -> ty::FieldTy\n {\n     let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &*v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n@@ -671,15 +671,15 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     match v.node.kind {\n         ast::NamedField(ident, visibility) => {\n-            ty::field_ty {\n+            ty::FieldTy {\n                 name: ident.name,\n                 id: local_def(v.node.id),\n                 vis: visibility,\n                 origin: origin,\n             }\n         }\n         ast::UnnamedField(visibility) => {\n-            ty::field_ty {\n+            ty::FieldTy {\n                 name: special_idents::unnamed_field.name,\n                 id: local_def(v.node.id),\n                 vis: visibility,"}, {"sha": "346ecf58276ff6b664ce263994f61a64db17addb", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -1074,7 +1074,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// appearing in a context with ambient variance `variance`\n     fn add_constraints_from_mt(&mut self,\n                                generics: &ty::Generics<'tcx>,\n-                               mt: &ty::mt<'tcx>,\n+                               mt: &ty::TypeWithMutability<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         match mt.mutbl {\n             ast::MutMutable => {"}, {"sha": "710aa72099cdbd86eb6722594c999ca78c5cbcfe", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754aaea88c5f2899e628a54fed4643384219da29/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=754aaea88c5f2899e628a54fed4643384219da29", "patch": "@@ -1729,7 +1729,7 @@ impl Clean<Item> for ast::StructField {\n     }\n }\n \n-impl Clean<Item> for ty::field_ty {\n+impl Clean<Item> for ty::FieldTy {\n     fn clean(&self, cx: &DocContext) -> Item {\n         use syntax::parse::token::special_idents::unnamed_field;\n         use rustc::metadata::csearch;"}]}