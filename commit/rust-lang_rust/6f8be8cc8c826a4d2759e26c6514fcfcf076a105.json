{"sha": "6f8be8cc8c826a4d2759e26c6514fcfcf076a105", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmOGJlOGNjOGM4MjZhNGQyNzU5ZTI2YzY1MTRmY2ZjZjA3NmExMDU=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-05-08T20:05:22Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-05-18T13:41:34Z"}, "message": "Fix docs", "tree": {"sha": "959578e0427d4fac44be34c04fc8bd8b81304e9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/959578e0427d4fac44be34c04fc8bd8b81304e9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f8be8cc8c826a4d2759e26c6514fcfcf076a105", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f8be8cc8c826a4d2759e26c6514fcfcf076a105", "html_url": "https://github.com/rust-lang/rust/commit/6f8be8cc8c826a4d2759e26c6514fcfcf076a105", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f8be8cc8c826a4d2759e26c6514fcfcf076a105/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9215ead1ee94bef156c109693c9aa5bb4981d098", "url": "https://api.github.com/repos/rust-lang/rust/commits/9215ead1ee94bef156c109693c9aa5bb4981d098", "html_url": "https://github.com/rust-lang/rust/commit/9215ead1ee94bef156c109693c9aa5bb4981d098"}], "stats": {"total": 40, "additions": 27, "deletions": 13}, "files": [{"sha": "9ce6d1caa1e79a2ce8a45ccc67b57c02791677a5", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6f8be8cc8c826a4d2759e26c6514fcfcf076a105/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/6f8be8cc8c826a4d2759e26c6514fcfcf076a105/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=6f8be8cc8c826a4d2759e26c6514fcfcf076a105", "patch": "@@ -25,6 +25,7 @@ cannot be otherwise achieved. Accessing low level hardware primitives, e.g. in k\n Let us start with the simplest possible example:\n \n ```rust\n+# #![feature(asm)]\n unsafe {\n     asm!(\"nop\");\n }\n@@ -41,6 +42,7 @@ Now inserting an instruction that does nothing is rather boring. Let us do somet\n actually acts on data:\n \n ```rust\n+# #![feature(asm)]\n let x: u64;\n unsafe {\n     asm!(\"mov {}, 5\", out(reg) x);\n@@ -62,6 +64,7 @@ the template and will read the variable from there after the inline assembly fin\n Let us see another example that also uses an input:\n \n ```rust\n+# #![feature(asm)]\n let i: u64 = 3;\n let o: u64;\n unsafe {\n@@ -93,6 +96,7 @@ readability, and allows reordering instructions without changing the argument or\n We can further refine the above example to avoid the `mov` instruction:\n \n ```rust\n+# #![feature(asm)]\n let mut x: u64 = 3;\n unsafe {\n     asm!(\"add {0}, {number}\", inout(reg) x, number = const 5);\n@@ -106,6 +110,7 @@ This is different from specifying an input and output separately in that it is g\n It is also possible to specify different variables for the input and output parts of an `inout` operand:\n \n ```rust\n+# #![feature(asm)]\n let x: u64 = 3;\n let y: u64;\n unsafe {\n@@ -127,6 +132,7 @@ There is also a `inlateout` variant of this specifier.\n Here is an example where `inlateout` *cannot* be used:\n \n ```rust\n+# #![feature(asm)]\n let mut a: u64 = 4;\n let b: u64 = 4;\n let c: u64 = 4;\n@@ -144,6 +150,7 @@ Here the compiler is free to allocate the same register for inputs `b` and `c` s\n However the following example can use `inlateout` since the output is only modified after all input registers have been read:\n \n ```rust\n+# #![feature(asm)]\n let mut a: u64 = 4;\n let b: u64 = 4;\n unsafe {\n@@ -161,21 +168,24 @@ Therefore, Rust inline assembly provides some more specific constraint specifier\n While `reg` is generally available on any architecture, these are highly architecture specific. E.g. for x86 the general purpose registers `eax`, `ebx`, `ecx`, `edx`, `ebp`, `esi`, and `edi`\n among others can be addressed by their name.\n \n-```rust\n+```rust,no_run\n+# #![feature(asm)]\n+let cmd = 0xd1;\n unsafe {\n-    asm!(\"out 0x64, rax\", in(\"rax\") cmd);\n+    asm!(\"out 0x64, eax\", in(\"eax\") cmd);\n }\n ```\n \n In this example we call the `out` instruction to output the content of the `cmd` variable\n-to port `0x64`. Since the `out` instruction only accepts `rax` (and its sub registers) as operand\n-we had to use the `rax` constraint specifier.\n+to port `0x64`. Since the `out` instruction only accepts `eax` (and its sub registers) as operand\n+we had to use the `eax` constraint specifier.\n \n Note that unlike other operand types, explicit register operands cannot be used in the template string: you can't use `{}` and should write the register name directly instead. Also, they must appear at the end of the operand list after all other operand types.\n \n Consider this example which uses the x86 `mul` instruction:\n \n ```rust\n+# #![feature(asm)]\n fn mul(a: u64, b: u64) -> u128 {\n     let lo: u64;\n     let hi: u64;\n@@ -191,7 +201,7 @@ fn mul(a: u64, b: u64) -> u128 {\n         );\n     }\n \n-    hi as u128 << 64 + lo as u128\n+    (hi as u128) << 64 + lo as u128\n }\n ```\n \n@@ -211,8 +221,9 @@ We need to tell the compiler about this since it may need to save and restore th\n around the inline assembly block.\n \n ```rust\n-let ebx: u64;\n-let ecx: u64;\n+# #![feature(asm)]\n+let ebx: u32;\n+let ecx: u32;\n \n unsafe {\n     asm!(\n@@ -240,6 +251,7 @@ However we still need to tell the compiler that `eax` and `edx` have been modifi\n This can also be used with a general register class (e.g. `reg`) to obtain a scratch register for use inside the asm code:\n \n ```rust\n+# #![feature(asm)]\n // Multiply x by 6 using shifts and adds\n let mut x: u64 = 4;\n unsafe {\n@@ -259,14 +271,15 @@ A special operand type, `sym`, allows you to use the symbol name of a `fn` or `s\n This allows you to call a function or access a global variable without needing to keep its address in a register.\n \n ```rust\n+# #![feature(asm)]\n extern \"C\" fn foo(arg: i32) {\n     println!(\"arg = {}\", arg);\n }\n \n fn call_foo(arg: i32) {\n     unsafe {\n         asm!(\n-            \"call {}\"\n+            \"call {}\",\n             sym foo,\n             // 1st argument in rdi, which is caller-saved\n             inout(\"rdi\") arg => _,\n@@ -294,10 +307,11 @@ By default the compiler will always choose the name that refers to the full regi\n This default can be overriden by using modifiers on the template string operands, just like you would with format strings:\n \n ```rust\n+# #![feature(asm)]\n let mut x: u16 = 0xab;\n \n unsafe {\n-    asm!(\"mov {0:h}, {0:b}\", inout(reg_abcd) x);\n+    asm!(\"mov {0:h}, {0:l}\", inout(reg_abcd) x);\n }\n \n assert_eq!(x, 0xabab);\n@@ -306,7 +320,7 @@ assert_eq!(x, 0xabab);\n In this example, we use the `reg_abcd` register class to restrict the register allocator to the 4 legacy x86 register (`ax`, `bx`, `cx`, `dx`) of which the first two bytes can be addressed independently.\n \n Let us assume that the register allocator has chosen to allocate `x` in the `ax` register.\n-The `h` modifier will emit the register name for the high byte of that register and the `b` modifier will emit the register name for the low byte. The asm code will therefore be expanded as `mov ah, al` which copies the low byte of the value into the high byte.\n+The `h` modifier will emit the register name for the high byte of that register and the `l` modifier will emit the register name for the low byte. The asm code will therefore be expanded as `mov ah, al` which copies the low byte of the value into the high byte.\n \n If you use a smaller data type (e.g. `u16`) with an operand and forget the use template modifiers, the compiler will emit a warning and suggest the correct modifier to use.\n \n@@ -317,6 +331,7 @@ By default, an inline assembly block is treated the same way as an external FFI\n Let's take our previous example of an `add` instruction:\n \n ```rust\n+# #![feature(asm)]\n let mut a: u64 = 4;\n let b: u64 = 4;\n unsafe {\n@@ -348,7 +363,7 @@ When required, options are specified as the final argument.\n \n The following ABNF specifies the general syntax:\n \n-```\n+```ignore\n dir_spec := \"in\" / \"out\" / \"lateout\" / \"inout\" / \"inlateout\"\n reg_spec := <register class> / \"<explicit register>\"\n operand_expr := expr / \"_\" / expr \"=>\" expr / expr \"=>\" \"_\"\n@@ -612,7 +627,7 @@ Currently the following options are defined:\n - `pure`: The `asm` block has no side effects, and its outputs depend only on its direct inputs (i.e. the values themselves, not what they point to) or values read from memory (unless the `nomem` options is also set). This allows the compiler to execute the `asm` block fewer times than specified in the program (e.g. by hoisting it out of a loop) or even eliminate it entirely if the outputs are not used.\n - `nomem`: The `asm` blocks does not read or write to any memory. This allows the compiler to cache the values of modified global variables in registers across the `asm` block since it knows that they are not read or written to by the `asm`.\n - `readonly`: The `asm` block does not write to any memory. This allows the compiler to cache the values of unmodified global variables in registers across the `asm` block since it knows that they are not written to by the `asm`.\n-- `preserves_flags`: The `asm` block does not modify the flags register (defined in the [rules][rules] below). This allows the compiler to avoid recomputing the condition flags after the `asm` block.\n+- `preserves_flags`: The `asm` block does not modify the flags register (defined in the rules below). This allows the compiler to avoid recomputing the condition flags after the `asm` block.\n - `noreturn`: The `asm` block never returns, and its return type is defined as `!` (never). Behavior is undefined if execution falls through past the end of the asm code. A `noreturn` asm block behaves just like a function which doesn't return; notably, local variables in scope are not dropped before it is invoked.\n - `nostack`: The `asm` block does not push data to the stack, or write to the stack red-zone (if supported by the target). If this option is *not* used then the stack pointer is guaranteed to be suitably aligned (according to the target ABI) for a function call.\n - `att_syntax`: This option is only valid on x86, and causes the assembler to use the `.att_syntax prefix` mode of the GNU assembler. Register operands are substituted in with a leading `%`.\n@@ -624,7 +639,6 @@ The compiler performs some additional checks on options:\n - It is a compile-time error to specify `noreturn` on an asm block with outputs.\n \n ## Rules for inline assembly\n-[rules]: #rules\n \n - Any registers not specified as inputs will contain an undefined value on entry to the asm block.\n   - An \"undefined value\" in the context of inline assembly means that the register can (non-deterministically) have any one of the possible values allowed by the architecture. Notably it is not the same as an LLVM `undef` which can have a different value every time you read it (since such a concept does not exist in assembly code)."}]}