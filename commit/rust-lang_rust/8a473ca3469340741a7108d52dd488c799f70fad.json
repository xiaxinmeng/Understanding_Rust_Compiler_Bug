{"sha": "8a473ca3469340741a7108d52dd488c799f70fad", "node_id": "C_kwDOAAsO6NoAKDhhNDczY2EzNDY5MzQwNzQxYTcxMDhkNTJkZDQ4OGM3OTlmNzBmYWQ", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-10-22T19:45:06Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-10-29T12:14:46Z"}, "message": "Recursively document Deref", "tree": {"sha": "c447c26102d45c7f5b1ced1f146a6fde7437b9b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c447c26102d45c7f5b1ced1f146a6fde7437b9b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a473ca3469340741a7108d52dd488c799f70fad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a473ca3469340741a7108d52dd488c799f70fad", "html_url": "https://github.com/rust-lang/rust/commit/8a473ca3469340741a7108d52dd488c799f70fad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a473ca3469340741a7108d52dd488c799f70fad/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2707fec04f655cdf18388618881748ebbd683e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2707fec04f655cdf18388618881748ebbd683e9", "html_url": "https://github.com/rust-lang/rust/commit/f2707fec04f655cdf18388618881748ebbd683e9"}], "stats": {"total": 127, "additions": 111, "deletions": 16}, "files": [{"sha": "db718fbe673898e6f687c23358d6740c37ee3d09", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a473ca3469340741a7108d52dd488c799f70fad/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a473ca3469340741a7108d52dd488c799f70fad/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=8a473ca3469340741a7108d52dd488c799f70fad", "patch": "@@ -6,7 +6,7 @@ use std::rc::Rc;\n use std::sync::mpsc::{channel, Receiver};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n@@ -54,6 +54,9 @@ crate struct Context<'tcx> {\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n     pub(super) render_redirect_pages: bool,\n+    /// Tracks section IDs for `Deref` targets so they match in both the main\n+    /// body and the sidebar.\n+    pub(super) deref_id_map: Rc<RefCell<FxHashMap<DefId, String>>>,\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     pub(super) id_map: RefCell<IdMap>,\n     /// Shared mutable state.\n@@ -70,7 +73,7 @@ crate struct Context<'tcx> {\n \n // `Context` is cloned a lot, so we don't want the size to grow unexpectedly.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Context<'_>, 104);\n+rustc_data_structures::static_assert_size!(Context<'_>, 112);\n \n /// Shared mutable state used in [`Context`] and elsewhere.\n crate struct SharedContext<'tcx> {\n@@ -513,6 +516,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             dst,\n             render_redirect_pages: false,\n             id_map: RefCell::new(id_map),\n+            deref_id_map: Rc::new(RefCell::new(FxHashMap::default())),\n             shared: Rc::new(scx),\n             include_sources,\n         };\n@@ -536,6 +540,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             current: self.current.clone(),\n             dst: self.dst.clone(),\n             render_redirect_pages: self.render_redirect_pages,\n+            deref_id_map: Rc::new(RefCell::new(FxHashMap::default())),\n             id_map: RefCell::new(IdMap::new()),\n             shared: Rc::clone(&self.shared),\n             include_sources: self.include_sources,"}, {"sha": "b84cd718d4c83e07f4cff47fd4a83c4e037d7a72", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 69, "deletions": 13, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8a473ca3469340741a7108d52dd488c799f70fad/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a473ca3469340741a7108d52dd488c799f70fad/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=8a473ca3469340741a7108d52dd488c799f70fad", "patch": "@@ -1053,6 +1053,19 @@ fn render_assoc_items(\n     containing_item: &clean::Item,\n     it: DefId,\n     what: AssocItemRender<'_>,\n+) {\n+    let mut derefs = FxHashSet::default();\n+    derefs.insert(it);\n+    render_assoc_items_inner(w, cx, containing_item, it, what, &mut derefs)\n+}\n+\n+fn render_assoc_items_inner(\n+    w: &mut Buffer,\n+    cx: &Context<'_>,\n+    containing_item: &clean::Item,\n+    it: DefId,\n+    what: AssocItemRender<'_>,\n+    derefs: &mut FxHashSet<DefId>,\n ) {\n     info!(\"Documenting associated items of {:?}\", containing_item.name);\n     let cache = cx.cache();\n@@ -1072,12 +1085,18 @@ fn render_assoc_items(\n                 RenderMode::Normal\n             }\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n+                let id =\n+                    cx.derive_id(small_url_encode(format!(\"deref-methods-{:#}\", type_.print(cx))));\n+                if let Some(def_id) = type_.def_id(cx.cache()) {\n+                    cx.deref_id_map.borrow_mut().insert(def_id, id.clone());\n+                }\n                 write!(\n                     w,\n-                    \"<h2 id=\\\"deref-methods\\\" class=\\\"small-section-header\\\">\\\n+                    \"<h2 id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n                          <span>Methods from {trait_}&lt;Target = {type_}&gt;</span>\\\n-                         <a href=\\\"#deref-methods\\\" class=\\\"anchor\\\"></a>\\\n+                         <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\\\n                      </h2>\",\n+                    id = id,\n                     trait_ = trait_.print(cx),\n                     type_ = type_.print(cx),\n                 );\n@@ -1104,17 +1123,22 @@ fn render_assoc_items(\n             );\n         }\n     }\n-    if let AssocItemRender::DerefFor { .. } = what {\n-        return;\n-    }\n+\n     if !traits.is_empty() {\n         let deref_impl =\n             traits.iter().find(|t| t.trait_did() == cx.tcx().lang_items().deref_trait());\n         if let Some(impl_) = deref_impl {\n             let has_deref_mut =\n                 traits.iter().any(|t| t.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n-            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n+            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut, derefs);\n         }\n+\n+        // If we were already one level into rendering deref methods, we don't want to render\n+        // anything after recursing into any further deref methods above.\n+        if let AssocItemRender::DerefFor { .. } = what {\n+            return;\n+        }\n+\n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n             traits.iter().partition(|t| t.inner_impl().synthetic);\n         let (blanket_impl, concrete): (Vec<&&Impl>, _) =\n@@ -1166,6 +1190,7 @@ fn render_deref_methods(\n     impl_: &Impl,\n     container_item: &clean::Item,\n     deref_mut: bool,\n+    derefs: &mut FxHashSet<DefId>,\n ) {\n     let cache = cx.cache();\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n@@ -1187,16 +1212,16 @@ fn render_deref_methods(\n     if let Some(did) = target.def_id(cache) {\n         if let Some(type_did) = impl_.inner_impl().for_.def_id(cache) {\n             // `impl Deref<Target = S> for S`\n-            if did == type_did {\n+            if did == type_did || !derefs.insert(did) {\n                 // Avoid infinite cycles\n                 return;\n             }\n         }\n-        render_assoc_items(w, cx, container_item, did, what);\n+        render_assoc_items_inner(w, cx, container_item, did, what, derefs);\n     } else {\n         if let Some(prim) = target.primitive_type() {\n             if let Some(&did) = cache.primitive_locations.get(&prim) {\n-                render_assoc_items(w, cx, container_item, did, what);\n+                render_assoc_items_inner(w, cx, container_item, did, what, derefs);\n             }\n         }\n     }\n@@ -1986,7 +2011,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n             if let Some(impl_) =\n                 v.iter().find(|i| i.trait_did() == cx.tcx().lang_items().deref_trait())\n             {\n-                sidebar_deref_methods(cx, out, impl_, v);\n+                let mut derefs = FxHashSet::default();\n+                derefs.insert(did);\n+                sidebar_deref_methods(cx, out, impl_, v, &mut derefs);\n             }\n \n             let format_impls = |impls: Vec<&Impl>| {\n@@ -2060,7 +2087,13 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n     }\n }\n \n-fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &[Impl]) {\n+fn sidebar_deref_methods(\n+    cx: &Context<'_>,\n+    out: &mut Buffer,\n+    impl_: &Impl,\n+    v: &[Impl],\n+    derefs: &mut FxHashSet<DefId>,\n+) {\n     let c = cx.cache();\n \n     debug!(\"found Deref: {:?}\", impl_);\n@@ -2077,7 +2110,7 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &[\n         if let Some(did) = target.def_id(c) {\n             if let Some(type_did) = impl_.inner_impl().for_.def_id(c) {\n                 // `impl Deref<Target = S> for S`\n-                if did == type_did {\n+                if did == type_did || !derefs.insert(did) {\n                     // Avoid infinite cycles\n                     return;\n                 }\n@@ -2101,9 +2134,17 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &[\n                 })\n                 .collect::<Vec<_>>();\n             if !ret.is_empty() {\n+                let map;\n+                let id = if let Some(target_def_id) = real_target.def_id(c) {\n+                    map = cx.deref_id_map.borrow();\n+                    map.get(&target_def_id).expect(\"Deref section without derived id\")\n+                } else {\n+                    \"deref-methods\"\n+                };\n                 write!(\n                     out,\n-                    \"<h3 class=\\\"sidebar-title\\\"><a href=\\\"#deref-methods\\\">Methods from {}&lt;Target={}&gt;</a></h3>\",\n+                    \"<h3 class=\\\"sidebar-title\\\"><a href=\\\"#{}\\\">Methods from {}&lt;Target={}&gt;</a></h3>\",\n+                    id,\n                     Escape(&format!(\"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print(cx))),\n                     Escape(&format!(\"{:#}\", real_target.print(cx))),\n                 );\n@@ -2116,6 +2157,21 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &[\n                 out.push_str(\"</div>\");\n             }\n         }\n+\n+        // Recurse into any further impls that might exist for `target`\n+        if let Some(target_did) = target.def_id_no_primitives() {\n+            if let Some(target_impls) = c.impls.get(&target_did) {\n+                if let Some(target_deref_impl) = target_impls.iter().find(|i| {\n+                    i.inner_impl()\n+                        .trait_\n+                        .as_ref()\n+                        .map(|t| Some(t.def_id()) == cx.tcx().lang_items().deref_trait())\n+                        .unwrap_or(false)\n+                }) {\n+                    sidebar_deref_methods(cx, out, target_deref_impl, target_impls, derefs);\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "d559dd4effe2c48beb1675d567db8575c162eead", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8a473ca3469340741a7108d52dd488c799f70fad/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a473ca3469340741a7108d52dd488c799f70fad/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=8a473ca3469340741a7108d52dd488c799f70fad", "patch": "@@ -3,7 +3,8 @@ use crate::clean::*;\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def_id::DefId;\n use rustc_middle::ty::DefIdTree;\n use rustc_span::symbol::sym;\n \n@@ -53,6 +54,29 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     }\n \n     let mut cleaner = BadImplStripper { prims, items: crate_items };\n+    let mut type_did_to_deref_target: FxHashMap<DefId, &Type> = FxHashMap::default();\n+\n+    // Follow all `Deref` targets of included items and recursively add them as valid\n+    fn add_deref_target(\n+        map: &FxHashMap<DefId, &Type>,\n+        cleaner: &mut BadImplStripper,\n+        type_did: DefId,\n+    ) {\n+        if let Some(target) = map.get(&type_did) {\n+            debug!(\"add_deref_target: type {:?}, target {:?}\", type_did, target);\n+            if let Some(target_prim) = target.primitive_type() {\n+                cleaner.prims.insert(target_prim);\n+            } else if let Some(target_did) = target.def_id() {\n+                // `impl Deref<Target = S> for S`\n+                if target_did == type_did {\n+                    // Avoid infinite cycles\n+                    return;\n+                }\n+                cleaner.items.insert(target_did.into());\n+                add_deref_target(map, cleaner, target_did);\n+            }\n+        }\n+    }\n \n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n     for it in &new_items {\n@@ -73,6 +97,16 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n                 } else if let Some(did) = target.def_id(&cx.cache) {\n                     cleaner.items.insert(did.into());\n                 }\n+                if let Some(for_did) = for_.def_id() {\n+                    if type_did_to_deref_target.insert(for_did, target).is_none() {\n+                        // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n+                        // `Deref` target type and the impl for type positions, this map of types is keyed by\n+                        // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n+                        if cleaner.keep_impl_with_def_id(for_did.into()) {\n+                            add_deref_target(&type_did_to_deref_target, &mut cleaner, for_did);\n+                        }\n+                    }\n+                }\n             }\n         }\n     }"}]}