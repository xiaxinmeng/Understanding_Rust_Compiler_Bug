{"sha": "d5f1c263806880280a3e4d9b01170791d360c618", "node_id": "C_kwDOAAsO6NoAKGQ1ZjFjMjYzODA2ODgwMjgwYTNlNGQ5YjAxMTcwNzkxZDM2MGM2MTg", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-07T01:28:47Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-07T01:38:52Z"}, "message": "rustup; ptr atomics", "tree": {"sha": "83f1cd93793979496e2f5828d175cdf97d9de473", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83f1cd93793979496e2f5828d175cdf97d9de473"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5f1c263806880280a3e4d9b01170791d360c618", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5f1c263806880280a3e4d9b01170791d360c618", "html_url": "https://github.com/rust-lang/rust/commit/d5f1c263806880280a3e4d9b01170791d360c618", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5f1c263806880280a3e4d9b01170791d360c618/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c7114841c6142678ffc991117550bf4874b2936", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7114841c6142678ffc991117550bf4874b2936", "html_url": "https://github.com/rust-lang/rust/commit/8c7114841c6142678ffc991117550bf4874b2936"}], "stats": {"total": 158, "additions": 107, "deletions": 51}, "files": [{"sha": "8f3b1d39fd04935b94956184ec53d1a17972dacb", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5f1c263806880280a3e4d9b01170791d360c618/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/d5f1c263806880280a3e4d9b01170791d360c618/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=d5f1c263806880280a3e4d9b01170791d360c618", "patch": "@@ -1 +1 @@\n-049308cf8b48e9d67e54d6d0b01c10c79d1efc3a\n+7665c3543079ebc3710b676d0fd6951bedfd4b29"}, {"sha": "29bf92af3faf2db1a077b915143c81d769fe1b74", "filename": "src/helpers.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5f1c263806880280a3e4d9b01170791d360c618/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f1c263806880280a3e4d9b01170791d360c618/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=d5f1c263806880280a3e4d9b01170791d360c618", "patch": "@@ -195,9 +195,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     /// Test if this pointer equals 0.\n     fn ptr_is_null(&self, ptr: Pointer<Option<Tag>>) -> InterpResult<'tcx, bool> {\n-        let this = self.eval_context_ref();\n-        let null = Scalar::null_ptr(this);\n-        this.ptr_eq(Scalar::from_maybe_pointer(ptr, this), null)\n+        Ok(ptr.addr().bytes() == 0)\n     }\n \n     /// Get the `Place` for a local"}, {"sha": "e7a43ac95520043899c30e71a3e9ba279de689f2", "filename": "src/operator.rs", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d5f1c263806880280a3e4d9b01170791d360c618/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f1c263806880280a3e4d9b01170791d360c618/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=d5f1c263806880280a3e4d9b01170791d360c618", "patch": "@@ -1,6 +1,7 @@\n use log::trace;\n \n use rustc_middle::{mir, ty::Ty};\n+use rustc_target::abi::Size;\n \n use crate::*;\n \n@@ -11,8 +12,6 @@ pub trait EvalContextExt<'tcx> {\n         left: &ImmTy<'tcx, Tag>,\n         right: &ImmTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, (Scalar<Tag>, bool, Ty<'tcx>)>;\n-\n-    fn ptr_eq(&self, left: Scalar<Tag>, right: Scalar<Tag>) -> InterpResult<'tcx, bool>;\n }\n \n impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n@@ -27,23 +26,8 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n         trace!(\"ptr_op: {:?} {:?} {:?}\", *left, bin_op, *right);\n \n         Ok(match bin_op {\n-            Eq | Ne => {\n-                // This supports fat pointers.\n-                #[rustfmt::skip]\n-                let eq = match (**left, **right) {\n-                    (Immediate::Scalar(left), Immediate::Scalar(right)) => {\n-                        self.ptr_eq(left.check_init()?, right.check_init()?)?\n-                    }\n-                    (Immediate::ScalarPair(left1, left2), Immediate::ScalarPair(right1, right2)) => {\n-                        self.ptr_eq(left1.check_init()?, right1.check_init()?)?\n-                            && self.ptr_eq(left2.check_init()?, right2.check_init()?)?\n-                    }\n-                    _ => bug!(\"Type system should not allow comparing Scalar with ScalarPair\"),\n-                };\n-                (Scalar::from_bool(if bin_op == Eq { eq } else { !eq }), false, self.tcx.types.bool)\n-            }\n-\n-            Lt | Le | Gt | Ge => {\n+            Eq | Ne | Lt | Le | Gt | Ge => {\n+                assert_eq!(left.layout.abi, right.layout.abi); // types an differ, e.g. fn ptrs with different `for`\n                 let size = self.pointer_size();\n                 // Just compare the bits. ScalarPairs are compared lexicographically.\n                 // We thus always compare pairs and simply fill scalars up with 0.\n@@ -58,35 +42,49 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                         (r1.check_init()?.to_bits(size)?, r2.check_init()?.to_bits(size)?),\n                 };\n                 let res = match bin_op {\n+                    Eq => left == right,\n+                    Ne => left != right,\n                     Lt => left < right,\n                     Le => left <= right,\n                     Gt => left > right,\n                     Ge => left >= right,\n-                    _ => bug!(\"We already established it has to be one of these operators.\"),\n+                    _ => bug!(),\n                 };\n                 (Scalar::from_bool(res), false, self.tcx.types.bool)\n             }\n \n             Offset => {\n+                assert!(left.layout.ty.is_unsafe_ptr());\n+                let ptr = self.scalar_to_ptr(left.to_scalar()?)?;\n+                let offset = right.to_scalar()?.to_machine_isize(self)?;\n+\n                 let pointee_ty =\n                     left.layout.ty.builtin_deref(true).expect(\"Offset called on non-ptr type\").ty;\n-                let ptr = self.ptr_offset_inbounds(\n-                    self.scalar_to_ptr(left.to_scalar()?)?,\n-                    pointee_ty,\n-                    right.to_scalar()?.to_machine_isize(self)?,\n-                )?;\n+                let ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset)?;\n                 (Scalar::from_maybe_pointer(ptr, self), false, left.layout.ty)\n             }\n \n-            _ => bug!(\"Invalid operator on pointers: {:?}\", bin_op),\n-        })\n-    }\n+            // Some more operations are possible with atomics.\n+            // The return value always has the provenance of the *left* operand.\n+            Add | Sub | BitOr | BitAnd | BitXor => {\n+                assert!(left.layout.ty.is_unsafe_ptr());\n+                assert!(right.layout.ty.is_unsafe_ptr());\n+                let ptr = self.scalar_to_ptr(left.to_scalar()?)?;\n+                // We do the actual operation with usize-typed scalars.\n+                let left = ImmTy::from_uint(ptr.addr().bytes(), self.machine.layouts.usize);\n+                let right = ImmTy::from_uint(\n+                    right.to_scalar()?.to_machine_usize(self)?,\n+                    self.machine.layouts.usize,\n+                );\n+                let (result, overflowing, _ty) =\n+                    self.overflowing_binary_op(bin_op, &left, &right)?;\n+                // Construct a new pointer with the provenance of `ptr` (the LHS).\n+                let result_ptr =\n+                    Pointer::new(ptr.provenance, Size::from_bytes(result.to_machine_usize(self)?));\n+                (Scalar::from_maybe_pointer(result_ptr, self), overflowing, left.layout.ty)\n+            }\n \n-    fn ptr_eq(&self, left: Scalar<Tag>, right: Scalar<Tag>) -> InterpResult<'tcx, bool> {\n-        let size = self.pointer_size();\n-        // Just compare the integers.\n-        let left = left.to_bits(size)?;\n-        let right = right.to_bits(size)?;\n-        Ok(left == right)\n+            _ => span_bug!(self.cur_span(), \"Invalid operator on pointers: {:?}\", bin_op),\n+        })\n     }\n }"}, {"sha": "9cf9461715f1a9df3e3591aebf72e0b2829cd624", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d5f1c263806880280a3e4d9b01170791d360c618/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f1c263806880280a3e4d9b01170791d360c618/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=d5f1c263806880280a3e4d9b01170791d360c618", "patch": "@@ -314,7 +314,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     ty::Float(FloatTy::F64) =>\n                         this.float_to_int_unchecked(val.to_scalar()?.to_f64()?, dest.layout.ty)?,\n                     _ =>\n-                        bug!(\n+                        span_bug!(\n+                            this.cur_span(),\n                             \"`float_to_int_unchecked` called with non-float input type {:?}\",\n                             val.layout.ty\n                         ),\n@@ -371,7 +372,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         Op::Abs => {\n                             // Works for f32 and f64.\n                             let ty::Float(float_ty) = op.layout.ty.kind() else {\n-                                bug!(\"{} operand is not a float\", intrinsic_name)\n+                                span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n                             };\n                             let op = op.to_scalar()?;\n                             match float_ty {\n@@ -381,7 +382,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         }\n                         Op::HostOp(host_op) => {\n                             let ty::Float(float_ty) = op.layout.ty.kind() else {\n-                                bug!(\"{} operand is not a float\", intrinsic_name)\n+                                span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n                             };\n                             // FIXME using host floats\n                             match float_ty {\n@@ -546,7 +547,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                     // Works for f32 and f64.\n                     let ty::Float(float_ty) = dest.layout.ty.kind() else {\n-                        bug!(\"{} operand is not a float\", intrinsic_name)\n+                        span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n                     };\n                     let val = match float_ty {\n                         FloatTy::F32 =>\n@@ -763,7 +764,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 // `index` is an array, not a SIMD type\n                 let ty::Array(_, index_len) = index.layout.ty.kind() else {\n-                    bug!(\"simd_shuffle index argument has non-array type {}\", index.layout.ty)\n+                    span_bug!(this.cur_span(), \"simd_shuffle index argument has non-array type {}\", index.layout.ty)\n                 };\n                 let index_len = index_len.eval_usize(*this.tcx, this.param_env());\n \n@@ -785,10 +786,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             &this.mplace_index(&right, src_index - left_len)?.into(),\n                         )?\n                     } else {\n-                        bug!(\n-                            \"simd_shuffle index {} is out of bounds for 2 vectors of size {}\",\n-                            src_index,\n-                            left_len\n+                        span_bug!(\n+                            this.cur_span(),\n+                            \"simd_shuffle index {src_index} is out of bounds for 2 vectors of size {left_len}\",\n                         );\n                     };\n                     this.write_immediate(*val, &dest.into())?;\n@@ -1187,8 +1187,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let [place, rhs] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n \n-        if !place.layout.ty.is_integral() {\n-            bug!(\"Atomic arithmetic operations only work on integer types\");\n+        if !place.layout.ty.is_integral() && !place.layout.ty.is_unsafe_ptr() {\n+            span_bug!(\n+                this.cur_span(),\n+                \"atomic arithmetic operations only work on integer and raw pointer types\",\n+            );\n         }\n         let rhs = this.read_immediate(rhs)?;\n \n@@ -1355,7 +1358,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             // Nothing else\n-            _ => bug!(\"`float_to_int_unchecked` called with non-int output type {dest_ty:?}\"),\n+            _ =>\n+                span_bug!(\n+                    this.cur_span(),\n+                    \"`float_to_int_unchecked` called with non-int output type {dest_ty:?}\"\n+                ),\n         })\n     }\n }"}, {"sha": "75e9cbdf1326249df01b5e3ca7fb684142ffde2e", "filename": "tests/pass/atomic.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d5f1c263806880280a3e4d9b01170791d360c618/tests%2Fpass%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5f1c263806880280a3e4d9b01170791d360c618/tests%2Fpass%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fatomic.rs?ref=d5f1c263806880280a3e4d9b01170791d360c618", "patch": "@@ -1,10 +1,15 @@\n-use std::sync::atomic::{compiler_fence, fence, AtomicBool, AtomicIsize, AtomicU64, Ordering::*};\n+// compile-flags: -Zmiri-strict-provenance\n+#![feature(strict_provenance, strict_provenance_atomic_ptr)]\n+use std::sync::atomic::{\n+    compiler_fence, fence, AtomicBool, AtomicIsize, AtomicPtr, AtomicU64, Ordering::*,\n+};\n \n fn main() {\n     atomic_bool();\n     atomic_all_ops();\n     atomic_u64();\n     atomic_fences();\n+    atomic_ptr();\n     weak_sometimes_fails();\n }\n \n@@ -130,6 +135,54 @@ fn atomic_fences() {\n     compiler_fence(AcqRel);\n }\n \n+fn atomic_ptr() {\n+    use std::ptr;\n+    let array: Vec<i32> = (0..100).into_iter().collect(); // a target to point to, to test provenance things\n+    let x = array.as_ptr() as *mut i32;\n+\n+    let ptr = AtomicPtr::<i32>::new(ptr::null_mut());\n+    assert!(ptr.load(Relaxed).addr() == 0);\n+    ptr.store(ptr::invalid_mut(13), SeqCst);\n+    assert!(ptr.swap(x, Relaxed).addr() == 13);\n+    unsafe { assert!(*ptr.load(Acquire) == 0) };\n+\n+    // comparison ignores provenance\n+    assert_eq!(\n+        ptr.compare_exchange(\n+            (&mut 0 as *mut i32).with_addr(x.addr()),\n+            ptr::invalid_mut(0),\n+            SeqCst,\n+            SeqCst\n+        )\n+        .unwrap()\n+        .addr(),\n+        x.addr(),\n+    );\n+    assert_eq!(\n+        ptr.compare_exchange(\n+            (&mut 0 as *mut i32).with_addr(x.addr()),\n+            ptr::invalid_mut(0),\n+            SeqCst,\n+            SeqCst\n+        )\n+        .unwrap_err()\n+        .addr(),\n+        0,\n+    );\n+    ptr.store(x, Relaxed);\n+\n+    assert_eq!(ptr.fetch_ptr_add(13, AcqRel).addr(), x.addr());\n+    unsafe { assert_eq!(*ptr.load(SeqCst), 13) }; // points to index 13 now\n+    assert_eq!(ptr.fetch_ptr_sub(4, AcqRel).addr(), x.addr() + 13 * 4);\n+    unsafe { assert_eq!(*ptr.load(SeqCst), 9) };\n+    assert_eq!(ptr.fetch_or(3, AcqRel).addr(), x.addr() + 9 * 4); // ptr is 4-aligned, so set the last 2 bits\n+    assert_eq!(ptr.fetch_and(!3, AcqRel).addr(), (x.addr() + 9 * 4) | 3); // and unset them again\n+    unsafe { assert_eq!(*ptr.load(SeqCst), 9) };\n+    assert_eq!(ptr.fetch_xor(0xdeadbeef, AcqRel).addr(), x.addr() + 9 * 4);\n+    assert_eq!(ptr.fetch_xor(0xdeadbeef, AcqRel).addr(), (x.addr() + 9 * 4) ^ 0xdeadbeef);\n+    unsafe { assert_eq!(*ptr.load(SeqCst), 9) }; // after XORing twice with the same thing, we get our ptr back\n+}\n+\n fn weak_sometimes_fails() {\n     let atomic = AtomicBool::new(false);\n     let tries = 100;"}]}