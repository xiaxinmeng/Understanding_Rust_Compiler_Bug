{"sha": "77f92674f9a2ea8e8cd303d15710621a4f7839cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3ZjkyNjc0ZjlhMmVhOGU4Y2QzMDNkMTU3MTA2MjFhNGY3ODM5Y2I=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-26T22:48:01Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-26T22:48:01Z"}, "message": "Handle cycles in type vars\n\nThis might be the cause of #587.", "tree": {"sha": "769232968e82fc463b3c08c7108ff2394e01ed4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/769232968e82fc463b3c08c7108ff2394e01ed4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77f92674f9a2ea8e8cd303d15710621a4f7839cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77f92674f9a2ea8e8cd303d15710621a4f7839cb", "html_url": "https://github.com/rust-lang/rust/commit/77f92674f9a2ea8e8cd303d15710621a4f7839cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77f92674f9a2ea8e8cd303d15710621a4f7839cb/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e40d8d40321b191ee82b8b07910f8a0898c8914c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e40d8d40321b191ee82b8b07910f8a0898c8914c", "html_url": "https://github.com/rust-lang/rust/commit/e40d8d40321b191ee82b8b07910f8a0898c8914c"}], "stats": {"total": 95, "additions": 86, "deletions": 9}, "files": [{"sha": "67fcc534610a5c13ca13fbe955b4f6de6a61961f", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/77f92674f9a2ea8e8cd303d15710621a4f7839cb/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f92674f9a2ea8e8cd303d15710621a4f7839cb/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=77f92674f9a2ea8e8cd303d15710621a4f7839cb", "patch": "@@ -862,14 +862,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn resolve_all(mut self) -> InferenceResult {\n+        let mut tv_stack = Vec::new();\n         let mut expr_types = mem::replace(&mut self.type_of_expr, ArenaMap::default());\n         for ty in expr_types.values_mut() {\n-            let resolved = self.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n+            let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n             *ty = resolved;\n         }\n         let mut pat_types = mem::replace(&mut self.type_of_pat, ArenaMap::default());\n         for ty in pat_types.values_mut() {\n-            let resolved = self.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n+            let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n             *ty = resolved;\n         }\n         InferenceResult {\n@@ -1014,13 +1015,20 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// by their known types. All types returned by the infer_* functions should\n     /// be resolved as far as possible, i.e. contain no type variables with\n     /// known type.\n-    fn resolve_ty_as_possible(&mut self, ty: Ty) -> Ty {\n+    fn resolve_ty_as_possible(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n         ty.fold(&mut |ty| match ty {\n             Ty::Infer(tv) => {\n                 let inner = tv.to_inner();\n+                if tv_stack.contains(&inner) {\n+                    // recursive type\n+                    return tv.fallback_value();\n+                }\n                 if let Some(known_ty) = self.var_unification_table.probe_value(inner).known() {\n                     // known_ty may contain other variables that are known by now\n-                    self.resolve_ty_as_possible(known_ty.clone())\n+                    tv_stack.push(inner);\n+                    let result = self.resolve_ty_as_possible(tv_stack, known_ty.clone());\n+                    tv_stack.pop();\n+                    result\n                 } else {\n                     ty\n                 }\n@@ -1049,13 +1057,20 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     /// Resolves the type completely; type variables without known type are\n     /// replaced by Ty::Unknown.\n-    fn resolve_ty_completely(&mut self, ty: Ty) -> Ty {\n+    fn resolve_ty_completely(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n         ty.fold(&mut |ty| match ty {\n             Ty::Infer(tv) => {\n                 let inner = tv.to_inner();\n+                if tv_stack.contains(&inner) {\n+                    // recursive type\n+                    return tv.fallback_value();\n+                }\n                 if let Some(known_ty) = self.var_unification_table.probe_value(inner).known() {\n                     // known_ty may contain other variables that are known by now\n-                    self.resolve_ty_completely(known_ty.clone())\n+                    tv_stack.push(inner);\n+                    let result = self.resolve_ty_completely(tv_stack, known_ty.clone());\n+                    tv_stack.pop();\n+                    result\n                 } else {\n                     tv.fallback_value()\n                 }\n@@ -1070,7 +1085,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let name = path.as_ident().cloned().unwrap_or_else(Name::self_param);\n             if let Some(scope_entry) = self.scopes.resolve_local_name(expr, name) {\n                 let ty = self.type_of_pat.get(scope_entry.pat())?;\n-                let ty = self.resolve_ty_as_possible(ty.clone());\n+                let ty = self.resolve_ty_as_possible(&mut vec![], ty.clone());\n                 return Some(ty);\n             };\n         };\n@@ -1239,7 +1254,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n         self.unify(&ty, expected);\n-        let ty = self.resolve_ty_as_possible(ty);\n+        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n         self.write_pat_ty(pat, ty.clone());\n         ty\n     }\n@@ -1538,7 +1553,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n         self.unify(&ty, &expected.ty);\n-        let ty = self.resolve_ty_as_possible(ty);\n+        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n         self.write_expr_ty(tgt_expr, ty.clone());\n         ty\n     }"}, {"sha": "c3227ff7eac45c7fe459c15a8f3c0287461d15b1", "filename": "crates/ra_hir/src/ty/snapshots/tests__recursive_vars.snap", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/77f92674f9a2ea8e8cd303d15710621a4f7839cb/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__recursive_vars.snap", "raw_url": "https://github.com/rust-lang/rust/raw/77f92674f9a2ea8e8cd303d15710621a4f7839cb/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__recursive_vars.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__recursive_vars.snap?ref=77f92674f9a2ea8e8cd303d15710621a4f7839cb", "patch": "@@ -0,0 +1,14 @@\n+---\n+created: \"2019-01-26T22:42:22.329980185+00:00\"\n+creator: insta@0.5.2\n+expression: \"&result\"\n+source: crates/ra_hir/src/ty/tests.rs\n+---\n+[11; 48) '{     ...&y]; }': ()\n+[21; 22) 'y': &[unknown]\n+[25; 32) 'unknown': &[unknown]\n+[38; 45) '[y, &y]': [&&[unknown]]\n+[39; 40) 'y': &[unknown]\n+[42; 44) '&y': &&[unknown]\n+[43; 44) 'y': &[unknown]\n+"}, {"sha": "de124da5b12e4e35e2db37a0a2f36d4903561953", "filename": "crates/ra_hir/src/ty/snapshots/tests__recursive_vars_2.snap", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/77f92674f9a2ea8e8cd303d15710621a4f7839cb/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__recursive_vars_2.snap", "raw_url": "https://github.com/rust-lang/rust/raw/77f92674f9a2ea8e8cd303d15710621a4f7839cb/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__recursive_vars_2.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__recursive_vars_2.snap?ref=77f92674f9a2ea8e8cd303d15710621a4f7839cb", "patch": "@@ -0,0 +1,21 @@\n+---\n+created: \"2019-01-26T22:42:22.331805845+00:00\"\n+creator: insta@0.5.2\n+expression: \"&result\"\n+source: crates/ra_hir/src/ty/tests.rs\n+---\n+[11; 80) '{     ...x)]; }': ()\n+[21; 22) 'x': &&[unknown]\n+[25; 32) 'unknown': &&[unknown]\n+[42; 43) 'y': &&[unknown]\n+[46; 53) 'unknown': &&[unknown]\n+[59; 77) '[(x, y..., &x)]': [(&&[unknown], &&[unknown])]\n+[60; 66) '(x, y)': (&&[unknown], &&[unknown])\n+[61; 62) 'x': &&[unknown]\n+[64; 65) 'y': &&[unknown]\n+[68; 76) '(&y, &x)': (&&&[unknown], &&&[unknown])\n+[69; 71) '&y': &&&[unknown]\n+[70; 71) 'y': &&[unknown]\n+[73; 75) '&x': &&&[unknown]\n+[74; 75) 'x': &&[unknown]\n+"}, {"sha": "e34daa0f79e9e7df1190020376053c630de29300", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/77f92674f9a2ea8e8cd303d15710621a4f7839cb/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f92674f9a2ea8e8cd303d15710621a4f7839cb/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=77f92674f9a2ea8e8cd303d15710621a4f7839cb", "patch": "@@ -562,6 +562,33 @@ fn quux() {\n     );\n }\n \n+#[test]\n+fn recursive_vars() {\n+    check_inference(\n+        \"recursive_vars\",\n+        r#\"\n+fn test() {\n+    let y = unknown;\n+    [y, &y];\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn recursive_vars_2() {\n+    check_inference(\n+        \"recursive_vars_2\",\n+        r#\"\n+fn test() {\n+    let x = unknown;\n+    let y = unknown;\n+    [(x, y), (&y, &x)];\n+}\n+\"#,\n+    );\n+}\n+\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.parse(file_id);"}]}