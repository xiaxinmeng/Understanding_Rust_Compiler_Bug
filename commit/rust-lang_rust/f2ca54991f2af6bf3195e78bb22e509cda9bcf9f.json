{"sha": "f2ca54991f2af6bf3195e78bb22e509cda9bcf9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyY2E1NDk5MWYyYWY2YmYzMTk1ZTc4YmIyMmU1MDljZGE5YmNmOWY=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-07T22:03:30Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-07T22:18:48Z"}, "message": "Add sync.rs with counting blocking semaphores", "tree": {"sha": "ce6bc45a1742a143b5f5734fb8e4b223d6bb0ce1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce6bc45a1742a143b5f5734fb8e4b223d6bb0ce1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2ca54991f2af6bf3195e78bb22e509cda9bcf9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2ca54991f2af6bf3195e78bb22e509cda9bcf9f", "html_url": "https://github.com/rust-lang/rust/commit/f2ca54991f2af6bf3195e78bb22e509cda9bcf9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2ca54991f2af6bf3195e78bb22e509cda9bcf9f/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2", "html_url": "https://github.com/rust-lang/rust/commit/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2"}], "stats": {"total": 192, "additions": 191, "deletions": 1}, "files": [{"sha": "06b9c6f2c9e0db9a7e4933f22eed58844a01c455", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2ca54991f2af6bf3195e78bb22e509cda9bcf9f/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f2ca54991f2af6bf3195e78bb22e509cda9bcf9f/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=f2ca54991f2af6bf3195e78bb22e509cda9bcf9f", "patch": "@@ -39,7 +39,7 @@ export float, f32, f64;\n export box, char, str, ptr, vec, at_vec, bool;\n export either, option, result, iter;\n export libc, os, io, run, rand, sys, unsafe, logging;\n-export arc, comm, task, future, pipes;\n+export arc, comm, task, future, pipes, sync;\n export extfmt;\n // The test harness links against core, so don't include runtime in tests.\n // FIXME (#2861): Uncomment this after snapshot gets updated.\n@@ -204,6 +204,7 @@ mod comm;\n mod task;\n mod future;\n mod pipes;\n+mod sync;\n \n // Runtime and language-primitive support\n "}, {"sha": "3e18a9b1634df14ad718db4f47bc344a0eff2547", "filename": "src/libcore/sync.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/f2ca54991f2af6bf3195e78bb22e509cda9bcf9f/src%2Flibcore%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2ca54991f2af6bf3195e78bb22e509cda9bcf9f/src%2Flibcore%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync.rs?ref=f2ca54991f2af6bf3195e78bb22e509cda9bcf9f", "patch": "@@ -0,0 +1,189 @@\n+/**\n+ * The concurrency primitives you know and love.\n+ *\n+ * Maybe once we have a \"core exports x only to std\" mechanism, these can be\n+ * in std.\n+ */\n+\n+export semaphore, new_semaphore;\n+\n+// FIXME (#3119) This shouldn't be a thing exported from core.\n+import arc::exclusive;\n+\n+// Each waiting task receives on one of these. FIXME #3125 make these oneshot.\n+type wait_end = pipes::port<()>;\n+type signal_end = pipes::chan<()>;\n+// A doubly-ended queue of waiting tasks.\n+type waitqueue = { head: pipes::port<signal_end>,\n+                   tail: pipes::chan<signal_end> };\n+\n+fn new_waiter() -> (signal_end, wait_end) { pipes::stream() }\n+\n+/// A counting semaphore.\n+enum semaphore = exclusive<{\n+    mut count: int,\n+    waiters:   waitqueue,\n+}>;\n+\n+/// Create a new semaphore with the specified count.\n+fn new_semaphore(count: int) -> semaphore {\n+    let (tail, head) = pipes::stream();\n+    semaphore(exclusive({ mut count: count,\n+                          waiters: { head: head, tail: tail } }))\n+}\n+\n+impl semaphore for &semaphore {\n+    /// Creates a new handle to the semaphore.\n+    fn clone() -> semaphore {\n+        semaphore((**self).clone())\n+    }\n+\n+    /**\n+     * Acquires a resource represented by the semaphore. Blocks if necessary\n+     * until resource(s) become available.\n+     */\n+    fn wait() {\n+        let mut waiter_nobe = none;\n+        unsafe {\n+            do (**self).with |state| {\n+                state.count -= 1;\n+                if state.count < 0 {\n+                    let (signal_end,wait_end) = new_waiter();\n+                    waiter_nobe = some(wait_end);\n+                    // Enqueue ourself.\n+                    state.waiters.tail.send(signal_end);\n+                }\n+            }\n+        }\n+        for 1000.times { task::yield(); }\n+        // Need to wait outside the exclusive.\n+        if waiter_nobe.is_some() {\n+            let _ = option::unwrap(waiter_nobe).recv();\n+        }\n+    }\n+\n+    /**\n+     * Release a held resource represented by the semaphore. Wakes a blocked\n+     * contending task, if any exist.\n+     */\n+    fn signal() {\n+        unsafe {\n+            do (**self).with |state| {\n+                state.count += 1;\n+                // The peek is mandatory to make sure recv doesn't block.\n+                if state.count >= 0 && state.waiters.head.peek() {\n+                    // Pop off the waitqueue and send a wakeup signal. If the\n+                    // waiter was killed, its port will have closed, and send\n+                    // will fail. Keep trying until we get a live task.\n+                    state.waiters.head.recv().send(());\n+                    // to-do: use this version when it's ready, kill-friendly.\n+                    // while !state.waiters.head.recv().try_send(()) { }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Runs a function with ownership of one of the semaphore's resources.\n+    fn access<U>(blk: fn() -> U) -> U {\n+        self.wait();\n+        let _x = sem_release(self);\n+        blk()\n+    }\n+}\n+\n+// FIXME(#3136) should go inside of access()\n+struct sem_release {\n+    sem: &semaphore;\n+    new(sem: &semaphore) { self.sem = sem; }\n+    drop { self.sem.signal(); }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_sem_as_mutex() {\n+        let s = ~new_semaphore(1);\n+        let s2 = ~s.clone();\n+        do task::spawn {\n+            do s2.access {\n+                for 10.times { task::yield(); }\n+            }\n+        }\n+        do s.access {\n+            for 10.times { task::yield(); }\n+        }\n+    }\n+    #[test]\n+    fn test_sem_as_cvar() {\n+        /* Child waits and parent signals */\n+        let (c,p) = pipes::stream();\n+        let s = ~new_semaphore(0);\n+        let s2 = ~s.clone();\n+        do task::spawn {\n+            s2.wait();\n+            c.send(());\n+        }\n+        for 10.times { task::yield(); }\n+        s.signal();\n+        let _ = p.recv();\n+        \n+        /* Parent waits and child signals */\n+        let (c,p) = pipes::stream();\n+        let s = ~new_semaphore(0);\n+        let s2 = ~s.clone();\n+        do task::spawn {\n+            for 10.times { task::yield(); }\n+            s2.signal();\n+            let _ = p.recv();\n+        }\n+        s.wait();\n+        c.send(());\n+    }\n+    #[test]\n+    fn test_sem_mutual_exclusion() {\n+        let (c,p) = pipes::stream();\n+        let s = ~new_semaphore(1);\n+        let s2 = ~s.clone();\n+        let sharedstate = ~0;\n+        let ptr = ptr::addr_of(*sharedstate);\n+        do task::spawn {\n+            let sharedstate = unsafe { unsafe::reinterpret_cast(ptr) };\n+            access_shared(sharedstate, s2, 10);\n+            c.send(());\n+        }\n+        access_shared(sharedstate, s, 10);\n+        let _ = p.recv();\n+\n+        assert *sharedstate == 20;\n+\n+        fn access_shared(sharedstate: &mut int, sem: &semaphore, n: uint) {\n+            for n.times {\n+                do sem.access {\n+                    let oldval = *sharedstate;\n+                    task::yield();\n+                    *sharedstate = oldval + 1;\n+                }\n+            }\n+        }\n+    }\n+    #[test]\n+    fn test_sem_runtime_friendly_blocking() {\n+        do task::spawn_sched(task::manual_threads(1)) {\n+            let s = ~new_semaphore(1);\n+            let s2 = ~s.clone();\n+            let (c,p) = pipes::stream();\n+            let child_data = ~mut some((s2,c));\n+            do s.access {\n+                let (s2,c) = option::swap_unwrap(child_data);\n+                do task::spawn {\n+                    c.send(());\n+                    do s2.access { }\n+                    c.send(());\n+                }\n+                let _ = p.recv(); // wait for child to come alive\n+                for 5.times { task::yield(); } // let the child contend\n+            }\n+            let _ = p.recv(); // wait for child to be done\n+        }\n+    }\n+}"}]}