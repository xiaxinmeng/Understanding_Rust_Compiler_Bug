{"sha": "e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5YmMxYmFjOGM3NjY0ZmIxYjQ4Nzg3OWIzZmJkNTYyMjFmNmE3MjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-24T21:57:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-24T21:57:34Z"}, "message": "Auto merge of #35764 - eddyb:byegone, r=nikomatsakis\n\nRemove the old AST-based backend from rustc_trans.\n\nStarting with Rust 1.13, `--disable-orbit` , `-Z orbit=off` and `#[rustc_no_mir]` have been removed.\nOnly the new MIR backend is left in the compiler, and only early const_eval uses ASTs from other crates.\n\nFilling drop (previously \"zeroing drop\"), `#[unsafe_no_drop_flag]` and associated unstable APIs are gone.\nImplementing `Drop` doesn't add a flag anymore to the type, all of the dynamic drop is function local.\nThis is a [breaking-change], please use `Option::None` and/or `mem::forget` if you are unsure about your ability to prevent/control the drop of a value. In the future, `union` will be usable in some such cases.\n\n**NOTE**: DO NOT MERGE before we get the new beta as the stage0, there's some cruft to remove.\n\nAll of this will massively simplify any efforts to implement (and as such it blocks) features such as `union`s, safe use of `#[packed]` or new type layout optimizations, not to mention many other experiments.", "tree": {"sha": "2a0739eb6851ceb45abcc38d7fe8d8ff18e71962", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a0739eb6851ceb45abcc38d7fe8d8ff18e71962"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "html_url": "https://github.com/rust-lang/rust/commit/e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03e23c7f9a10b18e1687bfd92c6807e9342aa00b", "url": "https://api.github.com/repos/rust-lang/rust/commits/03e23c7f9a10b18e1687bfd92c6807e9342aa00b", "html_url": "https://github.com/rust-lang/rust/commit/03e23c7f9a10b18e1687bfd92c6807e9342aa00b"}, {"sha": "25cf8001b1352fdaccdd1d71071c941f99acc2a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/25cf8001b1352fdaccdd1d71071c941f99acc2a1", "html_url": "https://github.com/rust-lang/rust/commit/25cf8001b1352fdaccdd1d71071c941f99acc2a1"}], "stats": {"total": 13468, "additions": 886, "deletions": 12582}, "files": [{"sha": "a48ff6a76109c37a618dbd9179181f87737cfa15", "filename": "configure", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/configure", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -733,8 +733,6 @@ if [ -n \"$CFG_ENABLE_DEBUG_ASSERTIONS\" ]; then putvar CFG_ENABLE_DEBUG_ASSERTION\n if [ -n \"$CFG_ENABLE_DEBUGINFO\" ]; then putvar CFG_ENABLE_DEBUGINFO; fi\n if [ -n \"$CFG_ENABLE_DEBUG_JEMALLOC\" ]; then putvar CFG_ENABLE_DEBUG_JEMALLOC; fi\n \n-if [ -n \"$CFG_DISABLE_ORBIT\" ]; then putvar CFG_DISABLE_ORBIT; fi\n-\n step_msg \"looking for build programs\"\n \n probe_need CFG_CURL curl"}, {"sha": "428d9d16182abd52df65e641c7866b35ad371579", "filename": "mk/main.mk", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -162,12 +162,6 @@ ifdef CFG_ENABLE_DEBUGINFO\n   CFG_RUSTC_FLAGS += -g\n endif\n \n-ifdef CFG_DISABLE_ORBIT\n-  $(info cfg: HOLD HOLD HOLD (CFG_DISABLE_ORBIT))\n-  RUSTFLAGS_STAGE1 += -Z orbit=off\n-  RUSTFLAGS_STAGE2 += -Z orbit=off\n-endif\n-\n ifdef SAVE_TEMPS\n   CFG_RUSTC_FLAGS += -C save-temps\n endif"}, {"sha": "9c9f1e7b9de07768d93c2c7c78809eed917796c0", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -121,7 +121,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// }\n /// ```\n \n-#[unsafe_no_drop_flag]\n+#[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n     ptr: Shared<ArcInner<T>>,\n@@ -147,7 +147,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n /// nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n /// as `Weak<T>` pointers.\n \n-#[unsafe_no_drop_flag]\n+#[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     ptr: Shared<ArcInner<T>>,\n@@ -559,15 +559,6 @@ impl<T: ?Sized> Drop for Arc<T> {\n     #[unsafe_destructor_blind_to_params]\n     #[inline]\n     fn drop(&mut self) {\n-        // This structure has #[unsafe_no_drop_flag], so this drop glue may run\n-        // more than once (but it is guaranteed to be zeroed after the first if\n-        // it's run more than once)\n-        let thin = *self.ptr as *const ();\n-\n-        if thin as usize == mem::POST_DROP_USIZE {\n-            return;\n-        }\n-\n         // Because `fetch_sub` is already atomic, we do not need to synchronize\n         // with other threads unless we are going to delete the object. This\n         // same logic applies to the below `fetch_sub` to the `weak` count.\n@@ -755,12 +746,6 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// ```\n     fn drop(&mut self) {\n         let ptr = *self.ptr;\n-        let thin = ptr as *const ();\n-\n-        // see comments above for why this check is here\n-        if thin as usize == mem::POST_DROP_USIZE {\n-            return;\n-        }\n \n         // If we find out that we were the last weak pointer, then its time to\n         // deallocate the data entirely. See the discussion in Arc::drop() about"}, {"sha": "d9fd2d92710dc5c75b873e4577a62c28b11c2755", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -88,7 +88,7 @@\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unique)]\n-#![feature(unsafe_no_drop_flag, filling_drop)]\n+#![cfg_attr(stage0, feature(unsafe_no_drop_flag))]\n #![feature(unsize)]\n \n #![cfg_attr(not(test), feature(fused, raw, fn_traits, placement_new_protocol))]"}, {"sha": "23542215fa890a7f4ddffb236a6cc714bc4a7ca2", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -44,7 +44,7 @@ use core::cmp;\n /// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n-#[unsafe_no_drop_flag]\n+#[cfg_attr(stage0, unsafe_no_drop_flag)]\n pub struct RawVec<T> {\n     ptr: Unique<T>,\n     cap: usize,\n@@ -546,21 +546,14 @@ impl<T> RawVec<T> {\n         mem::forget(self);\n         output\n     }\n-\n-    /// This is a stupid name in the hopes that someone will find this in the\n-    /// not too distant future and remove it with the rest of\n-    /// #[unsafe_no_drop_flag]\n-    pub fn unsafe_no_drop_flag_needs_drop(&self) -> bool {\n-        self.cap != mem::POST_DROP_USIZE\n-    }\n }\n \n impl<T> Drop for RawVec<T> {\n     #[unsafe_destructor_blind_to_params]\n     /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n     fn drop(&mut self) {\n         let elem_size = mem::size_of::<T>();\n-        if elem_size != 0 && self.cap != 0 && self.unsafe_no_drop_flag_needs_drop() {\n+        if elem_size != 0 && self.cap != 0 {\n             let align = mem::align_of::<T>();\n \n             let num_bytes = elem_size * self.cap;"}, {"sha": "8e43e9eec16085c44f16282f35c3cce7d46749d4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -182,7 +182,7 @@ struct RcBox<T: ?Sized> {\n /// A reference-counted pointer type over an immutable value.\n ///\n /// See the [module level documentation](./index.html) for more details.\n-#[unsafe_no_drop_flag]\n+#[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n     ptr: Shared<RcBox<T>>,\n@@ -466,21 +466,18 @@ impl<T: ?Sized> Drop for Rc<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = *self.ptr;\n-            let thin = ptr as *const ();\n \n-            if thin as usize != mem::POST_DROP_USIZE {\n-                self.dec_strong();\n-                if self.strong() == 0 {\n-                    // destroy the contained object\n-                    ptr::drop_in_place(&mut (*ptr).value);\n+            self.dec_strong();\n+            if self.strong() == 0 {\n+                // destroy the contained object\n+                ptr::drop_in_place(&mut (*ptr).value);\n \n-                    // remove the implicit \"strong weak\" pointer now that we've\n-                    // destroyed the contents.\n-                    self.dec_weak();\n+                // remove the implicit \"strong weak\" pointer now that we've\n+                // destroyed the contents.\n+                self.dec_weak();\n \n-                    if self.weak() == 0 {\n-                        deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n-                    }\n+                if self.weak() == 0 {\n+                    deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n                 }\n             }\n         }\n@@ -724,7 +721,7 @@ impl<T> From<T> for Rc<T> {\n /// dropped.\n ///\n /// See the [module level documentation](./index.html) for more.\n-#[unsafe_no_drop_flag]\n+#[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     ptr: Shared<RcBox<T>>,\n@@ -825,15 +822,12 @@ impl<T: ?Sized> Drop for Weak<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = *self.ptr;\n-            let thin = ptr as *const ();\n \n-            if thin as usize != mem::POST_DROP_USIZE {\n-                self.dec_weak();\n-                // the weak count starts at 1, and will only go to zero if all\n-                // the strong pointers have disappeared.\n-                if self.weak() == 0 {\n-                    deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n-                }\n+            self.dec_weak();\n+            // the weak count starts at 1, and will only go to zero if all\n+            // the strong pointers have disappeared.\n+            if self.weak() == 0 {\n+                deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n             }\n         }\n     }"}, {"sha": "c5a921693475a60e7ec1abfef9f78274ef742c11", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -52,7 +52,7 @@\n #![feature(step_by)]\n #![feature(unicode)]\n #![feature(unique)]\n-#![feature(unsafe_no_drop_flag)]\n+#![cfg_attr(stage0, feature(unsafe_no_drop_flag))]\n #![cfg_attr(test, feature(rand, test))]\n \n #![no_std]"}, {"sha": "876314613f523fa675cf4dee5dbb801cea160bb9", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -268,7 +268,7 @@ use super::range::RangeArgument;\n /// Vec does not currently guarantee the order in which elements are dropped\n /// (the order has changed in the past, and may change again).\n ///\n-#[unsafe_no_drop_flag]\n+#[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n     buf: RawVec<T>,\n@@ -1600,11 +1600,9 @@ impl<T: Ord> Ord for Vec<T> {\n impl<T> Drop for Vec<T> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n-        if self.buf.unsafe_no_drop_flag_needs_drop() {\n-            unsafe {\n-                // use drop for [T]\n-                ptr::drop_in_place(&mut self[..]);\n-            }\n+        unsafe {\n+            // use drop for [T]\n+            ptr::drop_in_place(&mut self[..]);\n         }\n         // RawVec handles deallocation\n     }"}, {"sha": "3c2c5abcb2821ce7ccb81be4838e6a43facb869b", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -244,19 +244,6 @@ extern \"rust-intrinsic\" {\n     /// crate it is invoked in.\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n-    /// Creates a value initialized to so that its drop flag,\n-    /// if any, says that it has been dropped.\n-    ///\n-    /// `init_dropped` is unsafe because it returns a datum with all\n-    /// of its bytes set to the drop flag, which generally does not\n-    /// correspond to a valid value.\n-    ///\n-    /// This intrinsic is likely to be deprecated in the future when\n-    /// Rust moves to non-zeroing dynamic drop (and thus removes the\n-    /// embedded drop flags that are being established by this\n-    /// intrinsic).\n-    pub fn init_dropped<T>() -> T;\n-\n     /// Creates a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,"}, {"sha": "6ebbe97d064a2c23521f247dc4e4e31bdea0af52", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -241,27 +241,6 @@ pub unsafe fn zeroed<T>() -> T {\n     intrinsics::init()\n }\n \n-/// Creates a value initialized to an unspecified series of bytes.\n-///\n-/// The byte sequence usually indicates that the value at the memory\n-/// in question has been dropped. Thus, *if* T carries a drop flag,\n-/// any associated destructor will not be run when the value falls out\n-/// of scope.\n-///\n-/// Some code at one time used the `zeroed` function above to\n-/// accomplish this goal.\n-///\n-/// This function is expected to be deprecated with the transition\n-/// to non-zeroing drop.\n-#[inline]\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-pub unsafe fn dropped<T>() -> T {\n-    #[inline(always)]\n-    unsafe fn dropped_impl<T>() -> T { intrinsics::init_dropped() }\n-\n-    dropped_impl()\n-}\n-\n /// Bypasses Rust's normal memory-initialization checks by pretending to\n /// produce a value of type T, while doing nothing at all.\n ///\n@@ -518,56 +497,6 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn drop<T>(_x: T) { }\n \n-macro_rules! repeat_u8_as_u16 {\n-    ($name:expr) => { (($name as u16) <<  8 |\n-                       ($name as u16)) }\n-}\n-macro_rules! repeat_u8_as_u32 {\n-    ($name:expr) => { (($name as u32) << 24 |\n-                       ($name as u32) << 16 |\n-                       ($name as u32) <<  8 |\n-                       ($name as u32)) }\n-}\n-macro_rules! repeat_u8_as_u64 {\n-    ($name:expr) => { ((repeat_u8_as_u32!($name) as u64) << 32 |\n-                       (repeat_u8_as_u32!($name) as u64)) }\n-}\n-\n-// NOTE: Keep synchronized with values used in librustc_trans::trans::adt.\n-//\n-// In particular, the POST_DROP_U8 marker must never equal the\n-// DTOR_NEEDED_U8 marker.\n-//\n-// For a while pnkfelix was using 0xc1 here.\n-// But having the sign bit set is a pain, so 0x1d is probably better.\n-//\n-// And of course, 0x00 brings back the old world of zero'ing on drop.\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-#[allow(missing_docs)]\n-pub const POST_DROP_U8: u8 = 0x1d;\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-#[allow(missing_docs)]\n-pub const POST_DROP_U16: u16 = repeat_u8_as_u16!(POST_DROP_U8);\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-#[allow(missing_docs)]\n-pub const POST_DROP_U32: u32 = repeat_u8_as_u32!(POST_DROP_U8);\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-#[allow(missing_docs)]\n-pub const POST_DROP_U64: u64 = repeat_u8_as_u64!(POST_DROP_U8);\n-\n-#[cfg(target_pointer_width = \"16\")]\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-#[allow(missing_docs)]\n-pub const POST_DROP_USIZE: usize = POST_DROP_U16 as usize;\n-#[cfg(target_pointer_width = \"32\")]\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-#[allow(missing_docs)]\n-pub const POST_DROP_USIZE: usize = POST_DROP_U32 as usize;\n-#[cfg(target_pointer_width = \"64\")]\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-#[allow(missing_docs)]\n-pub const POST_DROP_USIZE: usize = POST_DROP_U64 as usize;\n-\n /// Interprets `src` as `&U`, and then reads `src` without moving the contained\n /// value.\n ///"}, {"sha": "dd76843793332f407514e850087cffde7494a039", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -140,21 +140,6 @@ pub unsafe fn read<T>(src: *const T) -> T {\n     tmp\n }\n \n-#[allow(missing_docs)]\n-#[inline(always)]\n-#[unstable(feature = \"filling_drop\",\n-           reason = \"may play a larger role in std::ptr future extensions\",\n-           issue = \"5016\")]\n-pub unsafe fn read_and_drop<T>(dest: *mut T) -> T {\n-    // Copy the data out from `dest`:\n-    let tmp = read(&*dest);\n-\n-    // Now mark `dest` as dropped:\n-    write_bytes(dest, mem::POST_DROP_U8, 1);\n-\n-    tmp\n-}\n-\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///"}, {"sha": "5e14bb51ce8672fe5dffd5ec332d8bf7cc543dd1", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -315,8 +315,7 @@ impl<'ast> Map<'ast> {\n                     RootInlinedParent(parent) => match *parent {\n                         InlinedItem::Item(def_id, _) |\n                         InlinedItem::TraitItem(def_id, _) |\n-                        InlinedItem::ImplItem(def_id, _) |\n-                        InlinedItem::Foreign(def_id, _) =>\n+                        InlinedItem::ImplItem(def_id, _) =>\n                             return DepNode::MetaData(def_id)\n                     },\n \n@@ -940,8 +939,6 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n             II::ImplItem(fld.fold_ops.new_def_id(d),\n                          ii.map(|ii| fld.fold_impl_item(ii)))\n         }\n-        II::Foreign(d, i) => II::Foreign(fld.fold_ops.new_def_id(d),\n-                                         i.map(|i| fld.fold_foreign_item(i)))\n     };\n \n     let ii = map.forest.inlined_items.alloc(ii);"}, {"sha": "92e1b0681cc7e24eef7edfa61322e777e7481f83", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -96,17 +96,15 @@ pub enum DefLike {\n pub enum InlinedItem {\n     Item(DefId /* def-id in source crate */, P<hir::Item>),\n     TraitItem(DefId /* impl id */, P<hir::TraitItem>),\n-    ImplItem(DefId /* impl id */, P<hir::ImplItem>),\n-    Foreign(DefId /* extern item */, P<hir::ForeignItem>),\n+    ImplItem(DefId /* impl id */, P<hir::ImplItem>)\n }\n \n /// A borrowed version of `hir::InlinedItem`.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InlinedItemRef<'a> {\n     Item(DefId, &'a hir::Item),\n     TraitItem(DefId, &'a hir::TraitItem),\n-    ImplItem(DefId, &'a hir::ImplItem),\n-    Foreign(DefId, &'a hir::ForeignItem)\n+    ImplItem(DefId, &'a hir::ImplItem)\n }\n \n /// Item definitions in the currently-compiled crate would have the CrateNum\n@@ -286,7 +284,6 @@ impl InlinedItem {\n     {\n         match *self {\n             InlinedItem::Item(_, ref i) => visitor.visit_item(&i),\n-            InlinedItem::Foreign(_, ref i) => visitor.visit_foreign_item(&i),\n             InlinedItem::TraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n             InlinedItem::ImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n         }"}, {"sha": "a991a1a9ba4b53a36b9be93d06a2f95e214e7b37", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -605,8 +605,6 @@ macro_rules! options {\n         pub const parse_bool: Option<&'static str> = None;\n         pub const parse_opt_bool: Option<&'static str> =\n             Some(\"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\");\n-        pub const parse_all_bool: Option<&'static str> =\n-            Some(\"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\");\n         pub const parse_string: Option<&'static str> = Some(\"a string\");\n         pub const parse_opt_string: Option<&'static str> = Some(\"a string\");\n         pub const parse_list: Option<&'static str> = Some(\"a space-separated list of strings\");\n@@ -656,25 +654,6 @@ macro_rules! options {\n             }\n         }\n \n-        fn parse_all_bool(slot: &mut bool, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => {\n-                    match s {\n-                        \"n\" | \"no\" | \"off\" => {\n-                            *slot = false;\n-                        }\n-                        \"y\" | \"yes\" | \"on\" => {\n-                            *slot = true;\n-                        }\n-                        _ => { return false; }\n-                    }\n-\n-                    true\n-                },\n-                None => { *slot = true; true }\n-            }\n-        }\n-\n         fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n             match v {\n                 Some(s) => { *slot = Some(s.to_string()); true },\n@@ -910,8 +889,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"adds unstable command line options to rustc interface\"),\n     force_overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n           \"force overflow checks on or off\"),\n-    force_dropflag_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-          \"force drop flag checks on or off\"),\n     trace_macros: bool = (false, parse_bool, [UNTRACKED],\n           \"for every macro invocation, print its name and arguments\"),\n     enable_nonzeroing_move_hints: bool = (false, parse_bool, [TRACKED],\n@@ -930,8 +907,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"dump MIR state at various points in translation\"),\n     dump_mir_dir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"the directory the MIR is dumped into\"),\n-    orbit: bool = (true, parse_all_bool, [UNTRACKED],\n-          \"get MIR where it belongs - everywhere; most importantly, in orbit\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -1324,15 +1299,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         })\n     });\n \n-    let mut debugging_opts = build_debugging_options(matches, error_format);\n-\n-    // Incremental compilation only works reliably when translation is done via\n-    // MIR, so let's enable -Z orbit if necessary (see #34973).\n-    if debugging_opts.incremental.is_some() && !debugging_opts.orbit {\n-        early_warn(error_format, \"Automatically enabling `-Z orbit` because \\\n-                                  `-Z incremental` was specified\");\n-        debugging_opts.orbit = true;\n-    }\n+    let debugging_opts = build_debugging_options(matches, error_format);\n \n     let mir_opt_level = debugging_opts.mir_opt_level.unwrap_or(1);\n \n@@ -2424,8 +2391,6 @@ mod tests {\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.dump_mir_dir = Some(String::from(\"abc\"));\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.orbit = false;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n         // Make sure changing a [TRACKED] option changes the hash\n         opts = reference.clone();\n@@ -2460,10 +2425,6 @@ mod tests {\n         opts.debugging_opts.force_overflow_checks = Some(true);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n-        opts = reference.clone();\n-        opts.debugging_opts.force_dropflag_checks = Some(true);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n         opts = reference.clone();\n         opts.debugging_opts.enable_nonzeroing_move_hints = true;\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());"}, {"sha": "1ede8545e08e873a5ffa95dd9c236f097e67d8ba", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -891,17 +891,6 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let mut st = Struct::new(dl, packed);\n                 st.extend(dl, fields, ty)?;\n \n-                // FIXME(16758) don't add a drop flag to unsized structs, as it\n-                // won't actually be in the location we say it is because it'll be after\n-                // the unsized field. Several other pieces of code assume that the unsized\n-                // field is definitely the last one.\n-                if def.dtor_kind().has_drop_flag() &&\n-                   ty.is_sized(tcx, &infcx.parameter_environment, DUMMY_SP) {\n-                    st.extend(dl, Some(Ok(&Scalar {\n-                        value: Int(I8),\n-                        non_zero: false\n-                    })).into_iter(), ty)?;\n-                }\n                 Univariant {\n                     variant: st,\n                     non_zero: Some(def.did) == tcx.lang_items.non_zero()\n@@ -911,24 +900,18 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let hint = *tcx.lookup_repr_hints(def.did).get(0)\n                     .unwrap_or(&attr::ReprAny);\n \n-                let dtor = def.dtor_kind().has_drop_flag();\n-                let drop_flag = if dtor {\n-                    Some(Scalar { value: Int(I8), non_zero: false })\n-                } else {\n-                    None\n-                };\n-\n                 if def.variants.is_empty() {\n                     // Uninhabitable; represent as unit\n                     // (Typechecking will reject discriminant-sizing attrs.)\n                     assert_eq!(hint, attr::ReprAny);\n \n-                    let mut st = Struct::new(dl, false);\n-                    st.extend(dl, drop_flag.iter().map(Ok), ty)?;\n-                    return success(Univariant { variant: st, non_zero: false });\n+                    return success(Univariant {\n+                        variant: Struct::new(dl, false),\n+                        non_zero: false\n+                    });\n                 }\n \n-                if !dtor && def.variants.iter().all(|v| v.fields.is_empty()) {\n+                if def.variants.iter().all(|v| v.fields.is_empty()) {\n                     // All bodies empty -> intlike\n                     let (mut min, mut max) = (i64::MAX, i64::MIN);\n                     for v in &def.variants {\n@@ -964,7 +947,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         field.ty(tcx, substs).layout(infcx)\n                     });\n                     let mut st = Struct::new(dl, false);\n-                    st.extend(dl, fields.chain(drop_flag.iter().map(Ok)), ty)?;\n+                    st.extend(dl, fields, ty)?;\n                     return success(Univariant { variant: st, non_zero: false });\n                 }\n \n@@ -973,7 +956,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n                 }).collect::<Vec<_>>();\n \n-                if !dtor && variants.len() == 2 && hint == attr::ReprAny {\n+                if variants.len() == 2 && hint == attr::ReprAny {\n                     // Nullable pointer optimization\n                     for discr in 0..2 {\n                         let other_fields = variants[1 - discr].iter().map(|ty| {\n@@ -1045,8 +1028,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         Ok(field)\n                     });\n                     let mut st = Struct::new(dl, false);\n-                    st.extend(dl, discr.iter().map(Ok).chain(fields)\n-                                              .chain(drop_flag.iter().map(Ok)), ty)?;\n+                    st.extend(dl, discr.iter().map(Ok).chain(fields), ty)?;\n                     size = cmp::max(size, st.min_size());\n                     align = align.max(st.align);\n                     Ok(st)\n@@ -1277,11 +1259,6 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n                     return Err(err);\n                 }\n \n-                // If there's a drop flag, it can't be just a pointer.\n-                if def.dtor_kind().has_drop_flag() {\n-                    return Err(err);\n-                }\n-\n                 // Get a zero-sized variant or a pointer newtype.\n                 let zero_or_ptr_variant = |i: usize| {\n                     let fields = def.variants[i].fields.iter().map(|field| {"}, {"sha": "6c82157c8ca7c900039325e6e015a378e48cd16c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -122,23 +122,16 @@ pub struct CrateAnalysis<'a> {\n #[derive(Copy, Clone)]\n pub enum DtorKind {\n     NoDtor,\n-    TraitDtor(bool)\n+    TraitDtor\n }\n \n impl DtorKind {\n     pub fn is_present(&self) -> bool {\n         match *self {\n-            TraitDtor(..) => true,\n+            TraitDtor => true,\n             _ => false\n         }\n     }\n-\n-    pub fn has_drop_flag(&self) -> bool {\n-        match self {\n-            &NoDtor => false,\n-            &TraitDtor(flag) => flag\n-        }\n-    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n@@ -1440,7 +1433,6 @@ bitflags! {\n         const IS_PHANTOM_DATA     = 1 << 3,\n         const IS_SIMD             = 1 << 4,\n         const IS_FUNDAMENTAL      = 1 << 5,\n-        const IS_NO_DROP_FLAG     = 1 << 6,\n     }\n }\n \n@@ -1558,9 +1550,6 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n         if attr::contains_name(&attrs, \"fundamental\") {\n             flags = flags | AdtFlags::IS_FUNDAMENTAL;\n         }\n-        if attr::contains_name(&attrs, \"unsafe_no_drop_flag\") {\n-            flags = flags | AdtFlags::IS_NO_DROP_FLAG;\n-        }\n         if tcx.lookup_simd(did) {\n             flags = flags | AdtFlags::IS_SIMD;\n         }\n@@ -1627,10 +1616,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n \n     /// Returns whether this type has a destructor.\n     pub fn has_dtor(&self) -> bool {\n-        match self.dtor_kind() {\n-            NoDtor => false,\n-            TraitDtor(..) => true\n-        }\n+        self.dtor_kind().is_present()\n     }\n \n     /// Asserts this is a struct and returns the struct's unique\n@@ -1710,9 +1696,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n \n     pub fn dtor_kind(&self) -> DtorKind {\n         match self.destructor.get() {\n-            Some(_) => {\n-                TraitDtor(!self.flags.get().intersects(AdtFlags::IS_NO_DROP_FLAG))\n-            }\n+            Some(_) => TraitDtor,\n             None => NoDtor,\n         }\n     }"}, {"sha": "b4a2648b5dca7022c756bedbde457dc51d55e5cd", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 54, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -45,7 +45,7 @@ use std::collections::HashSet;\n \n use syntax::{ast};\n use syntax::attr::{self, AttrMetaMethods, AttributeMethods};\n-use syntax_pos::{self, Span};\n+use syntax_pos::Span;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit::FnKind;\n@@ -1154,56 +1154,3 @@ impl LateLintPass for UnstableFeatures {\n         }\n     }\n }\n-\n-/// Lints for attempts to impl Drop on types that have `#[repr(C)]`\n-/// attribute (see issue #24585).\n-#[derive(Copy, Clone)]\n-pub struct DropWithReprExtern;\n-\n-declare_lint! {\n-    DROP_WITH_REPR_EXTERN,\n-    Warn,\n-    \"use of #[repr(C)] on a type that implements Drop\"\n-}\n-\n-impl LintPass for DropWithReprExtern {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(DROP_WITH_REPR_EXTERN)\n-    }\n-}\n-\n-impl LateLintPass for DropWithReprExtern {\n-    fn check_crate(&mut self, ctx: &LateContext, _: &hir::Crate) {\n-        let drop_trait = match ctx.tcx.lang_items.drop_trait() {\n-            Some(id) => ctx.tcx.lookup_trait_def(id), None => { return }\n-        };\n-        drop_trait.for_each_impl(ctx.tcx, |drop_impl_did| {\n-            if !drop_impl_did.is_local() {\n-                return;\n-            }\n-            let dtor_self_type = ctx.tcx.lookup_item_type(drop_impl_did).ty;\n-\n-            match dtor_self_type.sty {\n-                ty::TyEnum(self_type_def, _) |\n-                ty::TyStruct(self_type_def, _) => {\n-                    let self_type_did = self_type_def.did;\n-                    let hints = ctx.tcx.lookup_repr_hints(self_type_did);\n-                    if hints.iter().any(|attr| *attr == attr::ReprExtern) &&\n-                        self_type_def.dtor_kind().has_drop_flag() {\n-                        let drop_impl_span = ctx.tcx.map.def_id_span(drop_impl_did,\n-                                                                     syntax_pos::DUMMY_SP);\n-                        let self_defn_span = ctx.tcx.map.def_id_span(self_type_did,\n-                                                                     syntax_pos::DUMMY_SP);\n-                        ctx.span_lint_note(DROP_WITH_REPR_EXTERN,\n-                                           drop_impl_span,\n-                                           \"implementing Drop adds hidden state to types, \\\n-                                            possibly conflicting with `#[repr(C)]`\",\n-                                            self_defn_span,\n-                                            \"the `#[repr(C)]` attribute is attached here\");\n-                    }\n-                }\n-                _ => {}\n-            }\n-        })\n-    }\n-}"}, {"sha": "1a4330f58c3cd7012d4c91c700f61dd5a238e84e", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -127,7 +127,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  UnconditionalRecursion,\n                  InvalidNoMangleItems,\n                  PluginAsLibrary,\n-                 DropWithReprExtern,\n                  MutableTransmutes,\n                  );\n \n@@ -218,4 +217,5 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     // This was renamed to raw_pointer_derive, which was then removed,\n     // so it is also considered removed\n     store.register_removed(\"raw_pointer_deriving\", \"using derive with raw pointers is ok\");\n+    store.register_removed(\"drop_with_repr_extern\", \"drop flags have been removed\");\n }"}, {"sha": "ad52d346857ffb0ab25d7d85e779bacfb62d5775", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -79,7 +79,6 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            ii: InlinedItemRef) {\n     let id = match ii {\n         InlinedItemRef::Item(_, i) => i.id,\n-        InlinedItemRef::Foreign(_, i) => i.id,\n         InlinedItemRef::TraitItem(_, ti) => ti.id,\n         InlinedItemRef::ImplItem(_, ii) => ii.id,\n     };\n@@ -147,7 +146,6 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n                                        dcx);\n     let name = match *ii {\n         InlinedItem::Item(_, ref i) => i.name,\n-        InlinedItem::Foreign(_, ref i) => i.name,\n         InlinedItem::TraitItem(_, ref ti) => ti.name,\n         InlinedItem::ImplItem(_, ref ii) => ii.name\n     };\n@@ -357,9 +355,6 @@ fn simplify_ast(ii: InlinedItemRef) -> (InlinedItem, IdRange) {\n         InlinedItemRef::ImplItem(d, ii) => {\n             InlinedItem::ImplItem(d, P(fold::noop_fold_impl_item(ii.clone(), &mut fld)))\n         }\n-        InlinedItemRef::Foreign(d, i) => {\n-            InlinedItem::Foreign(d, P(fold::noop_fold_foreign_item(i.clone(), &mut fld)))\n-        }\n     };\n \n     (ii, fld.id_range)\n@@ -1208,8 +1203,7 @@ fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem, orig_did: DefId) {\n     let item_node_id = match ii {\n         &InlinedItem::Item(_, ref i) => i.id,\n         &InlinedItem::TraitItem(_, ref ti) => ti.id,\n-        &InlinedItem::ImplItem(_, ref ii) => ii.id,\n-        &InlinedItem::Foreign(_, ref fi) => fi.id\n+        &InlinedItem::ImplItem(_, ref ii) => ii.id\n     };\n     copy_item_type(dcx, item_node_id, orig_did);\n "}, {"sha": "94426dcbf1d8d0efdd424588d623b7dabd3b9c2a", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -562,11 +562,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                 let inlined_root_node_id = find_inlined_item_root(item.id);\n                 cache_inlined_item(def_id, item.id, inlined_root_node_id);\n             }\n-            decoder::FoundAst::Found(&InlinedItem::Foreign(d, ref item)) => {\n-                assert_eq!(d, def_id);\n-                let inlined_root_node_id = find_inlined_item_root(item.id);\n-                cache_inlined_item(def_id, item.id, inlined_root_node_id);\n-            }\n             decoder::FoundAst::FoundParent(parent_did, item) => {\n                 let inlined_root_node_id = find_inlined_item_root(item.id);\n                 cache_inlined_item(parent_did, item.id, inlined_root_node_id);"}, {"sha": "9a668b69b2eeb45480a5b8d456f7f65f28ae8ac0", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -40,7 +40,6 @@ use std::io::prelude::*;\n use std::io::{Cursor, SeekFrom};\n use std::rc::Rc;\n use std::u32;\n-use syntax::abi::Abi;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n use syntax::attr::{self,AttrMetaMethods,AttributeMethods};\n use errors::Handler;\n@@ -626,11 +625,6 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n \n                 if body.is_some() {\n                     encode_item_sort(self.rbml_w, 'p');\n-                    encode_inlined_item(ecx,\n-                                        self.rbml_w,\n-                                        InlinedItemRef::TraitItem(\n-                                            trait_def_id,\n-                                            trait_item));\n                     self.encode_mir(trait_item.id);\n                 } else {\n                     encode_item_sort(self.rbml_w, 'r');\n@@ -728,12 +722,14 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                 let types = generics.parent_types as usize + generics.types.len();\n                 let needs_inline = types > 0 || is_default_impl ||\n                     attr::requests_inline(&impl_item.attrs);\n-                if needs_inline || sig.constness == hir::Constness::Const {\n+                if sig.constness == hir::Constness::Const {\n                     encode_inlined_item(\n                         ecx,\n                         self.rbml_w,\n                         InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n                                                  impl_item));\n+                }\n+                if needs_inline || sig.constness == hir::Constness::Const {\n                     self.encode_mir(impl_item.id);\n                 }\n                 encode_constness(self.rbml_w, sig.constness);\n@@ -934,8 +930,10 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                 encode_name(self.rbml_w, item.name);\n                 encode_attributes(self.rbml_w, &item.attrs);\n                 let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n-                if needs_inline || constness == hir::Constness::Const {\n+                if constness == hir::Constness::Const {\n                     encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n+                }\n+                if needs_inline || constness == hir::Constness::Const {\n                     self.encode_mir(item.id);\n                 }\n                 encode_constness(self.rbml_w, constness);\n@@ -982,8 +980,6 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                 for v in &enum_definition.variants {\n                     encode_variant_id(self.rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n                 }\n-                encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n-                self.encode_mir(item.id);\n \n                 // Encode inherent implementations for self enumeration.\n                 encode_inherent_implementations(ecx, self.rbml_w, def_id);\n@@ -1019,9 +1015,6 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                 needs to know*/\n                 self.encode_struct_fields(variant);\n \n-                encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n-                self.encode_mir(item.id);\n-\n                 // Encode inherent implementations for self structure.\n                 encode_inherent_implementations(ecx, self.rbml_w, def_id);\n \n@@ -1265,7 +1258,6 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n         let ecx = self.ecx();\n \n         debug!(\"writing foreign item {}\", ecx.tcx.node_path_str(nitem.id));\n-        let abi = ecx.tcx.map.get_foreign_abi(nitem.id);\n \n         encode_def_id_and_key(ecx, self.rbml_w, def_id);\n         let parent_id = ecx.tcx.map.get_parent(nitem.id);\n@@ -1276,12 +1268,6 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                 encode_family(self.rbml_w, FN_FAMILY);\n                 self.encode_bounds_and_type_for_item(nitem.id);\n                 encode_name(self.rbml_w, nitem.name);\n-                if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-                    encode_inlined_item(ecx,\n-                                        self.rbml_w,\n-                                        InlinedItemRef::Foreign(def_id, nitem));\n-                    self.encode_mir(nitem.id);\n-                }\n                 encode_attributes(self.rbml_w, &nitem.attrs);\n                 let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n                 let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));"}, {"sha": "d6866b27f98a56869da645060afa69fb7a84a6ab", "filename": "src/librustc_trans/_match.rs", "status": "removed", "additions": 0, "deletions": 2012, "changes": 2012, "blob_url": "https://github.com/rust-lang/rust/blob/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=03e23c7f9a10b18e1687bfd92c6807e9342aa00b", "patch": "@@ -1,2012 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! # Compilation of match statements\n-//!\n-//! I will endeavor to explain the code as best I can.  I have only a loose\n-//! understanding of some parts of it.\n-//!\n-//! ## Matching\n-//!\n-//! The basic state of the code is maintained in an array `m` of `Match`\n-//! objects.  Each `Match` describes some list of patterns, all of which must\n-//! match against the current list of values.  If those patterns match, then\n-//! the arm listed in the match is the correct arm.  A given arm may have\n-//! multiple corresponding match entries, one for each alternative that\n-//! remains.  As we proceed these sets of matches are adjusted by the various\n-//! `enter_XXX()` functions, each of which adjusts the set of options given\n-//! some information about the value which has been matched.\n-//!\n-//! So, initially, there is one value and N matches, each of which have one\n-//! constituent pattern.  N here is usually the number of arms but may be\n-//! greater, if some arms have multiple alternatives.  For example, here:\n-//!\n-//!     enum Foo { A, B(int), C(usize, usize) }\n-//!     match foo {\n-//!         A => ...,\n-//!         B(x) => ...,\n-//!         C(1, 2) => ...,\n-//!         C(_) => ...\n-//!     }\n-//!\n-//! The value would be `foo`.  There would be four matches, each of which\n-//! contains one pattern (and, in one case, a guard).  We could collect the\n-//! various options and then compile the code for the case where `foo` is an\n-//! `A`, a `B`, and a `C`.  When we generate the code for `C`, we would (1)\n-//! drop the two matches that do not match a `C` and (2) expand the other two\n-//! into two patterns each.  In the first case, the two patterns would be `1`\n-//! and `2`, and the in the second case the _ pattern would be expanded into\n-//! `_` and `_`.  The two values are of course the arguments to `C`.\n-//!\n-//! Here is a quick guide to the various functions:\n-//!\n-//! - `compile_submatch()`: The main workhouse.  It takes a list of values and\n-//!   a list of matches and finds the various possibilities that could occur.\n-//!\n-//! - `enter_XXX()`: modifies the list of matches based on some information\n-//!   about the value that has been matched.  For example,\n-//!   `enter_rec_or_struct()` adjusts the values given that a record or struct\n-//!   has been matched.  This is an infallible pattern, so *all* of the matches\n-//!   must be either wildcards or record/struct patterns.  `enter_opt()`\n-//!   handles the fallible cases, and it is correspondingly more complex.\n-//!\n-//! ## Bindings\n-//!\n-//! We store information about the bound variables for each arm as part of the\n-//! per-arm `ArmData` struct.  There is a mapping from identifiers to\n-//! `BindingInfo` structs.  These structs contain the mode/id/type of the\n-//! binding, but they also contain an LLVM value which points at an alloca\n-//! called `llmatch`. For by value bindings that are Copy, we also create\n-//! an extra alloca that we copy the matched value to so that any changes\n-//! we do to our copy is not reflected in the original and vice-versa.\n-//! We don't do this if it's a move since the original value can't be used\n-//! and thus allowing us to cheat in not creating an extra alloca.\n-//!\n-//! The `llmatch` binding always stores a pointer into the value being matched\n-//! which points at the data for the binding.  If the value being matched has\n-//! type `T`, then, `llmatch` will point at an alloca of type `T*` (and hence\n-//! `llmatch` has type `T**`).  So, if you have a pattern like:\n-//!\n-//!    let a: A = ...;\n-//!    let b: B = ...;\n-//!    match (a, b) { (ref c, d) => { ... } }\n-//!\n-//! For `c` and `d`, we would generate allocas of type `C*` and `D*`\n-//! respectively.  These are called the `llmatch`.  As we match, when we come\n-//! up against an identifier, we store the current pointer into the\n-//! corresponding alloca.\n-//!\n-//! Once a pattern is completely matched, and assuming that there is no guard\n-//! pattern, we will branch to a block that leads to the body itself.  For any\n-//! by-value bindings, this block will first load the ptr from `llmatch` (the\n-//! one of type `D*`) and then load a second time to get the actual value (the\n-//! one of type `D`). For by ref bindings, the value of the local variable is\n-//! simply the first alloca.\n-//!\n-//! So, for the example above, we would generate a setup kind of like this:\n-//!\n-//!        +-------+\n-//!        | Entry |\n-//!        +-------+\n-//!            |\n-//!        +--------------------------------------------+\n-//!        | llmatch_c = (addr of first half of tuple)  |\n-//!        | llmatch_d = (addr of second half of tuple) |\n-//!        +--------------------------------------------+\n-//!            |\n-//!        +--------------------------------------+\n-//!        | *llbinding_d = **llmatch_d           |\n-//!        +--------------------------------------+\n-//!\n-//! If there is a guard, the situation is slightly different, because we must\n-//! execute the guard code.  Moreover, we need to do so once for each of the\n-//! alternatives that lead to the arm, because if the guard fails, they may\n-//! have different points from which to continue the search. Therefore, in that\n-//! case, we generate code that looks more like:\n-//!\n-//!        +-------+\n-//!        | Entry |\n-//!        +-------+\n-//!            |\n-//!        +-------------------------------------------+\n-//!        | llmatch_c = (addr of first half of tuple) |\n-//!        | llmatch_d = (addr of first half of tuple) |\n-//!        +-------------------------------------------+\n-//!            |\n-//!        +-------------------------------------------------+\n-//!        | *llbinding_d = **llmatch_d                      |\n-//!        | check condition                                 |\n-//!        | if false { goto next case }                     |\n-//!        | if true { goto body }                           |\n-//!        +-------------------------------------------------+\n-//!\n-//! The handling for the cleanups is a bit... sensitive.  Basically, the body\n-//! is the one that invokes `add_clean()` for each binding.  During the guard\n-//! evaluation, we add temporary cleanups and revoke them after the guard is\n-//! evaluated (it could fail, after all). Note that guards and moves are\n-//! just plain incompatible.\n-//!\n-//! Some relevant helper functions that manage bindings:\n-//! - `create_bindings_map()`\n-//! - `insert_lllocals()`\n-//!\n-//!\n-//! ## Notes on vector pattern matching.\n-//!\n-//! Vector pattern matching is surprisingly tricky. The problem is that\n-//! the structure of the vector isn't fully known, and slice matches\n-//! can be done on subparts of it.\n-//!\n-//! The way that vector pattern matches are dealt with, then, is as\n-//! follows. First, we make the actual condition associated with a\n-//! vector pattern simply a vector length comparison. So the pattern\n-//! [1, .. x] gets the condition \"vec len >= 1\", and the pattern\n-//! [.. x] gets the condition \"vec len >= 0\". The problem here is that\n-//! having the condition \"vec len >= 1\" hold clearly does not mean that\n-//! only a pattern that has exactly that condition will match. This\n-//! means that it may well be the case that a condition holds, but none\n-//! of the patterns matching that condition match; to deal with this,\n-//! when doing vector length matches, we have match failures proceed to\n-//! the next condition to check.\n-//!\n-//! There are a couple more subtleties to deal with. While the \"actual\"\n-//! condition associated with vector length tests is simply a test on\n-//! the vector length, the actual vec_len Opt entry contains more\n-//! information used to restrict which matches are associated with it.\n-//! So that all matches in a submatch are matching against the same\n-//! values from inside the vector, they are split up by how many\n-//! elements they match at the front and at the back of the vector. In\n-//! order to make sure that arms are properly checked in order, even\n-//! with the overmatching conditions, each vec_len Opt entry is\n-//! associated with a range of matches.\n-//! Consider the following:\n-//!\n-//!   match &[1, 2, 3] {\n-//!       [1, 1, .. _] => 0,\n-//!       [1, 2, 2, .. _] => 1,\n-//!       [1, 2, 3, .. _] => 2,\n-//!       [1, 2, .. _] => 3,\n-//!       _ => 4\n-//!   }\n-//! The proper arm to match is arm 2, but arms 0 and 3 both have the\n-//! condition \"len >= 2\". If arm 3 was lumped in with arm 0, then the\n-//! wrong branch would be taken. Instead, vec_len Opts are associated\n-//! with a contiguous range of matches that have the same \"shape\".\n-//! This is sort of ugly and requires a bunch of special handling of\n-//! vec_len options.\n-\n-pub use self::BranchKind::*;\n-pub use self::OptResult::*;\n-pub use self::TransBindingMode::*;\n-use self::Opt::*;\n-use self::FailureHandler::*;\n-\n-use llvm::{ValueRef, BasicBlockRef};\n-use rustc_const_eval::check_match::{self, Constructor, StaticInliner};\n-use rustc_const_eval::{compare_lit_exprs, eval_const_expr, fatal_const_eval_err};\n-use rustc::hir::def::{Def, DefMap};\n-use rustc::hir::def_id::DefId;\n-use middle::expr_use_visitor as euv;\n-use middle::lang_items::StrEqFnLangItem;\n-use middle::mem_categorization as mc;\n-use middle::mem_categorization::Categorization;\n-use rustc::hir::pat_util::*;\n-use rustc::ty::subst::Substs;\n-use adt;\n-use base::*;\n-use build::{AddCase, And, Br, CondBr, GEPi, InBoundsGEP, Load, PointerCast};\n-use build::{Not, Store, Sub, add_comment};\n-use build;\n-use callee::{Callee, ArgVals};\n-use cleanup::{self, CleanupMethods, DropHintMethods};\n-use common::*;\n-use consts;\n-use datum::*;\n-use debuginfo::{self, DebugLoc, ToDebugLoc};\n-use expr::{self, Dest};\n-use monomorphize;\n-use tvec;\n-use type_of;\n-use Disr;\n-use value::Value;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::Reveal;\n-use session::config::NoDebugInfo;\n-use util::common::indenter;\n-use util::nodemap::FnvHashMap;\n-use util::ppaux;\n-\n-use std;\n-use std::cell::RefCell;\n-use std::cmp::Ordering;\n-use std::fmt;\n-use std::rc::Rc;\n-use rustc::hir::{self, PatKind};\n-use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n-use syntax_pos::Span;\n-use rustc::hir::fold::Folder;\n-use syntax::ptr::P;\n-\n-#[derive(Copy, Clone, Debug)]\n-struct ConstantExpr<'a>(&'a hir::Expr);\n-\n-impl<'a> ConstantExpr<'a> {\n-    fn eq<'b, 'tcx>(self, other: ConstantExpr<'a>, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> bool {\n-        match compare_lit_exprs(tcx, self.0.span, self.0, other.0) {\n-            Ok(result) => result == Ordering::Equal,\n-            Err(_) => bug!(\"compare_list_exprs: type mismatch\"),\n-        }\n-    }\n-}\n-\n-// An option identifying a branch (either a literal, an enum variant or a range)\n-#[derive(Debug)]\n-enum Opt<'a, 'tcx> {\n-    ConstantValue(ConstantExpr<'a>, DebugLoc),\n-    ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>, DebugLoc),\n-    Variant(Disr, Rc<adt::Repr<'tcx>>, DefId, DebugLoc),\n-    SliceLengthEqual(usize, DebugLoc),\n-    SliceLengthGreaterOrEqual(/* prefix length */ usize,\n-                              /* suffix length */ usize,\n-                              DebugLoc),\n-}\n-\n-impl<'a, 'b, 'tcx> Opt<'a, 'tcx> {\n-    fn eq(&self, other: &Opt<'a, 'tcx>, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> bool {\n-        match (self, other) {\n-            (&ConstantValue(a, _), &ConstantValue(b, _)) => a.eq(b, tcx),\n-            (&ConstantRange(a1, a2, _), &ConstantRange(b1, b2, _)) => {\n-                a1.eq(b1, tcx) && a2.eq(b2, tcx)\n-            }\n-            (&Variant(a_disr, ref a_repr, a_def, _),\n-             &Variant(b_disr, ref b_repr, b_def, _)) => {\n-                a_disr == b_disr && *a_repr == *b_repr && a_def == b_def\n-            }\n-            (&SliceLengthEqual(a, _), &SliceLengthEqual(b, _)) => a == b,\n-            (&SliceLengthGreaterOrEqual(a1, a2, _),\n-             &SliceLengthGreaterOrEqual(b1, b2, _)) => {\n-                a1 == b1 && a2 == b2\n-            }\n-            _ => false\n-        }\n-    }\n-\n-    fn trans<'blk>(&self, mut bcx: Block<'blk, 'tcx>) -> OptResult<'blk, 'tcx> {\n-        use consts::TrueConst::Yes;\n-        let _icx = push_ctxt(\"match::trans_opt\");\n-        let ccx = bcx.ccx();\n-        match *self {\n-            ConstantValue(ConstantExpr(lit_expr), _) => {\n-                let lit_ty = bcx.tcx().node_id_to_type(lit_expr.id);\n-                let expr = consts::const_expr(ccx, &lit_expr, bcx.fcx.param_substs, None, Yes);\n-                let llval = match expr {\n-                    Ok((llval, _)) => llval,\n-                    Err(err) => {\n-                        fatal_const_eval_err(bcx.tcx(), err.as_inner(), lit_expr.span, \"pattern\");\n-                    }\n-                };\n-                let lit_datum = immediate_rvalue(llval, lit_ty);\n-                let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n-                SingleResult(Result::new(bcx, lit_datum.val))\n-            }\n-            ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2), _) => {\n-                let l1 = match consts::const_expr(ccx, &l1, bcx.fcx.param_substs, None, Yes) {\n-                    Ok((l1, _)) => l1,\n-                    Err(err) => fatal_const_eval_err(bcx.tcx(), err.as_inner(), l1.span, \"pattern\"),\n-                };\n-                let l2 = match consts::const_expr(ccx, &l2, bcx.fcx.param_substs, None, Yes) {\n-                    Ok((l2, _)) => l2,\n-                    Err(err) => fatal_const_eval_err(bcx.tcx(), err.as_inner(), l2.span, \"pattern\"),\n-                };\n-                RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n-            }\n-            Variant(disr_val, ref repr, _, _) => {\n-                SingleResult(Result::new(bcx, adt::trans_case(bcx, &repr, disr_val)))\n-            }\n-            SliceLengthEqual(length, _) => {\n-                SingleResult(Result::new(bcx, C_uint(ccx, length)))\n-            }\n-            SliceLengthGreaterOrEqual(prefix, suffix, _) => {\n-                LowerBound(Result::new(bcx, C_uint(ccx, prefix + suffix)))\n-            }\n-        }\n-    }\n-\n-    fn debug_loc(&self) -> DebugLoc {\n-        match *self {\n-            ConstantValue(_,debug_loc)                 |\n-            ConstantRange(_, _, debug_loc)             |\n-            Variant(_, _, _, debug_loc)                |\n-            SliceLengthEqual(_, debug_loc)             |\n-            SliceLengthGreaterOrEqual(_, _, debug_loc) => debug_loc\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum BranchKind {\n-    NoBranch,\n-    Single,\n-    Switch,\n-    Compare,\n-    CompareSliceLength\n-}\n-\n-pub enum OptResult<'blk, 'tcx: 'blk> {\n-    SingleResult(Result<'blk, 'tcx>),\n-    RangeResult(Result<'blk, 'tcx>, Result<'blk, 'tcx>),\n-    LowerBound(Result<'blk, 'tcx>)\n-}\n-\n-#[derive(Clone, Copy, PartialEq)]\n-pub enum TransBindingMode {\n-    /// By-value binding for a copy type: copies from matched data\n-    /// into a fresh LLVM alloca.\n-    TrByCopy(/* llbinding */ ValueRef),\n-\n-    /// By-value binding for a non-copy type where we copy into a\n-    /// fresh LLVM alloca; this most accurately reflects the language\n-    /// semantics (e.g. it properly handles overwrites of the matched\n-    /// input), but potentially injects an unwanted copy.\n-    TrByMoveIntoCopy(/* llbinding */ ValueRef),\n-\n-    /// Binding a non-copy type by reference under the hood; this is\n-    /// a codegen optimization to avoid unnecessary memory traffic.\n-    TrByMoveRef,\n-\n-    /// By-ref binding exposed in the original source input.\n-    TrByRef,\n-}\n-\n-impl TransBindingMode {\n-    /// if binding by making a fresh copy; returns the alloca that it\n-    /// will copy into; otherwise None.\n-    fn alloca_if_copy(&self) -> Option<ValueRef> {\n-        match *self {\n-            TrByCopy(llbinding) | TrByMoveIntoCopy(llbinding) => Some(llbinding),\n-            TrByMoveRef | TrByRef => None,\n-        }\n-    }\n-}\n-\n-/// Information about a pattern binding:\n-/// - `llmatch` is a pointer to a stack slot.  The stack slot contains a\n-///   pointer into the value being matched.  Hence, llmatch has type `T**`\n-///   where `T` is the value being matched.\n-/// - `trmode` is the trans binding mode\n-/// - `id` is the node id of the binding\n-/// - `ty` is the Rust type of the binding\n-#[derive(Clone, Copy)]\n-pub struct BindingInfo<'tcx> {\n-    pub llmatch: ValueRef,\n-    pub trmode: TransBindingMode,\n-    pub id: ast::NodeId,\n-    pub span: Span,\n-    pub ty: Ty<'tcx>,\n-}\n-\n-type BindingsMap<'tcx> = FnvHashMap<ast::Name, BindingInfo<'tcx>>;\n-\n-struct ArmData<'p, 'blk, 'tcx: 'blk> {\n-    bodycx: Block<'blk, 'tcx>,\n-    arm: &'p hir::Arm,\n-    bindings_map: BindingsMap<'tcx>\n-}\n-\n-/// Info about Match.\n-/// If all `pats` are matched then arm `data` will be executed.\n-/// As we proceed `bound_ptrs` are filled with pointers to values to be bound,\n-/// these pointers are stored in llmatch variables just before executing `data` arm.\n-struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n-    pats: Vec<&'p hir::Pat>,\n-    data: &'a ArmData<'p, 'blk, 'tcx>,\n-    bound_ptrs: Vec<(ast::Name, ValueRef)>,\n-    // Thread along renamings done by the check_match::StaticInliner, so we can\n-    // map back to original NodeIds\n-    pat_renaming_map: Option<&'a FnvHashMap<(NodeId, Span), NodeId>>\n-}\n-\n-impl<'a, 'p, 'blk, 'tcx> fmt::Debug for Match<'a, 'p, 'blk, 'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if ppaux::verbose() {\n-            // for many programs, this just take too long to serialize\n-            write!(f, \"{:?}\", self.pats)\n-        } else {\n-            write!(f, \"{} pats\", self.pats.len())\n-        }\n-    }\n-}\n-\n-fn has_nested_bindings(m: &[Match], col: usize) -> bool {\n-    for br in m {\n-        if let PatKind::Binding(_, _, Some(..)) = br.pats[col].node {\n-            return true\n-        }\n-    }\n-    false\n-}\n-\n-// As noted in `fn match_datum`, we should eventually pass around a\n-// `Datum<Lvalue>` for the `val`; but until we get to that point, this\n-// `MatchInput` struct will serve -- it has everything `Datum<Lvalue>`\n-// does except for the type field.\n-#[derive(Copy, Clone)]\n-pub struct MatchInput { val: ValueRef, lval: Lvalue }\n-\n-impl<'tcx> Datum<'tcx, Lvalue> {\n-    pub fn match_input(&self) -> MatchInput {\n-        MatchInput {\n-            val: self.val,\n-            lval: self.kind,\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for MatchInput {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&Value(self.val), f)\n-    }\n-}\n-\n-impl MatchInput {\n-    fn from_val(val: ValueRef) -> MatchInput {\n-        MatchInput {\n-            val: val,\n-            lval: Lvalue::new(\"MatchInput::from_val\"),\n-        }\n-    }\n-\n-    fn to_datum<'tcx>(self, ty: Ty<'tcx>) -> Datum<'tcx, Lvalue> {\n-        Datum::new(self.val, ty, self.lval)\n-    }\n-}\n-\n-fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                              m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                              col: usize,\n-                                              val: MatchInput)\n-                                              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"expand_nested_bindings(bcx={}, m={:?}, col={}, val={:?})\",\n-           bcx.to_str(), m, col, val);\n-    let _indenter = indenter();\n-\n-    m.iter().map(|br| {\n-        let mut bound_ptrs = br.bound_ptrs.clone();\n-        let mut pat = br.pats[col];\n-        loop {\n-            pat = match pat.node {\n-                PatKind::Binding(_, ref path, Some(ref inner)) => {\n-                    bound_ptrs.push((path.node, val.val));\n-                    &inner\n-                },\n-                _ => break\n-            }\n-        }\n-\n-        let mut pats = br.pats.clone();\n-        pats[col] = pat;\n-        Match {\n-            pats: pats,\n-            data: &br.data,\n-            bound_ptrs: bound_ptrs,\n-            pat_renaming_map: br.pat_renaming_map,\n-        }\n-    }).collect()\n-}\n-\n-fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                          m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                          col: usize,\n-                                          val: MatchInput,\n-                                          mut e: F)\n-                                          -> Vec<Match<'a, 'p, 'blk, 'tcx>> where\n-    F: FnMut(&[(&'p hir::Pat, Option<Ty<'tcx>>)])\n-             -> Option<Vec<(&'p hir::Pat, Option<Ty<'tcx>>)>>,\n-{\n-    debug!(\"enter_match(bcx={}, m={:?}, col={}, val={:?})\",\n-           bcx.to_str(), m, col, val);\n-    let _indenter = indenter();\n-\n-    m.iter().filter_map(|br| {\n-        let pats : Vec<_> = br.pats.iter().map(|p| (*p, None)).collect();\n-        e(&pats).map(|pats| {\n-            let this = br.pats[col];\n-            let mut bound_ptrs = br.bound_ptrs.clone();\n-            match this.node {\n-                PatKind::Binding(_, ref path, None) => {\n-                    bound_ptrs.push((path.node, val.val));\n-                }\n-                PatKind::Vec(ref before, Some(ref slice), ref after) => {\n-                    if let PatKind::Binding(_, ref path, None) = slice.node {\n-                        let subslice_val = bind_subslice_pat(\n-                            bcx, this.id, val,\n-                            before.len(), after.len());\n-                        bound_ptrs.push((path.node, subslice_val));\n-                    }\n-                }\n-                _ => {}\n-            }\n-            Match {\n-                pats: pats.into_iter().map(|p| p.0).collect(),\n-                data: br.data,\n-                bound_ptrs: bound_ptrs,\n-                pat_renaming_map: br.pat_renaming_map,\n-            }\n-        })\n-    }).collect()\n-}\n-\n-fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                     col: usize,\n-                                     val: MatchInput)\n-                                     -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"enter_default(bcx={}, m={:?}, col={}, val={:?})\",\n-           bcx.to_str(), m, col, val);\n-    let _indenter = indenter();\n-\n-    // Collect all of the matches that can match against anything.\n-    enter_match(bcx, m, col, val, |pats| {\n-        match pats[col].0.node {\n-            PatKind::Binding(..) | PatKind::Wild => {\n-                let mut r = pats[..col].to_vec();\n-                r.extend_from_slice(&pats[col + 1..]);\n-                Some(r)\n-            }\n-            _ => None\n-        }\n-    })\n-}\n-\n-// <pcwalton> nmatsakis: what does enter_opt do?\n-// <pcwalton> in trans/match\n-// <pcwalton> trans/match.rs is like stumbling around in a dark cave\n-// <nmatsakis> pcwalton: the enter family of functions adjust the set of\n-//             patterns as needed\n-// <nmatsakis> yeah, at some point I kind of achieved some level of\n-//             understanding\n-// <nmatsakis> anyhow, they adjust the patterns given that something of that\n-//             kind has been found\n-// <nmatsakis> pcwalton: ok, right, so enter_XXX() adjusts the patterns, as I\n-//             said\n-// <nmatsakis> enter_match() kind of embodies the generic code\n-// <nmatsakis> it is provided with a function that tests each pattern to see\n-//             if it might possibly apply and so forth\n-// <nmatsakis> so, if you have a pattern like {a: _, b: _, _} and one like _\n-// <nmatsakis> then _ would be expanded to (_, _)\n-// <nmatsakis> one spot for each of the sub-patterns\n-// <nmatsakis> enter_opt() is one of the more complex; it covers the fallible\n-//             cases\n-// <nmatsakis> enter_rec_or_struct() or enter_tuple() are simpler, since they\n-//             are infallible patterns\n-// <nmatsakis> so all patterns must either be records (resp. tuples) or\n-//             wildcards\n-\n-/// The above is now outdated in that enter_match() now takes a function that\n-/// takes the complete row of patterns rather than just the first one.\n-/// Also, most of the enter_() family functions have been unified with\n-/// the check_match specialization step.\n-fn enter_opt<'a, 'p, 'blk, 'tcx>(\n-             bcx: Block<'blk, 'tcx>,\n-             _: ast::NodeId,\n-             m: &[Match<'a, 'p, 'blk, 'tcx>],\n-             opt: &Opt,\n-             col: usize,\n-             variant_size: usize,\n-             val: MatchInput)\n-             -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"enter_opt(bcx={}, m={:?}, opt={:?}, col={}, val={:?})\",\n-           bcx.to_str(), m, *opt, col, val);\n-    let _indenter = indenter();\n-\n-    let ctor = match opt {\n-        &ConstantValue(ConstantExpr(expr), _) => Constructor::ConstantValue(\n-            eval_const_expr(bcx.tcx(), &expr)\n-        ),\n-        &ConstantRange(ConstantExpr(lo), ConstantExpr(hi), _) => Constructor::ConstantRange(\n-            eval_const_expr(bcx.tcx(), &lo),\n-            eval_const_expr(bcx.tcx(), &hi)\n-        ),\n-        &SliceLengthEqual(n, _) =>\n-            Constructor::Slice(n),\n-        &SliceLengthGreaterOrEqual(before, after, _) =>\n-            Constructor::SliceWithSubslice(before, after),\n-        &Variant(_, _, def_id, _) =>\n-            Constructor::Variant(def_id)\n-    };\n-\n-    let param_env = bcx.tcx().empty_parameter_environment();\n-    let mcx = check_match::MatchCheckCtxt {\n-        tcx: bcx.tcx(),\n-        param_env: param_env,\n-    };\n-    enter_match(bcx, m, col, val, |pats|\n-        check_match::specialize(&mcx, &pats[..], &ctor, col, variant_size)\n-    )\n-}\n-\n-// Returns the options in one column of matches. An option is something that\n-// needs to be conditionally matched at runtime; for example, the discriminant\n-// on a set of enum variants or a literal.\n-fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                    col: usize)\n-                                    -> Vec<Opt<'p, 'tcx>> {\n-    let tcx = bcx.tcx();\n-\n-    let mut found: Vec<Opt> = vec![];\n-    for br in m {\n-        let cur = br.pats[col];\n-        let debug_loc = match br.pat_renaming_map {\n-            Some(pat_renaming_map) => {\n-                match pat_renaming_map.get(&(cur.id, cur.span)) {\n-                    Some(&id) => DebugLoc::At(id, cur.span),\n-                    None => DebugLoc::At(cur.id, cur.span),\n-                }\n-            }\n-            None => DebugLoc::None\n-        };\n-\n-        let opt = match cur.node {\n-            PatKind::Lit(ref l) => {\n-                ConstantValue(ConstantExpr(&l), debug_loc)\n-            }\n-            PatKind::Path(..) | PatKind::TupleStruct(..) | PatKind::Struct(..) => {\n-                match tcx.expect_def(cur.id) {\n-                    Def::Variant(enum_id, var_id) => {\n-                        let variant = tcx.lookup_adt_def(enum_id).variant_with_id(var_id);\n-                        Variant(Disr::from(variant.disr_val),\n-                                adt::represent_node(bcx, cur.id),\n-                                var_id,\n-                                debug_loc)\n-                    }\n-                    _ => continue\n-                }\n-            }\n-            PatKind::Range(ref l1, ref l2) => {\n-                ConstantRange(ConstantExpr(&l1), ConstantExpr(&l2), debug_loc)\n-            }\n-            PatKind::Vec(ref before, None, ref after) => {\n-                SliceLengthEqual(before.len() + after.len(), debug_loc)\n-            }\n-            PatKind::Vec(ref before, Some(_), ref after) => {\n-                SliceLengthGreaterOrEqual(before.len(), after.len(), debug_loc)\n-            }\n-            _ => continue\n-        };\n-\n-        if !found.iter().any(|x| x.eq(&opt, tcx)) {\n-            found.push(opt);\n-        }\n-    }\n-    found\n-}\n-\n-struct ExtractedBlock<'blk, 'tcx: 'blk> {\n-    vals: Vec<ValueRef>,\n-    bcx: Block<'blk, 'tcx>,\n-}\n-\n-fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    repr: &adt::Repr<'tcx>,\n-                                    disr_val: Disr,\n-                                    val: MatchInput)\n-                                    -> ExtractedBlock<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"match::extract_variant_args\");\n-    // Assume enums are always sized for now.\n-    let val = adt::MaybeSizedValue::sized(val.val);\n-    let args = (0..adt::num_args(repr, disr_val)).map(|i| {\n-        adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n-    }).collect();\n-\n-    ExtractedBlock { vals: args, bcx: bcx }\n-}\n-\n-/// Helper for converting from the ValueRef that we pass around in the match code, which is always\n-/// an lvalue, into a Datum. Eventually we should just pass around a Datum and be done with it.\n-fn match_datum<'tcx>(val: MatchInput, left_ty: Ty<'tcx>) -> Datum<'tcx, Lvalue> {\n-    val.to_datum(left_ty)\n-}\n-\n-fn bind_subslice_pat(bcx: Block,\n-                     pat_id: ast::NodeId,\n-                     val: MatchInput,\n-                     offset_left: usize,\n-                     offset_right: usize) -> ValueRef {\n-    let _icx = push_ctxt(\"match::bind_subslice_pat\");\n-    let vec_ty = node_id_type(bcx, pat_id);\n-    let vec_ty_contents = match vec_ty.sty {\n-        ty::TyBox(ty) => ty,\n-        ty::TyRef(_, mt) | ty::TyRawPtr(mt) => mt.ty,\n-        _ => vec_ty\n-    };\n-    let unit_ty = vec_ty_contents.sequence_element_type(bcx.tcx());\n-    let vec_datum = match_datum(val, vec_ty);\n-    let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n-\n-    let slice_begin = InBoundsGEP(bcx, base, &[C_uint(bcx.ccx(), offset_left)]);\n-    let diff = offset_left + offset_right;\n-    if let ty::TyArray(ty, n) = vec_ty_contents.sty {\n-        let array_ty = bcx.tcx().mk_array(ty, n-diff);\n-        let llty_array = type_of::type_of(bcx.ccx(), array_ty);\n-        return PointerCast(bcx, slice_begin, llty_array.ptr_to());\n-    }\n-\n-    let slice_len_offset = C_uint(bcx.ccx(), diff);\n-    let slice_len = Sub(bcx, len, slice_len_offset, DebugLoc::None);\n-    let slice_ty = bcx.tcx().mk_imm_ref(bcx.tcx().mk_region(ty::ReErased),\n-                                         bcx.tcx().mk_slice(unit_ty));\n-    let scratch = rvalue_scratch_datum(bcx, slice_ty, \"\");\n-    Store(bcx, slice_begin, expr::get_dataptr(bcx, scratch.val));\n-    Store(bcx, slice_len, expr::get_meta(bcx, scratch.val));\n-    scratch.val\n-}\n-\n-fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 left_ty: Ty<'tcx>,\n-                                 before: usize,\n-                                 after: usize,\n-                                 val: MatchInput)\n-                                 -> ExtractedBlock<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"match::extract_vec_elems\");\n-    let vec_datum = match_datum(val, left_ty);\n-    let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n-    let mut elems = vec![];\n-    elems.extend((0..before).map(|i| GEPi(bcx, base, &[i])));\n-    elems.extend((0..after).rev().map(|i| {\n-        InBoundsGEP(bcx, base, &[\n-            Sub(bcx, len, C_uint(bcx.ccx(), i + 1), DebugLoc::None)\n-        ])\n-    }));\n-    ExtractedBlock { vals: elems, bcx: bcx }\n-}\n-\n-// Macro for deciding whether any of the remaining matches fit a given kind of\n-// pattern.  Note that, because the macro is well-typed, either ALL of the\n-// matches should fit that sort of pattern or NONE (however, some of the\n-// matches may be wildcards like _ or identifiers).\n-macro_rules! any_pat {\n-    ($m:expr, $col:expr, $pattern:pat) => (\n-        ($m).iter().any(|br| {\n-            match br.pats[$col].node {\n-                $pattern => true,\n-                _ => false\n-            }\n-        })\n-    )\n-}\n-\n-fn any_uniq_pat(m: &[Match], col: usize) -> bool {\n-    any_pat!(m, col, PatKind::Box(_))\n-}\n-\n-fn any_region_pat(m: &[Match], col: usize) -> bool {\n-    any_pat!(m, col, PatKind::Ref(..))\n-}\n-\n-fn any_irrefutable_adt_pat(tcx: TyCtxt, m: &[Match], col: usize) -> bool {\n-    m.iter().any(|br| {\n-        let pat = br.pats[col];\n-        match pat.node {\n-            PatKind::Tuple(..) => true,\n-            PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) => {\n-                match tcx.expect_def(pat.id) {\n-                    Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => true,\n-                    _ => false,\n-                }\n-            }\n-            _ => false\n-        }\n-    })\n-}\n-\n-/// What to do when the pattern match fails.\n-enum FailureHandler {\n-    Infallible,\n-    JumpToBasicBlock(BasicBlockRef),\n-    Unreachable\n-}\n-\n-impl FailureHandler {\n-    fn is_fallible(&self) -> bool {\n-        match *self {\n-            Infallible => false,\n-            _ => true\n-        }\n-    }\n-\n-    fn is_infallible(&self) -> bool {\n-        !self.is_fallible()\n-    }\n-\n-    fn handle_fail(&self, bcx: Block) {\n-        match *self {\n-            Infallible =>\n-                bug!(\"attempted to panic in a non-panicking panic handler!\"),\n-            JumpToBasicBlock(basic_block) =>\n-                Br(bcx, basic_block, DebugLoc::None),\n-            Unreachable =>\n-                build::Unreachable(bcx)\n-        }\n-    }\n-}\n-\n-fn pick_column_to_specialize(def_map: &RefCell<DefMap>, m: &[Match]) -> Option<usize> {\n-    fn pat_score(def_map: &RefCell<DefMap>, pat: &hir::Pat) -> usize {\n-        match pat.node {\n-            PatKind::Binding(_, _, Some(ref inner)) => pat_score(def_map, &inner),\n-            _ if pat_is_refutable(&def_map.borrow(), pat) => 1,\n-            _ => 0\n-        }\n-    }\n-\n-    let column_score = |m: &[Match], col: usize| -> usize {\n-        let total_score = m.iter()\n-            .map(|row| row.pats[col])\n-            .map(|pat| pat_score(def_map, pat))\n-            .sum();\n-\n-        // Irrefutable columns always go first, they'd only be duplicated in the branches.\n-        if total_score == 0 {\n-            std::usize::MAX\n-        } else {\n-            total_score\n-        }\n-    };\n-\n-    let column_contains_any_nonwild_patterns = |&col: &usize| -> bool {\n-        m.iter().any(|row| match row.pats[col].node {\n-            PatKind::Wild => false,\n-            _ => true\n-        })\n-    };\n-\n-    (0..m[0].pats.len())\n-        .filter(column_contains_any_nonwild_patterns)\n-        .map(|col| (col, column_score(m, col)))\n-        .max_by_key(|&(_, score)| score)\n-        .map(|(col, _)| col)\n-}\n-\n-// Compiles a comparison between two things.\n-fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                              lhs: ValueRef,\n-                              rhs: ValueRef,\n-                              rhs_t: Ty<'tcx>,\n-                              debug_loc: DebugLoc)\n-                              -> Result<'blk, 'tcx> {\n-    fn compare_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               lhs_data: ValueRef,\n-                               lhs_len: ValueRef,\n-                               rhs_data: ValueRef,\n-                               rhs_len: ValueRef,\n-                               rhs_t: Ty<'tcx>,\n-                               debug_loc: DebugLoc)\n-                               -> Result<'blk, 'tcx> {\n-        let did = langcall(bcx.tcx(),\n-                           None,\n-                           &format!(\"comparison of `{}`\", rhs_t),\n-                           StrEqFnLangItem);\n-        let args = [lhs_data, lhs_len, rhs_data, rhs_len];\n-        Callee::def(bcx.ccx(), did, Substs::empty(bcx.tcx()))\n-            .call(bcx, debug_loc, ArgVals(&args), None)\n-    }\n-\n-    let _icx = push_ctxt(\"compare_values\");\n-    if rhs_t.is_scalar() {\n-        let cmp = compare_scalar_types(cx, lhs, rhs, rhs_t, hir::BiEq, debug_loc);\n-        return Result::new(cx, cmp);\n-    }\n-\n-    match rhs_t.sty {\n-        ty::TyRef(_, mt) => match mt.ty.sty {\n-            ty::TyStr => {\n-                let lhs_data = Load(cx, expr::get_dataptr(cx, lhs));\n-                let lhs_len = Load(cx, expr::get_meta(cx, lhs));\n-                let rhs_data = Load(cx, expr::get_dataptr(cx, rhs));\n-                let rhs_len = Load(cx, expr::get_meta(cx, rhs));\n-                compare_str(cx, lhs_data, lhs_len, rhs_data, rhs_len, rhs_t, debug_loc)\n-            }\n-            ty::TyArray(ty, _) | ty::TySlice(ty) => match ty.sty {\n-                ty::TyUint(ast::UintTy::U8) => {\n-                    // NOTE: cast &[u8] and &[u8; N] to &str and abuse the str_eq lang item,\n-                    // which calls memcmp().\n-                    let pat_len = val_ty(rhs).element_type().array_length();\n-                    let ty_str_slice = cx.tcx().mk_static_str();\n-\n-                    let rhs_data = GEPi(cx, rhs, &[0, 0]);\n-                    let rhs_len = C_uint(cx.ccx(), pat_len);\n-\n-                    let lhs_data;\n-                    let lhs_len;\n-                    if val_ty(lhs) == val_ty(rhs) {\n-                        // Both the discriminant and the pattern are thin pointers\n-                        lhs_data = GEPi(cx, lhs, &[0, 0]);\n-                        lhs_len = C_uint(cx.ccx(), pat_len);\n-                    } else {\n-                        // The discriminant is a fat pointer\n-                        let llty_str_slice = type_of::type_of(cx.ccx(), ty_str_slice).ptr_to();\n-                        let lhs_str = PointerCast(cx, lhs, llty_str_slice);\n-                        lhs_data = Load(cx, expr::get_dataptr(cx, lhs_str));\n-                        lhs_len = Load(cx, expr::get_meta(cx, lhs_str));\n-                    }\n-\n-                    compare_str(cx, lhs_data, lhs_len, rhs_data, rhs_len, rhs_t, debug_loc)\n-                },\n-                _ => bug!(\"only byte strings supported in compare_values\"),\n-            },\n-            _ => bug!(\"only string and byte strings supported in compare_values\"),\n-        },\n-        _ => bug!(\"only scalars, byte strings, and strings supported in compare_values\"),\n-    }\n-}\n-\n-/// For each binding in `data.bindings_map`, adds an appropriate entry into the `fcx.lllocals` map\n-fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                               bindings_map: &BindingsMap<'tcx>,\n-                               cs: Option<cleanup::ScopeId>)\n-                               -> Block<'blk, 'tcx> {\n-    for (&name, &binding_info) in bindings_map {\n-        let (llval, aliases_other_state) = match binding_info.trmode {\n-            // By value mut binding for a copy type: load from the ptr\n-            // into the matched value and copy to our alloca\n-            TrByCopy(llbinding) |\n-            TrByMoveIntoCopy(llbinding) => {\n-                let llval = Load(bcx, binding_info.llmatch);\n-                let lvalue = match binding_info.trmode {\n-                    TrByCopy(..) =>\n-                        Lvalue::new(\"_match::insert_lllocals\"),\n-                    TrByMoveIntoCopy(..) => {\n-                        // match_input moves from the input into a\n-                        // separate stack slot.\n-                        //\n-                        // E.g. consider moving the value `D(A)` out\n-                        // of the tuple `(D(A), D(B))` and into the\n-                        // local variable `x` via the pattern `(x,_)`,\n-                        // leaving the remainder of the tuple `(_,\n-                        // D(B))` still to be dropped in the future.\n-                        //\n-                        // Thus, here we must zero the place that we\n-                        // are moving *from*, because we do not yet\n-                        // track drop flags for a fragmented parent\n-                        // match input expression.\n-                        //\n-                        // Longer term we will be able to map the move\n-                        // into `(x, _)` up to the parent path that\n-                        // owns the whole tuple, and mark the\n-                        // corresponding stack-local drop-flag\n-                        // tracking the first component of the tuple.\n-                        let hint_kind = HintKind::ZeroAndMaintain;\n-                        Lvalue::new_with_hint(\"_match::insert_lllocals (match_input)\",\n-                                              bcx, binding_info.id, hint_kind)\n-                    }\n-                    _ => bug!(),\n-                };\n-                let datum = Datum::new(llval, binding_info.ty, lvalue);\n-                call_lifetime_start(bcx, llbinding);\n-                bcx = datum.store_to(bcx, llbinding);\n-                if let Some(cs) = cs {\n-                    bcx.fcx.schedule_lifetime_end(cs, llbinding);\n-                }\n-\n-                (llbinding, false)\n-            },\n-\n-            // By value move bindings: load from the ptr into the matched value\n-            TrByMoveRef => (Load(bcx, binding_info.llmatch), true),\n-\n-            // By ref binding: use the ptr into the matched value\n-            TrByRef => (binding_info.llmatch, true),\n-        };\n-\n-\n-        // A local that aliases some other state must be zeroed, since\n-        // the other state (e.g. some parent data that we matched\n-        // into) will still have its subcomponents (such as this\n-        // local) destructed at the end of the parent's scope. Longer\n-        // term, we will properly map such parents to the set of\n-        // unique drop flags for its fragments.\n-        let hint_kind = if aliases_other_state {\n-            HintKind::ZeroAndMaintain\n-        } else {\n-            HintKind::DontZeroJustUse\n-        };\n-        let lvalue = Lvalue::new_with_hint(\"_match::insert_lllocals (local)\",\n-                                           bcx,\n-                                           binding_info.id,\n-                                           hint_kind);\n-        let datum = Datum::new(llval, binding_info.ty, lvalue);\n-        if let Some(cs) = cs {\n-            let opt_datum = lvalue.dropflag_hint(bcx);\n-            bcx.fcx.schedule_lifetime_end(cs, binding_info.llmatch);\n-            bcx.fcx.schedule_drop_and_fill_mem(cs, llval, binding_info.ty, opt_datum);\n-        }\n-\n-        debug!(\"binding {} to {:?}\", binding_info.id, Value(llval));\n-        bcx.fcx.lllocals.borrow_mut().insert(binding_info.id, datum);\n-        debuginfo::create_match_binding_metadata(bcx, name, binding_info);\n-    }\n-    bcx\n-}\n-\n-fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     guard_expr: &hir::Expr,\n-                                     data: &ArmData<'p, 'blk, 'tcx>,\n-                                     m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                     vals: &[MatchInput],\n-                                     chk: &FailureHandler,\n-                                     has_genuine_default: bool)\n-                                     -> Block<'blk, 'tcx> {\n-    debug!(\"compile_guard(bcx={}, guard_expr={:?}, m={:?}, vals={:?})\",\n-           bcx.to_str(), guard_expr, m, vals);\n-    let _indenter = indenter();\n-\n-    let mut bcx = insert_lllocals(bcx, &data.bindings_map, None);\n-\n-    let val = unpack_datum!(bcx, expr::trans(bcx, guard_expr));\n-    let val = val.to_llbool(bcx);\n-\n-    for (_, &binding_info) in &data.bindings_map {\n-        if let Some(llbinding) = binding_info.trmode.alloca_if_copy() {\n-            call_lifetime_end(bcx, llbinding)\n-        }\n-    }\n-\n-    for (_, &binding_info) in &data.bindings_map {\n-        bcx.fcx.lllocals.borrow_mut().remove(&binding_info.id);\n-    }\n-\n-    with_cond(bcx, Not(bcx, val, guard_expr.debug_loc()), |bcx| {\n-        for (_, &binding_info) in &data.bindings_map {\n-            call_lifetime_end(bcx, binding_info.llmatch);\n-        }\n-        match chk {\n-            // If the default arm is the only one left, move on to the next\n-            // condition explicitly rather than (possibly) falling back to\n-            // the default arm.\n-            &JumpToBasicBlock(_) if m.len() == 1 && has_genuine_default => {\n-                chk.handle_fail(bcx);\n-            }\n-            _ => {\n-                compile_submatch(bcx, m, vals, chk, has_genuine_default);\n-            }\n-        };\n-        bcx\n-    })\n-}\n-\n-fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                        m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                        vals: &[MatchInput],\n-                                        chk: &FailureHandler,\n-                                        has_genuine_default: bool) {\n-    debug!(\"compile_submatch(bcx={}, m={:?}, vals=[{:?}])\",\n-           bcx.to_str(), m, vals);\n-    let _indenter = indenter();\n-    let _icx = push_ctxt(\"match::compile_submatch\");\n-    let mut bcx = bcx;\n-    if m.is_empty() {\n-        if chk.is_fallible() {\n-            chk.handle_fail(bcx);\n-        }\n-        return;\n-    }\n-\n-    let tcx = bcx.tcx();\n-    let def_map = &tcx.def_map;\n-    match pick_column_to_specialize(def_map, m) {\n-        Some(col) => {\n-            let val = vals[col];\n-            if has_nested_bindings(m, col) {\n-                let expanded = expand_nested_bindings(bcx, m, col, val);\n-                compile_submatch_continue(bcx,\n-                                          &expanded[..],\n-                                          vals,\n-                                          chk,\n-                                          col,\n-                                          val,\n-                                          has_genuine_default)\n-            } else {\n-                compile_submatch_continue(bcx, m, vals, chk, col, val, has_genuine_default)\n-            }\n-        }\n-        None => {\n-            let data = &m[0].data;\n-            for &(ref name, ref value_ptr) in &m[0].bound_ptrs {\n-                let binfo = *data.bindings_map.get(name).unwrap();\n-                call_lifetime_start(bcx, binfo.llmatch);\n-                if binfo.trmode == TrByRef && type_is_fat_ptr(bcx.tcx(), binfo.ty) {\n-                    expr::copy_fat_ptr(bcx, *value_ptr, binfo.llmatch);\n-                }\n-                else {\n-                    Store(bcx, *value_ptr, binfo.llmatch);\n-                }\n-            }\n-            match data.arm.guard {\n-                Some(ref guard_expr) => {\n-                    bcx = compile_guard(bcx,\n-                                        &guard_expr,\n-                                        m[0].data,\n-                                        &m[1..m.len()],\n-                                        vals,\n-                                        chk,\n-                                        has_genuine_default);\n-                }\n-                _ => ()\n-            }\n-            Br(bcx, data.bodycx.llbb, DebugLoc::None);\n-        }\n-    }\n-}\n-\n-fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                                 m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                                 vals: &[MatchInput],\n-                                                 chk: &FailureHandler,\n-                                                 col: usize,\n-                                                 val: MatchInput,\n-                                                 has_genuine_default: bool) {\n-    let fcx = bcx.fcx;\n-    let tcx = bcx.tcx();\n-\n-    let mut vals_left = vals[0..col].to_vec();\n-    vals_left.extend_from_slice(&vals[col + 1..]);\n-    let ccx = bcx.fcx.ccx;\n-\n-    // Find a real id (we're adding placeholder wildcard patterns, but\n-    // each column is guaranteed to have at least one real pattern)\n-    let pat_id = m.iter().map(|br| br.pats[col].id)\n-                         .find(|&id| id != DUMMY_NODE_ID)\n-                         .unwrap_or(DUMMY_NODE_ID);\n-\n-    let left_ty = if pat_id == DUMMY_NODE_ID {\n-        tcx.mk_nil()\n-    } else {\n-        node_id_type(bcx, pat_id)\n-    };\n-\n-    let mcx = check_match::MatchCheckCtxt {\n-        tcx: bcx.tcx(),\n-        param_env: bcx.tcx().empty_parameter_environment(),\n-    };\n-    let adt_vals = if any_irrefutable_adt_pat(bcx.tcx(), m, col) {\n-        let repr = adt::represent_type(bcx.ccx(), left_ty);\n-        let arg_count = adt::num_args(&repr, Disr(0));\n-        let (arg_count, struct_val) = if type_is_sized(bcx.tcx(), left_ty) {\n-            (arg_count, val.val)\n-        } else {\n-            // For an unsized ADT (i.e. DST struct), we need to treat\n-            // the last field specially: instead of simply passing a\n-            // ValueRef pointing to that field, as with all the others,\n-            // we skip it and instead construct a 'fat ptr' below.\n-            (arg_count - 1, Load(bcx, expr::get_dataptr(bcx, val.val)))\n-        };\n-        let mut field_vals: Vec<ValueRef> = (0..arg_count).map(|ix|\n-            // By definition, these are all sized\n-            adt::trans_field_ptr(bcx, &repr, adt::MaybeSizedValue::sized(struct_val), Disr(0), ix)\n-        ).collect();\n-\n-        match left_ty.sty {\n-            ty::TyStruct(def, substs) if !type_is_sized(bcx.tcx(), left_ty) => {\n-                // The last field is technically unsized but\n-                // since we can only ever match that field behind\n-                // a reference we construct a fat ptr here.\n-                let unsized_ty = def.struct_variant().fields.last().map(|field| {\n-                    monomorphize::field_ty(bcx.tcx(), substs, field)\n-                }).unwrap();\n-                let scratch = alloc_ty(bcx, unsized_ty, \"__struct_field_fat_ptr\");\n-\n-                let meta = Load(bcx, expr::get_meta(bcx, val.val));\n-                let struct_val = adt::MaybeSizedValue::unsized_(struct_val, meta);\n-\n-                let data = adt::trans_field_ptr(bcx, &repr, struct_val, Disr(0), arg_count);\n-                Store(bcx, data, expr::get_dataptr(bcx, scratch));\n-                Store(bcx, meta, expr::get_meta(bcx, scratch));\n-                field_vals.push(scratch);\n-            }\n-            _ => {}\n-        }\n-        Some(field_vals)\n-    } else if any_uniq_pat(m, col) || any_region_pat(m, col) {\n-        let ptr = if type_is_fat_ptr(bcx.tcx(), left_ty) {\n-            val.val\n-        } else {\n-            Load(bcx, val.val)\n-        };\n-        Some(vec!(ptr))\n-    } else {\n-        match left_ty.sty {\n-            ty::TyArray(_, n) => {\n-                let args = extract_vec_elems(bcx, left_ty, n, 0, val);\n-                Some(args.vals)\n-            }\n-            _ => None\n-        }\n-    };\n-    match adt_vals {\n-        Some(field_vals) => {\n-            let pats = enter_match(bcx, m, col, val, |pats|\n-                check_match::specialize(&mcx, pats,\n-                                        &Constructor::Single, col,\n-                                        field_vals.len())\n-            );\n-            let mut vals: Vec<_> = field_vals.into_iter()\n-                .map(|v|MatchInput::from_val(v))\n-                .collect();\n-            vals.extend_from_slice(&vals_left);\n-            compile_submatch(bcx, &pats, &vals, chk, has_genuine_default);\n-            return;\n-        }\n-        _ => ()\n-    }\n-\n-    // Decide what kind of branch we need\n-    let opts = get_branches(bcx, m, col);\n-    debug!(\"options={:?}\", opts);\n-    let mut kind = NoBranch;\n-    let mut test_val = val.val;\n-    debug!(\"test_val={:?}\", Value(test_val));\n-    if !opts.is_empty() {\n-        match opts[0] {\n-            ConstantValue(..) | ConstantRange(..) => {\n-                test_val = load_if_immediate(bcx, val.val, left_ty);\n-                kind = if left_ty.is_integral() {\n-                    Switch\n-                } else {\n-                    Compare\n-                };\n-            }\n-            Variant(_, ref repr, _, _) => {\n-                let (the_kind, val_opt) = adt::trans_switch(bcx, &repr,\n-                                                            val.val, true);\n-                kind = the_kind;\n-                if let Some(tval) = val_opt { test_val = tval; }\n-            }\n-            SliceLengthEqual(..) | SliceLengthGreaterOrEqual(..) => {\n-                let (_, len) = tvec::get_base_and_len(bcx, val.val, left_ty);\n-                test_val = len;\n-                kind = Switch;\n-            }\n-        }\n-    }\n-    for o in &opts {\n-        match *o {\n-            ConstantRange(..) => { kind = Compare; break },\n-            SliceLengthGreaterOrEqual(..) => { kind = CompareSliceLength; break },\n-            _ => ()\n-        }\n-    }\n-    let else_cx = match kind {\n-        NoBranch | Single => bcx,\n-        _ => bcx.fcx.new_temp_block(\"match_else\")\n-    };\n-    let sw = if kind == Switch {\n-        build::Switch(bcx, test_val, else_cx.llbb, opts.len())\n-    } else {\n-        C_int(ccx, 0) // Placeholder for when not using a switch\n-    };\n-\n-    let defaults = enter_default(else_cx, m, col, val);\n-    let exhaustive = chk.is_infallible() && defaults.is_empty();\n-    let len = opts.len();\n-\n-    if exhaustive && kind == Switch {\n-        build::Unreachable(else_cx);\n-    }\n-\n-    // Compile subtrees for each option\n-    for (i, opt) in opts.iter().enumerate() {\n-        // In some cases of range and vector pattern matching, we need to\n-        // override the failure case so that instead of failing, it proceeds\n-        // to try more matching. branch_chk, then, is the proper failure case\n-        // for the current conditional branch.\n-        let mut branch_chk = None;\n-        let mut opt_cx = else_cx;\n-        let debug_loc = opt.debug_loc();\n-\n-        if kind == Switch || !exhaustive || i + 1 < len {\n-            opt_cx = bcx.fcx.new_temp_block(\"match_case\");\n-            match kind {\n-                Single => Br(bcx, opt_cx.llbb, debug_loc),\n-                Switch => {\n-                    match opt.trans(bcx) {\n-                        SingleResult(r) => {\n-                            AddCase(sw, r.val, opt_cx.llbb);\n-                            bcx = r.bcx;\n-                        }\n-                        _ => {\n-                            bug!(\n-                                \"in compile_submatch, expected \\\n-                                 opt.trans() to return a SingleResult\")\n-                        }\n-                    }\n-                }\n-                Compare | CompareSliceLength => {\n-                    let t = if kind == Compare {\n-                        left_ty\n-                    } else {\n-                        tcx.types.usize // vector length\n-                    };\n-                    let Result { bcx: after_cx, val: matches } = {\n-                        match opt.trans(bcx) {\n-                            SingleResult(Result { bcx, val }) => {\n-                                compare_values(bcx, test_val, val, t, debug_loc)\n-                            }\n-                            RangeResult(Result { val: vbegin, .. },\n-                                        Result { bcx, val: vend }) => {\n-                                let llge = compare_scalar_types(bcx, test_val, vbegin,\n-                                                                t, hir::BiGe, debug_loc);\n-                                let llle = compare_scalar_types(bcx, test_val, vend,\n-                                                                t, hir::BiLe, debug_loc);\n-                                Result::new(bcx, And(bcx, llge, llle, DebugLoc::None))\n-                            }\n-                            LowerBound(Result { bcx, val }) => {\n-                                Result::new(bcx, compare_scalar_types(bcx, test_val,\n-                                                                      val, t, hir::BiGe,\n-                                                                      debug_loc))\n-                            }\n-                        }\n-                    };\n-                    bcx = fcx.new_temp_block(\"compare_next\");\n-\n-                    // If none of the sub-cases match, and the current condition\n-                    // is guarded or has multiple patterns, move on to the next\n-                    // condition, if there is any, rather than falling back to\n-                    // the default.\n-                    let guarded = m[i].data.arm.guard.is_some();\n-                    let multi_pats = m[i].pats.len() > 1;\n-                    if i + 1 < len && (guarded || multi_pats || kind == CompareSliceLength) {\n-                        branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n-                    }\n-                    CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb, debug_loc);\n-                }\n-                _ => ()\n-            }\n-        } else if kind == Compare || kind == CompareSliceLength {\n-            Br(bcx, else_cx.llbb, debug_loc);\n-        }\n-\n-        let mut size = 0;\n-        let mut unpacked = Vec::new();\n-        match *opt {\n-            Variant(disr_val, ref repr, _, _) => {\n-                let ExtractedBlock {vals: argvals, bcx: new_bcx} =\n-                    extract_variant_args(opt_cx, &repr, disr_val, val);\n-                size = argvals.len();\n-                unpacked = argvals;\n-                opt_cx = new_bcx;\n-            }\n-            SliceLengthEqual(len, _) => {\n-                let args = extract_vec_elems(opt_cx, left_ty, len, 0, val);\n-                size = args.vals.len();\n-                unpacked = args.vals.clone();\n-                opt_cx = args.bcx;\n-            }\n-            SliceLengthGreaterOrEqual(before, after, _) => {\n-                let args = extract_vec_elems(opt_cx, left_ty, before, after, val);\n-                size = args.vals.len();\n-                unpacked = args.vals.clone();\n-                opt_cx = args.bcx;\n-            }\n-            ConstantValue(..) | ConstantRange(..) => ()\n-        }\n-        let opt_ms = enter_opt(opt_cx, pat_id, m, opt, col, size, val);\n-        let mut opt_vals: Vec<_> = unpacked.into_iter()\n-            .map(|v|MatchInput::from_val(v))\n-            .collect();\n-        opt_vals.extend_from_slice(&vals_left[..]);\n-        compile_submatch(opt_cx,\n-                         &opt_ms[..],\n-                         &opt_vals[..],\n-                         branch_chk.as_ref().unwrap_or(chk),\n-                         has_genuine_default);\n-    }\n-\n-    // Compile the fall-through case, if any\n-    if !exhaustive && kind != Single {\n-        if kind == Compare || kind == CompareSliceLength {\n-            Br(bcx, else_cx.llbb, DebugLoc::None);\n-        }\n-        match chk {\n-            // If there is only one default arm left, move on to the next\n-            // condition explicitly rather than (eventually) falling back to\n-            // the last default arm.\n-            &JumpToBasicBlock(_) if defaults.len() == 1 && has_genuine_default => {\n-                chk.handle_fail(else_cx);\n-            }\n-            _ => {\n-                compile_submatch(else_cx,\n-                                 &defaults[..],\n-                                 &vals_left[..],\n-                                 chk,\n-                                 has_genuine_default);\n-            }\n-        }\n-    }\n-}\n-\n-pub fn trans_match<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               match_expr: &hir::Expr,\n-                               discr_expr: &hir::Expr,\n-                               arms: &[hir::Arm],\n-                               dest: Dest)\n-                               -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"match::trans_match\");\n-    trans_match_inner(bcx, match_expr.id, discr_expr, arms, dest)\n-}\n-\n-/// Checks whether the binding in `discr` is assigned to anywhere in the expression `body`\n-fn is_discr_reassigned(bcx: Block, discr: &hir::Expr, body: &hir::Expr) -> bool {\n-    let (vid, field) = match discr.node {\n-        hir::ExprPath(..) => match bcx.tcx().expect_def(discr.id) {\n-            Def::Local(_, vid) | Def::Upvar(_, vid, _, _) => (vid, None),\n-            _ => return false\n-        },\n-        hir::ExprField(ref base, field) => {\n-            let vid = match bcx.tcx().expect_def_or_none(base.id) {\n-                Some(Def::Local(_, vid)) | Some(Def::Upvar(_, vid, _, _)) => vid,\n-                _ => return false\n-            };\n-            (vid, Some(mc::NamedField(field.node)))\n-        },\n-        hir::ExprTupField(ref base, field) => {\n-            let vid = match bcx.tcx().expect_def_or_none(base.id) {\n-                Some(Def::Local(_, vid)) | Some(Def::Upvar(_, vid, _, _)) => vid,\n-                _ => return false\n-            };\n-            (vid, Some(mc::PositionalField(field.node)))\n-        },\n-        _ => return false\n-    };\n-\n-    let mut rc = ReassignmentChecker {\n-        node: vid,\n-        field: field,\n-        reassigned: false\n-    };\n-    bcx.tcx().normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n-        let mut visitor = euv::ExprUseVisitor::new(&mut rc, &infcx);\n-        visitor.walk_expr(body);\n-    });\n-    rc.reassigned\n-}\n-\n-struct ReassignmentChecker {\n-    node: ast::NodeId,\n-    field: Option<mc::FieldName>,\n-    reassigned: bool\n-}\n-\n-// Determine if the expression we're matching on is reassigned to within\n-// the body of the match's arm.\n-// We only care for the `mutate` callback since this check only matters\n-// for cases where the matched value is moved.\n-impl<'tcx> euv::Delegate<'tcx> for ReassignmentChecker {\n-    fn consume(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: euv::ConsumeMode) {}\n-    fn matched_pat(&mut self, _: &hir::Pat, _: mc::cmt, _: euv::MatchMode) {}\n-    fn consume_pat(&mut self, _: &hir::Pat, _: mc::cmt, _: euv::ConsumeMode) {}\n-    fn borrow(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: ty::Region,\n-              _: ty::BorrowKind, _: euv::LoanCause) {}\n-    fn decl_without_init(&mut self, _: ast::NodeId, _: Span) {}\n-\n-    fn mutate(&mut self, _: ast::NodeId, _: Span, cmt: mc::cmt, _: euv::MutateMode) {\n-        let cmt_id = |cmt: &mc::cmt| match cmt.cat {\n-            Categorization::Upvar(mc::Upvar { id: ty::UpvarId { var_id: vid, ..}, ..}) |\n-            Categorization::Local(vid) => Some(vid),\n-            Categorization::Interior(ref base_cmt, mc::InteriorField(_)) => Some(base_cmt.id),\n-            _ => None\n-        };\n-        match cmt.cat {\n-            Categorization::Upvar(mc::Upvar { id: ty::UpvarId { var_id: vid, .. }, .. }) |\n-            Categorization::Local(vid) => self.reassigned |= self.node == vid,\n-            ref cat => {\n-                let mut cat = cat;\n-                while let &Categorization::Interior(ref base_cmt, mc::InteriorField(field)) = cat {\n-                    if let Some(vid) = cmt_id(base_cmt) {\n-                        if self.node == vid && (self.field.is_none() || self.field == Some(field)) {\n-                            self.reassigned = true;\n-                            return;\n-                        }\n-                    }\n-                    cat = &base_cmt.cat;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &hir::Pat,\n-                                   discr: &hir::Expr, body: &hir::Expr)\n-                                   -> BindingsMap<'tcx> {\n-    // Create the bindings map, which is a mapping from each binding name\n-    // to an alloca() that will be the value for that local variable.\n-    // Note that we use the names because each binding will have many ids\n-    // from the various alternatives.\n-    let ccx = bcx.ccx();\n-    let reassigned = is_discr_reassigned(bcx, discr, body);\n-    let mut bindings_map = FnvHashMap();\n-    pat_bindings(&pat, |bm, p_id, span, path1| {\n-        let name = path1.node;\n-        let variable_ty = node_id_type(bcx, p_id);\n-        let llvariable_ty = type_of::type_of(ccx, variable_ty);\n-        let tcx = bcx.tcx();\n-        let param_env = tcx.empty_parameter_environment();\n-\n-        let llmatch;\n-        let trmode;\n-        let moves_by_default = variable_ty.moves_by_default(tcx, &param_env, span);\n-        match bm {\n-            hir::BindByValue(_) if !moves_by_default || reassigned =>\n-            {\n-                llmatch = alloca(bcx, llvariable_ty.ptr_to(), \"__llmatch\");\n-                let llcopy = alloca(bcx, llvariable_ty, &bcx.name(name));\n-                trmode = if moves_by_default {\n-                    TrByMoveIntoCopy(llcopy)\n-                } else {\n-                    TrByCopy(llcopy)\n-                };\n-            }\n-            hir::BindByValue(_) => {\n-                // in this case, the final type of the variable will be T,\n-                // but during matching we need to store a *T as explained\n-                // above\n-                llmatch = alloca(bcx, llvariable_ty.ptr_to(), &bcx.name(name));\n-                trmode = TrByMoveRef;\n-            }\n-            hir::BindByRef(_) => {\n-                llmatch = alloca(bcx, llvariable_ty, &bcx.name(name));\n-                trmode = TrByRef;\n-            }\n-        };\n-        bindings_map.insert(name, BindingInfo {\n-            llmatch: llmatch,\n-            trmode: trmode,\n-            id: p_id,\n-            span: span,\n-            ty: variable_ty\n-        });\n-    });\n-    return bindings_map;\n-}\n-\n-fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n-                                 match_id: ast::NodeId,\n-                                 discr_expr: &hir::Expr,\n-                                 arms: &[hir::Arm],\n-                                 dest: Dest) -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"match::trans_match_inner\");\n-    let fcx = scope_cx.fcx;\n-    let mut bcx = scope_cx;\n-    let tcx = bcx.tcx();\n-\n-    let discr_datum = unpack_datum!(bcx, expr::trans_to_lvalue(bcx, discr_expr,\n-                                                               \"match\"));\n-    if bcx.unreachable.get() {\n-        return bcx;\n-    }\n-\n-    let t = node_id_type(bcx, discr_expr.id);\n-    let chk = if t.is_uninhabited(tcx) {\n-        Unreachable\n-    } else {\n-        Infallible\n-    };\n-\n-    let arm_datas: Vec<ArmData> = arms.iter().map(|arm| ArmData {\n-        bodycx: fcx.new_id_block(\"case_body\", arm.body.id),\n-        arm: arm,\n-        bindings_map: create_bindings_map(bcx, &arm.pats[0], discr_expr, &arm.body)\n-    }).collect();\n-\n-    let mut pat_renaming_map = if scope_cx.sess().opts.debuginfo != NoDebugInfo {\n-        Some(FnvHashMap())\n-    } else {\n-        None\n-    };\n-\n-    let arm_pats: Vec<Vec<P<hir::Pat>>> = {\n-        let mut static_inliner = StaticInliner::new(scope_cx.tcx(),\n-                                                    pat_renaming_map.as_mut());\n-        arm_datas.iter().map(|arm_data| {\n-            arm_data.arm.pats.iter().map(|p| static_inliner.fold_pat((*p).clone())).collect()\n-        }).collect()\n-    };\n-\n-    let mut matches = Vec::new();\n-    for (arm_data, pats) in arm_datas.iter().zip(&arm_pats) {\n-        matches.extend(pats.iter().map(|p| Match {\n-            pats: vec![&p],\n-            data: arm_data,\n-            bound_ptrs: Vec::new(),\n-            pat_renaming_map: pat_renaming_map.as_ref()\n-        }));\n-    }\n-\n-    // `compile_submatch` works one column of arm patterns a time and\n-    // then peels that column off. So as we progress, it may become\n-    // impossible to tell whether we have a genuine default arm, i.e.\n-    // `_ => foo` or not. Sometimes it is important to know that in order\n-    // to decide whether moving on to the next condition or falling back\n-    // to the default arm.\n-    let has_default = arms.last().map_or(false, |arm| {\n-        arm.pats.len() == 1\n-        && arm.pats.last().unwrap().node == PatKind::Wild\n-    });\n-\n-    compile_submatch(bcx, &matches[..], &[discr_datum.match_input()], &chk, has_default);\n-\n-    let mut arm_cxs = Vec::new();\n-    for arm_data in &arm_datas {\n-        let mut bcx = arm_data.bodycx;\n-\n-        // insert bindings into the lllocals map and add cleanups\n-        let cs = fcx.push_custom_cleanup_scope();\n-        bcx = insert_lllocals(bcx, &arm_data.bindings_map, Some(cleanup::CustomScope(cs)));\n-        bcx = expr::trans_into(bcx, &arm_data.arm.body, dest);\n-        bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, cs);\n-        arm_cxs.push(bcx);\n-    }\n-\n-    bcx = scope_cx.fcx.join_blocks(match_id, &arm_cxs[..]);\n-    return bcx;\n-}\n-\n-/// Generates code for a local variable declaration like `let <pat>;` or `let <pat> =\n-/// <opt_init_expr>`.\n-pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               local: &hir::Local)\n-                               -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"match::store_local\");\n-    let mut bcx = bcx;\n-    let tcx = bcx.tcx();\n-    let pat = &local.pat;\n-\n-    fn create_dummy_locals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                       pat: &hir::Pat)\n-                                       -> Block<'blk, 'tcx> {\n-        let _icx = push_ctxt(\"create_dummy_locals\");\n-        // create dummy memory for the variables if we have no\n-        // value to store into them immediately\n-        let tcx = bcx.tcx();\n-        pat_bindings(pat, |_, p_id, _, path1| {\n-            let scope = cleanup::var_scope(tcx, p_id);\n-            bcx = mk_binding_alloca(\n-                bcx, p_id, path1.node, scope, (),\n-                \"_match::store_local::create_dummy_locals\",\n-                |(), bcx, Datum { val: llval, ty, kind }| {\n-                    // Dummy-locals start out uninitialized, so set their\n-                    // drop-flag hints (if any) to \"moved.\"\n-                    if let Some(hint) = kind.dropflag_hint(bcx) {\n-                        let moved_hint = adt::DTOR_MOVED_HINT;\n-                        debug!(\"store moved_hint={} for hint={:?}, uninitialized dummy\",\n-                               moved_hint, hint);\n-                        Store(bcx, C_u8(bcx.fcx.ccx, moved_hint), hint.to_value().value());\n-                    }\n-\n-                    if kind.drop_flag_info.must_zero() {\n-                        // if no drop-flag hint, or the hint requires\n-                        // we maintain the embedded drop-flag, then\n-                        // mark embedded drop-flag(s) as moved\n-                        // (i.e. \"already dropped\").\n-                        drop_done_fill_mem(bcx, llval, ty);\n-                    }\n-                    bcx\n-                });\n-        });\n-        bcx\n-    }\n-\n-    match local.init {\n-        Some(ref init_expr) => {\n-            // Optimize the \"let x = expr\" case. This just writes\n-            // the result of evaluating `expr` directly into the alloca\n-            // for `x`. Often the general path results in similar or the\n-            // same code post-optimization, but not always. In particular,\n-            // in unsafe code, you can have expressions like\n-            //\n-            //    let x = intrinsics::uninit();\n-            //\n-            // In such cases, the more general path is unsafe, because\n-            // it assumes it is matching against a valid value.\n-            if let Some(name) = simple_name(pat) {\n-                let var_scope = cleanup::var_scope(tcx, local.id);\n-                return mk_binding_alloca(\n-                    bcx, pat.id, name, var_scope, (),\n-                    \"_match::store_local\",\n-                    |(), bcx, Datum { val: v, .. }| expr::trans_into(bcx, &init_expr,\n-                                                                     expr::SaveIn(v)));\n-            }\n-\n-            // General path.\n-            let init_datum =\n-                unpack_datum!(bcx, expr::trans_to_lvalue(bcx, &init_expr, \"let\"));\n-            if bcx.sess().asm_comments() {\n-                add_comment(bcx, \"creating zeroable ref llval\");\n-            }\n-            let var_scope = cleanup::var_scope(tcx, local.id);\n-            bind_irrefutable_pat(bcx, pat, init_datum.match_input(), var_scope)\n-        }\n-        None => {\n-            create_dummy_locals(bcx, pat)\n-        }\n-    }\n-}\n-\n-fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n-                                       p_id: ast::NodeId,\n-                                       name: ast::Name,\n-                                       cleanup_scope: cleanup::ScopeId,\n-                                       arg: A,\n-                                       caller_name: &'static str,\n-                                       populate: F)\n-                                       -> Block<'blk, 'tcx> where\n-    F: FnOnce(A, Block<'blk, 'tcx>, Datum<'tcx, Lvalue>) -> Block<'blk, 'tcx>,\n-{\n-    let var_ty = node_id_type(bcx, p_id);\n-\n-    // Allocate memory on stack for the binding.\n-    let llval = alloc_ty(bcx, var_ty, &bcx.name(name));\n-    let lvalue = Lvalue::new_with_hint(caller_name, bcx, p_id, HintKind::DontZeroJustUse);\n-    let datum = Datum::new(llval, var_ty, lvalue);\n-\n-    debug!(\"mk_binding_alloca cleanup_scope={:?} llval={:?} var_ty={:?}\",\n-           cleanup_scope, Value(llval), var_ty);\n-\n-    // Subtle: be sure that we *populate* the memory *before*\n-    // we schedule the cleanup.\n-    call_lifetime_start(bcx, llval);\n-    let bcx = populate(arg, bcx, datum);\n-    bcx.fcx.schedule_lifetime_end(cleanup_scope, llval);\n-    bcx.fcx.schedule_drop_mem(cleanup_scope, llval, var_ty, lvalue.dropflag_hint(bcx));\n-\n-    // Now that memory is initialized and has cleanup scheduled,\n-    // insert datum into the local variable map.\n-    bcx.fcx.lllocals.borrow_mut().insert(p_id, datum);\n-    bcx\n-}\n-\n-/// A simple version of the pattern matching code that only handles\n-/// irrefutable patterns. This is used in let/argument patterns,\n-/// not in match statements. Unifying this code with the code above\n-/// sounds nice, but in practice it produces very inefficient code,\n-/// since the match code is so much more general. In most cases,\n-/// LLVM is able to optimize the code, but it causes longer compile\n-/// times and makes the generated code nigh impossible to read.\n-///\n-/// # Arguments\n-/// - bcx: starting basic block context\n-/// - pat: the irrefutable pattern being matched.\n-/// - val: the value being matched -- must be an lvalue (by ref, with cleanup)\n-pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    pat: &hir::Pat,\n-                                    val: MatchInput,\n-                                    cleanup_scope: cleanup::ScopeId)\n-                                    -> Block<'blk, 'tcx> {\n-    debug!(\"bind_irrefutable_pat(bcx={}, pat={:?}, val={:?})\",\n-           bcx.to_str(), pat, val);\n-\n-    if bcx.sess().asm_comments() {\n-        add_comment(bcx, &format!(\"bind_irrefutable_pat(pat={:?})\",\n-                                 pat));\n-    }\n-\n-    let _indenter = indenter();\n-\n-    let _icx = push_ctxt(\"match::bind_irrefutable_pat\");\n-    let mut bcx = bcx;\n-    let tcx = bcx.tcx();\n-    let ccx = bcx.ccx();\n-    match pat.node {\n-        PatKind::Binding(pat_binding_mode, ref path1, ref inner) => {\n-            // Allocate the stack slot where the value of this\n-            // binding will live and place it into the appropriate\n-            // map.\n-            bcx = mk_binding_alloca(bcx, pat.id, path1.node, cleanup_scope, (),\n-                                    \"_match::bind_irrefutable_pat\",\n-                                    |(), bcx, Datum { val: llval, ty, kind: _ }| {\n-                match pat_binding_mode {\n-                    hir::BindByValue(_) => {\n-                        // By value binding: move the value that `val`\n-                        // points at into the binding's stack slot.\n-                        let d = val.to_datum(ty);\n-                        d.store_to(bcx, llval)\n-                    }\n-\n-                    hir::BindByRef(_) => {\n-                        // By ref binding: the value of the variable\n-                        // is the pointer `val` itself or fat pointer referenced by `val`\n-                        if type_is_fat_ptr(bcx.tcx(), ty) {\n-                            expr::copy_fat_ptr(bcx, val.val, llval);\n-                        }\n-                        else {\n-                            Store(bcx, val.val, llval);\n-                        }\n-\n-                        bcx\n-                    }\n-                }\n-            });\n-\n-            if let Some(ref inner_pat) = *inner {\n-                bcx = bind_irrefutable_pat(bcx, &inner_pat, val, cleanup_scope);\n-            }\n-        }\n-        PatKind::TupleStruct(_, ref sub_pats, ddpos) => {\n-            match bcx.tcx().expect_def(pat.id) {\n-                Def::Variant(enum_id, var_id) => {\n-                    let repr = adt::represent_node(bcx, pat.id);\n-                    let vinfo = ccx.tcx().lookup_adt_def(enum_id).variant_with_id(var_id);\n-                    let args = extract_variant_args(bcx,\n-                                                    &repr,\n-                                                    Disr::from(vinfo.disr_val),\n-                                                    val);\n-                    for (i, subpat) in sub_pats.iter()\n-                                               .enumerate_and_adjust(vinfo.fields.len(), ddpos) {\n-                        bcx = bind_irrefutable_pat(\n-                            bcx,\n-                            subpat,\n-                            MatchInput::from_val(args.vals[i]),\n-                            cleanup_scope);\n-                    }\n-                }\n-                Def::Struct(..) => {\n-                    let expected_len = match *ccx.tcx().pat_ty(&pat) {\n-                        ty::TyS{sty: ty::TyStruct(adt_def, _), ..} => {\n-                            adt_def.struct_variant().fields.len()\n-                        }\n-                        ref ty => {\n-                            span_bug!(pat.span, \"tuple struct pattern unexpected type {:?}\", ty);\n-                        }\n-                    };\n-\n-                    let repr = adt::represent_node(bcx, pat.id);\n-                    let val = adt::MaybeSizedValue::sized(val.val);\n-                    for (i, elem) in sub_pats.iter().enumerate_and_adjust(expected_len, ddpos) {\n-                        let fldptr = adt::trans_field_ptr(bcx, &repr, val, Disr(0), i);\n-                        bcx = bind_irrefutable_pat(\n-                            bcx,\n-                            &elem,\n-                            MatchInput::from_val(fldptr),\n-                            cleanup_scope);\n-                    }\n-                }\n-                _ => {\n-                    // Nothing to do here.\n-                }\n-            }\n-        }\n-        PatKind::Struct(_, ref fields, _) => {\n-            let tcx = bcx.tcx();\n-            let pat_ty = node_id_type(bcx, pat.id);\n-            let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n-            let pat_v = VariantInfo::of_node(tcx, pat_ty, pat.id);\n-\n-            let val = if type_is_sized(tcx, pat_ty) {\n-                adt::MaybeSizedValue::sized(val.val)\n-            } else {\n-                let data = Load(bcx, expr::get_dataptr(bcx, val.val));\n-                let meta = Load(bcx, expr::get_meta(bcx, val.val));\n-                adt::MaybeSizedValue::unsized_(data, meta)\n-            };\n-\n-            for f in fields {\n-                let name = f.node.name;\n-                let field_idx = pat_v.field_index(name);\n-                let mut fldptr = adt::trans_field_ptr(\n-                    bcx,\n-                    &pat_repr,\n-                    val,\n-                    pat_v.discr,\n-                    field_idx);\n-\n-                let fty = pat_v.fields[field_idx].1;\n-                // If it's not sized, then construct a fat pointer instead of\n-                // a regular one\n-                if !type_is_sized(tcx, fty) {\n-                    let scratch = alloc_ty(bcx, fty, \"__struct_field_fat_ptr\");\n-                    debug!(\"Creating fat pointer {:?}\", Value(scratch));\n-                    Store(bcx, fldptr, expr::get_dataptr(bcx, scratch));\n-                    Store(bcx, val.meta, expr::get_meta(bcx, scratch));\n-                    fldptr = scratch;\n-                }\n-                bcx = bind_irrefutable_pat(bcx,\n-                                           &f.node.pat,\n-                                           MatchInput::from_val(fldptr),\n-                                           cleanup_scope);\n-            }\n-        }\n-        PatKind::Tuple(ref elems, ddpos) => {\n-            match tcx.node_id_to_type(pat.id).sty {\n-                ty::TyTuple(ref tys) => {\n-                    let repr = adt::represent_node(bcx, pat.id);\n-                    let val = adt::MaybeSizedValue::sized(val.val);\n-                    for (i, elem) in elems.iter().enumerate_and_adjust(tys.len(), ddpos) {\n-                        let fldptr = adt::trans_field_ptr(bcx, &repr, val, Disr(0), i);\n-                        bcx = bind_irrefutable_pat(\n-                            bcx,\n-                            &elem,\n-                            MatchInput::from_val(fldptr),\n-                            cleanup_scope);\n-                    }\n-                }\n-                ref sty => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", sty),\n-            }\n-        }\n-        PatKind::Box(ref inner) => {\n-            let pat_ty = node_id_type(bcx, inner.id);\n-            // Pass along DSTs as fat pointers.\n-            let val = if type_is_fat_ptr(tcx, pat_ty) {\n-                // We need to check for this, as the pattern could be binding\n-                // a fat pointer by-value.\n-                if let PatKind::Binding(hir::BindByRef(..),_,_) = inner.node {\n-                    val.val\n-                } else {\n-                    Load(bcx, val.val)\n-                }\n-            } else if type_is_sized(tcx, pat_ty) {\n-                Load(bcx, val.val)\n-            } else {\n-                val.val\n-            };\n-            bcx = bind_irrefutable_pat(\n-                bcx, &inner, MatchInput::from_val(val), cleanup_scope);\n-        }\n-        PatKind::Ref(ref inner, _) => {\n-            let pat_ty = node_id_type(bcx, inner.id);\n-            // Pass along DSTs as fat pointers.\n-            let val = if type_is_fat_ptr(tcx, pat_ty) {\n-                // We need to check for this, as the pattern could be binding\n-                // a fat pointer by-value.\n-                if let PatKind::Binding(hir::BindByRef(..),_,_) = inner.node {\n-                    val.val\n-                } else {\n-                    Load(bcx, val.val)\n-                }\n-            } else if type_is_sized(tcx, pat_ty) {\n-                Load(bcx, val.val)\n-            } else {\n-                val.val\n-            };\n-            bcx = bind_irrefutable_pat(\n-                bcx,\n-                &inner,\n-                MatchInput::from_val(val),\n-                cleanup_scope);\n-        }\n-        PatKind::Vec(ref before, ref slice, ref after) => {\n-            let pat_ty = node_id_type(bcx, pat.id);\n-            let mut extracted = extract_vec_elems(bcx, pat_ty, before.len(), after.len(), val);\n-            match slice {\n-                &Some(_) => {\n-                    extracted.vals.insert(\n-                        before.len(),\n-                        bind_subslice_pat(bcx, pat.id, val, before.len(), after.len())\n-                    );\n-                }\n-                &None => ()\n-            }\n-            bcx = before\n-                .iter()\n-                .chain(slice.iter())\n-                .chain(after.iter())\n-                .zip(extracted.vals)\n-                .fold(bcx, |bcx, (inner, elem)| {\n-                    bind_irrefutable_pat(\n-                        bcx,\n-                        &inner,\n-                        MatchInput::from_val(elem),\n-                        cleanup_scope)\n-                });\n-        }\n-        PatKind::Path(..) | PatKind::Wild |\n-        PatKind::Lit(..) | PatKind::Range(..) => ()\n-    }\n-    return bcx;\n-}"}, {"sha": "2fb7a69d36186a45e45646112300e6cd690e1a88", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 50, "deletions": 332, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -53,14 +53,9 @@ use rustc::ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::IntType;\n-use _match;\n use abi::FAT_PTR_ADDR;\n-use base::InitAlloca;\n use build::*;\n-use cleanup;\n-use cleanup::CleanupMethods;\n use common::*;\n-use datum;\n use debuginfo::DebugLoc;\n use glue;\n use machine;\n@@ -69,50 +64,24 @@ use type_::Type;\n use type_of;\n use value::Value;\n \n-type Hint = attr::ReprAttr;\n-\n-// Representation of the context surrounding an unsized type. I want\n-// to be able to track the drop flags that are injected by trans.\n-#[derive(Clone, Copy, PartialEq, Debug)]\n-pub struct TypeContext {\n-    prefix: Type,\n-    needs_drop_flag: bool,\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum BranchKind {\n+    Switch,\n+    Single\n }\n \n-impl TypeContext {\n-    pub fn prefix(&self) -> Type { self.prefix }\n-    pub fn needs_drop_flag(&self) -> bool { self.needs_drop_flag }\n-\n-    fn direct(t: Type) -> TypeContext {\n-        TypeContext { prefix: t, needs_drop_flag: false }\n-    }\n-    fn may_need_drop_flag(t: Type, needs_drop_flag: bool) -> TypeContext {\n-        TypeContext { prefix: t, needs_drop_flag: needs_drop_flag }\n-    }\n-}\n+type Hint = attr::ReprAttr;\n \n /// Representations.\n #[derive(Eq, PartialEq, Debug)]\n pub enum Repr<'tcx> {\n     /// C-like enums; basically an int.\n     CEnum(IntType, Disr, Disr), // discriminant range (signedness based on the IntType)\n     /// Single-case variants, and structs/tuples/records.\n-    ///\n-    /// Structs with destructors need a dynamic destroyedness flag to\n-    /// avoid running the destructor too many times; this is included\n-    /// in the `Struct` if present.\n-    /// (The flag if nonzero, represents the initialization value to use;\n-    ///  if zero, then use no flag at all.)\n-    Univariant(Struct<'tcx>, u8),\n+    Univariant(Struct<'tcx>),\n     /// General-case enums: for each case there is a struct, and they\n     /// all start with a field for the discriminant.\n-    ///\n-    /// Types with destructors need a dynamic destroyedness flag to\n-    /// avoid running the destructor too many times; the last argument\n-    /// indicates whether such a flag is present.\n-    /// (The flag, if nonzero, represents the initialization value to use;\n-    ///  if zero, then use no flag at all.)\n-    General(IntType, Vec<Struct<'tcx>>, u8),\n+    General(IntType, Vec<Struct<'tcx>>),\n     /// Two cases distinguished by a nullable pointer: the case with discriminant\n     /// `nndiscr` must have single field which is known to be nonnull due to its type.\n     /// The other case is known to be zero sized. Hence we represent the enum\n@@ -178,14 +147,6 @@ impl MaybeSizedValue {\n     }\n }\n \n-/// Convenience for `represent_type`.  There should probably be more or\n-/// these, for places in trans where the `Ty` isn't directly\n-/// available.\n-pub fn represent_node<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  node: ast::NodeId) -> Rc<Repr<'tcx>> {\n-    represent_type(bcx.ccx(), node_id_type(bcx, node))\n-}\n-\n /// Decides how to represent a given type.\n pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 t: Ty<'tcx>)\n@@ -201,91 +162,36 @@ pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     repr\n }\n \n-const fn repeat_u8_as_u32(val: u8) -> u32 {\n-    (val as u32) << 24 | (val as u32) << 16 | (val as u32) << 8 | val as u32\n-}\n-\n-const fn repeat_u8_as_u64(val: u8) -> u64 {\n-    (repeat_u8_as_u32(val) as u64) << 32 | repeat_u8_as_u32(val) as u64\n-}\n-\n-/// `DTOR_NEEDED_HINT` is a stack-local hint that just means\n-/// \"we do not know whether the destructor has run or not; check the\n-/// drop-flag embedded in the value itself.\"\n-pub const DTOR_NEEDED_HINT: u8 = 0x3d;\n-\n-/// `DTOR_MOVED_HINT` is a stack-local hint that means \"this value has\n-/// definitely been moved; you do not need to run its destructor.\"\n-///\n-/// (However, for now, such values may still end up being explicitly\n-/// zeroed by the generated code; this is the distinction between\n-/// `datum::DropFlagInfo::ZeroAndMaintain` versus\n-/// `datum::DropFlagInfo::DontZeroJustUse`.)\n-pub const DTOR_MOVED_HINT: u8 = 0x2d;\n-\n-pub const DTOR_NEEDED: u8 = 0xd4;\n-#[allow(dead_code)]\n-pub const DTOR_NEEDED_U64: u64 = repeat_u8_as_u64(DTOR_NEEDED);\n-\n-pub const DTOR_DONE: u8 = 0x1d;\n-#[allow(dead_code)]\n-pub const DTOR_DONE_U64: u64 = repeat_u8_as_u64(DTOR_DONE);\n-\n-fn dtor_to_init_u8(dtor: bool) -> u8 {\n-    if dtor { DTOR_NEEDED } else { 0 }\n-}\n-\n-pub trait GetDtorType<'tcx> { fn dtor_type(self) -> Ty<'tcx>; }\n-impl<'a, 'tcx> GetDtorType<'tcx> for TyCtxt<'a, 'tcx, 'tcx> {\n-    fn dtor_type(self) -> Ty<'tcx> { self.types.u8 }\n-}\n-\n-fn dtor_active(flag: u8) -> bool {\n-    flag != 0\n-}\n-\n fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      t: Ty<'tcx>) -> Repr<'tcx> {\n     match t.sty {\n         ty::TyTuple(ref elems) => {\n-            Univariant(mk_struct(cx, &elems[..], false, t), 0)\n+            Univariant(mk_struct(cx, &elems[..], false, t))\n         }\n         ty::TyStruct(def, substs) => {\n-            let mut ftys = def.struct_variant().fields.iter().map(|field| {\n+            let ftys = def.struct_variant().fields.iter().map(|field| {\n                 monomorphize::field_ty(cx.tcx(), substs, field)\n             }).collect::<Vec<_>>();\n             let packed = cx.tcx().lookup_packed(def.did);\n-            // FIXME(16758) don't add a drop flag to unsized structs, as it\n-            // won't actually be in the location we say it is because it'll be after\n-            // the unsized field. Several other pieces of code assume that the unsized\n-            // field is definitely the last one.\n-            let dtor = def.dtor_kind().has_drop_flag() && type_is_sized(cx.tcx(), t);\n-            if dtor {\n-                ftys.push(cx.tcx().dtor_type());\n-            }\n \n-            Univariant(mk_struct(cx, &ftys[..], packed, t), dtor_to_init_u8(dtor))\n+            Univariant(mk_struct(cx, &ftys[..], packed, t))\n         }\n         ty::TyClosure(_, ref substs) => {\n-            Univariant(mk_struct(cx, &substs.upvar_tys, false, t), 0)\n+            Univariant(mk_struct(cx, &substs.upvar_tys, false, t))\n         }\n         ty::TyEnum(def, substs) => {\n             let cases = get_cases(cx.tcx(), def, substs);\n             let hint = *cx.tcx().lookup_repr_hints(def.did).get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n-            let dtor = def.dtor_kind().has_drop_flag();\n-\n             if cases.is_empty() {\n                 // Uninhabitable; represent as unit\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n-                let ftys = if dtor { vec!(cx.tcx().dtor_type()) } else { vec!() };\n-                return Univariant(mk_struct(cx, &ftys[..], false, t),\n-                                  dtor_to_init_u8(dtor));\n+                return Univariant(mk_struct(cx, &[], false, t));\n             }\n \n-            if !dtor && cases.iter().all(|c| c.tys.is_empty()) {\n+            if cases.iter().all(|c| c.tys.is_empty()) {\n                 // All bodies empty -> intlike\n                 let discrs: Vec<_> = cases.iter().map(|c| Disr::from(c.discr)).collect();\n                 let bounds = IntBounds {\n@@ -307,13 +213,10 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             if cases.len() == 1 && hint == attr::ReprAny {\n                 // Equivalent to a struct/tuple/newtype.\n-                let mut ftys = cases[0].tys.clone();\n-                if dtor { ftys.push(cx.tcx().dtor_type()); }\n-                return Univariant(mk_struct(cx, &ftys[..], false, t),\n-                                  dtor_to_init_u8(dtor));\n+                return Univariant(mk_struct(cx, &cases[0].tys, false, t));\n             }\n \n-            if !dtor && cases.len() == 2 && hint == attr::ReprAny {\n+            if cases.len() == 2 && hint == attr::ReprAny {\n                 // Nullable pointer optimization\n                 let mut discr = 0;\n                 while discr < 2 {\n@@ -356,7 +259,6 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), min_ity));\n                 ftys.extend_from_slice(&c.tys);\n-                if dtor { ftys.push(cx.tcx().dtor_type()); }\n                 mk_struct(cx, &ftys, false, t)\n             }).collect();\n \n@@ -418,13 +320,12 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n                 ftys.extend_from_slice(&c.tys);\n-                if dtor { ftys.push(cx.tcx().dtor_type()); }\n                 mk_struct(cx, &ftys[..], false, t)\n             }).collect();\n \n             ensure_enum_fits_in_address_space(cx, &fields[..], t);\n \n-            General(ity, fields, dtor_to_init_u8(dtor))\n+            General(ity, fields)\n         }\n         _ => bug!(\"adt::represent_type called on non-ADT type: {}\", t)\n     }\n@@ -722,9 +623,7 @@ fn ensure_enum_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n /// and fill in the actual contents in a second pass to prevent\n /// unbounded recursion; see also the comments in `trans::type_of`.\n pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>) -> Type {\n-    let c = generic_type_of(cx, r, None, false, false, false);\n-    assert!(!c.needs_drop_flag);\n-    c.prefix\n+    generic_type_of(cx, r, None, false, false)\n }\n \n \n@@ -733,25 +632,19 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>) -> Type {\n // are going to get the wrong type (it will not include the unsized parts of it).\n pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 r: &Repr<'tcx>, dst: bool) -> Type {\n-    let c = generic_type_of(cx, r, None, true, dst, false);\n-    assert!(!c.needs_drop_flag);\n-    c.prefix\n-}\n-pub fn sizing_type_context_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                        r: &Repr<'tcx>, dst: bool) -> TypeContext {\n-    generic_type_of(cx, r, None, true, dst, true)\n+    generic_type_of(cx, r, None, true, dst)\n }\n+\n pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     r: &Repr<'tcx>, name: &str) -> Type {\n-    let c = generic_type_of(cx, r, Some(name), false, false, false);\n-    assert!(!c.needs_drop_flag);\n-    c.prefix\n+    generic_type_of(cx, r, Some(name), false, false)\n }\n+\n pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 r: &Repr<'tcx>, llty: &mut Type) {\n     match *r {\n         CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n-        Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n+        Univariant(ref st) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n             llty.set_struct_body(&struct_llfields(cx, st, false, false),\n                                  st.packed)\n     }\n@@ -761,50 +654,40 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                              r: &Repr<'tcx>,\n                              name: Option<&str>,\n                              sizing: bool,\n-                             dst: bool,\n-                             delay_drop_flag: bool) -> TypeContext {\n-    debug!(\"adt::generic_type_of r: {:?} name: {:?} sizing: {} dst: {} delay_drop_flag: {}\",\n-           r, name, sizing, dst, delay_drop_flag);\n+                             dst: bool) -> Type {\n+    debug!(\"adt::generic_type_of r: {:?} name: {:?} sizing: {} dst: {}\",\n+           r, name, sizing, dst);\n     match *r {\n-        CEnum(ity, _, _) => TypeContext::direct(ll_inttype(cx, ity)),\n+        CEnum(ity, _, _) => ll_inttype(cx, ity),\n         RawNullablePointer { nnty, .. } =>\n-            TypeContext::direct(type_of::sizing_type_of(cx, nnty)),\n+            type_of::sizing_type_of(cx, nnty),\n         StructWrappedNullablePointer { nonnull: ref st, .. } => {\n             match name {\n                 None => {\n-                    TypeContext::direct(\n-                        Type::struct_(cx, &struct_llfields(cx, st, sizing, dst),\n-                                      st.packed))\n+                    Type::struct_(cx, &struct_llfields(cx, st, sizing, dst),\n+                                  st.packed)\n                 }\n                 Some(name) => {\n                     assert_eq!(sizing, false);\n-                    TypeContext::direct(Type::named_struct(cx, name))\n+                    Type::named_struct(cx, name)\n                 }\n             }\n         }\n-        Univariant(ref st, dtor_needed) => {\n-            let dtor_needed = dtor_needed != 0;\n+        Univariant(ref st) => {\n             match name {\n                 None => {\n-                    let mut fields = struct_llfields(cx, st, sizing, dst);\n-                    if delay_drop_flag && dtor_needed {\n-                        fields.pop();\n-                    }\n-                    TypeContext::may_need_drop_flag(\n-                        Type::struct_(cx, &fields,\n-                                      st.packed),\n-                        delay_drop_flag && dtor_needed)\n+                    let fields = struct_llfields(cx, st, sizing, dst);\n+                    Type::struct_(cx, &fields, st.packed)\n                 }\n                 Some(name) => {\n                     // Hypothesis: named_struct's can never need a\n                     // drop flag. (... needs validation.)\n                     assert_eq!(sizing, false);\n-                    TypeContext::direct(Type::named_struct(cx, name))\n+                    Type::named_struct(cx, name)\n                 }\n             }\n         }\n-        General(ity, ref sts, dtor_needed) => {\n-            let dtor_needed = dtor_needed != 0;\n+        General(ity, ref sts) => {\n             // We need a representation that has:\n             // * The alignment of the most-aligned field\n             // * The size of the largest variant (rounded up to that alignment)\n@@ -836,25 +719,18 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             };\n             assert_eq!(machine::llalign_of_min(cx, fill_ty), align);\n             assert_eq!(padded_discr_size % discr_size, 0); // Ensure discr_ty can fill pad evenly\n-            let mut fields: Vec<Type> =\n+            let fields: Vec<Type> =\n                 [discr_ty,\n                  Type::array(&discr_ty, (padded_discr_size - discr_size)/discr_size),\n                  fill_ty].iter().cloned().collect();\n-            if delay_drop_flag && dtor_needed {\n-                fields.pop();\n-            }\n             match name {\n                 None => {\n-                    TypeContext::may_need_drop_flag(\n-                        Type::struct_(cx, &fields[..], false),\n-                        delay_drop_flag && dtor_needed)\n+                    Type::struct_(cx, &fields[..], false)\n                 }\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n                     llty.set_struct_body(&fields[..], false);\n-                    TypeContext::may_need_drop_flag(\n-                        llty,\n-                        delay_drop_flag && dtor_needed)\n+                    llty\n                 }\n             }\n         }\n@@ -873,30 +749,27 @@ fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, st: &Struct<'tcx>,\n \n /// Obtain a representation of the discriminant sufficient to translate\n /// destructuring; this may or may not involve the actual discriminant.\n-///\n-/// This should ideally be less tightly tied to `_match`.\n pub fn trans_switch<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 r: &Repr<'tcx>,\n                                 scrutinee: ValueRef,\n                                 range_assert: bool)\n-                                -> (_match::BranchKind, Option<ValueRef>) {\n+                                -> (BranchKind, Option<ValueRef>) {\n     match *r {\n         CEnum(..) | General(..) |\n         RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n-            (_match::Switch, Some(trans_get_discr(bcx, r, scrutinee, None,\n-                                                  range_assert)))\n+            (BranchKind::Switch, Some(trans_get_discr(bcx, r, scrutinee, None, range_assert)))\n         }\n         Univariant(..) => {\n             // N.B.: Univariant means <= 1 enum variants (*not* == 1 variants).\n-            (_match::Single, None)\n+            (BranchKind::Single, None)\n         }\n     }\n }\n \n pub fn is_discr_signed<'tcx>(r: &Repr<'tcx>) -> bool {\n     match *r {\n         CEnum(ity, _, _) => ity.is_signed(),\n-        General(ity, _, _) => ity.is_signed(),\n+        General(ity, _) => ity.is_signed(),\n         Univariant(..) => false,\n         RawNullablePointer { .. } => false,\n         StructWrappedNullablePointer { .. } => false,\n@@ -913,7 +786,7 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         CEnum(ity, min, max) => {\n             load_discr(bcx, ity, scrutinee, min, max, range_assert)\n         }\n-        General(ity, ref cases, _) => {\n+        General(ity, ref cases) => {\n             let ptr = StructGEP(bcx, scrutinee, 0);\n             load_discr(bcx, ity, ptr, Disr(0), Disr(cases.len() as u64 - 1),\n                        range_assert)\n@@ -977,7 +850,7 @@ pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr, discr: Disr)\n         CEnum(ity, _, _) => {\n             C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true)\n         }\n-        General(ity, _, _) => {\n+        General(ity, _) => {\n             C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true)\n         }\n         Univariant(..) => {\n@@ -1001,21 +874,12 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true),\n                   val);\n         }\n-        General(ity, ref cases, dtor) => {\n-            if dtor_active(dtor) {\n-                let ptr = trans_field_ptr(bcx, r, MaybeSizedValue::sized(val), discr,\n-                                          cases[discr.0 as usize].fields.len() - 2);\n-                Store(bcx, C_u8(bcx.ccx(), DTOR_NEEDED), ptr);\n-            }\n+        General(ity, _) => {\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true),\n                   StructGEP(bcx, val, 0));\n         }\n-        Univariant(ref st, dtor) => {\n+        Univariant(_) => {\n             assert_eq!(discr, Disr(0));\n-            if dtor_active(dtor) {\n-                Store(bcx, C_u8(bcx.ccx(), DTOR_NEEDED),\n-                      StructGEP(bcx, val, st.fields.len() - 1));\n-            }\n         }\n         RawNullablePointer { nndiscr, nnty, ..} => {\n             if discr != nndiscr {\n@@ -1046,28 +910,6 @@ fn assert_discr_in_range(ity: IntType, min: Disr, max: Disr, discr: Disr) {\n     }\n }\n \n-/// The number of fields in a given case; for use when obtaining this\n-/// information from the type or definition is less convenient.\n-pub fn num_args(r: &Repr, discr: Disr) -> usize {\n-    match *r {\n-        CEnum(..) => 0,\n-        Univariant(ref st, dtor) => {\n-            assert_eq!(discr, Disr(0));\n-            st.fields.len() - (if dtor_active(dtor) { 1 } else { 0 })\n-        }\n-        General(_, ref cases, dtor) => {\n-            cases[discr.0 as usize].fields.len() - 1 - (if dtor_active(dtor) { 1 } else { 0 })\n-        }\n-        RawNullablePointer { nndiscr, ref nullfields, .. } => {\n-            if discr == nndiscr { 1 } else { nullfields.len() }\n-        }\n-        StructWrappedNullablePointer { ref nonnull, nndiscr,\n-                                       ref nullfields, .. } => {\n-            if discr == nndiscr { nonnull.fields.len() } else { nullfields.len() }\n-        }\n-    }\n-}\n-\n /// Access a field, at a point when the value's case is known.\n pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n                                    val: MaybeSizedValue, discr: Disr, ix: usize) -> ValueRef {\n@@ -1087,11 +929,11 @@ pub fn trans_field_ptr_builder<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         CEnum(..) => {\n             bug!(\"element access in C-like enum\")\n         }\n-        Univariant(ref st, _dtor) => {\n+        Univariant(ref st) => {\n             assert_eq!(discr, Disr(0));\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n-        General(_, ref cases, _) => {\n+        General(_, ref cases) => {\n             struct_field_ptr(bcx, &cases[discr.0 as usize], val, ix + 1, true)\n         }\n         RawNullablePointer { nndiscr, ref nullfields, .. } |\n@@ -1218,108 +1060,6 @@ fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     bcx.pointercast(byte_ptr, ll_fty.ptr_to())\n }\n \n-pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                    r: &Repr<'tcx>,\n-                                    value: ValueRef,\n-                                    mut f: F)\n-                                    -> Block<'blk, 'tcx> where\n-    F: FnMut(Block<'blk, 'tcx>, &Struct<'tcx>, ValueRef) -> Block<'blk, 'tcx>,\n-{\n-    let fcx = bcx.fcx;\n-    match *r {\n-        Univariant(ref st, _) => {\n-            f(bcx, st, value)\n-        }\n-        General(ity, ref cases, _) => {\n-            let ccx = bcx.ccx();\n-\n-            // See the comments in trans/base.rs for more information (inside\n-            // iter_structural_ty), but the gist here is that if the enum's\n-            // discriminant is *not* in the range that we're expecting (in which\n-            // case we'll take the fall-through branch on the switch\n-            // instruction) then we can't just optimize this to an Unreachable\n-            // block.\n-            //\n-            // Currently we still have filling drop, so this means that the drop\n-            // glue for enums may be called when the enum has been paved over\n-            // with the \"I've been dropped\" value. In this case the default\n-            // branch of the switch instruction will actually be taken at\n-            // runtime, so the basic block isn't actually unreachable, so we\n-            // need to make it do something with defined behavior. In this case\n-            // we just return early from the function.\n-            //\n-            // Note that this is also why the `trans_get_discr` below has\n-            // `false` to indicate that loading the discriminant should\n-            // not have a range assert.\n-            let ret_void_cx = fcx.new_temp_block(\"enum-variant-iter-ret-void\");\n-            RetVoid(ret_void_cx, DebugLoc::None);\n-\n-            let discr_val = trans_get_discr(bcx, r, value, None, false);\n-            let llswitch = Switch(bcx, discr_val, ret_void_cx.llbb, cases.len());\n-            let bcx_next = fcx.new_temp_block(\"enum-variant-iter-next\");\n-\n-            for (discr, case) in cases.iter().enumerate() {\n-                let mut variant_cx = fcx.new_temp_block(\n-                    &format!(\"enum-variant-iter-{}\", &discr.to_string())\n-                );\n-                let rhs_val = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n-                AddCase(llswitch, rhs_val, variant_cx.llbb);\n-\n-                let fields = case.fields.iter().map(|&ty|\n-                    type_of::type_of(bcx.ccx(), ty)).collect::<Vec<_>>();\n-                let real_ty = Type::struct_(ccx, &fields[..], case.packed);\n-                let variant_value = PointerCast(variant_cx, value, real_ty.ptr_to());\n-\n-                variant_cx = f(variant_cx, case, variant_value);\n-                Br(variant_cx, bcx_next.llbb, DebugLoc::None);\n-            }\n-\n-            bcx_next\n-        }\n-        _ => bug!()\n-    }\n-}\n-\n-/// Access the struct drop flag, if present.\n-pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                       r: &Repr<'tcx>,\n-                                       val: ValueRef)\n-                                       -> datum::DatumBlock<'blk, 'tcx, datum::Expr>\n-{\n-    let tcx = bcx.tcx();\n-    let ptr_ty = bcx.tcx().mk_imm_ptr(tcx.dtor_type());\n-    match *r {\n-        Univariant(ref st, dtor) if dtor_active(dtor) => {\n-            let flag_ptr = StructGEP(bcx, val, st.fields.len() - 1);\n-            datum::immediate_rvalue_bcx(bcx, flag_ptr, ptr_ty).to_expr_datumblock()\n-        }\n-        General(_, _, dtor) if dtor_active(dtor) => {\n-            let fcx = bcx.fcx;\n-            let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n-            let scratch = unpack_datum!(bcx, datum::lvalue_scratch_datum(\n-                bcx, tcx.dtor_type(), \"drop_flag\",\n-                InitAlloca::Uninit(\"drop flag itself has no dtor\"),\n-                cleanup::CustomScope(custom_cleanup_scope), |bcx, _| {\n-                    debug!(\"no-op populate call for trans_drop_flag_ptr on dtor_type={:?}\",\n-                           tcx.dtor_type());\n-                    bcx\n-                }\n-            ));\n-            bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {\n-                let ptr = struct_field_ptr(&variant_cx.build(), st,\n-                                           MaybeSizedValue::sized(value),\n-                                           (st.fields.len() - 1), false);\n-                datum::Datum::new(ptr, ptr_ty, datum::Lvalue::new(\"adt::trans_drop_flag_ptr\"))\n-                    .store_to(variant_cx, scratch.val)\n-            });\n-            let expr_datum = scratch.to_expr_datum();\n-            fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n-            datum::DatumBlock::new(bcx, expr_datum)\n-        }\n-        _ => bug!(\"tried to get drop flag of non-droppable type\")\n-    }\n-}\n-\n /// Construct a constant value, suitable for initializing a\n /// GlobalVariable, given a case and constant values for its fields.\n /// Note that this may have a different LLVM type (and different\n@@ -1347,7 +1087,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             assert_discr_in_range(ity, min, max, discr);\n             C_integral(ll_inttype(ccx, ity), discr.0, true)\n         }\n-        General(ity, ref cases, _) => {\n+        General(ity, ref cases) => {\n             let case = &cases[discr.0 as usize];\n             let (max_sz, _) = union_size_and_align(&cases[..]);\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr.0 as u64, true);\n@@ -1357,7 +1097,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             contents.extend_from_slice(&[padding(ccx, max_sz - case.size)]);\n             C_struct(ccx, &contents[..], false)\n         }\n-        Univariant(ref st, _dro) => {\n+        Univariant(ref st) => {\n             assert_eq!(discr, Disr(0));\n             let contents = build_const_struct(ccx, st, vals);\n             C_struct(ccx, &contents[..], st.packed)\n@@ -1458,28 +1198,6 @@ fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n #[inline]\n fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }\n \n-/// Get the discriminant of a constant value.\n-pub fn const_get_discrim(r: &Repr, val: ValueRef) -> Disr {\n-    match *r {\n-        CEnum(ity, _, _) => {\n-            match ity {\n-                attr::SignedInt(..) => Disr(const_to_int(val) as u64),\n-                attr::UnsignedInt(..) => Disr(const_to_uint(val)),\n-            }\n-        }\n-        General(ity, _, _) => {\n-            match ity {\n-                attr::SignedInt(..) => Disr(const_to_int(const_get_elt(val, &[0])) as u64),\n-                attr::UnsignedInt(..) => Disr(const_to_uint(const_get_elt(val, &[0])))\n-            }\n-        }\n-        Univariant(..) => Disr(0),\n-        RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n-            bug!(\"const discrim access of non c-like enum\")\n-        }\n-    }\n-}\n-\n /// Extract a field of a constant value, as appropriate for its\n /// representation.\n ///"}, {"sha": "308118b1fbc6cda9e718c08eedee0099e269c0f3", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -14,28 +14,29 @@ use llvm::{self, ValueRef};\n use base;\n use build::*;\n use common::*;\n-use datum::{Datum, Lvalue};\n use type_of;\n use type_::Type;\n \n-use rustc::hir as ast;\n+use rustc::hir;\n+use rustc::ty::Ty;\n+\n use std::ffi::CString;\n use syntax::ast::AsmDialect;\n use libc::{c_uint, c_char};\n \n // Take an inline assembly expression and splat it out via LLVM\n pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    ia: &ast::InlineAsm,\n-                                    outputs: Vec<Datum<'tcx, Lvalue>>,\n+                                    ia: &hir::InlineAsm,\n+                                    outputs: Vec<(ValueRef, Ty<'tcx>)>,\n                                     mut inputs: Vec<ValueRef>) {\n     let mut ext_constraints = vec![];\n     let mut output_types = vec![];\n \n     // Prepare the output operands\n     let mut indirect_outputs = vec![];\n-    for (i, (out, out_datum)) in ia.outputs.iter().zip(&outputs).enumerate() {\n+    for (i, (out, &(val, ty))) in ia.outputs.iter().zip(&outputs).enumerate() {\n         let val = if out.is_rw || out.is_indirect {\n-            Some(base::load_ty(bcx, out_datum.val, out_datum.ty))\n+            Some(base::load_ty(bcx, val, ty))\n         } else {\n             None\n         };\n@@ -46,7 +47,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         if out.is_indirect {\n             indirect_outputs.push(val.unwrap());\n         } else {\n-            output_types.push(type_of::type_of(bcx.ccx(), out_datum.ty));\n+            output_types.push(type_of::type_of(bcx.ccx(), ty));\n         }\n     }\n     if !indirect_outputs.is_empty() {\n@@ -100,9 +101,9 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Again, based on how many outputs we have\n     let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n-    for (i, (_, datum)) in outputs.enumerate() {\n+    for (i, (_, &(val, _))) in outputs.enumerate() {\n         let v = if num_outputs == 1 { r } else { ExtractValue(bcx, r, i) };\n-        Store(bcx, v, datum.val);\n+        Store(bcx, v, val);\n     }\n \n     // Store expn_id in a metadata node so we can map LLVM errors"}, {"sha": "165884c8f55a2a9eb4605c9dd2356e7c4444700b", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 81, "deletions": 969, "changes": 1050, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -33,12 +33,10 @@ use super::ModuleTranslation;\n use assert_module_sources;\n use back::link;\n use back::linker::LinkerInfo;\n-use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n+use llvm::{Linkage, ValueRef, Vector, get_param};\n use llvm;\n-use rustc::cfg;\n use rustc::hir::def_id::DefId;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n-use rustc::hir::pat_util::simple_name;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -47,36 +45,27 @@ use rustc::dep_graph::{DepNode, WorkProduct};\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n use rustc::mir::mir_map::MirMap;\n-use rustc_data_structures::graph::OUTGOING;\n+use session::config::{self, NoDebugInfo};\n use rustc_incremental::IncrementalHashesMap;\n-use session::config::{self, NoDebugInfo, FullDebugInfo};\n use session::Session;\n-use _match;\n use abi::{self, Abi, FnType};\n use adt;\n use attributes;\n use build::*;\n use builder::{Builder, noname};\n-use callee::{Callee, CallArgs, ArgExprs, ArgVals};\n-use cleanup::{self, CleanupMethods, DropHint};\n-use closure;\n-use common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_uint, C_integral};\n+use callee::{Callee};\n+use common::{Block, C_bool, C_bytes_in_context, C_i32, C_uint};\n use collector::{self, TransItemCollectionMode};\n use common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n-use common::{CrateContext, DropFlagHintsMap, Field, FunctionContext};\n-use common::{Result, NodeIdAndSpan, VariantInfo};\n-use common::{node_id_type, fulfill_obligation};\n-use common::{type_is_immediate, type_is_zero_size, val_ty};\n+use common::{CrateContext, FunctionContext};\n+use common::{Result};\n+use common::{fulfill_obligation};\n+use common::{type_is_zero_size, val_ty};\n use common;\n use consts;\n use context::{SharedCrateContext, CrateContextList};\n-use controlflow;\n-use datum;\n-use debuginfo::{self, DebugLoc, ToDebugLoc};\n+use debuginfo::{self, DebugLoc};\n use declare;\n-use expr;\n-use glue;\n-use inline;\n use machine;\n use machine::{llalign_of_min, llsize_of};\n use meth;\n@@ -86,14 +75,12 @@ use partitioning::{self, PartitioningStrategy, CodegenUnit};\n use symbol_map::SymbolMap;\n use symbol_names_test;\n use trans_item::TransItem;\n-use tvec;\n use type_::Type;\n use type_of;\n use value::Value;\n use Disr;\n-use util::common::indenter;\n use util::sha2::Sha256;\n-use util::nodemap::{NodeMap, NodeSet, FnvHashSet};\n+use util::nodemap::{NodeSet, FnvHashSet};\n \n use arena::TypedArena;\n use libc::c_uint;\n@@ -104,12 +91,10 @@ use std::collections::HashMap;\n use std::ptr;\n use std::rc::Rc;\n use std::str;\n-use std::{i8, i16, i32, i64};\n+use std::i32;\n use syntax_pos::{Span, DUMMY_SP};\n-use syntax::parse::token::InternedString;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n-use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir;\n use syntax::ast;\n \n@@ -192,8 +177,12 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     }\n }\n \n-pub fn kind_for_closure(ccx: &CrateContext, closure_id: DefId) -> ty::ClosureKind {\n-    *ccx.tcx().tables.borrow().closure_kinds.get(&closure_id).unwrap()\n+pub fn get_meta(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n+    StructGEP(bcx, fat_ptr, abi::FAT_PTR_EXTRA)\n+}\n+\n+pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n+    StructGEP(bcx, fat_ptr, abi::FAT_PTR_ADDR)\n }\n \n fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, info_ty: Ty<'tcx>, it: LangItem) -> DefId {\n@@ -220,7 +209,7 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Allocate space:\n     let def_id = require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem);\n     let r = Callee::def(bcx.ccx(), def_id, Substs::empty(bcx.tcx()))\n-        .call(bcx, debug_loc, ArgVals(&[size, align]), None);\n+        .call(bcx, debug_loc, &[size, align], None);\n \n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n@@ -395,154 +384,6 @@ pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     SExt(bcx, ICmp(bcx, cmp, lhs, rhs, debug_loc), ret_ty)\n }\n \n-// Iterates through the elements of a structural type.\n-pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n-                                         av: ValueRef,\n-                                         t: Ty<'tcx>,\n-                                         mut f: F)\n-                                         -> Block<'blk, 'tcx>\n-    where F: FnMut(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>\n-{\n-    let _icx = push_ctxt(\"iter_structural_ty\");\n-\n-    fn iter_variant<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n-                                   repr: &adt::Repr<'tcx>,\n-                                   av: adt::MaybeSizedValue,\n-                                   variant: ty::VariantDef<'tcx>,\n-                                   substs: &Substs<'tcx>,\n-                                   f: &mut F)\n-                                   -> Block<'blk, 'tcx>\n-        where F: FnMut(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>\n-    {\n-        let _icx = push_ctxt(\"iter_variant\");\n-        let tcx = cx.tcx();\n-        let mut cx = cx;\n-\n-        for (i, field) in variant.fields.iter().enumerate() {\n-            let arg = monomorphize::field_ty(tcx, substs, field);\n-            cx = f(cx,\n-                   adt::trans_field_ptr(cx, repr, av, Disr::from(variant.disr_val), i),\n-                   arg);\n-        }\n-        return cx;\n-    }\n-\n-    let value = if common::type_is_sized(cx.tcx(), t) {\n-        adt::MaybeSizedValue::sized(av)\n-    } else {\n-        let data = Load(cx, expr::get_dataptr(cx, av));\n-        let info = Load(cx, expr::get_meta(cx, av));\n-        adt::MaybeSizedValue::unsized_(data, info)\n-    };\n-\n-    let mut cx = cx;\n-    match t.sty {\n-        ty::TyStruct(..) => {\n-            let repr = adt::represent_type(cx.ccx(), t);\n-            let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n-            for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr::from(discr), i);\n-\n-                let val = if common::type_is_sized(cx.tcx(), field_ty) {\n-                    llfld_a\n-                } else {\n-                    let scratch = datum::rvalue_scratch_datum(cx, field_ty, \"__fat_ptr_iter\");\n-                    Store(cx, llfld_a, expr::get_dataptr(cx, scratch.val));\n-                    Store(cx, value.meta, expr::get_meta(cx, scratch.val));\n-                    scratch.val\n-                };\n-                cx = f(cx, val, field_ty);\n-            }\n-        }\n-        ty::TyClosure(_, ref substs) => {\n-            let repr = adt::represent_type(cx.ccx(), t);\n-            for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n-                let llupvar = adt::trans_field_ptr(cx, &repr, value, Disr(0), i);\n-                cx = f(cx, llupvar, upvar_ty);\n-            }\n-        }\n-        ty::TyArray(_, n) => {\n-            let (base, len) = tvec::get_fixed_base_and_len(cx, value.value, n);\n-            let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n-        }\n-        ty::TySlice(_) | ty::TyStr => {\n-            let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::iter_vec_raw(cx, value.value, unit_ty, value.meta, f);\n-        }\n-        ty::TyTuple(ref args) => {\n-            let repr = adt::represent_type(cx.ccx(), t);\n-            for (i, arg) in args.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr(0), i);\n-                cx = f(cx, llfld_a, *arg);\n-            }\n-        }\n-        ty::TyEnum(en, substs) => {\n-            let fcx = cx.fcx;\n-            let ccx = fcx.ccx;\n-\n-            let repr = adt::represent_type(ccx, t);\n-            let n_variants = en.variants.len();\n-\n-            // NB: we must hit the discriminant first so that structural\n-            // comparison know not to proceed when the discriminants differ.\n-\n-            match adt::trans_switch(cx, &repr, av, false) {\n-                (_match::Single, None) => {\n-                    if n_variants != 0 {\n-                        assert!(n_variants == 1);\n-                        cx = iter_variant(cx, &repr, adt::MaybeSizedValue::sized(av),\n-                                          &en.variants[0], substs, &mut f);\n-                    }\n-                }\n-                (_match::Switch, Some(lldiscrim_a)) => {\n-                    cx = f(cx, lldiscrim_a, cx.tcx().types.isize);\n-\n-                    // Create a fall-through basic block for the \"else\" case of\n-                    // the switch instruction we're about to generate. Note that\n-                    // we do **not** use an Unreachable instruction here, even\n-                    // though most of the time this basic block will never be hit.\n-                    //\n-                    // When an enum is dropped it's contents are currently\n-                    // overwritten to DTOR_DONE, which means the discriminant\n-                    // could have changed value to something not within the actual\n-                    // range of the discriminant. Currently this function is only\n-                    // used for drop glue so in this case we just return quickly\n-                    // from the outer function, and any other use case will only\n-                    // call this for an already-valid enum in which case the `ret\n-                    // void` will never be hit.\n-                    let ret_void_cx = fcx.new_temp_block(\"enum-iter-ret-void\");\n-                    RetVoid(ret_void_cx, DebugLoc::None);\n-                    let llswitch = Switch(cx, lldiscrim_a, ret_void_cx.llbb, n_variants);\n-                    let next_cx = fcx.new_temp_block(\"enum-iter-next\");\n-\n-                    for variant in &en.variants {\n-                        let variant_cx = fcx.new_temp_block(&format!(\"enum-iter-variant-{}\",\n-                                                                     &variant.disr_val\n-                                                                             .to_string()));\n-                        let case_val = adt::trans_case(cx, &repr, Disr::from(variant.disr_val));\n-                        AddCase(llswitch, case_val, variant_cx.llbb);\n-                        let variant_cx = iter_variant(variant_cx,\n-                                                      &repr,\n-                                                      value,\n-                                                      variant,\n-                                                      substs,\n-                                                      &mut f);\n-                        Br(variant_cx, next_cx.llbb, DebugLoc::None);\n-                    }\n-                    cx = next_cx;\n-                }\n-                _ => ccx.sess().unimpl(\"value from adt::trans_switch in iter_structural_ty\"),\n-            }\n-        }\n-        _ => {\n-            cx.sess().unimpl(&format!(\"type in iter_structural_ty: {}\", t))\n-        }\n-    }\n-    return cx;\n-}\n-\n-\n /// Retrieve the information we are losing (making dynamic) in an unsizing\n /// adjustment.\n ///\n@@ -634,12 +475,12 @@ pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             let src_repr = adt::represent_type(bcx.ccx(), src_ty);\n             let src_fields = match &*src_repr {\n-                &adt::Repr::Univariant(ref s, _) => &s.fields,\n+                &adt::Repr::Univariant(ref s) => &s.fields,\n                 _ => bug!(\"struct has non-univariant repr\"),\n             };\n             let dst_repr = adt::represent_type(bcx.ccx(), dst_ty);\n             let dst_fields = match &*dst_repr {\n-                &adt::Repr::Univariant(ref s, _) => &s.fields,\n+                &adt::Repr::Univariant(ref s) => &s.fields,\n                 _ => bug!(\"struct has non-univariant repr\"),\n             };\n \n@@ -733,101 +574,6 @@ fn cast_shift_rhs<F, G>(op: hir::BinOp_,\n     }\n }\n \n-pub fn llty_and_min_for_signed_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                                              val_t: Ty<'tcx>)\n-                                              -> (Type, u64) {\n-    match val_t.sty {\n-        ty::TyInt(t) => {\n-            let llty = Type::int_from_ty(cx.ccx(), t);\n-            let min = match t {\n-                ast::IntTy::Is if llty == Type::i32(cx.ccx()) => i32::MIN as u64,\n-                ast::IntTy::Is => i64::MIN as u64,\n-                ast::IntTy::I8 => i8::MIN as u64,\n-                ast::IntTy::I16 => i16::MIN as u64,\n-                ast::IntTy::I32 => i32::MIN as u64,\n-                ast::IntTy::I64 => i64::MIN as u64,\n-            };\n-            (llty, min)\n-        }\n-        _ => bug!(),\n-    }\n-}\n-\n-pub fn fail_if_zero_or_overflows<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                                             call_info: NodeIdAndSpan,\n-                                             divrem: hir::BinOp,\n-                                             lhs: ValueRef,\n-                                             rhs: ValueRef,\n-                                             rhs_t: Ty<'tcx>)\n-                                             -> Block<'blk, 'tcx> {\n-    use rustc_const_math::{ConstMathErr, Op};\n-\n-    let (zero_err, overflow_err) = if divrem.node == hir::BiDiv {\n-        (ConstMathErr::DivisionByZero, ConstMathErr::Overflow(Op::Div))\n-    } else {\n-        (ConstMathErr::RemainderByZero, ConstMathErr::Overflow(Op::Rem))\n-    };\n-    let debug_loc = call_info.debug_loc();\n-\n-    let (is_zero, is_signed) = match rhs_t.sty {\n-        ty::TyInt(t) => {\n-            let zero = C_integral(Type::int_from_ty(cx.ccx(), t), 0, false);\n-            (ICmp(cx, llvm::IntEQ, rhs, zero, debug_loc), true)\n-        }\n-        ty::TyUint(t) => {\n-            let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0, false);\n-            (ICmp(cx, llvm::IntEQ, rhs, zero, debug_loc), false)\n-        }\n-        ty::TyStruct(def, _) if def.is_simd() => {\n-            let mut res = C_bool(cx.ccx(), false);\n-            for i in 0..rhs_t.simd_size(cx.tcx()) {\n-                res = Or(cx,\n-                         res,\n-                         IsNull(cx, ExtractElement(cx, rhs, C_int(cx.ccx(), i as i64))),\n-                         debug_loc);\n-            }\n-            (res, false)\n-        }\n-        _ => {\n-            bug!(\"fail-if-zero on unexpected type: {}\", rhs_t);\n-        }\n-    };\n-    let bcx = with_cond(cx, is_zero, |bcx| {\n-        controlflow::trans_fail(bcx, call_info, InternedString::new(zero_err.description()))\n-    });\n-\n-    // To quote LLVM's documentation for the sdiv instruction:\n-    //\n-    //      Division by zero leads to undefined behavior. Overflow also leads\n-    //      to undefined behavior; this is a rare case, but can occur, for\n-    //      example, by doing a 32-bit division of -2147483648 by -1.\n-    //\n-    // In order to avoid undefined behavior, we perform runtime checks for\n-    // signed division/remainder which would trigger overflow. For unsigned\n-    // integers, no action beyond checking for zero need be taken.\n-    if is_signed {\n-        let (llty, min) = llty_and_min_for_signed_ty(cx, rhs_t);\n-        let minus_one = ICmp(bcx,\n-                             llvm::IntEQ,\n-                             rhs,\n-                             C_integral(llty, !0, false),\n-                             debug_loc);\n-        with_cond(bcx, minus_one, |bcx| {\n-            let is_min = ICmp(bcx,\n-                              llvm::IntEQ,\n-                              lhs,\n-                              C_integral(llty, min, true),\n-                              debug_loc);\n-            with_cond(bcx, is_min, |bcx| {\n-                controlflow::trans_fail(bcx, call_info,\n-                                        InternedString::new(overflow_err.description()))\n-            })\n-        })\n-    } else {\n-        bcx\n-    }\n-}\n-\n pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           llfn: ValueRef,\n                           llargs: &[ValueRef],\n@@ -838,21 +584,12 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return (C_null(Type::i8(bcx.ccx())), bcx);\n     }\n \n-    match bcx.opt_node_id {\n-        None => {\n-            debug!(\"invoke at ???\");\n-        }\n-        Some(id) => {\n-            debug!(\"invoke at {}\", bcx.tcx().map.node_to_string(id));\n-        }\n-    }\n-\n     if need_invoke(bcx) {\n         debug!(\"invoking {:?} at {:?}\", Value(llfn), bcx.llbb);\n         for &llarg in llargs {\n             debug!(\"arg: {:?}\", Value(llarg));\n         }\n-        let normal_bcx = bcx.fcx.new_temp_block(\"normal-return\");\n+        let normal_bcx = bcx.fcx.new_block(\"normal-return\");\n         let landing_pad = bcx.fcx.get_landing_pad();\n \n         let llresult = Invoke(bcx,\n@@ -894,14 +631,6 @@ pub fn need_invoke(bcx: Block) -> bool {\n     }\n }\n \n-pub fn load_if_immediate<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, t: Ty<'tcx>) -> ValueRef {\n-    let _icx = push_ctxt(\"load_if_immediate\");\n-    if type_is_immediate(cx.ccx(), t) {\n-        return load_ty(cx, v, t);\n-    }\n-    return v;\n-}\n-\n /// Helper for loading values from memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values. Also handles various special cases where the type\n /// gives us better information about what we are loading.\n@@ -957,10 +686,10 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n     if common::type_is_fat_ptr(cx.tcx(), t) {\n         Store(cx,\n               ExtractValue(cx, v, abi::FAT_PTR_ADDR),\n-              expr::get_dataptr(cx, dst));\n+              get_dataptr(cx, dst));\n         Store(cx,\n               ExtractValue(cx, v, abi::FAT_PTR_EXTRA),\n-              expr::get_meta(cx, dst));\n+              get_meta(cx, dst));\n     } else {\n         Store(cx, from_immediate(cx, v), dst);\n     }\n@@ -972,17 +701,17 @@ pub fn store_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                  dst: ValueRef,\n                                  _ty: Ty<'tcx>) {\n     // FIXME: emit metadata\n-    Store(cx, data, expr::get_dataptr(cx, dst));\n-    Store(cx, extra, expr::get_meta(cx, dst));\n+    Store(cx, data, get_dataptr(cx, dst));\n+    Store(cx, extra, get_meta(cx, dst));\n }\n \n pub fn load_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                 src: ValueRef,\n                                 _ty: Ty<'tcx>)\n                                 -> (ValueRef, ValueRef) {\n     // FIXME: emit metadata\n-    (Load(cx, expr::get_dataptr(cx, src)),\n-     Load(cx, expr::get_meta(cx, src)))\n+    (Load(cx, get_dataptr(cx, src)),\n+     Load(cx, get_meta(cx, src)))\n }\n \n pub fn from_immediate(bcx: Block, val: ValueRef) -> ValueRef {\n@@ -1001,19 +730,6 @@ pub fn to_immediate(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n     }\n }\n \n-pub fn init_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, local: &hir::Local) -> Block<'blk, 'tcx> {\n-    debug!(\"init_local(bcx={}, local.id={})\", bcx.to_str(), local.id);\n-    let _indenter = indenter();\n-    let _icx = push_ctxt(\"init_local\");\n-    _match::store_local(bcx, local)\n-}\n-\n-pub fn raw_block<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n-                             llbb: BasicBlockRef)\n-                             -> Block<'blk, 'tcx> {\n-    common::BlockS::new(llbb, None, fcx)\n-}\n-\n pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>, val: ValueRef, f: F) -> Block<'blk, 'tcx>\n     where F: FnOnce(Block<'blk, 'tcx>) -> Block<'blk, 'tcx>\n {\n@@ -1024,8 +740,8 @@ pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>, val: ValueRef, f: F) ->\n     }\n \n     let fcx = bcx.fcx;\n-    let next_cx = fcx.new_temp_block(\"next\");\n-    let cond_cx = fcx.new_temp_block(\"cond\");\n+    let next_cx = fcx.new_block(\"next\");\n+    let cond_cx = fcx.new_block(\"cond\");\n     CondBr(bcx, val, cond_cx.llbb, next_cx.llbb, DebugLoc::None);\n     let after_cx = f(cond_cx);\n     if !after_cx.terminated.get() {\n@@ -1099,7 +815,7 @@ pub fn trans_unwind_resume(bcx: Block, lpval: ValueRef) {\n     } else {\n         let exc_ptr = ExtractValue(bcx, lpval, 0);\n         bcx.fcx.eh_unwind_resume()\n-            .call(bcx, DebugLoc::None, ArgVals(&[exc_ptr]), None);\n+            .call(bcx, DebugLoc::None, &[exc_ptr], None);\n     }\n }\n \n@@ -1142,15 +858,6 @@ pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, dst: ValueRef, src: ValueRe\n     }\n }\n \n-pub fn drop_done_fill_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n-    if cx.unreachable.get() {\n-        return;\n-    }\n-    let _icx = push_ctxt(\"drop_done_fill_mem\");\n-    let bcx = cx;\n-    memfill(&B(bcx), llptr, t, adt::DTOR_DONE);\n-}\n-\n pub fn init_zero_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n     if cx.unreachable.get() {\n         return;\n@@ -1190,82 +897,11 @@ pub fn call_memset<'bcx, 'tcx>(b: &Builder<'bcx, 'tcx>,\n     b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None);\n }\n \n-\n-/// In general, when we create an scratch value in an alloca, the\n-/// creator may not know if the block (that initializes the scratch\n-/// with the desired value) actually dominates the cleanup associated\n-/// with the scratch value.\n-///\n-/// To deal with this, when we do an alloca (at the *start* of whole\n-/// function body), we optionally can also set the associated\n-/// dropped-flag state of the alloca to \"dropped.\"\n-#[derive(Copy, Clone, Debug)]\n-pub enum InitAlloca {\n-    /// Indicates that the state should have its associated drop flag\n-    /// set to \"dropped\" at the point of allocation.\n-    Dropped,\n-    /// Indicates the value of the associated drop flag is irrelevant.\n-    /// The embedded string literal is a programmer provided argument\n-    /// for why. This is a safeguard forcing compiler devs to\n-    /// document; it might be a good idea to also emit this as a\n-    /// comment with the alloca itself when emitting LLVM output.ll.\n-    Uninit(&'static str),\n-}\n-\n-\n pub fn alloc_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                            t: Ty<'tcx>,\n+                            ty: Ty<'tcx>,\n                             name: &str) -> ValueRef {\n-    // pnkfelix: I do not know why alloc_ty meets the assumptions for\n-    // passing Uninit, but it was never needed (even back when we had\n-    // the original boolean `zero` flag on `lvalue_scratch_datum`).\n-    alloc_ty_init(bcx, t, InitAlloca::Uninit(\"all alloc_ty are uninit\"), name)\n-}\n-\n-/// This variant of `fn alloc_ty` does not necessarily assume that the\n-/// alloca should be created with no initial value. Instead the caller\n-/// controls that assumption via the `init` flag.\n-///\n-/// Note that if the alloca *is* initialized via `init`, then we will\n-/// also inject an `llvm.lifetime.start` before that initialization\n-/// occurs, and thus callers should not call_lifetime_start\n-/// themselves.  But if `init` says \"uninitialized\", then callers are\n-/// in charge of choosing where to call_lifetime_start and\n-/// subsequently populate the alloca.\n-///\n-/// (See related discussion on PR #30823.)\n-pub fn alloc_ty_init<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             t: Ty<'tcx>,\n-                             init: InitAlloca,\n-                             name: &str) -> ValueRef {\n-    let _icx = push_ctxt(\"alloc_ty\");\n-    let ccx = bcx.ccx();\n-    let ty = type_of::type_of(ccx, t);\n-    assert!(!t.has_param_types());\n-    match init {\n-        InitAlloca::Dropped => alloca_dropped(bcx, t, name),\n-        InitAlloca::Uninit(_) => alloca(bcx, ty, name),\n-    }\n-}\n-\n-pub fn alloca_dropped<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ty: Ty<'tcx>, name: &str) -> ValueRef {\n-    let _icx = push_ctxt(\"alloca_dropped\");\n-    let llty = type_of::type_of(cx.ccx(), ty);\n-    if cx.unreachable.get() {\n-        unsafe { return llvm::LLVMGetUndef(llty.ptr_to().to_ref()); }\n-    }\n-    let p = alloca(cx, llty, name);\n-    let b = cx.fcx.ccx.builder();\n-    b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n-\n-    // This is just like `call_lifetime_start` (but latter expects a\n-    // Block, which we do not have for `alloca_insert_pt`).\n-    core_lifetime_emit(cx.ccx(), p, Lifetime::Start, |ccx, size, lifetime_start| {\n-        let ptr = b.pointercast(p, Type::i8p(ccx));\n-        b.call(lifetime_start, &[C_u64(ccx, size), ptr], None);\n-    });\n-    memfill(&b, p, ty, adt::DTOR_DONE);\n-    p\n+    assert!(!ty.has_param_types());\n+    alloca(bcx, type_of::type_of(bcx.ccx(), ty), name)\n }\n \n pub fn alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n@@ -1279,208 +915,70 @@ pub fn alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n     Alloca(cx, ty, name)\n }\n \n-pub fn set_value_name(val: ValueRef, name: &str) {\n-    unsafe {\n-        let name = CString::new(name).unwrap();\n-        llvm::LLVMSetValueName(val, name.as_ptr());\n-    }\n-}\n-\n-struct FindNestedReturn {\n-    found: bool,\n-}\n-\n-impl FindNestedReturn {\n-    fn new() -> FindNestedReturn {\n-        FindNestedReturn {\n-            found: false,\n-        }\n-    }\n-}\n-\n-impl<'v> Visitor<'v> for FindNestedReturn {\n-    fn visit_expr(&mut self, e: &hir::Expr) {\n-        match e.node {\n-            hir::ExprRet(..) => {\n-                self.found = true;\n-            }\n-            _ => intravisit::walk_expr(self, e),\n-        }\n-    }\n-}\n-\n-fn build_cfg<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       id: ast::NodeId)\n-                       -> (ast::NodeId, Option<cfg::CFG>) {\n-    let blk = match tcx.map.find(id) {\n-        Some(hir_map::NodeItem(i)) => {\n-            match i.node {\n-                hir::ItemFn(_, _, _, _, _, ref blk) => {\n-                    blk\n-                }\n-                _ => bug!(\"unexpected item variant in has_nested_returns\"),\n-            }\n-        }\n-        Some(hir_map::NodeTraitItem(trait_item)) => {\n-            match trait_item.node {\n-                hir::MethodTraitItem(_, Some(ref body)) => body,\n-                _ => {\n-                    bug!(\"unexpected variant: trait item other than a provided method in \\\n-                          has_nested_returns\")\n-                }\n-            }\n-        }\n-        Some(hir_map::NodeImplItem(impl_item)) => {\n-            match impl_item.node {\n-                hir::ImplItemKind::Method(_, ref body) => body,\n-                _ => {\n-                    bug!(\"unexpected variant: non-method impl item in has_nested_returns\")\n-                }\n-            }\n-        }\n-        Some(hir_map::NodeExpr(e)) => {\n-            match e.node {\n-                hir::ExprClosure(_, _, ref blk, _) => blk,\n-                _ => bug!(\"unexpected expr variant in has_nested_returns\"),\n-            }\n-        }\n-        Some(hir_map::NodeVariant(..)) |\n-        Some(hir_map::NodeStructCtor(..)) => return (ast::DUMMY_NODE_ID, None),\n-\n-        // glue, shims, etc\n-        None if id == ast::DUMMY_NODE_ID => return (ast::DUMMY_NODE_ID, None),\n-\n-        _ => bug!(\"unexpected variant in has_nested_returns: {}\",\n-                  tcx.node_path_str(id)),\n-    };\n-\n-    (blk.id, Some(cfg::CFG::new(tcx, blk)))\n-}\n-\n-// Checks for the presence of \"nested returns\" in a function.\n-// Nested returns are when the inner expression of a return expression\n-// (the 'expr' in 'return expr') contains a return expression. Only cases\n-// where the outer return is actually reachable are considered. Implicit\n-// returns from the end of blocks are considered as well.\n-//\n-// This check is needed to handle the case where the inner expression is\n-// part of a larger expression that may have already partially-filled the\n-// return slot alloca. This can cause errors related to clean-up due to\n-// the clobbering of the existing value in the return slot.\n-fn has_nested_returns(tcx: TyCtxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bool {\n-    for index in cfg.graph.depth_traverse(cfg.entry, OUTGOING) {\n-        let n = cfg.graph.node_data(index);\n-        match tcx.map.find(n.id()) {\n-            Some(hir_map::NodeExpr(ex)) => {\n-                if let hir::ExprRet(Some(ref ret_expr)) = ex.node {\n-                    let mut visitor = FindNestedReturn::new();\n-                    intravisit::walk_expr(&mut visitor, &ret_expr);\n-                    if visitor.found {\n-                        return true;\n-                    }\n-                }\n-            }\n-            Some(hir_map::NodeBlock(blk)) if blk.id == blk_id => {\n-                let mut visitor = FindNestedReturn::new();\n-                walk_list!(&mut visitor, visit_expr, &blk.expr);\n-                if visitor.found {\n-                    return true;\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    return false;\n-}\n-\n impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     /// Create a function context for the given function.\n     /// Beware that you must call `fcx.init` or `fcx.bind_args`\n     /// before doing anything with the returned function context.\n     pub fn new(ccx: &'blk CrateContext<'blk, 'tcx>,\n                llfndecl: ValueRef,\n                fn_ty: FnType,\n-               definition: Option<(Instance<'tcx>, &ty::FnSig<'tcx>, Abi, ast::NodeId)>,\n+               definition: Option<(Instance<'tcx>, &ty::FnSig<'tcx>, Abi)>,\n                block_arena: &'blk TypedArena<common::BlockS<'blk, 'tcx>>)\n                -> FunctionContext<'blk, 'tcx> {\n-        let (param_substs, def_id, inlined_id) = match definition {\n-            Some((instance, _, _, inlined_id)) => {\n+        let (param_substs, def_id) = match definition {\n+            Some((instance, _, _)) => {\n                 common::validate_substs(instance.substs);\n-                (instance.substs, Some(instance.def), Some(inlined_id))\n+                (instance.substs, Some(instance.def))\n             }\n-            None => (Substs::empty(ccx.tcx()), None, None)\n+            None => (Substs::empty(ccx.tcx()), None)\n         };\n \n         let local_id = def_id.and_then(|id| ccx.tcx().map.as_local_node_id(id));\n \n         debug!(\"FunctionContext::new({})\",\n                definition.map_or(String::new(), |d| d.0.to_string()));\n \n-        let cfg = inlined_id.map(|id| build_cfg(ccx.tcx(), id));\n-        let nested_returns = if let Some((blk_id, Some(ref cfg))) = cfg {\n-            has_nested_returns(ccx.tcx(), cfg, blk_id)\n-        } else {\n-            false\n-        };\n-\n-        let check_attrs = |attrs: &[ast::Attribute]| {\n-            let default_to_mir = ccx.sess().opts.debugging_opts.orbit;\n-            let invert = if default_to_mir { \"rustc_no_mir\" } else { \"rustc_mir\" };\n-            (default_to_mir ^ attrs.iter().any(|item| item.check_name(invert)),\n-             attrs.iter().any(|item| item.check_name(\"no_debug\")))\n-        };\n-\n-        let (use_mir, no_debug) = if let Some(id) = local_id {\n-            check_attrs(ccx.tcx().map.attrs(id))\n+        let no_debug = if let Some(id) = local_id {\n+            ccx.tcx().map.attrs(id)\n+               .iter().any(|item| item.check_name(\"no_debug\"))\n         } else if let Some(def_id) = def_id {\n-            check_attrs(&ccx.sess().cstore.item_attrs(def_id))\n+            ccx.sess().cstore.item_attrs(def_id)\n+               .iter().any(|item| item.check_name(\"no_debug\"))\n         } else {\n-            check_attrs(&[])\n+            false\n         };\n \n-        let mir = if use_mir {\n-            def_id.and_then(|id| ccx.get_mir(id))\n-        } else {\n-            None\n-        };\n+        let mir = def_id.and_then(|id| ccx.get_mir(id));\n \n-        let debug_context = if let (false, Some(definition)) = (no_debug, definition) {\n-            let (instance, sig, abi, _) = definition;\n-            debuginfo::create_function_debug_context(ccx, instance, sig, abi, llfndecl)\n+        let debug_context = if let (false, Some((instance, sig, abi)), &Some(ref mir)) =\n+                (no_debug, definition, &mir) {\n+            debuginfo::create_function_debug_context(ccx, instance, sig, abi, llfndecl, mir)\n         } else {\n             debuginfo::empty_function_debug_context(ccx)\n         };\n \n         FunctionContext {\n-            needs_ret_allocas: nested_returns && mir.is_none(),\n             mir: mir,\n             llfn: llfndecl,\n             llretslotptr: Cell::new(None),\n             param_env: ccx.tcx().empty_parameter_environment(),\n             alloca_insert_pt: Cell::new(None),\n-            llreturn: Cell::new(None),\n             landingpad_alloca: Cell::new(None),\n-            lllocals: RefCell::new(NodeMap()),\n-            llupvars: RefCell::new(NodeMap()),\n-            lldropflag_hints: RefCell::new(DropFlagHintsMap::new()),\n             fn_ty: fn_ty,\n             param_substs: param_substs,\n-            span: inlined_id.and_then(|id| ccx.tcx().map.opt_span(id)),\n+            span: None,\n             block_arena: block_arena,\n             lpad_arena: TypedArena::new(),\n             ccx: ccx,\n             debug_context: debug_context,\n             scopes: RefCell::new(Vec::new()),\n-            cfg: cfg.and_then(|(_, cfg)| cfg)\n         }\n     }\n \n     /// Performs setup on a newly created function, creating the entry\n     /// scope block and allocating space for the return pointer.\n-    pub fn init(&'blk self, skip_retptr: bool, fn_did: Option<DefId>)\n-                -> Block<'blk, 'tcx> {\n-        let entry_bcx = self.new_temp_block(\"entry-block\");\n+    pub fn init(&'blk self, skip_retptr: bool) -> Block<'blk, 'tcx> {\n+        let entry_bcx = self.new_block(\"entry-block\");\n \n         // Use a dummy instruction as the insertion point for all allocas.\n         // This is later removed in FunctionContext::cleanup.\n@@ -1498,244 +996,26 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             // which will hold the pointer to the right alloca which has the\n             // final ret value\n             let llty = self.fn_ty.ret.memory_ty(self.ccx);\n-            let slot = if self.needs_ret_allocas {\n-                // Let's create the stack slot\n-                let slot = AllocaFcx(self, llty.ptr_to(), \"llretslotptr\");\n-\n-                // and if we're using an out pointer, then store that in our newly made slot\n-                if self.fn_ty.ret.is_indirect() {\n-                    let outptr = get_param(self.llfn, 0);\n-\n-                    let b = self.ccx.builder();\n-                    b.position_before(self.alloca_insert_pt.get().unwrap());\n-                    b.store(outptr, slot);\n-                }\n-\n-                slot\n+            // But if there are no nested returns, we skip the indirection\n+            // and have a single retslot\n+            let slot = if self.fn_ty.ret.is_indirect() {\n+                get_param(self.llfn, 0)\n             } else {\n-                // But if there are no nested returns, we skip the indirection\n-                // and have a single retslot\n-                if self.fn_ty.ret.is_indirect() {\n-                    get_param(self.llfn, 0)\n-                } else {\n-                    AllocaFcx(self, llty, \"sret_slot\")\n-                }\n+                AllocaFcx(self, llty, \"sret_slot\")\n             };\n \n             self.llretslotptr.set(Some(slot));\n         }\n \n-        // Create the drop-flag hints for every unfragmented path in the function.\n-        let tcx = self.ccx.tcx();\n-        let tables = tcx.tables.borrow();\n-        let mut hints = self.lldropflag_hints.borrow_mut();\n-        let fragment_infos = tcx.fragment_infos.borrow();\n-\n-        // Intern table for drop-flag hint datums.\n-        let mut seen = HashMap::new();\n-\n-        let fragment_infos = fn_did.and_then(|did| fragment_infos.get(&did));\n-        if let Some(fragment_infos) = fragment_infos {\n-            for &info in fragment_infos {\n-\n-                let make_datum = |id| {\n-                    let init_val = C_u8(self.ccx, adt::DTOR_NEEDED_HINT);\n-                    let llname = &format!(\"dropflag_hint_{}\", id);\n-                    debug!(\"adding hint {}\", llname);\n-                    let ty = tcx.types.u8;\n-                    let ptr = alloc_ty(entry_bcx, ty, llname);\n-                    Store(entry_bcx, init_val, ptr);\n-                    let flag = datum::Lvalue::new_dropflag_hint(\"FunctionContext::init\");\n-                    datum::Datum::new(ptr, ty, flag)\n-                };\n-\n-                let (var, datum) = match info {\n-                    ty::FragmentInfo::Moved { var, .. } |\n-                    ty::FragmentInfo::Assigned { var, .. } => {\n-                        let opt_datum = seen.get(&var).cloned().unwrap_or_else(|| {\n-                            let ty = tables.node_types[&var];\n-                            if self.type_needs_drop(ty) {\n-                                let datum = make_datum(var);\n-                                seen.insert(var, Some(datum.clone()));\n-                                Some(datum)\n-                            } else {\n-                                // No drop call needed, so we don't need a dropflag hint\n-                                None\n-                            }\n-                        });\n-                        if let Some(datum) = opt_datum {\n-                            (var, datum)\n-                        } else {\n-                            continue\n-                        }\n-                    }\n-                };\n-                match info {\n-                    ty::FragmentInfo::Moved { move_expr: expr_id, .. } => {\n-                        debug!(\"FragmentInfo::Moved insert drop hint for {}\", expr_id);\n-                        hints.insert(expr_id, DropHint::new(var, datum));\n-                    }\n-                    ty::FragmentInfo::Assigned { assignee_id: expr_id, .. } => {\n-                        debug!(\"FragmentInfo::Assigned insert drop hint for {}\", expr_id);\n-                        hints.insert(expr_id, DropHint::new(var, datum));\n-                    }\n-                }\n-            }\n-        }\n-\n         entry_bcx\n     }\n \n-    /// Creates lvalue datums for each of the incoming function arguments,\n-    /// matches all argument patterns against them to produce bindings,\n-    /// and returns the entry block (see FunctionContext::init).\n-    fn bind_args(&'blk self,\n-                 args: &[hir::Arg],\n-                 abi: Abi,\n-                 id: ast::NodeId,\n-                 closure_env: closure::ClosureEnv,\n-                 arg_scope: cleanup::CustomScopeIndex)\n-                 -> Block<'blk, 'tcx> {\n-        let _icx = push_ctxt(\"FunctionContext::bind_args\");\n-        let fn_did = self.ccx.tcx().map.local_def_id(id);\n-        let mut bcx = self.init(false, Some(fn_did));\n-        let arg_scope_id = cleanup::CustomScope(arg_scope);\n-\n-        let mut idx = 0;\n-        let mut llarg_idx = self.fn_ty.ret.is_indirect() as usize;\n-\n-        let has_tupled_arg = match closure_env {\n-            closure::ClosureEnv::NotClosure => abi == Abi::RustCall,\n-            closure::ClosureEnv::Closure(..) => {\n-                closure_env.load(bcx, arg_scope_id);\n-                let env_arg = &self.fn_ty.args[idx];\n-                idx += 1;\n-                if env_arg.pad.is_some() {\n-                    llarg_idx += 1;\n-                }\n-                if !env_arg.is_ignore() {\n-                    llarg_idx += 1;\n-                }\n-                false\n-            }\n-        };\n-        let tupled_arg_id = if has_tupled_arg {\n-            args[args.len() - 1].id\n-        } else {\n-            ast::DUMMY_NODE_ID\n-        };\n-\n-        // Return an array wrapping the ValueRefs that we get from `get_param` for\n-        // each argument into datums.\n-        //\n-        // For certain mode/type combinations, the raw llarg values are passed\n-        // by value.  However, within the fn body itself, we want to always\n-        // have all locals and arguments be by-ref so that we can cancel the\n-        // cleanup and for better interaction with LLVM's debug info.  So, if\n-        // the argument would be passed by value, we store it into an alloca.\n-        // This alloca should be optimized away by LLVM's mem-to-reg pass in\n-        // the event it's not truly needed.\n-        let uninit_reason = InitAlloca::Uninit(\"fn_arg populate dominates dtor\");\n-        for hir_arg in args {\n-            let arg_ty = node_id_type(bcx, hir_arg.id);\n-            let arg_datum = if hir_arg.id != tupled_arg_id {\n-                let arg = &self.fn_ty.args[idx];\n-                idx += 1;\n-                if arg.is_indirect() && bcx.sess().opts.debuginfo != FullDebugInfo {\n-                    // Don't copy an indirect argument to an alloca, the caller\n-                    // already put it in a temporary alloca and gave it up, unless\n-                    // we emit extra-debug-info, which requires local allocas :(.\n-                    let llarg = get_param(self.llfn, llarg_idx as c_uint);\n-                    llarg_idx += 1;\n-                    self.schedule_lifetime_end(arg_scope_id, llarg);\n-                    self.schedule_drop_mem(arg_scope_id, llarg, arg_ty, None);\n-\n-                    datum::Datum::new(llarg,\n-                                      arg_ty,\n-                                      datum::Lvalue::new(\"FunctionContext::bind_args\"))\n-                } else {\n-                    unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\",\n-                                                                   uninit_reason,\n-                                                                   arg_scope_id, |bcx, dst| {\n-                        debug!(\"FunctionContext::bind_args: {:?}: {:?}\", hir_arg, arg_ty);\n-                        let b = &bcx.build();\n-                        if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n-                            let meta = &self.fn_ty.args[idx];\n-                            idx += 1;\n-                            arg.store_fn_arg(b, &mut llarg_idx, expr::get_dataptr(bcx, dst));\n-                            meta.store_fn_arg(b, &mut llarg_idx, expr::get_meta(bcx, dst));\n-                        } else {\n-                            arg.store_fn_arg(b, &mut llarg_idx, dst);\n-                        }\n-                        bcx\n-                    }))\n-                }\n-            } else {\n-                // FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n-                let tupled_arg_tys = match arg_ty.sty {\n-                    ty::TyTuple(ref tys) => tys,\n-                    _ => bug!(\"last argument of `rust-call` fn isn't a tuple?!\")\n-                };\n-\n-                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx,\n-                                                            arg_ty,\n-                                                            \"tupled_args\",\n-                                                            uninit_reason,\n-                                                            arg_scope_id,\n-                                                            |bcx, llval| {\n-                    debug!(\"FunctionContext::bind_args: tupled {:?}: {:?}\", hir_arg, arg_ty);\n-                    for (j, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n-                        let dst = StructGEP(bcx, llval, j);\n-                        let arg = &self.fn_ty.args[idx];\n-                        idx += 1;\n-                        let b = &bcx.build();\n-                        if common::type_is_fat_ptr(bcx.tcx(), tupled_arg_ty) {\n-                            let meta = &self.fn_ty.args[idx];\n-                            idx += 1;\n-                            arg.store_fn_arg(b, &mut llarg_idx, expr::get_dataptr(bcx, dst));\n-                            meta.store_fn_arg(b, &mut llarg_idx, expr::get_meta(bcx, dst));\n-                        } else {\n-                            arg.store_fn_arg(b, &mut llarg_idx, dst);\n-                        }\n-                    }\n-                    bcx\n-                }))\n-            };\n-\n-            let pat = &hir_arg.pat;\n-            bcx = if let Some(name) = simple_name(pat) {\n-                // Generate nicer LLVM for the common case of fn a pattern\n-                // like `x: T`\n-                set_value_name(arg_datum.val, &bcx.name(name));\n-                self.lllocals.borrow_mut().insert(pat.id, arg_datum);\n-                bcx\n-            } else {\n-                // General path. Copy out the values that are used in the\n-                // pattern.\n-                _match::bind_irrefutable_pat(bcx, pat, arg_datum.match_input(), arg_scope_id)\n-            };\n-            debuginfo::create_argument_metadata(bcx, hir_arg);\n-        }\n-\n-        bcx\n-    }\n-\n     /// Ties up the llstaticallocas -> llloadenv -> lltop edges,\n     /// and builds the return block.\n-    pub fn finish(&'blk self, last_bcx: Block<'blk, 'tcx>,\n+    pub fn finish(&'blk self, ret_cx: Block<'blk, 'tcx>,\n                   ret_debug_loc: DebugLoc) {\n         let _icx = push_ctxt(\"FunctionContext::finish\");\n \n-        let ret_cx = match self.llreturn.get() {\n-            Some(llreturn) => {\n-                if !last_bcx.terminated.get() {\n-                    Br(last_bcx, llreturn, DebugLoc::None);\n-                }\n-                raw_block(self, llreturn)\n-            }\n-            None => last_bcx,\n-        };\n-\n         self.build_return_block(ret_cx, ret_debug_loc);\n \n         DebugLoc::None.apply(self);\n@@ -1747,15 +1027,11 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                               ret_debug_location: DebugLoc) {\n         if self.llretslotptr.get().is_none() ||\n            ret_cx.unreachable.get() ||\n-           (!self.needs_ret_allocas && self.fn_ty.ret.is_indirect()) {\n+           self.fn_ty.ret.is_indirect() {\n             return RetVoid(ret_cx, ret_debug_location);\n         }\n \n-        let retslot = if self.needs_ret_allocas {\n-            Load(ret_cx, self.llretslotptr.get().unwrap())\n-        } else {\n-            self.llretslotptr.get().unwrap()\n-        };\n+        let retslot = self.llretslotptr.get().unwrap();\n         let retptr = Value(retslot);\n         let llty = self.fn_ty.ret.original_ty;\n         match (retptr.get_dominating_store(ret_cx), self.fn_ty.ret.cast) {\n@@ -1814,14 +1090,10 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n ///\n /// If the function closes over its environment a closure will be returned.\n pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               decl: &hir::FnDecl,\n-                               body: &hir::Block,\n                                llfndecl: ValueRef,\n                                instance: Instance<'tcx>,\n-                               inlined_id: ast::NodeId,\n                                sig: &ty::FnSig<'tcx>,\n-                               abi: Abi,\n-                               closure_env: closure::ClosureEnv) {\n+                               abi: Abi) {\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n     let _icx = push_ctxt(\"trans_closure\");\n@@ -1841,84 +1113,21 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     fcx = FunctionContext::new(ccx,\n                                llfndecl,\n                                fn_ty,\n-                               Some((instance, sig, abi, inlined_id)),\n+                               Some((instance, sig, abi)),\n                                &arena);\n \n-    if fcx.mir.is_some() {\n-        return mir::trans_mir(&fcx);\n+    if fcx.mir.is_none() {\n+        bug!(\"attempted translation of `{}` w/o MIR\", instance);\n     }\n \n-    debuginfo::fill_scope_map_for_function(&fcx, decl, body, inlined_id);\n-\n-    // cleanup scope for the incoming arguments\n-    let fn_cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(\n-        ccx, inlined_id, body.span, true);\n-    let arg_scope = fcx.push_custom_cleanup_scope_with_debug_loc(fn_cleanup_debug_loc);\n-\n-    // Set up arguments to the function.\n-    debug!(\"trans_closure: function: {:?}\", Value(fcx.llfn));\n-    let bcx = fcx.bind_args(&decl.inputs, abi, inlined_id, closure_env, arg_scope);\n-\n-    // Up until here, IR instructions for this function have explicitly not been annotated with\n-    // source code location, so we don't step into call setup code. From here on, source location\n-    // emitting should be enabled.\n-    debuginfo::start_emitting_source_locations(&fcx);\n-\n-    let dest = if fcx.fn_ty.ret.is_ignore() {\n-        expr::Ignore\n-    } else {\n-        expr::SaveIn(fcx.get_ret_slot(bcx, \"iret_slot\"))\n-    };\n-\n-    // This call to trans_block is the place where we bridge between\n-    // translation calls that don't have a return value (trans_crate,\n-    // trans_mod, trans_item, et cetera) and those that do\n-    // (trans_block, trans_expr, et cetera).\n-    let mut bcx = controlflow::trans_block(bcx, body, dest);\n-\n-    match dest {\n-        expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n-            Store(bcx, slot, fcx.llretslotptr.get().unwrap());\n-        }\n-        _ => {}\n-    }\n-\n-    match fcx.llreturn.get() {\n-        Some(_) => {\n-            Br(bcx, fcx.return_exit_block(), DebugLoc::None);\n-            fcx.pop_custom_cleanup_scope(arg_scope);\n-        }\n-        None => {\n-            // Microoptimization writ large: avoid creating a separate\n-            // llreturn basic block\n-            bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_scope);\n-        }\n-    };\n-\n-    // Put return block after all other blocks.\n-    // This somewhat improves single-stepping experience in debugger.\n-    unsafe {\n-        let llreturn = fcx.llreturn.get();\n-        if let Some(llreturn) = llreturn {\n-            llvm::LLVMMoveBasicBlockAfter(llreturn, bcx.llbb);\n-        }\n-    }\n-\n-    // Insert the mandatory first few basic blocks before lltop.\n-    fcx.finish(bcx, fn_cleanup_debug_loc.debug_loc());\n+    mir::trans_mir(&fcx);\n }\n \n pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n-    let local_instance = inline::maybe_inline_instance(ccx, instance);\n-\n-    let fn_node_id = ccx.tcx().map.as_local_node_id(local_instance.def).unwrap();\n-\n-    let _s = StatRecorder::new(ccx, ccx.tcx().node_path_str(fn_node_id));\n+    let _s = StatRecorder::new(ccx, ccx.tcx().item_path_str(instance.def));\n     debug!(\"trans_instance(instance={:?})\", instance);\n     let _icx = push_ctxt(\"trans_instance\");\n \n-    let item = ccx.tcx().map.find(fn_node_id).unwrap();\n-\n     let fn_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n     let fn_ty = ccx.tcx().erase_regions(&fn_ty);\n     let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), instance.substs, &fn_ty);\n@@ -1927,109 +1136,24 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     let sig = ccx.tcx().normalize_associated_type(&sig);\n     let abi = fn_ty.fn_abi();\n \n-    let lldecl = match ccx.instances().borrow().get(&local_instance) {\n+    let lldecl = match ccx.instances().borrow().get(&instance) {\n         Some(&val) => val,\n         None => bug!(\"Instance `{:?}` not already declared\", instance)\n     };\n \n-    match item {\n-        hir_map::NodeItem(&hir::Item {\n-            node: hir::ItemFn(ref decl, _, _, _, _, ref body), ..\n-        }) |\n-        hir_map::NodeTraitItem(&hir::TraitItem {\n-            node: hir::MethodTraitItem(\n-                hir::MethodSig { ref decl, .. }, Some(ref body)), ..\n-        }) |\n-        hir_map::NodeImplItem(&hir::ImplItem {\n-            node: hir::ImplItemKind::Method(\n-                hir::MethodSig { ref decl, .. }, ref body), ..\n-        }) => {\n-            trans_closure(ccx, decl, body, lldecl, instance,\n-                          fn_node_id, &sig, abi, closure::ClosureEnv::NotClosure);\n-        }\n-        _ => bug!(\"Instance is a {:?}?\", item)\n-    }\n-}\n-\n-pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                                 ctor_ty: Ty<'tcx>,\n-                                                 disr: Disr,\n-                                                 args: CallArgs,\n-                                                 dest: expr::Dest,\n-                                                 debug_loc: DebugLoc)\n-                                                 -> Result<'blk, 'tcx> {\n-\n-    let ccx = bcx.fcx.ccx;\n-\n-    let sig = ccx.tcx().erase_late_bound_regions(&ctor_ty.fn_sig());\n-    let sig = ccx.tcx().normalize_associated_type(&sig);\n-    let result_ty = sig.output;\n-\n-    // Get location to store the result. If the user does not care about\n-    // the result, just make a stack slot\n-    let llresult = match dest {\n-        expr::SaveIn(d) => d,\n-        expr::Ignore => {\n-            if !type_is_zero_size(ccx, result_ty) {\n-                let llresult = alloc_ty(bcx, result_ty, \"constructor_result\");\n-                call_lifetime_start(bcx, llresult);\n-                llresult\n-            } else {\n-                C_undef(type_of::type_of(ccx, result_ty).ptr_to())\n-            }\n-        }\n-    };\n-\n-    if !type_is_zero_size(ccx, result_ty) {\n-        match args {\n-            ArgExprs(exprs) => {\n-                let fields = exprs.iter().map(|x| &**x).enumerate().collect::<Vec<_>>();\n-                bcx = expr::trans_adt(bcx,\n-                                      result_ty,\n-                                      disr,\n-                                      &fields[..],\n-                                      None,\n-                                      expr::SaveIn(llresult),\n-                                      debug_loc);\n-            }\n-            _ => bug!(\"expected expr as arguments for variant/struct tuple constructor\"),\n-        }\n-    } else {\n-        // Just eval all the expressions (if any). Since expressions in Rust can have arbitrary\n-        // contents, there could be side-effects we need from them.\n-        match args {\n-            ArgExprs(exprs) => {\n-                for expr in exprs {\n-                    bcx = expr::trans_into(bcx, expr, expr::Ignore);\n-                }\n-            }\n-            _ => (),\n-        }\n-    }\n-\n-    // If the caller doesn't care about the result\n-    // drop the temporary we made\n-    let bcx = match dest {\n-        expr::SaveIn(_) => bcx,\n-        expr::Ignore => {\n-            let bcx = glue::drop_ty(bcx, llresult, result_ty, debug_loc);\n-            if !type_is_zero_size(ccx, result_ty) {\n-                call_lifetime_end(bcx, llresult);\n-            }\n-            bcx\n-        }\n-    };\n-\n-    Result::new(bcx, llresult)\n+    trans_closure(ccx, lldecl, instance, &sig, abi);\n }\n \n pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                 ctor_id: ast::NodeId,\n+                                 def_id: DefId,\n+                                 substs: &'tcx Substs<'tcx>,\n                                  disr: Disr,\n-                                 param_substs: &'tcx Substs<'tcx>,\n                                  llfndecl: ValueRef) {\n-    let ctor_ty = ccx.tcx().node_id_to_type(ctor_id);\n-    let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &ctor_ty);\n+    attributes::inline(llfndecl, attributes::InlineAttr::Hint);\n+    attributes::set_frame_pointer_elimination(ccx, llfndecl);\n+\n+    let ctor_ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), substs, &ctor_ty);\n \n     let sig = ccx.tcx().erase_late_bound_regions(&ctor_ty.fn_sig());\n     let sig = ccx.tcx().normalize_associated_type(&sig);\n@@ -2038,12 +1162,10 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n     fcx = FunctionContext::new(ccx, llfndecl, fn_ty, None, &arena);\n-    let bcx = fcx.init(false, None);\n-\n-    assert!(!fcx.needs_ret_allocas);\n+    let bcx = fcx.init(false);\n \n     if !fcx.fn_ty.ret.is_ignore() {\n-        let dest = fcx.get_ret_slot(bcx, \"eret_slot\");\n+        let dest = fcx.llretslotptr.get().unwrap();\n         let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n         let repr = adt::represent_type(ccx, sig.output);\n         let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n@@ -2056,8 +1178,8 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n                 let meta = &fcx.fn_ty.args[arg_idx];\n                 arg_idx += 1;\n-                arg.store_fn_arg(b, &mut llarg_idx, expr::get_dataptr(bcx, lldestptr));\n-                meta.store_fn_arg(b, &mut llarg_idx, expr::get_meta(bcx, lldestptr));\n+                arg.store_fn_arg(b, &mut llarg_idx, get_dataptr(bcx, lldestptr));\n+                meta.store_fn_arg(b, &mut llarg_idx, get_meta(bcx, lldestptr));\n             } else {\n                 arg.store_fn_arg(b, &mut llarg_idx, lldestptr);\n             }\n@@ -2133,7 +1255,7 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n         return;\n     }\n \n-    let main_llfn = Callee::def(ccx, main_def_id, instance.substs).reify(ccx).val;\n+    let main_llfn = Callee::def(ccx, main_def_id, instance.substs).reify(ccx);\n \n     let et = ccx.sess().entry_type.get().unwrap();\n     match et {\n@@ -2175,7 +1297,7 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n                     Err(s) => ccx.sess().fatal(&s)\n                 };\n                 let empty_substs = Substs::empty(ccx.tcx());\n-                let start_fn = Callee::def(ccx, start_def_id, empty_substs).reify(ccx).val;\n+                let start_fn = Callee::def(ccx, start_def_id, empty_substs).reify(ccx);\n                 let args = {\n                     let opaque_rust_main =\n                         llvm::LLVMBuildPointerCast(bld,\n@@ -2502,12 +1624,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.sess.opts.debug_assertions\n     };\n \n-    let check_dropflag = if let Some(v) = tcx.sess.opts.debugging_opts.force_dropflag_checks {\n-        v\n-    } else {\n-        tcx.sess.opts.debug_assertions\n-    };\n-\n     let link_meta = link::build_link_meta(incremental_hashes_map, name);\n \n     let shared_ccx = SharedCrateContext::new(tcx,\n@@ -2516,8 +1632,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              Sha256::new(),\n                                              link_meta.clone(),\n                                              reachable,\n-                                             check_overflow,\n-                                             check_dropflag);\n+                                             check_overflow);\n     // Translate the metadata.\n     let metadata = time(tcx.sess.time_passes(), \"write metadata\", || {\n         write_metadata(&shared_ccx, shared_ccx.reachable())\n@@ -2631,10 +1746,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         println!(\"n_null_glues: {}\", stats.n_null_glues.get());\n         println!(\"n_real_glues: {}\", stats.n_real_glues.get());\n \n-        println!(\"n_fallback_instantiations: {}\", stats.n_fallback_instantiations.get());\n-\n         println!(\"n_fns: {}\", stats.n_fns.get());\n-        println!(\"n_monos: {}\", stats.n_monos.get());\n         println!(\"n_inlines: {}\", stats.n_inlines.get());\n         println!(\"n_closures: {}\", stats.n_closures.get());\n         println!(\"fn stats:\");"}, {"sha": "9aa486dc62811604f7dbda71f3543994d12c21f7", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 97, "deletions": 505, "changes": 602, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -15,48 +15,32 @@\n //! closure.\n \n pub use self::CalleeData::*;\n-pub use self::CallArgs::*;\n \n use arena::TypedArena;\n use back::symbol_names;\n use llvm::{self, ValueRef, get_params};\n-use middle::cstore::LOCAL_CRATE;\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n-use rustc::hir::map as hir_map;\n use abi::{Abi, FnType};\n-use adt;\n use attributes;\n use base;\n use base::*;\n use build::*;\n-use cleanup;\n-use cleanup::CleanupMethods;\n use closure;\n-use common::{self, Block, Result, CrateContext, FunctionContext, C_undef};\n+use common::{self, Block, Result, CrateContext, FunctionContext};\n use consts;\n-use datum::*;\n use debuginfo::DebugLoc;\n use declare;\n-use expr;\n-use glue;\n-use inline;\n-use intrinsic;\n-use machine::llalign_of_min;\n use meth;\n use monomorphize::{self, Instance};\n use trans_item::TransItem;\n-use type_::Type;\n use type_of;\n-use value::Value;\n use Disr;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::hir;\n \n use syntax_pos::DUMMY_SP;\n-use errors;\n-use syntax::ptr::P;\n \n #[derive(Debug)]\n pub enum CalleeData {\n@@ -80,10 +64,10 @@ pub struct Callee<'tcx> {\n \n impl<'tcx> Callee<'tcx> {\n     /// Function pointer.\n-    pub fn ptr(datum: Datum<'tcx, Rvalue>) -> Callee<'tcx> {\n+    pub fn ptr(llfn: ValueRef, ty: Ty<'tcx>) -> Callee<'tcx> {\n         Callee {\n-            data: Fn(datum.val),\n-            ty: datum.ty\n+            data: Fn(llfn),\n+            ty: ty\n         }\n     }\n \n@@ -113,32 +97,28 @@ impl<'tcx> Callee<'tcx> {\n             return Callee::trait_method(ccx, trait_id, def_id, substs);\n         }\n \n-        let maybe_node_id = inline::get_local_instance(ccx, def_id)\n-            .and_then(|def_id| tcx.map.as_local_node_id(def_id));\n-        let maybe_ast_node = maybe_node_id.and_then(|node_id| {\n-            tcx.map.find(node_id)\n-        });\n-\n-        let data = match maybe_ast_node {\n-            Some(hir_map::NodeStructCtor(_)) => {\n-                NamedTupleConstructor(Disr(0))\n-            }\n-            Some(hir_map::NodeVariant(_)) => {\n-                let vinfo = common::inlined_variant_def(ccx, maybe_node_id.unwrap());\n-                NamedTupleConstructor(Disr::from(vinfo.disr_val))\n+        let fn_ty = def_ty(tcx, def_id, substs);\n+        if let ty::TyFnDef(_, _, f) = fn_ty.sty {\n+            if f.abi == Abi::RustIntrinsic || f.abi == Abi::PlatformIntrinsic {\n+                return Callee {\n+                    data: Intrinsic,\n+                    ty: fn_ty\n+                };\n             }\n-            Some(hir_map::NodeForeignItem(fi)) if {\n-                let abi = tcx.map.get_foreign_abi(fi.id);\n-                abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic\n-            } => Intrinsic,\n-\n-            _ => return Callee::ptr(get_fn(ccx, def_id, substs))\n-        };\n+        }\n \n-        Callee {\n-            data: data,\n-            ty: def_ty(tcx, def_id, substs)\n+        // FIXME(eddyb) Detect ADT constructors more efficiently.\n+        if let Some(adt_def) = fn_ty.fn_ret().skip_binder().ty_adt_def() {\n+            if let Some(v) = adt_def.variants.iter().find(|v| def_id == v.did) {\n+                return Callee {\n+                    data: NamedTupleConstructor(Disr::from(v.disr_val)),\n+                    ty: fn_ty\n+                };\n+            }\n         }\n+\n+        let (llfn, ty) = get_fn(ccx, def_id, substs);\n+        Callee::ptr(llfn, ty)\n     }\n \n     /// Trait method, which has to be resolved to an impl method.\n@@ -163,7 +143,8 @@ impl<'tcx> Callee<'tcx> {\n                 // That is because default methods have the same ID as the\n                 // trait method used to look up the impl method that ended\n                 // up here, so calling Callee::def would infinitely recurse.\n-                Callee::ptr(get_fn(ccx, mth.method.def_id, mth.substs))\n+                let (llfn, ty) = get_fn(ccx, mth.method.def_id, mth.substs);\n+                Callee::ptr(llfn, ty)\n             }\n             traits::VtableClosure(vtable_closure) => {\n                 // The substitutions should have no type parameters remaining\n@@ -175,24 +156,14 @@ impl<'tcx> Callee<'tcx> {\n                                                          trait_closure_kind);\n \n                 let method_ty = def_ty(tcx, def_id, substs);\n-                let fn_ptr_ty = match method_ty.sty {\n-                    ty::TyFnDef(_, _, fty) => tcx.mk_fn_ptr(fty),\n-                    _ => bug!(\"expected fn item type, found {}\",\n-                              method_ty)\n-                };\n-                Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n+                Callee::ptr(llfn, method_ty)\n             }\n             traits::VtableFnPointer(vtable_fn_pointer) => {\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n                 let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, vtable_fn_pointer.fn_ty);\n \n                 let method_ty = def_ty(tcx, def_id, substs);\n-                let fn_ptr_ty = match method_ty.sty {\n-                    ty::TyFnDef(_, _, fty) => tcx.mk_fn_ptr(fty),\n-                    _ => bug!(\"expected fn item type, found {}\",\n-                              method_ty)\n-                };\n-                Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n+                Callee::ptr(llfn, method_ty)\n             }\n             traits::VtableObject(ref data) => {\n                 Callee {\n@@ -236,30 +207,34 @@ impl<'tcx> Callee<'tcx> {\n     /// function.\n     pub fn call<'a, 'blk>(self, bcx: Block<'blk, 'tcx>,\n                           debug_loc: DebugLoc,\n-                          args: CallArgs<'a, 'tcx>,\n-                          dest: Option<expr::Dest>)\n+                          args: &[ValueRef],\n+                          dest: Option<ValueRef>)\n                           -> Result<'blk, 'tcx> {\n         trans_call_inner(bcx, debug_loc, self, args, dest)\n     }\n \n     /// Turn the callee into a function pointer.\n-    pub fn reify<'a>(self, ccx: &CrateContext<'a, 'tcx>)\n-                     -> Datum<'tcx, Rvalue> {\n-        let fn_ptr_ty = match self.ty.sty {\n-            ty::TyFnDef(_, _, f) => ccx.tcx().mk_fn_ptr(f),\n-            _ => self.ty\n-        };\n+    pub fn reify<'a>(self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         match self.data {\n-            Fn(llfn) => {\n-                immediate_rvalue(llfn, fn_ptr_ty)\n-            }\n+            Fn(llfn) => llfn,\n             Virtual(idx) => {\n-                let llfn = meth::trans_object_shim(ccx, self.ty, idx);\n-                immediate_rvalue(llfn, fn_ptr_ty)\n+                meth::trans_object_shim(ccx, self.ty, idx)\n             }\n-            NamedTupleConstructor(_) => match self.ty.sty {\n+            NamedTupleConstructor(disr) => match self.ty.sty {\n                 ty::TyFnDef(def_id, substs, _) => {\n-                    return get_fn(ccx, def_id, substs);\n+                    let instance = Instance::new(def_id, substs);\n+                    if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n+                        return llfn;\n+                    }\n+\n+                    let sym = ccx.symbol_map().get_or_compute(ccx.shared(),\n+                                                              TransItem::Fn(instance));\n+                    assert!(!ccx.codegen_unit().contains_item(&TransItem::Fn(instance)));\n+                    let lldecl = declare::define_internal_fn(ccx, &sym, self.ty);\n+                    base::trans_ctor_shim(ccx, def_id, substs, disr, lldecl);\n+                    ccx.instances().borrow_mut().insert(instance, lldecl);\n+\n+                    lldecl\n                 }\n                 _ => bug!(\"expected fn item type, found {}\", self.ty)\n             },\n@@ -310,7 +285,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfnpointer = match bare_fn_ty.sty {\n         ty::TyFnDef(def_id, substs, _) => {\n             // Function definitions have to be turned into a pointer.\n-            let llfn = Callee::def(ccx, def_id, substs).reify(ccx).val;\n+            let llfn = Callee::def(ccx, def_id, substs).reify(ccx);\n             if !is_by_ref {\n                 // A by-value fn item is ignored, so the shim has\n                 // the same signature as the original function.\n@@ -380,7 +355,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n     fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &block_arena);\n-    let mut bcx = fcx.init(false, None);\n+    let mut bcx = fcx.init(false);\n \n     let llargs = get_params(fcx.llfn);\n \n@@ -394,17 +369,13 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         }\n     });\n \n-    assert!(!fcx.needs_ret_allocas);\n-\n-    let dest = fcx.llretslotptr.get().map(|_|\n-        expr::SaveIn(fcx.get_ret_slot(bcx, \"ret_slot\"))\n-    );\n+    let dest = fcx.llretslotptr.get();\n \n     let callee = Callee {\n         data: Fn(llfnpointer),\n         ty: bare_fn_ty\n     };\n-    bcx = callee.call(bcx, DebugLoc::None, ArgVals(&llargs[(self_idx + 1)..]), dest).bcx;\n+    bcx = callee.call(bcx, DebugLoc::None, &llargs[(self_idx + 1)..], dest).bcx;\n \n     fcx.finish(bcx, DebugLoc::None);\n \n@@ -424,90 +395,27 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     def_id: DefId,\n                     substs: &'tcx Substs<'tcx>)\n-                    -> Datum<'tcx, Rvalue> {\n+                    -> (ValueRef, Ty<'tcx>) {\n     let tcx = ccx.tcx();\n \n     debug!(\"get_fn(def_id={:?}, substs={:?})\", def_id, substs);\n \n     assert!(!substs.types.needs_infer());\n     assert!(!substs.types.has_escaping_regions());\n+    assert!(!substs.types.has_param_types());\n \n-    // Check whether this fn has an inlined copy and, if so, redirect\n-    // def_id to the local id of the inlined copy.\n-    let def_id = inline::maybe_instantiate_inline(ccx, def_id);\n-\n-    fn is_named_tuple_constructor(tcx: TyCtxt, def_id: DefId) -> bool {\n-        let node_id = match tcx.map.as_local_node_id(def_id) {\n-            Some(n) => n,\n-            None => { return false; }\n-        };\n-        let map_node = errors::expect(\n-            &tcx.sess.diagnostic(),\n-            tcx.map.find(node_id),\n-            || \"local item should be in ast map\".to_string());\n-\n-        match map_node {\n-            hir_map::NodeVariant(v) => {\n-                v.node.data.is_tuple()\n-            }\n-            hir_map::NodeStructCtor(_) => true,\n-            _ => false\n-        }\n-    }\n-    let must_monomorphise =\n-        !substs.types.is_empty() || is_named_tuple_constructor(tcx, def_id);\n-\n-    debug!(\"get_fn({:?}) must_monomorphise: {}\",\n-           def_id, must_monomorphise);\n-\n-    // Create a monomorphic version of generic functions\n-    if must_monomorphise {\n-        // Should be either intra-crate or inlined.\n-        assert_eq!(def_id.krate, LOCAL_CRATE);\n-\n-        let substs = tcx.normalize_associated_type(&substs);\n-        let (val, fn_ty) = monomorphize::monomorphic_fn(ccx, def_id, substs);\n-        let fn_ptr_ty = match fn_ty.sty {\n-            ty::TyFnDef(_, _, fty) => {\n-                // Create a fn pointer with the substituted signature.\n-                tcx.mk_fn_ptr(fty)\n-            }\n-            _ => bug!(\"expected fn item type, found {}\", fn_ty)\n-        };\n-        assert_eq!(type_of::type_of(ccx, fn_ptr_ty), common::val_ty(val));\n-        return immediate_rvalue(val, fn_ptr_ty);\n-    }\n-\n-    // Find the actual function pointer.\n-    let ty = ccx.tcx().lookup_item_type(def_id).ty;\n-    let fn_ptr_ty = match ty.sty {\n-        ty::TyFnDef(_, _, ref fty) => {\n-            // Create a fn pointer with the normalized signature.\n-            tcx.mk_fn_ptr(tcx.normalize_associated_type(fty))\n-        }\n-        _ => bug!(\"expected fn item type, found {}\", ty)\n-    };\n+    let substs = tcx.normalize_associated_type(&substs);\n+    let instance = Instance::new(def_id, substs);\n+    let item_ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), substs, &item_ty);\n \n-    let instance = Instance::mono(ccx.shared(), def_id);\n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n-        return immediate_rvalue(llfn, fn_ptr_ty);\n+        return (llfn, fn_ty);\n     }\n \n-    let local_id = ccx.tcx().map.as_local_node_id(def_id);\n-    let local_item = match local_id.and_then(|id| tcx.map.find(id)) {\n-        Some(hir_map::NodeItem(&hir::Item {\n-            span, node: hir::ItemFn(..), ..\n-        })) |\n-        Some(hir_map::NodeTraitItem(&hir::TraitItem {\n-            span, node: hir::MethodTraitItem(_, Some(_)), ..\n-        })) |\n-        Some(hir_map::NodeImplItem(&hir::ImplItem {\n-            span, node: hir::ImplItemKind::Method(..), ..\n-        })) => {\n-            Some(span)\n-        }\n-        _ => None\n-    };\n+    let sym = ccx.symbol_map().get_or_compute(ccx.shared(),\n+                                              TransItem::Fn(instance));\n+    debug!(\"get_fn({:?}: {:?}) => {}\", instance, fn_ty, sym);\n \n     // This is subtle and surprising, but sometimes we have to bitcast\n     // the resulting fn pointer.  The reason has to do with external\n@@ -533,57 +441,57 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n \n-    let sym = ccx.symbol_map().get_or_compute(ccx.shared(),\n-                                              TransItem::Fn(instance));\n-\n-    let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n-    let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {\n-        if let Some(span) = local_item {\n-            if declare::get_defined_value(ccx, &sym).is_some() {\n-                ccx.sess().span_fatal(span,\n-                    &format!(\"symbol `{}` is already defined\", &sym));\n-            }\n+    let fn_ptr_ty = match fn_ty.sty {\n+        ty::TyFnDef(_, _, fty) => {\n+            // Create a fn pointer with the substituted signature.\n+            tcx.mk_fn_ptr(fty)\n         }\n+        _ => bug!(\"expected fn item type, found {}\", fn_ty)\n+    };\n+    let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n \n+    let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {\n         if common::val_ty(llfn) != llptrty {\n-            if local_item.is_some() {\n-                bug!(\"symbol `{}` previously declared as {:?}, now wanted as {:?}\",\n-                     sym, Value(llfn), llptrty);\n-            }\n             debug!(\"get_fn: casting {:?} to {:?}\", llfn, llptrty);\n             consts::ptrcast(llfn, llptrty)\n         } else {\n             debug!(\"get_fn: not casting pointer!\");\n             llfn\n         }\n     } else {\n-        let llfn = declare::declare_fn(ccx, &sym, ty);\n+        let llfn = declare::declare_fn(ccx, &sym, fn_ty);\n         assert_eq!(common::val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n \n         let attrs = ccx.tcx().get_attrs(def_id);\n         attributes::from_fn_attrs(ccx, &attrs, llfn);\n-        if local_item.is_some() {\n+\n+        let is_local_def = ccx.shared().translation_items().borrow()\n+                              .contains(&TransItem::Fn(instance));\n+        if is_local_def {\n             // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n             attributes::unwind(llfn, true);\n+            unsafe {\n+                llvm::LLVMSetLinkage(llfn, llvm::ExternalLinkage);\n+            }\n         }\n \n         llfn\n     };\n \n     ccx.instances().borrow_mut().insert(instance, llfn);\n \n-    immediate_rvalue(llfn, fn_ptr_ty)\n+    (llfn, fn_ty)\n }\n \n // ______________________________________________________________________\n // Translating calls\n \n-fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+fn trans_call_inner<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     debug_loc: DebugLoc,\n                                     callee: Callee<'tcx>,\n-                                    args: CallArgs<'a, 'tcx>,\n-                                    dest: Option<expr::Dest>)\n+                                    args: &[ValueRef],\n+                                    opt_llretslot: Option<ValueRef>)\n                                     -> Result<'blk, 'tcx> {\n     // Introduce a temporary cleanup scope that will contain cleanups\n     // for the arguments while they are being evaluated. The purpose\n@@ -595,65 +503,16 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n \n-    let abi = callee.ty.fn_abi();\n-    let sig = callee.ty.fn_sig();\n-    let output = bcx.tcx().erase_late_bound_regions(&sig.output());\n-    let output = bcx.tcx().normalize_associated_type(&output);\n-\n-    let extra_args = match args {\n-        ArgExprs(args) if abi != Abi::RustCall => {\n-            args[sig.0.inputs.len()..].iter().map(|expr| {\n-                common::expr_ty_adjusted(bcx, expr)\n-            }).collect()\n-        }\n-        _ => vec![]\n-    };\n-    let fn_ty = callee.direct_fn_type(ccx, &extra_args);\n+    let fn_ret = callee.ty.fn_ret();\n+    let fn_ty = callee.direct_fn_type(ccx, &[]);\n \n     let mut callee = match callee.data {\n-        Intrinsic => {\n-            assert!(abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic);\n-            assert!(dest.is_some());\n-\n-            return intrinsic::trans_intrinsic_call(bcx, callee.ty, &fn_ty,\n-                                                   args, dest.unwrap(),\n-                                                   debug_loc);\n-        }\n-        NamedTupleConstructor(disr) => {\n-            assert!(dest.is_some());\n-\n-            return base::trans_named_tuple_constructor(bcx,\n-                                                       callee.ty,\n-                                                       disr,\n-                                                       args,\n-                                                       dest.unwrap(),\n-                                                       debug_loc);\n+        NamedTupleConstructor(_) | Intrinsic => {\n+            bug!(\"{:?} calls should not go through Callee::call\", callee);\n         }\n         f => f\n     };\n \n-    // Generate a location to store the result. If the user does\n-    // not care about the result, just make a stack slot.\n-    let opt_llretslot = dest.and_then(|dest| match dest {\n-        expr::SaveIn(dst) => Some(dst),\n-        expr::Ignore => {\n-            let needs_drop = || bcx.fcx.type_needs_drop(output);\n-            if fn_ty.ret.is_indirect() || fn_ty.ret.cast.is_some() || needs_drop() {\n-                // Push the out-pointer if we use an out-pointer for this\n-                // return type, otherwise push \"undef\".\n-                if fn_ty.ret.is_ignore() {\n-                    Some(C_undef(fn_ty.ret.original_ty.ptr_to()))\n-                } else {\n-                    let llresult = alloca(bcx, fn_ty.ret.original_ty, \"__llret\");\n-                    call_lifetime_start(bcx, llresult);\n-                    Some(llresult)\n-                }\n-            } else {\n-                None\n-            }\n-        }\n-    });\n-\n     // If there no destination, return must be direct, with no cast.\n     if opt_llretslot.is_none() {\n         assert!(!fn_ty.ret.is_indirect() && fn_ty.ret.cast.is_none());\n@@ -669,17 +528,24 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         llargs.push(llretslot);\n     }\n \n-    let arg_cleanup_scope = fcx.push_custom_cleanup_scope();\n-    bcx = trans_args(bcx, abi, &fn_ty, &mut callee, args, &mut llargs,\n-                     cleanup::CustomScope(arg_cleanup_scope));\n-    fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n+    match callee {\n+        Virtual(idx) => {\n+            llargs.push(args[0]);\n+\n+            let fn_ptr = meth::get_virtual_method(bcx, args[1], idx);\n+            let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n+            callee = Fn(PointerCast(bcx, fn_ptr, llty));\n+            llargs.extend_from_slice(&args[2..]);\n+        }\n+        _ => llargs.extend_from_slice(args)\n+    }\n \n     let llfn = match callee {\n         Fn(f) => f,\n         _ => bug!(\"expected fn pointer callee, found {:?}\", callee)\n     };\n \n-    let (llret, mut bcx) = base::invoke(bcx, llfn, &llargs, debug_loc);\n+    let (llret, bcx) = base::invoke(bcx, llfn, &llargs, debug_loc);\n     if !bcx.unreachable.get() {\n         fn_ty.apply_attrs_callsite(llret);\n \n@@ -695,283 +561,9 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_cleanup_scope);\n-\n-    // If the caller doesn't care about the result of this fn call,\n-    // drop the temporary slot we made.\n-    match (dest, opt_llretslot) {\n-        (Some(expr::Ignore), Some(llretslot)) => {\n-            // drop the value if it is not being saved.\n-            bcx = glue::drop_ty(bcx, llretslot, output, debug_loc);\n-            call_lifetime_end(bcx, llretslot);\n-        }\n-        _ => {}\n-    }\n-\n-    // FIXME(canndrew): This is_never should really be an is_uninhabited\n-    if output.is_never() {\n+    if fn_ret.0.is_never() {\n         Unreachable(bcx);\n     }\n \n     Result::new(bcx, llret)\n }\n-\n-pub enum CallArgs<'a, 'tcx> {\n-    /// Supply value of arguments as a list of expressions that must be\n-    /// translated. This is used in the common case of `foo(bar, qux)`.\n-    ArgExprs(&'a [P<hir::Expr>]),\n-\n-    /// Supply value of arguments as a list of LLVM value refs; frequently\n-    /// used with lang items and so forth, when the argument is an internal\n-    /// value.\n-    ArgVals(&'a [ValueRef]),\n-\n-    /// For overloaded operators: `(lhs, Option(rhs))`.\n-    /// `lhs` is the left-hand-side and `rhs` is the datum\n-    /// of the right-hand-side argument (if any).\n-    ArgOverloadedOp(Datum<'tcx, Expr>, Option<Datum<'tcx, Expr>>),\n-\n-    /// Supply value of arguments as a list of expressions that must be\n-    /// translated, for overloaded call operators.\n-    ArgOverloadedCall(Vec<&'a hir::Expr>),\n-}\n-\n-fn trans_args_under_call_abi<'blk, 'tcx>(\n-                             mut bcx: Block<'blk, 'tcx>,\n-                             arg_exprs: &[P<hir::Expr>],\n-                             callee: &mut CalleeData,\n-                             fn_ty: &FnType,\n-                             llargs: &mut Vec<ValueRef>,\n-                             arg_cleanup_scope: cleanup::ScopeId)\n-                             -> Block<'blk, 'tcx>\n-{\n-    let mut arg_idx = 0;\n-\n-    // Translate the `self` argument first.\n-    let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_exprs[0]));\n-    bcx = trans_arg_datum(bcx,\n-                          arg_datum,\n-                          callee, fn_ty, &mut arg_idx,\n-                          arg_cleanup_scope,\n-                          llargs);\n-\n-    // Now untuple the rest of the arguments.\n-    let tuple_expr = &arg_exprs[1];\n-    let tuple_type = common::node_id_type(bcx, tuple_expr.id);\n-\n-    match tuple_type.sty {\n-        ty::TyTuple(ref field_types) => {\n-            let tuple_datum = unpack_datum!(bcx,\n-                                            expr::trans(bcx, &tuple_expr));\n-            let tuple_lvalue_datum =\n-                unpack_datum!(bcx,\n-                              tuple_datum.to_lvalue_datum(bcx,\n-                                                          \"args\",\n-                                                          tuple_expr.id));\n-            let repr = adt::represent_type(bcx.ccx(), tuple_type);\n-            let repr_ptr = &repr;\n-            for (i, field_type) in field_types.iter().enumerate() {\n-                let arg_datum = tuple_lvalue_datum.get_element(\n-                    bcx,\n-                    field_type,\n-                    |srcval| {\n-                        adt::trans_field_ptr(bcx, repr_ptr, srcval, Disr(0), i)\n-                    }).to_expr_datum();\n-                bcx = trans_arg_datum(bcx,\n-                                      arg_datum,\n-                                      callee, fn_ty, &mut arg_idx,\n-                                      arg_cleanup_scope,\n-                                      llargs);\n-            }\n-        }\n-        _ => {\n-            span_bug!(tuple_expr.span,\n-                      \"argument to `.call()` wasn't a tuple?!\")\n-        }\n-    };\n-\n-    bcx\n-}\n-\n-pub fn trans_args<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  abi: Abi,\n-                                  fn_ty: &FnType,\n-                                  callee: &mut CalleeData,\n-                                  args: CallArgs<'a, 'tcx>,\n-                                  llargs: &mut Vec<ValueRef>,\n-                                  arg_cleanup_scope: cleanup::ScopeId)\n-                                  -> Block<'blk, 'tcx> {\n-    debug!(\"trans_args(abi={})\", abi);\n-\n-    let _icx = push_ctxt(\"trans_args\");\n-\n-    let mut bcx = bcx;\n-    let mut arg_idx = 0;\n-\n-    // First we figure out the caller's view of the types of the arguments.\n-    // This will be needed if this is a generic call, because the callee has\n-    // to cast her view of the arguments to the caller's view.\n-    match args {\n-        ArgExprs(arg_exprs) => {\n-            if abi == Abi::RustCall {\n-                // This is only used for direct calls to the `call`,\n-                // `call_mut` or `call_once` functions.\n-                return trans_args_under_call_abi(bcx,\n-                                                 arg_exprs, callee, fn_ty,\n-                                                 llargs,\n-                                                 arg_cleanup_scope)\n-            }\n-\n-            for arg_expr in arg_exprs {\n-                let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_expr));\n-                bcx = trans_arg_datum(bcx,\n-                                      arg_datum,\n-                                      callee, fn_ty, &mut arg_idx,\n-                                      arg_cleanup_scope,\n-                                      llargs);\n-            }\n-        }\n-        ArgOverloadedCall(arg_exprs) => {\n-            for expr in arg_exprs {\n-                let arg_datum =\n-                    unpack_datum!(bcx, expr::trans(bcx, expr));\n-                bcx = trans_arg_datum(bcx,\n-                                      arg_datum,\n-                                      callee, fn_ty, &mut arg_idx,\n-                                      arg_cleanup_scope,\n-                                      llargs);\n-            }\n-        }\n-        ArgOverloadedOp(lhs, rhs) => {\n-            bcx = trans_arg_datum(bcx, lhs,\n-                                  callee, fn_ty, &mut arg_idx,\n-                                  arg_cleanup_scope,\n-                                  llargs);\n-\n-            if let Some(rhs) = rhs {\n-                bcx = trans_arg_datum(bcx, rhs,\n-                                      callee, fn_ty, &mut arg_idx,\n-                                      arg_cleanup_scope,\n-                                      llargs);\n-            }\n-        }\n-        ArgVals(vs) => {\n-            match *callee {\n-                Virtual(idx) => {\n-                    llargs.push(vs[0]);\n-\n-                    let fn_ptr = meth::get_virtual_method(bcx, vs[1], idx);\n-                    let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n-                    *callee = Fn(PointerCast(bcx, fn_ptr, llty));\n-                    llargs.extend_from_slice(&vs[2..]);\n-                }\n-                _ => llargs.extend_from_slice(vs)\n-            }\n-        }\n-    }\n-\n-    bcx\n-}\n-\n-fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               arg_datum: Datum<'tcx, Expr>,\n-                               callee: &mut CalleeData,\n-                               fn_ty: &FnType,\n-                               next_idx: &mut usize,\n-                               arg_cleanup_scope: cleanup::ScopeId,\n-                               llargs: &mut Vec<ValueRef>)\n-                               -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_arg_datum\");\n-    let mut bcx = bcx;\n-\n-    debug!(\"trans_arg_datum({:?})\", arg_datum);\n-\n-    let arg = &fn_ty.args[*next_idx];\n-    *next_idx += 1;\n-\n-    // Fill padding with undef value, where applicable.\n-    if let Some(ty) = arg.pad {\n-        llargs.push(C_undef(ty));\n-    }\n-\n-    // Determine whether we want a by-ref datum even if not appropriate.\n-    let want_by_ref = arg.is_indirect() || arg.cast.is_some();\n-\n-    let fat_ptr = common::type_is_fat_ptr(bcx.tcx(), arg_datum.ty);\n-    let (by_ref, val) = if fat_ptr && !bcx.fcx.type_needs_drop(arg_datum.ty) {\n-        (true, arg_datum.val)\n-    } else {\n-        // Make this an rvalue, since we are going to be\n-        // passing ownership.\n-        let arg_datum = unpack_datum!(\n-            bcx, arg_datum.to_rvalue_datum(bcx, \"arg\"));\n-\n-        // Now that arg_datum is owned, get it into the appropriate\n-        // mode (ref vs value).\n-        let arg_datum = unpack_datum!(bcx, if want_by_ref {\n-            arg_datum.to_ref_datum(bcx)\n-        } else {\n-            arg_datum.to_appropriate_datum(bcx)\n-        });\n-\n-        // Technically, ownership of val passes to the callee.\n-        // However, we must cleanup should we panic before the\n-        // callee is actually invoked.\n-        (arg_datum.kind.is_by_ref(),\n-         arg_datum.add_clean(bcx.fcx, arg_cleanup_scope))\n-    };\n-\n-    if arg.is_ignore() {\n-        return bcx;\n-    }\n-\n-    debug!(\"--- trans_arg_datum passing {:?}\", Value(val));\n-\n-    if fat_ptr {\n-        // Fat pointers should be passed without any transformations.\n-        assert!(!arg.is_indirect() && arg.cast.is_none());\n-        llargs.push(Load(bcx, expr::get_dataptr(bcx, val)));\n-\n-        let info_arg = &fn_ty.args[*next_idx];\n-        *next_idx += 1;\n-        assert!(!info_arg.is_indirect() && info_arg.cast.is_none());\n-        let info = Load(bcx, expr::get_meta(bcx, val));\n-\n-        if let Virtual(idx) = *callee {\n-            // We have to grab the fn pointer from the vtable when\n-            // handling the first argument, ensure that here.\n-            assert_eq!(*next_idx, 2);\n-            assert!(info_arg.is_ignore());\n-            let fn_ptr = meth::get_virtual_method(bcx, info, idx);\n-            let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n-            *callee = Fn(PointerCast(bcx, fn_ptr, llty));\n-        } else {\n-            assert!(!info_arg.is_ignore());\n-            llargs.push(info);\n-        }\n-        return bcx;\n-    }\n-\n-    let mut val = val;\n-    if by_ref && !arg.is_indirect() {\n-        // Have to load the argument, maybe while casting it.\n-        if arg.original_ty == Type::i1(bcx.ccx()) {\n-            // We store bools as i8 so we need to truncate to i1.\n-            val = LoadRangeAssert(bcx, val, 0, 2, llvm::False);\n-            val = Trunc(bcx, val, arg.original_ty);\n-        } else if let Some(ty) = arg.cast {\n-            val = Load(bcx, PointerCast(bcx, val, ty.ptr_to()));\n-            if !bcx.unreachable.get() {\n-                let llalign = llalign_of_min(bcx.ccx(), arg.ty);\n-                unsafe {\n-                    llvm::LLVMSetAlignment(val, llalign);\n-                }\n-            }\n-        } else {\n-            val = Load(bcx, val);\n-        }\n-    }\n-\n-    llargs.push(val);\n-    bcx\n-}"}, {"sha": "d368ce47430b7e586a96137a5b1418095c95f3e2", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 53, "deletions": 635, "changes": 688, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -114,37 +114,22 @@\n //! code for `expr` itself is responsible for freeing any other byproducts\n //! that may be in play.\n \n-pub use self::ScopeId::*;\n-pub use self::CleanupScopeKind::*;\n pub use self::EarlyExitLabel::*;\n-pub use self::Heap::*;\n \n use llvm::{BasicBlockRef, ValueRef};\n use base;\n use build;\n use common;\n-use common::{Block, FunctionContext, NodeIdAndSpan, LandingPad};\n-use datum::{Datum, Lvalue};\n-use debuginfo::{DebugLoc, ToDebugLoc};\n+use common::{Block, FunctionContext, LandingPad};\n+use debuginfo::{DebugLoc};\n use glue;\n-use middle::region;\n use type_::Type;\n use value::Value;\n-use rustc::ty::{Ty, TyCtxt};\n-\n-use std::fmt;\n-use syntax::ast;\n-\n-pub struct CleanupScope<'blk, 'tcx: 'blk> {\n-    // The id of this cleanup scope. If the id is None,\n-    // this is a *temporary scope* that is pushed during trans to\n-    // cleanup miscellaneous garbage that trans may generate whose\n-    // lifetime is a subset of some expression.  See module doc for\n-    // more details.\n-    kind: CleanupScopeKind<'blk, 'tcx>,\n+use rustc::ty::Ty;\n \n+pub struct CleanupScope<'tcx> {\n     // Cleanups to run upon scope exit.\n-    cleanups: Vec<CleanupObj<'tcx>>,\n+    cleanups: Vec<DropValue<'tcx>>,\n \n     // The debug location any drop calls generated for this scope will be\n     // associated with.\n@@ -159,37 +144,9 @@ pub struct CustomScopeIndex {\n     index: usize\n }\n \n-pub const EXIT_BREAK: usize = 0;\n-pub const EXIT_LOOP: usize = 1;\n-pub const EXIT_MAX: usize = 2;\n-\n-pub enum CleanupScopeKind<'blk, 'tcx: 'blk> {\n-    CustomScopeKind,\n-    AstScopeKind(ast::NodeId),\n-    LoopScopeKind(ast::NodeId, [Block<'blk, 'tcx>; EXIT_MAX])\n-}\n-\n-impl<'blk, 'tcx: 'blk> fmt::Debug for CleanupScopeKind<'blk, 'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            CustomScopeKind => write!(f, \"CustomScopeKind\"),\n-            AstScopeKind(nid) => write!(f, \"AstScopeKind({})\", nid),\n-            LoopScopeKind(nid, ref blks) => {\n-                write!(f, \"LoopScopeKind({}, [\", nid)?;\n-                for blk in blks {\n-                    write!(f, \"{:p}, \", blk)?;\n-                }\n-                write!(f, \"])\")\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum EarlyExitLabel {\n     UnwindExit(UnwindKind),\n-    ReturnExit,\n-    LoopExit(ast::NodeId, usize)\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -205,97 +162,8 @@ pub struct CachedEarlyExit {\n     last_cleanup: usize,\n }\n \n-pub trait Cleanup<'tcx> {\n-    fn must_unwind(&self) -> bool;\n-    fn is_lifetime_end(&self) -> bool;\n-    fn trans<'blk>(&self,\n-                   bcx: Block<'blk, 'tcx>,\n-                   debug_loc: DebugLoc)\n-                   -> Block<'blk, 'tcx>;\n-}\n-\n-pub type CleanupObj<'tcx> = Box<Cleanup<'tcx>+'tcx>;\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum ScopeId {\n-    AstScope(ast::NodeId),\n-    CustomScope(CustomScopeIndex)\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct DropHint<K>(pub ast::NodeId, pub K);\n-\n-pub type DropHintDatum<'tcx> = DropHint<Datum<'tcx, Lvalue>>;\n-pub type DropHintValue = DropHint<ValueRef>;\n-\n-impl<K> DropHint<K> {\n-    pub fn new(id: ast::NodeId, k: K) -> DropHint<K> { DropHint(id, k) }\n-}\n-\n-impl DropHint<ValueRef> {\n-    pub fn value(&self) -> ValueRef { self.1 }\n-}\n-\n-pub trait DropHintMethods {\n-    type ValueKind;\n-    fn to_value(&self) -> Self::ValueKind;\n-}\n-impl<'tcx> DropHintMethods for DropHintDatum<'tcx> {\n-    type ValueKind = DropHintValue;\n-    fn to_value(&self) -> DropHintValue { DropHint(self.0, self.1.val) }\n-}\n-\n-impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n-    /// Invoked when we start to trans the code contained within a new cleanup scope.\n-    fn push_ast_cleanup_scope(&self, debug_loc: NodeIdAndSpan) {\n-        debug!(\"push_ast_cleanup_scope({})\",\n-               self.ccx.tcx().map.node_to_string(debug_loc.id));\n-\n-        // FIXME(#2202) -- currently closure bodies have a parent\n-        // region, which messes up the assertion below, since there\n-        // are no cleanup scopes on the stack at the start of\n-        // trans'ing a closure body.  I think though that this should\n-        // eventually be fixed by closure bodies not having a parent\n-        // region, though that's a touch unclear, and it might also be\n-        // better just to narrow this assertion more (i.e., by\n-        // excluding id's that correspond to closure bodies only). For\n-        // now we just say that if there is already an AST scope on the stack,\n-        // this new AST scope had better be its immediate child.\n-        let top_scope = self.top_ast_scope();\n-        let region_maps = &self.ccx.tcx().region_maps;\n-        if top_scope.is_some() {\n-            assert!((region_maps\n-                     .opt_encl_scope(region_maps.node_extent(debug_loc.id))\n-                     .map(|s|s.node_id(region_maps)) == top_scope)\n-                    ||\n-                    (region_maps\n-                     .opt_encl_scope(region_maps.lookup_code_extent(\n-                         region::CodeExtentData::DestructionScope(debug_loc.id)))\n-                     .map(|s|s.node_id(region_maps)) == top_scope));\n-        }\n-\n-        self.push_scope(CleanupScope::new(AstScopeKind(debug_loc.id),\n-                                          debug_loc.debug_loc()));\n-    }\n-\n-    fn push_loop_cleanup_scope(&self,\n-                               id: ast::NodeId,\n-                               exits: [Block<'blk, 'tcx>; EXIT_MAX]) {\n-        debug!(\"push_loop_cleanup_scope({})\",\n-               self.ccx.tcx().map.node_to_string(id));\n-        assert_eq!(Some(id), self.top_ast_scope());\n-\n-        // Just copy the debuginfo source location from the enclosing scope\n-        let debug_loc = self.scopes\n-                            .borrow()\n-                            .last()\n-                            .unwrap()\n-                            .debug_loc;\n-\n-        self.push_scope(CleanupScope::new(LoopScopeKind(id, exits), debug_loc));\n-    }\n-\n-    fn push_custom_cleanup_scope(&self) -> CustomScopeIndex {\n+impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n+    pub fn push_custom_cleanup_scope(&self) -> CustomScopeIndex {\n         let index = self.scopes_len();\n         debug!(\"push_custom_cleanup_scope(): {}\", index);\n \n@@ -306,276 +174,109 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                             .map(|opt_scope| opt_scope.debug_loc)\n                             .unwrap_or(DebugLoc::None);\n \n-        self.push_scope(CleanupScope::new(CustomScopeKind, debug_loc));\n-        CustomScopeIndex { index: index }\n-    }\n-\n-    fn push_custom_cleanup_scope_with_debug_loc(&self,\n-                                                debug_loc: NodeIdAndSpan)\n-                                                -> CustomScopeIndex {\n-        let index = self.scopes_len();\n-        debug!(\"push_custom_cleanup_scope(): {}\", index);\n-\n-        self.push_scope(CleanupScope::new(CustomScopeKind,\n-                                          debug_loc.debug_loc()));\n+        self.push_scope(CleanupScope::new(debug_loc));\n         CustomScopeIndex { index: index }\n     }\n \n-    /// Removes the cleanup scope for id `cleanup_scope`, which must be at the top of the cleanup\n-    /// stack, and generates the code to do its cleanups for normal exit.\n-    fn pop_and_trans_ast_cleanup_scope(&self,\n-                                       bcx: Block<'blk, 'tcx>,\n-                                       cleanup_scope: ast::NodeId)\n-                                       -> Block<'blk, 'tcx> {\n-        debug!(\"pop_and_trans_ast_cleanup_scope({})\",\n-               self.ccx.tcx().map.node_to_string(cleanup_scope));\n-\n-        assert!(self.top_scope(|s| s.kind.is_ast_with_id(cleanup_scope)));\n-\n-        let scope = self.pop_scope();\n-        self.trans_scope_cleanups(bcx, &scope)\n-    }\n-\n-    /// Removes the loop cleanup scope for id `cleanup_scope`, which must be at the top of the\n-    /// cleanup stack. Does not generate any cleanup code, since loop scopes should exit by\n-    /// branching to a block generated by `normal_exit_block`.\n-    fn pop_loop_cleanup_scope(&self,\n-                              cleanup_scope: ast::NodeId) {\n-        debug!(\"pop_loop_cleanup_scope({})\",\n-               self.ccx.tcx().map.node_to_string(cleanup_scope));\n-\n-        assert!(self.top_scope(|s| s.kind.is_loop_with_id(cleanup_scope)));\n-\n-        let _ = self.pop_scope();\n-    }\n-\n     /// Removes the top cleanup scope from the stack without executing its cleanups. The top\n     /// cleanup scope must be the temporary scope `custom_scope`.\n-    fn pop_custom_cleanup_scope(&self,\n-                                custom_scope: CustomScopeIndex) {\n+    pub fn pop_custom_cleanup_scope(&self,\n+                                    custom_scope: CustomScopeIndex) {\n         debug!(\"pop_custom_cleanup_scope({})\", custom_scope.index);\n         assert!(self.is_valid_to_pop_custom_scope(custom_scope));\n         let _ = self.pop_scope();\n     }\n \n     /// Removes the top cleanup scope from the stack, which must be a temporary scope, and\n     /// generates the code to do its cleanups for normal exit.\n-    fn pop_and_trans_custom_cleanup_scope(&self,\n-                                          bcx: Block<'blk, 'tcx>,\n-                                          custom_scope: CustomScopeIndex)\n-                                          -> Block<'blk, 'tcx> {\n+    pub fn pop_and_trans_custom_cleanup_scope(&self,\n+                                              bcx: Block<'blk, 'tcx>,\n+                                              custom_scope: CustomScopeIndex)\n+                                              -> Block<'blk, 'tcx> {\n         debug!(\"pop_and_trans_custom_cleanup_scope({:?})\", custom_scope);\n         assert!(self.is_valid_to_pop_custom_scope(custom_scope));\n \n         let scope = self.pop_scope();\n         self.trans_scope_cleanups(bcx, &scope)\n     }\n \n-    /// Returns the id of the top-most loop scope\n-    fn top_loop_scope(&self) -> ast::NodeId {\n-        for scope in self.scopes.borrow().iter().rev() {\n-            if let LoopScopeKind(id, _) = scope.kind {\n-                return id;\n-            }\n-        }\n-        bug!(\"no loop scope found\");\n-    }\n-\n-    /// Returns a block to branch to which will perform all pending cleanups and\n-    /// then break/continue (depending on `exit`) out of the loop with id\n-    /// `cleanup_scope`\n-    fn normal_exit_block(&'blk self,\n-                         cleanup_scope: ast::NodeId,\n-                         exit: usize) -> BasicBlockRef {\n-        self.trans_cleanups_to_exit_scope(LoopExit(cleanup_scope, exit))\n-    }\n-\n-    /// Returns a block to branch to which will perform all pending cleanups and\n-    /// then return from this function\n-    fn return_exit_block(&'blk self) -> BasicBlockRef {\n-        self.trans_cleanups_to_exit_scope(ReturnExit)\n-    }\n-\n-    fn schedule_lifetime_end(&self,\n-                             cleanup_scope: ScopeId,\n-                             val: ValueRef) {\n-        let drop = box LifetimeEnd {\n-            ptr: val,\n-        };\n-\n-        debug!(\"schedule_lifetime_end({:?}, val={:?})\",\n-               cleanup_scope, Value(val));\n-\n-        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n-    }\n-\n     /// Schedules a (deep) drop of `val`, which is a pointer to an instance of\n     /// `ty`\n-    fn schedule_drop_mem(&self,\n-                         cleanup_scope: ScopeId,\n-                         val: ValueRef,\n-                         ty: Ty<'tcx>,\n-                         drop_hint: Option<DropHintDatum<'tcx>>) {\n+    pub fn schedule_drop_mem(&self,\n+                             cleanup_scope: CustomScopeIndex,\n+                             val: ValueRef,\n+                             ty: Ty<'tcx>) {\n         if !self.type_needs_drop(ty) { return; }\n-        let drop_hint = drop_hint.map(|hint|hint.to_value());\n-        let drop = box DropValue {\n+        let drop = DropValue {\n             is_immediate: false,\n             val: val,\n             ty: ty,\n-            fill_on_drop: false,\n             skip_dtor: false,\n-            drop_hint: drop_hint,\n         };\n \n-        debug!(\"schedule_drop_mem({:?}, val={:?}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n+        debug!(\"schedule_drop_mem({:?}, val={:?}, ty={:?}) skip_dtor={}\",\n                cleanup_scope,\n                Value(val),\n                ty,\n-               drop.fill_on_drop,\n                drop.skip_dtor);\n \n-        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n-    }\n-\n-    /// Schedules a (deep) drop and filling of `val`, which is a pointer to an instance of `ty`\n-    fn schedule_drop_and_fill_mem(&self,\n-                                  cleanup_scope: ScopeId,\n-                                  val: ValueRef,\n-                                  ty: Ty<'tcx>,\n-                                  drop_hint: Option<DropHintDatum<'tcx>>) {\n-        if !self.type_needs_drop(ty) { return; }\n-\n-        let drop_hint = drop_hint.map(|datum|datum.to_value());\n-        let drop = box DropValue {\n-            is_immediate: false,\n-            val: val,\n-            ty: ty,\n-            fill_on_drop: true,\n-            skip_dtor: false,\n-            drop_hint: drop_hint,\n-        };\n-\n-        debug!(\"schedule_drop_and_fill_mem({:?}, val={:?}, ty={:?},\n-                fill_on_drop={}, skip_dtor={}, has_drop_hint={})\",\n-               cleanup_scope,\n-               Value(val),\n-               ty,\n-               drop.fill_on_drop,\n-               drop.skip_dtor,\n-               drop_hint.is_some());\n-\n-        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n+        self.schedule_clean(cleanup_scope, drop);\n     }\n \n     /// Issue #23611: Schedules a (deep) drop of the contents of\n     /// `val`, which is a pointer to an instance of struct/enum type\n     /// `ty`. The scheduled code handles extracting the discriminant\n     /// and dropping the contents associated with that variant\n     /// *without* executing any associated drop implementation.\n-    fn schedule_drop_adt_contents(&self,\n-                                  cleanup_scope: ScopeId,\n-                                  val: ValueRef,\n-                                  ty: Ty<'tcx>) {\n+    pub fn schedule_drop_adt_contents(&self,\n+                                      cleanup_scope: CustomScopeIndex,\n+                                      val: ValueRef,\n+                                      ty: Ty<'tcx>) {\n         // `if` below could be \"!contents_needs_drop\"; skipping drop\n         // is just an optimization, so sound to be conservative.\n         if !self.type_needs_drop(ty) { return; }\n \n-        let drop = box DropValue {\n+        let drop = DropValue {\n             is_immediate: false,\n             val: val,\n             ty: ty,\n-            fill_on_drop: false,\n             skip_dtor: true,\n-            drop_hint: None,\n         };\n \n-        debug!(\"schedule_drop_adt_contents({:?}, val={:?}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n+        debug!(\"schedule_drop_adt_contents({:?}, val={:?}, ty={:?}) skip_dtor={}\",\n                cleanup_scope,\n                Value(val),\n                ty,\n-               drop.fill_on_drop,\n                drop.skip_dtor);\n \n-        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n+        self.schedule_clean(cleanup_scope, drop);\n     }\n \n     /// Schedules a (deep) drop of `val`, which is an instance of `ty`\n-    fn schedule_drop_immediate(&self,\n-                               cleanup_scope: ScopeId,\n-                               val: ValueRef,\n-                               ty: Ty<'tcx>) {\n+    pub fn schedule_drop_immediate(&self,\n+                                   cleanup_scope: CustomScopeIndex,\n+                                   val: ValueRef,\n+                                   ty: Ty<'tcx>) {\n \n         if !self.type_needs_drop(ty) { return; }\n-        let drop = Box::new(DropValue {\n+        let drop = DropValue {\n             is_immediate: true,\n             val: val,\n             ty: ty,\n-            fill_on_drop: false,\n             skip_dtor: false,\n-            drop_hint: None,\n-        });\n+        };\n \n-        debug!(\"schedule_drop_immediate({:?}, val={:?}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n+        debug!(\"schedule_drop_immediate({:?}, val={:?}, ty={:?}) skip_dtor={}\",\n                cleanup_scope,\n                Value(val),\n                ty,\n-               drop.fill_on_drop,\n                drop.skip_dtor);\n \n-        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n-    }\n-\n-    /// Schedules a call to `free(val)`. Note that this is a shallow operation.\n-    fn schedule_free_value(&self,\n-                           cleanup_scope: ScopeId,\n-                           val: ValueRef,\n-                           heap: Heap,\n-                           content_ty: Ty<'tcx>) {\n-        let drop = box FreeValue { ptr: val, heap: heap, content_ty: content_ty };\n-\n-        debug!(\"schedule_free_value({:?}, val={:?}, heap={:?})\",\n-               cleanup_scope, Value(val), heap);\n-\n-        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n-    }\n-\n-    fn schedule_clean(&self,\n-                      cleanup_scope: ScopeId,\n-                      cleanup: CleanupObj<'tcx>) {\n-        match cleanup_scope {\n-            AstScope(id) => self.schedule_clean_in_ast_scope(id, cleanup),\n-            CustomScope(id) => self.schedule_clean_in_custom_scope(id, cleanup),\n-        }\n-    }\n-\n-    /// Schedules a cleanup to occur upon exit from `cleanup_scope`. If `cleanup_scope` is not\n-    /// provided, then the cleanup is scheduled in the topmost scope, which must be a temporary\n-    /// scope.\n-    fn schedule_clean_in_ast_scope(&self,\n-                                   cleanup_scope: ast::NodeId,\n-                                   cleanup: CleanupObj<'tcx>) {\n-        debug!(\"schedule_clean_in_ast_scope(cleanup_scope={})\",\n-               cleanup_scope);\n-\n-        for scope in self.scopes.borrow_mut().iter_mut().rev() {\n-            if scope.kind.is_ast_with_id(cleanup_scope) {\n-                scope.cleanups.push(cleanup);\n-                scope.cached_landing_pad = None;\n-                return;\n-            } else {\n-                // will be adding a cleanup to some enclosing scope\n-                scope.clear_cached_exits();\n-            }\n-        }\n-\n-        bug!(\"no cleanup scope {} found\",\n-             self.ccx.tcx().map.node_to_string(cleanup_scope));\n+        self.schedule_clean(cleanup_scope, drop);\n     }\n \n     /// Schedules a cleanup to occur in the top-most scope, which must be a temporary scope.\n-    fn schedule_clean_in_custom_scope(&self,\n-                                      custom_scope: CustomScopeIndex,\n-                                      cleanup: CleanupObj<'tcx>) {\n+    fn schedule_clean(&self, custom_scope: CustomScopeIndex, cleanup: DropValue<'tcx>) {\n         debug!(\"schedule_clean_in_custom_scope(custom_scope={})\",\n                custom_scope.index);\n \n@@ -588,14 +289,14 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     }\n \n     /// Returns true if there are pending cleanups that should execute on panic.\n-    fn needs_invoke(&self) -> bool {\n+    pub fn needs_invoke(&self) -> bool {\n         self.scopes.borrow().iter().rev().any(|s| s.needs_invoke())\n     }\n \n     /// Returns a basic block to branch to in the event of a panic. This block\n     /// will run the panic cleanups and eventually resume the exception that\n     /// caused the landing pad to be run.\n-    fn get_landing_pad(&'blk self) -> BasicBlockRef {\n+    pub fn get_landing_pad(&'blk self) -> BasicBlockRef {\n         let _icx = base::push_ctxt(\"get_landing_pad\");\n \n         debug!(\"get_landing_pad\");\n@@ -625,25 +326,6 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n         return llbb;\n     }\n-}\n-\n-impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n-    /// Returns the id of the current top-most AST scope, if any.\n-    fn top_ast_scope(&self) -> Option<ast::NodeId> {\n-        for scope in self.scopes.borrow().iter().rev() {\n-            match scope.kind {\n-                CustomScopeKind | LoopScopeKind(..) => {}\n-                AstScopeKind(i) => {\n-                    return Some(i);\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n-    fn top_nonempty_cleanup_scope(&self) -> Option<usize> {\n-        self.scopes.borrow().iter().rev().position(|s| !s.cleanups.is_empty())\n-    }\n \n     fn is_valid_to_pop_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool {\n         self.is_valid_custom_scope(custom_scope) &&\n@@ -652,14 +334,13 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n \n     fn is_valid_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool {\n         let scopes = self.scopes.borrow();\n-        custom_scope.index < scopes.len() &&\n-            (*scopes)[custom_scope.index].kind.is_temp()\n+        custom_scope.index < scopes.len()\n     }\n \n     /// Generates the cleanups for `scope` into `bcx`\n     fn trans_scope_cleanups(&self, // cannot borrow self, will recurse\n                             bcx: Block<'blk, 'tcx>,\n-                            scope: &CleanupScope<'blk, 'tcx>) -> Block<'blk, 'tcx> {\n+                            scope: &CleanupScope<'tcx>) -> Block<'blk, 'tcx> {\n \n         let mut bcx = bcx;\n         if !bcx.unreachable.get() {\n@@ -674,19 +355,19 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         self.scopes.borrow().len()\n     }\n \n-    fn push_scope(&self, scope: CleanupScope<'blk, 'tcx>) {\n+    fn push_scope(&self, scope: CleanupScope<'tcx>) {\n         self.scopes.borrow_mut().push(scope)\n     }\n \n-    fn pop_scope(&self) -> CleanupScope<'blk, 'tcx> {\n+    fn pop_scope(&self) -> CleanupScope<'tcx> {\n         debug!(\"popping cleanup scope {}, {} scopes remaining\",\n                self.top_scope(|s| s.block_name(\"\")),\n                self.scopes_len() - 1);\n \n         self.scopes.borrow_mut().pop().unwrap()\n     }\n \n-    fn top_scope<R, F>(&self, f: F) -> R where F: FnOnce(&CleanupScope<'blk, 'tcx>) -> R {\n+    fn top_scope<R, F>(&self, f: F) -> R where F: FnOnce(&CleanupScope<'tcx>) -> R {\n         f(self.scopes.borrow().last().unwrap())\n     }\n \n@@ -738,7 +419,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                     UnwindExit(val) => {\n                         // Generate a block that will resume unwinding to the\n                         // calling function\n-                        let bcx = self.new_block(\"resume\", None);\n+                        let bcx = self.new_block(\"resume\");\n                         match val {\n                             UnwindKind::LandingPad => {\n                                 let addr = self.landingpad_alloca.get()\n@@ -755,15 +436,6 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                         prev_llbb = bcx.llbb;\n                         break;\n                     }\n-\n-                    ReturnExit => {\n-                        prev_llbb = self.get_llreturn();\n-                        break\n-                    }\n-\n-                    LoopExit(id, _) => {\n-                        bug!(\"cannot exit from scope {}, not in scope\", id);\n-                    }\n                 }\n             }\n \n@@ -782,20 +454,6 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 skip = last_cleanup;\n                 break;\n             }\n-\n-            // If we are searching for a loop exit,\n-            // and this scope is that loop, then stop popping and set\n-            // `prev_llbb` to the appropriate exit block from the loop.\n-            let scope = popped_scopes.last().unwrap();\n-            match label {\n-                UnwindExit(..) | ReturnExit => { }\n-                LoopExit(id, exit) => {\n-                    if let Some(exit) = scope.kind.early_exit_block(id, exit) {\n-                        prev_llbb = exit;\n-                        break\n-                    }\n-                }\n-            }\n         }\n \n         debug!(\"trans_cleanups_to_exit_scope: popped {} scopes\",\n@@ -826,7 +484,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 let name = scope.block_name(\"clean\");\n                 debug!(\"generating cleanups for {}\", name);\n \n-                let bcx_in = self.new_block(&name[..], None);\n+                let bcx_in = self.new_block(&name[..]);\n                 let exit_label = label.start(bcx_in);\n                 let mut bcx_out = bcx_in;\n                 let len = scope.cleanups.len();\n@@ -869,7 +527,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 Some(llbb) => return llbb,\n                 None => {\n                     let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.new_block(&name[..], None);\n+                    pad_bcx = self.new_block(&name[..]);\n                     last_scope.cached_landing_pad = Some(pad_bcx.llbb);\n                 }\n             }\n@@ -923,24 +581,16 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n     }\n }\n \n-impl<'blk, 'tcx> CleanupScope<'blk, 'tcx> {\n-    fn new(kind: CleanupScopeKind<'blk, 'tcx>,\n-           debug_loc: DebugLoc)\n-        -> CleanupScope<'blk, 'tcx> {\n+impl<'tcx> CleanupScope<'tcx> {\n+    fn new(debug_loc: DebugLoc) -> CleanupScope<'tcx> {\n         CleanupScope {\n-            kind: kind,\n             debug_loc: debug_loc,\n             cleanups: vec!(),\n             cached_early_exits: vec!(),\n             cached_landing_pad: None,\n         }\n     }\n \n-    fn clear_cached_exits(&mut self) {\n-        self.cached_early_exits = vec!();\n-        self.cached_landing_pad = None;\n-    }\n-\n     fn cached_early_exit(&self,\n                          label: EarlyExitLabel)\n                          -> Option<(BasicBlockRef, usize)> {\n@@ -961,62 +611,13 @@ impl<'blk, 'tcx> CleanupScope<'blk, 'tcx> {\n \n     /// True if this scope has cleanups that need unwinding\n     fn needs_invoke(&self) -> bool {\n-\n         self.cached_landing_pad.is_some() ||\n-            self.cleanups.iter().any(|c| c.must_unwind())\n+            !self.cleanups.is_empty()\n     }\n \n     /// Returns a suitable name to use for the basic block that handles this cleanup scope\n     fn block_name(&self, prefix: &str) -> String {\n-        match self.kind {\n-            CustomScopeKind => format!(\"{}_custom_\", prefix),\n-            AstScopeKind(id) => format!(\"{}_ast_{}_\", prefix, id),\n-            LoopScopeKind(id, _) => format!(\"{}_loop_{}_\", prefix, id),\n-        }\n-    }\n-\n-    /// Manipulate cleanup scope for call arguments. Conceptually, each\n-    /// argument to a call is an lvalue, and performing the call moves each\n-    /// of the arguments into a new rvalue (which gets cleaned up by the\n-    /// callee). As an optimization, instead of actually performing all of\n-    /// those moves, trans just manipulates the cleanup scope to obtain the\n-    /// same effect.\n-    pub fn drop_non_lifetime_clean(&mut self) {\n-        self.cleanups.retain(|c| c.is_lifetime_end());\n-        self.clear_cached_exits();\n-    }\n-}\n-\n-impl<'blk, 'tcx> CleanupScopeKind<'blk, 'tcx> {\n-    fn is_temp(&self) -> bool {\n-        match *self {\n-            CustomScopeKind => true,\n-            LoopScopeKind(..) | AstScopeKind(..) => false,\n-        }\n-    }\n-\n-    fn is_ast_with_id(&self, id: ast::NodeId) -> bool {\n-        match *self {\n-            CustomScopeKind | LoopScopeKind(..) => false,\n-            AstScopeKind(i) => i == id\n-        }\n-    }\n-\n-    fn is_loop_with_id(&self, id: ast::NodeId) -> bool {\n-        match *self {\n-            CustomScopeKind | AstScopeKind(..) => false,\n-            LoopScopeKind(i, _) => i == id\n-        }\n-    }\n-\n-    /// If this is a loop scope with id `id`, return the early exit block `exit`, else `None`\n-    fn early_exit_block(&self,\n-                        id: ast::NodeId,\n-                        exit: usize) -> Option<BasicBlockRef> {\n-        match *self {\n-            LoopScopeKind(i, ref exits) if id == i => Some(exits[exit].llbb),\n-            _ => None,\n-        }\n+        format!(\"{}_custom_\", prefix)\n     }\n }\n \n@@ -1057,7 +658,6 @@ impl EarlyExitLabel {\n                 bcx.lpad.set(Some(bcx.fcx.lpad_arena.alloc(LandingPad::gnu())));\n                 *self\n             }\n-            label => label,\n         }\n     }\n }\n@@ -1080,20 +680,10 @@ pub struct DropValue<'tcx> {\n     is_immediate: bool,\n     val: ValueRef,\n     ty: Ty<'tcx>,\n-    fill_on_drop: bool,\n     skip_dtor: bool,\n-    drop_hint: Option<DropHintValue>,\n }\n \n-impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n-    fn must_unwind(&self) -> bool {\n-        true\n-    }\n-\n-    fn is_lifetime_end(&self) -> bool {\n-        false\n-    }\n-\n+impl<'tcx> DropValue<'tcx> {\n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n                    debug_loc: DebugLoc)\n@@ -1107,180 +697,8 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n         let bcx = if self.is_immediate {\n             glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc, self.skip_dtor)\n         } else {\n-            glue::drop_ty_core(bcx, self.val, self.ty, debug_loc, self.skip_dtor, self.drop_hint)\n+            glue::drop_ty_core(bcx, self.val, self.ty, debug_loc, self.skip_dtor)\n         };\n-        if self.fill_on_drop {\n-            base::drop_done_fill_mem(bcx, self.val, self.ty);\n-        }\n         bcx\n     }\n }\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum Heap {\n-    HeapExchange\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct FreeValue<'tcx> {\n-    ptr: ValueRef,\n-    heap: Heap,\n-    content_ty: Ty<'tcx>\n-}\n-\n-impl<'tcx> Cleanup<'tcx> for FreeValue<'tcx> {\n-    fn must_unwind(&self) -> bool {\n-        true\n-    }\n-\n-    fn is_lifetime_end(&self) -> bool {\n-        false\n-    }\n-\n-    fn trans<'blk>(&self,\n-                   bcx: Block<'blk, 'tcx>,\n-                   debug_loc: DebugLoc)\n-                   -> Block<'blk, 'tcx> {\n-        match self.heap {\n-            HeapExchange => {\n-                glue::trans_exchange_free_ty(bcx,\n-                                             self.ptr,\n-                                             self.content_ty,\n-                                             debug_loc)\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct LifetimeEnd {\n-    ptr: ValueRef,\n-}\n-\n-impl<'tcx> Cleanup<'tcx> for LifetimeEnd {\n-    fn must_unwind(&self) -> bool {\n-        false\n-    }\n-\n-    fn is_lifetime_end(&self) -> bool {\n-        true\n-    }\n-\n-    fn trans<'blk>(&self,\n-                   bcx: Block<'blk, 'tcx>,\n-                   debug_loc: DebugLoc)\n-                   -> Block<'blk, 'tcx> {\n-        debug_loc.apply(bcx.fcx);\n-        base::call_lifetime_end(bcx, self.ptr);\n-        bcx\n-    }\n-}\n-\n-pub fn temporary_scope(tcx: TyCtxt,\n-                       id: ast::NodeId)\n-                       -> ScopeId {\n-    match tcx.region_maps.temporary_scope(id) {\n-        Some(scope) => {\n-            let r = AstScope(scope.node_id(&tcx.region_maps));\n-            debug!(\"temporary_scope({}) = {:?}\", id, r);\n-            r\n-        }\n-        None => {\n-            bug!(\"no temporary scope available for expr {}\", id)\n-        }\n-    }\n-}\n-\n-pub fn var_scope(tcx: TyCtxt,\n-                 id: ast::NodeId)\n-                 -> ScopeId {\n-    let r = AstScope(tcx.region_maps.var_scope(id).node_id(&tcx.region_maps));\n-    debug!(\"var_scope({}) = {:?}\", id, r);\n-    r\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// These traits just exist to put the methods into this file.\n-\n-pub trait CleanupMethods<'blk, 'tcx> {\n-    fn push_ast_cleanup_scope(&self, id: NodeIdAndSpan);\n-    fn push_loop_cleanup_scope(&self,\n-                               id: ast::NodeId,\n-                               exits: [Block<'blk, 'tcx>; EXIT_MAX]);\n-    fn push_custom_cleanup_scope(&self) -> CustomScopeIndex;\n-    fn push_custom_cleanup_scope_with_debug_loc(&self,\n-                                                debug_loc: NodeIdAndSpan)\n-                                                -> CustomScopeIndex;\n-    fn pop_and_trans_ast_cleanup_scope(&self,\n-                                       bcx: Block<'blk, 'tcx>,\n-                                       cleanup_scope: ast::NodeId)\n-                                       -> Block<'blk, 'tcx>;\n-    fn pop_loop_cleanup_scope(&self,\n-                              cleanup_scope: ast::NodeId);\n-    fn pop_custom_cleanup_scope(&self,\n-                                custom_scope: CustomScopeIndex);\n-    fn pop_and_trans_custom_cleanup_scope(&self,\n-                                          bcx: Block<'blk, 'tcx>,\n-                                          custom_scope: CustomScopeIndex)\n-                                          -> Block<'blk, 'tcx>;\n-    fn top_loop_scope(&self) -> ast::NodeId;\n-    fn normal_exit_block(&'blk self,\n-                         cleanup_scope: ast::NodeId,\n-                         exit: usize) -> BasicBlockRef;\n-    fn return_exit_block(&'blk self) -> BasicBlockRef;\n-    fn schedule_lifetime_end(&self,\n-                         cleanup_scope: ScopeId,\n-                         val: ValueRef);\n-    fn schedule_drop_mem(&self,\n-                         cleanup_scope: ScopeId,\n-                         val: ValueRef,\n-                         ty: Ty<'tcx>,\n-                         drop_hint: Option<DropHintDatum<'tcx>>);\n-    fn schedule_drop_and_fill_mem(&self,\n-                                  cleanup_scope: ScopeId,\n-                                  val: ValueRef,\n-                                  ty: Ty<'tcx>,\n-                                  drop_hint: Option<DropHintDatum<'tcx>>);\n-    fn schedule_drop_adt_contents(&self,\n-                                  cleanup_scope: ScopeId,\n-                                  val: ValueRef,\n-                                  ty: Ty<'tcx>);\n-    fn schedule_drop_immediate(&self,\n-                               cleanup_scope: ScopeId,\n-                               val: ValueRef,\n-                               ty: Ty<'tcx>);\n-    fn schedule_free_value(&self,\n-                           cleanup_scope: ScopeId,\n-                           val: ValueRef,\n-                           heap: Heap,\n-                           content_ty: Ty<'tcx>);\n-    fn schedule_clean(&self,\n-                      cleanup_scope: ScopeId,\n-                      cleanup: CleanupObj<'tcx>);\n-    fn schedule_clean_in_ast_scope(&self,\n-                                   cleanup_scope: ast::NodeId,\n-                                   cleanup: CleanupObj<'tcx>);\n-    fn schedule_clean_in_custom_scope(&self,\n-                                    custom_scope: CustomScopeIndex,\n-                                    cleanup: CleanupObj<'tcx>);\n-    fn needs_invoke(&self) -> bool;\n-    fn get_landing_pad(&'blk self) -> BasicBlockRef;\n-}\n-\n-trait CleanupHelperMethods<'blk, 'tcx> {\n-    fn top_ast_scope(&self) -> Option<ast::NodeId>;\n-    fn top_nonempty_cleanup_scope(&self) -> Option<usize>;\n-    fn is_valid_to_pop_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool;\n-    fn is_valid_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool;\n-    fn trans_scope_cleanups(&self,\n-                            bcx: Block<'blk, 'tcx>,\n-                            scope: &CleanupScope<'blk, 'tcx>) -> Block<'blk, 'tcx>;\n-    fn trans_cleanups_to_exit_scope(&'blk self,\n-                                    label: EarlyExitLabel)\n-                                    -> BasicBlockRef;\n-    fn get_or_create_landing_pad(&'blk self) -> BasicBlockRef;\n-    fn scopes_len(&self) -> usize;\n-    fn push_scope(&self, scope: CleanupScope<'blk, 'tcx>);\n-    fn pop_scope(&self) -> CleanupScope<'blk, 'tcx>;\n-    fn top_scope<R, F>(&self, f: F) -> R where F: FnOnce(&CleanupScope<'blk, 'tcx>) -> R;\n-}"}, {"sha": "842a8fddb83e199e03af4a917d117f6a38a236b2", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 21, "deletions": 233, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -10,113 +10,21 @@\n \n use arena::TypedArena;\n use back::symbol_names;\n-use llvm::{self, ValueRef, get_param, get_params};\n+use llvm::{self, ValueRef, get_params};\n use rustc::hir::def_id::DefId;\n use abi::{Abi, FnType};\n-use adt;\n use attributes;\n use base::*;\n-use build::*;\n-use callee::{self, ArgVals, Callee};\n-use cleanup::{CleanupMethods, CustomScope, ScopeId};\n+use callee::{self, Callee};\n use common::*;\n-use datum::{ByRef, Datum, lvalue_scratch_datum};\n-use datum::{rvalue_scratch_datum, Rvalue};\n-use debuginfo::{self, DebugLoc};\n+use debuginfo::{DebugLoc};\n use declare;\n-use expr;\n use monomorphize::{Instance};\n use value::Value;\n-use Disr;\n use rustc::ty::{self, Ty, TyCtxt};\n-use session::config::FullDebugInfo;\n-\n-use syntax::ast;\n \n use rustc::hir;\n \n-use libc::c_uint;\n-\n-fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                        closure_def_id: DefId,\n-                                        arg_scope_id: ScopeId,\n-                                        id: ast::NodeId) {\n-    let _icx = push_ctxt(\"closure::load_closure_environment\");\n-    let kind = kind_for_closure(bcx.ccx(), closure_def_id);\n-\n-    let env_arg = &bcx.fcx.fn_ty.args[0];\n-    let mut env_idx = bcx.fcx.fn_ty.ret.is_indirect() as usize;\n-\n-    // Special case for small by-value selfs.\n-    let llenv = if kind == ty::ClosureKind::FnOnce && !env_arg.is_indirect() {\n-        let closure_ty = node_id_type(bcx, id);\n-        let llenv = rvalue_scratch_datum(bcx, closure_ty, \"closure_env\").val;\n-        env_arg.store_fn_arg(&bcx.build(), &mut env_idx, llenv);\n-        llenv\n-    } else {\n-        get_param(bcx.fcx.llfn, env_idx as c_uint)\n-    };\n-\n-    // Store the pointer to closure data in an alloca for debug info because that's what the\n-    // llvm.dbg.declare intrinsic expects\n-    let env_pointer_alloca = if bcx.sess().opts.debuginfo == FullDebugInfo {\n-        let alloc = alloca(bcx, val_ty(llenv), \"__debuginfo_env_ptr\");\n-        Store(bcx, llenv, alloc);\n-        Some(alloc)\n-    } else {\n-        None\n-    };\n-\n-    bcx.tcx().with_freevars(id, |fv| {\n-        for (i, freevar) in fv.iter().enumerate() {\n-            let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n-                                        closure_expr_id: id };\n-            let upvar_capture = bcx.tcx().upvar_capture(upvar_id).unwrap();\n-            let mut upvar_ptr = StructGEP(bcx, llenv, i);\n-            let captured_by_ref = match upvar_capture {\n-                ty::UpvarCapture::ByValue => false,\n-                ty::UpvarCapture::ByRef(..) => {\n-                    upvar_ptr = Load(bcx, upvar_ptr);\n-                    true\n-                }\n-            };\n-            let node_id = freevar.def.var_id();\n-            bcx.fcx.llupvars.borrow_mut().insert(node_id, upvar_ptr);\n-\n-            if kind == ty::ClosureKind::FnOnce && !captured_by_ref {\n-                let hint = bcx.fcx.lldropflag_hints.borrow().hint_datum(upvar_id.var_id);\n-                bcx.fcx.schedule_drop_mem(arg_scope_id,\n-                                        upvar_ptr,\n-                                        node_id_type(bcx, node_id),\n-                                        hint)\n-            }\n-\n-            if let Some(env_pointer_alloca) = env_pointer_alloca {\n-                debuginfo::create_captured_var_metadata(\n-                    bcx,\n-                    node_id,\n-                    env_pointer_alloca,\n-                    i,\n-                    captured_by_ref,\n-                    freevar.span);\n-            }\n-        }\n-    })\n-}\n-\n-pub enum ClosureEnv {\n-    NotClosure,\n-    Closure(DefId, ast::NodeId),\n-}\n-\n-impl ClosureEnv {\n-    pub fn load<'blk,'tcx>(self, bcx: Block<'blk, 'tcx>, arg_scope: ScopeId) {\n-        if let ClosureEnv::Closure(def_id, id) = self {\n-            load_closure_environment(bcx, def_id, arg_scope, id);\n-        }\n-    }\n-}\n-\n fn get_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            closure_id: DefId,\n                            fn_ty: Ty<'tcx>)\n@@ -181,68 +89,15 @@ fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     llfn\n }\n \n-fn translating_closure_body_via_mir_will_fail(ccx: &CrateContext,\n-                                              closure_def_id: DefId)\n-                                              -> bool {\n-    let default_to_mir = ccx.sess().opts.debugging_opts.orbit;\n-    let invert = if default_to_mir { \"rustc_no_mir\" } else { \"rustc_mir\" };\n-    let use_mir = default_to_mir ^ ccx.tcx().has_attr(closure_def_id, invert);\n-\n-    !use_mir\n-}\n-\n pub fn trans_closure_body_via_mir<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                             closure_def_id: DefId,\n                                             closure_substs: ty::ClosureSubsts<'tcx>) {\n-    use syntax::ast::DUMMY_NODE_ID;\n-    use syntax_pos::DUMMY_SP;\n-    use syntax::ptr::P;\n-\n-    trans_closure_expr(Dest::Ignore(ccx),\n-                       &hir::FnDecl {\n-                           inputs: P::new(),\n-                           output: hir::Return(P(hir::Ty {\n-                               id: DUMMY_NODE_ID,\n-                               span: DUMMY_SP,\n-                               node: hir::Ty_::TyNever,\n-                           })),\n-                           variadic: false\n-                       },\n-                       &hir::Block {\n-                           stmts: P::new(),\n-                           expr: None,\n-                           id: DUMMY_NODE_ID,\n-                           rules: hir::DefaultBlock,\n-                           span: DUMMY_SP\n-                       },\n-                       DUMMY_NODE_ID,\n-                       closure_def_id,\n-                       closure_substs);\n-}\n-\n-pub enum Dest<'a, 'tcx: 'a> {\n-    SaveIn(Block<'a, 'tcx>, ValueRef),\n-    Ignore(&'a CrateContext<'a, 'tcx>)\n-}\n-\n-pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n-                                    decl: &hir::FnDecl,\n-                                    body: &hir::Block,\n-                                    id: ast::NodeId,\n-                                    closure_def_id: DefId, // (*)\n-                                    closure_substs: ty::ClosureSubsts<'tcx>)\n-                                    -> Option<Block<'a, 'tcx>>\n-{\n     // (*) Note that in the case of inlined functions, the `closure_def_id` will be the\n     // defid of the closure in its original crate, whereas `id` will be the id of the local\n     // inlined copy.\n-    debug!(\"trans_closure_expr(id={:?}, closure_def_id={:?}, closure_substs={:?})\",\n-           id, closure_def_id, closure_substs);\n+    debug!(\"trans_closure_body_via_mir(closure_def_id={:?}, closure_substs={:?})\",\n+           closure_def_id, closure_substs);\n \n-    let ccx = match dest {\n-        Dest::SaveIn(bcx, _) => bcx.ccx(),\n-        Dest::Ignore(ccx) => ccx\n-    };\n     let tcx = ccx.tcx();\n     let _icx = push_ctxt(\"closure::trans_closure_expr\");\n \n@@ -285,52 +140,13 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n         };\n \n         trans_closure(ccx,\n-                      decl,\n-                      body,\n                       llfn,\n                       Instance::new(closure_def_id, param_substs),\n-                      id,\n                       &sig,\n-                      Abi::RustCall,\n-                      ClosureEnv::Closure(closure_def_id, id));\n+                      Abi::RustCall);\n \n         ccx.instances().borrow_mut().insert(instance, llfn);\n     }\n-\n-    // Don't hoist this to the top of the function. It's perfectly legitimate\n-    // to have a zero-size closure (in which case dest will be `Ignore`) and\n-    // we must still generate the closure body.\n-    let (mut bcx, dest_addr) = match dest {\n-        Dest::SaveIn(bcx, p) => (bcx, p),\n-        Dest::Ignore(_) => {\n-            debug!(\"trans_closure_expr() ignoring result\");\n-            return None;\n-        }\n-    };\n-\n-    let repr = adt::represent_type(ccx, node_id_type(bcx, id));\n-\n-    // Create the closure.\n-    tcx.with_freevars(id, |fv| {\n-        for (i, freevar) in fv.iter().enumerate() {\n-            let datum = expr::trans_var(bcx, freevar.def);\n-            let upvar_slot_dest = adt::trans_field_ptr(\n-                bcx, &repr, adt::MaybeSizedValue::sized(dest_addr), Disr(0), i);\n-            let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n-                                        closure_expr_id: id };\n-            match tcx.upvar_capture(upvar_id).unwrap() {\n-                ty::UpvarCapture::ByValue => {\n-                    bcx = datum.store_to(bcx, upvar_slot_dest);\n-                }\n-                ty::UpvarCapture::ByRef(..) => {\n-                    Store(bcx, datum.to_llref(), upvar_slot_dest);\n-                }\n-            }\n-        }\n-    });\n-    adt::trans_set_discr(bcx, &repr, dest_addr, Disr(0));\n-\n-    Some(bcx)\n }\n \n pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n@@ -347,32 +163,7 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     if !ccx.sess().target.target.options.allows_weak_linkage &&\n        !ccx.sess().opts.single_codegen_unit() {\n \n-        if let Some(node_id) = ccx.tcx().map.as_local_node_id(closure_def_id) {\n-            // If the closure is defined in the local crate, we can always just\n-            // translate it.\n-            let (decl, body) = match ccx.tcx().map.expect_expr(node_id).node {\n-                hir::ExprClosure(_, ref decl, ref body, _) => (decl, body),\n-                _ => { unreachable!() }\n-            };\n-\n-            trans_closure_expr(Dest::Ignore(ccx),\n-                               decl,\n-                               body,\n-                               node_id,\n-                               closure_def_id,\n-                               substs);\n-        } else {\n-            // If the closure is defined in an upstream crate, we can only\n-            // translate it if MIR-trans is active.\n-\n-            if translating_closure_body_via_mir_will_fail(ccx, closure_def_id) {\n-                ccx.sess().fatal(\"You have run into a known limitation of the \\\n-                                  MingW toolchain. Either compile with -Zorbit or \\\n-                                  with -Ccodegen-units=1 to work around it.\");\n-            }\n-\n-            trans_closure_body_via_mir(ccx, closure_def_id, substs);\n-        }\n+        trans_closure_body_via_mir(ccx, closure_def_id, substs);\n     }\n \n     // If the closure is a Fn closure, but a FnOnce is needed (etc),\n@@ -472,28 +263,21 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n     fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None, &block_arena);\n-    let mut bcx = fcx.init(false, None);\n+    let mut bcx = fcx.init(false);\n \n \n     // the first argument (`self`) will be the (by value) closure env.\n-    let self_scope = fcx.push_custom_cleanup_scope();\n-    let self_scope_id = CustomScope(self_scope);\n \n     let mut llargs = get_params(fcx.llfn);\n     let mut self_idx = fcx.fn_ty.ret.is_indirect() as usize;\n     let env_arg = &fcx.fn_ty.args[0];\n     let llenv = if env_arg.is_indirect() {\n-        Datum::new(llargs[self_idx], closure_ty, Rvalue::new(ByRef))\n-            .add_clean(&fcx, self_scope_id)\n+        llargs[self_idx]\n     } else {\n-        unpack_datum!(bcx, lvalue_scratch_datum(bcx, closure_ty, \"self\",\n-                                                InitAlloca::Dropped,\n-                                                self_scope_id, |bcx, llval| {\n-            let mut llarg_idx = self_idx;\n-            env_arg.store_fn_arg(&bcx.build(), &mut llarg_idx, llval);\n-            bcx.fcx.schedule_lifetime_end(self_scope_id, llval);\n-            bcx\n-        })).val\n+        let scratch = alloc_ty(bcx, closure_ty, \"self\");\n+        let mut llarg_idx = self_idx;\n+        env_arg.store_fn_arg(&bcx.build(), &mut llarg_idx, scratch);\n+        scratch\n     };\n \n     debug!(\"trans_fn_once_adapter_shim: env={:?}\", Value(llenv));\n@@ -510,15 +294,19 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n         llargs[self_idx] = llenv;\n     }\n \n-    let dest =\n-        fcx.llretslotptr.get().map(\n-            |_| expr::SaveIn(fcx.get_ret_slot(bcx, \"ret_slot\")));\n+    let dest = fcx.llretslotptr.get();\n \n     let callee = Callee {\n         data: callee::Fn(llreffn),\n         ty: llref_fn_ty\n     };\n-    bcx = callee.call(bcx, DebugLoc::None, ArgVals(&llargs[self_idx..]), dest).bcx;\n+\n+    // Call the by-ref closure body with `self` in a cleanup scope,\n+    // to drop `self` when the body returns, or in case it unwinds.\n+    let self_scope = fcx.push_custom_cleanup_scope();\n+    fcx.schedule_drop_mem(self_scope, llenv, closure_ty);\n+\n+    bcx = callee.call(bcx, DebugLoc::None, &llargs[self_idx..], dest).bcx;\n \n     fcx.pop_and_trans_custom_cleanup_scope(bcx, self_scope);\n "}, {"sha": "c5053e4feee6200bc7e98e511f93bdc6a07a1312", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 6, "deletions": 204, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -16,7 +16,6 @@ use session::Session;\n use llvm;\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef, TypeKind};\n use llvm::{True, False, Bool, OperandBundleDef};\n-use rustc::cfg;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n@@ -30,7 +29,6 @@ use builder::Builder;\n use callee::Callee;\n use cleanup;\n use consts;\n-use datum;\n use debuginfo::{self, DebugLoc};\n use declare;\n use machine;\n@@ -43,7 +41,6 @@ use rustc::ty::layout::Layout;\n use rustc::traits::{self, SelectionContext, Reveal};\n use rustc::ty::fold::TypeFoldable;\n use rustc::hir;\n-use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n use libc::{c_uint, c_char};\n@@ -202,16 +199,6 @@ pub fn gensym_name(name: &str) -> ast::Name {\n \n use Disr;\n \n-#[derive(Copy, Clone)]\n-pub struct NodeIdAndSpan {\n-    pub id: ast::NodeId,\n-    pub span: Span,\n-}\n-\n-pub fn expr_info(expr: &hir::Expr) -> NodeIdAndSpan {\n-    NodeIdAndSpan { id: expr.id, span: expr.span }\n-}\n-\n /// The concrete version of ty::FieldDef. The name is the field index if\n /// the field is numeric.\n pub struct Field<'tcx>(pub ast::Name, pub Ty<'tcx>);\n@@ -257,17 +244,6 @@ impl<'a, 'tcx> VariantInfo<'tcx> {\n             }\n         }\n     }\n-\n-    /// Return the variant corresponding to a given node (e.g. expr)\n-    pub fn of_node(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>, id: ast::NodeId) -> Self {\n-        Self::from_ty(tcx, ty, Some(tcx.expect_def(id)))\n-    }\n-\n-    pub fn field_index(&self, name: ast::Name) -> usize {\n-        self.fields.iter().position(|&Field(n,_)| n == name).unwrap_or_else(|| {\n-            bug!(\"unknown field `{}`\", name)\n-        })\n-    }\n }\n \n pub struct BuilderRef_res {\n@@ -292,37 +268,6 @@ pub fn validate_substs(substs: &Substs) {\n     assert!(!substs.types.needs_infer());\n }\n \n-// work around bizarre resolve errors\n-type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n-pub type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n-\n-#[derive(Clone, Debug)]\n-struct HintEntry<'tcx> {\n-    // The datum for the dropflag-hint itself; note that many\n-    // source-level Lvalues will be associated with the same\n-    // dropflag-hint datum.\n-    datum: cleanup::DropHintDatum<'tcx>,\n-}\n-\n-pub struct DropFlagHintsMap<'tcx> {\n-    // Maps NodeId for expressions that read/write unfragmented state\n-    // to that state's drop-flag \"hint.\"  (A stack-local hint\n-    // indicates either that (1.) it is certain that no-drop is\n-    // needed, or (2.)  inline drop-flag must be consulted.)\n-    node_map: NodeMap<HintEntry<'tcx>>,\n-}\n-\n-impl<'tcx> DropFlagHintsMap<'tcx> {\n-    pub fn new() -> DropFlagHintsMap<'tcx> { DropFlagHintsMap { node_map: NodeMap() } }\n-    pub fn has_hint(&self, id: ast::NodeId) -> bool { self.node_map.contains_key(&id) }\n-    pub fn insert(&mut self, id: ast::NodeId, datum: cleanup::DropHintDatum<'tcx>) {\n-        self.node_map.insert(id, HintEntry { datum: datum });\n-    }\n-    pub fn hint_datum(&self, id: ast::NodeId) -> Option<cleanup::DropHintDatum<'tcx>> {\n-        self.node_map.get(&id).map(|t|t.datum)\n-    }\n-}\n-\n // Function context.  Every LLVM function we create will have one of\n // these.\n pub struct FunctionContext<'a, 'tcx: 'a> {\n@@ -352,12 +297,6 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // A marker for the place where we want to insert the function's static\n     // allocas, so that LLVM will coalesce them into a single alloca call.\n     pub alloca_insert_pt: Cell<Option<ValueRef>>,\n-    pub llreturn: Cell<Option<BasicBlockRef>>,\n-\n-    // If the function has any nested return's, including something like:\n-    // fn foo() -> Option<Foo> { Some(Foo { x: return None }) }, then\n-    // we use a separate alloca for each return\n-    pub needs_ret_allocas: bool,\n \n     // When working with landingpad-based exceptions this value is alloca'd and\n     // later loaded when using the resume instruction. This ends up being\n@@ -367,17 +306,6 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // Note that for cleanuppad-based exceptions this is not used.\n     pub landingpad_alloca: Cell<Option<ValueRef>>,\n \n-    // Maps the DefId's for local variables to the allocas created for\n-    // them in llallocas.\n-    pub lllocals: RefCell<NodeMap<LvalueDatum<'tcx>>>,\n-\n-    // Same as above, but for closure upvars\n-    pub llupvars: RefCell<NodeMap<ValueRef>>,\n-\n-    // Carries info about drop-flags for local bindings (longer term,\n-    // paths) for the code being compiled.\n-    pub lldropflag_hints: RefCell<DropFlagHintsMap<'tcx>>,\n-\n     // Describes the return/argument LLVM types and their ABI handling.\n     pub fn_ty: FnType,\n \n@@ -402,9 +330,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     pub debug_context: debuginfo::FunctionDebugContext,\n \n     // Cleanup scopes.\n-    pub scopes: RefCell<Vec<cleanup::CleanupScope<'a, 'tcx>>>,\n-\n-    pub cfg: Option<cfg::CFG>,\n+    pub scopes: RefCell<Vec<cleanup::CleanupScope<'tcx>>>,\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n@@ -420,70 +346,18 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn get_llreturn(&self) -> BasicBlockRef {\n-        if self.llreturn.get().is_none() {\n-\n-            self.llreturn.set(Some(unsafe {\n-                llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(), self.llfn,\n-                                                    \"return\\0\".as_ptr() as *const _)\n-            }))\n-        }\n-\n-        self.llreturn.get().unwrap()\n-    }\n-\n-    pub fn get_ret_slot(&self, bcx: Block<'a, 'tcx>, name: &str) -> ValueRef {\n-        if self.needs_ret_allocas {\n-            base::alloca(bcx, self.fn_ty.ret.memory_ty(self.ccx), name)\n-        } else {\n-            self.llretslotptr.get().unwrap()\n-        }\n-    }\n-\n     pub fn new_block(&'a self,\n-                     name: &str,\n-                     opt_node_id: Option<ast::NodeId>)\n+                     name: &str)\n                      -> Block<'a, 'tcx> {\n         unsafe {\n             let name = CString::new(name).unwrap();\n             let llbb = llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n                                                            self.llfn,\n                                                            name.as_ptr());\n-            BlockS::new(llbb, opt_node_id, self)\n+            BlockS::new(llbb, self)\n         }\n     }\n \n-    pub fn new_id_block(&'a self,\n-                        name: &str,\n-                        node_id: ast::NodeId)\n-                        -> Block<'a, 'tcx> {\n-        self.new_block(name, Some(node_id))\n-    }\n-\n-    pub fn new_temp_block(&'a self,\n-                          name: &str)\n-                          -> Block<'a, 'tcx> {\n-        self.new_block(name, None)\n-    }\n-\n-    pub fn join_blocks(&'a self,\n-                       id: ast::NodeId,\n-                       in_cxs: &[Block<'a, 'tcx>])\n-                       -> Block<'a, 'tcx> {\n-        let out = self.new_id_block(\"join\", id);\n-        let mut reachable = false;\n-        for bcx in in_cxs {\n-            if !bcx.unreachable.get() {\n-                build::Br(*bcx, out.llbb, DebugLoc::None);\n-                reachable = true;\n-            }\n-        }\n-        if !reachable {\n-            build::Unreachable(out);\n-        }\n-        return out;\n-    }\n-\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n@@ -523,7 +397,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         let tcx = ccx.tcx();\n         match tcx.lang_items.eh_personality() {\n             Some(def_id) if !base::wants_msvc_seh(ccx.sess()) => {\n-                Callee::def(ccx, def_id, Substs::empty(tcx)).reify(ccx).val\n+                Callee::def(ccx, def_id, Substs::empty(tcx)).reify(ccx)\n             }\n             _ => {\n                 if let Some(llpersonality) = ccx.eh_personality().get() {\n@@ -565,12 +439,12 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n \n         let unwresume = ccx.eh_unwind_resume();\n         if let Some(llfn) = unwresume.get() {\n-            return Callee::ptr(datum::immediate_rvalue(llfn, ty));\n+            return Callee::ptr(llfn, ty);\n         }\n         let llfn = declare::declare_fn(ccx, \"rust_eh_unwind_resume\", ty);\n         attributes::unwind(llfn, true);\n         unwresume.set(Some(llfn));\n-        Callee::ptr(datum::immediate_rvalue(llfn, ty))\n+        Callee::ptr(llfn, ty)\n     }\n }\n \n@@ -593,10 +467,6 @@ pub struct BlockS<'blk, 'tcx: 'blk> {\n     // kind of landing pad its in, otherwise this is none.\n     pub lpad: Cell<Option<&'blk LandingPad>>,\n \n-    // AST node-id associated with this block, if any. Used for\n-    // debugging purposes only.\n-    pub opt_node_id: Option<ast::NodeId>,\n-\n     // The function context for the function to which this block is\n     // attached.\n     pub fcx: &'blk FunctionContext<'blk, 'tcx>,\n@@ -606,15 +476,13 @@ pub type Block<'blk, 'tcx> = &'blk BlockS<'blk, 'tcx>;\n \n impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     pub fn new(llbb: BasicBlockRef,\n-               opt_node_id: Option<ast::NodeId>,\n                fcx: &'blk FunctionContext<'blk, 'tcx>)\n                -> Block<'blk, 'tcx> {\n         fcx.block_arena.alloc(BlockS {\n             llbb: llbb,\n             terminated: Cell::new(false),\n             unreachable: Cell::new(false),\n             lpad: Cell::new(None),\n-            opt_node_id: opt_node_id,\n             fcx: fcx\n         })\n     }\n@@ -883,13 +751,6 @@ pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n     }\n }\n \n-pub fn C_floating(s: &str, t: Type) -> ValueRef {\n-    unsafe {\n-        let s = CString::new(s).unwrap();\n-        llvm::LLVMConstRealOfString(t.to_ref(), s.as_ptr())\n-    }\n-}\n-\n pub fn C_floating_f64(f: f64, t: Type) -> ValueRef {\n     unsafe {\n         llvm::LLVMConstReal(t.to_ref(), f)\n@@ -916,19 +777,6 @@ pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n     C_integral(Type::i64(ccx), i, false)\n }\n \n-pub fn C_int<I: AsI64>(ccx: &CrateContext, i: I) -> ValueRef {\n-    let v = i.as_i64();\n-\n-    let bit_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n-\n-    if bit_size < 64 {\n-        // make sure it doesn't overflow\n-        assert!(v < (1<<(bit_size-1)) && v >= -(1<<(bit_size-1)));\n-    }\n-\n-    C_integral(ccx.int_type(), v as u64, true)\n-}\n-\n pub fn C_uint<I: AsU64>(ccx: &CrateContext, i: I) -> ValueRef {\n     let v = i.as_u64();\n \n@@ -1099,24 +947,6 @@ pub fn is_null(val: ValueRef) -> bool {\n     }\n }\n \n-pub fn monomorphize_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n-    bcx.fcx.monomorphize(&t)\n-}\n-\n-pub fn node_id_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n-    let tcx = bcx.tcx();\n-    let t = tcx.node_id_to_type(id);\n-    monomorphize_type(bcx, t)\n-}\n-\n-pub fn expr_ty<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &hir::Expr) -> Ty<'tcx> {\n-    node_id_type(bcx, ex.id)\n-}\n-\n-pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &hir::Expr) -> Ty<'tcx> {\n-    monomorphize_type(bcx, bcx.tcx().expr_ty_adjusted(ex))\n-}\n-\n /// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n /// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n /// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n@@ -1230,34 +1060,6 @@ pub fn langcall(tcx: TyCtxt,\n     }\n }\n \n-/// Return the VariantDef corresponding to an inlined variant node\n-pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                     inlined_vid: ast::NodeId)\n-                                     -> ty::VariantDef<'tcx>\n-{\n-    let ctor_ty = ccx.tcx().node_id_to_type(inlined_vid);\n-    debug!(\"inlined_variant_def: ctor_ty={:?} inlined_vid={:?}\", ctor_ty,\n-           inlined_vid);\n-    let adt_def = match ctor_ty.sty {\n-        ty::TyFnDef(_, _, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n-            output, ..\n-        }), ..}) => output,\n-        _ => ctor_ty\n-    }.ty_adt_def().unwrap();\n-    let variant_def_id = if ccx.tcx().map.is_inlined_node_id(inlined_vid) {\n-        ccx.defid_for_inlined_node(inlined_vid).unwrap()\n-    } else {\n-        ccx.tcx().map.local_def_id(inlined_vid)\n-    };\n-\n-    adt_def.variants\n-           .iter()\n-           .find(|v| variant_def_id == v.did)\n-           .unwrap_or_else(|| {\n-                bug!(\"no variant for {:?}::{}\", adt_def, inlined_vid)\n-            })\n-}\n-\n // To avoid UB from LLVM, these two functions mask RHS with an\n // appropriate mask unconditionally (i.e. the fallback behavior for\n // all shifts). For 32- and 64-bit types, this matches the semantics"}, {"sha": "fa1e008d496e45d08eb99d2df2ae5cdc1e859b6b", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 25, "deletions": 969, "changes": 994, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -11,98 +11,26 @@\n \n use llvm;\n use llvm::{SetUnnamedAddr};\n-use llvm::{InternalLinkage, ValueRef, Bool, True};\n-use middle::const_qualif::ConstQualif;\n-use rustc_const_eval::{ConstEvalErr, lookup_const_fn_by_id, lookup_const_by_id, ErrKind};\n-use rustc_const_eval::{eval_length, report_const_eval_err, note_const_eval_err};\n-use rustc::hir::def::Def;\n+use llvm::{InternalLinkage, ValueRef, True};\n+use rustc_const_eval::ConstEvalErr;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n-use {abi, adt, closure, debuginfo, expr, machine};\n+use {debuginfo, machine};\n use base::{self, push_ctxt};\n-use callee::Callee;\n use trans_item::TransItem;\n-use common::{type_is_sized, C_nil, const_get_elt};\n-use common::{CrateContext, C_integral, C_floating, C_bool, C_str_slice, C_bytes, val_ty};\n-use common::{C_struct, C_undef, const_to_opt_int, const_to_opt_uint, VariantInfo, C_uint};\n-use common::{type_is_fat_ptr, Field, C_vector, C_array, C_null};\n-use datum::{Datum, Lvalue};\n+use common::{CrateContext, val_ty};\n use declare;\n-use monomorphize::{self, Instance};\n+use monomorphize::{Instance};\n use type_::Type;\n use type_of;\n-use value::Value;\n-use Disr;\n-use rustc::ty::subst::Substs;\n-use rustc::ty::adjustment::{AdjustNeverToAny, AdjustDerefRef, AdjustReifyFnPointer};\n-use rustc::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::cast::{CastTy,IntTy};\n-use util::nodemap::NodeMap;\n-use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n+use rustc::ty;\n \n use rustc::hir;\n \n use std::ffi::{CStr, CString};\n-use libc::c_uint;\n-use syntax::ast::{self, LitKind};\n+use syntax::ast;\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::parse::token;\n-use syntax::ptr::P;\n-use syntax_pos::Span;\n-\n-pub type FnArgMap<'a> = Option<&'a NodeMap<ValueRef>>;\n-\n-pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &ast::Lit)\n-    -> ValueRef {\n-    let _icx = push_ctxt(\"trans_lit\");\n-    debug!(\"const_lit: {:?}\", lit);\n-    match lit.node {\n-        LitKind::Byte(b) => C_integral(Type::uint_from_ty(cx, ast::UintTy::U8), b as u64, false),\n-        LitKind::Char(i) => C_integral(Type::char(cx), i as u64, false),\n-        LitKind::Int(i, ast::LitIntType::Signed(t)) => {\n-            C_integral(Type::int_from_ty(cx, t), i, true)\n-        }\n-        LitKind::Int(u, ast::LitIntType::Unsigned(t)) => {\n-            C_integral(Type::uint_from_ty(cx, t), u, false)\n-        }\n-        LitKind::Int(i, ast::LitIntType::Unsuffixed) => {\n-            let lit_int_ty = cx.tcx().node_id_to_type(e.id);\n-            match lit_int_ty.sty {\n-                ty::TyInt(t) => {\n-                    C_integral(Type::int_from_ty(cx, t), i as u64, true)\n-                }\n-                ty::TyUint(t) => {\n-                    C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n-                }\n-                _ => span_bug!(lit.span,\n-                        \"integer literal has type {:?} (expected int \\\n-                         or usize)\",\n-                        lit_int_ty)\n-            }\n-        }\n-        LitKind::Float(ref fs, t) => {\n-            C_floating(&fs, Type::float_from_ty(cx, t))\n-        }\n-        LitKind::FloatUnsuffixed(ref fs) => {\n-            let lit_float_ty = cx.tcx().node_id_to_type(e.id);\n-            match lit_float_ty.sty {\n-                ty::TyFloat(t) => {\n-                    C_floating(&fs, Type::float_from_ty(cx, t))\n-                }\n-                _ => {\n-                    span_bug!(lit.span,\n-                        \"floating point literal doesn't have the right type\");\n-                }\n-            }\n-        }\n-        LitKind::Bool(b) => C_bool(cx, b),\n-        LitKind::Str(ref s, _) => C_str_slice(cx, (*s).clone()),\n-        LitKind::ByteStr(ref data) => {\n-            addr_of(cx, C_bytes(cx, &data[..]), 1, \"byte_str\")\n-        }\n-    }\n-}\n \n pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {\n     unsafe {\n@@ -154,868 +82,13 @@ pub fn addr_of(ccx: &CrateContext,\n     gv\n }\n \n-/// Deref a constant pointer\n-pub fn load_const(cx: &CrateContext, v: ValueRef, t: Ty) -> ValueRef {\n-    let v = match cx.const_unsized().borrow().get(&v) {\n-        Some(&v) => v,\n-        None => v\n-    };\n-    let d = unsafe { llvm::LLVMGetInitializer(v) };\n-    if !d.is_null() && t.is_bool() {\n-        unsafe { llvm::LLVMConstTrunc(d, Type::i1(cx).to_ref()) }\n-    } else {\n-        d\n-    }\n-}\n-\n-fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                         v: ValueRef,\n-                         ty: Ty<'tcx>)\n-                         -> (ValueRef, Ty<'tcx>) {\n-    match ty.builtin_deref(true, ty::NoPreference) {\n-        Some(mt) => {\n-            if type_is_sized(cx.tcx(), mt.ty) {\n-                (load_const(cx, v, mt.ty), mt.ty)\n-            } else {\n-                // Derefing a fat pointer does not change the representation,\n-                // just the type to the unsized contents.\n-                (v, mt.ty)\n-            }\n-        }\n-        None => {\n-            bug!(\"unexpected dereferenceable type {:?}\", ty)\n-        }\n-    }\n-}\n-\n-fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                           def_id: DefId,\n-                           substs: &'tcx Substs<'tcx>,\n-                           arg_vals: &[ValueRef],\n-                           param_substs: &'tcx Substs<'tcx>,\n-                           trueconst: TrueConst) -> Result<ValueRef, ConstEvalFailure> {\n-    let fn_like = lookup_const_fn_by_id(ccx.tcx(), def_id);\n-    let fn_like = fn_like.expect(\"lookup_const_fn_by_id failed in const_fn_call\");\n-\n-    let body = match fn_like.body().expr {\n-        Some(ref expr) => expr,\n-        None => return Ok(C_nil(ccx))\n-    };\n-\n-    let args = &fn_like.decl().inputs;\n-    assert_eq!(args.len(), arg_vals.len());\n-\n-    let arg_ids = args.iter().map(|arg| arg.pat.id);\n-    let fn_args = arg_ids.zip(arg_vals.iter().cloned()).collect();\n-\n-    let substs = ccx.tcx().erase_regions(&substs);\n-    let substs = monomorphize::apply_param_substs(ccx.tcx(),\n-                                                  param_substs,\n-                                                  &substs);\n-\n-    const_expr(ccx, body, substs, Some(&fn_args), trueconst).map(|(res, _)| res)\n-}\n-\n-pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                def_id: DefId,\n-                                ref_expr: &hir::Expr,\n-                                param_substs: &'tcx Substs<'tcx>)\n-                                -> &'tcx hir::Expr {\n-    let substs = ccx.tcx().node_id_item_substs(ref_expr.id).substs;\n-    let substs = ccx.tcx().erase_regions(&substs);\n-    let substs = monomorphize::apply_param_substs(ccx.tcx(),\n-                                                  param_substs,\n-                                                  &substs);\n-    match lookup_const_by_id(ccx.tcx(), def_id, Some(substs)) {\n-        Some((ref expr, _ty)) => expr,\n-        None => {\n-            span_bug!(ref_expr.span, \"constant item not found\")\n-        }\n-    }\n-}\n-\n-pub enum ConstEvalFailure {\n-    /// in case the const evaluator failed on something that panic at runtime\n-    /// as defined in RFC 1229\n-    Runtime(ConstEvalErr),\n-    // in case we found a true constant\n-    Compiletime(ConstEvalErr),\n-}\n-\n-impl ConstEvalFailure {\n-    fn into_inner(self) -> ConstEvalErr {\n-        match self {\n-            Runtime(e) => e,\n-            Compiletime(e) => e,\n-        }\n-    }\n-\n-    pub fn as_inner(&self) -> &ConstEvalErr {\n-        match self {\n-            &Runtime(ref e) => e,\n-            &Compiletime(ref e) => e,\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub enum TrueConst {\n-    Yes, No\n-}\n-\n-use self::ConstEvalFailure::*;\n-\n-fn get_const_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                           def_id: DefId,\n-                           ref_expr: &hir::Expr,\n-                           param_substs: &'tcx Substs<'tcx>)\n-                           -> Result<ValueRef, ConstEvalFailure> {\n-    let expr = get_const_expr(ccx, def_id, ref_expr, param_substs);\n-    let empty_substs = Substs::empty(ccx.tcx());\n-    match get_const_expr_as_global(ccx, expr, ConstQualif::empty(), empty_substs, TrueConst::Yes) {\n-        Err(Runtime(err)) => {\n-            report_const_eval_err(ccx.tcx(), &err, expr.span, \"expression\").emit();\n-            Err(Compiletime(err))\n-        },\n-        other => other,\n-    }\n-}\n-\n-pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                          expr: &hir::Expr,\n-                                          qualif: ConstQualif,\n-                                          param_substs: &'tcx Substs<'tcx>,\n-                                          trueconst: TrueConst)\n-                                          -> Result<ValueRef, ConstEvalFailure> {\n-    debug!(\"get_const_expr_as_global: {:?}\", expr.id);\n-    // Special-case constants to cache a common global for all uses.\n-    if let hir::ExprPath(..) = expr.node {\n-        // `def` must be its own statement and cannot be in the `match`\n-        // otherwise the `def_map` will be borrowed for the entire match instead\n-        // of just to get the `def` value\n-        match ccx.tcx().expect_def(expr.id) {\n-            Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                if !ccx.tcx().tables.borrow().adjustments.contains_key(&expr.id) {\n-                    debug!(\"get_const_expr_as_global ({:?}): found const {:?}\",\n-                           expr.id, def_id);\n-                    return get_const_val(ccx, def_id, expr, param_substs);\n-                }\n-            },\n-            _ => {},\n-        }\n-    }\n-\n-    let key = (expr.id, param_substs);\n-    if let Some(&val) = ccx.const_values().borrow().get(&key) {\n-        return Ok(val);\n-    }\n-    let ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs,\n-                                              &ccx.tcx().expr_ty(expr));\n-    let val = if qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n-        // Avoid autorefs as they would create global instead of stack\n-        // references, even when only the latter are correct.\n-        const_expr_unadjusted(ccx, expr, ty, param_substs, None, trueconst)?\n-    } else {\n-        const_expr(ccx, expr, param_substs, None, trueconst)?.0\n-    };\n-\n-    // boolean SSA values are i1, but they have to be stored in i8 slots,\n-    // otherwise some LLVM optimization passes don't work as expected\n-    let val = unsafe {\n-        if llvm::LLVMTypeOf(val) == Type::i1(ccx).to_ref() {\n-            llvm::LLVMConstZExt(val, Type::i8(ccx).to_ref())\n-        } else {\n-            val\n-        }\n-    };\n-\n-    let lvalue = addr_of(ccx, val, type_of::align_of(ccx, ty), \"const\");\n-    ccx.const_values().borrow_mut().insert(key, lvalue);\n-    Ok(lvalue)\n-}\n-\n-pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                            e: &hir::Expr,\n-                            param_substs: &'tcx Substs<'tcx>,\n-                            fn_args: FnArgMap,\n-                            trueconst: TrueConst)\n-                            -> Result<(ValueRef, Ty<'tcx>), ConstEvalFailure> {\n-    let ety = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n-                                               &cx.tcx().expr_ty(e));\n-    let llconst = const_expr_unadjusted(cx, e, ety, param_substs, fn_args, trueconst)?;\n-    let mut llconst = llconst;\n-    let mut ety_adjusted = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n-                                                            &cx.tcx().expr_ty_adjusted(e));\n-    let opt_adj = cx.tcx().tables.borrow().adjustments.get(&e.id).cloned();\n-    match opt_adj {\n-        Some(AdjustNeverToAny(..)) => span_bug!(e.span, \"const expression of type ! encountered\"),\n-        Some(AdjustReifyFnPointer) => {\n-            match ety.sty {\n-                ty::TyFnDef(def_id, substs, _) => {\n-                    llconst = Callee::def(cx, def_id, substs).reify(cx).val;\n-                }\n-                _ => {\n-                    bug!(\"{} cannot be reified to a fn ptr\", ety)\n-                }\n-            }\n-        }\n-        Some(AdjustUnsafeFnPointer) | Some(AdjustMutToConstPointer) => {\n-            // purely a type-level thing\n-        }\n-        Some(AdjustDerefRef(adj)) => {\n-            let mut ty = ety;\n-            // Save the last autoderef in case we can avoid it.\n-            if adj.autoderefs > 0 {\n-                for _ in 0..adj.autoderefs-1 {\n-                    let (dv, dt) = const_deref(cx, llconst, ty);\n-                    llconst = dv;\n-                    ty = dt;\n-                }\n-            }\n-\n-            if adj.autoref.is_some() {\n-                if adj.autoderefs == 0 {\n-                    // Don't copy data to do a deref+ref\n-                    // (i.e., skip the last auto-deref).\n-                    llconst = addr_of(cx, llconst, type_of::align_of(cx, ty), \"autoref\");\n-                    ty = cx.tcx().mk_imm_ref(cx.tcx().mk_region(ty::ReErased), ty);\n-                }\n-            } else if adj.autoderefs > 0 {\n-                let (dv, dt) = const_deref(cx, llconst, ty);\n-                llconst = dv;\n-\n-                // If we derefed a fat pointer then we will have an\n-                // open type here. So we need to update the type with\n-                // the one returned from const_deref.\n-                ety_adjusted = dt;\n-            }\n-\n-            if let Some(target) = adj.unsize {\n-                let target = monomorphize::apply_param_substs(cx.tcx(),\n-                                                              param_substs,\n-                                                              &target);\n-\n-                let pointee_ty = ty.builtin_deref(true, ty::NoPreference)\n-                    .expect(\"consts: unsizing got non-pointer type\").ty;\n-                let (base, old_info) = if !type_is_sized(cx.tcx(), pointee_ty) {\n-                    // Normally, the source is a thin pointer and we are\n-                    // adding extra info to make a fat pointer. The exception\n-                    // is when we are upcasting an existing object fat pointer\n-                    // to use a different vtable. In that case, we want to\n-                    // load out the original data pointer so we can repackage\n-                    // it.\n-                    (const_get_elt(llconst, &[abi::FAT_PTR_ADDR as u32]),\n-                     Some(const_get_elt(llconst, &[abi::FAT_PTR_EXTRA as u32])))\n-                } else {\n-                    (llconst, None)\n-                };\n-\n-                let unsized_ty = target.builtin_deref(true, ty::NoPreference)\n-                    .expect(\"consts: unsizing got non-pointer target type\").ty;\n-                let ptr_ty = type_of::in_memory_type_of(cx, unsized_ty).ptr_to();\n-                let base = ptrcast(base, ptr_ty);\n-                let info = base::unsized_info(cx, pointee_ty, unsized_ty, old_info);\n-\n-                if old_info.is_none() {\n-                    let prev_const = cx.const_unsized().borrow_mut()\n-                                       .insert(base, llconst);\n-                    assert!(prev_const.is_none() || prev_const == Some(llconst));\n-                }\n-                assert_eq!(abi::FAT_PTR_ADDR, 0);\n-                assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-                llconst = C_struct(cx, &[base, info], false);\n-            }\n-        }\n-        None => {}\n-    };\n-\n-    let llty = type_of::sizing_type_of(cx, ety_adjusted);\n-    let csize = machine::llsize_of_alloc(cx, val_ty(llconst));\n-    let tsize = machine::llsize_of_alloc(cx, llty);\n-    if csize != tsize {\n-        cx.sess().abort_if_errors();\n-        unsafe {\n-            // FIXME these values could use some context\n-            llvm::LLVMDumpValue(llconst);\n-            llvm::LLVMDumpValue(C_undef(llty));\n-        }\n-        bug!(\"const {:?} of type {:?} has size {} instead of {}\",\n-             e, ety_adjusted,\n-             csize, tsize);\n-    }\n-    Ok((llconst, ety_adjusted))\n-}\n-\n-fn check_unary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n-                             te: ValueRef, trueconst: TrueConst) -> Result<(), ConstEvalFailure> {\n-    // The only kind of unary expression that we check for validity\n-    // here is `-expr`, to check if it \"overflows\" (e.g. `-i32::MIN`).\n-    if let hir::ExprUnary(hir::UnNeg, ref inner_e) = e.node {\n-\n-        // An unfortunate special case: we parse e.g. -128 as a\n-        // negation of the literal 128, which means if we're expecting\n-        // a i8 (or if it was already suffixed, e.g. `-128_i8`), then\n-        // 128 will have already overflowed to -128, and so then the\n-        // constant evaluator thinks we're trying to negate -128.\n-        //\n-        // Catch this up front by looking for ExprLit directly,\n-        // and just accepting it.\n-        if let hir::ExprLit(_) = inner_e.node { return Ok(()); }\n-        let cval = match to_const_int(te, t, cx.tcx()) {\n-            Some(v) => v,\n-            None => return Ok(()),\n-        };\n-        const_err(cx, e.span, (-cval).map_err(ErrKind::Math), trueconst)?;\n-    }\n-    Ok(())\n-}\n-\n-pub fn to_const_int(value: ValueRef, t: Ty, tcx: TyCtxt) -> Option<ConstInt> {\n-    match t.sty {\n-        ty::TyInt(int_type) => const_to_opt_int(value).and_then(|input| match int_type {\n-            ast::IntTy::I8 => {\n-                assert_eq!(input as i8 as i64, input);\n-                Some(ConstInt::I8(input as i8))\n-            },\n-            ast::IntTy::I16 => {\n-                assert_eq!(input as i16 as i64, input);\n-                Some(ConstInt::I16(input as i16))\n-            },\n-            ast::IntTy::I32 => {\n-                assert_eq!(input as i32 as i64, input);\n-                Some(ConstInt::I32(input as i32))\n-            },\n-            ast::IntTy::I64 => {\n-                Some(ConstInt::I64(input))\n-            },\n-            ast::IntTy::Is => {\n-                ConstIsize::new(input, tcx.sess.target.int_type)\n-                    .ok().map(ConstInt::Isize)\n-            },\n-        }),\n-        ty::TyUint(uint_type) => const_to_opt_uint(value).and_then(|input| match uint_type {\n-            ast::UintTy::U8 => {\n-                assert_eq!(input as u8 as u64, input);\n-                Some(ConstInt::U8(input as u8))\n-            },\n-            ast::UintTy::U16 => {\n-                assert_eq!(input as u16 as u64, input);\n-                Some(ConstInt::U16(input as u16))\n-            },\n-            ast::UintTy::U32 => {\n-                assert_eq!(input as u32 as u64, input);\n-                Some(ConstInt::U32(input as u32))\n-            },\n-            ast::UintTy::U64 => {\n-                Some(ConstInt::U64(input))\n-            },\n-            ast::UintTy::Us => {\n-                ConstUsize::new(input, tcx.sess.target.uint_type)\n-                    .ok().map(ConstInt::Usize)\n-            },\n-        }),\n-        _ => None,\n-    }\n-}\n-\n-pub fn const_err<T>(cx: &CrateContext,\n-                    span: Span,\n-                    result: Result<T, ErrKind>,\n-                    trueconst: TrueConst)\n-                    -> Result<T, ConstEvalFailure> {\n-    match (result, trueconst) {\n-        (Ok(x), _) => Ok(x),\n-        (Err(err), TrueConst::Yes) => {\n-            let err = ConstEvalErr{ span: span, kind: err };\n-            report_const_eval_err(cx.tcx(), &err, span, \"expression\").emit();\n-            Err(Compiletime(err))\n-        },\n-        (Err(err), TrueConst::No) => {\n-            let err = ConstEvalErr{ span: span, kind: err };\n-            let mut diag = cx.tcx().sess.struct_span_warn(\n-                span, \"this expression will panic at run-time\");\n-            note_const_eval_err(cx.tcx(), &err, span, \"expression\", &mut diag);\n-            diag.emit();\n-            Err(Runtime(err))\n-        },\n-    }\n-}\n-\n-fn check_binary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n-                              te1: ValueRef, te2: ValueRef,\n-                              trueconst: TrueConst) -> Result<(), ConstEvalFailure> {\n-    let b = if let hir::ExprBinary(b, _, _) = e.node { b } else { bug!() };\n-    let (lhs, rhs) = match (to_const_int(te1, t, cx.tcx()), to_const_int(te2, t, cx.tcx())) {\n-        (Some(v1), Some(v2)) => (v1, v2),\n-        _ => return Ok(()),\n-    };\n-    let result = match b.node {\n-        hir::BiAdd => lhs + rhs,\n-        hir::BiSub => lhs - rhs,\n-        hir::BiMul => lhs * rhs,\n-        hir::BiDiv => lhs / rhs,\n-        hir::BiRem => lhs % rhs,\n-        hir::BiShl => lhs << rhs,\n-        hir::BiShr => lhs >> rhs,\n-        _ => return Ok(()),\n-    };\n-    const_err(cx, e.span, result.map_err(ErrKind::Math), trueconst)?;\n-    Ok(())\n-}\n-\n-fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                   e: &hir::Expr,\n-                                   ety: Ty<'tcx>,\n-                                   param_substs: &'tcx Substs<'tcx>,\n-                                   fn_args: FnArgMap,\n-                                   trueconst: TrueConst)\n-                                   -> Result<ValueRef, ConstEvalFailure>\n-{\n-    debug!(\"const_expr_unadjusted(e={:?}, ety={:?}, param_substs={:?})\",\n-           e,\n-           ety,\n-           param_substs);\n-\n-    let map_list = |exprs: &[P<hir::Expr>]| -> Result<Vec<ValueRef>, ConstEvalFailure> {\n-        exprs.iter()\n-             .map(|e| const_expr(cx, &e, param_substs, fn_args, trueconst).map(|(l, _)| l))\n-             .collect::<Vec<Result<ValueRef, ConstEvalFailure>>>()\n-             .into_iter()\n-             .collect()\n-         // this dance is necessary to eagerly run const_expr so all errors are reported\n-    };\n-    let _icx = push_ctxt(\"const_expr\");\n-    Ok(match e.node {\n-        hir::ExprLit(ref lit) => const_lit(cx, e, &lit),\n-        hir::ExprBinary(b, ref e1, ref e2) => {\n-            /* Neither type is bottom, and we expect them to be unified\n-             * already, so the following is safe. */\n-            let (te1, ty) = const_expr(cx, &e1, param_substs, fn_args, trueconst)?;\n-            debug!(\"const_expr_unadjusted: te1={:?}, ty={:?}\",\n-                   Value(te1), ty);\n-            assert!(!ty.is_simd());\n-            let is_float = ty.is_fp();\n-            let signed = ty.is_signed();\n-\n-            let (te2, ty2) = const_expr(cx, &e2, param_substs, fn_args, trueconst)?;\n-            debug!(\"const_expr_unadjusted: te2={:?}, ty={:?}\",\n-                   Value(te2), ty2);\n-\n-            check_binary_expr_validity(cx, e, ty, te1, te2, trueconst)?;\n-\n-            unsafe { match b.node {\n-                hir::BiAdd if is_float => llvm::LLVMConstFAdd(te1, te2),\n-                hir::BiAdd             => llvm::LLVMConstAdd(te1, te2),\n-\n-                hir::BiSub if is_float => llvm::LLVMConstFSub(te1, te2),\n-                hir::BiSub             => llvm::LLVMConstSub(te1, te2),\n-\n-                hir::BiMul if is_float => llvm::LLVMConstFMul(te1, te2),\n-                hir::BiMul             => llvm::LLVMConstMul(te1, te2),\n-\n-                hir::BiDiv if is_float => llvm::LLVMConstFDiv(te1, te2),\n-                hir::BiDiv if signed   => llvm::LLVMConstSDiv(te1, te2),\n-                hir::BiDiv             => llvm::LLVMConstUDiv(te1, te2),\n-\n-                hir::BiRem if is_float => llvm::LLVMConstFRem(te1, te2),\n-                hir::BiRem if signed   => llvm::LLVMConstSRem(te1, te2),\n-                hir::BiRem             => llvm::LLVMConstURem(te1, te2),\n-\n-                hir::BiAnd    => llvm::LLVMConstAnd(te1, te2),\n-                hir::BiOr     => llvm::LLVMConstOr(te1, te2),\n-                hir::BiBitXor => llvm::LLVMConstXor(te1, te2),\n-                hir::BiBitAnd => llvm::LLVMConstAnd(te1, te2),\n-                hir::BiBitOr  => llvm::LLVMConstOr(te1, te2),\n-                hir::BiShl    => {\n-                    let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n-                    llvm::LLVMConstShl(te1, te2)\n-                },\n-                hir::BiShr    => {\n-                    let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n-                    if signed { llvm::LLVMConstAShr(te1, te2) }\n-                    else      { llvm::LLVMConstLShr(te1, te2) }\n-                },\n-                hir::BiEq | hir::BiNe | hir::BiLt | hir::BiLe | hir::BiGt | hir::BiGe => {\n-                    if is_float {\n-                        let cmp = base::bin_op_to_fcmp_predicate(b.node);\n-                        llvm::LLVMConstFCmp(cmp, te1, te2)\n-                    } else {\n-                        let cmp = base::bin_op_to_icmp_predicate(b.node, signed);\n-                        llvm::LLVMConstICmp(cmp, te1, te2)\n-                    }\n-                },\n-            } } // unsafe { match b.node {\n-        },\n-        hir::ExprUnary(u, ref inner_e) => {\n-            let (te, ty) = const_expr(cx, &inner_e, param_substs, fn_args, trueconst)?;\n-\n-            check_unary_expr_validity(cx, e, ty, te, trueconst)?;\n-\n-            let is_float = ty.is_fp();\n-            unsafe { match u {\n-                hir::UnDeref           => const_deref(cx, te, ty).0,\n-                hir::UnNot             => llvm::LLVMConstNot(te),\n-                hir::UnNeg if is_float => llvm::LLVMConstFNeg(te),\n-                hir::UnNeg             => llvm::LLVMConstNeg(te),\n-            } }\n-        },\n-        hir::ExprField(ref base, field) => {\n-            let (bv, bt) = const_expr(cx, &base, param_substs, fn_args, trueconst)?;\n-            let brepr = adt::represent_type(cx, bt);\n-            let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n-            let ix = vinfo.field_index(field.node);\n-            adt::const_get_field(&brepr, bv, vinfo.discr, ix)\n-        },\n-        hir::ExprTupField(ref base, idx) => {\n-            let (bv, bt) = const_expr(cx, &base, param_substs, fn_args, trueconst)?;\n-            let brepr = adt::represent_type(cx, bt);\n-            let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n-            adt::const_get_field(&brepr, bv, vinfo.discr, idx.node)\n-        },\n-        hir::ExprIndex(ref base, ref index) => {\n-            let (bv, bt) = const_expr(cx, &base, param_substs, fn_args, trueconst)?;\n-            let iv = const_expr(cx, &index, param_substs, fn_args, TrueConst::Yes)?.0;\n-            let iv = if let Some(iv) = const_to_opt_uint(iv) {\n-                iv\n-            } else {\n-                span_bug!(index.span, \"index is not an integer-constant expression\");\n-            };\n-            let (arr, len) = match bt.sty {\n-                ty::TyArray(_, u) => (bv, C_uint(cx, u)),\n-                ty::TySlice(..) | ty::TyStr => {\n-                    let e1 = const_get_elt(bv, &[0]);\n-                    (load_const(cx, e1, bt), const_get_elt(bv, &[1]))\n-                },\n-                ty::TyRef(_, mt) => match mt.ty.sty {\n-                    ty::TyArray(_, u) => {\n-                        (load_const(cx, bv, mt.ty), C_uint(cx, u))\n-                    },\n-                    _ => span_bug!(base.span,\n-                                   \"index-expr base must be a vector \\\n-                                    or string type, found {:?}\",\n-                                   bt),\n-                },\n-                _ => span_bug!(base.span,\n-                               \"index-expr base must be a vector \\\n-                                or string type, found {:?}\",\n-                               bt),\n-            };\n-\n-            let len = unsafe { llvm::LLVMConstIntGetZExtValue(len) as u64 };\n-            let len = match bt.sty {\n-                ty::TyBox(ty) | ty::TyRef(_, ty::TypeAndMut{ty, ..}) => match ty.sty {\n-                    ty::TyStr => {\n-                        assert!(len > 0);\n-                        len - 1\n-                    },\n-                    _ => len,\n-                },\n-                _ => len,\n-            };\n-            if iv >= len {\n-                // FIXME #3170: report this earlier on in the const-eval\n-                // pass. Reporting here is a bit late.\n-                const_err(cx, e.span, Err(ErrKind::IndexOutOfBounds {\n-                    len: len,\n-                    index: iv\n-                }), trueconst)?;\n-                C_undef(val_ty(arr).element_type())\n-            } else {\n-                const_get_elt(arr, &[iv as c_uint])\n-            }\n-        },\n-        hir::ExprCast(ref base, _) => {\n-            let t_cast = ety;\n-            let llty = type_of::type_of(cx, t_cast);\n-            let (v, t_expr) = const_expr(cx, &base, param_substs, fn_args, trueconst)?;\n-            debug!(\"trans_const_cast({:?} as {:?})\", t_expr, t_cast);\n-            if expr::cast_is_noop(cx.tcx(), base, t_expr, t_cast) {\n-                return Ok(v);\n-            }\n-            if type_is_fat_ptr(cx.tcx(), t_expr) {\n-                // Fat pointer casts.\n-                let t_cast_inner =\n-                    t_cast.builtin_deref(true, ty::NoPreference).expect(\"cast to non-pointer\").ty;\n-                let ptr_ty = type_of::in_memory_type_of(cx, t_cast_inner).ptr_to();\n-                let addr = ptrcast(const_get_elt(v, &[abi::FAT_PTR_ADDR as u32]),\n-                                   ptr_ty);\n-                if type_is_fat_ptr(cx.tcx(), t_cast) {\n-                    let info = const_get_elt(v, &[abi::FAT_PTR_EXTRA as u32]);\n-                    return Ok(C_struct(cx, &[addr, info], false))\n-                } else {\n-                    return Ok(addr);\n-                }\n-            }\n-            unsafe { match (\n-                CastTy::from_ty(t_expr).expect(\"bad input type for cast\"),\n-                CastTy::from_ty(t_cast).expect(\"bad output type for cast\"),\n-            ) {\n-                (CastTy::Int(IntTy::CEnum), CastTy::Int(_)) => {\n-                    let repr = adt::represent_type(cx, t_expr);\n-                    let discr = adt::const_get_discrim(&repr, v);\n-                    let iv = C_integral(cx.int_type(), discr.0, false);\n-                    let s = adt::is_discr_signed(&repr) as Bool;\n-                    llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n-                },\n-                (CastTy::Int(_), CastTy::Int(_)) => {\n-                    let s = t_expr.is_signed() as Bool;\n-                    llvm::LLVMConstIntCast(v, llty.to_ref(), s)\n-                },\n-                (CastTy::Int(_), CastTy::Float) => {\n-                    if t_expr.is_signed() {\n-                        llvm::LLVMConstSIToFP(v, llty.to_ref())\n-                    } else {\n-                        llvm::LLVMConstUIToFP(v, llty.to_ref())\n-                    }\n-                },\n-                (CastTy::Float, CastTy::Float) => llvm::LLVMConstFPCast(v, llty.to_ref()),\n-                (CastTy::Float, CastTy::Int(IntTy::I)) => llvm::LLVMConstFPToSI(v, llty.to_ref()),\n-                (CastTy::Float, CastTy::Int(_)) => llvm::LLVMConstFPToUI(v, llty.to_ref()),\n-                (CastTy::Ptr(_), CastTy::Ptr(_)) | (CastTy::FnPtr, CastTy::Ptr(_))\n-                | (CastTy::RPtr(_), CastTy::Ptr(_)) => {\n-                    ptrcast(v, llty)\n-                },\n-                (CastTy::FnPtr, CastTy::FnPtr) => ptrcast(v, llty), // isn't this a coercion?\n-                (CastTy::Int(_), CastTy::Ptr(_)) => llvm::LLVMConstIntToPtr(v, llty.to_ref()),\n-                (CastTy::Ptr(_), CastTy::Int(_)) | (CastTy::FnPtr, CastTy::Int(_)) => {\n-                  llvm::LLVMConstPtrToInt(v, llty.to_ref())\n-                },\n-                _ => {\n-                  span_bug!(e.span, \"bad combination of types for cast\")\n-                },\n-            } } // unsafe { match ( ... ) {\n-        },\n-        hir::ExprAddrOf(hir::MutImmutable, ref sub) => {\n-            // If this is the address of some static, then we need to return\n-            // the actual address of the static itself (short circuit the rest\n-            // of const eval).\n-            let mut cur = sub;\n-            loop {\n-                match cur.node {\n-                    hir::ExprBlock(ref blk) => {\n-                        if let Some(ref sub) = blk.expr {\n-                            cur = sub;\n-                        } else {\n-                            break;\n-                        }\n-                    },\n-                    _ => break,\n-                }\n-            }\n-            if let Some(Def::Static(def_id, _)) = cx.tcx().expect_def_or_none(cur.id) {\n-                get_static(cx, def_id).val\n-            } else {\n-                // If this isn't the address of a static, then keep going through\n-                // normal constant evaluation.\n-                let (v, ty) = const_expr(cx, &sub, param_substs, fn_args, trueconst)?;\n-                addr_of(cx, v, type_of::align_of(cx, ty), \"ref\")\n-            }\n-        },\n-        hir::ExprAddrOf(hir::MutMutable, ref sub) => {\n-            let (v, ty) = const_expr(cx, &sub, param_substs, fn_args, trueconst)?;\n-            addr_of_mut(cx, v, type_of::align_of(cx, ty), \"ref_mut_slice\")\n-        },\n-        hir::ExprTup(ref es) => {\n-            let repr = adt::represent_type(cx, ety);\n-            let vals = map_list(&es[..])?;\n-            adt::trans_const(cx, &repr, Disr(0), &vals[..])\n-        },\n-        hir::ExprStruct(_, ref fs, ref base_opt) => {\n-            let repr = adt::represent_type(cx, ety);\n-\n-            let base_val = match *base_opt {\n-                Some(ref base) => Some(const_expr(\n-                    cx,\n-                    &base,\n-                    param_substs,\n-                    fn_args,\n-                    trueconst,\n-                )?),\n-                None => None\n-            };\n-\n-            let VariantInfo { discr, fields } = VariantInfo::of_node(cx.tcx(), ety, e.id);\n-            let cs = fields.iter().enumerate().map(|(ix, &Field(f_name, _))| {\n-                match (fs.iter().find(|f| f_name == f.name.node), base_val) {\n-                    (Some(ref f), _) => {\n-                        const_expr(cx, &f.expr, param_substs, fn_args, trueconst).map(|(l, _)| l)\n-                    },\n-                    (_, Some((bv, _))) => Ok(adt::const_get_field(&repr, bv, discr, ix)),\n-                    (_, None) => span_bug!(e.span, \"missing struct field\"),\n-                }\n-            })\n-            .collect::<Vec<Result<_, ConstEvalFailure>>>()\n-            .into_iter()\n-            .collect::<Result<Vec<_>,ConstEvalFailure>>();\n-            let cs = cs?;\n-            if ety.is_simd() {\n-                C_vector(&cs[..])\n-            } else {\n-                adt::trans_const(cx, &repr, discr, &cs[..])\n-            }\n-        },\n-        hir::ExprVec(ref es) => {\n-            let unit_ty = ety.sequence_element_type(cx.tcx());\n-            let llunitty = type_of::type_of(cx, unit_ty);\n-            let vs = es.iter()\n-                       .map(|e| const_expr(\n-                           cx,\n-                           &e,\n-                           param_substs,\n-                           fn_args,\n-                           trueconst,\n-                       ).map(|(l, _)| l))\n-                       .collect::<Vec<Result<_, ConstEvalFailure>>>()\n-                       .into_iter()\n-                       .collect::<Result<Vec<_>, ConstEvalFailure>>();\n-            let vs = vs?;\n-            // If the vector contains enums, an LLVM array won't work.\n-            if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-                C_struct(cx, &vs[..], false)\n-            } else {\n-                C_array(llunitty, &vs[..])\n-            }\n-        },\n-        hir::ExprRepeat(ref elem, ref count) => {\n-            let unit_ty = ety.sequence_element_type(cx.tcx());\n-            let llunitty = type_of::type_of(cx, unit_ty);\n-            let n = eval_length(cx.tcx(), count, \"repeat count\").unwrap();\n-            let unit_val = const_expr(cx, &elem, param_substs, fn_args, trueconst)?.0;\n-            let vs = vec![unit_val; n];\n-            if val_ty(unit_val) != llunitty {\n-                C_struct(cx, &vs[..], false)\n-            } else {\n-                C_array(llunitty, &vs[..])\n-            }\n-        },\n-        hir::ExprPath(..) => {\n-            match cx.tcx().expect_def(e.id) {\n-                Def::Local(_, id) => {\n-                    if let Some(val) = fn_args.and_then(|args| args.get(&id).cloned()) {\n-                        val\n-                    } else {\n-                        span_bug!(e.span, \"const fn argument not found\")\n-                    }\n-                }\n-                Def::Fn(..) | Def::Method(..) => C_nil(cx),\n-                Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                    load_const(cx, get_const_val(cx, def_id, e, param_substs)?,\n-                               ety)\n-                }\n-                Def::Variant(enum_did, variant_did) => {\n-                    let vinfo = cx.tcx().lookup_adt_def(enum_did).variant_with_id(variant_did);\n-                    match vinfo.kind {\n-                        ty::VariantKind::Unit => {\n-                            let repr = adt::represent_type(cx, ety);\n-                            adt::trans_const(cx, &repr, Disr::from(vinfo.disr_val), &[])\n-                        }\n-                        ty::VariantKind::Tuple => C_nil(cx),\n-                        ty::VariantKind::Struct => {\n-                            span_bug!(e.span, \"path-expr refers to a dict variant!\")\n-                        }\n-                    }\n-                }\n-                // Unit struct or ctor.\n-                Def::Struct(..) => C_null(type_of::type_of(cx, ety)),\n-                _ => {\n-                    span_bug!(e.span, \"expected a const, fn, struct, \\\n-                                       or variant def\")\n-                }\n-            }\n-        },\n-        hir::ExprCall(ref callee, ref args) => {\n-            let mut callee = &**callee;\n-            loop {\n-                callee = match callee.node {\n-                    hir::ExprBlock(ref block) => match block.expr {\n-                        Some(ref tail) => &tail,\n-                        None => break,\n-                    },\n-                    _ => break,\n-                };\n-            }\n-            let arg_vals = map_list(args)?;\n-            match cx.tcx().expect_def(callee.id) {\n-                Def::Fn(did) | Def::Method(did) => {\n-                    const_fn_call(\n-                        cx,\n-                        did,\n-                        cx.tcx().node_id_item_substs(callee.id).substs,\n-                        &arg_vals,\n-                        param_substs,\n-                        trueconst,\n-                    )?\n-                }\n-                Def::Struct(..) => {\n-                    if ety.is_simd() {\n-                        C_vector(&arg_vals[..])\n-                    } else {\n-                        let repr = adt::represent_type(cx, ety);\n-                        adt::trans_const(cx, &repr, Disr(0), &arg_vals[..])\n-                    }\n-                }\n-                Def::Variant(enum_did, variant_did) => {\n-                    let repr = adt::represent_type(cx, ety);\n-                    let vinfo = cx.tcx().lookup_adt_def(enum_did).variant_with_id(variant_did);\n-                    adt::trans_const(cx,\n-                                     &repr,\n-                                     Disr::from(vinfo.disr_val),\n-                                     &arg_vals[..])\n-                }\n-                _ => span_bug!(e.span, \"expected a struct, variant, or const fn def\"),\n-            }\n-        },\n-        hir::ExprMethodCall(_, _, ref args) => {\n-            let arg_vals = map_list(args)?;\n-            let method_call = ty::MethodCall::expr(e.id);\n-            let method = cx.tcx().tables.borrow().method_map[&method_call];\n-            const_fn_call(cx, method.def_id, method.substs,\n-                          &arg_vals, param_substs, trueconst)?\n-        },\n-        hir::ExprType(ref e, _) => const_expr(cx, &e, param_substs, fn_args, trueconst)?.0,\n-        hir::ExprBlock(ref block) => {\n-            match block.expr {\n-                Some(ref expr) => const_expr(\n-                    cx,\n-                    &expr,\n-                    param_substs,\n-                    fn_args,\n-                    trueconst,\n-                )?.0,\n-                None => C_nil(cx),\n-            }\n-        },\n-        hir::ExprClosure(_, ref decl, ref body, _) => {\n-            match ety.sty {\n-                ty::TyClosure(def_id, substs) => {\n-                    closure::trans_closure_expr(closure::Dest::Ignore(cx),\n-                                                decl,\n-                                                body,\n-                                                e.id,\n-                                                def_id,\n-                                                substs);\n-                }\n-                _ =>\n-                    span_bug!(\n-                        e.span,\n-                        \"bad type for closure expr: {:?}\", ety)\n-            }\n-            C_null(type_of::type_of(cx, ety))\n-        },\n-        _ => span_bug!(e.span,\n-                       \"bad constant expression type in consts::const_expr\"),\n-    })\n-}\n-\n-pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n-                            -> Datum<'tcx, Lvalue> {\n-    let ty = ccx.tcx().lookup_item_type(def_id).ty;\n-\n+pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n     let instance = Instance::mono(ccx.shared(), def_id);\n     if let Some(&g) = ccx.instances().borrow().get(&instance) {\n-        return Datum::new(g, ty, Lvalue::new(\"static\"));\n+        return g;\n     }\n \n+    let ty = ccx.tcx().lookup_item_type(def_id).ty;\n     let g = if let Some(id) = ccx.tcx().map.as_local_node_id(def_id) {\n \n         let llty = type_of::type_of(ccx, ty);\n@@ -1032,14 +105,10 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items()\n                                                          .contains_key(&TransItem::Static(id));\n-                if defined_in_current_codegen_unit {\n-                    if declare::get_declared_value(ccx, sym).is_none() {\n-                        span_bug!(span, \"trans: Static not properly pre-defined?\");\n-                    }\n-                } else {\n-                    if declare::get_declared_value(ccx, sym).is_some() {\n-                        span_bug!(span, \"trans: Conflicting symbol names for static?\");\n-                    }\n+                assert!(!defined_in_current_codegen_unit);\n+\n+                if declare::get_declared_value(ccx, sym).is_some() {\n+                    span_bug!(span, \"trans: Conflicting symbol names for static?\");\n                 }\n \n                 let g = declare::define_global(ccx, sym, llty).unwrap();\n@@ -1136,34 +205,20 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n \n     ccx.instances().borrow_mut().insert(instance, g);\n     ccx.statics().borrow_mut().insert(g, def_id);\n-    Datum::new(g, ty, Lvalue::new(\"static\"))\n+    g\n }\n \n pub fn trans_static(ccx: &CrateContext,\n                     m: hir::Mutability,\n-                    expr: &hir::Expr,\n                     id: ast::NodeId,\n                     attrs: &[ast::Attribute])\n                     -> Result<ValueRef, ConstEvalErr> {\n     unsafe {\n         let _icx = push_ctxt(\"trans_static\");\n         let def_id = ccx.tcx().map.local_def_id(id);\n-        let datum = get_static(ccx, def_id);\n+        let g = get_static(ccx, def_id);\n \n-        let check_attrs = |attrs: &[ast::Attribute]| {\n-            let default_to_mir = ccx.sess().opts.debugging_opts.orbit;\n-            let invert = if default_to_mir { \"rustc_no_mir\" } else { \"rustc_mir\" };\n-            default_to_mir ^ attrs.iter().any(|item| item.check_name(invert))\n-        };\n-        let use_mir = check_attrs(ccx.tcx().map.attrs(id));\n-\n-        let v = if use_mir {\n-            ::mir::trans_static_initializer(ccx, def_id)\n-        } else {\n-            let empty_substs = Substs::empty(ccx.tcx());\n-            const_expr(ccx, expr, empty_substs, None, TrueConst::Yes)\n-                .map(|(v, _)| v)\n-        }.map_err(|e| e.into_inner())?;\n+        let v = ::mir::trans_static_initializer(ccx, def_id)?;\n \n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n@@ -1175,31 +230,32 @@ pub fn trans_static(ccx: &CrateContext,\n             v\n         };\n \n-        let llty = type_of::type_of(ccx, datum.ty);\n+        let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+        let llty = type_of::type_of(ccx, ty);\n         let g = if val_llty == llty {\n-            datum.val\n+            g\n         } else {\n             // If we created the global with the wrong type,\n             // correct the type.\n             let empty_string = CString::new(\"\").unwrap();\n-            let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(datum.val));\n+            let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(g));\n             let name_string = CString::new(name_str_ref.to_bytes()).unwrap();\n-            llvm::LLVMSetValueName(datum.val, empty_string.as_ptr());\n+            llvm::LLVMSetValueName(g, empty_string.as_ptr());\n             let new_g = llvm::LLVMRustGetOrInsertGlobal(\n                 ccx.llmod(), name_string.as_ptr(), val_llty.to_ref());\n             // To avoid breaking any invariants, we leave around the old\n             // global for the moment; we'll replace all references to it\n             // with the new global later. (See base::trans_crate.)\n-            ccx.statics_to_rauw().borrow_mut().push((datum.val, new_g));\n+            ccx.statics_to_rauw().borrow_mut().push((g, new_g));\n             new_g\n         };\n-        llvm::LLVMSetAlignment(g, type_of::align_of(ccx, datum.ty));\n+        llvm::LLVMSetAlignment(g, type_of::align_of(ccx, ty));\n         llvm::LLVMSetInitializer(g, v);\n \n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n         if m != hir::MutMutable {\n-            let tcontents = datum.ty.type_contents(ccx.tcx());\n+            let tcontents = ty.type_contents(ccx.tcx());\n             if !tcontents.interior_unsafe() {\n                 llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }"}, {"sha": "0a295b251b31e4ff85ddc4c028b43b1735562219", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -53,9 +53,7 @@ pub struct Stats {\n     pub n_glues_created: Cell<usize>,\n     pub n_null_glues: Cell<usize>,\n     pub n_real_glues: Cell<usize>,\n-    pub n_fallback_instantiations: Cell<usize>,\n     pub n_fns: Cell<usize>,\n-    pub n_monos: Cell<usize>,\n     pub n_inlines: Cell<usize>,\n     pub n_closures: Cell<usize>,\n     pub n_llvm_insns: Cell<usize>,\n@@ -79,7 +77,6 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     stats: Stats,\n     check_overflow: bool,\n-    check_drop_flag_for_sanity: bool,\n     mir_map: &'a MirMap<'tcx>,\n     mir_cache: RefCell<DepTrackingMap<MirCache<'tcx>>>,\n \n@@ -104,7 +101,6 @@ pub struct LocalCrateContext<'tcx> {\n     drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>>,\n     /// Cache instances of monomorphic and polymorphic items\n     instances: RefCell<FnvHashMap<Instance<'tcx>, ValueRef>>,\n-    monomorphizing: RefCell<DefIdMap<usize>>,\n     /// Cache generated vtables\n     vtables: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>>,\n     /// Cache of constant strings,\n@@ -424,8 +420,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n                reachable: NodeSet,\n-               check_overflow: bool,\n-               check_drop_flag_for_sanity: bool)\n+               check_overflow: bool)\n                -> SharedCrateContext<'b, 'tcx> {\n         let (metadata_llcx, metadata_llmod) = unsafe {\n             create_context_and_module(&tcx.sess, \"metadata\")\n@@ -490,17 +485,14 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n                 n_glues_created: Cell::new(0),\n                 n_null_glues: Cell::new(0),\n                 n_real_glues: Cell::new(0),\n-                n_fallback_instantiations: Cell::new(0),\n                 n_fns: Cell::new(0),\n-                n_monos: Cell::new(0),\n                 n_inlines: Cell::new(0),\n                 n_closures: Cell::new(0),\n                 n_llvm_insns: Cell::new(0),\n                 llvm_insns: RefCell::new(FnvHashMap()),\n                 fn_stats: RefCell::new(Vec::new()),\n             },\n             check_overflow: check_overflow,\n-            check_drop_flag_for_sanity: check_drop_flag_for_sanity,\n             use_dll_storage_attrs: use_dll_storage_attrs,\n             translation_items: RefCell::new(FnvHashSet()),\n             trait_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n@@ -629,7 +621,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 fn_pointer_shims: RefCell::new(FnvHashMap()),\n                 drop_glues: RefCell::new(FnvHashMap()),\n                 instances: RefCell::new(FnvHashMap()),\n-                monomorphizing: RefCell::new(DefIdMap()),\n                 vtables: RefCell::new(FnvHashMap()),\n                 const_cstr_cache: RefCell::new(FnvHashMap()),\n                 const_unsized: RefCell::new(FnvHashMap()),\n@@ -833,10 +824,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().instances\n     }\n \n-    pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<usize>> {\n-        &self.local().monomorphizing\n-    }\n-\n     pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>> {\n         &self.local().vtables\n     }\n@@ -964,13 +951,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared.check_overflow\n     }\n \n-    pub fn check_drop_flag_for_sanity(&self) -> bool {\n-        // This controls whether we emit a conditional llvm.debugtrap\n-        // guarded on whether the dropflag is one of its (two) valid\n-        // values.\n-        self.shared.check_drop_flag_for_sanity\n-    }\n-\n     pub fn use_dll_storage_attrs(&self) -> bool {\n         self.shared.use_dll_storage_attrs()\n     }"}, {"sha": "8b3a8a2bfccfb87d1bff788c10f021dd08314e83", "filename": "src/librustc_trans/controlflow.rs", "status": "removed", "additions": 0, "deletions": 434, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Flibrustc_trans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Flibrustc_trans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontrolflow.rs?ref=03e23c7f9a10b18e1687bfd92c6807e9342aa00b", "patch": "@@ -1,434 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use llvm::ValueRef;\n-use rustc::hir::def::Def;\n-use middle::lang_items::{PanicFnLangItem, PanicBoundsCheckFnLangItem};\n-use rustc::ty::subst::Substs;\n-use base::*;\n-use basic_block::BasicBlock;\n-use build::*;\n-use callee::{Callee, ArgVals};\n-use cleanup::CleanupMethods;\n-use cleanup;\n-use common::*;\n-use consts;\n-use debuginfo;\n-use debuginfo::{DebugLoc, ToDebugLoc};\n-use expr;\n-use machine;\n-\n-use rustc::hir;\n-\n-use syntax::ast;\n-use syntax::parse::token::InternedString;\n-use syntax::parse::token;\n-\n-pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                              s: &hir::Stmt)\n-                              -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_stmt\");\n-    let fcx = cx.fcx;\n-    debug!(\"trans_stmt({:?})\", s);\n-\n-    if cx.unreachable.get() {\n-        return cx;\n-    }\n-\n-    if cx.sess().asm_comments() {\n-        add_span_comment(cx, s.span, &format!(\"{:?}\", s));\n-    }\n-\n-    let mut bcx = cx;\n-\n-    let id = s.node.id();\n-    let cleanup_debug_loc =\n-        debuginfo::get_cleanup_debug_loc_for_ast_node(bcx.ccx(), id, s.span, false);\n-    fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n-\n-    match s.node {\n-        hir::StmtExpr(ref e, _) | hir::StmtSemi(ref e, _) => {\n-            bcx = trans_stmt_semi(bcx, &e);\n-        }\n-        hir::StmtDecl(ref d, _) => {\n-            match d.node {\n-                hir::DeclLocal(ref local) => {\n-                    bcx = init_local(bcx, &local);\n-                    debuginfo::create_local_var_metadata(bcx, &local);\n-                }\n-                // Inner items are visited by `trans_item`/`trans_meth`.\n-                hir::DeclItem(_) => {},\n-            }\n-        }\n-    }\n-\n-    bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, s.node.id());\n-\n-    return bcx;\n-}\n-\n-pub fn trans_stmt_semi<'blk, 'tcx>(cx: Block<'blk, 'tcx>, e: &hir::Expr)\n-                                   -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_stmt_semi\");\n-\n-    if cx.unreachable.get() {\n-        return cx;\n-    }\n-\n-    let ty = expr_ty(cx, e);\n-    if cx.fcx.type_needs_drop(ty) {\n-        expr::trans_to_lvalue(cx, e, \"stmt\").bcx\n-    } else {\n-        expr::trans_into(cx, e, expr::Ignore)\n-    }\n-}\n-\n-pub fn trans_block<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               b: &hir::Block,\n-                               mut dest: expr::Dest)\n-                               -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_block\");\n-\n-    if bcx.unreachable.get() {\n-        return bcx;\n-    }\n-\n-    let fcx = bcx.fcx;\n-    let mut bcx = bcx;\n-\n-    let cleanup_debug_loc =\n-        debuginfo::get_cleanup_debug_loc_for_ast_node(bcx.ccx(), b.id, b.span, true);\n-    fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n-\n-    for s in &b.stmts {\n-        bcx = trans_stmt(bcx, s);\n-    }\n-\n-    if dest != expr::Ignore {\n-        let block_ty = node_id_type(bcx, b.id);\n-\n-        if b.expr.is_none() || type_is_zero_size(bcx.ccx(), block_ty) {\n-            dest = expr::Ignore;\n-        } else if b.expr.is_some() {\n-            // If the block has an expression, but that expression isn't reachable,\n-            // don't save into the destination given, ignore it.\n-            if let Some(ref cfg) = bcx.fcx.cfg {\n-                if !cfg.node_is_reachable(b.expr.as_ref().unwrap().id) {\n-                    dest = expr::Ignore;\n-                }\n-            }\n-        }\n-    }\n-\n-    match b.expr {\n-        Some(ref e) => {\n-            if !bcx.unreachable.get() {\n-                bcx = expr::trans_into(bcx, &e, dest);\n-            }\n-        }\n-        None => {\n-            assert!(dest == expr::Ignore || bcx.unreachable.get());\n-        }\n-    }\n-\n-    bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, b.id);\n-\n-    return bcx;\n-}\n-\n-pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                            if_id: ast::NodeId,\n-                            cond: &hir::Expr,\n-                            thn: &hir::Block,\n-                            els: Option<&hir::Expr>,\n-                            dest: expr::Dest)\n-                            -> Block<'blk, 'tcx> {\n-    debug!(\"trans_if(bcx={}, if_id={}, cond={:?}, thn={}, dest={:?})\",\n-           bcx.to_str(), if_id, cond, thn.id, dest);\n-    let _icx = push_ctxt(\"trans_if\");\n-\n-    if bcx.unreachable.get() {\n-        return bcx;\n-    }\n-\n-    let mut bcx = bcx;\n-\n-    let cond_val = unpack_result!(bcx, expr::trans(bcx, cond).to_llbool());\n-\n-    // Drop branches that are known to be impossible\n-    if let Some(cv) = const_to_opt_uint(cond_val) {\n-        if cv == 1 {\n-            // if true { .. } [else { .. }]\n-            bcx = trans_block(bcx, &thn, dest);\n-            DebugLoc::None.apply(bcx.fcx);\n-        } else {\n-            if let Some(elexpr) = els {\n-                bcx = expr::trans_into(bcx, &elexpr, dest);\n-                DebugLoc::None.apply(bcx.fcx);\n-            }\n-        }\n-\n-        return bcx;\n-    }\n-\n-    let name = format!(\"then-block-{}-\", thn.id);\n-    let then_bcx_in = bcx.fcx.new_id_block(&name[..], thn.id);\n-    let then_bcx_out = trans_block(then_bcx_in, &thn, dest);\n-    DebugLoc::None.apply(bcx.fcx);\n-\n-    let cond_source_loc = cond.debug_loc();\n-\n-    let next_bcx;\n-    match els {\n-        Some(elexpr) => {\n-            let else_bcx_in = bcx.fcx.new_id_block(\"else-block\", elexpr.id);\n-            let else_bcx_out = expr::trans_into(else_bcx_in, &elexpr, dest);\n-            next_bcx = bcx.fcx.join_blocks(if_id,\n-                                           &[then_bcx_out, else_bcx_out]);\n-            CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb, cond_source_loc);\n-        }\n-\n-        None => {\n-            next_bcx = bcx.fcx.new_id_block(\"next-block\", if_id);\n-            Br(then_bcx_out, next_bcx.llbb, DebugLoc::None);\n-            CondBr(bcx, cond_val, then_bcx_in.llbb, next_bcx.llbb, cond_source_loc);\n-        }\n-    }\n-\n-    // Clear the source location because it is still set to whatever has been translated\n-    // right before.\n-    DebugLoc::None.apply(next_bcx.fcx);\n-\n-    next_bcx\n-}\n-\n-pub fn trans_while<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               loop_expr: &hir::Expr,\n-                               cond: &hir::Expr,\n-                               body: &hir::Block)\n-                               -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_while\");\n-\n-    if bcx.unreachable.get() {\n-        return bcx;\n-    }\n-\n-    let fcx = bcx.fcx;\n-\n-    //            bcx\n-    //             |\n-    //         cond_bcx_in  <--------+\n-    //             |                 |\n-    //         cond_bcx_out          |\n-    //           |      |            |\n-    //           |    body_bcx_in    |\n-    // cleanup_blk      |            |\n-    //    |           body_bcx_out --+\n-    // next_bcx_in\n-\n-    let next_bcx_in = fcx.new_id_block(\"while_exit\", loop_expr.id);\n-    let cond_bcx_in = fcx.new_id_block(\"while_cond\", cond.id);\n-    let body_bcx_in = fcx.new_id_block(\"while_body\", body.id);\n-\n-    fcx.push_loop_cleanup_scope(loop_expr.id, [next_bcx_in, cond_bcx_in]);\n-\n-    Br(bcx, cond_bcx_in.llbb, loop_expr.debug_loc());\n-\n-    // compile the block where we will handle loop cleanups\n-    let cleanup_llbb = fcx.normal_exit_block(loop_expr.id, cleanup::EXIT_BREAK);\n-\n-    // compile the condition\n-    let Result {bcx: cond_bcx_out, val: cond_val} =\n-        expr::trans(cond_bcx_in, cond).to_llbool();\n-\n-    CondBr(cond_bcx_out, cond_val, body_bcx_in.llbb, cleanup_llbb, cond.debug_loc());\n-\n-    // loop body:\n-    let body_bcx_out = trans_block(body_bcx_in, body, expr::Ignore);\n-    Br(body_bcx_out, cond_bcx_in.llbb, DebugLoc::None);\n-\n-    fcx.pop_loop_cleanup_scope(loop_expr.id);\n-    return next_bcx_in;\n-}\n-\n-pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              loop_expr: &hir::Expr,\n-                              body: &hir::Block)\n-                              -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_loop\");\n-\n-    if bcx.unreachable.get() {\n-        return bcx;\n-    }\n-\n-    let fcx = bcx.fcx;\n-\n-    //            bcx\n-    //             |\n-    //         body_bcx_in\n-    //             |\n-    //         body_bcx_out\n-    //\n-    // next_bcx\n-    //\n-    // Links between body_bcx_in and next_bcx are created by\n-    // break statements.\n-\n-    let next_bcx_in = bcx.fcx.new_id_block(\"loop_exit\", loop_expr.id);\n-    let body_bcx_in = bcx.fcx.new_id_block(\"loop_body\", body.id);\n-\n-    fcx.push_loop_cleanup_scope(loop_expr.id, [next_bcx_in, body_bcx_in]);\n-\n-    Br(bcx, body_bcx_in.llbb, loop_expr.debug_loc());\n-    let body_bcx_out = trans_block(body_bcx_in, body, expr::Ignore);\n-    Br(body_bcx_out, body_bcx_in.llbb, DebugLoc::None);\n-\n-    fcx.pop_loop_cleanup_scope(loop_expr.id);\n-\n-    // If there are no predecessors for the next block, we just translated an endless loop and the\n-    // next block is unreachable\n-    if BasicBlock(next_bcx_in.llbb).pred_iter().next().is_none() {\n-        Unreachable(next_bcx_in);\n-    }\n-\n-    return next_bcx_in;\n-}\n-\n-pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    expr: &hir::Expr,\n-                                    opt_label: Option<ast::Name>,\n-                                    exit: usize)\n-                                    -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_break_cont\");\n-\n-    if bcx.unreachable.get() {\n-        return bcx;\n-    }\n-\n-    let fcx = bcx.fcx;\n-\n-    // Locate loop that we will break to\n-    let loop_id = match opt_label {\n-        None => fcx.top_loop_scope(),\n-        Some(_) => {\n-            match bcx.tcx().expect_def(expr.id) {\n-                Def::Label(loop_id) => loop_id,\n-                r => {\n-                    bug!(\"{:?} in def-map for label\", r)\n-                }\n-            }\n-        }\n-    };\n-\n-    // Generate appropriate cleanup code and branch\n-    let cleanup_llbb = fcx.normal_exit_block(loop_id, exit);\n-    Br(bcx, cleanup_llbb, expr.debug_loc());\n-    Unreachable(bcx); // anything afterwards should be ignored\n-    return bcx;\n-}\n-\n-pub fn trans_break<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               expr: &hir::Expr,\n-                               label_opt: Option<ast::Name>)\n-                               -> Block<'blk, 'tcx> {\n-    return trans_break_cont(bcx, expr, label_opt, cleanup::EXIT_BREAK);\n-}\n-\n-pub fn trans_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              expr: &hir::Expr,\n-                              label_opt: Option<ast::Name>)\n-                              -> Block<'blk, 'tcx> {\n-    return trans_break_cont(bcx, expr, label_opt, cleanup::EXIT_LOOP);\n-}\n-\n-pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             return_expr: &hir::Expr,\n-                             retval_expr: Option<&hir::Expr>)\n-                             -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_ret\");\n-\n-    if bcx.unreachable.get() {\n-        return bcx;\n-    }\n-\n-    let fcx = bcx.fcx;\n-    let mut bcx = bcx;\n-    if let Some(x) = retval_expr {\n-        let dest = if fcx.llretslotptr.get().is_some() {\n-            expr::SaveIn(fcx.get_ret_slot(bcx, \"ret_slot\"))\n-        } else {\n-            expr::Ignore\n-        };\n-        bcx = expr::trans_into(bcx, &x, dest);\n-        match dest {\n-            expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n-                Store(bcx, slot, fcx.llretslotptr.get().unwrap());\n-            }\n-            _ => {}\n-        }\n-    }\n-    let cleanup_llbb = fcx.return_exit_block();\n-    Br(bcx, cleanup_llbb, return_expr.debug_loc());\n-    Unreachable(bcx);\n-    return bcx;\n-}\n-\n-pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              call_info: NodeIdAndSpan,\n-                              fail_str: InternedString)\n-                              -> Block<'blk, 'tcx> {\n-    let ccx = bcx.ccx();\n-    let _icx = push_ctxt(\"trans_fail_value\");\n-\n-    if bcx.unreachable.get() {\n-        return bcx;\n-    }\n-\n-    let v_str = C_str_slice(ccx, fail_str);\n-    let loc = bcx.sess().codemap().lookup_char_pos(call_info.span.lo);\n-    let filename = token::intern_and_get_ident(&loc.file.name);\n-    let filename = C_str_slice(ccx, filename);\n-    let line = C_u32(ccx, loc.line as u32);\n-    let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n-    let align = machine::llalign_of_min(ccx, val_ty(expr_file_line_const));\n-    let expr_file_line = consts::addr_of(ccx, expr_file_line_const, align, \"panic_loc\");\n-    let args = vec!(expr_file_line);\n-    let did = langcall(bcx.tcx(), Some(call_info.span), \"\", PanicFnLangItem);\n-    Callee::def(ccx, did, Substs::empty(ccx.tcx()))\n-        .call(bcx, call_info.debug_loc(), ArgVals(&args), None).bcx\n-}\n-\n-pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                           call_info: NodeIdAndSpan,\n-                                           index: ValueRef,\n-                                           len: ValueRef)\n-                                           -> Block<'blk, 'tcx> {\n-    let ccx = bcx.ccx();\n-    let _icx = push_ctxt(\"trans_fail_bounds_check\");\n-\n-    if bcx.unreachable.get() {\n-        return bcx;\n-    }\n-\n-    // Extract the file/line from the span\n-    let loc = bcx.sess().codemap().lookup_char_pos(call_info.span.lo);\n-    let filename = token::intern_and_get_ident(&loc.file.name);\n-\n-    // Invoke the lang item\n-    let filename = C_str_slice(ccx,  filename);\n-    let line = C_u32(ccx, loc.line as u32);\n-    let file_line_const = C_struct(ccx, &[filename, line], false);\n-    let align = machine::llalign_of_min(ccx, val_ty(file_line_const));\n-    let file_line = consts::addr_of(ccx, file_line_const, align, \"panic_bounds_check_loc\");\n-    let args = vec!(file_line, index, len);\n-    let did = langcall(bcx.tcx(), Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n-    Callee::def(ccx, did, Substs::empty(ccx.tcx()))\n-        .call(bcx, call_info.debug_loc(), ArgVals(&args), None).bcx\n-}"}, {"sha": "875f88e37c916d623d8e9024be1aa7506a0b7d07", "filename": "src/librustc_trans/datum.rs", "status": "removed", "additions": 0, "deletions": 828, "changes": 828, "blob_url": "https://github.com/rust-lang/rust/blob/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Flibrustc_trans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Flibrustc_trans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdatum.rs?ref=03e23c7f9a10b18e1687bfd92c6807e9342aa00b", "patch": "@@ -1,828 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! ## The Datum module\n-//!\n-//! A `Datum` encapsulates the result of evaluating a Rust expression.  It\n-//! contains a `ValueRef` indicating the result, a `Ty` describing\n-//! the Rust type, but also a *kind*. The kind indicates whether the datum\n-//! has cleanup scheduled (lvalue) or not (rvalue) and -- in the case of\n-//! rvalues -- whether or not the value is \"by ref\" or \"by value\".\n-//!\n-//! The datum API is designed to try and help you avoid memory errors like\n-//! forgetting to arrange cleanup or duplicating a value. The type of the\n-//! datum incorporates the kind, and thus reflects whether it has cleanup\n-//! scheduled:\n-//!\n-//! - `Datum<Lvalue>` -- by ref, cleanup scheduled\n-//! - `Datum<Rvalue>` -- by value or by ref, no cleanup scheduled\n-//! - `Datum<Expr>` -- either `Datum<Lvalue>` or `Datum<Rvalue>`\n-//!\n-//! Rvalue and expr datums are noncopyable, and most of the methods on\n-//! datums consume the datum itself (with some notable exceptions). This\n-//! reflects the fact that datums may represent affine values which ought\n-//! to be consumed exactly once, and if you were to try to (for example)\n-//! store an affine value multiple times, you would be duplicating it,\n-//! which would certainly be a bug.\n-//!\n-//! Some of the datum methods, however, are designed to work only on\n-//! copyable values such as ints or pointers. Those methods may borrow the\n-//! datum (`&self`) rather than consume it, but they always include\n-//! assertions on the type of the value represented to check that this\n-//! makes sense. An example is `shallow_copy()`, which duplicates\n-//! a datum value.\n-//!\n-//! Translating an expression always yields a `Datum<Expr>` result, but\n-//! the methods `to_[lr]value_datum()` can be used to coerce a\n-//! `Datum<Expr>` into a `Datum<Lvalue>` or `Datum<Rvalue>` as\n-//! needed. Coercing to an lvalue is fairly common, and generally occurs\n-//! whenever it is necessary to inspect a value and pull out its\n-//! subcomponents (for example, a match, or indexing expression). Coercing\n-//! to an rvalue is more unusual; it occurs when moving values from place\n-//! to place, such as in an assignment expression or parameter passing.\n-//!\n-//! ### Lvalues in detail\n-//!\n-//! An lvalue datum is one for which cleanup has been scheduled. Lvalue\n-//! datums are always located in memory, and thus the `ValueRef` for an\n-//! LLVM value is always a pointer to the actual Rust value. This means\n-//! that if the Datum has a Rust type of `int`, then the LLVM type of the\n-//! `ValueRef` will be `int*` (pointer to int).\n-//!\n-//! Because lvalues already have cleanups scheduled, the memory must be\n-//! zeroed to prevent the cleanup from taking place (presuming that the\n-//! Rust type needs drop in the first place, otherwise it doesn't\n-//! matter). The Datum code automatically performs this zeroing when the\n-//! value is stored to a new location, for example.\n-//!\n-//! Lvalues usually result from evaluating lvalue expressions. For\n-//! example, evaluating a local variable `x` yields an lvalue, as does a\n-//! reference to a field like `x.f` or an index `x[i]`.\n-//!\n-//! Lvalue datums can also arise by *converting* an rvalue into an lvalue.\n-//! This is done with the `to_lvalue_datum` method defined on\n-//! `Datum<Expr>`. Basically this method just schedules cleanup if the\n-//! datum is an rvalue, possibly storing the value into a stack slot first\n-//! if needed. Converting rvalues into lvalues occurs in constructs like\n-//! `&foo()` or `match foo() { ref x => ... }`, where the user is\n-//! implicitly requesting a temporary.\n-//!\n-//! ### Rvalues in detail\n-//!\n-//! Rvalues datums are values with no cleanup scheduled. One must be\n-//! careful with rvalue datums to ensure that cleanup is properly\n-//! arranged, usually by converting to an lvalue datum or by invoking the\n-//! `add_clean` method.\n-//!\n-//! ### Scratch datums\n-//!\n-//! Sometimes you need some temporary scratch space.  The functions\n-//! `[lr]value_scratch_datum()` can be used to get temporary stack\n-//! space. As their name suggests, they yield lvalues and rvalues\n-//! respectively. That is, the slot from `lvalue_scratch_datum` will have\n-//! cleanup arranged, and the slot from `rvalue_scratch_datum` does not.\n-\n-pub use self::Expr::*;\n-pub use self::RvalueMode::*;\n-\n-use llvm::ValueRef;\n-use adt;\n-use base::*;\n-use build::{Load, Store};\n-use common::*;\n-use cleanup;\n-use cleanup::{CleanupMethods, DropHintDatum, DropHintMethods};\n-use expr;\n-use tvec;\n-use value::Value;\n-use rustc::ty::Ty;\n-\n-use std::fmt;\n-use syntax::ast;\n-use syntax_pos::DUMMY_SP;\n-\n-/// A `Datum` encapsulates the result of evaluating an expression.  It\n-/// describes where the value is stored, what Rust type the value has,\n-/// whether it is addressed by reference, and so forth. Please refer\n-/// the section on datums in `README.md` for more details.\n-#[derive(Clone, Copy)]\n-pub struct Datum<'tcx, K> {\n-    /// The llvm value.  This is either a pointer to the Rust value or\n-    /// the value itself, depending on `kind` below.\n-    pub val: ValueRef,\n-\n-    /// The rust type of the value.\n-    pub ty: Ty<'tcx>,\n-\n-    /// Indicates whether this is by-ref or by-value.\n-    pub kind: K,\n-}\n-\n-impl<'tcx, K: fmt::Debug> fmt::Debug for Datum<'tcx, K> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Datum({:?}, {:?}, {:?})\",\n-               Value(self.val), self.ty, self.kind)\n-    }\n-}\n-\n-pub struct DatumBlock<'blk, 'tcx: 'blk, K> {\n-    pub bcx: Block<'blk, 'tcx>,\n-    pub datum: Datum<'tcx, K>,\n-}\n-\n-#[derive(Debug)]\n-pub enum Expr {\n-    /// a fresh value that was produced and which has no cleanup yet\n-    /// because it has not yet \"landed\" into its permanent home\n-    RvalueExpr(Rvalue),\n-\n-    /// `val` is a pointer into memory for which a cleanup is scheduled\n-    /// (and thus has type *T). If you move out of an Lvalue, you must\n-    /// zero out the memory (FIXME #5016).\n-    LvalueExpr(Lvalue),\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum DropFlagInfo {\n-    DontZeroJustUse(ast::NodeId),\n-    ZeroAndMaintain(ast::NodeId),\n-    None,\n-}\n-\n-impl DropFlagInfo {\n-    pub fn must_zero(&self) -> bool {\n-        match *self {\n-            DropFlagInfo::DontZeroJustUse(..) => false,\n-            DropFlagInfo::ZeroAndMaintain(..) => true,\n-            DropFlagInfo::None => true,\n-        }\n-    }\n-\n-    pub fn hint_datum<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>)\n-                              -> Option<DropHintDatum<'tcx>> {\n-        let id = match *self {\n-            DropFlagInfo::None => return None,\n-            DropFlagInfo::DontZeroJustUse(id) |\n-            DropFlagInfo::ZeroAndMaintain(id) => id,\n-        };\n-\n-        let hints = bcx.fcx.lldropflag_hints.borrow();\n-        let retval = hints.hint_datum(id);\n-        assert!(retval.is_some(), \"An id (={}) means must have a hint\", id);\n-        retval\n-    }\n-}\n-\n-// FIXME: having Lvalue be `Copy` is a bit of a footgun, since clients\n-// may not realize that subparts of an Lvalue can have a subset of\n-// drop-flags associated with them, while this as written will just\n-// memcpy the drop_flag_info. But, it is an easier way to get `_match`\n-// off the ground to just let this be `Copy` for now.\n-#[derive(Copy, Clone, Debug)]\n-pub struct Lvalue {\n-    pub source: &'static str,\n-    pub drop_flag_info: DropFlagInfo\n-}\n-\n-#[derive(Debug)]\n-pub struct Rvalue {\n-    pub mode: RvalueMode\n-}\n-\n-/// Classifies what action we should take when a value is moved away\n-/// with respect to its drop-flag.\n-///\n-/// Long term there will be no need for this classification: all flags\n-/// (which will be stored on the stack frame) will have the same\n-/// interpretation and maintenance code associated with them.\n-#[derive(Copy, Clone, Debug)]\n-pub enum HintKind {\n-    /// When the value is moved, set the drop-flag to \"dropped\"\n-    /// (i.e. \"zero the flag\", even when the specific representation\n-    /// is not literally 0) and when it is reinitialized, set the\n-    /// drop-flag back to \"initialized\".\n-    ZeroAndMaintain,\n-\n-    /// When the value is moved, do not set the drop-flag to \"dropped\"\n-    /// However, continue to read the drop-flag in deciding whether to\n-    /// drop. (In essence, the path/fragment in question will never\n-    /// need to be dropped at the points where it is moved away by\n-    /// this code, but we are defending against the scenario where\n-    /// some *other* code could move away (or drop) the value and thus\n-    /// zero-the-flag, which is why we will still read from it.\n-    DontZeroJustUse,\n-}\n-\n-impl Lvalue { // Constructors for various Lvalues.\n-    pub fn new<'blk, 'tcx>(source: &'static str) -> Lvalue {\n-        debug!(\"Lvalue at {} no drop flag info\", source);\n-        Lvalue { source: source, drop_flag_info: DropFlagInfo::None }\n-    }\n-\n-    pub fn new_dropflag_hint(source: &'static str) -> Lvalue {\n-        debug!(\"Lvalue at {} is drop flag hint\", source);\n-        Lvalue { source: source, drop_flag_info: DropFlagInfo::None }\n-    }\n-\n-    pub fn new_with_hint<'blk, 'tcx>(source: &'static str,\n-                                     bcx: Block<'blk, 'tcx>,\n-                                     id: ast::NodeId,\n-                                     k: HintKind) -> Lvalue {\n-        let (opt_id, info) = {\n-            let hint_available = Lvalue::has_dropflag_hint(bcx, id) &&\n-                bcx.tcx().sess.nonzeroing_move_hints();\n-            let info = match k {\n-                HintKind::ZeroAndMaintain if hint_available =>\n-                    DropFlagInfo::ZeroAndMaintain(id),\n-                HintKind::DontZeroJustUse if hint_available =>\n-                    DropFlagInfo::DontZeroJustUse(id),\n-                _ =>\n-                    DropFlagInfo::None,\n-            };\n-            (Some(id), info)\n-        };\n-        debug!(\"Lvalue at {}, id: {:?} info: {:?}\", source, opt_id, info);\n-        Lvalue { source: source, drop_flag_info: info }\n-    }\n-} // end Lvalue constructor methods.\n-\n-impl Lvalue {\n-    fn has_dropflag_hint<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     id: ast::NodeId) -> bool {\n-        let hints = bcx.fcx.lldropflag_hints.borrow();\n-        hints.has_hint(id)\n-    }\n-    pub fn dropflag_hint<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>)\n-                                 -> Option<DropHintDatum<'tcx>> {\n-        self.drop_flag_info.hint_datum(bcx)\n-    }\n-}\n-\n-impl Rvalue {\n-    pub fn new(m: RvalueMode) -> Rvalue {\n-        Rvalue { mode: m }\n-    }\n-}\n-\n-// Make Datum linear for more type safety.\n-impl Drop for Rvalue {\n-    fn drop(&mut self) { }\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum RvalueMode {\n-    /// `val` is a pointer to the actual value (and thus has type *T)\n-    ByRef,\n-\n-    /// `val` is the actual value (*only used for immediates* like ints, ptrs)\n-    ByValue,\n-}\n-\n-pub fn immediate_rvalue<'tcx>(val: ValueRef, ty: Ty<'tcx>) -> Datum<'tcx, Rvalue> {\n-    return Datum::new(val, ty, Rvalue::new(ByValue));\n-}\n-\n-pub fn immediate_rvalue_bcx<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                        val: ValueRef,\n-                                        ty: Ty<'tcx>)\n-                                        -> DatumBlock<'blk, 'tcx, Rvalue> {\n-    return DatumBlock::new(bcx, immediate_rvalue(val, ty))\n-}\n-\n-/// Allocates temporary space on the stack using alloca() and returns a by-ref Datum pointing to\n-/// it. The memory will be dropped upon exit from `scope`. The callback `populate` should\n-/// initialize the memory.\n-///\n-/// The flag `zero` indicates how the temporary space itself should be\n-/// initialized at the outset of the function; the only time that\n-/// `InitAlloca::Uninit` is a valid value for `zero` is when the\n-/// caller can prove that either (1.) the code injected by `populate`\n-/// onto `bcx` always dominates the end of `scope`, or (2.) the data\n-/// being allocated has no associated destructor.\n-pub fn lvalue_scratch_datum<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                           ty: Ty<'tcx>,\n-                                           name: &str,\n-                                           zero: InitAlloca,\n-                                           scope: cleanup::ScopeId,\n-                                           populate: F)\n-                                           -> DatumBlock<'blk, 'tcx, Lvalue> where\n-    F: FnOnce(Block<'blk, 'tcx>, ValueRef) -> Block<'blk, 'tcx>,\n-{\n-    // Very subtle: potentially initialize the scratch memory at point where it is alloca'ed.\n-    // (See discussion at Issue 30530.)\n-    let scratch = alloc_ty_init(bcx, ty, zero, name);\n-    debug!(\"lvalue_scratch_datum scope={:?} scratch={:?} ty={:?}\",\n-           scope, Value(scratch), ty);\n-\n-    // Subtle. Populate the scratch memory *before* scheduling cleanup.\n-    let bcx = populate(bcx, scratch);\n-    bcx.fcx.schedule_drop_mem(scope, scratch, ty, None);\n-\n-    DatumBlock::new(bcx, Datum::new(scratch, ty, Lvalue::new(\"datum::lvalue_scratch_datum\")))\n-}\n-\n-/// Allocates temporary space on the stack using alloca() and returns a by-ref Datum pointing to\n-/// it.  If `zero` is true, the space will be zeroed when it is allocated; this is normally not\n-/// necessary, but in the case of automatic rooting in match statements it is possible to have\n-/// temporaries that may not get initialized if a certain arm is not taken, so we must zero them.\n-/// You must arrange any cleanups etc yourself!\n-pub fn rvalue_scratch_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                        ty: Ty<'tcx>,\n-                                        name: &str)\n-                                        -> Datum<'tcx, Rvalue> {\n-    let scratch = alloc_ty(bcx, ty, name);\n-    call_lifetime_start(bcx, scratch);\n-    Datum::new(scratch, ty, Rvalue::new(ByRef))\n-}\n-\n-/// Indicates the \"appropriate\" mode for this value, which is either by ref or by value, depending\n-/// on whether type is immediate or not.\n-pub fn appropriate_rvalue_mode<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                         ty: Ty<'tcx>) -> RvalueMode {\n-    if type_is_immediate(ccx, ty) {\n-        ByValue\n-    } else {\n-        ByRef\n-    }\n-}\n-\n-fn add_rvalue_clean<'a, 'tcx>(mode: RvalueMode,\n-                              fcx: &FunctionContext<'a, 'tcx>,\n-                              scope: cleanup::ScopeId,\n-                              val: ValueRef,\n-                              ty: Ty<'tcx>) {\n-    debug!(\"add_rvalue_clean scope={:?} val={:?} ty={:?}\",\n-           scope, Value(val), ty);\n-    match mode {\n-        ByValue => { fcx.schedule_drop_immediate(scope, val, ty); }\n-        ByRef => {\n-            fcx.schedule_lifetime_end(scope, val);\n-            fcx.schedule_drop_mem(scope, val, ty, None);\n-        }\n-    }\n-}\n-\n-pub trait KindOps {\n-\n-    /// Take appropriate action after the value in `datum` has been\n-    /// stored to a new location.\n-    fn post_store<'blk, 'tcx>(&self,\n-                              bcx: Block<'blk, 'tcx>,\n-                              val: ValueRef,\n-                              ty: Ty<'tcx>)\n-                              -> Block<'blk, 'tcx>;\n-\n-    /// True if this mode is a reference mode, meaning that the datum's\n-    /// val field is a pointer to the actual value\n-    fn is_by_ref(&self) -> bool;\n-\n-    /// Converts to an Expr kind\n-    fn to_expr_kind(self) -> Expr;\n-\n-}\n-\n-impl KindOps for Rvalue {\n-    fn post_store<'blk, 'tcx>(&self,\n-                              bcx: Block<'blk, 'tcx>,\n-                              _val: ValueRef,\n-                              _ty: Ty<'tcx>)\n-                              -> Block<'blk, 'tcx> {\n-        // No cleanup is scheduled for an rvalue, so we don't have\n-        // to do anything after a move to cancel or duplicate it.\n-        if self.is_by_ref() {\n-            call_lifetime_end(bcx, _val);\n-        }\n-        bcx\n-    }\n-\n-    fn is_by_ref(&self) -> bool {\n-        self.mode == ByRef\n-    }\n-\n-    fn to_expr_kind(self) -> Expr {\n-        RvalueExpr(self)\n-    }\n-}\n-\n-impl KindOps for Lvalue {\n-    /// If an lvalue is moved, we must zero out the memory in which it resides so as to cancel\n-    /// cleanup. If an @T lvalue is copied, we must increment the reference count.\n-    fn post_store<'blk, 'tcx>(&self,\n-                              bcx: Block<'blk, 'tcx>,\n-                              val: ValueRef,\n-                              ty: Ty<'tcx>)\n-                              -> Block<'blk, 'tcx> {\n-        let _icx = push_ctxt(\"<Lvalue as KindOps>::post_store\");\n-        if bcx.fcx.type_needs_drop(ty) {\n-            // cancel cleanup of affine values:\n-            // 1. if it has drop-hint, mark as moved; then code\n-            //    aware of drop-hint won't bother calling the\n-            //    drop-glue itself.\n-            if let Some(hint_datum) = self.drop_flag_info.hint_datum(bcx) {\n-                let moved_hint_byte = adt::DTOR_MOVED_HINT;\n-                let hint_llval = hint_datum.to_value().value();\n-                Store(bcx, C_u8(bcx.fcx.ccx, moved_hint_byte), hint_llval);\n-            }\n-            // 2. if the drop info says its necessary, drop-fill the memory.\n-            if self.drop_flag_info.must_zero() {\n-                let () = drop_done_fill_mem(bcx, val, ty);\n-            }\n-            bcx\n-        } else {\n-            // FIXME (#5016) would be nice to assert this, but we have\n-            // to allow for e.g. DontZeroJustUse flags, for now.\n-            //\n-            // (The dropflag hint construction should be taking\n-            // !type_needs_drop into account; earlier analysis phases\n-            // may not have all the info they need to include such\n-            // information properly, I think; in particular the\n-            // fragments analysis works on a non-monomorphized view of\n-            // the code.)\n-            //\n-            // assert_eq!(self.drop_flag_info, DropFlagInfo::None);\n-            bcx\n-        }\n-    }\n-\n-    fn is_by_ref(&self) -> bool {\n-        true\n-    }\n-\n-    fn to_expr_kind(self) -> Expr {\n-        LvalueExpr(self)\n-    }\n-}\n-\n-impl KindOps for Expr {\n-    fn post_store<'blk, 'tcx>(&self,\n-                              bcx: Block<'blk, 'tcx>,\n-                              val: ValueRef,\n-                              ty: Ty<'tcx>)\n-                              -> Block<'blk, 'tcx> {\n-        match *self {\n-            LvalueExpr(ref l) => l.post_store(bcx, val, ty),\n-            RvalueExpr(ref r) => r.post_store(bcx, val, ty),\n-        }\n-    }\n-\n-    fn is_by_ref(&self) -> bool {\n-        match *self {\n-            LvalueExpr(ref l) => l.is_by_ref(),\n-            RvalueExpr(ref r) => r.is_by_ref()\n-        }\n-    }\n-\n-    fn to_expr_kind(self) -> Expr {\n-        self\n-    }\n-}\n-\n-impl<'tcx> Datum<'tcx, Rvalue> {\n-    /// Schedules a cleanup for this datum in the given scope. That means that this datum is no\n-    /// longer an rvalue datum; hence, this function consumes the datum and returns the contained\n-    /// ValueRef.\n-    pub fn add_clean<'a>(self,\n-                         fcx: &FunctionContext<'a, 'tcx>,\n-                         scope: cleanup::ScopeId)\n-                         -> ValueRef {\n-        add_rvalue_clean(self.kind.mode, fcx, scope, self.val, self.ty);\n-        self.val\n-    }\n-\n-    /// Returns an lvalue datum (that is, a by ref datum with cleanup scheduled). If `self` is not\n-    /// already an lvalue, cleanup will be scheduled in the temporary scope for `expr_id`.\n-    pub fn to_lvalue_datum_in_scope<'blk>(self,\n-                                          bcx: Block<'blk, 'tcx>,\n-                                          name: &str,\n-                                          scope: cleanup::ScopeId)\n-                                          -> DatumBlock<'blk, 'tcx, Lvalue> {\n-        let fcx = bcx.fcx;\n-\n-        match self.kind.mode {\n-            ByRef => {\n-                add_rvalue_clean(ByRef, fcx, scope, self.val, self.ty);\n-                DatumBlock::new(bcx, Datum::new(\n-                    self.val,\n-                    self.ty,\n-                    Lvalue::new(\"datum::to_lvalue_datum_in_scope\")))\n-            }\n-\n-            ByValue => {\n-                lvalue_scratch_datum(\n-                    bcx, self.ty, name, InitAlloca::Dropped, scope,\n-                    |bcx, llval| {\n-                        debug!(\"populate call for Datum::to_lvalue_datum_in_scope \\\n-                                self.ty={:?}\", self.ty);\n-                        // do not call_lifetime_start here; the\n-                        // `InitAlloc::Dropped` will start scratch\n-                        // value's lifetime at open of function body.\n-                        let bcx = self.store_to(bcx, llval);\n-                        bcx.fcx.schedule_lifetime_end(scope, llval);\n-                        bcx\n-                    })\n-            }\n-        }\n-    }\n-\n-    pub fn to_ref_datum<'blk>(self, bcx: Block<'blk, 'tcx>)\n-                              -> DatumBlock<'blk, 'tcx, Rvalue> {\n-        let mut bcx = bcx;\n-        match self.kind.mode {\n-            ByRef => DatumBlock::new(bcx, self),\n-            ByValue => {\n-                let scratch = rvalue_scratch_datum(bcx, self.ty, \"to_ref\");\n-                bcx = self.store_to(bcx, scratch.val);\n-                DatumBlock::new(bcx, scratch)\n-            }\n-        }\n-    }\n-\n-    pub fn to_appropriate_datum<'blk>(self, bcx: Block<'blk, 'tcx>)\n-                                      -> DatumBlock<'blk, 'tcx, Rvalue> {\n-        match self.appropriate_rvalue_mode(bcx.ccx()) {\n-            ByRef => {\n-                self.to_ref_datum(bcx)\n-            }\n-            ByValue => {\n-                match self.kind.mode {\n-                    ByValue => DatumBlock::new(bcx, self),\n-                    ByRef => {\n-                        let llval = load_ty(bcx, self.val, self.ty);\n-                        call_lifetime_end(bcx, self.val);\n-                        DatumBlock::new(bcx, Datum::new(llval, self.ty, Rvalue::new(ByValue)))\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// Methods suitable for \"expr\" datums that could be either lvalues or\n-/// rvalues. These include coercions into lvalues/rvalues but also a number\n-/// of more general operations. (Some of those operations could be moved to\n-/// the more general `impl<K> Datum<K>`, but it's convenient to have them\n-/// here since we can `match self.kind` rather than having to implement\n-/// generic methods in `KindOps`.)\n-impl<'tcx> Datum<'tcx, Expr> {\n-    fn match_kind<R, F, G>(self, if_lvalue: F, if_rvalue: G) -> R where\n-        F: FnOnce(Datum<'tcx, Lvalue>) -> R,\n-        G: FnOnce(Datum<'tcx, Rvalue>) -> R,\n-    {\n-        let Datum { val, ty, kind } = self;\n-        match kind {\n-            LvalueExpr(l) => if_lvalue(Datum::new(val, ty, l)),\n-            RvalueExpr(r) => if_rvalue(Datum::new(val, ty, r)),\n-        }\n-    }\n-\n-    /// Asserts that this datum *is* an lvalue and returns it.\n-    #[allow(dead_code)] // potentially useful\n-    pub fn assert_lvalue(self) -> Datum<'tcx, Lvalue> {\n-        self.match_kind(\n-            |d| d,\n-            |_| bug!(\"assert_lvalue given rvalue\"))\n-    }\n-\n-    pub fn store_to_dest<'blk>(self,\n-                               bcx: Block<'blk, 'tcx>,\n-                               dest: expr::Dest,\n-                               expr_id: ast::NodeId)\n-                               -> Block<'blk, 'tcx> {\n-        match dest {\n-            expr::Ignore => {\n-                self.add_clean_if_rvalue(bcx, expr_id);\n-                bcx\n-            }\n-            expr::SaveIn(addr) => {\n-                self.store_to(bcx, addr)\n-            }\n-        }\n-    }\n-\n-    /// Arranges cleanup for `self` if it is an rvalue. Use when you are done working with a value\n-    /// that may need drop.\n-    pub fn add_clean_if_rvalue<'blk>(self,\n-                                     bcx: Block<'blk, 'tcx>,\n-                                     expr_id: ast::NodeId) {\n-        self.match_kind(\n-            |_| { /* Nothing to do, cleanup already arranged */ },\n-            |r| {\n-                let scope = cleanup::temporary_scope(bcx.tcx(), expr_id);\n-                r.add_clean(bcx.fcx, scope);\n-            })\n-    }\n-\n-    pub fn to_lvalue_datum<'blk>(self,\n-                                 bcx: Block<'blk, 'tcx>,\n-                                 name: &str,\n-                                 expr_id: ast::NodeId)\n-                                 -> DatumBlock<'blk, 'tcx, Lvalue> {\n-        debug!(\"to_lvalue_datum self: {:?}\", self);\n-\n-        self.match_kind(\n-            |l| DatumBlock::new(bcx, l),\n-            |r| {\n-                let scope = cleanup::temporary_scope(bcx.tcx(), expr_id);\n-                r.to_lvalue_datum_in_scope(bcx, name, scope)\n-            })\n-    }\n-\n-    /// Ensures that we have an rvalue datum (that is, a datum with no cleanup scheduled).\n-    pub fn to_rvalue_datum<'blk>(self,\n-                                 bcx: Block<'blk, 'tcx>,\n-                                 name: &'static str)\n-                                 -> DatumBlock<'blk, 'tcx, Rvalue> {\n-        self.match_kind(\n-            |l| {\n-                let mut bcx = bcx;\n-                match l.appropriate_rvalue_mode(bcx.ccx()) {\n-                    ByRef => {\n-                        let scratch = rvalue_scratch_datum(bcx, l.ty, name);\n-                        bcx = l.store_to(bcx, scratch.val);\n-                        DatumBlock::new(bcx, scratch)\n-                    }\n-                    ByValue => {\n-                        let v = load_ty(bcx, l.val, l.ty);\n-                        bcx = l.kind.post_store(bcx, l.val, l.ty);\n-                        DatumBlock::new(bcx, Datum::new(v, l.ty, Rvalue::new(ByValue)))\n-                    }\n-                }\n-            },\n-            |r| DatumBlock::new(bcx, r))\n-    }\n-\n-}\n-\n-/// Methods suitable only for lvalues. These include the various\n-/// operations to extract components out of compound data structures,\n-/// such as extracting the field from a struct or a particular element\n-/// from an array.\n-impl<'tcx> Datum<'tcx, Lvalue> {\n-    /// Converts a datum into a by-ref value. The datum type must be one which is always passed by\n-    /// reference.\n-    pub fn to_llref(self) -> ValueRef {\n-        self.val\n-    }\n-\n-    // Extracts a component of a compound data structure (e.g., a field from a\n-    // struct). Note that if self is an opened, unsized type then the returned\n-    // datum may also be unsized _without the size information_. It is the\n-    // callers responsibility to package the result in some way to make a valid\n-    // datum in that case (e.g., by making a fat pointer or opened pair).\n-    pub fn get_element<'blk, F>(&self, bcx: Block<'blk, 'tcx>, ty: Ty<'tcx>,\n-                                gep: F)\n-                                -> Datum<'tcx, Lvalue> where\n-        F: FnOnce(adt::MaybeSizedValue) -> ValueRef,\n-    {\n-        let val = if type_is_sized(bcx.tcx(), self.ty) {\n-            let val = adt::MaybeSizedValue::sized(self.val);\n-            gep(val)\n-        } else {\n-            let val = adt::MaybeSizedValue::unsized_(\n-                Load(bcx, expr::get_dataptr(bcx, self.val)),\n-                Load(bcx, expr::get_meta(bcx, self.val)));\n-            gep(val)\n-        };\n-        Datum {\n-            val: val,\n-            kind: Lvalue::new(\"Datum::get_element\"),\n-            ty: ty,\n-        }\n-    }\n-\n-    pub fn get_vec_base_and_len<'blk>(&self, bcx: Block<'blk, 'tcx>)\n-                                      -> (ValueRef, ValueRef) {\n-        //! Converts a vector into the slice pair.\n-\n-        tvec::get_base_and_len(bcx, self.val, self.ty)\n-    }\n-}\n-\n-/// Generic methods applicable to any sort of datum.\n-impl<'tcx, K: KindOps + fmt::Debug> Datum<'tcx, K> {\n-    pub fn new(val: ValueRef, ty: Ty<'tcx>, kind: K) -> Datum<'tcx, K> {\n-        Datum { val: val, ty: ty, kind: kind }\n-    }\n-\n-    pub fn to_expr_datum(self) -> Datum<'tcx, Expr> {\n-        let Datum { val, ty, kind } = self;\n-        Datum { val: val, ty: ty, kind: kind.to_expr_kind() }\n-    }\n-\n-    /// Moves or copies this value into a new home, as appropriate depending on the type of the\n-    /// datum. This method consumes the datum, since it would be incorrect to go on using the datum\n-    /// if the value represented is affine (and hence the value is moved).\n-    pub fn store_to<'blk>(self,\n-                          bcx: Block<'blk, 'tcx>,\n-                          dst: ValueRef)\n-                          -> Block<'blk, 'tcx> {\n-        self.shallow_copy_raw(bcx, dst);\n-\n-        self.kind.post_store(bcx, self.val, self.ty)\n-    }\n-\n-    /// Helper function that performs a shallow copy of this value into `dst`, which should be a\n-    /// pointer to a memory location suitable for `self.ty`. `dst` should contain uninitialized\n-    /// memory (either newly allocated, zeroed, or dropped).\n-    ///\n-    /// This function is private to datums because it leaves memory in an unstable state, where the\n-    /// source value has been copied but not zeroed. Public methods are `store_to` (if you no\n-    /// longer need the source value) or `shallow_copy` (if you wish the source value to remain\n-    /// valid).\n-    fn shallow_copy_raw<'blk>(&self,\n-                              bcx: Block<'blk, 'tcx>,\n-                              dst: ValueRef)\n-                              -> Block<'blk, 'tcx> {\n-        let _icx = push_ctxt(\"copy_to_no_check\");\n-\n-        if type_is_zero_size(bcx.ccx(), self.ty) {\n-            return bcx;\n-        }\n-\n-        if self.kind.is_by_ref() {\n-            memcpy_ty(bcx, dst, self.val, self.ty);\n-        } else {\n-            store_ty(bcx, self.val, dst, self.ty);\n-        }\n-\n-        return bcx;\n-    }\n-\n-    /// Copies the value into a new location. This function always preserves the existing datum as\n-    /// a valid value. Therefore, it does not consume `self` and, also, cannot be applied to affine\n-    /// values (since they must never be duplicated).\n-    pub fn shallow_copy<'blk>(&self,\n-                              bcx: Block<'blk, 'tcx>,\n-                              dst: ValueRef)\n-                              -> Block<'blk, 'tcx> {\n-        /*!\n-         * Copies the value into a new location. This function always\n-         * preserves the existing datum as a valid value. Therefore,\n-         * it does not consume `self` and, also, cannot be applied to\n-         * affine values (since they must never be duplicated).\n-         */\n-\n-        assert!(!self.ty.moves_by_default(bcx.tcx(),\n-            &bcx.tcx().empty_parameter_environment(), DUMMY_SP));\n-        self.shallow_copy_raw(bcx, dst)\n-    }\n-\n-    /// See the `appropriate_rvalue_mode()` function\n-    pub fn appropriate_rvalue_mode<'a>(&self, ccx: &CrateContext<'a, 'tcx>)\n-                                       -> RvalueMode {\n-        appropriate_rvalue_mode(ccx, self.ty)\n-    }\n-\n-    /// Converts `self` into a by-value `ValueRef`. Consumes this datum (i.e., absolves you of\n-    /// responsibility to cleanup the value). For this to work, the value must be something\n-    /// scalar-ish (like an int or a pointer) which (1) does not require drop glue and (2) is\n-    /// naturally passed around by value, and not by reference.\n-    pub fn to_llscalarish<'blk>(self, bcx: Block<'blk, 'tcx>) -> ValueRef {\n-        assert!(!bcx.fcx.type_needs_drop(self.ty));\n-        assert!(self.appropriate_rvalue_mode(bcx.ccx()) == ByValue);\n-        if self.kind.is_by_ref() {\n-            load_ty(bcx, self.val, self.ty)\n-        } else {\n-            self.val\n-        }\n-    }\n-\n-    pub fn to_llbool<'blk>(self, bcx: Block<'blk, 'tcx>) -> ValueRef {\n-        assert!(self.ty.is_bool());\n-        self.to_llscalarish(bcx)\n-    }\n-}\n-\n-impl<'blk, 'tcx, K> DatumBlock<'blk, 'tcx, K> {\n-    pub fn new(bcx: Block<'blk, 'tcx>, datum: Datum<'tcx, K>)\n-               -> DatumBlock<'blk, 'tcx, K> {\n-        DatumBlock { bcx: bcx, datum: datum }\n-    }\n-}\n-\n-impl<'blk, 'tcx, K: KindOps + fmt::Debug> DatumBlock<'blk, 'tcx, K> {\n-    pub fn to_expr_datumblock(self) -> DatumBlock<'blk, 'tcx, Expr> {\n-        DatumBlock::new(self.bcx, self.datum.to_expr_datum())\n-    }\n-}\n-\n-impl<'blk, 'tcx> DatumBlock<'blk, 'tcx, Expr> {\n-    pub fn store_to_dest(self,\n-                         dest: expr::Dest,\n-                         expr_id: ast::NodeId) -> Block<'blk, 'tcx> {\n-        let DatumBlock { bcx, datum } = self;\n-        datum.store_to_dest(bcx, dest, expr_id)\n-    }\n-\n-    pub fn to_llbool(self) -> Result<'blk, 'tcx> {\n-        let DatumBlock { datum, bcx } = self;\n-        Result::new(bcx, datum.to_llbool(bcx))\n-    }\n-}"}, {"sha": "58cf85747374ae45c0a88bea7aadfab69097d3fa", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 446, "changes": 447, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -15,58 +15,15 @@ use super::utils::{DIB, span_start};\n use llvm;\n use llvm::debuginfo::{DIScope, DISubprogram};\n use common::{CrateContext, FunctionContext};\n-use rustc::hir::pat_util;\n use rustc::mir::repr::{Mir, VisibilityScope};\n-use rustc::util::nodemap::NodeMap;\n \n use libc::c_uint;\n use std::ptr;\n \n-use syntax_pos::{Span, Pos};\n-use syntax::{ast, codemap};\n+use syntax_pos::Pos;\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc::hir::{self, PatKind};\n-\n-// This procedure builds the *scope map* for a given function, which maps any\n-// given ast::NodeId in the function's AST to the correct DIScope metadata instance.\n-//\n-// This builder procedure walks the AST in execution order and keeps track of\n-// what belongs to which scope, creating DIScope DIEs along the way, and\n-// introducing *artificial* lexical scope descriptors where necessary. These\n-// artificial scopes allow GDB to correctly handle name shadowing.\n-pub fn create_scope_map(cx: &CrateContext,\n-                        args: &[hir::Arg],\n-                        fn_entry_block: &hir::Block,\n-                        fn_metadata: DISubprogram,\n-                        fn_ast_id: ast::NodeId)\n-                        -> NodeMap<DIScope> {\n-    let mut scope_map = NodeMap();\n-    let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata, name: None });\n-    scope_map.insert(fn_ast_id, fn_metadata);\n-\n-    // Push argument identifiers onto the stack so arguments integrate nicely\n-    // with variable shadowing.\n-    for arg in args {\n-        pat_util::pat_bindings(&arg.pat, |_, node_id, _, path1| {\n-            scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n-                                               name: Some(path1.node) });\n-            scope_map.insert(node_id, fn_metadata);\n-        })\n-    }\n-\n-    // Clang creates a separate scope for function bodies, so let's do this too.\n-    with_new_scope(cx,\n-                   fn_entry_block.span,\n-                   &mut scope_stack,\n-                   &mut scope_map,\n-                   |cx, scope_stack, scope_map| {\n-        walk_block(cx, fn_entry_block, scope_stack, scope_map);\n-    });\n-\n-    return scope_map;\n-}\n \n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n@@ -141,405 +98,3 @@ fn make_mir_scope(ccx: &CrateContext,\n             loc.col.to_usize() as c_uint)\n     };\n }\n-\n-// local helper functions for walking the AST.\n-fn with_new_scope<F>(cx: &CrateContext,\n-                     scope_span: Span,\n-                     scope_stack: &mut Vec<ScopeStackEntry> ,\n-                     scope_map: &mut NodeMap<DIScope>,\n-                     inner_walk: F) where\n-    F: FnOnce(&CrateContext, &mut Vec<ScopeStackEntry>, &mut NodeMap<DIScope>),\n-{\n-    // Create a new lexical scope and push it onto the stack\n-    let loc = span_start(cx, scope_span);\n-    let file_metadata = file_metadata(cx, &loc.file.name, &loc.file.abs_path);\n-    let parent_scope = scope_stack.last().unwrap().scope_metadata;\n-\n-    let scope_metadata = unsafe {\n-        llvm::LLVMRustDIBuilderCreateLexicalBlock(\n-            DIB(cx),\n-            parent_scope,\n-            file_metadata,\n-            loc.line as c_uint,\n-            loc.col.to_usize() as c_uint)\n-    };\n-\n-    scope_stack.push(ScopeStackEntry { scope_metadata: scope_metadata, name: None });\n-\n-    inner_walk(cx, scope_stack, scope_map);\n-\n-    // pop artificial scopes\n-    while scope_stack.last().unwrap().name.is_some() {\n-        scope_stack.pop();\n-    }\n-\n-    if scope_stack.last().unwrap().scope_metadata != scope_metadata {\n-        span_bug!(scope_span, \"debuginfo: Inconsistency in scope management.\");\n-    }\n-\n-    scope_stack.pop();\n-}\n-\n-struct ScopeStackEntry {\n-    scope_metadata: DIScope,\n-    name: Option<ast::Name>\n-}\n-\n-fn walk_block(cx: &CrateContext,\n-              block: &hir::Block,\n-              scope_stack: &mut Vec<ScopeStackEntry> ,\n-              scope_map: &mut NodeMap<DIScope>) {\n-    scope_map.insert(block.id, scope_stack.last().unwrap().scope_metadata);\n-\n-    // The interesting things here are statements and the concluding expression.\n-    for statement in &block.stmts {\n-        scope_map.insert(statement.node.id(),\n-                         scope_stack.last().unwrap().scope_metadata);\n-\n-        match statement.node {\n-            hir::StmtDecl(ref decl, _) =>\n-                walk_decl(cx, &decl, scope_stack, scope_map),\n-            hir::StmtExpr(ref exp, _) |\n-            hir::StmtSemi(ref exp, _) =>\n-                walk_expr(cx, &exp, scope_stack, scope_map),\n-        }\n-    }\n-\n-    if let Some(ref exp) = block.expr {\n-        walk_expr(cx, &exp, scope_stack, scope_map);\n-    }\n-}\n-\n-fn walk_decl(cx: &CrateContext,\n-             decl: &hir::Decl,\n-             scope_stack: &mut Vec<ScopeStackEntry> ,\n-             scope_map: &mut NodeMap<DIScope>) {\n-    match *decl {\n-        codemap::Spanned { node: hir::DeclLocal(ref local), .. } => {\n-            scope_map.insert(local.id, scope_stack.last().unwrap().scope_metadata);\n-\n-            walk_pattern(cx, &local.pat, scope_stack, scope_map);\n-\n-            if let Some(ref exp) = local.init {\n-                walk_expr(cx, &exp, scope_stack, scope_map);\n-            }\n-        }\n-        _ => ()\n-    }\n-}\n-\n-fn walk_pattern(cx: &CrateContext,\n-                pat: &hir::Pat,\n-                scope_stack: &mut Vec<ScopeStackEntry> ,\n-                scope_map: &mut NodeMap<DIScope>) {\n-    // Unfortunately, we cannot just use pat_util::pat_bindings() or\n-    // ast_util::walk_pat() here because we have to visit *all* nodes in\n-    // order to put them into the scope map. The above functions don't do that.\n-    match pat.node {\n-        PatKind::Binding(_, ref path1, ref sub_pat_opt) => {\n-            // LLVM does not properly generate 'DW_AT_start_scope' fields\n-            // for variable DIEs. For this reason we have to introduce\n-            // an artificial scope at bindings whenever a variable with\n-            // the same name is declared in *any* parent scope.\n-            //\n-            // Otherwise the following error occurs:\n-            //\n-            // let x = 10;\n-            //\n-            // do_something(); // 'gdb print x' correctly prints 10\n-            //\n-            // {\n-            //     do_something(); // 'gdb print x' prints 0, because it\n-            //                     // already reads the uninitialized 'x'\n-            //                     // from the next line...\n-            //     let x = 100;\n-            //     do_something(); // 'gdb print x' correctly prints 100\n-            // }\n-\n-            // Is there already a binding with that name?\n-            // N.B.: this comparison must be UNhygienic... because\n-            // gdb knows nothing about the context, so any two\n-            // variables with the same name will cause the problem.\n-            let name = path1.node;\n-            let need_new_scope = scope_stack\n-                .iter()\n-                .any(|entry| entry.name == Some(name));\n-\n-            if need_new_scope {\n-                // Create a new lexical scope and push it onto the stack\n-                let loc = span_start(cx, pat.span);\n-                let file_metadata = file_metadata(cx, &loc.file.name, &loc.file.abs_path);\n-                let parent_scope = scope_stack.last().unwrap().scope_metadata;\n-\n-                let scope_metadata = unsafe {\n-                    llvm::LLVMRustDIBuilderCreateLexicalBlock(\n-                        DIB(cx),\n-                        parent_scope,\n-                        file_metadata,\n-                        loc.line as c_uint,\n-                        loc.col.to_usize() as c_uint)\n-                };\n-\n-                scope_stack.push(ScopeStackEntry {\n-                    scope_metadata: scope_metadata,\n-                    name: Some(name)\n-                });\n-\n-            } else {\n-                // Push a new entry anyway so the name can be found\n-                let prev_metadata = scope_stack.last().unwrap().scope_metadata;\n-                scope_stack.push(ScopeStackEntry {\n-                    scope_metadata: prev_metadata,\n-                    name: Some(name)\n-                });\n-            }\n-\n-            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-\n-            if let Some(ref sub_pat) = *sub_pat_opt {\n-                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n-            }\n-        }\n-\n-        PatKind::Wild => {\n-            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-        }\n-\n-        PatKind::TupleStruct(_, ref sub_pats, _) => {\n-            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-\n-            for p in sub_pats {\n-                walk_pattern(cx, &p, scope_stack, scope_map);\n-            }\n-        }\n-\n-        PatKind::Path(..) => {\n-            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-        }\n-\n-        PatKind::Struct(_, ref field_pats, _) => {\n-            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-\n-            for &codemap::Spanned {\n-                node: hir::FieldPat { pat: ref sub_pat, .. },\n-                ..\n-            } in field_pats {\n-                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n-            }\n-        }\n-\n-        PatKind::Tuple(ref sub_pats, _) => {\n-            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-\n-            for sub_pat in sub_pats {\n-                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n-            }\n-        }\n-\n-        PatKind::Box(ref sub_pat) | PatKind::Ref(ref sub_pat, _) => {\n-            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-            walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n-        }\n-\n-        PatKind::Lit(ref exp) => {\n-            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-            walk_expr(cx, &exp, scope_stack, scope_map);\n-        }\n-\n-        PatKind::Range(ref exp1, ref exp2) => {\n-            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-            walk_expr(cx, &exp1, scope_stack, scope_map);\n-            walk_expr(cx, &exp2, scope_stack, scope_map);\n-        }\n-\n-        PatKind::Vec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n-            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-\n-            for sub_pat in front_sub_pats {\n-                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n-            }\n-\n-            if let Some(ref sub_pat) = *middle_sub_pats {\n-                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n-            }\n-\n-            for sub_pat in back_sub_pats {\n-                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n-            }\n-        }\n-    }\n-}\n-\n-fn walk_expr(cx: &CrateContext,\n-             exp: &hir::Expr,\n-             scope_stack: &mut Vec<ScopeStackEntry> ,\n-             scope_map: &mut NodeMap<DIScope>) {\n-\n-    scope_map.insert(exp.id, scope_stack.last().unwrap().scope_metadata);\n-\n-    match exp.node {\n-        hir::ExprLit(_)   |\n-        hir::ExprBreak(_) |\n-        hir::ExprAgain(_) |\n-        hir::ExprPath(..) => {}\n-\n-        hir::ExprCast(ref sub_exp, _)     |\n-        hir::ExprType(ref sub_exp, _) |\n-        hir::ExprAddrOf(_, ref sub_exp)  |\n-        hir::ExprField(ref sub_exp, _) |\n-        hir::ExprTupField(ref sub_exp, _) =>\n-            walk_expr(cx, &sub_exp, scope_stack, scope_map),\n-\n-        hir::ExprBox(ref sub_expr) => {\n-            walk_expr(cx, &sub_expr, scope_stack, scope_map);\n-        }\n-\n-        hir::ExprRet(ref exp_opt) => match *exp_opt {\n-            Some(ref sub_exp) => walk_expr(cx, &sub_exp, scope_stack, scope_map),\n-            None => ()\n-        },\n-\n-        hir::ExprUnary(_, ref sub_exp) => {\n-            walk_expr(cx, &sub_exp, scope_stack, scope_map);\n-        }\n-\n-        hir::ExprAssignOp(_, ref lhs, ref rhs) |\n-        hir::ExprIndex(ref lhs, ref rhs) |\n-        hir::ExprBinary(_, ref lhs, ref rhs)    => {\n-            walk_expr(cx, &lhs, scope_stack, scope_map);\n-            walk_expr(cx, &rhs, scope_stack, scope_map);\n-        }\n-\n-        hir::ExprVec(ref init_expressions) |\n-        hir::ExprTup(ref init_expressions) => {\n-            for ie in init_expressions {\n-                walk_expr(cx, &ie, scope_stack, scope_map);\n-            }\n-        }\n-\n-        hir::ExprAssign(ref sub_exp1, ref sub_exp2) |\n-        hir::ExprRepeat(ref sub_exp1, ref sub_exp2) => {\n-            walk_expr(cx, &sub_exp1, scope_stack, scope_map);\n-            walk_expr(cx, &sub_exp2, scope_stack, scope_map);\n-        }\n-\n-        hir::ExprIf(ref cond_exp, ref then_block, ref opt_else_exp) => {\n-            walk_expr(cx, &cond_exp, scope_stack, scope_map);\n-\n-            with_new_scope(cx,\n-                           then_block.span,\n-                           scope_stack,\n-                           scope_map,\n-                           |cx, scope_stack, scope_map| {\n-                walk_block(cx, &then_block, scope_stack, scope_map);\n-            });\n-\n-            match *opt_else_exp {\n-                Some(ref else_exp) =>\n-                    walk_expr(cx, &else_exp, scope_stack, scope_map),\n-                _ => ()\n-            }\n-        }\n-\n-        hir::ExprWhile(ref cond_exp, ref loop_body, _) => {\n-            walk_expr(cx, &cond_exp, scope_stack, scope_map);\n-\n-            with_new_scope(cx,\n-                           loop_body.span,\n-                           scope_stack,\n-                           scope_map,\n-                           |cx, scope_stack, scope_map| {\n-                walk_block(cx, &loop_body, scope_stack, scope_map);\n-            })\n-        }\n-\n-        hir::ExprLoop(ref block, _) |\n-        hir::ExprBlock(ref block)   => {\n-            with_new_scope(cx,\n-                           block.span,\n-                           scope_stack,\n-                           scope_map,\n-                           |cx, scope_stack, scope_map| {\n-                walk_block(cx, &block, scope_stack, scope_map);\n-            })\n-        }\n-\n-        hir::ExprClosure(_, ref decl, ref block, _) => {\n-            with_new_scope(cx,\n-                           block.span,\n-                           scope_stack,\n-                           scope_map,\n-                           |cx, scope_stack, scope_map| {\n-                for &hir::Arg { pat: ref pattern, .. } in &decl.inputs {\n-                    walk_pattern(cx, &pattern, scope_stack, scope_map);\n-                }\n-\n-                walk_block(cx, &block, scope_stack, scope_map);\n-            })\n-        }\n-\n-        hir::ExprCall(ref fn_exp, ref args) => {\n-            walk_expr(cx, &fn_exp, scope_stack, scope_map);\n-\n-            for arg_exp in args {\n-                walk_expr(cx, &arg_exp, scope_stack, scope_map);\n-            }\n-        }\n-\n-        hir::ExprMethodCall(_, _, ref args) => {\n-            for arg_exp in args {\n-                walk_expr(cx, &arg_exp, scope_stack, scope_map);\n-            }\n-        }\n-\n-        hir::ExprMatch(ref discriminant_exp, ref arms, _) => {\n-            walk_expr(cx, &discriminant_exp, scope_stack, scope_map);\n-\n-            // For each arm we have to first walk the pattern as these might\n-            // introduce new artificial scopes. It should be sufficient to\n-            // walk only one pattern per arm, as they all must contain the\n-            // same binding names.\n-\n-            for arm_ref in arms {\n-                let arm_span = arm_ref.pats[0].span;\n-\n-                with_new_scope(cx,\n-                               arm_span,\n-                               scope_stack,\n-                               scope_map,\n-                               |cx, scope_stack, scope_map| {\n-                    for pat in &arm_ref.pats {\n-                        walk_pattern(cx, &pat, scope_stack, scope_map);\n-                    }\n-\n-                    if let Some(ref guard_exp) = arm_ref.guard {\n-                        walk_expr(cx, &guard_exp, scope_stack, scope_map)\n-                    }\n-\n-                    walk_expr(cx, &arm_ref.body, scope_stack, scope_map);\n-                })\n-            }\n-        }\n-\n-        hir::ExprStruct(_, ref fields, ref base_exp) => {\n-            for &hir::Field { expr: ref exp, .. } in fields {\n-                walk_expr(cx, &exp, scope_stack, scope_map);\n-            }\n-\n-            match *base_exp {\n-                Some(ref exp) => walk_expr(cx, &exp, scope_stack, scope_map),\n-                None => ()\n-            }\n-        }\n-\n-        hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n-            for output in outputs {\n-                walk_expr(cx, output, scope_stack, scope_map);\n-            }\n-\n-            for input in inputs {\n-                walk_expr(cx, input, scope_stack, scope_map);\n-            }\n-        }\n-    }\n-}"}, {"sha": "ba91b44343868decf494f3fde8396616c62bff71", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 8, "deletions": 255, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -14,28 +14,24 @@ use self::MemberDescriptionFactory::*;\n use self::EnumDiscriminantInfo::*;\n \n use super::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n-                   get_namespace_and_span_for_item, create_DIArray,\n-                   fn_should_be_ignored, is_node_local_to_unit};\n+                   get_namespace_and_span_for_item, create_DIArray, is_node_local_to_unit};\n use super::namespace::mangled_name_of_item;\n use super::type_names::{compute_debuginfo_type_name, push_debuginfo_type_name};\n-use super::{declare_local, VariableKind, VariableAccess, CrateDebugContext};\n+use super::{CrateDebugContext};\n use context::SharedCrateContext;\n use session::Session;\n \n use llvm::{self, ValueRef};\n use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType};\n \n use rustc::hir::def_id::DefId;\n-use rustc::hir::pat_util;\n use rustc::ty::subst::Substs;\n-use rustc::hir::map as hir_map;\n-use rustc::hir::{self, PatKind};\n+use rustc::hir;\n use {type_of, adt, machine, monomorphize};\n-use common::{self, CrateContext, FunctionContext, Block};\n-use _match::{BindingInfo, TransBindingMode};\n+use common::CrateContext;\n use type_::Type;\n use rustc::ty::{self, Ty};\n-use session::config::{self, FullDebugInfo};\n+use session::config;\n use util::nodemap::FnvHashMap;\n use util::common::path2cstr;\n \n@@ -886,26 +882,6 @@ fn file_metadata_(cx: &CrateContext, key: &str, file_name: &str, work_dir: &str)\n     file_metadata\n }\n \n-/// Finds the scope metadata node for the given AST node.\n-pub fn scope_metadata(fcx: &FunctionContext,\n-                  node_id: ast::NodeId,\n-                  error_reporting_span: Span)\n-               -> DIScope {\n-    let scope_map = &fcx.debug_context\n-                        .get_ref(error_reporting_span)\n-                        .scope_map;\n-    match scope_map.borrow().get(&node_id).cloned() {\n-        Some(scope_metadata) => scope_metadata,\n-        None => {\n-            let node = fcx.ccx.tcx().map.get(node_id);\n-\n-            span_bug!(error_reporting_span,\n-                      \"debuginfo: Could not find scope info for node {:?}\",\n-                      node);\n-        }\n-    }\n-}\n-\n fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  t: Ty<'tcx>) -> DIType {\n \n@@ -1251,7 +1227,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                                       -> Vec<MemberDescription> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n         match *self.type_rep {\n-            adt::General(_, ref struct_defs, _) => {\n+            adt::General(_, ref struct_defs) => {\n                 let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n                     .expect(\"\"));\n                 struct_defs\n@@ -1285,7 +1261,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         }\n                     }).collect()\n             },\n-            adt::Univariant(ref struct_def, _) => {\n+            adt::Univariant(ref struct_def) => {\n                 assert!(adt.variants.len() <= 1);\n \n                 if adt.variants.is_empty() {\n@@ -1635,7 +1611,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         adt::RawNullablePointer { .. }           |\n         adt::StructWrappedNullablePointer { .. } |\n         adt::Univariant(..)                      => None,\n-        adt::General(inttype, _, _) => Some(discriminant_type_metadata(inttype)),\n+        adt::General(inttype, _) => Some(discriminant_type_metadata(inttype)),\n     };\n \n     let enum_llvm_type = type_of::type_of(cx, enum_type);\n@@ -1863,226 +1839,3 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                                     ptr::null_mut());\n     }\n }\n-\n-/// Creates debug information for the given local variable.\n-///\n-/// This function assumes that there's a datum for each pattern component of the\n-/// local in `bcx.fcx.lllocals`.\n-/// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_local_var_metadata(bcx: Block, local: &hir::Local) {\n-    if bcx.unreachable.get() ||\n-       fn_should_be_ignored(bcx.fcx) ||\n-       bcx.sess().opts.debuginfo != FullDebugInfo  {\n-        return;\n-    }\n-\n-    let locals = bcx.fcx.lllocals.borrow();\n-    pat_util::pat_bindings(&local.pat, |_, node_id, span, var_name| {\n-        let datum = match locals.get(&node_id) {\n-            Some(datum) => datum,\n-            None => {\n-                span_bug!(span,\n-                          \"no entry in lllocals table for {}\",\n-                          node_id);\n-            }\n-        };\n-\n-        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            span_bug!(span, \"debuginfo::create_local_var_metadata() - \\\n-                             Referenced variable location is not an alloca!\");\n-        }\n-\n-        let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n-\n-        declare_local(bcx,\n-                      var_name.node,\n-                      datum.ty,\n-                      scope_metadata,\n-                      VariableAccess::DirectVariable { alloca: datum.val },\n-                      VariableKind::LocalVariable,\n-                      span);\n-    })\n-}\n-\n-/// Creates debug information for a variable captured in a closure.\n-///\n-/// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                node_id: ast::NodeId,\n-                                                env_pointer: ValueRef,\n-                                                env_index: usize,\n-                                                captured_by_ref: bool,\n-                                                span: Span) {\n-    if bcx.unreachable.get() ||\n-       fn_should_be_ignored(bcx.fcx) ||\n-       bcx.sess().opts.debuginfo != FullDebugInfo {\n-        return;\n-    }\n-\n-    let cx = bcx.ccx();\n-\n-    let ast_item = cx.tcx().map.find(node_id);\n-\n-    let variable_name = match ast_item {\n-        None => {\n-            span_bug!(span, \"debuginfo::create_captured_var_metadata: node not found\");\n-        }\n-        Some(hir_map::NodeLocal(pat)) => {\n-            match pat.node {\n-                PatKind::Binding(_, ref path1, _) => {\n-                    path1.node\n-                }\n-                _ => {\n-                    span_bug!(span,\n-                              \"debuginfo::create_captured_var_metadata() - \\\n-                               Captured var-id refers to unexpected \\\n-                               hir_map variant: {:?}\",\n-                              ast_item);\n-                }\n-            }\n-        }\n-        _ => {\n-            span_bug!(span,\n-                      \"debuginfo::create_captured_var_metadata() - \\\n-                       Captured var-id refers to unexpected \\\n-                       hir_map variant: {:?}\",\n-                      ast_item);\n-        }\n-    };\n-\n-    let variable_type = common::node_id_type(bcx, node_id);\n-    let scope_metadata = bcx.fcx.debug_context.get_ref(span).fn_metadata;\n-\n-    // env_pointer is the alloca containing the pointer to the environment,\n-    // so it's type is **EnvironmentType. In order to find out the type of\n-    // the environment we have to \"dereference\" two times.\n-    let llvm_env_data_type = common::val_ty(env_pointer).element_type()\n-                                                        .element_type();\n-    let byte_offset_of_var_in_env = machine::llelement_offset(cx,\n-                                                              llvm_env_data_type,\n-                                                              env_index);\n-\n-    let address_operations = unsafe {\n-        [llvm::LLVMRustDIBuilderCreateOpDeref(),\n-         llvm::LLVMRustDIBuilderCreateOpPlus(),\n-         byte_offset_of_var_in_env as i64,\n-         llvm::LLVMRustDIBuilderCreateOpDeref()]\n-    };\n-\n-    let address_op_count = if captured_by_ref {\n-        address_operations.len()\n-    } else {\n-        address_operations.len() - 1\n-    };\n-\n-    let variable_access = VariableAccess::IndirectVariable {\n-        alloca: env_pointer,\n-        address_operations: &address_operations[..address_op_count]\n-    };\n-\n-    declare_local(bcx,\n-                  variable_name,\n-                  variable_type,\n-                  scope_metadata,\n-                  variable_access,\n-                  VariableKind::CapturedVariable,\n-                  span);\n-}\n-\n-/// Creates debug information for a local variable introduced in the head of a\n-/// match-statement arm.\n-///\n-/// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                 variable_name: ast::Name,\n-                                                 binding: BindingInfo<'tcx>) {\n-    if bcx.unreachable.get() ||\n-       fn_should_be_ignored(bcx.fcx) ||\n-       bcx.sess().opts.debuginfo != FullDebugInfo {\n-        return;\n-    }\n-\n-    let scope_metadata = scope_metadata(bcx.fcx, binding.id, binding.span);\n-    let aops = unsafe {\n-        [llvm::LLVMRustDIBuilderCreateOpDeref()]\n-    };\n-    // Regardless of the actual type (`T`) we're always passed the stack slot\n-    // (alloca) for the binding. For ByRef bindings that's a `T*` but for ByMove\n-    // bindings we actually have `T**`. So to get the actual variable we need to\n-    // dereference once more. For ByCopy we just use the stack slot we created\n-    // for the binding.\n-    let var_access = match binding.trmode {\n-        TransBindingMode::TrByCopy(llbinding) |\n-        TransBindingMode::TrByMoveIntoCopy(llbinding) => VariableAccess::DirectVariable {\n-            alloca: llbinding\n-        },\n-        TransBindingMode::TrByMoveRef => VariableAccess::IndirectVariable {\n-            alloca: binding.llmatch,\n-            address_operations: &aops\n-        },\n-        TransBindingMode::TrByRef => VariableAccess::DirectVariable {\n-            alloca: binding.llmatch\n-        }\n-    };\n-\n-    declare_local(bcx,\n-                  variable_name,\n-                  binding.ty,\n-                  scope_metadata,\n-                  var_access,\n-                  VariableKind::LocalVariable,\n-                  binding.span);\n-}\n-\n-/// Creates debug information for the given function argument.\n-///\n-/// This function assumes that there's a datum for each pattern component of the\n-/// argument in `bcx.fcx.lllocals`.\n-/// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_argument_metadata(bcx: Block, arg: &hir::Arg) {\n-    if bcx.unreachable.get() ||\n-       fn_should_be_ignored(bcx.fcx) ||\n-       bcx.sess().opts.debuginfo != FullDebugInfo {\n-        return;\n-    }\n-\n-    let scope_metadata = bcx\n-                         .fcx\n-                         .debug_context\n-                         .get_ref(arg.pat.span)\n-                         .fn_metadata;\n-    let locals = bcx.fcx.lllocals.borrow();\n-\n-    pat_util::pat_bindings(&arg.pat, |_, node_id, span, var_name| {\n-        let datum = match locals.get(&node_id) {\n-            Some(v) => v,\n-            None => {\n-                span_bug!(span, \"no entry in lllocals table for {}\", node_id);\n-            }\n-        };\n-\n-        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            span_bug!(span, \"debuginfo::create_argument_metadata() - \\\n-                             Referenced variable location is not an alloca!\");\n-        }\n-\n-        let argument_index = {\n-            let counter = &bcx\n-                          .fcx\n-                          .debug_context\n-                          .get_ref(span)\n-                          .argument_counter;\n-            let argument_index = counter.get();\n-            counter.set(argument_index + 1);\n-            argument_index\n-        };\n-\n-        declare_local(bcx,\n-                      var_name.node,\n-                      datum.ty,\n-                      scope_metadata,\n-                      VariableAccess::DirectVariable { alloca: datum.val },\n-                      VariableKind::ArgumentVariable(argument_index),\n-                      span);\n-    })\n-}"}, {"sha": "cbf423b0739a399f3e61f0ced5ba0a5b44f50efd", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 13, "deletions": 75, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -27,15 +27,14 @@ use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArr\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::ty::subst::Substs;\n-use rustc::hir;\n \n use abi::Abi;\n-use common::{NodeIdAndSpan, CrateContext, FunctionContext, Block, BlockAndBuilder};\n-use inline;\n+use common::{CrateContext, FunctionContext, Block, BlockAndBuilder};\n use monomorphize::{self, Instance};\n use rustc::ty::{self, Ty};\n+use rustc::mir::repr as mir;\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n-use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{DefIdMap, FnvHashMap, FnvHashSet};\n \n use libc::c_uint;\n use std::cell::{Cell, RefCell};\n@@ -56,13 +55,7 @@ mod source_loc;\n \n pub use self::create_scope_map::create_mir_scopes;\n pub use self::source_loc::start_emitting_source_locations;\n-pub use self::source_loc::get_cleanup_debug_loc_for_ast_node;\n-pub use self::source_loc::with_source_location_override;\n-pub use self::metadata::create_match_binding_metadata;\n-pub use self::metadata::create_argument_metadata;\n-pub use self::metadata::create_captured_var_metadata;\n pub use self::metadata::create_global_var_metadata;\n-pub use self::metadata::create_local_var_metadata;\n \n #[allow(non_upper_case_globals)]\n const DW_TAG_auto_variable: c_uint = 0x100;\n@@ -140,9 +133,7 @@ impl FunctionDebugContext {\n }\n \n pub struct FunctionDebugContextData {\n-    scope_map: RefCell<NodeMap<DIScope>>,\n     fn_metadata: DISubprogram,\n-    argument_counter: Cell<usize>,\n     source_locations_enabled: Cell<bool>,\n     source_location_override: Cell<bool>,\n }\n@@ -229,7 +220,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                instance: Instance<'tcx>,\n                                                sig: &ty::FnSig<'tcx>,\n                                                abi: Abi,\n-                                               llfn: ValueRef) -> FunctionDebugContext {\n+                                               llfn: ValueRef,\n+                                               mir: &mir::Mir) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n         return FunctionDebugContext::DebugInfoDisabled;\n     }\n@@ -238,8 +230,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // Do this here already, in case we do an early exit from this function.\n     source_loc::set_debug_location(cx, None, UnknownLocation);\n \n-    let instance = inline::maybe_inline_instance(cx, instance);\n-    let (containing_scope, span) = get_containing_scope_and_span(cx, instance);\n+    let containing_scope = get_containing_scope(cx, instance);\n+    let span = mir.span;\n \n     // This can be the case for functions inlined from another crate\n     if span == syntax_pos::DUMMY_SP {\n@@ -305,9 +297,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // Initialize fn debug context (including scope map and namespace map)\n     let fn_debug_context = box FunctionDebugContextData {\n-        scope_map: RefCell::new(NodeMap()),\n         fn_metadata: fn_metadata,\n-        argument_counter: Cell::new(1),\n         source_locations_enabled: Cell::new(false),\n         source_location_override: Cell::new(false),\n     };\n@@ -414,9 +404,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         names\n     }\n \n-    fn get_containing_scope_and_span<'ccx, 'tcx>(cx: &CrateContext<'ccx, 'tcx>,\n-                                                 instance: Instance<'tcx>)\n-                                                 -> (DIScope, Span) {\n+    fn get_containing_scope<'ccx, 'tcx>(cx: &CrateContext<'ccx, 'tcx>,\n+                                        instance: Instance<'tcx>)\n+                                        -> DIScope {\n         // First, let's see if this is a method within an inherent impl. Because\n         // if yes, we want to make the result subroutine DIE a child of the\n         // subroutine's self-type.\n@@ -436,41 +426,15 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n         });\n \n-        let containing_scope = self_type.unwrap_or_else(|| {\n+        self_type.unwrap_or_else(|| {\n             namespace::item_namespace(cx, DefId {\n                 krate: instance.def.krate,\n                 index: cx.tcx()\n                          .def_key(instance.def)\n                          .parent\n-                         .expect(\"get_containing_scope_and_span: missing parent?\")\n+                         .expect(\"get_containing_scope: missing parent?\")\n             })\n-        });\n-\n-        // Try to get some span information, if we have an inlined item.\n-        let definition_span = cx.tcx()\n-                                .map\n-                                .def_id_span(instance.def, syntax_pos::DUMMY_SP);\n-\n-        (containing_scope, definition_span)\n-    }\n-}\n-\n-/// Computes the scope map for a function given its declaration and body.\n-pub fn fill_scope_map_for_function<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n-                                             fn_decl: &hir::FnDecl,\n-                                             top_level_block: &hir::Block,\n-                                             fn_ast_id: ast::NodeId) {\n-    match fcx.debug_context {\n-        FunctionDebugContext::RegularContext(box ref data) => {\n-            let scope_map = create_scope_map::create_scope_map(fcx.ccx,\n-                                                               &fn_decl.inputs,\n-                                                               top_level_block,\n-                                                               data.fn_metadata,\n-                                                               fn_ast_id);\n-            *data.scope_map.borrow_mut() = scope_map;\n-        }\n-        FunctionDebugContext::DebugInfoDisabled |\n-        FunctionDebugContext::FunctionWithoutDebugInfo => {}\n+        })\n     }\n }\n \n@@ -548,7 +512,6 @@ pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum DebugLoc {\n-    At(ast::NodeId, Span),\n     ScopeAt(DIScope, Span),\n     None\n }\n@@ -562,28 +525,3 @@ impl DebugLoc {\n         source_loc::set_source_location(bcx.fcx(), Some(bcx), self);\n     }\n }\n-\n-pub trait ToDebugLoc {\n-    fn debug_loc(&self) -> DebugLoc;\n-}\n-\n-impl ToDebugLoc for hir::Expr {\n-    fn debug_loc(&self) -> DebugLoc {\n-        DebugLoc::At(self.id, self.span)\n-    }\n-}\n-\n-impl ToDebugLoc for NodeIdAndSpan {\n-    fn debug_loc(&self) -> DebugLoc {\n-        DebugLoc::At(self.id, self.span)\n-    }\n-}\n-\n-impl ToDebugLoc for Option<NodeIdAndSpan> {\n-    fn debug_loc(&self) -> DebugLoc {\n-        match *self {\n-            Some(NodeIdAndSpan { id, span }) => DebugLoc::At(id, span),\n-            None => DebugLoc::None\n-        }\n-    }\n-}"}, {"sha": "1aee27c144a36f9c0a9c8ed1ccc4f1f8ee3cf7a5", "filename": "src/librustc_trans/debuginfo/source_loc.rs", "status": "modified", "additions": 3, "deletions": 97, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -11,79 +11,17 @@\n use self::InternalDebugLocation::*;\n \n use super::utils::{debug_context, span_start};\n-use super::metadata::{scope_metadata,UNKNOWN_COLUMN_NUMBER};\n+use super::metadata::{UNKNOWN_COLUMN_NUMBER};\n use super::{FunctionDebugContext, DebugLoc};\n \n use llvm;\n use llvm::debuginfo::DIScope;\n use builder::Builder;\n-use common::{NodeIdAndSpan, CrateContext, FunctionContext};\n+use common::{CrateContext, FunctionContext};\n \n use libc::c_uint;\n use std::ptr;\n-use syntax_pos::{self, Span, Pos};\n-use syntax::ast;\n-\n-pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                                    node_id: ast::NodeId,\n-                                                    node_span: Span,\n-                                                    is_block: bool)\n-                                                 -> NodeIdAndSpan {\n-    // A debug location needs two things:\n-    // (1) A span (of which only the beginning will actually be used)\n-    // (2) An AST node-id which will be used to look up the lexical scope\n-    //     for the location in the functions scope-map\n-    //\n-    // This function will calculate the debug location for compiler-generated\n-    // cleanup calls that are executed when control-flow leaves the\n-    // scope identified by `node_id`.\n-    //\n-    // For everything but block-like things we can simply take id and span of\n-    // the given expression, meaning that from a debugger's view cleanup code is\n-    // executed at the same source location as the statement/expr itself.\n-    //\n-    // Blocks are a special case. Here we want the cleanup to be linked to the\n-    // closing curly brace of the block. The *scope* the cleanup is executed in\n-    // is up to debate: It could either still be *within* the block being\n-    // cleaned up, meaning that locals from the block are still visible in the\n-    // debugger.\n-    // Or it could be in the scope that the block is contained in, so any locals\n-    // from within the block are already considered out-of-scope and thus not\n-    // accessible in the debugger anymore.\n-    //\n-    // The current implementation opts for the second option: cleanup of a block\n-    // already happens in the parent scope of the block. The main reason for\n-    // this decision is that scoping becomes controlflow dependent when variable\n-    // shadowing is involved and it's impossible to decide statically which\n-    // scope is actually left when the cleanup code is executed.\n-    // In practice it shouldn't make much of a difference.\n-\n-    let mut cleanup_span = node_span;\n-\n-    if is_block {\n-        // Not all blocks actually have curly braces (e.g. simple closure\n-        // bodies), in which case we also just want to return the span of the\n-        // whole expression.\n-        let code_snippet = cx.sess().codemap().span_to_snippet(node_span);\n-        if let Ok(code_snippet) = code_snippet {\n-            let bytes = code_snippet.as_bytes();\n-\n-            if !bytes.is_empty() && &bytes[bytes.len()-1..] == b\"}\" {\n-                cleanup_span = Span {\n-                    lo: node_span.hi - syntax_pos::BytePos(1),\n-                    hi: node_span.hi,\n-                    expn_id: node_span.expn_id\n-                };\n-            }\n-        }\n-    }\n-\n-    NodeIdAndSpan {\n-        id: node_id,\n-        span: cleanup_span\n-    }\n-}\n-\n+use syntax_pos::Pos;\n \n /// Sets the current debug location at the beginning of the span.\n ///\n@@ -109,9 +47,6 @@ pub fn set_source_location(fcx: &FunctionContext,\n \n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n         let (scope, span) = match debug_loc {\n-            DebugLoc::At(node_id, span) => {\n-                (scope_metadata(fcx, node_id, span), span)\n-            }\n             DebugLoc::ScopeAt(scope, span) => (scope, span),\n             DebugLoc::None => {\n                 set_debug_location(fcx.ccx, builder, UnknownLocation);\n@@ -129,35 +64,6 @@ pub fn set_source_location(fcx: &FunctionContext,\n     set_debug_location(fcx.ccx, builder, dbg_loc);\n }\n \n-/// This function makes sure that all debug locations emitted while executing\n-/// `wrapped_function` are set to the given `debug_loc`.\n-pub fn with_source_location_override<F, R>(fcx: &FunctionContext,\n-                                           debug_loc: DebugLoc,\n-                                           wrapped_function: F) -> R\n-    where F: FnOnce() -> R\n-{\n-    match fcx.debug_context {\n-        FunctionDebugContext::DebugInfoDisabled => {\n-            wrapped_function()\n-        }\n-        FunctionDebugContext::FunctionWithoutDebugInfo => {\n-            set_debug_location(fcx.ccx, None, UnknownLocation);\n-            wrapped_function()\n-        }\n-        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n-            if function_debug_context.source_location_override.get() {\n-                wrapped_function()\n-            } else {\n-                debug_loc.apply(fcx);\n-                function_debug_context.source_location_override.set(true);\n-                let result = wrapped_function();\n-                function_debug_context.source_location_override.set(false);\n-                result\n-            }\n-        }\n-    }\n-}\n-\n /// Enables emitting source locations for the given functions.\n ///\n /// Since we don't want source locations to be emitted for the function prelude,"}, {"sha": "3cdac485fecc990dc32f8b3d8c0227ea94787e51", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -10,15 +10,15 @@\n \n // Utility Functions.\n \n-use super::{FunctionDebugContext, CrateDebugContext};\n+use super::{CrateDebugContext};\n use super::namespace::item_namespace;\n \n use rustc::hir::def_id::DefId;\n \n use llvm;\n use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n use machine;\n-use common::{CrateContext, FunctionContext};\n+use common::{CrateContext};\n use type_::Type;\n \n use syntax_pos::{self, Span};\n@@ -70,13 +70,6 @@ pub fn DIB(cx: &CrateContext) -> DIBuilderRef {\n     cx.dbg_cx().as_ref().unwrap().builder\n }\n \n-pub fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n-    match fcx.debug_context {\n-        FunctionDebugContext::RegularContext(_) => false,\n-        _ => true\n-    }\n-}\n-\n pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: DefId)\n                                    -> (DIScope, Span) {\n     let containing_scope = item_namespace(cx, DefId {"}, {"sha": "beb589c80bfc56f27a2d9f7d1aa74b1e2872aba6", "filename": "src/librustc_trans/expr.rs", "status": "removed", "additions": 0, "deletions": 2473, "changes": 2473, "blob_url": "https://github.com/rust-lang/rust/blob/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=03e23c7f9a10b18e1687bfd92c6807e9342aa00b", "patch": "@@ -1,2473 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! # Translation of Expressions\n-//!\n-//! The expr module handles translation of expressions. The most general\n-//! translation routine is `trans()`, which will translate an expression\n-//! into a datum. `trans_into()` is also available, which will translate\n-//! an expression and write the result directly into memory, sometimes\n-//! avoiding the need for a temporary stack slot. Finally,\n-//! `trans_to_lvalue()` is available if you'd like to ensure that the\n-//! result has cleanup scheduled.\n-//!\n-//! Internally, each of these functions dispatches to various other\n-//! expression functions depending on the kind of expression. We divide\n-//! up expressions into:\n-//!\n-//! - **Datum expressions:** Those that most naturally yield values.\n-//!   Examples would be `22`, `box x`, or `a + b` (when not overloaded).\n-//! - **DPS expressions:** Those that most naturally write into a location\n-//!   in memory. Examples would be `foo()` or `Point { x: 3, y: 4 }`.\n-//! - **Statement expressions:** That that do not generate a meaningful\n-//!   result. Examples would be `while { ... }` or `return 44`.\n-//!\n-//! Public entry points:\n-//!\n-//! - `trans_into(bcx, expr, dest) -> bcx`: evaluates an expression,\n-//!   storing the result into `dest`. This is the preferred form, if you\n-//!   can manage it.\n-//!\n-//! - `trans(bcx, expr) -> DatumBlock`: evaluates an expression, yielding\n-//!   `Datum` with the result. You can then store the datum, inspect\n-//!   the value, etc. This may introduce temporaries if the datum is a\n-//!   structural type.\n-//!\n-//! - `trans_to_lvalue(bcx, expr, \"...\") -> DatumBlock`: evaluates an\n-//!   expression and ensures that the result has a cleanup associated with it,\n-//!   creating a temporary stack slot if necessary.\n-//!\n-//! - `trans_var -> Datum`: looks up a local variable, upvar or static.\n-\n-#![allow(non_camel_case_types)]\n-\n-pub use self::Dest::*;\n-use self::lazy_binop_ty::*;\n-\n-use llvm::{self, ValueRef, TypeKind};\n-use middle::const_qualif::ConstQualif;\n-use rustc::hir::def::Def;\n-use rustc::ty::subst::Substs;\n-use {_match, abi, adt, asm, base, closure, consts, controlflow};\n-use base::*;\n-use build::*;\n-use callee::{Callee, ArgExprs, ArgOverloadedCall, ArgOverloadedOp};\n-use cleanup::{self, CleanupMethods, DropHintMethods};\n-use common::*;\n-use datum::*;\n-use debuginfo::{self, DebugLoc, ToDebugLoc};\n-use glue;\n-use machine;\n-use tvec;\n-use type_of;\n-use value::Value;\n-use Disr;\n-use rustc::ty::adjustment::{AdjustNeverToAny, AdjustDerefRef, AdjustReifyFnPointer};\n-use rustc::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n-use rustc::ty::adjustment::CustomCoerceUnsized;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::MethodCall;\n-use rustc::ty::cast::{CastKind, CastTy};\n-use util::common::indenter;\n-use machine::{llsize_of, llsize_of_alloc};\n-use type_::Type;\n-\n-use rustc::hir;\n-\n-use syntax::ast;\n-use syntax::parse::token::InternedString;\n-use syntax_pos;\n-use std::fmt;\n-use std::mem;\n-\n-// Destinations\n-\n-// These are passed around by the code generating functions to track the\n-// destination of a computation's value.\n-\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum Dest {\n-    SaveIn(ValueRef),\n-    Ignore,\n-}\n-\n-impl fmt::Debug for Dest {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            SaveIn(v) => write!(f, \"SaveIn({:?})\", Value(v)),\n-            Ignore => f.write_str(\"Ignore\")\n-        }\n-    }\n-}\n-\n-/// This function is equivalent to `trans(bcx, expr).store_to_dest(dest)` but it may generate\n-/// better optimized LLVM code.\n-pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              expr: &hir::Expr,\n-                              dest: Dest)\n-                              -> Block<'blk, 'tcx> {\n-    let mut bcx = bcx;\n-\n-    expr.debug_loc().apply(bcx.fcx);\n-\n-    if adjustment_required(bcx, expr) {\n-        // use trans, which may be less efficient but\n-        // which will perform the adjustments:\n-        let datum = unpack_datum!(bcx, trans(bcx, expr));\n-        return datum.store_to_dest(bcx, dest, expr.id);\n-    }\n-\n-    let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n-    if !qualif.intersects(ConstQualif::NOT_CONST | ConstQualif::NEEDS_DROP) {\n-        if !qualif.intersects(ConstQualif::PREFER_IN_PLACE) {\n-            if let SaveIn(lldest) = dest {\n-                match consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n-                                                       bcx.fcx.param_substs,\n-                                                       consts::TrueConst::No) {\n-                    Ok(global) => {\n-                        // Cast pointer to destination, because constants\n-                        // have different types.\n-                        let lldest = PointerCast(bcx, lldest, val_ty(global));\n-                        memcpy_ty(bcx, lldest, global, expr_ty_adjusted(bcx, expr));\n-                        return bcx;\n-                    },\n-                    Err(consts::ConstEvalFailure::Runtime(_)) => {\n-                        // in case const evaluation errors, translate normally\n-                        // debug assertions catch the same errors\n-                        // see RFC 1229\n-                    },\n-                    Err(consts::ConstEvalFailure::Compiletime(_)) => {\n-                        return bcx;\n-                    },\n-                }\n-            }\n-\n-            // If we see a const here, that's because it evaluates to a type with zero size. We\n-            // should be able to just discard it, since const expressions are guaranteed not to\n-            // have side effects. This seems to be reached through tuple struct constructors being\n-            // passed zero-size constants.\n-            if let hir::ExprPath(..) = expr.node {\n-                match bcx.tcx().expect_def(expr.id) {\n-                    Def::Const(_) | Def::AssociatedConst(_) => {\n-                        assert!(type_is_zero_size(bcx.ccx(), bcx.tcx().node_id_to_type(expr.id)));\n-                        return bcx;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            // Even if we don't have a value to emit, and the expression\n-            // doesn't have any side-effects, we still have to translate the\n-            // body of any closures.\n-            // FIXME: Find a better way of handling this case.\n-        } else {\n-            // The only way we're going to see a `const` at this point is if\n-            // it prefers in-place instantiation, likely because it contains\n-            // `[x; N]` somewhere within.\n-            match expr.node {\n-                hir::ExprPath(..) => {\n-                    match bcx.tcx().expect_def(expr.id) {\n-                        Def::Const(did) | Def::AssociatedConst(did) => {\n-                            let empty_substs = Substs::empty(bcx.tcx());\n-                            let const_expr = consts::get_const_expr(bcx.ccx(), did, expr,\n-                                                                    empty_substs);\n-                            // Temporarily get cleanup scopes out of the way,\n-                            // as they require sub-expressions to be contained\n-                            // inside the current AST scope.\n-                            // These should record no cleanups anyways, `const`\n-                            // can't have destructors.\n-                            let scopes = mem::replace(&mut *bcx.fcx.scopes.borrow_mut(),\n-                                                      vec![]);\n-                            // Lock emitted debug locations to the location of\n-                            // the constant reference expression.\n-                            debuginfo::with_source_location_override(bcx.fcx,\n-                                                                     expr.debug_loc(),\n-                                                                     || {\n-                                bcx = trans_into(bcx, const_expr, dest)\n-                            });\n-                            let scopes = mem::replace(&mut *bcx.fcx.scopes.borrow_mut(),\n-                                                      scopes);\n-                            assert!(scopes.is_empty());\n-                            return bcx;\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    debug!(\"trans_into() expr={:?}\", expr);\n-\n-    let cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(bcx.ccx(),\n-                                                                          expr.id,\n-                                                                          expr.span,\n-                                                                          false);\n-    bcx.fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n-\n-    let kind = expr_kind(bcx.tcx(), expr);\n-    bcx = match kind {\n-        ExprKind::Lvalue | ExprKind::RvalueDatum => {\n-            trans_unadjusted(bcx, expr).store_to_dest(dest, expr.id)\n-        }\n-        ExprKind::RvalueDps => {\n-            trans_rvalue_dps_unadjusted(bcx, expr, dest)\n-        }\n-        ExprKind::RvalueStmt => {\n-            trans_rvalue_stmt_unadjusted(bcx, expr)\n-        }\n-    };\n-\n-    bcx.fcx.pop_and_trans_ast_cleanup_scope(bcx, expr.id)\n-}\n-\n-/// Translates an expression, returning a datum (and new block) encapsulating the result. When\n-/// possible, it is preferred to use `trans_into`, as that may avoid creating a temporary on the\n-/// stack.\n-pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                         expr: &hir::Expr)\n-                         -> DatumBlock<'blk, 'tcx, Expr> {\n-    debug!(\"trans(expr={:?})\", expr);\n-\n-    let mut bcx = bcx;\n-    let fcx = bcx.fcx;\n-    let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n-    let adjusted_global = !qualif.intersects(ConstQualif::NON_STATIC_BORROWS);\n-    let global = if !qualif.intersects(ConstQualif::NOT_CONST | ConstQualif::NEEDS_DROP) {\n-        match consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n-                                                            bcx.fcx.param_substs,\n-                                                            consts::TrueConst::No) {\n-            Ok(global) => {\n-                if qualif.intersects(ConstQualif::HAS_STATIC_BORROWS) {\n-                    // Is borrowed as 'static, must return lvalue.\n-\n-                    // Cast pointer to global, because constants have different types.\n-                    let const_ty = expr_ty_adjusted(bcx, expr);\n-                    let llty = type_of::type_of(bcx.ccx(), const_ty);\n-                    let global = PointerCast(bcx, global, llty.ptr_to());\n-                    let datum = Datum::new(global, const_ty, Lvalue::new(\"expr::trans\"));\n-                    return DatumBlock::new(bcx, datum.to_expr_datum());\n-                }\n-\n-                // Otherwise, keep around and perform adjustments, if needed.\n-                let const_ty = if adjusted_global {\n-                    expr_ty_adjusted(bcx, expr)\n-                } else {\n-                    expr_ty(bcx, expr)\n-                };\n-\n-                // This could use a better heuristic.\n-                Some(if type_is_immediate(bcx.ccx(), const_ty) {\n-                    // Cast pointer to global, because constants have different types.\n-                    let llty = type_of::type_of(bcx.ccx(), const_ty);\n-                    let global = PointerCast(bcx, global, llty.ptr_to());\n-                    // Maybe just get the value directly, instead of loading it?\n-                    immediate_rvalue(load_ty(bcx, global, const_ty), const_ty)\n-                } else {\n-                    let scratch = alloc_ty(bcx, const_ty, \"const\");\n-                    call_lifetime_start(bcx, scratch);\n-                    let lldest = if !const_ty.is_structural() {\n-                        // Cast pointer to slot, because constants have different types.\n-                        PointerCast(bcx, scratch, val_ty(global))\n-                    } else {\n-                        // In this case, memcpy_ty calls llvm.memcpy after casting both\n-                        // source and destination to i8*, so we don't need any casts.\n-                        scratch\n-                    };\n-                    memcpy_ty(bcx, lldest, global, const_ty);\n-                    Datum::new(scratch, const_ty, Rvalue::new(ByRef))\n-                })\n-            },\n-            Err(consts::ConstEvalFailure::Runtime(_)) => {\n-                // in case const evaluation errors, translate normally\n-                // debug assertions catch the same errors\n-                // see RFC 1229\n-                None\n-            },\n-            Err(consts::ConstEvalFailure::Compiletime(_)) => {\n-                // generate a dummy llvm value\n-                let const_ty = expr_ty(bcx, expr);\n-                let llty = type_of::type_of(bcx.ccx(), const_ty);\n-                let dummy = C_undef(llty.ptr_to());\n-                Some(Datum::new(dummy, const_ty, Rvalue::new(ByRef)))\n-            },\n-        }\n-    } else {\n-        None\n-    };\n-\n-    let cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(bcx.ccx(),\n-                                                                          expr.id,\n-                                                                          expr.span,\n-                                                                          false);\n-    fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n-    let datum = match global {\n-        Some(rvalue) => rvalue.to_expr_datum(),\n-        None => unpack_datum!(bcx, trans_unadjusted(bcx, expr))\n-    };\n-    let datum = if adjusted_global {\n-        datum // trans::consts already performed adjustments.\n-    } else {\n-        unpack_datum!(bcx, apply_adjustments(bcx, expr, datum))\n-    };\n-    bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, expr.id);\n-    return DatumBlock::new(bcx, datum);\n-}\n-\n-pub fn get_meta(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n-    StructGEP(bcx, fat_ptr, abi::FAT_PTR_EXTRA)\n-}\n-\n-pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n-    StructGEP(bcx, fat_ptr, abi::FAT_PTR_ADDR)\n-}\n-\n-pub fn copy_fat_ptr(bcx: Block, src_ptr: ValueRef, dst_ptr: ValueRef) {\n-    Store(bcx, Load(bcx, get_dataptr(bcx, src_ptr)), get_dataptr(bcx, dst_ptr));\n-    Store(bcx, Load(bcx, get_meta(bcx, src_ptr)), get_meta(bcx, dst_ptr));\n-}\n-\n-fn adjustment_required<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   expr: &hir::Expr) -> bool {\n-    let adjustment = match bcx.tcx().tables.borrow().adjustments.get(&expr.id).cloned() {\n-        None => { return false; }\n-        Some(adj) => adj\n-    };\n-\n-    // Don't skip a conversion from Box<T> to &T, etc.\n-    if bcx.tcx().is_overloaded_autoderef(expr.id, 0) {\n-        return true;\n-    }\n-\n-    match adjustment {\n-        AdjustNeverToAny(..) => true,\n-        AdjustReifyFnPointer => true,\n-        AdjustUnsafeFnPointer | AdjustMutToConstPointer => {\n-            // purely a type-level thing\n-            false\n-        }\n-        AdjustDerefRef(ref adj) => {\n-            // We are a bit paranoid about adjustments and thus might have a re-\n-            // borrow here which merely derefs and then refs again (it might have\n-            // a different region or mutability, but we don't care here).\n-            !(adj.autoderefs == 1 && adj.autoref.is_some() && adj.unsize.is_none())\n-        }\n-    }\n-}\n-\n-/// Helper for trans that apply adjustments from `expr` to `datum`, which should be the unadjusted\n-/// translation of `expr`.\n-fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 expr: &hir::Expr,\n-                                 datum: Datum<'tcx, Expr>)\n-                                 -> DatumBlock<'blk, 'tcx, Expr>\n-{\n-    let mut bcx = bcx;\n-    let mut datum = datum;\n-    let adjustment = match bcx.tcx().tables.borrow().adjustments.get(&expr.id).cloned() {\n-        None => {\n-            return DatumBlock::new(bcx, datum);\n-        }\n-        Some(adj) => { adj }\n-    };\n-    debug!(\"unadjusted datum for expr {:?}: {:?} adjustment={:?}\",\n-           expr, datum, adjustment);\n-    match adjustment {\n-        AdjustNeverToAny(ref target) => {\n-            let mono_target = bcx.monomorphize(target);\n-            let llty = type_of::type_of(bcx.ccx(), mono_target);\n-            let dummy = C_undef(llty.ptr_to());\n-            datum = Datum::new(dummy, mono_target, Lvalue::new(\"never\")).to_expr_datum();\n-        }\n-        AdjustReifyFnPointer => {\n-            match datum.ty.sty {\n-                ty::TyFnDef(def_id, substs, _) => {\n-                    datum = Callee::def(bcx.ccx(), def_id, substs)\n-                        .reify(bcx.ccx()).to_expr_datum();\n-                }\n-                _ => {\n-                    bug!(\"{} cannot be reified to a fn ptr\", datum.ty)\n-                }\n-            }\n-        }\n-        AdjustUnsafeFnPointer | AdjustMutToConstPointer => {\n-            // purely a type-level thing\n-        }\n-        AdjustDerefRef(ref adj) => {\n-            let skip_reborrows = if adj.autoderefs == 1 && adj.autoref.is_some() {\n-                // We are a bit paranoid about adjustments and thus might have a re-\n-                // borrow here which merely derefs and then refs again (it might have\n-                // a different region or mutability, but we don't care here).\n-                match datum.ty.sty {\n-                    // Don't skip a conversion from Box<T> to &T, etc.\n-                    ty::TyRef(..) => {\n-                        if bcx.tcx().is_overloaded_autoderef(expr.id, 0) {\n-                            // Don't skip an overloaded deref.\n-                            0\n-                        } else {\n-                            1\n-                        }\n-                    }\n-                    _ => 0\n-                }\n-            } else {\n-                0\n-            };\n-\n-            if adj.autoderefs > skip_reborrows {\n-                // Schedule cleanup.\n-                let lval = unpack_datum!(bcx, datum.to_lvalue_datum(bcx, \"auto_deref\", expr.id));\n-                datum = unpack_datum!(bcx, deref_multiple(bcx, expr,\n-                                                          lval.to_expr_datum(),\n-                                                          adj.autoderefs - skip_reborrows));\n-            }\n-\n-            // (You might think there is a more elegant way to do this than a\n-            // skip_reborrows bool, but then you remember that the borrow checker exists).\n-            if skip_reborrows == 0 && adj.autoref.is_some() {\n-                datum = unpack_datum!(bcx, auto_ref(bcx, datum, expr));\n-            }\n-\n-            if let Some(target) = adj.unsize {\n-                // We do not arrange cleanup ourselves; if we already are an\n-                // L-value, then cleanup will have already been scheduled (and\n-                // the `datum.to_rvalue_datum` call below will emit code to zero\n-                // the drop flag when moving out of the L-value). If we are an\n-                // R-value, then we do not need to schedule cleanup.\n-                let source_datum = unpack_datum!(bcx,\n-                    datum.to_rvalue_datum(bcx, \"__coerce_source\"));\n-\n-                let target = bcx.monomorphize(&target);\n-\n-                let scratch = alloc_ty(bcx, target, \"__coerce_target\");\n-                call_lifetime_start(bcx, scratch);\n-                let target_datum = Datum::new(scratch, target,\n-                                              Rvalue::new(ByRef));\n-                bcx = coerce_unsized(bcx, expr.span, source_datum, target_datum);\n-                datum = Datum::new(scratch, target,\n-                                   RvalueExpr(Rvalue::new(ByRef)));\n-            }\n-        }\n-    }\n-    debug!(\"after adjustments, datum={:?}\", datum);\n-    DatumBlock::new(bcx, datum)\n-}\n-\n-fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              span: syntax_pos::Span,\n-                              source: Datum<'tcx, Rvalue>,\n-                              target: Datum<'tcx, Rvalue>)\n-                              -> Block<'blk, 'tcx> {\n-    let mut bcx = bcx;\n-    debug!(\"coerce_unsized({:?} -> {:?})\", source, target);\n-\n-    match (&source.ty.sty, &target.ty.sty) {\n-        (&ty::TyBox(a), &ty::TyBox(b)) |\n-        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n-         &ty::TyRef(_, ty::TypeAndMut { ty: b, .. })) |\n-        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n-         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n-        (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n-         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            let (inner_source, inner_target) = (a, b);\n-\n-            let (base, old_info) = if !type_is_sized(bcx.tcx(), inner_source) {\n-                // Normally, the source is a thin pointer and we are\n-                // adding extra info to make a fat pointer. The exception\n-                // is when we are upcasting an existing object fat pointer\n-                // to use a different vtable. In that case, we want to\n-                // load out the original data pointer so we can repackage\n-                // it.\n-                (Load(bcx, get_dataptr(bcx, source.val)),\n-                Some(Load(bcx, get_meta(bcx, source.val))))\n-            } else {\n-                let val = if source.kind.is_by_ref() {\n-                    load_ty(bcx, source.val, source.ty)\n-                } else {\n-                    source.val\n-                };\n-                (val, None)\n-            };\n-\n-            let info = unsized_info(bcx.ccx(), inner_source, inner_target, old_info);\n-\n-            // Compute the base pointer. This doesn't change the pointer value,\n-            // but merely its type.\n-            let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), inner_target).ptr_to();\n-            let base = PointerCast(bcx, base, ptr_ty);\n-\n-            Store(bcx, base, get_dataptr(bcx, target.val));\n-            Store(bcx, info, get_meta(bcx, target.val));\n-        }\n-\n-        // This can be extended to enums and tuples in the future.\n-        // (&ty::TyEnum(def_id_a, _), &ty::TyEnum(def_id_b, _)) |\n-        (&ty::TyStruct(def_id_a, _), &ty::TyStruct(def_id_b, _)) => {\n-            assert_eq!(def_id_a, def_id_b);\n-\n-            // The target is already by-ref because it's to be written to.\n-            let source = unpack_datum!(bcx, source.to_ref_datum(bcx));\n-            assert!(target.kind.is_by_ref());\n-\n-            let kind = custom_coerce_unsize_info(bcx.ccx().shared(),\n-                                                 source.ty,\n-                                                 target.ty);\n-\n-            let repr_source = adt::represent_type(bcx.ccx(), source.ty);\n-            let src_fields = match &*repr_source {\n-                &adt::Repr::Univariant(ref s, _) => &s.fields,\n-                _ => span_bug!(span,\n-                               \"Non univariant struct? (repr_source: {:?})\",\n-                               repr_source),\n-            };\n-            let repr_target = adt::represent_type(bcx.ccx(), target.ty);\n-            let target_fields = match &*repr_target {\n-                &adt::Repr::Univariant(ref s, _) => &s.fields,\n-                _ => span_bug!(span,\n-                               \"Non univariant struct? (repr_target: {:?})\",\n-                               repr_target),\n-            };\n-\n-            let coerce_index = match kind {\n-                CustomCoerceUnsized::Struct(i) => i\n-            };\n-            assert!(coerce_index < src_fields.len() && src_fields.len() == target_fields.len());\n-\n-            let source_val = adt::MaybeSizedValue::sized(source.val);\n-            let target_val = adt::MaybeSizedValue::sized(target.val);\n-\n-            let iter = src_fields.iter().zip(target_fields).enumerate();\n-            for (i, (src_ty, target_ty)) in iter {\n-                let ll_source = adt::trans_field_ptr(bcx, &repr_source, source_val, Disr(0), i);\n-                let ll_target = adt::trans_field_ptr(bcx, &repr_target, target_val, Disr(0), i);\n-\n-                // If this is the field we need to coerce, recurse on it.\n-                if i == coerce_index {\n-                    coerce_unsized(bcx, span,\n-                                   Datum::new(ll_source, src_ty,\n-                                              Rvalue::new(ByRef)),\n-                                   Datum::new(ll_target, target_ty,\n-                                              Rvalue::new(ByRef)));\n-                } else {\n-                    // Otherwise, simply copy the data from the source.\n-                    assert!(src_ty.is_phantom_data() || src_ty == target_ty);\n-                    memcpy_ty(bcx, ll_target, ll_source, src_ty);\n-                }\n-            }\n-        }\n-        _ => bug!(\"coerce_unsized: invalid coercion {:?} -> {:?}\",\n-                  source.ty,\n-                  target.ty)\n-    }\n-    bcx\n-}\n-\n-/// Translates an expression in \"lvalue\" mode -- meaning that it returns a reference to the memory\n-/// that the expr represents.\n-///\n-/// If this expression is an rvalue, this implies introducing a temporary.  In other words,\n-/// something like `x().f` is translated into roughly the equivalent of\n-///\n-///   { tmp = x(); tmp.f }\n-pub fn trans_to_lvalue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   expr: &hir::Expr,\n-                                   name: &str)\n-                                   -> DatumBlock<'blk, 'tcx, Lvalue> {\n-    let mut bcx = bcx;\n-    let datum = unpack_datum!(bcx, trans(bcx, expr));\n-    return datum.to_lvalue_datum(bcx, name, expr.id);\n-}\n-\n-/// A version of `trans` that ignores adjustments. You almost certainly do not want to call this\n-/// directly.\n-fn trans_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                expr: &hir::Expr)\n-                                -> DatumBlock<'blk, 'tcx, Expr> {\n-    let mut bcx = bcx;\n-\n-    debug!(\"trans_unadjusted(expr={:?})\", expr);\n-    let _indenter = indenter();\n-\n-    expr.debug_loc().apply(bcx.fcx);\n-\n-    return match expr_kind(bcx.tcx(), expr) {\n-        ExprKind::Lvalue | ExprKind::RvalueDatum => {\n-            let datum = unpack_datum!(bcx, {\n-                trans_datum_unadjusted(bcx, expr)\n-            });\n-\n-            DatumBlock {bcx: bcx, datum: datum}\n-        }\n-\n-        ExprKind::RvalueStmt => {\n-            bcx = trans_rvalue_stmt_unadjusted(bcx, expr);\n-            nil(bcx, expr_ty(bcx, expr))\n-        }\n-\n-        ExprKind::RvalueDps => {\n-            let ty = expr_ty(bcx, expr);\n-            if type_is_zero_size(bcx.ccx(), ty) {\n-                bcx = trans_rvalue_dps_unadjusted(bcx, expr, Ignore);\n-                nil(bcx, ty)\n-            } else {\n-                let scratch = rvalue_scratch_datum(bcx, ty, \"\");\n-                bcx = trans_rvalue_dps_unadjusted(\n-                    bcx, expr, SaveIn(scratch.val));\n-\n-                // Note: this is not obviously a good idea.  It causes\n-                // immediate values to be loaded immediately after a\n-                // return from a call or other similar expression,\n-                // which in turn leads to alloca's having shorter\n-                // lifetimes and hence larger stack frames.  However,\n-                // in turn it can lead to more register pressure.\n-                // Still, in practice it seems to increase\n-                // performance, since we have fewer problems with\n-                // morestack churn.\n-                let scratch = unpack_datum!(\n-                    bcx, scratch.to_appropriate_datum(bcx));\n-\n-                DatumBlock::new(bcx, scratch.to_expr_datum())\n-            }\n-        }\n-    };\n-\n-    fn nil<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ty: Ty<'tcx>)\n-                       -> DatumBlock<'blk, 'tcx, Expr> {\n-        let llval = C_undef(type_of::type_of(bcx.ccx(), ty));\n-        let datum = immediate_rvalue(llval, ty);\n-        DatumBlock::new(bcx, datum.to_expr_datum())\n-    }\n-}\n-\n-fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                      expr: &hir::Expr)\n-                                      -> DatumBlock<'blk, 'tcx, Expr> {\n-    let mut bcx = bcx;\n-    let fcx = bcx.fcx;\n-    let _icx = push_ctxt(\"trans_datum_unadjusted\");\n-\n-    match expr.node {\n-        hir::ExprType(ref e, _) => {\n-            trans(bcx, &e)\n-        }\n-        hir::ExprPath(..) => {\n-            let var = trans_var(bcx, bcx.tcx().expect_def(expr.id));\n-            DatumBlock::new(bcx, var.to_expr_datum())\n-        }\n-        hir::ExprField(ref base, name) => {\n-            trans_rec_field(bcx, &base, name.node)\n-        }\n-        hir::ExprTupField(ref base, idx) => {\n-            trans_rec_tup_field(bcx, &base, idx.node)\n-        }\n-        hir::ExprIndex(ref base, ref idx) => {\n-            trans_index(bcx, expr, &base, &idx, MethodCall::expr(expr.id))\n-        }\n-        hir::ExprBox(ref contents) => {\n-            // Special case for `Box<T>`\n-            let box_ty = expr_ty(bcx, expr);\n-            let contents_ty = expr_ty(bcx, &contents);\n-            match box_ty.sty {\n-                ty::TyBox(..) => {\n-                    trans_uniq_expr(bcx, expr, box_ty, &contents, contents_ty)\n-                }\n-                _ => span_bug!(expr.span,\n-                               \"expected unique box\")\n-            }\n-\n-        }\n-        hir::ExprLit(ref lit) => trans_immediate_lit(bcx, expr, &lit),\n-        hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            trans_binary(bcx, expr, op, &lhs, &rhs)\n-        }\n-        hir::ExprUnary(op, ref x) => {\n-            trans_unary(bcx, expr, op, &x)\n-        }\n-        hir::ExprAddrOf(_, ref x) => {\n-            match x.node {\n-                hir::ExprRepeat(..) | hir::ExprVec(..) => {\n-                    // Special case for slices.\n-                    let cleanup_debug_loc =\n-                        debuginfo::get_cleanup_debug_loc_for_ast_node(bcx.ccx(),\n-                                                                      x.id,\n-                                                                      x.span,\n-                                                                      false);\n-                    fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n-                    let datum = unpack_datum!(\n-                        bcx, tvec::trans_slice_vec(bcx, expr, &x));\n-                    bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, x.id);\n-                    DatumBlock::new(bcx, datum)\n-                }\n-                _ => {\n-                    trans_addr_of(bcx, expr, &x)\n-                }\n-            }\n-        }\n-        hir::ExprCast(ref val, _) => {\n-            // Datum output mode means this is a scalar cast:\n-            trans_imm_cast(bcx, &val, expr.id)\n-        }\n-        _ => {\n-            span_bug!(\n-                expr.span,\n-                \"trans_rvalue_datum_unadjusted reached \\\n-                 fall-through case: {:?}\",\n-                expr.node);\n-        }\n-    }\n-}\n-\n-fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                              base: &hir::Expr,\n-                              get_idx: F)\n-                              -> DatumBlock<'blk, 'tcx, Expr> where\n-    F: FnOnce(TyCtxt<'blk, 'tcx, 'tcx>, &VariantInfo<'tcx>) -> usize,\n-{\n-    let mut bcx = bcx;\n-    let _icx = push_ctxt(\"trans_rec_field\");\n-\n-    let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, base, \"field\"));\n-    let bare_ty = base_datum.ty;\n-    let repr = adt::represent_type(bcx.ccx(), bare_ty);\n-    let vinfo = VariantInfo::from_ty(bcx.tcx(), bare_ty, None);\n-\n-    let ix = get_idx(bcx.tcx(), &vinfo);\n-    let d = base_datum.get_element(\n-        bcx,\n-        vinfo.fields[ix].1,\n-        |srcval| {\n-            adt::trans_field_ptr(bcx, &repr, srcval, vinfo.discr, ix)\n-        });\n-\n-    if type_is_sized(bcx.tcx(), d.ty) {\n-        DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n-    } else {\n-        let scratch = rvalue_scratch_datum(bcx, d.ty, \"\");\n-        Store(bcx, d.val, get_dataptr(bcx, scratch.val));\n-        let info = Load(bcx, get_meta(bcx, base_datum.val));\n-        Store(bcx, info, get_meta(bcx, scratch.val));\n-\n-        // Always generate an lvalue datum, because this pointer doesn't own\n-        // the data and cleanup is scheduled elsewhere.\n-        DatumBlock::new(bcx, Datum::new(scratch.val, scratch.ty, LvalueExpr(d.kind)))\n-    }\n-}\n-\n-/// Translates `base.field`.\n-fn trans_rec_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               base: &hir::Expr,\n-                               field: ast::Name)\n-                               -> DatumBlock<'blk, 'tcx, Expr> {\n-    trans_field(bcx, base, |_, vinfo| vinfo.field_index(field))\n-}\n-\n-/// Translates `base.<idx>`.\n-fn trans_rec_tup_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   base: &hir::Expr,\n-                                   idx: usize)\n-                                   -> DatumBlock<'blk, 'tcx, Expr> {\n-    trans_field(bcx, base, |_, _| idx)\n-}\n-\n-fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                           index_expr: &hir::Expr,\n-                           base: &hir::Expr,\n-                           idx: &hir::Expr,\n-                           method_call: MethodCall)\n-                           -> DatumBlock<'blk, 'tcx, Expr> {\n-    //! Translates `base[idx]`.\n-\n-    let _icx = push_ctxt(\"trans_index\");\n-    let ccx = bcx.ccx();\n-    let mut bcx = bcx;\n-\n-    let index_expr_debug_loc = index_expr.debug_loc();\n-\n-    // Check for overloaded index.\n-    let method = ccx.tcx().tables.borrow().method_map.get(&method_call).cloned();\n-    let elt_datum = match method {\n-        Some(method) => {\n-            let method_ty = monomorphize_type(bcx, method.ty);\n-\n-            let base_datum = unpack_datum!(bcx, trans(bcx, base));\n-\n-            // Translate index expression.\n-            let ix_datum = unpack_datum!(bcx, trans(bcx, idx));\n-\n-            let ref_ty = // invoked methods have LB regions instantiated:\n-                bcx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n-            let elt_ty = match ref_ty.builtin_deref(true, ty::NoPreference) {\n-                None => {\n-                    span_bug!(index_expr.span,\n-                              \"index method didn't return a \\\n-                              dereferenceable type?!\")\n-                }\n-                Some(elt_tm) => elt_tm.ty,\n-            };\n-\n-            // Overloaded. Invoke the index() method, which basically\n-            // yields a `&T` pointer.  We can then proceed down the\n-            // normal path (below) to dereference that `&T`.\n-            let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_index_elt\");\n-\n-            bcx = Callee::method(bcx, method)\n-                .call(bcx, index_expr_debug_loc,\n-                      ArgOverloadedOp(base_datum, Some(ix_datum)),\n-                      Some(SaveIn(scratch.val))).bcx;\n-\n-            let datum = scratch.to_expr_datum();\n-            let lval = Lvalue::new(\"expr::trans_index overload\");\n-            if type_is_sized(bcx.tcx(), elt_ty) {\n-                Datum::new(datum.to_llscalarish(bcx), elt_ty, LvalueExpr(lval))\n-            } else {\n-                Datum::new(datum.val, elt_ty, LvalueExpr(lval))\n-            }\n-        }\n-        None => {\n-            let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx,\n-                                                                base,\n-                                                                \"index\"));\n-\n-            // Translate index expression and cast to a suitable LLVM integer.\n-            // Rust is less strict than LLVM in this regard.\n-            let ix_datum = unpack_datum!(bcx, trans(bcx, idx));\n-            let ix_val = ix_datum.to_llscalarish(bcx);\n-            let ix_size = machine::llbitsize_of_real(bcx.ccx(),\n-                                                     val_ty(ix_val));\n-            let int_size = machine::llbitsize_of_real(bcx.ccx(),\n-                                                      ccx.int_type());\n-            let ix_val = {\n-                if ix_size < int_size {\n-                    if expr_ty(bcx, idx).is_signed() {\n-                        SExt(bcx, ix_val, ccx.int_type())\n-                    } else { ZExt(bcx, ix_val, ccx.int_type()) }\n-                } else if ix_size > int_size {\n-                    Trunc(bcx, ix_val, ccx.int_type())\n-                } else {\n-                    ix_val\n-                }\n-            };\n-\n-            let unit_ty = base_datum.ty.sequence_element_type(bcx.tcx());\n-\n-            let (base, len) = base_datum.get_vec_base_and_len(bcx);\n-\n-            debug!(\"trans_index: base {:?}\", Value(base));\n-            debug!(\"trans_index: len {:?}\", Value(len));\n-\n-            let bounds_check = ICmp(bcx,\n-                                    llvm::IntUGE,\n-                                    ix_val,\n-                                    len,\n-                                    index_expr_debug_loc);\n-            let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            let expected = Call(bcx,\n-                                expect,\n-                                &[bounds_check, C_bool(ccx, false)],\n-                                index_expr_debug_loc);\n-            bcx = with_cond(bcx, expected, |bcx| {\n-                controlflow::trans_fail_bounds_check(bcx,\n-                                                     expr_info(index_expr),\n-                                                     ix_val,\n-                                                     len)\n-            });\n-            let elt = InBoundsGEP(bcx, base, &[ix_val]);\n-            let elt = PointerCast(bcx, elt, type_of::type_of(ccx, unit_ty).ptr_to());\n-            let lval = Lvalue::new(\"expr::trans_index fallback\");\n-            Datum::new(elt, unit_ty, LvalueExpr(lval))\n-        }\n-    };\n-\n-    DatumBlock::new(bcx, elt_datum)\n-}\n-\n-/// Translates a reference to a variable.\n-pub fn trans_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, def: Def)\n-                             -> Datum<'tcx, Lvalue> {\n-\n-    match def {\n-        Def::Static(did, _) => consts::get_static(bcx.ccx(), did),\n-        Def::Upvar(_, nid, _, _) => {\n-            // Can't move upvars, so this is never a ZeroMemLastUse.\n-            let local_ty = node_id_type(bcx, nid);\n-            let lval = Lvalue::new_with_hint(\"expr::trans_var (upvar)\",\n-                                             bcx, nid, HintKind::ZeroAndMaintain);\n-            match bcx.fcx.llupvars.borrow().get(&nid) {\n-                Some(&val) => Datum::new(val, local_ty, lval),\n-                None => {\n-                    bug!(\"trans_var: no llval for upvar {} found\", nid);\n-                }\n-            }\n-        }\n-        Def::Local(_, nid) => {\n-            let datum = match bcx.fcx.lllocals.borrow().get(&nid) {\n-                Some(&v) => v,\n-                None => {\n-                    bug!(\"trans_var: no datum for local/arg {} found\", nid);\n-                }\n-            };\n-            debug!(\"take_local(nid={}, v={:?}, ty={})\",\n-                   nid, Value(datum.val), datum.ty);\n-            datum\n-        }\n-        _ => bug!(\"{:?} should not reach expr::trans_var\", def)\n-    }\n-}\n-\n-fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                            expr: &hir::Expr)\n-                                            -> Block<'blk, 'tcx> {\n-    let mut bcx = bcx;\n-    let _icx = push_ctxt(\"trans_rvalue_stmt\");\n-\n-    if bcx.unreachable.get() {\n-        return bcx;\n-    }\n-\n-    expr.debug_loc().apply(bcx.fcx);\n-\n-    match expr.node {\n-        hir::ExprBreak(label_opt) => {\n-            controlflow::trans_break(bcx, expr, label_opt.map(|l| l.node))\n-        }\n-        hir::ExprType(ref e, _) => {\n-            trans_into(bcx, &e, Ignore)\n-        }\n-        hir::ExprAgain(label_opt) => {\n-            controlflow::trans_cont(bcx, expr, label_opt.map(|l| l.node))\n-        }\n-        hir::ExprRet(ref ex) => {\n-            // Check to see if the return expression itself is reachable.\n-            // This can occur when the inner expression contains a return\n-            let reachable = if let Some(ref cfg) = bcx.fcx.cfg {\n-                cfg.node_is_reachable(expr.id)\n-            } else {\n-                true\n-            };\n-\n-            if reachable {\n-                controlflow::trans_ret(bcx, expr, ex.as_ref().map(|e| &**e))\n-            } else {\n-                // If it's not reachable, just translate the inner expression\n-                // directly. This avoids having to manage a return slot when\n-                // it won't actually be used anyway.\n-                if let &Some(ref x) = ex {\n-                    bcx = trans_into(bcx, &x, Ignore);\n-                }\n-                // Mark the end of the block as unreachable. Once we get to\n-                // a return expression, there's no more we should be doing\n-                // after this.\n-                Unreachable(bcx);\n-                bcx\n-            }\n-        }\n-        hir::ExprWhile(ref cond, ref body, _) => {\n-            controlflow::trans_while(bcx, expr, &cond, &body)\n-        }\n-        hir::ExprLoop(ref body, _) => {\n-            controlflow::trans_loop(bcx, expr, &body)\n-        }\n-        hir::ExprAssign(ref dst, ref src) => {\n-            let src_datum = unpack_datum!(bcx, trans(bcx, &src));\n-            let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &dst, \"assign\"));\n-\n-            if bcx.fcx.type_needs_drop(dst_datum.ty) {\n-                // If there are destructors involved, make sure we\n-                // are copying from an rvalue, since that cannot possible\n-                // alias an lvalue. We are concerned about code like:\n-                //\n-                //   a = a\n-                //\n-                // but also\n-                //\n-                //   a = a.b\n-                //\n-                // where e.g. a : Option<Foo> and a.b :\n-                // Option<Foo>. In that case, freeing `a` before the\n-                // assignment may also free `a.b`!\n-                //\n-                // We could avoid this intermediary with some analysis\n-                // to determine whether `dst` may possibly own `src`.\n-                expr.debug_loc().apply(bcx.fcx);\n-                let src_datum = unpack_datum!(\n-                    bcx, src_datum.to_rvalue_datum(bcx, \"ExprAssign\"));\n-                let opt_hint_datum = dst_datum.kind.drop_flag_info.hint_datum(bcx);\n-                let opt_hint_val = opt_hint_datum.map(|d|d.to_value());\n-\n-                // 1. Drop the data at the destination, passing the\n-                //    drop-hint in case the lvalue has already been\n-                //    dropped or moved.\n-                bcx = glue::drop_ty_core(bcx,\n-                                         dst_datum.val,\n-                                         dst_datum.ty,\n-                                         expr.debug_loc(),\n-                                         false,\n-                                         opt_hint_val);\n-\n-                // 2. We are overwriting the destination; ensure that\n-                //    its drop-hint (if any) says \"initialized.\"\n-                if let Some(hint_val) = opt_hint_val {\n-                    let hint_llval = hint_val.value();\n-                    let drop_needed = C_u8(bcx.fcx.ccx, adt::DTOR_NEEDED_HINT);\n-                    Store(bcx, drop_needed, hint_llval);\n-                }\n-                src_datum.store_to(bcx, dst_datum.val)\n-            } else {\n-                src_datum.store_to(bcx, dst_datum.val)\n-            }\n-        }\n-        hir::ExprAssignOp(op, ref dst, ref src) => {\n-            let method = bcx.tcx().tables\n-                                  .borrow()\n-                                  .method_map\n-                                  .get(&MethodCall::expr(expr.id)).cloned();\n-\n-            if let Some(method) = method {\n-                let dst = unpack_datum!(bcx, trans(bcx, &dst));\n-                let src_datum = unpack_datum!(bcx, trans(bcx, &src));\n-\n-                Callee::method(bcx, method)\n-                    .call(bcx, expr.debug_loc(),\n-                          ArgOverloadedOp(dst, Some(src_datum)), None).bcx\n-            } else {\n-                trans_assign_op(bcx, expr, op, &dst, &src)\n-            }\n-        }\n-        hir::ExprInlineAsm(ref a, ref outputs, ref inputs) => {\n-            let outputs = outputs.iter().map(|output| {\n-                let out_datum = unpack_datum!(bcx, trans(bcx, output));\n-                unpack_datum!(bcx, out_datum.to_lvalue_datum(bcx, \"out\", expr.id))\n-            }).collect();\n-            let inputs = inputs.iter().map(|input| {\n-                let input = unpack_datum!(bcx, trans(bcx, input));\n-                let input = unpack_datum!(bcx, input.to_rvalue_datum(bcx, \"in\"));\n-                input.to_llscalarish(bcx)\n-            }).collect();\n-            asm::trans_inline_asm(bcx, a, outputs, inputs);\n-            bcx\n-        }\n-        _ => {\n-            span_bug!(\n-                expr.span,\n-                \"trans_rvalue_stmt_unadjusted reached \\\n-                 fall-through case: {:?}\",\n-                expr.node);\n-        }\n-    }\n-}\n-\n-fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                           expr: &hir::Expr,\n-                                           dest: Dest)\n-                                           -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n-    let mut bcx = bcx;\n-\n-    expr.debug_loc().apply(bcx.fcx);\n-\n-    // Entry into the method table if this is an overloaded call/op.\n-    let method_call = MethodCall::expr(expr.id);\n-\n-    match expr.node {\n-        hir::ExprType(ref e, _) => {\n-            trans_into(bcx, &e, dest)\n-        }\n-        hir::ExprPath(..) => {\n-            trans_def_dps_unadjusted(bcx, expr, bcx.tcx().expect_def(expr.id), dest)\n-        }\n-        hir::ExprIf(ref cond, ref thn, ref els) => {\n-            controlflow::trans_if(bcx, expr.id, &cond, &thn, els.as_ref().map(|e| &**e), dest)\n-        }\n-        hir::ExprMatch(ref discr, ref arms, _) => {\n-            _match::trans_match(bcx, expr, &discr, &arms[..], dest)\n-        }\n-        hir::ExprBlock(ref blk) => {\n-            controlflow::trans_block(bcx, &blk, dest)\n-        }\n-        hir::ExprStruct(_, ref fields, ref base) => {\n-            trans_struct(bcx,\n-                         &fields[..],\n-                         base.as_ref().map(|e| &**e),\n-                         expr.span,\n-                         expr.id,\n-                         node_id_type(bcx, expr.id),\n-                         dest)\n-        }\n-        hir::ExprTup(ref args) => {\n-            let numbered_fields: Vec<(usize, &hir::Expr)> =\n-                args.iter().enumerate().map(|(i, arg)| (i, &**arg)).collect();\n-            trans_adt(bcx,\n-                      expr_ty(bcx, expr),\n-                      Disr(0),\n-                      &numbered_fields[..],\n-                      None,\n-                      dest,\n-                      expr.debug_loc())\n-        }\n-        hir::ExprLit(ref lit) => {\n-            match lit.node {\n-                ast::LitKind::Str(ref s, _) => {\n-                    tvec::trans_lit_str(bcx, expr, (*s).clone(), dest)\n-                }\n-                _ => {\n-                    span_bug!(expr.span,\n-                              \"trans_rvalue_dps_unadjusted shouldn't be \\\n-                              translating this type of literal\")\n-                }\n-            }\n-        }\n-        hir::ExprVec(..) | hir::ExprRepeat(..) => {\n-            tvec::trans_fixed_vstore(bcx, expr, dest)\n-        }\n-        hir::ExprClosure(_, ref decl, ref body, _) => {\n-            let dest = match dest {\n-                SaveIn(lldest) => closure::Dest::SaveIn(bcx, lldest),\n-                Ignore => closure::Dest::Ignore(bcx.ccx())\n-            };\n-\n-            // NB. To get the id of the closure, we don't use\n-            // `local_def_id(id)`, but rather we extract the closure\n-            // def-id from the expr's type. This is because this may\n-            // be an inlined expression from another crate, and we\n-            // want to get the ORIGINAL closure def-id, since that is\n-            // the key we need to find the closure-kind and\n-            // closure-type etc.\n-            let (def_id, substs) = match expr_ty(bcx, expr).sty {\n-                ty::TyClosure(def_id, substs) => (def_id, substs),\n-                ref t =>\n-                    span_bug!(\n-                        expr.span,\n-                        \"closure expr without closure type: {:?}\", t),\n-            };\n-\n-            closure::trans_closure_expr(dest,\n-                                        decl,\n-                                        body,\n-                                        expr.id,\n-                                        def_id,\n-                                        substs).unwrap_or(bcx)\n-        }\n-        hir::ExprCall(ref f, ref args) => {\n-            let method = bcx.tcx().tables.borrow().method_map.get(&method_call).cloned();\n-            let (callee, args) = if let Some(method) = method {\n-                let mut all_args = vec![&**f];\n-                all_args.extend(args.iter().map(|e| &**e));\n-\n-                (Callee::method(bcx, method), ArgOverloadedCall(all_args))\n-            } else {\n-                let f = unpack_datum!(bcx, trans(bcx, f));\n-                (match f.ty.sty {\n-                    ty::TyFnDef(def_id, substs, _) => {\n-                        Callee::def(bcx.ccx(), def_id, substs)\n-                    }\n-                    ty::TyFnPtr(_) => {\n-                        let f = unpack_datum!(bcx,\n-                            f.to_rvalue_datum(bcx, \"callee\"));\n-                        Callee::ptr(f)\n-                    }\n-                    _ => {\n-                        span_bug!(expr.span,\n-                            \"type of callee is not a fn: {}\", f.ty);\n-                    }\n-                }, ArgExprs(&args))\n-            };\n-            callee.call(bcx, expr.debug_loc(), args, Some(dest)).bcx\n-        }\n-        hir::ExprMethodCall(_, _, ref args) => {\n-            Callee::method_call(bcx, method_call)\n-                .call(bcx, expr.debug_loc(), ArgExprs(&args), Some(dest)).bcx\n-        }\n-        hir::ExprBinary(op, ref lhs, ref rhs_expr) => {\n-            // if not overloaded, would be RvalueDatumExpr\n-            let lhs = unpack_datum!(bcx, trans(bcx, &lhs));\n-            let mut rhs = unpack_datum!(bcx, trans(bcx, &rhs_expr));\n-            if !op.node.is_by_value() {\n-                rhs = unpack_datum!(bcx, auto_ref(bcx, rhs, rhs_expr));\n-            }\n-\n-            Callee::method_call(bcx, method_call)\n-                .call(bcx, expr.debug_loc(),\n-                      ArgOverloadedOp(lhs, Some(rhs)), Some(dest)).bcx\n-        }\n-        hir::ExprUnary(_, ref subexpr) => {\n-            // if not overloaded, would be RvalueDatumExpr\n-            let arg = unpack_datum!(bcx, trans(bcx, &subexpr));\n-\n-            Callee::method_call(bcx, method_call)\n-                .call(bcx, expr.debug_loc(),\n-                      ArgOverloadedOp(arg, None), Some(dest)).bcx\n-        }\n-        hir::ExprCast(..) => {\n-            // Trait casts used to come this way, now they should be coercions.\n-            span_bug!(expr.span, \"DPS expr_cast (residual trait cast?)\")\n-        }\n-        hir::ExprAssignOp(op, _, _) => {\n-            span_bug!(\n-                expr.span,\n-                \"augmented assignment `{}=` should always be a rvalue_stmt\",\n-                op.node.as_str())\n-        }\n-        _ => {\n-            span_bug!(\n-                expr.span,\n-                \"trans_rvalue_dps_unadjusted reached fall-through \\\n-                 case: {:?}\",\n-                expr.node);\n-        }\n-    }\n-}\n-\n-fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                        ref_expr: &hir::Expr,\n-                                        def: Def,\n-                                        dest: Dest)\n-                                        -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n-\n-    let lldest = match dest {\n-        SaveIn(lldest) => lldest,\n-        Ignore => { return bcx; }\n-    };\n-\n-    let ty = expr_ty(bcx, ref_expr);\n-    if let ty::TyFnDef(..) = ty.sty {\n-        // Zero-sized function or ctor.\n-        return bcx;\n-    }\n-\n-    match def {\n-        Def::Variant(tid, vid) => {\n-            let variant = bcx.tcx().lookup_adt_def(tid).variant_with_id(vid);\n-            // Nullary variant.\n-            let ty = expr_ty(bcx, ref_expr);\n-            let repr = adt::represent_type(bcx.ccx(), ty);\n-            adt::trans_set_discr(bcx, &repr, lldest, Disr::from(variant.disr_val));\n-            bcx\n-        }\n-        Def::Struct(..) => {\n-            match ty.sty {\n-                ty::TyStruct(def, _) if def.has_dtor() => {\n-                    let repr = adt::represent_type(bcx.ccx(), ty);\n-                    adt::trans_set_discr(bcx, &repr, lldest, Disr(0));\n-                }\n-                _ => {}\n-            }\n-            bcx\n-        }\n-        _ => {\n-            span_bug!(ref_expr.span,\n-                      \"Non-DPS def {:?} referened by {}\",\n-                      def, bcx.node_id_to_string(ref_expr.id));\n-        }\n-    }\n-}\n-\n-fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                            fields: &[hir::Field],\n-                            base: Option<&hir::Expr>,\n-                            expr_span: syntax_pos::Span,\n-                            expr_id: ast::NodeId,\n-                            ty: Ty<'tcx>,\n-                            dest: Dest) -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_rec\");\n-\n-    let tcx = bcx.tcx();\n-    let vinfo = VariantInfo::of_node(tcx, ty, expr_id);\n-\n-    let mut need_base = vec![true; vinfo.fields.len()];\n-\n-    let numbered_fields = fields.iter().map(|field| {\n-        let pos = vinfo.field_index(field.name.node);\n-        need_base[pos] = false;\n-        (pos, &*field.expr)\n-    }).collect::<Vec<_>>();\n-\n-    let optbase = match base {\n-        Some(base_expr) => {\n-            let mut leftovers = Vec::new();\n-            for (i, b) in need_base.iter().enumerate() {\n-                if *b {\n-                    leftovers.push((i, vinfo.fields[i].1));\n-                }\n-            }\n-            Some(StructBaseInfo {expr: base_expr,\n-                                 fields: leftovers })\n-        }\n-        None => {\n-            if need_base.iter().any(|b| *b) {\n-                span_bug!(expr_span, \"missing fields and no base expr\")\n-            }\n-            None\n-        }\n-    };\n-\n-    trans_adt(bcx,\n-              ty,\n-              vinfo.discr,\n-              &numbered_fields,\n-              optbase,\n-              dest,\n-              DebugLoc::At(expr_id, expr_span))\n-}\n-\n-/// Information that `trans_adt` needs in order to fill in the fields\n-/// of a struct copied from a base struct (e.g., from an expression\n-/// like `Foo { a: b, ..base }`.\n-///\n-/// Note that `fields` may be empty; the base expression must always be\n-/// evaluated for side-effects.\n-pub struct StructBaseInfo<'a, 'tcx> {\n-    /// The base expression; will be evaluated after all explicit fields.\n-    expr: &'a hir::Expr,\n-    /// The indices of fields to copy paired with their types.\n-    fields: Vec<(usize, Ty<'tcx>)>\n-}\n-\n-/// Constructs an ADT instance:\n-///\n-/// - `fields` should be a list of field indices paired with the\n-/// expression to store into that field.  The initializers will be\n-/// evaluated in the order specified by `fields`.\n-///\n-/// - `optbase` contains information on the base struct (if any) from\n-/// which remaining fields are copied; see comments on `StructBaseInfo`.\n-pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                 ty: Ty<'tcx>,\n-                                 discr: Disr,\n-                                 fields: &[(usize, &hir::Expr)],\n-                                 optbase: Option<StructBaseInfo<'a, 'tcx>>,\n-                                 dest: Dest,\n-                                 debug_location: DebugLoc)\n-                                 -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_adt\");\n-    let fcx = bcx.fcx;\n-    let repr = adt::represent_type(bcx.ccx(), ty);\n-\n-    debug_location.apply(bcx.fcx);\n-\n-    // If we don't care about the result, just make a\n-    // temporary stack slot\n-    let addr = match dest {\n-        SaveIn(pos) => pos,\n-        Ignore => {\n-            let llresult = alloc_ty(bcx, ty, \"temp\");\n-            call_lifetime_start(bcx, llresult);\n-            llresult\n-        }\n-    };\n-\n-    debug!(\"trans_adt\");\n-\n-    // This scope holds intermediates that must be cleaned should\n-    // panic occur before the ADT as a whole is ready.\n-    let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n-\n-    if ty.is_simd() {\n-        // Issue 23112: The original logic appeared vulnerable to same\n-        // order-of-eval bug. But, SIMD values are tuple-structs;\n-        // i.e. functional record update (FRU) syntax is unavailable.\n-        //\n-        // To be safe, double-check that we did not get here via FRU.\n-        assert!(optbase.is_none());\n-\n-        // This is the constructor of a SIMD type, such types are\n-        // always primitive machine types and so do not have a\n-        // destructor or require any clean-up.\n-        let llty = type_of::type_of(bcx.ccx(), ty);\n-\n-        // keep a vector as a register, and running through the field\n-        // `insertelement`ing them directly into that register\n-        // (i.e. avoid GEPi and `store`s to an alloca) .\n-        let mut vec_val = C_undef(llty);\n-\n-        for &(i, ref e) in fields {\n-            let block_datum = trans(bcx, &e);\n-            bcx = block_datum.bcx;\n-            let position = C_uint(bcx.ccx(), i);\n-            let value = block_datum.datum.to_llscalarish(bcx);\n-            vec_val = InsertElement(bcx, vec_val, value, position);\n-        }\n-        Store(bcx, vec_val, addr);\n-    } else if let Some(base) = optbase {\n-        // Issue 23112: If there is a base, then order-of-eval\n-        // requires field expressions eval'ed before base expression.\n-\n-        // First, trans field expressions to temporary scratch values.\n-        let scratch_vals: Vec<_> = fields.iter().map(|&(i, ref e)| {\n-            let datum = unpack_datum!(bcx, trans(bcx, &e));\n-            (i, datum)\n-        }).collect();\n-\n-        debug_location.apply(bcx.fcx);\n-\n-        // Second, trans the base to the dest.\n-        assert_eq!(discr, Disr(0));\n-\n-        let addr = adt::MaybeSizedValue::sized(addr);\n-        match expr_kind(bcx.tcx(), &base.expr) {\n-            ExprKind::RvalueDps | ExprKind::RvalueDatum if !bcx.fcx.type_needs_drop(ty) => {\n-                bcx = trans_into(bcx, &base.expr, SaveIn(addr.value));\n-            },\n-            ExprKind::RvalueStmt => {\n-                bug!(\"unexpected expr kind for struct base expr\")\n-            }\n-            _ => {\n-                let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &base.expr, \"base\"));\n-                for &(i, t) in &base.fields {\n-                    let datum = base_datum.get_element(\n-                            bcx, t, |srcval| adt::trans_field_ptr(bcx, &repr, srcval, discr, i));\n-                    assert!(type_is_sized(bcx.tcx(), datum.ty));\n-                    let dest = adt::trans_field_ptr(bcx, &repr, addr, discr, i);\n-                    bcx = datum.store_to(bcx, dest);\n-                }\n-            }\n-        }\n-\n-        // Finally, move scratch field values into actual field locations\n-        for (i, datum) in scratch_vals {\n-            let dest = adt::trans_field_ptr(bcx, &repr, addr, discr, i);\n-            bcx = datum.store_to(bcx, dest);\n-        }\n-    } else {\n-        // No base means we can write all fields directly in place.\n-        let addr = adt::MaybeSizedValue::sized(addr);\n-        for &(i, ref e) in fields {\n-            let dest = adt::trans_field_ptr(bcx, &repr, addr, discr, i);\n-            let e_ty = expr_ty_adjusted(bcx, &e);\n-            bcx = trans_into(bcx, &e, SaveIn(dest));\n-            let scope = cleanup::CustomScope(custom_cleanup_scope);\n-            fcx.schedule_lifetime_end(scope, dest);\n-            // FIXME: nonzeroing move should generalize to fields\n-            fcx.schedule_drop_mem(scope, dest, e_ty, None);\n-        }\n-    }\n-\n-    adt::trans_set_discr(bcx, &repr, addr, discr);\n-\n-    fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n-\n-    // If we don't care about the result drop the temporary we made\n-    match dest {\n-        SaveIn(_) => bcx,\n-        Ignore => {\n-            bcx = glue::drop_ty(bcx, addr, ty, debug_location);\n-            base::call_lifetime_end(bcx, addr);\n-            bcx\n-        }\n-    }\n-}\n-\n-\n-fn trans_immediate_lit<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   expr: &hir::Expr,\n-                                   lit: &ast::Lit)\n-                                   -> DatumBlock<'blk, 'tcx, Expr> {\n-    // must not be a string constant, that is a RvalueDpsExpr\n-    let _icx = push_ctxt(\"trans_immediate_lit\");\n-    let ty = expr_ty(bcx, expr);\n-    let v = consts::const_lit(bcx.ccx(), expr, lit);\n-    immediate_rvalue_bcx(bcx, v, ty).to_expr_datumblock()\n-}\n-\n-fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                           expr: &hir::Expr,\n-                           op: hir::UnOp,\n-                           sub_expr: &hir::Expr)\n-                           -> DatumBlock<'blk, 'tcx, Expr> {\n-    let ccx = bcx.ccx();\n-    let mut bcx = bcx;\n-    let _icx = push_ctxt(\"trans_unary_datum\");\n-\n-    let method_call = MethodCall::expr(expr.id);\n-\n-    // The only overloaded operator that is translated to a datum\n-    // is an overloaded deref, since it is always yields a `&T`.\n-    // Otherwise, we should be in the RvalueDpsExpr path.\n-    assert!(op == hir::UnDeref || !ccx.tcx().is_method_call(expr.id));\n-\n-    let un_ty = expr_ty(bcx, expr);\n-\n-    let debug_loc = expr.debug_loc();\n-\n-    match op {\n-        hir::UnNot => {\n-            let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n-            let llresult = Not(bcx, datum.to_llscalarish(bcx), debug_loc);\n-            immediate_rvalue_bcx(bcx, llresult, un_ty).to_expr_datumblock()\n-        }\n-        hir::UnNeg => {\n-            let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n-            let val = datum.to_llscalarish(bcx);\n-            let (bcx, llneg) = {\n-                if un_ty.is_fp() {\n-                    let result = FNeg(bcx, val, debug_loc);\n-                    (bcx, result)\n-                } else {\n-                    let is_signed = un_ty.is_signed();\n-                    let result = Neg(bcx, val, debug_loc);\n-                    let bcx = if bcx.ccx().check_overflow() && is_signed {\n-                        let (llty, min) = base::llty_and_min_for_signed_ty(bcx, un_ty);\n-                        let is_min = ICmp(bcx, llvm::IntEQ, val,\n-                                          C_integral(llty, min, true), debug_loc);\n-                        with_cond(bcx, is_min, |bcx| {\n-                            let msg = InternedString::new(\n-                                \"attempt to negate with overflow\");\n-                            controlflow::trans_fail(bcx, expr_info(expr), msg)\n-                        })\n-                    } else {\n-                        bcx\n-                    };\n-                    (bcx, result)\n-                }\n-            };\n-            immediate_rvalue_bcx(bcx, llneg, un_ty).to_expr_datumblock()\n-        }\n-        hir::UnDeref => {\n-            let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n-            deref_once(bcx, expr, datum, method_call)\n-        }\n-    }\n-}\n-\n-fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               box_expr: &hir::Expr,\n-                               box_ty: Ty<'tcx>,\n-                               contents: &hir::Expr,\n-                               contents_ty: Ty<'tcx>)\n-                               -> DatumBlock<'blk, 'tcx, Expr> {\n-    let _icx = push_ctxt(\"trans_uniq_expr\");\n-    let fcx = bcx.fcx;\n-    assert!(type_is_sized(bcx.tcx(), contents_ty));\n-    let llty = type_of::type_of(bcx.ccx(), contents_ty);\n-    let size = llsize_of(bcx.ccx(), llty);\n-    let align = C_uint(bcx.ccx(), type_of::align_of(bcx.ccx(), contents_ty));\n-    let llty_ptr = llty.ptr_to();\n-    let Result { bcx, val } = malloc_raw_dyn(bcx,\n-                                             llty_ptr,\n-                                             box_ty,\n-                                             size,\n-                                             align,\n-                                             box_expr.debug_loc());\n-    // Unique boxes do not allocate for zero-size types. The standard library\n-    // may assume that `free` is never called on the pointer returned for\n-    // `Box<ZeroSizeType>`.\n-    let bcx = if llsize_of_alloc(bcx.ccx(), llty) == 0 {\n-        trans_into(bcx, contents, SaveIn(val))\n-    } else {\n-        let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n-        fcx.schedule_free_value(cleanup::CustomScope(custom_cleanup_scope),\n-                                val, cleanup::HeapExchange, contents_ty);\n-        let bcx = trans_into(bcx, contents, SaveIn(val));\n-        fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n-        bcx\n-    };\n-    immediate_rvalue_bcx(bcx, val, box_ty).to_expr_datumblock()\n-}\n-\n-fn trans_addr_of<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             expr: &hir::Expr,\n-                             subexpr: &hir::Expr)\n-                             -> DatumBlock<'blk, 'tcx, Expr> {\n-    let _icx = push_ctxt(\"trans_addr_of\");\n-    let mut bcx = bcx;\n-    let sub_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, subexpr, \"addr_of\"));\n-    let ty = expr_ty(bcx, expr);\n-    if !type_is_sized(bcx.tcx(), sub_datum.ty) {\n-        // Always generate an lvalue datum, because this pointer doesn't own\n-        // the data and cleanup is scheduled elsewhere.\n-        DatumBlock::new(bcx, Datum::new(sub_datum.val, ty, LvalueExpr(sub_datum.kind)))\n-    } else {\n-        // Sized value, ref to a thin pointer\n-        immediate_rvalue_bcx(bcx, sub_datum.val, ty).to_expr_datumblock()\n-    }\n-}\n-\n-fn trans_scalar_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  binop_expr: &hir::Expr,\n-                                  binop_ty: Ty<'tcx>,\n-                                  op: hir::BinOp,\n-                                  lhs: Datum<'tcx, Rvalue>,\n-                                  rhs: Datum<'tcx, Rvalue>)\n-                                  -> DatumBlock<'blk, 'tcx, Expr>\n-{\n-    let _icx = push_ctxt(\"trans_scalar_binop\");\n-\n-    let lhs_t = lhs.ty;\n-    assert!(!lhs_t.is_simd());\n-    let is_float = lhs_t.is_fp();\n-    let is_signed = lhs_t.is_signed();\n-    let info = expr_info(binop_expr);\n-\n-    let binop_debug_loc = binop_expr.debug_loc();\n-\n-    let mut bcx = bcx;\n-    let lhs = lhs.to_llscalarish(bcx);\n-    let rhs = rhs.to_llscalarish(bcx);\n-    let val = match op.node {\n-      hir::BiAdd => {\n-        if is_float {\n-            FAdd(bcx, lhs, rhs, binop_debug_loc)\n-        } else {\n-            let (newbcx, res) = with_overflow_check(\n-                bcx, OverflowOp::Add, info, lhs_t, lhs, rhs, binop_debug_loc);\n-            bcx = newbcx;\n-            res\n-        }\n-      }\n-      hir::BiSub => {\n-        if is_float {\n-            FSub(bcx, lhs, rhs, binop_debug_loc)\n-        } else {\n-            let (newbcx, res) = with_overflow_check(\n-                bcx, OverflowOp::Sub, info, lhs_t, lhs, rhs, binop_debug_loc);\n-            bcx = newbcx;\n-            res\n-        }\n-      }\n-      hir::BiMul => {\n-        if is_float {\n-            FMul(bcx, lhs, rhs, binop_debug_loc)\n-        } else {\n-            let (newbcx, res) = with_overflow_check(\n-                bcx, OverflowOp::Mul, info, lhs_t, lhs, rhs, binop_debug_loc);\n-            bcx = newbcx;\n-            res\n-        }\n-      }\n-      hir::BiDiv => {\n-        if is_float {\n-            FDiv(bcx, lhs, rhs, binop_debug_loc)\n-        } else {\n-            // Only zero-check integers; fp /0 is NaN\n-            bcx = base::fail_if_zero_or_overflows(bcx,\n-                                                  expr_info(binop_expr),\n-                                                  op,\n-                                                  lhs,\n-                                                  rhs,\n-                                                  lhs_t);\n-            if is_signed {\n-                SDiv(bcx, lhs, rhs, binop_debug_loc)\n-            } else {\n-                UDiv(bcx, lhs, rhs, binop_debug_loc)\n-            }\n-        }\n-      }\n-      hir::BiRem => {\n-        if is_float {\n-            FRem(bcx, lhs, rhs, binop_debug_loc)\n-        } else {\n-            // Only zero-check integers; fp %0 is NaN\n-            bcx = base::fail_if_zero_or_overflows(bcx,\n-                                                  expr_info(binop_expr),\n-                                                  op, lhs, rhs, lhs_t);\n-            if is_signed {\n-                SRem(bcx, lhs, rhs, binop_debug_loc)\n-            } else {\n-                URem(bcx, lhs, rhs, binop_debug_loc)\n-            }\n-        }\n-      }\n-      hir::BiBitOr => Or(bcx, lhs, rhs, binop_debug_loc),\n-      hir::BiBitAnd => And(bcx, lhs, rhs, binop_debug_loc),\n-      hir::BiBitXor => Xor(bcx, lhs, rhs, binop_debug_loc),\n-      hir::BiShl => {\n-          let (newbcx, res) = with_overflow_check(\n-              bcx, OverflowOp::Shl, info, lhs_t, lhs, rhs, binop_debug_loc);\n-          bcx = newbcx;\n-          res\n-      }\n-      hir::BiShr => {\n-          let (newbcx, res) = with_overflow_check(\n-              bcx, OverflowOp::Shr, info, lhs_t, lhs, rhs, binop_debug_loc);\n-          bcx = newbcx;\n-          res\n-      }\n-      hir::BiEq | hir::BiNe | hir::BiLt | hir::BiGe | hir::BiLe | hir::BiGt => {\n-          base::compare_scalar_types(bcx, lhs, rhs, lhs_t, op.node, binop_debug_loc)\n-      }\n-      _ => {\n-        span_bug!(binop_expr.span, \"unexpected binop\");\n-      }\n-    };\n-\n-    immediate_rvalue_bcx(bcx, val, binop_ty).to_expr_datumblock()\n-}\n-\n-// refinement types would obviate the need for this\n-#[derive(Clone, Copy)]\n-enum lazy_binop_ty {\n-    lazy_and,\n-    lazy_or,\n-}\n-\n-\n-fn trans_lazy_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                binop_expr: &hir::Expr,\n-                                op: lazy_binop_ty,\n-                                a: &hir::Expr,\n-                                b: &hir::Expr)\n-                                -> DatumBlock<'blk, 'tcx, Expr> {\n-    let _icx = push_ctxt(\"trans_lazy_binop\");\n-    let binop_ty = expr_ty(bcx, binop_expr);\n-    let fcx = bcx.fcx;\n-\n-    let DatumBlock {bcx: past_lhs, datum: lhs} = trans(bcx, a);\n-    let lhs = lhs.to_llscalarish(past_lhs);\n-\n-    if past_lhs.unreachable.get() {\n-        return immediate_rvalue_bcx(past_lhs, lhs, binop_ty).to_expr_datumblock();\n-    }\n-\n-    // If the rhs can never be reached, don't generate code for it.\n-    if let Some(cond_val) = const_to_opt_uint(lhs) {\n-        match (cond_val, op) {\n-            (0, lazy_and) |\n-            (1, lazy_or)  => {\n-                return immediate_rvalue_bcx(past_lhs, lhs, binop_ty).to_expr_datumblock();\n-            }\n-            _ => { /* continue */ }\n-        }\n-    }\n-\n-    let join = fcx.new_id_block(\"join\", binop_expr.id);\n-    let before_rhs = fcx.new_id_block(\"before_rhs\", b.id);\n-\n-    match op {\n-      lazy_and => CondBr(past_lhs, lhs, before_rhs.llbb, join.llbb, DebugLoc::None),\n-      lazy_or => CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb, DebugLoc::None)\n-    }\n-\n-    let DatumBlock {bcx: past_rhs, datum: rhs} = trans(before_rhs, b);\n-    let rhs = rhs.to_llscalarish(past_rhs);\n-\n-    if past_rhs.unreachable.get() {\n-        return immediate_rvalue_bcx(join, lhs, binop_ty).to_expr_datumblock();\n-    }\n-\n-    Br(past_rhs, join.llbb, DebugLoc::None);\n-    let phi = Phi(join, Type::i1(bcx.ccx()), &[lhs, rhs],\n-                  &[past_lhs.llbb, past_rhs.llbb]);\n-\n-    return immediate_rvalue_bcx(join, phi, binop_ty).to_expr_datumblock();\n-}\n-\n-fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                            expr: &hir::Expr,\n-                            op: hir::BinOp,\n-                            lhs: &hir::Expr,\n-                            rhs: &hir::Expr)\n-                            -> DatumBlock<'blk, 'tcx, Expr> {\n-    let _icx = push_ctxt(\"trans_binary\");\n-    let ccx = bcx.ccx();\n-\n-    // if overloaded, would be RvalueDpsExpr\n-    assert!(!ccx.tcx().is_method_call(expr.id));\n-\n-    match op.node {\n-        hir::BiAnd => {\n-            trans_lazy_binop(bcx, expr, lazy_and, lhs, rhs)\n-        }\n-        hir::BiOr => {\n-            trans_lazy_binop(bcx, expr, lazy_or, lhs, rhs)\n-        }\n-        _ => {\n-            let mut bcx = bcx;\n-            let binop_ty = expr_ty(bcx, expr);\n-\n-            let lhs = unpack_datum!(bcx, trans(bcx, lhs));\n-            let lhs = unpack_datum!(bcx, lhs.to_rvalue_datum(bcx, \"binop_lhs\"));\n-            debug!(\"trans_binary (expr {}): lhs={:?}\", expr.id, lhs);\n-            let rhs = unpack_datum!(bcx, trans(bcx, rhs));\n-            let rhs = unpack_datum!(bcx, rhs.to_rvalue_datum(bcx, \"binop_rhs\"));\n-            debug!(\"trans_binary (expr {}): rhs={:?}\", expr.id, rhs);\n-\n-            if type_is_fat_ptr(ccx.tcx(), lhs.ty) {\n-                assert!(type_is_fat_ptr(ccx.tcx(), rhs.ty),\n-                        \"built-in binary operators on fat pointers are homogeneous\");\n-                assert_eq!(binop_ty, bcx.tcx().types.bool);\n-                let val = base::compare_scalar_types(\n-                    bcx,\n-                    lhs.val,\n-                    rhs.val,\n-                    lhs.ty,\n-                    op.node,\n-                    expr.debug_loc());\n-                immediate_rvalue_bcx(bcx, val, binop_ty).to_expr_datumblock()\n-            } else {\n-                assert!(!type_is_fat_ptr(ccx.tcx(), rhs.ty),\n-                        \"built-in binary operators on fat pointers are homogeneous\");\n-                trans_scalar_binop(bcx, expr, binop_ty, op, lhs, rhs)\n-            }\n-        }\n-    }\n-}\n-\n-pub fn cast_is_noop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              expr: &hir::Expr,\n-                              t_in: Ty<'tcx>,\n-                              t_out: Ty<'tcx>)\n-                              -> bool {\n-    if let Some(&CastKind::CoercionCast) = tcx.cast_kinds.borrow().get(&expr.id) {\n-        return true;\n-    }\n-\n-    match (t_in.builtin_deref(true, ty::NoPreference),\n-           t_out.builtin_deref(true, ty::NoPreference)) {\n-        (Some(ty::TypeAndMut{ ty: t_in, .. }), Some(ty::TypeAndMut{ ty: t_out, .. })) => {\n-            t_in == t_out\n-        }\n-        _ => {\n-            // This condition isn't redundant with the check for CoercionCast:\n-            // different types can be substituted into the same type, and\n-            // == equality can be overconservative if there are regions.\n-            t_in == t_out\n-        }\n-    }\n-}\n-\n-fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              expr: &hir::Expr,\n-                              id: ast::NodeId)\n-                              -> DatumBlock<'blk, 'tcx, Expr>\n-{\n-    use rustc::ty::cast::CastTy::*;\n-    use rustc::ty::cast::IntTy::*;\n-\n-    fn int_cast(bcx: Block,\n-                lldsttype: Type,\n-                llsrctype: Type,\n-                llsrc: ValueRef,\n-                signed: bool)\n-                -> ValueRef\n-    {\n-        let _icx = push_ctxt(\"int_cast\");\n-        let srcsz = llsrctype.int_width();\n-        let dstsz = lldsttype.int_width();\n-        return if dstsz == srcsz {\n-            BitCast(bcx, llsrc, lldsttype)\n-        } else if srcsz > dstsz {\n-            TruncOrBitCast(bcx, llsrc, lldsttype)\n-        } else if signed {\n-            SExtOrBitCast(bcx, llsrc, lldsttype)\n-        } else {\n-            ZExtOrBitCast(bcx, llsrc, lldsttype)\n-        }\n-    }\n-\n-    fn float_cast(bcx: Block,\n-                  lldsttype: Type,\n-                  llsrctype: Type,\n-                  llsrc: ValueRef)\n-                  -> ValueRef\n-    {\n-        let _icx = push_ctxt(\"float_cast\");\n-        let srcsz = llsrctype.float_width();\n-        let dstsz = lldsttype.float_width();\n-        return if dstsz > srcsz {\n-            FPExt(bcx, llsrc, lldsttype)\n-        } else if srcsz > dstsz {\n-            FPTrunc(bcx, llsrc, lldsttype)\n-        } else { llsrc };\n-    }\n-\n-    let _icx = push_ctxt(\"trans_cast\");\n-    let mut bcx = bcx;\n-    let ccx = bcx.ccx();\n-\n-    let t_in = expr_ty_adjusted(bcx, expr);\n-    let t_out = node_id_type(bcx, id);\n-\n-    debug!(\"trans_cast({:?} as {:?})\", t_in, t_out);\n-    let mut ll_t_in = type_of::immediate_type_of(ccx, t_in);\n-    let ll_t_out = type_of::immediate_type_of(ccx, t_out);\n-    // Convert the value to be cast into a ValueRef, either by-ref or\n-    // by-value as appropriate given its type:\n-    let mut datum = unpack_datum!(bcx, trans(bcx, expr));\n-\n-    let datum_ty = monomorphize_type(bcx, datum.ty);\n-\n-    if cast_is_noop(bcx.tcx(), expr, datum_ty, t_out) {\n-        datum.ty = t_out;\n-        return DatumBlock::new(bcx, datum);\n-    }\n-\n-    if type_is_fat_ptr(bcx.tcx(), t_in) {\n-        assert!(datum.kind.is_by_ref());\n-        if type_is_fat_ptr(bcx.tcx(), t_out) {\n-            return DatumBlock::new(bcx, Datum::new(\n-                PointerCast(bcx, datum.val, ll_t_out.ptr_to()),\n-                t_out,\n-                Rvalue::new(ByRef)\n-            )).to_expr_datumblock();\n-        } else {\n-            // Return the address\n-            return immediate_rvalue_bcx(bcx,\n-                                        PointerCast(bcx,\n-                                                    Load(bcx, get_dataptr(bcx, datum.val)),\n-                                                    ll_t_out),\n-                                        t_out).to_expr_datumblock();\n-        }\n-    }\n-\n-    let r_t_in = CastTy::from_ty(t_in).expect(\"bad input type for cast\");\n-    let r_t_out = CastTy::from_ty(t_out).expect(\"bad output type for cast\");\n-\n-    let (llexpr, signed) = if let Int(CEnum) = r_t_in {\n-        let repr = adt::represent_type(ccx, t_in);\n-        let datum = unpack_datum!(\n-            bcx, datum.to_lvalue_datum(bcx, \"trans_imm_cast\", expr.id));\n-        let llexpr_ptr = datum.to_llref();\n-        let discr = adt::trans_get_discr(bcx, &repr, llexpr_ptr,\n-                                         Some(Type::i64(ccx)), true);\n-        ll_t_in = val_ty(discr);\n-        (discr, adt::is_discr_signed(&repr))\n-    } else {\n-        (datum.to_llscalarish(bcx), t_in.is_signed())\n-    };\n-\n-    let newval = match (r_t_in, r_t_out) {\n-        (Ptr(_), Ptr(_)) | (FnPtr, Ptr(_)) | (RPtr(_), Ptr(_)) => {\n-            PointerCast(bcx, llexpr, ll_t_out)\n-        }\n-        (Ptr(_), Int(_)) | (FnPtr, Int(_)) => PtrToInt(bcx, llexpr, ll_t_out),\n-        (Int(_), Ptr(_)) => IntToPtr(bcx, llexpr, ll_t_out),\n-\n-        (Int(_), Int(_)) => int_cast(bcx, ll_t_out, ll_t_in, llexpr, signed),\n-        (Float, Float) => float_cast(bcx, ll_t_out, ll_t_in, llexpr),\n-        (Int(_), Float) if signed => SIToFP(bcx, llexpr, ll_t_out),\n-        (Int(_), Float) => UIToFP(bcx, llexpr, ll_t_out),\n-        (Float, Int(I)) => FPToSI(bcx, llexpr, ll_t_out),\n-        (Float, Int(_)) => FPToUI(bcx, llexpr, ll_t_out),\n-\n-        _ => span_bug!(expr.span,\n-                       \"translating unsupported cast: \\\n-                        {:?} -> {:?}\",\n-                       t_in,\n-                       t_out)\n-    };\n-    return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n-}\n-\n-fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               expr: &hir::Expr,\n-                               op: hir::BinOp,\n-                               dst: &hir::Expr,\n-                               src: &hir::Expr)\n-                               -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"trans_assign_op\");\n-    let mut bcx = bcx;\n-\n-    debug!(\"trans_assign_op(expr={:?})\", expr);\n-\n-    // User-defined operator methods cannot be used with `+=` etc right now\n-    assert!(!bcx.tcx().is_method_call(expr.id));\n-\n-    // Evaluate LHS (destination), which should be an lvalue\n-    let dst = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n-    assert!(!bcx.fcx.type_needs_drop(dst.ty));\n-    let lhs = load_ty(bcx, dst.val, dst.ty);\n-    let lhs = immediate_rvalue(lhs, dst.ty);\n-\n-    // Evaluate RHS - FIXME(#28160) this sucks\n-    let rhs = unpack_datum!(bcx, trans(bcx, &src));\n-    let rhs = unpack_datum!(bcx, rhs.to_rvalue_datum(bcx, \"assign_op_rhs\"));\n-\n-    // Perform computation and store the result\n-    let result_datum = unpack_datum!(\n-        bcx, trans_scalar_binop(bcx, expr, dst.ty, op, lhs, rhs));\n-    return result_datum.store_to(bcx, dst.val);\n-}\n-\n-fn auto_ref<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                        datum: Datum<'tcx, Expr>,\n-                        expr: &hir::Expr)\n-                        -> DatumBlock<'blk, 'tcx, Expr> {\n-    let mut bcx = bcx;\n-\n-    // Ensure cleanup of `datum` if not already scheduled and obtain\n-    // a \"by ref\" pointer.\n-    let lv_datum = unpack_datum!(bcx, datum.to_lvalue_datum(bcx, \"autoref\", expr.id));\n-\n-    // Compute final type. Note that we are loose with the region and\n-    // mutability, since those things don't matter in trans.\n-    let referent_ty = lv_datum.ty;\n-    let ptr_ty = bcx.tcx().mk_imm_ref(bcx.tcx().mk_region(ty::ReErased), referent_ty);\n-\n-    // Construct the resulting datum. The right datum to return here would be an Lvalue datum,\n-    // because there is cleanup scheduled and the datum doesn't own the data, but for thin pointers\n-    // we microoptimize it to be an Rvalue datum to avoid the extra alloca and level of\n-    // indirection and for thin pointers, this has no ill effects.\n-    let kind  = if type_is_sized(bcx.tcx(), referent_ty) {\n-        RvalueExpr(Rvalue::new(ByValue))\n-    } else {\n-        LvalueExpr(lv_datum.kind)\n-    };\n-\n-    // Get the pointer.\n-    let llref = lv_datum.to_llref();\n-    DatumBlock::new(bcx, Datum::new(llref, ptr_ty, kind))\n-}\n-\n-fn deref_multiple<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              expr: &hir::Expr,\n-                              datum: Datum<'tcx, Expr>,\n-                              times: usize)\n-                              -> DatumBlock<'blk, 'tcx, Expr> {\n-    let mut bcx = bcx;\n-    let mut datum = datum;\n-    for i in 0..times {\n-        let method_call = MethodCall::autoderef(expr.id, i as u32);\n-        datum = unpack_datum!(bcx, deref_once(bcx, expr, datum, method_call));\n-    }\n-    DatumBlock { bcx: bcx, datum: datum }\n-}\n-\n-fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                          expr: &hir::Expr,\n-                          datum: Datum<'tcx, Expr>,\n-                          method_call: MethodCall)\n-                          -> DatumBlock<'blk, 'tcx, Expr> {\n-    let ccx = bcx.ccx();\n-\n-    debug!(\"deref_once(expr={:?}, datum={:?}, method_call={:?})\",\n-           expr, datum, method_call);\n-\n-    let mut bcx = bcx;\n-\n-    // Check for overloaded deref.\n-    let method = ccx.tcx().tables.borrow().method_map.get(&method_call).cloned();\n-    let datum = match method {\n-        Some(method) => {\n-            let method_ty = monomorphize_type(bcx, method.ty);\n-\n-            // Overloaded. Invoke the deref() method, which basically\n-            // converts from the `Smaht<T>` pointer that we have into\n-            // a `&T` pointer.  We can then proceed down the normal\n-            // path (below) to dereference that `&T`.\n-            let datum = if method_call.autoderef == 0 {\n-                datum\n-            } else {\n-                // Always perform an AutoPtr when applying an overloaded auto-deref\n-                unpack_datum!(bcx, auto_ref(bcx, datum, expr))\n-            };\n-\n-            let ref_ty = // invoked methods have their LB regions instantiated\n-                ccx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n-            let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n-\n-            bcx = Callee::method(bcx, method)\n-                .call(bcx, expr.debug_loc(),\n-                      ArgOverloadedOp(datum, None),\n-                      Some(SaveIn(scratch.val))).bcx;\n-            scratch.to_expr_datum()\n-        }\n-        None => {\n-            // Not overloaded. We already have a pointer we know how to deref.\n-            datum\n-        }\n-    };\n-\n-    let r = match datum.ty.sty {\n-        ty::TyBox(content_ty) => {\n-            // Make sure we have an lvalue datum here to get the\n-            // proper cleanups scheduled\n-            let datum = unpack_datum!(\n-                bcx, datum.to_lvalue_datum(bcx, \"deref\", expr.id));\n-\n-            if type_is_sized(bcx.tcx(), content_ty) {\n-                let ptr = load_ty(bcx, datum.val, datum.ty);\n-                DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr(datum.kind)))\n-            } else {\n-                // A fat pointer and a DST lvalue have the same representation\n-                // just different types. Since there is no temporary for `*e`\n-                // here (because it is unsized), we cannot emulate the sized\n-                // object code path for running drop glue and free. Instead,\n-                // we schedule cleanup for `e`, turning it into an lvalue.\n-\n-                let lval = Lvalue::new(\"expr::deref_once ty_uniq\");\n-                let datum = Datum::new(datum.val, content_ty, LvalueExpr(lval));\n-                DatumBlock::new(bcx, datum)\n-            }\n-        }\n-\n-        ty::TyRawPtr(ty::TypeAndMut { ty: content_ty, .. }) |\n-        ty::TyRef(_, ty::TypeAndMut { ty: content_ty, .. }) => {\n-            let lval = Lvalue::new(\"expr::deref_once ptr\");\n-            if type_is_sized(bcx.tcx(), content_ty) {\n-                let ptr = datum.to_llscalarish(bcx);\n-\n-                // Always generate an lvalue datum, even if datum.mode is\n-                // an rvalue.  This is because datum.mode is only an\n-                // rvalue for non-owning pointers like &T or *T, in which\n-                // case cleanup *is* scheduled elsewhere, by the true\n-                // owner (or, in the case of *T, by the user).\n-                DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr(lval)))\n-            } else {\n-                // A fat pointer and a DST lvalue have the same representation\n-                // just different types.\n-                DatumBlock::new(bcx, Datum::new(datum.val, content_ty, LvalueExpr(lval)))\n-            }\n-        }\n-\n-        _ => {\n-            span_bug!(\n-                expr.span,\n-                \"deref invoked on expr of invalid type {:?}\",\n-                datum.ty);\n-        }\n-    };\n-\n-    debug!(\"deref_once(expr={}, method_call={:?}, result={:?})\",\n-           expr.id, method_call, r.datum);\n-\n-    return r;\n-}\n-\n-#[derive(Debug)]\n-enum OverflowOp {\n-    Add,\n-    Sub,\n-    Mul,\n-    Shl,\n-    Shr,\n-}\n-\n-impl OverflowOp {\n-    fn codegen_strategy(&self) -> OverflowCodegen {\n-        use self::OverflowCodegen::{ViaIntrinsic, ViaInputCheck};\n-        match *self {\n-            OverflowOp::Add => ViaIntrinsic(OverflowOpViaIntrinsic::Add),\n-            OverflowOp::Sub => ViaIntrinsic(OverflowOpViaIntrinsic::Sub),\n-            OverflowOp::Mul => ViaIntrinsic(OverflowOpViaIntrinsic::Mul),\n-\n-            OverflowOp::Shl => ViaInputCheck(OverflowOpViaInputCheck::Shl),\n-            OverflowOp::Shr => ViaInputCheck(OverflowOpViaInputCheck::Shr),\n-        }\n-    }\n-}\n-\n-enum OverflowCodegen {\n-    ViaIntrinsic(OverflowOpViaIntrinsic),\n-    ViaInputCheck(OverflowOpViaInputCheck),\n-}\n-\n-enum OverflowOpViaInputCheck { Shl, Shr, }\n-\n-#[derive(Debug)]\n-enum OverflowOpViaIntrinsic { Add, Sub, Mul, }\n-\n-impl OverflowOpViaIntrinsic {\n-    fn to_intrinsic<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>, lhs_ty: Ty) -> ValueRef {\n-        let name = self.to_intrinsic_name(bcx.tcx(), lhs_ty);\n-        bcx.ccx().get_intrinsic(&name)\n-    }\n-    fn to_intrinsic_name(&self, tcx: TyCtxt, ty: Ty) -> &'static str {\n-        use syntax::ast::IntTy::*;\n-        use syntax::ast::UintTy::*;\n-        use rustc::ty::{TyInt, TyUint};\n-\n-        let new_sty = match ty.sty {\n-            TyInt(Is) => match &tcx.sess.target.target.target_pointer_width[..] {\n-                \"16\" => TyInt(I16),\n-                \"32\" => TyInt(I32),\n-                \"64\" => TyInt(I64),\n-                _ => bug!(\"unsupported target word size\")\n-            },\n-            TyUint(Us) => match &tcx.sess.target.target.target_pointer_width[..] {\n-                \"16\" => TyUint(U16),\n-                \"32\" => TyUint(U32),\n-                \"64\" => TyUint(U64),\n-                _ => bug!(\"unsupported target word size\")\n-            },\n-            ref t @ TyUint(_) | ref t @ TyInt(_) => t.clone(),\n-            _ => bug!(\"tried to get overflow intrinsic for {:?} applied to non-int type\",\n-                      *self)\n-        };\n-\n-        match *self {\n-            OverflowOpViaIntrinsic::Add => match new_sty {\n-                TyInt(I8) => \"llvm.sadd.with.overflow.i8\",\n-                TyInt(I16) => \"llvm.sadd.with.overflow.i16\",\n-                TyInt(I32) => \"llvm.sadd.with.overflow.i32\",\n-                TyInt(I64) => \"llvm.sadd.with.overflow.i64\",\n-\n-                TyUint(U8) => \"llvm.uadd.with.overflow.i8\",\n-                TyUint(U16) => \"llvm.uadd.with.overflow.i16\",\n-                TyUint(U32) => \"llvm.uadd.with.overflow.i32\",\n-                TyUint(U64) => \"llvm.uadd.with.overflow.i64\",\n-\n-                _ => bug!(),\n-            },\n-            OverflowOpViaIntrinsic::Sub => match new_sty {\n-                TyInt(I8) => \"llvm.ssub.with.overflow.i8\",\n-                TyInt(I16) => \"llvm.ssub.with.overflow.i16\",\n-                TyInt(I32) => \"llvm.ssub.with.overflow.i32\",\n-                TyInt(I64) => \"llvm.ssub.with.overflow.i64\",\n-\n-                TyUint(U8) => \"llvm.usub.with.overflow.i8\",\n-                TyUint(U16) => \"llvm.usub.with.overflow.i16\",\n-                TyUint(U32) => \"llvm.usub.with.overflow.i32\",\n-                TyUint(U64) => \"llvm.usub.with.overflow.i64\",\n-\n-                _ => bug!(),\n-            },\n-            OverflowOpViaIntrinsic::Mul => match new_sty {\n-                TyInt(I8) => \"llvm.smul.with.overflow.i8\",\n-                TyInt(I16) => \"llvm.smul.with.overflow.i16\",\n-                TyInt(I32) => \"llvm.smul.with.overflow.i32\",\n-                TyInt(I64) => \"llvm.smul.with.overflow.i64\",\n-\n-                TyUint(U8) => \"llvm.umul.with.overflow.i8\",\n-                TyUint(U16) => \"llvm.umul.with.overflow.i16\",\n-                TyUint(U32) => \"llvm.umul.with.overflow.i32\",\n-                TyUint(U64) => \"llvm.umul.with.overflow.i64\",\n-\n-                _ => bug!(),\n-            },\n-        }\n-    }\n-\n-    fn build_intrinsic_call<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>,\n-                                        info: NodeIdAndSpan,\n-                                        lhs_t: Ty<'tcx>, lhs: ValueRef,\n-                                        rhs: ValueRef,\n-                                        binop_debug_loc: DebugLoc)\n-                                        -> (Block<'blk, 'tcx>, ValueRef) {\n-        use rustc_const_math::{ConstMathErr, Op};\n-\n-        let llfn = self.to_intrinsic(bcx, lhs_t);\n-\n-        let val = Call(bcx, llfn, &[lhs, rhs], binop_debug_loc);\n-        let result = ExtractValue(bcx, val, 0); // iN operation result\n-        let overflow = ExtractValue(bcx, val, 1); // i1 \"did it overflow?\"\n-\n-        let cond = ICmp(bcx, llvm::IntEQ, overflow, C_integral(Type::i1(bcx.ccx()), 1, false),\n-                        binop_debug_loc);\n-\n-        let expect = bcx.ccx().get_intrinsic(&\"llvm.expect.i1\");\n-        let expected = Call(bcx, expect, &[cond, C_bool(bcx.ccx(), false)],\n-                            binop_debug_loc);\n-\n-        let op = match *self {\n-            OverflowOpViaIntrinsic::Add => Op::Add,\n-            OverflowOpViaIntrinsic::Sub => Op::Sub,\n-            OverflowOpViaIntrinsic::Mul => Op::Mul\n-        };\n-\n-        let bcx =\n-            base::with_cond(bcx, expected, |bcx|\n-                controlflow::trans_fail(bcx, info,\n-                    InternedString::new(ConstMathErr::Overflow(op).description())));\n-\n-        (bcx, result)\n-    }\n-}\n-\n-impl OverflowOpViaInputCheck {\n-    fn build_with_input_check<'blk, 'tcx>(&self,\n-                                          bcx: Block<'blk, 'tcx>,\n-                                          info: NodeIdAndSpan,\n-                                          lhs_t: Ty<'tcx>,\n-                                          lhs: ValueRef,\n-                                          rhs: ValueRef,\n-                                          binop_debug_loc: DebugLoc)\n-                                          -> (Block<'blk, 'tcx>, ValueRef)\n-    {\n-        use rustc_const_math::{ConstMathErr, Op};\n-\n-        let lhs_llty = val_ty(lhs);\n-        let rhs_llty = val_ty(rhs);\n-\n-        // Panic if any bits are set outside of bits that we always\n-        // mask in.\n-        //\n-        // Note that the mask's value is derived from the LHS type\n-        // (since that is where the 32/64 distinction is relevant) but\n-        // the mask's type must match the RHS type (since they will\n-        // both be fed into an and-binop)\n-        let invert_mask = shift_mask_val(bcx, lhs_llty, rhs_llty, true);\n-\n-        let outer_bits = And(bcx, rhs, invert_mask, binop_debug_loc);\n-        let cond = build_nonzero_check(bcx, outer_bits, binop_debug_loc);\n-        let (result, op) = match *self {\n-            OverflowOpViaInputCheck::Shl =>\n-                (build_unchecked_lshift(bcx, lhs, rhs, binop_debug_loc), Op::Shl),\n-            OverflowOpViaInputCheck::Shr =>\n-                (build_unchecked_rshift(bcx, lhs_t, lhs, rhs, binop_debug_loc), Op::Shr)\n-        };\n-        let bcx =\n-            base::with_cond(bcx, cond, |bcx|\n-                controlflow::trans_fail(bcx, info,\n-                    InternedString::new(ConstMathErr::Overflow(op).description())));\n-\n-        (bcx, result)\n-    }\n-}\n-\n-// Check if an integer or vector contains a nonzero element.\n-fn build_nonzero_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   value: ValueRef,\n-                                   binop_debug_loc: DebugLoc) -> ValueRef {\n-    let llty = val_ty(value);\n-    let kind = llty.kind();\n-    match kind {\n-        TypeKind::Integer => ICmp(bcx, llvm::IntNE, value, C_null(llty), binop_debug_loc),\n-        TypeKind::Vector => {\n-            // Check if any elements of the vector are nonzero by treating\n-            // it as a wide integer and checking if the integer is nonzero.\n-            let width = llty.vector_length() as u64 * llty.element_type().int_width();\n-            let int_value = BitCast(bcx, value, Type::ix(bcx.ccx(), width));\n-            build_nonzero_check(bcx, int_value, binop_debug_loc)\n-        },\n-        _ => bug!(\"build_nonzero_check: expected Integer or Vector, found {:?}\", kind),\n-    }\n-}\n-\n-fn with_overflow_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, oop: OverflowOp, info: NodeIdAndSpan,\n-                                   lhs_t: Ty<'tcx>, lhs: ValueRef,\n-                                   rhs: ValueRef,\n-                                   binop_debug_loc: DebugLoc)\n-                                   -> (Block<'blk, 'tcx>, ValueRef) {\n-    if bcx.unreachable.get() { return (bcx, _Undef(lhs)); }\n-    if bcx.ccx().check_overflow() {\n-\n-        match oop.codegen_strategy() {\n-            OverflowCodegen::ViaIntrinsic(oop) =>\n-                oop.build_intrinsic_call(bcx, info, lhs_t, lhs, rhs, binop_debug_loc),\n-            OverflowCodegen::ViaInputCheck(oop) =>\n-                oop.build_with_input_check(bcx, info, lhs_t, lhs, rhs, binop_debug_loc),\n-        }\n-    } else {\n-        let res = match oop {\n-            OverflowOp::Add => Add(bcx, lhs, rhs, binop_debug_loc),\n-            OverflowOp::Sub => Sub(bcx, lhs, rhs, binop_debug_loc),\n-            OverflowOp::Mul => Mul(bcx, lhs, rhs, binop_debug_loc),\n-\n-            OverflowOp::Shl =>\n-                build_unchecked_lshift(bcx, lhs, rhs, binop_debug_loc),\n-            OverflowOp::Shr =>\n-                build_unchecked_rshift(bcx, lhs_t, lhs, rhs, binop_debug_loc),\n-        };\n-        (bcx, res)\n-    }\n-}\n-\n-/// We categorize expressions into three kinds.  The distinction between\n-/// lvalue/rvalue is fundamental to the language.  The distinction between the\n-/// two kinds of rvalues is an artifact of trans which reflects how we will\n-/// generate code for that kind of expression.  See trans/expr.rs for more\n-/// information.\n-#[derive(Copy, Clone)]\n-enum ExprKind {\n-    Lvalue,\n-    RvalueDps,\n-    RvalueDatum,\n-    RvalueStmt\n-}\n-\n-fn expr_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, expr: &hir::Expr) -> ExprKind {\n-    if tcx.is_method_call(expr.id) {\n-        // Overloaded operations are generally calls, and hence they are\n-        // generated via DPS, but there are a few exceptions:\n-        return match expr.node {\n-            // `a += b` has a unit result.\n-            hir::ExprAssignOp(..) => ExprKind::RvalueStmt,\n-\n-            // the deref method invoked for `*a` always yields an `&T`\n-            hir::ExprUnary(hir::UnDeref, _) => ExprKind::Lvalue,\n-\n-            // the index method invoked for `a[i]` always yields an `&T`\n-            hir::ExprIndex(..) => ExprKind::Lvalue,\n-\n-            // in the general case, result could be any type, use DPS\n-            _ => ExprKind::RvalueDps\n-        };\n-    }\n-\n-    match expr.node {\n-        hir::ExprPath(..) => {\n-            match tcx.expect_def(expr.id) {\n-                // Put functions and ctors with the ADTs, as they\n-                // are zero-sized, so DPS is the cheapest option.\n-                Def::Struct(..) | Def::Variant(..) |\n-                Def::Fn(..) | Def::Method(..) => {\n-                    ExprKind::RvalueDps\n-                }\n-\n-                // Note: there is actually a good case to be made that\n-                // DefArg's, particularly those of immediate type, ought to\n-                // considered rvalues.\n-                Def::Static(..) |\n-                Def::Upvar(..) |\n-                Def::Local(..) => ExprKind::Lvalue,\n-\n-                Def::Const(..) |\n-                Def::AssociatedConst(..) => ExprKind::RvalueDatum,\n-\n-                def => {\n-                    span_bug!(\n-                        expr.span,\n-                        \"uncategorized def for expr {}: {:?}\",\n-                        expr.id,\n-                        def);\n-                }\n-            }\n-        }\n-\n-        hir::ExprType(ref expr, _) => {\n-            expr_kind(tcx, expr)\n-        }\n-\n-        hir::ExprUnary(hir::UnDeref, _) |\n-        hir::ExprField(..) |\n-        hir::ExprTupField(..) |\n-        hir::ExprIndex(..) => {\n-            ExprKind::Lvalue\n-        }\n-\n-        hir::ExprCall(..) |\n-        hir::ExprMethodCall(..) |\n-        hir::ExprStruct(..) |\n-        hir::ExprTup(..) |\n-        hir::ExprIf(..) |\n-        hir::ExprMatch(..) |\n-        hir::ExprClosure(..) |\n-        hir::ExprBlock(..) |\n-        hir::ExprRepeat(..) |\n-        hir::ExprVec(..) => {\n-            ExprKind::RvalueDps\n-        }\n-\n-        hir::ExprLit(ref lit) if lit.node.is_str() => {\n-            ExprKind::RvalueDps\n-        }\n-\n-        hir::ExprBreak(..) |\n-        hir::ExprAgain(..) |\n-        hir::ExprRet(..) |\n-        hir::ExprWhile(..) |\n-        hir::ExprLoop(..) |\n-        hir::ExprAssign(..) |\n-        hir::ExprInlineAsm(..) |\n-        hir::ExprAssignOp(..) => {\n-            ExprKind::RvalueStmt\n-        }\n-\n-        hir::ExprLit(_) | // Note: LitStr is carved out above\n-        hir::ExprUnary(..) |\n-        hir::ExprBox(_) |\n-        hir::ExprAddrOf(..) |\n-        hir::ExprBinary(..) |\n-        hir::ExprCast(..) => {\n-            ExprKind::RvalueDatum\n-        }\n-    }\n-}"}, {"sha": "6a072c84dd9b39e39d6b3faa33e22c7950213f8d", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 188, "deletions": 146, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -21,21 +21,19 @@ use rustc::ty::subst::{Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use adt;\n-use adt::GetDtorType; // for tcx.dtor_type()\n use base::*;\n use build::*;\n-use callee::{Callee, ArgVals};\n-use cleanup;\n-use cleanup::CleanupMethods;\n+use callee::{Callee};\n use common::*;\n use debuginfo::DebugLoc;\n-use expr;\n use machine::*;\n use monomorphize;\n use trans_item::TransItem;\n+use tvec;\n use type_of::{type_of, sizing_type_of, align_of};\n use type_::Type;\n use value::Value;\n+use Disr;\n \n use arena::TypedArena;\n use syntax_pos::DUMMY_SP;\n@@ -51,7 +49,7 @@ pub fn trans_exchange_free_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let def_id = langcall(bcx.tcx(), None, \"\", ExchangeFreeFnLangItem);\n     let args = [PointerCast(bcx, v, Type::i8p(bcx.ccx())), size, align];\n     Callee::def(bcx.ccx(), def_id, Substs::empty(bcx.tcx()))\n-        .call(bcx, debug_loc, ArgVals(&args), None).bcx\n+        .call(bcx, debug_loc, &args, None).bcx\n }\n \n pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n@@ -133,20 +131,18 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            v: ValueRef,\n                            t: Ty<'tcx>,\n                            debug_loc: DebugLoc) -> Block<'blk, 'tcx> {\n-    drop_ty_core(bcx, v, t, debug_loc, false, None)\n+    drop_ty_core(bcx, v, t, debug_loc, false)\n }\n \n pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 v: ValueRef,\n                                 t: Ty<'tcx>,\n                                 debug_loc: DebugLoc,\n-                                skip_dtor: bool,\n-                                drop_hint: Option<cleanup::DropHintValue>)\n+                                skip_dtor: bool)\n                                 -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    debug!(\"drop_ty_core(t={:?}, skip_dtor={} drop_hint={:?})\", t, skip_dtor, drop_hint);\n+    debug!(\"drop_ty_core(t={:?}, skip_dtor={})\", t, skip_dtor);\n     let _icx = push_ctxt(\"drop_ty\");\n-    let mut bcx = bcx;\n     if bcx.fcx.type_needs_drop(t) {\n         let ccx = bcx.ccx();\n         let g = if skip_dtor {\n@@ -162,23 +158,8 @@ pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             v\n         };\n \n-        match drop_hint {\n-            Some(drop_hint) => {\n-                let hint_val = load_ty(bcx, drop_hint.value(), bcx.tcx().types.u8);\n-                let moved_val =\n-                    C_integral(Type::i8(bcx.ccx()), adt::DTOR_MOVED_HINT as u64, false);\n-                let may_need_drop =\n-                    ICmp(bcx, llvm::IntNE, hint_val, moved_val, DebugLoc::None);\n-                bcx = with_cond(bcx, may_need_drop, |cx| {\n-                    Call(cx, glue, &[ptr], debug_loc);\n-                    cx\n-                })\n-            }\n-            None => {\n-                // No drop-hint ==> call standard drop glue\n-                Call(bcx, glue, &[ptr], debug_loc);\n-            }\n-        }\n+        // No drop-hint ==> call standard drop glue\n+        Call(bcx, glue, &[ptr], debug_loc);\n     }\n     bcx\n }\n@@ -193,7 +174,7 @@ pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let vp = alloc_ty(bcx, t, \"\");\n     call_lifetime_start(bcx, vp);\n     store_ty(bcx, v, vp, t);\n-    let bcx = drop_ty_core(bcx, vp, t, debug_loc, skip_dtor, None);\n+    let bcx = drop_ty_core(bcx, vp, t, debug_loc, skip_dtor);\n     call_lifetime_end(bcx, vp);\n     bcx\n }\n@@ -240,10 +221,6 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     g,\n                     TransItem::DropGlue(g).to_raw_string(),\n                     ccx.codegen_unit().name());\n-\n-            ccx.stats().n_fallback_instantiations.set(ccx.stats()\n-                                                         .n_fallback_instantiations\n-                                                         .get() + 1);\n         }\n     }\n \n@@ -273,7 +250,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     arena = TypedArena::new();\n     fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &arena);\n \n-    let bcx = fcx.init(false, None);\n+    let bcx = fcx.init(false);\n \n     ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n     // All glue functions take values passed *by alias*; this is a\n@@ -288,40 +265,6 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     fcx.finish(bcx, DebugLoc::None);\n }\n \n-\n-fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                      t: Ty<'tcx>,\n-                                      struct_data: ValueRef)\n-                                      -> Block<'blk, 'tcx> {\n-    assert!(type_is_sized(bcx.tcx(), t), \"Precondition: caller must ensure t is sized\");\n-\n-    let repr = adt::represent_type(bcx.ccx(), t);\n-    let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &repr, struct_data));\n-    let loaded = load_ty(bcx, drop_flag.val, bcx.tcx().dtor_type());\n-    let drop_flag_llty = type_of(bcx.fcx.ccx, bcx.tcx().dtor_type());\n-    let init_val = C_integral(drop_flag_llty, adt::DTOR_NEEDED as u64, false);\n-\n-    let bcx = if !bcx.ccx().check_drop_flag_for_sanity() {\n-        bcx\n-    } else {\n-        let drop_flag_llty = type_of(bcx.fcx.ccx, bcx.tcx().dtor_type());\n-        let done_val = C_integral(drop_flag_llty, adt::DTOR_DONE as u64, false);\n-        let not_init = ICmp(bcx, llvm::IntNE, loaded, init_val, DebugLoc::None);\n-        let not_done = ICmp(bcx, llvm::IntNE, loaded, done_val, DebugLoc::None);\n-        let drop_flag_neither_initialized_nor_cleared =\n-            And(bcx, not_init, not_done, DebugLoc::None);\n-        with_cond(bcx, drop_flag_neither_initialized_nor_cleared, |cx| {\n-            let llfn = cx.ccx().get_intrinsic(&(\"llvm.debugtrap\"));\n-            Call(cx, llfn, &[], DebugLoc::None);\n-            cx\n-        })\n-    };\n-\n-    let drop_flag_dtor_needed = ICmp(bcx, llvm::IntEQ, loaded, init_val, DebugLoc::None);\n-    with_cond(bcx, drop_flag_dtor_needed, |cx| {\n-        trans_struct_drop(cx, t, struct_data)\n-    })\n-}\n fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  t: Ty<'tcx>,\n                                  v0: ValueRef)\n@@ -343,14 +286,17 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Issue #23611: schedule cleanup of contents, re-inspecting the\n     // discriminant (if any) in case of variant swap in drop code.\n-    bcx.fcx.schedule_drop_adt_contents(cleanup::CustomScope(contents_scope), v0, t);\n+    bcx.fcx.schedule_drop_adt_contents(contents_scope, v0, t);\n \n     let (sized_args, unsized_args);\n     let args: &[ValueRef] = if type_is_sized(tcx, t) {\n         sized_args = [v0];\n         &sized_args\n     } else {\n-        unsized_args = [Load(bcx, expr::get_dataptr(bcx, v0)), Load(bcx, expr::get_meta(bcx, v0))];\n+        unsized_args = [\n+            Load(bcx, get_dataptr(bcx, v0)),\n+            Load(bcx, get_meta(bcx, v0))\n+        ];\n         &unsized_args\n     };\n \n@@ -364,7 +310,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n     let dtor_did = def.destructor().unwrap();\n     bcx = Callee::def(bcx.ccx(), dtor_did, vtbl.substs)\n-        .call(bcx, DebugLoc::None, ArgVals(args), None).bcx;\n+        .call(bcx, DebugLoc::None, args, None).bcx;\n \n     bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n }\n@@ -395,10 +341,10 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             // Don't use type_of::sizing_type_of because that expects t to be sized.\n             assert!(!t.is_simd());\n             let repr = adt::represent_type(ccx, t);\n-            let sizing_type = adt::sizing_type_context_of(ccx, &repr, true);\n+            let sizing_type = adt::sizing_type_of(ccx, &repr, true);\n             debug!(\"DST {} sizing_type: {:?}\", t, sizing_type);\n-            let sized_size = llsize_of_alloc(ccx, sizing_type.prefix());\n-            let sized_align = llalign_of_min(ccx, sizing_type.prefix());\n+            let sized_size = llsize_of_alloc(ccx, sizing_type);\n+            let sized_align = llalign_of_min(ccx, sizing_type);\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n             let sized_size = C_uint(ccx, sized_size);\n@@ -418,15 +364,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             // here. But this is where the add would go.)\n \n             // Return the sum of sizes and max of aligns.\n-            let mut size = bcx.add(sized_size, unsized_size);\n-\n-            // Issue #27023: If there is a drop flag, *now* we add 1\n-            // to the size.  (We can do this without adding any\n-            // padding because drop flags do not have any alignment\n-            // constraints.)\n-            if sizing_type.needs_drop_flag() {\n-                size = bcx.add(size, C_uint(bcx.ccx(), 1_u64));\n-            }\n+            let size = bcx.add(sized_size, unsized_size);\n \n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n@@ -492,100 +430,204 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n     // must definitely check for special bit-patterns corresponding to\n     // the special dtor markings.\n \n-    let inttype = Type::int(bcx.ccx());\n-    let dropped_pattern = C_integral(inttype, adt::DTOR_DONE_U64, false);\n-\n     match t.sty {\n         ty::TyBox(content_ty) => {\n             // Support for TyBox is built-in and its drop glue is\n             // special. It may move to library and have Drop impl. As\n             // a safe-guard, assert TyBox not used with TyContents.\n             assert!(!skip_dtor);\n             if !type_is_sized(bcx.tcx(), content_ty) {\n-                let llval = expr::get_dataptr(bcx, v0);\n+                let llval = get_dataptr(bcx, v0);\n                 let llbox = Load(bcx, llval);\n-                let llbox_as_usize = PtrToInt(bcx, llbox, Type::int(bcx.ccx()));\n-                let drop_flag_not_dropped_already =\n-                    ICmp(bcx, llvm::IntNE, llbox_as_usize, dropped_pattern, DebugLoc::None);\n-                with_cond(bcx, drop_flag_not_dropped_already, |bcx| {\n-                    let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n-                    let info = expr::get_meta(bcx, v0);\n-                    let info = Load(bcx, info);\n-                    let (llsize, llalign) =\n-                        size_and_align_of_dst(&bcx.build(), content_ty, info);\n-\n-                    // `Box<ZeroSizeType>` does not allocate.\n-                    let needs_free = ICmp(bcx,\n-                                          llvm::IntNE,\n-                                          llsize,\n-                                          C_uint(bcx.ccx(), 0u64),\n-                                          DebugLoc::None);\n-                    with_cond(bcx, needs_free, |bcx| {\n-                        trans_exchange_free_dyn(bcx, llbox, llsize, llalign, DebugLoc::None)\n-                    })\n+                let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n+                let info = get_meta(bcx, v0);\n+                let info = Load(bcx, info);\n+                let (llsize, llalign) =\n+                    size_and_align_of_dst(&bcx.build(), content_ty, info);\n+\n+                // `Box<ZeroSizeType>` does not allocate.\n+                let needs_free = ICmp(bcx,\n+                                        llvm::IntNE,\n+                                        llsize,\n+                                        C_uint(bcx.ccx(), 0u64),\n+                                        DebugLoc::None);\n+                with_cond(bcx, needs_free, |bcx| {\n+                    trans_exchange_free_dyn(bcx, llbox, llsize, llalign, DebugLoc::None)\n                 })\n             } else {\n                 let llval = v0;\n                 let llbox = Load(bcx, llval);\n-                let llbox_as_usize = PtrToInt(bcx, llbox, inttype);\n-                let drop_flag_not_dropped_already =\n-                    ICmp(bcx, llvm::IntNE, llbox_as_usize, dropped_pattern, DebugLoc::None);\n-                with_cond(bcx, drop_flag_not_dropped_already, |bcx| {\n-                    let bcx = drop_ty(bcx, llbox, content_ty, DebugLoc::None);\n-                    trans_exchange_free_ty(bcx, llbox, content_ty, DebugLoc::None)\n-                })\n-            }\n-        }\n-        ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n-            match (def.dtor_kind(), skip_dtor) {\n-                (ty::TraitDtor(true), false) => {\n-                    // FIXME(16758) Since the struct is unsized, it is hard to\n-                    // find the drop flag (which is at the end of the struct).\n-                    // Lets just ignore the flag and pretend everything will be\n-                    // OK.\n-                    if type_is_sized(bcx.tcx(), t) {\n-                        trans_struct_drop_flag(bcx, t, v0)\n-                    } else {\n-                        // Give the user a heads up that we are doing something\n-                        // stupid and dangerous.\n-                        bcx.sess().warn(&format!(\"Ignoring drop flag in destructor for {} \\\n-                                                 because the struct is unsized. See issue \\\n-                                                 #16758\", t));\n-                        trans_struct_drop(bcx, t, v0)\n-                    }\n-                }\n-                (ty::TraitDtor(false), false) => {\n-                    trans_struct_drop(bcx, t, v0)\n-                }\n-                (ty::NoDtor, _) | (_, true) => {\n-                    // No dtor? Just the default case\n-                    iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n-                }\n+                let bcx = drop_ty(bcx, llbox, content_ty, DebugLoc::None);\n+                trans_exchange_free_ty(bcx, llbox, content_ty, DebugLoc::None)\n             }\n         }\n         ty::TyTrait(..) => {\n             // No support in vtable for distinguishing destroying with\n             // versus without calling Drop::drop. Assert caller is\n             // okay with always calling the Drop impl, if any.\n             assert!(!skip_dtor);\n-            let data_ptr = expr::get_dataptr(bcx, v0);\n-            let vtable_ptr = Load(bcx, expr::get_meta(bcx, v0));\n+            let data_ptr = get_dataptr(bcx, v0);\n+            let vtable_ptr = Load(bcx, get_meta(bcx, v0));\n             let dtor = Load(bcx, vtable_ptr);\n             Call(bcx,\n                  dtor,\n                  &[PointerCast(bcx, Load(bcx, data_ptr), Type::i8p(bcx.ccx()))],\n                  DebugLoc::None);\n             bcx\n         }\n+        ty::TyStruct(def, _) | ty::TyEnum(def, _)\n+                if def.dtor_kind().is_present() && !skip_dtor => {\n+            trans_struct_drop(bcx, t, v0)\n+        }\n         _ => {\n             if bcx.fcx.type_needs_drop(t) {\n-                iter_structural_ty(bcx,\n-                                   v0,\n-                                   t,\n-                                   |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n+                drop_structural_ty(bcx, v0, t)\n             } else {\n                 bcx\n             }\n         }\n     }\n }\n+\n+// Iterates through the elements of a structural type, dropping them.\n+fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                  av: ValueRef,\n+                                  t: Ty<'tcx>)\n+                                  -> Block<'blk, 'tcx> {\n+    let _icx = push_ctxt(\"drop_structural_ty\");\n+\n+    fn iter_variant<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                repr: &adt::Repr<'tcx>,\n+                                av: adt::MaybeSizedValue,\n+                                variant: ty::VariantDef<'tcx>,\n+                                substs: &Substs<'tcx>)\n+                                -> Block<'blk, 'tcx> {\n+        let _icx = push_ctxt(\"iter_variant\");\n+        let tcx = cx.tcx();\n+        let mut cx = cx;\n+\n+        for (i, field) in variant.fields.iter().enumerate() {\n+            let arg = monomorphize::field_ty(tcx, substs, field);\n+            cx = drop_ty(cx,\n+                         adt::trans_field_ptr(cx, repr, av, Disr::from(variant.disr_val), i),\n+                         arg, DebugLoc::None);\n+        }\n+        return cx;\n+    }\n+\n+    let value = if type_is_sized(cx.tcx(), t) {\n+        adt::MaybeSizedValue::sized(av)\n+    } else {\n+        let data = Load(cx, get_dataptr(cx, av));\n+        let info = Load(cx, get_meta(cx, av));\n+        adt::MaybeSizedValue::unsized_(data, info)\n+    };\n+\n+    let mut cx = cx;\n+    match t.sty {\n+        ty::TyStruct(..) => {\n+            let repr = adt::represent_type(cx.ccx(), t);\n+            let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n+            for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n+                let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr::from(discr), i);\n+\n+                let val = if type_is_sized(cx.tcx(), field_ty) {\n+                    llfld_a\n+                } else {\n+                    let scratch = alloc_ty(cx, field_ty, \"__fat_ptr_iter\");\n+                    Store(cx, llfld_a, get_dataptr(cx, scratch));\n+                    Store(cx, value.meta, get_meta(cx, scratch));\n+                    scratch\n+                };\n+                cx = drop_ty(cx, val, field_ty, DebugLoc::None);\n+            }\n+        }\n+        ty::TyClosure(_, ref substs) => {\n+            let repr = adt::represent_type(cx.ccx(), t);\n+            for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n+                let llupvar = adt::trans_field_ptr(cx, &repr, value, Disr(0), i);\n+                cx = drop_ty(cx, llupvar, upvar_ty, DebugLoc::None);\n+            }\n+        }\n+        ty::TyArray(_, n) => {\n+            let base = get_dataptr(cx, value.value);\n+            let len = C_uint(cx.ccx(), n);\n+            let unit_ty = t.sequence_element_type(cx.tcx());\n+            cx = tvec::slice_for_each(cx, base, unit_ty, len,\n+                |bb, vv| drop_ty(bb, vv, unit_ty, DebugLoc::None));\n+        }\n+        ty::TySlice(_) | ty::TyStr => {\n+            let unit_ty = t.sequence_element_type(cx.tcx());\n+            cx = tvec::slice_for_each(cx, value.value, unit_ty, value.meta,\n+                |bb, vv| drop_ty(bb, vv, unit_ty, DebugLoc::None));\n+        }\n+        ty::TyTuple(ref args) => {\n+            let repr = adt::represent_type(cx.ccx(), t);\n+            for (i, arg) in args.iter().enumerate() {\n+                let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr(0), i);\n+                cx = drop_ty(cx, llfld_a, *arg, DebugLoc::None);\n+            }\n+        }\n+        ty::TyEnum(en, substs) => {\n+            let fcx = cx.fcx;\n+            let ccx = fcx.ccx;\n+\n+            let repr = adt::represent_type(ccx, t);\n+            let n_variants = en.variants.len();\n+\n+            // NB: we must hit the discriminant first so that structural\n+            // comparison know not to proceed when the discriminants differ.\n+\n+            match adt::trans_switch(cx, &repr, av, false) {\n+                (adt::BranchKind::Single, None) => {\n+                    if n_variants != 0 {\n+                        assert!(n_variants == 1);\n+                        cx = iter_variant(cx, &repr, adt::MaybeSizedValue::sized(av),\n+                                          &en.variants[0], substs);\n+                    }\n+                }\n+                (adt::BranchKind::Switch, Some(lldiscrim_a)) => {\n+                    cx = drop_ty(cx, lldiscrim_a, cx.tcx().types.isize, DebugLoc::None);\n+\n+                    // Create a fall-through basic block for the \"else\" case of\n+                    // the switch instruction we're about to generate. Note that\n+                    // we do **not** use an Unreachable instruction here, even\n+                    // though most of the time this basic block will never be hit.\n+                    //\n+                    // When an enum is dropped it's contents are currently\n+                    // overwritten to DTOR_DONE, which means the discriminant\n+                    // could have changed value to something not within the actual\n+                    // range of the discriminant. Currently this function is only\n+                    // used for drop glue so in this case we just return quickly\n+                    // from the outer function, and any other use case will only\n+                    // call this for an already-valid enum in which case the `ret\n+                    // void` will never be hit.\n+                    let ret_void_cx = fcx.new_block(\"enum-iter-ret-void\");\n+                    RetVoid(ret_void_cx, DebugLoc::None);\n+                    let llswitch = Switch(cx, lldiscrim_a, ret_void_cx.llbb, n_variants);\n+                    let next_cx = fcx.new_block(\"enum-iter-next\");\n+\n+                    for variant in &en.variants {\n+                        let variant_cx = fcx.new_block(&format!(\"enum-iter-variant-{}\",\n+                                                                     &variant.disr_val\n+                                                                             .to_string()));\n+                        let case_val = adt::trans_case(cx, &repr, Disr::from(variant.disr_val));\n+                        AddCase(llswitch, case_val, variant_cx.llbb);\n+                        let variant_cx = iter_variant(variant_cx,\n+                                                      &repr,\n+                                                      value,\n+                                                      variant,\n+                                                      substs);\n+                        Br(variant_cx, next_cx.llbb, DebugLoc::None);\n+                    }\n+                    cx = next_cx;\n+                }\n+                _ => ccx.sess().unimpl(\"value from adt::trans_switch in drop_structural_ty\"),\n+            }\n+        }\n+        _ => {\n+            cx.sess().unimpl(&format!(\"type in drop_structural_ty: {}\", t))\n+        }\n+    }\n+    return cx;\n+}"}, {"sha": "8581fccf10ab53b0d2c783567a4e403ea894e60f", "filename": "src/librustc_trans/inline.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Flibrustc_trans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Flibrustc_trans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Finline.rs?ref=03e23c7f9a10b18e1687bfd92c6807e9342aa00b", "patch": "@@ -1,52 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::hir::def_id::DefId;\n-use base::push_ctxt;\n-use common::*;\n-use monomorphize::Instance;\n-\n-use rustc::dep_graph::DepNode;\n-\n-fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n-    debug!(\"instantiate_inline({:?})\", fn_id);\n-    let _icx = push_ctxt(\"instantiate_inline\");\n-    let tcx = ccx.tcx();\n-    let _task = tcx.dep_graph.in_task(DepNode::TransInlinedItem(fn_id));\n-\n-    tcx.sess\n-       .cstore\n-       .maybe_get_item_ast(tcx, fn_id)\n-       .map(|(_, inline_id)| {\n-            tcx.map.local_def_id(inline_id)\n-       })\n-}\n-\n-pub fn get_local_instance(ccx: &CrateContext, fn_id: DefId)\n-    -> Option<DefId> {\n-    if let Some(_) = ccx.tcx().map.as_local_node_id(fn_id) {\n-        Some(fn_id)\n-    } else {\n-        instantiate_inline(ccx, fn_id)\n-    }\n-}\n-\n-pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> DefId {\n-    get_local_instance(ccx, fn_id).unwrap_or(fn_id)\n-}\n-\n-pub fn maybe_inline_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                       instance: Instance<'tcx>) -> Instance<'tcx> {\n-    let def_id = maybe_instantiate_inline(ccx, instance.def);\n-    Instance {\n-        def: def_id,\n-        substs: instance.substs\n-    }\n-}"}, {"sha": "7faff98aea4425b490468d27b581cca86afdb58b", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 27, "deletions": 259, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -14,21 +14,14 @@ use arena::TypedArena;\n use intrinsics::{self, Intrinsic};\n use libc;\n use llvm;\n-use llvm::{ValueRef, TypeKind};\n-use rustc::ty::subst::Substs;\n+use llvm::{ValueRef};\n use abi::{Abi, FnType};\n use adt;\n use base::*;\n use build::*;\n-use callee::{self, Callee};\n-use cleanup;\n-use cleanup::CleanupMethods;\n use common::*;\n-use consts;\n-use datum::*;\n use debuginfo::DebugLoc;\n use declare;\n-use expr;\n use glue;\n use type_of;\n use machine;\n@@ -37,11 +30,9 @@ use rustc::ty::{self, Ty};\n use Disr;\n use rustc::hir;\n use syntax::ast;\n-use syntax::ptr::P;\n use syntax::parse::token;\n \n use rustc::session::Session;\n-use rustc_const_eval::fatal_const_eval_err;\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::cmp::Ordering;\n@@ -98,8 +89,8 @@ fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                             callee_ty: Ty<'tcx>,\n                                             fn_ty: &FnType,\n-                                            args: callee::CallArgs<'a, 'tcx>,\n-                                            dest: expr::Dest,\n+                                            llargs: &[ValueRef],\n+                                            llresult: ValueRef,\n                                             call_debug_location: DebugLoc)\n                                             -> Result<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n@@ -120,217 +111,26 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let name = tcx.item_name(def_id).as_str();\n \n     let span = match call_debug_location {\n-        DebugLoc::At(_, span) | DebugLoc::ScopeAt(_, span) => span,\n+        DebugLoc::ScopeAt(_, span) => span,\n         DebugLoc::None => {\n             span_bug!(fcx.span.unwrap_or(DUMMY_SP),\n                       \"intrinsic `{}` called with missing span\", name);\n         }\n     };\n \n-    let cleanup_scope = fcx.push_custom_cleanup_scope();\n-\n-    // For `transmute` we can just trans the input expr directly into dest\n-    if name == \"transmute\" {\n-        let llret_ty = type_of::type_of(ccx, ret_ty);\n-        match args {\n-            callee::ArgExprs(arg_exprs) => {\n-                assert_eq!(arg_exprs.len(), 1);\n-\n-                let (in_type, out_type) = (substs.types[0],\n-                                           substs.types[1]);\n-                let llintype = type_of::type_of(ccx, in_type);\n-                let llouttype = type_of::type_of(ccx, out_type);\n-\n-                let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n-                let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n-\n-                if let ty::TyFnDef(def_id, substs, _) = in_type.sty {\n-                    if out_type_size != 0 {\n-                        // FIXME #19925 Remove this hack after a release cycle.\n-                        let _ = unpack_datum!(bcx, expr::trans(bcx, &arg_exprs[0]));\n-                        let llfn = Callee::def(ccx, def_id, substs).reify(ccx).val;\n-                        let llfnty = val_ty(llfn);\n-                        let llresult = match dest {\n-                            expr::SaveIn(d) => d,\n-                            expr::Ignore => alloc_ty(bcx, out_type, \"ret\")\n-                        };\n-                        Store(bcx, llfn, PointerCast(bcx, llresult, llfnty.ptr_to()));\n-                        if dest == expr::Ignore {\n-                            bcx = glue::drop_ty(bcx, llresult, out_type,\n-                                                call_debug_location);\n-                        }\n-                        fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n-                        fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n-                        return Result::new(bcx, llresult);\n-                    }\n-                }\n-\n-                // This should be caught by the intrinsicck pass\n-                assert_eq!(in_type_size, out_type_size);\n-\n-                let nonpointer_nonaggregate = |llkind: TypeKind| -> bool {\n-                    use llvm::TypeKind::*;\n-                    match llkind {\n-                        Half | Float | Double | X86_FP80 | FP128 |\n-                            PPC_FP128 | Integer | Vector | X86_MMX => true,\n-                        _ => false\n-                    }\n-                };\n-\n-                // An approximation to which types can be directly cast via\n-                // LLVM's bitcast.  This doesn't cover pointer -> pointer casts,\n-                // but does, importantly, cover SIMD types.\n-                let in_kind = llintype.kind();\n-                let ret_kind = llret_ty.kind();\n-                let bitcast_compatible =\n-                    (nonpointer_nonaggregate(in_kind) && nonpointer_nonaggregate(ret_kind)) || {\n-                        in_kind == TypeKind::Pointer && ret_kind == TypeKind::Pointer\n-                    };\n-\n-                let dest = if bitcast_compatible {\n-                    // if we're here, the type is scalar-like (a primitive, a\n-                    // SIMD type or a pointer), and so can be handled as a\n-                    // by-value ValueRef and can also be directly bitcast to the\n-                    // target type.  Doing this special case makes conversions\n-                    // like `u32x4` -> `u64x2` much nicer for LLVM and so more\n-                    // efficient (these are done efficiently implicitly in C\n-                    // with the `__m128i` type and so this means Rust doesn't\n-                    // lose out there).\n-                    let expr = &arg_exprs[0];\n-                    let datum = unpack_datum!(bcx, expr::trans(bcx, expr));\n-                    let datum = unpack_datum!(bcx, datum.to_rvalue_datum(bcx, \"transmute_temp\"));\n-                    let val = if datum.kind.is_by_ref() {\n-                        load_ty(bcx, datum.val, datum.ty)\n-                    } else {\n-                        from_immediate(bcx, datum.val)\n-                    };\n-\n-                    let cast_val = BitCast(bcx, val, llret_ty);\n-\n-                    match dest {\n-                        expr::SaveIn(d) => {\n-                            // this often occurs in a sequence like `Store(val,\n-                            // d); val2 = Load(d)`, so disappears easily.\n-                            Store(bcx, cast_val, d);\n-                        }\n-                        expr::Ignore => {}\n-                    }\n-                    dest\n-                } else {\n-                    // The types are too complicated to do with a by-value\n-                    // bitcast, so pointer cast instead. We need to cast the\n-                    // dest so the types work out.\n-                    let dest = match dest {\n-                        expr::SaveIn(d) => expr::SaveIn(PointerCast(bcx, d, llintype.ptr_to())),\n-                        expr::Ignore => expr::Ignore\n-                    };\n-                    bcx = expr::trans_into(bcx, &arg_exprs[0], dest);\n-                    dest\n-                };\n-\n-                fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n-                fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n-\n-                return match dest {\n-                    expr::SaveIn(d) => Result::new(bcx, d),\n-                    expr::Ignore => Result::new(bcx, C_undef(llret_ty.ptr_to()))\n-                };\n-\n-            }\n-\n-            _ => {\n-                bug!(\"expected expr as argument for transmute\");\n-            }\n-        }\n-    }\n-\n-    // For `move_val_init` we can evaluate the destination address\n-    // (the first argument) and then trans the source value (the\n-    // second argument) directly into the resulting destination\n-    // address.\n-    if name == \"move_val_init\" {\n-        if let callee::ArgExprs(ref exprs) = args {\n-            let (dest_expr, source_expr) = if exprs.len() != 2 {\n-                bug!(\"expected two exprs as arguments for `move_val_init` intrinsic\");\n-            } else {\n-                (&exprs[0], &exprs[1])\n-            };\n-\n-            // evaluate destination address\n-            let dest_datum = unpack_datum!(bcx, expr::trans(bcx, dest_expr));\n-            let dest_datum = unpack_datum!(\n-                bcx, dest_datum.to_rvalue_datum(bcx, \"arg\"));\n-            let dest_datum = unpack_datum!(\n-                bcx, dest_datum.to_appropriate_datum(bcx));\n-\n-            // `expr::trans_into(bcx, expr, dest)` is equiv to\n-            //\n-            //    `trans(bcx, expr).store_to_dest(dest)`,\n-            //\n-            // which for `dest == expr::SaveIn(addr)`, is equivalent to:\n-            //\n-            //    `trans(bcx, expr).store_to(bcx, addr)`.\n-            let lldest = expr::Dest::SaveIn(dest_datum.val);\n-            bcx = expr::trans_into(bcx, source_expr, lldest);\n-\n-            let llresult = C_nil(ccx);\n-            fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n-\n-            return Result::new(bcx, llresult);\n-        } else {\n-            bug!(\"expected two exprs as arguments for `move_val_init` intrinsic\");\n-        }\n-    }\n-\n-    // save the actual AST arguments for later (some places need to do\n-    // const-evaluation on them)\n-    let expr_arguments = match args {\n-        callee::ArgExprs(args) => Some(args),\n-        _ => None,\n-    };\n-\n-    // Push the arguments.\n-    let mut llargs = Vec::new();\n-    bcx = callee::trans_args(bcx,\n-                             Abi::RustIntrinsic,\n-                             fn_ty,\n-                             &mut callee::Intrinsic,\n-                             args,\n-                             &mut llargs,\n-                             cleanup::CustomScope(cleanup_scope));\n-\n-    fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n-\n     // These are the only intrinsic functions that diverge.\n     if name == \"abort\" {\n         let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n         Call(bcx, llfn, &[], call_debug_location);\n-        fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         Unreachable(bcx);\n         return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n     } else if &name[..] == \"unreachable\" {\n-        fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         Unreachable(bcx);\n         return Result::new(bcx, C_nil(ccx));\n     }\n \n     let llret_ty = type_of::type_of(ccx, ret_ty);\n \n-    // Get location to store the result. If the user does\n-    // not care about the result, just make a stack slot\n-    let llresult = match dest {\n-        expr::SaveIn(d) => d,\n-        expr::Ignore => {\n-            if !type_is_zero_size(ccx, ret_ty) {\n-                let llresult = alloc_ty(bcx, ret_ty, \"intrinsic_result\");\n-                call_lifetime_start(bcx, llresult);\n-                llresult\n-            } else {\n-                C_undef(llret_ty.ptr_to())\n-            }\n-        }\n-    };\n-\n     let simple = get_simple_intrinsic(ccx, &name);\n     let llval = match (simple, &name[..]) {\n         (Some(llfn), _) => {\n@@ -382,16 +182,20 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"drop_in_place\") => {\n             let tp_ty = substs.types[0];\n-            let ptr = if type_is_sized(tcx, tp_ty) {\n+            let is_sized = type_is_sized(tcx, tp_ty);\n+            let ptr = if is_sized {\n                 llargs[0]\n             } else {\n-                let scratch = rvalue_scratch_datum(bcx, tp_ty, \"tmp\");\n-                Store(bcx, llargs[0], expr::get_dataptr(bcx, scratch.val));\n-                Store(bcx, llargs[1], expr::get_meta(bcx, scratch.val));\n-                fcx.schedule_lifetime_end(cleanup::CustomScope(cleanup_scope), scratch.val);\n-                scratch.val\n+                let scratch = alloc_ty(bcx, tp_ty, \"drop\");\n+                call_lifetime_start(bcx, scratch);\n+                Store(bcx, llargs[0], get_dataptr(bcx, scratch));\n+                Store(bcx, llargs[1], get_meta(bcx, scratch));\n+                scratch\n             };\n             glue::drop_ty(bcx, ptr, tp_ty, call_debug_location);\n+            if !is_sized {\n+                call_lifetime_end(bcx, ptr);\n+            }\n             C_nil(ccx)\n         }\n         (_, \"type_name\") => {\n@@ -402,13 +206,6 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"type_id\") => {\n             C_u64(ccx, ccx.tcx().type_id_hash(substs.types[0]))\n         }\n-        (_, \"init_dropped\") => {\n-            let tp_ty = substs.types[0];\n-            if !type_is_zero_size(ccx, tp_ty) {\n-                drop_done_fill_mem(bcx, llresult, tp_ty);\n-            }\n-            C_nil(ccx)\n-        }\n         (_, \"init\") => {\n             let tp_ty = substs.types[0];\n             if !type_is_zero_size(ccx, tp_ty) {\n@@ -511,8 +308,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"volatile_store\") => {\n             let tp_ty = substs.types[0];\n             if type_is_fat_ptr(bcx.tcx(), tp_ty) {\n-                VolatileStore(bcx, llargs[1], expr::get_dataptr(bcx, llargs[0]));\n-                VolatileStore(bcx, llargs[2], expr::get_meta(bcx, llargs[0]));\n+                VolatileStore(bcx, llargs[1], get_dataptr(bcx, llargs[0]));\n+                VolatileStore(bcx, llargs[2], get_meta(bcx, llargs[0]));\n             } else {\n                 let val = if fn_ty.args[1].is_indirect() {\n                     Load(bcx, llargs[1])\n@@ -621,9 +418,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, name) if name.starts_with(\"simd_\") => {\n             generic_simd_intrinsic(bcx, name,\n-                                   substs,\n                                    callee_ty,\n-                                   expr_arguments,\n                                    &llargs,\n                                    ret_ty, llret_ty,\n                                    call_debug_location,\n@@ -868,13 +663,13 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n             let llargs = if !any_changes_needed {\n                 // no aggregates to flatten, so no change needed\n-                llargs\n+                llargs.to_vec()\n             } else {\n                 // there are some aggregates that need to be flattened\n                 // in the LLVM call, so we need to run over the types\n                 // again to find them and extract the arguments\n                 intr.inputs.iter()\n-                           .zip(&llargs)\n+                           .zip(llargs)\n                            .zip(&arg_tys)\n                            .flat_map(|((t, llarg), ty)| modify_as_needed(bcx, t, ty, *llarg))\n                            .collect()\n@@ -919,17 +714,6 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    // If we made a temporary stack slot, let's clean it up\n-    match dest {\n-        expr::Ignore => {\n-            bcx = glue::drop_ty(bcx, llresult, ret_ty, call_debug_location);\n-            call_lifetime_end(bcx, llresult);\n-        }\n-        expr::SaveIn(_) => {}\n-    }\n-\n-    fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n-\n     Result::new(bcx, llresult)\n }\n \n@@ -1064,10 +848,10 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         SetPersonalityFn(bcx, bcx.fcx.eh_personality());\n \n-        let normal = bcx.fcx.new_temp_block(\"normal\");\n-        let catchswitch = bcx.fcx.new_temp_block(\"catchswitch\");\n-        let catchpad = bcx.fcx.new_temp_block(\"catchpad\");\n-        let caught = bcx.fcx.new_temp_block(\"caught\");\n+        let normal = bcx.fcx.new_block(\"normal\");\n+        let catchswitch = bcx.fcx.new_block(\"catchswitch\");\n+        let catchpad = bcx.fcx.new_block(\"catchpad\");\n+        let caught = bcx.fcx.new_block(\"caught\");\n \n         let func = llvm::get_param(bcx.fcx.llfn, 0);\n         let data = llvm::get_param(bcx.fcx.llfn, 1);\n@@ -1123,7 +907,7 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         let tcx = ccx.tcx();\n         let tydesc = match tcx.lang_items.msvc_try_filter() {\n-            Some(did) => ::consts::get_static(ccx, did).to_llref(),\n+            Some(did) => ::consts::get_static(ccx, did),\n             None => bug!(\"msvc_try_filter not defined\"),\n         };\n         let tok = CatchPad(catchpad, cs, &[tydesc, C_i32(ccx, 0), slot]);\n@@ -1184,8 +968,8 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // expected to be `*mut *mut u8` for this to actually work, but that's\n         // managed by the standard library.\n \n-        let then = bcx.fcx.new_temp_block(\"then\");\n-        let catch = bcx.fcx.new_temp_block(\"catch\");\n+        let then = bcx.fcx.new_block(\"then\");\n+        let catch = bcx.fcx.new_block(\"catch\");\n \n         let func = llvm::get_param(bcx.fcx.llfn, 0);\n         let data = llvm::get_param(bcx.fcx.llfn, 1);\n@@ -1240,8 +1024,7 @@ fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     let (fcx, block_arena);\n     block_arena = TypedArena::new();\n     fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &block_arena);\n-    let bcx = fcx.init(true, None);\n-    trans(bcx);\n+    trans(fcx.init(true));\n     fcx.cleanup();\n     llfn\n }\n@@ -1283,9 +1066,7 @@ fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n     (bcx: Block<'blk, 'tcx>,\n      name: &str,\n-     substs: &'tcx Substs<'tcx>,\n      callee_ty: Ty<'tcx>,\n-     args: Option<&[P<hir::Expr>]>,\n      llargs: &[ValueRef],\n      ret_ty: Ty<'tcx>,\n      llret_ty: Type,\n@@ -1386,20 +1167,7 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n \n         let total_len = in_len as u64 * 2;\n \n-        let vector = match args {\n-            Some(args) => {\n-                match consts::const_expr(bcx.ccx(), &args[2], substs, None,\n-                                         // this should probably help simd error reporting\n-                                         consts::TrueConst::Yes) {\n-                    Ok((vector, _)) => vector,\n-                    Err(err) => {\n-                        fatal_const_eval_err(bcx.tcx(), err.as_inner(), span,\n-                                             \"shuffle indices\");\n-                    }\n-                }\n-            }\n-            None => llargs[2]\n-        };\n+        let vector = llargs[2];\n \n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {"}, {"sha": "1286df7b97e6742582a7e6aae85a435efad5aee2", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -110,17 +110,12 @@ mod collector;\n mod common;\n mod consts;\n mod context;\n-mod controlflow;\n-mod datum;\n mod debuginfo;\n mod declare;\n mod disr;\n-mod expr;\n mod glue;\n-mod inline;\n mod intrinsic;\n mod machine;\n-mod _match;\n mod meth;\n mod mir;\n mod monomorphize;"}, {"sha": "97c77ee3d8c7270ce17660896bd38c5f6b5303b2", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -20,13 +20,12 @@ use rustc::traits::{self, Reveal};\n use abi::FnType;\n use base::*;\n use build::*;\n-use callee::{Callee, Virtual, ArgVals, trans_fn_pointer_shim};\n+use callee::{Callee, Virtual, trans_fn_pointer_shim};\n use closure;\n use common::*;\n use consts;\n use debuginfo::DebugLoc;\n use declare;\n-use expr;\n use glue;\n use machine;\n use type_::Type;\n@@ -96,25 +95,21 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n     fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &block_arena);\n-    let mut bcx = fcx.init(false, None);\n-    assert!(!fcx.needs_ret_allocas);\n+    let mut bcx = fcx.init(false);\n \n-\n-    let dest =\n-        fcx.llretslotptr.get().map(\n-            |_| expr::SaveIn(fcx.get_ret_slot(bcx, \"ret_slot\")));\n+    let dest = fcx.llretslotptr.get();\n \n     debug!(\"trans_object_shim: method_offset_in_vtable={}\",\n            vtable_index);\n \n     let llargs = get_params(fcx.llfn);\n-    let args = ArgVals(&llargs[fcx.fn_ty.ret.is_indirect() as usize..]);\n \n     let callee = Callee {\n         data: Virtual(vtable_index),\n         ty: method_ty\n     };\n-    bcx = callee.call(bcx, DebugLoc::None, args, dest).bcx;\n+    bcx = callee.call(bcx, DebugLoc::None,\n+                      &llargs[fcx.fn_ty.ret.is_indirect() as usize..], dest).bcx;\n \n     fcx.finish(bcx, DebugLoc::None);\n \n@@ -160,7 +155,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 get_vtable_methods(tcx, id, substs)\n                     .into_iter()\n                     .map(|opt_mth| opt_mth.map_or(nullptr, |mth| {\n-                        Callee::def(ccx, mth.method.def_id, &mth.substs).reify(ccx).val\n+                        Callee::def(ccx, mth.method.def_id, &mth.substs).reify(ccx)\n                     }))\n                     .collect::<Vec<_>>()\n                     .into_iter()"}, {"sha": "3ab4290e7b9b98284492cca8f107de83cc051593", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use llvm::{self, ValueRef};\n-use rustc_const_eval::ErrKind;\n+use rustc_const_eval::{ErrKind, ConstEvalErr, note_const_eval_err};\n use rustc::middle::lang_items;\n use rustc::ty;\n use rustc::mir::repr as mir;\n@@ -78,7 +78,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                         debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n                         let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", bb, target);\n-                        let trampoline = this.fcx.new_block(name, None).build();\n+                        let trampoline = this.fcx.new_block(name).build();\n                         trampoline.set_personality_fn(this.fcx.eh_personality());\n                         trampoline.cleanup_ret(cp, Some(lltarget));\n                         trampoline.llbb()\n@@ -291,7 +291,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 // Create the failure block and the conditional branch to it.\n                 let lltarget = llblock(self, target);\n-                let panic_block = self.fcx.new_block(\"panic\", None);\n+                let panic_block = self.fcx.new_block(\"panic\");\n                 if expected {\n                     bcx.cond_br(cond, lltarget, panic_block.llbb);\n                 } else {\n@@ -354,17 +354,19 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // is also constant, then we can produce a warning.\n                 if const_cond == Some(!expected) {\n                     if let Some(err) = const_err {\n-                        let _ = consts::const_err(bcx.ccx(), span,\n-                                                  Err::<(), _>(err),\n-                                                  consts::TrueConst::No);\n+                        let err = ConstEvalErr{ span: span, kind: err };\n+                        let mut diag = bcx.tcx().sess.struct_span_warn(\n+                            span, \"this expression will panic at run-time\");\n+                        note_const_eval_err(bcx.tcx(), &err, span, \"expression\", &mut diag);\n+                        diag.emit();\n                     }\n                 }\n \n                 // Obtain the panic entry point.\n                 let def_id = common::langcall(bcx.tcx(), Some(span), \"\", lang_item);\n                 let callee = Callee::def(bcx.ccx(), def_id,\n                     bcx.ccx().empty_substs_for_def_id(def_id));\n-                let llfn = callee.reify(bcx.ccx()).val;\n+                let llfn = callee.reify(bcx.ccx());\n \n                 // Translate the actual panic invoke/call.\n                 if let Some(unwind) = cleanup {\n@@ -497,28 +499,27 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let fn_ptr = match callee.data {\n                     NamedTupleConstructor(_) => {\n                         // FIXME translate this like mir::Rvalue::Aggregate.\n-                        callee.reify(bcx.ccx()).val\n+                        callee.reify(bcx.ccx())\n                     }\n                     Intrinsic => {\n-                        use callee::ArgVals;\n-                        use expr::{Ignore, SaveIn};\n                         use intrinsic::trans_intrinsic_call;\n \n                         let (dest, llargs) = match ret_dest {\n                             _ if fn_ty.ret.is_indirect() => {\n-                                (SaveIn(llargs[0]), &llargs[1..])\n+                                (llargs[0], &llargs[1..])\n+                            }\n+                            ReturnDest::Nothing => {\n+                                (C_undef(fn_ty.ret.original_ty.ptr_to()), &llargs[..])\n                             }\n-                            ReturnDest::Nothing => (Ignore, &llargs[..]),\n                             ReturnDest::IndirectOperand(dst, _) |\n-                            ReturnDest::Store(dst) => (SaveIn(dst), &llargs[..]),\n+                            ReturnDest::Store(dst) => (dst, &llargs[..]),\n                             ReturnDest::DirectOperand(_) =>\n                                 bug!(\"Cannot use direct operand with an intrinsic call\")\n                         };\n \n                         bcx.with_block(|bcx| {\n                             trans_intrinsic_call(bcx, callee.ty, &fn_ty,\n-                                                           ArgVals(llargs), dest,\n-                                                           debug_loc);\n+                                                 &llargs, dest, debug_loc);\n                         });\n \n                         if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n@@ -766,7 +767,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n         let target = self.bcx(target_bb);\n \n-        let block = self.fcx.new_block(\"cleanup\", None);\n+        let block = self.fcx.new_block(\"cleanup\");\n         self.landing_pads[target_bb] = Some(block);\n \n         let bcx = block.build();\n@@ -809,7 +810,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n     fn unreachable_block(&mut self) -> Block<'bcx, 'tcx> {\n         self.unreachable_block.unwrap_or_else(|| {\n-            let bl = self.fcx.new_block(\"unreachable\", None);\n+            let bl = self.fcx.new_block(\"unreachable\");\n             bl.build().unreachable();\n             self.unreachable_block = Some(bl);\n             bl\n@@ -878,10 +879,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             if out_type_size != 0 {\n                 // FIXME #19925 Remove this hack after a release cycle.\n                 let f = Callee::def(bcx.ccx(), def_id, substs);\n-                let datum = f.reify(bcx.ccx());\n+                let ty = match f.ty.sty {\n+                    ty::TyFnDef(_, _, f) => bcx.tcx().mk_fn_ptr(f),\n+                    _ => f.ty\n+                };\n                 val = OperandRef {\n-                    val: Immediate(datum.val),\n-                    ty: datum.ty\n+                    val: Immediate(f.reify(bcx.ccx())),\n+                    ty: ty\n                 };\n             }\n         }"}, {"sha": "1badfdba6603f1482497f1f1f21c4c47a4ceae37", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 78, "deletions": 29, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -10,10 +10,10 @@\n \n use llvm::{self, ValueRef};\n use rustc::middle::const_val::ConstVal;\n-use rustc_const_eval::ErrKind;\n+use rustc_const_eval::{ErrKind, ConstEvalErr, report_const_eval_err};\n use rustc_const_math::ConstInt::*;\n use rustc_const_math::ConstFloat::*;\n-use rustc_const_math::ConstMathErr;\n+use rustc_const_math::{ConstInt, ConstIsize, ConstUsize, ConstMathErr};\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::mir::repr as mir;\n@@ -28,12 +28,14 @@ use callee::Callee;\n use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty};\n use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral};\n use common::{C_null, C_struct, C_str_slice, C_undef, C_uint};\n-use consts::{self, ConstEvalFailure, TrueConst, to_const_int};\n+use common::{const_to_opt_int, const_to_opt_uint};\n+use consts;\n use monomorphize::{self, Instance};\n use type_of;\n use type_::Type;\n use value::Value;\n \n+use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::ptr;\n@@ -230,7 +232,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n                  mut instance: Instance<'tcx>,\n                  args: IndexVec<mir::Arg, Const<'tcx>>)\n-                 -> Result<Const<'tcx>, ConstEvalFailure> {\n+                 -> Result<Const<'tcx>, ConstEvalErr> {\n         // Try to resolve associated constants.\n         if let Some(trait_id) = ccx.tcx().trait_of_item(instance.def) {\n             let trait_ref = ty::TraitRef::new(trait_id, instance.substs);\n@@ -261,7 +263,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                          value)\n     }\n \n-    fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalFailure> {\n+    fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalErr> {\n         let tcx = self.ccx.tcx();\n         let mut bb = mir::START_BLOCK;\n \n@@ -320,10 +322,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 ErrKind::Math(err.clone())\n                             }\n                         };\n-                        match consts::const_err(self.ccx, span, Err(err), TrueConst::Yes) {\n-                            Ok(()) => {}\n-                            Err(err) => if failure.is_ok() { failure = Err(err); }\n-                        }\n+\n+                        let err = ConstEvalErr{ span: span, kind: err };\n+                        report_const_eval_err(tcx, &err, span, \"expression\").emit();\n+                        failure = Err(err);\n                     }\n                     target\n                 }\n@@ -370,7 +372,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn const_lvalue(&self, lvalue: &mir::Lvalue<'tcx>, span: Span)\n-                    -> Result<ConstLvalue<'tcx>, ConstEvalFailure> {\n+                    -> Result<ConstLvalue<'tcx>, ConstEvalErr> {\n         let tcx = self.ccx.tcx();\n \n         if let Some(index) = self.mir.local_index(lvalue) {\n@@ -386,7 +388,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             mir::Lvalue::ReturnPointer => bug!(), // handled above\n             mir::Lvalue::Static(def_id) => {\n                 ConstLvalue {\n-                    base: Base::Static(consts::get_static(self.ccx, def_id).val),\n+                    base: Base::Static(consts::get_static(self.ccx, def_id)),\n                     llextra: ptr::null_mut(),\n                     ty: lvalue.ty(self.mir, tcx).to_ty(tcx)\n                 }\n@@ -411,11 +413,18 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         } else if let ty::TyStr = projected_ty.sty {\n                             (Base::Str(base), extra)\n                         } else {\n-                            let val = consts::load_const(self.ccx, base, projected_ty);\n+                            let v = base;\n+                            let v = self.ccx.const_unsized().borrow().get(&v).map_or(v, |&v| v);\n+                            let mut val = unsafe { llvm::LLVMGetInitializer(v) };\n                             if val.is_null() {\n                                 span_bug!(span, \"dereference of non-constant pointer `{:?}`\",\n                                           Value(base));\n                             }\n+                            if projected_ty.is_bool() {\n+                                unsafe {\n+                                    val = llvm::LLVMConstTrunc(val, Type::i1(self.ccx).to_ref());\n+                                }\n+                            }\n                             (Base::Value(val), extra)\n                         }\n                     }\n@@ -462,7 +471,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn const_operand(&self, operand: &mir::Operand<'tcx>, span: Span)\n-                     -> Result<Const<'tcx>, ConstEvalFailure> {\n+                     -> Result<Const<'tcx>, ConstEvalErr> {\n         match *operand {\n             mir::Operand::Consume(ref lvalue) => {\n                 Ok(self.const_lvalue(lvalue, span)?.to_const(span))\n@@ -497,7 +506,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n     fn const_rvalue(&self, rvalue: &mir::Rvalue<'tcx>,\n                     dest_ty: Ty<'tcx>, span: Span)\n-                    -> Result<Const<'tcx>, ConstEvalFailure> {\n+                    -> Result<Const<'tcx>, ConstEvalErr> {\n         let tcx = self.ccx.tcx();\n         let val = match *rvalue {\n             mir::Rvalue::Use(ref operand) => self.const_operand(operand, span)?,\n@@ -565,7 +574,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         match operand.ty.sty {\n                             ty::TyFnDef(def_id, substs, _) => {\n                                 Callee::def(self.ccx, def_id, substs)\n-                                    .reify(self.ccx).val\n+                                    .reify(self.ccx)\n                             }\n                             _ => {\n                                 span_bug!(span, \"{} cannot be reified to a fn ptr\",\n@@ -782,6 +791,54 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n }\n \n+fn to_const_int(value: ValueRef, t: Ty, tcx: TyCtxt) -> Option<ConstInt> {\n+    match t.sty {\n+        ty::TyInt(int_type) => const_to_opt_int(value).and_then(|input| match int_type {\n+            ast::IntTy::I8 => {\n+                assert_eq!(input as i8 as i64, input);\n+                Some(ConstInt::I8(input as i8))\n+            },\n+            ast::IntTy::I16 => {\n+                assert_eq!(input as i16 as i64, input);\n+                Some(ConstInt::I16(input as i16))\n+            },\n+            ast::IntTy::I32 => {\n+                assert_eq!(input as i32 as i64, input);\n+                Some(ConstInt::I32(input as i32))\n+            },\n+            ast::IntTy::I64 => {\n+                Some(ConstInt::I64(input))\n+            },\n+            ast::IntTy::Is => {\n+                ConstIsize::new(input, tcx.sess.target.int_type)\n+                    .ok().map(ConstInt::Isize)\n+            },\n+        }),\n+        ty::TyUint(uint_type) => const_to_opt_uint(value).and_then(|input| match uint_type {\n+            ast::UintTy::U8 => {\n+                assert_eq!(input as u8 as u64, input);\n+                Some(ConstInt::U8(input as u8))\n+            },\n+            ast::UintTy::U16 => {\n+                assert_eq!(input as u16 as u64, input);\n+                Some(ConstInt::U16(input as u16))\n+            },\n+            ast::UintTy::U32 => {\n+                assert_eq!(input as u32 as u64, input);\n+                Some(ConstInt::U32(input as u32))\n+            },\n+            ast::UintTy::U64 => {\n+                Some(ConstInt::U64(input))\n+            },\n+            ast::UintTy::Us => {\n+                ConstUsize::new(input, tcx.sess.target.uint_type)\n+                    .ok().map(ConstInt::Usize)\n+            },\n+        }),\n+        _ => None,\n+    }\n+}\n+\n pub fn const_scalar_binop(op: mir::BinOp,\n                           lhs: ValueRef,\n                           rhs: ValueRef,\n@@ -902,25 +959,17 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n         };\n \n-        match result {\n-            Ok(v) => v,\n-            Err(ConstEvalFailure::Compiletime(_)) => {\n-                // We've errored, so we don't have to produce working code.\n-                let llty = type_of::type_of(bcx.ccx(), ty);\n-                Const::new(C_undef(llty), ty)\n-            }\n-            Err(ConstEvalFailure::Runtime(err)) => {\n-                span_bug!(constant.span,\n-                          \"MIR constant {:?} results in runtime panic: {:?}\",\n-                          constant, err.description())\n-            }\n-        }\n+        result.unwrap_or_else(|_| {\n+            // We've errored, so we don't have to produce working code.\n+            let llty = type_of::type_of(bcx.ccx(), ty);\n+            Const::new(C_undef(llty), ty)\n+        })\n     }\n }\n \n \n pub fn trans_static_initializer(ccx: &CrateContext, def_id: DefId)\n-                                -> Result<ValueRef, ConstEvalFailure> {\n+                                -> Result<ValueRef, ConstEvalErr> {\n     let instance = Instance::mono(ccx.shared(), def_id);\n     MirConstContext::trans_def(ccx, instance, IndexVec::new()).map(|c| c.llval)\n }"}, {"sha": "5e180887a36043c3f14feab5639d6f52392ad8fc", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -109,7 +109,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Lvalue::ReturnPointer => bug!(), // handled above\n             mir::Lvalue::Static(def_id) => {\n                 let const_ty = self.monomorphized_lvalue_ty(lvalue);\n-                LvalueRef::new_sized(consts::get_static(ccx, def_id).val,\n+                LvalueRef::new_sized(consts::get_static(ccx, def_id),\n                                      LvalueTy::from_ty(const_ty))\n             },\n             mir::Lvalue::Projection(box mir::Projection {"}, {"sha": "474b2552e70796ce4ae6d89624ff1c87b9ac1d91", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -145,7 +145,7 @@ impl<'tcx> LocalRef<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n \n pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n-    let bcx = fcx.init(false, None).build();\n+    let bcx = fcx.init(true).build();\n     let mir = bcx.mir();\n \n     // Analyze the temps to determine which must be lvalues\n@@ -207,9 +207,9 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     let block_bcxs: IndexVec<mir::BasicBlock, Block<'blk,'tcx>> =\n         mir.basic_blocks().indices().map(|bb| {\n             if bb == mir::START_BLOCK {\n-                fcx.new_block(\"start\", None)\n+                fcx.new_block(\"start\")\n             } else {\n-                fcx.new_block(&format!(\"{:?}\", bb), None)\n+                fcx.new_block(&format!(\"{:?}\", bb))\n             }\n         }).collect();\n "}, {"sha": "13484cb7a4ece286527df91b0bdc17313cf523d9", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -17,7 +17,6 @@ use asm;\n use base;\n use callee::Callee;\n use common::{self, val_ty, C_bool, C_null, C_uint, BlockAndBuilder, Result};\n-use datum::{Datum, Lvalue};\n use debuginfo::DebugLoc;\n use adt;\n use machine;\n@@ -101,7 +100,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let size = C_uint(bcx.ccx(), size);\n                 let base = get_dataptr(&bcx, dest.llval);\n                 let bcx = bcx.map_block(|block| {\n-                    tvec::iter_vec_raw(block, base, tr_elem.ty, size, |block, llslot, _| {\n+                    tvec::slice_for_each(block, base, tr_elem.ty, size, |block, llslot| {\n                         self.store_operand_direct(block, llslot, tr_elem);\n                         block\n                     })\n@@ -157,8 +156,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Rvalue::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 let outputs = outputs.iter().map(|output| {\n                     let lvalue = self.trans_lvalue(&bcx, output);\n-                    Datum::new(lvalue.llval, lvalue.ty.to_ty(bcx.tcx()),\n-                               Lvalue::new(\"out\"))\n+                    (lvalue.llval, lvalue.ty.to_ty(bcx.tcx()))\n                 }).collect();\n \n                 let input_vals = inputs.iter().map(|input| {\n@@ -202,7 +200,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             ty::TyFnDef(def_id, substs, _) => {\n                                 OperandValue::Immediate(\n                                     Callee::def(bcx.ccx(), def_id, substs)\n-                                        .reify(bcx.ccx()).val)\n+                                        .reify(bcx.ccx()))\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be reified to a fn ptr\", operand.ty)"}, {"sha": "020ac8d643b86df29e82959ef6a4e4062158a36f", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 149, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,162 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::ValueRef;\n-use llvm;\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n-use attributes;\n-use base::{push_ctxt};\n-use base;\n+use rustc::ty::{self, Ty, TyCtxt};\n use common::*;\n-use declare;\n-use Disr;\n-use rustc::hir::map as hir_map;\n use rustc::util::ppaux;\n \n-use rustc::hir;\n-\n-use errors;\n-\n use std::fmt;\n-use trans_item::TransItem;\n-\n-pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                fn_id: DefId,\n-                                psubsts: &'tcx Substs<'tcx>)\n-                                -> (ValueRef, Ty<'tcx>) {\n-    debug!(\"monomorphic_fn(fn_id={:?}, real_substs={:?})\", fn_id, psubsts);\n-    assert!(!psubsts.types.needs_infer() && !psubsts.types.has_param_types());\n-\n-    let _icx = push_ctxt(\"monomorphic_fn\");\n-\n-    let instance = Instance::new(fn_id, psubsts);\n-\n-    let item_ty = ccx.tcx().lookup_item_type(fn_id).ty;\n-\n-    debug!(\"monomorphic_fn about to subst into {:?}\", item_ty);\n-    let mono_ty = apply_param_substs(ccx.tcx(), psubsts, &item_ty);\n-    debug!(\"mono_ty = {:?} (post-substitution)\", mono_ty);\n-\n-    if let Some(&val) = ccx.instances().borrow().get(&instance) {\n-        debug!(\"leaving monomorphic fn {:?}\", instance);\n-        return (val, mono_ty);\n-    } else {\n-        assert!(!ccx.codegen_unit().contains_item(&TransItem::Fn(instance)));\n-    }\n-\n-    debug!(\"monomorphic_fn({:?})\", instance);\n-\n-    ccx.stats().n_monos.set(ccx.stats().n_monos.get() + 1);\n-\n-    let depth;\n-    {\n-        let mut monomorphizing = ccx.monomorphizing().borrow_mut();\n-        depth = match monomorphizing.get(&fn_id) {\n-            Some(&d) => d, None => 0\n-        };\n-\n-        debug!(\"monomorphic_fn: depth for fn_id={:?} is {:?}\", fn_id, depth+1);\n-\n-        // Random cut-off -- code that needs to instantiate the same function\n-        // recursively more than thirty times can probably safely be assumed\n-        // to be causing an infinite expansion.\n-        if depth > ccx.sess().recursion_limit.get() {\n-            let error = format!(\"reached the recursion limit while instantiating `{}`\",\n-                                instance);\n-            if let Some(id) = ccx.tcx().map.as_local_node_id(fn_id) {\n-                ccx.sess().span_fatal(ccx.tcx().map.span(id), &error);\n-            } else {\n-                ccx.sess().fatal(&error);\n-            }\n-        }\n-\n-        monomorphizing.insert(fn_id, depth + 1);\n-    }\n-\n-    let symbol = ccx.symbol_map().get_or_compute(ccx.shared(),\n-                                                 TransItem::Fn(instance));\n-\n-    debug!(\"monomorphize_fn mangled to {}\", &symbol);\n-    assert!(declare::get_defined_value(ccx, &symbol).is_none());\n-\n-    // FIXME(nagisa): perhaps needs a more fine grained selection?\n-    let lldecl = declare::define_internal_fn(ccx, &symbol, mono_ty);\n-    // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n-    attributes::unwind(lldecl, true);\n-\n-    ccx.instances().borrow_mut().insert(instance, lldecl);\n-\n-    // we can only monomorphize things in this crate (or inlined into it)\n-    let fn_node_id = ccx.tcx().map.as_local_node_id(fn_id).unwrap();\n-    let map_node = errors::expect(\n-        ccx.sess().diagnostic(),\n-        ccx.tcx().map.find(fn_node_id),\n-        || {\n-            format!(\"while instantiating `{}`, couldn't find it in \\\n-                     the item map (may have attempted to monomorphize \\\n-                     an item defined in a different crate?)\",\n-                    instance)\n-        });\n-    match map_node {\n-        hir_map::NodeItem(&hir::Item {\n-            ref attrs,\n-            node: hir::ItemFn(..), ..\n-        }) |\n-        hir_map::NodeImplItem(&hir::ImplItem {\n-            ref attrs, node: hir::ImplItemKind::Method(\n-                hir::MethodSig { .. }, _), ..\n-        }) |\n-        hir_map::NodeTraitItem(&hir::TraitItem {\n-            ref attrs, node: hir::MethodTraitItem(\n-                hir::MethodSig { .. }, Some(_)), ..\n-        }) => {\n-            let trans_item = TransItem::Fn(instance);\n-\n-            if ccx.shared().translation_items().borrow().contains(&trans_item) {\n-                attributes::from_fn_attrs(ccx, attrs, lldecl);\n-                unsafe {\n-                    llvm::LLVMSetLinkage(lldecl, llvm::ExternalLinkage);\n-                }\n-            } else {\n-                // FIXME: #34151\n-                // Normally, getting here would indicate a bug in trans::collector,\n-                // since it seems to have missed a translation item. When we are\n-                // translating with non-MIR based trans, however, the results of\n-                // the collector are not entirely reliable since it bases its\n-                // analysis on MIR. Thus, we'll instantiate the missing function\n-                // privately in this codegen unit, so that things keep working.\n-                ccx.stats().n_fallback_instantiations.set(ccx.stats()\n-                                                             .n_fallback_instantiations\n-                                                             .get() + 1);\n-                trans_item.predefine(ccx, llvm::InternalLinkage);\n-                trans_item.define(ccx);\n-            }\n-        }\n-\n-        hir_map::NodeVariant(_) | hir_map::NodeStructCtor(_) => {\n-            let disr = match map_node {\n-                hir_map::NodeVariant(_) => {\n-                    Disr::from(inlined_variant_def(ccx, fn_node_id).disr_val)\n-                }\n-                hir_map::NodeStructCtor(_) => Disr(0),\n-                _ => bug!()\n-            };\n-            attributes::inline(lldecl, attributes::InlineAttr::Hint);\n-            attributes::set_frame_pointer_elimination(ccx, lldecl);\n-            base::trans_ctor_shim(ccx, fn_node_id, disr, psubsts, lldecl);\n-        }\n-\n-        _ => bug!(\"can't monomorphize a {:?}\", map_node)\n-    };\n-\n-    ccx.monomorphizing().borrow_mut().insert(fn_id, depth);\n-\n-    debug!(\"leaving monomorphic fn {}\", ccx.tcx().item_path_str(fn_id));\n-    (lldecl, mono_ty)\n-}\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Instance<'tcx> {"}, {"sha": "90dcc3a61fd7ebda35f10c6bff6c5d29032612a7", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 22, "deletions": 53, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -22,17 +22,15 @@ use declare;\n use glue::DropGlueKind;\n use llvm;\n use monomorphize::{self, Instance};\n-use inline;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n-use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst::Substs;\n use rustc_const_eval::fatal_const_eval_err;\n use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n-use syntax::{attr,errors};\n+use syntax::attr;\n use type_of;\n use glue;\n use abi::{Abi, FnType};\n@@ -88,13 +86,13 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                 let def_id = ccx.tcx().map.local_def_id(node_id);\n                 let _task = ccx.tcx().dep_graph.in_task(DepNode::TransCrateItem(def_id)); // (*)\n                 let item = ccx.tcx().map.expect_item(node_id);\n-                if let hir::ItemStatic(_, m, ref expr) = item.node {\n-                    match consts::trans_static(&ccx, m, expr, item.id, &item.attrs) {\n+                if let hir::ItemStatic(_, m, _) = item.node {\n+                    match consts::trans_static(&ccx, m, item.id, &item.attrs) {\n                         Ok(_) => { /* Cool, everything's alright. */ },\n                         Err(err) => {\n                             // FIXME: shouldn't this be a `span_err`?\n                             fatal_const_eval_err(\n-                                ccx.tcx(), &err, expr.span, \"static\");\n+                                ccx.tcx(), &err, item.span, \"static\");\n                         }\n                     };\n                 } else {\n@@ -157,20 +155,16 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         let ty = ccx.tcx().lookup_item_type(def_id).ty;\n         let llty = type_of::type_of(ccx, ty);\n \n-        match ccx.tcx().map.get(node_id) {\n-            hir::map::NodeItem(&hir::Item {\n-                span, node: hir::ItemStatic(..), ..\n-            }) => {\n-                let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n-                    ccx.sess().span_fatal(span,\n-                        &format!(\"symbol `{}` is already defined\", symbol_name))\n-                });\n+        let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n+            ccx.sess().span_fatal(ccx.tcx().map.span(node_id),\n+                &format!(\"symbol `{}` is already defined\", symbol_name))\n+        });\n \n-                unsafe { llvm::LLVMSetLinkage(g, linkage) };\n-            }\n+        unsafe { llvm::LLVMSetLinkage(g, linkage) };\n \n-            item => bug!(\"predefine_static: expected static, found {:?}\", item)\n-        }\n+        let instance = Instance::mono(ccx.shared(), def_id);\n+        ccx.instances().borrow_mut().insert(instance, g);\n+        ccx.statics().borrow_mut().insert(g, def_id);\n     }\n \n     fn predefine_fn(ccx: &CrateContext<'a, 'tcx>,\n@@ -180,47 +174,22 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         assert!(!instance.substs.types.needs_infer() &&\n                 !instance.substs.types.has_param_types());\n \n-        let instance = inline::maybe_inline_instance(ccx, instance);\n-\n         let item_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n         let item_ty = ccx.tcx().erase_regions(&item_ty);\n         let mono_ty = monomorphize::apply_param_substs(ccx.tcx(), instance.substs, &item_ty);\n \n-        let fn_node_id = ccx.tcx().map.as_local_node_id(instance.def).unwrap();\n-        let map_node = errors::expect(\n-            ccx.sess().diagnostic(),\n-            ccx.tcx().map.find(fn_node_id),\n-            || {\n-                format!(\"while instantiating `{}`, couldn't find it in \\\n-                     the item map (may have attempted to monomorphize \\\n-                     an item defined in a different crate?)\",\n-                    instance)\n-            });\n-\n-        match map_node {\n-            hir_map::NodeItem(&hir::Item {\n-                ref attrs, node: hir::ItemFn(..), ..\n-            }) |\n-            hir_map::NodeTraitItem(&hir::TraitItem {\n-                ref attrs, node: hir::MethodTraitItem(..), ..\n-            }) |\n-            hir_map::NodeImplItem(&hir::ImplItem {\n-                ref attrs, node: hir::ImplItemKind::Method(..), ..\n-            }) => {\n-                let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n-                unsafe { llvm::LLVMSetLinkage(lldecl, linkage) };\n-                base::set_link_section(ccx, lldecl, attrs);\n-                if linkage == llvm::LinkOnceODRLinkage ||\n-                   linkage == llvm::WeakODRLinkage {\n-                    llvm::SetUniqueComdat(ccx.llmod(), lldecl);\n-                }\n+        let attrs = ccx.tcx().get_attrs(instance.def);\n+        let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n+        unsafe { llvm::LLVMSetLinkage(lldecl, linkage) };\n+        base::set_link_section(ccx, lldecl, &attrs);\n+        if linkage == llvm::LinkOnceODRLinkage ||\n+            linkage == llvm::WeakODRLinkage {\n+            llvm::SetUniqueComdat(ccx.llmod(), lldecl);\n+        }\n \n-                attributes::from_fn_attrs(ccx, attrs, lldecl);\n-                ccx.instances().borrow_mut().insert(instance, lldecl);\n-            }\n-            _ => bug!(\"Invalid item for TransItem::Fn: `{:?}`\", map_node)\n-        };\n+        attributes::from_fn_attrs(ccx, &attrs, lldecl);\n \n+        ccx.instances().borrow_mut().insert(instance, lldecl);\n     }\n \n     fn predefine_drop_glue(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "7e4719870cd83a426f458c65d5c680971c7d9bc7", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 33, "deletions": 365, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -13,383 +13,51 @@\n use llvm;\n use llvm::ValueRef;\n use base::*;\n-use base;\n use build::*;\n-use cleanup;\n-use cleanup::CleanupMethods;\n use common::*;\n-use consts;\n-use datum::*;\n use debuginfo::DebugLoc;\n-use expr::{Dest, Ignore, SaveIn};\n-use expr;\n-use machine::llsize_of_alloc;\n-use type_::Type;\n-use type_of;\n-use value::Value;\n-use rustc::ty::{self, Ty};\n-\n-use rustc::hir;\n-use rustc_const_eval::eval_length;\n-\n-use syntax::ast;\n-use syntax::parse::token::InternedString;\n-\n-#[derive(Copy, Clone, Debug)]\n-struct VecTypes<'tcx> {\n-    unit_ty: Ty<'tcx>,\n-    llunit_ty: Type\n-}\n-\n-pub fn trans_fixed_vstore<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                      expr: &hir::Expr,\n-                                      dest: expr::Dest)\n-                                      -> Block<'blk, 'tcx> {\n-    //!\n-    //\n-    // [...] allocates a fixed-size array and moves it around \"by value\".\n-    // In this case, it means that the caller has already given us a location\n-    // to store the array of the suitable size, so all we have to do is\n-    // generate the content.\n-\n-    debug!(\"trans_fixed_vstore(expr={:?}, dest={:?})\", expr, dest);\n-\n-    let vt = vec_types_from_expr(bcx, expr);\n-\n-    return match dest {\n-        Ignore => write_content(bcx, &vt, expr, expr, dest),\n-        SaveIn(lldest) => {\n-            // lldest will have type *[T x N], but we want the type *T,\n-            // so use GEP to convert:\n-            let lldest = StructGEP(bcx, lldest, 0);\n-            write_content(bcx, &vt, expr, expr, SaveIn(lldest))\n-        }\n-    };\n-}\n-\n-/// &[...] allocates memory on the stack and writes the values into it, returning the vector (the\n-/// caller must make the reference).  \"...\" is similar except that the memory can be statically\n-/// allocated and we return a reference (strings are always by-ref).\n-pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   slice_expr: &hir::Expr,\n-                                   content_expr: &hir::Expr)\n-                                   -> DatumBlock<'blk, 'tcx, Expr> {\n+use rustc::ty::Ty;\n+\n+pub fn slice_for_each<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                                     data_ptr: ValueRef,\n+                                     unit_ty: Ty<'tcx>,\n+                                     len: ValueRef,\n+                                     f: F)\n+                                     -> Block<'blk, 'tcx> where\n+    F: FnOnce(Block<'blk, 'tcx>, ValueRef) -> Block<'blk, 'tcx>,\n+{\n+    let _icx = push_ctxt(\"tvec::slice_for_each\");\n     let fcx = bcx.fcx;\n-    let mut bcx = bcx;\n-\n-    debug!(\"trans_slice_vec(slice_expr={:?})\",\n-           slice_expr);\n-\n-    let vec_ty = node_id_type(bcx, slice_expr.id);\n-\n-    // Handle the \"...\" case (returns a slice since strings are always unsized):\n-    if let hir::ExprLit(ref lit) = content_expr.node {\n-        if let ast::LitKind::Str(ref s, _) = lit.node {\n-            let scratch = rvalue_scratch_datum(bcx, vec_ty, \"\");\n-            bcx = trans_lit_str(bcx,\n-                                content_expr,\n-                                s.clone(),\n-                                SaveIn(scratch.val));\n-            return DatumBlock::new(bcx, scratch.to_expr_datum());\n-        }\n-    }\n-\n-    // Handle the &[...] case:\n-    let vt = vec_types_from_expr(bcx, content_expr);\n-    let count = elements_required(bcx, content_expr);\n-    debug!(\"    vt={:?}, count={}\", vt, count);\n \n-    let fixed_ty = bcx.tcx().mk_array(vt.unit_ty, count);\n-\n-    // Always create an alloca even if zero-sized, to preserve\n-    // the non-null invariant of the inner slice ptr\n-    let llfixed;\n-    // Issue 30018: ensure state is initialized as dropped if necessary.\n-    if fcx.type_needs_drop(vt.unit_ty) {\n-        llfixed = base::alloc_ty_init(bcx, fixed_ty, InitAlloca::Dropped, \"\");\n+    // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n+    let zst = type_is_zero_size(bcx.ccx(), unit_ty);\n+    let add = |bcx, a, b| if zst {\n+        Add(bcx, a, b, DebugLoc::None)\n     } else {\n-        let uninit = InitAlloca::Uninit(\"fcx says vt.unit_ty is non-drop\");\n-        llfixed = base::alloc_ty_init(bcx, fixed_ty, uninit, \"\");\n-        call_lifetime_start(bcx, llfixed);\n-    };\n-\n-    if count > 0 {\n-        // Arrange for the backing array to be cleaned up.\n-        let cleanup_scope = cleanup::temporary_scope(bcx.tcx(), content_expr.id);\n-        fcx.schedule_lifetime_end(cleanup_scope, llfixed);\n-        fcx.schedule_drop_mem(cleanup_scope, llfixed, fixed_ty, None);\n-\n-        // Generate the content into the backing array.\n-        // llfixed has type *[T x N], but we want the type *T,\n-        // so use GEP to convert\n-        bcx = write_content(bcx, &vt, slice_expr, content_expr,\n-                            SaveIn(StructGEP(bcx, llfixed, 0)));\n+        InBoundsGEP(bcx, a, &[b])\n     };\n \n-    immediate_rvalue_bcx(bcx, llfixed, vec_ty).to_expr_datumblock()\n-}\n-\n-/// Literal strings translate to slices into static memory.  This is different from\n-/// trans_slice_vstore() above because it doesn't need to copy the content anywhere.\n-pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 lit_expr: &hir::Expr,\n-                                 str_lit: InternedString,\n-                                 dest: Dest)\n-                                 -> Block<'blk, 'tcx> {\n-    debug!(\"trans_lit_str(lit_expr={:?}, dest={:?})\", lit_expr, dest);\n-\n-    match dest {\n-        Ignore => bcx,\n-        SaveIn(lldest) => {\n-            let bytes = str_lit.len();\n-            let llbytes = C_uint(bcx.ccx(), bytes);\n-            let llcstr = C_cstr(bcx.ccx(), str_lit, false);\n-            let llcstr = consts::ptrcast(llcstr, Type::i8p(bcx.ccx()));\n-            Store(bcx, llcstr, expr::get_dataptr(bcx, lldest));\n-            Store(bcx, llbytes, expr::get_meta(bcx, lldest));\n-            bcx\n-        }\n-    }\n-}\n-\n-fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             vt: &VecTypes<'tcx>,\n-                             vstore_expr: &hir::Expr,\n-                             content_expr: &hir::Expr,\n-                             dest: Dest)\n-                             -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"tvec::write_content\");\n-    let fcx = bcx.fcx;\n-    let mut bcx = bcx;\n-\n-    debug!(\"write_content(vt={:?}, dest={:?}, vstore_expr={:?})\",\n-           vt, dest, vstore_expr);\n-\n-    match content_expr.node {\n-        hir::ExprLit(ref lit) => {\n-            match lit.node {\n-                ast::LitKind::Str(ref s, _) => {\n-                    match dest {\n-                        Ignore => return bcx,\n-                        SaveIn(lldest) => {\n-                            let bytes = s.len();\n-                            let llbytes = C_uint(bcx.ccx(), bytes);\n-                            let llcstr = C_cstr(bcx.ccx(), (*s).clone(), false);\n-                            if !bcx.unreachable.get() {\n-                                base::call_memcpy(&B(bcx), lldest, llcstr, llbytes, 1);\n-                            }\n-                            return bcx;\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    span_bug!(content_expr.span, \"unexpected evec content\");\n-                }\n-            }\n-        }\n-        hir::ExprVec(ref elements) => {\n-            match dest {\n-                Ignore => {\n-                    for element in elements {\n-                        bcx = expr::trans_into(bcx, &element, Ignore);\n-                    }\n-                }\n-\n-                SaveIn(lldest) => {\n-                    let temp_scope = fcx.push_custom_cleanup_scope();\n-                    for (i, element) in elements.iter().enumerate() {\n-                        let lleltptr = GEPi(bcx, lldest, &[i]);\n-                        debug!(\"writing index {} with lleltptr={:?}\",\n-                               i, Value(lleltptr));\n-                        bcx = expr::trans_into(bcx, &element,\n-                                               SaveIn(lleltptr));\n-                        let scope = cleanup::CustomScope(temp_scope);\n-                        // Issue #30822: mark memory as dropped after running destructor\n-                        fcx.schedule_drop_and_fill_mem(scope, lleltptr, vt.unit_ty, None);\n-                    }\n-                    fcx.pop_custom_cleanup_scope(temp_scope);\n-                }\n-            }\n-            return bcx;\n-        }\n-        hir::ExprRepeat(ref element, ref count_expr) => {\n-            match dest {\n-                Ignore => {\n-                    return expr::trans_into(bcx, &element, Ignore);\n-                }\n-                SaveIn(lldest) => {\n-                    match eval_length(bcx.tcx(), &count_expr, \"repeat count\").unwrap() {\n-                        0 => expr::trans_into(bcx, &element, Ignore),\n-                        1 => expr::trans_into(bcx, &element, SaveIn(lldest)),\n-                        count => {\n-                            let elem = unpack_datum!(bcx, expr::trans(bcx, &element));\n-                            let bcx = iter_vec_loop(bcx, lldest, vt,\n-                                                    C_uint(bcx.ccx(), count),\n-                                                    |set_bcx, lleltptr, _| {\n-                                                        elem.shallow_copy(set_bcx, lleltptr)\n-                                                    });\n-                            bcx\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        _ => {\n-            span_bug!(content_expr.span, \"unexpected vec content\");\n-        }\n-    }\n-}\n-\n-fn vec_types_from_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, vec_expr: &hir::Expr)\n-                                   -> VecTypes<'tcx> {\n-    let vec_ty = node_id_type(bcx, vec_expr.id);\n-    vec_types(bcx, vec_ty.sequence_element_type(bcx.tcx()))\n-}\n-\n-fn vec_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, unit_ty: Ty<'tcx>)\n-                         -> VecTypes<'tcx> {\n-    VecTypes {\n-        unit_ty: unit_ty,\n-        llunit_ty: type_of::type_of(bcx.ccx(), unit_ty)\n-    }\n-}\n-\n-fn elements_required(bcx: Block, content_expr: &hir::Expr) -> usize {\n-    //! Figure out the number of elements we need to store this content\n-\n-    match content_expr.node {\n-        hir::ExprLit(ref lit) => {\n-            match lit.node {\n-                ast::LitKind::Str(ref s, _) => s.len(),\n-                _ => {\n-                    span_bug!(content_expr.span, \"unexpected evec content\")\n-                }\n-            }\n-        },\n-        hir::ExprVec(ref es) => es.len(),\n-        hir::ExprRepeat(_, ref count_expr) => {\n-            eval_length(bcx.tcx(), &count_expr, \"repeat count\").unwrap()\n-        }\n-        _ => span_bug!(content_expr.span, \"unexpected vec content\")\n-    }\n-}\n-\n-/// Converts a fixed-length vector into the slice pair. The vector should be stored in `llval`\n-/// which should be by ref.\n-pub fn get_fixed_base_and_len(bcx: Block,\n-                              llval: ValueRef,\n-                              vec_length: usize)\n-                              -> (ValueRef, ValueRef) {\n-    let ccx = bcx.ccx();\n-\n-    let base = expr::get_dataptr(bcx, llval);\n-    let len = C_uint(ccx, vec_length);\n-    (base, len)\n-}\n-\n-/// Converts a vector into the slice pair.  The vector should be stored in `llval` which should be\n-/// by-reference.  If you have a datum, you would probably prefer to call\n-/// `Datum::get_base_and_len()` which will handle any conversions for you.\n-pub fn get_base_and_len<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    llval: ValueRef,\n-                                    vec_ty: Ty<'tcx>)\n-                                    -> (ValueRef, ValueRef) {\n-    match vec_ty.sty {\n-        ty::TyArray(_, n) => get_fixed_base_and_len(bcx, llval, n),\n-        ty::TySlice(_) | ty::TyStr => {\n-            let base = Load(bcx, expr::get_dataptr(bcx, llval));\n-            let len = Load(bcx, expr::get_meta(bcx, llval));\n-            (base, len)\n-        }\n-\n-        // Only used for pattern matching.\n-        ty::TyBox(ty) | ty::TyRef(_, ty::TypeAndMut{ty, ..}) => {\n-            let inner = if type_is_sized(bcx.tcx(), ty) {\n-                Load(bcx, llval)\n-            } else {\n-                llval\n-            };\n-            get_base_and_len(bcx, inner, ty)\n-        },\n-        _ => bug!(\"unexpected type in get_base_and_len\"),\n-    }\n-}\n+    let header_bcx = fcx.new_block(\"slice_loop_header\");\n+    let body_bcx = fcx.new_block(\"slice_loop_body\");\n+    let next_bcx = fcx.new_block(\"slice_loop_next\");\n \n-fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                data_ptr: ValueRef,\n-                                vt: &VecTypes<'tcx>,\n-                                count: ValueRef,\n-                                f: F)\n-                                -> Block<'blk, 'tcx> where\n-    F: FnOnce(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n-{\n-    let _icx = push_ctxt(\"tvec::iter_vec_loop\");\n-\n-    if bcx.unreachable.get() {\n-        return bcx;\n-    }\n-\n-    let fcx = bcx.fcx;\n-    let loop_bcx = fcx.new_temp_block(\"expr_repeat\");\n-    let next_bcx = fcx.new_temp_block(\"expr_repeat: next\");\n-\n-    Br(bcx, loop_bcx.llbb, DebugLoc::None);\n-\n-    let loop_counter = Phi(loop_bcx, bcx.ccx().int_type(),\n-                           &[C_uint(bcx.ccx(), 0 as usize)], &[bcx.llbb]);\n-\n-    let bcx = loop_bcx;\n-\n-    let lleltptr = if llsize_of_alloc(bcx.ccx(), vt.llunit_ty) == 0 {\n-        data_ptr\n+    let start = if zst {\n+        C_uint(bcx.ccx(), 0 as usize)\n     } else {\n-        InBoundsGEP(bcx, data_ptr, &[loop_counter])\n+        data_ptr\n     };\n-    let bcx = f(bcx, lleltptr, vt.unit_ty);\n-    let plusone = Add(bcx, loop_counter, C_uint(bcx.ccx(), 1usize), DebugLoc::None);\n-    AddIncomingToPhi(loop_counter, plusone, bcx.llbb);\n+    let end = add(bcx, start, len);\n \n-    let cond_val = ICmp(bcx, llvm::IntULT, plusone, count, DebugLoc::None);\n-    CondBr(bcx, cond_val, loop_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n+    Br(bcx, header_bcx.llbb, DebugLoc::None);\n+    let current = Phi(header_bcx, val_ty(start), &[start], &[bcx.llbb]);\n \n-    next_bcx\n-}\n+    let keep_going =\n+        ICmp(header_bcx, llvm::IntULT, current, end, DebugLoc::None);\n+    CondBr(header_bcx, keep_going, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n \n-pub fn iter_vec_raw<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                   data_ptr: ValueRef,\n-                                   unit_ty: Ty<'tcx>,\n-                                   len: ValueRef,\n-                                   f: F)\n-                                   -> Block<'blk, 'tcx> where\n-    F: FnOnce(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n-{\n-    let _icx = push_ctxt(\"tvec::iter_vec_raw\");\n-    let fcx = bcx.fcx;\n-\n-    let vt = vec_types(bcx, unit_ty);\n-\n-    if llsize_of_alloc(bcx.ccx(), vt.llunit_ty) == 0 {\n-        // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n-        iter_vec_loop(bcx, data_ptr, &vt, len, f)\n-    } else {\n-        // Calculate the last pointer address we want to handle.\n-        let data_end_ptr = InBoundsGEP(bcx, data_ptr, &[len]);\n-\n-        // Now perform the iteration.\n-        let header_bcx = fcx.new_temp_block(\"iter_vec_loop_header\");\n-        Br(bcx, header_bcx.llbb, DebugLoc::None);\n-        let data_ptr =\n-            Phi(header_bcx, val_ty(data_ptr), &[data_ptr], &[bcx.llbb]);\n-        let not_yet_at_end =\n-            ICmp(header_bcx, llvm::IntULT, data_ptr, data_end_ptr, DebugLoc::None);\n-        let body_bcx = fcx.new_temp_block(\"iter_vec_loop_body\");\n-        let next_bcx = fcx.new_temp_block(\"iter_vec_next\");\n-        CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n-        let body_bcx = f(body_bcx, data_ptr, unit_ty);\n-        AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n-                                               &[C_int(bcx.ccx(), 1)]),\n-                         body_bcx.llbb);\n-        Br(body_bcx, header_bcx.llbb, DebugLoc::None);\n-        next_bcx\n-    }\n+    let body_bcx = f(body_bcx, if zst { data_ptr } else { current });\n+    let next = add(body_bcx, current, C_uint(bcx.ccx(), 1usize));\n+    AddIncomingToPhi(current, next, body_bcx.llbb);\n+    Br(body_bcx, header_bcx.llbb, DebugLoc::None);\n+    next_bcx\n }"}, {"sha": "7f9e715b7fafc634798dc1090f7b238ef6c9e99c", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -122,7 +122,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                  ], ccx.tcx.types.usize)\n             }\n             \"rustc_peek\" => (1, vec![param(ccx, 0)], param(ccx, 0)),\n-            \"init\" | \"init_dropped\" => (1, Vec::new(), param(ccx, 0)),\n+            \"init\" => (1, Vec::new(), param(ccx, 0)),\n             \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n             \"forget\" => (1, vec!( param(ccx, 0) ), tcx.mk_nil()),\n             \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),"}, {"sha": "8f02c9c7d3de0334ca6403101bc4fc0c525c1a26", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -59,7 +59,7 @@ const EMPTY_BUCKET: u64 = 0;\n /// around just the \"table\" part of the hashtable. It enforces some\n /// invariants at the type level and employs some performance trickery,\n /// but in general is just a tricked out `Vec<Option<u64, K, V>>`.\n-#[unsafe_no_drop_flag]\n+#[cfg_attr(stage0, unsafe_no_drop_flag)]\n pub struct RawTable<K, V> {\n     capacity: usize,\n     size: usize,\n@@ -1042,7 +1042,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n impl<K, V> Drop for RawTable<K, V> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n-        if self.capacity == 0 || self.capacity == mem::POST_DROP_USIZE {\n+        if self.capacity == 0 {\n             return;\n         }\n "}, {"sha": "2b15f3dd9455c5c5cadd9b8faef1195a1ea9ad27", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -275,7 +275,7 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unique)]\n-#![feature(unsafe_no_drop_flag, filling_drop)]\n+#![cfg_attr(stage0, feature(unsafe_no_drop_flag))]\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]\n #![feature(zero_one)]"}, {"sha": "d746f8e21141f4001d3e7823c4561474f68a8803", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -164,10 +164,6 @@ declare_features! (\n     // Allows using `box` in patterns; RFC 469\n     (active, box_patterns, \"1.0.0\", Some(29641)),\n \n-    // Allows using the unsafe_no_drop_flag attribute (unlikely to\n-    // switch to Accepted; see RFC 320)\n-    (active, unsafe_no_drop_flag, \"1.0.0\", None),\n-\n     // Allows using the unsafe_destructor_blind_to_params attribute;\n     // RFC 1238\n     (active, dropck_parametricity, \"1.3.0\", Some(28498)),\n@@ -300,7 +296,8 @@ declare_features! (\n     (removed, quad_precision_float, \"1.0.0\", None),\n     (removed, struct_inherit, \"1.0.0\", None),\n     (removed, test_removed_feature, \"1.0.0\", None),\n-    (removed, visible_private_types, \"1.0.0\", None)\n+    (removed, visible_private_types, \"1.0.0\", None),\n+    (removed, unsafe_no_drop_flag, \"1.0.0\", None)\n );\n \n declare_features! (\n@@ -517,11 +514,6 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                       is just used for rustc unit tests \\\n                                       and will never be stable\",\n                                      cfg_fn!(rustc_attrs))),\n-    (\"rustc_no_mir\", Whitelisted, Gated(\"rustc_attrs\",\n-                                        \"the `#[rustc_no_mir]` attribute \\\n-                                         is just used to make tests pass \\\n-                                         and will never be stable\",\n-                                        cfg_fn!(rustc_attrs))),\n     (\"rustc_inherit_overflow_checks\", Whitelisted, Gated(\"rustc_attrs\",\n                                                          \"the `#[rustc_inherit_overflow_checks]` \\\n                                                           attribute is just used to control \\\n@@ -570,10 +562,6 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                                         attribute is just used for the Rust test \\\n                                                         suite\",\n                                                        cfg_fn!(omit_gdb_pretty_printer_section))),\n-    (\"unsafe_no_drop_flag\", Whitelisted, Gated(\"unsafe_no_drop_flag\",\n-                                               \"unsafe_no_drop_flag has unstable semantics \\\n-                                                and may be removed in the future\",\n-                                               cfg_fn!(unsafe_no_drop_flag))),\n     (\"unsafe_destructor_blind_to_params\",\n      Normal,\n      Gated(\"dropck_parametricity\","}, {"sha": "65bc9f34c9061ed55d5074cc5d4024d647b62b4f", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -26,7 +26,6 @@\n \n #![feature(associated_consts)]\n #![feature(const_fn)]\n-#![feature(filling_drop)]\n #![feature(libc)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "c3f8a977a659b572a63dc14be1aba96cd6e36975", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -39,7 +39,7 @@\n use std::fmt::{self, Display, Debug};\n use std::iter::FromIterator;\n use std::ops::Deref;\n-use std::{ptr, slice, vec};\n+use std::{mem, ptr, slice, vec};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -74,12 +74,22 @@ impl<T: 'static> P<T> {\n     pub fn map<F>(mut self, f: F) -> P<T> where\n         F: FnOnce(T) -> T,\n     {\n+        let p: *mut T = &mut *self.ptr;\n+\n+        // Leak self in case of panic.\n+        // FIXME(eddyb) Use some sort of \"free guard\" that\n+        // only deallocates, without dropping the pointee,\n+        // in case the call the `f` below ends in a panic.\n+        mem::forget(self);\n+\n         unsafe {\n-            let p = &mut *self.ptr;\n-            // FIXME(#5016) this shouldn't need to drop-fill to be safe.\n-            ptr::write(p, f(ptr::read_and_drop(p)));\n+            ptr::write(p, f(ptr::read(p)));\n+\n+            // Recreate self from the raw pointer.\n+            P {\n+                ptr: Box::from_raw(p)\n+            }\n         }\n-        self\n     }\n }\n "}, {"sha": "40603845da2b00b0d60e651bd57aad369719a805", "filename": "src/test/codegen/adjustments.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Fadjustments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Fadjustments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fadjustments.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -11,7 +11,6 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n-#![feature(rustc_attrs)]\n \n // Hack to get the correct size for the length part in slices\n // CHECK: @helper([[USIZE:i[0-9]+]])\n@@ -21,13 +20,12 @@ fn helper(_: usize) {\n \n // CHECK-LABEL: @no_op_slice_adjustment\n #[no_mangle]\n-#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn no_op_slice_adjustment(x: &[u8]) -> &[u8] {\n     // We used to generate an extra alloca and memcpy for the block's trailing expression value, so\n     // check that we copy directly to the return value slot\n-// CHECK: [[SRC:%[0-9]+]] = bitcast { i8*, [[USIZE]] }* %x to\n-// CHECK: [[DST:%[0-9]+]] = bitcast { i8*, [[USIZE]] }* %sret_slot to i8*\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* [[DST]], i8* [[SRC]],\n+// CHECK: %2 = insertvalue { i8*, [[USIZE]] } undef, i8* %0, 0\n+// CHECK: %3 = insertvalue { i8*, [[USIZE]] } %2, [[USIZE]] %1, 1\n+// CHECK: ret { i8*, [[USIZE]] } %3\n     { x }\n }\n "}, {"sha": "c8c9f5b407c421b11458d6b6c514f54ac64afbaf", "filename": "src/test/codegen/coercions.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Fcoercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Fcoercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoercions.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -11,22 +11,19 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n-#![feature(rustc_attrs)]\n \n static X: i32 = 5;\n \n // CHECK-LABEL: @raw_ptr_to_raw_ptr_noop\n // CHECK-NOT: alloca\n #[no_mangle]\n-#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn raw_ptr_to_raw_ptr_noop() -> *const i32{\n     &X as *const i32\n }\n \n // CHECK-LABEL: @reference_to_raw_ptr_noop\n // CHECK-NOT: alloca\n #[no_mangle]\n-#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn reference_to_raw_ptr_noop() -> *const i32 {\n     &X\n }"}, {"sha": "36a582ca73709bb35b3e9ad14ecd96ab9743ef1b", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -11,7 +11,6 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n-#![feature(rustc_attrs)]\n \n // Below, these constants are defined as enum variants that by itself would\n // have a lower alignment than the enum type. Ensure that we mark them\n@@ -20,11 +19,12 @@\n // CHECK: @STATIC = {{.*}}, align 4\n \n // This checks the constants from inline_enum_const\n-// CHECK: @const{{[0-9]+}} = {{.*}}, align 2\n+// CHECK: @ref{{[0-9]+}} = {{.*}}, align 2\n \n // This checks the constants from {low,high}_align_const, they share the same\n // constant, but the alignment differs, so the higher one should be used\n-// CHECK: @const{{[0-9]+}} = {{.*}}, align 4\n+// CHECK: [[LOW_HIGH:@ref[0-9]+]] = {{.*}}, align 4\n+// CHECK: [[LOW_HIGH_REF:@const[0-9]+]] = {{.*}} [[LOW_HIGH]]\n \n #[derive(Copy, Clone)]\n \n@@ -40,32 +40,28 @@ pub static STATIC: E<i16, i32> = E::A(0);\n \n // CHECK-LABEL: @static_enum_const\n #[no_mangle]\n-#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn static_enum_const() -> E<i16, i32> {\n    STATIC\n }\n \n // CHECK-LABEL: @inline_enum_const\n #[no_mangle]\n-#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn inline_enum_const() -> E<i8, i16> {\n-    E::A(0)\n+    *&E::A(0)\n }\n \n // CHECK-LABEL: @low_align_const\n #[no_mangle]\n-#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn low_align_const() -> E<i16, [i16; 3]> {\n // Check that low_align_const and high_align_const use the same constant\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{[0-9]+}}, i8* {{.*}} [[LOW_HIGH:@const[0-9]+]]\n-    E::A(0)\n+// CHECK: load {{.*}} bitcast ({ i16, i16, [4 x i8] }** [[LOW_HIGH_REF]]\n+    *&E::A(0)\n }\n \n // CHECK-LABEL: @high_align_const\n #[no_mangle]\n-#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn high_align_const() -> E<i16, i32> {\n // Check that low_align_const and high_align_const use the same constant\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{[0-9]}}, i8* {{.*}} [[LOW_HIGH]]\n-    E::A(0)\n+// CHECK: load {{.*}} bitcast ({ i16, i16, [4 x i8] }** [[LOW_HIGH_REF]]\n+    *&E::A(0)\n }"}, {"sha": "a4bd5cf2c158e3d3dcd6de4a36ede21ce28cb5d3", "filename": "src/test/codegen/drop.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdrop.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -11,7 +11,6 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n-#![feature(rustc_attrs)]\n \n struct SomeUniqueName;\n \n@@ -25,19 +24,20 @@ pub fn possibly_unwinding() {\n \n // CHECK-LABEL: @droppy\n #[no_mangle]\n-#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn droppy() {\n // Check that there are exactly 6 drop calls. The cleanups for the unwinding should be reused, so\n // that's one new drop call per call to possibly_unwinding(), and finally 3 drop calls for the\n // regular function exit. We used to have problems with quadratic growths of drop calls in such\n // functions.\n-// CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n-// CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n-// CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n+// CHECK-NOT: invoke{{.*}}drop{{.*}}SomeUniqueName\n // CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n // CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n // CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n // CHECK-NOT: call{{.*}}drop{{.*}}SomeUniqueName\n+// CHECK: invoke{{.*}}drop{{.*}}SomeUniqueName\n+// CHECK: invoke{{.*}}drop{{.*}}SomeUniqueName\n+// CHECK: invoke{{.*}}drop{{.*}}SomeUniqueName\n+// CHECK-NOT: {{(call|invoke).*}}drop{{.*}}SomeUniqueName\n // The next line checks for the } that ends the function definition\n // CHECK-LABEL: {{^[}]}}\n     let _s = SomeUniqueName;"}, {"sha": "def5269e07a02b1c345a897e5677c65ba9fa9276", "filename": "src/test/codegen/loads.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Floads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Floads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Floads.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -11,7 +11,6 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n-#![feature(rustc_attrs)]\n \n pub struct Bytes {\n   a: u8,\n@@ -22,15 +21,14 @@ pub struct Bytes {\n \n // CHECK-LABEL: @borrow\n #[no_mangle]\n-#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn borrow(x: &i32) -> &i32 {\n // CHECK: load {{(i32\\*, )?}}i32** %x{{.*}}, !nonnull\n+    &x; // keep variable in an alloca\n     x\n }\n \n // CHECK-LABEL: @_box\n #[no_mangle]\n-#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn _box(x: Box<i32>) -> i32 {\n // CHECK: load {{(i32\\*, )?}}i32** %x{{.*}}, !nonnull\n     *x"}, {"sha": "a2cedc853a1e6dbf6a41beb9fce51950a096733b", "filename": "src/test/codegen/mir_zst_stores.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Fmir_zst_stores.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Fmir_zst_stores.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmir_zst_stores.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -10,7 +10,6 @@\n \n // compile-flags: -C no-prepopulate-passes\n \n-#![feature(rustc_attrs)]\n #![crate_type = \"lib\"]\n use std::marker::PhantomData;\n \n@@ -19,7 +18,6 @@ struct Zst { phantom: PhantomData<Zst> }\n \n // CHECK-LABEL: @mir\n #[no_mangle]\n-#[rustc_mir]\n fn mir(){\n     // CHECK-NOT: getelementptr\n     // CHECK-NOT: store{{.*}}undef"}, {"sha": "9de74f72005e359a20f35cf2d8a5fcbaa2532cbd", "filename": "src/test/codegen/naked-functions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Fnaked-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Fnaked-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnaked-functions.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -13,7 +13,7 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n-#![feature(naked_functions, rustc_attrs)]\n+#![feature(naked_functions)]\n \n // CHECK: Function Attrs: naked uwtable\n // CHECK-NEXT: define internal void @naked_empty()\n@@ -26,11 +26,11 @@ fn naked_empty() {\n // CHECK: Function Attrs: naked uwtable\n #[no_mangle]\n #[naked]\n-#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n // CHECK-NEXT: define internal void @naked_with_args(i{{[0-9]+}})\n fn naked_with_args(a: isize) {\n     // CHECK: %a = alloca i{{[0-9]+}}\n     // CHECK: ret void\n+    &a; // keep variable in an alloca\n }\n \n // CHECK: Function Attrs: naked uwtable\n@@ -46,10 +46,10 @@ fn naked_with_return() -> isize {\n // CHECK-NEXT: define internal i{{[0-9]+}} @naked_with_args_and_return(i{{[0-9]+}})\n #[no_mangle]\n #[naked]\n-#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n fn naked_with_args_and_return(a: isize) -> isize {\n     // CHECK: %a = alloca i{{[0-9]+}}\n     // CHECK: ret i{{[0-9]+}} %{{[0-9]+}}\n+    &a; // keep variable in an alloca\n     a\n }\n "}, {"sha": "49ed2229fcd2b721bcb865a468a718095d10515b", "filename": "src/test/codegen/refs.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Frefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Frefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frefs.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -11,7 +11,6 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n-#![feature(rustc_attrs)]\n \n // Hack to get the correct size for the length part in slices\n // CHECK: @helper([[USIZE:i[0-9]+]])\n@@ -21,12 +20,14 @@ fn helper(_: usize) {\n \n // CHECK-LABEL: @ref_dst\n #[no_mangle]\n-#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn ref_dst(s: &[u8]) {\n     // We used to generate an extra alloca and memcpy to ref the dst, so check that we copy\n     // directly to the alloca for \"x\"\n-// CHECK: [[SRC:%[0-9]+]] = bitcast { i8*, [[USIZE]] }* %s to i8*\n-// CHECK: [[DST:%[0-9]+]] = bitcast { i8*, [[USIZE]] }* %x to i8*\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* [[DST]], i8* [[SRC]],\n+// CHECK: [[X0:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %x, i32 0, i32 0\n+// CHECK: store i8* %0, i8** [[X0]]\n+// CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %x, i32 0, i32 1\n+// CHECK: store [[USIZE]] %1, [[USIZE]]* [[X1]]\n+\n     let x = &*s;\n+    &x; // keep variable in an alloca\n }"}, {"sha": "9141b7245e35aa0d89465e01ce1b9ef887522cec", "filename": "src/test/codegen/stores.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Fstores.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Fcodegen%2Fstores.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstores.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -11,7 +11,6 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n-#![feature(rustc_attrs)]\n \n pub struct Bytes {\n   a: u8,\n@@ -24,12 +23,11 @@ pub struct Bytes {\n // The array is stored as i32, but its alignment is lower, go with 1 byte to avoid target\n // dependent alignment\n #[no_mangle]\n-#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn small_array_alignment(x: &mut [i8; 4], y: [i8; 4]) {\n-// CHECK: %y = alloca [4 x i8]\n+// CHECK: %arg1 = alloca [4 x i8]\n // CHECK: [[TMP:%.+]] = alloca i32\n // CHECK: store i32 %1, i32* [[TMP]]\n-// CHECK: [[Y8:%[0-9]+]] = bitcast [4 x i8]* %y to i8*\n+// CHECK: [[Y8:%[0-9]+]] = bitcast [4 x i8]* %arg1 to i8*\n // CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*\n // CHECK: call void @llvm.memcpy.{{.*}}(i8* [[Y8]], i8* [[TMP8]], i{{[0-9]+}} 4, i32 1, i1 false)\n     *x = y;\n@@ -39,12 +37,11 @@ pub fn small_array_alignment(x: &mut [i8; 4], y: [i8; 4]) {\n // The struct is stored as i32, but its alignment is lower, go with 1 byte to avoid target\n // dependent alignment\n #[no_mangle]\n-#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn small_struct_alignment(x: &mut Bytes, y: Bytes) {\n-// CHECK: %y = alloca %Bytes\n+// CHECK: %arg1 = alloca %Bytes\n // CHECK: [[TMP:%.+]] = alloca i32\n // CHECK: store i32 %1, i32* [[TMP]]\n-// CHECK: [[Y8:%[0-9]+]] = bitcast %Bytes* %y to i8*\n+// CHECK: [[Y8:%[0-9]+]] = bitcast %Bytes* %arg1 to i8*\n // CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*\n // CHECK: call void @llvm.memcpy.{{.*}}(i8* [[Y8]], i8* [[TMP8]], i{{[0-9]+}} 4, i32 1, i1 false)\n     *x = y;"}, {"sha": "eec6bad731e33aeda2be019e80ed30138a5162db", "filename": "src/test/compile-fail/enable-orbit-for-incr-comp.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Ftest%2Fcompile-fail%2Fenable-orbit-for-incr-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Ftest%2Fcompile-fail%2Fenable-orbit-for-incr-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenable-orbit-for-incr-comp.rs?ref=03e23c7f9a10b18e1687bfd92c6807e9342aa00b", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-pretty\n-// compile-flags:-Zincremental=tmp/cfail-tests/enable-orbit-for-incr-comp -Zorbit=off\n-// error-pattern:Automatically enabling `-Z orbit` because `-Z incremental` was specified\n-\n-#![deny(warnings)]\n-\n-fn main() {\n-    FAIL! // We just need some compilation error. What we really care about is\n-          // that the error pattern above is checked.\n-}"}, {"sha": "91e5065517dcc9c4acb776d019a12da69ba20768", "filename": "src/test/compile-fail/lint-no-drop-on-repr-extern.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Ftest%2Fcompile-fail%2Flint-no-drop-on-repr-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Ftest%2Fcompile-fail%2Flint-no-drop-on-repr-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-no-drop-on-repr-extern.rs?ref=03e23c7f9a10b18e1687bfd92c6807e9342aa00b", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Check we reject structs that mix a `Drop` impl with `#[repr(C)]`.\n-//\n-// As a special case, also check that we do not warn on such structs\n-// if they also are declared with `#[unsafe_no_drop_flag]`\n-\n-#![feature(unsafe_no_drop_flag)]\n-#![deny(drop_with_repr_extern)]\n-//~^ NOTE lint level defined here\n-//~| NOTE lint level defined here\n-\n-#[repr(C)] struct As { x: Box<i8> }\n-#[repr(C)] enum Ae { Ae(Box<i8>), _None }\n-\n-struct Bs { x: Box<i8> }\n-enum Be { Be(Box<i8>), _None }\n-\n-#[repr(C)] struct Cs { x: Box<i8> }\n-//~^ NOTE the `#[repr(C)]` attribute is attached here\n-\n-impl Drop for Cs { fn drop(&mut self) { } }\n-//~^ ERROR implementing Drop adds hidden state to types, possibly conflicting with `#[repr(C)]`\n-\n-#[repr(C)] enum Ce { Ce(Box<i8>), _None }\n-//~^ NOTE the `#[repr(C)]` attribute is attached here\n-\n-impl Drop for Ce { fn drop(&mut self) { } }\n-//~^ ERROR implementing Drop adds hidden state to types, possibly conflicting with `#[repr(C)]`\n-\n-#[unsafe_no_drop_flag]\n-#[repr(C)] struct Ds { x: Box<i8> }\n-\n-impl Drop for Ds { fn drop(&mut self) { } }\n-\n-#[unsafe_no_drop_flag]\n-#[repr(C)] enum De { De(Box<i8>), _None }\n-\n-impl Drop for De { fn drop(&mut self) { } }\n-\n-fn main() {\n-    let a = As { x: Box::new(3) };\n-    let b = Bs { x: Box::new(3) };\n-    let c = Cs { x: Box::new(3) };\n-    let d = Ds { x: Box::new(3) };\n-\n-    println!(\"{:?}\", (*a.x, *b.x, *c.x, *d.x));\n-\n-    let _a = Ae::Ae(Box::new(3));\n-    let _b = Be::Be(Box::new(3));\n-    let _c = Ce::Ce(Box::new(3));\n-    let _d = De::De(Box::new(3));\n-}"}, {"sha": "542698fd15295f13260cacc029234fabda8f4cd1", "filename": "src/test/compile-fail/unsafe_no_drop_flag-gate.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Ftest%2Fcompile-fail%2Funsafe_no_drop_flag-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Ftest%2Fcompile-fail%2Funsafe_no_drop_flag-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe_no_drop_flag-gate.rs?ref=03e23c7f9a10b18e1687bfd92c6807e9342aa00b", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub struct T;\n-\n-#[unsafe_no_drop_flag]\n-//~^ ERROR unsafe_no_drop_flag has unstable semantics and may be removed\n-pub struct S {\n-    pub x: T,\n-}\n-\n-impl Drop for S {\n-    fn drop(&mut self) {}\n-}\n-\n-pub fn main() {}"}, {"sha": "7bd9adcba9bd1eebd3ef3fceb2d73d1f3237860d", "filename": "src/test/run-fail/issue-30380.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fissue-30380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fissue-30380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-30380.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n // check that panics in destructors during assignment do not leave\n // destroyed values lying around for other destructors to observe.\n \n@@ -35,7 +33,6 @@ impl<'a> Drop for Observer<'a> {\n     }\n }\n \n-#[rustc_mir]\n fn foo(b: &mut Observer) {\n     *b.0 = FilledOnDrop(1);\n }"}, {"sha": "98311525ad0f26b77a61c473654fdd7996b82bb3", "filename": "src/test/run-fail/mir_drop_panics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_drop_panics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_drop_panics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_drop_panics.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -7,7 +7,6 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(rustc_attrs)]\n \n // error-pattern:panic 1\n // error-pattern:drop 2\n@@ -24,7 +23,6 @@ impl Drop for Droppable {\n     }\n }\n \n-#[rustc_mir]\n fn mir() {\n     let x = Droppable(2);\n     let y = Droppable(1);"}, {"sha": "6cf2851d93d472b664a1e6999e74b9c963252cdd", "filename": "src/test/run-fail/mir_dynamic_drops_1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_1.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -7,7 +7,6 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(rustc_attrs)]\n // error-pattern:drop 1\n // error-pattern:drop 2\n use std::io::{self, Write};\n@@ -26,7 +25,6 @@ impl<'a> Drop for Droppable<'a> {\n     }\n }\n \n-#[rustc_mir]\n fn mir() {\n     let (mut xv, mut yv) = (false, false);\n     let x = Droppable(&mut xv, 1);"}, {"sha": "7a90298e4225323ab81633d0796bb61b68db9fc1", "filename": "src/test/run-fail/mir_dynamic_drops_2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_2.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(rustc_attrs)]\n+\n // error-pattern:drop 1\n use std::io::{self, Write};\n \n@@ -25,7 +25,6 @@ impl<'a> Drop for Droppable<'a> {\n     }\n }\n \n-#[rustc_mir]\n fn mir<'a>(d: Droppable<'a>) {\n     loop {\n         let x = d;"}, {"sha": "79ecbbb35bc56cc7f2082bc73759d9577c5c2cbf", "filename": "src/test/run-fail/mir_dynamic_drops_3.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_3.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(rustc_attrs)]\n+\n // error-pattern:unwind happens\n // error-pattern:drop 3\n // error-pattern:drop 2\n@@ -32,7 +32,6 @@ fn may_panic<'a>() -> Droppable<'a> {\n     panic!(\"unwind happens\");\n }\n \n-#[rustc_mir]\n fn mir<'a>(d: Droppable<'a>) {\n     let (mut a, mut b) = (false, false);\n     let y = Droppable(&mut a, 2);"}, {"sha": "41ff466f810ea262d8cd9237e50b0f7172c4e9ac", "filename": "src/test/run-fail/mir_indexing_oob_1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_1.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -9,11 +9,9 @@\n // except according to those terms.\n \n // error-pattern:index out of bounds: the len is 5 but the index is 10\n-#![feature(rustc_attrs)]\n \n const C: [u32; 5] = [0; 5];\n \n-#[rustc_mir]\n fn test() -> u32 {\n     C[10]\n }"}, {"sha": "c5c823428bc94edfcf26095d60614c990252e7f1", "filename": "src/test/run-fail/mir_indexing_oob_2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_2.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -9,11 +9,9 @@\n // except according to those terms.\n \n // error-pattern:index out of bounds: the len is 5 but the index is 10\n-#![feature(rustc_attrs)]\n \n const C: &'static [u8; 5] = b\"hello\";\n \n-#[rustc_mir]\n fn test() -> u8 {\n     C[10]\n }"}, {"sha": "9bc4b0025e55ad46f604fddd34a0438430a48d85", "filename": "src/test/run-fail/mir_indexing_oob_3.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_indexing_oob_3.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -9,11 +9,9 @@\n // except according to those terms.\n \n // error-pattern:index out of bounds: the len is 5 but the index is 10\n-#![feature(rustc_attrs)]\n \n const C: &'static [u8; 5] = b\"hello\";\n \n-#[rustc_mir]\n fn mir() -> u8 {\n     C[10]\n }"}, {"sha": "7a7526c5fc1d37d220ab8c8d6aa98cbd8602b03e", "filename": "src/test/run-fail/mir_trans_calls_converging_drops.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n // error-pattern:converging_fn called\n // error-pattern:0 dropped\n // error-pattern:exit\n@@ -27,7 +25,6 @@ fn converging_fn() {\n     write!(io::stderr(), \"converging_fn called\\n\");\n }\n \n-#[rustc_mir]\n fn mir(d: Droppable) {\n     converging_fn();\n }"}, {"sha": "1301630cc85ea64b52ff3653fd8256e4d792c792", "filename": "src/test/run-fail/mir_trans_calls_converging_drops_2.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops_2.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n // error-pattern:complex called\n // error-pattern:dropped\n // error-pattern:exit\n@@ -30,7 +28,6 @@ fn complex() -> u64 {\n }\n \n \n-#[rustc_mir]\n fn mir() -> u64 {\n     let x = Droppable;\n     return complex();"}, {"sha": "9dbf7de0d2d4988d6a9dc0e5c01641107a3b66e2", "filename": "src/test/run-fail/mir_trans_calls_diverging.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_trans_calls_diverging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_trans_calls_diverging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_trans_calls_diverging.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -7,14 +7,13 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(rustc_attrs)]\n+\n // error-pattern:diverging_fn called\n \n fn diverging_fn() -> ! {\n     panic!(\"diverging_fn called\")\n }\n \n-#[rustc_mir]\n fn mir() {\n     diverging_fn();\n }"}, {"sha": "c191870492969628b96bcc86bf39c1254b6bbdd1", "filename": "src/test/run-fail/mir_trans_calls_diverging_drops.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_trans_calls_diverging_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_trans_calls_diverging_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_trans_calls_diverging_drops.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n // error-pattern:diverging_fn called\n // error-pattern:0 dropped\n \n@@ -26,7 +24,6 @@ fn diverging_fn() -> ! {\n     panic!(\"diverging_fn called\")\n }\n \n-#[rustc_mir]\n fn mir(d: Droppable) {\n     diverging_fn();\n }"}, {"sha": "dacb039d89dc5c0e6694b84a65899ca152ca08a4", "filename": "src/test/run-fail/mir_trans_no_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_trans_no_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_trans_no_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_trans_no_landing_pads.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(rustc_attrs)]\n+\n // compile-flags: -Z no-landing-pads\n // error-pattern:converging_fn called\n use std::io::{self, Write};\n@@ -23,7 +23,6 @@ fn converging_fn() {\n     panic!(\"converging_fn called\")\n }\n \n-#[rustc_mir]\n fn mir(d: Droppable) {\n     let x = Droppable;\n     converging_fn();"}, {"sha": "87037c1efed9e02e3db69003f8e6f72f3189fa13", "filename": "src/test/run-fail/mir_trans_no_landing_pads_diverging.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_trans_no_landing_pads_diverging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-fail%2Fmir_trans_no_landing_pads_diverging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_trans_no_landing_pads_diverging.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(rustc_attrs)]\n+\n // compile-flags: -Z no-landing-pads\n // error-pattern:diverging_fn called\n use std::io::{self, Write};\n@@ -23,7 +23,6 @@ fn diverging_fn() -> ! {\n     panic!(\"diverging_fn called\")\n }\n \n-#[rustc_mir]\n fn mir(d: Droppable) {\n     let x = Droppable;\n     diverging_fn();"}, {"sha": "8ac4bf9733757cc25a1af1da68c0d3b9d14f8300", "filename": "src/test/run-pass-fulldeps/mir-pass.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass-fulldeps%2Fmir-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass-fulldeps%2Fmir-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmir-pass.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -11,10 +11,9 @@\n // aux-build:dummy_mir_pass.rs\n // ignore-stage1\n \n-#![feature(plugin, rustc_attrs)]\n+#![feature(plugin)]\n #![plugin(dummy_mir_pass)]\n \n-#[rustc_mir]\n fn math() -> i32 {\n     11\n }"}, {"sha": "7cf75924a28c0c7fd67bcb941694986bdeeda972", "filename": "src/test/run-pass-valgrind/cast-enum-with-dtor.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -13,7 +13,7 @@\n // no-prefer-dynamic\n \n #![allow(dead_code)]\n-#![feature(const_fn, rustc_attrs)]\n+#![feature(const_fn)]\n \n // check dtor calling order when casting enums.\n \n@@ -38,13 +38,12 @@ impl Drop for E {\n     }\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR miscompiles this.\n fn main() {\n     assert_eq!(FLAG.load(Ordering::SeqCst), 0);\n     {\n         let e = E::C;\n         assert_eq!(e as u32, 2);\n         assert_eq!(FLAG.load(Ordering::SeqCst), 0);\n     }\n-    assert_eq!(FLAG.load(Ordering::SeqCst), 1);\n+    assert_eq!(FLAG.load(Ordering::SeqCst), 0);\n }"}, {"sha": "ed42ad6e875273237792d9c3b799007d09ab3699", "filename": "src/test/run-pass/auxiliary/issue-10028.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-10028.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-10028.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-10028.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unsafe_no_drop_flag)]\n-\n-#[unsafe_no_drop_flag]\n pub struct ZeroLengthThingWithDestructor;\n impl Drop for ZeroLengthThingWithDestructor {\n     fn drop(&mut self) {}"}, {"sha": "a8014768d78470c14b7196c26d3410a031ba66a1", "filename": "src/test/run-pass/drop-flag-sanity-check.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Ftest%2Frun-pass%2Fdrop-flag-sanity-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Ftest%2Frun-pass%2Fdrop-flag-sanity-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-flag-sanity-check.rs?ref=03e23c7f9a10b18e1687bfd92c6807e9342aa00b", "patch": "@@ -1,68 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z force-dropflag-checks=on\n-// ignore-emscripten\n-\n-// Quick-and-dirty test to ensure -Z force-dropflag-checks=on works as\n-// expected. Note that the inlined drop-flag is slated for removal\n-// (RFC 320); when that happens, the -Z flag and this test should\n-// simply be removed.\n-//\n-// See also drop-flag-skip-sanity-check.rs.\n-\n-use std::env;\n-use std::process::Command;\n-\n-fn main() {\n-    let args: Vec<String> = env::args().collect();\n-    if args.len() > 1 && args[1] == \"test\" {\n-        return test();\n-    }\n-\n-    let mut p = Command::new(&args[0]).arg(\"test\").spawn().unwrap();\n-    // The invocation should fail due to the drop-flag sanity check.\n-    assert!(!p.wait().unwrap().success());\n-}\n-\n-#[derive(Debug)]\n-struct Corrupted {\n-    x: u8\n-}\n-\n-impl Drop for Corrupted {\n-    fn drop(&mut self) { println!(\"dropping\"); }\n-}\n-\n-fn test() {\n-    {\n-        let mut c1 = Corrupted { x: 1 };\n-        let mut c2 = Corrupted { x: 2 };\n-        unsafe {\n-            let p1 = &mut c1 as *mut Corrupted as *mut u8;\n-            let p2 = &mut c2 as *mut Corrupted as *mut u8;\n-            for i in 0..std::mem::size_of::<Corrupted>() {\n-                // corrupt everything, *including the drop flag.\n-                //\n-                // (We corrupt via two different means to safeguard\n-                // against the hypothetical assignment of the\n-                // dtor_needed/dtor_done values to v and v+k.  that\n-                // happen to match with one of the corruption values\n-                // below.)\n-                *p1.offset(i as isize) += 2;\n-                *p2.offset(i as isize) += 3;\n-            }\n-        }\n-        // Here, at the end of the scope of `c1` and `c2`, the\n-        // drop-glue should detect the corruption of (at least one of)\n-        // the drop-flags.\n-    }\n-    println!(\"We should never get here.\");\n-}"}, {"sha": "07a10c8d45443892151490ea3b7e50d315ac427b", "filename": "src/test/run-pass/drop-flag-skip-sanity-check.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Ftest%2Frun-pass%2Fdrop-flag-skip-sanity-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Ftest%2Frun-pass%2Fdrop-flag-skip-sanity-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-flag-skip-sanity-check.rs?ref=03e23c7f9a10b18e1687bfd92c6807e9342aa00b", "patch": "@@ -1,67 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z force-dropflag-checks=off\n-// ignore-emscripten no threads support\n-\n-// Quick-and-dirty test to ensure -Z force-dropflag-checks=off works as\n-// expected. Note that the inlined drop-flag is slated for removal\n-// (RFC 320); when that happens, the -Z flag and this test should\n-// simply be removed.\n-//\n-// See also drop-flag-sanity-check.rs.\n-\n-use std::env;\n-use std::process::Command;\n-\n-fn main() {\n-    let args: Vec<String> = env::args().collect();\n-    if args.len() > 1 && args[1] == \"test\" {\n-        return test();\n-    }\n-\n-    let s = Command::new(&args[0]).arg(\"test\").status().unwrap();\n-    // Invocatinn should succeed as drop-flag sanity check is skipped.\n-    assert!(s.success());\n-}\n-\n-#[derive(Debug)]\n-struct Corrupted {\n-    x: u8\n-}\n-\n-impl Drop for Corrupted {\n-    fn drop(&mut self) { println!(\"dropping\"); }\n-}\n-\n-fn test() {\n-    {\n-        let mut c1 = Corrupted { x: 1 };\n-        let mut c2 = Corrupted { x: 2 };\n-        unsafe {\n-            let p1 = &mut c1 as *mut Corrupted as *mut u8;\n-            let p2 = &mut c2 as *mut Corrupted as *mut u8;\n-            for i in 0..std::mem::size_of::<Corrupted>() {\n-                // corrupt everything, *including the drop flag.\n-                //\n-                // (We corrupt via two different means to safeguard\n-                // against the hypothetical assignment of the\n-                // dtor_needed/dtor_done values to v and v+k.  that\n-                // happen to match with one of the corruption values\n-                // below.)\n-                *p1.offset(i as isize) += 2;\n-                *p2.offset(i as isize) += 3;\n-            }\n-        }\n-        // Here, at the end of the scope of `c1` and `c2`, the\n-        // drop-glue should detect the corruption of (at least one of)\n-        // the drop-flags.\n-    }\n-}"}, {"sha": "2b016dfb33ecaf33f69e7003ae40ad70ae009116", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -74,15 +74,13 @@ impl<'a> Drop for Ptr<'a> {\n     }\n }\n \n-#[rustc_mir]\n fn dynamic_init(a: &Allocator, c: bool) {\n     let _x;\n     if c {\n         _x = Some(a.alloc());\n     }\n }\n \n-#[rustc_mir]\n fn dynamic_drop(a: &Allocator, c: bool) {\n     let x = a.alloc();\n     if c {\n@@ -92,7 +90,6 @@ fn dynamic_drop(a: &Allocator, c: bool) {\n     };\n }\n \n-#[rustc_mir]\n fn assignment2(a: &Allocator, c0: bool, c1: bool) {\n     let mut _v = a.alloc();\n     let mut _w = a.alloc();\n@@ -105,7 +102,6 @@ fn assignment2(a: &Allocator, c0: bool, c1: bool) {\n     }\n }\n \n-#[rustc_mir]\n fn assignment1(a: &Allocator, c0: bool) {\n     let mut _v = a.alloc();\n     let mut _w = a.alloc();"}, {"sha": "27bcab43229c52ade34099809fdd634f1d698917", "filename": "src/test/run-pass/exhaustive-bool-match-sanity.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fexhaustive-bool-match-sanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fexhaustive-bool-match-sanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexhaustive-bool-match-sanity.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -15,9 +15,6 @@\n // sanity in that we generate an if-else chain giving the correct\n // results.\n \n-#![feature(rustc_attrs)]\n-\n-#[rustc_mir]\n fn foo(x: bool, y: bool) -> u32 {\n     match (x, y) {\n         (false, _) => 0,"}, {"sha": "ea42b59f1f2b84045a973bce147501e596d31056", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -55,15 +55,6 @@ pub fn main() {\n         // compiler is hidden.\n         rusti::move_val_init(&mut y, x);\n \n-        // In particular, it may be tracked via a drop-flag embedded\n-        // in the value, or via a null pointer, or via\n-        // mem::POST_DROP_USIZE, or (most preferably) via a\n-        // stack-local drop flag.\n-        //\n-        // (This test used to build-in knowledge of how it was\n-        // tracked, and check that the underlying stack slot had been\n-        // set to `mem::POST_DROP_USIZE`.)\n-\n         // But what we *can* observe is how many times the destructor\n         // for `D` is invoked, and what the last value we saw was\n         // during such a destructor call. We do so after the end of"}, {"sha": "a521e5d4b6c34b04488b4f2db023e05655702167", "filename": "src/test/run-pass/issue-10734.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fissue-10734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fissue-10734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10734.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,12 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(unsafe_no_drop_flag)]\n-\n static mut drop_count: usize = 0;\n \n-#[unsafe_no_drop_flag]\n struct Foo {\n     dropped: bool\n }"}, {"sha": "e1b94179764bf8fbe6bfa3ad3516e603955ad1c9", "filename": "src/test/run-pass/issue-16648.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fissue-16648.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fissue-16648.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16648.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -9,9 +9,8 @@\n // except according to those terms.\n \n \n-#![feature(slice_patterns, rustc_attrs)]\n+#![feature(slice_patterns)]\n \n-#[rustc_mir]\n fn main() {\n     let x: (isize, &[isize]) = (2, &[1, 2]);\n     assert_eq!(match x {"}, {"sha": "b0fd0e148c8c26f690e55faa7f01ae419a67f88a", "filename": "src/test/run-pass/issue-2895.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fissue-2895.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fissue-2895.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2895.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -26,11 +26,11 @@ impl Drop for Kitty {\n #[cfg(target_pointer_width = \"64\")]\n pub fn main() {\n     assert_eq!(mem::size_of::<Cat>(), 8 as usize);\n-    assert_eq!(mem::size_of::<Kitty>(), 16 as usize);\n+    assert_eq!(mem::size_of::<Kitty>(), 8 as usize);\n }\n \n #[cfg(target_pointer_width = \"32\")]\n pub fn main() {\n     assert_eq!(mem::size_of::<Cat>(), 4 as usize);\n-    assert_eq!(mem::size_of::<Kitty>(), 8 as usize);\n+    assert_eq!(mem::size_of::<Kitty>(), 4 as usize);\n }"}, {"sha": "a70c2b3ae1b7ba03dea6fb1220116a9a63f885e7", "filename": "src/test/run-pass/issue-28950.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fissue-28950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fissue-28950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-28950.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -9,19 +9,23 @@\n // except according to those terms.\n \n // ignore-emscripten\n-// compile-flags: -Z orbit=off\n-// (blows the stack with MIR trans and no optimizations)\n+// compile-flags: -O\n \n // Tests that the `vec!` macro does not overflow the stack when it is\n // given data larger than the stack.\n \n+// FIXME(eddyb) Improve unoptimized codegen to avoid the temporary,\n+// and thus run successfully even when compiled at -C opt-level=0.\n+\n const LEN: usize = 1 << 15;\n \n use std::thread::Builder;\n \n fn main() {\n     assert!(Builder::new().stack_size(LEN / 2).spawn(|| {\n-        let vec = vec![[0; LEN]];\n+        // FIXME(eddyb) this can be vec![[0: LEN]] pending\n+        // https://llvm.org/bugs/show_bug.cgi?id=28987\n+        let vec = vec![unsafe { std::mem::zeroed::<[u8; LEN]>() }];\n         assert_eq!(vec.len(), 1);\n     }).unwrap().join().is_ok());\n }"}, {"sha": "b7ff63b75ce88df7cc2c4f9490f396951a60dc18", "filename": "src/test/run-pass/issue-32805.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fissue-32805.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fissue-32805.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-32805.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,19 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n-#[rustc_mir]\n fn const_mir() -> f32 { 9007199791611905.0 }\n \n-#[rustc_no_mir]\n-fn const_old() -> f32 { 9007199791611905.0 }\n-\n fn main() {\n     let original = \"9007199791611905.0\"; // (1<<53)+(1<<29)+1\n     let expected = \"9007200000000000\";\n \n     assert_eq!(const_mir().to_string(), expected);\n-    assert_eq!(const_old().to_string(), expected);\n     assert_eq!(original.parse::<f32>().unwrap().to_string(), expected);\n }"}, {"sha": "d30e88b3968c7ab242d22800ff86fee7e82ff377", "filename": "src/test/run-pass/issue-33387.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fissue-33387.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fissue-33387.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-33387.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -24,17 +24,14 @@ impl Foo for [u8; 2] {\n \n struct Bar<T: ?Sized>(T);\n \n-#[rustc_mir]\n fn unsize_fat_ptr<'a>(x: &'a Bar<Foo + Send + 'a>) -> &'a Bar<Foo + 'a> {\n     x\n }\n \n-#[rustc_mir]\n fn unsize_nested_fat_ptr(x: Arc<Foo + Send>) -> Arc<Foo> {\n     x\n }\n \n-#[rustc_mir]\n fn main() {\n     let x: Box<Bar<Foo + Send>> = Box::new(Bar([1,2]));\n     assert_eq!(unsize_fat_ptr(&*x).0.get(), [1, 2]);"}, {"sha": "badc013cd621f6297af82991af69264dc35b0073", "filename": "src/test/run-pass/issue-7784.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7784.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -11,7 +11,6 @@\n \n #![feature(advanced_slice_patterns)]\n #![feature(slice_patterns)]\n-#![feature(rustc_attrs)]\n \n use std::ops::Add;\n \n@@ -22,7 +21,6 @@ fn bar(a: &'static str, b: &'static str) -> [&'static str; 4] {\n     [a, b, b, a]\n }\n \n-#[rustc_mir]\n fn main() {\n     assert_eq!(foo([1, 2, 3]), (1, 3, 6));\n "}, {"sha": "fa609593c24b631807873967526c5c30238b803e", "filename": "src/test/run-pass/match-vec-alternatives.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -11,9 +11,7 @@\n \n #![feature(advanced_slice_patterns)]\n #![feature(slice_patterns)]\n-#![feature(rustc_attrs)]\n \n-#[rustc_mir]\n fn match_vecs<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n     match (l1, l2) {\n         (&[], &[]) => \"both empty\",\n@@ -22,7 +20,6 @@ fn match_vecs<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n     }\n }\n \n-#[rustc_mir]\n fn match_vecs_cons<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n     match (l1, l2) {\n         (&[], &[]) => \"both empty\",\n@@ -31,7 +28,6 @@ fn match_vecs_cons<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n     }\n }\n \n-#[rustc_mir]\n fn match_vecs_snoc<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n     match (l1, l2) {\n         (&[], &[]) => \"both empty\",\n@@ -40,7 +36,6 @@ fn match_vecs_snoc<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n     }\n }\n \n-#[rustc_mir]\n fn match_nested_vecs_cons<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'static str {\n     match (l1, l2) {\n         (Some(&[]), Ok(&[])) => \"Some(empty), Ok(empty)\",\n@@ -51,7 +46,6 @@ fn match_nested_vecs_cons<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -\n     }\n }\n \n-#[rustc_mir]\n fn match_nested_vecs_snoc<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'static str {\n     match (l1, l2) {\n         (Some(&[]), Ok(&[])) => \"Some(empty), Ok(empty)\","}, {"sha": "dae843bba9fa6e6ba5d343fc8f70b4243915e438", "filename": "src/test/run-pass/mir_adt_construction.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_adt_construction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_adt_construction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_adt_construction.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,15 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n #[repr(C, u32)]\n enum CEnum {\n     Hello = 30,\n     World = 60\n }\n \n-#[rustc_mir]\n fn test1(c: CEnum) -> i32 {\n   let c2 = CEnum::Hello;\n   match (c, c2) {\n@@ -40,26 +37,22 @@ impl Drop for Pakd {\n     fn drop(&mut self) {}\n }\n \n-#[rustc_mir]\n fn test2() -> Pakd {\n     Pakd { a: 42, b: 42, c: 42, d: 42, e: () }\n }\n \n #[derive(PartialEq, Debug)]\n struct TupleLike(u64, u32);\n \n-#[rustc_mir]\n fn test3() -> TupleLike {\n     TupleLike(42, 42)\n }\n \n-#[rustc_mir]\n fn test4(x: fn(u64, u32) -> TupleLike) -> (TupleLike, TupleLike) {\n     let y = TupleLike;\n     (x(42, 84), y(42, 84))\n }\n \n-#[rustc_mir]\n fn test5(x: fn(u32) -> Option<u32>) -> (Option<u32>, Option<u32>) {\n     let y = Some;\n     (x(42), y(42))"}, {"sha": "bc1013429aa59252aa3ddeb7ff1763b9b5a27b81", "filename": "src/test/run-pass/mir_ascription_coercion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_ascription_coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_ascription_coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_ascription_coercion.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -10,9 +10,8 @@\n \n // Tests that the result of type ascription has adjustments applied\n \n-#![feature(rustc_attrs, type_ascription)]\n+#![feature(type_ascription)]\n \n-#[rustc_mir]\n fn main() {\n     let x = [1, 2, 3];\n     // The RHS should coerce to &[i32]"}, {"sha": "bb90f25fce5f405200a6490a5152621bb7368812", "filename": "src/test/run-pass/mir_augmented_assignments.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_augmented_assignments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_augmented_assignments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_augmented_assignments.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n use std::mem;\n use std::ops::{\n     AddAssign, BitAndAssign, BitOrAssign, BitXorAssign, DivAssign, MulAssign, RemAssign,\n@@ -33,7 +31,6 @@ fn main() {\n     main_mir();\n }\n \n-#[rustc_mir]\n fn main_mir() {\n     let mut x = Int(1);\n \n@@ -92,91 +89,78 @@ fn main_mir() {\n }\n \n impl AddAssign for Int {\n-    #[rustc_mir]\n     fn add_assign(&mut self, rhs: Int) {\n         self.0 += rhs.0;\n     }\n }\n \n impl BitAndAssign for Int {\n-    #[rustc_mir]\n     fn bitand_assign(&mut self, rhs: Int) {\n         self.0 &= rhs.0;\n     }\n }\n \n impl BitOrAssign for Int {\n-    #[rustc_mir]\n     fn bitor_assign(&mut self, rhs: Int) {\n         self.0 |= rhs.0;\n     }\n }\n \n impl BitXorAssign for Int {\n-    #[rustc_mir]\n     fn bitxor_assign(&mut self, rhs: Int) {\n         self.0 ^= rhs.0;\n     }\n }\n \n impl DivAssign for Int {\n-    #[rustc_mir]\n     fn div_assign(&mut self, rhs: Int) {\n         self.0 /= rhs.0;\n     }\n }\n \n impl MulAssign for Int {\n-    #[rustc_mir]\n     fn mul_assign(&mut self, rhs: Int) {\n         self.0 *= rhs.0;\n     }\n }\n \n impl RemAssign for Int {\n-    #[rustc_mir]\n     fn rem_assign(&mut self, rhs: Int) {\n         self.0 %= rhs.0;\n     }\n }\n \n impl ShlAssign<u8> for Int {\n-    #[rustc_mir]\n     fn shl_assign(&mut self, rhs: u8) {\n         self.0 <<= rhs;\n     }\n }\n \n impl ShlAssign<u16> for Int {\n-    #[rustc_mir]\n     fn shl_assign(&mut self, rhs: u16) {\n         self.0 <<= rhs;\n     }\n }\n \n impl ShrAssign<u8> for Int {\n-    #[rustc_mir]\n     fn shr_assign(&mut self, rhs: u8) {\n         self.0 >>= rhs;\n     }\n }\n \n impl ShrAssign<u16> for Int {\n-    #[rustc_mir]\n     fn shr_assign(&mut self, rhs: u16) {\n         self.0 >>= rhs;\n     }\n }\n \n impl SubAssign for Int {\n-    #[rustc_mir]\n     fn sub_assign(&mut self, rhs: Int) {\n         self.0 -= rhs.0;\n     }\n }\n \n impl AddAssign<i32> for Slice {\n-    #[rustc_mir]\n     fn add_assign(&mut self, rhs: i32) {\n         for lhs in &mut self.0 {\n             *lhs += rhs;"}, {"sha": "f0032fee2835eff90350ccde03ae68622262fa2c", "filename": "src/test/run-pass/mir_autoderef.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_autoderef.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n use std::ops::{Deref, DerefMut};\n \n pub struct MyRef(u32);\n@@ -24,12 +22,10 @@ impl DerefMut for MyRef {\n }\n \n \n-#[rustc_mir]\n fn deref(x: &MyRef) -> &u32 {\n     x\n }\n \n-#[rustc_mir]\n fn deref_mut(x: &mut MyRef) -> &mut u32 {\n     x\n }"}, {"sha": "1c5134755d7aa1465eacbcf7939abdb52ee5d655", "filename": "src/test/run-pass/mir_boxing.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_boxing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_boxing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_boxing.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs, box_syntax)]\n+#![feature(box_syntax)]\n \n-#[rustc_mir]\n fn test() -> Box<i32> {\n     box 42\n }"}, {"sha": "b195ff63412af4dcc960fbf7869ad9e742cbdfb3", "filename": "src/test/run-pass/mir_build_match_comparisons.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_build_match_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_build_match_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_build_match_comparisons.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n-#[rustc_mir]\n fn test1(x: i8) -> i32 {\n   match x {\n     1...10 => 0,\n@@ -21,15 +18,13 @@ fn test1(x: i8) -> i32 {\n const U: Option<i8> = Some(10);\n const S: &'static str = \"hello\";\n \n-#[rustc_mir]\n fn test2(x: i8) -> i32 {\n   match Some(x) {\n     U => 0,\n     _ => 1,\n   }\n }\n \n-#[rustc_mir]\n fn test3(x: &'static str) -> i32 {\n   match x {\n     S => 0,\n@@ -42,7 +37,6 @@ enum Opt<T> {\n     None\n }\n \n-#[rustc_mir]\n fn test4(x: u64) -> i32 {\n   let opt = Opt::Some{ v: x };\n   match opt {"}, {"sha": "935d0e58985d7c683160a10dbc6c7614ed1e1dc1", "filename": "src/test/run-pass/mir_call_with_associated_type.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_call_with_associated_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_call_with_associated_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_call_with_associated_type.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n trait Trait {\n     type Type;\n }\n@@ -18,12 +16,10 @@ impl<'a> Trait for &'a () {\n     type Type = u32;\n }\n \n-#[rustc_mir]\n fn foo<'a>(t: <&'a () as Trait>::Type) -> <&'a () as Trait>::Type {\n     t\n }\n \n-#[rustc_mir]\n fn main() {\n     assert_eq!(foo(4), 4);\n }"}, {"sha": "311d5451eb6dd5012d56247e316072e19a6c1b82", "filename": "src/test/run-pass/mir_cast_fn_ret.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_cast_fn_ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_cast_fn_ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_cast_fn_ret.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n pub extern \"C\" fn tuple2() -> (u16, u8) {\n     (1, 2)\n }\n@@ -18,12 +16,10 @@ pub extern \"C\" fn tuple3() -> (u8, u8, u8) {\n     (1, 2, 3)\n }\n \n-#[rustc_mir]\n pub fn test2() -> u8 {\n     tuple2().1\n }\n \n-#[rustc_mir]\n pub fn test3() -> u8 {\n     tuple3().2\n }"}, {"sha": "2be2854fac959cc582065264633a927c4c0b7a2e", "filename": "src/test/run-pass/mir_coercion_casts.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_coercion_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_coercion_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_coercion_casts.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -10,9 +10,6 @@\n \n // Tests the coercion casts are handled properly\n \n-#![feature(rustc_attrs)]\n-\n-#[rustc_mir]\n fn main() {\n     // This should produce only a reification of f,\n     // not a fn -> fn cast as well"}, {"sha": "79d1cfde7cd581b831aa46417d12df41545e6347", "filename": "src/test/run-pass/mir_coercions.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_coercions.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,24 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs, coerce_unsized, unsize)]\n+#![feature(coerce_unsized, unsize)]\n \n use std::ops::CoerceUnsized;\n use std::marker::Unsize;\n \n-#[rustc_mir]\n fn identity_coercion(x: &(Fn(u32)->u32 + Send)) -> &Fn(u32)->u32 {\n     x\n }\n-#[rustc_mir]\n fn fn_coercions(f: &fn(u32) -> u32) ->\n     (unsafe fn(u32) -> u32,\n      &(Fn(u32) -> u32+Send))\n {\n     (*f, f)\n }\n \n-#[rustc_mir]\n fn simple_array_coercion(x: &[u8; 3]) -> &[u8] { x }\n \n fn square(a: u32) -> u32 { a * a }\n@@ -39,23 +36,19 @@ struct TrivPtrWrapper<'a, T: 'a+?Sized>(&'a T);\n impl<'a, T: ?Sized+Unsize<U>, U: ?Sized>\n     CoerceUnsized<TrivPtrWrapper<'a, U>> for TrivPtrWrapper<'a, T> {}\n \n-#[rustc_mir]\n fn coerce_ptr_wrapper(p: PtrWrapper<[u8; 3]>) -> PtrWrapper<[u8]> {\n     p\n }\n \n-#[rustc_mir]\n fn coerce_triv_ptr_wrapper(p: TrivPtrWrapper<[u8; 3]>) -> TrivPtrWrapper<[u8]> {\n     p\n }\n \n-#[rustc_mir]\n fn coerce_fat_ptr_wrapper(p: PtrWrapper<Fn(u32) -> u32+Send>)\n                           -> PtrWrapper<Fn(u32) -> u32> {\n     p\n }\n \n-#[rustc_mir]\n fn coerce_ptr_wrapper_poly<'a, T, Trait: ?Sized>(p: PtrWrapper<'a, T>)\n                                                  -> PtrWrapper<'a, Trait>\n     where PtrWrapper<'a, T>: CoerceUnsized<PtrWrapper<'a, Trait>>"}, {"sha": "696ff8a7e600fe16756eaa6ab6aab5924f3d6806", "filename": "src/test/run-pass/mir_constval_adts.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_constval_adts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_constval_adts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_constval_adts.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -7,7 +7,6 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(rustc_attrs)]\n \n #[derive(PartialEq, Debug)]\n struct Point {\n@@ -23,7 +22,6 @@ const TUPLE1: (i32, i32) = (42, 42);\n const TUPLE2: (&'static str, &'static str) = (\"hello\",\"world\");\n const PAIR_NEWTYPE: (Newtype<i32>, Newtype<i32>) = (Newtype(42), Newtype(42));\n \n-#[rustc_mir]\n fn mir() -> (Point, (i32, i32), (&'static str, &'static str), (Newtype<i32>, Newtype<i32>)) {\n     let struct1 = STRUCT;\n     let tuple1 = TUPLE1;\n@@ -34,7 +32,6 @@ fn mir() -> (Point, (i32, i32), (&'static str, &'static str), (Newtype<i32>, New\n \n const NEWTYPE: Newtype<&'static str> = Newtype(\"foobar\");\n \n-#[rustc_mir]\n fn test_promoted_newtype_str_ref() {\n     let x = &NEWTYPE;\n     assert_eq!(x, &Newtype(\"foobar\"));"}, {"sha": "cc239d9f68b1355d14c33c855e6e67e3978b1cc9", "filename": "src/test/run-pass/mir_cross_crate.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Ftest%2Frun-pass%2Fmir_cross_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03e23c7f9a10b18e1687bfd92c6807e9342aa00b/src%2Ftest%2Frun-pass%2Fmir_cross_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_cross_crate.rs?ref=03e23c7f9a10b18e1687bfd92c6807e9342aa00b", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z orbit\n-// Tests that -Z orbit affects functions from other crates.\n-\n-#![feature(unsafe_no_drop_flag)]\n-\n-#[unsafe_no_drop_flag]\n-struct Foo;\n-\n-impl Drop for Foo {\n-    fn drop(&mut self) {\n-        panic!(\"MIR trans is not enabled for mem::forget\");\n-    }\n-}\n-\n-fn main() {\n-    let x = Foo;\n-    std::mem::forget(x);\n-}"}, {"sha": "e5c9e3577d1c302a1cd6458eccf6019e01e1845b", "filename": "src/test/run-pass/mir_fat_ptr.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_fat_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_fat_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_fat_ptr.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -10,46 +10,37 @@\n \n // test that ordinary fat pointer operations work.\n \n-#![feature(rustc_attrs)]\n-\n struct Wrapper<T: ?Sized>(u32, T);\n \n struct FatPtrContainer<'a> {\n     ptr: &'a [u8]\n }\n \n-#[rustc_mir]\n fn fat_ptr_project(a: &Wrapper<[u8]>) -> &[u8] {\n     &a.1\n }\n \n-#[rustc_mir]\n fn fat_ptr_simple(a: &[u8]) -> &[u8] {\n     a\n }\n \n-#[rustc_mir]\n fn fat_ptr_via_local(a: &[u8]) -> &[u8] {\n     let x = a;\n     x\n }\n \n-#[rustc_mir]\n fn fat_ptr_from_struct(s: FatPtrContainer) -> &[u8] {\n     s.ptr\n }\n \n-#[rustc_mir]\n fn fat_ptr_to_struct(a: &[u8]) -> FatPtrContainer {\n     FatPtrContainer { ptr: a }\n }\n \n-#[rustc_mir]\n fn fat_ptr_store_to<'a>(a: &'a [u8], b: &mut &'a [u8]) {\n     *b = a;\n }\n \n-#[rustc_mir]\n fn fat_ptr_constant() -> &'static str {\n     \"HELLO\"\n }"}, {"sha": "64e68c78c3ca6b77a201049d6f131e6f354a7846", "filename": "src/test/run-pass/mir_fat_ptr_drop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_fat_ptr_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_fat_ptr_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_fat_ptr_drop.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -27,7 +27,6 @@ impl Drop for DropMe {\n     }\n }\n \n-#[rustc_mir]\n fn fat_ptr_move_then_drop(a: Box<[DropMe]>) {\n     let b = a;\n }"}, {"sha": "487999e6ed62bbf0978e44f21347fa726d2d474a", "filename": "src/test/run-pass/mir_match_arm_guard.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_match_arm_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_match_arm_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_match_arm_guard.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -10,9 +10,6 @@\n \n // #30527 - We were not generating arms with guards in certain cases.\n \n-#![feature(rustc_attrs)]\n-\n-#[rustc_mir]\n fn match_with_guard(x: Option<i8>) -> i8 {\n     match x {\n         Some(xyz) if xyz > 100 => 0,"}, {"sha": "ae719ac2800eeefb8a1e59983d494456ada45ce3", "filename": "src/test/run-pass/mir_misc_casts.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_misc_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_misc_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_misc_casts.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(libc, rustc_attrs)]\n+#![feature(libc)]\n \n extern crate libc;\n \n@@ -17,7 +17,6 @@ fn func(){}\n const STR: &'static str = \"hello\";\n const BSTR: &'static [u8; 5] = b\"hello\";\n \n-#[rustc_mir]\n fn from_ptr()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, *const ()) {\n     let f = 1_usize as *const libc::FILE;\n@@ -35,7 +34,6 @@ fn from_ptr()\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11)\n }\n \n-#[rustc_mir]\n fn from_1()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n     let c1 = 1 as isize;\n@@ -54,7 +52,6 @@ fn from_1()\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n-#[rustc_mir]\n fn from_1usize()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n     let c1 = 1_usize as isize;\n@@ -73,7 +70,6 @@ fn from_1usize()\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n-#[rustc_mir]\n fn from_1isize()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n     let c1 = 1_isize as isize;\n@@ -92,7 +88,6 @@ fn from_1isize()\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n-#[rustc_mir]\n fn from_1u8()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n     let c1 = 1_u8 as isize;\n@@ -111,7 +106,6 @@ fn from_1u8()\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n-#[rustc_mir]\n fn from_1i8()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n     let c1 = 1_i8 as isize;\n@@ -130,7 +124,6 @@ fn from_1i8()\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n-#[rustc_mir]\n fn from_1u16()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n     let c1 = 1_u16 as isize;\n@@ -149,7 +142,6 @@ fn from_1u16()\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n-#[rustc_mir]\n fn from_1i16()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n     let c1 = 1_i16 as isize;\n@@ -168,7 +160,6 @@ fn from_1i16()\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n-#[rustc_mir]\n fn from_1u32()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n     let c1 = 1_u32 as isize;\n@@ -187,7 +178,6 @@ fn from_1u32()\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n-#[rustc_mir]\n fn from_1i32()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n     let c1 = 1_i32 as isize;\n@@ -206,7 +196,6 @@ fn from_1i32()\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n-#[rustc_mir]\n fn from_1u64()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n     let c1 = 1_u64 as isize;\n@@ -225,7 +214,6 @@ fn from_1u64()\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n-#[rustc_mir]\n fn from_1i64()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n     let c1 = 1_i64 as isize;\n@@ -244,7 +232,6 @@ fn from_1i64()\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n-#[rustc_mir]\n fn from_bool()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64) {\n     let c1 = true as isize;\n@@ -260,7 +247,6 @@ fn from_bool()\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10)\n }\n \n-#[rustc_mir]\n fn from_1f32()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64) {\n     let c1 = 1.0_f32 as isize;\n@@ -278,7 +264,6 @@ fn from_1f32()\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12)\n }\n \n-#[rustc_mir]\n fn from_1f64()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64) {\n     let c1 = 1.0f64 as isize;\n@@ -296,7 +281,6 @@ fn from_1f64()\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12)\n }\n \n-#[rustc_mir]\n fn other_casts()\n -> (*const u8, *const isize, *const u8, *const u8) {\n     let c1 = func as *const u8;"}, {"sha": "0db1e7b4563c18907e89fa840131fc583fb2d111", "filename": "src/test/run-pass/mir_overflow_off.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_overflow_off.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_overflow_off.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_overflow_off.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z force-overflow-checks=off -Z orbit\n+// compile-flags: -Z force-overflow-checks=off\n \n // Test that with MIR trans, overflow checks can be\n // turned off, even when they're from core::ops::*."}, {"sha": "c9fd88f2fb3cfba15dac2d00005680145de62c5b", "filename": "src/test/run-pass/mir_raw_fat_ptr.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n // ignore-pretty : (#23623) problems when  ending with // comments\n \n // check raw fat pointer ops in mir\n@@ -54,7 +52,6 @@ const GT: ComparisonResults = ComparisonResults {\n     ne: true\n };\n \n-#[rustc_mir]\n fn compare_su8(a: *const S<[u8]>, b: *const S<[u8]>) -> ComparisonResults {\n     ComparisonResults {\n         lt: a < b,\n@@ -66,7 +63,6 @@ fn compare_su8(a: *const S<[u8]>, b: *const S<[u8]>) -> ComparisonResults {\n     }\n }\n \n-#[rustc_mir]\n fn compare_au8(a: *const [u8], b: *const [u8]) -> ComparisonResults {\n     ComparisonResults {\n         lt: a < b,\n@@ -78,7 +74,6 @@ fn compare_au8(a: *const [u8], b: *const [u8]) -> ComparisonResults {\n     }\n }\n \n-#[rustc_mir]\n fn compare_foo<'a>(a: *const (Foo+'a), b: *const (Foo+'a)) -> ComparisonResults {\n     ComparisonResults {\n         lt: a < b,\n@@ -90,7 +85,6 @@ fn compare_foo<'a>(a: *const (Foo+'a), b: *const (Foo+'a)) -> ComparisonResults\n     }\n }\n \n-#[rustc_mir]\n fn simple_eq<'a>(a: *const (Foo+'a), b: *const (Foo+'a)) -> bool {\n     let result = a == b;\n     result"}, {"sha": "df90fe2b7918d43740e740c9a2411be2769f66d4", "filename": "src/test/run-pass/mir_refs_correct.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -7,9 +7,8 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(rustc_attrs)]\n-// aux-build:mir_external_refs.rs\n \n+// aux-build:mir_external_refs.rs\n \n extern crate mir_external_refs as ext;\n \n@@ -78,128 +77,103 @@ fn parametric<T>(u: T) -> T {\n     u\n }\n \n-#[rustc_mir]\n fn t1() -> fn()->u8 {\n     regular\n }\n \n-#[rustc_mir]\n fn t2() -> fn(u8)->E {\n     E::U\n }\n \n-#[rustc_mir]\n fn t3() -> fn(u8)->S {\n     S\n }\n \n-#[rustc_mir]\n fn t4() -> fn()->u8 {\n     S::hey\n }\n \n-#[rustc_mir]\n fn t5() -> fn(&S)-> u8 {\n     <S as X>::hoy\n }\n \n \n-#[rustc_mir]\n fn t6() -> fn()->u8{\n     ext::regular_fn\n }\n \n-#[rustc_mir]\n fn t7() -> fn(u8)->ext::E {\n     ext::E::U\n }\n \n-#[rustc_mir]\n fn t8() -> fn(u8)->ext::S {\n     ext::S\n }\n \n-#[rustc_mir]\n fn t9() -> fn()->u8 {\n     ext::S::hey\n }\n \n-#[rustc_mir]\n fn t10() -> fn(&ext::S)->u8 {\n     <ext::S as ext::X>::hoy\n }\n \n-#[rustc_mir]\n fn t11() -> fn(u8)->u8 {\n     parametric\n }\n \n-#[rustc_mir]\n fn t12() -> u8 {\n     C\n }\n \n-#[rustc_mir]\n fn t13() -> [u8; 5] {\n     C2\n }\n \n-#[rustc_mir]\n fn t13_2() -> [u8; 3] {\n     C3\n }\n \n-#[rustc_mir]\n fn t14() -> fn()-> u8 {\n     <S as X>::hoy2\n }\n \n-#[rustc_mir]\n fn t15() -> fn(&S)-> u8 {\n     S::hey2\n }\n \n-#[rustc_mir]\n fn t16() -> fn(u32, u32)->u64 {\n     F::f\n }\n \n-#[rustc_mir]\n fn t17() -> fn(u32, u64)->u64 {\n     F::f\n }\n \n-#[rustc_mir]\n fn t18() -> fn(u64, u64)->u64 {\n     F::f\n }\n \n-#[rustc_mir]\n fn t19() -> fn(u64, u32)->u64 {\n     F::f\n }\n \n-#[rustc_mir]\n fn t20() -> fn(u64, u32)->(u64, u32) {\n     <u32 as T<_, _>>::staticmeth\n }\n \n-#[rustc_mir]\n fn t21() -> Unit {\n     Unit\n }\n \n-#[rustc_mir]\n fn t22() -> Option<u8> {\n     None\n }\n \n-#[rustc_mir]\n fn t23() -> (CEnum, CEnum) {\n     (CEnum::A, CEnum::B)\n }\n \n-#[rustc_mir]\n fn t24() -> fn(u8) -> S {\n     C4\n }"}, {"sha": "639a585ae0013f60ecfbead13fdaa0d05530c617", "filename": "src/test/run-pass/mir_small_agg_arg.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_small_agg_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_small_agg_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_small_agg_arg.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n-#[rustc_mir]\n fn foo((x, y): (i8, i8)) {\n }\n "}, {"sha": "7b2514c27c8cba1b852ac0583848e57b6a265583", "filename": "src/test/run-pass/mir_struct_with_assoc_ty.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_struct_with_assoc_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_struct_with_assoc_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_struct_with_assoc_ty.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n use std::marker::PhantomData;\n \n pub trait DataBind {\n@@ -26,7 +24,6 @@ pub struct Data {\n     pub offsets: <Global<[u32; 2]> as DataBind>::Data,\n }\n \n-#[rustc_mir]\n fn create_data() -> Data {\n     let mut d = Data { offsets: [1, 2] };\n     d.offsets[0] = 3;"}, {"sha": "4865e955091f8eac6754f179fdf3da20296a9cc5", "filename": "src/test/run-pass/mir_temp_promotions.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_temp_promotions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_temp_promotions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_temp_promotions.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n-#[rustc_mir]\n fn test1(f: f32) -> bool {\n     // test that we properly promote temporaries to allocas when a temporary is assigned to\n     // multiple times (assignment is still happening once \u2200 possible dataflows)."}, {"sha": "b7f247012ce129da0bb7f694698a792d31ff0bd5", "filename": "src/test/run-pass/mir_trans_array.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_array.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -7,9 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(rustc_attrs)]\n \n-#[rustc_mir]\n fn into_inner() -> [u64; 1024] {\n     let mut x = 10 + 20;\n     [x; 1024]"}, {"sha": "c7133fb0c0e4923b5447bc4732fb3b8b72579dd2", "filename": "src/test/run-pass/mir_trans_array_2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_array_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_array_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_array_2.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -7,9 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(rustc_attrs)]\n \n-#[rustc_mir]\n fn into_inner(x: u64) -> [u64; 1024] {\n     [x; 2*4*8*16]\n }"}, {"sha": "7d420bb86c6077968714deba37f25d3cede35739", "filename": "src/test/run-pass/mir_trans_call_converging.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_call_converging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_call_converging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_call_converging.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -7,13 +7,11 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(rustc_attrs)]\n \n fn converging_fn() -> u64 {\n     43\n }\n \n-#[rustc_mir]\n fn mir() -> u64 {\n     let x;\n     loop {"}, {"sha": "d429c681bbe4ac317271c7c479416dba951e9556", "filename": "src/test/run-pass/mir_trans_calls.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs, fn_traits)]\n+#![feature(fn_traits)]\n \n-#[rustc_mir]\n fn test1(a: isize, b: (i32, i32), c: &[i32]) -> (isize, (i32, i32), &[i32]) {\n     // Test passing a number of arguments including a fat pointer.\n     // Also returning via an out pointer\n@@ -20,7 +19,6 @@ fn test1(a: isize, b: (i32, i32), c: &[i32]) -> (isize, (i32, i32), &[i32]) {\n     callee(a, b, c)\n }\n \n-#[rustc_mir]\n fn test2(a: isize) -> isize {\n     // Test passing a single argument.\n     // Not using out pointer.\n@@ -36,7 +34,6 @@ impl Foo {\n     fn inherent_method(&self, a: isize) -> isize { a }\n }\n \n-#[rustc_mir]\n fn test3(x: &Foo, a: isize) -> isize {\n     // Test calling inherent method\n     x.inherent_method(a)\n@@ -47,19 +44,16 @@ trait Bar {\n }\n impl Bar for Foo {}\n \n-#[rustc_mir]\n fn test4(x: &Foo, a: isize) -> isize {\n     // Test calling extension method\n     x.extension_method(a)\n }\n \n-#[rustc_mir]\n fn test5(x: &Bar, a: isize) -> isize {\n     // Test calling method on trait object\n     x.extension_method(a)\n }\n \n-#[rustc_mir]\n fn test6<T: Bar>(x: &T, a: isize) -> isize {\n     // Test calling extension method on generic callee\n     x.extension_method(a)\n@@ -72,7 +66,6 @@ impl One for isize {\n     fn one() -> isize { 1 }\n }\n \n-#[rustc_mir]\n fn test7() -> isize {\n     // Test calling trait static method\n     <isize as One>::one()\n@@ -83,7 +76,6 @@ impl Two {\n     fn two() -> isize { 2 }\n }\n \n-#[rustc_mir]\n fn test8() -> isize {\n     // Test calling impl static method\n     Two::two()\n@@ -93,53 +85,45 @@ extern fn simple_extern(x: u32, y: (u32, u32)) -> u32 {\n     x + y.0 * y.1\n }\n \n-#[rustc_mir]\n fn test9() -> u32 {\n     simple_extern(41, (42, 43))\n }\n \n-#[rustc_mir]\n fn test_closure<F>(f: &F, x: i32, y: i32) -> i32\n     where F: Fn(i32, i32) -> i32\n {\n     f(x, y)\n }\n \n-#[rustc_mir]\n fn test_fn_object(f: &Fn(i32, i32) -> i32, x: i32, y: i32) -> i32 {\n     f(x, y)\n }\n \n-#[rustc_mir]\n fn test_fn_impl(f: &&Fn(i32, i32) -> i32, x: i32, y: i32) -> i32 {\n     // This call goes through the Fn implementation for &Fn provided in\n     // core::ops::impls. It expands to a static Fn::call() that calls the\n     // Fn::call() implementation of the object shim underneath.\n     f(x, y)\n }\n \n-#[rustc_mir]\n fn test_fn_direct_call<F>(f: &F, x: i32, y: i32) -> i32\n     where F: Fn(i32, i32) -> i32\n {\n     f.call((x, y))\n }\n \n-#[rustc_mir]\n fn test_fn_const_call<F>(f: &F) -> i32\n     where F: Fn(i32, i32) -> i32\n {\n     f.call((100, -1))\n }\n \n-#[rustc_mir]\n fn test_fn_nil_call<F>(f: &F) -> i32\n     where F: Fn() -> i32\n {\n     f()\n }\n \n-#[rustc_mir]\n fn test_fn_transmute_zst(x: ()) -> [(); 1] {\n     fn id<T>(x: T) -> T {x}\n \n@@ -148,30 +132,24 @@ fn test_fn_transmute_zst(x: ()) -> [(); 1] {\n     })\n }\n \n-#[rustc_mir]\n fn test_fn_ignored_pair() -> ((), ()) {\n     ((), ())\n }\n \n-#[rustc_mir]\n fn test_fn_ignored_pair_0() {\n     test_fn_ignored_pair().0\n }\n \n-#[rustc_mir]\n fn id<T>(x: T) -> T { x }\n \n-#[rustc_mir]\n fn ignored_pair_named() -> (Foo, Foo) {\n     (Foo, Foo)\n }\n \n-#[rustc_mir]\n fn test_fn_ignored_pair_named() -> (Foo, Foo) {\n     id(ignored_pair_named())\n }\n \n-#[rustc_mir]\n fn test_fn_nested_pair(x: &((f32, f32), u32)) -> (f32, f32) {\n     let y = *x;\n     let z = y.0;"}, {"sha": "4e06738da4fd5e5a1d2b63591a393f04a9ef34c7", "filename": "src/test/run-pass/mir_trans_calls_variadic.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_calls_variadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_calls_variadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_calls_variadic.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,14 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n #[link(name = \"rust_test_helpers\")]\n extern {\n     fn rust_interesting_average(_: i64, ...) -> f64;\n }\n \n-#[rustc_mir]\n fn test<T, U>(a: i64, b: i64, c: i64, d: i64, e: i64, f: T, g: U) -> i64 {\n     unsafe {\n         rust_interesting_average(6, a, a as f64,"}, {"sha": "f6fe19c43097aed253c460c77715be4d1f799961", "filename": "src/test/run-pass/mir_trans_critical_edge.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_critical_edge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_critical_edge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_critical_edge.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -29,7 +29,6 @@ impl<A, B> Foo<A, B>\n where A: Iterator, B: Iterator<Item=A::Item>\n {\n     // This is the function we care about\n-    #[rustc_mir]\n     fn next(&mut self) -> Option<A::Item> {\n         match self.state {\n             State::Both => match self.a.next() {"}, {"sha": "8474e841e01ad91d794f285142d6ee38b6eb54e8", "filename": "src/test/run-pass/mir_trans_spike1.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_spike1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_spike1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_spike1.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -10,9 +10,6 @@\n \n // A simple spike test for MIR version of trans.\n \n-#![feature(rustc_attrs)]\n-\n-#[rustc_mir]\n fn sum(x: i32, y: i32) -> i32 {\n     x + y\n }"}, {"sha": "b097bf46ad3708210eebf151ad60077439553971", "filename": "src/test/run-pass/mir_trans_switch.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_switch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_switch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_switch.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,16 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n enum Abc {\n     A(u8),\n     B(i8),\n     C,\n     D,\n }\n \n-#[rustc_mir]\n fn foo(x: Abc) -> i32 {\n     match x {\n         Abc::C => 3,\n@@ -27,7 +24,6 @@ fn foo(x: Abc) -> i32 {\n     }\n }\n \n-#[rustc_mir]\n fn foo2(x: Abc) -> bool {\n     match x {\n         Abc::D => true,"}, {"sha": "537734596a5214f42de7ba2b8b94cd5e8b486a2b", "filename": "src/test/run-pass/mir_trans_switchint.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_switchint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_trans_switchint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_switchint.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n-#[rustc_mir]\n pub fn foo(x: i8) -> i32 {\n   match x {\n     1 => 0,"}, {"sha": "78cb9fb39d6a6cf28fc9bcb093abca0beffe2d91", "filename": "src/test/run-pass/mir_void_return.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_void_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_void_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_void_return.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n-#[rustc_mir]\n fn mir() -> (){\n     let x = 1;\n     let mut y = 0;"}, {"sha": "fc9e3d5e3b535d1a74faf62fb283dc3012bc3ce0", "filename": "src/test/run-pass/mir_void_return_2.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_void_return_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fmir_void_return_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_void_return_2.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n fn nil() {}\n \n-#[rustc_mir]\n fn mir(){\n     nil()\n }"}, {"sha": "a606a8a9f4b3b9b5f0720fb61ab18fef33cfa4ab", "filename": "src/test/run-pass/no-drop-flag-size.rs", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fno-drop-flag-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fno-drop-flag-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fno-drop-flag-size.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unsafe_no_drop_flag)]\n-\n use std::mem::size_of;\n \n-#[unsafe_no_drop_flag]\n struct Test<T> {\n     a: T\n }", "previous_filename": "src/test/run-pass/attr-no-drop-flag-size.rs"}, {"sha": "ac80a4211ada627fbfc0c0a2eb50dfda3d31f570", "filename": "src/test/run-pass/vec-matching-fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -11,11 +11,9 @@\n \n #![feature(advanced_slice_patterns)]\n #![feature(slice_patterns)]\n-#![feature(rustc_attrs)]\n \n use std::fmt::Debug;\n \n-#[rustc_mir(graphviz=\"mir.gv\")]\n fn foldl<T, U, F>(values: &[T],\n                   initial: U,\n                   mut function: F)\n@@ -32,7 +30,6 @@ fn foldl<T, U, F>(values: &[T],\n     }\n }\n \n-#[rustc_mir]\n fn foldr<T, U, F>(values: &[T],\n                   initial: U,\n                   mut function: F)"}, {"sha": "eecc3e7afdbb45d0549903076547343060a974c9", "filename": "src/test/run-pass/vec-matching-legal-tail-element-borrow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(slice_patterns, rustc_attrs)]\n+#![feature(slice_patterns)]\n \n-#[rustc_mir]\n pub fn main() {\n     let x = &[1, 2, 3, 4, 5];\n     let x: &[isize] = &[1, 2, 3, 4, 5];"}, {"sha": "97006f54cd9551f07feb03256ae448f993202aae", "filename": "src/test/run-pass/vec-matching.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -11,9 +11,7 @@\n \n #![feature(advanced_slice_patterns)]\n #![feature(slice_patterns)]\n-#![feature(rustc_attrs)]\n \n-#[rustc_mir]\n fn a() {\n     let x = [1];\n     match x {\n@@ -23,7 +21,6 @@ fn a() {\n     }\n }\n \n-#[rustc_mir]\n fn b() {\n     let x = [1, 2, 3];\n     match x {\n@@ -60,7 +57,6 @@ fn b() {\n }\n \n \n-#[rustc_mir]\n fn b_slice() {\n     let x : &[_] = &[1, 2, 3];\n     match x {\n@@ -100,7 +96,6 @@ fn b_slice() {\n     }\n }\n \n-#[rustc_mir]\n fn c() {\n     let x = [1];\n     match x {\n@@ -109,7 +104,6 @@ fn c() {\n     }\n }\n \n-#[rustc_mir]\n fn d() {\n     let x = [1, 2, 3];\n     let branch = match x {\n@@ -121,7 +115,6 @@ fn d() {\n     assert_eq!(branch, 1);\n }\n \n-#[rustc_mir]\n fn e() {\n     let x: &[isize] = &[1, 2, 3];\n     let a = match *x {"}, {"sha": "d123eb36a7d4d0d2a762b0ddf2dc733e68e6f6b9", "filename": "src/test/run-pass/vec-tail-matching.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -11,13 +11,11 @@\n \n \n #![feature(slice_patterns)]\n-#![feature(rustc_attrs)]\n \n struct Foo {\n     string: &'static str\n }\n \n-#[rustc_mir]\n pub fn main() {\n     let x = [\n         Foo { string: \"foo\" },"}, {"sha": "18b6c372a5ec2a0ae0e93e437ec9eda5857bdad1", "filename": "src/test/run-pass/zero-size-type-destructors.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fzero-size-type-destructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fzero-size-type-destructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzero-size-type-destructors.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,15 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs, unsafe_no_drop_flag)]\n-\n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n static mut destructions : isize = 3;\n \n-#[rustc_no_mir] // FIXME #29855 MIR doesn't handle all drops correctly.\n pub fn foo() {\n-    #[unsafe_no_drop_flag]\n     struct Foo;\n \n     impl Drop for Foo {"}, {"sha": "d399ef72976f1ae818c3f45a8980069970ada7ab", "filename": "src/test/run-pass/zero_sized_subslice_match.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fzero_sized_subslice_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bc1bac8c7664fb1b487879b3fbd56221f6a721/src%2Ftest%2Frun-pass%2Fzero_sized_subslice_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzero_sized_subslice_match.rs?ref=e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n #![feature(slice_patterns)]\n \n-#[rustc_mir]\n fn main() {\n     let x = [(), ()];\n "}]}