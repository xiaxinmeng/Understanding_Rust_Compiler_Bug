{"sha": "894b4c64ffdb280a38c1ea2e9be145ca308965fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NGI0YzY0ZmZkYjI4MGEzOGMxZWEyZTliZTE0NWNhMzA4OTY1ZmQ=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-11T11:15:35Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-31T19:08:43Z"}, "message": "Include old tests", "tree": {"sha": "91f64355d533424f03139690b724f7a2170a5670", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91f64355d533424f03139690b724f7a2170a5670"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/894b4c64ffdb280a38c1ea2e9be145ca308965fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/894b4c64ffdb280a38c1ea2e9be145ca308965fd", "html_url": "https://github.com/rust-lang/rust/commit/894b4c64ffdb280a38c1ea2e9be145ca308965fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/894b4c64ffdb280a38c1ea2e9be145ca308965fd/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d675eda80c5f1eb4a9fe7d374023d71721bf2f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d675eda80c5f1eb4a9fe7d374023d71721bf2f1", "html_url": "https://github.com/rust-lang/rust/commit/7d675eda80c5f1eb4a9fe7d374023d71721bf2f1"}], "stats": {"total": 666, "additions": 597, "deletions": 69}, "files": [{"sha": "f8d2e9baa99fa57c4d6cc09e77c7fd2312755a93", "filename": "crates/hir_ty/src/diagnostics/pattern.rs", "status": "modified", "additions": 597, "deletions": 69, "changes": 666, "blob_url": "https://github.com/rust-lang/rust/blob/894b4c64ffdb280a38c1ea2e9be145ca308965fd/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/894b4c64ffdb280a38c1ea2e9be145ca308965fd/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs?ref=894b4c64ffdb280a38c1ea2e9be145ca308965fd", "patch": "@@ -3,7 +3,7 @@\n //! This module provides lowering from [hir_def::expr::Pat] to [self::Pat] and match\n //! checking algorithm.\n //!\n-//! It is a loose port of `rustc_mir_build::thir::pattern` module.\n+//! It is modeled on the rustc module `rustc_mir_build::thir::pattern`.\n \n mod deconstruct_pat;\n mod pat_util;\n@@ -341,136 +341,636 @@ mod tests {\n     use crate::diagnostics::tests::check_diagnostics;\n \n     #[test]\n-    fn unit() {\n+    fn empty_tuple() {\n         check_diagnostics(\n             r#\"\n fn main() {\n-    match () { () => {} }\n-    match () {  _ => {} }\n-    match () {          }\n+    match () { }\n         //^^ Missing match arm\n+    match (()) { }\n+        //^^^^ Missing match arm\n+\n+    match () { _ => (), }\n+    match () { () => (), }\n+    match (()) { (()) => (), }\n }\n \"#,\n         );\n     }\n \n     #[test]\n-    fn tuple_of_units() {\n+    fn tuple_of_two_empty_tuple() {\n         check_diagnostics(\n             r#\"\n fn main() {\n-    match ((), ()) { ((), ()) => {} }\n-    match ((), ()) {  ((), _) => {} }\n-    match ((), ()) {   (_, _) => {} }\n-    match ((), ()) {        _ => {} }\n-    match ((), ()) {                }\n+    match ((), ()) { }\n         //^^^^^^^^ Missing match arm\n+\n+    match ((), ()) { ((), ()) => (), }\n }\n \"#,\n         );\n     }\n \n     #[test]\n-    fn tuple_with_ellipsis() {\n+    fn boolean() {\n         check_diagnostics(\n             r#\"\n-struct A; struct B;\n-fn main(v: (A, (), B)) {\n-    match v { (A, ..)    => {} }\n-    match v { (.., B)    => {} }\n-    match v { (A, .., B) => {} }\n-    match v { (..)       => {} }\n-    match v {                  }\n-        //^ Missing match arm\n+fn test_main() {\n+    match false { }\n+        //^^^^^ Missing match arm\n+    match false { true => (), }\n+        //^^^^^ Missing match arm\n+    match (false, true) {}\n+        //^^^^^^^^^^^^^ Missing match arm\n+    match (false, true) { (true, true) => (), }\n+        //^^^^^^^^^^^^^ Missing match arm\n+    match (false, true) {\n+        //^^^^^^^^^^^^^ Missing match arm\n+        (false, true) => (),\n+        (false, false) => (),\n+        (true, false) => (),\n+    }\n+    match (false, true) { (true, _x) => (), }\n+        //^^^^^^^^^^^^^ Missing match arm\n+\n+    match false { true => (), false => (), }\n+    match (false, true) {\n+        (false, _) => (),\n+        (true, false) => (),\n+        (_, true) => (),\n+    }\n+    match (false, true) {\n+        (true, true) => (),\n+        (true, false) => (),\n+        (false, true) => (),\n+        (false, false) => (),\n+    }\n+    match (false, true) {\n+        (true, _x) => (),\n+        (false, true) => (),\n+        (false, false) => (),\n+    }\n+    match (false, true, false) {\n+        (false, ..) => (),\n+        (true, ..) => (),\n+    }\n+    match (false, true, false) {\n+        (.., false) => (),\n+        (.., true) => (),\n+    }\n+    match (false, true, false) { (..) => (), }\n }\n \"#,\n         );\n     }\n \n     #[test]\n-    fn strukt() {\n+    fn tuple_of_tuple_and_bools() {\n         check_diagnostics(\n             r#\"\n-struct A; struct B;\n-struct S { a: A, b: B}\n-fn main(v: S) {\n-    match v { S { a, b }       => {} }\n-    match v { S { a: _, b: _ } => {} }\n-    match v { S { .. }         => {} }\n-    match v { _                => {} }\n-    match v {                        }\n-        //^ Missing match arm\n+fn main() {\n+    match (false, ((), false)) {}\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+    match (false, ((), false)) { (true, ((), true)) => (), }\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+    match (false, ((), false)) { (true, _) => (), }\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+\n+    match (false, ((), false)) {\n+        (true, ((), true)) => (),\n+        (true, ((), false)) => (),\n+        (false, ((), true)) => (),\n+        (false, ((), false)) => (),\n+    }\n+    match (false, ((), false)) {\n+        (true, ((), true)) => (),\n+        (true, ((), false)) => (),\n+        (false, _) => (),\n+    }\n }\n \"#,\n         );\n     }\n \n     #[test]\n-    fn c_enum() {\n+    fn enums() {\n         check_diagnostics(\n             r#\"\n-enum E { A, B }\n-fn main(v: E) {\n-    match v { E::A | E::B => {} }\n-    match v { _           => {} }\n-    match v { E::A        => {} }\n+enum Either { A, B, }\n+\n+fn main() {\n+    match Either::A { }\n+        //^^^^^^^^^ Missing match arm\n+    match Either::B { Either::A => (), }\n+        //^^^^^^^^^ Missing match arm\n+\n+    match &Either::B {\n+        //^^^^^^^^^^ Missing match arm\n+        Either::A => (),\n+    }\n+\n+    match Either::B {\n+        Either::A => (), Either::B => (),\n+    }\n+    match &Either::B {\n+        Either::A => (), Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_containing_bool() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B }\n+\n+fn main() {\n+    match Either::B { }\n+        //^^^^^^^^^ Missing match arm\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true) => (), Either::B => ()\n+    }\n+\n+    match Either::B {\n+        Either::A(true) => (),\n+        Either::A(false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        Either::B => (),\n+        _ => (),\n+    }\n+    match Either::B {\n+        Either::A(_) => (),\n+        Either::B => (),\n+    }\n+\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_different_sizes() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B(bool, bool) }\n+\n+fn main() {\n+    match Either::A(false) {\n+        //^^^^^^^^^^^^^^^^ Missing match arm\n+        Either::A(_) => (),\n+        Either::B(false, _) => (),\n+    }\n+\n+    match Either::A(false) {\n+        Either::A(_) => (),\n+        Either::B(true, _) => (),\n+        Either::B(false, _) => (),\n+    }\n+    match Either::A(false) {\n+        Either::A(true) | Either::A(false) => (),\n+        Either::B(true, _) => (),\n+        Either::B(false, _) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_enum_no_diagnostic() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B(bool, bool) }\n+enum Either2 { C, D }\n+\n+fn main() {\n+    match (Either::A(false), Either2::C) {\n+        (Either::A(true), _) | (Either::A(false), _) => (),\n+        (Either::B(true, _), Either2::C) => (),\n+        (Either::B(false, _), Either2::C) => (),\n+        (Either::B(_, _), Either2::D) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn or_pattern_no_diagnostic() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {A, B}\n+\n+fn main() {\n+    match (Either::A, Either::B) {\n+        (Either::A | Either::B, _) => (),\n+    }\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn mismatched_types() {\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B }\n+enum Either2 { C, D }\n+\n+fn main() {\n+    match Either::A {\n+        Either2::C => (),\n+        Either2::D => (),\n+    }\n+    match (true, false) {\n+        (true, false, true) => (),\n+        (true) => (),\n+    }\n+    match (0) { () => () }\n+    match Unresolved::Bar { Unresolved::Baz => () }\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn malformed_match_arm_tuple_enum_missing_pattern() {\n+        // We are testing to be sure we don't panic here when the match\n+        // arm `Either::B` is missing its pattern.\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B(u32) }\n+\n+fn main() {\n+    match Either::A {\n+        Either::A => (),\n+        Either::B() => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn expr_diverges() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B }\n+\n+fn main() {\n+    match loop {} {\n+        Either::A => (),\n+        Either::B => (),\n+    }\n+    match loop {} {\n+        Either::A => (),\n+    }\n+    match loop { break Foo::A } {\n+        //^^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+        Either::A => (),\n+    }\n+    match loop { break Foo::A } {\n+        Either::A => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn expr_partially_diverges() {\n+        check_diagnostics(\n+            r#\"\n+enum Either<T> { A(T), B }\n+\n+fn foo() -> Either<!> { Either::B }\n+fn main() -> u32 {\n+    match foo() {\n+        Either::A(val) => val,\n+        Either::B => 0,\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_record() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A { foo: bool }, B }\n+\n+fn main() {\n+    let a = Either::A { foo: true };\n+    match a { }\n         //^ Missing match arm\n-    match v {                   }\n+    match a { Either::A { foo: true } => () }\n         //^ Missing match arm\n+    match a {\n+        Either::A { } => (),\n+      //^^^^^^^^^ Missing structure fields:\n+      //        | - foo\n+        Either::B => (),\n+    }\n+    match a {\n+        //^ Missing match arm\n+        Either::A { } => (),\n+    } //^^^^^^^^^ Missing structure fields:\n+      //        | - foo\n+\n+    match a {\n+        Either::A { foo: true } => (),\n+        Either::A { foo: false } => (),\n+        Either::B => (),\n+    }\n+    match a {\n+        Either::A { foo: _ } => (),\n+        Either::B => (),\n+    }\n }\n \"#,\n         );\n     }\n \n     #[test]\n-    fn enum_() {\n+    fn enum_record_fields_out_of_order() {\n         check_diagnostics(\n             r#\"\n-struct A; struct B;\n-enum E { Tuple(A, B), Struct{ a: A, b: B } }\n-fn main(v: E) {\n-    match v {\n-        E::Tuple(a, b)    => {}\n-        E::Struct{ a, b } => {}\n-    }\n-    match v {\n-        E::Tuple(_, _) => {}\n-        E::Struct{..}  => {}\n-    }\n-    match v {\n-        E::Tuple(..) => {}\n-        _ => {}\n-    }\n-    match v { E::Tuple(..) => {} }\n+enum Either {\n+    A { foo: bool, bar: () },\n+    B,\n+}\n+\n+fn main() {\n+    let a = Either::A { foo: true, bar: () };\n+    match a {\n         //^ Missing match arm\n-    match v { }\n+        Either::A { bar: (), foo: false } => (),\n+        Either::A { foo: true, bar: () } => (),\n+    }\n+\n+    match a {\n+        Either::A { bar: (), foo: false } => (),\n+        Either::A { foo: true, bar: () } => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_record_ellipsis() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A { foo: bool, bar: bool },\n+    B,\n+}\n+\n+fn main() {\n+    let a = Either::B;\n+    match a {\n+        //^ Missing match arm\n+        Either::A { foo: true, .. } => (),\n+        Either::B => (),\n+    }\n+    match a {\n         //^ Missing match arm\n+        Either::A { .. } => (),\n+    }\n+\n+    match a {\n+        Either::A { foo: true, .. } => (),\n+        Either::A { foo: false, .. } => (),\n+        Either::B => (),\n+    }\n+\n+    match a {\n+        Either::A { .. } => (),\n+        Either::B => (),\n+    }\n }\n \"#,\n         );\n     }\n \n     #[test]\n-    fn boolean() {\n+    fn enum_tuple_partial_ellipsis() {\n         check_diagnostics(\n             r#\"\n+enum Either {\n+    A(bool, bool, bool, bool),\n+    B,\n+}\n+\n fn main() {\n-    match true {\n-        true  => {}\n-        false => {}\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(false, .., false) => (),\n+        Either::B => (),\n     }\n-    match true {\n-        true | false => {}\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(.., true) => (),\n+        Either::B => (),\n     }\n-    match true {\n-        true => {}\n-        _ => {}\n+\n+    match Either::B {\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(false, .., true) => (),\n+        Either::A(false, .., false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(.., true) => (),\n+        Either::A(.., false) => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn never() {\n+        check_diagnostics(\n+            r#\"\n+enum Never {}\n+\n+fn enum_(never: Never) {\n+    match never {}\n+}\n+fn enum_ref(never: &Never) {\n+    match never {}\n+        //^^^^^ Missing match arm\n+}\n+fn bang(never: !) {\n+    match never {}\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unknown_type() {\n+        check_diagnostics(\n+            r#\"\n+enum Option<T> { Some(T), None }\n+\n+fn main() {\n+    // `Never` is deliberately not defined so that it's an uninferred type.\n+    match Option::<Never>::None {\n+        None => (),\n+        Some(never) => match never {},\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (false, true, false) {\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+        (false, ..) => (),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (false, true, false) {\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+        (.., false) => (),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_in_middle_missing_arm() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (false, true, false) {\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+        (true, .., false) => (),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn record_struct() {\n+        check_diagnostics(\n+            r#\"struct Foo { a: bool }\n+fn main(f: Foo) {\n+    match f {}\n+        //^ Missing match arm\n+    match f { Foo { a: true } => () }\n+        //^ Missing match arm\n+    match &f { Foo { a: true } => () }\n+        //^^ Missing match arm\n+    match f { Foo { a: _ } => () }\n+    match f {\n+        Foo { a: true } => (),\n+        Foo { a: false } => (),\n+    }\n+    match &f {\n+        Foo { a: true } => (),\n+        Foo { a: false } => (),\n+    }\n+}\n+\"#,\n+        );\n     }\n-    match true {}\n-        //^^^^ Missing match arm\n-    match true { true => {} }\n-        //^^^^ Missing match arm\n \n+    #[test]\n+    fn tuple_struct() {\n+        check_diagnostics(\n+            r#\"struct Foo(bool);\n+fn main(f: Foo) {\n+    match f {}\n+        //^ Missing match arm\n+    match f { Foo(true) => () }\n+        //^ Missing match arm\n+    match f {\n+        Foo(true) => (),\n+        Foo(false) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unit_struct() {\n+        check_diagnostics(\n+            r#\"struct Foo;\n+fn main(f: Foo) {\n+    match f {}\n+        //^ Missing match arm\n+    match f { Foo => () }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn record_struct_ellipsis() {\n+        check_diagnostics(\n+            r#\"struct Foo { foo: bool, bar: bool }\n+fn main(f: Foo) {\n+    match f { Foo { foo: true, .. } => () }\n+        //^ Missing match arm\n+    match f {\n+        //^ Missing match arm\n+        Foo { foo: true, .. } => (),\n+        Foo { bar: false, .. } => ()\n+    }\n+    match f { Foo { .. } => () }\n+    match f {\n+        Foo { foo: true, .. } => (),\n+        Foo { foo: false, .. } => ()\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn internal_or() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    enum Either { A(bool), B }\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true | false) => (),\n+    }\n }\n \"#,\n         );\n@@ -483,7 +983,7 @@ fn main() {\n struct S { a: char}\n fn main(v: S) {\n     match v { S{ a }      => {} }\n-    match v { S{ a: _x }   => {} }\n+    match v { S{ a: _x }  => {} }\n     match v { S{ a: 'a' } => {} }\n     match v { S{..}       => {} }\n     match v { _           => {} }\n@@ -509,4 +1009,32 @@ fn main() {\n \"#,\n         );\n     }\n+\n+    mod false_negatives {\n+        //! The implementation of match checking here is a work in progress. As we roll this out, we\n+        //! prefer false negatives to false positives (ideally there would be no false positives). This\n+        //! test module should document known false negatives. Eventually we will have a complete\n+        //! implementation of match checking and this module will be empty.\n+        //!\n+        //! The reasons for documenting known false negatives:\n+        //!\n+        //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n+        //!   2. It ensures the code doesn't panic when handling these cases.\n+        use super::*;\n+\n+        #[test]\n+        fn integers() {\n+            // We don't currently check integer exhaustiveness.\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match 5 {\n+        10 => (),\n+        11..20 => (),\n+    }\n+}\n+\"#,\n+            );\n+        }\n+    }\n }"}]}