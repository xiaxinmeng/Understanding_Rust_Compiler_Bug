{"sha": "0101f35f276d0ef1ab841a179d01d0c66a18b38a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMDFmMzVmMjc2ZDBlZjFhYjg0MWExNzlkMDFkMGM2NmExOGIzOGE=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-11T18:22:13Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-20T09:08:57Z"}, "message": "Add BlockedTask (wake, try_block, etc) in kill.rs.", "tree": {"sha": "87fd49199b5bbf97fa3f1b969ac8ade3890af04f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87fd49199b5bbf97fa3f1b969ac8ade3890af04f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0101f35f276d0ef1ab841a179d01d0c66a18b38a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0101f35f276d0ef1ab841a179d01d0c66a18b38a", "html_url": "https://github.com/rust-lang/rust/commit/0101f35f276d0ef1ab841a179d01d0c66a18b38a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0101f35f276d0ef1ab841a179d01d0c66a18b38a/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e80efe3fda506877b3fb7ff0df5d97dffb6a906f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e80efe3fda506877b3fb7ff0df5d97dffb6a906f", "html_url": "https://github.com/rust-lang/rust/commit/e80efe3fda506877b3fb7ff0df5d97dffb6a906f"}], "stats": {"total": 97, "additions": 95, "deletions": 2}, "files": [{"sha": "a3ee40f395fe0b4064e50a0a9d68ef3316096a18", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 95, "deletions": 2, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0101f35f276d0ef1ab841a179d01d0c66a18b38a/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0101f35f276d0ef1ab841a179d01d0c66a18b38a/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=0101f35f276d0ef1ab841a179d01d0c66a18b38a", "patch": "@@ -12,6 +12,7 @@\n \n use cast;\n use cell::Cell;\n+use either::{Either, Left, Right};\n use option::{Option, Some, None};\n use prelude::*;\n use rt::task::Task;\n@@ -26,6 +27,16 @@ static KILL_RUNNING:    uint = 0;\n static KILL_KILLED:     uint = 1;\n static KILL_UNKILLABLE: uint = 2;\n \n+struct KillFlag(AtomicUint);\n+type KillFlagHandle = UnsafeAtomicRcBox<KillFlag>;\n+\n+/// A handle to a blocked task. Usually this means having the ~Task pointer by\n+/// ownership, but if the task is killable, a killer can steal it at any time.\n+pub enum BlockedTask {\n+    Unkillable(~Task),\n+    Killable(KillFlagHandle),\n+}\n+\n // FIXME(#7544)(bblum): think about the cache efficiency of this\n struct KillHandleInner {\n     // Is the task running, blocked, or killed? Possible values:\n@@ -35,7 +46,7 @@ struct KillHandleInner {\n     // This flag is refcounted because it may also be referenced by a blocking\n     // concurrency primitive, used to wake the task normally, whose reference\n     // may outlive the handle's if the task is killed.\n-    killed: UnsafeAtomicRcBox<AtomicUint>,\n+    killed: KillFlagHandle,\n     // Has the task deferred kill signals? This flag guards the above one.\n     // Possible values:\n     // * KILL_RUNNING    - Not unkillable, no kill pending.\n@@ -76,11 +87,93 @@ pub struct Death {\n     wont_sleep:      int,\n }\n \n+impl Drop for KillFlag {\n+    // Letting a KillFlag with a task inside get dropped would leak the task.\n+    // We could free it here, but the task should get awoken by hand somehow.\n+    fn drop(&self) {\n+        match self.load(Acquire) {\n+            KILL_RUNNING | KILL_KILLED => { },\n+            _ => rtabort!(\"can't drop kill flag with a blocked task inside!\"),\n+        }\n+    }\n+}\n+\n+impl BlockedTask {\n+    /// Returns Some if the task was successfully woken; None if already killed.\n+    pub fn wake(self) -> Option<~Task> {\n+        let mut this = self;\n+        match this {\n+            Unkillable(task) => Some(task),\n+            Killable(ref mut flag_arc) => {\n+                let flag = unsafe { &mut **flag_arc.get() };\n+                match flag.swap(KILL_RUNNING, SeqCst) {\n+                    KILL_RUNNING => rtabort!(\"tried to wake an already-running task\"),\n+                    KILL_KILLED  => None, // a killer stole it already\n+                    task_ptr     => Some(unsafe { cast::transmute(task_ptr) }),\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Create a blocked task, unless the task was already killed.\n+    pub fn try_block(task: ~Task) -> Either<~Task, BlockedTask> {\n+        if task.death.unkillable > 0 { // FIXME(#7544): || self.indestructible\n+            Right(Unkillable(task))\n+        } else {\n+            rtassert!(task.death.kill_handle.is_some());\n+            unsafe {\n+                // FIXME(#7544) optimz\n+                let flag_arc = (*task.death.kill_handle.get_ref().get()).killed.clone();\n+                let flag     = &mut **flag_arc.get();\n+                let task_ptr = cast::transmute(task);\n+                // Expect flag to contain RUNNING. If KILLED, it should stay KILLED.\n+                match flag.compare_and_swap(KILL_RUNNING, task_ptr, SeqCst) {\n+                    KILL_RUNNING => Right(Killable(flag_arc)),\n+                    KILL_KILLED  => Left(cast::transmute(task_ptr)),\n+                    x            => rtabort!(\"can't block task! kill flag = %?\", x),\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Convert to an unsafe uint value. Useful for storing in a pipe's state flag.\n+    #[inline]\n+    pub unsafe fn cast_to_uint(self) -> uint {\n+        // Use the low bit to distinguish the enum variants, to save a second\n+        // allocation in the indestructible case.\n+        match self {\n+            Unkillable(task) => {\n+                let blocked_task_ptr: uint = cast::transmute(task);\n+                rtassert!(blocked_task_ptr & 0x1 == 0);\n+                blocked_task_ptr\n+            },\n+            Killable(flag_arc) => {\n+                let blocked_task_ptr: uint = cast::transmute(~flag_arc);\n+                rtassert!(blocked_task_ptr & 0x1 == 0);\n+                blocked_task_ptr | 0x1\n+            }\n+        }\n+    }\n+\n+    /// Convert from an unsafe uint value. Useful for retrieving a pipe's state flag.\n+    #[inline]\n+    pub unsafe fn cast_from_uint(blocked_task_ptr: uint) -> BlockedTask {\n+        if blocked_task_ptr & 0x1 == 0 {\n+            Unkillable(cast::transmute(blocked_task_ptr))\n+        } else {\n+            let ptr: ~KillFlagHandle = cast::transmute(blocked_task_ptr & !0x1);\n+            match ptr {\n+                ~flag_arc => Killable(flag_arc)\n+            }\n+        }\n+    }\n+}\n+\n impl KillHandle {\n     pub fn new() -> KillHandle {\n         KillHandle(UnsafeAtomicRcBox::new(KillHandleInner {\n             // Linked failure fields\n-            killed:     UnsafeAtomicRcBox::new(AtomicUint::new(KILL_RUNNING)),\n+            killed:     UnsafeAtomicRcBox::new(KillFlag(AtomicUint::new(KILL_RUNNING))),\n             unkillable: AtomicUint::new(KILL_RUNNING),\n             // Exit code propagation fields\n             any_child_failed: false,"}]}