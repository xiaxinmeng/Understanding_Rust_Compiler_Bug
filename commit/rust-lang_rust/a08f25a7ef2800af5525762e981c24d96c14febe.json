{"sha": "a08f25a7ef2800af5525762e981c24d96c14febe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwOGYyNWE3ZWYyODAwYWY1NTI1NzYyZTk4MWMyNGQ5NmMxNGZlYmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-14T05:10:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-14T05:10:57Z"}, "message": "Auto merge of #86211 - tlyu:option-result-overviews, r=joshtriplett\n\ncreate method overview docs for core::option and core::result\n\nThe `Option` and `Result` types have large lists of methods. They each could use an overview page of methods grouped by category. These proposed overviews include \"truth tables\" for the underappreciated boolean operators/combinators of these types. The methods are already somewhat categorized in the source, but some logical groupings are broken up by the necessities of putting related methods in different `impl` blocks, for example.\n\nThis is based on #86209, but those are small changes and unlikely to conflict.", "tree": {"sha": "b6fb670eda9a5ec7e8950d81eab730f67914089d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6fb670eda9a5ec7e8950d81eab730f67914089d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a08f25a7ef2800af5525762e981c24d96c14febe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a08f25a7ef2800af5525762e981c24d96c14febe", "html_url": "https://github.com/rust-lang/rust/commit/a08f25a7ef2800af5525762e981c24d96c14febe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a08f25a7ef2800af5525762e981c24d96c14febe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2155386f319d1d17b7b1604a2d6401c98decce9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2155386f319d1d17b7b1604a2d6401c98decce9b", "html_url": "https://github.com/rust-lang/rust/commit/2155386f319d1d17b7b1604a2d6401c98decce9b"}, {"sha": "2b4a6aa1494d80564662271900fa3c73d713411e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b4a6aa1494d80564662271900fa3c73d713411e", "html_url": "https://github.com/rust-lang/rust/commit/2b4a6aa1494d80564662271900fa3c73d713411e"}], "stats": {"total": 588, "additions": 583, "deletions": 5}, "files": [{"sha": "b7af3ea8c1af4e5680cec669f5e88a0884eb4687", "filename": "library/core/src/option.rs", "status": "modified", "additions": 339, "deletions": 5, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/a08f25a7ef2800af5525762e981c24d96c14febe/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f25a7ef2800af5525762e981c24d96c14febe/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=a08f25a7ef2800af5525762e981c24d96c14febe", "patch": "@@ -49,6 +49,8 @@\n //! no \"null\" references. Instead, Rust has *optional* pointers, like\n //! the optional owned box, [`Option`]`<`[`Box<T>`]`>`.\n //!\n+//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n+//!\n //! The following example uses [`Option`] to create an optional box of\n //! [`i32`]. Notice that in order to use the inner [`i32`] value, the\n //! `check_optional` function first needs to use pattern matching to\n@@ -83,13 +85,350 @@\n //! * [`ptr::NonNull<U>`]\n //! * `#[repr(transparent)]` struct around one of the types in this list.\n //!\n+//! [`Box<U>`]: ../../std/boxed/struct.Box.html\n+//! [`num::NonZero*`]: crate::num\n+//! [`ptr::NonNull<U>`]: crate::ptr::NonNull\n+//!\n //! This is called the \"null pointer optimization\" or NPO.\n //!\n //! It is further guaranteed that, for the cases above, one can\n //! [`mem::transmute`] from all valid values of `T` to `Option<T>` and\n //! from `Some::<T>(_)` to `T` (but transmuting `None::<T>` to `T`\n //! is undefined behaviour).\n //!\n+//! # Method overview\n+//!\n+//! In addition to working with pattern matching, [`Option`] provides a wide\n+//! variety of different methods.\n+//!\n+//! ## Querying the variant\n+//!\n+//! The [`is_some`] and [`is_none`] methods return [`true`] if the [`Option`]\n+//! is [`Some`] or [`None`], respectively.\n+//!\n+//! [`is_none`]: Option::is_none\n+//! [`is_some`]: Option::is_some\n+//!\n+//! ## Adapters for working with references\n+//!\n+//! * [`as_ref`] converts from `&Option<T>` to `Option<&T>`\n+//! * [`as_mut`] converts from `&mut Option<T>` to `Option<&mut T>`\n+//! * [`as_deref`] converts from `&Option<T>` to `Option<&T::Target>`\n+//! * [`as_deref_mut`] converts from `&mut Option<T>` to\n+//!   `Option<&mut T::Target>`\n+//! * [`as_pin_ref`] converts from [`Pin`]`<&Option<T>>` to\n+//!   `Option<`[`Pin`]`<&T>>`\n+//! * [`as_pin_mut`] converts from [`Pin`]`<&mut Option<T>>` to\n+//!   `Option<`[`Pin`]`<&mut T>>`\n+//!\n+//! [`as_deref`]: Option::as_deref\n+//! [`as_deref_mut`]: Option::as_deref_mut\n+//! [`as_mut`]: Option::as_mut\n+//! [`as_pin_mut`]: Option::as_pin_mut\n+//! [`as_pin_ref`]: Option::as_pin_ref\n+//! [`as_ref`]: Option::as_ref\n+//!\n+//! ## Extracting the contained value\n+//!\n+//! These methods extract the contained value in an [`Option<T>`] when it\n+//! is the [`Some`] variant. If the [`Option`] is [`None`]:\n+//!\n+//! * [`expect`] panics with a provided custom message\n+//! * [`unwrap`] panics with a generic message\n+//! * [`unwrap_or`] returns the provided default value\n+//! * [`unwrap_or_default`] returns the default value of the type `T`\n+//!   (which must implement the [`Default`] trait)\n+//! * [`unwrap_or_else`] returns the result of evaluating the provided\n+//!   function\n+//!\n+//! [`expect`]: Option::expect\n+//! [`unwrap`]: Option::unwrap\n+//! [`unwrap_or`]: Option::unwrap_or\n+//! [`unwrap_or_default`]: Option::unwrap_or_default\n+//! [`unwrap_or_else`]: Option::unwrap_or_else\n+//!\n+//! ## Transforming contained values\n+//!\n+//! These methods transform [`Option`] to [`Result`]:\n+//!\n+//! * [`ok_or`] transforms [`Some(v)`] to [`Ok(v)`], and [`None`] to\n+//!   [`Err(err)`] using the provided default `err` value\n+//! * [`ok_or_else`] transforms [`Some(v)`] to [`Ok(v)`], and [`None`] to\n+//!   a value of [`Err`] using the provided function\n+//! * [`transpose`] transposes an [`Option`] of a [`Result`] into a\n+//!   [`Result`] of an [`Option`]\n+//!\n+//! [`Err(err)`]: Err\n+//! [`Ok(v)`]: Ok\n+//! [`Some(v)`]: Some\n+//! [`ok_or`]: Option::ok_or\n+//! [`ok_or_else`]: Option::ok_or_else\n+//! [`transpose`]: Option::transpose\n+//!\n+//! These methods transform the [`Some`] variant:\n+//!\n+//! * [`filter`] calls the provided predicate function on the contained\n+//!   value `t` if the [`Option`] is [`Some(t)`], and returns [`Some(t)`]\n+//!   if the function returns `true`; otherwise, returns [`None`]\n+//! * [`flatten`] removes one level of nesting from an\n+//!   [`Option<Option<T>>`]\n+//! * [`map`] transforms [`Option<T>`] to [`Option<U>`] by applying the\n+//!   provided function to the contained value of [`Some`] and leaving\n+//!   [`None`] values unchanged\n+//!\n+//! [`Some(t)`]: Some\n+//! [`filter`]: Option::filter\n+//! [`flatten`]: Option::flatten\n+//! [`map`]: Option::map\n+//!\n+//! These methods transform [`Option<T>`] to a value of a possibly\n+//! different type `U`:\n+//!\n+//! * [`map_or`] applies the provided function to the contained value of\n+//!   [`Some`], or returns the provided default value if the [`Option`] is\n+//!   [`None`]\n+//! * [`map_or_else`] applies the provided function to the contained value\n+//!   of [`Some`], or returns the result of evaluating the provided\n+//!   fallback function if the [`Option`] is [`None`]\n+//!\n+//! [`map_or`]: Option::map_or\n+//! [`map_or_else`]: Option::map_or_else\n+//!\n+//! These methods combine the [`Some`] variants of two [`Option`] values:\n+//!\n+//! * [`zip`] returns [`Some((s, o))`] if `self` is [`Some(s)`] and the\n+//!   provided [`Option`] value is [`Some(o)`]; otherwise, returns [`None`]\n+//! * [`zip_with`] calls the provided function `f` and returns\n+//!   [`Some(f(s, o))`] if `self` is [`Some(s)`] and the provided\n+//!   [`Option`] value is [`Some(o)`]; otherwise, returns [`None`]\n+//!\n+//! [`Some(f(s, o))`]: Some\n+//! [`Some(o)`]: Some\n+//! [`Some(s)`]: Some\n+//! [`Some((s, o))`]: Some\n+//! [`zip`]: Option::zip\n+//! [`zip_with`]: Option::zip_with\n+//!\n+//! ## Boolean operators\n+//!\n+//! These methods treat the [`Option`] as a boolean value, where [`Some`]\n+//! acts like [`true`] and [`None`] acts like [`false`]. There are two\n+//! categories of these methods: ones that take an [`Option`] as input, and\n+//! ones that take a function as input (to be lazily evaluated).\n+//!\n+//! The [`and`], [`or`], and [`xor`] methods take another [`Option`] as\n+//! input, and produce an [`Option`] as output. Only the [`and`] method can\n+//! produce an [`Option<U>`] value having a different inner type `U` than\n+//! [`Option<T>`].\n+//!\n+//! | method  | self      | input     | output    |\n+//! |---------|-----------|-----------|-----------|\n+//! | [`and`] | `None`    | (ignored) | `None`    |\n+//! | [`and`] | `Some(x)` | `None`    | `None`    |\n+//! | [`and`] | `Some(x)` | `Some(y)` | `Some(y)` |\n+//! | [`or`]  | `None`    | `None`    | `None`    |\n+//! | [`or`]  | `None`    | `Some(y)` | `Some(y)` |\n+//! | [`or`]  | `Some(x)` | (ignored) | `Some(x)` |\n+//! | [`xor`] | `None`    | `None`    | `None`    |\n+//! | [`xor`] | `None`    | `Some(y)` | `Some(y)` |\n+//! | [`xor`] | `Some(x)` | `None`    | `Some(x)` |\n+//! | [`xor`] | `Some(x)` | `Some(y)` | `None`    |\n+//!\n+//! [`and`]: Option::and\n+//! [`or`]: Option::or\n+//! [`xor`]: Option::xor\n+//!\n+//! The [`and_then`] and [`or_else`] methods take a function as input, and\n+//! only evaluate the function when they need to produce a new value. Only\n+//! the [`and_then`] method can produce an [`Option<U>`] value having a\n+//! different inner type `U` than [`Option<T>`].\n+//!\n+//! | method       | self      | function input | function result | output    |\n+//! |--------------|-----------|----------------|-----------------|-----------|\n+//! | [`and_then`] | `None`    | (not provided) | (not evaluated) | `None`    |\n+//! | [`and_then`] | `Some(x)` | `x`            | `None`          | `None`    |\n+//! | [`and_then`] | `Some(x)` | `x`            | `Some(y)`       | `Some(y)` |\n+//! | [`or_else`]  | `None`    | (not provided) | `None`          | `None`    |\n+//! | [`or_else`]  | `None`    | (not provided) | `Some(y)`       | `Some(y)` |\n+//! | [`or_else`]  | `Some(x)` | (not provided) | (not evaluated) | `Some(x)` |\n+//!\n+//! [`and_then`]: Option::and_then\n+//! [`or_else`]: Option::or_else\n+//!\n+//! This is an example of using methods like [`and_then`] and [`or`] in a\n+//! pipeline of method calls. Early stages of the pipeline pass failure\n+//! values ([`None`]) through unchanged, and continue processing on\n+//! success values ([`Some`]). Toward the end, [`or`] substitutes an error\n+//! message if it receives [`None`].\n+//!\n+//! ```\n+//! # use std::collections::BTreeMap;\n+//! let mut bt = BTreeMap::new();\n+//! bt.insert(20u8, \"foo\");\n+//! bt.insert(42u8, \"bar\");\n+//! let res = vec![0u8, 1, 11, 200, 22]\n+//!     .into_iter()\n+//!     .map(|x| {\n+//!         // `checked_sub()` returns `None` on error\n+//!         x.checked_sub(1)\n+//!             // same with `checked_mul()`\n+//!             .and_then(|x| x.checked_mul(2))\n+//!             // `BTreeMap::get` returns `None` on error\n+//!             .and_then(|x| bt.get(&x))\n+//!             // Substitute an error message if we have `None` so far\n+//!             .or(Some(&\"error!\"))\n+//!             .copied()\n+//!             // Won't panic because we unconditionally used `Some` above\n+//!             .unwrap()\n+//!     })\n+//!     .collect::<Vec<_>>();\n+//! assert_eq!(res, [\"error!\", \"error!\", \"foo\", \"error!\", \"bar\"]);\n+//! ```\n+//!\n+//! ## Iterating over `Option`\n+//!\n+//! An [`Option`] can be iterated over. This can be helpful if you need an\n+//! iterator that is conditionally empty. The iterator will either produce\n+//! a single value (when the [`Option`] is [`Some`]), or produce no values\n+//! (when the [`Option`] is [`None`]). For example, [`into_iter`] acts like\n+//! [`once(v)`] if the [`Option`] is [`Some(v)`], and like [`empty()`] if\n+//! the [`Option`] is [`None`].\n+//!\n+//! [`Some(v)`]: Some\n+//! [`empty()`]: crate::iter::empty\n+//! [`once(v)`]: crate::iter::once\n+//!\n+//! Iterators over [`Option<T>`] come in three types:\n+//!\n+//! * [`into_iter`] consumes the [`Option`] and produces the contained\n+//!   value\n+//! * [`iter`] produces an immutable reference of type `&T` to the\n+//!   contained value\n+//! * [`iter_mut`] produces a mutable reference of type `&mut T` to the\n+//!   contained value\n+//!\n+//! [`into_iter`]: Option::into_iter\n+//! [`iter`]: Option::iter\n+//! [`iter_mut`]: Option::iter_mut\n+//!\n+//! An iterator over [`Option`] can be useful when chaining iterators, for\n+//! example, to conditionally insert items. (It's not always necessary to\n+//! explicitly call an iterator constructor: many [`Iterator`] methods that\n+//! accept other iterators will also accept iterable types that implement\n+//! [`IntoIterator`], which includes [`Option`].)\n+//!\n+//! ```\n+//! let yep = Some(42);\n+//! let nope = None;\n+//! // chain() already calls into_iter(), so we don't have to do so\n+//! let nums: Vec<i32> = (0..4).chain(yep).chain(4..8).collect();\n+//! assert_eq!(nums, [0, 1, 2, 3, 42, 4, 5, 6, 7]);\n+//! let nums: Vec<i32> = (0..4).chain(nope).chain(4..8).collect();\n+//! assert_eq!(nums, [0, 1, 2, 3, 4, 5, 6, 7]);\n+//! ```\n+//!\n+//! One reason to chain iterators in this way is that a function returning\n+//! `impl Iterator` must have all possible return values be of the same\n+//! concrete type. Chaining an iterated [`Option`] can help with that.\n+//!\n+//! ```\n+//! fn make_iter(do_insert: bool) -> impl Iterator<Item = i32> {\n+//!     // Explicit returns to illustrate return types matching\n+//!     match do_insert {\n+//!         true => return (0..4).chain(Some(42)).chain(4..8),\n+//!         false => return (0..4).chain(None).chain(4..8),\n+//!     }\n+//! }\n+//! println!(\"{:?}\", make_iter(true).collect::<Vec<_>>());\n+//! println!(\"{:?}\", make_iter(false).collect::<Vec<_>>());\n+//! ```\n+//!\n+//! If we try to do the same thing, but using [`once()`] and [`empty()`],\n+//! we can't return `impl Iterator` anymore because the concrete types of\n+//! the return values differ.\n+//!\n+//! [`empty()`]: crate::iter::empty\n+//! [`once()`]: crate::iter::once\n+//!\n+//! ```compile_fail,E0308\n+//! # use std::iter::{empty, once};\n+//! // This won't compile because all possible returns from the function\n+//! // must have the same concrete type.\n+//! fn make_iter(do_insert: bool) -> impl Iterator<Item = i32> {\n+//!     // Explicit returns to illustrate return types not matching\n+//!     match x {\n+//!         true => return (0..4).chain(once(42)).chain(4..8),\n+//!         false => return (0..4).chain(empty()).chain(4..8),\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! ## Collecting into `Option`\n+//!\n+//! [`Option`] implements the [`FromIterator`][impl-FromIterator] trait,\n+//! which allows an iterator over [`Option`] values to be collected into an\n+//! [`Option`] of a collection of each contained value of the original\n+//! [`Option`] values, or [`None`] if any of the elements was [`None`].\n+//!\n+//! [impl-FromIterator]: Option#impl-FromIterator%3COption%3CA%3E%3E\n+//!\n+//! ```\n+//! let v = vec![Some(2), Some(4), None, Some(8)];\n+//! let res: Option<Vec<_>> = v.into_iter().collect();\n+//! assert_eq!(res, None);\n+//! let v = vec![Some(2), Some(4), Some(8)];\n+//! let res: Option<Vec<_>> = v.into_iter().collect();\n+//! assert_eq!(res, Some(vec![2, 4, 8]));\n+//! ```\n+//!\n+//! [`Option`] also implements the [`Product`][impl-Product] and\n+//! [`Sum`][impl-Sum] traits, allowing an iterator over [`Option`] values\n+//! to provide the [`product`][Iterator::product] and\n+//! [`sum`][Iterator::sum] methods.\n+//!\n+//! [impl-Product]: Option#impl-Product%3COption%3CU%3E%3E\n+//! [impl-Sum]: Option#impl-Sum%3COption%3CU%3E%3E\n+//!\n+//! ```\n+//! let v = vec![None, Some(1), Some(2), Some(3)];\n+//! let res: Option<i32> = v.into_iter().sum();\n+//! assert_eq!(res, None);\n+//! let v = vec![Some(1), Some(2), Some(21)];\n+//! let res: Option<i32> = v.into_iter().product();\n+//! assert_eq!(res, Some(42));\n+//! ```\n+//!\n+//! ## Modifying an [`Option`] in-place\n+//!\n+//! These methods return a mutable reference to the contained value of an\n+//! [`Option<T>`]:\n+//!\n+//! * [`insert`] inserts a value, dropping any old contents\n+//! * [`get_or_insert`] gets the current value, inserting a provided\n+//!   default value if it is [`None`]\n+//! * [`get_or_insert_default`] gets the current value, inserting the\n+//!   default value of type `T` (which must implement [`Default`]) if it is\n+//!   [`None`]\n+//! * [`get_or_insert_with`] gets the current value, inserting a default\n+//!   computed by the provided function if it is [`None`]\n+//!\n+//! [`get_or_insert`]: Option::get_or_insert\n+//! [`get_or_insert_default`]: Option::get_or_insert_default\n+//! [`get_or_insert_with`]: Option::get_or_insert_with\n+//! [`insert`]: Option::insert\n+//!\n+//! These methods transfer ownership of the contained value of an\n+//! [`Option`]:\n+//!\n+//! * [`take`] takes ownership of the contained value of an [`Option`], if\n+//!   any, replacing the [`Option`] with [`None`]\n+//! * [`replace`] takes ownership of the contained value of an [`Option`],\n+//!   if any, replacing the [`Option`] with a [`Some`] containing the\n+//!   provided value\n+//!\n+//! [`replace`]: Option::replace\n+//! [`take`]: Option::take\n+//!\n //! # Examples\n //!\n //! Basic pattern matching on [`Option`]:\n@@ -141,11 +480,6 @@\n //!     None => println!(\"there are no animals :(\"),\n //! }\n //! ```\n-//!\n-//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n-//! [`Box<U>`]: ../../std/boxed/struct.Box.html\n-//! [`num::NonZero*`]: crate::num\n-//! [`ptr::NonNull<U>`]: crate::ptr::NonNull\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "53aaa5219b1d4c0b3b8c6f219f85723dcccc35b5", "filename": "library/core/src/result.rs", "status": "modified", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/a08f25a7ef2800af5525762e981c24d96c14febe/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08f25a7ef2800af5525762e981c24d96c14febe/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=a08f25a7ef2800af5525762e981c24d96c14febe", "patch": "@@ -224,6 +224,250 @@\n //! [`Ok(T)`]: Ok\n //! [`Err(E)`]: Err\n //! [`io::Error`]: ../../std/io/struct.Error.html\n+//!\n+//! # Method overview\n+//!\n+//! In addition to working with pattern matching, [`Result`] provides a\n+//! wide variety of different methods.\n+//!\n+//! ## Querying the variant\n+//!\n+//! The [`is_ok`] and [`is_err`] methods return [`true`] if the [`Result`]\n+//! is [`Ok`] or [`Err`], respectively.\n+//!\n+//! [`is_err`]: Result::is_err\n+//! [`is_ok`]: Result::is_ok\n+//!\n+//! ## Adapters for working with references\n+//!\n+//! * [`as_ref`] converts from `&Result<T, E>` to `Result<&T, &E>`\n+//! * [`as_mut`] converts from `&mut Result<T, E>` to `Result<&mut T, &mut E>`\n+//! * [`as_deref`] converts from `&Result<T, E>` to `Result<&T::Target, &E>`\n+//! * [`as_deref_mut`] converts from `&mut Result<T, E>` to\n+//!   `Result<&mut T::Target, &mut E>`\n+//!\n+//! [`as_deref`]: Result::as_deref\n+//! [`as_deref_mut`]: Result::as_deref_mut\n+//! [`as_mut`]: Result::as_mut\n+//! [`as_ref`]: Result::as_ref\n+//!\n+//! ## Extracting contained values\n+//!\n+//! These methods extract the contained value in a [`Result<T, E>`] when it\n+//! is the [`Ok`] variant. If the [`Result`] is [`Err`]:\n+//!\n+//! * [`expect`] panics with a provided custom message\n+//! * [`unwrap`] panics with a generic message\n+//! * [`unwrap_or`] returns the provided default value\n+//! * [`unwrap_or_default`] returns the default value of the type `T`\n+//!   (which must implement the [`Default`] trait)\n+//! * [`unwrap_or_else`] returns the result of evaluating the provided\n+//!   function\n+//!\n+//! The panicking methods [`expect`] and [`unwrap`] require `E` to\n+//! implement the [`Debug`] trait.\n+//!\n+//! [`Debug`]: crate::fmt::Debug\n+//! [`expect`]: Result::expect\n+//! [`unwrap`]: Result::unwrap\n+//! [`unwrap_or`]: Result::unwrap_or\n+//! [`unwrap_or_default`]: Result::unwrap_or_default\n+//! [`unwrap_or_else`]: Result::unwrap_or_else\n+//!\n+//! These methods extract the contained value in a [`Result<T, E>`] when it\n+//! is the [`Err`] variant. They require `T` to implement the [`Debug`]\n+//! trait. If the [`Result`] is [`Ok`]:\n+//!\n+//! * [`expect_err`] panics with a provided custom message\n+//! * [`unwrap_err`] panics with a generic message\n+//!\n+//! [`Debug`]: crate::fmt::Debug\n+//! [`expect_err`]: Result::expect_err\n+//! [`unwrap_err`]: Result::unwrap_err\n+//!\n+//! ## Transforming contained values\n+//!\n+//! These methods transform [`Result`] to [`Option`]:\n+//!\n+//! * [`err`][Result::err] transforms [`Result<T, E>`] into [`Option<E>`],\n+//!   mapping [`Err(e)`] to [`Some(e)`] and [`Ok(v)`] to [`None`]\n+//! * [`ok`][Result::ok] transforms [`Result<T, E>`] into [`Option<T>`],\n+//!   mapping [`Ok(v)`] to [`Some(v)`] and [`Err(e)`] to [`None`]\n+//! * [`transpose`] transposes a [`Result`] of an [`Option`] into an\n+//!   [`Option`] of a [`Result`]\n+//!\n+// Do NOT add link reference definitions for `err` or `ok`, because they\n+// will generate numerous incorrect URLs for `Err` and `Ok` elsewhere, due\n+// to case folding.\n+//!\n+//! [`Err(e)`]: Err\n+//! [`Ok(v)`]: Ok\n+//! [`Some(e)`]: Option::Some\n+//! [`Some(v)`]: Option::Some\n+//! [`transpose`]: Result::transpose\n+//!\n+//! This method transforms the contained value of the [`Ok`] variant:\n+//!\n+//! * [`map`] transforms [`Result<T, E>`] into [`Result<U, E>`] by applying\n+//!   the provided function to the contained value of [`Ok`] and leaving\n+//!   [`Err`] values unchanged\n+//!\n+//! [`map`]: Result::map\n+//!\n+//! This method transforms the contained value of the [`Err`] variant:\n+//!\n+//! * [`map_err`] transforms [`Result<T, E>`] into [`Result<T, F>`] by\n+//!   applying the provided function to the contained value of [`Err`] and\n+//!   leaving [`Ok`] values unchanged\n+//!\n+//! [`map_err`]: Result::map_err\n+//!\n+//! These methods transform a [`Result<T, E>`] into a value of a possibly\n+//! different type `U`:\n+//!\n+//! * [`map_or`] applies the provided function to the contained value of\n+//!   [`Ok`], or returns the provided default value if the [`Result`] is\n+//!   [`Err`]\n+//! * [`map_or_else`] applies the provided function to the contained value\n+//!   of [`Ok`], or applies the provided fallback function to the contained\n+//!   value of [`Err`]\n+//!\n+//! [`map_or`]: Result::map_or\n+//! [`map_or_else`]: Result::map_or_else\n+//!\n+//! ## Boolean operators\n+//!\n+//! These methods treat the [`Result`] as a boolean value, where [`Ok`]\n+//! acts like [`true`] and [`Err`] acts like [`false`]. There are two\n+//! categories of these methods: ones that take a [`Result`] as input, and\n+//! ones that take a function as input (to be lazily evaluated).\n+//!\n+//! The [`and`] and [`or`] methods take another [`Result`] as input, and\n+//! produce a [`Result`] as output. The [`and`] method can produce a\n+//! [`Result<U, E>`] value having a different inner type `U` than\n+//! [`Result<T, E>`]. The [`or`] method can produce a [`Result<T, F>`]\n+//! value having a different error type `F` than [`Result<T, E>`].\n+//!\n+//! | method  | self     | input     | output   |\n+//! |---------|----------|-----------|----------|\n+//! | [`and`] | `Err(e)` | (ignored) | `Err(e)` |\n+//! | [`and`] | `Ok(x)`  | `Err(d)`  | `Err(d)` |\n+//! | [`and`] | `Ok(x)`  | `Ok(y)`   | `Ok(y)`  |\n+//! | [`or`]  | `Err(e)` | `Err(d)`  | `Err(d)` |\n+//! | [`or`]  | `Err(e)` | `Ok(y)`   | `Ok(y)`  |\n+//! | [`or`]  | `Ok(x)`  | (ignored) | `Ok(x)`  |\n+//!\n+//! [`and`]: Result::and\n+//! [`or`]: Result::or\n+//!\n+//! The [`and_then`] and [`or_else`] methods take a function as input, and\n+//! only evaluate the function when they need to produce a new value. The\n+//! [`and_then`] method can produce a [`Result<U, E>`] value having a\n+//! different inner type `U` than [`Result<T, E>`]. The [`or_else`] method\n+//! can produce a [`Result<T, F>`] value having a different error type `F`\n+//! than [`Result<T, E>`].\n+//!\n+//! | method       | self     | function input | function result | output   |\n+//! |--------------|----------|----------------|-----------------|----------|\n+//! | [`and_then`] | `Err(e)` | (not provided) | (not evaluated) | `Err(e)` |\n+//! | [`and_then`] | `Ok(x)`  | `x`            | `Err(d)`        | `Err(d)` |\n+//! | [`and_then`] | `Ok(x)`  | `x`            | `Ok(y)`         | `Ok(y)`  |\n+//! | [`or_else`]  | `Err(e)` | `e`            | `Err(d)`        | `Err(d)` |\n+//! | [`or_else`]  | `Err(e)` | `e`            | `Ok(y)`         | `Ok(y)`  |\n+//! | [`or_else`]  | `Ok(x)`  | (not provided) | (not evaluated) | `Ok(x)`  |\n+//!\n+//! [`and_then`]: Result::and_then\n+//! [`or_else`]: Result::or_else\n+//!\n+//! ## Iterating over `Result`\n+//!\n+//! A [`Result`] can be iterated over. This can be helpful if you need an\n+//! iterator that is conditionally empty. The iterator will either produce\n+//! a single value (when the [`Result`] is [`Ok`]), or produce no values\n+//! (when the [`Result`] is [`Err`]). For example, [`into_iter`] acts like\n+//! [`once(v)`] if the [`Result`] is [`Ok(v)`], and like [`empty()`] if the\n+//! [`Result`] is [`Err`].\n+//!\n+//! [`Ok(v)`]: Ok\n+//! [`empty()`]: crate::iter::empty\n+//! [`once(v)`]: crate::iter::once\n+//!\n+//! Iterators over [`Result<T, E>`] come in three types:\n+//!\n+//! * [`into_iter`] consumes the [`Result`] and produces the contained\n+//!   value\n+//! * [`iter`] produces an immutable reference of type `&T` to the\n+//!   contained value\n+//! * [`iter_mut`] produces a mutable reference of type `&mut T` to the\n+//!   contained value\n+//!\n+//! See [Iterating over `Option`] for examples of how this can be useful.\n+//!\n+//! [Iterating over `Option`]: crate::option#iterating-over-option\n+//! [`into_iter`]: Result::into_iter\n+//! [`iter`]: Result::iter\n+//! [`iter_mut`]: Result::iter_mut\n+//!\n+//! You might want to use an iterator chain to do multiple instances of an\n+//! operation that can fail, but would like to ignore failures while\n+//! continuing to process the successful results. In this example, we take\n+//! advantage of the iterable nature of [`Result`] to select only the\n+//! [`Ok`] values using [`flatten`][Iterator::flatten].\n+//!\n+//! ```\n+//! # use std::str::FromStr;\n+//! let mut results = vec![];\n+//! let mut errs = vec![];\n+//! let nums: Vec<_> = vec![\"17\", \"not a number\", \"99\", \"-27\", \"768\"]\n+//!    .into_iter()\n+//!    .map(u8::from_str)\n+//!    // Save clones of the raw `Result` values to inspect\n+//!    .inspect(|x| results.push(x.clone()))\n+//!    // Challenge: explain how this captures only the `Err` values\n+//!    .inspect(|x| errs.extend(x.clone().err()))\n+//!    .flatten()\n+//!    .collect();\n+//! assert_eq!(errs.len(), 3);\n+//! assert_eq!(nums, [17, 99]);\n+//! println!(\"results {:?}\", results);\n+//! println!(\"errs {:?}\", errs);\n+//! println!(\"nums {:?}\", nums);\n+//! ```\n+//!\n+//! ## Collecting into `Result`\n+//!\n+//! [`Result`] implements the [`FromIterator`][impl-FromIterator] trait,\n+//! which allows an iterator over [`Result`] values to be collected into a\n+//! [`Result`] of a collection of each contained value of the original\n+//! [`Result`] values, or [`Err`] if any of the elements was [`Err`].\n+//!\n+//! [impl-FromIterator]: Result#impl-FromIterator%3CResult%3CA%2C%20E%3E%3E\n+//!\n+//! ```\n+//! let v = vec![Ok(2), Ok(4), Err(\"err!\"), Ok(8)];\n+//! let res: Result<Vec<_>, &str> = v.into_iter().collect();\n+//! assert_eq!(res, Err(\"err!\"));\n+//! let v = vec![Ok(2), Ok(4), Ok(8)];\n+//! let res: Result<Vec<_>, &str> = v.into_iter().collect();\n+//! assert_eq!(res, Ok(vec![2, 4, 8]));\n+//! ```\n+//!\n+//! [`Result`] also implements the [`Product`][impl-Product] and\n+//! [`Sum`][impl-Sum] traits, allowing an iterator over [`Result`] values\n+//! to provide the [`product`][Iterator::product] and\n+//! [`sum`][Iterator::sum] methods.\n+//!\n+//! [impl-Product]: Result#impl-Product%3CResult%3CU%2C%20E%3E%3E\n+//! [impl-Sum]: Result#impl-Sum%3CResult%3CU%2C%20E%3E%3E\n+//!\n+//! ```\n+//! let v = vec![Err(\"error!\"), Ok(1), Ok(2), Ok(3), Err(\"foo\")];\n+//! let res: Result<i32, &str> = v.into_iter().sum();\n+//! assert_eq!(res, Err(\"error!\"));\n+//! let v: Vec<Result<i32, &str>> = vec![Ok(1), Ok(2), Ok(21)];\n+//! let res: Result<i32, &str> = v.into_iter().product();\n+//! assert_eq!(res, Ok(42));\n+//! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}