{"sha": "3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjZjBmYmVlZTliNmU5MGRlNmU3ZDQ0YWI5NDYxOTYzNzI5ZjAzNjU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-11T18:37:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-19T08:29:30Z"}, "message": "Create distinct types for a PolyTraitRef (with bindings) and a normal TraitRef.", "tree": {"sha": "f5b60f24fa9c2f3457b94cf40067d94985a1461d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5b60f24fa9c2f3457b94cf40067d94985a1461d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "html_url": "https://github.com/rust-lang/rust/commit/3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3dcb85404aabd66a5765bb99aa46e24acede4dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3dcb85404aabd66a5765bb99aa46e24acede4dc", "html_url": "https://github.com/rust-lang/rust/commit/b3dcb85404aabd66a5765bb99aa46e24acede4dc"}], "stats": {"total": 985, "additions": 516, "deletions": 469}, "files": [{"sha": "ca8eee847d3f9352af5607dd007dd77961c79ccd", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -1785,7 +1785,7 @@ impl LintPass for Stability {\n                                 ..\n                             }) => {\n                                 ty::trait_item(cx.tcx,\n-                                               trait_ref.def_id,\n+                                               trait_ref.def_id(),\n                                                index).def_id()\n                             }\n                         }"}, {"sha": "1a1c810b2781410d7d0ae70985e696d7dbfb969c", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -262,7 +262,7 @@ pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n // if there is one.\n pub fn get_impl_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             def: ast::DefId)\n-                            -> Option<Rc<ty::TraitRef<'tcx>>> {\n+                            -> Option<Rc<ty::PolyTraitRef<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_trait(&*cdata, def.node, tcx)"}, {"sha": "1b3a6c0e6ba39d0ad164ea946a18eee991198ce0", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -425,11 +425,11 @@ pub fn get_repr_attrs(cdata: Cmd, id: ast::NodeId) -> Vec<attr::ReprAttr> {\n pub fn get_impl_trait<'tcx>(cdata: Cmd,\n                             id: ast::NodeId,\n                             tcx: &ty::ctxt<'tcx>)\n-                            -> Option<Rc<ty::TraitRef<'tcx>>>\n+                            -> Option<Rc<ty::PolyTraitRef<'tcx>>>\n {\n     let item_doc = lookup_item(id, cdata.data());\n     reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n-        Rc::new(doc_trait_ref(tp, tcx, cdata))\n+        Rc::new(ty::bind(doc_trait_ref(tp, tcx, cdata)))\n     })\n }\n "}, {"sha": "3d0b63139e4bc312dd9f08a19220dc397065471f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -414,7 +414,7 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n       }\n       'x' => {\n         assert_eq!(next(st), '[');\n-        let trait_ref = parse_trait_ref(st, |x,y| conv(x,y));\n+        let trait_ref = ty::bind(parse_trait_ref(st, |x,y| conv(x,y)));\n         let bounds = parse_existential_bounds(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n         return ty::mk_trait(st.tcx, trait_ref, bounds);\n@@ -669,7 +669,7 @@ pub fn parse_predicate<'a,'tcx>(st: &mut PState<'a, 'tcx>,\n                                 -> ty::Predicate<'tcx>\n {\n     match next(st) {\n-        't' => ty::Predicate::Trait(Rc::new(parse_trait_ref(st, conv))),\n+        't' => ty::Predicate::Trait(Rc::new(ty::bind(parse_trait_ref(st, conv)))),\n         'e' => ty::Predicate::Equate(parse_ty(st, |x,y| conv(x,y)),\n                                      parse_ty(st, |x,y| conv(x,y))),\n         'r' => ty::Predicate::RegionOutlives(parse_region(st, |x,y| conv(x,y)),\n@@ -759,10 +759,12 @@ fn parse_bounds<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n     loop {\n         match next(st) {\n             'R' => {\n-                param_bounds.region_bounds.push(parse_region(st, |x, y| conv (x, y)));\n+                param_bounds.region_bounds.push(\n+                    parse_region(st, |x, y| conv (x, y)));\n             }\n             'I' => {\n-                param_bounds.trait_bounds.push(Rc::new(parse_trait_ref(st, |x,y| conv(x,y))));\n+                param_bounds.trait_bounds.push(\n+                    Rc::new(ty::bind(parse_trait_ref(st, |x,y| conv(x,y)))));\n             }\n             '.' => {\n                 return param_bounds;"}, {"sha": "fd13ea57e6be0d2814e3af67290e41e8e727fb58", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -251,7 +251,7 @@ fn enc_sty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n         ty::ty_trait(box ty::TyTrait { ref principal,\n                                        ref bounds }) => {\n             mywrite!(w, \"x[\");\n-            enc_trait_ref(w, cx, principal);\n+            enc_trait_ref(w, cx, &principal.value);\n             enc_existential_bounds(w, cx, bounds);\n             mywrite!(w, \"]\");\n         }\n@@ -401,7 +401,7 @@ pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n \n     for tp in bs.trait_bounds.iter() {\n         mywrite!(w, \"I\");\n-        enc_trait_ref(w, cx, &**tp);\n+        enc_trait_ref(w, cx, &tp.value);\n     }\n \n     mywrite!(w, \".\");\n@@ -425,7 +425,7 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n     match *p {\n         ty::Predicate::Trait(ref trait_ref) => {\n             mywrite!(w, \"t\");\n-            enc_trait_ref(w, cx, &**trait_ref);\n+            enc_trait_ref(w, cx, &trait_ref.value);\n         }\n         ty::Predicate::Equate(a, b) => {\n             mywrite!(w, \"e\");"}, {"sha": "3f0e28589fc5467354db55bfda1096271d434dcf", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -887,7 +887,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_enum_variant(\"MethodTypeParam\", 2, 1, |this| {\n                         this.emit_struct(\"MethodParam\", 2, |this| {\n                             try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &*p.trait_ref))\n+                                Ok(this.emit_trait_ref(ecx, &p.trait_ref.value))\n                             }));\n                             try!(this.emit_struct_field(\"method_num\", 0, |this| {\n                                 this.emit_uint(p.method_num)\n@@ -901,7 +901,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_enum_variant(\"MethodTraitObject\", 3, 1, |this| {\n                         this.emit_struct(\"MethodObject\", 2, |this| {\n                             try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &*o.trait_ref))\n+                                Ok(this.emit_trait_ref(ecx, &o.trait_ref.value))\n                             }));\n                             try!(this.emit_struct_field(\"object_trait_id\", 0, |this| {\n                                 Ok(this.emit_def_id(o.object_trait_id))\n@@ -1113,7 +1113,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_enum_variant(\"UnsizeVtable\", 2, 4, |this| {\n                         this.emit_enum_variant_arg(0, |this| {\n                             try!(this.emit_struct_field(\"principal\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &*principal))\n+                                Ok(this.emit_trait_ref(ecx, &principal.value))\n                             }));\n                             this.emit_struct_field(\"bounds\", 1, |this| {\n                                 Ok(this.emit_existential_bounds(ecx, b))\n@@ -1277,7 +1277,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         rbml_w.tag(c::tag_table_object_cast_map, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_trait_ref(ecx, &**trait_ref);\n+                rbml_w.emit_trait_ref(ecx, &trait_ref.value);\n             })\n         })\n     }\n@@ -1356,6 +1356,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n     fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Vec<Ty<'tcx>>;\n     fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                               -> Rc<ty::TraitRef<'tcx>>;\n+    fn read_poly_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                   -> Rc<ty::PolyTraitRef<'tcx>>;\n     fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> ty::TypeParameterDef<'tcx>;\n     fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1455,7 +1457,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                 ty::MethodParam {\n                                     trait_ref: {\n                                         this.read_struct_field(\"trait_ref\", 0, |this| {\n-                                            Ok(this.read_trait_ref(dcx))\n+                                            Ok(this.read_poly_trait_ref(dcx))\n                                         }).unwrap()\n                                     },\n                                     method_num: {\n@@ -1473,7 +1475,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                 ty::MethodObject {\n                                     trait_ref: {\n                                         this.read_struct_field(\"trait_ref\", 0, |this| {\n-                                            Ok(this.read_trait_ref(dcx))\n+                                            Ok(this.read_poly_trait_ref(dcx))\n                                         }).unwrap()\n                                     },\n                                     object_trait_id: {\n@@ -1548,6 +1550,19 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap())\n     }\n \n+    fn read_poly_trait_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n+                                   -> Rc<ty::PolyTraitRef<'tcx>> {\n+        Rc::new(ty::bind(self.read_opaque(|this, doc| {\n+            let ty = tydecode::parse_trait_ref_data(\n+                doc.data,\n+                dcx.cdata.cnum,\n+                doc.start,\n+                dcx.tcx,\n+                |s, a| this.convert_def_id(dcx, s, a));\n+            Ok(ty)\n+        }).unwrap()))\n+    }\n+\n     fn read_type_param_def<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                    -> ty::TypeParameterDef<'tcx> {\n         self.read_opaque(|this, doc| {\n@@ -1753,7 +1768,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                     2 => {\n                         let ty_trait = try!(this.read_enum_variant_arg(0, |this| {\n                             let principal = try!(this.read_struct_field(\"principal\", 0, |this| {\n-                                Ok(this.read_trait_ref(dcx))\n+                                Ok(this.read_poly_trait_ref(dcx))\n                             }));\n                             Ok(ty::TyTrait {\n                                 principal: (*principal).clone(),\n@@ -1926,7 +1941,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         dcx.tcx.method_map.borrow_mut().insert(method_call, method);\n                     }\n                     c::tag_table_object_cast_map => {\n-                        let trait_ref = val_dsr.read_trait_ref(dcx);\n+                        let trait_ref = val_dsr.read_poly_trait_ref(dcx);\n                         dcx.tcx.object_cast_map.borrow_mut()\n                                                .insert(id, trait_ref);\n                     }"}, {"sha": "af2be6e088dd530570282acf64a7d48fba41063d", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -31,7 +31,6 @@ use middle::infer;\n use middle::traits;\n use middle::mem_categorization as mc;\n use middle::expr_use_visitor as euv;\n-use util::common::ErrorReported;\n use util::nodemap::NodeSet;\n \n use syntax::ast;\n@@ -122,17 +121,12 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n         let ty = ty::node_id_to_type(self.tcx, e.id);\n         let infcx = infer::new_infer_ctxt(self.tcx);\n         let mut fulfill_cx = traits::FulfillmentContext::new();\n-        match traits::trait_ref_for_builtin_bound(self.tcx, ty::BoundSync, ty) {\n-            Ok(trait_ref) => {\n-                fulfill_cx.register_trait_ref(self.tcx, trait_ref,\n-                                              traits::ObligationCause::dummy());\n-                let env = ty::empty_parameter_environment();\n-                if !fulfill_cx.select_all_or_error(&infcx, &env, self.tcx).is_ok() {\n-                    self.tcx.sess.span_err(e.span, \"shared static items must have a \\\n-                                                    type which implements Sync\");\n-                }\n-            }\n-            Err(ErrorReported) => { }\n+        fulfill_cx.register_builtin_bound(self.tcx, ty, ty::BoundSync,\n+                                          traits::ObligationCause::dummy());\n+        let env = ty::empty_parameter_environment();\n+        if !fulfill_cx.select_all_or_error(&infcx, &env, self.tcx).is_ok() {\n+            self.tcx.sess.span_err(e.span, \"shared static items must have a \\\n+                                            type which implements Sync\");\n         }\n     }\n }"}, {"sha": "46c4de5c35ed0286dcb8a052f73407bc5dddfb68", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                         ..\n                     }) => {\n                         let trait_item = ty::trait_item(self.tcx,\n-                                                        trait_ref.def_id,\n+                                                        trait_ref.def_id(),\n                                                         index);\n                         match trait_item {\n                             ty::MethodTraitItem(method) => {"}, {"sha": "41020df63995e3d3efc2340fa04b0aab056af580", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -265,7 +265,7 @@ impl OverloadedCallType {\n             }\n             Some(ref trait_ref) => (*trait_ref).clone(),\n         };\n-        OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n+        OverloadedCallType::from_trait_id(tcx, trait_ref.value.def_id)\n     }\n \n     fn from_unboxed_closure(tcx: &ty::ctxt, closure_did: ast::DefId)\n@@ -292,7 +292,7 @@ impl OverloadedCallType {\n             }\n             MethodTypeParam(MethodParam { ref trait_ref, .. }) |\n             MethodTraitObject(MethodObject { ref trait_ref, .. }) => {\n-                OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n+                OverloadedCallType::from_trait_id(tcx, trait_ref.def_id())\n             }\n         }\n     }"}, {"sha": "2be5e46fcbb68deea643661bee0da493ad0b28c7", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -60,7 +60,7 @@ pub fn simplify_type(tcx: &ty::ctxt,\n         ty::ty_vec(..) => Some(VecSimplifiedType),\n         ty::ty_ptr(_) => Some(PtrSimplifiedType),\n         ty::ty_trait(ref trait_info) => {\n-            Some(TraitSimplifiedType(trait_info.principal.def_id))\n+            Some(TraitSimplifiedType(trait_info.principal.value.def_id))\n         }\n         ty::ty_struct(def_id, _) => {\n             Some(StructSimplifiedType(def_id))"}, {"sha": "805d4532aa1c49ff802d4ff4c7f16d8ae3e08a17", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -354,7 +354,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 }\n                 (_, &ty::ty_trait(box ty::TyTrait { ref principal, bounds })) => {\n                     // FIXME what is the purpose of `ty`?\n-                    let ty = ty::mk_trait(tcx, (*principal).clone(), bounds);\n+                    let ty = ty::mk_trait(tcx, principal.clone(), bounds);\n                     Some((ty, ty::UnsizeVtable(ty::TyTrait { principal: (*principal).clone(),\n                                                              bounds: bounds },\n                                                ty_a)))\n@@ -464,7 +464,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n                     debug!(\"mutbl={} b_mutbl={}\", mutbl, b_mutbl);\n                     // FIXME what is purpose of this type `tr`?\n-                    let tr = ty::mk_trait(tcx, (*principal).clone(), bounds);\n+                    let tr = ty::mk_trait(tcx, principal.clone(), bounds);\n                     try!(self.subtype(mk_ty(tr), b));\n                     Ok(Some(AdjustDerefRef(AutoDerefRef {\n                         autoderefs: 1,"}, {"sha": "1681731005db8712538812d000efd1fea8ede6d0", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -301,7 +301,21 @@ pub trait Combine<'tcx> {\n     fn trait_refs(&self,\n                   a: &ty::TraitRef<'tcx>,\n                   b: &ty::TraitRef<'tcx>)\n-                  -> cres<'tcx, ty::TraitRef<'tcx>>;\n+                  -> cres<'tcx, ty::TraitRef<'tcx>>\n+    {\n+        // Different traits cannot be related\n+        if a.def_id != b.def_id {\n+            Err(ty::terr_traits(expected_found(self, a.def_id, b.def_id)))\n+        } else {\n+            let substs = try!(self.substs(a.def_id, &a.substs, &b.substs));\n+            Ok(ty::TraitRef { def_id: a.def_id, substs: substs })\n+        }\n+    }\n+\n+    fn poly_trait_refs(&self,\n+                       a: &ty::PolyTraitRef<'tcx>,\n+                       b: &ty::PolyTraitRef<'tcx>)\n+                       -> cres<'tcx, ty::PolyTraitRef<'tcx>>;\n     // this must be overridden to do correctly, so as to account for higher-ranked\n     // behavior\n }\n@@ -410,7 +424,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n       (&ty::ty_trait(ref a_),\n        &ty::ty_trait(ref b_)) => {\n           debug!(\"Trying to match traits {} and {}\", a, b);\n-          let principal = try!(this.trait_refs(&a_.principal, &b_.principal));\n+          let principal = try!(this.poly_trait_refs(&a_.principal, &b_.principal));\n           let bounds = try!(this.existential_bounds(a_.bounds, b_.bounds));\n           Ok(ty::mk_trait(tcx, principal, bounds))\n       }"}, {"sha": "79fbc33f2a1dfca77982b688e80acba1672e287f", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -134,14 +134,16 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n-               -> cres<'tcx, ty::FnSig<'tcx>> {\n+               -> cres<'tcx, ty::FnSig<'tcx>>\n+    {\n         try!(self.sub().fn_sigs(a, b));\n         self.sub().fn_sigs(b, a)\n     }\n \n-    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n-                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n-        try!(self.sub().trait_refs(a, b));\n-        self.sub().trait_refs(b, a)\n+    fn poly_trait_refs(&self, a: &ty::PolyTraitRef<'tcx>, b: &ty::PolyTraitRef<'tcx>)\n+                       -> cres<'tcx, ty::PolyTraitRef<'tcx>>\n+    {\n+        try!(self.sub().poly_trait_refs(a, b));\n+        self.sub().poly_trait_refs(b, a)\n     }\n }"}, {"sha": "89d6a7df05098535f620bf7100a0976e6fd92af4", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -1647,13 +1647,13 @@ impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx> Resolvable<'tcx> for Rc<ty::TraitRef<'tcx>> {\n+impl<'tcx> Resolvable<'tcx> for Rc<ty::PolyTraitRef<'tcx>> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n-                   -> Rc<ty::TraitRef<'tcx>> {\n+                   -> Rc<ty::PolyTraitRef<'tcx>> {\n         Rc::new(infcx.resolve_type_vars_if_possible(&**self))\n     }\n     fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(&**self)\n+        ty::trait_ref_contains_error(&self.value)\n     }\n }\n "}, {"sha": "f751931a9412ee856a53c2c50a213d4c2ac63a8a", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -126,8 +126,8 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         self.higher_ranked_glb(a, b)\n     }\n \n-    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n-                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n+    fn poly_trait_refs(&self, a: &ty::PolyTraitRef<'tcx>, b: &ty::PolyTraitRef<'tcx>)\n+                       -> cres<'tcx, ty::PolyTraitRef<'tcx>> {\n         self.higher_ranked_glb(a, b)\n     }\n }"}, {"sha": "93a4d7c2f46d9bb42cce5af65c64bc6abd95491d", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -377,21 +377,13 @@ impl<'tcx> HigherRankedCombineable<'tcx> for ty::FnSig<'tcx> {\n     }\n }\n \n-impl<'tcx> HigherRankedCombineable<'tcx> for ty::TraitRef<'tcx> {\n+impl<'tcx> HigherRankedCombineable<'tcx> for ty::PolyTraitRef<'tcx> {\n     fn super_combine<C:Combine<'tcx>>(combiner: &C,\n-                                      a: &ty::TraitRef<'tcx>,\n-                                      b: &ty::TraitRef<'tcx>)\n-                                      -> cres<'tcx, ty::TraitRef<'tcx>>\n+                                      a: &ty::PolyTraitRef<'tcx>,\n+                                      b: &ty::PolyTraitRef<'tcx>)\n+                                      -> cres<'tcx, ty::PolyTraitRef<'tcx>>\n     {\n-        // Different traits cannot be related\n-        if a.def_id != b.def_id {\n-            Err(ty::terr_traits(\n-                combine::expected_found(combiner, a.def_id, b.def_id)))\n-        } else {\n-            let substs = try!(combiner.substs(a.def_id, &a.substs, &b.substs));\n-            Ok(ty::TraitRef { def_id: a.def_id,\n-                              substs: substs })\n-        }\n+        Ok(ty::bind(try!(combiner.trait_refs(&a.value, &b.value))))\n     }\n }\n "}, {"sha": "e142e3dbe443b07aa8aa0cd59803b1b777a6b936", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -122,8 +122,8 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         super_lattice_tys(self, a, b)\n     }\n \n-    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n-                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n+    fn poly_trait_refs(&self, a: &ty::PolyTraitRef<'tcx>, b: &ty::PolyTraitRef<'tcx>)\n+                       -> cres<'tcx, ty::PolyTraitRef<'tcx>> {\n         self.higher_ranked_lub(a, b)\n     }\n }"}, {"sha": "80508a8f16f1f98dce56bcce0e4f735c03007a39", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -133,7 +133,7 @@ impl Copy for TypeOrigin {}\n #[deriving(Clone, Show)]\n pub enum ValuePairs<'tcx> {\n     Types(ty::expected_found<Ty<'tcx>>),\n-    TraitRefs(ty::expected_found<Rc<ty::TraitRef<'tcx>>>),\n+    TraitRefs(ty::expected_found<Rc<ty::PolyTraitRef<'tcx>>>),\n }\n \n /// The trace designates the path through inference that we took to\n@@ -402,17 +402,17 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n         || cx.eq_types(a_is_expected, origin, a, b))\n }\n \n-pub fn mk_sub_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                    a_is_expected: bool,\n                                    origin: TypeOrigin,\n-                                   a: Rc<ty::TraitRef<'tcx>>,\n-                                   b: Rc<ty::TraitRef<'tcx>>)\n+                                   a: Rc<ty::PolyTraitRef<'tcx>>,\n+                                   b: Rc<ty::PolyTraitRef<'tcx>>)\n                                    -> ures<'tcx>\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n            a.repr(cx.tcx), b.repr(cx.tcx));\n     cx.commit_if_ok(\n-        || cx.sub_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n+        || cx.sub_poly_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n }\n \n fn expected_found<T>(a_is_expected: bool,\n@@ -679,12 +679,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n-    pub fn sub_trait_refs(&self,\n-                          a_is_expected: bool,\n-                          origin: TypeOrigin,\n-                          a: Rc<ty::TraitRef<'tcx>>,\n-                          b: Rc<ty::TraitRef<'tcx>>)\n-                          -> ures<'tcx>\n+    pub fn sub_poly_trait_refs(&self,\n+                               a_is_expected: bool,\n+                               origin: TypeOrigin,\n+                               a: Rc<ty::PolyTraitRef<'tcx>>,\n+                               b: Rc<ty::PolyTraitRef<'tcx>>)\n+                               -> ures<'tcx>\n     {\n         debug!(\"sub_trait_refs({} <: {})\",\n                a.repr(self.tcx),\n@@ -695,7 +695,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 values: TraitRefs(expected_found(a_is_expected,\n                                                  a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace).trait_refs(&*a, &*b).to_ures()\n+            self.sub(a_is_expected, trace).poly_trait_refs(&*a, &*b).to_ures()\n         })\n     }\n }"}, {"sha": "e7b7791cc2a843d5a32c2928cd41a42730f4e074", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -160,8 +160,8 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         self.higher_ranked_sub(a, b)\n     }\n \n-    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n-                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n+    fn poly_trait_refs(&self, a: &ty::PolyTraitRef<'tcx>, b: &ty::PolyTraitRef<'tcx>)\n+                       -> cres<'tcx, ty::PolyTraitRef<'tcx>> {\n         self.higher_ranked_sub(a, b)\n     }\n }"}, {"sha": "b0d62644ca510e5ef057b9ad287e803309fdf46c", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -257,8 +257,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 };\n                 let tr = ty::impl_trait_ref(self.tcx, local_def(item.id));\n                 let public_trait = tr.clone().map_or(false, |tr| {\n-                    !is_local(tr.def_id) ||\n-                     self.exported_items.contains(&tr.def_id.node)\n+                    !is_local(tr.value.def_id) ||\n+                     self.exported_items.contains(&tr.value.def_id.node)\n                 });\n \n                 if public_ty || public_trait {\n@@ -407,7 +407,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n                                     debug!(\"privacy - impl of trait {}\", id);\n-                                    self.def_privacy(t.def_id)\n+                                    self.def_privacy(t.value.def_id)\n                                 }\n                                 None => {\n                                     debug!(\"privacy - found a method {}\",\n@@ -432,7 +432,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n                                     debug!(\"privacy - impl of trait {}\", id);\n-                                    self.def_privacy(t.def_id)\n+                                    self.def_privacy(t.value.def_id)\n                                 }\n                                 None => {\n                                     debug!(\"privacy - found a typedef {}\",\n@@ -811,7 +811,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             // is whether the trait itself is accessible or not.\n             MethodTypeParam(MethodParam { ref trait_ref, .. }) |\n             MethodTraitObject(MethodObject { ref trait_ref, .. }) => {\n-                self.report_error(self.ensure_public(span, trait_ref.def_id,\n+                self.report_error(self.ensure_public(span, trait_ref.def_id(),\n                                                      None, \"source trait\"));\n             }\n         }"}, {"sha": "011f86e2810ae5a4de19db0e9a87496f7420f242", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -65,15 +65,15 @@ pub fn impl_is_local(tcx: &ty::ctxt,\n     debug!(\"trait_ref={}\", trait_ref.repr(tcx));\n \n     // If the trait is local to the crate, ok.\n-    if trait_ref.def_id.krate == ast::LOCAL_CRATE {\n+    if trait_ref.value.def_id.krate == ast::LOCAL_CRATE {\n         debug!(\"trait {} is local to current crate\",\n-               trait_ref.def_id.repr(tcx));\n+               trait_ref.value.def_id.repr(tcx));\n         return true;\n     }\n \n     // Otherwise, at least one of the input types must be local to the\n     // crate.\n-    trait_ref.input_types().iter().any(|&t| ty_is_local(tcx, t))\n+    trait_ref.value.input_types().iter().any(|&t| ty_is_local(tcx, t))\n }\n \n pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -143,7 +143,7 @@ pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         }\n \n         ty::ty_trait(ref tt) => {\n-            tt.principal.def_id.krate == ast::LOCAL_CRATE\n+            tt.principal.value.def_id.krate == ast::LOCAL_CRATE\n         }\n \n         // Type parameters may be bound to types that are not local to"}, {"sha": "8433313cb37180ce817f36e05343e3fc3528037f", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -28,7 +28,7 @@ use super::ObligationCause;\n use super::PredicateObligation;\n use super::Selection;\n use super::select::SelectionContext;\n-use super::trait_ref_for_builtin_bound;\n+use super::poly_trait_ref_for_builtin_bound;\n use super::Unimplemented;\n \n /// The fulfillment context is used to drive trait resolution.  It\n@@ -107,7 +107,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                                   builtin_bound: ty::BuiltinBound,\n                                   cause: ObligationCause<'tcx>)\n     {\n-        match trait_ref_for_builtin_bound(tcx, builtin_bound, ty) {\n+        match poly_trait_ref_for_builtin_bound(tcx, builtin_bound, ty) {\n             Ok(trait_ref) => {\n                 self.register_trait_ref(tcx, trait_ref, cause);\n             }\n@@ -117,7 +117,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n     pub fn register_trait_ref<'a>(&mut self,\n                                   tcx: &ty::ctxt<'tcx>,\n-                                  trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                                  trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n                                   cause: ObligationCause<'tcx>)\n     {\n         /*!"}, {"sha": "3289acd0c2e5e0b78ba4a893c1fcdd4540cdf2b2", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -33,7 +33,7 @@ pub use self::util::supertraits;\n pub use self::util::Supertraits;\n pub use self::util::search_trait_and_supertraits_from_bound;\n pub use self::util::transitive_bounds;\n-pub use self::util::trait_ref_for_builtin_bound;\n+pub use self::util::poly_trait_ref_for_builtin_bound;\n \n mod coherence;\n mod fulfill;\n@@ -54,7 +54,7 @@ pub struct Obligation<'tcx, T> {\n }\n \n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n-pub type TraitObligation<'tcx> = Obligation<'tcx, Rc<ty::TraitRef<'tcx>>>;\n+pub type TraitObligation<'tcx> = Obligation<'tcx, Rc<ty::PolyTraitRef<'tcx>>>;\n \n /// Why did we incur this obligation? Used for error reporting.\n #[deriving(Copy, Clone)]\n@@ -115,7 +115,9 @@ pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n pub enum SelectionError<'tcx> {\n     Unimplemented,\n     Overflow,\n-    OutputTypeParameterMismatch(Rc<ty::TraitRef<'tcx>>, Rc<ty::TraitRef<'tcx>>, ty::type_err<'tcx>),\n+    OutputTypeParameterMismatch(Rc<ty::PolyTraitRef<'tcx>>,\n+                                Rc<ty::PolyTraitRef<'tcx>>,\n+                                ty::type_err<'tcx>),\n }\n \n pub struct FulfillmentError<'tcx> {\n@@ -226,7 +228,7 @@ pub struct VtableBuiltinData<N> {\n #[deriving(PartialEq,Eq,Clone)]\n pub struct VtableParamData<'tcx> {\n     // In the above example, this would `Eq`\n-    pub bound: Rc<ty::TraitRef<'tcx>>,\n+    pub bound: Rc<ty::PolyTraitRef<'tcx>>,\n }\n \n /// True if neither the trait nor self type is local. Note that `impl_def_id` must refer to an impl\n@@ -278,7 +280,7 @@ impl<'tcx,O> Obligation<'tcx,O> {\n     }\n }\n \n-impl<'tcx> Obligation<'tcx,Rc<ty::TraitRef<'tcx>>> {\n+impl<'tcx> TraitObligation<'tcx> {\n     pub fn self_ty(&self) -> Ty<'tcx> {\n         self.trait_ref.self_ty()\n     }"}, {"sha": "86435267be002cec5e33d9beac79ed1cef11570c", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 39, "deletions": 46, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -28,7 +28,7 @@ use super::{util};\n use middle::fast_reject;\n use middle::mem_categorization::Typer;\n use middle::subst::{Subst, Substs, VecPerParamSpace};\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, Ty, RegionEscape};\n use middle::infer;\n use middle::infer::{InferCtxt, TypeSkolemizer};\n use middle::ty_fold::TypeFoldable;\n@@ -74,14 +74,14 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n \n     /// Trait ref from `obligation` but skolemized with the\n     /// selection-context's skolemizer. Used to check for recursion.\n-    skol_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    skol_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n \n     previous: Option<&'prev TraitObligationStack<'prev, 'tcx>>\n }\n \n #[deriving(Clone)]\n pub struct SelectionCache<'tcx> {\n-    hashmap: RefCell<HashMap<Rc<ty::TraitRef<'tcx>>,\n+    hashmap: RefCell<HashMap<Rc<ty::PolyTraitRef<'tcx>>,\n                              SelectionResult<'tcx, Candidate<'tcx>>>>,\n }\n \n@@ -347,13 +347,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // This suffices to allow chains like `FnMut` implemented in\n         // terms of `Fn` etc, but we could probably make this more\n         // precise still.\n-        let input_types = stack.skol_trait_ref.input_types();\n+        let input_types = stack.skol_trait_ref.value.input_types();\n         let unbound_input_types = input_types.iter().any(|&t| ty::type_is_skolemized(t));\n         if\n             unbound_input_types &&\n              (self.intercrate ||\n               stack.iter().skip(1).any(\n-                  |prev| stack.skol_trait_ref.def_id == prev.skol_trait_ref.def_id))\n+                  |prev| stack.skol_trait_ref.value.def_id == prev.skol_trait_ref.value.def_id))\n         {\n             debug!(\"evaluate_stack({}) --> unbound argument, recursion -->  ambiguous\",\n                    stack.skol_trait_ref.repr(self.tcx()));\n@@ -569,7 +569,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn pick_candidate_cache(&self,\n-                            cache_skol_trait_ref: &Rc<ty::TraitRef<'tcx>>)\n+                            cache_skol_trait_ref: &Rc<ty::PolyTraitRef<'tcx>>)\n                             -> &SelectionCache<'tcx>\n     {\n         // High-level idea: we have to decide whether to consult the\n@@ -591,7 +591,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // If the trait refers to any parameters in scope, then use\n         // the cache of the param-environment.\n         if\n-            cache_skol_trait_ref.input_types().iter().any(\n+            cache_skol_trait_ref.value.input_types().iter().any(\n                 |&t| ty::type_has_self(t) || ty::type_has_params(t))\n         {\n             return &self.param_env.selection_cache;\n@@ -604,7 +604,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // See the discussion in doc.rs for more details.\n         if\n             !self.param_env.caller_bounds.is_empty() &&\n-            cache_skol_trait_ref.input_types().iter().any(\n+            cache_skol_trait_ref.value.input_types().iter().any(\n                 |&t| ty::type_has_ty_infer(t))\n         {\n             return &self.param_env.selection_cache;\n@@ -615,7 +615,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn check_candidate_cache(&mut self,\n-                             cache_skol_trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                             cache_skol_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n                              -> Option<SelectionResult<'tcx, Candidate<'tcx>>>\n     {\n         let cache = self.pick_candidate_cache(&cache_skol_trait_ref);\n@@ -624,7 +624,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn insert_candidate_cache(&mut self,\n-                              cache_skol_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                              cache_skol_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n                               candidate: SelectionResult<'tcx, Candidate<'tcx>>)\n     {\n         let cache = self.pick_candidate_cache(&cache_skol_trait_ref);\n@@ -648,7 +648,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n \n-        match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.def_id) {\n+        match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.value.def_id) {\n             Some(ty::BoundCopy) => {\n                 debug!(\"obligation self ty is {}\",\n                        obligation.self_ty().repr(self.tcx()));\n@@ -696,7 +696,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"assemble_candidates_from_caller_bounds({})\",\n                obligation.repr(self.tcx()));\n \n-        let caller_trait_refs: Vec<Rc<ty::TraitRef>> =\n+        let caller_trait_refs: Vec<_> =\n             self.param_env.caller_bounds.predicates.iter()\n             .filter_map(|o| o.to_trait())\n             .collect();\n@@ -731,7 +731,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                            candidates: &mut CandidateSet<'tcx>)\n                                            -> Result<(),SelectionError<'tcx>>\n     {\n-        let kind = match self.fn_family_trait_kind(obligation.trait_ref.def_id) {\n+        let kind = match self.fn_family_trait_kind(obligation.trait_ref.value.def_id) {\n             Some(k) => k,\n             None => { return Ok(()); }\n         };\n@@ -779,7 +779,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // We provide a `Fn` impl for fn pointers. There is no need to provide\n         // the other traits (e.g. `FnMut`) since those are provided by blanket\n         // impls.\n-        if Some(obligation.trait_ref.def_id) != self.tcx().lang_items.fn_trait() {\n+        if Some(obligation.trait_ref.value.def_id) != self.tcx().lang_items.fn_trait() {\n             return Ok(());\n         }\n \n@@ -814,7 +814,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       candidates: &mut CandidateSet<'tcx>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n-        let all_impls = self.all_impls(obligation.trait_ref.def_id);\n+        let all_impls = self.all_impls(obligation.trait_ref.value.def_id);\n         for &impl_def_id in all_impls.iter() {\n             self.infcx.probe(|| {\n                 match self.match_impl(impl_def_id, obligation) {\n@@ -926,8 +926,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     let origin =\n                         infer::RelateOutputImplTypes(stack.obligation.cause.span);\n                     self.infcx\n-                        .sub_trait_refs(false, origin,\n-                                        impl_trait_ref, vt.bound.clone())\n+                        .sub_poly_trait_refs(false, origin, impl_trait_ref, vt.bound.clone())\n                         .is_ok()\n                 })\n             }\n@@ -1071,26 +1070,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n+            ty::ty_trait(ref data) => {\n                 match bound {\n                     ty::BoundSized => {\n                         Err(Unimplemented)\n                     }\n                     ty::BoundCopy | ty::BoundSync | ty::BoundSend => {\n-                        if bounds.builtin_bounds.contains(&bound) {\n+                        if data.bounds.builtin_bounds.contains(&bound) {\n                             Ok(If(Vec::new()))\n                         } else {\n                             // Recursively check all supertraits to find out if any further\n                             // bounds are required and thus we must fulfill.\n-                            // We have to create a temp trait ref here since TyTraits don't\n-                            // have actual self type info (which is required for the\n-                            // supertraits iterator).\n-                            let tmp_tr = Rc::new(ty::TraitRef {\n-                                def_id: principal.def_id,\n-                                substs: principal.substs.with_self_ty(ty::mk_err())\n-                            });\n+                            let tmp_tr = data.principal_trait_ref_with_self_ty(ty::mk_err());\n                             for tr in util::supertraits(self.tcx(), tmp_tr) {\n-                                let td = ty::lookup_trait_def(self.tcx(), tr.def_id);\n+                                let td = ty::lookup_trait_def(self.tcx(), tr.value.def_id);\n \n                                 if td.bounds.builtin_bounds.contains(&bound) {\n                                     return Ok(If(Vec::new()))\n@@ -1534,10 +1527,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 vec![],\n                 vec![],\n                 self_ty);\n-        let trait_ref = Rc::new(ty::TraitRef {\n-            def_id: obligation.trait_ref.def_id,\n+        let trait_ref = Rc::new(ty::bind(ty::TraitRef {\n+            def_id: obligation.trait_ref.def_id(),\n             substs: substs,\n-        });\n+        }));\n \n         let () =\n             try!(self.confirm(obligation.cause,\n@@ -1577,10 +1570,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 vec![],\n                 vec![],\n                 obligation.self_ty());\n-        let trait_ref = Rc::new(ty::TraitRef {\n-            def_id: obligation.trait_ref.def_id,\n+        let trait_ref = Rc::new(ty::bind(ty::TraitRef {\n+            def_id: obligation.trait_ref.def_id(),\n             substs: substs,\n-        });\n+        }));\n \n         debug!(\"confirm_unboxed_closure_candidate(closure_def_id={}, trait_ref={})\",\n                closure_def_id.repr(self.tcx()),\n@@ -1650,7 +1643,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn fast_reject_trait_refs(&mut self,\n                               obligation: &TraitObligation,\n-                              impl_trait_ref: &ty::TraitRef)\n+                              impl_trait_ref: &ty::PolyTraitRef)\n                               -> bool\n     {\n         // We can avoid creating type variables and doing the full\n@@ -1673,18 +1666,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_trait_refs(&mut self,\n                         obligation: &TraitObligation<'tcx>,\n-                        trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                        trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n                         -> Result<(),()>\n     {\n         debug!(\"match_trait_refs: obligation={} trait_ref={}\",\n                obligation.repr(self.tcx()),\n                trait_ref.repr(self.tcx()));\n \n         let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n-        match self.infcx.sub_trait_refs(false,\n-                                        origin,\n-                                        trait_ref,\n-                                        obligation.trait_ref.clone()) {\n+        match self.infcx.sub_poly_trait_refs(false,\n+                                             origin,\n+                                             trait_ref,\n+                                             obligation.trait_ref.clone()) {\n             Ok(()) => Ok(()),\n             Err(_) => Err(()),\n         }\n@@ -1783,7 +1776,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_impl_vtable(&mut self,\n                            impl_def_id: ast::DefId,\n                            obligation_cause: ObligationCause<'tcx>,\n-                           obligation_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                           obligation_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n                            substs: &Substs<'tcx>)\n                            -> Result<(), SelectionError<'tcx>>\n     {\n@@ -1814,17 +1807,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// we report an error to the user.\n     fn confirm(&mut self,\n                obligation_cause: ObligationCause,\n-               obligation_trait_ref: Rc<ty::TraitRef<'tcx>>,\n-               expected_trait_ref: Rc<ty::TraitRef<'tcx>>)\n+               obligation_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n+               expected_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n                -> Result<(), SelectionError<'tcx>>\n     {\n         let origin = infer::RelateOutputImplTypes(obligation_cause.span);\n \n         let obligation_trait_ref = obligation_trait_ref.clone();\n-        match self.infcx.sub_trait_refs(false,\n-                                        origin,\n-                                        expected_trait_ref.clone(),\n-                                        obligation_trait_ref.clone()) {\n+        match self.infcx.sub_poly_trait_refs(false,\n+                                             origin,\n+                                             expected_trait_ref.clone(),\n+                                             obligation_trait_ref.clone()) {\n             Ok(()) => Ok(()),\n             Err(e) => Err(OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n         }"}, {"sha": "2daf5453745b51638d58ef0100589c26389701b8", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -47,15 +47,15 @@ struct StackEntry<'tcx> {\n \n pub fn elaborate_trait_ref<'cx, 'tcx>(\n     tcx: &'cx ty::ctxt<'tcx>,\n-    trait_ref: Rc<ty::TraitRef<'tcx>>)\n+    trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n     -> Elaborator<'cx, 'tcx>\n {\n     elaborate_predicates(tcx, vec![ty::Predicate::Trait(trait_ref)])\n }\n \n pub fn elaborate_trait_refs<'cx, 'tcx>(\n     tcx: &'cx ty::ctxt<'tcx>,\n-    trait_refs: &[Rc<ty::TraitRef<'tcx>>])\n+    trait_refs: &[Rc<ty::PolyTraitRef<'tcx>>])\n     -> Elaborator<'cx, 'tcx>\n {\n     let predicates = trait_refs.iter()\n@@ -174,23 +174,23 @@ pub struct Supertraits<'cx, 'tcx:'cx> {\n }\n \n pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                              trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                              trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n                               -> Supertraits<'cx, 'tcx>\n {\n     let elaborator = elaborate_trait_ref(tcx, trait_ref);\n     Supertraits { elaborator: elaborator }\n }\n \n pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                                    bounds: &[Rc<ty::TraitRef<'tcx>>])\n+                                    bounds: &[Rc<ty::PolyTraitRef<'tcx>>])\n                                     -> Supertraits<'cx, 'tcx>\n {\n     let elaborator = elaborate_trait_refs(tcx, bounds);\n     Supertraits { elaborator: elaborator }\n }\n \n-impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n-    fn next(&mut self) -> Option<Rc<ty::TraitRef<'tcx>>> {\n+impl<'cx, 'tcx> Iterator<Rc<ty::PolyTraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n+    fn next(&mut self) -> Option<Rc<ty::PolyTraitRef<'tcx>>> {\n         loop {\n             match self.elaborator.next() {\n                 None => {\n@@ -266,18 +266,18 @@ pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n     })\n }\n \n-pub fn trait_ref_for_builtin_bound<'tcx>(\n+pub fn poly_trait_ref_for_builtin_bound<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n     param_ty: Ty<'tcx>)\n-    -> Result<Rc<ty::TraitRef<'tcx>>, ErrorReported>\n+    -> Result<Rc<ty::PolyTraitRef<'tcx>>, ErrorReported>\n {\n     match tcx.lang_items.from_builtin_kind(builtin_bound) {\n         Ok(def_id) => {\n-            Ok(Rc::new(ty::TraitRef {\n+            Ok(Rc::new(ty::bind(ty::TraitRef {\n                 def_id: def_id,\n                 substs: Substs::empty().with_self_ty(param_ty)\n-            }))\n+            })))\n         }\n         Err(e) => {\n             tcx.sess.err(e.as_slice());\n@@ -294,7 +294,7 @@ pub fn predicate_for_builtin_bound<'tcx>(\n     param_ty: Ty<'tcx>)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n-    let trait_ref = try!(trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty));\n+    let trait_ref = try!(poly_trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty));\n     Ok(Obligation {\n         cause: cause,\n         recursion_depth: recursion_depth,\n@@ -306,14 +306,14 @@ pub fn predicate_for_builtin_bound<'tcx>(\n /// of caller obligations), search through the trait and supertraits to find one where `test(d)` is\n /// true, where `d` is the def-id of the trait/supertrait. If any is found, return `Some(p)` where\n /// `p` is the path to that trait/supertrait. Else `None`.\n-pub fn search_trait_and_supertraits_from_bound<'tcx, F>(tcx: &ty::ctxt<'tcx>,\n-                                                        caller_bound: Rc<ty::TraitRef<'tcx>>,\n-                                                        mut test: F)\n-                                                        -> Option<VtableParamData<'tcx>> where\n-    F: FnMut(ast::DefId) -> bool,\n+pub fn search_trait_and_supertraits_from_bound<'tcx,F>(tcx: &ty::ctxt<'tcx>,\n+                                                       caller_bound: Rc<ty::PolyTraitRef<'tcx>>,\n+                                                       mut test: F)\n+                                                       -> Option<VtableParamData<'tcx>>\n+    where F: FnMut(ast::DefId) -> bool,\n {\n     for bound in transitive_bounds(tcx, &[caller_bound]) {\n-        if test(bound.def_id) {\n+        if test(bound.def_id()) {\n             let vtable_param = VtableParamData { bound: bound };\n             return Some(vtable_param);\n         }"}, {"sha": "ee4097b4d0a9c32aab9cae37dafdcf8577f84234", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 110, "deletions": 42, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -479,7 +479,7 @@ pub enum MethodOrigin<'tcx> {\n pub struct MethodParam<'tcx> {\n     // the precise trait reference that occurs as a bound -- this may\n     // be a supertrait of what the user actually typed.\n-    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    pub trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n \n     // index of uint in the list of methods for the trait\n     pub method_num: uint,\n@@ -489,7 +489,7 @@ pub struct MethodParam<'tcx> {\n #[deriving(Clone, Show)]\n pub struct MethodObject<'tcx> {\n     // the (super)trait containing the method to be invoked\n-    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    pub trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n \n     // the actual base trait id of the object\n     pub object_trait_id: ast::DefId,\n@@ -609,7 +609,7 @@ pub enum vtable_origin<'tcx> {\n \n // For every explicit cast into an object type, maps from the cast\n // expr to the associated trait ref.\n-pub type ObjectCastMap<'tcx> = RefCell<NodeMap<Rc<ty::TraitRef<'tcx>>>>;\n+pub type ObjectCastMap<'tcx> = RefCell<NodeMap<Rc<ty::PolyTraitRef<'tcx>>>>;\n \n /// A restriction that certain types must be the same size. The use of\n /// `transmute` gives rise to these restrictions.\n@@ -665,7 +665,7 @@ pub struct ctxt<'tcx> {\n     /// A cache for the trait_items() routine\n     pub trait_items_cache: RefCell<DefIdMap<Rc<Vec<ImplOrTraitItem<'tcx>>>>>,\n \n-    pub impl_trait_cache: RefCell<DefIdMap<Option<Rc<ty::TraitRef<'tcx>>>>>,\n+    pub impl_trait_cache: RefCell<DefIdMap<Option<Rc<ty::PolyTraitRef<'tcx>>>>>,\n \n     pub trait_refs: RefCell<NodeMap<Rc<TraitRef<'tcx>>>>,\n     pub trait_defs: RefCell<DefIdMap<Rc<TraitDef<'tcx>>>>,\n@@ -1308,10 +1308,23 @@ pub enum sty<'tcx> {\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct TyTrait<'tcx> {\n     // Principal trait reference.\n-    pub principal: TraitRef<'tcx>, // would use Rc<TraitRef>, but it runs afoul of some static rules\n+    pub principal: PolyTraitRef<'tcx>, // would use Rc<TraitRef>, but it runs afoul of some static rules\n     pub bounds: ExistentialBounds\n }\n \n+impl<'tcx> TyTrait<'tcx> {\n+    /// Object types don't have a self-type specified. Therefore, when\n+    /// we convert the principal trait-ref into a normal trait-ref,\n+    /// you must give *some* self-type. A common choice is `mk_err()`\n+    /// or some skolemized type.\n+    pub fn principal_trait_ref_with_self_ty(&self, self_ty: Ty<'tcx>) -> Rc<ty::PolyTraitRef<'tcx>> {\n+        Rc::new(ty::bind(ty::TraitRef {\n+            def_id: self.principal.value.def_id,\n+            substs: self.principal.value.substs.with_self_ty(self_ty),\n+        }))\n+    }\n+}\n+\n /// A complete reference to a trait. These take numerous guises in syntax,\n /// but perhaps the most recognizable form is in a where clause:\n ///\n@@ -1333,6 +1346,26 @@ pub struct TraitRef<'tcx> {\n     pub substs: Substs<'tcx>,\n }\n \n+pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n+\n+impl<'tcx> PolyTraitRef<'tcx> {\n+    pub fn self_ty(&self) -> Ty<'tcx> {\n+        self.value.self_ty()\n+    }\n+\n+    pub fn def_id(&self) -> ast::DefId {\n+        self.value.def_id\n+    }\n+\n+    pub fn substs(&self) -> &Substs<'tcx> {\n+        &self.value.substs\n+    }\n+\n+    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+        self.value.input_types()\n+    }\n+}\n+\n /// Binder serves as a synthetic binder for lifetimes. It is used when\n /// we wish to replace the escaping higher-ranked lifetimes in a type\n /// or something else that is not itself a binder (this is because the\n@@ -1416,7 +1449,7 @@ impl<'tcx> Copy for type_err<'tcx> {}\n pub struct ParamBounds<'tcx> {\n     pub region_bounds: Vec<ty::Region>,\n     pub builtin_bounds: BuiltinBounds,\n-    pub trait_bounds: Vec<Rc<TraitRef<'tcx>>>\n+    pub trait_bounds: Vec<Rc<PolyTraitRef<'tcx>>>\n }\n \n /// Bounds suitable for an existentially quantified type parameter\n@@ -1657,7 +1690,7 @@ pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the parameters in the `TypeSpace`.\n-    Trait(Rc<TraitRef<'tcx>>),\n+    Trait(Rc<PolyTraitRef<'tcx>>),\n \n     /// where `T1 == T2`.\n     Equate(/* T1 */ Ty<'tcx>, /* T2 */ Ty<'tcx>),\n@@ -1680,7 +1713,7 @@ impl<'tcx> Predicate<'tcx> {\n         }\n     }\n \n-    pub fn to_trait(&self) -> Option<Rc<TraitRef<'tcx>>> {\n+    pub fn to_trait(&self) -> Option<Rc<PolyTraitRef<'tcx>>> {\n         match *self {\n             Predicate::Trait(ref t) => {\n                 Some(t.clone())\n@@ -1748,14 +1781,6 @@ impl<'tcx> TraitRef<'tcx> {\n         // associated types.\n         self.substs.types.as_slice()\n     }\n-\n-    pub fn has_escaping_regions(&self) -> bool {\n-        self.substs.has_regions_escaping_depth(1)\n-    }\n-\n-    pub fn has_bound_regions(&self) -> bool {\n-        self.substs.has_regions_escaping_depth(0)\n-    }\n }\n \n /// When type checking, we use the `ParameterEnvironment` to track\n@@ -2160,7 +2185,7 @@ impl FlagComputation {\n \n             &ty_trait(box TyTrait { ref principal, ref bounds }) => {\n                 let mut computation = FlagComputation::new();\n-                computation.add_substs(&principal.substs);\n+                computation.add_substs(principal.substs());\n                 self.add_bound_computation(&computation);\n \n                 self.add_bounds(bounds);\n@@ -2366,7 +2391,7 @@ pub fn mk_ctor_fn<'tcx>(cx: &ctxt<'tcx>,\n \n \n pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n-                      principal: ty::TraitRef<'tcx>,\n+                      principal: ty::PolyTraitRef<'tcx>,\n                       bounds: ExistentialBounds)\n                       -> Ty<'tcx> {\n     // take a copy of substs so that we own the vectors inside\n@@ -2439,7 +2464,7 @@ pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n             maybe_walk_ty(tm.ty, f);\n         }\n         ty_trait(box TyTrait { ref principal, .. }) => {\n-            for subty in principal.substs.types.iter() {\n+            for subty in principal.substs().types.iter() {\n                 maybe_walk_ty(*subty, |x| f(x));\n             }\n         }\n@@ -3182,7 +3207,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n \n     fn kind_bounds_to_contents<'tcx>(cx: &ctxt<'tcx>,\n                                      bounds: BuiltinBounds,\n-                                     traits: &[Rc<TraitRef<'tcx>>])\n+                                     traits: &[Rc<PolyTraitRef<'tcx>>])\n                                      -> TypeContents {\n         let _i = indenter();\n         let mut tc = TC::All;\n@@ -3198,7 +3223,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n         // those inherited from traits with builtin-kind-supertraits.\n         fn each_inherited_builtin_bound<'tcx, F>(cx: &ctxt<'tcx>,\n                                                  bounds: BuiltinBounds,\n-                                                 traits: &[Rc<TraitRef<'tcx>>],\n+                                                 traits: &[Rc<PolyTraitRef<'tcx>>],\n                                                  mut f: F) where\n             F: FnMut(BuiltinBound),\n         {\n@@ -3207,7 +3232,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             each_bound_trait_and_supertraits(cx, traits, |trait_ref| {\n-                let trait_def = lookup_trait_def(cx, trait_ref.def_id);\n+                let trait_def = lookup_trait_def(cx, trait_ref.def_id());\n                 for bound in trait_def.bounds.builtin_bounds.iter() {\n                     f(bound);\n                 }\n@@ -4393,7 +4418,7 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n         ty_bare_fn(_) => \"extern fn\".to_string(),\n         ty_closure(_) => \"fn\".to_string(),\n         ty_trait(ref inner) => {\n-            format!(\"trait {}\", item_path_str(cx, inner.principal.def_id))\n+            format!(\"trait {}\", item_path_str(cx, inner.principal.def_id()))\n         }\n         ty_struct(id, _) => {\n             format!(\"struct {}\", item_path_str(cx, id))\n@@ -4760,7 +4785,7 @@ pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n }\n \n pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n-                            -> Option<Rc<TraitRef<'tcx>>> {\n+                            -> Option<Rc<PolyTraitRef<'tcx>>> {\n     memoized(&cx.impl_trait_cache, id, |id: ast::DefId| {\n         if id.krate == ast::LOCAL_CRATE {\n             debug!(\"(impl_trait_ref) searching for trait impl {}\", id);\n@@ -4770,7 +4795,9 @@ pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                         ast::ItemImpl(_, _, ref opt_trait, _, _) => {\n                             match opt_trait {\n                                 &Some(ref t) => {\n-                                    Some(ty::node_id_to_trait_ref(cx, t.ref_id))\n+                                    let trait_ref =\n+                                        (*ty::node_id_to_trait_ref(cx, t.ref_id)).clone();\n+                                    Some(Rc::new(ty::bind(trait_ref)))\n                                 }\n                                 &None => None\n                             }\n@@ -4813,7 +4840,7 @@ pub fn try_add_builtin_trait(\n pub fn ty_to_def_id(ty: Ty) -> Option<ast::DefId> {\n     match ty.sty {\n         ty_trait(ref tt) =>\n-            Some(tt.principal.def_id),\n+            Some(tt.principal.def_id()),\n         ty_struct(id, _) |\n         ty_enum(id, _) |\n         ty_unboxed_closure(id, _, _) =>\n@@ -5073,10 +5100,10 @@ pub fn lookup_trait_def<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n /// Given a reference to a trait, returns the \"superbounds\" declared\n /// on the trait, with appropriate substitutions applied.\n pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n-                                      trait_ref: &TraitRef<'tcx>)\n+                                      trait_ref: &PolyTraitRef<'tcx>)\n                                       -> Vec<ty::Predicate<'tcx>>\n {\n-    let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n+    let trait_def = lookup_trait_def(tcx, trait_ref.def_id());\n \n     debug!(\"bounds_for_trait_ref(trait_def={}, trait_ref={})\",\n            trait_def.repr(tcx), trait_ref.repr(tcx));\n@@ -5149,8 +5176,9 @@ pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n         trait_def.bounds.trait_bounds\n         .iter()\n         .map(|bound_trait_ref| {\n-            ty::TraitRef::new(bound_trait_ref.def_id,\n-                              bound_trait_ref.substs.subst(tcx, &trait_ref.substs))\n+            ty::bind(\n+                ty::TraitRef::new(bound_trait_ref.def_id(),\n+                                  bound_trait_ref.substs().subst(tcx, trait_ref.substs())))\n         })\n         .map(|bound_trait_ref| Rc::new(bound_trait_ref))\n         .collect();\n@@ -5161,9 +5189,9 @@ pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n     // The region bounds and builtin bounds do not currently introduce\n     // binders so we can just substitute in a straightforward way here.\n     let region_bounds =\n-        trait_def.bounds.region_bounds.subst(tcx, &trait_ref.substs);\n+        trait_def.bounds.region_bounds.subst(tcx, trait_ref.substs());\n     let builtin_bounds =\n-        trait_def.bounds.builtin_bounds.subst(tcx, &trait_ref.substs);\n+        trait_def.bounds.builtin_bounds.subst(tcx, trait_ref.substs());\n \n     let bounds = ty::ParamBounds {\n         trait_bounds: trait_bounds,\n@@ -5183,7 +5211,7 @@ pub fn predicates<'tcx>(\n     let mut vec = Vec::new();\n \n     for builtin_bound in bounds.builtin_bounds.iter() {\n-        match traits::trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty) {\n+        match traits::poly_trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty) {\n             Ok(trait_ref) => { vec.push(Predicate::Trait(trait_ref)); }\n             Err(ErrorReported) => { }\n         }\n@@ -5545,10 +5573,10 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n // relation on the supertraits from each bounded trait's constraint\n // list.\n pub fn each_bound_trait_and_supertraits<'tcx, F>(tcx: &ctxt<'tcx>,\n-                                                 bounds: &[Rc<TraitRef<'tcx>>],\n+                                                 bounds: &[Rc<PolyTraitRef<'tcx>>],\n                                                  mut f: F)\n                                                  -> bool where\n-    F: FnMut(Rc<TraitRef<'tcx>>) -> bool,\n+    F: FnMut(Rc<PolyTraitRef<'tcx>>) -> bool,\n {\n     for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n         if !f(bound_trait_ref) {\n@@ -5559,7 +5587,7 @@ pub fn each_bound_trait_and_supertraits<'tcx, F>(tcx: &ctxt<'tcx>,\n }\n \n pub fn object_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n-                                  opt_principal: Option<&TraitRef<'tcx>>, // None for boxed closures\n+                                  opt_principal: Option<&PolyTraitRef<'tcx>>, // None for closures\n                                   others: BuiltinBounds)\n                                   -> Vec<ty::Region>\n {\n@@ -5569,8 +5597,8 @@ pub fn object_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n     let open_ty = ty::mk_infer(tcx, SkolemizedTy(0));\n \n     let opt_trait_ref = opt_principal.map_or(Vec::new(), |principal| {\n-        let substs = principal.substs.with_self_ty(open_ty);\n-        vec!(Rc::new(ty::TraitRef::new(principal.def_id, substs)))\n+        let substs = principal.substs().with_self_ty(open_ty);\n+        vec!(Rc::new(ty::bind(ty::TraitRef::new(principal.def_id(), substs))))\n     });\n \n     let param_bounds = ty::ParamBounds {\n@@ -5663,7 +5691,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n         // Record the trait->implementation mappings, if applicable.\n         let associated_traits = csearch::get_impl_trait(tcx, impl_def_id);\n         for trait_ref in associated_traits.iter() {\n-            record_trait_implementation(tcx, trait_ref.def_id, impl_def_id);\n+            record_trait_implementation(tcx, trait_ref.def_id(), impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n@@ -5938,11 +5966,11 @@ pub fn hash_crate_independent(tcx: &ctxt, ty: Ty, svh: &Svh) -> u64 {\n                 }\n                 ty_trait(box TyTrait { ref principal, bounds }) => {\n                     byte!(17);\n-                    did(state, principal.def_id);\n+                    did(state, principal.def_id());\n                     hash!(bounds);\n \n                     let principal = anonymize_late_bound_regions(tcx, principal);\n-                    for subty in principal.substs.types.iter() {\n+                    for subty in principal.substs().types.iter() {\n                         helper(tcx, *subty, svh, state);\n                     }\n \n@@ -6200,7 +6228,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n                 accumulator.push(region)\n             }\n             ty_trait(ref t) => {\n-                accumulator.push_all(t.principal.substs.regions().as_slice());\n+                accumulator.push_all(t.principal.substs().regions().as_slice());\n             }\n             ty_enum(_, ref substs) |\n             ty_struct(_, ref substs) => {\n@@ -6538,3 +6566,43 @@ pub fn can_type_implement_copy<'tcx>(tcx: &ctxt<'tcx>,\n \n     Ok(())\n }\n+\n+pub trait RegionEscape {\n+    fn has_escaping_regions(&self) -> bool {\n+        self.has_regions_escaping_depth(0)\n+    }\n+\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool;\n+}\n+\n+impl<'tcx> RegionEscape for Ty<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        ty::type_escapes_depth(*self, depth)\n+    }\n+}\n+\n+impl RegionEscape for Region {\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        self.escapes_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for TraitRef<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        self.substs.types.iter().any(|t| t.has_regions_escaping_depth(depth)) &&\n+            self.substs.regions().iter().any(|t| t.has_regions_escaping_depth(depth))\n+    }\n+}\n+\n+impl<'tcx,T:RegionEscape> RegionEscape for Binder<T> {\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        self.value.has_regions_escaping_depth(depth + 1)\n+    }\n+}\n+\n+impl<T:RegionEscape> Binder<T> {\n+    pub fn has_bound_regions(&self) -> bool {\n+        self.value.has_regions_escaping_depth(0)\n+    }\n+}\n+"}, {"sha": "da6ddf7461b35e232c5f8cedc1693684631f2230", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -583,16 +583,6 @@ pub fn super_fold_closure_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n pub fn super_fold_trait_ref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                        t: &ty::TraitRef<'tcx>)\n                                                        -> ty::TraitRef<'tcx>\n-{\n-    this.enter_region_binder();\n-    let result = super_fold_trait_ref_contents(this, t);\n-    this.exit_region_binder();\n-    result\n-}\n-\n-pub fn super_fold_trait_ref_contents<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                                t: &ty::TraitRef<'tcx>)\n-                                                                -> ty::TraitRef<'tcx>\n {\n     ty::TraitRef {\n         def_id: t.def_id,\n@@ -722,12 +712,6 @@ impl<'tcx> HigherRankedFoldable<'tcx> for ty::FnSig<'tcx> {\n     }\n }\n \n-impl<'tcx> HigherRankedFoldable<'tcx> for ty::TraitRef<'tcx> {\n-    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef<'tcx> {\n-        super_fold_trait_ref_contents(folder, self)\n-    }\n-}\n-\n impl<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>> HigherRankedFoldable<'tcx> for ty::Binder<T> {\n     fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n         ty::bind(self.value.fold_with(folder))"}, {"sha": "afa7ce1867554fcabf0342b50542bbf52bf2ca89", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -433,16 +433,11 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         ty_trait(box ty::TyTrait {\n             ref principal, ref bounds\n         }) => {\n-            let base = ty::item_path_str(cx, principal.def_id);\n-            let trait_def = ty::lookup_trait_def(cx, principal.def_id);\n-            let did = trait_def.trait_ref.def_id;\n-            let ty = parameterized(cx, base.as_slice(),\n-                                   &principal.substs, &trait_def.generics,\n-                                   did);\n+            let principal = principal.user_string(cx);\n             let bound_str = bounds.user_string(cx);\n             let bound_sep = if bound_str.is_empty() { \"\" } else { \" + \" };\n             format!(\"{}{}{}\",\n-                    ty,\n+                    principal,\n                     bound_sep,\n                     bound_str)\n         }\n@@ -749,7 +744,7 @@ impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n         // tells you everything you need to know.\n         let base = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        format!(\"<{} : {}>\",\n+        format!(\"TraitRef({}, {})\",\n                 self.substs.self_ty().repr(tcx),\n                 parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics, self.def_id))\n     }\n@@ -1161,7 +1156,7 @@ impl<'tcx> UserString<'tcx> for ty::BuiltinBounds {\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n+impl<'tcx> UserString<'tcx> for ty::PolyTraitRef<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         // Replace any anonymous late-bound regions with named\n         // variants, using gensym'd identifiers, so that we can\n@@ -1178,27 +1173,29 @@ impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n                 ty::BrAnon(_) |\n                 ty::BrFresh(_) |\n                 ty::BrEnv => {\n-                    let name = token::gensym(\"r\");\n+                    let name = token::gensym(\"'r\");\n                     names.push(token::get_name(name));\n                     ty::BrNamed(ast_util::local_def(ast::DUMMY_NODE_ID), name)\n                 }\n             })\n         });\n         let names: Vec<_> = names.iter().map(|s| s.get()).collect();\n \n-        // Let the base string be either `SomeTrait` for `for<'a,'b> SomeTrait`,\n-        // depending on whether there are bound regions.\n-        let path_str = ty::item_path_str(tcx, self.def_id);\n-        let base =\n-            if names.is_empty() {\n-                path_str\n-            } else {\n-                format!(\"for<{}> {}\", names.connect(\",\"), path_str)\n-            };\n+        let trait_ref_str = trait_ref.value.user_string(tcx);\n+        if names.len() == 0 {\n+            trait_ref_str\n+        } else {\n+            format!(\"for<{}> {}\", names.connect(\",\"), trait_ref_str)\n+        }\n+    }\n+}\n \n+impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        let path_str = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        let did = trait_def.trait_ref.def_id;\n-        parameterized(tcx, base.as_slice(), &trait_ref.substs, &trait_def.generics, did)\n+        parameterized(tcx, path_str.as_slice(), &self.substs,\n+                      &trait_def.generics, self.def_id)\n     }\n }\n "}, {"sha": "2162055f287826ee497758a37003a799a28d0b1d", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -941,14 +941,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             ty::MethodTypeParam(ref mp) => {\n                 // method invoked on a type parameter\n                 let trait_item = ty::trait_item(&self.analysis.ty_cx,\n-                                                mp.trait_ref.def_id,\n+                                                mp.trait_ref.def_id(),\n                                                 mp.method_num);\n                 (None, Some(trait_item.def_id()))\n             }\n             ty::MethodTraitObject(ref mo) => {\n                 // method invoked on a trait instance\n                 let trait_item = ty::trait_item(&self.analysis.ty_cx,\n-                                                mo.trait_ref.def_id,\n+                                                mo.trait_ref.def_id(),\n                                                 mo.method_num);\n                 (None, Some(trait_item.def_id()))\n             }"}, {"sha": "7c2f719611632ba78e8788adf4f67168de9e946d", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -426,7 +426,7 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n \n                     // Compute the first substitution\n                     let first_subst =\n-                        ty::make_substs_for_receiver_types(tcx, &*trait_ref, &*method)\n+                        ty::make_substs_for_receiver_types(tcx, &trait_ref.value, &*method)\n                         .erase_regions();\n \n                     // And compose them\n@@ -435,7 +435,7 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n                     debug!(\"trans_fn_with_vtables - default method: \\\n                             substs = {}, trait_subst = {}, \\\n                             first_subst = {}, new_subst = {}\",\n-                           substs.repr(tcx), trait_ref.substs.repr(tcx),\n+                           substs.repr(tcx), trait_ref.substs().repr(tcx),\n                            first_subst.repr(tcx), new_substs.repr(tcx));\n \n                     (true, source_id, new_substs)"}, {"sha": "ab18a05a2511fecdd821d753cd93663219fb18ca", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -764,7 +764,7 @@ pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ex: &ast::Expr) -> T\n /// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     span: Span,\n-                                    trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                                    trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n                                     -> traits::Vtable<'tcx, ()>\n {\n     let tcx = ccx.tcx();\n@@ -783,7 +783,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     debug!(\"trans fulfill_obligation: trait_ref={}\", trait_ref.repr(ccx.tcx()));\n \n-    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id);\n+    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n     let infcx = infer::new_infer_ctxt(tcx);\n \n     // Parameter environment is used to give details about type parameters,"}, {"sha": "af003b011579f2687e56897f14f841517dd24970", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -99,7 +99,7 @@ pub struct LocalCrateContext<'tcx> {\n     monomorphized: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<uint>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::TraitRef<'tcx>>), ValueRef>>,\n+    vtables: RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::PolyTraitRef<'tcx>>), ValueRef>>,\n     /// Cache of constant strings,\n     const_cstr_cache: RefCell<FnvHashMap<InternedString, ValueRef>>,\n \n@@ -150,7 +150,7 @@ pub struct LocalCrateContext<'tcx> {\n     /// contexts around the same size.\n     n_llvm_insns: Cell<uint>,\n \n-    trait_cache: RefCell<FnvHashMap<Rc<ty::TraitRef<'tcx>>,\n+    trait_cache: RefCell<FnvHashMap<Rc<ty::PolyTraitRef<'tcx>>,\n                                     traits::Vtable<'tcx, ()>>>,\n }\n \n@@ -601,7 +601,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.monomorphizing\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::TraitRef<'tcx>>),\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::PolyTraitRef<'tcx>>),\n                                                             ValueRef>> {\n         &self.local.vtables\n     }\n@@ -699,7 +699,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.n_llvm_insns.set(self.local.n_llvm_insns.get() + 1);\n     }\n \n-    pub fn trait_cache(&self) -> &RefCell<FnvHashMap<Rc<ty::TraitRef<'tcx>>,\n+    pub fn trait_cache(&self) -> &RefCell<FnvHashMap<Rc<ty::PolyTraitRef<'tcx>>,\n                                                      traits::Vtable<'tcx, ()>>> {\n         &self.local.trait_cache\n     }"}, {"sha": "8fcab0a3144d1c84d2682db8a0063281a5131301", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -429,8 +429,8 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 from_def_id_and_substs(self,\n                                        cx,\n-                                       trait_data.principal.def_id,\n-                                       &trait_data.principal.substs,\n+                                       trait_data.principal.def_id(),\n+                                       trait_data.principal.substs(),\n                                        &mut unique_type_id);\n             },\n             ty::ty_bare_fn(ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n@@ -2834,7 +2834,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // But it does not describe the trait's methods.\n \n     let def_id = match trait_type.sty {\n-        ty::ty_trait(box ty::TyTrait { ref principal, .. }) => principal.def_id,\n+        ty::ty_trait(box ty::TyTrait { ref principal, .. }) => principal.def_id(),\n         _ => {\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(format!(\"debuginfo: Unexpected trait-object type in \\\n@@ -3765,8 +3765,8 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             output.push(']');\n         },\n         ty::ty_trait(ref trait_data) => {\n-            push_item_name(cx, trait_data.principal.def_id, false, output);\n-            push_type_params(cx, &trait_data.principal.substs, output);\n+            push_item_name(cx, trait_data.principal.def_id(), false, output);\n+            push_type_params(cx, trait_data.principal.substs(), output);\n         },\n         ty::ty_bare_fn(ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n             if unsafety == ast::Unsafety::Unsafe {"}, {"sha": "0bcca6c80ff0d32723eec81fb453fdc528b68a1d", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -316,10 +316,10 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           bcx.ty_to_string(unadjusted_ty)).as_slice())\n             },\n             &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n-                let substs = principal.substs.with_self_ty(unadjusted_ty).erase_regions();\n+                let substs = principal.substs().with_self_ty(unadjusted_ty).erase_regions();\n                 let trait_ref =\n-                    Rc::new(ty::TraitRef { def_id: principal.def_id,\n-                                           substs: substs });\n+                    Rc::new(ty::bind(ty::TraitRef { def_id: principal.def_id(),\n+                                                    substs: substs }));\n                 let trait_ref = trait_ref.subst(bcx.tcx(), bcx.fcx.param_substs);\n                 let box_ty = mk_ty(unadjusted_ty);\n                 PointerCast(bcx,"}, {"sha": "b386df85d627eaafcc6f4950d3cc1ffb9a8bbeae", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -142,7 +142,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                             span,\n                                             (*trait_ref).clone());\n             debug!(\"origin = {}\", origin.repr(bcx.tcx()));\n-            trans_monomorphized_callee(bcx, method_call, trait_ref.def_id,\n+            trans_monomorphized_callee(bcx, method_call, trait_ref.def_id(),\n                                        method_num, origin)\n         }\n \n@@ -239,8 +239,8 @@ pub fn trans_static_method_callee(bcx: Block,\n                                              rcvr_assoc,\n                                              Vec::new()));\n     debug!(\"trait_substs={}\", trait_substs.repr(bcx.tcx()));\n-    let trait_ref = Rc::new(ty::TraitRef { def_id: trait_id,\n-                                           substs: trait_substs });\n+    let trait_ref = Rc::new(ty::bind(ty::TraitRef { def_id: trait_id,\n+                                                    substs: trait_substs }));\n     let vtbl = fulfill_obligation(bcx.ccx(),\n                                   DUMMY_SP,\n                                   trait_ref);\n@@ -515,7 +515,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// This will hopefully change now that DST is underway.\n pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               box_ty: Ty<'tcx>,\n-                              trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                              trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n                               -> ValueRef\n {\n     debug!(\"get_vtable(box_ty={}, trait_ref={})\",\n@@ -618,7 +618,7 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n-        Some(t_id) => t_id.def_id,\n+        Some(t_id) => t_id.def_id(),\n         None       => ccx.sess().bug(\"make_impl_vtable: don't know how to \\\n                                       make a vtable for a type impl!\")\n     };\n@@ -670,7 +670,7 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     datum: Datum<'tcx, Expr>,\n                                     id: ast::NodeId,\n-                                    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                                    trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n                                     dest: expr::Dest)\n                                     -> Block<'blk, 'tcx> {\n     let mut bcx = bcx;"}, {"sha": "1acd5684d169c3f68a0d99fe062d0da924a76e24", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 38, "deletions": 27, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -524,6 +524,19 @@ fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n     vec![input_ty, output]\n }\n \n+pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n+    this: &AC,\n+    rscope: &RS,\n+    ast_trait_ref: &ast::PolyTraitRef,\n+    self_ty: Option<Ty<'tcx>>,\n+    allow_eq: AllowEqConstraints)\n+    -> Rc<ty::PolyTraitRef<'tcx>>\n+    where AC: AstConv<'tcx>, RS: RegionScope\n+{\n+    let trait_ref = instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty, allow_eq);\n+    let trait_ref = (*trait_ref).clone();\n+    Rc::new(ty::bind(trait_ref)) // Ugh.\n+}\n \n /// Instantiates the path for the given trait reference, assuming that it's\n /// bound to a valid trait type. Returns the def_id for the defining trait.\n@@ -537,9 +550,7 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n                                          where AC: AstConv<'tcx>,\n                                                RS: RegionScope\n {\n-    match ::lookup_def_tcx(this.tcx(),\n-                           ast_trait_ref.path.span,\n-                           ast_trait_ref.ref_id) {\n+    match ::lookup_def_tcx(this.tcx(), ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n         def::DefTrait(trait_def_id) => {\n             let trait_ref = Rc::new(ast_path_to_trait_ref(this,\n                                                           rscope,\n@@ -749,7 +760,7 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                    rscope: &RS,\n                                    ty: &ast::Ty,\n                                    bounds: &[ast::TyParamBound])\n-                                   -> Result<ty::TraitRef<'tcx>, ErrorReported>\n+                                   -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n     where AC : AstConv<'tcx>, RS : RegionScope\n {\n     /*!\n@@ -767,12 +778,12 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n         ast::TyPath(ref path, id) => {\n             match this.tcx().def_map.borrow().get(&id) {\n                 Some(&def::DefTrait(trait_def_id)) => {\n-                    return Ok(ast_path_to_trait_ref(this,\n-                                                    rscope,\n-                                                    trait_def_id,\n-                                                    None,\n-                                                    path,\n-                                                    AllowEqConstraints::Allow));\n+                    return Ok(ty::bind(ast_path_to_trait_ref(this,\n+                                                             rscope,\n+                                                             trait_def_id,\n+                                                             None,\n+                                                             path,\n+                                                             AllowEqConstraints::Allow)));\n                 }\n                 _ => {\n                     span_err!(this.tcx().sess, ty.span, E0172, \"expected a reference to a trait\");\n@@ -814,7 +825,7 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,\n                                         rscope: &RS,\n                                         span: Span,\n-                                        trait_ref: ty::TraitRef<'tcx>,\n+                                        trait_ref: ty::PolyTraitRef<'tcx>,\n                                         bounds: &[ast::TyParamBound])\n                                         -> Ty<'tcx>\n     where AC : AstConv<'tcx>, RS : RegionScope\n@@ -982,12 +993,12 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     def::DefTrait(trait_def_id) => {\n                         // N.B. this case overlaps somewhat with\n                         // TyObjectSum, see that fn for details\n-                        let result = ast_path_to_trait_ref(this,\n-                                                           rscope,\n-                                                           trait_def_id,\n-                                                           None,\n-                                                           path,\n-                                                           AllowEqConstraints::Allow);\n+                        let result = ty::bind(ast_path_to_trait_ref(this,\n+                                                                    rscope,\n+                                                                    trait_def_id,\n+                                                                    None,\n+                                                                    path,\n+                                                                    AllowEqConstraints::Allow));\n                         trait_ref_to_object_type(this, rscope, path.span, result, &[])\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n@@ -1039,7 +1050,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                 let ty_param_defs = tcx.ty_param_defs.borrow();\n                                 let tp_def = &(*ty_param_defs)[did.node];\n                                 let assoc_tys = tp_def.bounds.trait_bounds.iter()\n-                                    .filter_map(|b| find_assoc_ty(this, &**b, assoc_ident))\n+                                    .filter_map(|b| find_assoc_ty(this, &b.value, assoc_ident))\n                                     .collect();\n                                 (assoc_tys, token::get_name(tp_def.name).to_string())\n                             }\n@@ -1423,7 +1434,7 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    principal_trait_ref: Option<&ty::TraitRef<'tcx>>, // None for boxed closures\n+    principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>, // None for boxed closures\n     ast_bounds: &[ast::TyParamBound])\n     -> ty::ExistentialBounds\n {\n@@ -1450,11 +1461,11 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n \n     let main_trait_bound = match partitioned_bounds.trait_bounds.remove(0) {\n         Some(trait_bound) => {\n-            Some(instantiate_trait_ref(this,\n-                                       rscope,\n-                                       &trait_bound.trait_ref,\n-                                       None,\n-                                       AllowEqConstraints::Allow))\n+            Some(instantiate_poly_trait_ref(this,\n+                                            rscope,\n+                                            trait_bound,\n+                                            None,\n+                                            AllowEqConstraints::Allow))\n         }\n         None => {\n             this.tcx().sess.span_err(\n@@ -1481,7 +1492,7 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    principal_trait_ref: Option<&ty::TraitRef<'tcx>>, // None for boxed closures\n+    principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>, // None for boxed closures\n     partitioned_bounds: PartitionedBounds)\n     -> ty::ExistentialBounds\n     where AC: AstConv<'tcx>, RS:RegionScope\n@@ -1519,7 +1530,7 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   span: Span,\n                                   explicit_region_bounds: &[&ast::Lifetime],\n-                                  principal_trait_ref: Option<&ty::TraitRef<'tcx>>,\n+                                  principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>,\n                                   builtin_bounds: ty::BuiltinBounds)\n                                   -> Option<ty::Region>\n {\n@@ -1579,7 +1590,7 @@ fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     rscope: &RS,\n     span: Span,\n     region_bounds: &[&ast::Lifetime],\n-    principal_trait_ref: Option<&ty::TraitRef<'tcx>>, // None for closures\n+    principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>, // None for closures\n     builtin_bounds: ty::BuiltinBounds)\n     -> ty::Region\n {"}, {"sha": "44cc5fce53da35c81c0f118e2eff0b7382f2324f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -18,6 +18,7 @@ use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n use check::{instantiate_path, structurally_resolved_type, valid_range_bounds};\n use require_same_types;\n use util::nodemap::FnvHashMap;\n+use util::ppaux::Repr;\n \n use std::cmp;\n use std::collections::hash_map::{Occupied, Vacant};\n@@ -33,6 +34,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n+    debug!(\"check_pat(pat={},expected={})\",\n+           pat.repr(tcx),\n+           expected.repr(tcx));\n+\n     match pat.node {\n         ast::PatWild(_) => {\n             fcx.write_ty(pat.id, expected);"}, {"sha": "6e5fdbfac9fd3e6e102809a9c2c58f45abf42525", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -180,22 +180,22 @@ fn deduce_unboxed_closure_expectations_from_expected_type<'a,'tcx>(\n \n fn deduce_unboxed_closure_expectations_from_trait_ref<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n-    trait_ref: &ty::TraitRef<'tcx>)\n+    trait_ref: &ty::PolyTraitRef<'tcx>)\n     -> Option<(ty::FnSig<'tcx>, ty::UnboxedClosureKind)>\n {\n     let tcx = fcx.tcx();\n \n     debug!(\"deduce_unboxed_closure_expectations_from_object_type({})\",\n            trait_ref.repr(tcx));\n \n-    let kind = match tcx.lang_items.fn_trait_kind(trait_ref.def_id) {\n+    let kind = match tcx.lang_items.fn_trait_kind(trait_ref.def_id()) {\n         Some(k) => k,\n         None => { return None; }\n     };\n \n     debug!(\"found object type {}\", kind);\n \n-    let arg_param_ty = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n+    let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 0);\n     let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(&arg_param_ty);\n     debug!(\"arg_param_ty {}\", arg_param_ty.repr(tcx));\n \n@@ -205,7 +205,7 @@ fn deduce_unboxed_closure_expectations_from_trait_ref<'a,'tcx>(\n     };\n     debug!(\"input_tys {}\", input_tys.repr(tcx));\n \n-    let ret_param_ty = *trait_ref.substs.types.get(subst::TypeSpace, 1);\n+    let ret_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 1);\n     let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(&ret_param_ty);\n     debug!(\"ret_param_ty {}\", ret_param_ty.repr(tcx));\n "}, {"sha": "0d07957ba3d97413ab921c6c9b1d906f9c37f75f", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -222,15 +222,15 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     // argument type), but those cases have already\n                     // been ruled out when we deemed the trait to be\n                     // \"object safe\".\n-                    let substs = data.principal.substs.clone().with_self_ty(object_ty);\n                     let original_trait_ref =\n-                        Rc::new(ty::TraitRef::new(data.principal.def_id, substs));\n-                    let upcast_trait_ref = this.upcast(original_trait_ref.clone(), trait_def_id);\n+                        data.principal_trait_ref_with_self_ty(object_ty);\n+                    let upcast_trait_ref =\n+                        this.upcast(original_trait_ref.clone(), trait_def_id);\n                     debug!(\"original_trait_ref={} upcast_trait_ref={} target_trait={}\",\n                            original_trait_ref.repr(this.tcx()),\n                            upcast_trait_ref.repr(this.tcx()),\n                            trait_def_id.repr(this.tcx()));\n-                    let substs = upcast_trait_ref.substs.clone();\n+                    let substs = upcast_trait_ref.substs().clone();\n                     let origin = MethodTraitObject(MethodObject {\n                         trait_ref: upcast_trait_ref,\n                         object_trait_id: trait_def_id,\n@@ -257,7 +257,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                      .subst(self.tcx(), &impl_polytype.substs);\n                 let origin = MethodTypeParam(MethodParam { trait_ref: impl_trait_ref.clone(),\n                                                            method_num: method_num });\n-                (impl_trait_ref.substs.clone(), origin)\n+                (impl_trait_ref.substs().clone(), origin)\n             }\n \n             probe::TraitPick(trait_def_id, method_num) => {\n@@ -272,16 +272,16 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                                                  &trait_def.generics,\n                                                                  self.infcx().next_ty_var());\n \n-                let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs.clone()));\n+                let trait_ref = Rc::new(ty::bind(ty::TraitRef::new(trait_def_id, substs.clone())));\n                 let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n                                                            method_num: method_num });\n                 (substs, origin)\n             }\n \n             probe::WhereClausePick(ref trait_ref, method_num) => {\n-                let origin = MethodTypeParam(MethodParam { trait_ref: (*trait_ref).clone(),\n+                let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref.clone(),\n                                                            method_num: method_num });\n-                (trait_ref.substs.clone(), origin)\n+                (trait_ref.substs().clone(), origin)\n             }\n         }\n     }\n@@ -637,12 +637,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn upcast(&mut self,\n-              source_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+              source_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n               target_trait_def_id: ast::DefId)\n-              -> Rc<ty::TraitRef<'tcx>>\n+              -> Rc<ty::PolyTraitRef<'tcx>>\n     {\n         for super_trait_ref in traits::supertraits(self.tcx(), source_trait_ref.clone()) {\n-            if super_trait_ref.def_id == target_trait_def_id {\n+            if super_trait_ref.def_id() == target_trait_def_id {\n                 return super_trait_ref;\n             }\n         }"}, {"sha": "14bd0edda1078971536954825202f976585f5cf4", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -166,7 +166,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n     // Construct a trait-reference `self_ty : Trait<input_tys>`\n     let substs = subst::Substs::new_trait(input_types, Vec::new(), assoc_types, self_ty);\n-    let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs));\n+    let trait_ref = Rc::new(ty::bind(ty::TraitRef::new(trait_def_id, substs)));\n \n     // Construct an obligation\n     let obligation = traits::Obligation::misc(span,\n@@ -198,7 +198,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     // Note that as the method comes from a trait, it can only have\n     // late-bound regions from the fn itself, not the impl.\n     let ref bare_fn_ty = method_ty.fty;\n-    let fn_sig = bare_fn_ty.sig.subst(tcx, &trait_ref.substs);\n+    let fn_sig = bare_fn_ty.sig.subst(tcx, trait_ref.substs());\n     let fn_sig = fcx.infcx().replace_late_bound_regions_with_fresh_var(span,\n                                                                        infer::FnCall,\n                                                                        &fn_sig).0;\n@@ -221,7 +221,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     //\n     // Note that as the method comes from a trait, it should not have\n     // any late-bound regions appearing in its bounds.\n-    let method_bounds = method_ty.generics.to_bounds(fcx.tcx(), &trait_ref.substs);\n+    let method_bounds = method_ty.generics.to_bounds(fcx.tcx(), trait_ref.substs());\n     assert!(!method_bounds.has_escaping_regions());\n     fcx.add_obligations_for_parameters(\n         traits::ObligationCause::misc(span, fcx.body_id),\n@@ -293,7 +293,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n         origin: MethodTypeParam(MethodParam{trait_ref: trait_ref.clone(),\n                                             method_num: method_num}),\n         ty: fty,\n-        substs: trait_ref.substs.clone()\n+        substs: trait_ref.substs().clone()\n     };\n \n     debug!(\"callee = {}\", callee.repr(fcx.tcx()));\n@@ -379,7 +379,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         None => format!(\"\"),\n                         Some(trait_ref) => format!(\" of the trait `{}`\",\n                                                    ty::item_path_str(fcx.tcx(),\n-                                                                     trait_ref.def_id)),\n+                                                                     trait_ref.def_id())),\n                     };\n \n                     span_note!(fcx.sess(), method_span,"}, {"sha": "452d001fe8aa95fc42d8f577fd734f41b5a52f1d", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -59,10 +59,10 @@ struct Candidate<'tcx> {\n enum CandidateKind<'tcx> {\n     InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n     ObjectCandidate(MethodObject<'tcx>),\n-    ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n+    ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::PolyTraitRef<'tcx>>,\n                            subst::Substs<'tcx>, MethodIndex),\n     UnboxedClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClauseCandidate(Rc<ty::TraitRef<'tcx>>, MethodIndex),\n+    WhereClauseCandidate(Rc<ty::PolyTraitRef<'tcx>>, MethodIndex),\n }\n \n pub struct Pick<'tcx> {\n@@ -77,7 +77,7 @@ pub enum PickKind<'tcx> {\n     ObjectPick(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n     ExtensionImplPick(/* Impl */ ast::DefId, MethodIndex),\n     TraitPick(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClausePick(/* Trait */ Rc<ty::TraitRef<'tcx>>, MethodIndex),\n+    WhereClausePick(/* Trait */ Rc<ty::PolyTraitRef<'tcx>>, MethodIndex),\n }\n \n pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError>;\n@@ -231,9 +231,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                self_ty.repr(self.tcx()));\n \n         match self_ty.sty {\n-            ty::ty_trait(box ty::TyTrait { ref principal, bounds, .. }) => {\n-                self.assemble_inherent_candidates_from_object(self_ty, &*principal, bounds);\n-                self.assemble_inherent_impl_candidates_for_type(principal.def_id);\n+            ty::ty_trait(box ref data) => {\n+                self.assemble_inherent_candidates_from_object(self_ty, data);\n+                self.assemble_inherent_impl_candidates_for_type(data.principal.def_id());\n             }\n             ty::ty_enum(did, _) |\n             ty::ty_struct(did, _) |\n@@ -290,8 +290,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_inherent_candidates_from_object(&mut self,\n                                                 self_ty: Ty<'tcx>,\n-                                                principal: &ty::TraitRef<'tcx>,\n-                                                _bounds: ty::ExistentialBounds) {\n+                                                data: &ty::TyTrait<'tcx>) {\n         debug!(\"assemble_inherent_candidates_from_object(self_ty={})\",\n                self_ty.repr(self.tcx()));\n \n@@ -304,26 +303,20 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // a substitution that replaces `Self` with the object type\n         // itself. Hence, a `&self` method will wind up with an\n         // argument type like `&Trait`.\n-        let rcvr_substs = principal.substs.clone().with_self_ty(self_ty);\n-        let trait_ref = Rc::new(ty::TraitRef {\n-            def_id: principal.def_id,\n-            substs: rcvr_substs.clone()\n-        });\n-\n+        let trait_ref = data.principal_trait_ref_with_self_ty(self_ty);\n         self.elaborate_bounds(&[trait_ref.clone()], false, |this, new_trait_ref, m, method_num| {\n             let vtable_index =\n-                get_method_index(tcx, &*new_trait_ref,\n-                                 trait_ref.clone(), method_num);\n+                get_method_index(tcx, &*new_trait_ref, trait_ref.clone(), method_num);\n \n             let xform_self_ty =\n-                this.xform_self_ty(&m, &new_trait_ref.substs);\n+                this.xform_self_ty(&m, new_trait_ref.substs());\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 method_ty: m,\n                 kind: ObjectCandidate(MethodObject {\n                     trait_ref: new_trait_ref,\n-                    object_trait_id: principal.def_id,\n+                    object_trait_id: trait_ref.def_id(),\n                     method_num: method_num,\n                     real_index: vtable_index\n                 })\n@@ -358,27 +351,27 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         self.elaborate_bounds(bounds.as_slice(), true, |this, trait_ref, m, method_num| {\n             let xform_self_ty =\n-                this.xform_self_ty(&m, &trait_ref.substs);\n+                this.xform_self_ty(&m, trait_ref.substs());\n \n             debug!(\"found match: trait_ref={} substs={} m={}\",\n                    trait_ref.repr(this.tcx()),\n-                   trait_ref.substs.repr(this.tcx()),\n+                   trait_ref.substs().repr(this.tcx()),\n                    m.repr(this.tcx()));\n             assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n-                       trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n+                       trait_ref.substs().types.get_slice(subst::TypeSpace).len());\n             assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n-                       trait_ref.substs.regions().get_slice(subst::TypeSpace).len());\n+                       trait_ref.substs().regions().get_slice(subst::TypeSpace).len());\n             assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n-                       trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n+                       trait_ref.substs().types.get_slice(subst::SelfSpace).len());\n             assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n-                       trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n+                       trait_ref.substs().regions().get_slice(subst::SelfSpace).len());\n \n             // Because this trait derives from a where-clause, it\n             // should not contain any inference variables or other\n             // artifacts. This means it is safe to put into the\n             // `WhereClauseCandidate` and (eventually) into the\n             // `WhereClausePick`.\n-            assert!(trait_ref.substs.types.iter().all(|&t| !ty::type_needs_infer(t)));\n+            assert!(trait_ref.substs().types.iter().all(|&t| !ty::type_needs_infer(t)));\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -392,10 +385,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     // create the candidates.\n     fn elaborate_bounds(\n         &mut self,\n-        bounds: &[Rc<ty::TraitRef<'tcx>>],\n+        bounds: &[Rc<ty::PolyTraitRef<'tcx>>],\n         num_includes_types: bool,\n         mk_cand: for<'b> |this: &mut ProbeContext<'b, 'tcx>,\n-                          tr: Rc<ty::TraitRef<'tcx>>,\n+                          tr: Rc<ty::PolyTraitRef<'tcx>>,\n                           m: Rc<ty::Method<'tcx>>,\n                           method_num: uint|)\n     {\n@@ -405,20 +398,20 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let mut cache = HashSet::new();\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n             // Already visited this trait, skip it.\n-            if !cache.insert(bound_trait_ref.def_id) {\n+            if !cache.insert(bound_trait_ref.def_id()) {\n                 continue;\n             }\n \n             let (pos, method) = match trait_method(tcx,\n-                                                   bound_trait_ref.def_id,\n+                                                   bound_trait_ref.def_id(),\n                                                    self.method_name,\n                                                    num_includes_types) {\n                 Some(v) => v,\n                 None => { continue; }\n             };\n \n             if !self.has_applicable_self(&*method) {\n-                self.record_static_candidate(TraitSource(bound_trait_ref.def_id));\n+                self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));\n             } else {\n                 mk_cand(self, bound_trait_ref, method, pos);\n             }\n@@ -510,7 +503,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             // Determine the receiver type that the method itself expects.\n             let xform_self_ty =\n-                self.xform_self_ty(&method, &impl_trait_ref.substs);\n+                self.xform_self_ty(&method, impl_trait_ref.substs());\n \n             debug!(\"xform_self_ty={}\", xform_self_ty.repr(self.tcx()));\n \n@@ -1007,8 +1000,8 @@ fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n // Determine the index of a method in the list of all methods belonging\n // to a trait and its supertraits.\n fn get_method_index<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                          trait_ref: &ty::TraitRef<'tcx>,\n-                          subtrait: Rc<ty::TraitRef<'tcx>>,\n+                          trait_ref: &ty::PolyTraitRef<'tcx>,\n+                          subtrait: Rc<ty::PolyTraitRef<'tcx>>,\n                           n_method: uint) -> uint {\n     // We need to figure the \"real index\" of the method in a\n     // listing of all the methods of an object. We do this by\n@@ -1017,10 +1010,10 @@ fn get_method_index<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // methods from them.\n     let mut method_count = n_method;\n     ty::each_bound_trait_and_supertraits(tcx, &[subtrait], |bound_ref| {\n-        if bound_ref.def_id == trait_ref.def_id {\n+        if bound_ref.def_id() == trait_ref.def_id() {\n             false\n         } else {\n-            let trait_items = ty::trait_items(tcx, bound_ref.def_id);\n+            let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n             for trait_item in trait_items.iter() {\n                 match *trait_item {\n                     ty::MethodTraitItem(_) => method_count += 1,\n@@ -1043,7 +1036,7 @@ impl<'tcx> Candidate<'tcx> {\n                     InherentImplPick(def_id)\n                 }\n                 ObjectCandidate(ref data) => {\n-                    ObjectPick(data.trait_ref.def_id, data.method_num, data.real_index)\n+                    ObjectPick(data.trait_ref.def_id(), data.method_num, data.real_index)\n                 }\n                 ExtensionImplCandidate(def_id, _, _, index) => {\n                     ExtensionImplPick(def_id, index)\n@@ -1057,7 +1050,7 @@ impl<'tcx> Candidate<'tcx> {\n                     // inference variables or other artifacts. This\n                     // means they are safe to put into the\n                     // `WhereClausePick`.\n-                    assert!(trait_ref.substs.types.iter().all(|&t| !ty::type_needs_infer(t)));\n+                    assert!(trait_ref.substs().types.iter().all(|&t| !ty::type_needs_infer(t)));\n \n                     WhereClausePick((*trait_ref).clone(), index)\n                 }\n@@ -1068,10 +1061,10 @@ impl<'tcx> Candidate<'tcx> {\n     fn to_source(&self) -> CandidateSource {\n         match self.kind {\n             InherentImplCandidate(def_id, _) => ImplSource(def_id),\n-            ObjectCandidate(ref obj) => TraitSource(obj.trait_ref.def_id),\n+            ObjectCandidate(ref obj) => TraitSource(obj.trait_ref.def_id()),\n             ExtensionImplCandidate(def_id, _, _, _) => ImplSource(def_id),\n             UnboxedClosureCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n-            WhereClauseCandidate(ref trait_ref, _) => TraitSource(trait_ref.def_id),\n+            WhereClauseCandidate(ref trait_ref, _) => TraitSource(trait_ref.def_id()),\n         }\n     }\n \n@@ -1086,7 +1079,7 @@ impl<'tcx> Candidate<'tcx> {\n             }\n             ExtensionImplCandidate(_, ref trait_ref, _, method_num) |\n             WhereClauseCandidate(ref trait_ref, method_num) => {\n-                Some((trait_ref.def_id, method_num))\n+                Some((trait_ref.def_id(), method_num))\n             }\n         }\n     }"}, {"sha": "1e9f7992fb7423e86e72863c2235ce4af08629b2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 42, "deletions": 62, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -625,23 +625,20 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n         let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n         check_bare_fn(ccx, &**decl, &**body, it.id, fn_pty.ty, param_env);\n       }\n-      ast::ItemImpl(_, _, ref opt_trait_ref, _, ref impl_items) => {\n+      ast::ItemImpl(_, _, _, _, ref impl_items) => {\n         debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n \n         let impl_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n \n-        match *opt_trait_ref {\n-            Some(ref ast_trait_ref) => {\n-                let impl_trait_ref =\n-                    ty::node_id_to_trait_ref(ccx.tcx, ast_trait_ref.ref_id);\n+          match ty::impl_trait_ref(ccx.tcx, local_def(it.id)) {\n+              Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n                                                it.span,\n-                                               ast_trait_ref,\n                                                &*impl_trait_ref,\n                                                impl_items.as_slice());\n-            }\n-            None => { }\n-        }\n+              }\n+              None => { }\n+          }\n \n         for impl_item in impl_items.iter() {\n             match *impl_item {\n@@ -739,12 +736,11 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_span: Span,\n-                                            ast_trait_ref: &ast::TraitRef,\n-                                            impl_trait_ref: &ty::TraitRef<'tcx>,\n+                                            impl_trait_ref: &ty::PolyTraitRef<'tcx>,\n                                             impl_items: &[ast::ImplItem]) {\n     // Locate trait methods\n     let tcx = ccx.tcx;\n-    let trait_items = ty::trait_items(tcx, impl_trait_ref.def_id);\n+    let trait_items = ty::trait_items(tcx, impl_trait_ref.def_id());\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n@@ -772,21 +768,16 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                     impl_method.span,\n                                                     impl_method.pe_body().id,\n                                                     &**trait_method_ty,\n-                                                    impl_trait_ref);\n+                                                    &*impl_trait_ref);\n                             }\n                             _ => {\n                                 // This is span_bug as it should have already been\n                                 // caught in resolve.\n-                                tcx.sess\n-                                   .span_bug(impl_method.span,\n-                                             format!(\"item `{}` is of a \\\n-                                                      different kind from \\\n-                                                      its trait `{}`\",\n-                                                     token::get_name(\n-                                                        impl_item_ty.name()),\n-                                                     pprust::path_to_string(\n-                                                        &ast_trait_ref.path))\n-                                             .as_slice());\n+                                tcx.sess.span_bug(\n+                                    impl_method.span,\n+                                    format!(\"item `{}` is of a different kind from its trait `{}`\",\n+                                            token::get_name(impl_item_ty.name()),\n+                                            impl_trait_ref.repr(tcx)).as_slice());\n                             }\n                         }\n                     }\n@@ -795,11 +786,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         // caught in resolve.\n                         tcx.sess.span_bug(\n                             impl_method.span,\n-                            format!(\n-                                \"method `{}` is not a member of trait `{}`\",\n-                                token::get_name(impl_item_ty.name()),\n-                                pprust::path_to_string(\n-                                    &ast_trait_ref.path)).as_slice());\n+                            format!(\"method `{}` is not a member of trait `{}`\",\n+                                    token::get_name(impl_item_ty.name()),\n+                                    impl_trait_ref.repr(tcx)).as_slice());\n                     }\n                 }\n             }\n@@ -812,27 +801,19 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 // corresponding type definition in the trait.\n                 let opt_associated_type =\n                     trait_items.iter()\n-                               .find(|ti| {\n-                                   ti.name() == typedef_ty.name()\n-                               });\n+                               .find(|ti| ti.name() == typedef_ty.name());\n                 match opt_associated_type {\n                     Some(associated_type) => {\n                         match (associated_type, &typedef_ty) {\n-                            (&ty::TypeTraitItem(_),\n-                             &ty::TypeTraitItem(_)) => {}\n+                            (&ty::TypeTraitItem(_), &ty::TypeTraitItem(_)) => {}\n                             _ => {\n                                 // This is `span_bug` as it should have\n                                 // already been caught in resolve.\n-                                tcx.sess\n-                                   .span_bug(typedef.span,\n-                                             format!(\"item `{}` is of a \\\n-                                                      different kind from \\\n-                                                      its trait `{}`\",\n-                                                     token::get_name(\n-                                                        typedef_ty.name()),\n-                                                     pprust::path_to_string(\n-                                                        &ast_trait_ref.path))\n-                                             .as_slice());\n+                                tcx.sess.span_bug(\n+                                    typedef.span,\n+                                    format!(\"item `{}` is of a different kind from its trait `{}`\",\n+                                            token::get_name(typedef_ty.name()),\n+                                            impl_trait_ref.repr(tcx)).as_slice());\n                             }\n                         }\n                     }\n@@ -845,8 +826,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 \"associated type `{}` is not a member of \\\n                                  trait `{}`\",\n                                 token::get_name(typedef_ty.name()),\n-                                pprust::path_to_string(\n-                                    &ast_trait_ref.path)).as_slice());\n+                                impl_trait_ref.repr(tcx)).as_slice());\n                     }\n                 }\n             }\n@@ -855,7 +835,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // Check for missing items from trait\n     let provided_methods = ty::provided_trait_methods(tcx,\n-                                                      impl_trait_ref.def_id);\n+                                                      impl_trait_ref.def_id());\n     let mut missing_methods = Vec::new();\n     for trait_item in trait_items.iter() {\n         match *trait_item {\n@@ -870,8 +850,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         }\n                     });\n                 let is_provided =\n-                    provided_methods.iter().any(\n-                        |m| m.name == trait_method.name);\n+                    provided_methods.iter().any(|m| m.name == trait_method.name);\n                 if !is_implemented && !is_provided {\n                     missing_methods.push(format!(\"`{}`\", token::get_name(trait_method.name)));\n                 }\n@@ -915,7 +894,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                              impl_m_span: Span,\n                              impl_m_body_id: ast::NodeId,\n                              trait_m: &ty::Method<'tcx>,\n-                             impl_trait_ref: &ty::TraitRef<'tcx>) {\n+                             impl_trait_ref: &ty::PolyTraitRef<'tcx>) {\n     debug!(\"compare_impl_method(impl_trait_ref={})\",\n            impl_trait_ref.repr(tcx));\n \n@@ -945,7 +924,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let infcx = infer::new_infer_ctxt(tcx);\n \n-    let trait_to_impl_substs = &impl_trait_ref.substs;\n+    let trait_to_impl_substs = impl_trait_ref.substs();\n \n     // Try to give more informative error messages about self typing\n     // mismatches.  Note that any mismatch will also be detected\n@@ -1167,20 +1146,20 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     let trait_bound =\n                         trait_bound.subst(tcx, &trait_to_skol_substs);\n                     let infcx = infer::new_infer_ctxt(tcx);\n-                    infer::mk_sub_trait_refs(&infcx,\n-                                             true,\n-                                             infer::Misc(impl_m_span),\n-                                             trait_bound,\n-                                             impl_trait_bound.clone()).is_ok()\n+                    infer::mk_sub_poly_trait_refs(&infcx,\n+                                                  true,\n+                                                  infer::Misc(impl_m_span),\n+                                                  trait_bound,\n+                                                  impl_trait_bound.clone()).is_ok()\n                 });\n \n             if !found_match_in_trait {\n                 span_err!(tcx.sess, impl_m_span, E0052,\n-                    \"in method `{}`, type parameter {} requires bound `{}`, which is not \\\n-                     required by the corresponding type parameter in the trait declaration\",\n-                    token::get_name(trait_m.name),\n-                    i,\n-                    ppaux::trait_ref_to_string(tcx, &*impl_trait_bound));\n+                          \"in method `{}`, type parameter {} requires bound `{}`, which is not \\\n+                           required by the corresponding type parameter in the trait declaration\",\n+                          token::get_name(trait_m.name),\n+                          i,\n+                          impl_trait_bound.user_string(tcx));\n             }\n         }\n     }\n@@ -1647,7 +1626,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn write_object_cast(&self,\n                              key: ast::NodeId,\n-                             trait_ref: Rc<ty::TraitRef<'tcx>>) {\n+                             trait_ref: Rc<ty::PolyTraitRef<'tcx>>) {\n         debug!(\"write_object_cast key={} trait_ref={}\",\n                key, trait_ref.repr(self.tcx()));\n         self.inh.object_cast_map.borrow_mut().insert(key, trait_ref);\n@@ -1745,7 +1724,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.register_unsize_obligations(span, &**u)\n             }\n             ty::UnsizeVtable(ref ty_trait, self_ty) => {\n-                vtable::check_object_safety(self.tcx(), &ty_trait.principal, span);\n+                vtable::check_object_safety(self.tcx(), ty_trait, span);\n+\n                 // If the type is `Foo+'a`, ensures that the type\n                 // being cast to `Foo+'a` implements `Foo`:\n                 vtable::register_object_cast_obligations(self,"}, {"sha": "4a10c698f7d1fd956acf046ca3ae7e91037f4384", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 15, "deletions": 28, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use check::{FnCtxt, structurally_resolved_type};\n-use middle::subst::{SelfSpace, FnSpace};\n+use middle::subst::{FnSpace};\n use middle::traits;\n use middle::traits::{SelectionError, OutputTypeParameterMismatch, Overflow, Unimplemented};\n use middle::traits::{Obligation, ObligationCause};\n@@ -44,7 +44,7 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n             // Ensure that if ~T is cast to ~Trait, then T : Trait\n             push_cast_obligation(fcx, cast_expr, object_trait, referent_ty);\n-            check_object_safety(fcx.tcx(), &object_trait.principal, source_expr.span);\n+            check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n         }\n \n         (&ty::ty_rptr(referent_region, ty::mt { ty: referent_ty,\n@@ -68,7 +68,7 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                target_region,\n                                referent_region);\n \n-                check_object_safety(fcx.tcx(), &object_trait.principal, source_expr.span);\n+                check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n             }\n         }\n \n@@ -132,24 +132,19 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n // self by value, has no type parameters and does not use the `Self` type, except\n // in self position.\n pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 object_trait: &ty::TraitRef<'tcx>,\n-                                 span: Span) {\n-\n-    let mut object = object_trait.clone();\n-    if object.substs.types.len(SelfSpace) == 0 {\n-        object.substs.types.push(SelfSpace, ty::mk_err());\n-    }\n-\n-    let object = Rc::new(object);\n-    for tr in traits::supertraits(tcx, object) {\n+                                 object_trait: &ty::TyTrait<'tcx>,\n+                                 span: Span)\n+{\n+    let object_trait_ref = object_trait.principal_trait_ref_with_self_ty(ty::mk_err());\n+    for tr in traits::supertraits(tcx, object_trait_ref) {\n         check_object_safety_inner(tcx, &*tr, span);\n     }\n }\n \n fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 object_trait: &ty::TraitRef<'tcx>,\n+                                 object_trait: &ty::PolyTraitRef<'tcx>,\n                                  span: Span) {\n-    let trait_items = ty::trait_items(tcx, object_trait.def_id);\n+    let trait_items = ty::trait_items(tcx, object_trait.def_id());\n \n     let mut errors = Vec::new();\n     for item in trait_items.iter() {\n@@ -163,7 +158,7 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let mut errors = errors.iter().flat_map(|x| x.iter()).peekable();\n     if errors.peek().is_some() {\n-        let trait_name = ty::item_path_str(tcx, object_trait.def_id);\n+        let trait_name = ty::item_path_str(tcx, object_trait.def_id());\n         span_err!(tcx.sess, span, E0038,\n             \"cannot convert to a trait object because trait `{}` is not object-safe\",\n             trait_name);\n@@ -237,7 +232,7 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   span: Span,\n                                                   object_trait: &ty::TyTrait<'tcx>,\n                                                   referent_ty: Ty<'tcx>)\n-                                                  -> Rc<ty::TraitRef<'tcx>>\n+                                                  -> Rc<ty::PolyTraitRef<'tcx>>\n {\n     // We can only make objects from sized types.\n     fcx.register_builtin_bound(\n@@ -256,17 +251,9 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            referent_ty.repr(fcx.tcx()),\n            object_trait_ty.repr(fcx.tcx()));\n \n-    // Take the type parameters from the object type, but set\n-    // the Self type (which is unknown, for the object type)\n-    // to be the type we are casting from.\n-    let mut object_substs = object_trait.principal.substs.clone();\n-    assert!(object_substs.self_ty().is_none());\n-    object_substs.types.push(SelfSpace, referent_ty);\n-\n     // Create the obligation for casting from T to Trait.\n     let object_trait_ref =\n-        Rc::new(ty::TraitRef { def_id: object_trait.principal.def_id,\n-                               substs: object_substs });\n+        object_trait.principal_trait_ref_with_self_ty(referent_ty);\n     let object_obligation =\n         Obligation::new(\n             ObligationCause::new(span,\n@@ -457,7 +444,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            trait_ref.repr(fcx.tcx()),\n            self_ty.repr(fcx.tcx()),\n            obligation.repr(fcx.tcx()));\n-    let all_types = &trait_ref.substs.types;\n+    let all_types = &trait_ref.substs().types;\n     if all_types.iter().any(|&t| ty::type_is_error(t)) {\n     } else if all_types.iter().any(|&t| ty::type_needs_infer(t)) {\n         // This is kind of a hack: it frequently happens that some earlier\n@@ -476,7 +463,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // anyway. In that case, why inundate the user.\n         if !fcx.tcx().sess.has_errors() {\n             if fcx.ccx.tcx.lang_items.sized_trait()\n-                  .map_or(false, |sized_id| sized_id == trait_ref.def_id) {\n+                  .map_or(false, |sized_id| sized_id == trait_ref.def_id()) {\n                 fcx.tcx().sess.span_err(\n                     obligation.cause.span,\n                     format!("}, {"sha": "e11f388b1160d427ef56606e9679d9798917d1d5", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -186,7 +186,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             // There are special rules that apply to drop.\n             if\n-                fcx.tcx().lang_items.drop_trait() == Some(trait_ref.def_id) &&\n+                fcx.tcx().lang_items.drop_trait() == Some(trait_ref.def_id()) &&\n                 !attr::contains_name(item.attrs.as_slice(), \"unsafe_destructor\")\n             {\n                 match self_ty.sty {\n@@ -200,7 +200,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 }\n             }\n \n-            if fcx.tcx().lang_items.copy_trait() == Some(trait_ref.def_id) {\n+            if fcx.tcx().lang_items.copy_trait() == Some(trait_ref.def_id()) {\n                 // This is checked in coherence.\n                 return\n             }\n@@ -219,7 +219,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 traits::ObligationCause::new(\n                     item.span,\n                     fcx.body_id,\n-                    traits::ItemObligation(trait_ref.def_id));\n+                    traits::ItemObligation(trait_ref.def_id()));\n \n             // Find the supertrait bounds. This will add `int:Bar`.\n             let predicates = ty::predicates_for_trait_ref(fcx.tcx(), &trait_ref);\n@@ -264,18 +264,18 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n     ///\n     /// Note that it does not (currently, at least) check that `A : Copy` (that check is delegated\n     /// to the point where impl `A : Trait<B>` is implemented).\n-    pub fn check_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n-        let trait_def = ty::lookup_trait_def(self.fcx.tcx(), trait_ref.def_id);\n+    pub fn check_trait_ref(&mut self, trait_ref: &ty::PolyTraitRef<'tcx>) {\n+        let trait_def = ty::lookup_trait_def(self.fcx.tcx(), trait_ref.def_id());\n \n-        let bounds = trait_def.generics.to_bounds(self.tcx(), &trait_ref.substs);\n+        let bounds = trait_def.generics.to_bounds(self.tcx(), trait_ref.substs());\n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n                 self.span,\n                 self.fcx.body_id,\n-                traits::ItemObligation(trait_ref.def_id)),\n+                traits::ItemObligation(trait_ref.def_id())),\n             &bounds);\n \n-        for &ty in trait_ref.substs.types.iter() {\n+        for &ty in trait_ref.substs().types.iter() {\n             self.check_traits_in_ty(ty);\n         }\n     }"}, {"sha": "e9a3db1b0e6aa8ef9567e323c73c52332a95d4cc", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -64,7 +64,7 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n         }\n \n         ty_trait(ref t) => {\n-            Some(t.principal.def_id)\n+            Some(t.principal.def_id())\n         }\n \n         ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n@@ -339,7 +339,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         // Record all the trait items.\n         for trait_ref in associated_traits.iter() {\n-            self.add_trait_impl(trait_ref.def_id, impl_def_id);\n+            self.add_trait_impl(trait_ref.def_id(), impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to"}, {"sha": "bb8efd29910702a2f4b0b3f23246b10b8670bf8e", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -55,7 +55,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                         self.check_def_id(item.span, def_id);\n                     }\n                     ty::ty_trait(box ty::TyTrait{ ref principal, ..}) => {\n-                        self.check_def_id(item.span, principal.def_id);\n+                        self.check_def_id(item.span, principal.def_id());\n                     }\n                     _ => {\n                         span_err!(self.tcx.sess, item.span, E0118,"}, {"sha": "6a24bdbb9f0ed7f21f237581cf3efb13d84b593e", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -45,7 +45,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n                     }\n \n                     Some(trait_ref) => {\n-                        let trait_def = ty::lookup_trait_def(self.tcx, trait_ref.def_id);\n+                        let trait_def = ty::lookup_trait_def(self.tcx, trait_ref.def_id());\n                         match (trait_def.unsafety, unsafety) {\n                             (ast::Unsafety::Normal, ast::Unsafety::Unsafe) => {\n                                 self.tcx.sess.span_err("}, {"sha": "8930ae0116052d154493180d7b9db45ff741f67a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -652,7 +652,7 @@ fn is_associated_type_valid_for_param(ty: Ty,\n     if let ty::ty_param(param_ty) = ty.sty {\n         let type_parameter = generics.types.get(param_ty.space, param_ty.idx);\n         for trait_bound in type_parameter.bounds.trait_bounds.iter() {\n-            if trait_bound.def_id == trait_id {\n+            if trait_bound.def_id() == trait_id {\n                 return true\n             }\n         }\n@@ -1638,8 +1638,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let param_id = trait_id;\n \n     let self_trait_ref =\n-        Rc::new(ty::TraitRef { def_id: local_def(trait_id),\n-                               substs: (*substs).clone() });\n+        Rc::new(ty::bind(ty::TraitRef { def_id: local_def(trait_id),\n+                                        substs: (*substs).clone() }));\n \n     let def = ty::TypeParameterDef {\n         space: subst::SelfSpace,\n@@ -2015,7 +2015,7 @@ fn compute_bounds<'tcx,AC>(this: &AC,\n                             &param_bounds,\n                             span);\n \n-    param_bounds.trait_bounds.sort_by(|a,b| a.def_id.cmp(&b.def_id));\n+    param_bounds.trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n \n     param_bounds\n }\n@@ -2031,13 +2031,13 @@ fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n             tcx,\n             param_bounds.trait_bounds.as_slice(),\n             |trait_ref| {\n-                let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id);\n+                let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id());\n                 if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {\n                     span_err!(tcx.sess, span, E0129,\n                               \"incompatible bounds on type parameter `{}`, \\\n                                bound `{}` does not allow unsized type\",\n                               name_of_bounded_thing.user_string(tcx),\n-                              ppaux::trait_ref_to_string(tcx, &*trait_ref));\n+                              trait_ref.user_string(tcx));\n                 }\n                 true\n             });\n@@ -2057,14 +2057,14 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n                                      trait_bounds,\n                                      region_bounds } =\n         astconv::partition_bounds(this.tcx(), span, all_bounds.as_slice());\n-    let trait_bounds: Vec<Rc<ty::TraitRef>> =\n+    let trait_bounds: Vec<Rc<ty::PolyTraitRef>> =\n         trait_bounds.into_iter()\n         .map(|bound| {\n-            astconv::instantiate_trait_ref(this,\n-                                           &ExplicitRscope,\n-                                           &bound.trait_ref,\n-                                           Some(param_ty.to_ty(this.tcx())),\n-                                           AllowEqConstraints::Allow)\n+            astconv::instantiate_poly_trait_ref(this,\n+                                                &ExplicitRscope,\n+                                                bound,\n+                                                Some(param_ty.to_ty(this.tcx())),\n+                                                AllowEqConstraints::Allow)\n         })\n         .collect();\n     let region_bounds: Vec<ty::Region> ="}, {"sha": "a70058b977ead451f886f61750b1e92025b991f8", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -777,13 +777,13 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n-                let trait_def = ty::lookup_trait_def(self.tcx(), principal.def_id);\n+                let trait_def = ty::lookup_trait_def(self.tcx(), principal.def_id());\n                 let generics = &trait_def.generics;\n \n                 // Traits DO have a Self type parameter, but it is\n                 // erased from object types.\n                 assert!(!generics.types.is_empty_in(subst::SelfSpace) &&\n-                        principal.substs.types.is_empty_in(subst::SelfSpace));\n+                        principal.substs().types.is_empty_in(subst::SelfSpace));\n \n                 // Traits never declare region parameters in the self\n                 // space.\n@@ -799,10 +799,10 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_region(bounds.region_bound, contra);\n \n                 self.add_constraints_from_substs(\n-                    principal.def_id,\n+                    principal.def_id(),\n                     generics.types.get_slice(subst::TypeSpace),\n                     generics.regions.get_slice(subst::TypeSpace),\n-                    &principal.substs,\n+                    principal.substs(),\n                     variance);\n             }\n "}, {"sha": "49e45c9e56ca4fb7c9cd3183368d0bb75f145689", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -281,7 +281,7 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n     // If this is an impl for a #[doc(hidden)] trait, be sure to not inline it.\n     match associated_trait {\n         Some(ref t) => {\n-            let trait_attrs = load_attrs(cx, tcx, t.def_id);\n+            let trait_attrs = load_attrs(cx, tcx, t.def_id());\n             if trait_attrs.iter().any(|a| is_doc_hidden(a)) {\n                 return None\n             }"}, {"sha": "9509986af4787ae9647da9d96071ce0ffe07dc4d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf0fbeee9b6e90de6e7d44ab9461963729f0365/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3cf0fbeee9b6e90de6e7d44ab9461963729f0365", "patch": "@@ -575,6 +575,12 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n     }\n }\n \n+impl<'tcx> Clean<TyParamBound> for ty::PolyTraitRef<'tcx> {\n+    fn clean(&self, cx: &DocContext) -> TyParamBound {\n+        self.value.clean(cx)\n+    }\n+}\n+\n impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n         let tcx = match cx.tcx_opt() {\n@@ -1391,8 +1397,10 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             }\n             ty::ty_struct(did, ref substs) |\n             ty::ty_enum(did, ref substs) |\n-            ty::ty_trait(box ty::TyTrait { principal: ty::TraitRef { def_id: did, ref substs },\n-                                           .. }) => {\n+            ty::ty_trait(box ty::TyTrait {\n+                principal: ty::Binder { value: ty::TraitRef { def_id: did, ref substs } },\n+                .. }) =>\n+            {\n                 let fqn = csearch::get_item_path(cx.tcx(), did);\n                 let fqn: Vec<String> = fqn.into_iter().map(|i| {\n                     i.to_string()"}]}