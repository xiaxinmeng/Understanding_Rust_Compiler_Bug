{"sha": "4e4092f8ccb4b7f8b3c4a5cdcbfcdfafa8f5f1e1", "node_id": "C_kwDOAAsO6NoAKDRlNDA5MmY4Y2NiNGI3ZjhiM2M0YTVjZGNiZmNkZmFmYThmNWYxZTE", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-10-18T23:34:45Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-10-25T01:07:23Z"}, "message": "rustc_codegen_ssa: use more consistent naming.\n\nEnsure:\n- builders always have a `bx` suffix;\n- backend basic blocks always have an `llbb` suffix,\n- paired builders and basic blocks have consistent prefixes.", "tree": {"sha": "0819ca2b0c6e526223860dc336d792d38e455b44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0819ca2b0c6e526223860dc336d792d38e455b44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e4092f8ccb4b7f8b3c4a5cdcbfcdfafa8f5f1e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e4092f8ccb4b7f8b3c4a5cdcbfcdfafa8f5f1e1", "html_url": "https://github.com/rust-lang/rust/commit/4e4092f8ccb4b7f8b3c4a5cdcbfcdfafa8f5f1e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e4092f8ccb4b7f8b3c4a5cdcbfcdfafa8f5f1e1/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fcf850d7942804990a1d2e3fe036622a0fe4c74", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fcf850d7942804990a1d2e3fe036622a0fe4c74", "html_url": "https://github.com/rust-lang/rust/commit/7fcf850d7942804990a1d2e3fe036622a0fe4c74"}], "stats": {"total": 61, "additions": 31, "deletions": 30}, "files": [{"sha": "e7abae665e357b3712effd43fd94bd7394c9d78a", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4e4092f8ccb4b7f8b3c4a5cdcbfcdfafa8f5f1e1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4092f8ccb4b7f8b3c4a5cdcbfcdfafa8f5f1e1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=4e4092f8ccb4b7f8b3c4a5cdcbfcdfafa8f5f1e1", "patch": "@@ -95,10 +95,10 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n \n             debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n             let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", self.bb, target);\n-            let trampoline = Bx::append_block(fx.cx, fx.llfn, name);\n-            let mut trampoline_bx = Bx::build(fx.cx, trampoline);\n+            let trampoline_llbb = Bx::append_block(fx.cx, fx.llfn, name);\n+            let mut trampoline_bx = Bx::build(fx.cx, trampoline_llbb);\n             trampoline_bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n-            trampoline\n+            trampoline_llbb\n         } else {\n             lltarget\n         }\n@@ -1459,20 +1459,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 //          bar();\n                 //      }\n                 Some(&mir::TerminatorKind::Abort) => {\n-                    let cs_bb =\n+                    let cs_llbb =\n                         Bx::append_block(self.cx, self.llfn, &format!(\"cs_funclet{:?}\", bb));\n-                    let cp_bb =\n+                    let cp_llbb =\n                         Bx::append_block(self.cx, self.llfn, &format!(\"cp_funclet{:?}\", bb));\n-                    ret_llbb = cs_bb;\n+                    ret_llbb = cs_llbb;\n \n-                    let mut cs_bx = Bx::build(self.cx, cs_bb);\n-                    let cs = cs_bx.catch_switch(None, None, &[cp_bb]);\n+                    let mut cs_bx = Bx::build(self.cx, cs_llbb);\n+                    let cs = cs_bx.catch_switch(None, None, &[cp_llbb]);\n \n                     // The \"null\" here is actually a RTTI type descriptor for the\n                     // C++ personality function, but `catch (...)` has no type so\n                     // it's null. The 64 here is actually a bitfield which\n                     // represents that this is a catch-all block.\n-                    let mut cp_bx = Bx::build(self.cx, cp_bb);\n+                    let mut cp_bx = Bx::build(self.cx, cp_llbb);\n                     let null = cp_bx.const_null(\n                         cp_bx.type_i8p_ext(cp_bx.cx().data_layout().instruction_address_space),\n                     );\n@@ -1481,30 +1481,31 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     cp_bx.br(llbb);\n                 }\n                 _ => {\n-                    let cleanup_bb =\n+                    let cleanup_llbb =\n                         Bx::append_block(self.cx, self.llfn, &format!(\"funclet_{:?}\", bb));\n-                    ret_llbb = cleanup_bb;\n-                    let mut cleanup_bx = Bx::build(self.cx, cleanup_bb);\n+                    ret_llbb = cleanup_llbb;\n+                    let mut cleanup_bx = Bx::build(self.cx, cleanup_llbb);\n                     funclet = cleanup_bx.cleanup_pad(None, &[]);\n                     cleanup_bx.br(llbb);\n                 }\n             }\n             self.funclets[bb] = Some(funclet);\n             ret_llbb\n         } else {\n-            let bb = Bx::append_block(self.cx, self.llfn, \"cleanup\");\n-            let mut bx = Bx::build(self.cx, bb);\n+            let cleanup_llbb = Bx::append_block(self.cx, self.llfn, \"cleanup\");\n+            let mut cleanup_bx = Bx::build(self.cx, cleanup_llbb);\n \n             let llpersonality = self.cx.eh_personality();\n             let llretty = self.landing_pad_type();\n-            let lp = bx.cleanup_landing_pad(llretty, llpersonality);\n+            let lp = cleanup_bx.cleanup_landing_pad(llretty, llpersonality);\n \n-            let slot = self.get_personality_slot(&mut bx);\n-            slot.storage_live(&mut bx);\n-            Pair(bx.extract_value(lp, 0), bx.extract_value(lp, 1)).store(&mut bx, slot);\n+            let slot = self.get_personality_slot(&mut cleanup_bx);\n+            slot.storage_live(&mut cleanup_bx);\n+            Pair(cleanup_bx.extract_value(lp, 0), cleanup_bx.extract_value(lp, 1))\n+                .store(&mut cleanup_bx, slot);\n \n-            bx.br(llbb);\n-            bx.llbb()\n+            cleanup_bx.br(llbb);\n+            cleanup_llbb\n         }\n     }\n "}, {"sha": "da9aaf00ecf6e83f4e9c62af5df4e1d054d5a08c", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4e4092f8ccb4b7f8b3c4a5cdcbfcdfafa8f5f1e1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4092f8ccb4b7f8b3c4a5cdcbfcdfafa8f5f1e1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=4e4092f8ccb4b7f8b3c4a5cdcbfcdfafa8f5f1e1", "patch": "@@ -148,10 +148,10 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     let debug_context = cx.create_function_debug_context(instance, &fn_abi, llfn, &mir);\n \n     let start_llbb = Bx::append_block(cx, llfn, \"start\");\n-    let mut bx = Bx::build(cx, start_llbb);\n+    let mut start_bx = Bx::build(cx, start_llbb);\n \n     if mir.basic_blocks.iter().any(|bb| bb.is_cleanup) {\n-        bx.set_personality_fn(cx.eh_personality());\n+        start_bx.set_personality_fn(cx.eh_personality());\n     }\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n@@ -180,7 +180,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         caller_location: None,\n     };\n \n-    fx.per_local_var_debug_info = fx.compute_per_local_var_debug_info(&mut bx);\n+    fx.per_local_var_debug_info = fx.compute_per_local_var_debug_info(&mut start_bx);\n \n     // Evaluate all required consts; codegen later assumes that CTFE will never fail.\n     let mut all_consts_ok = true;\n@@ -206,29 +206,29 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     // Allocate variable and temp allocas\n     fx.locals = {\n-        let args = arg_local_refs(&mut bx, &mut fx, &memory_locals);\n+        let args = arg_local_refs(&mut start_bx, &mut fx, &memory_locals);\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n-            let layout = bx.layout_of(fx.monomorphize(decl.ty));\n+            let layout = start_bx.layout_of(fx.monomorphize(decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n             if local == mir::RETURN_PLACE && fx.fn_abi.ret.is_indirect() {\n                 debug!(\"alloc: {:?} (return place) -> place\", local);\n-                let llretptr = bx.get_param(0);\n+                let llretptr = start_bx.get_param(0);\n                 return LocalRef::Place(PlaceRef::new_sized(llretptr, layout));\n             }\n \n             if memory_locals.contains(local) {\n                 debug!(\"alloc: {:?} -> place\", local);\n                 if layout.is_unsized() {\n-                    LocalRef::UnsizedPlace(PlaceRef::alloca_unsized_indirect(&mut bx, layout))\n+                    LocalRef::UnsizedPlace(PlaceRef::alloca_unsized_indirect(&mut start_bx, layout))\n                 } else {\n-                    LocalRef::Place(PlaceRef::alloca(&mut bx, layout))\n+                    LocalRef::Place(PlaceRef::alloca(&mut start_bx, layout))\n                 }\n             } else {\n                 debug!(\"alloc: {:?} -> operand\", local);\n-                LocalRef::new_operand(&mut bx, layout)\n+                LocalRef::new_operand(&mut start_bx, layout)\n             }\n         };\n \n@@ -240,7 +240,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     };\n \n     // Apply debuginfo to the newly allocated locals.\n-    fx.debug_introduce_locals(&mut bx);\n+    fx.debug_introduce_locals(&mut start_bx);\n \n     // Codegen the body of each block using reverse postorder\n     for (bb, _) in traversal::reverse_postorder(&mir) {"}]}