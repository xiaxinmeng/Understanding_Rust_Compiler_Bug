{"sha": "887296e8c32165de83deb5156f0255c1f286ee6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NzI5NmU4YzMyMTY1ZGU4M2RlYjUxNTZmMDI1NWMxZjI4NmVlNmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-07T18:14:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-07T18:52:59Z"}, "message": "make it possible to customize the `RegionGraph` direction", "tree": {"sha": "b97b0d76f7cca37c6b5d1ec70641bf8e61a889ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b97b0d76f7cca37c6b5d1ec70641bf8e61a889ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/887296e8c32165de83deb5156f0255c1f286ee6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/887296e8c32165de83deb5156f0255c1f286ee6a", "html_url": "https://github.com/rust-lang/rust/commit/887296e8c32165de83deb5156f0255c1f286ee6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/887296e8c32165de83deb5156f0255c1f286ee6a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a92bf8dd29f3219bf39cc064954cfdad05c491a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a92bf8dd29f3219bf39cc064954cfdad05c491a8", "html_url": "https://github.com/rust-lang/rust/commit/a92bf8dd29f3219bf39cc064954cfdad05c491a8"}], "stats": {"total": 124, "additions": 93, "deletions": 31}, "files": [{"sha": "6fd6c41bebe83824df09585ee725b916b93bcc4c", "filename": "src/librustc_mir/borrow_check/nll/constraints/graph.rs", "status": "modified", "additions": 86, "deletions": 24, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/887296e8c32165de83deb5156f0255c1f286ee6a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/887296e8c32165de83deb5156f0255c1f286ee6a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs?ref=887296e8c32165de83deb5156f0255c1f286ee6a", "patch": "@@ -8,41 +8,100 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::constraints::{ConstraintIndex, ConstraintSet};\n+use borrow_check::nll::constraints::{ConstraintIndex, ConstraintSet, OutlivesConstraint};\n use rustc::ty::RegionVid;\n use rustc_data_structures::graph;\n use rustc_data_structures::indexed_vec::IndexVec;\n \n-crate struct ConstraintGraph {\n+/// The construct graph organizes the constraints by their end-points.\n+/// It can be used to view a `R1: R2` constraint as either an edge `R1\n+/// -> R2` or `R2 -> R1` depending on the direction type `D`.\n+crate struct ConstraintGraph<D: ConstraintGraphDirecton> {\n+    _direction: D,\n     first_constraints: IndexVec<RegionVid, Option<ConstraintIndex>>,\n     next_constraints: IndexVec<ConstraintIndex, Option<ConstraintIndex>>,\n }\n \n-impl ConstraintGraph {\n+crate type NormalConstraintGraph = ConstraintGraph<Normal>;\n+\n+/// Marker trait that controls whether a `R1: R2` constraint\n+/// represents an edge `R1 -> R2` or `R2 -> R1`.\n+crate trait ConstraintGraphDirecton: Copy + 'static {\n+    fn start_region(c: &OutlivesConstraint) -> RegionVid;\n+    fn end_region(c: &OutlivesConstraint) -> RegionVid;\n+}\n+\n+/// In normal mode, a `R1: R2` constraint results in an edge `R1 ->\n+/// R2`. This is what we use when constructing the SCCs for\n+/// inference. This is because we compute the value of R1 by union'ing\n+/// all the things that it relies on.\n+#[derive(Copy, Clone, Debug)]\n+crate struct Normal;\n+\n+impl ConstraintGraphDirecton for Normal {\n+    fn start_region(c: &OutlivesConstraint) -> RegionVid {\n+        c.sup\n+    }\n+\n+    fn end_region(c: &OutlivesConstraint) -> RegionVid {\n+        c.sub\n+    }\n+}\n+\n+/// In reverse mode, a `R1: R2` constraint results in an edge `R2 ->\n+/// R1`. We use this for optimizing liveness computation, because then\n+/// we wish to iterate from a region (e.g., R2) to all the regions\n+/// that will outlive it (e.g., R1).\n+#[derive(Copy, Clone, Debug)]\n+crate struct Reverse;\n+\n+impl ConstraintGraphDirecton for Reverse {\n+    fn start_region(c: &OutlivesConstraint) -> RegionVid {\n+        c.sub\n+    }\n+\n+    fn end_region(c: &OutlivesConstraint) -> RegionVid {\n+        c.sup\n+    }\n+}\n+\n+impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     /// Create a \"dependency graph\" where each region constraint `R1:\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n-    crate fn new(set: &ConstraintSet, num_region_vars: usize) -> Self {\n+    crate fn new(\n+        direction: D,\n+        set: &ConstraintSet,\n+        num_region_vars: usize,\n+    ) -> Self {\n         let mut first_constraints = IndexVec::from_elem_n(None, num_region_vars);\n         let mut next_constraints = IndexVec::from_elem(None, &set.constraints);\n \n         for (idx, constraint) in set.constraints.iter_enumerated().rev() {\n-            let head = &mut first_constraints[constraint.sup];\n+            let head = &mut first_constraints[D::start_region(constraint)];\n             let next = &mut next_constraints[idx];\n             debug_assert!(next.is_none());\n             *next = *head;\n             *head = Some(idx);\n         }\n \n         Self {\n+            _direction: direction,\n             first_constraints,\n             next_constraints,\n         }\n     }\n \n+    /// Given the constraint set from which this graph was built\n+    /// creates a region graph so that you can iterate over *regions*\n+    /// and not constraints.\n+    crate fn region_graph<'rg>(&'rg self, set: &'rg ConstraintSet) -> RegionGraph<'rg, D> {\n+        RegionGraph::new(set, self)\n+    }\n+\n     /// Given a region `R`, iterate over all constraints `R: R1`.\n-    crate fn outgoing_edges(&self, region_sup: RegionVid) -> Edges<'_> {\n+    crate fn outgoing_edges(&self, region_sup: RegionVid) -> Edges<'_, D> {\n         let first = self.first_constraints[region_sup];\n         Edges {\n             graph: self,\n@@ -51,12 +110,12 @@ impl ConstraintGraph {\n     }\n }\n \n-crate struct Edges<'s> {\n-    graph: &'s ConstraintGraph,\n+crate struct Edges<'s, D: ConstraintGraphDirecton> {\n+    graph: &'s ConstraintGraph<D>,\n     pointer: Option<ConstraintIndex>,\n }\n \n-impl<'s> Iterator for Edges<'s> {\n+impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n     type Item = ConstraintIndex;\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -69,17 +128,20 @@ impl<'s> Iterator for Edges<'s> {\n     }\n }\n \n-crate struct RegionGraph<'s> {\n+/// This struct brings together a constraint set and a (normal, not\n+/// reverse) constraint graph. It implements the graph traits and is\n+/// usd for doing the SCC computation.\n+crate struct RegionGraph<'s, D: ConstraintGraphDirecton> {\n     set: &'s ConstraintSet,\n-    constraint_graph: &'s ConstraintGraph,\n+    constraint_graph: &'s ConstraintGraph<D>,\n }\n \n-impl<'s> RegionGraph<'s> {\n+impl<'s, D: ConstraintGraphDirecton> RegionGraph<'s, D> {\n     /// Create a \"dependency graph\" where each region constraint `R1:\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n-    crate fn new(set: &'s ConstraintSet, constraint_graph: &'s ConstraintGraph) -> Self {\n+    crate fn new(set: &'s ConstraintSet, constraint_graph: &'s ConstraintGraph<D>) -> Self {\n         Self {\n             set,\n             constraint_graph,\n@@ -88,47 +150,47 @@ impl<'s> RegionGraph<'s> {\n \n     /// Given a region `R`, iterate over all regions `R1` such that\n     /// there exists a constraint `R: R1`.\n-    crate fn sub_regions(&self, region_sup: RegionVid) -> Successors<'_> {\n+    crate fn outgoing_regions(&self, region_sup: RegionVid) -> Successors<'_, D> {\n         Successors {\n             set: self.set,\n             edges: self.constraint_graph.outgoing_edges(region_sup),\n         }\n     }\n }\n \n-crate struct Successors<'s> {\n+crate struct Successors<'s, D: ConstraintGraphDirecton> {\n     set: &'s ConstraintSet,\n-    edges: Edges<'s>,\n+    edges: Edges<'s, D>,\n }\n \n-impl<'s> Iterator for Successors<'s> {\n+impl<'s, D: ConstraintGraphDirecton> Iterator for Successors<'s, D> {\n     type Item = RegionVid;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        self.edges.next().map(|c| self.set[c].sub)\n+        self.edges.next().map(|c| D::end_region(&self.set[c]))\n     }\n }\n \n-impl<'s> graph::DirectedGraph for RegionGraph<'s> {\n+impl<'s, D: ConstraintGraphDirecton> graph::DirectedGraph for RegionGraph<'s, D> {\n     type Node = RegionVid;\n }\n \n-impl<'s> graph::WithNumNodes for RegionGraph<'s> {\n+impl<'s, D: ConstraintGraphDirecton> graph::WithNumNodes for RegionGraph<'s, D> {\n     fn num_nodes(&self) -> usize {\n         self.constraint_graph.first_constraints.len()\n     }\n }\n \n-impl<'s> graph::WithSuccessors for RegionGraph<'s> {\n+impl<'s, D: ConstraintGraphDirecton> graph::WithSuccessors for RegionGraph<'s, D> {\n     fn successors<'graph>(\n         &'graph self,\n         node: Self::Node,\n     ) -> <Self as graph::GraphSuccessors<'graph>>::Iter {\n-        self.sub_regions(node)\n+        self.outgoing_regions(node)\n     }\n }\n \n-impl<'s, 'graph> graph::GraphSuccessors<'graph> for RegionGraph<'s> {\n+impl<'s, 'graph, D: ConstraintGraphDirecton> graph::GraphSuccessors<'graph> for RegionGraph<'s, D> {\n     type Item = RegionVid;\n-    type Iter = Successors<'graph>;\n+    type Iter = Successors<'graph, D>;\n }"}, {"sha": "f5cab56bd29ee62fec8fea83483e0df8b9fc1460", "filename": "src/librustc_mir/borrow_check/nll/constraints/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/887296e8c32165de83deb5156f0255c1f286ee6a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/887296e8c32165de83deb5156f0255c1f286ee6a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs?ref=887296e8c32165de83deb5156f0255c1f286ee6a", "patch": "@@ -36,24 +36,24 @@ impl ConstraintSet {\n         self.constraints.push(constraint);\n     }\n \n-    /// Constructs a graph from the constraint set; the graph makes it\n+    /// Constructs a \"normal\" graph from the constraint set; the graph makes it\n     /// easy to find the constraints affecting a particular region.\n     ///\n     /// NB: This graph contains a \"frozen\" view of the current\n     /// constraints.  any new constraints added to the `ConstraintSet`\n     /// after the graph is built will not be present in the graph.\n-    crate fn graph(&self, num_region_vars: usize) -> graph::ConstraintGraph {\n-        graph::ConstraintGraph::new(self, num_region_vars)\n+    crate fn graph(&self, num_region_vars: usize) -> graph::NormalConstraintGraph {\n+        graph::ConstraintGraph::new(graph::Normal, self, num_region_vars)\n     }\n \n     /// Compute cycles (SCCs) in the graph of regions. In particular,\n     /// find all regions R1, R2 such that R1: R2 and R2: R1 and group\n     /// them into an SCC, and find the relationships between SCCs.\n     crate fn compute_sccs(\n         &self,\n-        constraint_graph: &graph::ConstraintGraph,\n+        constraint_graph: &graph::NormalConstraintGraph,\n     ) -> Sccs<RegionVid, ConstraintSccIndex> {\n-        let region_graph = &graph::RegionGraph::new(self, constraint_graph);\n+        let region_graph = &constraint_graph.region_graph(self);\n         Sccs::new(region_graph)\n     }\n }"}, {"sha": "867b05639f5e2eac36151734f95df3972d524b42", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/887296e8c32165de83deb5156f0255c1f286ee6a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/887296e8c32165de83deb5156f0255c1f286ee6a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=887296e8c32165de83deb5156f0255c1f286ee6a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use super::universal_regions::UniversalRegions;\n-use borrow_check::nll::constraints::graph::ConstraintGraph;\n+use borrow_check::nll::constraints::graph::NormalConstraintGraph;\n use borrow_check::nll::constraints::{\n     ConstraintIndex, ConstraintSccIndex, ConstraintSet, OutlivesConstraint,\n };\n@@ -61,7 +61,7 @@ pub struct RegionInferenceContext<'tcx> {\n     /// The constraint-set, but in graph form, making it easy to traverse\n     /// the constraints adjacent to a particular region. Used to construct\n     /// the SCC (see `constraint_sccs`) and for error reporting.\n-    constraint_graph: Rc<ConstraintGraph>,\n+    constraint_graph: Rc<NormalConstraintGraph>,\n \n     /// The SCC computed from `constraints` and the constraint graph. Used to compute the values\n     /// of each region."}]}