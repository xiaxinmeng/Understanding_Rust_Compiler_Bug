{"sha": "72c8f3772bdca40ff2be2908aaf6b6a73d1c7821", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyYzhmMzc3MmJkY2E0MGZmMmJlMjkwOGFhZjZiNmE3M2QxYzc4MjE=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2014-12-18T01:12:53Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2014-12-25T16:08:29Z"}, "message": "Prepared most `StrExt` pattern using methods for stabilization\nMade iterator-returning methods return newtypes\nAdjusted some docs to be forwards compatible with a generic pattern API", "tree": {"sha": "4d3fd31002e58baeaf1be614a08cf2ef9a30733a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d3fd31002e58baeaf1be614a08cf2ef9a30733a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72c8f3772bdca40ff2be2908aaf6b6a73d1c7821", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72c8f3772bdca40ff2be2908aaf6b6a73d1c7821", "html_url": "https://github.com/rust-lang/rust/commit/72c8f3772bdca40ff2be2908aaf6b6a73d1c7821", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72c8f3772bdca40ff2be2908aaf6b6a73d1c7821/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ead198c5133fd649d1e385cfc46f344a2baaef8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ead198c5133fd649d1e385cfc46f344a2baaef8b", "html_url": "https://github.com/rust-lang/rust/commit/ead198c5133fd649d1e385cfc46f344a2baaef8b"}], "stats": {"total": 446, "additions": 274, "deletions": 172}, "files": [{"sha": "446438c119f292d5fce1d037b93d9c298cfd3d26", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 101, "deletions": 78, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/72c8f3772bdca40ff2be2908aaf6b6a73d1c7821/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c8f3772bdca40ff2be2908aaf6b6a73d1c7821/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=72c8f3772bdca40ff2be2908aaf6b6a73d1c7821", "patch": "@@ -80,12 +80,14 @@ use vec::Vec;\n \n pub use core::str::{from_utf8, CharEq, Chars, CharIndices};\n pub use core::str::{Bytes, CharSplits, is_utf8};\n-pub use core::str::{CharSplitsN, Lines, LinesAny, MatchIndices, StrSplits};\n+pub use core::str::{CharSplitsN, Lines, LinesAny, MatchIndices, StrSplits, SplitStr};\n pub use core::str::{CharRange};\n pub use core::str::{FromStr, from_str, Utf8Error};\n pub use core::str::Str;\n pub use core::str::{from_utf8_unchecked, from_c_str};\n pub use unicode::str::{Words, Graphemes, GraphemeIndices};\n+pub use core::str::{Split, SplitTerminator};\n+pub use core::str::{SplitN, RSplitN};\n \n // FIXME(conventions): ensure bit/char conventions are followed by str's API\n \n@@ -721,7 +723,7 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     /// // not found, so no change.\n     /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    #[stable]\n     fn replace(&self, from: &str, to: &str) -> String {\n         let mut result = String::new();\n         let mut last_end = 0;\n@@ -828,36 +830,36 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n         }\n     }\n \n-    /// Returns true if one string contains another\n+    /// Returns true if a string contains a string pattern.\n     ///\n     /// # Arguments\n     ///\n-    /// - needle - The string to look for\n+    /// - pat - The string pattern to look for\n     ///\n     /// # Example\n     ///\n     /// ```rust\n     /// assert!(\"bananas\".contains(\"nana\"));\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n-    fn contains(&self, needle: &str) -> bool {\n-        core_str::StrExt::contains(self[], needle)\n+    #[stable]\n+    fn contains(&self, pat: &str) -> bool {\n+        core_str::StrExt::contains(self[], pat)\n     }\n \n-    /// Returns true if a string contains a char.\n+    /// Returns true if a string contains a char pattern.\n     ///\n     /// # Arguments\n     ///\n-    /// - needle - The char to look for\n+    /// - pat - The char pattern to look for\n     ///\n     /// # Example\n     ///\n     /// ```rust\n     /// assert!(\"hello\".contains_char('e'));\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n-    fn contains_char(&self, needle: char) -> bool {\n-        core_str::StrExt::contains_char(self[], needle)\n+    #[unstable = \"might get removed in favour of a more generic contains()\"]\n+    fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n+        core_str::StrExt::contains_char(self[], pat)\n     }\n \n     /// An iterator over the characters of `self`. Note, this iterates\n@@ -894,7 +896,7 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`.\n+    /// matched by the pattern `pat`.\n     ///\n     /// # Example\n     ///\n@@ -911,13 +913,13 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     /// let v: Vec<&str> = \"\".split('X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n-    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<Sep> {\n-        core_str::StrExt::split(self[], sep)\n+    #[stable]\n+    fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n+        core_str::StrExt::split(self[], pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`, restricted to splitting at most `count`\n+    /// matched by the pattern `pat`, restricted to splitting at most `count`\n     /// times.\n     ///\n     /// # Example\n@@ -938,13 +940,13 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n-    fn splitn<Sep: CharEq>(&self, count: uint, sep: Sep) -> CharSplitsN<Sep> {\n-        core_str::StrExt::splitn(self[], count, sep)\n+    #[stable]\n+    fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n+        core_str::StrExt::splitn(self[], count, pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`.\n+    /// matched by the pattern `pat`.\n     ///\n     /// Equivalent to `split`, except that the trailing substring\n     /// is skipped if empty (terminator semantics).\n@@ -967,13 +969,13 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n-    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<Sep> {\n-        core_str::StrExt::split_terminator(self[], sep)\n+    #[unstable = \"might get removed\"]\n+    fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n+        core_str::StrExt::split_terminator(self[], pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`, starting from the end of the string.\n+    /// matched by the pattern `pat`, starting from the end of the string.\n     /// Restricted to splitting at most `count` times.\n     ///\n     /// # Example\n@@ -988,13 +990,13 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n-    fn rsplitn<Sep: CharEq>(&self, count: uint, sep: Sep) -> CharSplitsN<Sep> {\n-        core_str::StrExt::rsplitn(self[], count, sep)\n+    #[stable]\n+    fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n+        core_str::StrExt::rsplitn(self[], count, pat)\n     }\n \n     /// An iterator over the start and end indices of the disjoint\n-    /// matches of `sep` within `self`.\n+    /// matches of the pattern `pat` within `self`.\n     ///\n     /// That is, each returned value `(start, end)` satisfies\n     /// `self.slice(start, end) == sep`. For matches of `sep` within\n@@ -1013,12 +1015,12 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     /// let v: Vec<(uint, uint)> = \"ababa\".match_indices(\"aba\").collect();\n     /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n-    fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a> {\n-        core_str::StrExt::match_indices(self[], sep)\n+    #[unstable = \"might have its iterator type changed\"]\n+    fn match_indices<'a>(&'a self, pat: &'a str) -> MatchIndices<'a> {\n+        core_str::StrExt::match_indices(self[], pat)\n     }\n \n-    /// An iterator over the substrings of `self` separated by `sep`.\n+    /// An iterator over the substrings of `self` separated by the pattern `sep`.\n     ///\n     /// # Example\n     ///\n@@ -1029,9 +1031,9 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n     /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n-    fn split_str<'a>(&'a self, s: &'a str) -> StrSplits<'a> {\n-        core_str::StrExt::split_str(self[], s)\n+    #[unstable = \"might get removed in the future in favor of a more generic split()\"]\n+    fn split_str<'a>(&'a self, pat: &'a str) -> StrSplits<'a> {\n+        core_str::StrExt::split_str(self[], pat)\n     }\n \n     /// An iterator over the lines of a string (subsequences separated\n@@ -1204,85 +1206,106 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n         core_str::StrExt::slice_unchecked(self[], begin, end)\n     }\n \n-    /// Returns true if `needle` is a prefix of the string.\n+    /// Returns true if the pattern `pat` is a prefix of the string.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n     /// assert!(\"banana\".starts_with(\"ba\"));\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n-    fn starts_with(&self, needle: &str) -> bool {\n-        core_str::StrExt::starts_with(self[], needle)\n+    #[stable]\n+    fn starts_with(&self, pat: &str) -> bool {\n+        core_str::StrExt::starts_with(self[], pat)\n     }\n \n-    /// Returns true if `needle` is a suffix of the string.\n+    /// Returns true if the pattern `pat` is a suffix of the string.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n     /// assert!(\"banana\".ends_with(\"nana\"));\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n-    fn ends_with(&self, needle: &str) -> bool {\n-        core_str::StrExt::ends_with(self[], needle)\n+    #[stable]\n+    fn ends_with(&self, pat: &str) -> bool {\n+        core_str::StrExt::ends_with(self[], pat)\n     }\n \n-    /// Returns a string with characters that match `to_trim` removed from the left and the right.\n+    /// Returns a string with all pre- and suffixes that match\n+    /// the pattern `pat` repeatedly removed.\n     ///\n     /// # Arguments\n     ///\n-    /// * to_trim - a character matcher\n+    /// * pat - a string pattern\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\");\n+    /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n     /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_chars(x), \"foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_chars(|&: c: char| c.is_numeric()), \"foo1bar\");\n+    /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_matches(|&: c: char| c.is_numeric()), \"foo1bar\");\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n-    fn trim_chars<C: CharEq>(&self, to_trim: C) -> &str {\n-        core_str::StrExt::trim_chars(self[], to_trim)\n+    #[stable]\n+    fn trim_matches<P: CharEq>(&self, pat: P) -> &str {\n+        core_str::StrExt::trim_matches(self[], pat)\n     }\n \n-    /// Returns a string with leading `chars_to_trim` removed.\n+    /// Deprecated\n+    #[deprecated = \"Replaced by `trim_matches`\"]\n+    fn trim_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str {\n+        self.trim_matches(to_trim)\n+    }\n+\n+    /// Returns a string with all prefixes that match\n+    /// the pattern `pat` repeatedly removed.\n     ///\n     /// # Arguments\n     ///\n-    /// * to_trim - a character matcher\n+    /// * pat - a string pattern\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\");\n+    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n     /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_left_chars(x), \"foo1bar12\");\n-    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|&: c: char| c.is_numeric()), \"foo1bar123\");\n+    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n+    /// assert_eq!(\"123foo1bar123\".trim_left_matches(|&: c: char| c.is_numeric()), \"foo1bar123\");\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n-    fn trim_left_chars<C: CharEq>(&self, to_trim: C) -> &str {\n-        core_str::StrExt::trim_left_chars(self[], to_trim)\n+    #[stable]\n+    fn trim_left_matches<P: CharEq>(&self, pat: P) -> &str {\n+        core_str::StrExt::trim_left_matches(self[], pat)\n+    }\n+\n+    /// Deprecated\n+    #[deprecated = \"Replaced by `trim_left_matches`\"]\n+    fn trim_left_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str {\n+        self.trim_left_matches(to_trim)\n     }\n \n-    /// Returns a string with trailing `chars_to_trim` removed.\n+    /// Returns a string with all suffixes that match\n+    /// the pattern `pat` repeatedly removed.\n     ///\n     /// # Arguments\n     ///\n-    /// * to_trim - a character matcher\n+    /// * pat - a string pattern\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\");\n+    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n     /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_right_chars(x), \"12foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|&: c: char| c.is_numeric()), \"123foo1bar\");\n+    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_right_matches(|&: c: char| c.is_numeric()), \"123foo1bar\");\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n-    fn trim_right_chars<C: CharEq>(&self, to_trim: C) -> &str {\n-        core_str::StrExt::trim_right_chars(self[], to_trim)\n+    #[stable]\n+    fn trim_right_matches<P: CharEq>(&self, pat: P) -> &str {\n+        core_str::StrExt::trim_right_matches(self[], pat)\n+    }\n+\n+    /// Deprecated\n+    #[deprecated = \"Replaced by `trim_right_matches`\"]\n+    fn trim_right_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str {\n+        self.trim_right_matches(to_trim)\n     }\n \n     /// Check that `index`-th byte lies at the start and/or end of a\n@@ -1430,7 +1453,7 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     }\n \n     /// Returns the byte index of the first character of `self` that\n-    /// matches `search`.\n+    /// matches the pattern `pat`.\n     ///\n     /// # Return value\n     ///\n@@ -1452,13 +1475,13 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(s.find(x), None);\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n-    fn find<C: CharEq>(&self, search: C) -> Option<uint> {\n-        core_str::StrExt::find(self[], search)\n+    #[unstable = \"might be superseded by match_indices\"]\n+    fn find<P: CharEq>(&self, pat: P) -> Option<uint> {\n+        core_str::StrExt::find(self[], pat)\n     }\n \n     /// Returns the byte index of the last character of `self` that\n-    /// matches `search`.\n+    /// matches the pattern `pat`.\n     ///\n     /// # Return value\n     ///\n@@ -1480,9 +1503,9 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(s.rfind(x), None);\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n-    fn rfind<C: CharEq>(&self, search: C) -> Option<uint> {\n-        core_str::StrExt::rfind(self[], search)\n+    #[unstable = \"might be superseded by match_indices\"]\n+    fn rfind<P: CharEq>(&self, pat: P) -> Option<uint> {\n+        core_str::StrExt::rfind(self[], pat)\n     }\n \n     /// Returns the byte index of the first matching substring\n@@ -1504,7 +1527,7 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n     /// assert_eq!(s.find_str(\"muffin man\"), None);\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    #[unstable = \"might get removed in favor of a more generic find in the future\"]\n     fn find_str(&self, needle: &str) -> Option<uint> {\n         core_str::StrExt::find_str(self[], needle)\n     }\n@@ -1546,7 +1569,7 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n     /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n     /// ```\n-    #[unstable = \"awaiting pattern/matcher stabilization\"]\n+    #[unstable = \"awaiting convention about comparability of arbitrary slices\"]\n     fn subslice_offset(&self, inner: &str) -> uint {\n         core_str::StrExt::subslice_offset(self[], inner)\n     }"}, {"sha": "1e7fe8f060c3e80e54a5ac80be5f8fc21a9aa471", "filename": "src/libcore/str/mod.rs", "status": "renamed", "additions": 164, "deletions": 84, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/72c8f3772bdca40ff2be2908aaf6b6a73d1c7821/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c8f3772bdca40ff2be2908aaf6b6a73d1c7821/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=72c8f3772bdca40ff2be2908aaf6b6a73d1c7821", "patch": "@@ -18,7 +18,6 @@\n \n use self::Searcher::{Naive, TwoWay, TwoWayLong};\n \n-use clone::Clone;\n use cmp::{mod, Eq};\n use default::Default;\n use iter::range;\n@@ -35,6 +34,70 @@ use result::Result::{mod, Ok, Err};\n use slice::{mod, SliceExt};\n use uint;\n \n+macro_rules! delegate_iter {\n+    (exact $te:ty in $ti:ty) => {\n+        delegate_iter!{$te in $ti}\n+        impl<'a> ExactSizeIterator<$te> for $ti {\n+            #[inline]\n+            fn rposition<P>(&mut self, predicate: P) -> Option<uint> where P: FnMut($te) -> bool{\n+                self.0.rposition(predicate)\n+            }\n+            #[inline]\n+            fn len(&self) -> uint {\n+                self.0.len()\n+            }\n+        }\n+    };\n+    ($te:ty in $ti:ty) => {\n+        impl<'a> Iterator<$te> for $ti {\n+            #[inline]\n+            fn next(&mut self) -> Option<$te> {\n+                self.0.next()\n+            }\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                self.0.size_hint()\n+            }\n+        }\n+        impl<'a> DoubleEndedIterator<$te> for $ti {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$te> {\n+                self.0.next_back()\n+            }\n+        }\n+    };\n+    (pattern $te:ty in $ti:ty) => {\n+        impl<'a, P: CharEq> Iterator<$te> for $ti {\n+            #[inline]\n+            fn next(&mut self) -> Option<$te> {\n+                self.0.next()\n+            }\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                self.0.size_hint()\n+            }\n+        }\n+        impl<'a, P: CharEq> DoubleEndedIterator<$te> for $ti {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$te> {\n+                self.0.next_back()\n+            }\n+        }\n+    };\n+    (pattern forward $te:ty in $ti:ty) => {\n+        impl<'a, P: CharEq> Iterator<$te> for $ti {\n+            #[inline]\n+            fn next(&mut self) -> Option<$te> {\n+                self.0.next()\n+            }\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                self.0.size_hint()\n+            }\n+        }\n+    }\n+}\n+\n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n // FIXME(#17307): there should be an `E` associated type for a `Result` return\n@@ -333,29 +396,28 @@ impl<'a> DoubleEndedIterator<(uint, char)> for CharIndices<'a> {\n \n /// External iterator for a string's bytes.\n /// Use with the `std::iter` module.\n+///\n+/// Created with `StrExt::bytes`\n #[stable]\n #[deriving(Clone)]\n-pub struct Bytes<'a> {\n-    inner: Map<&'a u8, u8, slice::Iter<'a, u8>, BytesFn>,\n-}\n+pub struct Bytes<'a>(Map<&'a u8, u8, slice::Iter<'a, u8>, BytesDeref>);\n+delegate_iter!{exact u8 in Bytes<'a>}\n \n-/// A temporary new type wrapper that ensures that the `Bytes` iterator\n+/// A temporary fn new type that ensures that the `Bytes` iterator\n /// is cloneable.\n-#[deriving(Copy)]\n-struct BytesFn(fn(&u8) -> u8);\n+#[deriving(Copy, Clone)]\n+struct BytesDeref;\n \n-impl<'a> Fn(&'a u8) -> u8 for BytesFn {\n+impl<'a> Fn(&'a u8) -> u8 for BytesDeref {\n+    #[inline]\n     extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n-        (self.0)(ptr)\n+        *ptr\n     }\n }\n \n-impl Clone for BytesFn {\n-    fn clone(&self) -> BytesFn { *self }\n-}\n-\n /// An iterator over the substrings of a string, separated by `sep`.\n #[deriving(Clone)]\n+#[deprecated = \"Type is now named `Split` or `SplitTerminator`\"]\n pub struct CharSplits<'a, Sep> {\n     /// The slice remaining to be iterated\n     string: &'a str,\n@@ -369,6 +431,7 @@ pub struct CharSplits<'a, Sep> {\n /// An iterator over the substrings of a string, separated by `sep`,\n /// splitting at most `count` times.\n #[deriving(Clone)]\n+#[deprecated = \"Type is now named `SplitN` or `RSplitN`\"]\n pub struct CharSplitsN<'a, Sep> {\n     iter: CharSplits<'a, Sep>,\n     /// The number of splits remaining\n@@ -790,12 +853,17 @@ pub struct MatchIndices<'a> {\n /// An iterator over the substrings of a string separated by a given\n /// search string\n #[deriving(Clone)]\n-pub struct StrSplits<'a> {\n+#[unstable = \"Type might get removed\"]\n+pub struct SplitStr<'a> {\n     it: MatchIndices<'a>,\n     last_end: uint,\n     finished: bool\n }\n \n+/// Deprecated\n+#[deprecated = \"Type is now named `SplitStr`\"]\n+pub type StrSplits<'a> = SplitStr<'a>;\n+\n impl<'a> Iterator<(uint, uint)> for MatchIndices<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, uint)> {\n@@ -810,7 +878,7 @@ impl<'a> Iterator<(uint, uint)> for MatchIndices<'a> {\n     }\n }\n \n-impl<'a> Iterator<&'a str> for StrSplits<'a> {\n+impl<'a> Iterator<&'a str> for SplitStr<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         if self.finished { return None; }\n@@ -1158,23 +1226,47 @@ impl<'a, Sized? S> Str for &'a S where S: Str {\n     fn as_slice(&self) -> &str { Str::as_slice(*self) }\n }\n \n+/// Return type of `StrExt::split`\n+#[deriving(Clone)]\n+#[stable]\n+pub struct Split<'a, P>(CharSplits<'a, P>);\n+delegate_iter!{pattern &'a str in Split<'a, P>}\n+\n+/// Return type of `StrExt::split_terminator`\n+#[deriving(Clone)]\n+#[unstable = \"might get removed in favour of a constructor method on Split\"]\n+pub struct SplitTerminator<'a, P>(CharSplits<'a, P>);\n+delegate_iter!{pattern &'a str in SplitTerminator<'a, P>}\n+\n+/// Return type of `StrExt::splitn`\n+#[deriving(Clone)]\n+#[stable]\n+pub struct SplitN<'a, P>(CharSplitsN<'a, P>);\n+delegate_iter!{pattern forward &'a str in SplitN<'a, P>}\n+\n+/// Return type of `StrExt::rsplitn`\n+#[deriving(Clone)]\n+#[stable]\n+pub struct RSplitN<'a, P>(CharSplitsN<'a, P>);\n+delegate_iter!{pattern forward &'a str in RSplitN<'a, P>}\n+\n /// Methods for string slices\n #[allow(missing_docs)]\n pub trait StrExt for Sized? {\n     // NB there are no docs here are they're all located on the StrExt trait in\n     // libcollections, not here.\n \n-    fn contains(&self, needle: &str) -> bool;\n-    fn contains_char(&self, needle: char) -> bool;\n+    fn contains(&self, pat: &str) -> bool;\n+    fn contains_char<P: CharEq>(&self, pat: P) -> bool;\n     fn chars<'a>(&'a self) -> Chars<'a>;\n     fn bytes<'a>(&'a self) -> Bytes<'a>;\n     fn char_indices<'a>(&'a self) -> CharIndices<'a>;\n-    fn split<'a, Sep: CharEq>(&'a self, sep: Sep) -> CharSplits<'a, Sep>;\n-    fn splitn<'a, Sep: CharEq>(&'a self, count: uint, sep: Sep) -> CharSplitsN<'a, Sep>;\n-    fn split_terminator<'a, Sep: CharEq>(&'a self, sep: Sep) -> CharSplits<'a, Sep>;\n-    fn rsplitn<'a, Sep: CharEq>(&'a self, count: uint, sep: Sep) -> CharSplitsN<'a, Sep>;\n+    fn split<'a, P: CharEq>(&'a self, pat: P) -> Split<'a, P>;\n+    fn splitn<'a, P: CharEq>(&'a self, count: uint, pat: P) -> SplitN<'a, P>;\n+    fn split_terminator<'a, P: CharEq>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n+    fn rsplitn<'a, P: CharEq>(&'a self, count: uint, pat: P) -> RSplitN<'a, P>;\n     fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a>;\n-    fn split_str<'a>(&'a self, &'a str) -> StrSplits<'a>;\n+    fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a>;\n     fn lines<'a>(&'a self) -> Lines<'a>;\n     fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n     fn char_len(&self) -> uint;\n@@ -1183,20 +1275,20 @@ pub trait StrExt for Sized? {\n     fn slice_to<'a>(&'a self, end: uint) -> &'a str;\n     fn slice_chars<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n     unsafe fn slice_unchecked<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-    fn starts_with(&self, needle: &str) -> bool;\n-    fn ends_with(&self, needle: &str) -> bool;\n-    fn trim_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n-    fn trim_left_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n-    fn trim_right_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n+    fn starts_with(&self, pat: &str) -> bool;\n+    fn ends_with(&self, pat: &str) -> bool;\n+    fn trim_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n+    fn trim_left_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n+    fn trim_right_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n     fn is_char_boundary(&self, index: uint) -> bool;\n     fn char_range_at(&self, start: uint) -> CharRange;\n     fn char_range_at_reverse(&self, start: uint) -> CharRange;\n     fn char_at(&self, i: uint) -> char;\n     fn char_at_reverse(&self, i: uint) -> char;\n     fn as_bytes<'a>(&'a self) -> &'a [u8];\n-    fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n-    fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n-    fn find_str(&self, &str) -> Option<uint>;\n+    fn find<P: CharEq>(&self, pat: P) -> Option<uint>;\n+    fn rfind<P: CharEq>(&self, pat: P) -> Option<uint>;\n+    fn find_str(&self, pat: &str) -> Option<uint>;\n     fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;\n     fn subslice_offset(&self, inner: &str) -> uint;\n     fn as_ptr(&self) -> *const u8;\n@@ -1218,8 +1310,8 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn contains_char(&self, needle: char) -> bool {\n-        self.find(needle).is_some()\n+    fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n+        self.find(pat).is_some()\n     }\n \n     #[inline]\n@@ -1229,9 +1321,7 @@ impl StrExt for str {\n \n     #[inline]\n     fn bytes(&self) -> Bytes {\n-        fn deref(&x: &u8) -> u8 { x }\n-\n-        Bytes { inner: self.as_bytes().iter().map(BytesFn(deref)) }\n+        Bytes(self.as_bytes().iter().map(BytesDeref))\n     }\n \n     #[inline]\n@@ -1240,43 +1330,44 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<Sep> {\n-        CharSplits {\n+    #[allow(deprecated)] // For using CharSplits\n+    fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n+        Split(CharSplits {\n             string: self,\n-            only_ascii: sep.only_ascii(),\n-            sep: sep,\n+            only_ascii: pat.only_ascii(),\n+            sep: pat,\n             allow_trailing_empty: true,\n             finished: false,\n-        }\n+        })\n     }\n \n     #[inline]\n-    fn splitn<Sep: CharEq>(&self, count: uint, sep: Sep)\n-        -> CharSplitsN<Sep> {\n-        CharSplitsN {\n-            iter: self.split(sep),\n+    #[allow(deprecated)] // For using CharSplitsN\n+    fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n+        SplitN(CharSplitsN {\n+            iter: self.split(pat).0,\n             count: count,\n             invert: false,\n-        }\n+        })\n     }\n \n     #[inline]\n-    fn split_terminator<Sep: CharEq>(&self, sep: Sep)\n-        -> CharSplits<Sep> {\n-        CharSplits {\n+    #[allow(deprecated)] // For using CharSplits\n+    fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n+        SplitTerminator(CharSplits {\n             allow_trailing_empty: false,\n-            ..self.split(sep)\n-        }\n+            ..self.split(pat).0\n+        })\n     }\n \n     #[inline]\n-    fn rsplitn<Sep: CharEq>(&self, count: uint, sep: Sep)\n-        -> CharSplitsN<Sep> {\n-        CharSplitsN {\n-            iter: self.split(sep),\n+    #[allow(deprecated)] // For using CharSplitsN\n+    fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n+        RSplitN(CharSplitsN {\n+            iter: self.split(pat).0,\n             count: count,\n             invert: true,\n-        }\n+        })\n     }\n \n     #[inline]\n@@ -1290,8 +1381,8 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn split_str<'a>(&'a self, sep: &'a str) -> StrSplits<'a> {\n-        StrSplits {\n+    fn split_str<'a>(&'a self, sep: &'a str) -> SplitStr<'a> {\n+        SplitStr {\n             it: self.match_indices(sep),\n             last_end: 0,\n             finished: false\n@@ -1300,7 +1391,7 @@ impl StrExt for str {\n \n     #[inline]\n     fn lines(&self) -> Lines {\n-        Lines { inner: self.split_terminator('\\n') }\n+        Lines { inner: self.split_terminator('\\n').0 }\n     }\n \n     fn lines_any(&self) -> LinesAny {\n@@ -1393,12 +1484,12 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn trim_chars<C: CharEq>(&self, mut to_trim: C) -> &str {\n-        let cur = match self.find(|&mut: c: char| !to_trim.matches(c)) {\n+    fn trim_matches<P: CharEq>(&self, mut pat: P) -> &str {\n+        let cur = match self.find(|&mut: c: char| !pat.matches(c)) {\n             None => \"\",\n             Some(i) => unsafe { self.slice_unchecked(i, self.len()) }\n         };\n-        match cur.rfind(|&mut: c: char| !to_trim.matches(c)) {\n+        match cur.rfind(|&mut: c: char| !pat.matches(c)) {\n             None => \"\",\n             Some(i) => {\n                 let right = cur.char_range_at(i).next;\n@@ -1408,16 +1499,16 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn trim_left_chars<C: CharEq>(&self, mut to_trim: C) -> &str {\n-        match self.find(|&mut: c: char| !to_trim.matches(c)) {\n+    fn trim_left_matches<P: CharEq>(&self, mut pat: P) -> &str {\n+        match self.find(|&mut: c: char| !pat.matches(c)) {\n             None => \"\",\n             Some(first) => unsafe { self.slice_unchecked(first, self.len()) }\n         }\n     }\n \n     #[inline]\n-    fn trim_right_chars<C: CharEq>(&self, mut to_trim: C) -> &str {\n-        match self.rfind(|&mut: c: char| !to_trim.matches(c)) {\n+    fn trim_right_matches<P: CharEq>(&self, mut pat: P) -> &str {\n+        match self.rfind(|&mut: c: char| !pat.matches(c)) {\n             None => \"\",\n             Some(last) => {\n                 let next = self.char_range_at(last).next;\n@@ -1504,23 +1595,23 @@ impl StrExt for str {\n         unsafe { mem::transmute(self) }\n     }\n \n-    fn find<C: CharEq>(&self, mut search: C) -> Option<uint> {\n-        if search.only_ascii() {\n-            self.bytes().position(|b| search.matches(b as char))\n+    fn find<P: CharEq>(&self, mut pat: P) -> Option<uint> {\n+        if pat.only_ascii() {\n+            self.bytes().position(|b| pat.matches(b as char))\n         } else {\n             for (index, c) in self.char_indices() {\n-                if search.matches(c) { return Some(index); }\n+                if pat.matches(c) { return Some(index); }\n             }\n             None\n         }\n     }\n \n-    fn rfind<C: CharEq>(&self, mut search: C) -> Option<uint> {\n-        if search.only_ascii() {\n-            self.bytes().rposition(|b| search.matches(b as char))\n+    fn rfind<P: CharEq>(&self, mut pat: P) -> Option<uint> {\n+        if pat.only_ascii() {\n+            self.bytes().rposition(|b| pat.matches(b as char))\n         } else {\n             for (index, c) in self.char_indices().rev() {\n-                if search.matches(c) { return Some(index); }\n+                if pat.matches(c) { return Some(index); }\n             }\n             None\n         }\n@@ -1596,14 +1687,3 @@ impl<'a> DoubleEndedIterator<&'a str> for LinesAny<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n }\n-impl<'a> Iterator<u8> for Bytes<'a> {\n-    #[inline]\n-    fn next(&mut self) -> Option<u8> { self.inner.next() }\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n-}\n-impl<'a> DoubleEndedIterator<u8> for Bytes<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<u8> { self.inner.next_back() }\n-}\n-impl<'a> ExactSizeIterator<u8> for Bytes<'a> {}", "previous_filename": "src/libcore/str.rs"}, {"sha": "1d998567b6ea3e1c28e01e7bec4442dcbaf26349", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72c8f3772bdca40ff2be2908aaf6b6a73d1c7821/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c8f3772bdca40ff2be2908aaf6b6a73d1c7821/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=72c8f3772bdca40ff2be2908aaf6b6a73d1c7821", "patch": "@@ -817,7 +817,7 @@ impl NonCamelCaseTypes {\n         fn is_camel_case(ident: ast::Ident) -> bool {\n             let ident = token::get_ident(ident);\n             if ident.get().is_empty() { return true; }\n-            let ident = ident.get().trim_chars('_');\n+            let ident = ident.get().trim_matches('_');\n \n             // start with a non-lowercase letter rather than non-uppercase\n             // ones (some scripts don't have a concept of upper/lowercase)\n@@ -940,8 +940,8 @@ impl NonSnakeCase {\n         fn is_snake_case(ident: ast::Ident) -> bool {\n             let ident = token::get_ident(ident);\n             if ident.get().is_empty() { return true; }\n-            let ident = ident.get().trim_left_chars('\\'');\n-            let ident = ident.trim_chars('_');\n+            let ident = ident.get().trim_left_matches('\\'');\n+            let ident = ident.trim_matches('_');\n \n             let mut allow_underscore = true;\n             ident.chars().all(|c| {"}, {"sha": "4cb2e496d92c09daf2b0bb7ec750cd8c6a029388", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72c8f3772bdca40ff2be2908aaf6b6a73d1c7821/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c8f3772bdca40ff2be2908aaf6b6a73d1c7821/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=72c8f3772bdca40ff2be2908aaf6b6a73d1c7821", "patch": "@@ -26,7 +26,7 @@ use mem;\n use option::Option;\n use option::Option::{Some, None};\n use slice::SliceExt;\n-use str::{CharSplits, FromStr, StrVector, StrExt};\n+use str::{SplitTerminator, FromStr, StrVector, StrExt};\n use string::{String, ToString};\n use unicode::char::UnicodeChar;\n use vec::Vec;\n@@ -38,7 +38,7 @@ use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n /// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n /// every component in WindowsPath is guaranteed to be Some.\n pub type StrComponents<'a> =\n-    Map<&'a str, Option<&'a str>, CharSplits<'a, char>, fn(&'a str) -> Option<&'a str>>;\n+    Map<&'a str, Option<&'a str>, SplitTerminator<'a, char>, fn(&'a str) -> Option<&'a str>>;\n \n /// Iterator that yields successive components of a Path as &[u8]\n pub type Components<'a> ="}, {"sha": "3b0cc1443f0c716cc9239cdbf460d9b97c0484d9", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72c8f3772bdca40ff2be2908aaf6b6a73d1c7821/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c8f3772bdca40ff2be2908aaf6b6a73d1c7821/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=72c8f3772bdca40ff2be2908aaf6b6a73d1c7821", "patch": "@@ -24,16 +24,15 @@ use core::iter::{Filter, AdditiveIterator};\n use core::mem;\n use core::num::Int;\n use core::slice;\n-use core::str::CharSplits;\n+use core::str::Split;\n \n use u_char::UnicodeChar;\n use tables::grapheme::GraphemeCat;\n \n /// An iterator over the words of a string, separated by a sequence of whitespace\n-/// FIXME: This should be opaque\n #[stable]\n pub struct Words<'a> {\n-    inner: Filter<&'a str, CharSplits<'a, fn(char) -> bool>, fn(&&str) -> bool>,\n+    inner: Filter<&'a str, Split<'a, fn(char) -> bool>, fn(&&str) -> bool>,\n }\n \n /// Methods for Unicode string slices\n@@ -90,12 +89,12 @@ impl UnicodeStr for str {\n \n     #[inline]\n     fn trim_left(&self) -> &str {\n-        self.trim_left_chars(|&: c: char| c.is_whitespace())\n+        self.trim_left_matches(|&: c: char| c.is_whitespace())\n     }\n \n     #[inline]\n     fn trim_right(&self) -> &str {\n-        self.trim_right_chars(|&: c: char| c.is_whitespace())\n+        self.trim_right_matches(|&: c: char| c.is_whitespace())\n     }\n }\n "}]}