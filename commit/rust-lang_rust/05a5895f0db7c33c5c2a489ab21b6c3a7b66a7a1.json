{"sha": "05a5895f0db7c33c5c2a489ab21b6c3a7b66a7a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YTU4OTVmMGRiN2MzM2M1YzJhNDg5YWIyMWI2YzNhN2I2NmE3YTE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-05T09:55:52Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-05T09:55:52Z"}, "message": "miri assignment check: compare types after normalizing all late-bound regions away", "tree": {"sha": "01494fdec05aae5b010c24b4c82a907c3bce532c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01494fdec05aae5b010c24b4c82a907c3bce532c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05a5895f0db7c33c5c2a489ab21b6c3a7b66a7a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05a5895f0db7c33c5c2a489ab21b6c3a7b66a7a1", "html_url": "https://github.com/rust-lang/rust/commit/05a5895f0db7c33c5c2a489ab21b6c3a7b66a7a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05a5895f0db7c33c5c2a489ab21b6c3a7b66a7a1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "html_url": "https://github.com/rust-lang/rust/commit/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd"}], "stats": {"total": 58, "additions": 39, "deletions": 19}, "files": [{"sha": "35f2aadff6a59a33922876629a4de7f585d8d49e", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/05a5895f0db7c33c5c2a489ab21b6c3a7b66a7a1/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a5895f0db7c33c5c2a489ab21b6c3a7b66a7a1/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=05a5895f0db7c33c5c2a489ab21b6c3a7b66a7a1", "patch": "@@ -14,11 +14,11 @@ use rustc_middle::mir::interpret::{\n     sign_extend, truncate, AllocId, FrameInfo, GlobalId, InterpResult, Pointer, Scalar,\n };\n use rustc_middle::ty::layout::{self, TyAndLayout};\n-use rustc_middle::ty::query::TyCtxtAt;\n-use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{\n+    self, fold::BottomUpFolder, query::TyCtxtAt, subst::SubstsRef, Ty, TyCtxt, TypeFoldable,\n+};\n use rustc_span::source_map::DUMMY_SP;\n-use rustc_target::abi::{Abi, Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n+use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n \n use super::{\n     Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, OpTy, Operand, Place, PlaceTy,\n@@ -213,30 +213,50 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n /// Test if it is valid for a MIR assignment to assign `src`-typed place to `dest`-typed value.\n /// This test should be symmetric, as it is primarily about layout compatibility.\n pub(super) fn mir_assign_valid_types<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     src: TyAndLayout<'tcx>,\n     dest: TyAndLayout<'tcx>,\n ) -> bool {\n     if src.ty == dest.ty {\n         // Equal types, all is good.\n         return true;\n     }\n-    // Type-changing assignments can happen for (at least) two reasons:\n-    // - `&mut T` -> `&T` gets optimized from a reborrow to a mere assignment.\n-    // - Subtyping is used. While all normal lifetimes are erased, higher-ranked lifetime\n-    //   bounds are still around and can lead to type differences.\n-    // There is no good way to check the latter, so we compare layouts instead -- but only\n-    // for values with `Scalar`/`ScalarPair` abi.\n-    // FIXME: Do something more accurate, type-based.\n-    match &src.abi {\n-        Abi::Scalar(..) | Abi::ScalarPair(..) => src.layout == dest.layout,\n-        _ => false,\n+    if src.layout != dest.layout {\n+        // Layout differs, definitely not equal.\n+        // We do this here because Miri would *do the wrong thing* if we allowed layout-changing\n+        // assignments.\n+        return false;\n     }\n+\n+    // Type-changing assignments can happen for (at least) two reasons:\n+    // 1. `&mut T` -> `&T` gets optimized from a reborrow to a mere assignment.\n+    // 2. Subtyping is used. While all normal lifetimes are erased, higher-ranked lifetime\n+    //    bounds with their late-bound regions are still around and can lead to type differences.\n+    // Normalize both of them away.\n+    let normalize = |ty: Ty<'tcx>| {\n+        ty.fold_with(&mut BottomUpFolder {\n+            tcx,\n+            // Normalize all references to immutable.\n+            ty_op: |ty| match ty.kind {\n+                ty::Ref(_, pointee, _) => tcx.mk_imm_ref(tcx.lifetimes.re_erased, pointee),\n+                _ => ty,\n+            },\n+            // We just erase all late-bound regions, but this is not fully correct (FIXME):\n+            // lifetimes in invariant positions could matter (e.g. through associated types).\n+            // We rely on the fact that layout was confirmed to be equal above.\n+            lt_op: |_| tcx.lifetimes.re_erased,\n+            // Leave consts unchanged.\n+            ct_op: |ct| ct,\n+        })\n+    };\n+    normalize(src.ty) == normalize(dest.ty)\n }\n \n /// Use the already known layout if given (but sanity check in debug mode),\n /// or compute the layout.\n #[cfg_attr(not(debug_assertions), inline(always))]\n pub(super) fn from_known_layout<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     known_layout: Option<TyAndLayout<'tcx>>,\n     compute: impl FnOnce() -> InterpResult<'tcx, TyAndLayout<'tcx>>,\n ) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n@@ -246,7 +266,7 @@ pub(super) fn from_known_layout<'tcx>(\n             if cfg!(debug_assertions) {\n                 let check_layout = compute()?;\n                 assert!(\n-                    mir_assign_valid_types(check_layout, known_layout),\n+                    mir_assign_valid_types(tcx, check_layout, known_layout),\n                     \"expected type differs from actual type.\\nexpected: {:?}\\nactual: {:?}\",\n                     known_layout.ty,\n                     check_layout.ty,\n@@ -424,7 +444,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // have to support that case (mostly by skipping all caching).\n         match frame.locals.get(local).and_then(|state| state.layout.get()) {\n             None => {\n-                let layout = from_known_layout(layout, || {\n+                let layout = from_known_layout(self.tcx.tcx, layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n                     let local_ty =\n                         self.subst_from_frame_and_normalize_erasing_regions(frame, local_ty);"}, {"sha": "03614b2803f65fe2e33091aeabe14e5f3dbff03d", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05a5895f0db7c33c5c2a489ab21b6c3a7b66a7a1/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a5895f0db7c33c5c2a489ab21b6c3a7b66a7a1/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=05a5895f0db7c33c5c2a489ab21b6c3a7b66a7a1", "patch": "@@ -529,7 +529,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::ConstKind::Value(val_val) => val_val,\n         };\n         // Other cases need layout.\n-        let layout = from_known_layout(layout, || self.layout_of(val.ty))?;\n+        let layout = from_known_layout(self.tcx.tcx, layout, || self.layout_of(val.ty))?;\n         let op = match val_val {\n             ConstValue::ByRef { alloc, offset } => {\n                 let id = self.tcx.alloc_map.lock().create_memory_alloc(alloc);"}, {"sha": "716c7c7d933677863efd504fc75d86d9acf8559b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05a5895f0db7c33c5c2a489ab21b6c3a7b66a7a1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a5895f0db7c33c5c2a489ab21b6c3a7b66a7a1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=05a5895f0db7c33c5c2a489ab21b6c3a7b66a7a1", "patch": "@@ -868,7 +868,7 @@ where\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n         assert!(\n-            mir_assign_valid_types(src.layout, dest.layout),\n+            mir_assign_valid_types(self.tcx.tcx, src.layout, dest.layout),\n             \"type mismatch when copying!\\nsrc: {:?},\\ndest: {:?}\",\n             src.layout.ty,\n             dest.layout.ty,\n@@ -922,7 +922,7 @@ where\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        if mir_assign_valid_types(src.layout, dest.layout) {\n+        if mir_assign_valid_types(self.tcx.tcx, src.layout, dest.layout) {\n             // Fast path: Just use normal `copy_op`\n             return self.copy_op(src, dest);\n         }"}]}