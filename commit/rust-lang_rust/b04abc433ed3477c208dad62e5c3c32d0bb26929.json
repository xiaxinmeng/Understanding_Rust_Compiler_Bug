{"sha": "b04abc433ed3477c208dad62e5c3c32d0bb26929", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNGFiYzQzM2VkMzQ3N2MyMDhkYWQ2MmU1YzNjMzJkMGJiMjY5Mjk=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-11-22T11:29:48Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-11-22T12:40:03Z"}, "message": "BTreeMap: swap the names of NodeRef::new and Root::new_leaf", "tree": {"sha": "ba25127c035c1a7c02036dfaec0d89254815d36d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba25127c035c1a7c02036dfaec0d89254815d36d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b04abc433ed3477c208dad62e5c3c32d0bb26929", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b04abc433ed3477c208dad62e5c3c32d0bb26929", "html_url": "https://github.com/rust-lang/rust/commit/b04abc433ed3477c208dad62e5c3c32d0bb26929", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b04abc433ed3477c208dad62e5c3c32d0bb26929/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20328b532336017213ccb4095740955d81060ebc", "url": "https://api.github.com/repos/rust-lang/rust/commits/20328b532336017213ccb4095740955d81060ebc", "html_url": "https://github.com/rust-lang/rust/commit/20328b532336017213ccb4095740955d81060ebc"}], "stats": {"total": 28, "additions": 14, "deletions": 14}, "files": [{"sha": "bd99c4ed2f14e7e24bc21fd61efa22d7b6e7a3d2", "filename": "library/alloc/src/collections/btree/append.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b04abc433ed3477c208dad62e5c3c32d0bb26929/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04abc433ed3477c208dad62e5c3c32d0bb26929/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs?ref=b04abc433ed3477c208dad62e5c3c32d0bb26929", "patch": "@@ -67,7 +67,7 @@ impl<K, V> Root<K, V> {\n \n                 // Push key-value pair and new right subtree.\n                 let tree_height = open_node.height() - 1;\n-                let mut right_tree = Root::new_leaf();\n+                let mut right_tree = Root::new();\n                 for _ in 0..tree_height {\n                     right_tree.push_internal_level();\n                 }"}, {"sha": "383f4487aff3d742b7a5eac282d295095878ecf8", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b04abc433ed3477c208dad62e5c3c32d0bb26929/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04abc433ed3477c208dad62e5c3c32d0bb26929/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=b04abc433ed3477c208dad62e5c3c32d0bb26929", "patch": "@@ -9,7 +9,7 @@ use core::ops::{Index, RangeBounds};\n use core::ptr;\n \n use super::borrow::DormantMutRef;\n-use super::node::{self, marker, ForceResult::*, Handle, NodeRef};\n+use super::node::{self, marker, ForceResult::*, Handle, NodeRef, Root};\n use super::search::{self, SearchResult::*};\n use super::unwrap_unchecked;\n \n@@ -128,7 +128,7 @@ pub(super) const MIN_LEN: usize = node::MIN_LEN_AFTER_SPLIT;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeMap<K, V> {\n-    root: Option<node::Root<K, V>>,\n+    root: Option<Root<K, V>>,\n     length: usize,\n }\n \n@@ -145,15 +145,15 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for BTreeMap<K, V> {\n impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n     fn clone(&self) -> BTreeMap<K, V> {\n         fn clone_subtree<'a, K: Clone, V: Clone>(\n-            node: node::NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>,\n+            node: NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>,\n         ) -> BTreeMap<K, V>\n         where\n             K: 'a,\n             V: 'a,\n         {\n             match node.force() {\n                 Leaf(leaf) => {\n-                    let mut out_tree = BTreeMap { root: Some(node::Root::new_leaf()), length: 0 };\n+                    let mut out_tree = BTreeMap { root: Some(Root::new()), length: 0 };\n \n                     {\n                         let root = out_tree.root.as_mut().unwrap(); // unwrap succeeds because we just wrapped\n@@ -198,7 +198,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                                 (root, length)\n                             };\n \n-                            out_node.push(k, v, subroot.unwrap_or_else(node::Root::new_leaf));\n+                            out_node.push(k, v, subroot.unwrap_or_else(Root::new));\n                             out_tree.length += 1 + sublength;\n                         }\n                     }\n@@ -1558,7 +1558,7 @@ pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n     length: &'a mut usize,\n     /// Burried reference to the root field in the borrowed map.\n     /// Wrapped in `Option` to allow drop handler to `take` it.\n-    dormant_root: Option<DormantMutRef<'a, node::Root<K, V>>>,\n+    dormant_root: Option<DormantMutRef<'a, Root<K, V>>>,\n     /// Contains a leaf edge preceding the next element to be returned, or the last leaf edge.\n     /// Empty if the map has no root, if iteration went beyond the last leaf edge,\n     /// or if a panic occurred in the predicate.\n@@ -2160,8 +2160,8 @@ impl<K, V> BTreeMap<K, V> {\n \n     /// If the root node is the empty (non-allocated) root node, allocate our\n     /// own node. Is an associated function to avoid borrowing the entire BTreeMap.\n-    fn ensure_is_owned(root: &mut Option<node::Root<K, V>>) -> &mut node::Root<K, V> {\n-        root.get_or_insert_with(node::Root::new_leaf)\n+    fn ensure_is_owned(root: &mut Option<Root<K, V>>) -> &mut Root<K, V> {\n+        root.get_or_insert_with(Root::new)\n     }\n }\n "}, {"sha": "e3e555a72de027eaff23b382ef73e44634d8ce3c", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b04abc433ed3477c208dad62e5c3c32d0bb26929/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04abc433ed3477c208dad62e5c3c32d0bb26929/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=b04abc433ed3477c208dad62e5c3c32d0bb26929", "patch": "@@ -134,13 +134,13 @@ pub type Root<K, V> = NodeRef<marker::Owned, K, V, marker::LeafOrInternal>;\n \n impl<K, V> Root<K, V> {\n     /// Returns a new owned tree, with its own root node that is initially empty.\n-    pub fn new_leaf() -> Self {\n-        NodeRef::new().forget_type()\n+    pub fn new() -> Self {\n+        NodeRef::new_leaf().forget_type()\n     }\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n-    fn new() -> Self {\n+    fn new_leaf() -> Self {\n         Self::from_new_leaf(Box::new(unsafe { LeafNode::new() }))\n     }\n "}, {"sha": "6886962106b02ea5dfd20c3df28f70c68a7af984", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b04abc433ed3477c208dad62e5c3c32d0bb26929/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04abc433ed3477c208dad62e5c3c32d0bb26929/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=b04abc433ed3477c208dad62e5c3c32d0bb26929", "patch": "@@ -74,12 +74,12 @@ fn test_splitpoint() {\n \n #[test]\n fn test_partial_cmp_eq() {\n-    let mut root1 = NodeRef::new();\n+    let mut root1 = NodeRef::new_leaf();\n     let mut leaf1 = root1.borrow_mut();\n     leaf1.push(1, ());\n     let mut root1 = root1.forget_type();\n     root1.push_internal_level();\n-    let root2 = Root::new_leaf();\n+    let root2 = Root::new();\n     root1.reborrow().assert_back_pointers();\n     root2.reborrow().assert_back_pointers();\n "}]}