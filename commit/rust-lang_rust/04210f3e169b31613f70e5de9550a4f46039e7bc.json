{"sha": "04210f3e169b31613f70e5de9550a4f46039e7bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0MjEwZjNlMTY5YjMxNjEzZjcwZTVkZTk1NTBhNGY0NjAzOWU3YmM=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-12T07:39:04Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-24T10:36:31Z"}, "message": "Access `self` instead of `alloc`", "tree": {"sha": "e4fe26f83b369bcdf50898ebdba10a22792fc2f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4fe26f83b369bcdf50898ebdba10a22792fc2f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04210f3e169b31613f70e5de9550a4f46039e7bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04210f3e169b31613f70e5de9550a4f46039e7bc", "html_url": "https://github.com/rust-lang/rust/commit/04210f3e169b31613f70e5de9550a4f46039e7bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04210f3e169b31613f70e5de9550a4f46039e7bc/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c392fbbbf16981dc6368de7ea6a8797892221283", "url": "https://api.github.com/repos/rust-lang/rust/commits/c392fbbbf16981dc6368de7ea6a8797892221283", "html_url": "https://github.com/rust-lang/rust/commit/c392fbbbf16981dc6368de7ea6a8797892221283"}], "stats": {"total": 44, "additions": 14, "deletions": 30}, "files": [{"sha": "aba0da32d4544b4677f7537c61a8db7f2f003d57", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 14, "deletions": 30, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/04210f3e169b31613f70e5de9550a4f46039e7bc/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04210f3e169b31613f70e5de9550a4f46039e7bc/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=04210f3e169b31613f70e5de9550a4f46039e7bc", "patch": "@@ -60,21 +60,12 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     pub fn check_bounds_ptr(\n         &self,\n         ptr: Pointer<Tag>,\n-        check: InboundsCheck,\n     ) -> EvalResult<'tcx> {\n-        let allocation_size = match check {\n-            InboundsCheck::Live => {\n-                let alloc = self.get(ptr.alloc_id)?;\n-                alloc.bytes.len() as u64\n-            }\n-            InboundsCheck::MaybeDead => {\n-                self.get_size_and_align(ptr.alloc_id).0.bytes()\n-            }\n-        };\n+        let allocation_size = self.bytes.len() as u64;\n         if ptr.offset.bytes() > allocation_size {\n             return err!(PointerOutOfBounds {\n                 ptr: ptr.erase_tag(),\n-                check,\n+                check: InboundsCheck::Live,\n                 allocation_size: Size::from_bytes(allocation_size),\n             });\n         }\n@@ -87,15 +78,14 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         &self,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        check: InboundsCheck,\n     ) -> EvalResult<'tcx> {\n         // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds_ptr(ptr.offset(size, &*self)?, check)\n+        self.check_bounds_ptr(ptr.offset(size, &*self)?)\n     }\n }\n \n /// Byte accessors\n-impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n+impl<'tcx, Tag, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// The last argument controls whether we error out when there are undefined\n     /// or pointer bytes.  You should never call this, call `get_bytes` or\n     /// `get_bytes_with_undef_and_ptr` instead,\n@@ -122,13 +112,12 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n             self.check_relocation_edges(ptr, size)?;\n         }\n \n-        let alloc = self.get(ptr.alloc_id)?;\n-        AllocationExtra::memory_read(alloc, ptr, size)?;\n+        AllocationExtra::memory_read(self, ptr, size)?;\n \n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n         let offset = ptr.offset.bytes() as usize;\n-        Ok(&alloc.bytes[offset..offset + size.bytes() as usize])\n+        Ok(&self.bytes[offset..offset + size.bytes() as usize])\n     }\n \n     #[inline]\n@@ -168,13 +157,12 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         self.mark_definedness(ptr, size, true)?;\n         self.clear_relocations(ptr, size)?;\n \n-        let alloc = self.get_mut(ptr.alloc_id)?;\n-        AllocationExtra::memory_written(alloc, ptr, size)?;\n+        AllocationExtra::memory_written(self, ptr, size)?;\n \n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n         let offset = ptr.offset.bytes() as usize;\n-        Ok(&mut alloc.bytes[offset..offset + size.bytes() as usize])\n+        Ok(&mut self.bytes[offset..offset + size.bytes() as usize])\n     }\n }\n \n@@ -190,7 +178,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         // the beginning of this range.\n         let start = ptr.offset.bytes().saturating_sub(self.pointer_size().bytes() - 1);\n         let end = ptr.offset + size; // this does overflow checking\n-        Ok(self.get(ptr.alloc_id)?.relocations.range(Size::from_bytes(start)..end))\n+        Ok(self.relocations.range(Size::from_bytes(start)..end))\n     }\n \n     /// Check that there ar eno relocations overlapping with the given range.\n@@ -224,19 +212,17 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         let start = ptr.offset;\n         let end = start + size;\n \n-        let alloc = self.get_mut(ptr.alloc_id)?;\n-\n         // Mark parts of the outermost relocations as undefined if they partially fall outside the\n         // given range.\n         if first < start {\n-            alloc.undef_mask.set_range(first, start, false);\n+            self.undef_mask.set_range(first, start, false);\n         }\n         if last > end {\n-            alloc.undef_mask.set_range(end, last, false);\n+            self.undef_mask.set_range(end, last, false);\n         }\n \n         // Forget all the relocations.\n-        alloc.relocations.remove_range(first..last);\n+        self.relocations.remove_range(first..last);\n \n         Ok(())\n     }\n@@ -258,8 +244,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     /// error which will report the first byte which is undefined.\n     #[inline]\n     fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> EvalResult<'tcx> {\n-        let alloc = self.get(ptr.alloc_id)?;\n-        alloc.undef_mask.is_range_defined(\n+        self.undef_mask.is_range_defined(\n             ptr.offset,\n             ptr.offset + size,\n         ).or_else(|idx| err!(ReadUndefBytes(idx)))\n@@ -274,8 +259,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         if size.bytes() == 0 {\n             return Ok(());\n         }\n-        let alloc = self.get_mut(ptr.alloc_id)?;\n-        alloc.undef_mask.set_range(\n+        self.undef_mask.set_range(\n             ptr.offset,\n             ptr.offset + size,\n             new_state,"}]}