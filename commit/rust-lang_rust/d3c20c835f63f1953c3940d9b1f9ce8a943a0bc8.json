{"sha": "d3c20c835f63f1953c3940d9b1f9ce8a943a0bc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYzIwYzgzNWY2M2YxOTUzYzM5NDBkOWIxZjljZThhOTQzYTBiYzg=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-05-27T21:10:35Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-05-27T21:25:17Z"}, "message": "Some cleanup for use_self", "tree": {"sha": "8a849fecc04d11c5dbdbc0dff5f20e89ee61b833", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a849fecc04d11c5dbdbc0dff5f20e89ee61b833"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3c20c835f63f1953c3940d9b1f9ce8a943a0bc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c20c835f63f1953c3940d9b1f9ce8a943a0bc8", "html_url": "https://github.com/rust-lang/rust/commit/d3c20c835f63f1953c3940d9b1f9ce8a943a0bc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3c20c835f63f1953c3940d9b1f9ce8a943a0bc8/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c54f61bebc5f3ee90e3904a19d9c166623972d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c54f61bebc5f3ee90e3904a19d9c166623972d1", "html_url": "https://github.com/rust-lang/rust/commit/6c54f61bebc5f3ee90e3904a19d9c166623972d1"}], "stats": {"total": 178, "additions": 51, "deletions": 127}, "files": [{"sha": "e79983134e44952f5e46c8b9ebe114865e93df0c", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 51, "deletions": 127, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/d3c20c835f63f1953c3940d9b1f9ce8a943a0bc8/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c20c835f63f1953c3940d9b1f9ce8a943a0bc8/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=d3c20c835f63f1953c3940d9b1f9ce8a943a0bc8", "patch": "@@ -1,23 +1,21 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::same_type_and_consts;\n use clippy_utils::{in_macro, meets_msrv, msrvs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{\n     self as hir,\n-    def::{self, DefKind},\n+    def::{CtorOf, DefKind, Res},\n     def_id::LocalDefId,\n     intravisit::{walk_ty, NestedVisitorMap, Visitor},\n-    Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Node, Path, PathSegment,\n-    QPath, TyKind,\n+    Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Node, Path, QPath, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::{AssocKind, Ty};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::Span;\n use rustc_typeck::hir_ty_to_ty;\n \n declare_clippy_lint! {\n@@ -234,111 +232,58 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n     }\n \n     fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>) {\n-        if in_macro(hir_ty.span)\n-            || in_impl(cx, hir_ty)\n-            || !meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS)\n-        {\n-            return;\n-        }\n-\n-        let lint_dependend_on_expr_kind = if let Some(StackItem::Check {\n-            hir_id,\n-            types_to_lint,\n-            types_to_skip,\n-            ..\n-        }) = self.stack.last()\n-        {\n-            if types_to_skip.contains(&hir_ty.hir_id) {\n-                false\n-            } else if types_to_lint.contains(&hir_ty.hir_id) {\n-                true\n-            } else {\n-                let self_ty = ty_from_hir_id(cx, *hir_id);\n-                should_lint_ty(hir_ty, hir_ty_to_ty(cx.tcx, hir_ty), self_ty)\n-            }\n-        } else {\n-            false\n-        };\n-\n-        if lint_dependend_on_expr_kind {\n-            // FIXME: this span manipulation should not be necessary\n-            // @flip1995 found an ast lowering issue in\n-            // https://github.com/rust-lang/rust/blob/master/src/librustc_ast_lowering/path.rs#l142-l162\n+        if_chain! {\n+            if !in_macro(hir_ty.span) && !in_impl(cx, hir_ty);\n+            if meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS);\n+            if let Some(StackItem::Check {\n+                hir_id,\n+                types_to_lint,\n+                types_to_skip,\n+                ..\n+            }) = self.stack.last();\n+            if !types_to_skip.contains(&hir_ty.hir_id);\n+            if types_to_lint.contains(&hir_ty.hir_id)\n+                || {\n+                    let self_ty = ty_from_hir_id(cx, *hir_id);\n+                    should_lint_ty(hir_ty, hir_ty_to_ty(cx.tcx, hir_ty), self_ty)\n+                };\n             let hir = cx.tcx.hir();\n             let id = hir.get_parent_node(hir_ty.hir_id);\n-\n-            if !hir.opt_span(id).map_or(false, in_macro) {\n-                match hir.find(id) {\n-                    Some(Node::Expr(Expr {\n-                        kind: ExprKind::Path(QPath::TypeRelative(_, segment)),\n-                        ..\n-                    })) => span_lint_until_last_segment(cx, hir_ty.span, segment),\n-                    _ => span_lint(cx, hir_ty.span),\n-                }\n+            if !hir.opt_span(id).map_or(false, in_macro);\n+            then {\n+                span_lint(cx, hir_ty.span);\n             }\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        fn expr_ty_matches(cx: &LateContext<'_>, expr: &Expr<'_>, self_ty: Ty<'_>) -> bool {\n-            let def_id = expr.hir_id.owner;\n-            if cx.tcx.has_typeck_results(def_id) {\n-                cx.tcx.typeck(def_id).expr_ty_opt(expr) == Some(self_ty)\n-            } else {\n-                false\n-            }\n-        }\n-\n-        if in_macro(expr.span) || !meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS) {\n-            return;\n+        if_chain! {\n+            if !in_macro(expr.span);\n+            if meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS);\n+            if let Some(StackItem::Check { hir_id, .. }) = self.stack.last();\n+            if cx.typeck_results().expr_ty(expr) == ty_from_hir_id(cx, *hir_id);\n+            then {} else { return; }\n         }\n-\n-        if let Some(StackItem::Check { hir_id, .. }) = self.stack.last() {\n-            let self_ty = ty_from_hir_id(cx, *hir_id);\n-\n-            match &expr.kind {\n-                ExprKind::Struct(QPath::Resolved(_, path), ..) => {\n-                    if expr_ty_matches(cx, expr, self_ty) {\n-                        match path.res {\n-                            def::Res::SelfTy(..) => (),\n-                            def::Res::Def(DefKind::Variant, _) => span_lint_on_path_until_last_segment(cx, path),\n-                            _ => {\n-                                span_lint(cx, path.span);\n-                            },\n-                        }\n-                    }\n-                },\n-                // tuple struct instantiation (`Foo(arg)` or `Enum::Foo(arg)`)\n-                ExprKind::Call(fun, _) => {\n-                    if let Expr {\n-                        kind: ExprKind::Path(ref qpath),\n-                        ..\n-                    } = fun\n-                    {\n-                        if expr_ty_matches(cx, expr, self_ty) {\n-                            let res = cx.qpath_res(qpath, fun.hir_id);\n-\n-                            if let def::Res::Def(DefKind::Ctor(ctor_of, _), ..) = res {\n-                                match ctor_of {\n-                                    def::CtorOf::Variant => {\n-                                        span_lint_on_qpath_resolved(cx, qpath, true);\n-                                    },\n-                                    def::CtorOf::Struct => {\n-                                        span_lint_on_qpath_resolved(cx, qpath, false);\n-                                    },\n-                                }\n-                            }\n+        match expr.kind {\n+            ExprKind::Struct(QPath::Resolved(_, path), ..) => match path.res {\n+                Res::SelfTy(..) => (),\n+                Res::Def(DefKind::Variant, _) => lint_path_to_variant(cx, path),\n+                _ => span_lint(cx, path.span),\n+            },\n+            // tuple struct instantiation (`Foo(arg)` or `Enum::Foo(arg)`)\n+            ExprKind::Call(fun, _) => {\n+                if let ExprKind::Path(QPath::Resolved(_, path)) = fun.kind {\n+                    if let Res::Def(DefKind::Ctor(ctor_of, _), ..) = path.res {\n+                        match ctor_of {\n+                            CtorOf::Variant => lint_path_to_variant(cx, path),\n+                            CtorOf::Struct => span_lint(cx, path.span),\n                         }\n                     }\n-                },\n-                // unit enum variants (`Enum::A`)\n-                ExprKind::Path(qpath) => {\n-                    if expr_ty_matches(cx, expr, self_ty) {\n-                        span_lint_on_qpath_resolved(cx, qpath, true);\n-                    }\n-                },\n-                _ => (),\n-            }\n+                }\n+            },\n+            // unit enum variants (`Enum::A`)\n+            ExprKind::Path(QPath::Resolved(_, path)) => lint_path_to_variant(cx, path),\n+            _ => (),\n         }\n     }\n \n@@ -405,33 +350,12 @@ fn span_lint(cx: &LateContext<'_>, span: Span) {\n     );\n }\n \n-#[allow(clippy::cast_possible_truncation)]\n-fn span_lint_until_last_segment(cx: &LateContext<'_>, span: Span, segment: &PathSegment<'_>) {\n-    let sp = span.with_hi(segment.ident.span.lo());\n-    // remove the trailing ::\n-    let span_without_last_segment = match snippet_opt(cx, sp) {\n-        Some(snippet) => match snippet.rfind(\"::\") {\n-            Some(bidx) => sp.with_hi(sp.lo() + BytePos(bidx as u32)),\n-            None => sp,\n-        },\n-        None => sp,\n-    };\n-    span_lint(cx, span_without_last_segment);\n-}\n-\n-fn span_lint_on_path_until_last_segment(cx: &LateContext<'_>, path: &Path<'_>) {\n-    if path.segments.len() > 1 {\n-        span_lint_until_last_segment(cx, path.span, path.segments.last().unwrap());\n-    }\n-}\n-\n-fn span_lint_on_qpath_resolved(cx: &LateContext<'_>, qpath: &QPath<'_>, until_last_segment: bool) {\n-    if let QPath::Resolved(_, path) = qpath {\n-        if until_last_segment {\n-            span_lint_on_path_until_last_segment(cx, path);\n-        } else {\n-            span_lint(cx, path.span);\n-        }\n+fn lint_path_to_variant(cx: &LateContext<'_>, path: &Path<'_>) {\n+    if let [.., self_seg, _variant] = path.segments {\n+        let span = path\n+            .span\n+            .with_hi(self_seg.args().span_ext().unwrap_or(self_seg.ident.span).hi());\n+        span_lint(cx, span);\n     }\n }\n "}]}