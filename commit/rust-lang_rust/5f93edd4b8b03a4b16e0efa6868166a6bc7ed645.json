{"sha": "5f93edd4b8b03a4b16e0efa6868166a6bc7ed645", "node_id": "C_kwDOAAsO6NoAKDVmOTNlZGQ0YjhiMDNhNGIxNmUwZWZhNjg2ODE2NmE2YmM3ZWQ2NDU", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-02-14T17:27:59Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-02-14T17:42:04Z"}, "message": "Prevent some attributes from being merged with others on reexports", "tree": {"sha": "a09c58b91447725fd2f227f69fffaa55ef950320", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a09c58b91447725fd2f227f69fffaa55ef950320"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f93edd4b8b03a4b16e0efa6868166a6bc7ed645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f93edd4b8b03a4b16e0efa6868166a6bc7ed645", "html_url": "https://github.com/rust-lang/rust/commit/5f93edd4b8b03a4b16e0efa6868166a6bc7ed645", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f93edd4b8b03a4b16e0efa6868166a6bc7ed645/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bb6e60d1f1360234aae90c97964c0fa5524f141", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb6e60d1f1360234aae90c97964c0fa5524f141", "html_url": "https://github.com/rust-lang/rust/commit/9bb6e60d1f1360234aae90c97964c0fa5524f141"}], "stats": {"total": 97, "additions": 89, "deletions": 8}, "files": [{"sha": "bdb559af037c19170276651394ac9bd181fdb5a7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 89, "deletions": 8, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/5f93edd4b8b03a4b16e0efa6868166a6bc7ed645/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f93edd4b8b03a4b16e0efa6868166a6bc7ed645/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5f93edd4b8b03a4b16e0efa6868166a6bc7ed645", "patch": "@@ -2126,6 +2126,87 @@ fn get_all_import_attributes<'hir>(\n     }\n }\n \n+/// When inlining items, we merge its attributes (and all the reexports attributes too) with the\n+/// final reexport. For example:\n+///\n+/// ```\n+/// #[doc(hidden, cfg(feature = \"foo\"))]\n+/// pub struct Foo;\n+///\n+/// #[doc(cfg(feature = \"bar\"))]\n+/// #[doc(hidden, no_inline)]\n+/// pub use Foo as Foo1;\n+///\n+/// #[doc(inline)]\n+/// pub use Foo2 as Bar;\n+/// ```\n+///\n+/// So `Bar` at the end will have both `cfg(feature = \"...\")`. However, we don't want to merge all\n+/// attributes so we filter out the following ones:\n+/// * `doc(inline)`\n+/// * `doc(no_inline)`\n+/// * `doc(hidden)`\n+fn add_without_unwanted_attributes(attrs: &mut Vec<ast::Attribute>, new_attrs: &[ast::Attribute]) {\n+    use rustc_ast::token::{Token, TokenKind};\n+    use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+\n+    for attr in new_attrs {\n+        let mut attr = attr.clone();\n+        match attr.kind {\n+            ast::AttrKind::Normal(ref mut normal) => {\n+                if let [ident] = &*normal.item.path.segments {\n+                    let ident = ident.ident.name;\n+                    if ident == sym::doc {\n+                        match normal.item.args {\n+                            ast::AttrArgs::Delimited(ref mut args) => {\n+                                let mut tokens = Vec::with_capacity(args.tokens.len());\n+                                let mut skip_next_comma = false;\n+                                for token in args.tokens.clone().into_trees() {\n+                                    match token {\n+                                        TokenTree::Token(\n+                                            Token {\n+                                                kind:\n+                                                    TokenKind::Ident(\n+                                                        sym::hidden | sym::inline | sym::no_inline,\n+                                                        _,\n+                                                    ),\n+                                                ..\n+                                            },\n+                                            _,\n+                                        ) => {\n+                                            skip_next_comma = true;\n+                                            continue;\n+                                        }\n+                                        TokenTree::Token(\n+                                            Token { kind: TokenKind::Comma, .. },\n+                                            _,\n+                                        ) if skip_next_comma => {\n+                                            skip_next_comma = false;\n+                                            continue;\n+                                        }\n+                                        _ => {}\n+                                    }\n+                                    skip_next_comma = false;\n+                                    tokens.push(token);\n+                                }\n+                                args.tokens = TokenStream::new(tokens);\n+                                attrs.push(attr);\n+                            }\n+                            ast::AttrArgs::Empty | ast::AttrArgs::Eq(..) => {\n+                                attrs.push(attr);\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            ast::AttrKind::DocComment(..) => {\n+                attrs.push(attr);\n+            }\n+        }\n+    }\n+}\n+\n fn clean_maybe_renamed_item<'tcx>(\n     cx: &mut DocContext<'tcx>,\n     item: &hir::Item<'tcx>,\n@@ -2216,17 +2297,17 @@ fn clean_maybe_renamed_item<'tcx>(\n             extra_attrs.extend_from_slice(inline::load_attrs(cx, import_id.to_def_id()));\n             // Then we get all the various imports' attributes.\n             get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut extra_attrs);\n+            add_without_unwanted_attributes(&mut extra_attrs, inline::load_attrs(cx, def_id));\n+        } else {\n+            // We only keep the item's attributes.\n+            extra_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n         }\n \n-        let mut item = if !extra_attrs.is_empty() {\n-            extra_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n-            let attrs = Attributes::from_ast(&extra_attrs);\n-            let cfg = extra_attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n+        let attrs = Attributes::from_ast(&extra_attrs);\n+        let cfg = extra_attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n \n-            Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg)\n-        } else {\n-            Item::from_def_id_and_parts(def_id, Some(name), kind, cx)\n-        };\n+        let mut item =\n+            Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg);\n         item.inline_stmt_id = import_id.map(|def_id| def_id.to_def_id());\n         vec![item]\n     })"}]}