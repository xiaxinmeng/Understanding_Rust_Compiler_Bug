{"sha": "d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZWJhNzZlNGQ2M2MwOGZhMGM0NDA2NzQ1ZDFmMGNjMGU1NzY3NTg=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-11-20T19:37:35Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-11-20T22:02:18Z"}, "message": "update Serde, etc.\n\nLots of changes to how closures work", "tree": {"sha": "84d014cfaef1f264f1a8f8231b96a312e972ee37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84d014cfaef1f264f1a8f8231b96a312e972ee37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "html_url": "https://github.com/rust-lang/rust/commit/d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61ab06a92eae355ed6447d85d3c416fb65e96bdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/61ab06a92eae355ed6447d85d3c416fb65e96bdb", "html_url": "https://github.com/rust-lang/rust/commit/61ab06a92eae355ed6447d85d3c416fb65e96bdb"}], "stats": {"total": 658, "additions": 352, "deletions": 306}, "files": [{"sha": "b5edd5f14d27ccd34d3968ff43c5ffc20bb15bdd", "filename": "Cargo.lock", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -7,14 +7,14 @@ dependencies = [\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"multimap 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.1.77 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strings 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syntex_errors 0.44.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syntex_syntax 0.44.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_errors 0.50.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_syntax 0.50.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -46,7 +46,7 @@ version = \"0.3.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.1.77 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -70,7 +70,7 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.16\"\n+version = \"0.2.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -83,7 +83,7 @@ name = \"memchr\"\n version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -93,24 +93,24 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"regex\"\n-version = \"0.1.77\"\n+version = \"0.1.80\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.3.5\"\n+version = \"0.3.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"rustc-serialize\"\n-version = \"0.3.19\"\n+version = \"0.3.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -123,36 +123,36 @@ dependencies = [\n \n [[package]]\n name = \"syntex_errors\"\n-version = \"0.44.0\"\n+version = \"0.50.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syntex_pos 0.44.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_pos 0.50.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"syntex_pos\"\n-version = \"0.44.0\"\n+version = \"0.50.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"syntex_syntax\"\n-version = \"0.44.1\"\n+version = \"0.50.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syntex_errors 0.44.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syntex_pos 0.44.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_errors 0.50.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_pos 0.50.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -172,7 +172,7 @@ version = \"2.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -188,7 +188,7 @@ name = \"toml\"\n version = \"0.1.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -233,17 +233,17 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n \"checksum itertools 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c4a9b56eb56058f43dc66e58f40a214b2ccbc9f3df51861b63d51dec7b65bc3f\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n-\"checksum libc 0.2.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"408014cace30ee0f767b1c4517980646a573ec61a57957aeeabcac8ac0a02e8d\"\n+\"checksum libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"044d1360593a78f5c8e5e710beccdc24ab71d1f01bc19a29bcacdba22e8475d8\"\n \"checksum log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab83497bf8bf4ed2a74259c1c802351fcd67a65baa86394b6ba73c36f4838054\"\n \"checksum memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d8b629fb514376c675b98c1421e80b151d3817ac42d7c667717d282761418d20\"\n \"checksum multimap 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9223f4774d08e06185e44e555b9a7561243d387bac49c78a6205c42d6975fbf2\"\n-\"checksum regex 0.1.77 (registry+https://github.com/rust-lang/crates.io-index)\" = \"64b03446c466d35b42f2a8b203c8e03ed8b91c0f17b56e1f84f7210a257aa665\"\n-\"checksum regex-syntax 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"279401017ae31cf4e15344aa3f085d0e2e5c1e70067289ef906906fdbe92c8fd\"\n-\"checksum rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6159e4e6e559c81bd706afe9c8fd68f547d3e851ce12e76b1de7914bab61691b\"\n+\"checksum regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4fd4ace6a8cf7860714a2c2280d6c1f7e6a413486c13298bbc86fd3da019402f\"\n+\"checksum regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f9ec002c35e86791825ed294b50008eea9ddfc8def4420124fbc6b08db834957\"\n+\"checksum rustc-serialize 0.3.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bff9fc1c79f2dec76b253273d07682e94a978bd8f132ded071188122b2af9818\"\n \"checksum strings 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"54f86446ab480b4f60782188f4f78886465c5793aee248cbb48b7fdc0d022420\"\n-\"checksum syntex_errors 0.44.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d0d95d2141ae79f312a01c6934d9984f9d7f5cfaf0c74aae5fbbc234a6dcb77a\"\n-\"checksum syntex_pos 0.44.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3e2cbf0598c5970f2dca122a4e6f7e93bf42f2d0b2dd88c3ea112413152864df\"\n-\"checksum syntex_syntax 0.44.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5a89ee386d492cdd3855becec489c25797bb91bcbb3c2478c41969b24cb318a2\"\n+\"checksum syntex_errors 0.50.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"84822a1178204a191239ad844599f8c85c128cf9f4173397def4eb46b55b0aa1\"\n+\"checksum syntex_pos 0.50.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a43abded5057c75bac8555e46ec913ce502efb418267b1ab8e9783897470c7db\"\n+\"checksum syntex_syntax 0.50.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ef781e4b60f03431f1b5b59843546ce60ae029a787770cf8e0969ac1fd063a5\"\n \"checksum term 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3deff8a2b3b6607d6d7cc32ac25c0b33709453ca9cceac006caac51e963cf94a\"\n \"checksum thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9539db560102d1cef46b8b78ce737ff0bb64e7e18d35b2a5688f7d097d0ff03\"\n \"checksum thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8576dbbfcaef9641452d5cf0df9b0e7eeab7694956dd33bb61515fb8f18cfdd5\""}, {"sha": "122c8196a6398abca12690b6ed6118660a0bc5d5", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -22,8 +22,8 @@ regex = \"0.1\"\n term = \"0.4\"\n strings = \"0.0.1\"\n diff = \"0.1\"\n-syntex_syntax = \"0.44\"\n-syntex_errors = \"0.44\"\n+syntex_syntax = \"0.50\"\n+syntex_errors = \"0.50\"\n log = \"0.3\"\n env_logger = \"0.3\"\n getopts = \"0.2\""}, {"sha": "3bc25af63115f23038f0fa86e9ef8e6148f99975", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -98,10 +98,8 @@ fn format_crate(verbosity: Verbosity) -> Result<ExitStatus, std::io::Error> {\n     // Currently only bin and lib files get formatted\n     let files: Vec<_> = targets.into_iter()\n         .filter(|t| t.kind.should_format())\n-        .inspect(|t| {\n-            if verbosity == Verbosity::Verbose {\n-                println!(\"[{:?}] {:?}\", t.kind, t.path)\n-            }\n+        .inspect(|t| if verbosity == Verbosity::Verbose {\n+            println!(\"[{:?}] {:?}\", t.kind, t.path)\n         })\n         .map(|t| t.path)\n         .collect();\n@@ -204,15 +202,12 @@ fn format_files(files: &[PathBuf],\n         .args(files)\n         .args(fmt_args)\n         .spawn()\n-        .map_err(|e| {\n-            match e.kind() {\n-                std::io::ErrorKind::NotFound => {\n-                    std::io::Error::new(std::io::ErrorKind::Other,\n-                                        \"Could not run rustfmt, please make sure it is in your \\\n-                                         PATH.\")\n-                }\n-                _ => e,\n+        .map_err(|e| match e.kind() {\n+            std::io::ErrorKind::NotFound => {\n+                std::io::Error::new(std::io::ErrorKind::Other,\n+                                    \"Could not run rustfmt, please make sure it is in your PATH.\")\n             }\n+            _ => e,\n         }));\n     command.wait()\n }"}, {"sha": "d04169c936e0f25e27f9ccd242000e36a54fda7b", "filename": "src/codemap.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodemap.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -46,15 +46,13 @@ pub trait LineRangeUtils {\n }\n \n impl SpanUtils for CodeMap {\n-    #[inline]\n     fn span_after(&self, original: Span, needle: &str) -> BytePos {\n         let snippet = self.span_to_snippet(original).unwrap();\n         let offset = snippet.find_uncommented(needle).unwrap() + needle.len();\n \n         original.lo + BytePos(offset as u32)\n     }\n \n-    #[inline]\n     fn span_after_last(&self, original: Span, needle: &str) -> BytePos {\n         let snippet = self.span_to_snippet(original).unwrap();\n         let mut offset = 0;\n@@ -66,7 +64,6 @@ impl SpanUtils for CodeMap {\n         original.lo + BytePos(offset as u32)\n     }\n \n-    #[inline]\n     fn span_before(&self, original: Span, needle: &str) -> BytePos {\n         let snippet = self.span_to_snippet(original).unwrap();\n         let offset = snippet.find_uncommented(needle).unwrap();"}, {"sha": "f831a039b955d665ead6d0d35bc6f9eaa70efb4e", "filename": "src/comment.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -111,12 +111,10 @@ pub fn rewrite_comment(orig: &str,\n             line.trim_right()\n         })\n         .map(left_trim_comment_line)\n-        .map(|line| {\n-            if orig.starts_with(\"/*\") && line_breaks == 0 {\n-                line.trim_left()\n-            } else {\n-                line\n-            }\n+        .map(|line| if orig.starts_with(\"/*\") && line_breaks == 0 {\n+            line.trim_left()\n+        } else {\n+            line\n         });\n \n     let mut result = opener.to_owned();\n@@ -746,11 +744,9 @@ mod test {\n     // keeping it around unless it helps us test stuff.\n     fn uncommented(text: &str) -> String {\n         CharClasses::new(text.chars())\n-            .filter_map(|(s, c)| {\n-                match s {\n-                    FullCodeCharKind::Normal => Some(c),\n-                    _ => None,\n-                }\n+            .filter_map(|(s, c)| match s {\n+                FullCodeCharKind::Normal => Some(c),\n+                _ => None,\n             })\n             .collect()\n     }"}, {"sha": "13150015417ef3aea5c5b504665cbe92731761f0", "filename": "src/expr.rs", "status": "modified", "additions": 185, "deletions": 105, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -22,14 +22,14 @@ use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTacti\n             DefinitiveListTactic, definitive_tactic, ListItem, format_item_list};\n use string::{StringFormat, rewrite_string};\n use utils::{extra_offset, last_line_width, wrap_str, binary_search, first_line_width,\n-            semicolon_for_stmt, trimmed_last_line_width, left_most_sub_expr, stmt_block, stmt_expr};\n+            semicolon_for_stmt, trimmed_last_line_width, left_most_sub_expr, stmt_expr};\n use visitor::FmtVisitor;\n use config::{Config, StructLitStyle, MultilineStyle, ElseIfBraceStyle, ControlBraceStyle};\n use comment::{FindUncommented, rewrite_comment, contains_comment, recover_comment_removed};\n use types::rewrite_path;\n use items::{span_lo_for_arg, span_hi_for_arg};\n use chains::rewrite_chain;\n-use macros::rewrite_macro;\n+use macros::{rewrite_macro, MacroPosition};\n \n use syntax::{ast, ptr};\n use syntax::codemap::{CodeMap, Span, BytePos, mk_sp};\n@@ -180,12 +180,13 @@ fn format_expr(expr: &ast::Expr,\n         ast::ExprKind::Mac(ref mac) => {\n             // Failure to rewrite a marco should not imply failure to\n             // rewrite the expression.\n-            rewrite_macro(mac, None, context, width, offset).or_else(|| {\n-                wrap_str(context.snippet(expr.span),\n-                         context.config.max_width,\n-                         width,\n-                         offset)\n-            })\n+            rewrite_macro(mac, None, context, width, offset, MacroPosition::Expression)\n+                .or_else(|| {\n+                    wrap_str(context.snippet(expr.span),\n+                             context.config.max_width,\n+                             width,\n+                             offset)\n+                })\n         }\n         ast::ExprKind::Ret(None) => {\n             wrap_str(\"return\".to_owned(), context.config.max_width, width, offset)\n@@ -356,8 +357,7 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n }\n \n // This functions is pretty messy because of the rules around closures and blocks:\n-//   * the body of a closure is represented by an ast::Block, but that does not\n-//     imply there are `{}` (unless the block is empty) (see rust issue #27872),\n+// TODO\n //   * if there is a return type, then there must be braces,\n //   * given a closure with braces, whether that is parsed to give an inner block\n //     or not depends on if there is a return type and if there are statements\n@@ -367,7 +367,7 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n //     can change whether it is treated as an expression or statement.\n fn rewrite_closure(capture: ast::CaptureBy,\n                    fn_decl: &ast::FnDecl,\n-                   body: &ast::Block,\n+                   body: &ast::Expr,\n                    span: Span,\n                    context: &RewriteContext,\n                    width: usize,\n@@ -386,7 +386,6 @@ fn rewrite_closure(capture: ast::CaptureBy,\n     // 1 = |\n     let argument_offset = offset + 1;\n     let ret_str = try_opt!(fn_decl.output.rewrite(context, budget, argument_offset));\n-    let force_block = !ret_str.is_empty();\n \n     // 1 = space between arguments and return type.\n     let horizontal_budget = budget.checked_sub(ret_str.len() + 1).unwrap_or(0);\n@@ -428,111 +427,194 @@ fn rewrite_closure(capture: ast::CaptureBy,\n         prefix.push_str(&ret_str);\n     }\n \n-    if body.stmts.is_empty() {\n-        return Some(format!(\"{} {{}}\", prefix));\n-    }\n-\n     // 1 = space between `|...|` and body.\n     let extra_offset = extra_offset(&prefix, offset) + 1;\n     let budget = try_opt!(width.checked_sub(extra_offset));\n-\n-    // This is where we figure out whether to use braces or not.\n-    let mut had_braces = true;\n-    let mut inner_block = body;\n-\n-    let mut trailing_expr = stmt_expr(&inner_block.stmts[inner_block.stmts.len() - 1]);\n-\n-    // If there is an inner block and we can ignore it, do so.\n-    if body.stmts.len() == 1 && trailing_expr.is_some() {\n-        if let Some(ref inner) = stmt_block(&inner_block.stmts[0]) {\n-            inner_block = inner;\n-            trailing_expr = if inner_block.stmts.is_empty() {\n-                None\n-            } else {\n-                stmt_expr(&inner_block.stmts[inner_block.stmts.len() - 1])\n-            };\n-        } else if !force_block {\n-            had_braces = false;\n+    let total_offset = offset + extra_offset;\n+\n+    if let ast::ExprKind::Block(ref block) = body.node {\n+        // The body of the closure is a block.\n+        if block.stmts.is_empty() && !block_contains_comment(block, context.codemap) {\n+            return Some(format!(\"{} {{}}\", prefix));\n+        }\n+\n+        // Figure out if the block is necessary.\n+        let needs_block = block.rules != ast::BlockCheckMode::Default || block.stmts.len() > 1 ||\n+                          block_contains_comment(block, context.codemap) ||\n+                          prefix.contains('\\n');\n+\n+        if ret_str.is_empty() && !needs_block {\n+            // lock.stmts.len() == 1\n+            if let Some(ref expr) = stmt_expr(&block.stmts[0]) {\n+                if let Some(rw) = rewrite_closure_expr(expr,\n+                                                       &prefix,\n+                                                       context,\n+                                                       budget,\n+                                                       total_offset) {\n+                    return Some(rw);\n+                }\n+            }\n         }\n-    }\n \n-    let try_single_line = is_simple_block(inner_block, context.codemap) &&\n-                          inner_block.rules == ast::BlockCheckMode::Default;\n+        if !needs_block {\n+            // We need braces, but we might still prefer a one-liner.\n+            let stmt = &block.stmts[0];\n+            // 4 = braces and spaces.\n+            let mut rewrite = stmt.rewrite(context, try_opt!(budget.checked_sub(4)), total_offset);\n \n-    if try_single_line && !force_block {\n-        let must_preserve_braces =\n-            trailing_expr.is_none() ||\n-            !classify::expr_requires_semi_to_be_stmt(left_most_sub_expr(trailing_expr.unwrap()));\n-        if !(must_preserve_braces && had_braces) &&\n-           (must_preserve_braces || !prefix.contains('\\n')) {\n-            // If we got here, then we can try to format without braces.\n-\n-            let inner_expr = &inner_block.stmts[0];\n-            let mut rewrite = inner_expr.rewrite(context, budget, offset + extra_offset);\n-\n-            if must_preserve_braces {\n-                // If we are here, then failure to rewrite is unacceptable.\n-                if rewrite.is_none() {\n-                    return None;\n-                }\n-            } else {\n-                // Checks if rewrite succeeded and fits on a single line.\n-                rewrite = and_one_line(rewrite);\n-            }\n+            // Checks if rewrite succeeded and fits on a single line.\n+            rewrite = and_one_line(rewrite);\n \n             if let Some(rewrite) = rewrite {\n-                return Some(format!(\"{} {}\", prefix, rewrite));\n+                return Some(format!(\"{} {{ {} }}\", prefix, rewrite));\n             }\n         }\n+\n+        // Either we require a block, or tried without and failed.\n+        return rewrite_closure_block(&block, prefix, context, budget);\n     }\n \n-    // If we fell through the above block, then we need braces, but we might\n-    // still prefer a one-liner (we might also have fallen through because of\n-    // lack of space).\n-    if try_single_line && !prefix.contains('\\n') {\n-        let inner_expr = &inner_block.stmts[0];\n-        // 4 = braces and spaces.\n-        let mut rewrite = inner_expr.rewrite(context,\n-                                             try_opt!(budget.checked_sub(4)),\n-                                             offset + extra_offset);\n+    if let Some(rw) = rewrite_closure_expr(body, &prefix, context, budget, total_offset) {\n+        return Some(rw);\n+    }\n \n-        // Checks if rewrite succeeded and fits on a single line.\n-        rewrite = and_one_line(rewrite);\n+    // The closure originally had a non-block expression, but we can't fit on\n+    // one line, so we'll insert a block.\n+    let block = ast::Block {\n+        stmts: vec![ast::Stmt {\n+                        id: ast::NodeId::new(0),\n+                        node: ast::StmtKind::Expr(ptr::P(body.clone())),\n+                        span: body.span,\n+                    }],\n+        id: ast::NodeId::new(0),\n+        rules: ast::BlockCheckMode::Default,\n+        span: body.span,\n+    };\n+    return rewrite_closure_block(&block, prefix, context, budget);\n \n-        if let Some(rewrite) = rewrite {\n-            return Some(format!(\"{} {{ {} }}\", prefix, rewrite));\n+    fn rewrite_closure_expr(expr: &ast::Expr,\n+                            prefix: &str,\n+                            context: &RewriteContext,\n+                            budget: usize,\n+                            offset: Indent)\n+                            -> Option<String> {\n+        let mut rewrite = expr.rewrite(context, budget, offset);\n+        if classify::expr_requires_semi_to_be_stmt(left_most_sub_expr(expr)) {\n+            rewrite = and_one_line(rewrite);\n         }\n+        rewrite.map(|rw| format!(\"{} {}\", prefix, rw))\n     }\n \n-    // We couldn't format the closure body as a single line expression; fall\n-    // back to block formatting.\n-    let body_rewrite = try_opt!(inner_block.rewrite(&context, budget, Indent::empty()));\n+    fn rewrite_closure_block(block: &ast::Block,\n+                             prefix: String,\n+                             context: &RewriteContext,\n+                             budget: usize)\n+                             -> Option<String> {\n+        // Start with visual indent, then fall back to block indent if the\n+        // closure is large.\n+        let rewrite = try_opt!(block.rewrite(&context, budget, Indent::empty()));\n \n-    let block_threshold = context.config.closure_block_indent_threshold;\n-    if block_threshold < 0 || body_rewrite.matches('\\n').count() <= block_threshold as usize {\n-        return Some(format!(\"{} {}\", prefix, body_rewrite));\n+        let block_threshold = context.config.closure_block_indent_threshold;\n+        if block_threshold < 0 || rewrite.matches('\\n').count() <= block_threshold as usize {\n+            return Some(format!(\"{} {}\", prefix, rewrite));\n+        }\n+\n+        // The body of the closure is big enough to be block indented, that\n+        // means we must re-format.\n+        let mut context = context.clone();\n+        context.block_indent.alignment = 0;\n+        let rewrite = try_opt!(block.rewrite(&context, budget, Indent::empty()));\n+        Some(format!(\"{} {}\", prefix, rewrite))\n     }\n \n-    // The body of the closure is big enough to be block indented, that means we\n-    // must re-format.\n-    let mut context = context.clone();\n-    context.block_indent.alignment = 0;\n-    let body_rewrite = try_opt!(inner_block.rewrite(&context, budget, Indent::empty()));\n-    Some(format!(\"{} {}\", prefix, body_rewrite))\n+    // // This is where we figure out whether to use braces or not.\n+    // let mut had_braces = true;\n+    // let mut inner_block = body;\n+\n+    // let mut trailing_expr = stmt_expr(&inner_block.stmts[inner_block.stmts.len() - 1]);\n+\n+    // // If there is an inner block and we can ignore it, do so.\n+    // if body.stmts.len() == 1 && trailing_expr.is_some() {\n+    //     if let Some(ref inner) = stmt_block(&inner_block.stmts[0]) {\n+    //         inner_block = inner;\n+    //         trailing_expr = if inner_block.stmts.is_empty() {\n+    //             None\n+    //         } else {\n+    //             stmt_expr(&inner_block.stmts[inner_block.stmts.len() - 1])\n+    //         };\n+    //     } else if !force_block {\n+    //         had_braces = false;\n+    //     }\n+    // }\n+\n+    // let try_single_line = is_simple_block(inner_block, context.codemap) &&\n+    //                       inner_block.rules == ast::BlockCheckMode::Default;\n+\n+\n+    // if try_single_line && !force_block {\n+    //     let must_preserve_braces =\n+    //         trailing_expr.is_none() ||\n+    //         !classify::expr_requires_semi_to_be_stmt(left_most_sub_expr(trailing_expr.unwrap()));\n+    //     if !(must_preserve_braces && had_braces) &&\n+    //        (must_preserve_braces || !prefix.contains('\\n')) {\n+    //         // If we got here, then we can try to format without braces.\n+\n+    //         let inner_expr = &inner_block.stmts[0];\n+    //         let mut rewrite = inner_expr.rewrite(context, budget, offset + extra_offset);\n+\n+    //         if must_preserve_braces {\n+    //             // If we are here, then failure to rewrite is unacceptable.\n+    //             if rewrite.is_none() {\n+    //                 return None;\n+    //             }\n+    //         } else {\n+    //             // Checks if rewrite succeeded and fits on a single line.\n+    //             rewrite = and_one_line(rewrite);\n+    //         }\n+\n+    //         if let Some(rewrite) = rewrite {\n+    //             return Some(format!(\"{} {}\", prefix, rewrite));\n+    //         }\n+    //     }\n+    // }\n+\n+    // // If we fell through the above block, then we need braces, but we might\n+    // // still prefer a one-liner (we might also have fallen through because of\n+    // // lack of space).\n+    // if try_single_line && !prefix.contains('\\n') {\n+    //     let inner_expr = &inner_block.stmts[0];\n+    //     // 4 = braces and spaces.\n+    //     let mut rewrite = inner_expr.rewrite(context,\n+    //                                          try_opt!(budget.checked_sub(4)),\n+    //                                          offset + extra_offset);\n+\n+    //     // Checks if rewrite succeeded and fits on a single line.\n+    //     rewrite = and_one_line(rewrite);\n+\n+    //     if let Some(rewrite) = rewrite {\n+    //         return Some(format!(\"{} {{ {} }}\", prefix, rewrite));\n+    //     }\n+    // }\n+\n+    // // We couldn't format the closure body as a single line expression; fall\n+    // // back to block formatting.\n+    // let mut context = context.clone();\n+    // context.block_indent.alignment = 0;\n+    // let body_rewrite = try_opt!(inner_block.rewrite(&context, budget, Indent::empty()));\n+    // Some(format!(\"{} {}\", prefix, body_rewrite))\n }\n \n fn and_one_line(x: Option<String>) -> Option<String> {\n     x.and_then(|x| if x.contains('\\n') { None } else { Some(x) })\n }\n \n fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String> {\n-    block_str.map(|block_str| {\n-        if block_str.starts_with('{') && budget >= 2 &&\n-           (block_str[1..].find(|c: char| !c.is_whitespace()).unwrap() == block_str.len() - 2) {\n-            \"{}\".to_owned()\n-        } else {\n-            block_str.to_owned()\n-        }\n+    block_str.map(|block_str| if block_str.starts_with('{') && budget >= 2 &&\n+                                 (block_str[1..].find(|c: char| !c.is_whitespace()).unwrap() ==\n+                                  block_str.len() - 2) {\n+        \"{}\".to_owned()\n+    } else {\n+        block_str.to_owned()\n     })\n }\n \n@@ -1616,23 +1698,21 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n     let items = itemize_list(context.codemap,\n                              field_iter,\n                              \"}\",\n-                             |item| {\n-        match *item {\n-            StructLitField::Regular(field) => field.span.lo,\n-            StructLitField::Base(expr) => {\n-                let last_field_hi = fields.last().map_or(span.lo, |field| field.span.hi);\n-                let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n-                let pos = snippet.find_uncommented(\"..\").unwrap();\n-                last_field_hi + BytePos(pos as u32)\n-            }\n-        }\n-    },\n-                             |item| {\n-                                 match *item {\n-                                     StructLitField::Regular(field) => field.span.hi,\n-                                     StructLitField::Base(expr) => expr.span.hi,\n+                             |item| match *item {\n+                                 StructLitField::Regular(field) => field.span.lo,\n+                                 StructLitField::Base(expr) => {\n+                                     let last_field_hi = fields.last()\n+                                         .map_or(span.lo, |field| field.span.hi);\n+                                     let snippet =\n+                                         context.snippet(mk_sp(last_field_hi, expr.span.lo));\n+                                     let pos = snippet.find_uncommented(\"..\").unwrap();\n+                                     last_field_hi + BytePos(pos as u32)\n                                  }\n                              },\n+                             |item| match *item {\n+                                 StructLitField::Regular(field) => field.span.hi,\n+                                 StructLitField::Base(expr) => expr.span.hi,\n+                             },\n                              |item| {\n         match *item {\n             StructLitField::Regular(field) => {"}, {"sha": "ac8a96a0fe0473b7a2ef1167c1773ac0d23e2bdc", "filename": "src/items.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -364,13 +364,11 @@ impl<'a> FmtVisitor<'a> {\n         let items = itemize_list(self.codemap,\n                                  enum_def.variants.iter(),\n                                  \"}\",\n-                                 |f| {\n-            if !f.node.attrs.is_empty() {\n-                f.node.attrs[0].span.lo\n-            } else {\n-                f.span.lo\n-            }\n-        },\n+                                 |f| if !f.node.attrs.is_empty() {\n+                                     f.node.attrs[0].span.lo\n+                                 } else {\n+                                     f.span.lo\n+                                 },\n                                  |f| f.span.hi,\n                                  |f| self.format_variant(f),\n                                  body_lo,\n@@ -1629,23 +1627,17 @@ fn rewrite_args(context: &RewriteContext,\n                                           .map(ArgumentKind::Regular)\n                                           .chain(variadic_arg),\n                                       \")\",\n-                                      |arg| {\n-                                          match *arg {\n-                                              ArgumentKind::Regular(arg) => span_lo_for_arg(arg),\n-                                              ArgumentKind::Variadic(start) => start,\n-                                          }\n+                                      |arg| match *arg {\n+                                          ArgumentKind::Regular(arg) => span_lo_for_arg(arg),\n+                                          ArgumentKind::Variadic(start) => start,\n                                       },\n-                                      |arg| {\n-                                          match *arg {\n-                                              ArgumentKind::Regular(arg) => arg.ty.span.hi,\n-                                              ArgumentKind::Variadic(start) => start + BytePos(3),\n-                                          }\n+                                      |arg| match *arg {\n+                                          ArgumentKind::Regular(arg) => arg.ty.span.hi,\n+                                          ArgumentKind::Variadic(start) => start + BytePos(3),\n                                       },\n-                                      |arg| {\n-                                          match *arg {\n-                                              ArgumentKind::Regular(..) => None,\n-                                              ArgumentKind::Variadic(..) => Some(\"...\".to_owned()),\n-                                          }\n+                                      |arg| match *arg {\n+                                          ArgumentKind::Regular(..) => None,\n+                                          ArgumentKind::Variadic(..) => Some(\"...\".to_owned()),\n                                       },\n                                       comment_span_start,\n                                       span.hi);"}, {"sha": "50f1ab312913535e60b6d3152a06ad716d1d9005", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -393,9 +393,9 @@ fn parse_input(input: Input,\n                parse_session: &ParseSess)\n                -> Result<ast::Crate, Option<DiagnosticBuilder>> {\n     let result = match input {\n-        Input::File(file) => parse::parse_crate_from_file(&file, Vec::new(), parse_session),\n+        Input::File(file) => parse::parse_crate_from_file(&file, parse_session),\n         Input::Text(text) => {\n-            parse::parse_crate_from_source_str(\"stdin\".to_owned(), text, Vec::new(), parse_session)\n+            parse::parse_crate_from_source_str(\"stdin\".to_owned(), text, parse_session)\n         }\n     };\n "}, {"sha": "1d9eb3f1ea87b0b2a2fa0071bc875f9fa49f774b", "filename": "src/macros.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -41,6 +41,13 @@ enum MacroStyle {\n     Braces,\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum MacroPosition {\n+    Item,\n+    Statement,\n+    Expression,\n+}\n+\n impl MacroStyle {\n     fn opener(&self) -> &'static str {\n         match *self {\n@@ -55,7 +62,8 @@ pub fn rewrite_macro(mac: &ast::Mac,\n                      extra_ident: Option<ast::Ident>,\n                      context: &RewriteContext,\n                      width: usize,\n-                     offset: Indent)\n+                     offset: Indent,\n+                     position: MacroPosition)\n                      -> Option<String> {\n     if context.config.use_try_shorthand {\n         if let Some(expr) = convert_try_mac(mac, context) {\n@@ -77,13 +85,16 @@ pub fn rewrite_macro(mac: &ast::Mac,\n \n     if mac.node.tts.is_empty() && !contains_comment(&context.snippet(mac.span)) {\n         return match style {\n+            MacroStyle::Parens if position == MacroPosition::Item => {\n+                Some(format!(\"{}();\", macro_name))\n+            }\n             MacroStyle::Parens => Some(format!(\"{}()\", macro_name)),\n             MacroStyle::Brackets => Some(format!(\"{}[]\", macro_name)),\n             MacroStyle::Braces => Some(format!(\"{}{{}}\", macro_name)),\n         };\n     }\n \n-    let mut parser = tts_to_parser(context.parse_session, mac.node.tts.clone(), Vec::new());\n+    let mut parser = tts_to_parser(context.parse_session, mac.node.tts.clone());\n     let mut expr_vec = Vec::new();\n \n     if MacroStyle::Braces != style {\n@@ -128,6 +139,10 @@ pub fn rewrite_macro(mac: &ast::Mac,\n         MacroStyle::Parens => {\n             // Format macro invocation as function call.\n             rewrite_call(context, &macro_name, &expr_vec, mac.span, width, offset)\n+                .map(|rw| match position {\n+                    MacroPosition::Item => format!(\"{};\", rw),\n+                    _ => rw,\n+                })\n         }\n         MacroStyle::Brackets => {\n             // Format macro invocation as array literal.\n@@ -155,10 +170,10 @@ pub fn rewrite_macro(mac: &ast::Mac,\n /// failed).\n pub fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext) -> Option<ast::Expr> {\n     if &format!(\"{}\", mac.node.path)[..] == \"try\" {\n-        let mut parser = tts_to_parser(context.parse_session, mac.node.tts.clone(), Vec::new());\n+        let mut parser = tts_to_parser(context.parse_session, mac.node.tts.clone());\n \n         Some(ast::Expr {\n-            id: 0, // dummy value\n+            id: ast::NodeId::new(0), // dummy value\n             node: ast::ExprKind::Try(try_opt!(parser.parse_expr().ok())),\n             span: mac.span, // incorrect span, but shouldn't matter too much\n             attrs: ThinVec::new(),"}, {"sha": "9caea8646410ae1e137e55177a20ee72ef780495", "filename": "src/missed_spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -103,7 +103,7 @@ impl<'a> FmtVisitor<'a> {\n \n         fn replace_chars(string: &str) -> String {\n             string.chars()\n-                .map(|ch| { if ch.is_whitespace() { ch } else { 'X' } })\n+                .map(|ch| if ch.is_whitespace() { ch } else { 'X' })\n                 .collect()\n         }\n "}, {"sha": "a4ae0b7595a6d876dbe11c7749ba72a2376012b8", "filename": "src/patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -78,7 +78,7 @@ impl Rewrite for Pat {\n                                   offset)\n             }\n             PatKind::Lit(ref expr) => expr.rewrite(context, width, offset),\n-            PatKind::Vec(ref prefix, ref slice_pat, ref suffix) => {\n+            PatKind::Slice(ref prefix, ref slice_pat, ref suffix) => {\n                 // Rewrite all the sub-patterns.\n                 let prefix = prefix.iter().map(|p| p.rewrite(context, width, offset));\n                 let slice_pat = slice_pat.as_ref()"}, {"sha": "f4f86f58815c61f1e18ff2c83be20a696a497cf6", "filename": "src/types.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -279,32 +279,27 @@ fn format_function_type<'a, I>(inputs: I,\n     // 1 for (\n     let offset = offset + 1;\n     let list_lo = context.codemap.span_after(span, \"(\");\n-    let items = itemize_list(context.codemap,\n-                             // FIXME Would be nice to avoid this allocation,\n-                             // but I couldn't get the types to work out.\n-                             inputs.map(|i| ArgumentKind::Regular(Box::new(i)))\n-                                 .chain(variadic_arg),\n-                             \")\",\n-                             |arg| {\n-                                 match *arg {\n-                                     ArgumentKind::Regular(ref ty) => ty.span().lo,\n-                                     ArgumentKind::Variadic(start) => start,\n-                                 }\n-                             },\n-                             |arg| {\n-                                 match *arg {\n-                                     ArgumentKind::Regular(ref ty) => ty.span().hi,\n-                                     ArgumentKind::Variadic(start) => start + BytePos(3),\n-                                 }\n-                             },\n-                             |arg| {\n-        match *arg {\n-            ArgumentKind::Regular(ref ty) => ty.rewrite(context, budget, offset),\n-            ArgumentKind::Variadic(_) => Some(\"...\".to_owned()),\n-        }\n-    },\n-                             list_lo,\n-                             span.hi);\n+    let items =\n+        itemize_list(context.codemap,\n+                     // FIXME Would be nice to avoid this allocation,\n+                     // but I couldn't get the types to work out.\n+                     inputs.map(|i| ArgumentKind::Regular(Box::new(i)))\n+                         .chain(variadic_arg),\n+                     \")\",\n+                     |arg| match *arg {\n+                         ArgumentKind::Regular(ref ty) => ty.span().lo,\n+                         ArgumentKind::Variadic(start) => start,\n+                     },\n+                     |arg| match *arg {\n+                         ArgumentKind::Regular(ref ty) => ty.span().hi,\n+                         ArgumentKind::Variadic(start) => start + BytePos(3),\n+                     },\n+                     |arg| match *arg {\n+                         ArgumentKind::Regular(ref ty) => ty.rewrite(context, budget, offset),\n+                         ArgumentKind::Variadic(_) => Some(\"...\".to_owned()),\n+                     },\n+                     list_lo,\n+                     span.hi);\n \n     let list_str = try_opt!(format_fn_args(items, budget, offset, context.config));\n \n@@ -606,7 +601,7 @@ impl Rewrite for ast::Ty {\n                         format!(\"({})\", ty_str)\n                     })\n             }\n-            ast::TyKind::Vec(ref ty) => {\n+            ast::TyKind::Slice(ref ty) => {\n                 let budget = if context.config.spaces_within_square_brackets {\n                     try_opt!(width.checked_sub(4))\n                 } else {\n@@ -630,7 +625,7 @@ impl Rewrite for ast::Ty {\n             ast::TyKind::Path(ref q_self, ref path) => {\n                 rewrite_path(context, false, q_self.as_ref(), path, width, offset)\n             }\n-            ast::TyKind::FixedLengthVec(ref ty, ref repeats) => {\n+            ast::TyKind::Array(ref ty, ref repeats) => {\n                 let use_spaces = context.config.spaces_within_square_brackets;\n                 let lbr = if use_spaces { \"[ \" } else { \"[\" };\n                 let rbr = if use_spaces { \" ]\" } else { \"]\" };"}, {"sha": "befed42c6fad29d30f0d29dbdb092fa3abf77f30", "filename": "src/utils.rs", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -127,11 +127,9 @@ pub fn contains_skip(attrs: &[Attribute]) -> bool {\n pub fn end_typaram(typaram: &ast::TyParam) -> BytePos {\n     typaram.bounds\n         .last()\n-        .map_or(typaram.span, |bound| {\n-            match *bound {\n-                ast::RegionTyParamBound(ref lt) => lt.span,\n-                ast::TraitTyParamBound(ref prt, _) => prt.span,\n-            }\n+        .map_or(typaram.span, |bound| match *bound {\n+            ast::RegionTyParamBound(ref lt) => lt.span,\n+            ast::TraitTyParamBound(ref prt, _) => prt.span,\n         })\n         .hi\n }\n@@ -163,19 +161,6 @@ pub fn semicolon_for_stmt(stmt: &ast::Stmt) -> bool {\n     }\n }\n \n-#[inline]\n-pub fn stmt_block(stmt: &ast::Stmt) -> Option<&ast::Block> {\n-    match stmt.node {\n-        ast::StmtKind::Expr(ref expr) => {\n-            match expr.node {\n-                ast::ExprKind::Block(ref inner) => Some(inner),\n-                _ => None,\n-            }\n-        }\n-        _ => None,\n-    }\n-}\n-\n #[inline]\n pub fn stmt_expr(stmt: &ast::Stmt) -> Option<&ast::Expr> {\n     match stmt.node {\n@@ -334,13 +319,11 @@ pub fn binary_search<C, T>(mut lo: usize, mut hi: usize, callback: C) -> Option<\n \n #[test]\n fn bin_search_test() {\n-    let closure = |i| {\n-        match i {\n-            4 => Ok(()),\n-            j if j > 4 => Err(Ordering::Less),\n-            j if j < 4 => Err(Ordering::Greater),\n-            _ => unreachable!(),\n-        }\n+    let closure = |i| match i {\n+        4 => Ok(()),\n+        j if j > 4 => Err(Ordering::Less),\n+        j if j < 4 => Err(Ordering::Greater),\n+        _ => unreachable!(),\n     };\n \n     assert_eq!(Some(()), binary_search(1, 10, &closure));"}, {"sha": "9c019fdd2d14e1dd5a8a9d154f45a88ee3f00148", "filename": "src/visitor.rs", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -20,7 +20,7 @@ use codemap::{LineRangeUtils, SpanUtils};\n use config::Config;\n use rewrite::{Rewrite, RewriteContext};\n use comment::rewrite_comment;\n-use macros::rewrite_macro;\n+use macros::{rewrite_macro, MacroPosition};\n use items::{rewrite_static, rewrite_associated_type, rewrite_type_alias, format_impl, format_trait};\n \n fn is_use_item(item: &ast::Item) -> bool {\n@@ -66,7 +66,7 @@ impl<'a> FmtVisitor<'a> {\n             }\n             ast::StmtKind::Mac(ref mac) => {\n                 let (ref mac, _macro_style, _) = **mac;\n-                self.visit_mac(mac, None);\n+                self.visit_mac(mac, None, MacroPosition::Statement);\n             }\n         }\n     }\n@@ -124,13 +124,14 @@ impl<'a> FmtVisitor<'a> {\n     fn visit_fn(&mut self,\n                 fk: visit::FnKind,\n                 fd: &ast::FnDecl,\n-                b: &ast::Block,\n                 s: Span,\n                 _: ast::NodeId,\n                 defaultness: ast::Defaultness) {\n         let indent = self.block_indent;\n+        let block;\n         let rewrite = match fk {\n-            visit::FnKind::ItemFn(ident, generics, unsafety, constness, abi, vis) => {\n+            visit::FnKind::ItemFn(ident, generics, unsafety, constness, abi, vis, b) => {\n+                block = b;\n                 self.rewrite_fn(indent,\n                                 ident,\n                                 fd,\n@@ -141,9 +142,10 @@ impl<'a> FmtVisitor<'a> {\n                                 abi,\n                                 vis,\n                                 codemap::mk_sp(s.lo, b.span.lo),\n-                                b)\n+                                &b)\n             }\n-            visit::FnKind::Method(ident, sig, vis) => {\n+            visit::FnKind::Method(ident, sig, vis, b) => {\n+                block = b;\n                 self.rewrite_fn(indent,\n                                 ident,\n                                 fd,\n@@ -154,26 +156,26 @@ impl<'a> FmtVisitor<'a> {\n                                 sig.abi,\n                                 vis.unwrap_or(&ast::Visibility::Inherited),\n                                 codemap::mk_sp(s.lo, b.span.lo),\n-                                b)\n+                                &b)\n             }\n-            visit::FnKind::Closure => None,\n+            visit::FnKind::Closure(_) => unreachable!(),\n         };\n \n         if let Some(fn_str) = rewrite {\n             self.format_missing_with_indent(source!(self, s).lo);\n             self.buffer.push_str(&fn_str);\n             if let Some(c) = fn_str.chars().last() {\n                 if c == '}' {\n-                    self.last_pos = source!(self, b.span).hi;\n+                    self.last_pos = source!(self, block.span).hi;\n                     return;\n                 }\n             }\n         } else {\n-            self.format_missing(source!(self, b.span).lo);\n+            self.format_missing(source!(self, block.span).lo);\n         }\n \n-        self.last_pos = source!(self, b.span).lo;\n-        self.visit_block(b)\n+        self.last_pos = source!(self, block.span).lo;\n+        self.visit_block(block)\n     }\n \n     pub fn visit_item(&mut self, item: &ast::Item) {\n@@ -261,11 +263,9 @@ impl<'a> FmtVisitor<'a> {\n                                            item.span,\n                                            indent,\n                                            None)\n-                        .map(|s| {\n-                            match *def {\n-                                ast::VariantData::Tuple(..) => s + \";\",\n-                                _ => s,\n-                            }\n+                        .map(|s| match *def {\n+                            ast::VariantData::Tuple(..) => s + \";\",\n+                            _ => s,\n                         })\n                 };\n                 self.push_rewrite(item.span, rewrite);\n@@ -280,7 +280,7 @@ impl<'a> FmtVisitor<'a> {\n                 self.format_mod(module, &item.vis, item.span, item.ident);\n             }\n             ast::ItemKind::Mac(ref mac) => {\n-                self.visit_mac(mac, Some(item.ident));\n+                self.visit_mac(mac, Some(item.ident), MacroPosition::Item);\n             }\n             ast::ItemKind::ForeignMod(ref foreign_mod) => {\n                 self.format_missing_with_indent(source!(self, item.span).lo);\n@@ -315,9 +315,9 @@ impl<'a> FmtVisitor<'a> {\n                                                     unsafety,\n                                                     constness,\n                                                     abi,\n-                                                    &item.vis),\n+                                                    &item.vis,\n+                                                    body),\n                               decl,\n-                              body,\n                               item.span,\n                               item.id,\n                               ast::Defaultness::Final)\n@@ -361,9 +361,8 @@ impl<'a> FmtVisitor<'a> {\n                 self.push_rewrite(ti.span, rewrite);\n             }\n             ast::TraitItemKind::Method(ref sig, Some(ref body)) => {\n-                self.visit_fn(visit::FnKind::Method(ti.ident, sig, None),\n+                self.visit_fn(visit::FnKind::Method(ti.ident, sig, None, body),\n                               &sig.decl,\n-                              body,\n                               ti.span,\n                               ti.id,\n                               ast::Defaultness::Final);\n@@ -390,9 +389,8 @@ impl<'a> FmtVisitor<'a> {\n \n         match ii.node {\n             ast::ImplItemKind::Method(ref sig, ref body) => {\n-                self.visit_fn(visit::FnKind::Method(ii.ident, sig, Some(&ii.vis)),\n+                self.visit_fn(visit::FnKind::Method(ii.ident, sig, Some(&ii.vis), body),\n                               &sig.decl,\n-                              body,\n                               ii.span,\n                               ii.id,\n                               ii.defaultness);\n@@ -416,15 +414,20 @@ impl<'a> FmtVisitor<'a> {\n                 self.push_rewrite(ii.span, rewrite);\n             }\n             ast::ImplItemKind::Macro(ref mac) => {\n-                self.visit_mac(mac, Some(ii.ident));\n+                self.visit_mac(mac, Some(ii.ident), MacroPosition::Item);\n             }\n         }\n     }\n \n-    fn visit_mac(&mut self, mac: &ast::Mac, ident: Option<ast::Ident>) {\n+    fn visit_mac(&mut self, mac: &ast::Mac, ident: Option<ast::Ident>, pos: MacroPosition) {\n         // 1 = ;\n         let width = self.config.max_width - self.block_indent.width() - 1;\n-        let rewrite = rewrite_macro(mac, ident, &self.get_context(), width, self.block_indent);\n+        let rewrite = rewrite_macro(mac,\n+                                    ident,\n+                                    &self.get_context(),\n+                                    width,\n+                                    self.block_indent,\n+                                    pos);\n         self.push_rewrite(mac.span, rewrite);\n     }\n \n@@ -513,7 +516,9 @@ impl<'a> FmtVisitor<'a> {\n     fn format_mod(&mut self, m: &ast::Mod, vis: &ast::Visibility, s: Span, ident: ast::Ident) {\n         // Decide whether this is an inline mod or an external mod.\n         let local_file_name = self.codemap.span_to_filename(s);\n-        let is_internal = local_file_name == self.codemap.span_to_filename(source!(self, m.inner));\n+        let inner_span = source!(self, m.inner);\n+        let is_internal = !(inner_span.lo.0 == 0 && inner_span.hi.0 == 0) &&\n+                          local_file_name == self.codemap.span_to_filename(inner_span);\n \n         self.buffer.push_str(&*utils::format_visibility(vis));\n         self.buffer.push_str(\"mod \");"}, {"sha": "472532676c5478b0c4cfb20459ae0285f961cae6", "filename": "tests/target/chains-visual.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/tests%2Ftarget%2Fchains-visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/tests%2Ftarget%2Fchains-visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-visual.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -46,9 +46,7 @@ fn main() {\n         });\n \n     fffffffffffffffffffffffffffffffffff(a, {\n-        SCRIPT_TASK_ROOT.with(|root| {\n-            *root.borrow_mut() = Some(&script_task);\n-        });\n+        SCRIPT_TASK_ROOT.with(|root| { *root.borrow_mut() = Some(&script_task); });\n     });\n \n     let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx.map(|x| x + 5)"}, {"sha": "726dbac155f63726b0080e22eb1d6342ba3e2387", "filename": "tests/target/chains.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -44,9 +44,7 @@ fn main() {\n         });\n \n     fffffffffffffffffffffffffffffffffff(a, {\n-        SCRIPT_TASK_ROOT.with(|root| {\n-            *root.borrow_mut() = Some(&script_task);\n-        });\n+        SCRIPT_TASK_ROOT.with(|root| { *root.borrow_mut() = Some(&script_task); });\n     });\n \n     let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx.map(|x| x + 5)"}, {"sha": "101f3ea961cb1866bef6c2f53fe74720a0c5451f", "filename": "tests/target/closure.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -3,14 +3,13 @@\n fn main() {\n     let square = (|i: i32| i * i);\n \n-    let commented = |// first\n-                     a, // argument\n-                     // second\n-                     b: WithType, // argument\n-                     // ignored\n-                     _| {\n-        (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb)\n-    };\n+    let commented =\n+        |// first\n+         a, // argument\n+         // second\n+         b: WithType, // argument\n+         // ignored\n+         _| (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\n \n     let block_body = move |xxxxxxxxxxxxxxxxxxxxxxxxxxxxx,\n                            ref yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy| {"}, {"sha": "d3adae0348159ee9207484dd4a32098af739b444", "filename": "tests/target/hard-tabs.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/tests%2Ftarget%2Fhard-tabs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/tests%2Ftarget%2Fhard-tabs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fhard-tabs.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -73,27 +73,21 @@ fn main() {\n \t\targ(a, b, c, d, e)\n \t}\n \n-\tloong_func().quux(move || {\n-\t\tif true {\n-\t\t\t1\n-\t\t} else {\n-\t\t\t2\n-\t\t}\n+\tloong_func().quux(move || if true {\n+\t\t1\n+\t} else {\n+\t\t2\n \t});\n \n \tfffffffffffffffffffffffffffffffffff(a, {\n-\t\tSCRIPT_TASK_ROOT.with(|root| {\n-\t\t\t*root.borrow_mut() = Some(&script_task);\n-\t\t});\n+\t\tSCRIPT_TASK_ROOT.with(|root| { *root.borrow_mut() = Some(&script_task); });\n \t});\n \ta.b\n \t\t.c\n \t\t.d();\n \n-\tx().y(|| {\n-\t\tmatch cond() {\n-\t\t\ttrue => (),\n-\t\t\tfalse => (),\n-\t\t}\n+\tx().y(|| match cond() {\n+\t\ttrue => (),\n+\t\tfalse => (),\n \t});\n }"}, {"sha": "ee143e792b02dceccc91ff19f08804e53decac3d", "filename": "tests/target/issue-1055.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/tests%2Ftarget%2Fissue-1055.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3eba76e4d63c08fa0c4406745d1f0cc0e576758/tests%2Ftarget%2Fissue-1055.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-1055.rs?ref=d3eba76e4d63c08fa0c4406745d1f0cc0e576758", "patch": "@@ -1,4 +1,3 @@\n fn issue_1055() {\n-    let foo = (|| {\n-    })();\n+    let foo = (|| {})();\n }"}]}