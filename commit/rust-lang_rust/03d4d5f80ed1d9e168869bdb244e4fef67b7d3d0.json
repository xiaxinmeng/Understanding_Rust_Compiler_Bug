{"sha": "03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzZDRkNWY4MGVkMWQ5ZTE2ODg2OWJkYjI0NGU0ZmVmNjdiN2QzZDA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-19T22:52:26Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-13T02:19:51Z"}, "message": "Fix a bunch of bugs\n\n* segfault due to not copying drop flag when coercing\n* fat pointer casts\n* segfault due to not checking drop flag properly\n* debuginfo for DST smart pointers\n* unreachable code in drop glue", "tree": {"sha": "d6fbc4384526bd7a96b39b708767558dc9b34f72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6fbc4384526bd7a96b39b708767558dc9b34f72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0", "html_url": "https://github.com/rust-lang/rust/commit/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d953538d10c4a31300afd27f73563adb056beab", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d953538d10c4a31300afd27f73563adb056beab", "html_url": "https://github.com/rust-lang/rust/commit/7d953538d10c4a31300afd27f73563adb056beab"}], "stats": {"total": 168, "additions": 114, "deletions": 54}, "files": [{"sha": "837cf590024504fe89c78d67f139f3381673a2ac", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0", "patch": "@@ -544,7 +544,8 @@ impl<T: ?Sized> Drop for Rc<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = *self._ptr;\n-            if !(*(&ptr as *const _ as *const *const ())).is_null() {\n+            if !(*(&ptr as *const _ as *const *const ())).is_null() &&\n+               ptr as usize != mem::POST_DROP_USIZE {\n                 self.dec_strong();\n                 if self.strong() == 0 {\n                     // destroy the contained object\n@@ -1010,7 +1011,8 @@ impl<T: ?Sized> Drop for Weak<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = *self._ptr;\n-            if !(*(&ptr as *const _ as *const *const ())).is_null() {\n+            if !(*(&ptr as *const _ as *const *const ())).is_null() &&\n+               ptr as usize != mem::POST_DROP_USIZE {\n                 self.dec_weak();\n                 // the weak count starts at 1, and will only go to zero if all\n                 // the strong pointers have disappeared."}, {"sha": "5a84edd3cdfbab489b4c86ddfa927a1a858e4633", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0", "patch": "@@ -5606,8 +5606,7 @@ impl DtorKind {\n     }\n }\n \n-/* If struct_id names a struct with a dtor, return Some(the dtor's id).\n-   Otherwise return none. */\n+/* If struct_id names a struct with a dtor. */\n pub fn ty_dtor(cx: &ctxt, struct_id: DefId) -> DtorKind {\n     match cx.destructor_for_type.borrow().get(&struct_id) {\n         Some(&method_def_id) => {"}, {"sha": "17c9fa248180c01ddd8dd3b57db8ebd8dac6154e", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0", "patch": "@@ -141,7 +141,8 @@ pub fn represent_node<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n /// Decides how to represent a given type.\n pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                t: Ty<'tcx>) -> Rc<Repr<'tcx>> {\n+                                t: Ty<'tcx>)\n+                                -> Rc<Repr<'tcx>> {\n     debug!(\"Representing: {}\", ty_to_string(cx.tcx(), t));\n     match cx.adt_reprs().borrow().get(&t) {\n         Some(repr) => return repr.clone(),\n@@ -216,7 +217,9 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }).collect::<Vec<_>>();\n             let packed = ty::lookup_packed(cx.tcx(), def_id);\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n-            if dtor { ftys.push(cx.tcx().dtor_type()); }\n+            if dtor {\n+                ftys.push(cx.tcx().dtor_type());\n+            }\n \n             Univariant(mk_struct(cx, &ftys[..], packed, t), dtor_to_init_u8(dtor))\n         }\n@@ -517,8 +520,7 @@ fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                        -> Struct<'tcx> {\n     let sized = tys.iter().all(|&ty| type_is_sized(cx.tcx(), ty));\n     let lltys : Vec<Type> = if sized {\n-        tys.iter()\n-           .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n+        tys.iter().map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n         tys.iter().filter(|&ty| type_is_sized(cx.tcx(), *ty))\n            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n@@ -1060,7 +1062,9 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n }\n \n /// Access the struct drop flag, if present.\n-pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>, val: ValueRef)\n+pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                       r: &Repr<'tcx>,\n+                                       val: ValueRef)\n                                        -> datum::DatumBlock<'blk, 'tcx, datum::Expr>\n {\n     let tcx = bcx.tcx();"}, {"sha": "4018df0da4737ed2e9410e1d289113183d0b7682", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0", "patch": "@@ -58,7 +58,7 @@ use middle::check_const;\n use middle::def;\n use middle::lang_items::CoerceUnsizedTraitLangItem;\n use middle::mem_categorization::Typer;\n-use middle::subst::{Subst, Substs, VecPerParamSpace};\n+use middle::subst::{Substs, VecPerParamSpace};\n use middle::traits;\n use trans::{_match, adt, asm, base, callee, closure, consts, controlflow};\n use trans::base::*;\n@@ -476,8 +476,8 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n \n         // This can be extended to enums and tuples in the future.\n-        // (&ty::ty_enum(def_id_a, substs_a), &ty::ty_enum(def_id_b, substs_b)) |\n-        (&ty::ty_struct(def_id_a, substs_a), &ty::ty_struct(def_id_b, substs_b)) => {\n+        // (&ty::ty_enum(def_id_a, _), &ty::ty_enum(def_id_b, _)) |\n+        (&ty::ty_struct(def_id_a, _), &ty::ty_struct(def_id_b, _)) => {\n             assert_eq!(def_id_a, def_id_b);\n \n             // The target is already by-ref because it's to be written to.\n@@ -504,35 +504,41 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n \n             let repr_source = adt::represent_type(bcx.ccx(), source.ty);\n+            let src_fields = match &*repr_source {\n+                &adt::Repr::Univariant(ref s, _) => &s.fields,\n+                _ => bcx.sess().span_bug(span,\n+                                         &format!(\"Non univariant struct? (repr_source: {:?})\",\n+                                                  repr_source)),\n+            };\n             let repr_target = adt::represent_type(bcx.ccx(), target.ty);\n-            let fields = ty::lookup_struct_fields(bcx.tcx(), def_id_a);\n+            let target_fields = match &*repr_target {\n+                &adt::Repr::Univariant(ref s, _) => &s.fields,\n+                _ => bcx.sess().span_bug(span,\n+                                         &format!(\"Non univariant struct? (repr_target: {:?})\",\n+                                                  repr_target)),\n+            };\n \n             let coerce_index = match kind {\n                 ty::CustomCoerceUnsized::Struct(i) => i\n             };\n-            assert!(coerce_index < fields.len());\n+            assert!(coerce_index < src_fields.len() && src_fields.len() == target_fields.len());\n \n-            for (i, field) in fields.iter().enumerate() {\n+            let iter = src_fields.iter().zip(target_fields.iter()).enumerate();\n+            for (i, (src_ty, target_ty)) in iter {\n                 let ll_source = adt::trans_field_ptr(bcx, &repr_source, source.val, 0, i);\n                 let ll_target = adt::trans_field_ptr(bcx, &repr_target, target.val, 0, i);\n \n-                let ty = ty::lookup_field_type_unsubstituted(bcx.tcx(),\n-                                                             def_id_a,\n-                                                             field.id);\n-                let field_source = ty.subst(bcx.tcx(), substs_a);\n-                let field_target = ty.subst(bcx.tcx(), substs_b);\n-\n                 // If this is the field we need to coerce, recurse on it.\n                 if i == coerce_index {\n                     coerce_unsized(bcx, span,\n-                                   Datum::new(ll_source, field_source,\n+                                   Datum::new(ll_source, src_ty,\n                                               Rvalue::new(ByRef)),\n-                                   Datum::new(ll_target, field_target,\n+                                   Datum::new(ll_target, target_ty,\n                                               Rvalue::new(ByRef)));\n                 } else {\n                     // Otherwise, simply copy the data from the source.\n-                    assert_eq!(field_source, field_target);\n-                    memcpy_ty(bcx, ll_target, ll_source, field_source);\n+                    assert_eq!(src_ty, target_ty);\n+                    memcpy_ty(bcx, ll_target, ll_source, src_ty);\n                 }\n             }\n         }\n@@ -2013,6 +2019,7 @@ fn float_cast(bcx: Block,\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum cast_kind {\n     cast_pointer,\n+    cast_fat_ptr,\n     cast_integral,\n     cast_float,\n     cast_enum,\n@@ -2027,7 +2034,7 @@ pub fn cast_type_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> cast_kind {\n             if type_is_sized(tcx, mt.ty) {\n                 cast_pointer\n             } else {\n-                cast_other\n+                cast_fat_ptr\n             }\n         }\n         ty::ty_bare_fn(..) => cast_pointer,\n@@ -2103,10 +2110,18 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let llexpr = datum.to_llscalarish(bcx);\n             PtrToInt(bcx, llexpr, ll_t_out)\n         }\n+        (cast_fat_ptr, cast_integral) => {\n+            let data_ptr = Load(bcx, get_dataptr(bcx, datum.val));\n+            PtrToInt(bcx, data_ptr, ll_t_out)\n+        }\n         (cast_pointer, cast_pointer) => {\n             let llexpr = datum.to_llscalarish(bcx);\n             PointerCast(bcx, llexpr, ll_t_out)\n         }\n+        (cast_fat_ptr, cast_pointer) => {\n+            let data_ptr = Load(bcx, get_dataptr(bcx, datum.val));\n+            PointerCast(bcx, data_ptr, ll_t_out)\n+        }\n         (cast_enum, cast_integral) |\n         (cast_enum, cast_float) => {\n             let mut bcx = bcx;"}, {"sha": "264957d36513b9ecd19b8fc485b4e5486d036200", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0", "patch": "@@ -278,18 +278,14 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       t: Ty<'tcx>,\n-                                      v0: ValueRef,\n+                                      struct_data: ValueRef,\n                                       dtor_did: ast::DefId,\n                                       class_did: ast::DefId,\n                                       substs: &subst::Substs<'tcx>)\n                                       -> Block<'blk, 'tcx> {\n+    assert!(type_is_sized(bcx.tcx(), t), \"Precondition: caller must ensure t is sized\");\n+\n     let repr = adt::represent_type(bcx.ccx(), t);\n-    let struct_data = if type_is_sized(bcx.tcx(), t) {\n-        v0\n-    } else {\n-        let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n-        Load(bcx, llval)\n-    };\n     let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &*repr, struct_data));\n     let loaded = load_ty(bcx, drop_flag.val, bcx.tcx().dtor_type());\n     let drop_flag_llty = type_of(bcx.fcx.ccx, bcx.tcx().dtor_type());\n@@ -313,9 +309,8 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let drop_flag_dtor_needed = ICmp(bcx, llvm::IntEQ, loaded, init_val, DebugLoc::None);\n     with_cond(bcx, drop_flag_dtor_needed, |cx| {\n-        trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n+        trans_struct_drop(cx, t, struct_data, dtor_did, class_did, substs)\n     })\n-\n }\n \n pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "39bc547a1a764d40cb42123b2df0c522efead0cf", "filename": "src/librustc_trans/trans/machine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs?ref=03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0", "patch": "@@ -101,7 +101,8 @@ pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> llalign {\n \n pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: usize) -> u64 {\n     unsafe {\n-        return llvm::LLVMOffsetOfElement(cx.td().lltd, struct_ty.to_ref(),\n+        return llvm::LLVMOffsetOfElement(cx.td().lltd,\n+                                         struct_ty.to_ref(),\n                                          element as u32);\n     }\n }"}, {"sha": "bfd159720c25b94a72762ea299600a2bd1576ab9", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0", "patch": "@@ -99,6 +99,7 @@ pub fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n     let t_1_is_bare_fn = ty::type_is_bare_fn(t_1);\n     let t_1_is_float = ty::type_is_floating_point(t_1);\n     let t_1_is_c_enum = ty::type_is_c_like_enum(fcx.tcx(), t_1);\n+    let t1_is_fat_ptr = fcx.type_is_fat_ptr(t_1, span);\n \n     // casts to scalars other than `char` and `bare fn` are trivial\n     let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n@@ -170,18 +171,16 @@ pub fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n                 demand::coerce(fcx, e.span, t_1, &e);\n             }\n         }\n-    } else if fcx.type_is_fat_ptr(t_e, span) != fcx.type_is_fat_ptr(t_1, span) {\n+    } else if t1_is_fat_ptr {\n+        // FIXME This should be allowed where the lefthandside is also a fat\n+        // pointer and is the same kind of fat pointer, i.e., array to array,\n+        // trait object to trait object.\n         fcx.type_error_message(span, |actual| {\n-            format!(\"illegal cast; cast to or from fat pointer: `{}` as `{}` \\\n-                     involving incompatible type.\",\n-                    actual, fcx.infcx().ty_to_string(t_1))\n+            format!(\"cast to fat pointer: `{}` as `{}`\",\n+                    actual,\n+                    fcx.infcx().ty_to_string(t_1))\n         }, t_e, None);\n     } else if !(t_e_is_scalar && t_1_is_trivial) {\n-        /*\n-        If more type combinations should be supported than are\n-        supported here, then file an enhancement issue and\n-        record the issue number in this comment.\n-        */\n         fcx.type_error_message(span, |actual| {\n             format!(\"non-scalar cast: `{}` as `{}`\",\n                     actual,"}, {"sha": "415785a1174b788d45de459758356e9dbfeec544", "filename": "src/test/compile-fail/fat-ptr-cast.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs?ref=03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0", "patch": "@@ -15,17 +15,13 @@ pub trait Trait {}\n fn main() {\n     let a: &[i32] = &[1, 2, 3];\n     let b: Box<[i32]> = Box::new([1, 2, 3]);\n-    let p = a as *const [i32];\n-    let q = a.as_ptr();\n \n     a as usize; //~ ERROR illegal cast\n     b as usize; //~ ERROR illegal cast\n-    p as usize; //~ ERROR illegal cast\n \n-    // #22955\n-    q as *const [i32]; //~ ERROR illegal cast\n+    let a: usize = 42;\n+    a as *const [i32]; //~ ERROR cast to fat pointer: `usize` as `*const [i32]`\n \n-    // #21397\n-    let t: *mut (Trait + 'static) = 0 as *mut _; //~ ERROR illegal cast\n-    let mut fail: *const str = 0 as *const str; //~ ERROR illegal cast\n+    let a: *const u8 = &42;\n+    a as *const [u8]; //~ ERROR cast to fat pointer: `*const u8` as `*const [u8]`\n }"}, {"sha": "1fdc87357143a6cbe55958a6634492dcacf06d8e", "filename": "src/test/compile-fail/issue-22289.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs?ref=03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    0 as &std::any::Any; //~ ERROR illegal cast\n+    0 as &std::any::Any; //~ ERROR cast to fat pointer: `i32` as `&core::any::Any`\n }"}, {"sha": "b7513da99c806eb26372abe6a77c6d1ae1e419f0", "filename": "src/test/run-pass/fat-ptr-cast.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Ftest%2Frun-pass%2Ffat-ptr-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0/src%2Ftest%2Frun-pass%2Ffat-ptr-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffat-ptr-cast.rs?ref=03d4d5f80ed1d9e168869bdb244e4fef67b7d3d0", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core)]\n+\n+use std::mem;\n+use std::raw;\n+\n+trait Foo {\n+    fn foo(&self) {}\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {}\n+\n+fn main() {\n+    // Test we can turn a fat pointer to array back into a thin pointer.\n+    let a: *const [i32] = &[1, 2, 3];\n+    let b = a as *const [i32; 2];\n+    unsafe {\n+        assert!(*b == [1, 2]);\n+    }\n+\n+    // Test conversion to an address (usize).\n+    let a: *const [i32; 3] = &[1, 2, 3];\n+    let b: *const [i32] = a;\n+    assert!(a as usize == b as usize);\n+\n+    // And conversion to a void pointer/address for trait objects too.\n+    let a: *mut Foo = &mut Bar;\n+    let b = a as *mut ();\n+    let c = a as usize;\n+\n+    let d = unsafe {\n+        let r: raw::TraitObject = mem::transmute(a);\n+        r.data\n+    };\n+\n+    assert!(b == d);\n+    assert!(c == d as usize);\n+}"}]}