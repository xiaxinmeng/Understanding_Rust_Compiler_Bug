{"sha": "594aac059e1f8c15a7c856e2778b0c4ff2a240aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NGFhYzA1OWUxZjhjMTVhN2M4NTZlMjc3OGIwYzRmZjJhMjQwYWE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-01T12:53:13Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-01T12:53:13Z"}, "message": "Use correct FileId when expanding macros in expressions", "tree": {"sha": "502484ae326c438febf324beb86078f00fe383b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/502484ae326c438febf324beb86078f00fe383b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/594aac059e1f8c15a7c856e2778b0c4ff2a240aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/594aac059e1f8c15a7c856e2778b0c4ff2a240aa", "html_url": "https://github.com/rust-lang/rust/commit/594aac059e1f8c15a7c856e2778b0c4ff2a240aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/594aac059e1f8c15a7c856e2778b0c4ff2a240aa/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43524a39cd6ac26dc6489f6481220179149c5f08", "url": "https://api.github.com/repos/rust-lang/rust/commits/43524a39cd6ac26dc6489f6481220179149c5f08", "html_url": "https://github.com/rust-lang/rust/commit/43524a39cd6ac26dc6489f6481220179149c5f08"}], "stats": {"total": 77, "additions": 44, "deletions": 33}, "files": [{"sha": "cdadf3ba658374f137bdeee547dd1d21a7fa5b99", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/594aac059e1f8c15a7c856e2778b0c4ff2a240aa/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594aac059e1f8c15a7c856e2778b0c4ff2a240aa/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=594aac059e1f8c15a7c856e2778b0c4ff2a240aa", "patch": "@@ -10,7 +10,7 @@ use ra_syntax::{\n };\n \n use crate::{\n-    Path, Name, HirDatabase, Resolver,DefWithBody, Either,\n+    Path, Name, HirDatabase, Resolver,DefWithBody, Either, HirFileId,\n     name::AsName,\n     ids::{MacroCallId},\n     type_ref::{Mutability, TypeRef},\n@@ -488,15 +488,19 @@ pub(crate) struct ExprCollector<DB> {\n     params: Vec<PatId>,\n     body_expr: Option<ExprId>,\n     resolver: Resolver,\n-    // FIXEME: Its a quick hack,see issue #1196\n-    is_in_macro: bool,\n+    // Expr collector expands macros along the way. original points to the file\n+    // we started with, current points to the current macro expansion. source\n+    // maps don't support macros yet, so we only record info into source map if\n+    // current == original (see #1196)\n+    original_file_id: HirFileId,\n+    current_file_id: HirFileId,\n }\n \n impl<'a, DB> ExprCollector<&'a DB>\n where\n     DB: HirDatabase,\n {\n-    fn new(owner: DefWithBody, resolver: Resolver, db: &'a DB) -> Self {\n+    fn new(owner: DefWithBody, file_id: HirFileId, resolver: Resolver, db: &'a DB) -> Self {\n         ExprCollector {\n             owner,\n             resolver,\n@@ -506,23 +510,23 @@ where\n             source_map: BodySourceMap::default(),\n             params: Vec::new(),\n             body_expr: None,\n-            is_in_macro: false,\n+            original_file_id: file_id,\n+            current_file_id: file_id,\n         }\n     }\n     fn alloc_expr(&mut self, expr: Expr, syntax_ptr: SyntaxNodePtr) -> ExprId {\n         let id = self.exprs.alloc(expr);\n-        if !self.is_in_macro {\n+        if self.current_file_id == self.original_file_id {\n             self.source_map.expr_map.insert(syntax_ptr, id);\n             self.source_map.expr_map_back.insert(id, syntax_ptr);\n         }\n-\n         id\n     }\n \n     fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n         let id = self.pats.alloc(pat);\n \n-        if !self.is_in_macro {\n+        if self.current_file_id == self.original_file_id {\n             self.source_map.pat_map.insert(ptr, id);\n             self.source_map.pat_map_back.insert(id, ptr);\n         }\n@@ -815,12 +819,19 @@ where\n                 // very hacky.FIXME change to use the macro resolution\n                 let path = e.path().and_then(Path::from_ast);\n \n-                if let Some(call_id) = self.resolver.resolve_macro_call(self.db, path, e) {\n+                let ast_id = self\n+                    .db\n+                    .ast_id_map(self.current_file_id)\n+                    .ast_id(e)\n+                    .with_file_id(self.current_file_id);\n+\n+                if let Some(call_id) = self.resolver.resolve_macro_call(self.db, path, ast_id) {\n                     if let Some(expr) = expand_macro_to_expr(self.db, call_id, e.token_tree()) {\n                         log::debug!(\"macro expansion {}\", expr.syntax().debug_dump());\n-                        let old = std::mem::replace(&mut self.is_in_macro, true);\n+                        let old_file_id =\n+                            std::mem::replace(&mut self.current_file_id, call_id.into());\n                         let id = self.collect_expr(&expr);\n-                        self.is_in_macro = old;\n+                        self.current_file_id = old_file_id;\n                         id\n                     } else {\n                         // FIXME: Instead of just dropping the error from expansion\n@@ -1006,12 +1017,24 @@ pub(crate) fn body_with_source_map_query(\n     db: &impl HirDatabase,\n     def: DefWithBody,\n ) -> (Arc<Body>, Arc<BodySourceMap>) {\n-    let mut collector = ExprCollector::new(def, def.resolver(db), db);\n+    let mut collector;\n \n     match def {\n-        DefWithBody::Const(ref c) => collector.collect_const_body(&c.source(db).1),\n-        DefWithBody::Function(ref f) => collector.collect_fn_body(&f.source(db).1),\n-        DefWithBody::Static(ref s) => collector.collect_static_body(&s.source(db).1),\n+        DefWithBody::Const(ref c) => {\n+            let (file_id, src) = c.source(db);\n+            collector = ExprCollector::new(def, file_id, def.resolver(db), db);\n+            collector.collect_const_body(&src)\n+        }\n+        DefWithBody::Function(ref f) => {\n+            let (file_id, src) = f.source(db);\n+            collector = ExprCollector::new(def, file_id, def.resolver(db), db);\n+            collector.collect_fn_body(&src)\n+        }\n+        DefWithBody::Static(ref s) => {\n+            let (file_id, src) = s.source(db);\n+            collector = ExprCollector::new(def, file_id, def.resolver(db), db);\n+            collector.collect_static_body(&src)\n+        }\n     }\n \n     let (body, source_map) = collector.finish();"}, {"sha": "bc9170cdc121028c2ce522e10bf0ad1369fcc1b3", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/594aac059e1f8c15a7c856e2778b0c4ff2a240aa/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594aac059e1f8c15a7c856e2778b0c4ff2a240aa/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=594aac059e1f8c15a7c856e2778b0c4ff2a240aa", "patch": "@@ -10,14 +10,15 @@ use crate::{\n     code_model_api::Crate,\n     MacroCallId,\n     MacroCallLoc,\n+    AstId,\n     db::HirDatabase,\n     name::{Name, KnownName},\n     nameres::{PerNs, CrateDefMap, CrateModuleId},\n     generics::GenericParams,\n     expr::{scope::{ExprScopes, ScopeId}, PatId},\n     impl_block::ImplBlock,\n     path::Path,\n-    Trait\n+    Trait,\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -138,25 +139,12 @@ impl Resolver {\n         &self,\n         db: &impl HirDatabase,\n         path: Option<Path>,\n-        call: &ast::MacroCall,\n+        ast_id: AstId<ast::MacroCall>,\n     ) -> Option<MacroCallId> {\n         let name = path.and_then(|path| path.expand_macro_expr()).unwrap_or_else(Name::missing);\n-        let macro_def_id = self.module().and_then(|(module, _)| module.find_macro(&name));\n-        if let Some(def_id) = macro_def_id {\n-            self.module().and_then(|(module, _)| {\n-                // we do this to get the ast_id for the macro call\n-                // if we used the ast_id from the def_id variable\n-                // it gives us the ast_id of the defenition site\n-                let module = module.mk_module(module.root());\n-                let hir_file_id = module.definition_source(db).0;\n-                let ast_id = db.ast_id_map(hir_file_id).ast_id(call).with_file_id(hir_file_id);\n-                let call_loc = MacroCallLoc { def: *def_id, ast_id }.id(db);\n-\n-                Some(call_loc)\n-            })\n-        } else {\n-            None\n-        }\n+        let def_id = self.module().and_then(|(module, _)| module.find_macro(&name))?;\n+        let call_loc = MacroCallLoc { def: *def_id, ast_id }.id(db);\n+        Some(call_loc)\n     }\n \n     /// Returns the resolved path segments"}]}