{"sha": "49ec909ca7d649d73115f7e0e894b0ffb0740b66", "node_id": "C_kwDOAAsO6NoAKDQ5ZWM5MDljYTdkNjQ5ZDczMTE1ZjdlMGU4OTRiMGZmYjA3NDBiNjY", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-04-26T10:59:45Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-04-29T01:05:20Z"}, "message": "macros: subdiagnostic derive\n\nAdd a new derive, `#[derive(SessionSubdiagnostic)]`, which enables\nderiving structs for labels, notes, helps and suggestions.\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "faf3bd8990a20a1a662701627d3f98d4f047e422", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faf3bd8990a20a1a662701627d3f98d4f047e422"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49ec909ca7d649d73115f7e0e894b0ffb0740b66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49ec909ca7d649d73115f7e0e894b0ffb0740b66", "html_url": "https://github.com/rust-lang/rust/commit/49ec909ca7d649d73115f7e0e894b0ffb0740b66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49ec909ca7d649d73115f7e0e894b0ffb0740b66/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa2abc9d1236b3a74f49f932c02ac9b30f7f36c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa2abc9d1236b3a74f49f932c02ac9b30f7f36c9", "html_url": "https://github.com/rust-lang/rust/commit/aa2abc9d1236b3a74f49f932c02ac9b30f7f36c9"}], "stats": {"total": 1886, "additions": 1735, "deletions": 151}, "files": [{"sha": "6a3235fc7728cad8044806e74ec5a51f0d54a6e3", "filename": "compiler/rustc_error_messages/locales/en-US/typeck.ftl", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftypeck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftypeck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftypeck.ftl?ref=49ec909ca7d649d73115f7e0e894b0ffb0740b66", "patch": "@@ -82,3 +82,11 @@ typeck-value-of-associated-struct-already-specified =\n \n typeck-address-of-temporary-taken = cannot take address of a temporary\n     .label = temporary value\n+\n+typeck-add-return-type-add = try adding a return type\n+\n+typeck-add-return-type-missing-here = a return type might be missing here\n+\n+typeck-expected-default-return-type = expected `()` because of default return type\n+\n+typeck-expected-return-type = expected `{$expected}` because of return type"}, {"sha": "83e6a751394f5a44c9227b8eb1a68ef9f91c6a19", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=49ec909ca7d649d73115f7e0e894b0ffb0740b66", "patch": "@@ -78,6 +78,13 @@ impl<'source> Into<FluentValue<'source>> for DiagnosticArgValue<'source> {\n     }\n }\n \n+/// Trait implemented by error types. This should not be implemented manually. Instead, use\n+/// `#[derive(SessionSubdiagnostic)]` -- see [rustc_macros::SessionSubdiagnostic].\n+pub trait AddSubdiagnostic {\n+    /// Add a subdiagnostic to an existing diagnostic.\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic);\n+}\n+\n #[must_use]\n #[derive(Clone, Debug, Encodable, Decodable)]\n pub struct Diagnostic {\n@@ -768,6 +775,13 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Add a subdiagnostic from a type that implements `SessionSubdiagnostic` - see\n+    /// [rustc_macros::SessionSubdiagnostic].\n+    pub fn subdiagnostic(&mut self, subdiagnostic: impl AddSubdiagnostic) -> &mut Self {\n+        subdiagnostic.add_to_diagnostic(self);\n+        self\n+    }\n+\n     pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n         self.span = sp.into();\n         if let Some(span) = self.span.primary_span() {"}, {"sha": "96b730c2baaffd6885518af9e50c8d20c4e36f14", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=49ec909ca7d649d73115f7e0e894b0ffb0740b66", "patch": "@@ -530,6 +530,11 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         name: impl Into<Cow<'static, str>>,\n         arg: DiagnosticArgValue<'static>,\n     ) -> &mut Self);\n+\n+    forward!(pub fn subdiagnostic(\n+        &mut self,\n+        subdiagnostic: impl crate::AddSubdiagnostic\n+    ) -> &mut Self);\n }\n \n impl<G: EmissionGuarantee> Debug for DiagnosticBuilder<'_, G> {"}, {"sha": "df41fc00714b684c9a16beaaa084b7a55b3c5bd4", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=49ec909ca7d649d73115f7e0e894b0ffb0740b66", "patch": "@@ -370,8 +370,8 @@ impl fmt::Display for ExplicitBug {\n impl error::Error for ExplicitBug {}\n \n pub use diagnostic::{\n-    Diagnostic, DiagnosticArg, DiagnosticArgValue, DiagnosticId, DiagnosticStyledString,\n-    IntoDiagnosticArg, SubDiagnostic,\n+    AddSubdiagnostic, Diagnostic, DiagnosticArg, DiagnosticArgValue, DiagnosticId,\n+    DiagnosticStyledString, IntoDiagnosticArg, SubDiagnostic,\n };\n pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee};\n use std::backtrace::Backtrace;"}, {"sha": "8026288202e1d7d13b66a19e18d74796be87d6f6", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=49ec909ca7d649d73115f7e0e894b0ffb0740b66", "patch": "@@ -1,5 +1,6 @@\n-#![feature(proc_macro_diagnostic)]\n #![feature(allow_internal_unstable)]\n+#![feature(let_else)]\n+#![feature(proc_macro_diagnostic)]\n #![allow(rustc::default_hash_types)]\n #![recursion_limit = \"128\"]\n \n@@ -77,3 +78,18 @@ decl_derive!(\n         suggestion_hidden,\n         suggestion_verbose)] => session_diagnostic::session_diagnostic_derive\n );\n+decl_derive!(\n+    [SessionSubdiagnostic, attributes(\n+        // struct/variant attributes\n+        label,\n+        help,\n+        note,\n+        suggestion,\n+        suggestion_short,\n+        suggestion_hidden,\n+        suggestion_verbose,\n+        // field attributes\n+        skip_arg,\n+        primary_span,\n+        applicability)] => session_diagnostic::session_subdiagnostic_derive\n+);"}, {"sha": "27c94f3e306b8ad364dc3f663b4ca14e657cae5a", "filename": "compiler/rustc_macros/src/session_diagnostic.rs", "status": "modified", "additions": 755, "deletions": 131, "changes": 886, "blob_url": "https://github.com/rust-lang/rust/blob/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs?ref=49ec909ca7d649d73115f7e0e894b0ffb0740b66", "patch": "@@ -1,9 +1,12 @@\n #![deny(unused_must_use)]\n-use proc_macro::Diagnostic;\n+use proc_macro::{Diagnostic, Level, MultiSpan};\n+use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n-use syn::spanned::Spanned;\n-\n use std::collections::{BTreeSet, HashMap};\n+use std::fmt;\n+use std::str::FromStr;\n+use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, Type, Visibility};\n+use synstructure::{BindingInfo, Structure, VariantInfo};\n \n /// Implements `#[derive(SessionDiagnostic)]`, which allows for errors to be specified as a struct,\n /// independent from the actual diagnostics emitting code.\n@@ -51,20 +54,70 @@ use std::collections::{BTreeSet, HashMap};\n ///\n /// See rustc dev guide for more examples on using the `#[derive(SessionDiagnostic)]`:\n /// <https://rustc-dev-guide.rust-lang.org/diagnostics/sessiondiagnostic.html>\n-pub fn session_diagnostic_derive(s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+pub fn session_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n     // Names for the diagnostic we build and the session we build it from.\n     let diag = format_ident!(\"diag\");\n     let sess = format_ident!(\"sess\");\n \n     SessionDiagnosticDerive::new(diag, sess, s).into_tokens()\n }\n \n+/// Implements `#[derive(SessionSubdiagnostic)]`, which allows for labels, notes, helps and\n+/// suggestions to be specified as a structs or enums, independent from the actual diagnostics\n+/// emitting code or diagnostic derives.\n+///\n+/// ```ignore (pseudo-rust)\n+/// #[derive(SessionSubdiagnostic)]\n+/// pub enum ExpectedIdentifierLabel<'tcx> {\n+///     #[label(slug = \"parser-expected-identifier\")]\n+///     WithoutFound {\n+///         #[primary_span]\n+///         span: Span,\n+///     }\n+///     #[label(slug = \"parser-expected-identifier-found\")]\n+///     WithFound {\n+///         #[primary_span]\n+///         span: Span,\n+///         found: String,\n+///     }\n+/// }\n+///\n+/// #[derive(SessionSubdiagnostic)]\n+/// #[suggestion_verbose(slug = \"parser-raw-identifier\")]\n+/// pub struct RawIdentifierSuggestion<'tcx> {\n+///     #[primary_span]\n+///     span: Span,\n+///     #[applicability]\n+///     applicability: Applicability,\n+///     ident: Ident,\n+/// }\n+/// ```\n+///\n+/// ```fluent\n+/// parser-expected-identifier = expected identifier\n+///\n+/// parser-expected-identifier-found = expected identifier, found {$found}\n+///\n+/// parser-raw-identifier = escape `{$ident}` to use it as an identifier\n+/// ```\n+///\n+/// Then, later, to add the subdiagnostic:\n+///\n+/// ```ignore (pseudo-rust)\n+/// diag.subdiagnostic(ExpectedIdentifierLabel::WithoutFound { span });\n+///\n+/// diag.subdiagnostic(RawIdentifierSuggestion { span, applicability, ident });\n+/// ```\n+pub fn session_subdiagnostic_derive(s: Structure<'_>) -> TokenStream {\n+    SessionSubdiagnosticDerive::new(s).into_tokens()\n+}\n+\n /// Checks whether the type name of `ty` matches `name`.\n ///\n /// Given some struct at `a::b::c::Foo`, this will return true for `c::Foo`, `b::c::Foo`, or\n /// `a::b::c::Foo`. This reasonably allows qualified names to be used in the macro.\n-fn type_matches_path(ty: &syn::Type, name: &[&str]) -> bool {\n-    if let syn::Type::Path(ty) = ty {\n+fn type_matches_path(ty: &Type, name: &[&str]) -> bool {\n+    if let Type::Path(ty) = ty {\n         ty.path\n             .segments\n             .iter()\n@@ -79,8 +132,8 @@ fn type_matches_path(ty: &syn::Type, name: &[&str]) -> bool {\n \n /// The central struct for constructing the `as_error` method from an annotated struct.\n struct SessionDiagnosticDerive<'a> {\n-    structure: synstructure::Structure<'a>,\n-    builder: SessionDiagnosticDeriveBuilder<'a>,\n+    structure: Structure<'a>,\n+    builder: SessionDiagnosticDeriveBuilder,\n }\n \n impl std::convert::From<syn::Error> for SessionDiagnosticDeriveError {\n@@ -96,7 +149,7 @@ enum SessionDiagnosticDeriveError {\n }\n \n impl SessionDiagnosticDeriveError {\n-    fn to_compile_error(self) -> proc_macro2::TokenStream {\n+    fn to_compile_error(self) -> TokenStream {\n         match self {\n             SessionDiagnosticDeriveError::SynError(e) => e.to_compile_error(),\n             SessionDiagnosticDeriveError::ErrorHandled => {\n@@ -110,8 +163,8 @@ impl SessionDiagnosticDeriveError {\n     }\n }\n \n-fn span_err(span: impl proc_macro::MultiSpan, msg: &str) -> proc_macro::Diagnostic {\n-    Diagnostic::spanned(span, proc_macro::Level::Error, msg)\n+fn span_err(span: impl MultiSpan, msg: &str) -> Diagnostic {\n+    Diagnostic::spanned(span, Level::Error, msg)\n }\n \n /// For methods that return a `Result<_, SessionDiagnosticDeriveError>`:\n@@ -128,17 +181,17 @@ macro_rules! throw_span_err {\n /// When possible, prefer using `throw_span_err!` over using this function directly. This only\n /// exists as a function to constrain `f` to an `impl FnOnce`.\n fn _throw_span_err(\n-    span: impl proc_macro::MultiSpan,\n+    span: impl MultiSpan,\n     msg: &str,\n-    f: impl FnOnce(proc_macro::Diagnostic) -> proc_macro::Diagnostic,\n+    f: impl FnOnce(Diagnostic) -> Diagnostic,\n ) -> SessionDiagnosticDeriveError {\n     let diag = span_err(span, msg);\n     f(diag).emit();\n     SessionDiagnosticDeriveError::ErrorHandled\n }\n \n impl<'a> SessionDiagnosticDerive<'a> {\n-    fn new(diag: syn::Ident, sess: syn::Ident, structure: synstructure::Structure<'a>) -> Self {\n+    fn new(diag: syn::Ident, sess: syn::Ident, structure: Structure<'a>) -> Self {\n         // Build the mapping of field names to fields. This allows attributes to peek values from\n         // other fields.\n         let mut fields_map = HashMap::new();\n@@ -149,7 +202,7 @@ impl<'a> SessionDiagnosticDerive<'a> {\n         if let syn::Data::Struct(syn::DataStruct { fields, .. }) = &ast.data {\n             for field in fields.iter() {\n                 if let Some(ident) = &field.ident {\n-                    fields_map.insert(ident.to_string(), field);\n+                    fields_map.insert(ident.to_string(), quote! { &self.#ident });\n                 }\n             }\n         }\n@@ -167,7 +220,7 @@ impl<'a> SessionDiagnosticDerive<'a> {\n         }\n     }\n \n-    fn into_tokens(self) -> proc_macro2::TokenStream {\n+    fn into_tokens(self) -> TokenStream {\n         let SessionDiagnosticDerive { mut structure, mut builder } = self;\n \n         let ast = structure.ast();\n@@ -321,9 +374,9 @@ impl<'a> SessionDiagnosticDerive<'a> {\n /// Field information passed to the builder. Deliberately omits attrs to discourage the\n /// `generate_*` methods from walking the attributes themselves.\n struct FieldInfo<'a> {\n-    vis: &'a syn::Visibility,\n-    binding: &'a synstructure::BindingInfo<'a>,\n-    ty: &'a syn::Type,\n+    vis: &'a Visibility,\n+    binding: &'a BindingInfo<'a>,\n+    ty: &'a Type,\n     span: &'a proc_macro2::Span,\n }\n \n@@ -350,15 +403,15 @@ impl SessionDiagnosticKind {\n /// methods for the final generated method. This is a separate struct to `SessionDiagnosticDerive`\n /// only to be able to destructure and split `self.builder` and the `self.structure` up to avoid a\n /// double mut borrow later on.\n-struct SessionDiagnosticDeriveBuilder<'a> {\n+struct SessionDiagnosticDeriveBuilder {\n     /// Name of the session parameter that's passed in to the `as_error` method.\n     sess: syn::Ident,\n     /// The identifier to use for the generated `DiagnosticBuilder` instance.\n     diag: syn::Ident,\n \n     /// Store a map of field name to its corresponding field. This is built on construction of the\n     /// derive builder.\n-    fields: HashMap<String, &'a syn::Field>,\n+    fields: HashMap<String, TokenStream>,\n \n     /// Kind of diagnostic requested via the struct attribute.\n     kind: Option<(SessionDiagnosticKind, proc_macro::Span)>,\n@@ -370,23 +423,21 @@ struct SessionDiagnosticDeriveBuilder<'a> {\n     code: Option<proc_macro::Span>,\n }\n \n-impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n+impl SessionDiagnosticDeriveBuilder {\n     /// Establishes state in the `SessionDiagnosticDeriveBuilder` resulting from the struct\n     /// attributes like `#[error(..)#`, such as the diagnostic kind and slug. Generates\n     /// diagnostic builder calls for setting error code and creating note/help messages.\n     fn generate_structure_code(\n         &mut self,\n-        attr: &syn::Attribute,\n-    ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n+        attr: &Attribute,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n         let span = attr.span().unwrap();\n \n         let name = attr.path.segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n         let meta = attr.parse_meta()?;\n \n-        if matches!(name, \"help\" | \"note\")\n-            && matches!(meta, syn::Meta::Path(_) | syn::Meta::NameValue(_))\n-        {\n+        if matches!(name, \"help\" | \"note\") && matches!(meta, Meta::Path(_) | Meta::NameValue(_)) {\n             let diag = &self.diag;\n             let slug = match &self.slug {\n                 Some((slug, _)) => slug.as_str(),\n@@ -396,16 +447,16 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n                         \"`#[{}{}]` must come after `#[error(..)]` or `#[warn(..)]`\",\n                         name,\n                         match meta {\n-                            syn::Meta::Path(_) => \"\",\n-                            syn::Meta::NameValue(_) => \" = ...\",\n+                            Meta::Path(_) => \"\",\n+                            Meta::NameValue(_) => \" = ...\",\n                             _ => unreachable!(),\n                         }\n                     )\n                 ),\n             };\n             let id = match meta {\n-                syn::Meta::Path(..) => quote! { #name },\n-                syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                Meta::Path(..) => quote! { #name },\n+                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n                     quote! { #s }\n                 }\n                 _ => unreachable!(),\n@@ -418,12 +469,12 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n         }\n \n         let nested = match meta {\n-            syn::Meta::List(syn::MetaList { nested, .. }) => nested,\n-            syn::Meta::Path(..) => throw_span_err!(\n+            Meta::List(MetaList { nested, .. }) => nested,\n+            Meta::Path(..) => throw_span_err!(\n                 span,\n                 &format!(\"`#[{}]` is not a valid `SessionDiagnostic` struct attribute\", name)\n             ),\n-            syn::Meta::NameValue(..) => throw_span_err!(\n+            Meta::NameValue(..) => throw_span_err!(\n                 span,\n                 &format!(\"`#[{} = ...]` is not a valid `SessionDiagnostic` struct attribute\", name)\n             ),\n@@ -458,7 +509,7 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n             match &meta {\n                 // Struct attributes are only allowed to be applied once, and the diagnostic\n                 // changes will be set in the initialisation code.\n-                syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n                     match nested_name.as_str() {\n                         \"slug\" => {\n                             self.set_slug_once(s.value(), s.span().unwrap());\n@@ -478,7 +529,7 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n                         }\n                     }\n                 }\n-                syn::Meta::NameValue(..) => {\n+                Meta::NameValue(..) => {\n                     span_err(\n                         span,\n                         &format!(\n@@ -489,7 +540,7 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n                     .help(\"value must be a string\")\n                     .emit();\n                 }\n-                syn::Meta::Path(..) => {\n+                Meta::Path(..) => {\n                     span_err(\n                         span,\n                         &format!(\n@@ -499,7 +550,7 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n                     )\n                     .emit();\n                 }\n-                syn::Meta::List(..) => {\n+                Meta::List(..) => {\n                     span_err(\n                         span,\n                         &format!(\n@@ -541,7 +592,7 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n         }\n     }\n \n-    fn set_code_once(&mut self, code: String, span: proc_macro::Span) -> proc_macro2::TokenStream {\n+    fn set_code_once(&mut self, code: String, span: proc_macro::Span) -> TokenStream {\n         match self.code {\n             None => {\n                 self.code = Some(span);\n@@ -574,7 +625,7 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n         &mut self,\n         attr: &syn::Attribute,\n         info: FieldInfo<'_>,\n-    ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n         let field_binding = &info.binding.binding;\n         let option_ty = option_inner_ty(&info.ty);\n         let generated_code = self.generate_non_option_field_code(\n@@ -600,9 +651,9 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n \n     fn generate_non_option_field_code(\n         &mut self,\n-        attr: &syn::Attribute,\n+        attr: &Attribute,\n         info: FieldInfo<'_>,\n-    ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n         let diag = &self.diag;\n         let span = attr.span().unwrap();\n         let field_binding = &info.binding.binding;\n@@ -612,30 +663,30 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n \n         let meta = attr.parse_meta()?;\n         match meta {\n-            syn::Meta::Path(_) => match name {\n+            Meta::Path(_) => match name {\n                 \"skip_arg\" => {\n                     // Don't need to do anything - by virtue of the attribute existing, the\n                     // `set_arg` call will not be generated.\n                     Ok(quote! {})\n                 }\n                 \"primary_span\" => {\n-                    self.report_error_if_not_applied_to_span(attr, info)?;\n+                    report_error_if_not_applied_to_span(attr, &info)?;\n                     Ok(quote! {\n                         #diag.set_span(*#field_binding);\n                     })\n                 }\n                 \"label\" | \"note\" | \"help\" => {\n-                    self.report_error_if_not_applied_to_span(attr, info)?;\n+                    report_error_if_not_applied_to_span(attr, &info)?;\n                     Ok(self.add_subdiagnostic(field_binding, name, name))\n                 }\n                 other => throw_span_err!(\n                     span,\n                     &format!(\"`#[{}]` is not a valid `SessionDiagnostic` field attribute\", other)\n                 ),\n             },\n-            syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => match name {\n+            Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => match name {\n                 \"label\" | \"note\" | \"help\" => {\n-                    self.report_error_if_not_applied_to_span(attr, info)?;\n+                    report_error_if_not_applied_to_span(attr, &info)?;\n                     Ok(self.add_subdiagnostic(field_binding, name, &s.value()))\n                 }\n                 other => throw_span_err!(\n@@ -646,12 +697,12 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n                     )\n                 ),\n             },\n-            syn::Meta::NameValue(_) => throw_span_err!(\n+            Meta::NameValue(_) => throw_span_err!(\n                 span,\n                 &format!(\"`#[{} = ...]` is not a valid `SessionDiagnostic` field attribute\", name),\n                 |diag| diag.help(\"value must be a string\")\n             ),\n-            syn::Meta::List(syn::MetaList { path, nested, .. }) => {\n+            Meta::List(MetaList { path, nested, .. }) => {\n                 let name = path.segments.last().unwrap().ident.to_string();\n                 let name = name.as_ref();\n \n@@ -689,40 +740,40 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n                     let nested_name = nested_name.as_str();\n \n                     match meta {\n-                        syn::Meta::NameValue(syn::MetaNameValue {\n-                            lit: syn::Lit::Str(s), ..\n-                        }) => match nested_name {\n-                            \"message\" => {\n-                                msg = Some(s.value());\n-                            }\n-                            \"code\" => {\n-                                let formatted_str = self.build_format(&s.value(), s.span());\n-                                code = Some(formatted_str);\n+                        Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                            match nested_name {\n+                                \"message\" => {\n+                                    msg = Some(s.value());\n+                                }\n+                                \"code\" => {\n+                                    let formatted_str = self.build_format(&s.value(), s.span());\n+                                    code = Some(formatted_str);\n+                                }\n+                                other => throw_span_err!(\n+                                    span,\n+                                    &format!(\n+                                        \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` field attribute\",\n+                                        name, other\n+                                    )\n+                                ),\n                             }\n-                            other => throw_span_err!(\n-                                span,\n-                                &format!(\n-                                    \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` field attribute\",\n-                                    name, other\n-                                )\n-                            ),\n-                        },\n-                        syn::Meta::NameValue(..) => throw_span_err!(\n+                        }\n+                        Meta::NameValue(..) => throw_span_err!(\n                             span,\n                             &format!(\n                                 \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` struct attribute\",\n                                 name, nested_name\n                             ),\n                             |diag| diag.help(\"value must be a string\")\n                         ),\n-                        syn::Meta::Path(..) => throw_span_err!(\n+                        Meta::Path(..) => throw_span_err!(\n                             span,\n                             &format!(\n                                 \"`#[{}({})]` is not a valid `SessionDiagnostic` struct attribute\",\n                                 name, nested_name\n                             )\n                         ),\n-                        syn::Meta::List(..) => throw_span_err!(\n+                        Meta::List(..) => throw_span_err!(\n                             span,\n                             &format!(\n                                 \"`#[{}({}(...))]` is not a valid `SessionDiagnostic` struct attribute\",\n@@ -748,42 +799,14 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n         }\n     }\n \n-    /// Reports an error if the field's type is not `Span`.\n-    fn report_error_if_not_applied_to_span(\n-        &self,\n-        attr: &syn::Attribute,\n-        info: FieldInfo<'_>,\n-    ) -> Result<(), SessionDiagnosticDeriveError> {\n-        if !type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n-            let name = attr.path.segments.last().unwrap().ident.to_string();\n-            let name = name.as_str();\n-            let meta = attr.parse_meta()?;\n-\n-            throw_span_err!(\n-                attr.span().unwrap(),\n-                &format!(\n-                    \"the `#[{}{}]` attribute can only be applied to fields of type `Span`\",\n-                    name,\n-                    match meta {\n-                        syn::Meta::Path(_) => \"\",\n-                        syn::Meta::NameValue(_) => \" = ...\",\n-                        syn::Meta::List(_) => \"(...)\",\n-                    }\n-                )\n-            );\n-        }\n-\n-        Ok(())\n-    }\n-\n     /// Adds a subdiagnostic by generating a `diag.span_$kind` call with the current slug and\n     /// `fluent_attr_identifier`.\n     fn add_subdiagnostic(\n         &self,\n         field_binding: &proc_macro2::Ident,\n         kind: &str,\n         fluent_attr_identifier: &str,\n-    ) -> proc_macro2::TokenStream {\n+    ) -> TokenStream {\n         let diag = &self.diag;\n \n         let slug =\n@@ -800,16 +823,15 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n     fn span_and_applicability_of_ty(\n         &self,\n         info: FieldInfo<'_>,\n-    ) -> Result<(proc_macro2::TokenStream, proc_macro2::TokenStream), SessionDiagnosticDeriveError>\n-    {\n+    ) -> Result<(TokenStream, TokenStream), SessionDiagnosticDeriveError> {\n         match &info.ty {\n             // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n-            ty @ syn::Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n+            ty @ Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n                 let binding = &info.binding.binding;\n                 Ok((quote!(*#binding), quote!(rustc_errors::Applicability::Unspecified)))\n             }\n             // If `ty` is `(Span, Applicability)` then return tokens accessing those.\n-            syn::Type::Tuple(tup) => {\n+            Type::Tuple(tup) => {\n                 let mut span_idx = None;\n                 let mut applicability_idx = None;\n \n@@ -855,43 +877,53 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n             }),\n         }\n     }\n+}\n+\n+trait HasFieldMap {\n+    fn get_field_binding(&self, field: &String) -> Option<&TokenStream>;\n \n     /// In the strings in the attributes supplied to this macro, we want callers to be able to\n     /// reference fields in the format string. For example:\n     ///\n     /// ```ignore (not-usage-example)\n-    /// struct Point {\n-    ///     #[error = \"Expected a point greater than ({x}, {y})\"]\n-    ///     x: i32,\n-    ///     y: i32,\n+    /// /// Suggest `==` when users wrote `===`.\n+    /// #[suggestion(slug = \"parser-not-javascript-eq\", code = \"{lhs} == {rhs}\")]\n+    /// struct NotJavaScriptEq {\n+    ///     #[primary_span]\n+    ///     span: Span,\n+    ///     lhs: Ident,\n+    ///     rhs: Ident,\n     /// }\n     /// ```\n     ///\n-    /// We want to automatically pick up that `{x}` refers `self.x` and `{y}` refers to `self.y`,\n-    /// then generate this call to `format!`:\n+    /// We want to automatically pick up that `{lhs}` refers `self.lhs` and `{rhs}` refers to\n+    /// `self.rhs`, then generate this call to `format!`:\n     ///\n     /// ```ignore (not-usage-example)\n-    /// format!(\"Expected a point greater than ({x}, {y})\", x = self.x, y = self.y)\n+    /// format!(\"{lhs} == {rhs}\", lhs = self.lhs, rhs = self.rhs)\n     /// ```\n     ///\n     /// This function builds the entire call to `format!`.\n-    fn build_format(&self, input: &str, span: proc_macro2::Span) -> proc_macro2::TokenStream {\n+    fn build_format(&self, input: &str, span: proc_macro2::Span) -> TokenStream {\n         // This set is used later to generate the final format string. To keep builds reproducible,\n-        // the iteration order needs to be deterministic, hence why we use a BTreeSet here instead\n-        // of a HashSet.\n+        // the iteration order needs to be deterministic, hence why we use a `BTreeSet` here\n+        // instead of a `HashSet`.\n         let mut referenced_fields: BTreeSet<String> = BTreeSet::new();\n \n         // At this point, we can start parsing the format string.\n         let mut it = input.chars().peekable();\n+\n         // Once the start of a format string has been found, process the format string and spit out\n-        // the referenced fields. Leaves `it` sitting on the closing brace of the format string, so the\n-        // next call to `it.next()` retrieves the next character.\n+        // the referenced fields. Leaves `it` sitting on the closing brace of the format string, so\n+        // the next call to `it.next()` retrieves the next character.\n         while let Some(c) = it.next() {\n             if c == '{' && *it.peek().unwrap_or(&'\\0') != '{' {\n                 let mut eat_argument = || -> Option<String> {\n                     let mut result = String::new();\n-                    // Format specifiers look like\n-                    // format   := '{' [ argument ] [ ':' format_spec ] '}' .\n+                    // Format specifiers look like:\n+                    //\n+                    //   format   := '{' [ argument ] [ ':' format_spec ] '}' .\n+                    //\n                     // Therefore, we only need to eat until ':' or '}' to find the argument.\n                     while let Some(c) = it.next() {\n                         result.push(c);\n@@ -916,25 +948,25 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n                 }\n             }\n         }\n+\n         // At this point, `referenced_fields` contains a set of the unique fields that were\n         // referenced in the format string. Generate the corresponding \"x = self.x\" format\n         // string parameters:\n         let args = referenced_fields.into_iter().map(|field: String| {\n             let field_ident = format_ident!(\"{}\", field);\n-            let value = if self.fields.contains_key(&field) {\n-                quote! {\n-                    &self.#field_ident\n-                }\n-            } else {\n+            let value = match self.get_field_binding(&field) {\n+                Some(value) => value.clone(),\n                 // This field doesn't exist. Emit a diagnostic.\n-                Diagnostic::spanned(\n-                    span.unwrap(),\n-                    proc_macro::Level::Error,\n-                    format!(\"`{}` doesn't refer to a field on this type\", field),\n-                )\n-                .emit();\n-                quote! {\n-                    \"{#field}\"\n+                None => {\n+                    Diagnostic::spanned(\n+                        span.unwrap(),\n+                        Level::Error,\n+                        format!(\"`{}` doesn't refer to a field on this type\", field),\n+                    )\n+                    .emit();\n+                    quote! {\n+                        \"{#field}\"\n+                    }\n                 }\n             };\n             quote! {\n@@ -947,10 +979,67 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n     }\n }\n \n+impl HasFieldMap for SessionDiagnosticDeriveBuilder {\n+    fn get_field_binding(&self, field: &String) -> Option<&TokenStream> {\n+        self.fields.get(field)\n+    }\n+}\n+\n+/// Reports an error if the field's type is not `Applicability`.\n+fn report_error_if_not_applied_to_ty(\n+    attr: &Attribute,\n+    info: &FieldInfo<'_>,\n+    path: &[&str],\n+    ty_name: &str,\n+) -> Result<(), SessionDiagnosticDeriveError> {\n+    if !type_matches_path(&info.ty, path) {\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_str();\n+        let meta = attr.parse_meta()?;\n+\n+        throw_span_err!(\n+            attr.span().unwrap(),\n+            &format!(\n+                \"the `#[{}{}]` attribute can only be applied to fields of type `{}`\",\n+                name,\n+                match meta {\n+                    Meta::Path(_) => \"\",\n+                    Meta::NameValue(_) => \" = ...\",\n+                    Meta::List(_) => \"(...)\",\n+                },\n+                ty_name\n+            )\n+        );\n+    }\n+\n+    Ok(())\n+}\n+\n+/// Reports an error if the field's type is not `Applicability`.\n+fn report_error_if_not_applied_to_applicability(\n+    attr: &Attribute,\n+    info: &FieldInfo<'_>,\n+) -> Result<(), SessionDiagnosticDeriveError> {\n+    report_error_if_not_applied_to_ty(\n+        attr,\n+        info,\n+        &[\"rustc_errors\", \"Applicability\"],\n+        \"Applicability\",\n+    )\n+}\n+\n+/// Reports an error if the field's type is not `Span`.\n+fn report_error_if_not_applied_to_span(\n+    attr: &Attribute,\n+    info: &FieldInfo<'_>,\n+) -> Result<(), SessionDiagnosticDeriveError> {\n+    report_error_if_not_applied_to_ty(attr, info, &[\"rustc_span\", \"Span\"], \"Span\")\n+}\n+\n /// If `ty` is an Option, returns `Some(inner type)`, otherwise returns `None`.\n-fn option_inner_ty(ty: &syn::Type) -> Option<&syn::Type> {\n+fn option_inner_ty(ty: &Type) -> Option<&Type> {\n     if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n-        if let syn::Type::Path(ty_path) = ty {\n+        if let Type::Path(ty_path) = ty {\n             let path = &ty_path.path;\n             let ty = path.segments.iter().last().unwrap();\n             if let syn::PathArguments::AngleBracketed(bracketed) = &ty.arguments {\n@@ -964,3 +1053,538 @@ fn option_inner_ty(ty: &syn::Type) -> Option<&syn::Type> {\n     }\n     None\n }\n+\n+trait SetOnce<T> {\n+    fn set_once(&mut self, value: T);\n+}\n+\n+impl<T> SetOnce<(T, proc_macro::Span)> for Option<(T, proc_macro::Span)> {\n+    fn set_once(&mut self, (value, span): (T, proc_macro::Span)) {\n+        match self {\n+            None => {\n+                *self = Some((value, span));\n+            }\n+            Some((_, prev_span)) => {\n+                span_err(span, \"specified multiple times\")\n+                    .span_note(*prev_span, \"previously specified here\")\n+                    .emit();\n+            }\n+        }\n+    }\n+}\n+\n+enum Applicability {\n+    MachineApplicable,\n+    MaybeIncorrect,\n+    HasPlaceholders,\n+    Unspecified,\n+}\n+\n+impl FromStr for Applicability {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"machine-applicable\" => Ok(Applicability::MachineApplicable),\n+            \"maybe-incorrect\" => Ok(Applicability::MaybeIncorrect),\n+            \"has-placeholders\" => Ok(Applicability::HasPlaceholders),\n+            \"unspecified\" => Ok(Applicability::Unspecified),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+impl quote::ToTokens for Applicability {\n+    fn to_tokens(&self, tokens: &mut TokenStream) {\n+        tokens.extend(match self {\n+            Applicability::MachineApplicable => {\n+                quote! { rustc_errors::Applicability::MachineApplicable }\n+            }\n+            Applicability::MaybeIncorrect => {\n+                quote! { rustc_errors::Applicability::MaybeIncorrect }\n+            }\n+            Applicability::HasPlaceholders => {\n+                quote! { rustc_errors::Applicability::HasPlaceholders }\n+            }\n+            Applicability::Unspecified => {\n+                quote! { rustc_errors::Applicability::Unspecified }\n+            }\n+        });\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum SubdiagnosticSuggestionKind {\n+    /// `#[suggestion]`\n+    Normal,\n+    /// `#[suggestion_short]`\n+    Short,\n+    /// `#[suggestion_hidden]`\n+    Hidden,\n+    /// `#[suggestion_verbose]`\n+    Verbose,\n+}\n+\n+#[derive(Clone, Copy)]\n+enum SubdiagnosticKind {\n+    /// `#[label]` or `#[label(...)]`\n+    Label,\n+    /// `#[note]` or  `#[note(...)]`\n+    Note,\n+    /// `#[help]` or `#[help(...)]`\n+    Help,\n+    /// `#[suggestion{,_short,_hidden,_verbose}]`\n+    Suggestion(SubdiagnosticSuggestionKind),\n+}\n+\n+impl FromStr for SubdiagnosticKind {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"label\" => Ok(SubdiagnosticKind::Label),\n+            \"note\" => Ok(SubdiagnosticKind::Note),\n+            \"help\" => Ok(SubdiagnosticKind::Help),\n+            \"suggestion\" => Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal)),\n+            \"suggestion_short\" => {\n+                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short))\n+            }\n+            \"suggestion_hidden\" => {\n+                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Hidden))\n+            }\n+            \"suggestion_verbose\" => {\n+                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Verbose))\n+            }\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+impl quote::IdentFragment for SubdiagnosticKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            SubdiagnosticKind::Label => write!(f, \"label\"),\n+            SubdiagnosticKind::Note => write!(f, \"note\"),\n+            SubdiagnosticKind::Help => write!(f, \"help\"),\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal) => {\n+                write!(f, \"suggestion\")\n+            }\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short) => {\n+                write!(f, \"suggestion_short\")\n+            }\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Hidden) => {\n+                write!(f, \"suggestion_hidden\")\n+            }\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Verbose) => {\n+                write!(f, \"suggestion_verbose\")\n+            }\n+        }\n+    }\n+\n+    fn span(&self) -> Option<proc_macro2::Span> {\n+        None\n+    }\n+}\n+\n+struct SessionSubdiagnosticDerive<'a> {\n+    structure: Structure<'a>,\n+    diag: syn::Ident,\n+}\n+\n+struct SessionSubdiagnosticDeriveBuilder<'a> {\n+    /// The identifier to use for the generated `DiagnosticBuilder` instance.\n+    diag: &'a syn::Ident,\n+\n+    /// Info for the current variant (or the type if not an enum).\n+    variant: &'a VariantInfo<'a>,\n+    /// Span for the entire type.\n+    span: proc_macro::Span,\n+\n+    /// Store a map of field name to its corresponding field. This is built on construction of the\n+    /// derive builder.\n+    fields: HashMap<String, TokenStream>,\n+\n+    /// Subdiagnostic kind of the type/variant.\n+    kind: Option<(SubdiagnosticKind, proc_macro::Span)>,\n+\n+    /// Slug of the subdiagnostic - corresponds to the Fluent identifier for the message - from the\n+    /// `#[kind(slug = \"...\")]` attribute on the type or variant.\n+    slug: Option<(String, proc_macro::Span)>,\n+    /// If a suggestion, the code to suggest as a replacement - from the `#[kind(code = \"...\")]`\n+    /// attribute on the type or variant.\n+    code: Option<(proc_macro2::TokenStream, proc_macro::Span)>,\n+\n+    /// Identifier for the binding to the `#[primary_span]` field.\n+    span_field: Option<(proc_macro2::Ident, proc_macro::Span)>,\n+    /// If a suggestion, the identifier for the binding to the `#[applicability]` field or a\n+    /// `rustc_errors::Applicability::*` variant directly.\n+    applicability: Option<(proc_macro2::TokenStream, proc_macro::Span)>,\n+}\n+\n+impl<'a> HasFieldMap for SessionSubdiagnosticDeriveBuilder<'a> {\n+    fn get_field_binding(&self, field: &String) -> Option<&TokenStream> {\n+        self.fields.get(field)\n+    }\n+}\n+\n+impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n+    fn identify_kind(&mut self) -> Result<(), SessionDiagnosticDeriveError> {\n+        for attr in self.variant.ast().attrs {\n+            let span = attr.span().unwrap();\n+\n+            let name = attr.path.segments.last().unwrap().ident.to_string();\n+            let name = name.as_str();\n+\n+            let meta = attr.parse_meta()?;\n+            let kind = match meta {\n+                Meta::Path(_) => throw_span_err!(\n+                    span,\n+                    &format!(\"`#[{}]` is not a valid `SessionSubdiagnostic` attribute\", name)\n+                ),\n+                Meta::NameValue(_) => throw_span_err!(\n+                    span,\n+                    &format!(\"`#[{} = ...]` is not a valid `SessionSubdiagnostic` attribute\", name)\n+                ),\n+                Meta::List(MetaList { nested, .. }) => {\n+                    for attr in nested {\n+                        let meta = match attr {\n+                            syn::NestedMeta::Meta(meta) => meta,\n+                            syn::NestedMeta::Lit(_) => throw_span_err!(\n+                                span,\n+                                &format!(\n+                                    \"`#[{}(\\\"...\\\")]` is not a valid `SessionSubdiagnostic` attribute\",\n+                                    name\n+                                )\n+                            ),\n+                        };\n+\n+                        let span = meta.span().unwrap();\n+                        let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+                        let nested_name = nested_name.as_str();\n+\n+                        match meta {\n+                            Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                                match nested_name {\n+                                    \"code\" => {\n+                                        let formatted_str = self.build_format(&s.value(), s.span());\n+                                        self.code.set_once((formatted_str, span));\n+                                    }\n+                                    \"slug\" => self.slug.set_once((s.value(), span)),\n+                                    \"applicability\" => {\n+                                        let value = match Applicability::from_str(&s.value()) {\n+                                            Ok(v) => v,\n+                                            Err(()) => {\n+                                                span_err(span, \"invalid applicability\").emit();\n+                                                Applicability::Unspecified\n+                                            }\n+                                        };\n+                                        self.applicability.set_once((quote! { #value }, span));\n+                                    }\n+                                    other => throw_span_err!(\n+                                        span,\n+                                        &format!(\n+                                            \"`#[{}({} = ...)]` is not a valid `SessionSubdiagnostic` attribute\",\n+                                            name, other\n+                                        )\n+                                    ),\n+                                }\n+                            }\n+                            Meta::NameValue(..) => throw_span_err!(\n+                                span,\n+                                &format!(\n+                                    \"`#[{}({} = ...)]` is not a valid `SessionSubdiagnostic` attribute\",\n+                                    name, nested_name\n+                                ),\n+                                |diag| diag.help(\"value must be a string\")\n+                            ),\n+                            Meta::Path(..) => throw_span_err!(\n+                                span,\n+                                &format!(\n+                                    \"`#[{}({})]` is not a valid `SessionSubdiagnostic` attribute\",\n+                                    name, nested_name\n+                                )\n+                            ),\n+                            Meta::List(..) => throw_span_err!(\n+                                span,\n+                                &format!(\n+                                    \"`#[{}({}(...))]` is not a valid `SessionSubdiagnostic` attribute\",\n+                                    name, nested_name\n+                                )\n+                            ),\n+                        }\n+                    }\n+\n+                    let Ok(kind) = SubdiagnosticKind::from_str(name) else {\n+                        throw_span_err!(\n+                            span,\n+                            &format!(\n+                                \"`#[{}(...)]` is not a valid `SessionSubdiagnostic` attribute\",\n+                                name\n+                            )\n+                        );\n+                    };\n+                    kind\n+                }\n+            };\n+\n+            if matches!(\n+                kind,\n+                SubdiagnosticKind::Label | SubdiagnosticKind::Help | SubdiagnosticKind::Note\n+            ) && self.code.is_some()\n+            {\n+                throw_span_err!(\n+                    span,\n+                    &format!(\"`code` is not a valid nested attribute of a `{}` attribute\", name)\n+                );\n+            }\n+\n+            if self.slug.is_none() {\n+                throw_span_err!(\n+                    span,\n+                    &format!(\"`slug` must be set in a `#[{}(...)]` attribute\", name)\n+                );\n+            }\n+\n+            self.kind.set_once((kind, span));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn generate_field_code(\n+        &mut self,\n+        binding: &BindingInfo<'_>,\n+        is_suggestion: bool,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        let ast = binding.ast();\n+\n+        let option_ty = option_inner_ty(&ast.ty);\n+        let info = FieldInfo {\n+            vis: &ast.vis,\n+            binding: binding,\n+            ty: option_ty.unwrap_or(&ast.ty),\n+            span: &ast.span(),\n+        };\n+\n+        for attr in &ast.attrs {\n+            let name = attr.path.segments.last().unwrap().ident.to_string();\n+            let name = name.as_str();\n+            let span = attr.span().unwrap();\n+\n+            let meta = attr.parse_meta()?;\n+            match meta {\n+                Meta::Path(_) => match name {\n+                    \"primary_span\" => {\n+                        report_error_if_not_applied_to_span(attr, &info)?;\n+                        self.span_field.set_once((binding.binding.clone(), span));\n+                        return Ok(quote! {});\n+                    }\n+                    \"applicability\" if is_suggestion => {\n+                        report_error_if_not_applied_to_applicability(attr, &info)?;\n+                        let binding = binding.binding.clone();\n+                        self.applicability.set_once((quote! { #binding }, span));\n+                        return Ok(quote! {});\n+                    }\n+                    \"applicability\" => {\n+                        span_err(span, \"`#[applicability]` is only valid on suggestions\").emit();\n+                        return Ok(quote! {});\n+                    }\n+                    \"skip_arg\" => {\n+                        return Ok(quote! {});\n+                    }\n+                    other => span_err(\n+                        span,\n+                        &format!(\n+                            \"`#[{}]` is not a valid `SessionSubdiagnostic` field attribute\",\n+                            other\n+                        ),\n+                    )\n+                    .emit(),\n+                },\n+                Meta::NameValue(_) => span_err(\n+                    span,\n+                    &format!(\n+                        \"`#[{} = ...]` is not a valid `SessionSubdiagnostic` field attribute\",\n+                        name\n+                    ),\n+                )\n+                .emit(),\n+                Meta::List(_) => span_err(\n+                    span,\n+                    &format!(\n+                        \"`#[{}(...)]` is not a valid `SessionSubdiagnostic` field attribute\",\n+                        name\n+                    ),\n+                )\n+                .emit(),\n+            }\n+        }\n+\n+        let ident = ast.ident.as_ref().unwrap();\n+\n+        let diag = &self.diag;\n+        let generated = quote! {\n+            #diag.set_arg(\n+                stringify!(#ident),\n+                #binding.into_diagnostic_arg()\n+            );\n+        };\n+\n+        if option_ty.is_none() {\n+            Ok(quote! { #generated })\n+        } else {\n+            Ok(quote! {\n+                if let Some(#binding) = #binding {\n+                    #generated\n+                }\n+            })\n+        }\n+    }\n+\n+    fn into_tokens(&mut self) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        self.identify_kind()?;\n+        let Some(kind) = self.kind.map(|(kind, _)| kind) else {\n+            throw_span_err!(\n+                self.variant.ast().ident.span().unwrap(),\n+                \"subdiagnostic kind not specified\"\n+            );\n+        };\n+\n+        let is_suggestion = matches!(kind, SubdiagnosticKind::Suggestion(_));\n+\n+        let mut args = TokenStream::new();\n+        for binding in self.variant.bindings() {\n+            let arg = self\n+                .generate_field_code(binding, is_suggestion)\n+                .unwrap_or_else(|v| v.to_compile_error());\n+            args.extend(arg);\n+        }\n+\n+        // Missing slug errors will already have been reported.\n+        let slug = self.slug.as_ref().map(|(slug, _)| &**slug).unwrap_or(\"missing-slug\");\n+        let code = match self.code.as_ref() {\n+            Some((code, _)) => Some(quote! { #code }),\n+            None if is_suggestion => {\n+                span_err(self.span, \"suggestion without `code = \\\"...\\\"`\").emit();\n+                Some(quote! { /* macro error */ \"...\" })\n+            }\n+            None => None,\n+        };\n+\n+        let span_field = self.span_field.as_ref().map(|(span, _)| span);\n+        let applicability = match self.applicability.clone() {\n+            Some((applicability, _)) => Some(applicability),\n+            None if is_suggestion => {\n+                span_err(self.span, \"suggestion without `applicability`\").emit();\n+                Some(quote! { rustc_errors::Applicability::Unspecified })\n+            }\n+            None => None,\n+        };\n+\n+        let diag = &self.diag;\n+        let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n+        let message = quote! { rustc_errors::DiagnosticMessage::fluent(#slug) };\n+        let call = if matches!(kind, SubdiagnosticKind::Suggestion(..)) {\n+            if let Some(span) = span_field {\n+                quote! { #diag.#name(#span, #message, #code, #applicability); }\n+            } else {\n+                span_err(self.span, \"suggestion without `#[primary_span]` field\").emit();\n+                quote! { unreachable!(); }\n+            }\n+        } else if matches!(kind, SubdiagnosticKind::Label) {\n+            if let Some(span) = span_field {\n+                quote! { #diag.#name(#span, #message); }\n+            } else {\n+                span_err(self.span, \"label without `#[primary_span]` field\").emit();\n+                quote! { unreachable!(); }\n+            }\n+        } else {\n+            if let Some(span) = span_field {\n+                quote! { #diag.#name(#span, #message); }\n+            } else {\n+                quote! { #diag.#name(#message); }\n+            }\n+        };\n+\n+        Ok(quote! {\n+            #call\n+            #args\n+        })\n+    }\n+}\n+\n+impl<'a> SessionSubdiagnosticDerive<'a> {\n+    fn new(structure: Structure<'a>) -> Self {\n+        let diag = format_ident!(\"diag\");\n+        Self { structure, diag }\n+    }\n+\n+    fn into_tokens(self) -> TokenStream {\n+        let SessionSubdiagnosticDerive { mut structure, diag } = self;\n+        let implementation = {\n+            let ast = structure.ast();\n+            let span = ast.span().unwrap();\n+            match ast.data {\n+                syn::Data::Struct(..) | syn::Data::Enum(..) => (),\n+                syn::Data::Union(..) => {\n+                    span_err(\n+                        span,\n+                        \"`#[derive(SessionSubdiagnostic)]` can only be used on structs and enums\",\n+                    );\n+                }\n+            }\n+\n+            if matches!(ast.data, syn::Data::Enum(..)) {\n+                for attr in &ast.attrs {\n+                    span_err(\n+                        attr.span().unwrap(),\n+                        \"unsupported type attribute for subdiagnostic enum\",\n+                    )\n+                    .emit();\n+                }\n+            }\n+\n+            structure.bind_with(|_| synstructure::BindStyle::Move);\n+            let variants_ = structure.each_variant(|variant| {\n+                // Build the mapping of field names to fields. This allows attributes to peek\n+                // values from other fields.\n+                let mut fields_map = HashMap::new();\n+                for binding in variant.bindings() {\n+                    let field = binding.ast();\n+                    if let Some(ident) = &field.ident {\n+                        fields_map.insert(ident.to_string(), quote! { #binding });\n+                    }\n+                }\n+\n+                let mut builder = SessionSubdiagnosticDeriveBuilder {\n+                    diag: &diag,\n+                    variant,\n+                    span,\n+                    fields: fields_map,\n+                    kind: None,\n+                    slug: None,\n+                    code: None,\n+                    span_field: None,\n+                    applicability: None,\n+                };\n+                builder.into_tokens().unwrap_or_else(|v| v.to_compile_error())\n+            });\n+\n+            quote! {\n+                match self {\n+                    #variants_\n+                }\n+            }\n+        };\n+\n+        let ret = structure.gen_impl(quote! {\n+            gen impl rustc_errors::AddSubdiagnostic for @Self {\n+                fn add_to_diagnostic(self, #diag: &mut rustc_errors::Diagnostic) {\n+                    use rustc_errors::{Applicability, IntoDiagnosticArg};\n+                    #implementation\n+                }\n+            }\n+        });\n+        ret\n+    }\n+}"}, {"sha": "a92c288cac93ddcfcad38fb8edad85e0ca5e5bdc", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=49ec909ca7d649d73115f7e0e894b0ffb0740b66", "patch": "@@ -1,5 +1,6 @@\n use super::FnCtxt;\n use crate::astconv::AstConv;\n+use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n \n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n@@ -527,28 +528,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // haven't set a return type at all (and aren't `fn main()` or an impl).\n         match (&fn_decl.output, found.is_suggestable(self.tcx), can_suggest, expected.is_unit()) {\n             (&hir::FnRetTy::DefaultReturn(span), true, true, true) => {\n-                err.span_suggestion(\n-                    span,\n-                    \"try adding a return type\",\n-                    format!(\"-> {} \", found),\n-                    Applicability::MachineApplicable,\n-                );\n+                err.subdiagnostic(AddReturnTypeSuggestion::Add { span, found });\n                 true\n             }\n             (&hir::FnRetTy::DefaultReturn(span), false, true, true) => {\n                 // FIXME: if `found` could be `impl Iterator` or `impl Fn*`, we should suggest\n                 // that.\n-                err.span_suggestion(\n-                    span,\n-                    \"a return type might be missing here\",\n-                    \"-> _ \".to_string(),\n-                    Applicability::HasPlaceholders,\n-                );\n+                err.subdiagnostic(AddReturnTypeSuggestion::MissingHere { span });\n                 true\n             }\n             (&hir::FnRetTy::DefaultReturn(span), _, false, true) => {\n                 // `fn main()` must return `()`, do not suggest changing return type\n-                err.span_label(span, \"expected `()` because of default return type\");\n+                err.subdiagnostic(ExpectedReturnTypeLabel::Unit { span });\n                 true\n             }\n             // expectation was caused by something else, not the default return\n@@ -557,16 +548,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Only point to return type if the expected type is the return type, as if they\n                 // are not, the expectation must have been caused by something else.\n                 debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.kind);\n-                let sp = ty.span;\n+                let span = ty.span;\n                 let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n                 debug!(\"suggest_missing_return_type: return type {:?}\", ty);\n                 debug!(\"suggest_missing_return_type: expected type {:?}\", ty);\n                 let bound_vars = self.tcx.late_bound_vars(fn_id);\n                 let ty = Binder::bind_with_vars(ty, bound_vars);\n-                let ty = self.normalize_associated_types_in(sp, ty);\n+                let ty = self.normalize_associated_types_in(span, ty);\n                 let ty = self.tcx.erase_late_bound_regions(ty);\n                 if self.can_coerce(expected, ty) {\n-                    err.span_label(sp, format!(\"expected `{}` because of return type\", expected));\n+                    err.subdiagnostic(ExpectedReturnTypeLabel::Other { span, expected });\n                     self.try_suggest_return_impl_trait(err, expected, ty, fn_id);\n                     return true;\n                 }"}, {"sha": "3d2f93537e4e8d5d9eccd66aefcb68dec2f76514", "filename": "compiler/rustc_typeck/src/errors.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs?ref=49ec909ca7d649d73115f7e0e894b0ffb0740b66", "patch": "@@ -1,6 +1,6 @@\n //! Errors emitted by typeck.\n use rustc_errors::Applicability;\n-use rustc_macros::SessionDiagnostic;\n+use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n use rustc_middle::ty::Ty;\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n@@ -190,3 +190,41 @@ pub struct AddressOfTemporaryTaken {\n     #[label]\n     pub span: Span,\n }\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum AddReturnTypeSuggestion<'tcx> {\n+    #[suggestion(\n+        slug = \"typeck-add-return-type-add\",\n+        code = \"-> {found} \",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Add {\n+        #[primary_span]\n+        span: Span,\n+        found: Ty<'tcx>,\n+    },\n+    #[suggestion(\n+        slug = \"typeck-add-return-type-missing-here\",\n+        code = \"-> _ \",\n+        applicability = \"has-placeholders\"\n+    )]\n+    MissingHere {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum ExpectedReturnTypeLabel<'tcx> {\n+    #[label(slug = \"typeck-expected-default-return-type\")]\n+    Unit {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(slug = \"typeck-expected-return-type\")]\n+    Other {\n+        #[primary_span]\n+        span: Span,\n+        expected: Ty<'tcx>,\n+    },\n+}"}, {"sha": "a587bd2cbb23d04c6503f153b9caef55bb6ce1f5", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "added", "additions": 501, "deletions": 0, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/49ec909ca7d649d73115f7e0e894b0ffb0740b66/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ec909ca7d649d73115f7e0e894b0ffb0740b66/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=49ec909ca7d649d73115f7e0e894b0ffb0740b66", "patch": "@@ -0,0 +1,501 @@\n+// check-fail\n+// Tests error conditions for specifying subdiagnostics using #[derive(SessionSubdiagnostic)]\n+\n+// The proc_macro2 crate handles spans differently when on beta/stable release rather than nightly,\n+// changing the output of this test. Since SessionSubdiagnostic is strictly internal to the compiler\n+// the test is just ignored on stable and beta:\n+// ignore-beta\n+// ignore-stable\n+\n+#![feature(rustc_private)]\n+#![crate_type = \"lib\"]\n+\n+extern crate rustc_errors;\n+extern crate rustc_session;\n+extern crate rustc_span;\n+extern crate rustc_macros;\n+\n+use rustc_errors::Applicability;\n+use rustc_span::Span;\n+use rustc_macros::SessionSubdiagnostic;\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"label-a\")]\n+struct A {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum B {\n+    #[label(slug = \"label-b-a\")]\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    },\n+    #[label(slug = \"label-b-b\")]\n+    B {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"label-c\")]\n+//~^ ERROR label without `#[primary_span]` field\n+struct C {\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label]\n+//~^ ERROR `#[label]` is not a valid `SessionSubdiagnostic` attribute \n+struct D {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[foo]\n+//~^ ERROR `#[foo]` is not a valid `SessionSubdiagnostic` attribute\n+//~^^ ERROR cannot find attribute `foo` in this scope\n+struct E {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label = \"...\"]\n+//~^ ERROR `#[label = ...]` is not a valid `SessionSubdiagnostic` attribute\n+struct F {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(bug = \"...\")]\n+//~^ ERROR `#[label(bug = ...)]` is not a valid `SessionSubdiagnostic` attribute\n+struct G {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(\"...\")]\n+//~^ ERROR `#[label(\"...\")]` is not a valid `SessionSubdiagnostic` attribute\n+struct H {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = 4)]\n+//~^ ERROR `#[label(slug = ...)]` is not a valid `SessionSubdiagnostic` attribute\n+struct J {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug(\"...\"))]\n+//~^ ERROR `#[label(slug(...))]` is not a valid `SessionSubdiagnostic` attribute\n+struct K {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug)]\n+//~^ ERROR `#[label(slug)]` is not a valid `SessionSubdiagnostic` attribute\n+struct L {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label()]\n+//~^ ERROR `slug` must be set in a `#[label(...)]` attribute\n+struct M {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(code = \"...\")]\n+//~^ ERROR `code` is not a valid nested attribute of a `label` attribute\n+struct N {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[foo]\n+//~^ ERROR cannot find attribute `foo` in this scope\n+//~^^ ERROR unsupported type attribute for subdiagnostic enum\n+enum O {\n+    #[label(slug = \"...\")]\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum P {\n+    #[bar]\n+//~^ ERROR `#[bar]` is not a valid `SessionSubdiagnostic` attribute\n+//~^^ ERROR cannot find attribute `bar` in this scope\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum Q {\n+    #[bar = \"...\"]\n+//~^ ERROR `#[bar = ...]` is not a valid `SessionSubdiagnostic` attribute\n+//~^^ ERROR cannot find attribute `bar` in this scope\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum R {\n+    #[bar = 4]\n+//~^ ERROR `#[bar = ...]` is not a valid `SessionSubdiagnostic` attribute\n+//~^^ ERROR cannot find attribute `bar` in this scope\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum S {\n+    #[bar(\"...\")]\n+//~^ ERROR `#[bar(\"...\")]` is not a valid `SessionSubdiagnostic` attribute\n+//~^^ ERROR cannot find attribute `bar` in this scope\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum T {\n+    #[label(code = \"...\")]\n+//~^ ERROR `code` is not a valid nested attribute of a `label`\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum U {\n+    #[label(slug = \"label-u\")]\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    },\n+    B {\n+//~^ ERROR subdiagnostic kind not specified\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"...\")]\n+//~^ ERROR label without `#[primary_span]` field\n+struct V {\n+    #[primary_span]\n+    //~^ ERROR the `#[primary_span]` attribute can only be applied to fields of type `Span`\n+    span: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"...\")]\n+struct W {\n+    #[primary_span]\n+    span: Span,\n+    #[applicability]\n+    //~^ ERROR `#[applicability]` is only valid on suggestions\n+    applicability: Applicability,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"...\")]\n+struct X {\n+    #[primary_span]\n+    span: Span,\n+    #[bar]\n+    //~^ ERROR `#[bar]` is not a valid `SessionSubdiagnostic` field attribute\n+    //~^^ ERROR cannot find attribute `bar` in this scope\n+    bar: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"...\")]\n+struct Y {\n+    #[primary_span]\n+    span: Span,\n+    #[bar = \"...\"]\n+    //~^ ERROR `#[bar = ...]` is not a valid `SessionSubdiagnostic` field attribute\n+    //~^^ ERROR cannot find attribute `bar` in this scope\n+    bar: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"...\")]\n+struct Z {\n+    #[primary_span]\n+    span: Span,\n+    #[bar(\"...\")]\n+    //~^ ERROR `#[bar(...)]` is not a valid `SessionSubdiagnostic` field attribute\n+    //~^^ ERROR cannot find attribute `bar` in this scope\n+    bar: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"label-aa\")]\n+struct AA {\n+    #[primary_span]\n+    span: Span,\n+    #[skip_arg]\n+    z: Z\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+union AB {\n+//~^ ERROR unexpected unsupported untagged union\n+    span: u32,\n+    b: u64\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"label-ac-1\")]\n+//~^ NOTE previously specified here\n+//~^^ NOTE previously specified here\n+#[label(slug = \"label-ac-2\")]\n+//~^ ERROR specified multiple times\n+//~^^ ERROR specified multiple times\n+struct AC {\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"label-ad-1\", slug = \"label-ad-2\")]\n+//~^ ERROR specified multiple times\n+//~^^ NOTE previously specified here\n+struct AD {\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"label-ad-1\")]\n+struct AE {\n+    #[primary_span]\n+//~^ NOTE previously specified here\n+    span_a: Span,\n+    #[primary_span]\n+//~^ ERROR specified multiple times\n+    span_b: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+struct AF {\n+//~^ ERROR subdiagnostic kind not specified\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"suggestion-af\", code = \"...\")]\n+struct AG {\n+    #[primary_span]\n+    span: Span,\n+    #[applicability]\n+    applicability: Applicability,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum AH {\n+    #[suggestion(slug = \"suggestion-ag-a\", code = \"...\")]\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        #[applicability]\n+        applicability: Applicability,\n+        var: String,\n+    },\n+    #[suggestion(slug = \"suggestion-ag-b\", code = \"...\")]\n+    B {\n+        #[primary_span]\n+        span: Span,\n+        #[applicability]\n+        applicability: Applicability,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code = \"...\", code = \"...\")]\n+//~^ ERROR specified multiple times\n+//~^^ NOTE previously specified here\n+struct AI {\n+    #[primary_span]\n+    span: Span,\n+    #[applicability]\n+    applicability: Applicability,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code = \"...\")]\n+struct AJ {\n+    #[primary_span]\n+    span: Span,\n+    #[applicability]\n+//~^ NOTE previously specified here\n+    applicability_a: Applicability,\n+    #[applicability]\n+//~^ ERROR specified multiple times\n+    applicability_b: Applicability,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code = \"...\")]\n+//~^ ERROR suggestion without `applicability`\n+struct AK {\n+    #[primary_span]\n+    span: Span,\n+    #[applicability]\n+//~^ ERROR the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n+    applicability: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code = \"...\")]\n+//~^ ERROR suggestion without `applicability`\n+struct AL {\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\")]\n+//~^ ERROR suggestion without `code = \"...\"`\n+struct AM {\n+    #[primary_span]\n+    span: Span,\n+    #[applicability]\n+    applicability: Applicability,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code =\"...\", applicability = \"foo\")]\n+//~^ ERROR invalid applicability\n+struct AN {\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[help(slug = \"label-am\")]\n+struct AO {\n+    var: String\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[note(slug = \"label-an\")]\n+struct AP;\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code = \"...\")]\n+//~^ ERROR suggestion without `applicability`\n+//~^^ ERROR suggestion without `#[primary_span]` field\n+struct AQ {\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code =\"...\", applicability = \"machine-applicable\")]\n+struct AR {\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label]\n+//~^ ERROR unsupported type attribute for subdiagnostic enum\n+enum AS {\n+    #[label(slug = \"...\")]\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n+struct AT {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n+//~^ ERROR `var` doesn't refer to a field on this type\n+struct AU {\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum AV {\n+    #[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum AW {\n+    #[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n+//~^ ERROR `var` doesn't refer to a field on this type\n+    A {\n+        #[primary_span]\n+        span: Span,\n+    }\n+}"}, {"sha": "bc96fcf771b8accae9307cd8d974d377d849187b", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/49ec909ca7d649d73115f7e0e894b0ffb0740b66/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49ec909ca7d649d73115f7e0e894b0ffb0740b66/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=49ec909ca7d649d73115f7e0e894b0ffb0740b66", "patch": "@@ -0,0 +1,387 @@\n+error: label without `#[primary_span]` field\n+  --> $DIR/subdiagnostic-derive.rs:47:1\n+   |\n+LL | / #[label(slug = \"label-c\")]\n+LL | |\n+LL | | struct C {\n+LL | |     var: String,\n+LL | | }\n+   | |_^\n+\n+error: `#[label]` is not a valid `SessionSubdiagnostic` attribute\n+  --> $DIR/subdiagnostic-derive.rs:54:1\n+   |\n+LL | #[label]\n+   | ^^^^^^^^\n+\n+error: `#[foo]` is not a valid `SessionSubdiagnostic` attribute\n+  --> $DIR/subdiagnostic-derive.rs:63:1\n+   |\n+LL | #[foo]\n+   | ^^^^^^\n+\n+error: `#[label = ...]` is not a valid `SessionSubdiagnostic` attribute\n+  --> $DIR/subdiagnostic-derive.rs:73:1\n+   |\n+LL | #[label = \"...\"]\n+   | ^^^^^^^^^^^^^^^^\n+\n+error: `#[label(bug = ...)]` is not a valid `SessionSubdiagnostic` attribute\n+  --> $DIR/subdiagnostic-derive.rs:82:9\n+   |\n+LL | #[label(bug = \"...\")]\n+   |         ^^^^^^^^^^^\n+\n+error: `#[label(\"...\")]` is not a valid `SessionSubdiagnostic` attribute\n+  --> $DIR/subdiagnostic-derive.rs:91:1\n+   |\n+LL | #[label(\"...\")]\n+   | ^^^^^^^^^^^^^^^\n+\n+error: `#[label(slug = ...)]` is not a valid `SessionSubdiagnostic` attribute\n+  --> $DIR/subdiagnostic-derive.rs:100:9\n+   |\n+LL | #[label(slug = 4)]\n+   |         ^^^^^^^^\n+   |\n+   = help: value must be a string\n+\n+error: `#[label(slug(...))]` is not a valid `SessionSubdiagnostic` attribute\n+  --> $DIR/subdiagnostic-derive.rs:109:9\n+   |\n+LL | #[label(slug(\"...\"))]\n+   |         ^^^^^^^^^^^\n+\n+error: `#[label(slug)]` is not a valid `SessionSubdiagnostic` attribute\n+  --> $DIR/subdiagnostic-derive.rs:118:9\n+   |\n+LL | #[label(slug)]\n+   |         ^^^^\n+\n+error: `slug` must be set in a `#[label(...)]` attribute\n+  --> $DIR/subdiagnostic-derive.rs:127:1\n+   |\n+LL | #[label()]\n+   | ^^^^^^^^^^\n+\n+error: `code` is not a valid nested attribute of a `label` attribute\n+  --> $DIR/subdiagnostic-derive.rs:136:1\n+   |\n+LL | #[label(code = \"...\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unsupported type attribute for subdiagnostic enum\n+  --> $DIR/subdiagnostic-derive.rs:145:1\n+   |\n+LL | #[foo]\n+   | ^^^^^^\n+\n+error: `#[bar]` is not a valid `SessionSubdiagnostic` attribute\n+  --> $DIR/subdiagnostic-derive.rs:159:5\n+   |\n+LL |     #[bar]\n+   |     ^^^^^^\n+\n+error: `#[bar = ...]` is not a valid `SessionSubdiagnostic` attribute\n+  --> $DIR/subdiagnostic-derive.rs:171:5\n+   |\n+LL |     #[bar = \"...\"]\n+   |     ^^^^^^^^^^^^^^\n+\n+error: `#[bar = ...]` is not a valid `SessionSubdiagnostic` attribute\n+  --> $DIR/subdiagnostic-derive.rs:183:5\n+   |\n+LL |     #[bar = 4]\n+   |     ^^^^^^^^^^\n+\n+error: `#[bar(\"...\")]` is not a valid `SessionSubdiagnostic` attribute\n+  --> $DIR/subdiagnostic-derive.rs:195:5\n+   |\n+LL |     #[bar(\"...\")]\n+   |     ^^^^^^^^^^^^^\n+\n+error: `code` is not a valid nested attribute of a `label` attribute\n+  --> $DIR/subdiagnostic-derive.rs:207:5\n+   |\n+LL |     #[label(code = \"...\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: subdiagnostic kind not specified\n+  --> $DIR/subdiagnostic-derive.rs:224:5\n+   |\n+LL |     B {\n+   |     ^\n+\n+error: the `#[primary_span]` attribute can only be applied to fields of type `Span`\n+  --> $DIR/subdiagnostic-derive.rs:236:5\n+   |\n+LL |     #[primary_span]\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: label without `#[primary_span]` field\n+  --> $DIR/subdiagnostic-derive.rs:233:1\n+   |\n+LL | / #[label(slug = \"...\")]\n+LL | |\n+LL | | struct V {\n+LL | |     #[primary_span]\n+LL | |\n+LL | |     span: String,\n+LL | | }\n+   | |_^\n+\n+error: `#[applicability]` is only valid on suggestions\n+  --> $DIR/subdiagnostic-derive.rs:246:5\n+   |\n+LL |     #[applicability]\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: `#[bar]` is not a valid `SessionSubdiagnostic` field attribute\n+  --> $DIR/subdiagnostic-derive.rs:256:5\n+   |\n+LL |     #[bar]\n+   |     ^^^^^^\n+\n+error: `#[bar = ...]` is not a valid `SessionSubdiagnostic` field attribute\n+  --> $DIR/subdiagnostic-derive.rs:267:5\n+   |\n+LL |     #[bar = \"...\"]\n+   |     ^^^^^^^^^^^^^^\n+\n+error: `#[bar(...)]` is not a valid `SessionSubdiagnostic` field attribute\n+  --> $DIR/subdiagnostic-derive.rs:278:5\n+   |\n+LL |     #[bar(\"...\")]\n+   |     ^^^^^^^^^^^^^\n+\n+error: unexpected unsupported untagged union\n+  --> $DIR/subdiagnostic-derive.rs:294:1\n+   |\n+LL | / union AB {\n+LL | |\n+LL | |     span: u32,\n+LL | |     b: u64\n+LL | | }\n+   | |_^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:304:9\n+   |\n+LL | #[label(slug = \"label-ac-2\")]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:301:9\n+   |\n+LL | #[label(slug = \"label-ac-1\")]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:304:1\n+   |\n+LL | #[label(slug = \"label-ac-2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:301:1\n+   |\n+LL | #[label(slug = \"label-ac-1\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:313:30\n+   |\n+LL | #[label(slug = \"label-ad-1\", slug = \"label-ad-2\")]\n+   |                              ^^^^^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:313:9\n+   |\n+LL | #[label(slug = \"label-ad-1\", slug = \"label-ad-2\")]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:327:5\n+   |\n+LL |     #[primary_span]\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:324:5\n+   |\n+LL |     #[primary_span]\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: subdiagnostic kind not specified\n+  --> $DIR/subdiagnostic-derive.rs:333:8\n+   |\n+LL | struct AF {\n+   |        ^^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:370:42\n+   |\n+LL | #[suggestion(slug = \"...\", code = \"...\", code = \"...\")]\n+   |                                          ^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:370:28\n+   |\n+LL | #[suggestion(slug = \"...\", code = \"...\", code = \"...\")]\n+   |                            ^^^^^^^^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:388:5\n+   |\n+LL |     #[applicability]\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:385:5\n+   |\n+LL |     #[applicability]\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n+  --> $DIR/subdiagnostic-derive.rs:399:5\n+   |\n+LL |     #[applicability]\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: suggestion without `applicability`\n+  --> $DIR/subdiagnostic-derive.rs:394:1\n+   |\n+LL | / #[suggestion(slug = \"...\", code = \"...\")]\n+LL | |\n+LL | | struct AK {\n+LL | |     #[primary_span]\n+...  |\n+LL | |     applicability: Span,\n+LL | | }\n+   | |_^\n+\n+error: suggestion without `applicability`\n+  --> $DIR/subdiagnostic-derive.rs:405:1\n+   |\n+LL | / #[suggestion(slug = \"...\", code = \"...\")]\n+LL | |\n+LL | | struct AL {\n+LL | |     #[primary_span]\n+LL | |     span: Span,\n+LL | | }\n+   | |_^\n+\n+error: suggestion without `code = \"...\"`\n+  --> $DIR/subdiagnostic-derive.rs:413:1\n+   |\n+LL | / #[suggestion(slug = \"...\")]\n+LL | |\n+LL | | struct AM {\n+LL | |     #[primary_span]\n+...  |\n+LL | |     applicability: Applicability,\n+LL | | }\n+   | |_^\n+\n+error: invalid applicability\n+  --> $DIR/subdiagnostic-derive.rs:423:41\n+   |\n+LL | #[suggestion(slug = \"...\", code =\"...\", applicability = \"foo\")]\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: suggestion without `applicability`\n+  --> $DIR/subdiagnostic-derive.rs:441:1\n+   |\n+LL | / #[suggestion(slug = \"...\", code = \"...\")]\n+LL | |\n+LL | |\n+LL | | struct AQ {\n+LL | |     var: String,\n+LL | | }\n+   | |_^\n+\n+error: suggestion without `#[primary_span]` field\n+  --> $DIR/subdiagnostic-derive.rs:441:1\n+   |\n+LL | / #[suggestion(slug = \"...\", code = \"...\")]\n+LL | |\n+LL | |\n+LL | | struct AQ {\n+LL | |     var: String,\n+LL | | }\n+   | |_^\n+\n+error: unsupported type attribute for subdiagnostic enum\n+  --> $DIR/subdiagnostic-derive.rs:456:1\n+   |\n+LL | #[label]\n+   | ^^^^^^^^\n+\n+error: `var` doesn't refer to a field on this type\n+  --> $DIR/subdiagnostic-derive.rs:476:34\n+   |\n+LL | #[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n+   |                                  ^^^^^^^\n+\n+error: `var` doesn't refer to a field on this type\n+  --> $DIR/subdiagnostic-derive.rs:495:38\n+   |\n+LL |     #[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n+   |                                      ^^^^^^^\n+\n+error: cannot find attribute `foo` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:63:3\n+   |\n+LL | #[foo]\n+   |   ^^^\n+\n+error: cannot find attribute `foo` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:145:3\n+   |\n+LL | #[foo]\n+   |   ^^^\n+\n+error: cannot find attribute `bar` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:159:7\n+   |\n+LL |     #[bar]\n+   |       ^^^\n+\n+error: cannot find attribute `bar` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:171:7\n+   |\n+LL |     #[bar = \"...\"]\n+   |       ^^^\n+\n+error: cannot find attribute `bar` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:183:7\n+   |\n+LL |     #[bar = 4]\n+   |       ^^^\n+\n+error: cannot find attribute `bar` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:195:7\n+   |\n+LL |     #[bar(\"...\")]\n+   |       ^^^\n+\n+error: cannot find attribute `bar` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:256:7\n+   |\n+LL |     #[bar]\n+   |       ^^^\n+\n+error: cannot find attribute `bar` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:267:7\n+   |\n+LL |     #[bar = \"...\"]\n+   |       ^^^\n+\n+error: cannot find attribute `bar` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:278:7\n+   |\n+LL |     #[bar(\"...\")]\n+   |       ^^^\n+\n+error: aborting due to 51 previous errors\n+"}]}