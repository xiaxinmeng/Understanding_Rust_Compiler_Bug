{"sha": "9bac0179dfa61ab6759041617f1a97cd1f94bb92", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYWMwMTc5ZGZhNjFhYjY3NTkwNDE2MTdmMWE5N2NkMWY5NGJiOTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-25T08:24:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-25T08:24:47Z"}, "message": "Auto merge of #20373 - huonw:self-call-lint, r=luqmana\n\nE.g. `fn foo() { foo() }`, or, more subtlely\r\n\r\n    impl Foo for Box<Foo+'static> {\r\n        fn bar(&self) {\r\n            self.bar();\r\n        }\r\n    }\r\n\r\nThe compiler will warn and point out the points where recursion occurs,\r\nif it determines that the function cannot return without calling itself.\r\n\r\nCloses #17899.\r\n\r\n---\r\n\r\nThis is highly non-perfect, in particular, my wording above is quite precise, and I have some unresolved questions: This currently will warn about\r\n\r\n```rust\r\nfn foo() {\r\n    if bar { loop {} }\r\n\r\n    foo()\r\n}\r\n```\r\n\r\neven though `foo` may never be called (i.e. our apparent \"unconditional\" recursion is actually conditional). I don't know if we should handle this case, and ones like it with `panic!()` instead of `loop` (or anything else that \"returns\" `!`).\r\n\r\nHowever, strictly speaking, it seems to me that changing the above to not warn will require changing\r\n\r\n```rust\r\nfn foo() {\r\n    while bar {}\r\n    foo()\r\n}\r\n```\r\n\r\nto also not warn since it could be that the `while` is an infinite loop and doesn't ever hit the `foo`.\r\n\r\nI'm inclined to think we let these cases warn since true edge cases like the first one seem rare, and if they do occur they seem like they would usually be typos in the function call. (I could imagine someone accidentally having code like `fn foo() { assert!(bar()); foo() /* meant to be boo() */ }` which won't warn if the `loop` case is \"fixed\".)\r\n\r\n(Part of the reason this is unresolved is wanting feedback, part of the reason is I couldn't devise a strategy that worked in all cases.)\r\n\r\n---\r\n\r\nThe name `unconditional_self_calls` is kinda clunky; and this reconstructs the CFG for each function that is linted which may or may not be very expensive, I don't know.", "tree": {"sha": "653ae917445aecffd3d111ed87e3a13b2bd101a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/653ae917445aecffd3d111ed87e3a13b2bd101a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bac0179dfa61ab6759041617f1a97cd1f94bb92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bac0179dfa61ab6759041617f1a97cd1f94bb92", "html_url": "https://github.com/rust-lang/rust/commit/9bac0179dfa61ab6759041617f1a97cd1f94bb92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bac0179dfa61ab6759041617f1a97cd1f94bb92/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43046becce78147fa43808626bbb48569086b6a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/43046becce78147fa43808626bbb48569086b6a5", "html_url": "https://github.com/rust-lang/rust/commit/43046becce78147fa43808626bbb48569086b6a5"}, {"sha": "0684c8ebf92933e6382d1ac13a77999296411dac", "url": "https://api.github.com/repos/rust-lang/rust/commits/0684c8ebf92933e6382d1ac13a77999296411dac", "html_url": "https://github.com/rust-lang/rust/commit/0684c8ebf92933e6382d1ac13a77999296411dac"}], "stats": {"total": 308, "additions": 299, "deletions": 9}, "files": [{"sha": "72f16a708198f14b6bae95367317b7d19b6cc005", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 191, "deletions": 1, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=9bac0179dfa61ab6759041617f1a97cd1f94bb92", "patch": "@@ -32,10 +32,12 @@ use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use middle::{def, pat_util, stability};\n use middle::const_eval::{eval_const_expr_partial, const_int, const_uint};\n+use middle::cfg;\n use util::ppaux::{ty_to_string};\n use util::nodemap::{FnvHashMap, NodeSet};\n-use lint::{Context, LintPass, LintArray, Lint};\n+use lint::{Level, Context, LintPass, LintArray, Lint};\n \n+use std::collections::BitvSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::num::SignedInt;\n use std::{cmp, slice};\n@@ -1788,6 +1790,194 @@ impl LintPass for Stability {\n     }\n }\n \n+declare_lint! {\n+    pub UNCONDITIONAL_RECURSION,\n+    Warn,\n+    \"functions that cannot return without calling themselves\"\n+}\n+\n+#[derive(Copy)]\n+pub struct UnconditionalRecursion;\n+\n+\n+impl LintPass for UnconditionalRecursion {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![UNCONDITIONAL_RECURSION]\n+    }\n+\n+    fn check_fn(&mut self, cx: &Context, fn_kind: visit::FnKind, _: &ast::FnDecl,\n+                blk: &ast::Block, sp: Span, id: ast::NodeId) {\n+        type F = for<'tcx> fn(&ty::ctxt<'tcx>,\n+                              ast::NodeId, ast::NodeId, ast::Ident, ast::NodeId) -> bool;\n+\n+        let (name, checker) = match fn_kind {\n+            visit::FkItemFn(name, _, _, _) => (name, id_refers_to_this_fn as F),\n+            visit::FkMethod(name, _, _) => (name, id_refers_to_this_method as F),\n+            // closures can't recur, so they don't matter.\n+            visit::FkFnBlock => return\n+        };\n+\n+        let impl_def_id = ty::impl_of_method(cx.tcx, ast_util::local_def(id))\n+            .unwrap_or(ast_util::local_def(ast::DUMMY_NODE_ID));\n+        assert!(ast_util::is_local(impl_def_id));\n+        let impl_node_id = impl_def_id.node;\n+\n+        // Walk through this function (say `f`) looking to see if\n+        // every possible path references itself, i.e. the function is\n+        // called recursively unconditionally. This is done by trying\n+        // to find a path from the entry node to the exit node that\n+        // *doesn't* call `f` by traversing from the entry while\n+        // pretending that calls of `f` are sinks (i.e. ignoring any\n+        // exit edges from them).\n+        //\n+        // NB. this has an edge case with non-returning statements,\n+        // like `loop {}` or `panic!()`: control flow never reaches\n+        // the exit node through these, so one can have a function\n+        // that never actually calls itselfs but is still picked up by\n+        // this lint:\n+        //\n+        //     fn f(cond: bool) {\n+        //         if !cond { panic!() } // could come from `assert!(cond)`\n+        //         f(false)\n+        //     }\n+        //\n+        // In general, functions of that form may be able to call\n+        // itself a finite number of times and then diverge. The lint\n+        // considers this to be an error for two reasons, (a) it is\n+        // easier to implement, and (b) it seems rare to actually want\n+        // to have behaviour like the above, rather than\n+        // e.g. accidentally recurring after an assert.\n+\n+        let cfg = cfg::CFG::new(cx.tcx, blk);\n+\n+        let mut work_queue = vec![cfg.entry];\n+        let mut reached_exit_without_self_call = false;\n+        let mut self_call_spans = vec![];\n+        let mut visited = BitvSet::new();\n+\n+        while let Some(idx) = work_queue.pop() {\n+            let cfg_id = idx.node_id();\n+            if idx == cfg.exit {\n+                // found a path!\n+                reached_exit_without_self_call = true;\n+                break\n+            } else if visited.contains(&cfg_id) {\n+                // already done\n+                continue\n+            }\n+            visited.insert(cfg_id);\n+            let node_id = cfg.graph.node_data(idx).id;\n+\n+            // is this a recursive call?\n+            if node_id != ast::DUMMY_NODE_ID && checker(cx.tcx, impl_node_id, id, name, node_id) {\n+\n+                self_call_spans.push(cx.tcx.map.span(node_id));\n+                // this is a self call, so we shouldn't explore past\n+                // this node in the CFG.\n+                continue\n+            }\n+            // add the successors of this node to explore the graph further.\n+            cfg.graph.each_outgoing_edge(idx, |_, edge| {\n+                let target_idx = edge.target();\n+                let target_cfg_id = target_idx.node_id();\n+                if !visited.contains(&target_cfg_id) {\n+                    work_queue.push(target_idx)\n+                }\n+                true\n+            });\n+        }\n+\n+        // check the number of sell calls because a function that\n+        // doesn't return (e.g. calls a `-> !` function or `loop { /*\n+        // no break */ }`) shouldn't be linted unless it actually\n+        // recurs.\n+        if !reached_exit_without_self_call && self_call_spans.len() > 0 {\n+            cx.span_lint(UNCONDITIONAL_RECURSION, sp,\n+                         \"function cannot return without recurring\");\n+\n+            // FIXME #19668: these could be span_lint_note's instead of this manual guard.\n+            if cx.current_level(UNCONDITIONAL_RECURSION) != Level::Allow {\n+                let sess = cx.sess();\n+                // offer some help to the programmer.\n+                for call in self_call_spans.iter() {\n+                    sess.span_note(*call, \"recursive call site\")\n+                }\n+                sess.span_help(sp, \"a `loop` may express intention better if this is on purpose\")\n+            }\n+        }\n+\n+        // all done\n+        return;\n+\n+        // Functions for identifying if the given NodeId `id`\n+        // represents a call to the function `fn_id`/method\n+        // `method_id`.\n+\n+        fn id_refers_to_this_fn<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                      _: ast::NodeId,\n+                                      fn_id: ast::NodeId,\n+                                      _: ast::Ident,\n+                                      id: ast::NodeId) -> bool {\n+            tcx.def_map.borrow().get(&id)\n+                .map_or(false, |def| {\n+                    let did = def.def_id();\n+                    ast_util::is_local(did) && did.node == fn_id\n+                })\n+        }\n+\n+        // check if the method call `id` refers to method `method_id`\n+        // (with name `method_name` contained in impl `impl_id`).\n+        fn id_refers_to_this_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                          impl_id: ast::NodeId,\n+                                          method_id: ast::NodeId,\n+                                          method_name: ast::Ident,\n+                                          id: ast::NodeId) -> bool {\n+            let did = match tcx.method_map.borrow().get(&ty::MethodCall::expr(id)) {\n+                None => return false,\n+                Some(m) => match m.origin {\n+                    // There's no way to know if a method call via a\n+                    // vtable is recursion, so we assume it's not.\n+                    ty::MethodTraitObject(_) => return false,\n+\n+                    // This `did` refers directly to the method definition.\n+                    ty::MethodStatic(did) | ty::MethodStaticUnboxedClosure(did) => did,\n+\n+                    // MethodTypeParam are methods from traits:\n+\n+                    // The `impl ... for ...` of this method call\n+                    // isn't known, e.g. it might be a default method\n+                    // in a trait, so we get the def-id of the trait\n+                    // method instead.\n+                    ty::MethodTypeParam(\n+                        ty::MethodParam { ref trait_ref, method_num, impl_def_id: None, }) => {\n+                        ty::trait_item(tcx, trait_ref.def_id, method_num).def_id()\n+                    }\n+\n+                    // The `impl` is known, so we check that with a\n+                    // special case:\n+                    ty::MethodTypeParam(\n+                        ty::MethodParam { impl_def_id: Some(impl_def_id), .. }) => {\n+\n+                        let name = match tcx.map.expect_expr(id).node {\n+                            ast::ExprMethodCall(ref sp_ident, _, _) => sp_ident.node,\n+                            _ => tcx.sess.span_bug(\n+                                tcx.map.span(id),\n+                                \"non-method call expr behaving like a method call?\")\n+                        };\n+                        // it matches if it comes from the same impl,\n+                        // and has the same method name.\n+                        return ast_util::is_local(impl_def_id)\n+                            && impl_def_id.node == impl_id\n+                            && method_name.name == name.name\n+                    }\n+                }\n+            };\n+\n+            ast_util::is_local(did) && did.node == method_id\n+        }\n+    }\n+}\n+\n declare_lint! {\n     pub UNUSED_IMPORTS,\n     Warn,"}, {"sha": "3728e6f4980d94059716f9be70f466da79faa6e2", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9bac0179dfa61ab6759041617f1a97cd1f94bb92", "patch": "@@ -211,6 +211,7 @@ impl LintStore {\n                      UnusedAllocation,\n                      MissingCopyImplementations,\n                      UnstableFeatures,\n+                     UnconditionalRecursion,\n         );\n \n         add_builtin_with_new!(sess,"}, {"sha": "430b63f81c852e82eabbf9d6953902c64466da5e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9bac0179dfa61ab6759041617f1a97cd1f94bb92", "patch": "@@ -627,6 +627,7 @@ impl<'tcx> tr for MethodOrigin<'tcx> {\n                         // def-id is already translated when we read it out\n                         trait_ref: mp.trait_ref.clone(),\n                         method_num: mp.method_num,\n+                        impl_def_id: mp.impl_def_id.tr(dcx),\n                     }\n                 )\n             }\n@@ -879,6 +880,16 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                             try!(this.emit_struct_field(\"method_num\", 0, |this| {\n                                 this.emit_uint(p.method_num)\n                             }));\n+                            try!(this.emit_struct_field(\"impl_def_id\", 0, |this| {\n+                                this.emit_option(|this| {\n+                                    match p.impl_def_id {\n+                                        None => this.emit_option_none(),\n+                                        Some(did) => this.emit_option_some(|this| {\n+                                            Ok(this.emit_def_id(did))\n+                                        })\n+                                    }\n+                                })\n+                            }));\n                             Ok(())\n                         })\n                     })\n@@ -1452,6 +1463,17 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                         this.read_struct_field(\"method_num\", 1, |this| {\n                                             this.read_uint()\n                                         }).unwrap()\n+                                    },\n+                                    impl_def_id: {\n+                                        this.read_struct_field(\"impl_def_id\", 2, |this| {\n+                                            this.read_option(|this, b| {\n+                                                if b {\n+                                                    Ok(Some(this.read_def_id(dcx)))\n+                                                } else {\n+                                                    Ok(None)\n+                                                }\n+                                            })\n+                                        }).unwrap()\n                                     }\n                                 }))\n                         }).unwrap()"}, {"sha": "d04c2d2d1a09449dff84d436fcbbbeb1cfc2fbb4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9bac0179dfa61ab6759041617f1a97cd1f94bb92", "patch": "@@ -453,9 +453,14 @@ pub struct MethodParam<'tcx> {\n     // never contains bound regions; those regions should have been\n     // instantiated with fresh variables at this point.\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n-\n     // index of uint in the list of methods for the trait\n     pub method_num: uint,\n+\n+    /// The impl for the trait from which the method comes. This\n+    /// should only be used for certain linting/heuristic purposes\n+    /// since there is no guarantee that this is Some in every\n+    /// situation that it could/should be.\n+    pub impl_def_id: Option<ast::DefId>,\n }\n \n // details for a method invoked with a receiver whose type is an object"}, {"sha": "0b8c77860155a5854eaf8e82656530d64939e530", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=9bac0179dfa61ab6759041617f1a97cd1f94bb92", "patch": "@@ -310,7 +310,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::MethodOrigin<'tcx> {\n             ty::MethodTypeParam(ref param) => {\n                 ty::MethodTypeParam(ty::MethodParam {\n                     trait_ref: param.trait_ref.fold_with(folder),\n-                    method_num: param.method_num\n+                    method_num: param.method_num,\n+                    impl_def_id: param.impl_def_id,\n                 })\n             }\n             ty::MethodTraitObject(ref object) => {"}, {"sha": "266048fce51c9ac6a90f326f3018c8be808d54f0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9bac0179dfa61ab6759041617f1a97cd1f94bb92", "patch": "@@ -544,7 +544,7 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Option<T> {\n \n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for P<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        (*self).repr(tcx)\n+        (**self).repr(tcx)\n     }\n }\n "}, {"sha": "9356be1b9b410808718bfc9e983f596b084a88a6", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=9bac0179dfa61ab6759041617f1a97cd1f94bb92", "patch": "@@ -132,7 +132,8 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         ty::MethodTypeParam(ty::MethodParam {\n             ref trait_ref,\n-            method_num\n+            method_num,\n+            impl_def_id: _\n         }) => {\n             let trait_ref = ty::Binder(bcx.monomorphize(trait_ref));\n             let span = bcx.tcx().map.span(method_call.expr_id);"}, {"sha": "4aa0a211221ef526afd7313d59596ae840966496", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=9bac0179dfa61ab6759041617f1a97cd1f94bb92", "patch": "@@ -256,7 +256,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         &impl_polytype.substs,\n                         &ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap());\n                 let origin = MethodTypeParam(MethodParam { trait_ref: impl_trait_ref.clone(),\n-                                                           method_num: method_num });\n+                                                           method_num: method_num,\n+                                                           impl_def_id: Some(impl_def_id) });\n                 (impl_trait_ref.substs.clone(), origin)\n             }\n \n@@ -275,7 +276,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 let trait_ref =\n                     Rc::new(ty::TraitRef::new(trait_def_id, self.tcx().mk_substs(substs.clone())));\n                 let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n-                                                           method_num: method_num });\n+                                                           method_num: method_num,\n+                                                           impl_def_id: None });\n                 (substs, origin)\n             }\n \n@@ -285,7 +287,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 let trait_ref = self.replace_late_bound_regions_with_fresh_var(&*poly_trait_ref);\n                 let substs = trait_ref.substs.clone();\n                 let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n-                                                           method_num: method_num });\n+                                                           method_num: method_num,\n+                                                           impl_def_id: None });\n                 (substs, origin)\n             }\n         }"}, {"sha": "d92cc1dfc1e95f4af178b5bc176a0e49e76db449", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=9bac0179dfa61ab6759041617f1a97cd1f94bb92", "patch": "@@ -287,7 +287,8 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     let callee = MethodCallee {\n         origin: MethodTypeParam(MethodParam{trait_ref: trait_ref.clone(),\n-                                            method_num: method_num}),\n+                                            method_num: method_num,\n+                                            impl_def_id: None}),\n         ty: fty,\n         substs: trait_ref.substs.clone()\n     };"}, {"sha": "0c3d1c6adea40c247440a8d77a039175b6630a45", "filename": "src/test/compile-fail/lint-unconditional-recursion.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Ftest%2Fcompile-fail%2Flint-unconditional-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bac0179dfa61ab6759041617f1a97cd1f94bb92/src%2Ftest%2Fcompile-fail%2Flint-unconditional-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unconditional-recursion.rs?ref=9bac0179dfa61ab6759041617f1a97cd1f94bb92", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(unconditional_recursion)]\n+#![allow(dead_code)]\n+fn foo() { //~ ERROR function cannot return without recurring\n+    foo(); //~ NOTE recursive call site\n+}\n+\n+fn bar() {\n+    if true {\n+        bar()\n+    }\n+}\n+\n+fn baz() { //~ ERROR function cannot return without recurring\n+    if true {\n+        baz() //~ NOTE recursive call site\n+    } else {\n+        baz() //~ NOTE recursive call site\n+    }\n+}\n+\n+fn qux() {\n+    loop {}\n+}\n+\n+fn quz() -> bool { //~ ERROR function cannot return without recurring\n+    if true {\n+        while quz() {} //~ NOTE recursive call site\n+        true\n+    } else {\n+        loop { quz(); } //~ NOTE recursive call site\n+    }\n+}\n+\n+trait Foo {\n+    fn bar(&self) { //~ ERROR function cannot return without recurring\n+        self.bar() //~ NOTE recursive call site\n+    }\n+}\n+\n+impl Foo for Box<Foo+'static> {\n+    fn bar(&self) { //~ ERROR function cannot return without recurring\n+        loop {\n+            self.bar() //~ NOTE recursive call site\n+        }\n+    }\n+\n+}\n+\n+struct Baz;\n+impl Baz {\n+    fn qux(&self) { //~ ERROR function cannot return without recurring\n+        self.qux(); //~ NOTE recursive call site\n+    }\n+}\n+\n+fn main() {}"}]}