{"sha": "422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMmM5YTBmYTI0YmZiYzk2MTVkNmNmZTBiZjMxNGRlOTFhYmI2ZTM=", "commit": {"author": {"name": "Daniel Wagner-Hall", "email": "dawagner@gmail.com", "date": "2019-01-31T22:01:23Z"}, "committer": {"name": "Daniel Wagner-Hall", "email": "dawagner@gmail.com", "date": "2019-02-18T22:56:43Z"}, "message": "wildcard_enum_match_arm gives suggestions\n\nAnd is also more robust", "tree": {"sha": "59f55bd8643937b6db428c391d700d19272f17bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59f55bd8643937b6db428c391d700d19272f17bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3", "html_url": "https://github.com/rust-lang/rust/commit/422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3/comments", "author": {"login": "illicitonion", "id": 1131704, "node_id": "MDQ6VXNlcjExMzE3MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1131704?v=4", "gravatar_id": "", "url": "https://api.github.com/users/illicitonion", "html_url": "https://github.com/illicitonion", "followers_url": "https://api.github.com/users/illicitonion/followers", "following_url": "https://api.github.com/users/illicitonion/following{/other_user}", "gists_url": "https://api.github.com/users/illicitonion/gists{/gist_id}", "starred_url": "https://api.github.com/users/illicitonion/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/illicitonion/subscriptions", "organizations_url": "https://api.github.com/users/illicitonion/orgs", "repos_url": "https://api.github.com/users/illicitonion/repos", "events_url": "https://api.github.com/users/illicitonion/events{/privacy}", "received_events_url": "https://api.github.com/users/illicitonion/received_events", "type": "User", "site_admin": false}, "committer": {"login": "illicitonion", "id": 1131704, "node_id": "MDQ6VXNlcjExMzE3MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1131704?v=4", "gravatar_id": "", "url": "https://api.github.com/users/illicitonion", "html_url": "https://github.com/illicitonion", "followers_url": "https://api.github.com/users/illicitonion/followers", "following_url": "https://api.github.com/users/illicitonion/following{/other_user}", "gists_url": "https://api.github.com/users/illicitonion/gists{/gist_id}", "starred_url": "https://api.github.com/users/illicitonion/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/illicitonion/subscriptions", "organizations_url": "https://api.github.com/users/illicitonion/orgs", "repos_url": "https://api.github.com/users/illicitonion/repos", "events_url": "https://api.github.com/users/illicitonion/events{/privacy}", "received_events_url": "https://api.github.com/users/illicitonion/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2139fbdbe13dd97f44526b0834a8745c5319a8bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2139fbdbe13dd97f44526b0834a8745c5319a8bd", "html_url": "https://github.com/rust-lang/rust/commit/2139fbdbe13dd97f44526b0834a8745c5319a8bd"}], "stats": {"total": 229, "additions": 171, "deletions": 58}, "files": [{"sha": "a7c66c22968dcd7ee9aede66309036baec02834d", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 81, "deletions": 12, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3", "patch": "@@ -6,13 +6,15 @@ use crate::utils::{\n     snippet_with_applicability, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty,\n };\n use if_chain::if_chain;\n+use rustc::hir::def::CtorKind;\n use rustc::hir::*;\n use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Ty, TyKind};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use std::cmp::Ordering;\n use std::collections::Bound;\n+use std::ops::Deref;\n use syntax::ast::LitKind;\n use syntax::source_map::Span;\n \n@@ -191,7 +193,8 @@ declare_clippy_lint! {\n ///\n /// **Why is this bad?** New enum variants added by library updates can be missed.\n ///\n-/// **Known problems:** Nested wildcards a la `Foo(_)` are currently not detected.\n+/// **Known problems:** Suggested replacements may be incorrect if guards exhaustively cover some\n+/// variants, and also may not use correct path to enum if it's not present in the current scope.\n ///\n /// **Example:**\n /// ```rust\n@@ -464,19 +467,85 @@ fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n }\n \n fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n-    if cx.tables.expr_ty(ex).is_enum() {\n+    let ty = cx.tables.expr_ty(ex);\n+    if !ty.is_enum() {\n+        // If there isn't a nice closed set of possible values that can be conveniently enumerated,\n+        // don't complain about not enumerating the mall.\n+        return;\n+    }\n+\n+    // First pass - check for violation, but don't do much book-keeping because this is hopefully\n+    // the uncommon case, and the book-keeping is slightly expensive.\n+    let mut wildcard_span = None;\n+    let mut wildcard_ident = None;\n+    for arm in arms {\n+        for pat in &arm.pats {\n+            if let PatKind::Wild = pat.node {\n+                wildcard_span = Some(pat.span);\n+            } else if let PatKind::Binding(_, _, ident, None) = pat.node {\n+                wildcard_span = Some(pat.span);\n+                wildcard_ident = Some(ident);\n+            }\n+        }\n+    }\n+\n+    if let Some(wildcard_span) = wildcard_span {\n+        // Accumulate the variants which should be put in place of the wildcard because they're not\n+        // already covered.\n+\n+        let mut missing_variants = vec![];\n+        if let TyKind::Adt(def, _) = ty.sty {\n+            for variant in &def.variants {\n+                missing_variants.push(variant);\n+            }\n+        }\n+\n         for arm in arms {\n-            if is_wild(&arm.pats[0]) {\n-                span_note_and_lint(\n-                    cx,\n-                    WILDCARD_ENUM_MATCH_ARM,\n-                    arm.pats[0].span,\n-                    \"wildcard match will miss any future added variants.\",\n-                    arm.pats[0].span,\n-                    \"to resolve, match each variant explicitly\",\n-                );\n+            if arm.guard.is_some() {\n+                // Guards mean that this case probably isn't exhaustively covered. Technically\n+                // this is incorrect, as we should really check whether each variant is exhaustively\n+                // covered by the set of guards that cover it, but that's really hard to do.\n+                continue;\n+            }\n+            for pat in &arm.pats {\n+                if let PatKind::Path(ref path) = pat.deref().node {\n+                    if let QPath::Resolved(_, p) = path {\n+                        missing_variants.retain(|e| e.did != p.def.def_id());\n+                    }\n+                } else if let PatKind::TupleStruct(ref path, ..) = pat.deref().node {\n+                    if let QPath::Resolved(_, p) = path {\n+                        missing_variants.retain(|e| e.did != p.def.def_id());\n+                    }\n+                }\n             }\n         }\n+\n+        let suggestion: Vec<String> = missing_variants\n+            .iter()\n+            .map(|v| {\n+                let suffix = match v.ctor_kind {\n+                    CtorKind::Fn => \"(..)\",\n+                    CtorKind::Const | CtorKind::Fictive => \"\",\n+                };\n+                let ident_str = if let Some(ident) = wildcard_ident {\n+                    format!(\"{} @ \", ident.name)\n+                } else {\n+                    String::new()\n+                };\n+                // This path assumes that the enum type is imported into scope.\n+                format!(\"{}{}{}\", ident_str, cx.tcx.item_path_str(v.did), suffix)\n+            })\n+            .collect();\n+\n+        span_lint_and_sugg(\n+            cx,\n+            WILDCARD_ENUM_MATCH_ARM,\n+            wildcard_span,\n+            \"wildcard match will miss any future added variants.\",\n+            \"try this\",\n+            suggestion.join(\" | \"),\n+            Applicability::MachineApplicable,\n+        )\n     }\n }\n "}, {"sha": "86d4c7f28c4e46fe0317d9ce991a2ff64abd6058", "filename": "tests/ui/wildcard_enum_match_arm.rs", "status": "modified", "additions": 68, "deletions": 37, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3/tests%2Fui%2Fwildcard_enum_match_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3/tests%2Fui%2Fwildcard_enum_match_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.rs?ref=422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3", "patch": "@@ -1,42 +1,73 @@\n-#![deny(clippy::wildcard_enum_match_arm)]\n-\n-#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n-enum Color {\n-    Red,\n-    Green,\n-    Blue,\n-    Rgb(u8, u8, u8),\n-    Cyan,\n-}\n-\n-impl Color {\n-    fn is_monochrome(self) -> bool {\n-        match self {\n-            Color::Red | Color::Green | Color::Blue => true,\n-            Color::Rgb(r, g, b) => r | g == 0 || r | b == 0 || g | b == 0,\n-            Color::Cyan => false,\n-        }\n+#![warn(clippy::wildcard_enum_match_arm)]\n+\n+#[derive(Debug)]\n+enum Maybe<T> {\n+    Some(T),\n+    Probably(T),\n+    None,\n+}\n+\n+fn is_it_wildcard<T>(m: Maybe<T>) -> &'static str {\n+    match m {\n+        Maybe::Some(_) => \"Some\",\n+        _ => \"Could be\",\n+    }\n+}\n+\n+fn is_it_bound<T>(m: Maybe<T>) -> &'static str {\n+    match m {\n+        Maybe::None => \"None\",\n+        _other => \"Could be\",\n+    }\n+}\n+\n+fn is_it_binding(m: Maybe<u32>) -> String {\n+    match m {\n+        Maybe::Some(v) => \"Large\".to_string(),\n+        n => format!(\"{:?}\", n),\n+    }\n+}\n+\n+fn is_it_binding_exhaustive(m: Maybe<u32>) -> String {\n+    match m {\n+        Maybe::Some(v) => \"Large\".to_string(),\n+        n @ Maybe::Probably(_) | n @ Maybe::None => format!(\"{:?}\", n),\n+    }\n+}\n+\n+fn is_it_with_guard(m: Maybe<u32>) -> &'static str {\n+    match m {\n+        Maybe::Some(v) if v > 100 => \"Large\",\n+        _ => \"Who knows\",\n+    }\n+}\n+\n+fn is_it_exhaustive<T>(m: Maybe<T>) -> &'static str {\n+    match m {\n+        Maybe::None => \"None\",\n+        Maybe::Some(_) | Maybe::Probably(..) => \"Could be\",\n+    }\n+}\n+\n+fn is_one_or_three(i: i32) -> bool {\n+    match i {\n+        1 | 3 => true,\n+        _ => false,\n     }\n }\n \n fn main() {\n-    let color = Color::Rgb(0, 0, 127);\n-    match color {\n-        Color::Red => println!(\"Red\"),\n-        _ => eprintln!(\"Not red\"),\n-    };\n-    match color {\n-        Color::Red => {},\n-        Color::Green => {},\n-        Color::Blue => {},\n-        Color::Cyan => {},\n-        c if c.is_monochrome() => {},\n-        Color::Rgb(_, _, _) => {},\n-    };\n-    let x: u8 = unimplemented!();\n-    match x {\n-        0 => {},\n-        140 => {},\n-        _ => {},\n-    };\n+    println!(\"{}\", is_it_wildcard(Maybe::Some(\"foo\")));\n+\n+    println!(\"{}\", is_it_bound(Maybe::Some(\"foo\")));\n+\n+    println!(\"{}\", is_it_binding(Maybe::Some(1)));\n+\n+    println!(\"{}\", is_it_binding_exhaustive(Maybe::Some(1)));\n+\n+    println!(\"{}\", is_it_with_guard(Maybe::Some(1)));\n+\n+    println!(\"{}\", is_it_exhaustive(Maybe::Some(\"foo\")));\n+\n+    println!(\"{}\", is_one_or_three(2));\n }"}, {"sha": "1d6f3f662a3ffd68b484c3e3ab4ec32c9deeece2", "filename": "tests/ui/wildcard_enum_match_arm.stderr", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.stderr?ref=422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3", "patch": "@@ -1,15 +1,28 @@\n error: wildcard match will miss any future added variants.\n-  --> $DIR/wildcard_enum_match_arm.rs:26:9\n+  --> $DIR/wildcard_enum_match_arm.rs:13:9\n    |\n-LL |         _ => eprintln!(\"Not red\"),\n-   |         ^\n+LL |         _ => \"Could be\",\n+   |         ^ help: try this: `Maybe::Probably(..) | Maybe::None`\n    |\n-note: lint level defined here\n-  --> $DIR/wildcard_enum_match_arm.rs:1:9\n+   = note: `-D clippy::wildcard-enum-match-arm` implied by `-D warnings`\n+\n+error: wildcard match will miss any future added variants.\n+  --> $DIR/wildcard_enum_match_arm.rs:20:9\n+   |\n+LL |         _other => \"Could be\",\n+   |         ^^^^^^ help: try this: `_other @ Maybe::Some(..) | _other @ Maybe::Probably(..)`\n+\n+error: wildcard match will miss any future added variants.\n+  --> $DIR/wildcard_enum_match_arm.rs:27:9\n+   |\n+LL |         n => format!(\"{:?}\", n),\n+   |         ^ help: try this: `n @ Maybe::Probably(..) | n @ Maybe::None`\n+\n+error: wildcard match will miss any future added variants.\n+  --> $DIR/wildcard_enum_match_arm.rs:41:9\n    |\n-LL | #![deny(clippy::wildcard_enum_match_arm)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: to resolve, match each variant explicitly\n+LL |         _ => \"Who knows\",\n+   |         ^ help: try this: `Maybe::Some(..) | Maybe::Probably(..) | Maybe::None`\n \n-error: aborting due to previous error\n+error: aborting due to 4 previous errors\n "}]}