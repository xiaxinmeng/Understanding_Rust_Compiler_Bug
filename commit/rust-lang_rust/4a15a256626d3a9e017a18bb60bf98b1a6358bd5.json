{"sha": "4a15a256626d3a9e017a18bb60bf98b1a6358bd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMTVhMjU2NjI2ZDNhOWUwMTdhMThiYjYwYmY5OGIxYTYzNThiZDU=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-10-22T08:32:41Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-10-22T08:43:28Z"}, "message": "min_const_generics: allow ty param in repeat expr", "tree": {"sha": "effd00f54809e111442e86d9cd02cee3e6b01213", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/effd00f54809e111442e86d9cd02cee3e6b01213"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a15a256626d3a9e017a18bb60bf98b1a6358bd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a15a256626d3a9e017a18bb60bf98b1a6358bd5", "html_url": "https://github.com/rust-lang/rust/commit/4a15a256626d3a9e017a18bb60bf98b1a6358bd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f0fa9d51ff4ad2c0869e660856cd327e79915e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f0fa9d51ff4ad2c0869e660856cd327e79915e9", "html_url": "https://github.com/rust-lang/rust/commit/8f0fa9d51ff4ad2c0869e660856cd327e79915e9"}], "stats": {"total": 230, "additions": 192, "deletions": 38}, "files": [{"sha": "d323aebe59798cc04de848bf7307bed502dbdef3", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 70, "deletions": 18, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=4a15a256626d3a9e017a18bb60bf98b1a6358bd5", "patch": "@@ -57,6 +57,12 @@ enum PatternSource {\n     FnParam,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum IsRepeatExpr {\n+    No,\n+    Yes,\n+}\n+\n impl PatternSource {\n     fn descr(self) -> &'static str {\n         match self {\n@@ -437,10 +443,8 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         self.resolve_block(block);\n     }\n     fn visit_anon_const(&mut self, constant: &'ast AnonConst) {\n-        debug!(\"visit_anon_const {:?}\", constant);\n-        self.with_constant_rib(constant.value.is_potential_trivial_const_param(), |this| {\n-            visit::walk_anon_const(this, constant);\n-        });\n+        // We deal with repeat expressions explicitly in `resolve_expr`.\n+        self.resolve_anon_const(constant, IsRepeatExpr::No);\n     }\n     fn visit_expr(&mut self, expr: &'ast Expr) {\n         self.resolve_expr(expr, None);\n@@ -647,7 +651,11 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         if !check_ns(TypeNS) && check_ns(ValueNS) {\n                             // This must be equivalent to `visit_anon_const`, but we cannot call it\n                             // directly due to visitor lifetimes so we have to copy-paste some code.\n-                            self.with_constant_rib(true, |this| {\n+                            //\n+                            // Note that we might not be inside of an repeat expression here,\n+                            // but considering that `IsRepeatExpr` is only relevant for\n+                            // non-trivial constants this is doesn't matter.\n+                            self.with_constant_rib(IsRepeatExpr::No, true, |this| {\n                                 this.smart_resolve_path(\n                                     ty.id,\n                                     qself.as_ref(),\n@@ -980,9 +988,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                             //\n                                             // Type parameters can already be used and as associated consts are\n                                             // not used as part of the type system, this is far less surprising.\n-                                            this.with_constant_rib(true, |this| {\n-                                                this.visit_expr(expr)\n-                                            });\n+                                            this.with_constant_rib(\n+                                                IsRepeatExpr::No,\n+                                                true,\n+                                                |this| this.visit_expr(expr),\n+                                            );\n                                         }\n                                     }\n                                     AssocItemKind::Fn(_, _, generics, _) => {\n@@ -1023,7 +1033,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.with_item_rib(HasGenericParams::No, |this| {\n                     this.visit_ty(ty);\n                     if let Some(expr) = expr {\n-                        this.with_constant_rib(expr.is_potential_trivial_const_param(), |this| {\n+                        // We already forbid generic params because of the above item rib,\n+                        // so it doesn't matter whether this is a trivial constant.\n+                        this.with_constant_rib(IsRepeatExpr::No, true, |this| {\n                             this.visit_expr(expr)\n                         });\n                     }\n@@ -1122,12 +1134,29 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         self.with_rib(ValueNS, kind, |this| this.with_rib(TypeNS, kind, f))\n     }\n \n-    fn with_constant_rib(&mut self, trivial: bool, f: impl FnOnce(&mut Self)) {\n-        debug!(\"with_constant_rib\");\n-        self.with_rib(ValueNS, ConstantItemRibKind(trivial), |this| {\n-            this.with_rib(TypeNS, ConstantItemRibKind(trivial), |this| {\n-                this.with_label_rib(ConstantItemRibKind(trivial), f);\n-            })\n+    // HACK(min_const_generics,const_evaluatable_unchecked): We\n+    // want to keep allowing `[0; std::mem::size_of::<*mut T>()]`\n+    // with a future compat lint for now. We do this by adding an\n+    // additional special case for repeat expressions.\n+    //\n+    // Note that we intentionally still forbid `[0; N + 1]` during\n+    // name resolution so that we don't extend the future\n+    // compat lint to new cases.\n+    fn with_constant_rib(\n+        &mut self,\n+        is_repeat: IsRepeatExpr,\n+        is_trivial: bool,\n+        f: impl FnOnce(&mut Self),\n+    ) {\n+        debug!(\"with_constant_rib: is_repeat={:?} is_trivial={}\", is_repeat, is_trivial);\n+        self.with_rib(ValueNS, ConstantItemRibKind(is_trivial), |this| {\n+            this.with_rib(\n+                TypeNS,\n+                ConstantItemRibKind(is_repeat == IsRepeatExpr::Yes || is_trivial),\n+                |this| {\n+                    this.with_label_rib(ConstantItemRibKind(is_trivial), f);\n+                },\n+            )\n         });\n     }\n \n@@ -1272,9 +1301,17 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                             //\n                                             // Type parameters can already be used and as associated consts are\n                                             // not used as part of the type system, this is far less surprising.\n-                                            this.with_constant_rib(true, |this| {\n-                                                visit::walk_assoc_item(this, item, AssocCtxt::Impl)\n-                                            });\n+                                            this.with_constant_rib(\n+                                                IsRepeatExpr::No,\n+                                                true,\n+                                                |this| {\n+                                                    visit::walk_assoc_item(\n+                                                        this,\n+                                                        item,\n+                                                        AssocCtxt::Impl,\n+                                                    )\n+                                                },\n+                                            );\n                                         }\n                                         AssocItemKind::Fn(_, _, generics, _) => {\n                                             // We also need a new scope for the impl item type parameters.\n@@ -2199,6 +2236,17 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         debug!(\"(resolving block) leaving block\");\n     }\n \n+    fn resolve_anon_const(&mut self, constant: &'ast AnonConst, is_repeat: IsRepeatExpr) {\n+        debug!(\"resolve_anon_const {:?} is_repeat: {:?}\", constant, is_repeat);\n+        self.with_constant_rib(\n+            is_repeat,\n+            constant.value.is_potential_trivial_const_param(),\n+            |this| {\n+                visit::walk_anon_const(this, constant);\n+            },\n+        );\n+    }\n+\n     fn resolve_expr(&mut self, expr: &'ast Expr, parent: Option<&'ast Expr>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n@@ -2322,6 +2370,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ExprKind::Async(..) | ExprKind::Closure(..) => {\n                 self.with_label_rib(ClosureOrAsyncRibKind, |this| visit::walk_expr(this, expr));\n             }\n+            ExprKind::Repeat(ref elem, ref ct) => {\n+                self.visit_expr(elem);\n+                self.resolve_anon_const(ct, IsRepeatExpr::Yes);\n+            }\n             _ => {\n                 visit::walk_expr(self, expr);\n             }"}, {"sha": "865eaf749326764fd36b94e16d68d45600451d99", "filename": "src/test/ui/const-generics/issues/issue-62504.min.stderr", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.min.stderr?ref=4a15a256626d3a9e017a18bb60bf98b1a6358bd5", "patch": "@@ -1,14 +1,20 @@\n-error: generic `Self` types are currently not permitted in anonymous constants\n+error[E0308]: mismatched types\n+  --> $DIR/issue-62504.rs:19:21\n+   |\n+LL |         ArrayHolder([0; Self::SIZE])\n+   |                     ^^^^^^^^^^^^^^^ expected `X`, found `Self::SIZE`\n+   |\n+   = note: expected array `[u32; X]`\n+              found array `[u32; _]`\n+\n+error: constant expression depends on a generic parameter\n   --> $DIR/issue-62504.rs:19:25\n    |\n LL |         ArrayHolder([0; Self::SIZE])\n    |                         ^^^^^^^^^^\n    |\n-note: not a concrete type\n-  --> $DIR/issue-62504.rs:17:22\n-   |\n-LL | impl<const X: usize> ArrayHolder<X> {\n-   |                      ^^^^^^^^^^^^^^\n+   = note: this may fail depending on what value the parameter takes\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "5630962ff53767ca8ff9b156640b464fbb9c5b90", "filename": "src/test/ui/const-generics/issues/issue-62504.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs?ref=4a15a256626d3a9e017a18bb60bf98b1a6358bd5", "patch": "@@ -17,8 +17,8 @@ struct ArrayHolder<const X: usize>([u32; X]);\n impl<const X: usize> ArrayHolder<X> {\n     pub const fn new() -> Self {\n         ArrayHolder([0; Self::SIZE])\n-        //[full]~^ ERROR constant expression depends on a generic parameter\n-        //[min]~^^ ERROR generic `Self` types are currently\n+        //~^ ERROR constant expression depends on a generic parameter\n+        //[min]~| ERROR mismatched types\n     }\n }\n "}, {"sha": "27a56b8eb02b2a0692f28bf6042155c77320600f", "filename": "src/test/ui/const-generics/issues/issue-67739.min.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.min.stderr?ref=4a15a256626d3a9e017a18bb60bf98b1a6358bd5", "patch": "@@ -1,10 +1,10 @@\n-error: generic parameters may not be used in const operations\n-  --> $DIR/issue-67739.rs:12:30\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-67739.rs:12:15\n    |\n LL |         [0u8; mem::size_of::<Self::Associated>()];\n-   |                              ^^^^^^^^^^^^^^^^ cannot perform const operation using `Self`\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: type parameters may not be used in const expressions\n+   = note: this may fail depending on what value the parameter takes\n \n error: aborting due to previous error\n "}, {"sha": "0f5860f22fdd34310f6132bda694682531ac76fe", "filename": "src/test/ui/const-generics/issues/issue-67739.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.rs?ref=4a15a256626d3a9e017a18bb60bf98b1a6358bd5", "patch": "@@ -10,8 +10,7 @@ pub trait Trait {\n \n     fn associated_size(&self) -> usize {\n         [0u8; mem::size_of::<Self::Associated>()];\n-        //[full]~^ ERROR constant expression depends on a generic parameter\n-        //[min]~^^ ERROR generic parameters may not be used in const operations\n+        //~^ ERROR constant expression depends on a generic parameter\n         0\n     }\n }"}, {"sha": "686ce98fcdff3f88f4a2a50a4ef7ee5e947067e4", "filename": "src/test/ui/const-generics/min_const_generics/complex-expression.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.rs?ref=4a15a256626d3a9e017a18bb60bf98b1a6358bd5", "patch": "@@ -1,5 +1,7 @@\n #![feature(min_const_generics)]\n \n+use std::mem::size_of;\n+\n fn test<const N: usize>() {}\n \n fn ok<const M: usize>() -> [u8; M] {\n@@ -22,6 +24,24 @@ fn break3<const N: usize>() {\n     //~^ ERROR generic parameters may not be used in const operations\n }\n \n+struct BreakTy0<T>(T, [u8; { size_of::<*mut T>() }]);\n+//~^ ERROR generic parameters may not be used in const operations\n+\n+struct BreakTy1<T>(T, [u8; { { size_of::<*mut T>() } }]);\n+//~^ ERROR generic parameters may not be used in const operations\n+\n+fn break_ty2<T>() {\n+    let _: [u8; size_of::<*mut T>() + 1];\n+    //~^ ERROR generic parameters may not be used in const operations\n+}\n+\n+fn break_ty3<T>() {\n+    let _ = [0; size_of::<*mut T>() + 1];\n+    //~^ WARN cannot use constants which depend on generic parameters in types\n+    //~| WARN this was previously accepted by the compiler but is being phased out\n+}\n+\n+\n trait Foo {\n     const ASSOC: usize;\n }"}, {"sha": "a8de987e1675ed2f2939c0a71a17f29c188be6e6", "filename": "src/test/ui/const-generics/min_const_generics/complex-expression.stderr", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.stderr?ref=4a15a256626d3a9e017a18bb60bf98b1a6358bd5", "patch": "@@ -1,34 +1,68 @@\n error: generic parameters may not be used in const operations\n-  --> $DIR/complex-expression.rs:9:38\n+  --> $DIR/complex-expression.rs:11:38\n    |\n LL | struct Break0<const N: usize>([u8; { N + 1 }]);\n    |                                      ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n \n error: generic parameters may not be used in const operations\n-  --> $DIR/complex-expression.rs:12:40\n+  --> $DIR/complex-expression.rs:14:40\n    |\n LL | struct Break1<const N: usize>([u8; { { N } }]);\n    |                                        ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n \n error: generic parameters may not be used in const operations\n-  --> $DIR/complex-expression.rs:16:17\n+  --> $DIR/complex-expression.rs:18:17\n    |\n LL |     let _: [u8; N + 1];\n    |                 ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n \n error: generic parameters may not be used in const operations\n-  --> $DIR/complex-expression.rs:21:17\n+  --> $DIR/complex-expression.rs:23:17\n    |\n LL |     let _ = [0; N + 1];\n    |                 ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n \n-error: aborting due to 4 previous errors\n+error: generic parameters may not be used in const operations\n+  --> $DIR/complex-expression.rs:27:45\n+   |\n+LL | struct BreakTy0<T>(T, [u8; { size_of::<*mut T>() }]);\n+   |                                             ^ cannot perform const operation using `T`\n+   |\n+   = note: type parameters may not be used in const expressions\n+\n+error: generic parameters may not be used in const operations\n+  --> $DIR/complex-expression.rs:30:47\n+   |\n+LL | struct BreakTy1<T>(T, [u8; { { size_of::<*mut T>() } }]);\n+   |                                               ^ cannot perform const operation using `T`\n+   |\n+   = note: type parameters may not be used in const expressions\n+\n+error: generic parameters may not be used in const operations\n+  --> $DIR/complex-expression.rs:34:32\n+   |\n+LL |     let _: [u8; size_of::<*mut T>() + 1];\n+   |                                ^ cannot perform const operation using `T`\n+   |\n+   = note: type parameters may not be used in const expressions\n+\n+warning: cannot use constants which depend on generic parameters in types\n+  --> $DIR/complex-expression.rs:39:17\n+   |\n+LL |     let _ = [0; size_of::<*mut T>() + 1];\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(const_evaluatable_unchecked)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #76200 <https://github.com/rust-lang/rust/issues/76200>\n+\n+error: aborting due to 7 previous errors; 1 warning emitted\n "}, {"sha": "4e99a098a34fe1af59b6c3ea49daddaca2e22917", "filename": "src/test/ui/const-generics/min_const_generics/const-evaluatable-unchecked.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-evaluatable-unchecked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-evaluatable-unchecked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-evaluatable-unchecked.rs?ref=4a15a256626d3a9e017a18bb60bf98b1a6358bd5", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+#![allow(dead_code)]\n+\n+fn foo<T>() {\n+    [0; std::mem::size_of::<*mut T>()];\n+    //~^ WARN cannot use constants which depend on generic parameters in types\n+    //~| WARN this was previously accepted by the compiler but is being phased out\n+}\n+\n+struct Foo<T>(T);\n+\n+impl<T> Foo<T> {\n+    const ASSOC: usize = 4;\n+\n+    fn test() {\n+        [0; Self::ASSOC];\n+        //~^ WARN cannot use constants which depend on generic parameters in types\n+        //~| WARN this was previously accepted by the compiler but is being phased out\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f493f0da040b9d95f93b0178537ee670340f6044", "filename": "src/test/ui/const-generics/min_const_generics/const-evaluatable-unchecked.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-evaluatable-unchecked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4a15a256626d3a9e017a18bb60bf98b1a6358bd5/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-evaluatable-unchecked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-evaluatable-unchecked.stderr?ref=4a15a256626d3a9e017a18bb60bf98b1a6358bd5", "patch": "@@ -0,0 +1,21 @@\n+warning: cannot use constants which depend on generic parameters in types\n+  --> $DIR/const-evaluatable-unchecked.rs:5:9\n+   |\n+LL |     [0; std::mem::size_of::<*mut T>()];\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(const_evaluatable_unchecked)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #76200 <https://github.com/rust-lang/rust/issues/76200>\n+\n+warning: cannot use constants which depend on generic parameters in types\n+  --> $DIR/const-evaluatable-unchecked.rs:16:13\n+   |\n+LL |         [0; Self::ASSOC];\n+   |             ^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #76200 <https://github.com/rust-lang/rust/issues/76200>\n+\n+warning: 2 warnings emitted\n+"}]}