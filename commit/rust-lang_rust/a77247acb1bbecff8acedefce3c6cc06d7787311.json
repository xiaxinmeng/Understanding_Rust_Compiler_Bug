{"sha": "a77247acb1bbecff8acedefce3c6cc06d7787311", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3NzI0N2FjYjFiYmVjZmY4YWNlZGVmY2UzYzZjYzA2ZDc3ODczMTE=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-08-11T20:11:53Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-08-26T22:51:34Z"}, "message": "Move source HTML generation to own module", "tree": {"sha": "19ec9567804c1153d10c5fba1b9b2f0da50787c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19ec9567804c1153d10c5fba1b9b2f0da50787c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a77247acb1bbecff8acedefce3c6cc06d7787311", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a77247acb1bbecff8acedefce3c6cc06d7787311", "html_url": "https://github.com/rust-lang/rust/commit/a77247acb1bbecff8acedefce3c6cc06d7787311", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a77247acb1bbecff8acedefce3c6cc06d7787311/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b91b9c10e3c87ed333a1e34c4f46ed68f1eee06", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b91b9c10e3c87ed333a1e34c4f46ed68f1eee06", "html_url": "https://github.com/rust-lang/rust/commit/9b91b9c10e3c87ed333a1e34c4f46ed68f1eee06"}], "stats": {"total": 367, "additions": 194, "deletions": 173}, "files": [{"sha": "c8921a92d33820890516db3a98bb3596cc189a9f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 6, "deletions": 173, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/a77247acb1bbecff8acedefce3c6cc06d7787311/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77247acb1bbecff8acedefce3c6cc06d7787311/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=a77247acb1bbecff8acedefce3c6cc06d7787311", "patch": "@@ -72,6 +72,7 @@ use crate::html::format::fmt_impl_for_trait_page;\n use crate::html::item_type::ItemType;\n use crate::html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes, IdMap};\n use crate::html::{highlight, layout, static_files};\n+use crate::html::sources;\n \n use minifier;\n \n@@ -173,7 +174,7 @@ struct Context {\n     playground: Option<markdown::Playground>,\n }\n \n-struct SharedContext {\n+crate struct SharedContext {\n     /// The path to the crate root source minus the file name.\n     /// Used for simplifying paths to the highlighted source code files.\n     pub src_root: PathBuf,\n@@ -218,7 +219,7 @@ struct SharedContext {\n }\n \n impl SharedContext {\n-    fn ensure_dir(&self, dst: &Path) -> Result<(), Error> {\n+    crate fn ensure_dir(&self, dst: &Path) -> Result<(), Error> {\n         let mut dirs = self.created_dirs.borrow_mut();\n         if !dirs.contains(dst) {\n             try_err!(self.fs.create_dir_all(dst), dst);\n@@ -389,18 +390,6 @@ pub struct RenderInfo {\n     pub owned_box_did: Option<DefId>,\n }\n \n-/// Helper struct to render all source code to HTML pages\n-struct SourceCollector<'a> {\n-    scx: &'a mut SharedContext,\n-\n-    /// Root destination to place all HTML output into\n-    dst: PathBuf,\n-}\n-\n-/// Wrapper struct to render the source code of a file. This will do things like\n-/// adding line numbers to the left-hand side.\n-struct Source<'a>(&'a str);\n-\n // Helper structs for rendering items/sidebars and carrying along contextual\n // information\n \n@@ -612,7 +601,7 @@ pub fn run(mut krate: clean::Crate,\n     }\n     let dst = output;\n     scx.ensure_dir(&dst)?;\n-    krate = render_sources(&dst, &mut scx, krate)?;\n+    krate = sources::render(&dst, &mut scx, krate)?;\n     let mut cx = Context {\n         current: Vec::new(),\n         dst,\n@@ -1293,18 +1282,6 @@ themePicker.onblur = handleThemeButtonsBlur;\n     Ok(())\n }\n \n-fn render_sources(dst: &Path, scx: &mut SharedContext,\n-                  krate: clean::Crate) -> Result<clean::Crate, Error> {\n-    info!(\"emitting source files\");\n-    let dst = dst.join(\"src\").join(&krate.name);\n-    scx.ensure_dir(&dst)?;\n-    let mut folder = SourceCollector {\n-        dst,\n-        scx,\n-    };\n-    Ok(folder.fold_crate(krate))\n-}\n-\n fn write_minify(fs:&DocFS, dst: PathBuf, contents: &str, enable_minification: bool\n                 ) -> Result<(), Error> {\n     if enable_minification {\n@@ -1384,33 +1361,6 @@ fn write_minify_replacer<W: Write>(\n     }\n }\n \n-/// Takes a path to a source file and cleans the path to it. This canonicalizes\n-/// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n-/// static HTML tree. Each component in the cleaned path will be passed as an\n-/// argument to `f`. The very last component of the path (ie the file name) will\n-/// be passed to `f` if `keep_filename` is true, and ignored otherwise.\n-fn clean_srcpath<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n-where\n-    F: FnMut(&OsStr),\n-{\n-    // make it relative, if possible\n-    let p = p.strip_prefix(src_root).unwrap_or(p);\n-\n-    let mut iter = p.components().peekable();\n-\n-    while let Some(c) = iter.next() {\n-        if !keep_filename && iter.peek().is_none() {\n-            break;\n-        }\n-\n-        match c {\n-            Component::ParentDir => f(\"up\".as_ref()),\n-            Component::Normal(c) => f(c),\n-            _ => continue,\n-        }\n-    }\n-}\n-\n /// Attempts to find where an external crate is located, given that we're\n /// rendering in to the specified source destination.\n fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Path)\n@@ -1444,102 +1394,6 @@ fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Pat\n     }).next().unwrap_or(Unknown) // Well, at least we tried.\n }\n \n-impl<'a> DocFolder for SourceCollector<'a> {\n-    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        // If we're including source files, and we haven't seen this file yet,\n-        // then we need to render it out to the filesystem.\n-        if self.scx.include_sources\n-            // skip all invalid or macro spans\n-            && item.source.filename.is_real()\n-            // skip non-local items\n-            && item.def_id.is_local() {\n-\n-            // If it turns out that we couldn't read this file, then we probably\n-            // can't read any of the files (generating html output from json or\n-            // something like that), so just don't include sources for the\n-            // entire crate. The other option is maintaining this mapping on a\n-            // per-file basis, but that's probably not worth it...\n-            self.scx\n-                .include_sources = match self.emit_source(&item.source.filename) {\n-                Ok(()) => true,\n-                Err(e) => {\n-                    println!(\"warning: source code was requested to be rendered, \\\n-                              but processing `{}` had an error: {}\",\n-                             item.source.filename, e);\n-                    println!(\"         skipping rendering of source code\");\n-                    false\n-                }\n-            };\n-        }\n-        self.fold_item_recur(item)\n-    }\n-}\n-\n-impl<'a> SourceCollector<'a> {\n-    /// Renders the given filename into its corresponding HTML source file.\n-    fn emit_source(&mut self, filename: &FileName) -> Result<(), Error> {\n-        let p = match *filename {\n-            FileName::Real(ref file) => file,\n-            _ => return Ok(()),\n-        };\n-        if self.scx.local_sources.contains_key(&**p) {\n-            // We've already emitted this source\n-            return Ok(());\n-        }\n-\n-        let contents = try_err!(fs::read_to_string(&p), &p);\n-\n-        // Remove the utf-8 BOM if any\n-        let contents = if contents.starts_with(\"\\u{feff}\") {\n-            &contents[3..]\n-        } else {\n-            &contents[..]\n-        };\n-\n-        // Create the intermediate directories\n-        let mut cur = self.dst.clone();\n-        let mut root_path = String::from(\"../../\");\n-        let mut href = String::new();\n-        clean_srcpath(&self.scx.src_root, &p, false, |component| {\n-            cur.push(component);\n-            root_path.push_str(\"../\");\n-            href.push_str(&component.to_string_lossy());\n-            href.push('/');\n-        });\n-        self.scx.ensure_dir(&cur)?;\n-        let mut fname = p.file_name()\n-                         .expect(\"source has no filename\")\n-                         .to_os_string();\n-        fname.push(\".html\");\n-        cur.push(&fname);\n-        href.push_str(&fname.to_string_lossy());\n-\n-        let mut v = Vec::new();\n-        let title = format!(\"{} -- source\", cur.file_name().expect(\"failed to get file name\")\n-                                               .to_string_lossy());\n-        let desc = format!(\"Source to the Rust file `{}`.\", filename);\n-        let page = layout::Page {\n-            title: &title,\n-            css_class: \"source\",\n-            root_path: &root_path,\n-            static_root_path: self.scx.static_root_path.as_deref(),\n-            description: &desc,\n-            keywords: BASIC_KEYWORDS,\n-            resource_suffix: &self.scx.resource_suffix,\n-            extra_scripts: &[&format!(\"source-files{}\", self.scx.resource_suffix)],\n-            static_extra_scripts: &[&format!(\"source-script{}\", self.scx.resource_suffix)],\n-        };\n-        try_err!(layout::render(&mut v, &self.scx.layout,\n-                       &page, &(\"\"), &Source(contents),\n-                       self.scx.css_file_extension.is_some(),\n-                       &self.scx.themes,\n-                       self.scx.generate_search_filter), &cur);\n-        self.scx.fs.write(&cur, &v)?;\n-        self.scx.local_sources.insert(p.clone(), href);\n-        Ok(())\n-    }\n-}\n-\n impl DocFolder for Cache {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         if item.def_id.is_local() {\n@@ -2399,7 +2253,7 @@ impl<'a> Item<'a> {\n                 (_, _, Unknown) => return None,\n             };\n \n-            clean_srcpath(&src_root, file, false, |component| {\n+            sources::clean_path(&src_root, file, false, |component| {\n                 path.push_str(&component.to_string_lossy());\n                 path.push('/');\n             });\n@@ -5048,27 +4902,6 @@ fn sidebar_foreign_type(fmt: &mut fmt::Formatter<'_>, it: &clean::Item) -> fmt::\n     Ok(())\n }\n \n-impl<'a> fmt::Display for Source<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let Source(s) = *self;\n-        let lines = s.lines().count();\n-        let mut cols = 0;\n-        let mut tmp = lines;\n-        while tmp > 0 {\n-            cols += 1;\n-            tmp /= 10;\n-        }\n-        write!(fmt, \"<pre class=\\\"line-numbers\\\">\")?;\n-        for i in 1..=lines {\n-            write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols)?;\n-        }\n-        write!(fmt, \"</pre>\")?;\n-        write!(fmt, \"{}\",\n-               highlight::render_with_highlighting(s, None, None, None))?;\n-        Ok(())\n-    }\n-}\n-\n fn item_macro(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n     wrap_into_docblock(w, |w| {\n@@ -5125,7 +4958,7 @@ fn item_keyword(w: &mut fmt::Formatter<'_>, cx: &Context,\n     document(w, cx, it)\n }\n \n-const BASIC_KEYWORDS: &'static str = \"rust, rustlang, rust-lang\";\n+crate const BASIC_KEYWORDS: &'static str = \"rust, rustlang, rust-lang\";\n \n fn make_item_keywords(it: &clean::Item) -> String {\n     format!(\"{}, {}\", BASIC_KEYWORDS, it.name.as_ref().unwrap())"}, {"sha": "c1f1f59d9149a715e3d5235f3ede1e2d600a7956", "filename": "src/librustdoc/html/sources.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/a77247acb1bbecff8acedefce3c6cc06d7787311/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77247acb1bbecff8acedefce3c6cc06d7787311/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=a77247acb1bbecff8acedefce3c6cc06d7787311", "patch": "@@ -0,0 +1,187 @@\n+use crate::clean;\n+use crate::docfs::PathError;\n+use crate::fold::DocFolder;\n+use crate::html::layout;\n+use crate::html::render::{Error, SharedContext, BASIC_KEYWORDS};\n+use crate::html::highlight;\n+use std::ffi::OsStr;\n+use std::fs;\n+use std::path::{Component, Path, PathBuf};\n+use std::fmt;\n+use syntax::source_map::FileName;\n+\n+crate fn render(dst: &Path, scx: &mut SharedContext,\n+                  krate: clean::Crate) -> Result<clean::Crate, Error> {\n+    info!(\"emitting source files\");\n+    let dst = dst.join(\"src\").join(&krate.name);\n+    scx.ensure_dir(&dst)?;\n+    let mut folder = SourceCollector {\n+        dst,\n+        scx,\n+    };\n+    Ok(folder.fold_crate(krate))\n+}\n+\n+/// Helper struct to render all source code to HTML pages\n+struct SourceCollector<'a> {\n+    scx: &'a mut SharedContext,\n+\n+    /// Root destination to place all HTML output into\n+    dst: PathBuf,\n+}\n+\n+impl<'a> DocFolder for SourceCollector<'a> {\n+    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        // If we're including source files, and we haven't seen this file yet,\n+        // then we need to render it out to the filesystem.\n+        if self.scx.include_sources\n+            // skip all invalid or macro spans\n+            && item.source.filename.is_real()\n+            // skip non-local items\n+            && item.def_id.is_local() {\n+\n+            // If it turns out that we couldn't read this file, then we probably\n+            // can't read any of the files (generating html output from json or\n+            // something like that), so just don't include sources for the\n+            // entire crate. The other option is maintaining this mapping on a\n+            // per-file basis, but that's probably not worth it...\n+            self.scx\n+                .include_sources = match self.emit_source(&item.source.filename) {\n+                Ok(()) => true,\n+                Err(e) => {\n+                    println!(\"warning: source code was requested to be rendered, \\\n+                              but processing `{}` had an error: {}\",\n+                             item.source.filename, e);\n+                    println!(\"         skipping rendering of source code\");\n+                    false\n+                }\n+            };\n+        }\n+        self.fold_item_recur(item)\n+    }\n+}\n+\n+impl<'a> SourceCollector<'a> {\n+    /// Renders the given filename into its corresponding HTML source file.\n+    fn emit_source(&mut self, filename: &FileName) -> Result<(), Error> {\n+        let p = match *filename {\n+            FileName::Real(ref file) => file,\n+            _ => return Ok(()),\n+        };\n+        if self.scx.local_sources.contains_key(&**p) {\n+            // We've already emitted this source\n+            return Ok(());\n+        }\n+\n+        let contents = match fs::read_to_string(&p) {\n+            Ok(contents) => contents,\n+            Err(e) => {\n+                return Err(Error::new(e, &p));\n+            }\n+        };\n+\n+        // Remove the utf-8 BOM if any\n+        let contents = if contents.starts_with(\"\\u{feff}\") {\n+            &contents[3..]\n+        } else {\n+            &contents[..]\n+        };\n+\n+        // Create the intermediate directories\n+        let mut cur = self.dst.clone();\n+        let mut root_path = String::from(\"../../\");\n+        let mut href = String::new();\n+        clean_path(&self.scx.src_root, &p, false, |component| {\n+            cur.push(component);\n+            root_path.push_str(\"../\");\n+            href.push_str(&component.to_string_lossy());\n+            href.push('/');\n+        });\n+        self.scx.ensure_dir(&cur)?;\n+        let mut fname = p.file_name()\n+                         .expect(\"source has no filename\")\n+                         .to_os_string();\n+        fname.push(\".html\");\n+        cur.push(&fname);\n+        href.push_str(&fname.to_string_lossy());\n+\n+        let mut v = Vec::new();\n+        let title = format!(\"{} -- source\", cur.file_name().expect(\"failed to get file name\")\n+                                               .to_string_lossy());\n+        let desc = format!(\"Source to the Rust file `{}`.\", filename);\n+        let page = layout::Page {\n+            title: &title,\n+            css_class: \"source\",\n+            root_path: &root_path,\n+            static_root_path: self.scx.static_root_path.as_deref(),\n+            description: &desc,\n+            keywords: BASIC_KEYWORDS,\n+            resource_suffix: &self.scx.resource_suffix,\n+            extra_scripts: &[&format!(\"source-files{}\", self.scx.resource_suffix)],\n+            static_extra_scripts: &[&format!(\"source-script{}\", self.scx.resource_suffix)],\n+        };\n+        let result = layout::render(&mut v, &self.scx.layout,\n+                       &page, &(\"\"), &Source(contents),\n+                       self.scx.css_file_extension.is_some(),\n+                       &self.scx.themes,\n+                       self.scx.generate_search_filter);\n+        if let Err(e) = result {\n+            return Err(Error::new(e, &cur));\n+        }\n+        self.scx.fs.write(&cur, &v)?;\n+        self.scx.local_sources.insert(p.clone(), href);\n+        Ok(())\n+    }\n+}\n+\n+/// Takes a path to a source file and cleans the path to it. This canonicalizes\n+/// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n+/// static HTML tree. Each component in the cleaned path will be passed as an\n+/// argument to `f`. The very last component of the path (ie the file name) will\n+/// be passed to `f` if `keep_filename` is true, and ignored otherwise.\n+pub fn clean_path<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n+where\n+    F: FnMut(&OsStr),\n+{\n+    // make it relative, if possible\n+    let p = p.strip_prefix(src_root).unwrap_or(p);\n+\n+    let mut iter = p.components().peekable();\n+\n+    while let Some(c) = iter.next() {\n+        if !keep_filename && iter.peek().is_none() {\n+            break;\n+        }\n+\n+        match c {\n+            Component::ParentDir => f(\"up\".as_ref()),\n+            Component::Normal(c) => f(c),\n+            _ => continue,\n+        }\n+    }\n+}\n+\n+/// Wrapper struct to render the source code of a file. This will do things like\n+/// adding line numbers to the left-hand side.\n+struct Source<'a>(&'a str);\n+\n+impl<'a> fmt::Display for Source<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let Source(s) = *self;\n+        let lines = s.lines().count();\n+        let mut cols = 0;\n+        let mut tmp = lines;\n+        while tmp > 0 {\n+            cols += 1;\n+            tmp /= 10;\n+        }\n+        write!(fmt, \"<pre class=\\\"line-numbers\\\">\")?;\n+        for i in 1..=lines {\n+            write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols)?;\n+        }\n+        write!(fmt, \"</pre>\")?;\n+        write!(fmt, \"{}\",\n+               highlight::render_with_highlighting(s, None, None, None))?;\n+        Ok(())\n+    }\n+}"}, {"sha": "968578f957c5c85c462b5292258b9abccf7df952", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a77247acb1bbecff8acedefce3c6cc06d7787311/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77247acb1bbecff8acedefce3c6cc06d7787311/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=a77247acb1bbecff8acedefce3c6cc06d7787311", "patch": "@@ -67,6 +67,7 @@ pub mod html {\n     crate mod render;\n     crate mod static_files;\n     crate mod toc;\n+    crate mod sources;\n }\n mod markdown;\n mod passes;"}]}