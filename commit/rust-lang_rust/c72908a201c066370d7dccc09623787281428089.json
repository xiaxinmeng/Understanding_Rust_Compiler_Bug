{"sha": "c72908a201c066370d7dccc09623787281428089", "node_id": "C_kwDOAAsO6NoAKGM3MjkwOGEyMDFjMDY2MzcwZDdkY2NjMDk2MjM3ODcyODE0MjgwODk", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2022-01-02T15:46:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2022-01-02T15:46:01Z"}, "message": "more intuitive order", "tree": {"sha": "cfc6995b4676f8db4178efa626d0d5d7bff3cb71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfc6995b4676f8db4178efa626d0d5d7bff3cb71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c72908a201c066370d7dccc09623787281428089", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c72908a201c066370d7dccc09623787281428089", "html_url": "https://github.com/rust-lang/rust/commit/c72908a201c066370d7dccc09623787281428089", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c72908a201c066370d7dccc09623787281428089/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d846afdeef167679b89e14bb420826f3496df000", "url": "https://api.github.com/repos/rust-lang/rust/commits/d846afdeef167679b89e14bb420826f3496df000", "html_url": "https://github.com/rust-lang/rust/commit/d846afdeef167679b89e14bb420826f3496df000"}], "stats": {"total": 86, "additions": 43, "deletions": 43}, "files": [{"sha": "cff4ca4ba294c804010eeb525e248bed18d0d0fc", "filename": "crates/parser/src/lib.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c72908a201c066370d7dccc09623787281428089/crates%2Fparser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72908a201c066370d7dccc09623787281428089/crates%2Fparser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flib.rs?ref=c72908a201c066370d7dccc09623787281428089", "patch": "@@ -41,48 +41,6 @@ pub use crate::{\n     syntax_kind::SyntaxKind,\n };\n \n-/// Parse a prefix of the input as a given syntactic construct.\n-///\n-/// This is used by macro-by-example parser to implement things like `$i:item`\n-/// and the naming of variants follows the naming of macro fragments.\n-///\n-/// Note that this is generally non-optional -- the result is intentionally not\n-/// `Option<Output>`. The way MBE work, by the time we *try* to parse `$e:expr`\n-/// we already commit to expression. In other words, this API by design can't be\n-/// used to implement \"rollback and try another alternative\" logic.\n-#[derive(Debug)]\n-pub enum PrefixEntryPoint {\n-    Vis,\n-    Block,\n-    Stmt,\n-    Pat,\n-    Ty,\n-    Expr,\n-    Path,\n-    Item,\n-    MetaItem,\n-}\n-\n-impl PrefixEntryPoint {\n-    pub fn parse(&self, input: &Input) -> Output {\n-        let entry_point: fn(&'_ mut parser::Parser) = match self {\n-            PrefixEntryPoint::Vis => grammar::entry::prefix::vis,\n-            PrefixEntryPoint::Block => grammar::entry::prefix::block,\n-            PrefixEntryPoint::Stmt => grammar::entry::prefix::stmt,\n-            PrefixEntryPoint::Pat => grammar::entry::prefix::pat,\n-            PrefixEntryPoint::Ty => grammar::entry::prefix::ty,\n-            PrefixEntryPoint::Expr => grammar::entry::prefix::expr,\n-            PrefixEntryPoint::Path => grammar::entry::prefix::path,\n-            PrefixEntryPoint::Item => grammar::entry::prefix::item,\n-            PrefixEntryPoint::MetaItem => grammar::entry::prefix::meta_item,\n-        };\n-        let mut p = parser::Parser::new(input);\n-        entry_point(&mut p);\n-        let events = p.finish();\n-        event::process(events)\n-    }\n-}\n-\n /// Parse the whole of the input as a given syntactic construct.\n ///\n /// This covers two main use-cases:\n@@ -152,6 +110,48 @@ impl TopEntryPoint {\n     }\n }\n \n+/// Parse a prefix of the input as a given syntactic construct.\n+///\n+/// This is used by macro-by-example parser to implement things like `$i:item`\n+/// and the naming of variants follows the naming of macro fragments.\n+///\n+/// Note that this is generally non-optional -- the result is intentionally not\n+/// `Option<Output>`. The way MBE work, by the time we *try* to parse `$e:expr`\n+/// we already commit to expression. In other words, this API by design can't be\n+/// used to implement \"rollback and try another alternative\" logic.\n+#[derive(Debug)]\n+pub enum PrefixEntryPoint {\n+    Vis,\n+    Block,\n+    Stmt,\n+    Pat,\n+    Ty,\n+    Expr,\n+    Path,\n+    Item,\n+    MetaItem,\n+}\n+\n+impl PrefixEntryPoint {\n+    pub fn parse(&self, input: &Input) -> Output {\n+        let entry_point: fn(&'_ mut parser::Parser) = match self {\n+            PrefixEntryPoint::Vis => grammar::entry::prefix::vis,\n+            PrefixEntryPoint::Block => grammar::entry::prefix::block,\n+            PrefixEntryPoint::Stmt => grammar::entry::prefix::stmt,\n+            PrefixEntryPoint::Pat => grammar::entry::prefix::pat,\n+            PrefixEntryPoint::Ty => grammar::entry::prefix::ty,\n+            PrefixEntryPoint::Expr => grammar::entry::prefix::expr,\n+            PrefixEntryPoint::Path => grammar::entry::prefix::path,\n+            PrefixEntryPoint::Item => grammar::entry::prefix::item,\n+            PrefixEntryPoint::MetaItem => grammar::entry::prefix::meta_item,\n+        };\n+        let mut p = parser::Parser::new(input);\n+        entry_point(&mut p);\n+        let events = p.finish();\n+        event::process(events)\n+    }\n+}\n+\n /// A parsing function for a specific braced-block.\n pub struct Reparser(fn(&mut parser::Parser));\n "}, {"sha": "cb25abdfeae9dc245776d3576bf1c301cb8873e7", "filename": "crates/parser/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c72908a201c066370d7dccc09623787281428089/crates%2Fparser%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72908a201c066370d7dccc09623787281428089/crates%2Fparser%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Ftests.rs?ref=c72908a201c066370d7dccc09623787281428089", "patch": "@@ -1,6 +1,6 @@\n mod sourcegen_inline_tests;\n-mod prefix_entries;\n mod top_entries;\n+mod prefix_entries;\n \n use std::{\n     fmt::Write,"}]}