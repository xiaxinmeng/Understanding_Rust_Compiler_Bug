{"sha": "42f8a3366a8e687ac1df804f41cfe1d980ce9987", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyZjhhMzM2NmE4ZTY4N2FjMWRmODA0ZjQxY2ZlMWQ5ODBjZTk5ODc=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-12-08T05:14:20Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-12-09T07:04:38Z"}, "message": "Print out a more helpful type error message for do-blocks/for-loops\n\nIf a do-block body has the wrong type, or a for-loop body has a\nnon-() type, suggest that the user might have meant the other one.\n\nCloses #2817\n\nr=brson", "tree": {"sha": "bb82f47fbd7beebdd8bc87be71de9eec4b380462", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb82f47fbd7beebdd8bc87be71de9eec4b380462"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42f8a3366a8e687ac1df804f41cfe1d980ce9987", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42f8a3366a8e687ac1df804f41cfe1d980ce9987", "html_url": "https://github.com/rust-lang/rust/commit/42f8a3366a8e687ac1df804f41cfe1d980ce9987", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42f8a3366a8e687ac1df804f41cfe1d980ce9987/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6630d75a1d39aa7fedc924676eb48a38010ddd92", "url": "https://api.github.com/repos/rust-lang/rust/commits/6630d75a1d39aa7fedc924676eb48a38010ddd92", "html_url": "https://github.com/rust-lang/rust/commit/6630d75a1d39aa7fedc924676eb48a38010ddd92"}], "stats": {"total": 133, "additions": 103, "deletions": 30}, "files": [{"sha": "a7e1da6ed7df7675899f7b7ea80227c36037576e", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42f8a3366a8e687ac1df804f41cfe1d980ce9987/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42f8a3366a8e687ac1df804f41cfe1d980ce9987/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=42f8a3366a8e687ac1df804f41cfe1d980ce9987", "patch": "@@ -14,13 +14,20 @@ use check::fn_ctxt;\n // don't.\n fn suptype(fcx: @fn_ctxt, sp: span,\n            expected: ty::t, actual: ty::t) {\n+    suptype_with_fn(fcx, sp, expected, actual,\n+        |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n+}\n+\n+fn suptype_with_fn(fcx: @fn_ctxt, sp: span,\n+           expected: ty::t, actual: ty::t,\n+                   handle_err: fn(span, ty::t, ty::t, &ty::type_err)) {\n \n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx(), false, sp,\n                           actual, expected) {\n       result::Ok(()) => { /* ok */ }\n       result::Err(ref err) => {\n-        fcx.report_mismatched_types(sp, expected, actual, err);\n+          handle_err(sp, expected, actual, err);\n       }\n     }\n }"}, {"sha": "d513221ba1d08d080dcf785d0e93eb9774f40c6b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 63, "deletions": 26, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/42f8a3366a8e687ac1df804f41cfe1d980ce9987/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42f8a3366a8e687ac1df804f41cfe1d980ce9987/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=42f8a3366a8e687ac1df804f41cfe1d980ce9987", "patch": "@@ -133,6 +133,8 @@ struct inherited {\n     adjustments: HashMap<ast::node_id, @ty::AutoAdjustment>\n }\n \n+enum FnKind { ForLoop, DoBlock, Vanilla }\n+\n struct fn_ctxt {\n     // var_bindings, locals and next_var_id are shared\n     // with any nested functions that capture the environment\n@@ -158,6 +160,11 @@ struct fn_ctxt {\n     // can actually be made to live as long as it needs to live.\n     mut region_lb: ast::node_id,\n \n+    // Says whether we're inside a for loop, in a do block\n+    // or neither. Helps with error messages involving the\n+    // function return type.\n+    fn_kind: FnKind,\n+\n     in_scope_regions: isr_alist,\n \n     inh: @inherited,\n@@ -187,6 +194,7 @@ fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n         purity: ast::pure_fn,\n         mut region_lb: region_bnd,\n         in_scope_regions: @Nil,\n+        fn_kind: Vanilla,\n         inh: blank_inherited(ccx),\n         ccx: ccx\n     }\n@@ -208,7 +216,7 @@ fn check_bare_fn(ccx: @crate_ctxt,\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n     match ty::get(fty).sty {\n         ty::ty_fn(ref fn_ty) => {\n-            check_fn(ccx, self_info, fn_ty, decl, body, false, None)\n+            check_fn(ccx, self_info, fn_ty, decl, body, Vanilla, None)\n         }\n         _ => ccx.tcx.sess.impossible_case(body.span,\n                                  \"check_bare_fn: function type expected\")\n@@ -220,10 +228,13 @@ fn check_fn(ccx: @crate_ctxt,\n             fn_ty: &ty::FnTy,\n             decl: ast::fn_decl,\n             body: ast::blk,\n-            indirect_ret: bool,\n+            fn_kind: FnKind,\n             old_fcx: Option<@fn_ctxt>) {\n \n     let tcx = ccx.tcx;\n+    let indirect_ret = match fn_kind {\n+        ForLoop => true, _ => false\n+    };\n \n     // ______________________________________________________________________\n     // First, we have to replace any bound regions in the fn and self\n@@ -276,6 +287,7 @@ fn check_fn(ccx: @crate_ctxt,\n             purity: purity,\n             mut region_lb: body.node.id,\n             in_scope_regions: isr,\n+            fn_kind: fn_kind,\n             inh: inherited,\n             ccx: ccx\n         }\n@@ -304,7 +316,11 @@ fn check_fn(ccx: @crate_ctxt,\n     match body.node.expr {\n       Some(tail_expr) => {\n         let tail_expr_ty = fcx.expr_ty(tail_expr);\n-        demand::suptype(fcx, tail_expr.span, fcx.ret_ty, tail_expr_ty);\n+        // Special case: we print a special error if there appears\n+        // to be do-block/for-loop confusion\n+        demand::suptype_with_fn(fcx, tail_expr.span, fcx.ret_ty, tail_expr_ty,\n+            |sp, e, a, s| {\n+                fcx.report_mismatched_return_types(sp, e, a, s) });\n       }\n       None => ()\n     }\n@@ -774,11 +790,27 @@ impl @fn_ctxt {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n     }\n \n-    fn report_mismatched_types(sp: span, e: ty::t, a: ty::t,\n+    fn report_mismatched_return_types(sp: span, e: ty::t, a: ty::t,\n                                err: &ty::type_err) {\n-        self.infcx().report_mismatched_types(sp, e, a, err);\n+        match self.fn_kind {\n+            ForLoop if !ty::type_is_bool(e) && !ty::type_is_nil(a) =>\n+                    self.tcx().sess.span_err(sp, fmt!(\"A for-loop body must \\\n+                        return (), but it returns %s here. \\\n+                        Perhaps you meant to write a `do`-block?\",\n+                                            ty_to_str(self.tcx(), a))),\n+            DoBlock if ty::type_is_bool(e) && ty::type_is_nil(a) =>\n+                // If we expected bool and got ()...\n+                    self.tcx().sess.span_err(sp, fmt!(\"Do-block body must \\\n+                        return %s, but returns () here. Perhaps you meant \\\n+                        to write a `for`-loop?\", ty_to_str(self.tcx(), e))),\n+            _ => self.infcx().report_mismatched_types(sp, e, a, err)\n+        }\n     }\n \n+    fn report_mismatched_types(sp: span, e: ty::t, a: ty::t,\n+                               err: &ty::type_err) {\n+            self.infcx().report_mismatched_types(sp, e, a, err)\n+    }\n }\n \n fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> (ty::t, uint) {\n@@ -1087,9 +1119,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                         DontDerefArgs => {}\n                     }\n \n+                    // mismatch error happens in here\n                     bot |= check_expr_with_assignability(fcx,\n                                                          *arg, formal_ty);\n-                    fcx.write_ty(arg.id, fcx.expr_ty(*arg));\n \n                 }\n             }\n@@ -1414,7 +1446,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                      ast_proto_opt: Option<ast::Proto>,\n                      decl: ast::fn_decl,\n                      body: ast::blk,\n-                     is_loop_body: bool,\n+                     fn_kind: FnKind,\n                      expected: Option<ty::t>) {\n         let tcx = fcx.ccx.tcx;\n \n@@ -1473,7 +1505,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_ty(expr.id, fty);\n \n         check_fn(fcx.ccx, None, &fn_ty, decl, body,\n-                 is_loop_body, Some(fcx));\n+                 fn_kind, Some(fcx));\n     }\n \n \n@@ -2041,14 +2073,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_fn(proto, decl, ref body, cap_clause) => {\n         check_expr_fn(fcx, expr, Some(proto),\n-                      decl, (*body), false,\n-                      expected);\n+                      decl, (*body), Vanilla, expected);\n         capture::check_capture_clause(tcx, expr.id, cap_clause);\n       }\n       ast::expr_fn_block(decl, ref body, cap_clause) => {\n         check_expr_fn(fcx, expr, None,\n-                      decl, (*body), false,\n-                      expected);\n+                      decl, (*body), Vanilla, expected);\n         capture::check_capture_clause(tcx, expr.id, cap_clause);\n       }\n       ast::expr_loop_body(b) => {\n@@ -2058,6 +2088,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // parameter. The catch here is that we need to validate two things:\n         // 1. a closure that returns a bool is expected\n         // 2. the closure that was given returns unit\n+        let mut err_happened = false;\n         let expected_sty = unpack_expected(fcx, expected, |x| Some(x));\n         let inner_ty = match expected_sty {\n           Some(ty::ty_fn(ref fty)) => {\n@@ -2071,8 +2102,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                 should return `bool`, not `%s`\", actual)\n                       },\n                       (*fty).sig.output, None);\n+                err_happened = true;\n                 fcx.write_ty(id, ty::mk_err(tcx));\n-                return true;\n               }\n             }\n             ty::mk_fn(tcx, FnTyBase {\n@@ -2091,8 +2122,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                actual)\n                       },\n                                              expected_t, None);\n-                      fcx.write_ty(id, ty::mk_err(tcx));\n-                      return true;\n+                      let err_ty = ty::mk_err(tcx);\n+                      fcx.write_ty(id, err_ty);\n+                      err_happened = true;\n+                      err_ty\n                   }\n                   None => fcx.tcx().sess.impossible_case(expr.span,\n                             ~\"loop body must have an expected type\")\n@@ -2101,8 +2134,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         match b.node {\n           ast::expr_fn_block(decl, ref body, cap_clause) => {\n             check_expr_fn(fcx, b, None,\n-                          decl, (*body), true,\n-                          Some(inner_ty));\n+                          decl, (*body), ForLoop, Some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n             capture::check_capture_clause(tcx, b.id, cap_clause);\n           }\n@@ -2113,11 +2145,16 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             fcx, expr.span, fcx.node_ty(b.id));\n         match ty::get(block_ty).sty {\n           ty::ty_fn(ref fty) => {\n-            fcx.write_ty(expr.id, ty::mk_fn(tcx, FnTyBase {\n-                meta: (*fty).meta,\n-                sig: FnSig {output: ty::mk_bool(tcx),\n-                            ..(*fty).sig}\n-            }))\n+              if !err_happened {\n+                  fcx.write_ty(expr.id, ty::mk_fn(tcx, FnTyBase {\n+                      meta: (*fty).meta,\n+                      sig: FnSig {output: ty::mk_bool(tcx),\n+                                  ..(*fty).sig}\n+                  }));\n+              }\n+              else {\n+                  fcx.write_ty(expr.id, ty::mk_err(fcx.tcx()));\n+              }\n           }\n           _ => fail ~\"expected fn type\"\n         }\n@@ -2135,8 +2172,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                             function as its last argument, or wrong number \\\n                             of arguments passed to a `do` function\"\n                       }, expected_t, None);\n-                      fcx.write_ty(id, ty::mk_err(tcx));\n-                      return true;\n+                      let err_ty = ty::mk_err(tcx);\n+                      fcx.write_ty(id, err_ty);\n+                      err_ty\n                   }\n                   None => fcx.tcx().sess.impossible_case(expr.span,\n                               ~\"do body must have expected type\")\n@@ -2145,8 +2183,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         match b.node {\n           ast::expr_fn_block(decl, ref body, cap_clause) => {\n             check_expr_fn(fcx, b, None,\n-                          decl, (*body), true,\n-                          Some(inner_ty));\n+                          decl, (*body), DoBlock, Some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n             capture::check_capture_clause(tcx, b.id, cap_clause);\n           }"}, {"sha": "ebede037fdfc4a92164f976bff4d661d4d94ce8d", "filename": "src/test/compile-fail/block-must-not-have-result-for.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42f8a3366a8e687ac1df804f41cfe1d980ce9987/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42f8a3366a8e687ac1df804f41cfe1d980ce9987/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs?ref=42f8a3366a8e687ac1df804f41cfe1d980ce9987", "patch": "@@ -1,7 +1,5 @@\n-// error-pattern:mismatched types: expected `()` but found `bool`\n-\n fn main() {\n-    for vec::each(~[0]) |_i| {\n+    for vec::each(~[0]) |_i| {  //~ ERROR A for-loop body must return (), but\n         true\n     }\n }\n\\ No newline at end of file"}, {"sha": "f3ebaaf4cb508396eb537e42773e4f05055e45e9", "filename": "src/test/compile-fail/issue-2817-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/42f8a3366a8e687ac1df804f41cfe1d980ce9987/src%2Ftest%2Fcompile-fail%2Fissue-2817-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42f8a3366a8e687ac1df804f41cfe1d980ce9987/src%2Ftest%2Fcompile-fail%2Fissue-2817-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2817-2.rs?ref=42f8a3366a8e687ac1df804f41cfe1d980ce9987", "patch": "@@ -0,0 +1,16 @@\n+fn not_bool(f: fn(int) -> ~str) {}\n+\n+fn main() {\n+    for uint::range(0, 100000) |_i| { //~ ERROR A for-loop body must return (), but\n+        false\n+    };\n+    for not_bool |_i| { //~ ERROR a `loop` function's last argument should return `bool`\n+        //~^ ERROR A for-loop body must return (), but\n+        ~\"hi\"\n+    };\n+    for uint::range(0, 100000) |_i| { //~ ERROR A for-loop body must return (), but\n+        ~\"hi\"\n+    };\n+    for not_bool() |_i| { //~ ERROR a `loop` function's last argument\n+    };\n+}\n\\ No newline at end of file"}, {"sha": "66e24d26790b223f2b4c082d54a9a9c1d7b814ec", "filename": "src/test/compile-fail/issue-2817.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/42f8a3366a8e687ac1df804f41cfe1d980ce9987/src%2Ftest%2Fcompile-fail%2Fissue-2817.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42f8a3366a8e687ac1df804f41cfe1d980ce9987/src%2Ftest%2Fcompile-fail%2Fissue-2817.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2817.rs?ref=42f8a3366a8e687ac1df804f41cfe1d980ce9987", "patch": "@@ -0,0 +1,15 @@\n+fn uuid() -> uint { fail; }\n+\n+fn from_str(s: ~str) -> uint { fail; }\n+fn to_str(u: uint) -> ~str { fail; }\n+fn uuid_random() -> uint { fail; }\n+\n+fn main() {\n+    do uint::range(0, 100000) |_i| { //~ ERROR Do-block body must return bool, but\n+    }\n+    // should get a more general message if the callback\n+    // doesn't return nil\n+    do uint::range(0, 100000) |_i| { //~ ERROR mismatched types\n+        ~\"str\"\n+    }\n+}\n\\ No newline at end of file"}]}