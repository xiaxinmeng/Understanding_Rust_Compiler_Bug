{"sha": "a48c382549f01ddbd5707601a2257bf45d0d4f5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0OGMzODI1NDlmMDFkZGJkNTcwNzYwMWEyMjU3YmY0NWQwZDRmNWM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-08-25T17:50:55Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-08-25T18:16:29Z"}, "message": "Introduce \"type patterns\" to the typechecker in preparation for function type-param inference", "tree": {"sha": "821ff272a3baa88090b879ae1b57092371879a5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/821ff272a3baa88090b879ae1b57092371879a5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a48c382549f01ddbd5707601a2257bf45d0d4f5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a48c382549f01ddbd5707601a2257bf45d0d4f5c", "html_url": "https://github.com/rust-lang/rust/commit/a48c382549f01ddbd5707601a2257bf45d0d4f5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a48c382549f01ddbd5707601a2257bf45d0d4f5c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b9a48b9c9605737ebf29269552ccbf618042bb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b9a48b9c9605737ebf29269552ccbf618042bb0", "html_url": "https://github.com/rust-lang/rust/commit/2b9a48b9c9605737ebf29269552ccbf618042bb0"}], "stats": {"total": 87, "additions": 51, "deletions": 36}, "files": [{"sha": "046b17ea1ef900f7b14f62b4949760395c953352", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 51, "deletions": 36, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a48c382549f01ddbd5707601a2257bf45d0d4f5c/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/a48c382549f01ddbd5707601a2257bf45d0d4f5c/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=a48c382549f01ddbd5707601a2257bf45d0d4f5c", "patch": "@@ -11,6 +11,12 @@ type ltype =\n   | LTYPE_poly of Ast.ty_param array * Ast.ty   (* \"big lambda\" *)\n   | LTYPE_module of Ast.mod_items               (* type of a module *)\n \n+(* A \"type pattern\" used for inference. *)\n+type ty_pat =\n+    TYPAT_wild                (* matches any type *)\n+  | TYPAT_ty of Ast.ty        (* matches only the given type *)\n+  | TYPAT_fn of Ast.ty array  (* matches a function with some arg types *)\n+\n type fn_ctx = {\n   fnctx_return_type: Ast.ty;\n   fnctx_is_iter: bool;\n@@ -231,7 +237,7 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n \n   (* Here the actual inference happens. *)\n   let internal_check_slot\n-      (infer:Ast.ty option)\n+      (infer:ty_pat)\n       (defn_id:Common.node_id)\n       : Ast.ty =\n     let slot =\n@@ -243,10 +249,10 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n             \"internal_check_slot: supplied defn wasn't a slot at all\"\n     in\n     match infer, slot.Ast.slot_ty with\n-        Some expected, Some actual ->\n+        TYPAT_ty expected, Some actual ->\n           demand expected actual;\n           actual\n-      | Some inferred, None ->\n+      | TYPAT_ty inferred, None ->\n           iflog cx\n             (fun _ ->\n                log cx \"setting auto slot #%d = %a to type %a\"\n@@ -258,9 +264,11 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n           Hashtbl.replace cx.Semant.ctxt_all_defns defn_id\n             (Semant.DEFN_slot new_slot);\n           inferred\n-      | None, Some actual -> actual\n-      | None, None ->\n+      | TYPAT_wild, Some actual -> actual\n+      | TYPAT_wild, None ->\n           Common.err None \"can't infer any type for this slot\"\n+      | TYPAT_fn _, _ ->\n+          Common.unimpl None \"sorry, fn type patterns aren't implemented\"\n   in\n \n   let internal_check_mod_item_decl\n@@ -281,7 +289,7 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n   in\n \n   let rec internal_check_base_lval\n-      (infer:Ast.ty option)\n+      (infer:ty_pat)\n       (nbi:Ast.name_base Common.identified)\n       : ltype =\n     let lval_id = nbi.Common.id in\n@@ -302,7 +310,7 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n       (comp:Ast.lval_component)\n       : ltype =\n     let base_ity =\n-      match internal_check_lval None base with\n+      match internal_check_lval TYPAT_wild base with\n           LTYPE_poly (_, ty) ->\n             Common.err None \"can't index the polymorphic type '%a'\"\n               Ast.sprintf_ty ty\n@@ -459,7 +467,7 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n     in\n     typecheck base_ity\n \n-  and internal_check_lval (infer:Ast.ty option) (lval:Ast.lval) : ltype =\n+  and internal_check_lval (infer:ty_pat) (lval:Ast.lval) : ltype =\n     match lval with\n         Ast.LVAL_base nbi -> internal_check_base_lval infer nbi\n       | Ast.LVAL_ext (base, comp) -> internal_check_ext_lval base comp\n@@ -473,43 +481,50 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n   and internal_check_outer_lval\n       ~mut:(mut:Ast.mutability)\n       ~deref:(deref:bool)\n-      ~fn_args:(fn_args:(Ast.ty array) option)\n-      (infer:Ast.ty option)\n+      (infer:ty_pat)\n       (lval:Ast.lval)\n       : (Ast.ty * int) =\n     let yield_ty ty =\n       let (ty, n_boxes) = if deref then unbox ty else (ty, 0) in\n         (maybe_mutable mut ty, n_boxes)\n     in\n     match infer, internal_check_lval infer lval with\n-      | None, LTYPE_mono ty -> yield_ty ty\n-      | Some expected, LTYPE_mono actual ->\n+      | TYPAT_wild, LTYPE_mono ty -> yield_ty ty\n+      | TYPAT_ty expected, LTYPE_mono actual ->\n           demand expected actual;\n           yield_ty actual\n-      | None, (LTYPE_poly _ as lty) ->\n-          begin\n-            match fn_args with\n-                None ->\n-                  Common.err None\n-                    \"can't auto-instantiate %a\" sprintf_ltype lty\n-              | Some args ->\n-                  Common.err None \"can't auto-instantiate %a on %d args\"\n-                    sprintf_ltype lty (Array.length args)\n-          end\n-      | Some _, (LTYPE_poly _) ->\n+      | TYPAT_fn _, LTYPE_mono _ ->\n+          (* FIXME: typecheck *)\n+          Common.unimpl\n+            None\n+            \"sorry, function type patterns aren't typechecked yet\"\n+      | TYPAT_wild, (LTYPE_poly _ as lty) ->\n+          Common.err\n+            None\n+            \"not enough context to automatically instantiate the polymorphic \\\n+              type '%a'; supply type parameters explicitly\"\n+            sprintf_ltype lty\n+      | TYPAT_ty expected, (LTYPE_poly _ as lty) ->\n+          (* FIXME: auto-instantiate *)\n+          Common.unimpl\n+            None\n+            \"sorry, automatic polymorphic instantiation of %a to %a isn't \\\n+            supported yet; please supply type parameters explicitly\"\n+            sprintf_ltype lty\n+            Ast.sprintf_ty expected\n+      | TYPAT_fn _, (LTYPE_poly _) ->\n           (* FIXME: auto-instantiate *)\n           Common.unimpl\n             None\n-            \"sorry, automatic polymorphic instantiation isn't supported yet; \\\n-              please supply type parameters explicitly\"\n+            \"sorry, automatic polymorphic instantiation of function types \\\n+            isn't supported yet; please supply type parameters explicitly\"\n       | _, LTYPE_module _ ->\n           Common.err None \"can't refer to a module as a first-class value\"\n \n   and generic_check_lval\n       ~mut:(mut:Ast.mutability)\n       ~deref:(deref:bool)\n-      ~fn_args:(fn_args:(Ast.ty array) option)\n-      (infer:Ast.ty option)\n+      (infer:ty_pat)\n       (lval:Ast.lval)\n       : Ast.ty =\n     (* The lval we got is an impostor (it may contain unresolved TY_nameds).\n@@ -524,11 +539,12 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n              (if mut = Ast.MUT_mutable then \"mutable\" else \"immutable\")\n              (if deref then \"true\" else \"false\")\n              (match infer with\n-                  None -> \"<none>\"\n-                | Some t -> Fmt.fmt_to_str Ast.fmt_ty t))\n+                  TYPAT_wild -> \"_\"\n+                | TYPAT_ty t -> Fmt.fmt_to_str Ast.fmt_ty t\n+                | TYPAT_fn _ -> \"<fn>\" (* FIXME *)))\n     in\n     let (lval_ty, n_boxes) =\n-      internal_check_outer_lval ~mut ~deref ~fn_args infer lval\n+      internal_check_outer_lval ~mut:mut ~deref:deref infer lval\n     in\n     let _ =\n       iflog cx\n@@ -570,10 +586,9 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n   and check_lval\n       ?mut:(mut=Ast.MUT_immutable)\n       ?deref:(deref=false)\n-      ?fn_args:(fn_args=None)\n       (lval:Ast.lval)\n       : Ast.ty =\n-    generic_check_lval ~fn_args ~mut ~deref None lval\n+    generic_check_lval ~mut:mut ~deref:deref TYPAT_wild lval\n \n   and check_atom ?deref:(deref=false) (atom:Ast.atom) : Ast.ty =\n     match atom with\n@@ -582,16 +597,16 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n   in\n \n   let infer_slot (ty:Ast.ty) (slot_id:Common.node_id) : unit =\n-    ignore (internal_check_slot (Some ty) slot_id)\n+    ignore (internal_check_slot (TYPAT_ty ty) slot_id)\n   in\n \n   let infer_lval\n       ?mut:(mut=Ast.MUT_immutable)\n       (ty:Ast.ty)\n       (lval:Ast.lval)\n       : unit =\n-    ignore (generic_check_lval ~mut ~deref:false ~fn_args:None\n-              (Some (Ast.TY_mutable ty)) lval)\n+    ignore (generic_check_lval ?mut:mut ~deref:false\n+              (TYPAT_ty (Ast.TY_mutable ty)) lval)\n   in\n \n   (*\n@@ -646,7 +661,7 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n    * returns the return type. *)\n   let check_fn (callee:Ast.lval) (args:Ast.atom array) : Ast.ty =\n     let arg_tys = Array.map check_atom args in\n-    let callee_ty = check_lval callee ~fn_args:(Some arg_tys) in\n+    let callee_ty = check_lval callee in\n     demand_fn (Array.map (fun ty -> Some ty) arg_tys) callee_ty\n   in\n "}]}