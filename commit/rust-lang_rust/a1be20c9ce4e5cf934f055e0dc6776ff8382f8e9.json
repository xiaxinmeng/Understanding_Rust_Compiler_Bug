{"sha": "a1be20c9ce4e5cf934f055e0dc6776ff8382f8e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYmUyMGM5Y2U0ZTVjZjkzNGYwNTVlMGRjNjc3NmZmODM4MmY4ZTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-24T12:51:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-27T13:06:03Z"}, "message": "error_reporting/mod.rs: rustfmt", "tree": {"sha": "5f63682d7dde90c5de3ec850686de078ea660e28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f63682d7dde90c5de3ec850686de078ea660e28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1be20c9ce4e5cf934f055e0dc6776ff8382f8e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1be20c9ce4e5cf934f055e0dc6776ff8382f8e9", "html_url": "https://github.com/rust-lang/rust/commit/a1be20c9ce4e5cf934f055e0dc6776ff8382f8e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1be20c9ce4e5cf934f055e0dc6776ff8382f8e9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b24b88734d7aab59184d30209bc6053cc2ecf3a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b24b88734d7aab59184d30209bc6053cc2ecf3a4", "html_url": "https://github.com/rust-lang/rust/commit/b24b88734d7aab59184d30209bc6053cc2ecf3a4"}], "stats": {"total": 269, "additions": 152, "deletions": 117}, "files": [{"sha": "bf150dbe4604d0731e91976db67e62d903a00390", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 152, "deletions": 117, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/a1be20c9ce4e5cf934f055e0dc6776ff8382f8e9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1be20c9ce4e5cf934f055e0dc6776ff8382f8e9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=a1be20c9ce4e5cf934f055e0dc6776ff8382f8e9", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::ConstraintDescription;\n-use borrow_check::nll::constraints::{OutlivesConstraint};\n+use borrow_check::nll::constraints::OutlivesConstraint;\n use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::type_check::Locations;\n use borrow_check::nll::universal_regions::DefiningTy;\n-use util::borrowck_errors::{BorrowckErrors, Origin};\n+use borrow_check::nll::ConstraintDescription;\n use rustc::hir::def_id::DefId;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n@@ -22,9 +21,10 @@ use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use std::collections::VecDeque;\n+use syntax::errors::Applicability;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n-use syntax::errors::Applicability;\n+use util::borrowck_errors::{BorrowckErrors, Origin};\n \n mod region_name;\n mod var_name;\n@@ -76,9 +76,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"best_blame_constraint(from_region={:?})\", from_region);\n \n         // Find all paths\n-        let (path, target_region) = self\n-            .find_constraint_paths_between_regions(from_region, target_test)\n-            .unwrap();\n+        let (path, target_region) =\n+            self.find_constraint_paths_between_regions(from_region, target_test)\n+                .unwrap();\n         debug!(\n             \"best_blame_constraint: path={:#?}\",\n             path.iter()\n@@ -92,8 +92,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         // Classify each of the constraints along the path.\n-        let mut categorized_path: Vec<(ConstraintCategory, bool, Span)> = path\n-            .iter()\n+        let mut categorized_path: Vec<(ConstraintCategory, bool, Span)> = path.iter()\n             .map(|constraint| {\n                 if constraint.category == ConstraintCategory::ClosureBounds {\n                     self.retrieve_closure_constraint_info(mir, &constraint)\n@@ -137,13 +136,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 | ConstraintCategory::Boring\n                 | ConstraintCategory::BoringNoLocation\n                 | ConstraintCategory::Internal => false,\n-                ConstraintCategory::TypeAnnotation\n-                | ConstraintCategory::Return => true,\n+                ConstraintCategory::TypeAnnotation | ConstraintCategory::Return => true,\n                 _ => constraint_sup_scc != target_scc,\n             }\n         });\n         if let Some(i) = best_choice {\n-            return categorized_path[i]\n+            return categorized_path[i];\n         }\n \n         // If that search fails, that is.. unusual. Maybe everything\n@@ -206,9 +204,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // enqueue any regions we find, keeping track of how we\n             // reached them.\n             let fr_static = self.universal_regions.fr_static;\n-            for constraint in self.constraint_graph.outgoing_edges(r,\n-                                                                   &self.constraints,\n-                                                                   fr_static) {\n+            for constraint in self.constraint_graph\n+                .outgoing_edges(r, &self.constraints, fr_static)\n+            {\n                 assert_eq!(constraint.sup, r);\n                 let sub_region = constraint.sub;\n                 if let Trace::NotVisited = context[sub_region] {\n@@ -240,11 +238,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let (category, _, span) = self.best_blame_constraint(\n-            mir,\n-            fr,\n-            |r| r == outlived_fr\n-        );\n+        let (category, _, span) = self.best_blame_constraint(mir, fr, |r| r == outlived_fr);\n \n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n@@ -260,20 +254,45 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.universal_regions.is_local_free_region(outlived_fr),\n         );\n \n-        debug!(\"report_error: fr_is_local={:?} outlived_fr_is_local={:?} category={:?}\",\n-               fr_is_local, outlived_fr_is_local, category);\n+        debug!(\n+            \"report_error: fr_is_local={:?} outlived_fr_is_local={:?} category={:?}\",\n+            fr_is_local, outlived_fr_is_local, category\n+        );\n         match (category, fr_is_local, outlived_fr_is_local) {\n-            (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(infcx, fr) =>\n-                self.report_fnmut_error(mir, infcx, mir_def_id, fr, outlived_fr, span,\n-                                        errors_buffer),\n-            (ConstraintCategory::Assignment, true, false) |\n-            (ConstraintCategory::CallArgument, true, false) =>\n-                self.report_escaping_data_error(mir, infcx, mir_def_id, fr, outlived_fr,\n-                                                category, span, errors_buffer),\n-            _ =>\n-                self.report_general_error(mir, infcx, mir_def_id, fr, fr_is_local,\n-                                          outlived_fr, outlived_fr_is_local,\n-                                          category, span, errors_buffer),\n+            (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(infcx, fr) => {\n+                self.report_fnmut_error(\n+                    mir,\n+                    infcx,\n+                    mir_def_id,\n+                    fr,\n+                    outlived_fr,\n+                    span,\n+                    errors_buffer,\n+                )\n+            }\n+            (ConstraintCategory::Assignment, true, false)\n+            | (ConstraintCategory::CallArgument, true, false) => self.report_escaping_data_error(\n+                mir,\n+                infcx,\n+                mir_def_id,\n+                fr,\n+                outlived_fr,\n+                category,\n+                span,\n+                errors_buffer,\n+            ),\n+            _ => self.report_general_error(\n+                mir,\n+                infcx,\n+                mir_def_id,\n+                fr,\n+                fr_is_local,\n+                outlived_fr,\n+                outlived_fr_is_local,\n+                category,\n+                span,\n+                errors_buffer,\n+            ),\n         };\n     }\n \n@@ -303,10 +322,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         span: Span,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n-        let mut diag = infcx.tcx.sess.struct_span_err(\n-            span,\n-            \"captured variable cannot escape `FnMut` closure body\",\n-        );\n+        let mut diag = infcx\n+            .tcx\n+            .sess\n+            .struct_span_err(span, \"captured variable cannot escape `FnMut` closure body\");\n \n         // We should check if the return type of this closure is in fact a closure - in that\n         // case, we can special case the error further.\n@@ -318,27 +337,28 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             \"returns a reference to a captured variable which escapes the closure body\"\n         };\n \n-        diag.span_label(\n-            span,\n-            message,\n-        );\n+        diag.span_label(span, message);\n \n-        match self.give_region_a_name(infcx, mir, mir_def_id, outlived_fr, &mut 1).source {\n-            RegionNameSource::NamedEarlyBoundRegion(fr_span) |\n-            RegionNameSource::NamedFreeRegion(fr_span) |\n-            RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _) |\n-            RegionNameSource::CannotMatchHirTy(fr_span, _) |\n-            RegionNameSource::MatchedHirTy(fr_span) |\n-            RegionNameSource::MatchedAdtAndSegment(fr_span) |\n-            RegionNameSource::AnonRegionFromUpvar(fr_span, _) |\n-            RegionNameSource::AnonRegionFromOutput(fr_span, _, _) => {\n+        match self.give_region_a_name(infcx, mir, mir_def_id, outlived_fr, &mut 1)\n+            .source\n+        {\n+            RegionNameSource::NamedEarlyBoundRegion(fr_span)\n+            | RegionNameSource::NamedFreeRegion(fr_span)\n+            | RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _)\n+            | RegionNameSource::CannotMatchHirTy(fr_span, _)\n+            | RegionNameSource::MatchedHirTy(fr_span)\n+            | RegionNameSource::MatchedAdtAndSegment(fr_span)\n+            | RegionNameSource::AnonRegionFromUpvar(fr_span, _)\n+            | RegionNameSource::AnonRegionFromOutput(fr_span, _, _) => {\n                 diag.span_label(fr_span, \"inferred to be a `FnMut` closure\");\n-            },\n-            _ => {},\n+            }\n+            _ => {}\n         }\n \n-        diag.note(\"`FnMut` closures only have access to their captured variables while they are \\\n-                   executing...\");\n+        diag.note(\n+            \"`FnMut` closures only have access to their captured variables while they are \\\n+             executing...\",\n+        );\n         diag.note(\"...therefore, they cannot allow references to captured variables to escape\");\n \n         diag.buffer(errors_buffer);\n@@ -375,7 +395,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             DefiningTy::Closure(..) => \"closure\",\n             DefiningTy::Generator(..) => \"generator\",\n             DefiningTy::FnDef(..) => \"function\",\n-            DefiningTy::Const(..) => \"const\"\n+            DefiningTy::Const(..) => \"const\",\n         };\n \n         // Revert to the normal error in these cases.\n@@ -384,12 +404,23 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             || (category == ConstraintCategory::Assignment && escapes_from == \"function\")\n             || escapes_from == \"const\"\n         {\n-            return self.report_general_error(mir, infcx, mir_def_id,\n-                                             fr, true, outlived_fr, false,\n-                                             category, span, errors_buffer);\n+            return self.report_general_error(\n+                mir,\n+                infcx,\n+                mir_def_id,\n+                fr,\n+                true,\n+                outlived_fr,\n+                false,\n+                category,\n+                span,\n+                errors_buffer,\n+            );\n         }\n \n-        let mut diag = infcx.tcx.borrowed_data_escapes_closure(span, escapes_from, Origin::Mir);\n+        let mut diag = infcx\n+            .tcx\n+            .borrowed_data_escapes_closure(span, escapes_from, Origin::Mir);\n \n         if let Some((Some(outlived_fr_name), outlived_fr_span)) = outlived_fr_name_and_span {\n             diag.span_label(\n@@ -410,7 +441,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 ),\n             );\n \n-            diag.span_label(span, format!(\"`{}` escapes the {} body here\", fr_name, escapes_from));\n+            diag.span_label(\n+                span,\n+                format!(\"`{}` escapes the {} body here\", fr_name, escapes_from),\n+            );\n         }\n \n         diag.buffer(errors_buffer);\n@@ -452,31 +486,41 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let counter = &mut 1;\n         let fr_name = self.give_region_a_name(infcx, mir, mir_def_id, fr, counter);\n         fr_name.highlight_region_name(&mut diag);\n-        let outlived_fr_name = self.give_region_a_name(\n-            infcx, mir, mir_def_id, outlived_fr, counter);\n+        let outlived_fr_name =\n+            self.give_region_a_name(infcx, mir, mir_def_id, outlived_fr, counter);\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n-        let mir_def_name = if infcx.tcx.is_closure(mir_def_id) { \"closure\" } else { \"function\" };\n+        let mir_def_name = if infcx.tcx.is_closure(mir_def_id) {\n+            \"closure\"\n+        } else {\n+            \"function\"\n+        };\n \n         match (category, outlived_fr_is_local, fr_is_local) {\n             (ConstraintCategory::Return, true, _) => {\n-                diag.span_label(span, format!(\n-                    \"{} was supposed to return data with lifetime `{}` but it is returning \\\n-                    data with lifetime `{}`\",\n-                    mir_def_name, outlived_fr_name, fr_name\n-                ));\n-            },\n+                diag.span_label(\n+                    span,\n+                    format!(\n+                        \"{} was supposed to return data with lifetime `{}` but it is returning \\\n+                         data with lifetime `{}`\",\n+                        mir_def_name, outlived_fr_name, fr_name\n+                    ),\n+                );\n+            }\n             _ => {\n-                diag.span_label(span, format!(\n-                    \"{}requires that `{}` must outlive `{}`\",\n-                    category.description(), fr_name, outlived_fr_name,\n-                ));\n-            },\n+                diag.span_label(\n+                    span,\n+                    format!(\n+                        \"{}requires that `{}` must outlive `{}`\",\n+                        category.description(),\n+                        fr_name,\n+                        outlived_fr_name,\n+                    ),\n+                );\n+            }\n         }\n \n-        self.add_static_impl_trait_suggestion(\n-            infcx, &mut diag, fr, fr_name, outlived_fr,\n-        );\n+        self.add_static_impl_trait_suggestion(infcx, &mut diag, fr, fr_name, outlived_fr);\n \n         diag.buffer(errors_buffer);\n     }\n@@ -499,17 +543,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr_name: RegionName,\n         outlived_fr: RegionVid,\n     ) {\n-        if let (\n-            Some(f),\n-            Some(ty::RegionKind::ReStatic)\n-        ) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n+        if let (Some(f), Some(ty::RegionKind::ReStatic)) =\n+            (self.to_error_region(fr), self.to_error_region(outlived_fr))\n+        {\n             if let Some(ty::TyS {\n                 sty: ty::TyKind::Opaque(did, substs),\n                 ..\n-            }) = infcx.tcx.is_suitable_region(f)\n-                    .map(|r| r.def_id)\n-                    .map(|id| infcx.tcx.return_type_impl_trait(id))\n-                    .unwrap_or(None)\n+            }) = infcx\n+                .tcx\n+                .is_suitable_region(f)\n+                .map(|r| r.def_id)\n+                .map(|id| infcx.tcx.return_type_impl_trait(id))\n+                .unwrap_or(None)\n             {\n                 // Check whether or not the impl trait return type is intended to capture\n                 // data with the static lifetime.\n@@ -522,10 +567,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     let mut found = false;\n                     for predicate in bounds.predicates {\n                         if let ty::Predicate::TypeOutlives(binder) = predicate {\n-                            if let ty::OutlivesPredicate(\n-                                _,\n-                                ty::RegionKind::ReStatic\n-                            ) = binder.skip_binder() {\n+                            if let ty::OutlivesPredicate(_, ty::RegionKind::ReStatic) =\n+                                binder.skip_binder()\n+                            {\n                                 found = true;\n                                 break;\n                             }\n@@ -535,18 +579,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     found\n                 };\n \n-                debug!(\"add_static_impl_trait_suggestion: has_static_predicate={:?}\",\n-                       has_static_predicate);\n+                debug!(\n+                    \"add_static_impl_trait_suggestion: has_static_predicate={:?}\",\n+                    has_static_predicate\n+                );\n                 let static_str = keywords::StaticLifetime.name();\n                 // If there is a static predicate, then the only sensible suggestion is to replace\n                 // fr with `'static`.\n                 if has_static_predicate {\n-                    diag.help(\n-                        &format!(\n-                            \"consider replacing `{}` with `{}`\",\n-                            fr_name, static_str,\n-                        ),\n-                    );\n+                    diag.help(&format!(\n+                        \"consider replacing `{}` with `{}`\",\n+                        fr_name, static_str,\n+                    ));\n                 } else {\n                     // Otherwise, we should suggest adding a constraint on the return type.\n                     let span = infcx.tcx.def_span(*did);\n@@ -581,13 +625,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n     ) -> (ConstraintCategory, bool, Span, RegionName) {\n-        let (category, from_closure, span) = self.best_blame_constraint(\n-            mir,\n-            borrow_region,\n-            |r| r == outlived_region\n-        );\n-        let outlived_fr_name = self.give_region_a_name(\n-            infcx, mir, mir_def_id, outlived_region, &mut 1);\n+        let (category, from_closure, span) =\n+            self.best_blame_constraint(mir, borrow_region, |r| r == outlived_region);\n+        let outlived_fr_name =\n+            self.give_region_a_name(infcx, mir, mir_def_id, outlived_region, &mut 1);\n         (category, from_closure, span, outlived_fr_name)\n     }\n \n@@ -596,10 +637,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n         debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n         // Find all paths\n-        let (_path, r) =\n-            self.find_constraint_paths_between_regions(fr1, |r| {\n-                self.liveness_constraints.contains(r, elem)\n-            }).unwrap();\n+        let (_path, r) = self.find_constraint_paths_between_regions(fr1, |r| {\n+            self.liveness_constraints.contains(r, elem)\n+        }).unwrap();\n         r\n     }\n \n@@ -617,27 +657,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn retrieve_closure_constraint_info(\n         &self,\n         mir: &Mir<'tcx>,\n-        constraint: &OutlivesConstraint\n+        constraint: &OutlivesConstraint,\n     ) -> (ConstraintCategory, bool, Span) {\n         let loc = match constraint.locations {\n             Locations::All(span) => return (constraint.category, false, span),\n             Locations::Single(loc) => loc,\n         };\n \n-        let opt_span_category = self\n-            .closure_bounds_mapping[&loc]\n-            .get(&(constraint.sup, constraint.sub));\n+        let opt_span_category =\n+            self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub));\n         opt_span_category\n             .map(|&(category, span)| (category, true, span))\n             .unwrap_or((constraint.category, false, mir.source_info(loc).span))\n     }\n \n     /// Returns `true` if a closure is inferred to be an `FnMut` closure.\n-    crate fn is_closure_fn_mut(\n-        &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n-        fr: RegionVid,\n-    ) -> bool {\n+    crate fn is_closure_fn_mut(&self, infcx: &InferCtxt<'_, '_, 'tcx>, fr: RegionVid) -> bool {\n         if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n             if let ty::BoundRegion::BrEnv = free_region.bound_region {\n                 if let DefiningTy::Closure(def_id, substs) = self.universal_regions.defining_ty {"}]}