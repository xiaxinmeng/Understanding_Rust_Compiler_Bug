{"sha": "5f7716d11bd7df5dbdffdd97a290c671ec1c54d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNzcxNmQxMWJkN2RmNWRiZGZmZGQ5N2EyOTBjNjcxZWMxYzU0ZDU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-17T06:39:20Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-17T09:56:54Z"}, "message": "invalid_value: factor finding dangerous inits into separate function", "tree": {"sha": "5883fd2fbfaf67ac98fc7735d8e83c579b4f1043", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5883fd2fbfaf67ac98fc7735d8e83c579b4f1043"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f7716d11bd7df5dbdffdd97a290c671ec1c54d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f7716d11bd7df5dbdffdd97a290c671ec1c54d5", "html_url": "https://github.com/rust-lang/rust/commit/5f7716d11bd7df5dbdffdd97a290c671ec1c54d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f7716d11bd7df5dbdffdd97a290c671ec1c54d5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdfd698f37184da42254a03ed466ab1f90e6fb6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdfd698f37184da42254a03ed466ab1f90e6fb6c", "html_url": "https://github.com/rust-lang/rust/commit/bdfd698f37184da42254a03ed466ab1f90e6fb6c"}], "stats": {"total": 91, "additions": 54, "deletions": 37}, "files": [{"sha": "afe81b3123d83a28403deec57949e5d9640cfa92", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 54, "deletions": 37, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/5f7716d11bd7df5dbdffdd97a290c671ec1c54d5/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7716d11bd7df5dbdffdd97a290c671ec1c54d5/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5f7716d11bd7df5dbdffdd97a290c671ec1c54d5", "patch": "@@ -1876,8 +1876,34 @@ declare_lint_pass!(InvalidValue => [INVALID_VALUE]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &hir::Expr) {\n \n-        const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n-        const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n+        #[derive(Debug)]\n+        enum InitKind { Zeroed, Uninit };\n+\n+        /// Determine if this expression is a \"dangerous initialization\".\n+        fn is_dangerous_init(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<InitKind> {\n+            const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n+            const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n+\n+            if let hir::ExprKind::Call(ref path_expr, ref _args) = expr.node {\n+                if let hir::ExprKind::Path(ref qpath) = path_expr.node {\n+                    if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id)\n+                        .opt_def_id()\n+                    {\n+                        if cx.match_def_path(def_id, &ZEROED_PATH) {\n+                            return Some(InitKind::Zeroed);\n+                        }\n+                        if cx.match_def_path(def_id, &UININIT_PATH) {\n+                            return Some(InitKind::Uninit);\n+                        }\n+                        // FIXME: Also detect `MaybeUninit::zeroed().assume_init()` and\n+                        // `MaybeUninit::uninit().assume_init()`.\n+                        // FIXME: Also detect `transmute` from 0.\n+                    }\n+                }\n+            }\n+\n+            None\n+        }\n \n         /// Information about why a type cannot be initialized this way.\n         /// Contains an error message and optionally a span to point at.\n@@ -1933,42 +1959,33 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n             }\n         }\n \n-        if let hir::ExprKind::Call(ref path_expr, ref _args) = expr.node {\n-            if let hir::ExprKind::Path(ref qpath) = path_expr.node {\n-                if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n-                    if cx.match_def_path(def_id, &ZEROED_PATH) ||\n-                        cx.match_def_path(def_id, &UININIT_PATH)\n-                    {\n-                        // This conjures an instance of a type out of nothing,\n-                        // using zeroed or uninitialized memory.\n-                        // We are extremely conservative with what we warn about.\n-                        let conjured_ty = cx.tables.expr_ty(expr);\n-                        if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty) {\n-                            let mut err = cx.struct_span_lint(\n-                                INVALID_VALUE,\n-                                expr.span,\n-                                &format!(\n-                                    \"the type `{}` does not permit {}\",\n-                                    conjured_ty,\n-                                    if cx.match_def_path(def_id, &ZEROED_PATH) {\n-                                        \"zero-initialization\"\n-                                    } else {\n-                                        \"being left uninitialized\"\n-                                    }\n-                                ),\n-                            );\n-                            err.span_label(expr.span,\n-                                \"this code causes undefined behavior when executed\");\n-                            err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead\");\n-                            if let Some(span) = span {\n-                                err.span_note(span, &msg);\n-                            } else {\n-                                err.note(&msg);\n-                            }\n-                            err.emit();\n-                        }\n-                    }\n+        if let Some(init) = is_dangerous_init(cx, expr) {\n+            // This conjures an instance of a type out of nothing,\n+            // using zeroed or uninitialized memory.\n+            // We are extremely conservative with what we warn about.\n+            let conjured_ty = cx.tables.expr_ty(expr);\n+            if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty) {\n+                let mut err = cx.struct_span_lint(\n+                    INVALID_VALUE,\n+                    expr.span,\n+                    &format!(\n+                        \"the type `{}` does not permit {}\",\n+                        conjured_ty,\n+                        match init {\n+                            InitKind::Zeroed => \"zero-initialization\",\n+                            InitKind::Uninit => \"being left uninitialized\",\n+                        },\n+                    ),\n+                );\n+                err.span_label(expr.span,\n+                    \"this code causes undefined behavior when executed\");\n+                err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead\");\n+                if let Some(span) = span {\n+                    err.span_note(span, &msg);\n+                } else {\n+                    err.note(&msg);\n                 }\n+                err.emit();\n             }\n         }\n     }"}]}