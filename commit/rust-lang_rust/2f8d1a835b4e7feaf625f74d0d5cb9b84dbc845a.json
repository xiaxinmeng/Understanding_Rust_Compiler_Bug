{"sha": "2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "node_id": "C_kwDOAAsO6NoAKDJmOGQxYTgzNWI0ZTdmZWFmNjI1Zjc0ZDBkNWNiOWI4NGRiYzg0NWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-03T04:28:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-03T04:28:08Z"}, "message": "Auto merge of #94541 - Dylan-DPC:rollup-564wbq3, r=Dylan-DPC\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #92061 (update char signess for openbsd)\n - #93072 (Compatible variants suggestion with desugaring)\n - #93354 (Add documentation about `BorrowedFd::to_owned`.)\n - #93663 (Rename `BorrowedFd::borrow_raw_fd` to `BorrowedFd::borrow_raw`.)\n - #94375 (Adt copy suggestions)\n - #94433 (Improve allowness of the unexpected_cfgs lint)\n - #94499 (Documentation was missed when demoting Windows XP to no_std only)\n - #94505 (Restore the local filter on mono item sorting)\n - #94529 (Unused doc comments blocks)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "58c9e240fbbb366d99880f74d49ab390c79285fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58c9e240fbbb366d99880f74d49ab390c79285fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "html_url": "https://github.com/rust-lang/rust/commit/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8769f4ef2fe1efddd1f072485f97f568e7328f79", "url": "https://api.github.com/repos/rust-lang/rust/commits/8769f4ef2fe1efddd1f072485f97f568e7328f79", "html_url": "https://github.com/rust-lang/rust/commit/8769f4ef2fe1efddd1f072485f97f568e7328f79"}, {"sha": "878a4ff90e5987027f8ce3d350faaad02e0c83c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/878a4ff90e5987027f8ce3d350faaad02e0c83c9", "html_url": "https://github.com/rust-lang/rust/commit/878a4ff90e5987027f8ce3d350faaad02e0c83c9"}], "stats": {"total": 1227, "additions": 972, "deletions": 255}, "files": [{"sha": "846abce9d6a6e23bd1429b90f290703c5e23dd6b", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -1,8 +1,7 @@\n //! Parsing and validation of builtin attributes\n \n use rustc_ast as ast;\n-use rustc_ast::node_id::CRATE_NODE_ID;\n-use rustc_ast::{Attribute, Lit, LitKind, MetaItem, MetaItemKind, NestedMetaItem};\n+use rustc_ast::{Attribute, Lit, LitKind, MetaItem, MetaItemKind, NestedMetaItem, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n@@ -436,7 +435,12 @@ pub fn find_crate_name(sess: &Session, attrs: &[Attribute]) -> Option<Symbol> {\n }\n \n /// Tests if a cfg-pattern matches the cfg set\n-pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool {\n+pub fn cfg_matches(\n+    cfg: &ast::MetaItem,\n+    sess: &ParseSess,\n+    lint_node_id: NodeId,\n+    features: Option<&Features>,\n+) -> bool {\n     eval_condition(cfg, sess, features, &mut |cfg| {\n         try_gate_cfg(cfg, sess, features);\n         let error = |span, msg| {\n@@ -470,7 +474,7 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n                         sess.buffer_lint_with_diagnostic(\n                             UNEXPECTED_CFGS,\n                             cfg.span,\n-                            CRATE_NODE_ID,\n+                            lint_node_id,\n                             \"unexpected `cfg` condition name\",\n                             BuiltinLintDiagnostics::UnexpectedCfg(ident.span, name, None),\n                         );\n@@ -482,7 +486,7 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n                             sess.buffer_lint_with_diagnostic(\n                                 UNEXPECTED_CFGS,\n                                 cfg.span,\n-                                CRATE_NODE_ID,\n+                                lint_node_id,\n                                 \"unexpected `cfg` condition value\",\n                                 BuiltinLintDiagnostics::UnexpectedCfg(\n                                     cfg.name_value_literal_span().unwrap(),"}, {"sha": "684a3ced5a0700725ab43d86dc20ce920cec2d3a", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -5,16 +5,21 @@ use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::ObligationCause;\n use rustc_middle::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory,\n     FakeReadCause, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{self, suggest_constraining_type_param, Ty};\n+use rustc_middle::ty::{\n+    self, suggest_constraining_type_param, suggest_constraining_type_params, PredicateKind, Ty,\n+};\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::TraitEngineExt as _;\n \n use crate::borrow_set::TwoPhaseActivation;\n use crate::borrowck_errors;\n@@ -423,7 +428,63 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             None,\n                         );\n                     }\n+                } else {\n+                    // Try to find predicates on *generic params* that would allow copying `ty`\n+\n+                    let tcx = self.infcx.tcx;\n+                    let generics = tcx.generics_of(self.mir_def_id());\n+                    if let Some(hir_generics) = tcx\n+                        .typeck_root_def_id(self.mir_def_id().to_def_id())\n+                        .as_local()\n+                        .and_then(|def_id| tcx.hir().get_generics(def_id))\n+                    {\n+                        let predicates: Result<Vec<_>, _> = tcx.infer_ctxt().enter(|infcx| {\n+                            let mut fulfill_cx =\n+                                <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n+\n+                            let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n+                            let cause = ObligationCause::new(\n+                                span,\n+                                self.mir_hir_id(),\n+                                rustc_infer::traits::ObligationCauseCode::MiscObligation,\n+                            );\n+                            fulfill_cx.register_bound(&infcx, self.param_env, ty, copy_did, cause);\n+                            let errors = fulfill_cx.select_where_possible(&infcx);\n+\n+                            // Only emit suggestion if all required predicates are on generic\n+                            errors\n+                                .into_iter()\n+                                .map(|err| match err.obligation.predicate.kind().skip_binder() {\n+                                    PredicateKind::Trait(predicate) => {\n+                                        match predicate.self_ty().kind() {\n+                                            ty::Param(param_ty) => Ok((\n+                                                generics.type_param(param_ty, tcx),\n+                                                predicate\n+                                                    .trait_ref\n+                                                    .print_only_trait_path()\n+                                                    .to_string(),\n+                                            )),\n+                                            _ => Err(()),\n+                                        }\n+                                    }\n+                                    _ => Err(()),\n+                                })\n+                                .collect()\n+                        });\n+\n+                        if let Ok(predicates) = predicates {\n+                            suggest_constraining_type_params(\n+                                tcx,\n+                                hir_generics,\n+                                &mut err,\n+                                predicates.iter().map(|(param, constraint)| {\n+                                    (param.name.as_str(), &**constraint, None)\n+                                }),\n+                            );\n+                        }\n+                    }\n                 }\n+\n                 let span = if let Some(local) = place.as_local() {\n                     let decl = &self.body.local_decls[local];\n                     Some(decl.source_info.span)"}, {"sha": "f5ef4765df64f9240d899b228ab1be8a4cdec524", "filename": "compiler/rustc_builtin_macros/src/cfg.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -19,7 +19,12 @@ pub fn expand_cfg(\n \n     match parse_cfg(cx, sp, tts) {\n         Ok(cfg) => {\n-            let matches_cfg = attr::cfg_matches(&cfg, &cx.sess.parse_sess, cx.ecfg.features);\n+            let matches_cfg = attr::cfg_matches(\n+                &cfg,\n+                &cx.sess.parse_sess,\n+                cx.current_expansion.lint_node_id,\n+                cx.ecfg.features,\n+            );\n             MacEager::expr(cx.expr_bool(sp, matches_cfg))\n         }\n         Err(mut err) => {"}, {"sha": "3c8f8f1854bf2934ff72e4cd8de0ff63b8e29813", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -5,6 +5,7 @@ use rustc_ast::mut_visit::MutVisitor;\n use rustc_ast::ptr::P;\n use rustc_ast::tokenstream::CanSynthesizeMissingTokens;\n use rustc_ast::visit::Visitor;\n+use rustc_ast::NodeId;\n use rustc_ast::{mut_visit, visit};\n use rustc_ast::{AstLike, Attribute};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n@@ -26,15 +27,16 @@ crate fn expand(\n ) -> Vec<Annotatable> {\n     check_builtin_macro_attribute(ecx, meta_item, sym::cfg_eval);\n     warn_on_duplicate_attribute(&ecx, &annotatable, sym::cfg_eval);\n-    vec![cfg_eval(ecx.sess, ecx.ecfg.features, annotatable)]\n+    vec![cfg_eval(ecx.sess, ecx.ecfg.features, annotatable, ecx.current_expansion.lint_node_id)]\n }\n \n crate fn cfg_eval(\n     sess: &Session,\n     features: Option<&Features>,\n     annotatable: Annotatable,\n+    lint_node_id: NodeId,\n ) -> Annotatable {\n-    CfgEval { cfg: &mut StripUnconfigured { sess, features, config_tokens: true } }\n+    CfgEval { cfg: &mut StripUnconfigured { sess, features, config_tokens: true, lint_node_id } }\n         .configure_annotatable(annotatable)\n         // Since the item itself has already been configured by the `InvocationCollector`,\n         // we know that fold result vector will contain exactly one element."}, {"sha": "61681ec66a48dfdea63284c47f358021af72b9bb", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -64,7 +64,12 @@ impl MultiItemModifier for Expander {\n                 match &mut resolutions[..] {\n                     [] => {}\n                     [(_, first_item, _), others @ ..] => {\n-                        *first_item = cfg_eval(sess, features, item.clone());\n+                        *first_item = cfg_eval(\n+                            sess,\n+                            features,\n+                            item.clone(),\n+                            ecx.current_expansion.lint_node_id,\n+                        );\n                         for (_, item, _) in others {\n                             *item = first_item.clone();\n                         }"}, {"sha": "6e9e0332faf604c7ba033cb1a0bf26de8d5ddafb", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -576,12 +576,12 @@ pub enum PassKind {\n     Module,\n }\n \n-/// LLVMRustThinLTOData\n+// LLVMRustThinLTOData\n extern \"C\" {\n     pub type ThinLTOData;\n }\n \n-/// LLVMRustThinLTOBuffer\n+// LLVMRustThinLTOBuffer\n extern \"C\" {\n     pub type ThinLTOBuffer;\n }"}, {"sha": "9cc06ac0319698ddbe64e962585a8a78f34c2b78", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -1,4 +1,5 @@\n use rustc_arena::TypedArena;\n+use rustc_ast::CRATE_NODE_ID;\n use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::temp_dir::MaybeTempDir;\n@@ -2434,7 +2435,7 @@ fn add_upstream_native_libraries(\n \n fn relevant_lib(sess: &Session, lib: &NativeLib) -> bool {\n     match lib.cfg {\n-        Some(ref cfg) => rustc_attr::cfg_matches(cfg, &sess.parse_sess, None),\n+        Some(ref cfg) => rustc_attr::cfg_matches(cfg, &sess.parse_sess, CRATE_NODE_ID, None),\n         None => true,\n     }\n }"}, {"sha": "d43c6fec7d5ad4efde6b308e3b72eab0946c92b0", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -5,6 +5,7 @@ use rustc_ast::token::{DelimToken, Token, TokenKind};\n use rustc_ast::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n use rustc_ast::tokenstream::{DelimSpan, Spacing};\n use rustc_ast::tokenstream::{LazyTokenStream, TokenTree};\n+use rustc_ast::NodeId;\n use rustc_ast::{self as ast, AstLike, AttrStyle, Attribute, MetaItem};\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n@@ -29,6 +30,7 @@ pub struct StripUnconfigured<'a> {\n     /// This is only used for the input to derive macros,\n     /// which needs eager expansion of `cfg` and `cfg_attr`\n     pub config_tokens: bool,\n+    pub lint_node_id: NodeId,\n }\n \n fn get_features(\n@@ -196,8 +198,13 @@ fn get_features(\n }\n \n // `cfg_attr`-process the crate's attributes and compute the crate's features.\n-pub fn features(sess: &Session, mut krate: ast::Crate) -> (ast::Crate, Features) {\n-    let mut strip_unconfigured = StripUnconfigured { sess, features: None, config_tokens: false };\n+pub fn features(\n+    sess: &Session,\n+    mut krate: ast::Crate,\n+    lint_node_id: NodeId,\n+) -> (ast::Crate, Features) {\n+    let mut strip_unconfigured =\n+        StripUnconfigured { sess, features: None, config_tokens: false, lint_node_id };\n \n     let unconfigured_attrs = krate.attrs.clone();\n     let diag = &sess.parse_sess.span_diagnostic;\n@@ -353,7 +360,12 @@ impl<'a> StripUnconfigured<'a> {\n             );\n         }\n \n-        if !attr::cfg_matches(&cfg_predicate, &self.sess.parse_sess, self.features) {\n+        if !attr::cfg_matches(\n+            &cfg_predicate,\n+            &self.sess.parse_sess,\n+            self.lint_node_id,\n+            self.features,\n+        ) {\n             return vec![];\n         }\n \n@@ -445,7 +457,7 @@ impl<'a> StripUnconfigured<'a> {\n             }\n         };\n         parse_cfg(&meta_item, &self.sess).map_or(true, |meta_item| {\n-            attr::cfg_matches(&meta_item, &self.sess.parse_sess, self.features)\n+            attr::cfg_matches(&meta_item, &self.sess.parse_sess, self.lint_node_id, self.features)\n         })\n     }\n "}, {"sha": "1b9761805093974a6012d674821ebb66b919c345", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -551,11 +551,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 // attribute is expanded. Therefore, we don't need to configure the tokens\n                 // Derive macros *can* see the results of cfg-expansion - they are handled\n                 // specially in `fully_expand_fragment`\n-                cfg: StripUnconfigured {\n-                    sess: &self.cx.sess,\n-                    features: self.cx.ecfg.features,\n-                    config_tokens: false,\n-                },\n                 cx: self.cx,\n                 invocations: Vec::new(),\n                 monotonic: self.monotonic,\n@@ -1538,12 +1533,20 @@ impl InvocationCollectorNode for AstLikeWrapper<P<ast::Expr>, OptExprTag> {\n \n struct InvocationCollector<'a, 'b> {\n     cx: &'a mut ExtCtxt<'b>,\n-    cfg: StripUnconfigured<'a>,\n     invocations: Vec<(Invocation, Option<Lrc<SyntaxExtension>>)>,\n     monotonic: bool,\n }\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n+    fn cfg(&self) -> StripUnconfigured<'_> {\n+        StripUnconfigured {\n+            sess: &self.cx.sess,\n+            features: self.cx.ecfg.features,\n+            config_tokens: false,\n+            lint_node_id: self.cx.current_expansion.lint_node_id,\n+        }\n+    }\n+\n     fn collect(&mut self, fragment_kind: AstFragmentKind, kind: InvocationKind) -> AstFragment {\n         let expn_id = LocalExpnId::fresh_empty();\n         let vis = kind.placeholder_visibility();\n@@ -1683,7 +1686,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         attr: ast::Attribute,\n         pos: usize,\n     ) -> bool {\n-        let res = self.cfg.cfg_true(&attr);\n+        let res = self.cfg().cfg_true(&attr);\n         if res {\n             // FIXME: `cfg(TRUE)` attributes do not currently remove themselves during expansion,\n             // and some tools like rustdoc and clippy rely on that. Find a way to remove them\n@@ -1696,7 +1699,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn expand_cfg_attr(&self, node: &mut impl AstLike, attr: ast::Attribute, pos: usize) {\n         node.visit_attrs(|attrs| {\n-            attrs.splice(pos..pos, self.cfg.expand_cfg_attr(attr, false));\n+            attrs.splice(pos..pos, self.cfg().expand_cfg_attr(attr, false));\n         });\n     }\n \n@@ -1718,7 +1721,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                         continue;\n                     }\n                     _ => {\n-                        Node::pre_flat_map_node_collect_attr(&self.cfg, &attr);\n+                        Node::pre_flat_map_node_collect_attr(&self.cfg(), &attr);\n                         self.collect_attr((attr, pos, derives), node.to_annotatable(), Node::KIND)\n                             .make_ast::<Node>()\n                     }\n@@ -1882,7 +1885,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn visit_expr(&mut self, node: &mut P<ast::Expr>) {\n         // FIXME: Feature gating is performed inconsistently between `Expr` and `OptExpr`.\n         if let Some(attr) = node.attrs.first() {\n-            self.cfg.maybe_emit_expr_attr_err(attr);\n+            self.cfg().maybe_emit_expr_attr_err(attr);\n         }\n         self.visit_node(node)\n     }"}, {"sha": "3b51f8eb61c8e83a2397bfc794487329c132359e", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -2,6 +2,7 @@ use crate::interface::{Compiler, Result};\n use crate::proc_macro_decls;\n use crate::util;\n \n+use ast::CRATE_NODE_ID;\n use rustc_ast::mut_visit::MutVisitor;\n use rustc_ast::{self as ast, visit};\n use rustc_borrowck as mir_borrowck;\n@@ -188,7 +189,7 @@ pub fn register_plugins<'a>(\n         )\n     });\n \n-    let (krate, features) = rustc_expand::config::features(sess, krate);\n+    let (krate, features) = rustc_expand::config::features(sess, krate, CRATE_NODE_ID);\n     // these need to be set \"early\" so that expansion sees `quote` if enabled.\n     sess.init_features(features);\n "}, {"sha": "72b8d8bb297a6b8a486814726ddf34851b73ac31", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -1086,6 +1086,16 @@ impl EarlyLintPass for UnusedDocComment {\n     fn check_generic_param(&mut self, cx: &EarlyContext<'_>, param: &ast::GenericParam) {\n         warn_if_doc(cx, param.ident.span, \"generic parameters\", &param.attrs);\n     }\n+\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n+        warn_if_doc(cx, block.span, \"block\", &block.attrs());\n+    }\n+\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n+        if let ast::ItemKind::ForeignMod(_) = item.kind {\n+            warn_if_doc(cx, item.span, \"extern block\", &item.attrs);\n+        }\n+    }\n }\n \n declare_lint! {"}, {"sha": "7cdcb6a4ab302604c30cb4fb95c1f1937cc56610", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -1,3 +1,4 @@\n+use rustc_ast::CRATE_NODE_ID;\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n@@ -21,7 +22,7 @@ crate fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLib> {\n \n crate fn relevant_lib(sess: &Session, lib: &NativeLib) -> bool {\n     match lib.cfg {\n-        Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n+        Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, CRATE_NODE_ID, None),\n         None => true,\n     }\n }"}, {"sha": "f977b0fffebb665cdf53258d9914e60abd15b297", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -56,6 +56,7 @@\n #![feature(nonzero_ops)]\n #![feature(unwrap_infallible)]\n #![feature(decl_macro)]\n+#![feature(drain_filter)]\n #![recursion_limit = \"512\"]\n #![allow(rustc::potential_query_instability)]\n "}, {"sha": "13c325a14e4023ac0ef7237421c715968875c912", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -7,6 +7,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_hir::ItemId;\n+use rustc_index::vec::Idx;\n use rustc_query_system::ich::{NodeIdHashingMode, StableHashingContext};\n use rustc_session::config::OptLevel;\n use rustc_span::source_map::Span;\n@@ -380,7 +381,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             // instances into account. The others don't matter for\n                             // the codegen tests and can even make item order\n                             // unstable.\n-                            InstanceDef::Item(def) => Some(def.did.index.as_usize()),\n+                            InstanceDef::Item(def) => def.did.as_local().map(Idx::index),\n                             InstanceDef::VtableShim(..)\n                             | InstanceDef::ReifyShim(..)\n                             | InstanceDef::Intrinsic(..)\n@@ -391,10 +392,8 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             | InstanceDef::CloneShim(..) => None,\n                         }\n                     }\n-                    MonoItem::Static(def_id) => Some(def_id.index.as_usize()),\n-                    MonoItem::GlobalAsm(item_id) => {\n-                        Some(item_id.def_id.to_def_id().index.as_usize())\n-                    }\n+                    MonoItem::Static(def_id) => def_id.as_local().map(Idx::index),\n+                    MonoItem::GlobalAsm(item_id) => Some(item_id.def_id.index()),\n                 },\n                 item.symbol_name(tcx),\n             )"}, {"sha": "99a3d4c7fe4f7c11f301e6e17621909103c4d343", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 235, "deletions": 163, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -7,6 +7,7 @@ use crate::ty::{\n     ProjectionTy, Term, Ty, TyCtxt, TypeAndMut,\n };\n \n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -157,9 +158,17 @@ pub fn suggest_arbitrary_trait_bound(\n     true\n }\n \n+#[derive(Debug)]\n+enum SuggestChangingConstraintsMessage<'a> {\n+    RestrictBoundFurther,\n+    RestrictType { ty: &'a str },\n+    RestrictTypeFurther { ty: &'a str },\n+    RemovingQSized,\n+}\n+\n fn suggest_removing_unsized_bound(\n     generics: &hir::Generics<'_>,\n-    err: &mut Diagnostic,\n+    suggestions: &mut Vec<(Span, String, SuggestChangingConstraintsMessage<'_>)>,\n     param_name: &str,\n     param: &hir::GenericParam<'_>,\n     def_id: Option<DefId>,\n@@ -221,13 +230,12 @@ fn suggest_removing_unsized_bound(\n                         //             ^^^^^^^^^\n                         (_, pos, _, _) => bounds[pos - 1].span().shrink_to_hi().to(bound.span()),\n                     };\n-                    err.span_suggestion_verbose(\n+\n+                    suggestions.push((\n                         sp,\n-                        \"consider removing the `?Sized` bound to make the \\\n-                            type parameter `Sized`\",\n                         String::new(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                        SuggestChangingConstraintsMessage::RemovingQSized,\n+                    ));\n                 }\n             }\n             _ => {}\n@@ -249,13 +257,12 @@ fn suggest_removing_unsized_bound(\n                     //       ^^^^^^^^^\n                     (_, pos) => param.bounds[pos - 1].span().shrink_to_hi().to(bound.span()),\n                 };\n-                err.span_suggestion_verbose(\n+\n+                suggestions.push((\n                     sp,\n-                    \"consider removing the `?Sized` bound to make the type parameter \\\n-                        `Sized`\",\n                     String::new(),\n-                    Applicability::MaybeIncorrect,\n-                );\n+                    SuggestChangingConstraintsMessage::RemovingQSized,\n+                ));\n             }\n             _ => {}\n         }\n@@ -271,184 +278,249 @@ pub fn suggest_constraining_type_param(\n     constraint: &str,\n     def_id: Option<DefId>,\n ) -> bool {\n-    let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n+    suggest_constraining_type_params(\n+        tcx,\n+        generics,\n+        err,\n+        [(param_name, constraint, def_id)].into_iter(),\n+    )\n+}\n \n-    let Some(param) = param else {\n-        return false;\n-    };\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_params<'a>(\n+    tcx: TyCtxt<'_>,\n+    generics: &hir::Generics<'_>,\n+    err: &mut Diagnostic,\n+    param_names_and_constraints: impl Iterator<Item = (&'a str, &'a str, Option<DefId>)>,\n+) -> bool {\n+    let mut grouped = FxHashMap::default();\n+    param_names_and_constraints.for_each(|(param_name, constraint, def_id)| {\n+        grouped.entry(param_name).or_insert(Vec::new()).push((constraint, def_id))\n+    });\n \n-    const MSG_RESTRICT_BOUND_FURTHER: &str = \"consider further restricting this bound\";\n-    let msg_restrict_type = format!(\"consider restricting type parameter `{}`\", param_name);\n-    let msg_restrict_type_further =\n-        format!(\"consider further restricting type parameter `{}`\", param_name);\n+    let mut applicability = Applicability::MachineApplicable;\n+    let mut suggestions = Vec::new();\n \n-    if def_id == tcx.lang_items().sized_trait() {\n-        // Type parameters are already `Sized` by default.\n-        err.span_label(param.span, &format!(\"this type parameter needs to be `{}`\", constraint));\n-        suggest_removing_unsized_bound(generics, err, param_name, param, def_id);\n-        return true;\n-    }\n-    let mut suggest_restrict = |span| {\n-        err.span_suggestion_verbose(\n-            span,\n-            MSG_RESTRICT_BOUND_FURTHER,\n-            format!(\" + {}\", constraint),\n-            Applicability::MachineApplicable,\n-        );\n-    };\n+    for (param_name, mut constraints) in grouped {\n+        let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n+        let Some(param) = param else { return false };\n \n-    if param_name.starts_with(\"impl \") {\n-        // If there's an `impl Trait` used in argument position, suggest\n-        // restricting it:\n-        //\n-        //   fn foo(t: impl Foo) { ... }\n-        //             --------\n-        //             |\n-        //             help: consider further restricting this bound with `+ Bar`\n-        //\n-        // Suggestion for tools in this case is:\n-        //\n-        //   fn foo(t: impl Foo) { ... }\n-        //             --------\n-        //             |\n-        //             replace with: `impl Foo + Bar`\n-\n-        suggest_restrict(param.span.shrink_to_hi());\n-        return true;\n-    }\n+        {\n+            let mut sized_constraints =\n+                constraints.drain_filter(|(_, def_id)| *def_id == tcx.lang_items().sized_trait());\n+            if let Some((constraint, def_id)) = sized_constraints.next() {\n+                applicability = Applicability::MaybeIncorrect;\n \n-    if generics.where_clause.predicates.is_empty()\n-        // Given `trait Base<T = String>: Super<T>` where `T: Copy`, suggest restricting in the\n-        // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n-        && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n-    {\n-        if let Some(span) = param.bounds_span_for_suggestions() {\n-            // If user has provided some bounds, suggest restricting them:\n+                err.span_label(\n+                    param.span,\n+                    &format!(\"this type parameter needs to be `{}`\", constraint),\n+                );\n+                suggest_removing_unsized_bound(\n+                    generics,\n+                    &mut suggestions,\n+                    param_name,\n+                    param,\n+                    def_id,\n+                );\n+            }\n+        }\n+\n+        if constraints.is_empty() {\n+            continue;\n+        }\n+\n+        let constraint = constraints.iter().map(|&(c, _)| c).collect::<Vec<_>>().join(\" + \");\n+        let mut suggest_restrict = |span| {\n+            suggestions.push((\n+                span,\n+                format!(\" + {}\", constraint),\n+                SuggestChangingConstraintsMessage::RestrictBoundFurther,\n+            ))\n+        };\n+\n+        if param_name.starts_with(\"impl \") {\n+            // If there's an `impl Trait` used in argument position, suggest\n+            // restricting it:\n             //\n-            //   fn foo<T: Foo>(t: T) { ... }\n-            //             ---\n+            //   fn foo(t: impl Foo) { ... }\n+            //             --------\n             //             |\n             //             help: consider further restricting this bound with `+ Bar`\n             //\n             // Suggestion for tools in this case is:\n             //\n-            //   fn foo<T: Foo>(t: T) { ... }\n-            //          --\n-            //          |\n-            //          replace with: `T: Bar +`\n-            suggest_restrict(span);\n-        } else {\n-            // If user hasn't provided any bounds, suggest adding a new one:\n-            //\n-            //   fn foo<T>(t: T) { ... }\n-            //          - help: consider restricting this type parameter with `T: Foo`\n-            err.span_suggestion_verbose(\n-                param.span.shrink_to_hi(),\n-                &msg_restrict_type,\n-                format!(\": {}\", constraint),\n-                Applicability::MachineApplicable,\n-            );\n+            //   fn foo(t: impl Foo) { ... }\n+            //             --------\n+            //             |\n+            //             replace with: `impl Foo + Bar`\n+\n+            suggest_restrict(param.span.shrink_to_hi());\n+            continue;\n         }\n \n-        true\n-    } else {\n-        // This part is a bit tricky, because using the `where` clause user can\n-        // provide zero, one or many bounds for the same type parameter, so we\n-        // have following cases to consider:\n-        //\n-        // 1) When the type parameter has been provided zero bounds\n-        //\n-        //    Message:\n-        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n-        //             - help: consider restricting this type parameter with `where X: Bar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n-        //                                           - insert: `, X: Bar`\n-        //\n-        //\n-        // 2) When the type parameter has been provided one bound\n-        //\n-        //    Message:\n-        //      fn foo<T>(t: T) where T: Foo { ... }\n-        //                            ^^^^^^\n-        //                            |\n-        //                            help: consider further restricting this bound with `+ Bar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<T>(t: T) where T: Foo { ... }\n-        //                            ^^\n-        //                            |\n-        //                            replace with: `T: Bar +`\n-        //\n-        //\n-        // 3) When the type parameter has been provided many bounds\n-        //\n-        //    Message:\n-        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-        //             - help: consider further restricting this type parameter with `where T: Zar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-        //                                          - insert: `, T: Zar`\n-        //\n-        // Additionally, there may be no `where` clause whatsoever in the case that this was\n-        // reached because the generic parameter has a default:\n-        //\n-        //    Message:\n-        //      trait Foo<T=()> {... }\n-        //             - help: consider further restricting this type parameter with `where T: Zar`\n-        //\n-        //    Suggestion:\n-        //      trait Foo<T=()> where T: Zar {... }\n-        //                     - insert: `where T: Zar`\n-\n-        if matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n-            && generics.where_clause.predicates.len() == 0\n+        if generics.where_clause.predicates.is_empty()\n+        // Given `trait Base<T = String>: Super<T>` where `T: Copy`, suggest restricting in the\n+        // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n+        && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n         {\n-            // Suggest a bound, but there is no existing `where` clause *and* the type param has a\n-            // default (`<T=Foo>`), so we suggest adding `where T: Bar`.\n-            err.span_suggestion_verbose(\n-                generics.where_clause.tail_span_for_suggestion(),\n-                &msg_restrict_type_further,\n-                format!(\" where {}: {}\", param_name, constraint),\n-                Applicability::MachineApplicable,\n-            );\n+            if let Some(span) = param.bounds_span_for_suggestions() {\n+                // If user has provided some bounds, suggest restricting them:\n+                //\n+                //   fn foo<T: Foo>(t: T) { ... }\n+                //             ---\n+                //             |\n+                //             help: consider further restricting this bound with `+ Bar`\n+                //\n+                // Suggestion for tools in this case is:\n+                //\n+                //   fn foo<T: Foo>(t: T) { ... }\n+                //          --\n+                //          |\n+                //          replace with: `T: Bar +`\n+                suggest_restrict(span);\n+            } else {\n+                // If user hasn't provided any bounds, suggest adding a new one:\n+                //\n+                //   fn foo<T>(t: T) { ... }\n+                //          - help: consider restricting this type parameter with `T: Foo`\n+                suggestions.push((\n+                    param.span.shrink_to_hi(),\n+                    format!(\": {}\", constraint),\n+                    SuggestChangingConstraintsMessage::RestrictType { ty: param_name },\n+                ));\n+            }\n         } else {\n-            let mut param_spans = Vec::new();\n+            // This part is a bit tricky, because using the `where` clause user can\n+            // provide zero, one or many bounds for the same type parameter, so we\n+            // have following cases to consider:\n+            //\n+            // 1) When the type parameter has been provided zero bounds\n+            //\n+            //    Message:\n+            //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n+            //             - help: consider restricting this type parameter with `where X: Bar`\n+            //\n+            //    Suggestion:\n+            //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n+            //                                           - insert: `, X: Bar`\n+            //\n+            //\n+            // 2) When the type parameter has been provided one bound\n+            //\n+            //    Message:\n+            //      fn foo<T>(t: T) where T: Foo { ... }\n+            //                            ^^^^^^\n+            //                            |\n+            //                            help: consider further restricting this bound with `+ Bar`\n+            //\n+            //    Suggestion:\n+            //      fn foo<T>(t: T) where T: Foo { ... }\n+            //                            ^^\n+            //                            |\n+            //                            replace with: `T: Bar +`\n+            //\n+            //\n+            // 3) When the type parameter has been provided many bounds\n+            //\n+            //    Message:\n+            //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n+            //             - help: consider further restricting this type parameter with `where T: Zar`\n+            //\n+            //    Suggestion:\n+            //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n+            //                                          - insert: `, T: Zar`\n+            //\n+            // Additionally, there may be no `where` clause whatsoever in the case that this was\n+            // reached because the generic parameter has a default:\n+            //\n+            //    Message:\n+            //      trait Foo<T=()> {... }\n+            //             - help: consider further restricting this type parameter with `where T: Zar`\n+            //\n+            //    Suggestion:\n+            //      trait Foo<T=()> where T: Zar {... }\n+            //                     - insert: `where T: Zar`\n \n-            for predicate in generics.where_clause.predicates {\n-                if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                    span,\n-                    bounded_ty,\n-                    ..\n-                }) = predicate\n-                {\n-                    if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n-                        if let Some(segment) = path.segments.first() {\n-                            if segment.ident.to_string() == param_name {\n-                                param_spans.push(span);\n+            if matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n+                && generics.where_clause.predicates.len() == 0\n+            {\n+                // Suggest a bound, but there is no existing `where` clause *and* the type param has a\n+                // default (`<T=Foo>`), so we suggest adding `where T: Bar`.\n+                suggestions.push((\n+                    generics.where_clause.tail_span_for_suggestion(),\n+                    format!(\" where {}: {}\", param_name, constraint),\n+                    SuggestChangingConstraintsMessage::RestrictTypeFurther { ty: param_name },\n+                ));\n+            } else {\n+                let mut param_spans = Vec::new();\n+\n+                for predicate in generics.where_clause.predicates {\n+                    if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n+                        span,\n+                        bounded_ty,\n+                        ..\n+                    }) = predicate\n+                    {\n+                        if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n+                            if let Some(segment) = path.segments.first() {\n+                                if segment.ident.to_string() == param_name {\n+                                    param_spans.push(span);\n+                                }\n                             }\n                         }\n                     }\n                 }\n-            }\n \n-            match param_spans[..] {\n-                [&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n-                _ => {\n-                    err.span_suggestion_verbose(\n-                        generics.where_clause.tail_span_for_suggestion(),\n-                        &msg_restrict_type_further,\n-                        format!(\", {}: {}\", param_name, constraint),\n-                        Applicability::MachineApplicable,\n-                    );\n+                match param_spans[..] {\n+                    [&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n+                    _ => {\n+                        suggestions.push((\n+                            generics.where_clause.tail_span_for_suggestion(),\n+                            constraints\n+                                .iter()\n+                                .map(|&(constraint, _)| format!(\", {}: {}\", param_name, constraint))\n+                                .collect::<String>(),\n+                            SuggestChangingConstraintsMessage::RestrictTypeFurther {\n+                                ty: param_name,\n+                            },\n+                        ));\n+                    }\n                 }\n             }\n         }\n+    }\n \n-        true\n+    if suggestions.len() == 1 {\n+        let (span, suggestion, msg) = suggestions.pop().unwrap();\n+\n+        let s;\n+        let msg = match msg {\n+            SuggestChangingConstraintsMessage::RestrictBoundFurther => {\n+                \"consider further restricting this bound\"\n+            }\n+            SuggestChangingConstraintsMessage::RestrictType { ty } => {\n+                s = format!(\"consider restricting type parameter `{}`\", ty);\n+                &s\n+            }\n+            SuggestChangingConstraintsMessage::RestrictTypeFurther { ty } => {\n+                s = format!(\"consider further restricting type parameter `{}`\", ty);\n+                &s\n+            }\n+            SuggestChangingConstraintsMessage::RemovingQSized => {\n+                \"consider removing the `?Sized` bound to make the type parameter `Sized`\"\n+            }\n+        };\n+\n+        err.span_suggestion_verbose(span, msg, suggestion, applicability);\n+    } else {\n+        err.multipart_suggestion_verbose(\n+            \"consider restricting type parameters\",\n+            suggestions.into_iter().map(|(span, suggestion, _)| (span, suggestion)).collect(),\n+            applicability,\n+        );\n     }\n+\n+    true\n }\n \n /// Collect al types that have an implicit `'static` obligation that we could suggest `'_` for."}, {"sha": "f01843ebabacf75e3c6fd87a315f014339658567", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -276,11 +276,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // we suggest adding a separate return expression instead.\n             // (To avoid things like suggesting `Ok(while .. { .. })`.)\n             if expr_ty.is_unit() {\n+                let mut id = expr.hir_id;\n+                let mut parent;\n+\n+                // Unroll desugaring, to make sure this works for `for` loops etc.\n+                loop {\n+                    parent = self.tcx.hir().get_parent_node(id);\n+                    if let Some(parent_span) = self.tcx.hir().opt_span(parent) {\n+                        if parent_span.find_ancestor_inside(expr.span).is_some() {\n+                            // The parent node is part of the same span, so is the result of the\n+                            // same expansion/desugaring and not the 'real' parent node.\n+                            id = parent;\n+                            continue;\n+                        }\n+                    }\n+                    break;\n+                }\n+\n                 if let Some(hir::Node::Block(&hir::Block {\n                     span: block_span, expr: Some(e), ..\n-                })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n+                })) = self.tcx.hir().find(parent)\n                 {\n-                    if e.hir_id == expr.hir_id {\n+                    if e.hir_id == id {\n                         if let Some(span) = expr.span.find_ancestor_inside(block_span) {\n                             let return_suggestions =\n                                 if self.tcx.is_diagnostic_item(sym::Result, expected_adt.did) {"}, {"sha": "2b611e5aae276b0acc773d4d87dbb269ab67572f", "filename": "library/core/src/ffi/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -117,7 +117,7 @@ mod c_char_definition {\n             all(target_os = \"android\", any(target_arch = \"aarch64\", target_arch = \"arm\")),\n             all(target_os = \"l4re\", target_arch = \"x86_64\"),\n             all(\n-                target_os = \"freebsd\",\n+                any(target_os = \"freebsd\", target_os = \"openbsd\"),\n                 any(\n                     target_arch = \"aarch64\",\n                     target_arch = \"arm\",\n@@ -130,7 +130,6 @@ mod c_char_definition {\n                 target_os = \"netbsd\",\n                 any(target_arch = \"aarch64\", target_arch = \"arm\", target_arch = \"powerpc\")\n             ),\n-            all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n             all(\n                 target_os = \"vxworks\",\n                 any("}, {"sha": "cf2c0a02351ed2fe3d7f332670b3a36057f258cd", "filename": "library/portable-simd/crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -18,9 +18,10 @@\n //!\n //! Unless stated otherwise, all intrinsics for binary operations require SIMD vectors of equal types and lengths.\n \n-/// These intrinsics aren't linked directly from LLVM and are mostly undocumented, however they are\n-/// mostly lowered to the matching LLVM instructions by the compiler in a fairly straightforward manner.\n-/// The associated LLVM instruction or intrinsic is documented alongside each Rust intrinsic function.\n+\n+// These intrinsics aren't linked directly from LLVM and are mostly undocumented, however they are\n+// mostly lowered to the matching LLVM instructions by the compiler in a fairly straightforward manner.\n+// The associated LLVM instruction or intrinsic is documented alongside each Rust intrinsic function.\n extern \"platform-intrinsic\" {\n     /// add/fadd\n     pub(crate) fn simd_add<T>(x: T, y: T) -> T;"}, {"sha": "13bb079194fbe06d1ecec28b5a14dfa28f0f2c10", "filename": "library/std/src/os/fd/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fmod.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -11,3 +11,6 @@ pub mod owned;\n \n // Implementations for `AsRawFd` etc. for network types.\n mod net;\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "807b057234ac1e3be37f786349bf2a6c8c5f7033", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -21,6 +21,10 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n /// descriptor, so it can be used in FFI in places where a file descriptor is\n /// passed as an argument, it is not captured or consumed, and it never has the\n /// value `-1`.\n+///\n+/// This type's `.to_owned()` implementation returns another `BorrowedFd`\n+/// rather than an `OwnedFd`. It just makes a trivial copy of the raw file\n+/// descriptor, which is then borrowed under the same lifetime.\n #[derive(Copy, Clone)]\n #[repr(transparent)]\n #[rustc_layout_scalar_valid_range_start(0)]\n@@ -62,7 +66,7 @@ impl BorrowedFd<'_> {\n     /// the returned `BorrowedFd`, and it must not have the value `-1`.\n     #[inline]\n     #[unstable(feature = \"io_safety\", issue = \"87074\")]\n-    pub unsafe fn borrow_raw_fd(fd: RawFd) -> Self {\n+    pub unsafe fn borrow_raw(fd: RawFd) -> Self {\n         assert_ne!(fd, u32::MAX as RawFd);\n         // SAFETY: we just asserted that the value is in the valid range and isn't `-1` (the only value bigger than `0xFF_FF_FF_FE` unsigned)\n         unsafe { Self { fd, _phantom: PhantomData } }\n@@ -231,7 +235,7 @@ impl AsFd for OwnedFd {\n         // Safety: `OwnedFd` and `BorrowedFd` have the same validity\n         // invariants, and the `BorrowdFd` is bounded by the lifetime\n         // of `&self`.\n-        unsafe { BorrowedFd::borrow_raw_fd(self.as_raw_fd()) }\n+        unsafe { BorrowedFd::borrow_raw(self.as_raw_fd()) }\n     }\n }\n "}, {"sha": "26ef93e3d7110a1f5d9020fd95ef69597b175534", "filename": "library/std/src/os/fd/tests.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fstd%2Fsrc%2Fos%2Ffd%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fstd%2Fsrc%2Fos%2Ffd%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Ftests.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -0,0 +1,34 @@\n+#[cfg(any(unix, target_os = \"wasi\"))]\n+#[test]\n+fn test_raw_fd() {\n+    #[cfg(unix)]\n+    use crate::os::unix::io::{AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd};\n+    #[cfg(target_os = \"wasi\")]\n+    use crate::os::wasi::io::{AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd};\n+\n+    let raw_fd: RawFd = crate::io::stdin().as_raw_fd();\n+\n+    let stdin_as_file = unsafe { crate::fs::File::from_raw_fd(raw_fd) };\n+    assert_eq!(stdin_as_file.as_raw_fd(), raw_fd);\n+    assert_eq!(unsafe { BorrowedFd::borrow_raw(raw_fd).as_raw_fd() }, raw_fd);\n+    assert_eq!(stdin_as_file.into_raw_fd(), 0);\n+}\n+\n+#[cfg(any(unix, target_os = \"wasi\"))]\n+#[test]\n+fn test_fd() {\n+    #[cfg(unix)]\n+    use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n+    #[cfg(target_os = \"wasi\")]\n+    use crate::os::wasi::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n+\n+    let stdin = crate::io::stdin();\n+    let fd: BorrowedFd<'_> = stdin.as_fd();\n+    let raw_fd: RawFd = fd.as_raw_fd();\n+    let owned_fd: OwnedFd = unsafe { OwnedFd::from_raw_fd(raw_fd) };\n+\n+    let stdin_as_file = crate::fs::File::from(owned_fd);\n+\n+    assert_eq!(stdin_as_file.as_fd().as_raw_fd(), raw_fd);\n+    assert_eq!(Into::<OwnedFd>::into(stdin_as_file).into_raw_fd(), raw_fd);\n+}"}, {"sha": "842a15ae1bfc02764efee9744599fb89e3c5bfcc", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -28,6 +28,10 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n /// And, it *may* have the value `NULL` (0), which can occur when consoles are\n /// detached from processes, or when `windows_subsystem` is used.\n ///\n+/// This type's `.to_owned()` implementation returns another `BorrowedHandle`\n+/// rather than an `OwnedHandle`. It just makes a trivial copy of the raw\n+/// handle, which is then borrowed under the same lifetime.\n+///\n /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n #[derive(Copy, Clone)]\n #[repr(transparent)]\n@@ -131,7 +135,7 @@ impl BorrowedHandle<'_> {\n     /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n     #[inline]\n     #[unstable(feature = \"io_safety\", issue = \"87074\")]\n-    pub unsafe fn borrow_raw_handle(handle: RawHandle) -> Self {\n+    pub unsafe fn borrow_raw(handle: RawHandle) -> Self {\n         Self { handle, _phantom: PhantomData }\n     }\n }\n@@ -345,7 +349,7 @@ impl AsHandle for OwnedHandle {\n         // Safety: `OwnedHandle` and `BorrowedHandle` have the same validity\n         // invariants, and the `BorrowdHandle` is bounded by the lifetime\n         // of `&self`.\n-        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }\n     }\n }\n \n@@ -373,49 +377,49 @@ impl From<OwnedHandle> for fs::File {\n impl AsHandle for crate::io::Stdin {\n     #[inline]\n     fn as_handle(&self) -> BorrowedHandle<'_> {\n-        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }\n     }\n }\n \n impl<'a> AsHandle for crate::io::StdinLock<'a> {\n     #[inline]\n     fn as_handle(&self) -> BorrowedHandle<'_> {\n-        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }\n     }\n }\n \n impl AsHandle for crate::io::Stdout {\n     #[inline]\n     fn as_handle(&self) -> BorrowedHandle<'_> {\n-        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }\n     }\n }\n \n impl<'a> AsHandle for crate::io::StdoutLock<'a> {\n     #[inline]\n     fn as_handle(&self) -> BorrowedHandle<'_> {\n-        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }\n     }\n }\n \n impl AsHandle for crate::io::Stderr {\n     #[inline]\n     fn as_handle(&self) -> BorrowedHandle<'_> {\n-        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }\n     }\n }\n \n impl<'a> AsHandle for crate::io::StderrLock<'a> {\n     #[inline]\n     fn as_handle(&self) -> BorrowedHandle<'_> {\n-        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }\n     }\n }\n \n impl AsHandle for crate::process::ChildStdin {\n     #[inline]\n     fn as_handle(&self) -> BorrowedHandle<'_> {\n-        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }\n     }\n }\n \n@@ -429,7 +433,7 @@ impl From<crate::process::ChildStdin> for OwnedHandle {\n impl AsHandle for crate::process::ChildStdout {\n     #[inline]\n     fn as_handle(&self) -> BorrowedHandle<'_> {\n-        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }\n     }\n }\n \n@@ -443,7 +447,7 @@ impl From<crate::process::ChildStdout> for OwnedHandle {\n impl AsHandle for crate::process::ChildStderr {\n     #[inline]\n     fn as_handle(&self) -> BorrowedHandle<'_> {\n-        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }\n     }\n }\n \n@@ -457,7 +461,7 @@ impl From<crate::process::ChildStderr> for OwnedHandle {\n impl<T> AsHandle for crate::thread::JoinHandle<T> {\n     #[inline]\n     fn as_handle(&self) -> BorrowedHandle<'_> {\n-        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+        unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }\n     }\n }\n "}, {"sha": "a695a4106e81004f8cd6e912fdf5604088e0f28d", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -21,6 +21,10 @@ use crate::sys::cvt;\n /// so it can be used in FFI in places where a socket is passed as an argument,\n /// it is not captured or consumed, and it never has the value\n /// `INVALID_SOCKET`.\n+///\n+/// This type's `.to_owned()` implementation returns another `BorrowedSocket`\n+/// rather than an `OwnedSocket`. It just makes a trivial copy of the raw\n+/// socket, which is then borrowed under the same lifetime.\n #[derive(Copy, Clone)]\n #[repr(transparent)]\n #[rustc_layout_scalar_valid_range_start(0)]\n@@ -67,7 +71,7 @@ impl BorrowedSocket<'_> {\n     /// `INVALID_SOCKET`.\n     #[inline]\n     #[unstable(feature = \"io_safety\", issue = \"87074\")]\n-    pub unsafe fn borrow_raw_socket(socket: RawSocket) -> Self {\n+    pub unsafe fn borrow_raw(socket: RawSocket) -> Self {\n         debug_assert_ne!(socket, c::INVALID_SOCKET as RawSocket);\n         Self { socket, _phantom: PhantomData }\n     }\n@@ -239,14 +243,14 @@ impl AsSocket for OwnedSocket {\n         // Safety: `OwnedSocket` and `BorrowedSocket` have the same validity\n         // invariants, and the `BorrowdSocket` is bounded by the lifetime\n         // of `&self`.\n-        unsafe { BorrowedSocket::borrow_raw_socket(self.as_raw_socket()) }\n+        unsafe { BorrowedSocket::borrow_raw(self.as_raw_socket()) }\n     }\n }\n \n impl AsSocket for crate::net::TcpStream {\n     #[inline]\n     fn as_socket(&self) -> BorrowedSocket<'_> {\n-        unsafe { BorrowedSocket::borrow_raw_socket(self.as_raw_socket()) }\n+        unsafe { BorrowedSocket::borrow_raw(self.as_raw_socket()) }\n     }\n }\n \n@@ -267,7 +271,7 @@ impl From<OwnedSocket> for crate::net::TcpStream {\n impl AsSocket for crate::net::TcpListener {\n     #[inline]\n     fn as_socket(&self) -> BorrowedSocket<'_> {\n-        unsafe { BorrowedSocket::borrow_raw_socket(self.as_raw_socket()) }\n+        unsafe { BorrowedSocket::borrow_raw(self.as_raw_socket()) }\n     }\n }\n \n@@ -288,7 +292,7 @@ impl From<OwnedSocket> for crate::net::TcpListener {\n impl AsSocket for crate::net::UdpSocket {\n     #[inline]\n     fn as_socket(&self) -> BorrowedSocket<'_> {\n-        unsafe { BorrowedSocket::borrow_raw_socket(self.as_raw_socket()) }\n+        unsafe { BorrowedSocket::borrow_raw(self.as_raw_socket()) }\n     }\n }\n "}, {"sha": "e4d83ba0ffd1335e3cefd3c6c9edfe16f1091685", "filename": "library/std/src/sys/unix/stdio.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstdio.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -96,46 +96,46 @@ pub fn panic_output() -> Option<impl io::Write> {\n impl AsFd for io::Stdin {\n     #[inline]\n     fn as_fd(&self) -> BorrowedFd<'_> {\n-        unsafe { BorrowedFd::borrow_raw_fd(libc::STDIN_FILENO) }\n+        unsafe { BorrowedFd::borrow_raw(libc::STDIN_FILENO) }\n     }\n }\n \n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl<'a> AsFd for io::StdinLock<'a> {\n     #[inline]\n     fn as_fd(&self) -> BorrowedFd<'_> {\n-        unsafe { BorrowedFd::borrow_raw_fd(libc::STDIN_FILENO) }\n+        unsafe { BorrowedFd::borrow_raw(libc::STDIN_FILENO) }\n     }\n }\n \n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl AsFd for io::Stdout {\n     #[inline]\n     fn as_fd(&self) -> BorrowedFd<'_> {\n-        unsafe { BorrowedFd::borrow_raw_fd(libc::STDOUT_FILENO) }\n+        unsafe { BorrowedFd::borrow_raw(libc::STDOUT_FILENO) }\n     }\n }\n \n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl<'a> AsFd for io::StdoutLock<'a> {\n     #[inline]\n     fn as_fd(&self) -> BorrowedFd<'_> {\n-        unsafe { BorrowedFd::borrow_raw_fd(libc::STDOUT_FILENO) }\n+        unsafe { BorrowedFd::borrow_raw(libc::STDOUT_FILENO) }\n     }\n }\n \n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl AsFd for io::Stderr {\n     #[inline]\n     fn as_fd(&self) -> BorrowedFd<'_> {\n-        unsafe { BorrowedFd::borrow_raw_fd(libc::STDERR_FILENO) }\n+        unsafe { BorrowedFd::borrow_raw(libc::STDERR_FILENO) }\n     }\n }\n \n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl<'a> AsFd for io::StderrLock<'a> {\n     #[inline]\n     fn as_fd(&self) -> BorrowedFd<'_> {\n-        unsafe { BorrowedFd::borrow_raw_fd(libc::STDERR_FILENO) }\n+        unsafe { BorrowedFd::borrow_raw(libc::STDERR_FILENO) }\n     }\n }"}, {"sha": "bcbe010614f398ec86f3a9274d22e33e5f2ee60b", "filename": "library/stdarch", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstdarch?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -1 +1 @@\n-Subproject commit b4a0e07552cf90ef8f1a5b775bf70e4db94b3d63\n+Subproject commit bcbe010614f398ec86f3a9274d22e33e5f2ee60b"}, {"sha": "4c05818440b09a504699cd36a35d1230e157e52e", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -139,7 +139,7 @@ target | std | notes\n `armv7r-none-eabi` | * | Bare ARMv7-R\n `armv7r-none-eabihf` | * | Bare ARMv7-R, hardfloat\n `asmjs-unknown-emscripten` | \u2713 | asm.js via Emscripten\n-`i586-pc-windows-msvc` | \u2713 | 32-bit Windows w/o SSE\n+`i586-pc-windows-msvc` | * | 32-bit Windows w/o SSE\n `i586-unknown-linux-gnu` | \u2713 | 32-bit Linux w/o SSE (kernel 4.4, glibc 2.23)\n `i586-unknown-linux-musl` | \u2713 | 32-bit Linux w/o SSE, MUSL\n `i686-linux-android` | \u2713 | 32-bit x86 Android\n@@ -236,7 +236,7 @@ target | std | host | notes\n `hexagon-unknown-linux-musl` | ? |  |\n `i386-apple-ios` | \u2713 |  | 32-bit x86 iOS\n `i686-apple-darwin` | \u2713 | \u2713 | 32-bit macOS (10.7+, Lion+)\n-`i686-pc-windows-msvc` | \u2713 |  | 32-bit Windows XP support\n+`i686-pc-windows-msvc` | * |  | 32-bit Windows XP support\n `i686-unknown-haiku` | \u2713 | \u2713 | 32-bit Haiku\n `i686-unknown-netbsd` | \u2713 | \u2713 | NetBSD/i386 with SSE2\n [`i686-unknown-openbsd`](platform-support/openbsd.md) | \u2713 | \u2713 | 32-bit OpenBSD\n@@ -283,7 +283,7 @@ target | std | host | notes\n [`wasm64-unknown-unknown`](platform-support/wasm64-unknown-unknown.md) | ? |  | WebAssembly\n `x86_64-apple-ios-macabi` | \u2713 |  | Apple Catalyst on x86_64\n `x86_64-apple-tvos` | * | | x86 64-bit tvOS\n-`x86_64-pc-windows-msvc` | \u2713 |  | 64-bit Windows XP support\n+`x86_64-pc-windows-msvc` | * |  | 64-bit Windows XP support\n `x86_64-sun-solaris` | ? |  | Deprecated target for 64-bit Solaris 10/11, illumos\n `x86_64-unknown-dragonfly` | \u2713 | \u2713 | 64-bit DragonFlyBSD\n `x86_64-unknown-haiku` | \u2713 | \u2713 | 64-bit Haiku"}, {"sha": "b29f8b4a029d08ff0cf75a4668584d3f05d1318b", "filename": "src/test/codegen/debuginfo-generic-closure-env-names.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fcodegen%2Fdebuginfo-generic-closure-env-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fcodegen%2Fdebuginfo-generic-closure-env-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdebuginfo-generic-closure-env-names.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -3,7 +3,7 @@\n // of the enclosing functions don't get lost.\n //\n // Unfortunately, the order that debuginfo gets emitted into LLVM IR becomes a bit hard\n-// to predict once async fns are involved.\n+// to predict once async fns are involved, so DAG allows any order.\n //\n // Note that the test does not check async-fns when targeting MSVC because debuginfo for\n // those does not follow the enum-fallback encoding yet and thus is incomplete.\n@@ -27,24 +27,24 @@\n // CHECK: ![[generic_async_block_NAMESPACE:[0-9]+]] = !DINamespace(name: \"generic_async_block\"\n \n // function_containing_closure<u32>()\n-// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{closure_env#0}<u32>\", scope: ![[function_containing_closure_NAMESPACE]]\n-// MSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"closure_env$0<u32>\", scope: ![[function_containing_closure_NAMESPACE]]\n+// NONMSVC-DAG: !DICompositeType(tag: DW_TAG_structure_type, name: \"{closure_env#0}<u32>\", scope: ![[function_containing_closure_NAMESPACE]]\n+// MSVC-DAG: !DICompositeType(tag: DW_TAG_structure_type, name: \"closure_env$0<u32>\", scope: ![[function_containing_closure_NAMESPACE]]\n \n // generic_async_function<Foo>()\n-// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_fn_env#0}<debuginfo_generic_closure_env_names::Foo>\", scope: ![[generic_async_function_NAMESPACE]]\n+// NONMSVC-DAG: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_fn_env#0}<debuginfo_generic_closure_env_names::Foo>\", scope: ![[generic_async_function_NAMESPACE]]\n \n // generic_async_function<u32>()\n-// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_fn_env#0}<u32>\", scope: ![[generic_async_function_NAMESPACE]]\n+// NONMSVC-DAG: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_fn_env#0}<u32>\", scope: ![[generic_async_function_NAMESPACE]]\n \n // generic_async_block<Foo>()\n-// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_block_env#0}<debuginfo_generic_closure_env_names::Foo>\", scope: ![[generic_async_block_NAMESPACE]]\n+// NONMSVC-DAG: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_block_env#0}<debuginfo_generic_closure_env_names::Foo>\", scope: ![[generic_async_block_NAMESPACE]]\n \n // generic_async_block<u32>()\n-// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_block_env#0}<u32>\", scope: ![[generic_async_block_NAMESPACE]]\n+// NONMSVC-DAG: !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_block_env#0}<u32>\", scope: ![[generic_async_block_NAMESPACE]]\n \n // function_containing_closure<Foo>()\n-// NONMSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"{closure_env#0}<debuginfo_generic_closure_env_names::Foo>\", scope: ![[function_containing_closure_NAMESPACE]]\n-// MSVC: !DICompositeType(tag: DW_TAG_structure_type, name: \"closure_env$0<debuginfo_generic_closure_env_names::Foo>\", scope: ![[function_containing_closure_NAMESPACE]]\n+// NONMSVC-DAG: !DICompositeType(tag: DW_TAG_structure_type, name: \"{closure_env#0}<debuginfo_generic_closure_env_names::Foo>\", scope: ![[function_containing_closure_NAMESPACE]]\n+// MSVC-DAG: !DICompositeType(tag: DW_TAG_structure_type, name: \"closure_env$0<debuginfo_generic_closure_env_names::Foo>\", scope: ![[function_containing_closure_NAMESPACE]]\n \n \n #![crate_type = \"lib\"]"}, {"sha": "7d43b575d2f66611eaf1c9c81a499a30122db121", "filename": "src/test/ui/async-await/proper-span-for-type-error.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fasync-await%2Fproper-span-for-type-error.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fasync-await%2Fproper-span-for-type-error.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fproper-span-for-type-error.fixed?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -5,7 +5,8 @@\n async fn a() {}\n \n async fn foo() -> Result<(), i32> {\n-    Ok(a().await) //~ ERROR mismatched types\n+    a().await;\n+    Ok(()) //~ ERROR mismatched types\n }\n \n fn main() {}"}, {"sha": "25f05156ce2bc57b4d60a55443a3dac2e8107b6c", "filename": "src/test/ui/async-await/proper-span-for-type-error.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fasync-await%2Fproper-span-for-type-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fasync-await%2Fproper-span-for-type-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fproper-span-for-type-error.stderr?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -6,10 +6,11 @@ LL |     a().await\n    |\n    = note:   expected enum `Result<(), i32>`\n            found unit type `()`\n-help: try wrapping the expression in `Ok`\n+help: try adding an expression at the end of the block\n+   |\n+LL ~     a().await;\n+LL ~     Ok(())\n    |\n-LL |     Ok(a().await)\n-   |     +++         +\n \n error: aborting due to previous error\n "}, {"sha": "8016a4d190cc32477ee59dae83b5e0849ab56aed", "filename": "src/test/ui/check-cfg/allow-macro-cfg.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fcheck-cfg%2Fallow-macro-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fcheck-cfg%2Fallow-macro-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fallow-macro-cfg.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -0,0 +1,14 @@\n+// This test check that local #[allow(unexpected_cfgs)] works\n+//\n+// check-pass\n+// compile-flags:--check-cfg=names() -Z unstable-options\n+\n+#[allow(unexpected_cfgs)]\n+fn foo() {\n+    if cfg!(FALSE) {}\n+}\n+\n+fn main() {\n+    #[allow(unexpected_cfgs)]\n+    if cfg!(FALSE) {}\n+}"}, {"sha": "6c869dc420235e1bc1181cf9eec1d5766f4c7b29", "filename": "src/test/ui/check-cfg/allow-same-level.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fcheck-cfg%2Fallow-same-level.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fcheck-cfg%2Fallow-same-level.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fallow-same-level.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -0,0 +1,11 @@\n+// This test check that #[allow(unexpected_cfgs)] doesn't work if put on the same level\n+//\n+// check-pass\n+// compile-flags:--check-cfg=names() -Z unstable-options\n+\n+#[allow(unexpected_cfgs)]\n+#[cfg(FALSE)]\n+//~^ WARNING unexpected `cfg` condition name\n+fn bar() {}\n+\n+fn main() {}"}, {"sha": "7797de584b9e1f1354c0b829d0b4e6b3db29352b", "filename": "src/test/ui/check-cfg/allow-same-level.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fcheck-cfg%2Fallow-same-level.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fcheck-cfg%2Fallow-same-level.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fallow-same-level.stderr?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -0,0 +1,10 @@\n+warning: unexpected `cfg` condition name\n+  --> $DIR/allow-same-level.rs:7:7\n+   |\n+LL | #[cfg(FALSE)]\n+   |       ^^^^^\n+   |\n+   = note: `#[warn(unexpected_cfgs)]` on by default\n+\n+warning: 1 warning emitted\n+"}, {"sha": "d14b0eae5ccdd7c8caa680e6dffac5aa51d9e48c", "filename": "src/test/ui/check-cfg/allow-top-level.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fcheck-cfg%2Fallow-top-level.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fcheck-cfg%2Fallow-top-level.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fallow-top-level.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -0,0 +1,15 @@\n+// This test check that a top-level #![allow(unexpected_cfgs)] works\n+//\n+// check-pass\n+// compile-flags:--check-cfg=names() -Z unstable-options\n+\n+#![allow(unexpected_cfgs)]\n+\n+#[cfg(FALSE)]\n+fn bar() {}\n+\n+fn foo() {\n+    if cfg!(FALSE) {}\n+}\n+\n+fn main() {}"}, {"sha": "04340694d9c1e333fc4af061966860d75502de30", "filename": "src/test/ui/check-cfg/allow-upper-level.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fcheck-cfg%2Fallow-upper-level.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fcheck-cfg%2Fallow-upper-level.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fallow-upper-level.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -0,0 +1,12 @@\n+// This test check that #[allow(unexpected_cfgs)] work if put on an upper level\n+//\n+// check-pass\n+// compile-flags:--check-cfg=names() -Z unstable-options\n+\n+#[allow(unexpected_cfgs)]\n+mod aa {\n+    #[cfg(FALSE)]\n+    fn bar() {}\n+}\n+\n+fn main() {}"}, {"sha": "b078064b26745c6835dd24319219c027d6e69b18", "filename": "src/test/ui/did_you_mean/compatible-variants.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -23,6 +23,21 @@ fn b() -> Result<(), ()> {\n     //~| HELP try adding an expression\n }\n \n+fn c() -> Option<()> {\n+    for _ in [1, 2] {\n+        //~^ ERROR mismatched types\n+        f();\n+    }\n+    //~^ HELP try adding an expression\n+}\n+\n+fn d() -> Option<()> {\n+    c()?\n+    //~^ ERROR incompatible types\n+    //~| HELP try removing this `?`\n+    //~| HELP try adding an expression\n+}\n+\n fn main() {\n     let _: Option<()> = while false {};\n     //~^ ERROR mismatched types"}, {"sha": "51c1bf97c4e2c5c91df8b341fac1ec8b2e778bbf", "filename": "src/test/ui/did_you_mean/compatible-variants.stderr", "status": "modified", "additions": 53, "deletions": 8, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -37,7 +37,52 @@ LL +     Ok(())\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:27:25\n+  --> $DIR/compatible-variants.rs:27:5\n+   |\n+LL |   fn c() -> Option<()> {\n+   |             ---------- expected `Option<()>` because of return type\n+LL | /     for _ in [1, 2] {\n+LL | |\n+LL | |         f();\n+LL | |     }\n+   | |_____^ expected enum `Option`, found `()`\n+   |\n+   = note:   expected enum `Option<()>`\n+           found unit type `()`\n+help: try adding an expression at the end of the block\n+   |\n+LL ~     }\n+LL +     None\n+   |\n+LL ~     }\n+LL +     Some(())\n+   |\n+\n+error[E0308]: `?` operator has incompatible types\n+  --> $DIR/compatible-variants.rs:35:5\n+   |\n+LL |     c()?\n+   |     ^^^^ expected enum `Option`, found `()`\n+   |\n+   = note: `?` operator cannot convert from `()` to `Option<()>`\n+   = note:   expected enum `Option<()>`\n+           found unit type `()`\n+help: try removing this `?`\n+   |\n+LL -     c()?\n+LL +     c()\n+   | \n+help: try adding an expression at the end of the block\n+   |\n+LL ~     c()?;\n+LL +     None\n+   |\n+LL ~     c()?;\n+LL +     Some(())\n+   |\n+\n+error[E0308]: mismatched types\n+  --> $DIR/compatible-variants.rs:42:25\n    |\n LL |     let _: Option<()> = while false {};\n    |            ----------   ^^^^^^^^^^^^^^ expected enum `Option`, found `()`\n@@ -52,7 +97,7 @@ LL |     let _: Option<()> = Some(while false {});\n    |                         +++++              +\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:31:9\n+  --> $DIR/compatible-variants.rs:46:9\n    |\n LL |         while false {}\n    |         ^^^^^^^^^^^^^^ expected enum `Option`, found `()`\n@@ -69,7 +114,7 @@ LL +         Some(())\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:35:31\n+  --> $DIR/compatible-variants.rs:50:31\n    |\n LL |     let _: Result<i32, i32> = 1;\n    |            ----------------   ^ expected enum `Result`, found integer\n@@ -86,7 +131,7 @@ LL |     let _: Result<i32, i32> = Err(1);\n    |                               ++++ +\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:38:26\n+  --> $DIR/compatible-variants.rs:53:26\n    |\n LL |     let _: Option<i32> = 1;\n    |            -----------   ^ expected enum `Option`, found integer\n@@ -101,7 +146,7 @@ LL |     let _: Option<i32> = Some(1);\n    |                          +++++ +\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:41:28\n+  --> $DIR/compatible-variants.rs:56:28\n    |\n LL |     let _: Hey<i32, i32> = 1;\n    |            -------------   ^ expected enum `Hey`, found integer\n@@ -118,7 +163,7 @@ LL |     let _: Hey<i32, i32> = Hey::B(1);\n    |                            +++++++ +\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:44:29\n+  --> $DIR/compatible-variants.rs:59:29\n    |\n LL |     let _: Hey<i32, bool> = false;\n    |            --------------   ^^^^^ expected enum `Hey`, found `bool`\n@@ -133,7 +178,7 @@ LL |     let _: Hey<i32, bool> = Hey::B(false);\n    |                             +++++++     +\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:48:19\n+  --> $DIR/compatible-variants.rs:63:19\n    |\n LL |     let _ = Foo { bar };\n    |                   ^^^ expected enum `Option`, found `i32`\n@@ -145,6 +190,6 @@ help: try wrapping the expression in `Some`\n LL |     let _ = Foo { bar: Some(bar) };\n    |                   ++++++++++   +\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 11 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "54d86c31fb4fbb0e97e3854ae4bebb6be1b779d0", "filename": "src/test/ui/lint/unused/unused-doc-comments-edge-cases.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Flint%2Funused%2Funused-doc-comments-edge-cases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Flint%2Funused%2Funused-doc-comments-edge-cases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused-doc-comments-edge-cases.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -29,4 +29,18 @@ fn doc_comment_on_expr(num: u8) -> bool {\n fn doc_comment_on_generic<#[doc = \"x\"] T>(val: T) {}\n //~^ ERROR: unused doc comment\n \n+fn doc_comment_on_block() {\n+    /// unused doc comment\n+    //~^ ERROR: unused doc comment\n+    {\n+        let x = 12;\n+    }\n+}\n+\n+/// unused doc comment\n+//~^ ERROR: unused doc comment\n+extern \"C\" {\n+    fn foo();\n+}\n+\n fn main() {}"}, {"sha": "30a96af583af77d3a841b4e5cd2fd91cb1a9c662", "filename": "src/test/ui/lint/unused/unused-doc-comments-edge-cases.stderr", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Flint%2Funused%2Funused-doc-comments-edge-cases.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Flint%2Funused%2Funused-doc-comments-edge-cases.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused-doc-comments-edge-cases.stderr?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -49,6 +49,32 @@ LL | fn doc_comment_on_generic<#[doc = \"x\"] T>(val: T) {}\n    |\n    = help: use `//` for a plain comment\n \n+error: unused doc comment\n+  --> $DIR/unused-doc-comments-edge-cases.rs:33:5\n+   |\n+LL |       /// unused doc comment\n+   |       ^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | /     {\n+LL | |         let x = 12;\n+LL | |     }\n+   | |_____- rustdoc does not generate documentation for expressions\n+   |\n+   = help: use `//` for a plain comment\n+\n+error: unused doc comment\n+  --> $DIR/unused-doc-comments-edge-cases.rs:40:1\n+   |\n+LL |   /// unused doc comment\n+   |   ^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | / extern \"C\" {\n+LL | |     fn foo();\n+LL | | }\n+   | |_- rustdoc does not generate documentation for extern block\n+   |\n+   = help: use `//` for a plain comment\n+\n error[E0308]: mismatched types\n   --> $DIR/unused-doc-comments-edge-cases.rs:14:9\n    |\n@@ -63,7 +89,7 @@ help: you might have meant to return this value\n LL |         return true;\n    |         ++++++     +\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 8 previous errors\n \n Some errors have detailed explanations: E0308, E0658.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "d5c8d4e6bdf2b76852167e32974a089fc06f70ec", "filename": "src/test/ui/moves/use_of_moved_value_clone_suggestions.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_clone_suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_clone_suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_clone_suggestions.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -0,0 +1,6 @@\n+// `Rc` is not ever `Copy`, we should not suggest adding `T: Copy` constraint\n+fn duplicate_rc<T>(t: std::rc::Rc<T>) -> (std::rc::Rc<T>, std::rc::Rc<T>) {\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn main() {}"}, {"sha": "c25981e6f80634cc73dedb1d7996f1b9d65fe932", "filename": "src/test/ui/moves/use_of_moved_value_clone_suggestions.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_clone_suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_clone_suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_clone_suggestions.stderr?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -0,0 +1,13 @@\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_clone_suggestions.rs:3:9\n+   |\n+LL | fn duplicate_rc<T>(t: std::rc::Rc<T>) -> (std::rc::Rc<T>, std::rc::Rc<T>) {\n+   |                    - move occurs because `t` has type `Rc<T>`, which does not implement the `Copy` trait\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "d31046c77006e1c68dfb8bf9d20edb08370fa996", "filename": "src/test/ui/moves/use_of_moved_value_copy_suggestions.fixed", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.fixed?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -0,0 +1,72 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+fn duplicate_t<T: Copy>(t: T) -> (T, T) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_opt<T: Copy>(t: Option<T>) -> (Option<T>, Option<T>) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_tup1<T: Copy>(t: (T,)) -> ((T,), (T,)) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_tup2<A: Copy, B: Copy>(t: (A, B)) -> ((A, B), (A, B)) {\n+    //~^ HELP consider restricting type parameters\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom<T: Trait + Copy>(t: S<T>) -> (S<T>, S<T>) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+struct S<T>(T);\n+trait Trait {}\n+impl<T: Trait + Clone> Clone for S<T> {\n+    fn clone(&self) -> Self {\n+        Self(self.0.clone())\n+    }\n+}\n+impl<T: Trait + Copy> Copy for S<T> {}\n+\n+trait A {}\n+trait B {}\n+\n+// Test where bounds are added with different bound placements\n+fn duplicate_custom_1<T: Trait + Copy>(t: S<T>) -> (S<T>, S<T>) where {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom_2<T>(t: S<T>) -> (S<T>, S<T>)\n+where\n+    T: A + Trait + Copy,\n+    //~^ HELP consider further restricting this bound\n+{\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom_3<T>(t: S<T>) -> (S<T>, S<T>)\n+where\n+    T: A,\n+    T: B, T: Trait, T: Copy\n+    //~^ HELP consider further restricting type parameter `T`\n+{\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom_4<T: A>(t: S<T>) -> (S<T>, S<T>)\n+where\n+    T: B + Trait + Copy,\n+    //~^ HELP consider further restricting this bound\n+{\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn main() {}"}, {"sha": "7cc5189fac017effed958a966bf67aa7c09d1a3e", "filename": "src/test/ui/moves/use_of_moved_value_copy_suggestions.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.rs?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -0,0 +1,72 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+fn duplicate_t<T>(t: T) -> (T, T) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_opt<T>(t: Option<T>) -> (Option<T>, Option<T>) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_tup1<T>(t: (T,)) -> ((T,), (T,)) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_tup2<A, B>(t: (A, B)) -> ((A, B), (A, B)) {\n+    //~^ HELP consider restricting type parameters\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom<T>(t: S<T>) -> (S<T>, S<T>) {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+struct S<T>(T);\n+trait Trait {}\n+impl<T: Trait + Clone> Clone for S<T> {\n+    fn clone(&self) -> Self {\n+        Self(self.0.clone())\n+    }\n+}\n+impl<T: Trait + Copy> Copy for S<T> {}\n+\n+trait A {}\n+trait B {}\n+\n+// Test where bounds are added with different bound placements\n+fn duplicate_custom_1<T>(t: S<T>) -> (S<T>, S<T>) where {\n+    //~^ HELP consider restricting type parameter `T`\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom_2<T>(t: S<T>) -> (S<T>, S<T>)\n+where\n+    T: A,\n+    //~^ HELP consider further restricting this bound\n+{\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom_3<T>(t: S<T>) -> (S<T>, S<T>)\n+where\n+    T: A,\n+    T: B,\n+    //~^ HELP consider further restricting type parameter `T`\n+{\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn duplicate_custom_4<T: A>(t: S<T>) -> (S<T>, S<T>)\n+where\n+    T: B,\n+    //~^ HELP consider further restricting this bound\n+{\n+    (t, t) //~ use of moved value: `t`\n+}\n+\n+fn main() {}"}, {"sha": "8e72697ca30bbafce9810285c8b6ad80c5f5f93b", "filename": "src/test/ui/moves/use_of_moved_value_copy_suggestions.stderr", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.stderr?ref=2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "patch": "@@ -0,0 +1,147 @@\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:6:9\n+   |\n+LL | fn duplicate_t<T>(t: T) -> (T, T) {\n+   |                   - move occurs because `t` has type `T`, which does not implement the `Copy` trait\n+LL |\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn duplicate_t<T: Copy>(t: T) -> (T, T) {\n+   |                 ++++++\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:11:9\n+   |\n+LL | fn duplicate_opt<T>(t: Option<T>) -> (Option<T>, Option<T>) {\n+   |                     - move occurs because `t` has type `Option<T>`, which does not implement the `Copy` trait\n+LL |\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn duplicate_opt<T: Copy>(t: Option<T>) -> (Option<T>, Option<T>) {\n+   |                   ++++++\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:16:9\n+   |\n+LL | fn duplicate_tup1<T>(t: (T,)) -> ((T,), (T,)) {\n+   |                      - move occurs because `t` has type `(T,)`, which does not implement the `Copy` trait\n+LL |\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn duplicate_tup1<T: Copy>(t: (T,)) -> ((T,), (T,)) {\n+   |                    ++++++\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:21:9\n+   |\n+LL | fn duplicate_tup2<A, B>(t: (A, B)) -> ((A, B), (A, B)) {\n+   |                         - move occurs because `t` has type `(A, B)`, which does not implement the `Copy` trait\n+LL |\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider restricting type parameters\n+   |\n+LL | fn duplicate_tup2<A: Copy, B: Copy>(t: (A, B)) -> ((A, B), (A, B)) {\n+   |                    ++++++   ++++++\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:26:9\n+   |\n+LL | fn duplicate_custom<T>(t: S<T>) -> (S<T>, S<T>) {\n+   |                        - move occurs because `t` has type `S<T>`, which does not implement the `Copy` trait\n+LL |\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn duplicate_custom<T: Trait + Copy>(t: S<T>) -> (S<T>, S<T>) {\n+   |                      ++++++++++++++\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:44:9\n+   |\n+LL | fn duplicate_custom_1<T>(t: S<T>) -> (S<T>, S<T>) where {\n+   |                          - move occurs because `t` has type `S<T>`, which does not implement the `Copy` trait\n+LL |\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn duplicate_custom_1<T: Trait + Copy>(t: S<T>) -> (S<T>, S<T>) where {\n+   |                        ++++++++++++++\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:52:9\n+   |\n+LL | fn duplicate_custom_2<T>(t: S<T>) -> (S<T>, S<T>)\n+   |                          - move occurs because `t` has type `S<T>`, which does not implement the `Copy` trait\n+...\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider further restricting this bound\n+   |\n+LL |     T: A + Trait + Copy,\n+   |          ++++++++++++++\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:61:9\n+   |\n+LL | fn duplicate_custom_3<T>(t: S<T>) -> (S<T>, S<T>)\n+   |                          - move occurs because `t` has type `S<T>`, which does not implement the `Copy` trait\n+...\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider further restricting type parameter `T`\n+   |\n+LL |     T: B, T: Trait, T: Copy\n+   |         ~~~~~~~~~~~~~~~~~~~\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:69:9\n+   |\n+LL | fn duplicate_custom_4<T: A>(t: S<T>) -> (S<T>, S<T>)\n+   |                             - move occurs because `t` has type `S<T>`, which does not implement the `Copy` trait\n+...\n+LL |     (t, t)\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider further restricting this bound\n+   |\n+LL |     T: B + Trait + Copy,\n+   |          ++++++++++++++\n+\n+error: aborting due to 9 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}]}