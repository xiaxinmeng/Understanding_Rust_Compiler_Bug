{"sha": "7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMWI1ZDVhOGE5YWJhNmE2ODJmOTViN2M3Mzg5NDViZThlMWZjYTI=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-01T09:52:05Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-01T10:39:58Z"}, "message": "Implement autoderef for function calls.\n\nThis is important since we are going to be making functions noncopyable\nsoon, which means we'll be seeing a lot of boxed functions.\n(*f)(...) is really just too heavyweight.\n\nDoing the autodereferencing was a very little bit tricky since\ntrans_call works with an *lval* of the function whereas existing\nautoderef code was not for lvals.", "tree": {"sha": "6761fa6e9c26cb08259b4e656269493ab2ae699d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6761fa6e9c26cb08259b4e656269493ab2ae699d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2", "html_url": "https://github.com/rust-lang/rust/commit/7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee45d54a4e14c8ae809b0b6c3111260a3f39ba40", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee45d54a4e14c8ae809b0b6c3111260a3f39ba40", "html_url": "https://github.com/rust-lang/rust/commit/ee45d54a4e14c8ae809b0b6c3111260a3f39ba40"}], "stats": {"total": 92, "additions": 69, "deletions": 23}, "files": [{"sha": "9bd1473e4b122bd7e80920ad6b5354168386f909", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2", "patch": "@@ -663,7 +663,7 @@ fn def_is_local(&ast::def d, bool objfields_count) -> bool {\n }\n \n fn fty_args(&ctx cx, ty::t fty) -> ty::arg[] {\n-    ret alt (ty::struct(*cx.tcx, fty)) {\n+    ret alt (ty::struct(*cx.tcx, ty::type_autoderef(*cx.tcx, fty))) {\n             case (ty::ty_fn(_, ?args, _, _, _)) { args }\n             case (ty::ty_native_fn(_, ?args, _)) { args }\n         };"}, {"sha": "f83ca38985204ade90b01ae73e1f419d3c10c676", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2", "patch": "@@ -4099,12 +4099,18 @@ fn trans_eager_binop(&@block_ctxt cx, ast::binop op, &ty::t intype,\n     }\n }\n \n-fn autoderef(&@block_ctxt cx, ValueRef v, &ty::t t) -> result {\n+fn autoderef_lval(&@block_ctxt cx, ValueRef v, &ty::t t, bool is_lval)\n+    -> result {\n     let ValueRef v1 = v;\n     let ty::t t1 = t;\n     while (true) {\n         alt (ty::struct(cx.fcx.lcx.ccx.tcx, t1)) {\n             case (ty::ty_box(?mt)) {\n+                // If we are working with an lval, we want to\n+                // unconditionally load at the top of the loop\n+                // to get rid of the extra indirection\n+                if (is_lval) { v1 = cx.build.Load(v1); }\n+\n                 auto body =\n                     cx.build.GEP(v1,\n                                  [C_int(0), C_int(abi::box_rc_field_body)]);\n@@ -4118,14 +4124,22 @@ fn autoderef(&@block_ctxt cx, ValueRef v, &ty::t t) -> result {\n                     auto llty = type_of(cx.fcx.lcx.ccx, cx.sp, mt.ty);\n                     v1 = cx.build.PointerCast(body, T_ptr(llty));\n                 } else { v1 = body; }\n-                v1 = load_if_immediate(cx, v1, t1);\n+\n+                // But if we aren't working with an lval, we get rid of\n+                // a layer of indirection at the bottom of the loop so\n+                // that it is gone when we return...\n+                if (!is_lval) { v1 = load_if_immediate(cx, v1, t1); }\n             }\n             case (_) { break; }\n         }\n     }\n     ret rslt(cx, v1);\n }\n \n+fn autoderef(&@block_ctxt cx, ValueRef v, &ty::t t) -> result {\n+    ret autoderef_lval(cx, v, t, false);\n+}\n+\n fn trans_binary(&@block_ctxt cx, ast::binop op, &@ast::expr a, &@ast::expr b)\n    -> result {\n \n@@ -5637,17 +5651,33 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n     // with trans_call.\n \n     auto f_res = trans_lval(cx, f);\n+    let ty::t fn_ty;\n+    alt (f_res.method_ty) {\n+        case (some(?meth)) {\n+            // self-call\n+            fn_ty = meth;\n+        }\n+        case (_) {\n+            fn_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, f);\n+        }\n+    }\n+\n+    auto bcx = f_res.res.bcx;\n+\n     auto faddr = f_res.res.val;\n     auto llenv = C_null(T_opaque_closure_ptr(cx.fcx.lcx.ccx.tn));\n     alt (f_res.llobj) {\n         case (some(_)) {\n             // It's a vtbl entry.\n-            faddr = f_res.res.bcx.build.Load(faddr);\n+            faddr = bcx.build.Load(faddr);\n         }\n         case (none) {\n-            // It's a closure.\n-            auto bcx = f_res.res.bcx;\n-            auto pair = faddr;\n+            // It's a closure. We have to autoderef.\n+            auto res = autoderef_lval(bcx, f_res.res.val, fn_ty, true);\n+            bcx = res.bcx;\n+            fn_ty = ty::type_autoderef(bcx.fcx.lcx.ccx.tcx, fn_ty);\n+\n+            auto pair = res.val;\n             faddr =\n                 bcx.build.GEP(pair, [C_int(0), C_int(abi::fn_field_code)]);\n             faddr = bcx.build.Load(faddr);\n@@ -5656,19 +5686,12 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n             llenv = bcx.build.Load(llclosure);\n         }\n     }\n-    let ty::t fn_ty;\n-    alt (f_res.method_ty) {\n-        case (some(?meth)) {\n-            // self-call\n-            fn_ty = meth;\n-        }\n-        case (_) { fn_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, f); }\n-    }\n+\n     auto ret_ty = ty::node_id_to_type(cx.fcx.lcx.ccx.tcx, id);\n     auto args_res =\n-        trans_args(f_res.res.bcx, llenv, f_res.llobj, f_res.generic,\n+        trans_args(bcx, llenv, f_res.llobj, f_res.generic,\n                    lliterbody, args, fn_ty);\n-    auto bcx = args_res._0;\n+    bcx = args_res._0;\n     auto llargs = args_res._1;\n     auto llretslot = args_res._2;\n     /*"}, {"sha": "3cf16870d8691cc32ba7e4de5d9ea07691f005c9", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2", "patch": "@@ -1336,17 +1336,21 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n     // expressions.\n \n     fn check_call_or_bind(&@fn_ctxt fcx, &span sp, &@ast::expr f,\n-                          &vec[option::t[@ast::expr]] args) {\n+                          &vec[option::t[@ast::expr]] args, bool is_call) {\n         // Check the function.\n \n         check_expr(fcx, f);\n         // Get the function type.\n \n         auto fty = expr_ty(fcx.ccx.tcx, f);\n-        // Grab the argument types and the return type.\n \n+        // We want to autoderef calls but not binds\n+        auto fty_stripped =\n+            if (is_call) { strip_boxes(fcx, sp, fty) } else { fty };\n+\n+        // Grab the argument types and the return type.\n         auto arg_tys;\n-        alt (structure_of(fcx, sp, fty)) {\n+        alt (structure_of(fcx, sp, fty_stripped)) {\n             case (ty::ty_fn(_, ?arg_tys_0, _, _, _)) { arg_tys = arg_tys_0; }\n             case (ty::ty_native_fn(_, ?arg_tys_0, _)) { arg_tys = arg_tys_0; }\n             case (_) {\n@@ -1410,7 +1414,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         }\n         // Call the generic checker.\n \n-        check_call_or_bind(fcx, sp, f, args_opt_0);\n+        check_call_or_bind(fcx, sp, f, args_opt_0, true);\n     }\n     // A generic function for checking for or for-each loops\n \n@@ -1806,7 +1810,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         case (ast::expr_bind(?f, ?args)) {\n             // Call the generic checker.\n \n-            check_call_or_bind(fcx, expr.span, f, args);\n+            check_call_or_bind(fcx, expr.span, f, args, false);\n             // Pull the argument and return types out.\n \n             auto proto_1;\n@@ -1855,7 +1859,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             // Pull the return type out of the type of the function.\n \n             auto rt_1;\n-            auto fty = ty::expr_ty(fcx.ccx.tcx, f);\n+            auto fty = strip_boxes(fcx, expr.span,\n+                                   ty::expr_ty(fcx.ccx.tcx, f));\n             alt (structure_of(fcx, expr.span, fty)) {\n                 case (ty::ty_fn(_, _, ?rt, _, _)) { rt_1 = rt; }\n                 case (ty::ty_native_fn(_, _, ?rt)) { rt_1 = rt; }"}, {"sha": "51f76be6289d62257f91dc116c6acc0e072cd1e8", "filename": "src/test/compile-fail/auto-deref-bind.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2/src%2Ftest%2Fcompile-fail%2Fauto-deref-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2/src%2Ftest%2Fcompile-fail%2Fauto-deref-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauto-deref-bind.rs?ref=7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2", "patch": "@@ -0,0 +1,7 @@\n+// error-pattern: mismatched types\n+\n+fn add1(int i) -> int { ret i+1; }\n+fn main() {\n+    auto f = @add1;\n+    auto g = bind f(5);\n+}"}, {"sha": "6959e8e109f34e299168a357ad61ef4b649e855d", "filename": "src/test/run-pass/auto-deref-fn.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2/src%2Ftest%2Frun-pass%2Fauto-deref-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2/src%2Ftest%2Frun-pass%2Fauto-deref-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-deref-fn.rs?ref=7b1b5d5a8a9aba6a682f95b7c738945be8e1fca2", "patch": "@@ -0,0 +1,11 @@\n+// xfail-stage0\n+\n+fn add1(int i) -> int { ret i+1; }\n+fn main() {\n+    auto f = @add1;\n+    auto g = @f;\n+    auto h = @@@add1;\n+    assert(f(5) == 6);\n+    assert(g(8) == 9);\n+    assert(h(0x1badd00d) == 0x1badd00e);\n+}"}]}