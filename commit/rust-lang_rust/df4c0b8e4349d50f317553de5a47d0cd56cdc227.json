{"sha": "df4c0b8e4349d50f317553de5a47d0cd56cdc227", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNGMwYjhlNDM0OWQ1MGYzMTc1NTNkZTVhNDdkMGNkNTZjZGMyMjc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-07T23:13:06Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:11Z"}, "message": "Make the uv bindings resilient to linked failure\n\nIn the ideal world, uv I/O could be canceled safely at any time. In reality,\nhowever, we are unable to do this. Right now linked failure is fairly flaky as\nimplemented in the runtime, making it very difficult to test whether the linked\nfailure mechanisms inside of the uv bindings are ready for this kind of\ninteraction.\n\nRight now, all constructors will execute in a task::unkillable block, and all\nhoming I/O operations will prevent linked failure in the duration of the homing\noperation. What this means is that tasks which perform I/O are still susceptible\nto linked failure, but the I/O operations themselves will never get interrupted.\nInstead, the linked failure will be received at the edge of the I/O operation.", "tree": {"sha": "470f0312c30becfa07aca3284a200c6d912e876b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/470f0312c30becfa07aca3284a200c6d912e876b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df4c0b8e4349d50f317553de5a47d0cd56cdc227", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df4c0b8e4349d50f317553de5a47d0cd56cdc227", "html_url": "https://github.com/rust-lang/rust/commit/df4c0b8e4349d50f317553de5a47d0cd56cdc227", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df4c0b8e4349d50f317553de5a47d0cd56cdc227/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e6bbc6bfa82f3ad0a014df24b40cbc042f24035", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035", "html_url": "https://github.com/rust-lang/rust/commit/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035"}], "stats": {"total": 1674, "additions": 846, "deletions": 828}, "files": [{"sha": "56f6eda53575c5728400b1e4386c41895fb35793", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=df4c0b8e4349d50f317553de5a47d0cd56cdc227", "patch": "@@ -9,15 +9,14 @@\n // except according to those terms.\n \n use ai = std::rt::io::net::addrinfo;\n-use std::cast;\n use std::libc::c_int;\n use std::ptr::null;\n use std::rt::BlockedTask;\n use std::rt::local::Local;\n use std::rt::sched::Scheduler;\n \n use net;\n-use super::{Loop, UvError, Request};\n+use super::{Loop, UvError, Request, wait_until_woken_after};\n use uvll;\n \n struct Addrinfo {\n@@ -76,20 +75,19 @@ impl GetAddrInfoRequest {\n             }\n         });\n         let hint_ptr = hint.as_ref().map_default(null(), |x| x as *uvll::addrinfo);\n-        let req = Request::new(uvll::UV_GETADDRINFO);\n+        let mut req = Request::new(uvll::UV_GETADDRINFO);\n \n         return match unsafe {\n             uvll::uv_getaddrinfo(loop_.handle, req.handle,\n                                  getaddrinfo_cb, c_node_ptr, c_service_ptr,\n                                  hint_ptr)\n         } {\n             0 => {\n+                req.defuse(); // uv callback now owns this request\n                 let mut cx = Ctx { slot: None, status: 0, addrinfo: None };\n-                req.set_data(&cx);\n-                req.defuse();\n-                let scheduler: ~Scheduler = Local::take();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    cx.slot = Some(task);\n+\n+                do wait_until_woken_after(&mut cx.slot) {\n+                    req.set_data(&cx);\n                 }\n \n                 match cx.status {\n@@ -105,8 +103,8 @@ impl GetAddrInfoRequest {\n                                  status: c_int,\n                                  res: *uvll::addrinfo) {\n             let req = Request::wrap(req);\n-            if status == uvll::ECANCELED { return }\n-            let cx: &mut Ctx = unsafe { cast::transmute(req.get_data()) };\n+            assert!(status != uvll::ECANCELED);\n+            let cx: &mut Ctx = unsafe { req.get_data() };\n             cx.status = status;\n             cx.addrinfo = Some(Addrinfo { handle: res });\n \n@@ -191,25 +189,23 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n mod test {\n     use std::rt::io::net::ip::{SocketAddr, Ipv4Addr};\n     use super::*;\n-    use super::super::run_uv_loop;\n+    use super::super::local_loop;\n \n     #[test]\n     fn getaddrinfo_test() {\n-        do run_uv_loop |l| {\n-            match GetAddrInfoRequest::run(l, Some(\"localhost\"), None, None) {\n-                Ok(infos) => {\n-                    let mut found_local = false;\n-                    let local_addr = &SocketAddr {\n-                        ip: Ipv4Addr(127, 0, 0, 1),\n-                        port: 0\n-                    };\n-                    for addr in infos.iter() {\n-                        found_local = found_local || addr.address == *local_addr;\n-                    }\n-                    assert!(found_local);\n+        match GetAddrInfoRequest::run(local_loop(), Some(\"localhost\"), None, None) {\n+            Ok(infos) => {\n+                let mut found_local = false;\n+                let local_addr = &SocketAddr {\n+                    ip: Ipv4Addr(127, 0, 0, 1),\n+                    port: 0\n+                };\n+                for addr in infos.iter() {\n+                    found_local = found_local || addr.address == *local_addr;\n                 }\n-                Err(e) => fail!(\"{:?}\", e),\n+                assert!(found_local);\n             }\n+            Err(e) => fail!(\"{:?}\", e),\n         }\n     }\n }"}, {"sha": "04e7bce5bd18190fb7fcbe799ab332f39c8d39ab", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=df4c0b8e4349d50f317553de5a47d0cd56cdc227", "patch": "@@ -131,11 +131,12 @@ mod test_remote {\n     use std::rt::tube::Tube;\n \n     use super::*;\n-    use super::super::run_uv_loop;\n+    use super::super::local_loop;\n \n-    // Make sure that we can fire watchers in remote threads\n+    // Make sure that we can fire watchers in remote threads and that they\n+    // actually trigger what they say they will.\n     #[test]\n-    fn test_uv_remote() {\n+    fn smoke_test() {\n         struct MyCallback(Option<Tube<int>>);\n         impl Callback for MyCallback {\n             fn call(&mut self) {\n@@ -147,35 +148,15 @@ mod test_remote {\n             }\n         }\n \n-        do run_uv_loop |l| {\n-            let mut tube = Tube::new();\n-            let cb = ~MyCallback(Some(tube.clone()));\n-            let watcher = Cell::new(AsyncWatcher::new(l, cb as ~Callback));\n-\n-            let thread = do Thread::start {\n-                watcher.take().fire();\n-            };\n+        let mut tube = Tube::new();\n+        let cb = ~MyCallback(Some(tube.clone()));\n+        let watcher = Cell::new(AsyncWatcher::new(local_loop(), cb as ~Callback));\n \n-            assert_eq!(tube.recv(), 1);\n-            thread.join();\n-        }\n-    }\n-\n-    #[test]\n-    fn smoke_test() {\n-        static mut hits: uint = 0;\n+        let thread = do Thread::start {\n+            watcher.take().fire();\n+        };\n \n-        struct MyCallback;\n-        impl Callback for MyCallback {\n-            fn call(&mut self) {\n-                unsafe { hits += 1; }\n-            }\n-        }\n-\n-        do run_uv_loop |l| {\n-            let mut watcher = AsyncWatcher::new(l, ~MyCallback as ~Callback);\n-            watcher.fire();\n-        }\n-        assert!(unsafe { hits > 0 });\n+        assert_eq!(tube.recv(), 1);\n+        thread.join();\n     }\n }"}, {"sha": "bdb1429f5b625b1ebd2b8d0ba07633d0bb176a39", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 82, "deletions": 94, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=df4c0b8e4349d50f317553de5a47d0cd56cdc227", "patch": "@@ -15,14 +15,14 @@ use std::cast;\n use std::libc::{c_int, c_char, c_void, c_uint};\n use std::libc;\n use std::rt::BlockedTask;\n-use std::rt::io;\n use std::rt::io::{FileStat, IoError};\n-use std::rt::rtio;\n+use std::rt::io;\n use std::rt::local::Local;\n+use std::rt::rtio;\n use std::rt::sched::{Scheduler, SchedHandle};\n use std::vec;\n \n-use super::{Loop, UvError, uv_error_to_io_error};\n+use super::{Loop, UvError, uv_error_to_io_error, wait_until_woken_after};\n use uvio::HomingIO;\n use uvll;\n \n@@ -305,10 +305,8 @@ fn execute(f: &fn(*uvll::uv_fs_t, uvll::uv_fs_cb) -> c_int)\n         0 => {\n             req.fired = true;\n             let mut slot = None;\n-            unsafe { uvll::set_data_for_req(req.req, &slot) }\n-            let sched: ~Scheduler = Local::take();\n-            do sched.deschedule_running_task_and_then |_, task| {\n-                slot = Some(task);\n+            do wait_until_woken_after(&mut slot) {\n+                unsafe { uvll::set_data_for_req(req.req, &slot) }\n             }\n             match req.get_result() {\n                 n if n < 0 => Err(UvError(n)),\n@@ -454,123 +452,113 @@ mod test {\n     use std::str;\n     use std::vec;\n     use super::*;\n-    use super::super::{run_uv_loop};\n+    use l = super::super::local_loop;\n \n     #[test]\n     fn file_test_full_simple_sync() {\n-        do run_uv_loop |l| {\n-            let create_flags = O_RDWR | O_CREAT;\n-            let read_flags = O_RDONLY;\n-            let mode = S_IWUSR | S_IRUSR;\n-            let path_str = \"./tmp/file_full_simple_sync.txt\";\n-\n-            {\n-                // open/create\n-                let result = FsRequest::open(l, &path_str.to_c_str(),\n-                                             create_flags as int, mode as int);\n-                assert!(result.is_ok());\n-                let result = result.unwrap();\n-                let fd = result.fd;\n-\n-                // write\n-                let result = FsRequest::write(l, fd, \"hello\".as_bytes(), -1);\n-                assert!(result.is_ok());\n-            }\n+        let create_flags = O_RDWR | O_CREAT;\n+        let read_flags = O_RDONLY;\n+        let mode = S_IWUSR | S_IRUSR;\n+        let path_str = \"./tmp/file_full_simple_sync.txt\";\n+\n+        {\n+            // open/create\n+            let result = FsRequest::open(l(), &path_str.to_c_str(),\n+                                         create_flags as int, mode as int);\n+            assert!(result.is_ok());\n+            let result = result.unwrap();\n+            let fd = result.fd;\n \n-            {\n-                // re-open\n-                let result = FsRequest::open(l, &path_str.to_c_str(),\n-                                             read_flags as int, 0);\n-                assert!(result.is_ok());\n-                let result = result.unwrap();\n-                let fd = result.fd;\n-\n-                // read\n-                let mut read_mem = vec::from_elem(1000, 0u8);\n-                let result = FsRequest::read(l, fd, read_mem, 0);\n-                assert!(result.is_ok());\n-\n-                let nread = result.unwrap();\n-                assert!(nread > 0);\n-                let read_str = str::from_utf8(read_mem.slice(0, nread as uint));\n-                assert_eq!(read_str, ~\"hello\");\n-            }\n-            // unlink\n-            let result = FsRequest::unlink(l, &path_str.to_c_str());\n+            // write\n+            let result = FsRequest::write(l(), fd, \"hello\".as_bytes(), -1);\n             assert!(result.is_ok());\n         }\n+\n+        {\n+            // re-open\n+            let result = FsRequest::open(l(), &path_str.to_c_str(),\n+                                         read_flags as int, 0);\n+            assert!(result.is_ok());\n+            let result = result.unwrap();\n+            let fd = result.fd;\n+\n+            // read\n+            let mut read_mem = vec::from_elem(1000, 0u8);\n+            let result = FsRequest::read(l(), fd, read_mem, 0);\n+            assert!(result.is_ok());\n+\n+            let nread = result.unwrap();\n+            assert!(nread > 0);\n+            let read_str = str::from_utf8(read_mem.slice(0, nread as uint));\n+            assert_eq!(read_str, ~\"hello\");\n+        }\n+        // unlink\n+        let result = FsRequest::unlink(l(), &path_str.to_c_str());\n+        assert!(result.is_ok());\n     }\n \n     #[test]\n     fn file_test_stat() {\n-        do run_uv_loop |l| {\n-            let path = &\"./tmp/file_test_stat_simple\".to_c_str();\n-            let create_flags = (O_RDWR | O_CREAT) as int;\n-            let mode = (S_IWUSR | S_IRUSR) as int;\n+        let path = &\"./tmp/file_test_stat_simple\".to_c_str();\n+        let create_flags = (O_RDWR | O_CREAT) as int;\n+        let mode = (S_IWUSR | S_IRUSR) as int;\n \n-            let result = FsRequest::open(l, path, create_flags, mode);\n-            assert!(result.is_ok());\n-            let file = result.unwrap();\n+        let result = FsRequest::open(l(), path, create_flags, mode);\n+        assert!(result.is_ok());\n+        let file = result.unwrap();\n \n-            let result = FsRequest::write(l, file.fd, \"hello\".as_bytes(), 0);\n-            assert!(result.is_ok());\n+        let result = FsRequest::write(l(), file.fd, \"hello\".as_bytes(), 0);\n+        assert!(result.is_ok());\n \n-            let result = FsRequest::stat(l, path);\n-            assert!(result.is_ok());\n-            assert_eq!(result.unwrap().size, 5);\n+        let result = FsRequest::stat(l(), path);\n+        assert!(result.is_ok());\n+        assert_eq!(result.unwrap().size, 5);\n \n-            fn free<T>(_: T) {}\n-            free(file);\n+        fn free<T>(_: T) {}\n+        free(file);\n \n-            let result = FsRequest::unlink(l, path);\n-            assert!(result.is_ok());\n-        }\n+        let result = FsRequest::unlink(l(), path);\n+        assert!(result.is_ok());\n     }\n \n     #[test]\n     fn file_test_mk_rm_dir() {\n-        do run_uv_loop |l| {\n-            let path = &\"./tmp/mk_rm_dir\".to_c_str();\n-            let mode = S_IWUSR | S_IRUSR;\n+        let path = &\"./tmp/mk_rm_dir\".to_c_str();\n+        let mode = S_IWUSR | S_IRUSR;\n \n-            let result = FsRequest::mkdir(l, path, mode);\n-            assert!(result.is_ok());\n+        let result = FsRequest::mkdir(l(), path, mode);\n+        assert!(result.is_ok());\n \n-            let result = FsRequest::stat(l, path);\n-            assert!(result.is_ok());\n-            assert!(result.unwrap().kind == io::TypeDirectory);\n+        let result = FsRequest::stat(l(), path);\n+        assert!(result.is_ok());\n+        assert!(result.unwrap().kind == io::TypeDirectory);\n \n-            let result = FsRequest::rmdir(l, path);\n-            assert!(result.is_ok());\n+        let result = FsRequest::rmdir(l(), path);\n+        assert!(result.is_ok());\n \n-            let result = FsRequest::stat(l, path);\n-            assert!(result.is_err());\n-        }\n+        let result = FsRequest::stat(l(), path);\n+        assert!(result.is_err());\n     }\n \n     #[test]\n     fn file_test_mkdir_chokes_on_double_create() {\n-        do run_uv_loop |l| {\n-            let path = &\"./tmp/double_create_dir\".to_c_str();\n-            let mode = S_IWUSR | S_IRUSR;\n-\n-            let result = FsRequest::stat(l, path);\n-            assert!(result.is_err(), \"{:?}\", result);\n-            let result = FsRequest::mkdir(l, path, mode as c_int);\n-            assert!(result.is_ok(), \"{:?}\", result);\n-            let result = FsRequest::mkdir(l, path, mode as c_int);\n-            assert!(result.is_err(), \"{:?}\", result);\n-            let result = FsRequest::rmdir(l, path);\n-            assert!(result.is_ok(), \"{:?}\", result);\n-        }\n+        let path = &\"./tmp/double_create_dir\".to_c_str();\n+        let mode = S_IWUSR | S_IRUSR;\n+\n+        let result = FsRequest::stat(l(), path);\n+        assert!(result.is_err(), \"{:?}\", result);\n+        let result = FsRequest::mkdir(l(), path, mode as c_int);\n+        assert!(result.is_ok(), \"{:?}\", result);\n+        let result = FsRequest::mkdir(l(), path, mode as c_int);\n+        assert!(result.is_err(), \"{:?}\", result);\n+        let result = FsRequest::rmdir(l(), path);\n+        assert!(result.is_ok(), \"{:?}\", result);\n     }\n \n     #[test]\n     fn file_test_rmdir_chokes_on_nonexistant_path() {\n-        do run_uv_loop |l| {\n-            let path = &\"./tmp/never_existed_dir\".to_c_str();\n-            let result = FsRequest::rmdir(l, path);\n-            assert!(result.is_err());\n-        }\n+        let path = &\"./tmp/never_existed_dir\".to_c_str();\n+        let result = FsRequest::rmdir(l(), path);\n+        assert!(result.is_err());\n     }\n }"}, {"sha": "83fc53dce1cd7f7f399e94100096e3cd211a97e2", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 31, "deletions": 40, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=df4c0b8e4349d50f317553de5a47d0cd56cdc227", "patch": "@@ -83,7 +83,6 @@ impl UvHandle<uvll::uv_idle_t> for IdleWatcher {\n }\n \n extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n-    if status == uvll::ECANCELED { return }\n     assert_eq!(status, 0);\n     let idle: &mut IdleWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n     idle.callback.call();\n@@ -101,7 +100,7 @@ mod test {\n     use super::*;\n     use std::rt::tube::Tube;\n     use std::rt::rtio::{Callback, PausibleIdleCallback};\n-    use super::super::run_uv_loop;\n+    use super::super::local_loop;\n \n     struct MyCallback(Tube<int>, int);\n     impl Callback for MyCallback {\n@@ -114,55 +113,47 @@ mod test {\n \n     #[test]\n     fn not_used() {\n-        do run_uv_loop |l| {\n-            let cb = ~MyCallback(Tube::new(), 1);\n-            let _idle = IdleWatcher::new(l, cb as ~Callback);\n-        }\n+        let cb = ~MyCallback(Tube::new(), 1);\n+        let _idle = IdleWatcher::new(local_loop(), cb as ~Callback);\n     }\n \n     #[test]\n     fn smoke_test() {\n-        do run_uv_loop |l| {\n-            let mut tube = Tube::new();\n-            let cb = ~MyCallback(tube.clone(), 1);\n-            let mut idle = IdleWatcher::new(l, cb as ~Callback);\n-            idle.resume();\n-            tube.recv();\n-        }\n+        let mut tube = Tube::new();\n+        let cb = ~MyCallback(tube.clone(), 1);\n+        let mut idle = IdleWatcher::new(local_loop(), cb as ~Callback);\n+        idle.resume();\n+        tube.recv();\n     }\n \n     #[test]\n     fn fun_combinations_of_methods() {\n-        do run_uv_loop |l| {\n-            let mut tube = Tube::new();\n-            let cb = ~MyCallback(tube.clone(), 1);\n-            let mut idle = IdleWatcher::new(l, cb as ~Callback);\n-            idle.resume();\n-            tube.recv();\n-            idle.pause();\n-            idle.resume();\n-            idle.resume();\n-            tube.recv();\n-            idle.pause();\n-            idle.pause();\n-            idle.resume();\n-            tube.recv();\n-        }\n+        let mut tube = Tube::new();\n+        let cb = ~MyCallback(tube.clone(), 1);\n+        let mut idle = IdleWatcher::new(local_loop(), cb as ~Callback);\n+        idle.resume();\n+        tube.recv();\n+        idle.pause();\n+        idle.resume();\n+        idle.resume();\n+        tube.recv();\n+        idle.pause();\n+        idle.pause();\n+        idle.resume();\n+        tube.recv();\n     }\n \n     #[test]\n     fn pause_pauses() {\n-        do run_uv_loop |l| {\n-            let mut tube = Tube::new();\n-            let cb = ~MyCallback(tube.clone(), 1);\n-            let mut idle1 = IdleWatcher::new(l, cb as ~Callback);\n-            let cb = ~MyCallback(tube.clone(), 2);\n-            let mut idle2 = IdleWatcher::new(l, cb as ~Callback);\n-            idle2.resume();\n-            assert_eq!(tube.recv(), 2);\n-            idle2.pause();\n-            idle1.resume();\n-            assert_eq!(tube.recv(), 1);\n-        }\n+        let mut tube = Tube::new();\n+        let cb = ~MyCallback(tube.clone(), 1);\n+        let mut idle1 = IdleWatcher::new(local_loop(), cb as ~Callback);\n+        let cb = ~MyCallback(tube.clone(), 2);\n+        let mut idle2 = IdleWatcher::new(local_loop(), cb as ~Callback);\n+        idle2.resume();\n+        assert_eq!(tube.recv(), 2);\n+        idle2.pause();\n+        idle1.resume();\n+        assert_eq!(tube.recv(), 1);\n     }\n }"}, {"sha": "4da5ad4275f792e0f32297c08e06a204053cfa64", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 89, "deletions": 29, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=df4c0b8e4349d50f317553de5a47d0cd56cdc227", "patch": "@@ -45,15 +45,19 @@ via `close` and `delete` methods.\n \n #[feature(macro_rules, globs)];\n \n+use std::cast::transmute;\n use std::cast;\n-use std::str::raw::from_c_str;\n-use std::vec;\n+use std::libc::{c_int, malloc, free};\n+use std::ptr::null;\n use std::ptr;\n+use std::rt::BlockedTask;\n+use std::rt::local::Local;\n+use std::rt::sched::Scheduler;\n+use std::str::raw::from_c_str;\n use std::str;\n-use std::libc::{c_void, c_int, malloc, free};\n-use std::cast::transmute;\n-use std::ptr::null;\n+use std::task;\n use std::unstable::finally::Finally;\n+use std::vec;\n \n use std::rt::io::IoError;\n \n@@ -124,27 +128,90 @@ pub trait UvHandle<T> {\n             uvll::uv_close(self.uv_handle() as *uvll::uv_handle_t, close_cb)\n         }\n     }\n+\n+    fn close(&mut self) {\n+        let mut slot = None;\n+\n+        unsafe {\n+            uvll::uv_close(self.uv_handle() as *uvll::uv_handle_t, close_cb);\n+            uvll::set_data_for_uv_handle(self.uv_handle(), ptr::null::<()>());\n+\n+            do wait_until_woken_after(&mut slot) {\n+                uvll::set_data_for_uv_handle(self.uv_handle(), &slot);\n+            }\n+        }\n+\n+        extern fn close_cb(handle: *uvll::uv_handle_t) {\n+            unsafe {\n+                let data = uvll::get_data_for_uv_handle(handle);\n+                uvll::free_handle(handle);\n+                if data == ptr::null() { return }\n+                let slot: &mut Option<BlockedTask> = cast::transmute(data);\n+                let sched: ~Scheduler = Local::take();\n+                sched.resume_blocked_task_immediately(slot.take_unwrap());\n+            }\n+        }\n+    }\n+}\n+\n+pub struct ForbidUnwind {\n+    msg: &'static str,\n+    failing_before: bool,\n+}\n+\n+impl ForbidUnwind {\n+    fn new(s: &'static str) -> ForbidUnwind {\n+        ForbidUnwind {\n+            msg: s, failing_before: task::failing(),\n+        }\n+    }\n+}\n+\n+impl Drop for ForbidUnwind {\n+    fn drop(&mut self) {\n+        assert!(self.failing_before == task::failing(),\n+                \"failing sadface {}\", self.msg);\n+    }\n+}\n+\n+fn wait_until_woken_after(slot: *mut Option<BlockedTask>, f: &fn()) {\n+    let _f = ForbidUnwind::new(\"wait_until_woken_after\");\n+    unsafe {\n+        assert!((*slot).is_none());\n+        let sched: ~Scheduler = Local::take();\n+        do sched.deschedule_running_task_and_then |_, task| {\n+            f();\n+            *slot = Some(task);\n+        }\n+    }\n }\n \n pub struct Request {\n     handle: *uvll::uv_req_t,\n+    priv defused: bool,\n }\n \n impl Request {\n     pub fn new(ty: uvll::uv_req_type) -> Request {\n-        Request::wrap(unsafe { uvll::malloc_req(ty) })\n+        unsafe {\n+            let handle = uvll::malloc_req(ty);\n+            uvll::set_data_for_req(handle, null::<()>());\n+            Request::wrap(handle)\n+        }\n     }\n \n     pub fn wrap(handle: *uvll::uv_req_t) -> Request {\n-        Request { handle: handle }\n+        Request { handle: handle, defused: false }\n     }\n \n     pub fn set_data<T>(&self, t: *T) {\n         unsafe { uvll::set_data_for_req(self.handle, t) }\n     }\n \n-    pub fn get_data(&self) -> *c_void {\n-        unsafe { uvll::get_data_for_req(self.handle) }\n+    pub unsafe fn get_data<T>(&self) -> &'static mut T {\n+        let data = uvll::get_data_for_req(self.handle);\n+        assert!(data != null());\n+        cast::transmute(data)\n     }\n \n     // This function should be used when the request handle has been given to an\n@@ -155,17 +222,15 @@ impl Request {\n     // This is still a problem in blocking situations due to linked failure. In\n     // the connection callback the handle should be re-wrapped with the `wrap`\n     // function to ensure its destruction.\n-    pub fn defuse(mut self) {\n-        self.handle = ptr::null();\n+    pub fn defuse(&mut self) {\n+        self.defused = true;\n     }\n }\n \n impl Drop for Request {\n     fn drop(&mut self) {\n-        unsafe {\n-            if self.handle != ptr::null() {\n-                uvll::free_req(self.handle)\n-            }\n+        if !self.defused {\n+            unsafe { uvll::free_req(self.handle) }\n         }\n     }\n }\n@@ -300,23 +365,18 @@ pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n     uvll::uv_buf_t { base: data, len: v.len() as uvll::uv_buf_len_t }\n }\n \n-fn run_uv_loop(f: proc(&mut Loop)) {\n-    use std::rt::local::Local;\n-    use std::rt::test::run_in_uv_task;\n-    use std::rt::sched::Scheduler;\n-    use std::cell::Cell;\n-\n-    let f = Cell::new(f);\n-    do run_in_uv_task {\n-        let mut io = None;\n-        do Local::borrow |sched: &mut Scheduler| {\n-            sched.event_loop.io(|i| unsafe {\n+#[cfg(test)]\n+fn local_loop() -> &'static mut Loop {\n+    unsafe {\n+        cast::transmute(do Local::borrow |sched: &mut Scheduler| {\n+            let mut io = None;\n+            do sched.event_loop.io |i| {\n                 let (_vtable, uvio): (uint, &'static mut uvio::UvIoFactory) =\n                     cast::transmute(i);\n                 io = Some(uvio);\n-            });\n-        }\n-        f.take()(io.unwrap().uv_loop());\n+            }\n+            io.unwrap()\n+        }.uv_loop())\n     }\n }\n "}, {"sha": "bf5f6c88527e220cafd454d6c4b7e8c95d454611", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 452, "deletions": 437, "changes": 889, "blob_url": "https://github.com/rust-lang/rust/blob/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=df4c0b8e4349d50f317553de5a47d0cd56cdc227", "patch": "@@ -19,11 +19,13 @@ use std::rt::rtio;\n use std::rt::sched::{Scheduler, SchedHandle};\n use std::rt::tube::Tube;\n use std::str;\n+use std::task;\n use std::vec;\n \n use stream::StreamWatcher;\n use super::{Loop, Request, UvError, Buf, status_to_io_result,\n-            uv_error_to_io_error, UvHandle, slice_to_uv_buf};\n+            uv_error_to_io_error, UvHandle, slice_to_uv_buf,\n+            wait_until_woken_after};\n use uvio::HomingIO;\n use uvll;\n \n@@ -206,46 +208,46 @@ impl TcpWatcher {\n     {\n         struct Ctx { status: c_int, task: Option<BlockedTask> }\n \n-        let tcp = TcpWatcher::new(loop_);\n-        let ret = do socket_addr_as_uv_socket_addr(address) |addr| {\n-            let req = Request::new(uvll::UV_CONNECT);\n-            let result = match addr {\n-                UvIpv4SocketAddr(addr) => unsafe {\n-                    uvll::tcp_connect(req.handle, tcp.handle, addr,\n-                                      connect_cb)\n-                },\n-                UvIpv6SocketAddr(addr) => unsafe {\n-                    uvll::tcp_connect6(req.handle, tcp.handle, addr,\n-                                       connect_cb)\n-                },\n-            };\n-            match result {\n-                0 => {\n-                    let mut cx = Ctx { status: 0, task: None };\n-                    req.set_data(&cx);\n-                    req.defuse();\n-                    let scheduler: ~Scheduler = Local::take();\n-                    do scheduler.deschedule_running_task_and_then |_, task| {\n-                        cx.task = Some(task);\n-                    }\n-                    match cx.status {\n-                        0 => Ok(()),\n-                        n => Err(UvError(n)),\n+        return do task::unkillable {\n+            let tcp = TcpWatcher::new(loop_);\n+            let ret = do socket_addr_as_uv_socket_addr(address) |addr| {\n+                let mut req = Request::new(uvll::UV_CONNECT);\n+                let result = match addr {\n+                    UvIpv4SocketAddr(addr) => unsafe {\n+                        uvll::tcp_connect(req.handle, tcp.handle, addr,\n+                                          connect_cb)\n+                    },\n+                    UvIpv6SocketAddr(addr) => unsafe {\n+                        uvll::tcp_connect6(req.handle, tcp.handle, addr,\n+                                           connect_cb)\n+                    },\n+                };\n+                match result {\n+                    0 => {\n+                        req.defuse(); // uv callback now owns this request\n+                        let mut cx = Ctx { status: 0, task: None };\n+                        do wait_until_woken_after(&mut cx.task) {\n+                            req.set_data(&cx);\n+                        }\n+                        match cx.status {\n+                            0 => Ok(()),\n+                            n => Err(UvError(n)),\n+                        }\n                     }\n+                    n => Err(UvError(n))\n                 }\n-                n => Err(UvError(n))\n-            }\n-        };\n+            };\n \n-        return match ret {\n-            Ok(()) => Ok(tcp),\n-            Err(e) => Err(e),\n+            match ret {\n+                Ok(()) => Ok(tcp),\n+                Err(e) => Err(e),\n+            }\n         };\n \n         extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n             let req = Request::wrap(req);\n-            if status == uvll::ECANCELED { return }\n-            let cx: &mut Ctx = unsafe { cast::transmute(req.get_data()) };\n+            assert!(status != uvll::ECANCELED);\n+            let cx: &mut Ctx = unsafe { req.get_data() };\n             cx.status = status;\n             let scheduler: ~Scheduler = Local::take();\n             scheduler.resume_blocked_task_immediately(cx.task.take_unwrap());\n@@ -310,10 +312,14 @@ impl rtio::RtioTcpStream for TcpWatcher {\n     }\n }\n \n+impl UvHandle<uvll::uv_tcp_t> for TcpWatcher {\n+    fn uv_handle(&self) -> *uvll::uv_tcp_t { self.stream.handle }\n+}\n+\n impl Drop for TcpWatcher {\n     fn drop(&mut self) {\n         let _m = self.fire_homing_missile();\n-        self.stream.close();\n+        self.close();\n     }\n }\n \n@@ -323,25 +329,27 @@ impl TcpListener {\n     pub fn bind(loop_: &mut Loop, address: SocketAddr)\n         -> Result<~TcpListener, UvError>\n     {\n-        let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n-        assert_eq!(unsafe {\n-            uvll::uv_tcp_init(loop_.handle, handle)\n-        }, 0);\n-        let l = ~TcpListener {\n-            home: get_handle_to_current_scheduler!(),\n-            handle: handle,\n-            closing_task: None,\n-            outgoing: Tube::new(),\n-        };\n-        let res = socket_addr_as_uv_socket_addr(address, |addr| unsafe {\n-            match addr {\n-                UvIpv4SocketAddr(addr) => uvll::tcp_bind(l.handle, addr),\n-                UvIpv6SocketAddr(addr) => uvll::tcp_bind6(l.handle, addr),\n+        do task::unkillable {\n+            let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n+            assert_eq!(unsafe {\n+                uvll::uv_tcp_init(loop_.handle, handle)\n+            }, 0);\n+            let l = ~TcpListener {\n+                home: get_handle_to_current_scheduler!(),\n+                handle: handle,\n+                closing_task: None,\n+                outgoing: Tube::new(),\n+            };\n+            let res = socket_addr_as_uv_socket_addr(address, |addr| unsafe {\n+                match addr {\n+                    UvIpv4SocketAddr(addr) => uvll::tcp_bind(l.handle, addr),\n+                    UvIpv6SocketAddr(addr) => uvll::tcp_bind6(l.handle, addr),\n+                }\n+            });\n+            match res {\n+                0 => Ok(l.install()),\n+                n => Err(UvError(n))\n             }\n-        });\n-        match res {\n-            0 => Ok(l.install()),\n-            n => Err(UvError(n))\n         }\n     }\n }\n@@ -380,6 +388,7 @@ impl rtio::RtioTcpListener for TcpListener {\n }\n \n extern fn listen_cb(server: *uvll::uv_stream_t, status: c_int) {\n+    assert!(status != uvll::ECANCELED);\n     let msg = match status {\n         0 => {\n             let loop_ = Loop::wrap(unsafe {\n@@ -389,7 +398,6 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: c_int) {\n             assert_eq!(unsafe { uvll::uv_accept(server, client.handle) }, 0);\n             Ok(~client as ~rtio::RtioTcpStream)\n         }\n-        uvll::ECANCELED => return,\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n \n@@ -399,12 +407,8 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: c_int) {\n \n impl Drop for TcpListener {\n     fn drop(&mut self) {\n-        let (_m, sched) = self.fire_homing_missile_sched();\n-\n-        do sched.deschedule_running_task_and_then |_, task| {\n-            self.closing_task = Some(task);\n-            unsafe { uvll::uv_close(self.handle, listener_close_cb) }\n-        }\n+        let _m = self.fire_homing_missile();\n+        self.close();\n     }\n }\n \n@@ -463,26 +467,34 @@ impl UdpWatcher {\n     pub fn bind(loop_: &Loop, address: SocketAddr)\n         -> Result<UdpWatcher, UvError>\n     {\n-        let udp = UdpWatcher {\n-            handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n-            home: get_handle_to_current_scheduler!(),\n-        };\n-        assert_eq!(unsafe {\n-            uvll::uv_udp_init(loop_.handle, udp.handle)\n-        }, 0);\n-        let result = socket_addr_as_uv_socket_addr(address, |addr| unsafe {\n-            match addr {\n-                UvIpv4SocketAddr(addr) => uvll::udp_bind(udp.handle, addr, 0u32),\n-                UvIpv6SocketAddr(addr) => uvll::udp_bind6(udp.handle, addr, 0u32),\n+        do task::unkillable {\n+            let udp = UdpWatcher {\n+                handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n+                home: get_handle_to_current_scheduler!(),\n+            };\n+            assert_eq!(unsafe {\n+                uvll::uv_udp_init(loop_.handle, udp.handle)\n+            }, 0);\n+            let result = socket_addr_as_uv_socket_addr(address, |addr| unsafe {\n+                match addr {\n+                    UvIpv4SocketAddr(addr) =>\n+                        uvll::udp_bind(udp.handle, addr, 0u32),\n+                    UvIpv6SocketAddr(addr) =>\n+                        uvll::udp_bind6(udp.handle, addr, 0u32),\n+                }\n+            });\n+            match result {\n+                0 => Ok(udp),\n+                n => Err(UvError(n)),\n             }\n-        });\n-        match result {\n-            0 => Ok(udp),\n-            n => Err(UvError(n)),\n         }\n     }\n }\n \n+impl UvHandle<uvll::uv_udp_t> for UdpWatcher {\n+    fn uv_handle(&self) -> *uvll::uv_udp_t { self.handle }\n+}\n+\n impl HomingIO for UdpWatcher {\n     fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n }\n@@ -505,7 +517,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         }\n         let _m = self.fire_homing_missile();\n \n-        return match unsafe {\n+        let a = match unsafe {\n             uvll::uv_udp_recv_start(self.handle, alloc_cb, recv_cb)\n         } {\n             0 => {\n@@ -514,10 +526,8 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                     buf: Some(slice_to_uv_buf(buf)),\n                     result: None,\n                 };\n-                unsafe { uvll::set_data_for_uv_handle(self.handle, &cx) }\n-                let scheduler: ~Scheduler = Local::take();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    cx.task = Some(task);\n+                do wait_until_woken_after(&mut cx.task) {\n+                    unsafe { uvll::set_data_for_uv_handle(self.handle, &cx) }\n                 }\n                 match cx.result.take_unwrap() {\n                     (n, _) if n < 0 =>\n@@ -527,23 +537,30 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             }\n             n => Err(uv_error_to_io_error(UvError(n)))\n         };\n+        return a;\n \n         extern fn alloc_cb(handle: *uvll::uv_udp_t,\n                            _suggested_size: size_t) -> Buf {\n             let cx: &mut Ctx = unsafe {\n                 cast::transmute(uvll::get_data_for_uv_handle(handle))\n             };\n-            cx.buf.take().expect(\"alloc_cb called more than once\")\n+            cx.buf.take().expect(\"recv alloc_cb called more than once\")\n         }\n \n-        extern fn recv_cb(handle: *uvll::uv_udp_t, nread: ssize_t, _buf: Buf,\n+        extern fn recv_cb(handle: *uvll::uv_udp_t, nread: ssize_t, buf: Buf,\n                           addr: *uvll::sockaddr, _flags: c_uint) {\n+            assert!(nread != uvll::ECANCELED as ssize_t);\n+            let cx: &mut Ctx = unsafe {\n+                cast::transmute(uvll::get_data_for_uv_handle(handle))\n+            };\n \n             // When there's no data to read the recv callback can be a no-op.\n             // This can happen if read returns EAGAIN/EWOULDBLOCK. By ignoring\n             // this we just drop back to kqueue and wait for the next callback.\n-            if nread == 0 { return }\n-            if nread == uvll::ECANCELED as ssize_t { return }\n+            if nread == 0 {\n+                cx.buf = Some(buf);\n+                return\n+            }\n \n             unsafe {\n                 assert_eq!(uvll::uv_udp_recv_stop(handle), 0)\n@@ -566,7 +583,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n \n         let _m = self.fire_homing_missile();\n \n-        let req = Request::new(uvll::UV_UDP_SEND);\n+        let mut req = Request::new(uvll::UV_UDP_SEND);\n         let buf = slice_to_uv_buf(buf);\n         let result = socket_addr_as_uv_socket_addr(dst, |dst| unsafe {\n             match dst {\n@@ -579,15 +596,11 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n \n         return match result {\n             0 => {\n+                req.defuse(); // uv callback now owns this request\n                 let mut cx = Ctx { task: None, result: 0 };\n-                req.set_data(&cx);\n-                req.defuse();\n-\n-                let sched: ~Scheduler = Local::take();\n-                do sched.deschedule_running_task_and_then |_, task| {\n-                    cx.task = Some(task);\n+                do wait_until_woken_after(&mut cx.task) {\n+                    req.set_data(&cx);\n                 }\n-\n                 match cx.result {\n                     0 => Ok(()),\n                     n => Err(uv_error_to_io_error(UvError(n)))\n@@ -598,7 +611,8 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n \n         extern fn send_cb(req: *uvll::uv_udp_send_t, status: c_int) {\n             let req = Request::wrap(req);\n-            let cx: &mut Ctx = unsafe { cast::transmute(req.get_data()) };\n+            assert!(status != uvll::ECANCELED);\n+            let cx: &mut Ctx = unsafe { req.get_data() };\n             cx.result = status;\n \n             let sched: ~Scheduler = Local::take();\n@@ -679,24 +693,8 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n impl Drop for UdpWatcher {\n     fn drop(&mut self) {\n         // Send ourselves home to close this handle (blocking while doing so).\n-        let (_m, sched) = self.fire_homing_missile_sched();\n-        let mut slot = None;\n-        unsafe {\n-            uvll::set_data_for_uv_handle(self.handle, &slot);\n-            uvll::uv_close(self.handle, close_cb);\n-        }\n-        do sched.deschedule_running_task_and_then |_, task| {\n-            slot = Some(task);\n-        }\n-\n-        extern fn close_cb(handle: *uvll::uv_handle_t) {\n-            let slot: &mut Option<BlockedTask> = unsafe {\n-                cast::transmute(uvll::get_data_for_uv_handle(handle))\n-            };\n-            unsafe { uvll::free_handle(handle) }\n-            let sched: ~Scheduler = Local::take();\n-            sched.resume_blocked_task_immediately(slot.take_unwrap());\n-        }\n+        let _m = self.fire_homing_missile();\n+        self.close();\n     }\n }\n \n@@ -714,397 +712,357 @@ mod test {\n     use std::task;\n \n     use super::*;\n-    use super::super::{Loop, run_uv_loop};\n+    use super::super::local_loop;\n \n     #[test]\n     fn connect_close_ip4() {\n-        do run_uv_loop |l| {\n-            match TcpWatcher::connect(l, next_test_ip4()) {\n-                Ok(*) => fail!(),\n-                Err(e) => assert_eq!(e.name(), ~\"ECONNREFUSED\"),\n-            }\n+        match TcpWatcher::connect(local_loop(), next_test_ip4()) {\n+            Ok(*) => fail!(),\n+            Err(e) => assert_eq!(e.name(), ~\"ECONNREFUSED\"),\n         }\n     }\n \n     #[test]\n     fn connect_close_ip6() {\n-        do run_uv_loop |l| {\n-            match TcpWatcher::connect(l, next_test_ip6()) {\n-                Ok(*) => fail!(),\n-                Err(e) => assert_eq!(e.name(), ~\"ECONNREFUSED\"),\n-            }\n+        match TcpWatcher::connect(local_loop(), next_test_ip6()) {\n+            Ok(*) => fail!(),\n+            Err(e) => assert_eq!(e.name(), ~\"ECONNREFUSED\"),\n         }\n     }\n \n     #[test]\n     fn udp_bind_close_ip4() {\n-        do run_uv_loop |l| {\n-            match UdpWatcher::bind(l, next_test_ip4()) {\n-                Ok(*) => {}\n-                Err(*) => fail!()\n-            }\n+        match UdpWatcher::bind(local_loop(), next_test_ip4()) {\n+            Ok(*) => {}\n+            Err(*) => fail!()\n         }\n     }\n \n     #[test]\n     fn udp_bind_close_ip6() {\n-        do run_uv_loop |l| {\n-            match UdpWatcher::bind(l, next_test_ip6()) {\n-                Ok(*) => {}\n-                Err(*) => fail!()\n-            }\n+        match UdpWatcher::bind(local_loop(), next_test_ip6()) {\n+            Ok(*) => {}\n+            Err(*) => fail!()\n         }\n     }\n \n     #[test]\n     fn listen_ip4() {\n-        do run_uv_loop |l| {\n-            let (port, chan) = oneshot();\n-            let chan = Cell::new(chan);\n-            let addr = next_test_ip4();\n-\n-            let handle = l.handle;\n-            do spawn {\n-                let w = match TcpListener::bind(&mut Loop::wrap(handle), addr) {\n-                    Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n-                };\n-                let mut w = match w.listen() {\n-                    Ok(w) => w, Err(e) => fail!(\"{:?}\", e),\n-                };\n-                chan.take().send(());\n-                match w.accept() {\n-                    Ok(mut stream) => {\n-                        let mut buf = [0u8, ..10];\n-                        match stream.read(buf) {\n-                            Ok(10) => {} e => fail!(\"{:?}\", e),\n-                        }\n-                        for i in range(0, 10u8) {\n-                            assert_eq!(buf[i], i + 1);\n-                        }\n-                    }\n-                    Err(e) => fail!(\"{:?}\", e)\n-                }\n-            }\n+        let (port, chan) = oneshot();\n+        let chan = Cell::new(chan);\n+        let addr = next_test_ip4();\n \n-            port.recv();\n-            let mut w = match TcpWatcher::connect(&mut Loop::wrap(handle), addr) {\n+        do spawn {\n+            let w = match TcpListener::bind(local_loop(), addr) {\n                 Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n             };\n-            match w.write([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) {\n-                Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n+            let mut w = match w.listen() {\n+                Ok(w) => w, Err(e) => fail!(\"{:?}\", e),\n+            };\n+            chan.take().send(());\n+            match w.accept() {\n+                Ok(mut stream) => {\n+                    let mut buf = [0u8, ..10];\n+                    match stream.read(buf) {\n+                        Ok(10) => {} e => fail!(\"{:?}\", e),\n+                    }\n+                    for i in range(0, 10u8) {\n+                        assert_eq!(buf[i], i + 1);\n+                    }\n+                }\n+                Err(e) => fail!(\"{:?}\", e)\n             }\n         }\n+\n+        port.recv();\n+        let mut w = match TcpWatcher::connect(local_loop(), addr) {\n+            Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n+        };\n+        match w.write([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) {\n+            Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n+        }\n     }\n \n     #[test]\n     fn listen_ip6() {\n-        do run_uv_loop |l| {\n-            let (port, chan) = oneshot();\n-            let chan = Cell::new(chan);\n-            let addr = next_test_ip6();\n-\n-            let handle = l.handle;\n-            do spawn {\n-                let w = match TcpListener::bind(&mut Loop::wrap(handle), addr) {\n-                    Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n-                };\n-                let mut w = match w.listen() {\n-                    Ok(w) => w, Err(e) => fail!(\"{:?}\", e),\n-                };\n-                chan.take().send(());\n-                match w.accept() {\n-                    Ok(mut stream) => {\n-                        let mut buf = [0u8, ..10];\n-                        match stream.read(buf) {\n-                            Ok(10) => {} e => fail!(\"{:?}\", e),\n-                        }\n-                        for i in range(0, 10u8) {\n-                            assert_eq!(buf[i], i + 1);\n-                        }\n-                    }\n-                    Err(e) => fail!(\"{:?}\", e)\n-                }\n-            }\n+        let (port, chan) = oneshot();\n+        let chan = Cell::new(chan);\n+        let addr = next_test_ip6();\n \n-            port.recv();\n-            let mut w = match TcpWatcher::connect(&mut Loop::wrap(handle), addr) {\n+        do spawn {\n+            let w = match TcpListener::bind(local_loop(), addr) {\n                 Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n             };\n-            match w.write([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) {\n-                Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n+            let mut w = match w.listen() {\n+                Ok(w) => w, Err(e) => fail!(\"{:?}\", e),\n+            };\n+            chan.take().send(());\n+            match w.accept() {\n+                Ok(mut stream) => {\n+                    let mut buf = [0u8, ..10];\n+                    match stream.read(buf) {\n+                        Ok(10) => {} e => fail!(\"{:?}\", e),\n+                    }\n+                    for i in range(0, 10u8) {\n+                        assert_eq!(buf[i], i + 1);\n+                    }\n+                }\n+                Err(e) => fail!(\"{:?}\", e)\n             }\n         }\n+\n+        port.recv();\n+        let mut w = match TcpWatcher::connect(local_loop(), addr) {\n+            Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n+        };\n+        match w.write([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) {\n+            Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n+        }\n     }\n \n     #[test]\n     fn udp_recv_ip4() {\n-        do run_uv_loop |l| {\n-            let (port, chan) = oneshot();\n-            let chan = Cell::new(chan);\n-            let client = next_test_ip4();\n-            let server = next_test_ip4();\n-\n-            let handle = l.handle;\n-            do spawn {\n-                match UdpWatcher::bind(&mut Loop::wrap(handle), server) {\n-                    Ok(mut w) => {\n-                        chan.take().send(());\n-                        let mut buf = [0u8, ..10];\n-                        match w.recvfrom(buf) {\n-                            Ok((10, addr)) => assert_eq!(addr, client),\n-                            e => fail!(\"{:?}\", e),\n-                        }\n-                        for i in range(0, 10u8) {\n-                            assert_eq!(buf[i], i + 1);\n-                        }\n+        let (port, chan) = oneshot();\n+        let chan = Cell::new(chan);\n+        let client = next_test_ip4();\n+        let server = next_test_ip4();\n+\n+        do spawn {\n+            match UdpWatcher::bind(local_loop(), server) {\n+                Ok(mut w) => {\n+                    chan.take().send(());\n+                    let mut buf = [0u8, ..10];\n+                    match w.recvfrom(buf) {\n+                        Ok((10, addr)) => assert_eq!(addr, client),\n+                        e => fail!(\"{:?}\", e),\n+                    }\n+                    for i in range(0, 10u8) {\n+                        assert_eq!(buf[i], i + 1);\n                     }\n-                    Err(e) => fail!(\"{:?}\", e)\n                 }\n+                Err(e) => fail!(\"{:?}\", e)\n             }\n+        }\n \n-            port.recv();\n-            let mut w = match UdpWatcher::bind(&mut Loop::wrap(handle), client) {\n-                Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n-            };\n-            match w.sendto([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], server) {\n-                Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n-            }\n+        port.recv();\n+        let mut w = match UdpWatcher::bind(local_loop(), client) {\n+            Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n+        };\n+        match w.sendto([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], server) {\n+            Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n         }\n     }\n \n     #[test]\n     fn udp_recv_ip6() {\n-        do run_uv_loop |l| {\n-            let (port, chan) = oneshot();\n-            let chan = Cell::new(chan);\n-            let client = next_test_ip6();\n-            let server = next_test_ip6();\n-\n-            let handle = l.handle;\n-            do spawn {\n-                match UdpWatcher::bind(&mut Loop::wrap(handle), server) {\n-                    Ok(mut w) => {\n-                        chan.take().send(());\n-                        let mut buf = [0u8, ..10];\n-                        match w.recvfrom(buf) {\n-                            Ok((10, addr)) => assert_eq!(addr, client),\n-                            e => fail!(\"{:?}\", e),\n-                        }\n-                        for i in range(0, 10u8) {\n-                            assert_eq!(buf[i], i + 1);\n-                        }\n+        let (port, chan) = oneshot();\n+        let chan = Cell::new(chan);\n+        let client = next_test_ip6();\n+        let server = next_test_ip6();\n+\n+        do spawn {\n+            match UdpWatcher::bind(local_loop(), server) {\n+                Ok(mut w) => {\n+                    chan.take().send(());\n+                    let mut buf = [0u8, ..10];\n+                    match w.recvfrom(buf) {\n+                        Ok((10, addr)) => assert_eq!(addr, client),\n+                        e => fail!(\"{:?}\", e),\n+                    }\n+                    for i in range(0, 10u8) {\n+                        assert_eq!(buf[i], i + 1);\n                     }\n-                    Err(e) => fail!(\"{:?}\", e)\n                 }\n+                Err(e) => fail!(\"{:?}\", e)\n             }\n+        }\n \n-            port.recv();\n-            let mut w = match UdpWatcher::bind(&mut Loop::wrap(handle), client) {\n-                Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n-            };\n-            match w.sendto([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], server) {\n-                Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n-            }\n+        port.recv();\n+        let mut w = match UdpWatcher::bind(local_loop(), client) {\n+            Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n+        };\n+        match w.sendto([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], server) {\n+            Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n         }\n     }\n \n     #[test]\n     fn test_read_read_read() {\n-        do run_uv_loop |l| {\n-            let addr = next_test_ip4();\n-            static MAX: uint = 500000;\n-            let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n-\n-            let handle = l.handle;\n-            do spawntask {\n-                let l = &mut Loop::wrap(handle);\n-                let listener = TcpListener::bind(l, addr).unwrap();\n-                let mut acceptor = listener.listen().unwrap();\n-                chan.take().send(());\n-                let mut stream = acceptor.accept().unwrap();\n-                let buf = [1, .. 2048];\n-                let mut total_bytes_written = 0;\n-                while total_bytes_written < MAX {\n-                    stream.write(buf);\n-                    total_bytes_written += buf.len();\n-                }\n+        use std::rt::rtio::*;\n+        let addr = next_test_ip4();\n+        static MAX: uint = 5000;\n+        let (port, chan) = oneshot();\n+        let port = Cell::new(port);\n+        let chan = Cell::new(chan);\n+\n+        do spawn {\n+            let listener = TcpListener::bind(local_loop(), addr).unwrap();\n+            let mut acceptor = listener.listen().unwrap();\n+            chan.take().send(());\n+            let mut stream = acceptor.accept().unwrap();\n+            let buf = [1, .. 2048];\n+            let mut total_bytes_written = 0;\n+            while total_bytes_written < MAX {\n+                assert!(stream.write(buf).is_ok());\n+                uvdebug!(\"wrote bytes\");\n+                total_bytes_written += buf.len();\n             }\n+        }\n \n-            do spawntask {\n-                let l = &mut Loop::wrap(handle);\n-                port.take().recv();\n-                let mut stream = TcpWatcher::connect(l, addr).unwrap();\n-                let mut buf = [0, .. 2048];\n-                let mut total_bytes_read = 0;\n-                while total_bytes_read < MAX {\n-                    let nread = stream.read(buf).unwrap();\n-                    uvdebug!(\"read {} bytes\", nread);\n-                    total_bytes_read += nread;\n-                    for i in range(0u, nread) {\n-                        assert_eq!(buf[i], 1);\n-                    }\n+        do spawn {\n+            port.take().recv();\n+            let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n+            let mut buf = [0, .. 2048];\n+            let mut total_bytes_read = 0;\n+            while total_bytes_read < MAX {\n+                let nread = stream.read(buf).unwrap();\n+                total_bytes_read += nread;\n+                for i in range(0u, nread) {\n+                    assert_eq!(buf[i], 1);\n                 }\n-                uvdebug!(\"read {} bytes total\", total_bytes_read);\n             }\n+            uvdebug!(\"read {} bytes total\", total_bytes_read);\n         }\n     }\n \n     #[test]\n-    #[ignore(cfg(windows))] // FIXME(#10102) the server never sees the second send\n     fn test_udp_twice() {\n-        do run_uv_loop |l| {\n-            let server_addr = next_test_ip4();\n-            let client_addr = next_test_ip4();\n-            let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n-\n-            let handle = l.handle;\n-            do spawntask {\n-                let l = &mut Loop::wrap(handle);\n-                let mut client = UdpWatcher::bind(l, client_addr).unwrap();\n-                port.take().recv();\n-                assert!(client.sendto([1], server_addr).is_ok());\n-                assert!(client.sendto([2], server_addr).is_ok());\n-            }\n+        let server_addr = next_test_ip4();\n+        let client_addr = next_test_ip4();\n+        let (port, chan) = oneshot();\n+        let port = Cell::new(port);\n+        let chan = Cell::new(chan);\n \n-            do spawntask {\n-                let l = &mut Loop::wrap(handle);\n-                let mut server = UdpWatcher::bind(l, server_addr).unwrap();\n-                chan.take().send(());\n-                let mut buf1 = [0];\n-                let mut buf2 = [0];\n-                let (nread1, src1) = server.recvfrom(buf1).unwrap();\n-                let (nread2, src2) = server.recvfrom(buf2).unwrap();\n-                assert_eq!(nread1, 1);\n-                assert_eq!(nread2, 1);\n-                assert_eq!(src1, client_addr);\n-                assert_eq!(src2, client_addr);\n-                assert_eq!(buf1[0], 1);\n-                assert_eq!(buf2[0], 2);\n-            }\n+        do spawn {\n+            let mut client = UdpWatcher::bind(local_loop(), client_addr).unwrap();\n+            port.take().recv();\n+            assert!(client.sendto([1], server_addr).is_ok());\n+            assert!(client.sendto([2], server_addr).is_ok());\n         }\n+\n+        let mut server = UdpWatcher::bind(local_loop(), server_addr).unwrap();\n+        chan.take().send(());\n+        let mut buf1 = [0];\n+        let mut buf2 = [0];\n+        let (nread1, src1) = server.recvfrom(buf1).unwrap();\n+        let (nread2, src2) = server.recvfrom(buf2).unwrap();\n+        assert_eq!(nread1, 1);\n+        assert_eq!(nread2, 1);\n+        assert_eq!(src1, client_addr);\n+        assert_eq!(src2, client_addr);\n+        assert_eq!(buf1[0], 1);\n+        assert_eq!(buf2[0], 2);\n     }\n \n     #[test]\n     fn test_udp_many_read() {\n-        do run_uv_loop |l| {\n-            let server_out_addr = next_test_ip4();\n-            let server_in_addr = next_test_ip4();\n-            let client_out_addr = next_test_ip4();\n-            let client_in_addr = next_test_ip4();\n-            static MAX: uint = 500_000;\n-\n-            let (p1, c1) = oneshot();\n-            let (p2, c2) = oneshot();\n-\n-            let first = Cell::new((p1, c2));\n-            let second = Cell::new((p2, c1));\n-\n-            let handle = l.handle;\n-            do spawntask {\n-                let l = &mut Loop::wrap(handle);\n-                let mut server_out = UdpWatcher::bind(l, server_out_addr).unwrap();\n-                let mut server_in = UdpWatcher::bind(l, server_in_addr).unwrap();\n-                let (port, chan) = first.take();\n-                chan.send(());\n-                port.recv();\n-                let msg = [1, .. 2048];\n-                let mut total_bytes_sent = 0;\n-                let mut buf = [1];\n-                while buf[0] == 1 {\n-                    // send more data\n-                    assert!(server_out.sendto(msg, client_in_addr).is_ok());\n-                    total_bytes_sent += msg.len();\n-                    // check if the client has received enough\n-                    let res = server_in.recvfrom(buf);\n-                    assert!(res.is_ok());\n-                    let (nread, src) = res.unwrap();\n-                    assert_eq!(nread, 1);\n-                    assert_eq!(src, client_out_addr);\n-                }\n-                assert!(total_bytes_sent >= MAX);\n+        let server_out_addr = next_test_ip4();\n+        let server_in_addr = next_test_ip4();\n+        let client_out_addr = next_test_ip4();\n+        let client_in_addr = next_test_ip4();\n+        static MAX: uint = 500_000;\n+\n+        let (p1, c1) = oneshot();\n+        let (p2, c2) = oneshot();\n+\n+        let first = Cell::new((p1, c2));\n+        let second = Cell::new((p2, c1));\n+\n+        do spawn {\n+            let l = local_loop();\n+            let mut server_out = UdpWatcher::bind(l, server_out_addr).unwrap();\n+            let mut server_in = UdpWatcher::bind(l, server_in_addr).unwrap();\n+            let (port, chan) = first.take();\n+            chan.send(());\n+            port.recv();\n+            let msg = [1, .. 2048];\n+            let mut total_bytes_sent = 0;\n+            let mut buf = [1];\n+            while buf[0] == 1 {\n+                // send more data\n+                assert!(server_out.sendto(msg, client_in_addr).is_ok());\n+                total_bytes_sent += msg.len();\n+                // check if the client has received enough\n+                let res = server_in.recvfrom(buf);\n+                assert!(res.is_ok());\n+                let (nread, src) = res.unwrap();\n+                assert_eq!(nread, 1);\n+                assert_eq!(src, client_out_addr);\n             }\n+            assert!(total_bytes_sent >= MAX);\n+        }\n \n-            do spawntask {\n-                let l = &mut Loop::wrap(handle);\n-                let mut client_out = UdpWatcher::bind(l, client_out_addr).unwrap();\n-                let mut client_in = UdpWatcher::bind(l, client_in_addr).unwrap();\n-                let (port, chan) = second.take();\n-                port.recv();\n-                chan.send(());\n-                let mut total_bytes_recv = 0;\n-                let mut buf = [0, .. 2048];\n-                while total_bytes_recv < MAX {\n-                    // ask for more\n-                    assert!(client_out.sendto([1], server_in_addr).is_ok());\n-                    // wait for data\n-                    let res = client_in.recvfrom(buf);\n-                    assert!(res.is_ok());\n-                    let (nread, src) = res.unwrap();\n-                    assert_eq!(src, server_out_addr);\n-                    total_bytes_recv += nread;\n-                    for i in range(0u, nread) {\n-                        assert_eq!(buf[i], 1);\n-                    }\n+        do spawn {\n+            let l = local_loop();\n+            let mut client_out = UdpWatcher::bind(l, client_out_addr).unwrap();\n+            let mut client_in = UdpWatcher::bind(l, client_in_addr).unwrap();\n+            let (port, chan) = second.take();\n+            port.recv();\n+            chan.send(());\n+            let mut total_bytes_recv = 0;\n+            let mut buf = [0, .. 2048];\n+            while total_bytes_recv < MAX {\n+                // ask for more\n+                assert!(client_out.sendto([1], server_in_addr).is_ok());\n+                // wait for data\n+                let res = client_in.recvfrom(buf);\n+                assert!(res.is_ok());\n+                let (nread, src) = res.unwrap();\n+                assert_eq!(src, server_out_addr);\n+                total_bytes_recv += nread;\n+                for i in range(0u, nread) {\n+                    assert_eq!(buf[i], 1);\n                 }\n-                // tell the server we're done\n-                assert!(client_out.sendto([0], server_in_addr).is_ok());\n             }\n+            // tell the server we're done\n+            assert!(client_out.sendto([0], server_in_addr).is_ok());\n         }\n     }\n \n     #[test]\n     fn test_read_and_block() {\n-        do run_uv_loop |l| {\n-            let addr = next_test_ip4();\n-            let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n-\n-            let handle = l.handle;\n-            do spawntask {\n-                let l = &mut Loop::wrap(handle);\n-                let listener = TcpListener::bind(l, addr).unwrap();\n-                let mut acceptor = listener.listen().unwrap();\n-                let (port2, chan2) = stream();\n-                chan.take().send(port2);\n-                let mut stream = acceptor.accept().unwrap();\n-                let mut buf = [0, .. 2048];\n-\n-                let expected = 32;\n-                let mut current = 0;\n-                let mut reads = 0;\n-\n-                while current < expected {\n-                    let nread = stream.read(buf).unwrap();\n-                    for i in range(0u, nread) {\n-                        let val = buf[i] as uint;\n-                        assert_eq!(val, current % 8);\n-                        current += 1;\n-                    }\n-                    reads += 1;\n+        let addr = next_test_ip4();\n+        let (port, chan) = oneshot();\n+        let port = Cell::new(port);\n+        let chan = Cell::new(chan);\n+\n+        do spawn {\n+            let listener = TcpListener::bind(local_loop(), addr).unwrap();\n+            let mut acceptor = listener.listen().unwrap();\n+            let (port2, chan2) = stream();\n+            chan.take().send(port2);\n+            let mut stream = acceptor.accept().unwrap();\n+            let mut buf = [0, .. 2048];\n+\n+            let expected = 32;\n+            let mut current = 0;\n+            let mut reads = 0;\n \n-                    chan2.send(());\n+            while current < expected {\n+                let nread = stream.read(buf).unwrap();\n+                for i in range(0u, nread) {\n+                    let val = buf[i] as uint;\n+                    assert_eq!(val, current % 8);\n+                    current += 1;\n                 }\n+                reads += 1;\n \n-                // Make sure we had multiple reads\n-                assert!(reads > 1);\n+                chan2.send(());\n             }\n \n-            do spawntask {\n-                let l = &mut Loop::wrap(handle);\n-                let port2 = port.take().recv();\n-                let mut stream = TcpWatcher::connect(l, addr).unwrap();\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                port2.recv();\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                port2.recv();\n-            }\n+            // Make sure we had multiple reads\n+            assert!(reads > 1);\n+        }\n+\n+        do spawn {\n+            let port2 = port.take().recv();\n+            let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            port2.recv();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            port2.recv();\n         }\n     }\n \n@@ -1113,27 +1071,23 @@ mod test {\n         let addr = next_test_ip4();\n \n         do task::spawn_sched(task::SingleThreaded) {\n-            do run_uv_loop |l| {\n-                let listener = TcpListener::bind(l, addr).unwrap();\n-                let mut acceptor = listener.listen().unwrap();\n-                let mut stream = acceptor.accept().unwrap();\n-                let mut buf = [0, .. 2048];\n-                let nread = stream.read(buf).unwrap();\n-                assert_eq!(nread, 8);\n-                for i in range(0u, nread) {\n-                    assert_eq!(buf[i], i as u8);\n-                }\n+            let listener = TcpListener::bind(local_loop(), addr).unwrap();\n+            let mut acceptor = listener.listen().unwrap();\n+            let mut stream = acceptor.accept().unwrap();\n+            let mut buf = [0, .. 2048];\n+            let nread = stream.read(buf).unwrap();\n+            assert_eq!(nread, 8);\n+            for i in range(0u, nread) {\n+                assert_eq!(buf[i], i as u8);\n             }\n         }\n \n         do task::spawn_sched(task::SingleThreaded) {\n-            do run_uv_loop |l| {\n-                let mut stream = TcpWatcher::connect(l, addr);\n-                while stream.is_err() {\n-                    stream = TcpWatcher::connect(l, addr);\n-                }\n-                stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            let mut stream = TcpWatcher::connect(local_loop(), addr);\n+            while stream.is_err() {\n+                stream = TcpWatcher::connect(local_loop(), addr);\n             }\n+            stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]);\n         }\n     }\n \n@@ -1149,17 +1103,13 @@ mod test {\n \n         do task::spawn_sched(task::SingleThreaded) {\n             let chan = Cell::new(chan.take());\n-            do run_uv_loop |l| {\n-                let listener = UdpWatcher::bind(l, next_test_ip4()).unwrap();\n-                chan.take().send(listener);\n-            }\n+            let listener = UdpWatcher::bind(local_loop(), next_test_ip4()).unwrap();\n+            chan.take().send(listener);\n         }\n \n         do task::spawn_sched(task::SingleThreaded) {\n             let port = Cell::new(port.take());\n-            do run_uv_loop |_l| {\n-                port.take().recv();\n-            }\n+            port.take().recv();\n         }\n     }\n \n@@ -1261,4 +1211,69 @@ mod test {\n         }\n     }\n \n+    #[should_fail]\n+    #[test]\n+    #[ignore(reason = \"linked failure\")]\n+    fn linked_failure1() {\n+        let (port, chan) = oneshot();\n+        let chan = Cell::new(chan);\n+        let addr = next_test_ip4();\n+\n+        do spawn {\n+            let w = TcpListener::bind(local_loop(), addr).unwrap();\n+            let mut w = w.listen().unwrap();\n+            chan.take().send(());\n+            w.accept();\n+        }\n+\n+        port.recv();\n+        fail!();\n+    }\n+\n+    #[should_fail]\n+    #[test]\n+    #[ignore(reason = \"linked failure\")]\n+    fn linked_failure2() {\n+        let (port, chan) = oneshot();\n+        let chan = Cell::new(chan);\n+        let addr = next_test_ip4();\n+\n+        do spawn {\n+            let w = TcpListener::bind(local_loop(), addr).unwrap();\n+            let mut w = w.listen().unwrap();\n+            chan.take().send(());\n+            let mut buf = [0];\n+            w.accept().unwrap().read(buf);\n+        }\n+\n+        port.recv();\n+        let _w = TcpWatcher::connect(local_loop(), addr).unwrap();\n+\n+        fail!();\n+    }\n+\n+    #[should_fail]\n+    #[test]\n+    #[ignore(reason = \"linked failure\")]\n+    fn linked_failure3() {\n+        let (port, chan) = stream();\n+        let chan = Cell::new(chan);\n+        let addr = next_test_ip4();\n+\n+        do spawn {\n+            let chan = chan.take();\n+            let w = TcpListener::bind(local_loop(), addr).unwrap();\n+            let mut w = w.listen().unwrap();\n+            chan.send(());\n+            let mut conn = w.accept().unwrap();\n+            chan.send(());\n+            let buf = [0, ..65536];\n+            conn.write(buf);\n+        }\n+\n+        port.recv();\n+        let _w = TcpWatcher::connect(local_loop(), addr).unwrap();\n+        port.recv();\n+        fail!();\n+    }\n }"}, {"sha": "89a86a2ff7dce106a0a4f6486cb1cd046c0b40ce", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 54, "deletions": 60, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=df4c0b8e4349d50f317553de5a47d0cd56cdc227", "patch": "@@ -9,17 +9,18 @@\n // except according to those terms.\n \n use std::c_str::CString;\n-use std::cast;\n use std::libc;\n use std::rt::BlockedTask;\n use std::rt::io::IoError;\n use std::rt::local::Local;\n use std::rt::rtio::{RtioPipe, RtioUnixListener, RtioUnixAcceptor};\n use std::rt::sched::{Scheduler, SchedHandle};\n use std::rt::tube::Tube;\n+use std::task;\n \n use stream::StreamWatcher;\n-use super::{Loop, UvError, UvHandle, Request, uv_error_to_io_error};\n+use super::{Loop, UvError, UvHandle, Request, uv_error_to_io_error,\n+            wait_until_woken_after};\n use uvio::HomingIO;\n use uvll;\n \n@@ -32,7 +33,6 @@ pub struct PipeWatcher {\n pub struct PipeListener {\n     home: SchedHandle,\n     pipe: *uvll::uv_pipe_t,\n-    priv closing_task: Option<BlockedTask>,\n     priv outgoing: Tube<Result<~RtioPipe, IoError>>,\n }\n \n@@ -74,36 +74,35 @@ impl PipeWatcher {\n     pub fn connect(loop_: &Loop, name: &CString) -> Result<PipeWatcher, UvError>\n     {\n         struct Ctx { task: Option<BlockedTask>, result: libc::c_int, }\n-        let mut cx = Ctx { task: None, result: 0 };\n-        let req = Request::new(uvll::UV_CONNECT);\n-        let pipe = PipeWatcher::new(loop_, false);\n-        unsafe {\n-            uvll::set_data_for_req(req.handle, &cx as *Ctx);\n-            uvll::uv_pipe_connect(req.handle,\n-                                  pipe.handle(),\n-                                  name.with_ref(|p| p),\n-                                  connect_cb)\n-        }\n-        req.defuse();\n+        return do task::unkillable {\n+            let mut cx = Ctx { task: None, result: 0 };\n+            let mut req = Request::new(uvll::UV_CONNECT);\n+            let pipe = PipeWatcher::new(loop_, false);\n+\n+            do wait_until_woken_after(&mut cx.task) {\n+                unsafe {\n+                    uvll::uv_pipe_connect(req.handle,\n+                                          pipe.handle(),\n+                                          name.with_ref(|p| p),\n+                                          connect_cb)\n+                }\n+                req.set_data(&cx);\n+                req.defuse(); // uv callback now owns this request\n+            }\n+            match cx.result {\n+                0 => Ok(pipe),\n+                n => Err(UvError(n))\n+            }\n \n-        let sched: ~Scheduler = Local::take();\n-        do sched.deschedule_running_task_and_then |_, task| {\n-            cx.task = Some(task);\n-        }\n-        return match cx.result {\n-            0 => Ok(pipe),\n-            n => Err(UvError(n))\n         };\n \n-        extern fn connect_cb(req: *uvll::uv_connect_t, status: libc::c_int) {\n-            let _req = Request::wrap(req);\n-            if status == uvll::ECANCELED { return }\n-            unsafe {\n-                let cx: &mut Ctx = cast::transmute(uvll::get_data_for_req(req));\n-                cx.result = status;\n-                let sched: ~Scheduler = Local::take();\n-                sched.resume_blocked_task_immediately(cx.task.take_unwrap());\n-            }\n+        extern fn connect_cb(req: *uvll::uv_connect_t, status: libc::c_int) {;\n+            let req = Request::wrap(req);\n+            assert!(status != uvll::ECANCELED);\n+            let cx: &mut Ctx = unsafe { req.get_data() };\n+            cx.result = status;\n+            let sched: ~Scheduler = Local::take();\n+            sched.resume_blocked_task_immediately(cx.task.take_unwrap());\n         }\n     }\n \n@@ -133,11 +132,15 @@ impl HomingIO for PipeWatcher {\n     fn home<'a>(&'a mut self) -> &'a mut SchedHandle { &mut self.home }\n }\n \n+impl UvHandle<uvll::uv_pipe_t> for PipeWatcher {\n+    fn uv_handle(&self) -> *uvll::uv_pipe_t { self.stream.handle }\n+}\n+\n impl Drop for PipeWatcher {\n     fn drop(&mut self) {\n         if !self.defused {\n             let _m = self.fire_homing_missile();\n-            self.stream.close();\n+            self.close();\n         }\n     }\n }\n@@ -150,21 +153,24 @@ extern fn pipe_close_cb(handle: *uvll::uv_handle_t) {\n \n impl PipeListener {\n     pub fn bind(loop_: &Loop, name: &CString) -> Result<~PipeListener, UvError> {\n-        let pipe = PipeWatcher::new(loop_, false);\n-        match unsafe { uvll::uv_pipe_bind(pipe.handle(), name.with_ref(|p| p)) } {\n-            0 => {\n-                // If successful, unwrap the PipeWatcher because we control how\n-                // we close the pipe differently. We can't rely on\n-                // StreamWatcher's default close method.\n-                let p = ~PipeListener {\n-                    home: get_handle_to_current_scheduler!(),\n-                    pipe: pipe.unwrap(),\n-                    closing_task: None,\n-                    outgoing: Tube::new(),\n-                };\n-                Ok(p.install())\n+        do task::unkillable {\n+            let pipe = PipeWatcher::new(loop_, false);\n+            match unsafe {\n+                uvll::uv_pipe_bind(pipe.handle(), name.with_ref(|p| p))\n+            } {\n+                0 => {\n+                    // If successful, unwrap the PipeWatcher because we control how\n+                    // we close the pipe differently. We can't rely on\n+                    // StreamWatcher's default close method.\n+                    let p = ~PipeListener {\n+                        home: get_handle_to_current_scheduler!(),\n+                        pipe: pipe.unwrap(),\n+                        outgoing: Tube::new(),\n+                    };\n+                    Ok(p.install())\n+                }\n+                n => Err(UvError(n))\n             }\n-            n => Err(UvError(n))\n         }\n     }\n }\n@@ -196,6 +202,7 @@ impl UvHandle<uvll::uv_pipe_t> for PipeListener {\n }\n \n extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n+    assert!(status != uvll::ECANCELED);\n     let msg = match status {\n         0 => {\n             let loop_ = Loop::wrap(unsafe {\n@@ -205,7 +212,6 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n             assert_eq!(unsafe { uvll::uv_accept(server, client.handle()) }, 0);\n             Ok(~client as ~RtioPipe)\n         }\n-        uvll::ECANCELED => return,\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n \n@@ -215,23 +221,11 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n \n impl Drop for PipeListener {\n     fn drop(&mut self) {\n-        let (_m, sched) = self.fire_homing_missile_sched();\n-\n-        do sched.deschedule_running_task_and_then |_, task| {\n-            self.closing_task = Some(task);\n-            unsafe { uvll::uv_close(self.pipe, listener_close_cb) }\n-        }\n+        let _m = self.fire_homing_missile();\n+        self.close();\n     }\n }\n \n-extern fn listener_close_cb(handle: *uvll::uv_handle_t) {\n-    let pipe: &mut PipeListener = unsafe { UvHandle::from_uv_handle(&handle) };\n-    unsafe { uvll::free_handle(handle) }\n-\n-    let sched: ~Scheduler = Local::take();\n-    sched.resume_blocked_task_immediately(pipe.closing_task.take_unwrap());\n-}\n-\n // PipeAcceptor implementation and traits\n \n impl RtioUnixAcceptor for PipeAcceptor {"}, {"sha": "17a7510aa19b71e32befb5000b9abc6976691b6c", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=df4c0b8e4349d50f317553de5a47d0cd56cdc227", "patch": "@@ -19,7 +19,8 @@ use std::rt::rtio::RtioProcess;\n use std::rt::sched::{Scheduler, SchedHandle};\n use std::vec;\n \n-use super::{Loop, UvHandle, UvError, uv_error_to_io_error};\n+use super::{Loop, UvHandle, UvError, uv_error_to_io_error,\n+            wait_until_woken_after};\n use uvio::HomingIO;\n use uvll;\n use pipe::PipeWatcher;\n@@ -222,11 +223,7 @@ impl RtioProcess for Process {\n                 // If there's no exit code previously listed, then the\n                 // process's exit callback has yet to be invoked. We just\n                 // need to deschedule ourselves and wait to be reawoken.\n-                let scheduler: ~Scheduler = Local::take();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    assert!(self.to_wake.is_none());\n-                    self.to_wake = Some(task);\n-                }\n+                wait_until_woken_after(&mut self.to_wake, || {});\n                 assert!(self.exit_status.is_some());\n             }\n         }"}, {"sha": "b9ccacf4df707ff51178358000a50f04a7828757", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 33, "deletions": 49, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=df4c0b8e4349d50f317553de5a47d0cd56cdc227", "patch": "@@ -9,12 +9,14 @@\n // except according to those terms.\n \n use std::cast;\n-use std::libc::{c_int, size_t, ssize_t, c_void};\n+use std::libc::{c_int, size_t, ssize_t};\n+use std::ptr;\n use std::rt::BlockedTask;\n use std::rt::local::Local;\n use std::rt::sched::Scheduler;\n \n-use super::{UvError, Buf, slice_to_uv_buf, Request};\n+use super::{UvError, Buf, slice_to_uv_buf, Request, wait_until_woken_after,\n+            ForbidUnwind};\n use uvll;\n \n // This is a helper structure which is intended to get embedded into other\n@@ -63,6 +65,10 @@ impl StreamWatcher {\n     }\n \n     pub fn read(&mut self, buf: &mut [u8]) -> Result<uint, UvError> {\n+        // This read operation needs to get canceled on an unwind via libuv's\n+        // uv_read_stop function\n+        let _f = ForbidUnwind::new(\"stream read\");\n+\n         // Send off the read request, but don't block until we're sure that the\n         // read request is queued.\n         match unsafe {\n@@ -74,12 +80,10 @@ impl StreamWatcher {\n                     result: 0,\n                     task: None,\n                 };\n-                unsafe {\n-                    uvll::set_data_for_uv_handle(self.handle, &rcx)\n-                }\n-                let scheduler: ~Scheduler = Local::take();\n-                do scheduler.deschedule_running_task_and_then |_sched, task| {\n-                    rcx.task = Some(task);\n+                do wait_until_woken_after(&mut rcx.task) {\n+                    unsafe {\n+                        uvll::set_data_for_uv_handle(self.handle, &rcx)\n+                    }\n                 }\n                 match rcx.result {\n                     n if n < 0 => Err(UvError(n as c_int)),\n@@ -91,12 +95,17 @@ impl StreamWatcher {\n     }\n \n     pub fn write(&mut self, buf: &[u8]) -> Result<(), UvError> {\n+        // The ownership of the write request is dubious if this function\n+        // unwinds. I believe that if the write_cb fails to re-schedule the task\n+        // then the write request will be leaked.\n+        let _f = ForbidUnwind::new(\"stream write\");\n+\n         // Prepare the write request, either using a cached one or allocating a\n         // new one\n-        if self.last_write_req.is_none() {\n-            self.last_write_req = Some(Request::new(uvll::UV_WRITE));\n-        }\n-        let req = self.last_write_req.get_ref();\n+        let mut req = match self.last_write_req.take() {\n+            Some(req) => req, None => Request::new(uvll::UV_WRITE),\n+        };\n+        req.set_data(ptr::null::<()>());\n \n         // Send off the request, but be careful to not block until we're sure\n         // that the write reqeust is queued. If the reqeust couldn't be queued,\n@@ -107,11 +116,12 @@ impl StreamWatcher {\n         } {\n             0 => {\n                 let mut wcx = WriteContext { result: 0, task: None, };\n-                req.set_data(&wcx);\n-                let scheduler: ~Scheduler = Local::take();\n-                do scheduler.deschedule_running_task_and_then |_sched, task| {\n-                    wcx.task = Some(task);\n+                req.defuse(); // uv callback now owns this request\n+\n+                do wait_until_woken_after(&mut wcx.task) {\n+                    req.set_data(&wcx);\n                 }\n+                self.last_write_req = Some(Request::wrap(req.handle));\n                 match wcx.result {\n                     0 => Ok(()),\n                     n => Err(UvError(n)),\n@@ -120,50 +130,24 @@ impl StreamWatcher {\n             n => Err(UvError(n)),\n         }\n     }\n-\n-    // This will deallocate an internally used memory, along with closing the\n-    // handle (and freeing it).\n-    pub fn close(&mut self) {\n-        let mut closing_task = None;\n-        unsafe {\n-            uvll::set_data_for_uv_handle(self.handle, &closing_task);\n-        }\n-\n-        // Wait for this stream to close because it possibly represents a remote\n-        // connection which may have consequences if we close asynchronously.\n-        let sched: ~Scheduler = Local::take();\n-        do sched.deschedule_running_task_and_then |_, task| {\n-            closing_task = Some(task);\n-            unsafe { uvll::uv_close(self.handle, close_cb) }\n-        }\n-\n-        extern fn close_cb(handle: *uvll::uv_handle_t) {\n-            let data: *c_void = unsafe { uvll::get_data_for_uv_handle(handle) };\n-            unsafe { uvll::free_handle(handle) }\n-\n-            let closing_task: &mut Option<BlockedTask> = unsafe {\n-                cast::transmute(data)\n-            };\n-            let task = closing_task.take_unwrap();\n-            let scheduler: ~Scheduler = Local::take();\n-            scheduler.resume_blocked_task_immediately(task);\n-        }\n-    }\n }\n \n // This allocation callback expects to be invoked once and only once. It will\n // unwrap the buffer in the ReadContext stored in the stream and return it. This\n // will fail if it is called more than once.\n extern fn alloc_cb(stream: *uvll::uv_stream_t, _hint: size_t) -> Buf {\n+    uvdebug!(\"alloc_cb\");\n     let rcx: &mut ReadContext = unsafe {\n         cast::transmute(uvll::get_data_for_uv_handle(stream))\n     };\n-    rcx.buf.take().expect(\"alloc_cb called more than once\")\n+    rcx.buf.take().expect(\"stream alloc_cb called more than once\")\n }\n \n // When a stream has read some data, we will always forcibly stop reading and\n // return all the data read (even if it didn't fill the whole buffer).\n extern fn read_cb(handle: *uvll::uv_stream_t, nread: ssize_t, _buf: Buf) {\n+    uvdebug!(\"read_cb {}\", nread);\n+    assert!(nread != uvll::ECANCELED as ssize_t);\n     let rcx: &mut ReadContext = unsafe {\n         cast::transmute(uvll::get_data_for_uv_handle(handle))\n     };\n@@ -182,11 +166,11 @@ extern fn read_cb(handle: *uvll::uv_stream_t, nread: ssize_t, _buf: Buf) {\n // reading, however, all this does is wake up the blocked task after squirreling\n // away the error code as a result.\n extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n-    if status == uvll::ECANCELED { return }\n+    let mut req = Request::wrap(req);\n+    assert!(status != uvll::ECANCELED);\n     // Remember to not free the request because it is re-used between writes on\n     // the same stream.\n-    let req = Request::wrap(req);\n-    let wcx: &mut WriteContext = unsafe { cast::transmute(req.get_data()) };\n+    let wcx: &mut WriteContext = unsafe { req.get_data() };\n     wcx.result = status;\n     req.defuse();\n "}, {"sha": "96cf024639f81b87f36f2bfdefab126219d0830e", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=df4c0b8e4349d50f317553de5a47d0cd56cdc227", "patch": "@@ -16,7 +16,7 @@ use std::rt::rtio::RtioTimer;\n use std::rt::sched::{Scheduler, SchedHandle};\n \n use uvll;\n-use super::{Loop, UvHandle};\n+use super::{Loop, UvHandle, ForbidUnwind};\n use uvio::HomingIO;\n \n pub struct TimerWatcher {\n@@ -67,6 +67,11 @@ impl UvHandle<uvll::uv_timer_t> for TimerWatcher {\n impl RtioTimer for TimerWatcher {\n     fn sleep(&mut self, msecs: u64) {\n         let (_m, sched) = self.fire_homing_missile_sched();\n+\n+        // If the descheduling operation unwinds after the timer has been\n+        // started, then we need to call stop on the timer.\n+        let _f = ForbidUnwind::new(\"timer\");\n+\n         do sched.deschedule_running_task_and_then |_sched, task| {\n             self.action = Some(WakeTask(task));\n             self.start(msecs, 0);\n@@ -124,51 +129,43 @@ impl Drop for TimerWatcher {\n mod test {\n     use super::*;\n     use std::rt::rtio::RtioTimer;\n-    use super::super::run_uv_loop;\n+    use super::super::local_loop;\n \n     #[test]\n     fn oneshot() {\n-        do run_uv_loop |l| {\n-            let mut timer = TimerWatcher::new(l);\n-            let port = timer.oneshot(1);\n-            port.recv();\n-            let port = timer.oneshot(1);\n-            port.recv();\n-        }\n+        let mut timer = TimerWatcher::new(local_loop());\n+        let port = timer.oneshot(1);\n+        port.recv();\n+        let port = timer.oneshot(1);\n+        port.recv();\n     }\n \n     #[test]\n     fn override() {\n-        do run_uv_loop |l| {\n-            let mut timer = TimerWatcher::new(l);\n-            let oport = timer.oneshot(1);\n-            let pport = timer.period(1);\n-            timer.sleep(1);\n-            assert_eq!(oport.try_recv(), None);\n-            assert_eq!(pport.try_recv(), None);\n-            timer.oneshot(1).recv();\n-        }\n+        let mut timer = TimerWatcher::new(local_loop());\n+        let oport = timer.oneshot(1);\n+        let pport = timer.period(1);\n+        timer.sleep(1);\n+        assert_eq!(oport.try_recv(), None);\n+        assert_eq!(pport.try_recv(), None);\n+        timer.oneshot(1).recv();\n     }\n \n     #[test]\n     fn period() {\n-        do run_uv_loop |l| {\n-            let mut timer = TimerWatcher::new(l);\n-            let port = timer.period(1);\n-            port.recv();\n-            port.recv();\n-            let port = timer.period(1);\n-            port.recv();\n-            port.recv();\n-        }\n+        let mut timer = TimerWatcher::new(local_loop());\n+        let port = timer.period(1);\n+        port.recv();\n+        port.recv();\n+        let port = timer.period(1);\n+        port.recv();\n+        port.recv();\n     }\n \n     #[test]\n     fn sleep() {\n-        do run_uv_loop |l| {\n-            let mut timer = TimerWatcher::new(l);\n-            timer.sleep(1);\n-            timer.sleep(1);\n-        }\n+        let mut timer = TimerWatcher::new(local_loop());\n+        timer.sleep(1);\n+        timer.sleep(1);\n     }\n }"}, {"sha": "04e406ce987e9f86d4b4a6dab04489bb7374c9b6", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=df4c0b8e4349d50f317553de5a47d0cd56cdc227", "patch": "@@ -103,6 +103,6 @@ impl HomingIO for TtyWatcher {\n impl Drop for TtyWatcher {\n     fn drop(&mut self) {\n         let _m = self.fire_homing_missile();\n-        self.stream.close();\n+        self.close();\n     }\n }"}, {"sha": "75ec5f26b336ce8ffc972d12260bfae950c932cd", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 40, "deletions": 25, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4c0b8e4349d50f317553de5a47d0cd56cdc227/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=df4c0b8e4349d50f317553de5a47d0cd56cdc227", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::c_str::CString;\n-use std::comm::{SharedChan, GenericChan};\n+use std::comm::SharedChan;\n use std::libc::c_int;\n use std::libc;\n use std::path::Path;\n@@ -26,7 +26,7 @@ use std::libc::{O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n use std::rt::io::{FileMode, FileAccess, Open, Append, Truncate, Read, Write,\n                   ReadWrite, FileStat};\n use std::rt::io::signal::Signum;\n-use std::task;\n+use std::util;\n use ai = std::rt::io::net::addrinfo;\n \n #[cfg(test)] use std::unstable::run_in_bare_thread;\n@@ -44,29 +44,31 @@ pub trait HomingIO {\n     fn go_to_IO_home(&mut self) -> uint {\n         use std::rt::sched::RunOnce;\n \n+        unsafe {\n+            let task: *mut Task = Local::unsafe_borrow();\n+            (*task).death.inhibit_kill((*task).unwinder.unwinding);\n+        }\n+\n+        let _f = ForbidUnwind::new(\"going home\");\n+\n         let current_sched_id = do Local::borrow |sched: &mut Scheduler| {\n             sched.sched_id()\n         };\n \n         // Only need to invoke a context switch if we're not on the right\n         // scheduler.\n         if current_sched_id != self.home().sched_id {\n-            do task::unkillable { // FIXME(#8674)\n-                let scheduler: ~Scheduler = Local::take();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    /* FIXME(#8674) if the task was already killed then wake\n-                     * will return None. In that case, the home pointer will\n-                     * never be set.\n-                     *\n-                     * RESOLUTION IDEA: Since the task is dead, we should\n-                     * just abort the IO action.\n-                     */\n-                    do task.wake().map |task| {\n-                        self.home().send(RunOnce(task));\n-                    };\n-                }\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                do task.wake().map |task| {\n+                    self.home().send(RunOnce(task));\n+                };\n             }\n         }\n+        let current_sched_id = do Local::borrow |sched: &mut Scheduler| {\n+            sched.sched_id()\n+        };\n+        assert!(current_sched_id == self.home().sched_id);\n \n         self.home().sched_id\n     }\n@@ -98,25 +100,38 @@ struct HomingMissile {\n     priv io_home: uint,\n }\n \n+impl HomingMissile {\n+    pub fn check(&self, msg: &'static str) {\n+        let local_id = Local::borrow(|sched: &mut Scheduler| sched.sched_id());\n+        assert!(local_id == self.io_home, \"{}\", msg);\n+    }\n+}\n+\n impl Drop for HomingMissile {\n     fn drop(&mut self) {\n+        let f = ForbidUnwind::new(\"leaving home\");\n+\n         // It would truly be a sad day if we had moved off the home I/O\n         // scheduler while we were doing I/O.\n-        assert_eq!(Local::borrow(|sched: &mut Scheduler| sched.sched_id()),\n-                   self.io_home);\n+        self.check(\"task moved away from the home scheduler\");\n \n         // If we were a homed task, then we must send ourselves back to the\n         // original scheduler. Otherwise, we can just return and keep running\n         if !Task::on_appropriate_sched() {\n-            do task::unkillable { // FIXME(#8674)\n-                let scheduler: ~Scheduler = Local::take();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    do task.wake().map |task| {\n-                        Scheduler::run_task(task);\n-                    };\n-                }\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                do task.wake().map |task| {\n+                    Scheduler::run_task(task);\n+                };\n             }\n         }\n+\n+        util::ignore(f);\n+\n+        unsafe {\n+            let task: *mut Task = Local::unsafe_borrow();\n+            (*task).death.allow_kill((*task).unwinder.unwinding);\n+        }\n     }\n }\n "}]}