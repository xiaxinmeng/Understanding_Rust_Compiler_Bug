{"sha": "5515a976464e488949a6a7324ac41ecaf3246a19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MTVhOTc2NDY0ZTQ4ODk0OWE2YTczMjRhYzQxZWNhZjMyNDZhMTk=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-10-04T04:29:20Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-10-04T07:03:41Z"}, "message": "Introduce a special case in `IntRange::from_const`.\n\nThe `if let Some(val) = value.try_eval_bits(...)` branch in `from_const()` is\nvery hot for the `unicode_normalization` benchmark.\n\nThis commit introduces a special-case alternative for scalars that avoids\n`try_eval_bits()` and all the functions it calls (`Const::eval()`,\n`ConstValue::try_to_bits()`, `ConstValue::try_to_scalar()`, and\n`Scalar::to_bits()`), instead extracting the result immediately.\n\nThe type and value checking done by `Scalar::to_bits()` is replicated by moving\nit into a new function `Scalar::check_raw()` and using that new function in the\nspecial case.\n\nPR #64673 introduced some special-case handling of scalar types in\n`Const::try_eval_bits()`. This handling is now moved out of that function into\nthe new `IntRange::integral_size_and_signed_bias` function.\n\nThis commit reduces the instruction count for\n`unicode_normalization-check-clean` by about 10%.", "tree": {"sha": "417375b4bc76f3ae824c02e9d069f5ede0741122", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/417375b4bc76f3ae824c02e9d069f5ede0741122"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5515a976464e488949a6a7324ac41ecaf3246a19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5515a976464e488949a6a7324ac41ecaf3246a19", "html_url": "https://github.com/rust-lang/rust/commit/5515a976464e488949a6a7324ac41ecaf3246a19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5515a976464e488949a6a7324ac41ecaf3246a19/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a69e0e0ab402591e9e42c596054ea45df702f3e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a69e0e0ab402591e9e42c596054ea45df702f3e0", "html_url": "https://github.com/rust-lang/rust/commit/a69e0e0ab402591e9e42c596054ea45df702f3e0"}], "stats": {"total": 64, "additions": 38, "deletions": 26}, "files": [{"sha": "bbf00cc23ae8835008e18b6fc596fdf440afe47a", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5515a976464e488949a6a7324ac41ecaf3246a19/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515a976464e488949a6a7324ac41ecaf3246a19/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=5515a976464e488949a6a7324ac41ecaf3246a19", "patch": "@@ -343,14 +343,19 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n+    #[inline(always)]\n+    pub fn check_raw(data: u128, size: u8, target_size: Size) {\n+        assert_eq!(target_size.bytes(), size as u64);\n+        assert_ne!(size, 0, \"you should never look at the bits of a ZST\");\n+        Scalar::check_data(data, size);\n+    }\n+\n     /// Do not call this method!  Use either `assert_bits` or `force_bits`.\n     #[inline]\n     pub fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(target_size.bytes(), size as u64);\n-                assert_ne!(size, 0, \"you should never look at the bits of a ZST\");\n-                Scalar::check_data(data, size);\n+                Self::check_raw(data, size, target_size);\n                 Ok(data)\n             }\n             Scalar::Ptr(_) => throw_unsup!(ReadPointerAsBytes),"}, {"sha": "d5bb18a2e3e2aadb81f01c009029930764cd01a2", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5515a976464e488949a6a7324ac41ecaf3246a19/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515a976464e488949a6a7324ac41ecaf3246a19/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=5515a976464e488949a6a7324ac41ecaf3246a19", "patch": "@@ -13,7 +13,7 @@ use rustc_macros::HashStable;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef, GenericArg, GenericArgKind};\n use crate::ty::{self, AdtDef, Discr, DefIdTree, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use crate::ty::{List, TyS, ParamEnvAnd, ParamEnv};\n-use crate::ty::layout::{Size, Integer, IntegerExt, VariantIdx};\n+use crate::ty::layout::VariantIdx;\n use crate::util::captures::Captures;\n use crate::mir::interpret::{Scalar, GlobalId};\n \n@@ -24,7 +24,6 @@ use std::marker::PhantomData;\n use std::ops::Range;\n use rustc_target::spec::abi;\n use syntax::ast::{self, Ident};\n-use syntax::attr::{SignedInt, UnsignedInt};\n use syntax::symbol::{kw, InternedString};\n \n use self::InferTy::*;\n@@ -2299,20 +2298,7 @@ impl<'tcx> Const<'tcx> {\n         ty: Ty<'tcx>,\n     ) -> Option<u128> {\n         assert_eq!(self.ty, ty);\n-        // This is purely an optimization -- layout_of is a pretty expensive operation,\n-        // but if we can determine the size without calling it, we don't need all that complexity\n-        // (hashing, caching, etc.). As such, try to skip it.\n-        let size = match ty.kind {\n-            ty::Bool => Size::from_bytes(1),\n-            ty::Char => Size::from_bytes(4),\n-            ty::Int(ity) => {\n-                Integer::from_attr(&tcx, SignedInt(ity)).size()\n-            }\n-            ty::Uint(uty) => {\n-                Integer::from_attr(&tcx, UnsignedInt(uty)).size()\n-            }\n-            _ => tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size,\n-        };\n+        let size = tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size;\n         // if `ty` does not depend on generic parameters, use an empty param_env\n         self.eval(tcx, param_env).val.try_to_bits(size)\n     }"}, {"sha": "c4f59e649b3aee2bdf9e05dff594236409d6a9e8", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5515a976464e488949a6a7324ac41ecaf3246a19/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5515a976464e488949a6a7324ac41ecaf3246a19/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=5515a976464e488949a6a7324ac41ecaf3246a19", "patch": "@@ -842,21 +842,42 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n+    #[inline]\n+    fn integral_size_and_signed_bias(tcx: TyCtxt<'tcx>, ty: Ty<'_>) -> Option<(Size, u128)> {\n+        match ty.kind {\n+            ty::Char => Some((Size::from_bytes(4), 0)),\n+            ty::Int(ity) => {\n+                let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n+                Some((size, 1u128 << (size.bits() as u128 - 1)))\n+            }\n+            ty::Uint(uty) => Some((Integer::from_attr(&tcx, UnsignedInt(uty)).size(), 0)),\n+            _ => None,\n+        }\n+    }\n+\n     #[inline]\n     fn from_const(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &Const<'tcx>,\n     ) -> Option<IntRange<'tcx>> {\n-        if Self::is_integral(value.ty) {\n+        if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, value.ty) {\n             let ty = value.ty;\n-            if let Some(val) = value.try_eval_bits(tcx, param_env, ty) {\n-                let bias = IntRange::signed_bias(tcx, ty);\n-                let val = val ^ bias;\n-                Some(IntRange { range: val..=val, ty })\n+            let val = if let ConstValue::Scalar(Scalar::Raw { data, size }) = value.val {\n+                // For this specific pattern we can skip a lot of effort and go\n+                // straight to the result, after doing a bit of checking. (We\n+                // could remove this branch and just use the next branch, which\n+                // is more general but much slower.)\n+                Scalar::<()>::check_raw(data, size, target_size);\n+                data\n+            } else if let Some(val) = value.try_eval_bits(tcx, param_env, ty) {\n+                // This is a more general form of the previous branch.\n+                val\n             } else {\n-                None\n-            }\n+                return None\n+            };\n+            let val = val ^ bias;\n+            Some(IntRange { range: val..=val, ty })\n         } else {\n             None\n         }"}]}