{"sha": "fe03caedf0d2e32c41bb1c5169fb0162c8af6b28", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMDNjYWVkZjBkMmUzMmM0MWJiMWM1MTY5ZmIwMTYyYzhhZjZiMjg=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-06T14:00:19Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-01-07T13:31:24Z"}, "message": "std::trie: use macros to share code between the iterator implementations.", "tree": {"sha": "6d5882aa183f160439e96a87a9afd40fb8a4d7ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d5882aa183f160439e96a87a9afd40fb8a4d7ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe03caedf0d2e32c41bb1c5169fb0162c8af6b28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe03caedf0d2e32c41bb1c5169fb0162c8af6b28", "html_url": "https://github.com/rust-lang/rust/commit/fe03caedf0d2e32c41bb1c5169fb0162c8af6b28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe03caedf0d2e32c41bb1c5169fb0162c8af6b28/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f07c74d93ad2b5292267e5829c4c8493211aa835", "url": "https://api.github.com/repos/rust-lang/rust/commits/f07c74d93ad2b5292267e5829c4c8493211aa835", "html_url": "https://github.com/rust-lang/rust/commit/f07c74d93ad2b5292267e5829c4c8493211aa835"}], "stats": {"total": 255, "additions": 126, "deletions": 129}, "files": [{"sha": "b6995a1d24ce30bbaca9001c2c96f3629b996858", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 126, "deletions": 129, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/fe03caedf0d2e32c41bb1c5169fb0162c8af6b28/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe03caedf0d2e32c41bb1c5169fb0162c8af6b28/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=fe03caedf0d2e32c41bb1c5169fb0162c8af6b28", "patch": "@@ -141,40 +141,95 @@ impl<T> TrieMap<T> {\n             remaining_max: self.length\n         }\n     }\n+}\n \n+// FIXME #5846 we want to be able to choose between &x and &mut x\n+// (with many different `x`) below, so we need to optionally pass mut\n+// as a tt, but the only thing we can do with a `tt` is pass them to\n+// other macros, so this takes the `& <mutability> <operand>` token\n+// sequence and forces their evalutation as an expression. (see also\n+// `item!` below.)\n+macro_rules! addr { ($e:expr) => { $e } }\n+\n+macro_rules! bound {\n+    ($iterator_name:ident,\n+     // the current treemap\n+     self = $this:expr,\n+     // the key to look for\n+     key = $key:expr,\n+     // are we looking at the upper bound?\n+     is_upper = $upper:expr,\n+\n+     // method names for slicing/iterating.\n+     slice_from = $slice_from:ident,\n+     iter = $iter:ident,\n+\n+     // see the comment on `addr!`, this is just an optional mut, but\n+     // there's no 0-or-1 repeats yet.\n+     mutability = $($mut_:tt)*) => {\n+        {\n+            // # For `mut`\n+            // We need an unsafe pointer here because we are borrowing\n+            // mutable references to the internals of each of these\n+            // mutable nodes, while still using the outer node.\n+            //\n+            // However, we're allowed to flaunt rustc like this because we\n+            // never actually modify the \"shape\" of the nodes. The only\n+            // place that mutation is can actually occur is of the actual\n+            // values of the TrieMap (as the return value of the\n+            // iterator), i.e. we can never cause a deallocation of any\n+            // TrieNodes so the raw pointer is always valid.\n+            //\n+            // # For non-`mut`\n+            // We like sharing code so much that even a little unsafe won't\n+            // stop us.\n+            let this = $this;\n+            let mut node = addr!(& $($mut_)* this.root as * $($mut_)* TrieNode<T>);\n+\n+            let key = $key;\n+\n+            let mut idx = 0;\n+            let mut it = $iterator_name {\n+                stack: ~[],\n+                remaining_min: 0,\n+                remaining_max: this.length\n+            };\n+            // this addr is necessary for the `Internal` pattern.\n+            addr!(loop {\n+                    let children = unsafe {addr!(& $($mut_)* (*node).children)};\n+                    let child_id = chunk(key, idx);\n+                    match children[child_id] {\n+                        Internal(ref $($mut_)* n) => {\n+                            node = addr!(& $($mut_)* **n as * $($mut_)* TrieNode<T>);\n+                        }\n+                        External(stored, _) => {\n+                            if stored < key || ($upper && stored == key) {\n+                                it.stack.push(children.$slice_from(child_id + 1).$iter());\n+                            } else {\n+                                it.stack.push(children.$slice_from(child_id).$iter());\n+                            }\n+                            return it;\n+                        }\n+                        Nothing => {\n+                            it.stack.push(children.$slice_from(child_id + 1).$iter());\n+                            return it\n+                        }\n+                    }\n+                    it.stack.push(children.$slice_from(child_id + 1).$iter());\n+                    idx += 1;\n+                })\n+        }\n+    }\n+}\n+\n+impl<T> TrieMap<T> {\n     // If `upper` is true then returns upper_bound else returns lower_bound.\n     #[inline]\n     fn bound<'a>(&'a self, key: uint, upper: bool) -> TrieMapIterator<'a, T> {\n-        let mut node: &'a TrieNode<T> = &self.root;\n-        let mut idx = 0;\n-        let mut it = TrieMapIterator {\n-            stack: ~[],\n-            remaining_min: 0,\n-            remaining_max: self.length\n-        };\n-        loop {\n-            let children = &node.children;\n-            let child_id = chunk(key, idx);\n-            match children[child_id] {\n-                Internal(ref n) => {\n-                    node = &**n;\n-                    it.stack.push(children.slice_from(child_id + 1).iter());\n-                }\n-                External(stored, _) => {\n-                    if stored < key || (upper && stored == key) {\n-                        it.stack.push(children.slice_from(child_id + 1).iter());\n-                    } else {\n-                        it.stack.push(children.slice_from(child_id).iter());\n-                    }\n-                    return it;\n-                }\n-                Nothing => {\n-                    it.stack.push(children.slice_from(child_id + 1).iter());\n-                    return it\n-                }\n-            }\n-            idx += 1;\n-        }\n+        bound!(TrieMapIterator, self = self,\n+               key = key, is_upper = upper,\n+               slice_from = slice_from, iter = iter,\n+               mutability = )\n     }\n \n     /// Get an iterator pointing to the first key-value pair whose key is not less than `key`.\n@@ -191,47 +246,10 @@ impl<T> TrieMap<T> {\n     // If `upper` is true then returns upper_bound else returns lower_bound.\n     #[inline]\n     fn mut_bound<'a>(&'a mut self, key: uint, upper: bool) -> TrieMapMutIterator<'a, T> {\n-        // we need an unsafe pointer here because we are borrowing\n-        // references to the internals of each of these\n-        // nodes.\n-        //\n-        // However, we're allowed to flaunt rustc like this because we\n-        // never actually modify the \"shape\" of the nodes. The only\n-        // place that mutation is can actually occur is of the actual\n-        // values of the TrieMap (as the return value of the\n-        // iterator), i.e. we can never cause a deallocation of any\n-        // TrieNodes so this pointer is always valid.\n-        let mut node = &mut self.root as *mut TrieNode<T>;\n-\n-        let mut idx = 0;\n-        let mut it = TrieMapMutIterator {\n-            stack: ~[],\n-            remaining_min: 0,\n-            remaining_max: self.length\n-        };\n-        loop {\n-            let children = unsafe {&mut (*node).children};\n-            let child_id = chunk(key, idx);\n-            match children[child_id] {\n-                Internal(ref mut n) => {\n-                    node = &mut **n as *mut TrieNode<T>;\n-                }\n-                External(stored, _) => {\n-                    if stored < key || (upper && stored == key) {\n-                        it.stack.push(children.mut_slice_from(child_id + 1).mut_iter());\n-                    } else {\n-                        it.stack.push(children.mut_slice_from(child_id).mut_iter());\n-                    }\n-                    return it;\n-                }\n-                Nothing => {\n-                    it.stack.push(children.mut_slice_from(child_id + 1).mut_iter());\n-                    return it\n-                }\n-            }\n-            it.stack.push(children.mut_slice_from(child_id + 1).mut_iter());\n-            idx += 1;\n-        }\n+        bound!(TrieMapMutIterator, self = self,\n+               key = key, is_upper = upper,\n+               slice_from = mut_slice_from, iter = mut_iter,\n+               mutability = mut)\n     }\n \n     /// Get an iterator pointing to the first key-value pair whose key is not less than `key`.\n@@ -464,39 +482,6 @@ pub struct TrieMapIterator<'a, T> {\n     priv remaining_max: uint\n }\n \n-impl<'a, T> Iterator<(uint, &'a T)> for TrieMapIterator<'a, T> {\n-    fn next(&mut self) -> Option<(uint, &'a T)> {\n-        while !self.stack.is_empty() {\n-            match self.stack[self.stack.len() - 1].next() {\n-                None => {\n-                    self.stack.pop();\n-                }\n-                Some(ref child) => {\n-                    match **child {\n-                        Internal(ref node) => {\n-                            self.stack.push(node.children.iter());\n-                        }\n-                        External(key, ref value) => {\n-                            self.remaining_max -= 1;\n-                            if self.remaining_min > 0 {\n-                                self.remaining_min -= 1;\n-                            }\n-                            return Some((key, value));\n-                        }\n-                        Nothing => {}\n-                    }\n-                }\n-            }\n-        }\n-        return None;\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.remaining_min, Some(self.remaining_max))\n-    }\n-}\n-\n /// Forward iterator over the key-value pairs of a map, with the\n /// values being mutable.\n pub struct TrieMapMutIterator<'a, T> {\n@@ -505,39 +490,51 @@ pub struct TrieMapMutIterator<'a, T> {\n     priv remaining_max: uint\n }\n \n-impl<'a, T> Iterator<(uint, &'a mut T)> for TrieMapMutIterator<'a, T> {\n-    fn next(&mut self) -> Option<(uint, &'a mut T)> {\n-        while !self.stack.is_empty() {\n-            match self.stack[self.stack.len() - 1].next() {\n-                None => {\n-                    self.stack.pop();\n-                }\n-                Some(child) => {\n-                    match *child {\n-                        Internal(ref mut node) => {\n-                            self.stack.push(node.children.mut_iter());\n-                        }\n-                        External(key, ref mut value) => {\n-                            self.remaining_max -= 1;\n-                            if self.remaining_min > 0 {\n-                                self.remaining_min -= 1;\n+// FIXME #5846: see `addr!` above.\n+macro_rules! item { ($i:item) => {$i}}\n+\n+macro_rules! iterator_impl {\n+    ($name:ident,\n+     iter = $iter:ident,\n+     mutability = $($mut_:tt)*) => {\n+        item!(impl<'a, T> Iterator<(uint, &'a $($mut_)* T)> for $name<'a, T> {\n+                fn next(&mut self) -> Option<(uint, &'a $($mut_)* T)> {\n+                    while !self.stack.is_empty() {\n+                        match self.stack[self.stack.len() - 1].next() {\n+                            None => {\n+                                self.stack.pop();\n+                            }\n+                            Some(child) => {\n+                                addr!(match *child {\n+                                        Internal(ref $($mut_)* node) => {\n+                                            self.stack.push(node.children.$iter());\n+                                        }\n+                                        External(key, ref $($mut_)* value) => {\n+                                            self.remaining_max -= 1;\n+                                            if self.remaining_min > 0 {\n+                                                self.remaining_min -= 1;\n+                                            }\n+                                            return Some((key, value));\n+                                        }\n+                                        Nothing => {}\n+                                    })\n                             }\n-                            return Some((key, value));\n                         }\n-                        Nothing => {}\n                     }\n+                    return None;\n                 }\n-            }\n-        }\n-        return None;\n-    }\n \n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.remaining_min, Some(self.remaining_max))\n+                #[inline]\n+                fn size_hint(&self) -> (uint, Option<uint>) {\n+                    (self.remaining_min, Some(self.remaining_max))\n+                }\n+            })\n     }\n }\n \n+iterator_impl! { TrieMapIterator, iter = iter, mutability = }\n+iterator_impl! { TrieMapMutIterator, iter = mut_iter, mutability = mut }\n+\n /// Forward iterator over a set\n pub struct TrieSetIterator<'a> {\n     priv iter: TrieMapIterator<'a, ()>"}]}