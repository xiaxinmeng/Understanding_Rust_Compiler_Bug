{"sha": "c2de80f05fe32bdb694c085b48a87727175e3691", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyZGU4MGYwNWZlMzJiZGI2OTRjMDg1YjQ4YTg3NzI3MTc1ZTM2OTE=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-04-16T05:38:18Z"}, "committer": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-04-28T01:18:51Z"}, "message": "Address comments\n\nMoves `stmt_expr` into its own module, `expr::stmt`.", "tree": {"sha": "d95e2401c343bc62e43ce8c92edd05a79e79eda1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d95e2401c343bc62e43ce8c92edd05a79e79eda1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2de80f05fe32bdb694c085b48a87727175e3691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2de80f05fe32bdb694c085b48a87727175e3691", "html_url": "https://github.com/rust-lang/rust/commit/c2de80f05fe32bdb694c085b48a87727175e3691", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2de80f05fe32bdb694c085b48a87727175e3691/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f242fe3c04621dca3aaa3ab288a3812b45633ffd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f242fe3c04621dca3aaa3ab288a3812b45633ffd", "html_url": "https://github.com/rust-lang/rust/commit/f242fe3c04621dca3aaa3ab288a3812b45633ffd"}], "stats": {"total": 305, "additions": 163, "deletions": 142}, "files": [{"sha": "49029f9642e087c1655e7b12b2083a4f6dde6bc2", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c2de80f05fe32bdb694c085b48a87727175e3691/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2de80f05fe32bdb694c085b48a87727175e3691/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=c2de80f05fe32bdb694c085b48a87727175e3691", "patch": "@@ -9,12 +9,9 @@\n // except according to those terms.\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n-use build::scope::LoopScope;\n use hair::*;\n-use rustc::middle::region::CodeExtent;\n use rustc::mir::repr::*;\n use rustc::hir;\n-use syntax::codemap::Span;\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn ast_block(&mut self,\n@@ -82,118 +79,4 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             block.unit()\n         })\n     }\n-\n-    pub fn stmt_expr(&mut self, mut block: BasicBlock, expr: Expr<'tcx>) -> BlockAnd<()> {\n-        let this = self;\n-        let expr_span = expr.span;\n-        let scope_id = this.innermost_scope_id();\n-        // Handle a number of expressions that don't need a destination at all. This\n-        // avoids needing a mountain of temporary `()` variables.\n-        match expr.kind {\n-            ExprKind::Scope { extent, value } => {\n-                let value = this.hir.mirror(value);\n-                this.in_scope(extent, block, |this, _| this.stmt_expr(block, value))\n-            }\n-            ExprKind::Assign { lhs, rhs } => {\n-                let lhs = this.hir.mirror(lhs);\n-                let scope_id = this.innermost_scope_id();\n-                let lhs_span = lhs.span;\n-                let lhs_ty = lhs.ty;\n-\n-                let lhs_needs_drop = this.hir.needs_drop(lhs_ty);\n-\n-                // Note: we evaluate assignments right-to-left. This\n-                // is better for borrowck interaction with overloaded\n-                // operators like x[j] = x[i].\n-\n-                // Generate better code for things that don't need to be\n-                // dropped. We need the temporary as_operand generates\n-                // so we can clean up the data if evaluating the LHS unwinds,\n-                // but if the LHS (and therefore the RHS) doesn't need\n-                // unwinding, we just translate directly to an rvalue instead.\n-                let rhs = if lhs_needs_drop {\n-                    let op = unpack!(block = this.as_operand(block, rhs));\n-                    Rvalue::Use(op)\n-                } else {\n-                    unpack!(block = this.as_rvalue(block, rhs))\n-                };\n-\n-                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n-                unpack!(block = this.build_drop(block, lhs_span, lhs.clone(), lhs_ty));\n-                this.cfg.push_assign(block, scope_id, expr_span, &lhs, rhs);\n-                block.unit()\n-            }\n-            ExprKind::AssignOp { op, lhs, rhs } => {\n-                // FIXME(#28160) there is an interesting semantics\n-                // question raised here -- should we \"freeze\" the\n-                // value of the lhs here?  I'm inclined to think not,\n-                // since it seems closer to the semantics of the\n-                // overloaded version, which takes `&mut self`.  This\n-                // only affects weird things like `x += {x += 1; x}`\n-                // -- is that equal to `x + (x + 1)` or `2*(x+1)`?\n-\n-                // As above, RTL.\n-                let rhs = unpack!(block = this.as_operand(block, rhs));\n-                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n-\n-                // we don't have to drop prior contents or anything\n-                // because AssignOp is only legal for Copy types\n-                // (overloaded ops should be desugared into a call).\n-                this.cfg.push_assign(block, scope_id, expr_span, &lhs,\n-                                     Rvalue::BinaryOp(op,\n-                                                      Operand::Consume(lhs.clone()),\n-                                                      rhs));\n-\n-                block.unit()\n-            }\n-            ExprKind::Continue { label } => {\n-                this.break_or_continue(expr_span, label, block,\n-                                       |loop_scope| loop_scope.continue_block)\n-            }\n-            ExprKind::Break { label } => {\n-                this.break_or_continue(expr_span, label, block, |loop_scope| {\n-                    loop_scope.might_break = true;\n-                    loop_scope.break_block\n-                })\n-            }\n-            ExprKind::Return { value } => {\n-                block = match value {\n-                    Some(value) => unpack!(this.into(&Lvalue::ReturnPointer, block, value)),\n-                    None => {\n-                        this.cfg.push_assign_unit(block, scope_id,\n-                                                  expr_span, &Lvalue::ReturnPointer);\n-                        block\n-                    }\n-                };\n-                let extent = this.extent_of_return_scope();\n-                let return_block = this.return_block();\n-                this.exit_scope(expr_span, extent, block, return_block);\n-                this.cfg.start_new_block().unit()\n-            }\n-            _ => {\n-                let expr_span = expr.span;\n-                let expr_ty = expr.ty;\n-                let temp = this.temp(expr.ty.clone());\n-                unpack!(block = this.into(&temp, block, expr));\n-                unpack!(block = this.build_drop(block, expr_span, temp, expr_ty));\n-                block.unit()\n-            }\n-        }\n-    }\n-\n-    fn break_or_continue<F>(&mut self,\n-                            span: Span,\n-                            label: Option<CodeExtent>,\n-                            block: BasicBlock,\n-                            exit_selector: F)\n-                            -> BlockAnd<()>\n-        where F: FnOnce(&mut LoopScope) -> BasicBlock\n-    {\n-        let (exit_block, extent) = {\n-            let loop_scope = self.find_loop_scope(span, label);\n-            (exit_selector(loop_scope), loop_scope.extent)\n-        };\n-        self.exit_scope(span, extent, block, exit_block);\n-        self.cfg.start_new_block().unit()\n-    }\n }"}, {"sha": "17b34f4586e8b6e0cdc65db49e54a359cbb4987f", "filename": "src/librustc_mir/build/expr/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2de80f05fe32bdb694c085b48a87727175e3691/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2de80f05fe32bdb694c085b48a87727175e3691/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs?ref=c2de80f05fe32bdb694c085b48a87727175e3691", "patch": "@@ -75,5 +75,6 @@ mod as_lvalue;\n mod as_rvalue;\n mod as_operand;\n mod as_temp;\n-pub mod category;\n+mod category;\n mod into;\n+mod stmt;"}, {"sha": "3c1672b919751172031677c10f67944d999a6514", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/c2de80f05fe32bdb694c085b48a87727175e3691/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2de80f05fe32bdb694c085b48a87727175e3691/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=c2de80f05fe32bdb694c085b48a87727175e3691", "patch": "@@ -0,0 +1,135 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::scope::LoopScope;\n+use hair::*;\n+use rustc::middle::region::CodeExtent;\n+use rustc::mir::repr::*;\n+use syntax::codemap::Span;\n+\n+impl<'a,'tcx> Builder<'a,'tcx> {\n+\n+    pub fn stmt_expr(&mut self, mut block: BasicBlock, expr: Expr<'tcx>) -> BlockAnd<()> {\n+        let this = self;\n+        let expr_span = expr.span;\n+        let scope_id = this.innermost_scope_id();\n+        // Handle a number of expressions that don't need a destination at all. This\n+        // avoids needing a mountain of temporary `()` variables.\n+        match expr.kind {\n+            ExprKind::Scope { extent, value } => {\n+                let value = this.hir.mirror(value);\n+                this.in_scope(extent, block, |this, _| this.stmt_expr(block, value))\n+            }\n+            ExprKind::Assign { lhs, rhs } => {\n+                let lhs = this.hir.mirror(lhs);\n+                let rhs = this.hir.mirror(rhs);\n+                let scope_id = this.innermost_scope_id();\n+                let lhs_span = lhs.span;\n+\n+                let lhs_ty = lhs.ty;\n+                let rhs_ty = rhs.ty;\n+\n+                let lhs_needs_drop = this.hir.needs_drop(lhs_ty);\n+                let rhs_needs_drop = this.hir.needs_drop(rhs_ty);\n+\n+                // Note: we evaluate assignments right-to-left. This\n+                // is better for borrowck interaction with overloaded\n+                // operators like x[j] = x[i].\n+\n+                // Generate better code for things that don't need to be\n+                // dropped.\n+                let rhs = if lhs_needs_drop || rhs_needs_drop {\n+                    let op = unpack!(block = this.as_operand(block, rhs));\n+                    Rvalue::Use(op)\n+                } else {\n+                    unpack!(block = this.as_rvalue(block, rhs))\n+                };\n+\n+                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n+                unpack!(block = this.build_drop(block, lhs_span, lhs.clone(), lhs_ty));\n+                this.cfg.push_assign(block, scope_id, expr_span, &lhs, rhs);\n+                block.unit()\n+            }\n+            ExprKind::AssignOp { op, lhs, rhs } => {\n+                // FIXME(#28160) there is an interesting semantics\n+                // question raised here -- should we \"freeze\" the\n+                // value of the lhs here?  I'm inclined to think not,\n+                // since it seems closer to the semantics of the\n+                // overloaded version, which takes `&mut self`.  This\n+                // only affects weird things like `x += {x += 1; x}`\n+                // -- is that equal to `x + (x + 1)` or `2*(x+1)`?\n+\n+                // As above, RTL.\n+                let rhs = unpack!(block = this.as_operand(block, rhs));\n+                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n+\n+                // we don't have to drop prior contents or anything\n+                // because AssignOp is only legal for Copy types\n+                // (overloaded ops should be desugared into a call).\n+                this.cfg.push_assign(block, scope_id, expr_span, &lhs,\n+                                     Rvalue::BinaryOp(op,\n+                                                      Operand::Consume(lhs.clone()),\n+                                                      rhs));\n+\n+                block.unit()\n+            }\n+            ExprKind::Continue { label } => {\n+                this.break_or_continue(expr_span, label, block,\n+                                       |loop_scope| loop_scope.continue_block)\n+            }\n+            ExprKind::Break { label } => {\n+                this.break_or_continue(expr_span, label, block, |loop_scope| {\n+                    loop_scope.might_break = true;\n+                    loop_scope.break_block\n+                })\n+            }\n+            ExprKind::Return { value } => {\n+                block = match value {\n+                    Some(value) => unpack!(this.into(&Lvalue::ReturnPointer, block, value)),\n+                    None => {\n+                        this.cfg.push_assign_unit(block, scope_id,\n+                                                  expr_span, &Lvalue::ReturnPointer);\n+                        block\n+                    }\n+                };\n+                let extent = this.extent_of_return_scope();\n+                let return_block = this.return_block();\n+                this.exit_scope(expr_span, extent, block, return_block);\n+                this.cfg.start_new_block().unit()\n+            }\n+            _ => {\n+                let expr_span = expr.span;\n+                let expr_ty = expr.ty;\n+                let temp = this.temp(expr.ty.clone());\n+                unpack!(block = this.into(&temp, block, expr));\n+                unpack!(block = this.build_drop(block, expr_span, temp, expr_ty));\n+                block.unit()\n+            }\n+        }\n+    }\n+\n+    fn break_or_continue<F>(&mut self,\n+                            span: Span,\n+                            label: Option<CodeExtent>,\n+                            block: BasicBlock,\n+                            exit_selector: F)\n+                            -> BlockAnd<()>\n+        where F: FnOnce(&mut LoopScope) -> BasicBlock\n+    {\n+        let (exit_block, extent) = {\n+            let loop_scope = self.find_loop_scope(span, label);\n+            (exit_selector(loop_scope), loop_scope.extent)\n+        };\n+        self.exit_scope(span, extent, block, exit_block);\n+        self.cfg.start_new_block().unit()\n+    }\n+\n+}"}, {"sha": "0b88ba554da678fa0d1aa79978fe46b926b3ea5a", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c2de80f05fe32bdb694c085b48a87727175e3691/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2de80f05fe32bdb694c085b48a87727175e3691/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=c2de80f05fe32bdb694c085b48a87727175e3691", "patch": "@@ -14,13 +14,13 @@\n use rustc_data_structures::bitvec::BitVector;\n use rustc::mir::repr as mir;\n use rustc::mir::visit::{Visitor, LvalueContext};\n-use common::{self, Block};\n+use common::{self, Block, BlockAndBuilder};\n use super::rvalue;\n \n pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n-                               mir: &mir::Mir<'tcx>)\n-                               -> BitVector {\n-    let mut analyzer = TempAnalyzer::new(mir, bcx, mir.temp_decls.len());\n+                               mir: &mir::Mir<'tcx>) -> BitVector {\n+    let bcx = bcx.build();\n+    let mut analyzer = TempAnalyzer::new(mir, &bcx, mir.temp_decls.len());\n \n     analyzer.visit_mir(mir);\n \n@@ -51,16 +51,16 @@ pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n     analyzer.lvalue_temps\n }\n \n-struct TempAnalyzer<'mir, 'bcx, 'tcx: 'mir + 'bcx> {\n+struct TempAnalyzer<'mir, 'bcx: 'mir, 'tcx: 'bcx> {\n     mir: &'mir mir::Mir<'tcx>,\n-    bcx: Block<'bcx, 'tcx>,\n+    bcx: &'mir BlockAndBuilder<'bcx, 'tcx>,\n     lvalue_temps: BitVector,\n     seen_assigned: BitVector\n }\n \n impl<'mir, 'bcx, 'tcx> TempAnalyzer<'mir, 'bcx, 'tcx> {\n     fn new(mir: &'mir mir::Mir<'tcx>,\n-           bcx: Block<'bcx, 'tcx>,\n+           bcx: &'mir BlockAndBuilder<'bcx, 'tcx>,\n            temp_count: usize) -> TempAnalyzer<'mir, 'bcx, 'tcx> {\n         TempAnalyzer {\n             mir: mir,"}, {"sha": "b7661ce039ca390d2f25d64d8444a3d63ec78e2a", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c2de80f05fe32bdb694c085b48a87727175e3691/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2de80f05fe32bdb694c085b48a87727175e3691/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=c2de80f05fe32bdb694c085b48a87727175e3691", "patch": "@@ -108,6 +108,16 @@ enum TempRef<'tcx> {\n     Operand(Option<OperandRef<'tcx>>),\n }\n \n+impl<'tcx> TempRef<'tcx> {\n+    fn new_operand(val: OperandValue, ty: ty::Ty<'tcx>) -> TempRef<'tcx> {\n+        let op = OperandRef {\n+            val: val,\n+            ty: ty\n+        };\n+        TempRef::Operand(Some(op))\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n \n pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n@@ -154,11 +164,8 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                                   // Zero-size temporaries aren't always initialized, which\n                                   // doesn't matter because they don't contain data, but\n                                   // we need something in the operand.\n-                                  let op = OperandRef {\n-                                      val: OperandValue::Immediate(common::C_nil(bcx.ccx())),\n-                                      ty: mty\n-                                  };\n-                                  TempRef::Operand(Some(op))\n+                                  let val = OperandValue::Immediate(common::C_nil(bcx.ccx()));\n+                                  TempRef::new_operand(val, mty)\n                               } else {\n                                   // If this is an immediate temp, we do not create an\n                                   // alloca in advance. Instead we wait until we see the"}, {"sha": "67d7f44cbbf41ab7764aeee42878a2c9fcdc9b8d", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c2de80f05fe32bdb694c085b48a87727175e3691/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2de80f05fe32bdb694c085b48a87727175e3691/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=c2de80f05fe32bdb694c085b48a87727175e3691", "patch": "@@ -18,7 +18,7 @@ use rustc::mir::repr as mir;\n use asm;\n use base;\n use callee::Callee;\n-use common::{self, C_uint, Block, BlockAndBuilder, Result};\n+use common::{self, C_uint, BlockAndBuilder, Result};\n use datum::{Datum, Lvalue};\n use debuginfo::DebugLoc;\n use declare;\n@@ -218,9 +218,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             _ => {\n-                bcx.with_block(|bcx| {\n-                    assert!(rvalue_creates_operand(&self.mir, bcx, rvalue));\n-                });\n+                assert!(rvalue_creates_operand(&self.mir, &bcx, rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue, debug_loc);\n                 self.store_operand(&bcx, dest.llval, temp);\n                 bcx\n@@ -234,10 +232,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 debug_loc: DebugLoc)\n                                 -> (BlockAndBuilder<'bcx, 'tcx>, OperandRef<'tcx>)\n     {\n-        bcx.with_block(|bcx| {\n-            assert!(rvalue_creates_operand(&self.mir, bcx, rvalue),\n-                    \"cannot trans {:?} to operand\", rvalue);\n-        });\n+        assert!(rvalue_creates_operand(&self.mir, &bcx, rvalue),\n+                \"cannot trans {:?} to operand\", rvalue);\n \n         match *rvalue {\n             mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n@@ -608,7 +604,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n }\n \n-pub fn rvalue_creates_operand<'bcx, 'tcx>(mir: &mir::Mir<'tcx>, bcx: Block<'bcx, 'tcx>,\n+pub fn rvalue_creates_operand<'bcx, 'tcx>(mir: &mir::Mir<'tcx>,\n+                                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                                           rvalue: &mir::Rvalue<'tcx>) -> bool {\n     match *rvalue {\n         mir::Rvalue::Ref(..) |"}, {"sha": "c9a4e540fa06b92948239af8c0bb3eef96351a99", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2de80f05fe32bdb694c085b48a87727175e3691/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2de80f05fe32bdb694c085b48a87727175e3691/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=c2de80f05fe32bdb694c085b48a87727175e3691", "patch": "@@ -52,9 +52,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 } else {\n                                     // If the type is zero-sized, it's already been set here,\n                                     // but we still need to make sure we translate the operand\n-                                    let (bcx, _) = self.trans_rvalue_operand(bcx, rvalue,\n-                                                                                   debug_loc);\n-                                    bcx\n+                                    self.trans_rvalue_operand(bcx, rvalue, debug_loc).0\n                                 }\n                             }\n                         }"}]}