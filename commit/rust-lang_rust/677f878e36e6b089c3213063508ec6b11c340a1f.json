{"sha": "677f878e36e6b089c3213063508ec6b11c340a1f", "node_id": "C_kwDOAAsO6NoAKDY3N2Y4NzhlMzZlNmIwODljMzIxMzA2MzUwOGVjNmIxMWMzNDBhMWY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-07T10:04:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-07T10:04:59Z"}, "message": "Rollup merge of #91341 - scottmcm:array-iter-frp, r=kennytm\n\nAdd `array::IntoIter::{empty, from_raw_parts}`\n\n`array::IntoIter` has a bunch of really handy logic for dealing with partial arrays, but it's currently hamstrung by only being creatable from a fully-initialized array.\n\nThis PR adds two new constructors:\n- a safe & const `empty`, since `[].into_iter()` can only give `IntoIter<T, 0>`, not `IntoIter<T, N>`.\n- an unsafe `from_raw_parts`, to allow experimentation with new uses.\n\n(Slice & vec iterators don't need `from_raw_parts` because you `from_raw_parts` the slice or vec instead, but there's no useful way to made a `<[T; N]>::from_raw_parts`, so I think this is a reasonable place to have one.)", "tree": {"sha": "f4ab272b0f52cc8402b95fd339df7c2dadb2a949", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4ab272b0f52cc8402b95fd339df7c2dadb2a949"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/677f878e36e6b089c3213063508ec6b11c340a1f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhrzHLCRBK7hj4Ov3rIwAAIXUIAE0QYkGooLuxwe1GhD/Ill3J\nHaN8j1WeI+FZA4fvDFP5yGoJLfalnJWFcv7huE7SCulzhoREElhSNy3tQ70Mh0df\nPHs2v04q4I3jTFj9oSFHwmpoayPLAb7e04RHZuhR/Z5kGm+WKHZGUBIHd4h60ZaI\nY586YENN4JOBBvdKMG9CbtLqG+zEYGET15eOuuHfK5pvht5NIh8I6yf6Wau2HlLI\naYP4wA7Eose4V8J75cKVyvdmy2jH+TgqaNFPlwQXj/OQpEpxqFVncoLaKNpbUZzE\n7Aezq8krb/3P6SiXWd6S+okG5ICuBVIAoGoYHPCMuaIj/hnK+JP7PpYvHVAkKNs=\n=0tuk\n-----END PGP SIGNATURE-----\n", "payload": "tree f4ab272b0f52cc8402b95fd339df7c2dadb2a949\nparent 57ae43d1f2f6053eebbf85313b418a8191d6e575\nparent 9b86c5998c5b5b274b21651334a320aecc516dfc\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1638871499 +0100\ncommitter GitHub <noreply@github.com> 1638871499 +0100\n\nRollup merge of #91341 - scottmcm:array-iter-frp, r=kennytm\n\nAdd `array::IntoIter::{empty, from_raw_parts}`\n\n`array::IntoIter` has a bunch of really handy logic for dealing with partial arrays, but it's currently hamstrung by only being creatable from a fully-initialized array.\n\nThis PR adds two new constructors:\n- a safe & const `empty`, since `[].into_iter()` can only give `IntoIter<T, 0>`, not `IntoIter<T, N>`.\n- an unsafe `from_raw_parts`, to allow experimentation with new uses.\n\n(Slice & vec iterators don't need `from_raw_parts` because you `from_raw_parts` the slice or vec instead, but there's no useful way to made a `<[T; N]>::from_raw_parts`, so I think this is a reasonable place to have one.)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/677f878e36e6b089c3213063508ec6b11c340a1f", "html_url": "https://github.com/rust-lang/rust/commit/677f878e36e6b089c3213063508ec6b11c340a1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/677f878e36e6b089c3213063508ec6b11c340a1f/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57ae43d1f2f6053eebbf85313b418a8191d6e575", "url": "https://api.github.com/repos/rust-lang/rust/commits/57ae43d1f2f6053eebbf85313b418a8191d6e575", "html_url": "https://github.com/rust-lang/rust/commit/57ae43d1f2f6053eebbf85313b418a8191d6e575"}, {"sha": "9b86c5998c5b5b274b21651334a320aecc516dfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b86c5998c5b5b274b21651334a320aecc516dfc", "html_url": "https://github.com/rust-lang/rust/commit/9b86c5998c5b5b274b21651334a320aecc516dfc"}], "stats": {"total": 131, "additions": 131, "deletions": 0}, "files": [{"sha": "0dc277785e8250255490c17da4bd146cc8ad3268", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/677f878e36e6b089c3213063508ec6b11c340a1f/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677f878e36e6b089c3213063508ec6b11c340a1f/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=677f878e36e6b089c3213063508ec6b11c340a1f", "patch": "@@ -84,6 +84,135 @@ impl<T, const N: usize> IntoIter<T, N> {\n         IntoIterator::into_iter(array)\n     }\n \n+    /// Creates an iterator over the elements in a partially-initialized buffer.\n+    ///\n+    /// If you have a fully-initialized array, then use [`IntoIterator`].\n+    /// But this is useful for returning partial results from unsafe code.\n+    ///\n+    /// # Safety\n+    ///\n+    /// - The `buffer[initialized]` elements must all be initialized.\n+    /// - The range must be canonical, with `initialized.start <= initialized.end`.\n+    /// - The range must in in-bounds for the buffer, with `initialized.end <= N`.\n+    ///   (Like how indexing `[0][100..100]` fails despite the range being empty.)\n+    ///\n+    /// It's sound to have more elements initialized than mentioned, though that\n+    /// will most likely result in them being leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(array_into_iter_constructors)]\n+    ///\n+    /// #![feature(maybe_uninit_array_assume_init)]\n+    /// #![feature(maybe_uninit_uninit_array)]\n+    /// use std::array::IntoIter;\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// # // Hi!  Thanks for reading the code.  This is restricted to `Copy` because\n+    /// # // otherwise it could leak.  A fully-general version this would need a drop\n+    /// # // guard to handle panics from the iterator, but this works for an example.\n+    /// fn next_chunk<T: Copy, const N: usize>(\n+    ///     it: &mut impl Iterator<Item = T>,\n+    /// ) -> Result<[T; N], IntoIter<T, N>> {\n+    ///     let mut buffer = MaybeUninit::uninit_array();\n+    ///     let mut i = 0;\n+    ///     while i < N {\n+    ///         match it.next() {\n+    ///             Some(x) => {\n+    ///                 buffer[i].write(x);\n+    ///                 i += 1;\n+    ///             }\n+    ///             None => {\n+    ///                 // SAFETY: We've initialized the first `i` items\n+    ///                 unsafe {\n+    ///                     return Err(IntoIter::new_unchecked(buffer, 0..i));\n+    ///                 }\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///\n+    ///     // SAFETY: We've initialized all N items\n+    ///     unsafe { Ok(MaybeUninit::array_assume_init(buffer)) }\n+    /// }\n+    ///\n+    /// let r: [_; 4] = next_chunk(&mut (10..16)).unwrap();\n+    /// assert_eq!(r, [10, 11, 12, 13]);\n+    /// let r: IntoIter<_, 40> = next_chunk(&mut (10..16)).unwrap_err();\n+    /// assert_eq!(r.collect::<Vec<_>>(), vec![10, 11, 12, 13, 14, 15]);\n+    /// ```\n+    #[unstable(feature = \"array_into_iter_constructors\", issue = \"91583\")]\n+    #[rustc_const_unstable(feature = \"const_array_into_iter_constructors\", issue = \"91583\")]\n+    pub const unsafe fn new_unchecked(\n+        buffer: [MaybeUninit<T>; N],\n+        initialized: Range<usize>,\n+    ) -> Self {\n+        Self { data: buffer, alive: initialized }\n+    }\n+\n+    /// Creates an iterator over `T` which returns no elements.\n+    ///\n+    /// If you just need an empty iterator, then use\n+    /// [`iter::empty()`](crate::iter::empty) instead.\n+    /// And if you need an empty array, use `[]`.\n+    ///\n+    /// But this is useful when you need an `array::IntoIter<T, N>` *specifically*.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(array_into_iter_constructors)]\n+    /// use std::array::IntoIter;\n+    ///\n+    /// let empty = IntoIter::<i32, 3>::empty();\n+    /// assert_eq!(empty.len(), 0);\n+    /// assert_eq!(empty.as_slice(), &[]);\n+    ///\n+    /// let empty = IntoIter::<std::convert::Infallible, 200>::empty();\n+    /// assert_eq!(empty.len(), 0);\n+    /// ```\n+    ///\n+    /// `[1, 2].into_iter()` and `[].into_iter()` have different types\n+    /// ```should_fail,edition2021\n+    /// #![feature(array_into_iter_constructors)]\n+    /// use std::array::IntoIter;\n+    ///\n+    /// pub fn get_bytes(b: bool) -> IntoIter<i8, 4> {\n+    ///     if b {\n+    ///         [1, 2, 3, 4].into_iter()\n+    ///     } else {\n+    ///         [].into_iter() // error[E0308]: mismatched types\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// But using this method you can get an empty iterator of appropriate size:\n+    /// ```edition2021\n+    /// #![feature(array_into_iter_constructors)]\n+    /// use std::array::IntoIter;\n+    ///\n+    /// pub fn get_bytes(b: bool) -> IntoIter<i8, 4> {\n+    ///     if b {\n+    ///         [1, 2, 3, 4].into_iter()\n+    ///     } else {\n+    ///         IntoIter::empty()\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(get_bytes(true).collect::<Vec<_>>(), vec![1, 2, 3, 4]);\n+    /// assert_eq!(get_bytes(false).collect::<Vec<_>>(), vec![]);\n+    /// ```\n+    #[unstable(feature = \"array_into_iter_constructors\", issue = \"91583\")]\n+    #[rustc_const_unstable(feature = \"const_array_into_iter_constructors\", issue = \"91583\")]\n+    pub const fn empty() -> Self {\n+        let buffer = MaybeUninit::uninit_array();\n+        let initialized = 0..0;\n+\n+        // SAFETY: We're telling it that none of the elements are initialized,\n+        // which is trivially true.  And \u2200N: usize, 0 <= N.\n+        unsafe { Self::new_unchecked(buffer, initialized) }\n+    }\n+\n     /// Returns an immutable slice of all elements that have not been yielded\n     /// yet.\n     #[stable(feature = \"array_value_iter\", since = \"1.51.0\")]"}, {"sha": "78383b54c5d1e410b7f02557a0fb6e5852a8869b", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/677f878e36e6b089c3213063508ec6b11c340a1f/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677f878e36e6b089c3213063508ec6b11c340a1f/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=677f878e36e6b089c3213063508ec6b11c340a1f", "patch": "@@ -101,6 +101,7 @@\n #![feature(const_align_of_val)]\n #![feature(const_alloc_layout)]\n #![feature(const_arguments_as_str)]\n+#![feature(const_array_into_iter_constructors)]\n #![feature(const_bigint_helper_methods)]\n #![feature(const_caller_location)]\n #![feature(const_cell_into_inner)]\n@@ -138,6 +139,7 @@\n #![feature(const_type_name)]\n #![feature(const_default_impls)]\n #![feature(duration_consts_float)]\n+#![feature(maybe_uninit_uninit_array)]\n #![feature(ptr_metadata)]\n #![feature(slice_ptr_get)]\n #![feature(str_internals)]"}]}