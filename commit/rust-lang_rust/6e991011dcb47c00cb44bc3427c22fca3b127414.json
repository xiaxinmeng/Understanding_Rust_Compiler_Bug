{"sha": "6e991011dcb47c00cb44bc3427c22fca3b127414", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlOTkxMDExZGNiNDdjMDBjYjQ0YmMzNDI3YzIyZmNhM2IxMjc0MTQ=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2019-02-19T17:13:41Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2019-02-20T03:59:13Z"}, "message": "Rollup merge of #58562 - dlrobertson:fix_nits, r=alexreg\n\nFix style nits\n\nFix style nits discovered in reading code.\n\nr? @alexreg", "tree": {"sha": "2b66c1210b96ac258261996f66693aa2c513d129", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b66c1210b96ac258261996f66693aa2c513d129"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e991011dcb47c00cb44bc3427c22fca3b127414", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlxs0JIACgkQ/vbIBR0O\nATyXHA//cO9dcJ4n3roSw69ouDL6IwExlMSIiymPnG6lgVI4x3A1hfeIIZBytPQ4\nHNRRK6OaugJlyrMaw9i8n7PX4ZK6at3PkPsO1TmdEjestcZQFZKvZo99wVTRXm5W\nIyBpni4P1D5jioLf9misqjmHDRVXfBX5sbyGtQIRfDuOWcT9kF3IrrP2xBiLKOh7\nyWsMLHEfGuFOcqqm1oBULAzzqZLaq/kB3YWyTiosue3CPZjl4cWEtnHANvCTZPp2\nBgO+sSi5oqaAF5+s7VdMhyazLe88BOTmiJ/7a2RqV0EHMqPNWEVcRexD+szfQVFz\nUP7D7lIrX+o54JX0UJcga/MuzbbzCv17gOwJR30sA5GifXJlXNVsCPAjEdHH97w8\naqKMMu5qRRJ36gcQEIzHyX199EdfZ3YrFQojppCngf2GonWqlxx+kiQeJNKejkpw\nX1Km9lsMCPCpwQ7DttoCHasb6q5Op6dwF1lbWezW8TXNGZMiMMw+1eT/p/keK8an\nug4tO6XpYCKb1vsg+d6o0sbaJsbBgv275PWdv186toStgpD3HvC3EHQyXw2IV+16\nGzX1V0OUqaT1wsJ8CFB5wSqfb2OsbZO0rJoJoz+uzCO58wXn21+mP590MZEgrFN0\ncY+c7HR20XkLyBaBWD1VDat8UuCbPm3r3JjzBR5/vxESeLWg4AA=\n=LniS\n-----END PGP SIGNATURE-----", "payload": "tree 2b66c1210b96ac258261996f66693aa2c513d129\nparent e3a8f7db479ce6562bfc312f412b65dc4f3c77d5\nparent f8b6449f80b75c8d42b1ebbe4c1fb6d4bfec7ace\nauthor kennytm <kennytm@gmail.com> 1550596421 +0800\ncommitter kennytm <kennytm@gmail.com> 1550635153 +0800\n\nRollup merge of #58562 - dlrobertson:fix_nits, r=alexreg\n\nFix style nits\n\nFix style nits discovered in reading code.\n\nr? @alexreg\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e991011dcb47c00cb44bc3427c22fca3b127414", "html_url": "https://github.com/rust-lang/rust/commit/6e991011dcb47c00cb44bc3427c22fca3b127414", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e991011dcb47c00cb44bc3427c22fca3b127414/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3a8f7db479ce6562bfc312f412b65dc4f3c77d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3a8f7db479ce6562bfc312f412b65dc4f3c77d5", "html_url": "https://github.com/rust-lang/rust/commit/e3a8f7db479ce6562bfc312f412b65dc4f3c77d5"}, {"sha": "f8b6449f80b75c8d42b1ebbe4c1fb6d4bfec7ace", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8b6449f80b75c8d42b1ebbe4c1fb6d4bfec7ace", "html_url": "https://github.com/rust-lang/rust/commit/f8b6449f80b75c8d42b1ebbe4c1fb6d4bfec7ace"}], "stats": {"total": 112, "additions": 64, "deletions": 48}, "files": [{"sha": "9eeae6eeb5f34819f73d44f8c79b0771ab296632", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -150,9 +150,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn pats_all<'b, I: Iterator<Item=&'b P<hir::Pat>>>(&mut self,\n-                                          pats: I,\n-                                          pred: CFGIndex) -> CFGIndex {\n+    fn pats_all<'b, I: Iterator<Item=&'b P<hir::Pat>>>(\n+        &mut self,\n+        pats: I,\n+        pred: CFGIndex\n+    ) -> CFGIndex {\n         //! Handles case where all of the patterns must match.\n         pats.fold(pred, |pred, pat| self.pat(&pat, pred))\n     }"}, {"sha": "d0b92587b59f007845f9a7963460ac1f5add199f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -964,14 +964,19 @@ pub enum PatKind {\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n     /// `0 <= position <= subpats.len()`\n     Tuple(HirVec<P<Pat>>, Option<usize>),\n+\n     /// A `box` pattern.\n     Box(P<Pat>),\n+\n     /// A reference pattern (e.g., `&mut (a, b)`).\n     Ref(P<Pat>, Mutability),\n+\n     /// A literal.\n     Lit(P<Expr>),\n+\n     /// A range pattern (e.g., `1...2` or `1..2`).\n     Range(P<Expr>, P<Expr>, RangeEnd),\n+\n     /// `[a, b, ..i, y, z]` is represented as:\n     ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`.\n     Slice(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),"}, {"sha": "f65c09e31343cf12c67c5635763cf90472481f5c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -1311,12 +1311,12 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                     Def::Err => {\n                         debug!(\"access to unresolvable pattern {:?}\", pat);\n                         return Err(())\n-                    },\n+                    }\n                     Def::Variant(variant_did) |\n                     Def::VariantCtor(variant_did, ..) => {\n                         self.cat_downcast_if_needed(pat, cmt, variant_did)\n-                    },\n-                    _ => cmt\n+                    }\n+                    _ => cmt,\n                 };\n \n                 for fp in field_pats {\n@@ -1347,7 +1347,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-                PatKind::Box(ref subpat) | PatKind::Ref(ref subpat, _) => {\n+            PatKind::Box(ref subpat) | PatKind::Ref(ref subpat, _) => {\n                 // box p1, &p1, &mut p1.  we can ignore the mutability of\n                 // PatKind::Ref since that information is already contained\n                 // in the type."}, {"sha": "350bc450263226b96d20c35b1ff71f994ec951da", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -1167,13 +1167,13 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/hrtb.html\n #[derive(Clone, PartialEq, Eq, Hash, Copy, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n pub enum RegionKind {\n-    // Region bound in a type or fn declaration which will be\n-    // substituted 'early' -- that is, at the same time when type\n-    // parameters are substituted.\n+    /// Region bound in a type or fn declaration which will be\n+    /// substituted 'early' -- that is, at the same time when type\n+    /// parameters are substituted.\n     ReEarlyBound(EarlyBoundRegion),\n \n-    // Region bound in a function scope, which will be substituted when the\n-    // function is called.\n+    /// Region bound in a function scope, which will be substituted when the\n+    /// function is called.\n     ReLateBound(DebruijnIndex, BoundRegion),\n \n     /// When checking a function body, the types of all arguments and so forth"}, {"sha": "3785e19af970f32a0d064fa3fd30cf5b12100a59", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -192,8 +192,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             \"size_of_val\" => {\n                 let tp_ty = substs.type_at(0);\n                 if let OperandValue::Pair(_, meta) = args[0].val {\n-                    let (llsize, _) =\n-                        glue::size_and_align_of_dst(self, tp_ty, Some(meta));\n+                    let (llsize, _) = glue::size_and_align_of_dst(self, tp_ty, Some(meta));\n                     llsize\n                 } else {\n                     self.const_usize(self.size_of(tp_ty).bytes())\n@@ -206,8 +205,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             \"min_align_of_val\" => {\n                 let tp_ty = substs.type_at(0);\n                 if let OperandValue::Pair(_, meta) = args[0].val {\n-                    let (_, llalign) =\n-                        glue::size_and_align_of_dst(self, tp_ty, Some(meta));\n+                    let (_, llalign) = glue::size_and_align_of_dst(self, tp_ty, Some(meta));\n                     llalign\n                 } else {\n                     self.const_usize(self.align_of(tp_ty).bytes())"}, {"sha": "ca61987e12f7a076c82a4fbf68e9bf53a7c5d34d", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -82,7 +82,6 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n     fn type_i16(&self) -> &'ll Type {\n         unsafe {\n-\n             llvm::LLVMInt16TypeInContext(self.llcx)\n         }\n     }"}, {"sha": "96d2c90345933d7487bb101f5e95286dec6fdd35", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -338,6 +338,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n             }\n+\n             _ => {\n                 let place = unpack!(block = self.as_place(block, initializer));\n                 self.place_into_pattern(block, irrefutable_pat, &place, true)\n@@ -534,6 +535,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     self.visit_bindings(subpattern, pattern_user_ty, f);\n                 }\n             }\n+\n             PatternKind::Array {\n                 ref prefix,\n                 ref slice,\n@@ -556,10 +558,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     self.visit_bindings(subpattern, pattern_user_ty.clone().index(), f);\n                 }\n             }\n+\n             PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {}\n+\n             PatternKind::Deref { ref subpattern } => {\n                 self.visit_bindings(subpattern, pattern_user_ty.deref(), f);\n             }\n+\n             PatternKind::AscribeUserType {\n                 ref subpattern,\n                 ascription: hair::pattern::Ascription {"}, {"sha": "01f8cbfbe8e2b2a4d727647966bf8ed412ed73ba", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -45,10 +45,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Tries to simplify `match_pair`, returning true if\n+    /// Tries to simplify `match_pair`, returning `Ok(())` if\n     /// successful. If successful, new match pairs and bindings will\n     /// have been pushed into the candidate. If no simplification is\n-    /// possible, Err is returned and no changes are made to\n+    /// possible, `Err` is returned and no changes are made to\n     /// candidate.\n     fn simplify_match_pair<'pat>(&mut self,\n                                  match_pair: MatchPair<'pat, 'tcx>,\n@@ -174,7 +174,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 } else {\n                     Err(match_pair)\n                 }\n-            },\n+            }\n \n             PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n                 self.prefix_slice_suffix(&mut candidate.match_pairs,"}, {"sha": "a41d3895d6d3cfcace3d167745f430ca6461f159", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -35,10 +35,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Constant { .. }\n-            if is_switch_ty(match_pair.pattern.ty) => {\n-                // for integers, we use a SwitchInt match, which allows\n-                // us to handle more cases\n+            PatternKind::Constant { .. } if is_switch_ty(match_pair.pattern.ty) => {\n+                // For integers, we use a `SwitchInt` match, which allows\n+                // us to handle more cases.\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::SwitchInt {\n@@ -253,12 +252,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             TestKind::Eq { value, mut ty } => {\n                 let val = Operand::Copy(place.clone());\n                 let mut expect = self.literal_operand(test.span, ty, value);\n-                // Use PartialEq::eq instead of BinOp::Eq\n+                // Use `PartialEq::eq` instead of `BinOp::Eq`\n                 // (the binop can only handle primitives)\n                 let fail = self.cfg.start_new_block();\n                 if !ty.is_scalar() {\n-                    // If we're using b\"...\" as a pattern, we need to insert an\n-                    // unsizing coercion, as the byte string has the type &[u8; N].\n+                    // If we're using `b\"...\"` as a pattern, we need to insert an\n+                    // unsizing coercion, as the byte string has the type `&[u8; N]`.\n                     //\n                     // We want to do this even when the scrutinee is a reference to an\n                     // array, so we can call `<[u8]>::eq` rather than having to find an\n@@ -503,6 +502,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 resulting_candidates[variant_index.as_usize()].push(new_candidate);\n                 true\n             }\n+\n             (&TestKind::Switch { .. }, _) => false,\n \n             // If we are performing a switch over integers, then this informs integer\n@@ -539,7 +539,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             (&TestKind::SwitchInt { .. }, _) => false,\n \n-\n             (&TestKind::Len { len: test_len, op: BinOp::Eq },\n              &PatternKind::Slice { ref prefix, ref slice, ref suffix }) => {\n                 let pat_len = (prefix.len() + suffix.len()) as u64;"}, {"sha": "b583b184a4103146286e5d81a7e53d5cf9d55a5f", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -13,7 +13,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         subpatterns.iter()\n                    .map(|fieldpat| {\n                        let place = place.clone().field(fieldpat.field,\n-                                                         fieldpat.pattern.ty);\n+                                                       fieldpat.pattern.ty);\n                        MatchPair::new(place, &fieldpat.pattern)\n                    })\n                    .collect()"}, {"sha": "6910fb7e988bb268ddf27f964bc94d352bff948c", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -634,8 +634,8 @@ impl<'tcx> Witness<'tcx> {\n /// but is instead bounded by the maximum fixed length of slice patterns in\n /// the column of patterns being analyzed.\n ///\n-/// We make sure to omit constructors that are statically impossible. eg for\n-/// Option<!> we do not include Some(_) in the returned list of constructors.\n+/// We make sure to omit constructors that are statically impossible. E.g., for\n+/// `Option<!>`, we do not include `Some(_)` in the returned list of constructors.\n fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                   pcx: PatternContext<'tcx>)\n                                   -> Vec<Constructor<'tcx>>\n@@ -1347,7 +1347,7 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n /// This computes the arity of a constructor. The arity of a constructor\n /// is how many subpattern patterns of that constructor should be expanded to.\n ///\n-/// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n+/// For instance, a tuple pattern `(_, 42, Some([]))` has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n fn constructor_arity(cx: &MatchCheckCtxt<'a, 'tcx>, ctor: &Constructor<'tcx>, ty: Ty<'tcx>) -> u64 {\n     debug!(\"constructor_arity({:#?}, {:?})\", ctor, ty);\n@@ -1357,7 +1357,7 @@ fn constructor_arity(cx: &MatchCheckCtxt<'a, 'tcx>, ctor: &Constructor<'tcx>, ty\n             Slice(length) => length,\n             ConstantValue(_) => 0,\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n-        },\n+        }\n         ty::Ref(..) => 1,\n         ty::Adt(adt, _) => {\n             adt.variants[ctor.variant_index_for_adt(cx, adt)].fields.len() as u64\n@@ -1381,7 +1381,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n             Slice(length) => (0..length).map(|_| ty).collect(),\n             ConstantValue(_) => vec![],\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n-        },\n+        }\n         ty::Ref(_, rty, _) => vec![rty],\n         ty::Adt(adt, substs) => {\n             if adt.is_box() {"}, {"sha": "7c44d1bf2c9369d2dd5cca0df6d4bd19de32bead", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -375,7 +375,7 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                 },\n                                 _ => bug!(),\n                             }\n-                        },\n+                        }\n \n                         hir::MatchSource::ForLoopDesugar |\n                         hir::MatchSource::Normal => {\n@@ -391,7 +391,7 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                 err.span_label(catchall, \"matches any value\");\n                             }\n                             err.emit();\n-                        },\n+                        }\n \n                         // Unreachable patterns in try expressions occur when one of the arms\n                         // are an uninhabited type. Which is OK.\n@@ -436,7 +436,7 @@ fn check_exhaustive<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                     let (tail, head) = witnesses.split_last().unwrap();\n                     let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n                     format!(\"`{}` and `{}`\", head.join(\"`, `\"), tail)\n-                },\n+                }\n                 _ => {\n                     let (head, tail) = witnesses.split_at(LIMIT);\n                     let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n@@ -446,7 +446,7 @@ fn check_exhaustive<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n             let label_text = match witnesses.len() {\n                 1 => format!(\"pattern {} not covered\", joined_patterns),\n-                _ => format!(\"patterns {} not covered\", joined_patterns)\n+                _ => format!(\"patterns {} not covered\", joined_patterns),\n             };\n             create_e0004(cx.tcx.sess, sp,\n                             format!(\"non-exhaustive patterns: {} not covered\",\n@@ -456,7 +456,7 @@ fn check_exhaustive<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         }\n         NotUseful => {\n             // This is good, wildcard pattern isn't reachable\n-        },\n+        }\n         _ => bug!()\n     }\n }"}, {"sha": "4d571f4f78296124d665a00d3818c5244e38d0c2", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -965,7 +965,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 PatternKind::Constant {\n                     value: cv,\n                 }\n-            },\n+            }\n             ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n@@ -978,7 +978,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                     self.tcx.item_path_str(adt_def.did));\n                 self.tcx.sess.span_err(span, &msg);\n                 PatternKind::Wild\n-            },\n+            }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n                 let variant_index = const_variant_index(\n                     self.tcx, self.param_env, cv\n@@ -993,7 +993,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     variant_index,\n                     subpatterns,\n                 }\n-            },\n+            }\n             ty::Adt(adt_def, _) => {\n                 let struct_var = adt_def.non_enum_variant();\n                 PatternKind::Leaf {\n@@ -1018,7 +1018,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 PatternKind::Constant {\n                     value: cv,\n                 }\n-            },\n+            }\n         };\n \n         Pattern {\n@@ -1252,19 +1252,19 @@ pub fn compare_const_vals<'a, 'gcx, 'tcx>(\n                 let l = ::rustc_apfloat::ieee::Single::from_bits(a);\n                 let r = ::rustc_apfloat::ieee::Single::from_bits(b);\n                 l.partial_cmp(&r)\n-            },\n+            }\n             ty::Float(ast::FloatTy::F64) => {\n                 let l = ::rustc_apfloat::ieee::Double::from_bits(a);\n                 let r = ::rustc_apfloat::ieee::Double::from_bits(b);\n                 l.partial_cmp(&r)\n-            },\n+            }\n             ty::Int(_) => {\n                 let layout = tcx.layout_of(ty).ok()?;\n                 assert!(layout.abi.is_signed());\n                 let a = sign_extend(a, layout.size);\n                 let b = sign_extend(b, layout.size);\n                 Some((a as i128).cmp(&(b as i128)))\n-            },\n+            }\n             _ => Some(a.cmp(&b)),\n         }\n     }"}, {"sha": "9c4945d74dbfef9e82e07bffd3d04441f413d151", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -640,19 +640,26 @@ pub enum PatKind {\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n     /// `0 <= position <= subpats.len()`.\n     Tuple(Vec<P<Pat>>, Option<usize>),\n+\n     /// A `box` pattern.\n     Box(P<Pat>),\n+\n     /// A reference pattern (e.g., `&mut (a, b)`).\n     Ref(P<Pat>, Mutability),\n+\n     /// A literal.\n     Lit(P<Expr>),\n+\n     /// A range pattern (e.g., `1...2`, `1..=2` or `1..2`).\n     Range(P<Expr>, P<Expr>, Spanned<RangeEnd>),\n+\n     /// `[a, b, ..i, y, z]` is represented as:\n     ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`\n     Slice(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n+\n     /// Parentheses in patterns used for grouping (i.e., `(PAT)`).\n     Paren(P<Pat>),\n+\n     /// A macro pattern; pre-expansion.\n     Mac(Mac),\n }"}, {"sha": "fd7003d30a1dc5c0613936305ba5e5282733bd41", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -1037,7 +1037,7 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n             vis.visit_expr(e1);\n             vis.visit_expr(e2);\n             vis.visit_span(span);\n-        },\n+        }\n         PatKind::Slice(before, slice, after) => {\n             visit_vec(before, |pat| vis.visit_pat(pat));\n             visit_opt(slice, |slice| vis.visit_pat(slice));"}, {"sha": "b1fb38d8eafb4e4404dd4f32ab8706444b10694f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e991011dcb47c00cb44bc3427c22fca3b127414/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6e991011dcb47c00cb44bc3427c22fca3b127414", "patch": "@@ -4173,7 +4173,8 @@ impl<'a> Parser<'a> {\n                 err.emit();\n                 self.bump();\n             } else if self.eat(&token::BinOp(token::Or)) {\n-                // No op.\n+                // This is a No-op. Continue the loop to parse the next\n+                // pattern.\n             } else {\n                 return Ok(pats);\n             }"}]}