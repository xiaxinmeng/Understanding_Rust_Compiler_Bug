{"sha": "589dabda2f212d8ae231ed6aab2bbf851eaed90c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4OWRhYmRhMmYyMTJkOGFlMjMxZWQ2YWFiMmJiZjg1MWVhZWQ5MGM=", "commit": {"author": {"name": "Kamal Marhubi", "email": "kamal@marhubi.com", "date": "2016-03-01T22:27:19Z"}, "committer": {"name": "Kamal Marhubi", "email": "kamal@marhubi.com", "date": "2016-03-02T18:08:21Z"}, "message": "deps: Update syntex_syntax to 0.29.1", "tree": {"sha": "9bba27bfeec92902b66e2419bf682c61e9c296f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bba27bfeec92902b66e2419bf682c61e9c296f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/589dabda2f212d8ae231ed6aab2bbf851eaed90c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/589dabda2f212d8ae231ed6aab2bbf851eaed90c", "html_url": "https://github.com/rust-lang/rust/commit/589dabda2f212d8ae231ed6aab2bbf851eaed90c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/589dabda2f212d8ae231ed6aab2bbf851eaed90c/comments", "author": {"login": "kamalmarhubi", "id": 50936, "node_id": "MDQ6VXNlcjUwOTM2", "avatar_url": "https://avatars.githubusercontent.com/u/50936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kamalmarhubi", "html_url": "https://github.com/kamalmarhubi", "followers_url": "https://api.github.com/users/kamalmarhubi/followers", "following_url": "https://api.github.com/users/kamalmarhubi/following{/other_user}", "gists_url": "https://api.github.com/users/kamalmarhubi/gists{/gist_id}", "starred_url": "https://api.github.com/users/kamalmarhubi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kamalmarhubi/subscriptions", "organizations_url": "https://api.github.com/users/kamalmarhubi/orgs", "repos_url": "https://api.github.com/users/kamalmarhubi/repos", "events_url": "https://api.github.com/users/kamalmarhubi/events{/privacy}", "received_events_url": "https://api.github.com/users/kamalmarhubi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kamalmarhubi", "id": 50936, "node_id": "MDQ6VXNlcjUwOTM2", "avatar_url": "https://avatars.githubusercontent.com/u/50936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kamalmarhubi", "html_url": "https://github.com/kamalmarhubi", "followers_url": "https://api.github.com/users/kamalmarhubi/followers", "following_url": "https://api.github.com/users/kamalmarhubi/following{/other_user}", "gists_url": "https://api.github.com/users/kamalmarhubi/gists{/gist_id}", "starred_url": "https://api.github.com/users/kamalmarhubi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kamalmarhubi/subscriptions", "organizations_url": "https://api.github.com/users/kamalmarhubi/orgs", "repos_url": "https://api.github.com/users/kamalmarhubi/repos", "events_url": "https://api.github.com/users/kamalmarhubi/events{/privacy}", "received_events_url": "https://api.github.com/users/kamalmarhubi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "684596fcddc0ffab45ba8ad0d3d8335af1ff1d2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/684596fcddc0ffab45ba8ad0d3d8335af1ff1d2f", "html_url": "https://github.com/rust-lang/rust/commit/684596fcddc0ffab45ba8ad0d3d8335af1ff1d2f"}], "stats": {"total": 443, "additions": 230, "deletions": 213}, "files": [{"sha": "9ebeff7bb254926035df7968283cc353349f1387", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/589dabda2f212d8ae231ed6aab2bbf851eaed90c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/589dabda2f212d8ae231ed6aab2bbf851eaed90c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=589dabda2f212d8ae231ed6aab2bbf851eaed90c", "patch": "@@ -9,7 +9,7 @@ dependencies = [\n  \"regex 0.1.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strings 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syntex_syntax 0.23.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_syntax 0.29.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -108,7 +108,7 @@ dependencies = [\n \n [[package]]\n name = \"syntex_syntax\"\n-version = \"0.23.0\"\n+version = \"0.29.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "49bd30a73cabf896c6a221f2ac78883eef5cb9c9", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589dabda2f212d8ae231ed6aab2bbf851eaed90c/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/589dabda2f212d8ae231ed6aab2bbf851eaed90c/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=589dabda2f212d8ae231ed6aab2bbf851eaed90c", "patch": "@@ -21,7 +21,7 @@ regex = \"0.1.41\"\n term = \"0.2.11\"\n strings = \"0.0.1\"\n diff = \"0.1.8\"\n-syntex_syntax = \"0.23.0\"\n+syntex_syntax = \"0.29.1\"\n log = \"0.3.2\"\n env_logger = \"0.3.1\"\n getopts = \"0.2\""}, {"sha": "191b4a2ea4ca118b98abfe47adb0711e2b9c71db", "filename": "src/chains.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=589dabda2f212d8ae231ed6aab2bbf851eaed90c", "patch": "@@ -94,7 +94,7 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n \n     let fits_single_line = !veto_single_line &&\n                            match subexpr_list[0].node {\n-        ast::Expr_::ExprMethodCall(ref method_name, ref types, ref expressions)\n+        ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions)\n             if context.config.chains_overflow_last => {\n             let len = rewrites.len();\n             let (init, last) = rewrites.split_at_mut(len - 1);\n@@ -150,28 +150,28 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n // parens, braces and brackets in its idiomatic formatting.\n fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n     match expr.node {\n-        ast::Expr_::ExprStruct(..) |\n-        ast::Expr_::ExprWhile(..) |\n-        ast::Expr_::ExprWhileLet(..) |\n-        ast::Expr_::ExprIf(..) |\n-        ast::Expr_::ExprIfLet(..) |\n-        ast::Expr_::ExprBlock(..) |\n-        ast::Expr_::ExprLoop(..) |\n-        ast::Expr_::ExprForLoop(..) |\n-        ast::Expr_::ExprMatch(..) => repr.contains('\\n'),\n-        ast::Expr_::ExprParen(ref expr) |\n-        ast::Expr_::ExprBinary(_, _, ref expr) |\n-        ast::Expr_::ExprIndex(_, ref expr) |\n-        ast::Expr_::ExprUnary(_, ref expr) => is_block_expr(expr, repr),\n+        ast::ExprKind::Struct(..) |\n+        ast::ExprKind::While(..) |\n+        ast::ExprKind::WhileLet(..) |\n+        ast::ExprKind::If(..) |\n+        ast::ExprKind::IfLet(..) |\n+        ast::ExprKind::Block(..) |\n+        ast::ExprKind::Loop(..) |\n+        ast::ExprKind::ForLoop(..) |\n+        ast::ExprKind::Match(..) => repr.contains('\\n'),\n+        ast::ExprKind::Paren(ref expr) |\n+        ast::ExprKind::Binary(_, _, ref expr) |\n+        ast::ExprKind::Index(_, ref expr) |\n+        ast::ExprKind::Unary(_, ref expr) => is_block_expr(expr, repr),\n         _ => false,\n     }\n }\n \n fn pop_expr_chain(expr: &ast::Expr) -> Option<&ast::Expr> {\n     match expr.node {\n-        ast::Expr_::ExprMethodCall(_, _, ref expressions) => Some(&expressions[0]),\n-        ast::Expr_::ExprTupField(ref subexpr, _) |\n-        ast::Expr_::ExprField(ref subexpr, _) => Some(subexpr),\n+        ast::ExprKind::MethodCall(_, _, ref expressions) => Some(&expressions[0]),\n+        ast::ExprKind::TupField(ref subexpr, _) |\n+        ast::ExprKind::Field(ref subexpr, _) => Some(subexpr),\n         _ => None,\n     }\n }\n@@ -183,7 +183,7 @@ fn rewrite_chain_expr(expr: &ast::Expr,\n                       offset: Indent)\n                       -> Option<String> {\n     match expr.node {\n-        ast::Expr_::ExprMethodCall(ref method_name, ref types, ref expressions) => {\n+        ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions) => {\n             let inner = &RewriteContext { block_indent: offset, ..*context };\n             rewrite_method_call(method_name.node,\n                                 types,\n@@ -193,15 +193,15 @@ fn rewrite_chain_expr(expr: &ast::Expr,\n                                 width,\n                                 offset)\n         }\n-        ast::Expr_::ExprField(_, ref field) => {\n+        ast::ExprKind::Field(_, ref field) => {\n             let s = format!(\".{}\", field.node);\n             if s.len() <= width {\n                 Some(s)\n             } else {\n                 None\n             }\n         }\n-        ast::Expr_::ExprTupField(_, ref field) => {\n+        ast::ExprKind::TupField(_, ref field) => {\n             let s = format!(\".{}\", field.node);\n             if s.len() <= width {\n                 Some(s)\n@@ -216,7 +216,7 @@ fn rewrite_chain_expr(expr: &ast::Expr,\n // Determines we can continue formatting a given expression on the same line.\n fn is_continuable(expr: &ast::Expr) -> bool {\n     match expr.node {\n-        ast::Expr_::ExprPath(..) => true,\n+        ast::ExprKind::Path(..) => true,\n         _ => false,\n     }\n }"}, {"sha": "6409ab8fdac47ab36ebde4fc44c3ee9aec857b02", "filename": "src/expr.rs", "status": "modified", "additions": 72, "deletions": 73, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=589dabda2f212d8ae231ed6aab2bbf851eaed90c", "patch": "@@ -37,16 +37,16 @@ use syntax::visit::Visitor;\n impl Rewrite for ast::Expr {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let result = match self.node {\n-            ast::Expr_::ExprVec(ref expr_vec) => {\n+            ast::ExprKind::Vec(ref expr_vec) => {\n                 rewrite_array(expr_vec.iter().map(|e| &**e),\n                               mk_sp(span_after(self.span, \"[\", context.codemap), self.span.hi),\n                               context,\n                               width,\n                               offset)\n             }\n-            ast::Expr_::ExprLit(ref l) => {\n+            ast::ExprKind::Lit(ref l) => {\n                 match l.node {\n-                    ast::Lit_::LitStr(_, ast::StrStyle::CookedStr) => {\n+                    ast::LitKind::Str(_, ast::StrStyle::Cooked) => {\n                         rewrite_string_lit(context, l.span, width, offset)\n                     }\n                     _ => {\n@@ -57,18 +57,18 @@ impl Rewrite for ast::Expr {\n                     }\n                 }\n             }\n-            ast::Expr_::ExprCall(ref callee, ref args) => {\n+            ast::ExprKind::Call(ref callee, ref args) => {\n                 let inner_span = mk_sp(callee.span.hi, self.span.hi);\n                 rewrite_call(context, &**callee, args, inner_span, width, offset)\n             }\n-            ast::Expr_::ExprParen(ref subexpr) => rewrite_paren(context, subexpr, width, offset),\n-            ast::Expr_::ExprBinary(ref op, ref lhs, ref rhs) => {\n+            ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, width, offset),\n+            ast::ExprKind::Binary(ref op, ref lhs, ref rhs) => {\n                 rewrite_binary_op(context, op, lhs, rhs, width, offset)\n             }\n-            ast::Expr_::ExprUnary(ref op, ref subexpr) => {\n+            ast::ExprKind::Unary(ref op, ref subexpr) => {\n                 rewrite_unary_op(context, op, subexpr, width, offset)\n             }\n-            ast::Expr_::ExprStruct(ref path, ref fields, ref base) => {\n+            ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 rewrite_struct_lit(context,\n                                    path,\n                                    fields,\n@@ -77,27 +77,27 @@ impl Rewrite for ast::Expr {\n                                    width,\n                                    offset)\n             }\n-            ast::Expr_::ExprTup(ref items) => {\n+            ast::ExprKind::Tup(ref items) => {\n                 rewrite_tuple(context,\n                               items.iter().map(|x| &**x),\n                               self.span,\n                               width,\n                               offset)\n             }\n-            ast::Expr_::ExprWhile(ref cond, ref block, label) => {\n+            ast::ExprKind::While(ref cond, ref block, label) => {\n                 Loop::new_while(None, cond, block, label).rewrite(context, width, offset)\n             }\n-            ast::Expr_::ExprWhileLet(ref pat, ref cond, ref block, label) => {\n+            ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => {\n                 Loop::new_while(Some(pat), cond, block, label).rewrite(context, width, offset)\n             }\n-            ast::Expr_::ExprForLoop(ref pat, ref cond, ref block, label) => {\n+            ast::ExprKind::ForLoop(ref pat, ref cond, ref block, label) => {\n                 Loop::new_for(pat, cond, block, label).rewrite(context, width, offset)\n             }\n-            ast::Expr_::ExprLoop(ref block, label) => {\n+            ast::ExprKind::Loop(ref block, label) => {\n                 Loop::new_loop(block, label).rewrite(context, width, offset)\n             }\n-            ast::Expr_::ExprBlock(ref block) => block.rewrite(context, width, offset),\n-            ast::Expr_::ExprIf(ref cond, ref if_block, ref else_block) => {\n+            ast::ExprKind::Block(ref block) => block.rewrite(context, width, offset),\n+            ast::ExprKind::If(ref cond, ref if_block, ref else_block) => {\n                 rewrite_if_else(context,\n                                 cond,\n                                 if_block,\n@@ -108,7 +108,7 @@ impl Rewrite for ast::Expr {\n                                 offset,\n                                 true)\n             }\n-            ast::Expr_::ExprIfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n+            ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n                 rewrite_if_else(context,\n                                 cond,\n                                 if_block,\n@@ -119,39 +119,39 @@ impl Rewrite for ast::Expr {\n                                 offset,\n                                 true)\n             }\n-            ast::Expr_::ExprMatch(ref cond, ref arms) => {\n+            ast::ExprKind::Match(ref cond, ref arms) => {\n                 rewrite_match(context, cond, arms, width, offset, self.span)\n             }\n-            ast::Expr_::ExprPath(ref qself, ref path) => {\n+            ast::ExprKind::Path(ref qself, ref path) => {\n                 rewrite_path(context, true, qself.as_ref(), path, width, offset)\n             }\n-            ast::Expr_::ExprAssign(ref lhs, ref rhs) => {\n+            ast::ExprKind::Assign(ref lhs, ref rhs) => {\n                 rewrite_assignment(context, lhs, rhs, None, width, offset)\n             }\n-            ast::Expr_::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n+            ast::ExprKind::AssignOp(ref op, ref lhs, ref rhs) => {\n                 rewrite_assignment(context, lhs, rhs, Some(op), width, offset)\n             }\n-            ast::Expr_::ExprAgain(ref opt_ident) => {\n+            ast::ExprKind::Again(ref opt_ident) => {\n                 let id_str = match *opt_ident {\n                     Some(ident) => format!(\" {}\", ident.node),\n                     None => String::new(),\n                 };\n                 Some(format!(\"continue{}\", id_str))\n             }\n-            ast::Expr_::ExprBreak(ref opt_ident) => {\n+            ast::ExprKind::Break(ref opt_ident) => {\n                 let id_str = match *opt_ident {\n                     Some(ident) => format!(\" {}\", ident.node),\n                     None => String::new(),\n                 };\n                 Some(format!(\"break{}\", id_str))\n             }\n-            ast::Expr_::ExprClosure(capture, ref fn_decl, ref body) => {\n+            ast::ExprKind::Closure(capture, ref fn_decl, ref body) => {\n                 rewrite_closure(capture, fn_decl, body, self.span, context, width, offset)\n             }\n-            ast::Expr_::ExprField(..) |\n-            ast::Expr_::ExprTupField(..) |\n-            ast::Expr_::ExprMethodCall(..) => rewrite_chain(self, context, width, offset),\n-            ast::Expr_::ExprMac(ref mac) => {\n+            ast::ExprKind::Field(..) |\n+            ast::ExprKind::TupField(..) |\n+            ast::ExprKind::MethodCall(..) => rewrite_chain(self, context, width, offset),\n+            ast::ExprKind::Mac(ref mac) => {\n                 // Failure to rewrite a marco should not imply failure to\n                 // rewrite the expression.\n                 rewrite_macro(mac, context, width, offset).or_else(|| {\n@@ -161,40 +161,43 @@ impl Rewrite for ast::Expr {\n                              offset)\n                 })\n             }\n-            ast::Expr_::ExprRet(None) => {\n+            ast::ExprKind::Ret(None) => {\n                 wrap_str(\"return\".to_owned(), context.config.max_width, width, offset)\n             }\n-            ast::Expr_::ExprRet(Some(ref expr)) => {\n+            ast::ExprKind::Ret(Some(ref expr)) => {\n                 rewrite_unary_prefix(context, \"return \", &**expr, width, offset)\n             }\n-            ast::Expr_::ExprBox(ref expr) => {\n+            ast::ExprKind::Box(ref expr) => {\n                 rewrite_unary_prefix(context, \"box \", &**expr, width, offset)\n             }\n-            ast::Expr_::ExprAddrOf(mutability, ref expr) => {\n+            ast::ExprKind::AddrOf(mutability, ref expr) => {\n                 rewrite_expr_addrof(context, mutability, expr, width, offset)\n             }\n-            ast::Expr_::ExprCast(ref expr, ref ty) => {\n+            ast::ExprKind::Cast(ref expr, ref ty) => {\n                 rewrite_pair(&**expr, &**ty, \"\", \" as \", \"\", context, width, offset)\n             }\n-            ast::Expr_::ExprIndex(ref expr, ref index) => {\n+            // TODO(#848): Handle type ascription; rust tracking issue\n+            //   https://github.com/rust-lang/rust/issues/23416\n+            ast::ExprKind::Type(_, _) => unimplemented!(),\n+            ast::ExprKind::Index(ref expr, ref index) => {\n                 rewrite_pair(&**expr, &**index, \"\", \"[\", \"]\", context, width, offset)\n             }\n-            ast::Expr_::ExprRepeat(ref expr, ref repeats) => {\n+            ast::ExprKind::Repeat(ref expr, ref repeats) => {\n                 rewrite_pair(&**expr, &**repeats, \"[\", \"; \", \"]\", context, width, offset)\n             }\n-            ast::Expr_::ExprRange(Some(ref lhs), Some(ref rhs)) => {\n+            ast::ExprKind::Range(Some(ref lhs), Some(ref rhs)) => {\n                 rewrite_pair(&**lhs, &**rhs, \"\", \"..\", \"\", context, width, offset)\n             }\n-            ast::Expr_::ExprRange(None, Some(ref rhs)) => {\n+            ast::ExprKind::Range(None, Some(ref rhs)) => {\n                 rewrite_unary_prefix(context, \"..\", &**rhs, width, offset)\n             }\n-            ast::Expr_::ExprRange(Some(ref lhs), None) => {\n+            ast::ExprKind::Range(Some(ref lhs), None) => {\n                 Some(format!(\"{}..\",\n                              try_opt!(lhs.rewrite(context,\n                                                   try_opt!(width.checked_sub(2)),\n                                                   offset))))\n             }\n-            ast::Expr_::ExprRange(None, None) => {\n+            ast::ExprKind::Range(None, None) => {\n                 if width >= 2 {\n                     Some(\"..\".into())\n                 } else {\n@@ -203,8 +206,8 @@ impl Rewrite for ast::Expr {\n             }\n             // We do not format these expressions yet, but they should still\n             // satisfy our width restrictions.\n-            ast::Expr_::ExprInPlace(..) |\n-            ast::Expr_::ExprInlineAsm(..) => {\n+            ast::ExprKind::InPlace(..) |\n+            ast::ExprKind::InlineAsm(..) => {\n                 wrap_str(context.snippet(self.span),\n                          context.config.max_width,\n                          width,\n@@ -302,15 +305,15 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n \n // This functions is pretty messy because of the wrapping and unwrapping of\n // expressions into and from blocks. See rust issue #27872.\n-fn rewrite_closure(capture: ast::CaptureClause,\n+fn rewrite_closure(capture: ast::CaptureBy,\n                    fn_decl: &ast::FnDecl,\n                    body: &ast::Block,\n                    span: Span,\n                    context: &RewriteContext,\n                    width: usize,\n                    offset: Indent)\n                    -> Option<String> {\n-    let mover = if capture == ast::CaptureClause::CaptureByValue {\n+    let mover = if capture == ast::CaptureBy::Value {\n         \"move \"\n     } else {\n         \"\"\n@@ -374,9 +377,8 @@ fn rewrite_closure(capture: ast::CaptureClause,\n         // All closure bodies are blocks in the eyes of the AST, but we may not\n         // want to unwrap them when they only contain a single expression.\n         let inner_expr = match expr.node {\n-            ast::Expr_::ExprBlock(ref inner) if inner.stmts.is_empty() && inner.expr.is_some() &&\n-                                                inner.rules ==\n-                                                ast::BlockCheckMode::DefaultBlock => {\n+            ast::ExprKind::Block(ref inner) if inner.stmts.is_empty() && inner.expr.is_some() &&\n+                                               inner.rules == ast::BlockCheckMode::Default => {\n                 inner.expr.as_ref().unwrap()\n             }\n             _ => expr,\n@@ -398,7 +400,7 @@ fn rewrite_closure(capture: ast::CaptureClause,\n     let body_rewrite = body.expr\n                            .as_ref()\n                            .and_then(|body_expr| {\n-                               if let ast::Expr_::ExprBlock(ref inner) = body_expr.node {\n+                               if let ast::ExprKind::Block(ref inner) = body_expr.node {\n                                    Some(inner.rewrite(&context, 2, Indent::empty()))\n                                } else {\n                                    None\n@@ -431,7 +433,7 @@ impl Rewrite for ast::Block {\n         visitor.block_indent = context.block_indent;\n \n         let prefix = match self.rules {\n-            ast::BlockCheckMode::UnsafeBlock(..) => {\n+            ast::BlockCheckMode::Unsafe(..) => {\n                 let snippet = context.snippet(self.span);\n                 let open_pos = try_opt!(snippet.find_uncommented(\"{\"));\n                 visitor.last_pos = self.span.lo + BytePos(open_pos as u32);\n@@ -467,7 +469,7 @@ impl Rewrite for ast::Block {\n \n                 prefix\n             }\n-            ast::BlockCheckMode::DefaultBlock => {\n+            ast::BlockCheckMode::Default => {\n                 visitor.last_pos = self.span.lo;\n \n                 String::new()\n@@ -483,14 +485,14 @@ impl Rewrite for ast::Block {\n impl Rewrite for ast::Stmt {\n     fn rewrite(&self, context: &RewriteContext, _width: usize, offset: Indent) -> Option<String> {\n         let result = match self.node {\n-            ast::Stmt_::StmtDecl(ref decl, _) => {\n-                if let ast::Decl_::DeclLocal(ref local) = decl.node {\n+            ast::StmtKind::Decl(ref decl, _) => {\n+                if let ast::DeclKind::Local(ref local) = decl.node {\n                     local.rewrite(context, context.config.max_width, offset)\n                 } else {\n                     None\n                 }\n             }\n-            ast::Stmt_::StmtExpr(ref ex, _) | ast::Stmt_::StmtSemi(ref ex, _) => {\n+            ast::StmtKind::Expr(ref ex, _) | ast::StmtKind::Semi(ref ex, _) => {\n                 let suffix = if semicolon_for_stmt(self) {\n                     \";\"\n                 } else {\n@@ -502,7 +504,7 @@ impl Rewrite for ast::Stmt {\n                            offset)\n                   .map(|s| s + suffix)\n             }\n-            ast::Stmt_::StmtMac(..) => None,\n+            ast::StmtKind::Mac(..) => None,\n         };\n         result.and_then(|res| recover_comment_removed(res, self.span, context, _width, offset))\n     }\n@@ -681,7 +683,7 @@ fn rewrite_if_else(context: &RewriteContext,\n         let rewrite = match else_block.node {\n             // If the else expression is another if-else expression, prevent it\n             // from being formatted on a single line.\n-            ast::Expr_::ExprIfLet(ref pat, ref cond, ref if_block, ref next_else_block) => {\n+            ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref next_else_block) => {\n                 rewrite_if_else(context,\n                                 cond,\n                                 if_block,\n@@ -692,7 +694,7 @@ fn rewrite_if_else(context: &RewriteContext,\n                                 offset,\n                                 false)\n             }\n-            ast::Expr_::ExprIf(ref cond, ref if_block, ref next_else_block) => {\n+            ast::ExprKind::If(ref cond, ref if_block, ref next_else_block) => {\n                 rewrite_if_else(context,\n                                 cond,\n                                 if_block,\n@@ -741,7 +743,7 @@ fn single_line_if_else(context: &RewriteContext,\n     let else_block = try_opt!(else_block_opt);\n     let fixed_cost = \"if  {  } else {  }\".len();\n \n-    if let ast::ExprBlock(ref else_node) = else_block.node {\n+    if let ast::ExprKind::Block(ref else_node) = else_block.node {\n         if !is_simple_block(if_node, context.codemap) ||\n            !is_simple_block(else_node, context.codemap) || pat_expr_str.contains('\\n') {\n             return None;\n@@ -794,7 +796,7 @@ pub fn is_empty_block(block: &ast::Block, codemap: &CodeMap) -> bool {\n }\n \n fn is_unsafe_block(block: &ast::Block) -> bool {\n-    if let ast::BlockCheckMode::UnsafeBlock(..) = block.rules {\n+    if let ast::BlockCheckMode::Unsafe(..) = block.rules {\n         true\n     } else {\n         false\n@@ -925,15 +927,15 @@ fn arm_end_pos(arm: &ast::Arm) -> BytePos {\n \n fn arm_comma(config: &Config, arm: &ast::Arm, body: &ast::Expr) -> &'static str {\n     if !config.match_wildcard_trailing_comma {\n-        if arm.pats.len() == 1 && arm.pats[0].node == ast::PatWild && arm.guard.is_none() {\n+        if arm.pats.len() == 1 && arm.pats[0].node == ast::PatKind::Wild && arm.guard.is_none() {\n             return \"\";\n         }\n     }\n \n     if config.match_block_trailing_comma {\n         \",\"\n-    } else if let ast::ExprBlock(ref block) = body.node {\n-        if let ast::DefaultBlock = block.rules {\n+    } else if let ast::ExprKind::Block(ref block) = body.node {\n+        if let ast::BlockCheckMode::Default = block.rules {\n             \"\"\n         } else {\n             \",\"\n@@ -1015,12 +1017,9 @@ impl Rewrite for ast::Arm {\n         }\n \n         let body = match **body {\n-            ast::Expr { node: ast::ExprBlock(ref block), .. } if !is_unsafe_block(block) &&\n-                                                                 is_simple_block(block,\n-                                                                                 context.codemap) &&\n-                                                                 context.config.wrap_match_arms => {\n-                block.expr.as_ref().map(|e| &**e).unwrap()\n-            }\n+            ast::Expr { node: ast::ExprKind::Block(ref block), .. }\n+                if !is_unsafe_block(block) && is_simple_block(block, context.codemap) &&\n+                context.config.wrap_match_arms => block.expr.as_ref().map(|e| &**e).unwrap(),\n             ref x => x,\n         };\n \n@@ -1032,7 +1031,7 @@ impl Rewrite for ast::Arm {\n             let budget = context.config.max_width - line_start - comma.len() - 4;\n             let offset = Indent::new(offset.block_indent, line_start + 4 - offset.block_indent);\n             let rewrite = nop_block_collapse(body.rewrite(context, budget, offset), budget);\n-            let is_block = if let ast::ExprBlock(..) = body.node {\n+            let is_block = if let ast::ExprKind::Block(..) = body.node {\n                 true\n             } else {\n                 false\n@@ -1307,8 +1306,8 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     // indentation. If its first line fits on one line with the other arguments,\n     // we format the function arguments horizontally.\n     let overflow_last = match args.last().map(|x| &x.node) {\n-        Some(&ast::Expr_::ExprClosure(..)) |\n-        Some(&ast::Expr_::ExprBlock(..)) if arg_count > 1 => true,\n+        Some(&ast::ExprKind::Closure(..)) |\n+        Some(&ast::ExprKind::Block(..)) if arg_count > 1 => true,\n         _ => false,\n     } && context.config.chains_overflow_last;\n \n@@ -1666,9 +1665,9 @@ fn rewrite_unary_op(context: &RewriteContext,\n                     -> Option<String> {\n     // For some reason, an UnOp is not spanned like BinOp!\n     let operator_str = match *op {\n-        ast::UnOp::UnDeref => \"*\",\n-        ast::UnOp::UnNot => \"!\",\n-        ast::UnOp::UnNeg => \"-\",\n+        ast::UnOp::Deref => \"*\",\n+        ast::UnOp::Not => \"!\",\n+        ast::UnOp::Neg => \"-\",\n     };\n     rewrite_unary_prefix(context, operator_str, expr, width, offset)\n }\n@@ -1744,8 +1743,8 @@ fn rewrite_expr_addrof(context: &RewriteContext,\n                        offset: Indent)\n                        -> Option<String> {\n     let operator_str = match mutability {\n-        ast::Mutability::MutImmutable => \"&\",\n-        ast::Mutability::MutMutable => \"&mut \",\n+        ast::Mutability::Immutable => \"&\",\n+        ast::Mutability::Mutable => \"&mut \",\n     };\n     rewrite_unary_prefix(context, operator_str, expr, width, offset)\n }"}, {"sha": "38720d84cce52204a8b88239483e27f446bf1b2b", "filename": "src/imports.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=589dabda2f212d8ae231ed6aab2bbf851eaed90c", "patch": "@@ -51,7 +51,7 @@ impl Rewrite for ast::ViewPath {\n }\n \n fn rewrite_single_use_list(path_str: String, vpi: &ast::PathListItem) -> String {\n-    let path_item_str = if let ast::PathListItem_::PathListIdent { name, .. } = vpi.node {\n+    let path_item_str = if let ast::PathListItemKind::Ident { name, .. } = vpi.node {\n         // A name.\n         if path_str.is_empty() {\n             name.to_string()\n@@ -74,17 +74,17 @@ fn rewrite_single_use_list(path_str: String, vpi: &ast::PathListItem) -> String\n \n fn rewrite_path_item(vpi: &&ast::PathListItem) -> Option<String> {\n     let path_item_str = match vpi.node {\n-        ast::PathListItem_::PathListIdent { name, .. } => name.to_string(),\n-        ast::PathListItem_::PathListMod { .. } => \"self\".to_owned(),\n+        ast::PathListItemKind::Ident { name, .. } => name.to_string(),\n+        ast::PathListItemKind::Mod { .. } => \"self\".to_owned(),\n     };\n \n     Some(append_alias(path_item_str, vpi))\n }\n \n fn append_alias(path_item_str: String, vpi: &ast::PathListItem) -> String {\n     match vpi.node {\n-        ast::PathListItem_::PathListIdent { rename: Some(rename), .. } |\n-        ast::PathListItem_::PathListMod { rename: Some(rename), .. } => {\n+        ast::PathListItemKind::Ident { rename: Some(rename), .. } |\n+        ast::PathListItemKind::Mod { rename: Some(rename), .. } => {\n             format!(\"{} as {}\", path_item_str, rename)\n         }\n         _ => path_item_str,"}, {"sha": "c013733f37f0ad89c0ac7960e427864a148e9511", "filename": "src/items.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=589dabda2f212d8ae231ed6aab2bbf851eaed90c", "patch": "@@ -27,7 +27,6 @@ use syntax::{ast, abi};\n use syntax::codemap::{Span, BytePos, mk_sp};\n use syntax::parse::token;\n use syntax::ast::ImplItem;\n-use syntax::ptr::P;\n \n // Statements of the form\n // let pat: ty = init;\n@@ -110,7 +109,7 @@ impl<'a> FmtVisitor<'a> {\n         let span = mk_sp(item.span.lo, item.span.hi - BytePos(1));\n \n         match item.node {\n-            ast::ForeignItem_::ForeignItemFn(ref fn_decl, ref generics) => {\n+            ast::ForeignItemKind::Fn(ref fn_decl, ref generics) => {\n                 let indent = self.block_indent;\n                 let rewrite = rewrite_fn_base(&self.get_context(),\n                                               indent,\n@@ -136,7 +135,7 @@ impl<'a> FmtVisitor<'a> {\n                     None => self.format_missing(item.span.hi),\n                 }\n             }\n-            ast::ForeignItem_::ForeignItemStatic(ref ty, is_mutable) => {\n+            ast::ForeignItemKind::Static(ref ty, is_mutable) => {\n                 // FIXME(#21): we're dropping potential comments in between the\n                 // function keywords here.\n                 let mut_str = if is_mutable {\n@@ -441,12 +440,12 @@ impl<'a> FmtVisitor<'a> {\n }\n \n pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -> Option<String> {\n-    if let ast::Item_::ItemImpl(unsafety,\n-                                polarity,\n-                                ref generics,\n-                                ref trait_ref,\n-                                ref self_ty,\n-                                ref items) = item.node {\n+    if let ast::ItemKind::Impl(unsafety,\n+                               polarity,\n+                               ref generics,\n+                               ref trait_ref,\n+                               ref self_ty,\n+                               ref items) = item.node {\n         let mut result = String::new();\n         result.push_str(format_visibility(item.vis));\n         result.push_str(format_unsafety(unsafety));\n@@ -562,7 +561,7 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n }\n \n fn is_impl_single_line(context: &RewriteContext,\n-                       items: &Vec<P<ImplItem>>,\n+                       items: &Vec<ImplItem>,\n                        result: &str,\n                        where_clause_str: &str,\n                        item: &ast::Item)\n@@ -919,15 +918,15 @@ pub fn rewrite_static(prefix: &str,\n impl Rewrite for ast::FunctionRetTy {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match *self {\n-            ast::FunctionRetTy::DefaultReturn(_) => Some(String::new()),\n-            ast::FunctionRetTy::NoReturn(_) => {\n+            ast::FunctionRetTy::Default(_) => Some(String::new()),\n+            ast::FunctionRetTy::None(_) => {\n                 if width >= 4 {\n                     Some(\"-> !\".to_owned())\n                 } else {\n                     None\n                 }\n             }\n-            ast::FunctionRetTy::Return(ref ty) => {\n+            ast::FunctionRetTy::Ty(ref ty) => {\n                 let inner_width = try_opt!(width.checked_sub(3));\n                 ty.rewrite(context, inner_width, offset + 3).map(|r| format!(\"-> {}\", r))\n             }\n@@ -940,7 +939,7 @@ impl Rewrite for ast::Arg {\n         if is_named_arg(self) {\n             let mut result = try_opt!(self.pat.rewrite(context, width, offset));\n \n-            if self.ty.node != ast::Ty_::TyInfer {\n+            if self.ty.node != ast::TyKind::Infer {\n                 result.push_str(\": \");\n                 let max_width = try_opt!(width.checked_sub(result.len()));\n                 let ty_str = try_opt!(self.ty.rewrite(context, max_width, offset + result.len()));\n@@ -959,7 +958,7 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf,\n                          context: &RewriteContext)\n                          -> Option<String> {\n     match explicit_self.node {\n-        ast::ExplicitSelf_::SelfRegion(lt, m, _) => {\n+        ast::SelfKind::Region(lt, m, _) => {\n             let mut_str = format_mutability(m);\n             match lt {\n                 Some(ref l) => {\n@@ -971,15 +970,15 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf,\n                 None => Some(format!(\"&{}self\", mut_str)),\n             }\n         }\n-        ast::ExplicitSelf_::SelfExplicit(ref ty, _) => {\n+        ast::SelfKind::Explicit(ref ty, _) => {\n             assert!(!args.is_empty(), \"&[ast::Arg] shouldn't be empty.\");\n \n             let mutability = explicit_self_mutability(&args[0]);\n             let type_str = try_opt!(ty.rewrite(context, usize::max_value(), Indent::empty()));\n \n             Some(format!(\"{}self: {}\", format_mutability(mutability), type_str))\n         }\n-        ast::ExplicitSelf_::SelfValue(_) => {\n+        ast::SelfKind::Value(_) => {\n             assert!(!args.is_empty(), \"&[ast::Arg] shouldn't be empty.\");\n \n             let mutability = explicit_self_mutability(&args[0]);\n@@ -993,7 +992,7 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf,\n // Hacky solution caused by absence of `Mutability` in `SelfValue` and\n // `SelfExplicit` variants of `ast::ExplicitSelf_`.\n fn explicit_self_mutability(arg: &ast::Arg) -> ast::Mutability {\n-    if let ast::Pat_::PatIdent(ast::BindingMode::BindByValue(mutability), _, _) = arg.pat.node {\n+    if let ast::PatKind::Ident(ast::BindingMode::ByValue(mutability), _, _) = arg.pat.node {\n         mutability\n     } else {\n         unreachable!()\n@@ -1010,13 +1009,13 @@ pub fn span_lo_for_arg(arg: &ast::Arg) -> BytePos {\n \n pub fn span_hi_for_arg(arg: &ast::Arg) -> BytePos {\n     match arg.ty.node {\n-        ast::Ty_::TyInfer if is_named_arg(arg) => arg.pat.span.hi,\n+        ast::TyKind::Infer if is_named_arg(arg) => arg.pat.span.hi,\n         _ => arg.ty.span.hi,\n     }\n }\n \n pub fn is_named_arg(arg: &ast::Arg) -> bool {\n-    if let ast::Pat_::PatIdent(_, ident, _) = arg.pat.node {\n+    if let ast::PatKind::Ident(_, ident, _) = arg.pat.node {\n         ident.node != token::special_idents::invalid\n     } else {\n         true\n@@ -1025,9 +1024,9 @@ pub fn is_named_arg(arg: &ast::Arg) -> bool {\n \n fn span_for_return(ret: &ast::FunctionRetTy) -> Span {\n     match *ret {\n-        ast::FunctionRetTy::NoReturn(ref span) |\n-        ast::FunctionRetTy::DefaultReturn(ref span) => span.clone(),\n-        ast::FunctionRetTy::Return(ref ty) => ty.span,\n+        ast::FunctionRetTy::None(ref span) |\n+        ast::FunctionRetTy::Default(ref span) => span.clone(),\n+        ast::FunctionRetTy::Ty(ref ty) => ty.span,\n     }\n }\n \n@@ -1085,7 +1084,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n         result.push_str(\"const \");\n     }\n \n-    if abi != abi::Rust {\n+    if abi != abi::Abi::Rust {\n         result.push_str(&::utils::format_abi(abi));\n     }\n "}, {"sha": "7e074f0512490f974b7ed9f4eae613c7cc94c8f1", "filename": "src/lib.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=589dabda2f212d8ae231ed6aab2bbf851eaed90c", "patch": "@@ -26,13 +26,15 @@ extern crate diff;\n extern crate term;\n \n use syntax::ast;\n-use syntax::codemap::{mk_sp, Span};\n-use syntax::diagnostic::{EmitterWriter, Handler};\n+use syntax::codemap::{mk_sp, CodeMap, Span};\n+use syntax::errors::Handler;\n+use syntax::errors::emitter::{ColorConfig, EmitterWriter};\n use syntax::parse::{self, ParseSess};\n \n use std::io::stdout;\n use std::ops::{Add, Sub};\n use std::path::Path;\n+use std::rc::Rc;\n use std::collections::HashMap;\n use std::fmt;\n \n@@ -367,15 +369,23 @@ pub fn fmt_lines(file_map: &mut FileMap, config: &Config) -> FormatReport {\n \n pub fn format_string(input: String, config: &Config) -> FileMap {\n     let path = \"stdin\";\n-    let mut parse_session = ParseSess::new();\n+    let codemap = Rc::new(CodeMap::new());\n+\n+    let tty_handler = Handler::with_tty_emitter(ColorConfig::Auto,\n+                                                None,\n+                                                true,\n+                                                false,\n+                                                codemap.clone());\n+    let mut parse_session = ParseSess::with_span_handler(tty_handler, codemap.clone());\n+\n     let krate = parse::parse_crate_from_source_str(path.to_owned(),\n                                                    input,\n                                                    Vec::new(),\n                                                    &parse_session);\n \n     // Suppress error output after parsing.\n-    let emitter = Box::new(EmitterWriter::new(Box::new(Vec::new()), None));\n-    parse_session.span_diagnostic.handler = Handler::with_emitter(false, emitter);\n+    let silent_emitter = Box::new(EmitterWriter::new(Box::new(Vec::new()), None, codemap.clone()));\n+    parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n \n     // FIXME: we still use a FileMap even though we only have\n     // one file, because fmt_lines requires a FileMap\n@@ -393,12 +403,20 @@ pub fn format_string(input: String, config: &Config) -> FileMap {\n }\n \n pub fn format(file: &Path, config: &Config) -> FileMap {\n-    let mut parse_session = ParseSess::new();\n+    let codemap = Rc::new(CodeMap::new());\n+\n+    let tty_handler = Handler::with_tty_emitter(ColorConfig::Auto,\n+                                                None,\n+                                                true,\n+                                                false,\n+                                                codemap.clone());\n+    let mut parse_session = ParseSess::with_span_handler(tty_handler, codemap.clone());\n+\n     let krate = parse::parse_crate_from_file(file, Vec::new(), &parse_session);\n \n     // Suppress error output after parsing.\n-    let emitter = Box::new(EmitterWriter::new(Box::new(Vec::new()), None));\n-    parse_session.span_diagnostic.handler = Handler::with_emitter(false, emitter);\n+    let silent_emitter = Box::new(EmitterWriter::new(Box::new(Vec::new()), None, codemap.clone()));\n+    parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n \n     let mut file_map = fmt_ast(&krate, &parse_session, file, config);\n "}, {"sha": "e56fa57ac7b911f6957d770b44c3049334107ba7", "filename": "src/modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=589dabda2f212d8ae231ed6aab2bbf851eaed90c", "patch": "@@ -40,7 +40,7 @@ fn list_submodules<'a>(module: &'a ast::Mod,\n                        result: &mut HashMap<PathBuf, &'a ast::Mod>) {\n     debug!(\"list_submodules: search_dir: {:?}\", search_dir);\n     for item in &module.items {\n-        if let ast::ItemMod(ref sub_mod) = item.node {\n+        if let ast::ItemKind::Mod(ref sub_mod) = item.node {\n             if !utils::contains_skip(&item.attrs) {\n                 let is_internal = codemap.span_to_filename(item.span) ==\n                                   codemap.span_to_filename(sub_mod.inner);"}, {"sha": "a761ad538f544f0b1d6c4b2d72a364a030e47899", "filename": "src/patterns.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=589dabda2f212d8ae231ed6aab2bbf851eaed90c", "patch": "@@ -15,16 +15,16 @@ use lists::{format_item_list, itemize_list};\n use expr::{rewrite_unary_prefix, rewrite_pair, rewrite_tuple};\n use types::rewrite_path;\n \n-use syntax::ast::{BindingMode, Pat, Pat_, FieldPat};\n+use syntax::ast::{BindingMode, Pat, PatKind, FieldPat};\n \n impl Rewrite for Pat {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match self.node {\n-            Pat_::PatBox(ref pat) => rewrite_unary_prefix(context, \"box \", &**pat, width, offset),\n-            Pat_::PatIdent(binding_mode, ident, ref sub_pat) => {\n+            PatKind::Box(ref pat) => rewrite_unary_prefix(context, \"box \", &**pat, width, offset),\n+            PatKind::Ident(binding_mode, ident, ref sub_pat) => {\n                 let (prefix, mutability) = match binding_mode {\n-                    BindingMode::BindByRef(mutability) => (\"ref \", mutability),\n-                    BindingMode::BindByValue(mutability) => (\"\", mutability),\n+                    BindingMode::ByRef(mutability) => (\"ref \", mutability),\n+                    BindingMode::ByValue(mutability) => (\"\", mutability),\n                 };\n                 let mut_infix = format_mutability(mutability);\n                 let id_str = ident.node.to_string();\n@@ -43,31 +43,32 @@ impl Rewrite for Pat {\n                 let result = format!(\"{}{}{}{}\", prefix, mut_infix, id_str, sub_pat);\n                 wrap_str(result, context.config.max_width, width, offset)\n             }\n-            Pat_::PatWild => {\n+            PatKind::Wild => {\n                 if 1 <= width {\n                     Some(\"_\".to_owned())\n                 } else {\n                     None\n                 }\n             }\n-            Pat_::PatQPath(ref q_self, ref path) => {\n+            PatKind::QPath(ref q_self, ref path) => {\n                 rewrite_path(context, true, Some(q_self), path, width, offset)\n             }\n-            Pat_::PatRange(ref lhs, ref rhs) => {\n+            PatKind::Range(ref lhs, ref rhs) => {\n                 rewrite_pair(&**lhs, &**rhs, \"\", \"...\", \"\", context, width, offset)\n             }\n-            Pat_::PatRegion(ref pat, mutability) => {\n+            PatKind::Ref(ref pat, mutability) => {\n                 let prefix = format!(\"&{}\", format_mutability(mutability));\n                 rewrite_unary_prefix(context, &prefix, &**pat, width, offset)\n             }\n-            Pat_::PatTup(ref items) => {\n+            PatKind::Tup(ref items) => {\n                 rewrite_tuple(context,\n                               items.iter().map(|x| &**x),\n                               self.span,\n                               width,\n                               offset)\n             }\n-            Pat_::PatEnum(ref path, ref pat_vec) => {\n+            PatKind::Path(ref path) => rewrite_path(context, true, None, path, width, offset),\n+            PatKind::TupleStruct(ref path, ref pat_vec) => {\n                 let path_str = try_opt!(rewrite_path(context, true, None, path, width, offset));\n \n                 match *pat_vec {\n@@ -97,8 +98,8 @@ impl Rewrite for Pat {\n                     None => Some(format!(\"{}(..)\", path_str)),\n                 }\n             }\n-            Pat_::PatLit(ref expr) => expr.rewrite(context, width, offset),\n-            Pat_::PatVec(ref prefix, ref slice_pat, ref suffix) => {\n+            PatKind::Lit(ref expr) => expr.rewrite(context, width, offset),\n+            PatKind::Vec(ref prefix, ref slice_pat, ref suffix) => {\n                 // Rewrite all the sub-patterns.\n                 let prefix = prefix.iter().map(|p| p.rewrite(context, width, offset));\n                 let slice_pat = slice_pat.as_ref().map(|p| {\n@@ -118,7 +119,7 @@ impl Rewrite for Pat {\n                 let result = format!(\"[{}]\", pats.join(\", \"));\n                 wrap_str(result, context.config.max_width, width, offset)\n             }\n-            Pat_::PatStruct(ref path, ref fields, elipses) => {\n+            PatKind::Struct(ref path, ref fields, elipses) => {\n                 let path = try_opt!(rewrite_path(context, true, None, path, width, offset));\n \n                 let (elipses_str, terminator) = if elipses {\n@@ -167,7 +168,7 @@ impl Rewrite for Pat {\n                 }\n             }\n             // FIXME(#819) format pattern macros.\n-            Pat_::PatMac(..) => {\n+            PatKind::Mac(..) => {\n                 wrap_str(context.snippet(self.span),\n                          context.config.max_width,\n                          width,"}, {"sha": "5a08e176618578d2f37276cd488e70b78cafe79b", "filename": "src/types.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=589dabda2f212d8ae231ed6aab2bbf851eaed90c", "patch": "@@ -172,9 +172,9 @@ fn rewrite_segment(expr_context: bool,\n     let offset = offset + ident_len;\n \n     let params = match segment.parameters {\n-        ast::PathParameters::AngleBracketedParameters(ref data) if !data.lifetimes.is_empty() ||\n-                                                                   !data.types.is_empty() ||\n-                                                                   !data.bindings.is_empty() => {\n+        ast::PathParameters::AngleBracketed(ref data) if !data.lifetimes.is_empty() ||\n+                                                         !data.types.is_empty() ||\n+                                                         !data.bindings.is_empty() => {\n             let param_list = data.lifetimes\n                                  .iter()\n                                  .map(SegmentParam::LifeTime)\n@@ -213,10 +213,10 @@ fn rewrite_segment(expr_context: bool,\n \n             format!(\"{}<{}>\", separator, list_str)\n         }\n-        ast::PathParameters::ParenthesizedParameters(ref data) => {\n+        ast::PathParameters::Parenthesized(ref data) => {\n             let output = match data.output {\n-                Some(ref ty) => FunctionRetTy::Return(ty.clone()),\n-                None => FunctionRetTy::DefaultReturn(codemap::DUMMY_SP),\n+                Some(ref ty) => FunctionRetTy::Ty(ty.clone()),\n+                None => FunctionRetTy::Default(codemap::DUMMY_SP),\n             };\n             try_opt!(format_function_type(data.inputs.iter().map(|x| &**x),\n                                           &output,\n@@ -259,13 +259,13 @@ fn format_function_type<'a, I>(inputs: I,\n     let list_str = try_opt!(format_fn_args(items, budget, offset, context.config));\n \n     let output = match *output {\n-        FunctionRetTy::Return(ref ty) => {\n+        FunctionRetTy::Ty(ref ty) => {\n             let budget = try_opt!(width.checked_sub(4));\n             let type_str = try_opt!(ty.rewrite(context, budget, offset + 4));\n             format!(\" -> {}\", type_str)\n         }\n-        FunctionRetTy::NoReturn(..) => \" -> !\".to_owned(),\n-        FunctionRetTy::DefaultReturn(..) => String::new(),\n+        FunctionRetTy::None(..) => \" -> !\".to_owned(),\n+        FunctionRetTy::Default(..) => String::new(),\n     };\n \n     let infix = if output.len() + list_str.len() > width {\n@@ -470,7 +470,7 @@ impl Rewrite for ast::TraitRef {\n impl Rewrite for ast::Ty {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match self.node {\n-            ast::TyObjectSum(ref ty, ref bounds) => {\n+            ast::TyKind::ObjectSum(ref ty, ref bounds) => {\n                 let ty_str = try_opt!(ty.rewrite(context, width, offset));\n                 let overhead = ty_str.len() + 3;\n                 let plus_str = match context.config.type_punctuation_density {\n@@ -484,15 +484,15 @@ impl Rewrite for ast::Ty {\n                                                      try_opt!(width.checked_sub(overhead)),\n                                                      offset + overhead))))\n             }\n-            ast::TyPtr(ref mt) => {\n+            ast::TyKind::Ptr(ref mt) => {\n                 let prefix = match mt.mutbl {\n-                    Mutability::MutMutable => \"*mut \",\n-                    Mutability::MutImmutable => \"*const \",\n+                    Mutability::Mutable => \"*mut \",\n+                    Mutability::Immutable => \"*const \",\n                 };\n \n                 rewrite_unary_prefix(context, prefix, &*mt.ty, width, offset)\n             }\n-            ast::TyRptr(ref lifetime, ref mt) => {\n+            ast::TyKind::Rptr(ref lifetime, ref mt) => {\n                 let mut_str = format_mutability(mt.mutbl);\n                 let mut_len = mut_str.len();\n                 Some(match *lifetime {\n@@ -520,39 +520,39 @@ impl Rewrite for ast::Ty {\n             }\n             // FIXME: we drop any comments here, even though it's a silly place to put\n             // comments.\n-            ast::TyParen(ref ty) => {\n+            ast::TyKind::Paren(ref ty) => {\n                 let budget = try_opt!(width.checked_sub(2));\n                 ty.rewrite(context, budget, offset + 1).map(|ty_str| format!(\"({})\", ty_str))\n             }\n-            ast::TyVec(ref ty) => {\n+            ast::TyKind::Vec(ref ty) => {\n                 let budget = try_opt!(width.checked_sub(2));\n                 ty.rewrite(context, budget, offset + 1).map(|ty_str| format!(\"[{}]\", ty_str))\n             }\n-            ast::TyTup(ref items) => {\n+            ast::TyKind::Tup(ref items) => {\n                 rewrite_tuple(context,\n                               items.iter().map(|x| &**x),\n                               self.span,\n                               width,\n                               offset)\n             }\n-            ast::TyPolyTraitRef(ref trait_ref) => trait_ref.rewrite(context, width, offset),\n-            ast::TyPath(ref q_self, ref path) => {\n+            ast::TyKind::PolyTraitRef(ref trait_ref) => trait_ref.rewrite(context, width, offset),\n+            ast::TyKind::Path(ref q_self, ref path) => {\n                 rewrite_path(context, false, q_self.as_ref(), path, width, offset)\n             }\n-            ast::TyFixedLengthVec(ref ty, ref repeats) => {\n+            ast::TyKind::FixedLengthVec(ref ty, ref repeats) => {\n                 rewrite_pair(&**ty, &**repeats, \"[\", \"; \", \"]\", context, width, offset)\n             }\n-            ast::TyInfer => {\n+            ast::TyKind::Infer => {\n                 if width >= 1 {\n                     Some(\"_\".to_owned())\n                 } else {\n                     None\n                 }\n             }\n-            ast::TyBareFn(ref bare_fn) => {\n+            ast::TyKind::BareFn(ref bare_fn) => {\n                 rewrite_bare_fn(bare_fn, self.span, context, width, offset)\n             }\n-            ast::TyMac(..) | ast::TyTypeof(..) => unreachable!(),\n+            ast::TyKind::Mac(..) | ast::TyKind::Typeof(..) => unreachable!(),\n         }\n     }\n }\n@@ -567,7 +567,7 @@ fn rewrite_bare_fn(bare_fn: &ast::BareFnTy,\n \n     result.push_str(&::utils::format_unsafety(bare_fn.unsafety));\n \n-    if bare_fn.abi != abi::Rust {\n+    if bare_fn.abi != abi::Abi::Rust {\n         result.push_str(&::utils::format_abi(bare_fn.abi));\n     }\n "}, {"sha": "acf758087d4bcffcced9450ffe18e5db830c7d49", "filename": "src/utils.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=589dabda2f212d8ae231ed6aab2bbf851eaed90c", "patch": "@@ -10,7 +10,7 @@\n \n use std::cmp::Ordering;\n \n-use syntax::ast::{self, Visibility, Attribute, MetaItem, MetaItem_};\n+use syntax::ast::{self, Visibility, Attribute, MetaItem, MetaItemKind};\n use syntax::codemap::{CodeMap, Span, BytePos};\n use syntax::abi;\n \n@@ -77,8 +77,8 @@ pub fn format_unsafety(unsafety: ast::Unsafety) -> &'static str {\n #[inline]\n pub fn format_mutability(mutability: ast::Mutability) -> &'static str {\n     match mutability {\n-        ast::Mutability::MutMutable => \"mut \",\n-        ast::Mutability::MutImmutable => \"\",\n+        ast::Mutability::Mutable => \"mut \",\n+        ast::Mutability::Immutable => \"\",\n     }\n }\n \n@@ -109,8 +109,8 @@ pub fn last_line_width(s: &str) -> usize {\n #[inline]\n fn is_skip(meta_item: &MetaItem) -> bool {\n     match meta_item.node {\n-        MetaItem_::MetaWord(ref s) => *s == SKIP_ANNOTATION,\n-        MetaItem_::MetaList(ref s, ref l) => *s == \"cfg_attr\" && l.len() == 2 && is_skip(&l[1]),\n+        MetaItemKind::Word(ref s) => *s == SKIP_ANNOTATION,\n+        MetaItemKind::List(ref s, ref l) => *s == \"cfg_attr\" && l.len() == 2 && is_skip(&l[1]),\n         _ => false,\n     }\n }\n@@ -137,26 +137,26 @@ pub fn end_typaram(typaram: &ast::TyParam) -> BytePos {\n #[inline]\n pub fn semicolon_for_expr(expr: &ast::Expr) -> bool {\n     match expr.node {\n-        ast::Expr_::ExprRet(..) |\n-        ast::Expr_::ExprAgain(..) |\n-        ast::Expr_::ExprBreak(..) => true,\n+        ast::ExprKind::Ret(..) |\n+        ast::ExprKind::Again(..) |\n+        ast::ExprKind::Break(..) => true,\n         _ => false,\n     }\n }\n \n #[inline]\n pub fn semicolon_for_stmt(stmt: &ast::Stmt) -> bool {\n     match stmt.node {\n-        ast::Stmt_::StmtSemi(ref expr, _) => {\n+        ast::StmtKind::Semi(ref expr, _) => {\n             match expr.node {\n-                ast::Expr_::ExprWhile(..) |\n-                ast::Expr_::ExprWhileLet(..) |\n-                ast::Expr_::ExprLoop(..) |\n-                ast::Expr_::ExprForLoop(..) => false,\n+                ast::ExprKind::While(..) |\n+                ast::ExprKind::WhileLet(..) |\n+                ast::ExprKind::Loop(..) |\n+                ast::ExprKind::ForLoop(..) => false,\n                 _ => true,\n             }\n         }\n-        ast::Stmt_::StmtExpr(..) => false,\n+        ast::StmtKind::Expr(..) => false,\n         _ => true,\n     }\n }"}, {"sha": "ae93ee52aab9b2aae7eba4ed20b5e3012f80a2c5", "filename": "src/visitor.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589dabda2f212d8ae231ed6aab2bbf851eaed90c/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=589dabda2f212d8ae231ed6aab2bbf851eaed90c", "patch": "@@ -36,8 +36,8 @@ pub struct FmtVisitor<'a> {\n impl<'a> FmtVisitor<'a> {\n     fn visit_stmt(&mut self, stmt: &ast::Stmt) {\n         match stmt.node {\n-            ast::Stmt_::StmtDecl(ref decl, _) => {\n-                if let ast::Decl_::DeclItem(ref item) = decl.node {\n+            ast::StmtKind::Decl(ref decl, _) => {\n+                if let ast::DeclKind::Item(ref item) = decl.node {\n                     self.visit_item(item);\n                 } else {\n                     let rewrite = stmt.rewrite(&self.get_context(),\n@@ -47,14 +47,14 @@ impl<'a> FmtVisitor<'a> {\n                     self.push_rewrite(stmt.span, rewrite);\n                 }\n             }\n-            ast::Stmt_::StmtExpr(..) | ast::Stmt_::StmtSemi(..) => {\n+            ast::StmtKind::Expr(..) | ast::StmtKind::Semi(..) => {\n                 let rewrite = stmt.rewrite(&self.get_context(),\n                                            self.config.max_width - self.block_indent.width(),\n                                            self.block_indent);\n \n                 self.push_rewrite(stmt.span, rewrite);\n             }\n-            ast::Stmt_::StmtMac(ref mac, _macro_style, _) => {\n+            ast::StmtKind::Mac(ref mac, _macro_style, _) => {\n                 self.format_missing_with_indent(stmt.span.lo);\n                 self.visit_mac(mac);\n             }\n@@ -183,7 +183,7 @@ impl<'a> FmtVisitor<'a> {\n         // FIXME This is overly conservative and means we miss attributes on\n         // inline modules.\n         match item.node {\n-            ast::Item_::ItemMod(_) => {\n+            ast::ItemKind::Mod(_) => {\n                 if utils::contains_skip(&item.attrs) {\n                     return;\n                 }\n@@ -197,32 +197,32 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         match item.node {\n-            ast::Item_::ItemUse(ref vp) => {\n+            ast::ItemKind::Use(ref vp) => {\n                 self.format_import(item.vis, vp, item.span);\n             }\n-            ast::Item_::ItemImpl(..) => {\n+            ast::ItemKind::Impl(..) => {\n                 self.format_missing_with_indent(item.span.lo);\n                 if let Some(impl_str) = format_impl(&self.get_context(), item, self.block_indent) {\n                     self.buffer.push_str(&impl_str);\n                     self.last_pos = item.span.hi;\n                 }\n             }\n             // FIXME(#78): format traits.\n-            ast::Item_::ItemTrait(_, _, _, ref trait_items) => {\n+            ast::ItemKind::Trait(_, _, _, ref trait_items) => {\n                 self.format_missing_with_indent(item.span.lo);\n                 self.block_indent = self.block_indent.block_indent(self.config);\n                 for item in trait_items {\n                     self.visit_trait_item(&item);\n                 }\n                 self.block_indent = self.block_indent.block_unindent(self.config);\n             }\n-            ast::Item_::ItemExternCrate(_) => {\n+            ast::ItemKind::ExternCrate(_) => {\n                 self.format_missing_with_indent(item.span.lo);\n                 let new_str = self.snippet(item.span);\n                 self.buffer.push_str(&new_str);\n                 self.last_pos = item.span.hi;\n             }\n-            ast::Item_::ItemStruct(ref def, ref generics) => {\n+            ast::ItemKind::Struct(ref def, ref generics) => {\n                 let rewrite = {\n                     let indent = self.block_indent;\n                     let context = self.get_context();\n@@ -243,24 +243,24 @@ impl<'a> FmtVisitor<'a> {\n                 };\n                 self.push_rewrite(item.span, rewrite);\n             }\n-            ast::Item_::ItemEnum(ref def, ref generics) => {\n+            ast::ItemKind::Enum(ref def, ref generics) => {\n                 self.format_missing_with_indent(item.span.lo);\n                 self.visit_enum(item.ident, item.vis, def, generics, item.span);\n                 self.last_pos = item.span.hi;\n             }\n-            ast::Item_::ItemMod(ref module) => {\n+            ast::ItemKind::Mod(ref module) => {\n                 self.format_missing_with_indent(item.span.lo);\n                 self.format_mod(module, item.vis, item.span, item.ident);\n             }\n-            ast::Item_::ItemMac(ref mac) => {\n+            ast::ItemKind::Mac(ref mac) => {\n                 self.format_missing_with_indent(item.span.lo);\n                 self.visit_mac(mac);\n             }\n-            ast::Item_::ItemForeignMod(ref foreign_mod) => {\n+            ast::ItemKind::ForeignMod(ref foreign_mod) => {\n                 self.format_missing_with_indent(item.span.lo);\n                 self.format_foreign_mod(foreign_mod, item.span);\n             }\n-            ast::Item_::ItemStatic(ref ty, mutability, ref expr) => {\n+            ast::ItemKind::Static(ref ty, mutability, ref expr) => {\n                 let rewrite = rewrite_static(\"static\",\n                                              item.vis,\n                                              item.ident,\n@@ -270,32 +270,32 @@ impl<'a> FmtVisitor<'a> {\n                                              &self.get_context());\n                 self.push_rewrite(item.span, rewrite);\n             }\n-            ast::Item_::ItemConst(ref ty, ref expr) => {\n+            ast::ItemKind::Const(ref ty, ref expr) => {\n                 let rewrite = rewrite_static(\"const\",\n                                              item.vis,\n                                              item.ident,\n                                              ty,\n-                                             ast::Mutability::MutImmutable,\n+                                             ast::Mutability::Immutable,\n                                              expr,\n                                              &self.get_context());\n                 self.push_rewrite(item.span, rewrite);\n             }\n-            ast::Item_::ItemDefaultImpl(..) => {\n+            ast::ItemKind::DefaultImpl(..) => {\n                 // FIXME(#78): format impl definitions.\n             }\n-            ast::ItemFn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n+            ast::ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n                 self.visit_fn(visit::FnKind::ItemFn(item.ident,\n                                                     generics,\n                                                     unsafety,\n                                                     constness,\n                                                     abi,\n                                                     item.vis),\n-                              declaration,\n+                              decl,\n                               body,\n                               item.span,\n                               item.id)\n             }\n-            ast::Item_::ItemTy(ref ty, ref generics) => {\n+            ast::ItemKind::Ty(ref ty, ref generics) => {\n                 let rewrite = rewrite_type_alias(&self.get_context(),\n                                                  self.block_indent,\n                                                  item.ident,\n@@ -314,22 +314,22 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         match ti.node {\n-            ast::ConstTraitItem(..) => {\n+            ast::TraitItemKind::Const(..) => {\n                 // FIXME: Implement\n             }\n-            ast::MethodTraitItem(ref sig, None) => {\n+            ast::TraitItemKind::Method(ref sig, None) => {\n                 let indent = self.block_indent;\n                 let rewrite = self.rewrite_required_fn(indent, ti.ident, sig, ti.span);\n                 self.push_rewrite(ti.span, rewrite);\n             }\n-            ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+            ast::TraitItemKind::Method(ref sig, Some(ref body)) => {\n                 self.visit_fn(visit::FnKind::Method(ti.ident, sig, None),\n                               &sig.decl,\n                               &body,\n                               ti.span,\n                               ti.id);\n             }\n-            ast::TypeTraitItem(..) => {\n+            ast::TraitItemKind::Type(..) => {\n                 // FIXME: Implement\n             }\n         }"}]}