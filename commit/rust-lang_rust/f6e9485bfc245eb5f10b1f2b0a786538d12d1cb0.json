{"sha": "f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZTk0ODViZmMyNDVlYjVmMTBiMWYyYjBhNzg2NTM4ZDEyZDFjYjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-17T04:10:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-17T04:10:52Z"}, "message": "Auto merge of #55627 - sunfishcode:cg-llvm-gen, r=nikomatsakis\n\nrustc_codegen_llvm: traitification of LLVM-specific CodegenCx and Builder methods\n\nThis PR is the continuation of #54012 and earlier PRs, in the grand plan of #45274 to allow for multiple codegen backends.\n\nHigh-level summary: interpose a set of traits between Rust's codegen logic and the LLVM APIs, allowing another backend to implement the traits and share most of the codegen logic. These traits are currently somewhat LLVM-specific, but once this refactoring is in place, they can evolve to be more general.\n\nSee [this README](https://github.com/rust-lang/rust/blob/756f84d7cef90b7364ae88ca707e59670dde4c92/src/librustc_codegen_ssa/README.md) for a writeup on the current trait organization.", "tree": {"sha": "943397caca2ddcb98b861d9cf01374f6e73da836", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/943397caca2ddcb98b861d9cf01374f6e73da836"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "html_url": "https://github.com/rust-lang/rust/commit/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee821736ccdf1d370bf2c906ce3c133c0fc295d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee821736ccdf1d370bf2c906ce3c133c0fc295d4", "html_url": "https://github.com/rust-lang/rust/commit/ee821736ccdf1d370bf2c906ce3c133c0fc295d4"}, {"sha": "756f84d7cef90b7364ae88ca707e59670dde4c92", "url": "https://api.github.com/repos/rust-lang/rust/commits/756f84d7cef90b7364ae88ca707e59670dde4c92", "html_url": "https://github.com/rust-lang/rust/commit/756f84d7cef90b7364ae88ca707e59670dde4c92"}], "stats": {"total": 17760, "additions": 10107, "deletions": 7653}, "files": [{"sha": "8b7f3591a2505fc6ce463c3fe68c487fb851f8eb", "filename": "src/Cargo.lock", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -2122,23 +2122,32 @@ dependencies = [\n  \"memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-demangle 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_codegen_ssa 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_codegen_ssa\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustc_codegen_utils\"\n version = \"0.0.0\"\n dependencies = [\n  \"flate2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc_allocator 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"rustc_target 0.0.0\",\n- \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]"}, {"sha": "34017009c2838eae75707709b2e53e02dc2cc58e", "filename": "src/librustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FCargo.toml?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -13,6 +13,7 @@ test = false\n cc = \"1.0.1\"\n num_cpus = \"1.0\"\n rustc-demangle = \"0.1.4\"\n+rustc_codegen_ssa = { path = \"../librustc_codegen_ssa\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n memmap = \"0.6\"\n "}, {"sha": "76fc5a6eeec7f7f40d857f159a80a93e11bddec6", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 108, "deletions": 38, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -9,18 +9,20 @@\n // except according to those terms.\n \n use llvm::{self, AttributePlace};\n-use base;\n-use builder::{Builder, MemFlags};\n-use common::C_usize;\n+use rustc_codegen_ssa::MemFlags;\n+use builder::Builder;\n use context::CodegenCx;\n-use mir::place::PlaceRef;\n-use mir::operand::OperandValue;\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n+use rustc_codegen_ssa::mir::operand::OperandValue;\n use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n use value::Value;\n+use rustc_target::abi::call::ArgType;\n+\n+use rustc_codegen_ssa::traits::*;\n \n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Ty, Instance};\n use rustc::ty::layout;\n \n use libc::c_uint;\n@@ -110,16 +112,16 @@ pub trait LlvmType {\n impl LlvmType for Reg {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         match self.kind {\n-            RegKind::Integer => Type::ix(cx, self.size.bits()),\n+            RegKind::Integer => cx.type_ix(self.size.bits()),\n             RegKind::Float => {\n                 match self.size.bits() {\n-                    32 => Type::f32(cx),\n-                    64 => Type::f64(cx),\n+                    32 => cx.type_f32(),\n+                    64 => cx.type_f64(),\n                     _ => bug!(\"unsupported float: {:?}\", self)\n                 }\n             }\n             RegKind::Vector => {\n-                Type::vector(Type::i8(cx), self.size.bytes())\n+                cx.type_vector(cx.type_i8(), self.size.bytes())\n             }\n         }\n     }\n@@ -143,7 +145,7 @@ impl LlvmType for CastTarget {\n \n             // Simplify to array when all chunks are the same size and type\n             if rem_bytes == 0 {\n-                return Type::array(rest_ll_unit, rest_count);\n+                return cx.type_array(rest_ll_unit, rest_count);\n             }\n         }\n \n@@ -158,17 +160,27 @@ impl LlvmType for CastTarget {\n         if rem_bytes != 0 {\n             // Only integers can be really split further.\n             assert_eq!(self.rest.unit.kind, RegKind::Integer);\n-            args.push(Type::ix(cx, rem_bytes * 8));\n+            args.push(cx.type_ix(rem_bytes * 8));\n         }\n \n-        Type::struct_(cx, &args, false)\n+        cx.type_struct(&args, false)\n     }\n }\n \n pub trait ArgTypeExt<'ll, 'tcx> {\n     fn memory_ty(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n-    fn store(&self, bx: &Builder<'_, 'll, 'tcx>, val: &'ll Value, dst: PlaceRef<'ll, 'tcx>);\n-    fn store_fn_arg(&self, bx: &Builder<'_, 'll, 'tcx>, idx: &mut usize, dst: PlaceRef<'ll, 'tcx>);\n+    fn store(\n+        &self,\n+        bx: &mut Builder<'_, 'll, 'tcx>,\n+        val: &'ll Value,\n+        dst: PlaceRef<'tcx, &'ll Value>,\n+    );\n+    fn store_fn_arg(\n+        &self,\n+        bx: &mut Builder<'_, 'll, 'tcx>,\n+        idx: &mut usize,\n+        dst: PlaceRef<'tcx, &'ll Value>,\n+    );\n }\n \n impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n@@ -182,11 +194,15 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n     /// place for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    fn store(&self, bx: &Builder<'_, 'll, 'tcx>, val: &'ll Value, dst: PlaceRef<'ll, 'tcx>) {\n+    fn store(\n+        &self,\n+        bx: &mut Builder<'_, 'll, 'tcx>,\n+        val: &'ll Value,\n+        dst: PlaceRef<'tcx, &'ll Value>,\n+    ) {\n         if self.is_ignore() {\n             return;\n         }\n-        let cx = bx.cx;\n         if self.is_sized_indirect() {\n             OperandValue::Ref(val, None, self.layout.align).store(bx, dst)\n         } else if self.is_unsized_indirect() {\n@@ -196,7 +212,8 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n-                let cast_dst = bx.pointercast(dst.llval, cast.llvm_type(cx).ptr_to());\n+                let cast_ptr_llty = bx.cx().type_ptr_to(cast.llvm_type(bx.cx()));\n+                let cast_dst = bx.pointercast(dst.llval, cast_ptr_llty);\n                 bx.store(val, cast_dst, self.layout.align);\n             } else {\n                 // The actual return type is a struct, but the ABI\n@@ -214,22 +231,23 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let scratch_size = cast.size(cx);\n-                let scratch_align = cast.align(cx);\n-                let llscratch = bx.alloca(cast.llvm_type(cx), \"abi_cast\", scratch_align);\n+                let scratch_size = cast.size(bx.cx());\n+                let scratch_align = cast.align(bx.cx());\n+                let llscratch = bx.alloca(cast.llvm_type(bx.cx()), \"abi_cast\", scratch_align);\n                 bx.lifetime_start(llscratch, scratch_size);\n \n                 // ...where we first store the value...\n                 bx.store(val, llscratch, scratch_align);\n \n                 // ...and then memcpy it to the intended destination.\n-                base::call_memcpy(bx,\n-                                  bx.pointercast(dst.llval, Type::i8p(cx)),\n-                                  self.layout.align,\n-                                  bx.pointercast(llscratch, Type::i8p(cx)),\n-                                  scratch_align,\n-                                  C_usize(cx, self.layout.size.bytes()),\n-                                  MemFlags::empty());\n+                bx.memcpy(\n+                    dst.llval,\n+                    self.layout.align,\n+                    llscratch,\n+                    scratch_align,\n+                    bx.cx().const_usize(self.layout.size.bytes()),\n+                    MemFlags::empty()\n+                );\n \n                 bx.lifetime_end(llscratch, scratch_size);\n             }\n@@ -238,7 +256,12 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn store_fn_arg(&self, bx: &Builder<'a, 'll, 'tcx>, idx: &mut usize, dst: PlaceRef<'ll, 'tcx>) {\n+    fn store_fn_arg(\n+        &self,\n+        bx: &mut Builder<'a, 'll, 'tcx>,\n+        idx: &mut usize,\n+        dst: PlaceRef<'tcx, &'ll Value>,\n+    ) {\n         let mut next = || {\n             let val = llvm::get_param(bx.llfn(), *idx as c_uint);\n             *idx += 1;\n@@ -259,6 +282,27 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n     }\n }\n \n+impl ArgTypeMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    fn store_fn_arg(\n+        &mut self,\n+        ty: &ArgType<'tcx, Ty<'tcx>>,\n+        idx: &mut usize, dst: PlaceRef<'tcx, Self::Value>\n+    ) {\n+        ty.store_fn_arg(self, idx, dst)\n+    }\n+    fn store_arg_ty(\n+        &mut self,\n+        ty: &ArgType<'tcx, Ty<'tcx>>,\n+        val: &'ll Value,\n+        dst: PlaceRef<'tcx, &'ll Value>\n+    ) {\n+        ty.store(self, val, dst)\n+    }\n+    fn memory_ty(&self, ty: &ArgType<'tcx, Ty<'tcx>>) -> &'ll Type {\n+        ty.memory_ty(self.cx())\n+    }\n+}\n+\n pub trait FnTypeExt<'tcx> {\n     fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>) -> Self;\n     fn new(cx: &CodegenCx<'ll, 'tcx>,\n@@ -280,7 +324,7 @@ pub trait FnTypeExt<'tcx> {\n     fn ptr_to_llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn llvm_cconv(&self) -> llvm::CallConv;\n     fn apply_attrs_llfn(&self, llfn: &'ll Value);\n-    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'll, 'tcx>, callsite: &'ll Value);\n+    fn apply_attrs_callsite(&self, bx: &mut Builder<'a, 'll, 'tcx>, callsite: &'ll Value);\n }\n \n impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n@@ -614,14 +658,14 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         );\n \n         let llreturn_ty = match self.ret.mode {\n-            PassMode::Ignore => Type::void(cx),\n+            PassMode::Ignore => cx.type_void(),\n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 self.ret.layout.immediate_llvm_type(cx)\n             }\n             PassMode::Cast(cast) => cast.llvm_type(cx),\n             PassMode::Indirect(..) => {\n-                llargument_tys.push(self.ret.memory_ty(cx).ptr_to());\n-                Type::void(cx)\n+                llargument_tys.push(cx.type_ptr_to(self.ret.memory_ty(cx)));\n+                cx.type_void()\n             }\n         };\n \n@@ -647,15 +691,15 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                     continue;\n                 }\n                 PassMode::Cast(cast) => cast.llvm_type(cx),\n-                PassMode::Indirect(_, None) => arg.memory_ty(cx).ptr_to(),\n+                PassMode::Indirect(_, None) => cx.type_ptr_to(arg.memory_ty(cx)),\n             };\n             llargument_tys.push(llarg_ty);\n         }\n \n         if self.variadic {\n-            Type::variadic_func(&llargument_tys, llreturn_ty)\n+            cx.type_variadic_func(&llargument_tys, llreturn_ty)\n         } else {\n-            Type::func(&llargument_tys, llreturn_ty)\n+            cx.type_func(&llargument_tys, llreturn_ty)\n         }\n     }\n \n@@ -717,7 +761,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'll, 'tcx>, callsite: &'ll Value) {\n+    fn apply_attrs_callsite(&self, bx: &mut Builder<'a, 'll, 'tcx>, callsite: &'ll Value) {\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes| {\n             attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n@@ -736,7 +780,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             // by the LLVM verifier.\n             if let layout::Int(..) = scalar.value {\n                 if !scalar.is_bool() {\n-                    let range = scalar.valid_range_exclusive(bx.cx);\n+                    let range = scalar.valid_range_exclusive(bx.cx());\n                     if range.start != range.end {\n                         bx.range_metadata(callsite, range);\n                     }\n@@ -769,3 +813,29 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n     }\n }\n+\n+impl AbiMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn new_fn_type(&self, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> FnType<'tcx, Ty<'tcx>> {\n+        FnType::new(&self, sig, extra_args)\n+    }\n+    fn new_vtable(\n+        &self,\n+        sig: ty::FnSig<'tcx>,\n+        extra_args: &[Ty<'tcx>]\n+    ) -> FnType<'tcx, Ty<'tcx>> {\n+        FnType::new_vtable(&self, sig, extra_args)\n+    }\n+    fn fn_type_of_instance(&self, instance: &Instance<'tcx>) -> FnType<'tcx, Ty<'tcx>> {\n+        FnType::of_instance(&self, instance)\n+    }\n+}\n+\n+impl AbiBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    fn apply_attrs_callsite(\n+        &mut self,\n+        ty: &FnType<'tcx, Ty<'tcx>>,\n+        callsite: Self::Value\n+    ) {\n+        ty.apply_attrs_callsite(self, callsite)\n+    }\n+}"}, {"sha": "efbe7cad1383559c6c0bda3501c050cc60d1641e", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 98, "deletions": 101, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -9,126 +9,123 @@\n // except according to those terms.\n \n use llvm;\n-use common::*;\n-use type_::Type;\n+use context::CodegenCx;\n use type_of::LayoutLlvmExt;\n use builder::Builder;\n use value::Value;\n \n use rustc::hir;\n+use rustc_codegen_ssa::traits::*;\n \n-use mir::place::PlaceRef;\n-use mir::operand::OperandValue;\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n+use rustc_codegen_ssa::mir::operand::OperandValue;\n \n use std::ffi::CString;\n-use syntax::ast::AsmDialect;\n use libc::{c_uint, c_char};\n \n-// Take an inline assembly expression and splat it out via LLVM\n-pub fn codegen_inline_asm(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    ia: &hir::InlineAsm,\n-    outputs: Vec<PlaceRef<'ll, 'tcx>>,\n-    mut inputs: Vec<&'ll Value>\n-) -> bool {\n-    let mut ext_constraints = vec![];\n-    let mut output_types = vec![];\n-\n-    // Prepare the output operands\n-    let mut indirect_outputs = vec![];\n-    for (i, (out, place)) in ia.outputs.iter().zip(&outputs).enumerate() {\n-        if out.is_rw {\n-            inputs.push(place.load(bx).immediate());\n-            ext_constraints.push(i.to_string());\n+\n+impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    fn codegen_inline_asm(\n+        &mut self,\n+        ia: &hir::InlineAsm,\n+        outputs: Vec<PlaceRef<'tcx, &'ll Value>>,\n+        mut inputs: Vec<&'ll Value>\n+    ) -> bool {\n+        let mut ext_constraints = vec![];\n+        let mut output_types = vec![];\n+\n+        // Prepare the output operands\n+        let mut indirect_outputs = vec![];\n+        for (i, (out, &place)) in ia.outputs.iter().zip(&outputs).enumerate() {\n+            if out.is_rw {\n+                inputs.push(self.load_operand(place).immediate());\n+                ext_constraints.push(i.to_string());\n+            }\n+            if out.is_indirect {\n+                indirect_outputs.push(self.load_operand(place).immediate());\n+            } else {\n+                output_types.push(place.layout.llvm_type(self.cx()));\n+            }\n         }\n-        if out.is_indirect {\n-            indirect_outputs.push(place.load(bx).immediate());\n-        } else {\n-            output_types.push(place.layout.llvm_type(bx.cx));\n+        if !indirect_outputs.is_empty() {\n+            indirect_outputs.extend_from_slice(&inputs);\n+            inputs = indirect_outputs;\n         }\n-    }\n-    if !indirect_outputs.is_empty() {\n-        indirect_outputs.extend_from_slice(&inputs);\n-        inputs = indirect_outputs;\n-    }\n \n-    let clobbers = ia.clobbers.iter()\n-                              .map(|s| format!(\"~{{{}}}\", &s));\n-\n-    // Default per-arch clobbers\n-    // Basically what clang does\n-    let arch_clobbers = match &bx.sess().target.target.arch[..] {\n-        \"x86\" | \"x86_64\"  => vec![\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"],\n-        \"mips\" | \"mips64\" => vec![\"~{$1}\"],\n-        _                 => Vec::new()\n-    };\n-\n-    let all_constraints =\n-        ia.outputs.iter().map(|out| out.constraint.to_string())\n-          .chain(ia.inputs.iter().map(|s| s.to_string()))\n-          .chain(ext_constraints)\n-          .chain(clobbers)\n-          .chain(arch_clobbers.iter().map(|s| s.to_string()))\n-          .collect::<Vec<String>>().join(\",\");\n-\n-    debug!(\"Asm Constraints: {}\", &all_constraints);\n-\n-    // Depending on how many outputs we have, the return type is different\n-    let num_outputs = output_types.len();\n-    let output_type = match num_outputs {\n-        0 => Type::void(bx.cx),\n-        1 => output_types[0],\n-        _ => Type::struct_(bx.cx, &output_types, false)\n-    };\n-\n-    let dialect = match ia.dialect {\n-        AsmDialect::Att   => llvm::AsmDialect::Att,\n-        AsmDialect::Intel => llvm::AsmDialect::Intel,\n-    };\n-\n-    let asm = CString::new(ia.asm.as_str().as_bytes()).unwrap();\n-    let constraint_cstr = CString::new(all_constraints).unwrap();\n-    let r = bx.inline_asm_call(\n-        asm.as_ptr(),\n-        constraint_cstr.as_ptr(),\n-        &inputs,\n-        output_type,\n-        ia.volatile,\n-        ia.alignstack,\n-        dialect\n-    );\n-    if r.is_none() {\n-        return false;\n-    }\n-    let r = r.unwrap();\n+        let clobbers = ia.clobbers.iter()\n+                                  .map(|s| format!(\"~{{{}}}\", &s));\n+\n+        // Default per-arch clobbers\n+        // Basically what clang does\n+        let arch_clobbers = match &self.cx().sess().target.target.arch[..] {\n+            \"x86\" | \"x86_64\"  => vec![\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"],\n+            \"mips\" | \"mips64\" => vec![\"~{$1}\"],\n+            _                 => Vec::new()\n+        };\n+\n+        let all_constraints =\n+            ia.outputs.iter().map(|out| out.constraint.to_string())\n+              .chain(ia.inputs.iter().map(|s| s.to_string()))\n+              .chain(ext_constraints)\n+              .chain(clobbers)\n+              .chain(arch_clobbers.iter().map(|s| s.to_string()))\n+              .collect::<Vec<String>>().join(\",\");\n+\n+        debug!(\"Asm Constraints: {}\", &all_constraints);\n+\n+        // Depending on how many outputs we have, the return type is different\n+        let num_outputs = output_types.len();\n+        let output_type = match num_outputs {\n+            0 => self.cx().type_void(),\n+            1 => output_types[0],\n+            _ => self.cx().type_struct(&output_types, false)\n+        };\n+\n+        let asm = CString::new(ia.asm.as_str().as_bytes()).unwrap();\n+        let constraint_cstr = CString::new(all_constraints).unwrap();\n+        let r = self.inline_asm_call(\n+            &asm,\n+            &constraint_cstr,\n+            &inputs,\n+            output_type,\n+            ia.volatile,\n+            ia.alignstack,\n+            ia.dialect\n+        );\n+        if r.is_none() {\n+            return false;\n+        }\n+        let r = r.unwrap();\n \n-    // Again, based on how many outputs we have\n-    let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n-    for (i, (_, &place)) in outputs.enumerate() {\n-        let v = if num_outputs == 1 { r } else { bx.extract_value(r, i as u64) };\n-        OperandValue::Immediate(v).store(bx, place);\n-    }\n+        // Again, based on how many outputs we have\n+        let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n+        for (i, (_, &place)) in outputs.enumerate() {\n+            let v = if num_outputs == 1 { r } else { self.extract_value(r, i as u64) };\n+            OperandValue::Immediate(v).store(self, place);\n+        }\n \n-    // Store mark in a metadata node so we can map LLVM errors\n-    // back to source locations.  See #17552.\n-    unsafe {\n-        let key = \"srcloc\";\n-        let kind = llvm::LLVMGetMDKindIDInContext(bx.cx.llcx,\n-            key.as_ptr() as *const c_char, key.len() as c_uint);\n+        // Store mark in a metadata node so we can map LLVM errors\n+        // back to source locations.  See #17552.\n+        unsafe {\n+            let key = \"srcloc\";\n+            let kind = llvm::LLVMGetMDKindIDInContext(self.cx().llcx,\n+                key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-        let val: &'ll Value = C_i32(bx.cx, ia.ctxt.outer().as_u32() as i32);\n+            let val: &'ll Value = self.cx().const_i32(ia.ctxt.outer().as_u32() as i32);\n \n-        llvm::LLVMSetMetadata(r, kind,\n-            llvm::LLVMMDNodeInContext(bx.cx.llcx, &val, 1));\n-    }\n+            llvm::LLVMSetMetadata(r, kind,\n+                llvm::LLVMMDNodeInContext(self.cx().llcx, &val, 1));\n+        }\n \n-    return true;\n+        true\n+    }\n }\n \n-pub fn codegen_global_asm<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                  ga: &hir::GlobalAsm) {\n-    let asm = CString::new(ga.asm.as_str().as_bytes()).unwrap();\n-    unsafe {\n-        llvm::LLVMRustAppendModuleInlineAsm(cx.llmod, asm.as_ptr());\n+impl AsmMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn codegen_global_asm(&self, ga: &hir::GlobalAsm) {\n+        let asm = CString::new(ga.asm.as_str().as_bytes()).unwrap();\n+        unsafe {\n+            llvm::LLVMRustAppendModuleInlineAsm(self.llmod, asm.as_ptr());\n+        }\n     }\n }"}, {"sha": "38ab1302cfa7cb5b525749a01fe30c9fedd38176", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -21,6 +21,7 @@ use rustc::ty::query::Providers;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_target::spec::PanicStrategy;\n+use rustc_codegen_ssa::traits::*;\n \n use attributes;\n use llvm::{self, Attribute};"}, {"sha": "76c50711639a4a10db73931dbedb64409465390d", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -18,6 +18,7 @@ use std::ptr;\n use std::str;\n \n use back::bytecode::RLIB_BYTECODE_EXTENSION;\n+use rustc_codegen_ssa::back::archive::find_library;\n use libc;\n use llvm::archive_ro::{ArchiveRO, Child};\n use llvm::{self, ArchiveKind};\n@@ -52,7 +53,6 @@ enum Addition {\n     },\n }\n \n-\n fn is_relevant_child(c: &Child) -> bool {\n     match c.name() {\n         Some(name) => !name.contains(\"SYMDEF\"),\n@@ -107,7 +107,7 @@ impl<'a> ArchiveBuilder<'a> {\n     /// Adds all of the contents of a native library to this archive. This will\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) {\n-        let location = ::rustc_codegen_utils::find_library(name, &self.config.lib_search_paths,\n+        let location = find_library(name, &self.config.lib_search_paths,\n                                     self.config.sess);\n         self.add_archive(&location, |_| false).unwrap_or_else(|e| {\n             self.config.sess.fatal(&format!(\"failed to add native library {}: {}\","}, {"sha": "20f05d110877a242184bbaa6a358a327ee0b21e9", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 11, "deletions": 187, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -9,9 +9,12 @@\n // except according to those terms.\n \n use back::wasm;\n-use cc::windows_registry;\n use super::archive::{ArchiveBuilder, ArchiveConfig};\n use super::bytecode::RLIB_BYTECODE_EXTENSION;\n+use rustc_codegen_ssa::back::linker::Linker;\n+use rustc_codegen_ssa::back::link::{remove, ignored_for_lto, each_linked_rlib, linker_and_flavor,\n+    get_linker};\n+use rustc_codegen_ssa::back::command::Command;\n use super::rpath::RPathConfig;\n use super::rpath;\n use metadata::METADATA_FILENAME;\n@@ -20,17 +23,15 @@ use rustc::session::config::{RUST_CGU_EXT, Lto};\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n-use rustc::middle::cstore::{NativeLibrary, LibSource, NativeLibraryKind};\n+use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind};\n use rustc::middle::dependency_format::Linkage;\n-use {CodegenResults, CrateInfo};\n+use rustc_codegen_ssa::CodegenResults;\n use rustc::util::common::time;\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc::hir::def_id::CrateNum;\n use tempfile::{Builder as TempFileBuilder, TempDir};\n use rustc_target::spec::{PanicStrategy, RelroLevel, LinkerFlavor};\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_codegen_utils::linker::Linker;\n-use rustc_codegen_utils::command::Command;\n use context::get_reloc_model;\n use llvm;\n \n@@ -50,69 +51,6 @@ pub use rustc_codegen_utils::link::{find_crate_name, filename_for_input, default\n                                     invalid_output_for_target, filename_for_metadata,\n                                     out_filename, check_file_is_writeable};\n \n-// The third parameter is for env vars, used on windows to set up the\n-// path for MSVC to find its DLLs, and gcc to find its bundled\n-// toolchain\n-pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathBuf, Command) {\n-    let msvc_tool = windows_registry::find_tool(&sess.opts.target_triple.triple(), \"link.exe\");\n-\n-    // If our linker looks like a batch script on Windows then to execute this\n-    // we'll need to spawn `cmd` explicitly. This is primarily done to handle\n-    // emscripten where the linker is `emcc.bat` and needs to be spawned as\n-    // `cmd /c emcc.bat ...`.\n-    //\n-    // This worked historically but is needed manually since #42436 (regression\n-    // was tagged as #42791) and some more info can be found on #44443 for\n-    // emscripten itself.\n-    let mut cmd = match linker.to_str() {\n-        Some(linker) if cfg!(windows) && linker.ends_with(\".bat\") => Command::bat_script(linker),\n-        _ => match flavor {\n-            LinkerFlavor::Lld(f) => Command::lld(linker, f),\n-            LinkerFlavor::Msvc\n-                if sess.opts.cg.linker.is_none() && sess.target.target.options.linker.is_none() =>\n-            {\n-                Command::new(msvc_tool.as_ref().map(|t| t.path()).unwrap_or(linker))\n-            },\n-            _ => Command::new(linker),\n-        }\n-    };\n-\n-    // The compiler's sysroot often has some bundled tools, so add it to the\n-    // PATH for the child.\n-    let mut new_path = sess.host_filesearch(PathKind::All)\n-                           .get_tools_search_paths();\n-    let mut msvc_changed_path = false;\n-    if sess.target.target.options.is_like_msvc {\n-        if let Some(ref tool) = msvc_tool {\n-            cmd.args(tool.args());\n-            for &(ref k, ref v) in tool.env() {\n-                if k == \"PATH\" {\n-                    new_path.extend(env::split_paths(v));\n-                    msvc_changed_path = true;\n-                } else {\n-                    cmd.env(k, v);\n-                }\n-            }\n-        }\n-    }\n-\n-    if !msvc_changed_path {\n-        if let Some(path) = env::var_os(\"PATH\") {\n-            new_path.extend(env::split_paths(&path));\n-        }\n-    }\n-    cmd.env(\"PATH\", env::join_paths(new_path).unwrap());\n-\n-    (linker.to_path_buf(), cmd)\n-}\n-\n-pub fn remove(sess: &Session, path: &Path) {\n-    if let Err(e) = fs::remove_file(path) {\n-        sess.err(&format!(\"failed to remove {}: {}\",\n-                          path.display(),\n-                          e));\n-    }\n-}\n \n /// Perform the linkage portion of the compilation phase. This will generate all\n /// of the requested outputs for this compilation session.\n@@ -214,60 +152,6 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n     false\n }\n \n-pub(crate) fn each_linked_rlib(sess: &Session,\n-                               info: &CrateInfo,\n-                               f: &mut dyn FnMut(CrateNum, &Path)) -> Result<(), String> {\n-    let crates = info.used_crates_static.iter();\n-    let fmts = sess.dependency_formats.borrow();\n-    let fmts = fmts.get(&config::CrateType::Executable)\n-                   .or_else(|| fmts.get(&config::CrateType::Staticlib))\n-                   .or_else(|| fmts.get(&config::CrateType::Cdylib))\n-                   .or_else(|| fmts.get(&config::CrateType::ProcMacro));\n-    let fmts = match fmts {\n-        Some(f) => f,\n-        None => return Err(\"could not find formats for rlibs\".to_string())\n-    };\n-    for &(cnum, ref path) in crates {\n-        match fmts.get(cnum.as_usize() - 1) {\n-            Some(&Linkage::NotLinked) |\n-            Some(&Linkage::IncludedFromDylib) => continue,\n-            Some(_) => {}\n-            None => return Err(\"could not find formats for rlibs\".to_string())\n-        }\n-        let name = &info.crate_name[&cnum];\n-        let path = match *path {\n-            LibSource::Some(ref p) => p,\n-            LibSource::MetadataOnly => {\n-                return Err(format!(\"could not find rlib for: `{}`, found rmeta (metadata) file\",\n-                                   name))\n-            }\n-            LibSource::None => {\n-                return Err(format!(\"could not find rlib for: `{}`\", name))\n-            }\n-        };\n-        f(cnum, &path);\n-    }\n-    Ok(())\n-}\n-\n-/// Returns a boolean indicating whether the specified crate should be ignored\n-/// during LTO.\n-///\n-/// Crates ignored during LTO are not lumped together in the \"massive object\n-/// file\" that we create and are linked in their normal rlib states. See\n-/// comments below for what crates do not participate in LTO.\n-///\n-/// It's unusual for a crate to not participate in LTO. Typically only\n-/// compiler-specific and unstable crates have a reason to not participate in\n-/// LTO.\n-pub(crate) fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum) -> bool {\n-    // If our target enables builtin function lowering in LLVM then the\n-    // crates providing these functions don't participate in LTO (e.g.\n-    // no_builtins or compiler builtins crates).\n-    !sess.target.target.options.no_builtins &&\n-        (info.compiler_builtins == Some(cnum) || info.is_no_builtins.contains(&cnum))\n-}\n-\n fn link_binary_output(sess: &Session,\n                       codegen_results: &CodegenResults,\n                       crate_type: config::CrateType,\n@@ -352,8 +236,11 @@ fn archive_config<'a>(sess: &'a Session,\n /// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n /// directory being searched for `extern crate` (observing an incomplete file).\n /// The returned path is the temporary file containing the complete metadata.\n-fn emit_metadata<'a>(sess: &'a Session, codegen_results: &CodegenResults, tmpdir: &TempDir)\n-                     -> PathBuf {\n+fn emit_metadata<'a>(\n+    sess: &'a Session,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &TempDir\n+) -> PathBuf {\n     let out_filename = tmpdir.path().join(METADATA_FILENAME);\n     let result = fs::write(&out_filename, &codegen_results.metadata.raw_data);\n \n@@ -575,69 +462,6 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n     }\n }\n \n-pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n-    fn infer_from(\n-        sess: &Session,\n-        linker: Option<PathBuf>,\n-        flavor: Option<LinkerFlavor>,\n-    ) -> Option<(PathBuf, LinkerFlavor)> {\n-        match (linker, flavor) {\n-            (Some(linker), Some(flavor)) => Some((linker, flavor)),\n-            // only the linker flavor is known; use the default linker for the selected flavor\n-            (None, Some(flavor)) => Some((PathBuf::from(match flavor {\n-                LinkerFlavor::Em  => if cfg!(windows) { \"emcc.bat\" } else { \"emcc\" },\n-                LinkerFlavor::Gcc => \"cc\",\n-                LinkerFlavor::Ld => \"ld\",\n-                LinkerFlavor::Msvc => \"link.exe\",\n-                LinkerFlavor::Lld(_) => \"lld\",\n-            }), flavor)),\n-            (Some(linker), None) => {\n-                let stem = linker.file_stem().and_then(|stem| stem.to_str()).unwrap_or_else(|| {\n-                    sess.fatal(\"couldn't extract file stem from specified linker\");\n-                }).to_owned();\n-\n-                let flavor = if stem == \"emcc\" {\n-                    LinkerFlavor::Em\n-                } else if stem == \"gcc\" || stem.ends_with(\"-gcc\") {\n-                    LinkerFlavor::Gcc\n-                } else if stem == \"ld\" || stem == \"ld.lld\" || stem.ends_with(\"-ld\") {\n-                    LinkerFlavor::Ld\n-                } else if stem == \"link\" || stem == \"lld-link\" {\n-                    LinkerFlavor::Msvc\n-                } else if stem == \"lld\" || stem == \"rust-lld\" {\n-                    LinkerFlavor::Lld(sess.target.target.options.lld_flavor)\n-                } else {\n-                    // fall back to the value in the target spec\n-                    sess.target.target.linker_flavor\n-                };\n-\n-                Some((linker, flavor))\n-            },\n-            (None, None) => None,\n-        }\n-    }\n-\n-    // linker and linker flavor specified via command line have precedence over what the target\n-    // specification specifies\n-    if let Some(ret) = infer_from(\n-        sess,\n-        sess.opts.cg.linker.clone(),\n-        sess.opts.debugging_opts.linker_flavor,\n-    ) {\n-        return ret;\n-    }\n-\n-    if let Some(ret) = infer_from(\n-        sess,\n-        sess.target.target.options.linker.clone().map(PathBuf::from),\n-        Some(sess.target.target.linker_flavor),\n-    ) {\n-        return ret;\n-    }\n-\n-    bug!(\"Not enough information provided to determine how to invoke the linker\");\n-}\n-\n // Create a dynamic library or executable\n //\n // This will invoke the system linker/cc to create the resulting file. This"}, {"sha": "b5ebd0409da38f68021e1ce442e2a1261a6fa662", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 169, "deletions": 265, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -9,23 +9,24 @@\n // except according to those terms.\n \n use back::bytecode::{DecodedBytecode, RLIB_BYTECODE_EXTENSION};\n-use back::write::{ModuleConfig, with_llvm_pmb, CodegenContext};\n-use back::write::{self, DiagnosticHandlers, pre_lto_bitcode_filename};\n+use rustc_codegen_ssa::back::symbol_export;\n+use rustc_codegen_ssa::back::write::{ModuleConfig, CodegenContext, pre_lto_bitcode_filename};\n+use rustc_codegen_ssa::back::lto::{SerializedModule, LtoModuleCodegen, ThinShared, ThinModule};\n+use rustc_codegen_ssa::traits::*;\n+use back::write::{self, DiagnosticHandlers, with_llvm_pmb, save_temp_bitcode, get_llvm_opt_level};\n use errors::{FatalError, Handler};\n use llvm::archive_ro::ArchiveRO;\n-use llvm::{True, False};\n-use llvm;\n-use memmap;\n+use llvm::{self, True, False};\n use rustc::dep_graph::WorkProduct;\n use rustc::dep_graph::cgu_reuse_tracker::CguReuse;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config::{self, Lto};\n use rustc::util::common::time_ext;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_codegen_utils::symbol_export;\n use time_graph::Timeline;\n-use {ModuleCodegen, ModuleLlvm, ModuleKind};\n+use {ModuleLlvm, LlvmCodegenBackend};\n+use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n \n use libc;\n \n@@ -47,71 +48,16 @@ pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n     }\n }\n \n-pub(crate) enum LtoModuleCodegen {\n-    Fat {\n-        module: Option<ModuleCodegen>,\n-        _serialized_bitcode: Vec<SerializedModule>,\n-    },\n-\n-    Thin(ThinModule),\n-}\n-\n-impl LtoModuleCodegen {\n-    pub fn name(&self) -> &str {\n-        match *self {\n-            LtoModuleCodegen::Fat { .. } => \"everything\",\n-            LtoModuleCodegen::Thin(ref m) => m.name(),\n-        }\n-    }\n-\n-    /// Optimize this module within the given codegen context.\n-    ///\n-    /// This function is unsafe as it'll return a `ModuleCodegen` still\n-    /// points to LLVM data structures owned by this `LtoModuleCodegen`.\n-    /// It's intended that the module returned is immediately code generated and\n-    /// dropped, and then this LTO module is dropped.\n-    pub(crate) unsafe fn optimize(&mut self,\n-                                  cgcx: &CodegenContext,\n-                                  timeline: &mut Timeline)\n-        -> Result<ModuleCodegen, FatalError>\n-    {\n-        match *self {\n-            LtoModuleCodegen::Fat { ref mut module, .. } => {\n-                let module = module.take().unwrap();\n-                {\n-                    let config = cgcx.config(module.kind);\n-                    let llmod = module.module_llvm.llmod();\n-                    let tm = &*module.module_llvm.tm;\n-                    run_pass_manager(cgcx, tm, llmod, config, false);\n-                    timeline.record(\"fat-done\");\n-                }\n-                Ok(module)\n-            }\n-            LtoModuleCodegen::Thin(ref mut thin) => thin.optimize(cgcx, timeline),\n-        }\n-    }\n-\n-    /// A \"gauge\" of how costly it is to optimize this module, used to sort\n-    /// biggest modules first.\n-    pub fn cost(&self) -> u64 {\n-        match *self {\n-            // Only one module with fat LTO, so the cost doesn't matter.\n-            LtoModuleCodegen::Fat { .. } => 0,\n-            LtoModuleCodegen::Thin(ref m) => m.cost(),\n-        }\n-    }\n-}\n-\n /// Performs LTO, which in the case of full LTO means merging all modules into\n /// a single one and returning it for further optimizing. For ThinLTO, it will\n /// do the global analysis necessary and return two lists, one of the modules\n /// the need optimization and another for modules that can simply be copied over\n /// from the incr. comp. cache.\n-pub(crate) fn run(cgcx: &CodegenContext,\n-                  modules: Vec<ModuleCodegen>,\n-                  cached_modules: Vec<(SerializedModule, WorkProduct)>,\n+pub(crate) fn run(cgcx: &CodegenContext<LlvmCodegenBackend>,\n+                  modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+                  cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n                   timeline: &mut Timeline)\n-    -> Result<(Vec<LtoModuleCodegen>, Vec<WorkProduct>), FatalError>\n+    -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError>\n {\n     let diag_handler = cgcx.create_diag_handler();\n     let export_threshold = match cgcx.lto {\n@@ -230,13 +176,13 @@ pub(crate) fn run(cgcx: &CodegenContext,\n     }\n }\n \n-fn fat_lto(cgcx: &CodegenContext,\n+fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n            diag_handler: &Handler,\n-           mut modules: Vec<ModuleCodegen>,\n-           mut serialized_modules: Vec<(SerializedModule, CString)>,\n+           mut modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+           mut serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n            symbol_white_list: &[*const libc::c_char],\n            timeline: &mut Timeline)\n-    -> Result<Vec<LtoModuleCodegen>, FatalError>\n+    -> Result<Vec<LtoModuleCodegen<LlvmCodegenBackend>>, FatalError>\n {\n     info!(\"going for a fat lto\");\n \n@@ -303,7 +249,7 @@ fn fat_lto(cgcx: &CodegenContext,\n             serialized_bitcode.push(bc_decoded);\n         }\n         drop(linker);\n-        cgcx.save_temp_bitcode(&module, \"lto.input\");\n+        save_temp_bitcode(&cgcx, &module, \"lto.input\");\n \n         // Internalize everything that *isn't* in our whitelist to help strip out\n         // more modules and such\n@@ -312,14 +258,14 @@ fn fat_lto(cgcx: &CodegenContext,\n             llvm::LLVMRustRunRestrictionPass(llmod,\n                                              ptr as *const *const libc::c_char,\n                                              symbol_white_list.len() as libc::size_t);\n-            cgcx.save_temp_bitcode(&module, \"lto.after-restriction\");\n+            save_temp_bitcode(&cgcx, &module, \"lto.after-restriction\");\n         }\n \n         if cgcx.no_landing_pads {\n             unsafe {\n                 llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n             }\n-            cgcx.save_temp_bitcode(&module, \"lto.after-nounwind\");\n+            save_temp_bitcode(&cgcx, &module, \"lto.after-nounwind\");\n         }\n         timeline.record(\"passes\");\n     }\n@@ -386,14 +332,14 @@ impl Drop for Linker<'a> {\n /// calculating the *index* for ThinLTO. This index will then be shared amongst\n /// all of the `LtoModuleCodegen` units returned below and destroyed once\n /// they all go out of scope.\n-fn thin_lto(cgcx: &CodegenContext,\n+fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             diag_handler: &Handler,\n-            modules: Vec<ModuleCodegen>,\n-            serialized_modules: Vec<(SerializedModule, CString)>,\n-            cached_modules: Vec<(SerializedModule, WorkProduct)>,\n+            modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+            serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n+            cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n             symbol_white_list: &[*const libc::c_char],\n             timeline: &mut Timeline)\n-    -> Result<(Vec<LtoModuleCodegen>, Vec<WorkProduct>), FatalError>\n+    -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError>\n {\n     unsafe {\n         info!(\"going for that thin, thin LTO\");\n@@ -556,9 +502,8 @@ fn thin_lto(cgcx: &CodegenContext,\n     }\n }\n \n-fn run_pass_manager(cgcx: &CodegenContext,\n-                    tm: &llvm::TargetMachine,\n-                    llmod: &llvm::Module,\n+pub(crate) fn run_pass_manager(cgcx: &CodegenContext<LlvmCodegenBackend>,\n+                    module: &ModuleCodegen<ModuleLlvm>,\n                     config: &ModuleConfig,\n                     thin: bool) {\n     // Now we have one massive module inside of llmod. Time to run the\n@@ -569,7 +514,7 @@ fn run_pass_manager(cgcx: &CodegenContext,\n     debug!(\"running the pass manager\");\n     unsafe {\n         let pm = llvm::LLVMCreatePassManager();\n-        llvm::LLVMRustAddAnalysisPasses(tm, pm, llmod);\n+        llvm::LLVMRustAddAnalysisPasses(module.module_llvm.tm, pm, module.module_llvm.llmod());\n \n         if config.verify_llvm_ir {\n             let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr() as *const _);\n@@ -588,12 +533,13 @@ fn run_pass_manager(cgcx: &CodegenContext,\n         // Note that in general this shouldn't matter too much as you typically\n         // only turn on ThinLTO when you're compiling with optimizations\n         // otherwise.\n-        let opt_level = config.opt_level.unwrap_or(llvm::CodeGenOptLevel::None);\n+        let opt_level = config.opt_level.map(get_llvm_opt_level)\n+            .unwrap_or(llvm::CodeGenOptLevel::None);\n         let opt_level = match opt_level {\n             llvm::CodeGenOptLevel::None => llvm::CodeGenOptLevel::Less,\n             level => level,\n         };\n-        with_llvm_pmb(llmod, config, opt_level, false, &mut |b| {\n+        with_llvm_pmb(module.module_llvm.llmod(), config, opt_level, false, &mut |b| {\n             if thin {\n                 llvm::LLVMRustPassManagerBuilderPopulateThinLTOPassManager(b, pm);\n             } else {\n@@ -615,29 +561,14 @@ fn run_pass_manager(cgcx: &CodegenContext,\n             llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n-        time_ext(cgcx.time_passes, None, \"LTO passes\", || llvm::LLVMRunPassManager(pm, llmod));\n+        time_ext(cgcx.time_passes, None, \"LTO passes\", ||\n+             llvm::LLVMRunPassManager(pm, module.module_llvm.llmod()));\n \n         llvm::LLVMDisposePassManager(pm);\n     }\n     debug!(\"lto done\");\n }\n \n-pub enum SerializedModule {\n-    Local(ModuleBuffer),\n-    FromRlib(Vec<u8>),\n-    FromUncompressedFile(memmap::Mmap),\n-}\n-\n-impl SerializedModule {\n-    fn data(&self) -> &[u8] {\n-        match *self {\n-            SerializedModule::Local(ref m) => m.data(),\n-            SerializedModule::FromRlib(ref m) => m,\n-            SerializedModule::FromUncompressedFile(ref m) => m,\n-        }\n-    }\n-}\n-\n pub struct ModuleBuffer(&'static mut llvm::ModuleBuffer);\n \n unsafe impl Send for ModuleBuffer {}\n@@ -649,8 +580,10 @@ impl ModuleBuffer {\n             llvm::LLVMRustModuleBufferCreate(m)\n         })\n     }\n+}\n \n-    pub fn data(&self) -> &[u8] {\n+impl ModuleBufferMethods for ModuleBuffer {\n+    fn data(&self) -> &[u8] {\n         unsafe {\n             let ptr = llvm::LLVMRustModuleBufferPtr(self.0);\n             let len = llvm::LLVMRustModuleBufferLen(self.0);\n@@ -665,19 +598,7 @@ impl Drop for ModuleBuffer {\n     }\n }\n \n-pub struct ThinModule {\n-    shared: Arc<ThinShared>,\n-    idx: usize,\n-}\n-\n-struct ThinShared {\n-    data: ThinData,\n-    thin_buffers: Vec<ThinBuffer>,\n-    serialized_modules: Vec<SerializedModule>,\n-    module_names: Vec<CString>,\n-}\n-\n-struct ThinData(&'static mut llvm::ThinLTOData);\n+pub struct ThinData(&'static mut llvm::ThinLTOData);\n \n unsafe impl Send for ThinData {}\n unsafe impl Sync for ThinData {}\n@@ -702,8 +623,10 @@ impl ThinBuffer {\n             ThinBuffer(buffer)\n         }\n     }\n+}\n \n-    pub fn data(&self) -> &[u8] {\n+impl ThinBufferMethods for ThinBuffer {\n+    fn data(&self) -> &[u8] {\n         unsafe {\n             let ptr = llvm::LLVMRustThinLTOBufferPtr(self.0) as *const _;\n             let len = llvm::LLVMRustThinLTOBufferLen(self.0);\n@@ -720,161 +643,142 @@ impl Drop for ThinBuffer {\n     }\n }\n \n-impl ThinModule {\n-    fn name(&self) -> &str {\n-        self.shared.module_names[self.idx].to_str().unwrap()\n-    }\n-\n-    fn cost(&self) -> u64 {\n-        // Yes, that's correct, we're using the size of the bytecode as an\n-        // indicator for how costly this codegen unit is.\n-        self.data().len() as u64\n-    }\n-\n-    fn data(&self) -> &[u8] {\n-        let a = self.shared.thin_buffers.get(self.idx).map(|b| b.data());\n-        a.unwrap_or_else(|| {\n-            let len = self.shared.thin_buffers.len();\n-            self.shared.serialized_modules[self.idx - len].data()\n-        })\n-    }\n-\n-    unsafe fn optimize(&mut self, cgcx: &CodegenContext, timeline: &mut Timeline)\n-        -> Result<ModuleCodegen, FatalError>\n-    {\n-        let diag_handler = cgcx.create_diag_handler();\n-        let tm = (cgcx.tm_factory)().map_err(|e| {\n-            write::llvm_err(&diag_handler, &e)\n-        })?;\n-\n-        // Right now the implementation we've got only works over serialized\n-        // modules, so we create a fresh new LLVM context and parse the module\n-        // into that context. One day, however, we may do this for upstream\n-        // crates but for locally codegened modules we may be able to reuse\n-        // that LLVM Context and Module.\n-        let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n-        let llmod_raw = llvm::LLVMRustParseBitcodeForThinLTO(\n+pub unsafe fn optimize_thin_module(\n+    thin_module: &mut ThinModule<LlvmCodegenBackend>,\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    timeline: &mut Timeline\n+) -> Result<ModuleCodegen<ModuleLlvm>, FatalError> {\n+    let diag_handler = cgcx.create_diag_handler();\n+    let tm = (cgcx.tm_factory.0)().map_err(|e| {\n+        write::llvm_err(&diag_handler, &e)\n+    })?;\n+\n+    // Right now the implementation we've got only works over serialized\n+    // modules, so we create a fresh new LLVM context and parse the module\n+    // into that context. One day, however, we may do this for upstream\n+    // crates but for locally codegened modules we may be able to reuse\n+    // that LLVM Context and Module.\n+    let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n+    let llmod_raw = llvm::LLVMRustParseBitcodeForThinLTO(\n+        llcx,\n+        thin_module.data().as_ptr(),\n+        thin_module.data().len(),\n+        thin_module.shared.module_names[thin_module.idx].as_ptr(),\n+    ).ok_or_else(|| {\n+        let msg = \"failed to parse bitcode for thin LTO module\";\n+        write::llvm_err(&diag_handler, msg)\n+    })? as *const _;\n+    let module = ModuleCodegen {\n+        module_llvm: ModuleLlvm {\n+            llmod_raw,\n             llcx,\n-            self.data().as_ptr(),\n-            self.data().len(),\n-            self.shared.module_names[self.idx].as_ptr(),\n-        ).ok_or_else(|| {\n-            let msg = \"failed to parse bitcode for thin LTO module\";\n-            write::llvm_err(&diag_handler, msg)\n-        })? as *const _;\n-        let module = ModuleCodegen {\n-            module_llvm: ModuleLlvm {\n-                llmod_raw,\n-                llcx,\n-                tm,\n-            },\n-            name: self.name().to_string(),\n-            kind: ModuleKind::Regular,\n-        };\n-        {\n-            let llmod = module.module_llvm.llmod();\n-            cgcx.save_temp_bitcode(&module, \"thin-lto-input\");\n-\n-            // Before we do much else find the \"main\" `DICompileUnit` that we'll be\n-            // using below. If we find more than one though then rustc has changed\n-            // in a way we're not ready for, so generate an ICE by returning\n-            // an error.\n-            let mut cu1 = ptr::null_mut();\n-            let mut cu2 = ptr::null_mut();\n-            llvm::LLVMRustThinLTOGetDICompileUnit(llmod, &mut cu1, &mut cu2);\n-            if !cu2.is_null() {\n-                let msg = \"multiple source DICompileUnits found\";\n-                return Err(write::llvm_err(&diag_handler, msg))\n-            }\n+            tm,\n+        },\n+        name: thin_module.name().to_string(),\n+        kind: ModuleKind::Regular,\n+    };\n+    {\n+        let llmod = module.module_llvm.llmod();\n+        save_temp_bitcode(&cgcx, &module, \"thin-lto-input\");\n+\n+        // Before we do much else find the \"main\" `DICompileUnit` that we'll be\n+        // using below. If we find more than one though then rustc has changed\n+        // in a way we're not ready for, so generate an ICE by returning\n+        // an error.\n+        let mut cu1 = ptr::null_mut();\n+        let mut cu2 = ptr::null_mut();\n+        llvm::LLVMRustThinLTOGetDICompileUnit(llmod, &mut cu1, &mut cu2);\n+        if !cu2.is_null() {\n+            let msg = \"multiple source DICompileUnits found\";\n+            return Err(write::llvm_err(&diag_handler, msg))\n+        }\n \n-            // Like with \"fat\" LTO, get some better optimizations if landing pads\n-            // are disabled by removing all landing pads.\n-            if cgcx.no_landing_pads {\n-                llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n-                cgcx.save_temp_bitcode(&module, \"thin-lto-after-nounwind\");\n-                timeline.record(\"nounwind\");\n-            }\n+        // Like with \"fat\" LTO, get some better optimizations if landing pads\n+        // are disabled by removing all landing pads.\n+        if cgcx.no_landing_pads {\n+            llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n+            save_temp_bitcode(&cgcx, &module, \"thin-lto-after-nounwind\");\n+            timeline.record(\"nounwind\");\n+        }\n \n-            // Up next comes the per-module local analyses that we do for Thin LTO.\n-            // Each of these functions is basically copied from the LLVM\n-            // implementation and then tailored to suit this implementation. Ideally\n-            // each of these would be supported by upstream LLVM but that's perhaps\n-            // a patch for another day!\n-            //\n-            // You can find some more comments about these functions in the LLVM\n-            // bindings we've got (currently `PassWrapper.cpp`)\n-            if !llvm::LLVMRustPrepareThinLTORename(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\";\n-                return Err(write::llvm_err(&diag_handler, msg))\n-            }\n-            cgcx.save_temp_bitcode(&module, \"thin-lto-after-rename\");\n-            timeline.record(\"rename\");\n-            if !llvm::LLVMRustPrepareThinLTOResolveWeak(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\";\n-                return Err(write::llvm_err(&diag_handler, msg))\n-            }\n-            cgcx.save_temp_bitcode(&module, \"thin-lto-after-resolve\");\n-            timeline.record(\"resolve\");\n-            if !llvm::LLVMRustPrepareThinLTOInternalize(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\";\n-                return Err(write::llvm_err(&diag_handler, msg))\n-            }\n-            cgcx.save_temp_bitcode(&module, \"thin-lto-after-internalize\");\n-            timeline.record(\"internalize\");\n-            if !llvm::LLVMRustPrepareThinLTOImport(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\";\n-                return Err(write::llvm_err(&diag_handler, msg))\n-            }\n-            cgcx.save_temp_bitcode(&module, \"thin-lto-after-import\");\n-            timeline.record(\"import\");\n-\n-            // Ok now this is a bit unfortunate. This is also something you won't\n-            // find upstream in LLVM's ThinLTO passes! This is a hack for now to\n-            // work around bugs in LLVM.\n-            //\n-            // First discovered in #45511 it was found that as part of ThinLTO\n-            // importing passes LLVM will import `DICompileUnit` metadata\n-            // information across modules. This means that we'll be working with one\n-            // LLVM module that has multiple `DICompileUnit` instances in it (a\n-            // bunch of `llvm.dbg.cu` members). Unfortunately there's a number of\n-            // bugs in LLVM's backend which generates invalid DWARF in a situation\n-            // like this:\n-            //\n-            //  https://bugs.llvm.org/show_bug.cgi?id=35212\n-            //  https://bugs.llvm.org/show_bug.cgi?id=35562\n-            //\n-            // While the first bug there is fixed the second ended up causing #46346\n-            // which was basically a resurgence of #45511 after LLVM's bug 35212 was\n-            // fixed.\n-            //\n-            // This function below is a huge hack around this problem. The function\n-            // below is defined in `PassWrapper.cpp` and will basically \"merge\"\n-            // all `DICompileUnit` instances in a module. Basically it'll take all\n-            // the objects, rewrite all pointers of `DISubprogram` to point to the\n-            // first `DICompileUnit`, and then delete all the other units.\n-            //\n-            // This is probably mangling to the debug info slightly (but hopefully\n-            // not too much) but for now at least gets LLVM to emit valid DWARF (or\n-            // so it appears). Hopefully we can remove this once upstream bugs are\n-            // fixed in LLVM.\n-            llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n-            cgcx.save_temp_bitcode(&module, \"thin-lto-after-patch\");\n-            timeline.record(\"patch\");\n-\n-            // Alright now that we've done everything related to the ThinLTO\n-            // analysis it's time to run some optimizations! Here we use the same\n-            // `run_pass_manager` as the \"fat\" LTO above except that we tell it to\n-            // populate a thin-specific pass manager, which presumably LLVM treats a\n-            // little differently.\n-            info!(\"running thin lto passes over {}\", module.name);\n-            let config = cgcx.config(module.kind);\n-            run_pass_manager(cgcx, module.module_llvm.tm, llmod, config, true);\n-            cgcx.save_temp_bitcode(&module, \"thin-lto-after-pm\");\n-            timeline.record(\"thin-done\");\n+        // Up next comes the per-module local analyses that we do for Thin LTO.\n+        // Each of these functions is basically copied from the LLVM\n+        // implementation and then tailored to suit this implementation. Ideally\n+        // each of these would be supported by upstream LLVM but that's perhaps\n+        // a patch for another day!\n+        //\n+        // You can find some more comments about these functions in the LLVM\n+        // bindings we've got (currently `PassWrapper.cpp`)\n+        if !llvm::LLVMRustPrepareThinLTORename(thin_module.shared.data.0, llmod) {\n+            let msg = \"failed to prepare thin LTO module\";\n+            return Err(write::llvm_err(&diag_handler, msg))\n         }\n+        save_temp_bitcode(cgcx, &module, \"thin-lto-after-rename\");\n+        timeline.record(\"rename\");\n+        if !llvm::LLVMRustPrepareThinLTOResolveWeak(thin_module.shared.data.0, llmod) {\n+            let msg = \"failed to prepare thin LTO module\";\n+            return Err(write::llvm_err(&diag_handler, msg))\n+        }\n+        save_temp_bitcode(cgcx, &module, \"thin-lto-after-resolve\");\n+        timeline.record(\"resolve\");\n+        if !llvm::LLVMRustPrepareThinLTOInternalize(thin_module.shared.data.0, llmod) {\n+            let msg = \"failed to prepare thin LTO module\";\n+            return Err(write::llvm_err(&diag_handler, msg))\n+        }\n+        save_temp_bitcode(cgcx, &module, \"thin-lto-after-internalize\");\n+        timeline.record(\"internalize\");\n+        if !llvm::LLVMRustPrepareThinLTOImport(thin_module.shared.data.0, llmod) {\n+            let msg = \"failed to prepare thin LTO module\";\n+            return Err(write::llvm_err(&diag_handler, msg))\n+        }\n+        save_temp_bitcode(cgcx, &module, \"thin-lto-after-import\");\n+        timeline.record(\"import\");\n \n-        Ok(module)\n+        // Ok now this is a bit unfortunate. This is also something you won't\n+        // find upstream in LLVM's ThinLTO passes! This is a hack for now to\n+        // work around bugs in LLVM.\n+        //\n+        // First discovered in #45511 it was found that as part of ThinLTO\n+        // importing passes LLVM will import `DICompileUnit` metadata\n+        // information across modules. This means that we'll be working with one\n+        // LLVM module that has multiple `DICompileUnit` instances in it (a\n+        // bunch of `llvm.dbg.cu` members). Unfortunately there's a number of\n+        // bugs in LLVM's backend which generates invalid DWARF in a situation\n+        // like this:\n+        //\n+        //  https://bugs.llvm.org/show_bug.cgi?id=35212\n+        //  https://bugs.llvm.org/show_bug.cgi?id=35562\n+        //\n+        // While the first bug there is fixed the second ended up causing #46346\n+        // which was basically a resurgence of #45511 after LLVM's bug 35212 was\n+        // fixed.\n+        //\n+        // This function below is a huge hack around this problem. The function\n+        // below is defined in `PassWrapper.cpp` and will basically \"merge\"\n+        // all `DICompileUnit` instances in a module. Basically it'll take all\n+        // the objects, rewrite all pointers of `DISubprogram` to point to the\n+        // first `DICompileUnit`, and then delete all the other units.\n+        //\n+        // This is probably mangling to the debug info slightly (but hopefully\n+        // not too much) but for now at least gets LLVM to emit valid DWARF (or\n+        // so it appears). Hopefully we can remove this once upstream bugs are\n+        // fixed in LLVM.\n+        llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n+        save_temp_bitcode(cgcx, &module, \"thin-lto-after-patch\");\n+        timeline.record(\"patch\");\n+\n+        // Alright now that we've done everything related to the ThinLTO\n+        // analysis it's time to run some optimizations! Here we use the same\n+        // `run_pass_manager` as the \"fat\" LTO above except that we tell it to\n+        // populate a thin-specific pass manager, which presumably LLVM treats a\n+        // little differently.\n+        info!(\"running thin lto passes over {}\", module.name);\n+        let config = cgcx.config(module.kind);\n+        run_pass_manager(cgcx, &module, config, true);\n+        save_temp_bitcode(cgcx, &module, \"thin-lto-after-pm\");\n+        timeline.record(\"thin-done\");\n     }\n+    Ok(module)\n }\n \n #[derive(Debug, Default)]"}, {"sha": "7945d381760a1b082a711014135b2948a5585ff4", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 50, "deletions": 1835, "changes": 1885, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -10,58 +10,35 @@\n \n use attributes;\n use back::bytecode::{self, RLIB_BYTECODE_EXTENSION};\n-use back::lto::{self, ThinBuffer, SerializedModule};\n-use back::link::{self, get_linker, remove};\n+use back::lto::ThinBuffer;\n+use rustc_codegen_ssa::back::write::{CodegenContext, ModuleConfig, run_assembler};\n+use rustc_codegen_ssa::traits::*;\n use base;\n use consts;\n-use memmap;\n-use rustc_incremental::{copy_cgu_workproducts_to_incr_comp_cache_dir,\n-                        in_incr_comp_dir, in_incr_comp_dir_sess};\n-use rustc::dep_graph::{WorkProduct, WorkProductId, WorkProductFileKind};\n-use rustc::dep_graph::cgu_reuse_tracker::CguReuseTracker;\n-use rustc::middle::cstore::EncodedMetadata;\n-use rustc::session::config::{self, OutputFilenames, OutputType, Passes, Sanitizer, Lto};\n+use rustc::session::config::{self, OutputType, Passes, Lto};\n use rustc::session::Session;\n-use rustc::util::nodemap::FxHashMap;\n-use time_graph::{self, TimeGraph, Timeline};\n+use time_graph::Timeline;\n use llvm::{self, DiagnosticInfo, PassManager, SMDiagnostic};\n use llvm_util;\n-use {CodegenResults, ModuleCodegen, CompiledModule, ModuleKind, // ModuleLlvm,\n-     CachedModuleCodegen};\n-use CrateInfo;\n-use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n-use rustc::ty::TyCtxt;\n-use rustc::util::common::{time_ext, time_depth, set_time_depth, print_time_passes_entry};\n+use ModuleLlvm;\n+use rustc_codegen_ssa::{ModuleCodegen, CompiledModule};\n+use rustc::util::common::time_ext;\n use rustc_fs_util::{path2cstr, link_or_copy};\n use rustc_data_structures::small_c_str::SmallCStr;\n-use rustc_data_structures::svh::Svh;\n-use rustc_codegen_utils::command::Command;\n-use rustc_codegen_utils::linker::LinkerInfo;\n-use rustc_codegen_utils::symbol_export::ExportedSymbols;\n-use errors::{self, Handler, Level, DiagnosticBuilder, FatalError, DiagnosticId};\n-use errors::emitter::{Emitter};\n-use syntax::attr;\n-use syntax::ext::hygiene::Mark;\n-use syntax_pos::MultiSpan;\n-use syntax_pos::symbol::Symbol;\n+use errors::{self, Handler, FatalError};\n use type_::Type;\n use context::{is_pie_binary, get_reloc_model};\n-use common::{C_bytes_in_context, val_ty};\n-use jobserver::{Client, Acquired};\n+use common;\n+use LlvmCodegenBackend;\n use rustc_demangle;\n \n-use std::any::Any;\n use std::ffi::{CString, CStr};\n use std::fs;\n use std::io::{self, Write};\n-use std::mem;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n use std::str;\n use std::sync::Arc;\n-use std::sync::mpsc::{channel, Sender, Receiver};\n use std::slice;\n-use std::time::Instant;\n-use std::thread;\n use libc::{c_uint, c_void, c_char, size_t};\n \n pub const RELOC_MODEL_ARGS : [(&str, llvm::RelocMode); 7] = [\n@@ -88,8 +65,6 @@ pub const TLS_MODEL_ARGS : [(&str, llvm::ThreadLocalMode); 4] = [\n     (\"local-exec\", llvm::ThreadLocalMode::LocalExec),\n ];\n \n-const PRE_THIN_LTO_BC_EXT: &str = \"pre-thin-lto.bc\";\n-\n pub fn llvm_err(handler: &errors::Handler, msg: &str) -> FatalError {\n     match llvm::last_error() {\n         Some(err) => handler.fatal(&format!(\"{}: {}\", msg, err)),\n@@ -116,7 +91,7 @@ pub fn write_output_file(\n     }\n }\n \n-fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n+pub(crate) fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n     match optimize {\n       config::OptLevel::No => llvm::CodeGenOptLevel::None,\n       config::OptLevel::Less => llvm::CodeGenOptLevel::Less,\n@@ -126,7 +101,7 @@ fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n     }\n }\n \n-fn get_llvm_opt_size(optimize: config::OptLevel) -> llvm::CodeGenOptSize {\n+pub(crate) fn get_llvm_opt_size(optimize: config::OptLevel) -> llvm::CodeGenOptSize {\n     match optimize {\n       config::OptLevel::Size => llvm::CodeGenOptSizeDefault,\n       config::OptLevel::SizeMin => llvm::CodeGenOptSizeAggressive,\n@@ -224,212 +199,31 @@ pub fn target_machine_factory(sess: &Session, find_features: bool)\n     })\n }\n \n-/// Module-specific configuration for `optimize_and_codegen`.\n-pub struct ModuleConfig {\n-    /// Names of additional optimization passes to run.\n-    passes: Vec<String>,\n-    /// Some(level) to optimize at a certain level, or None to run\n-    /// absolutely no optimizations (used for the metadata module).\n-    pub opt_level: Option<llvm::CodeGenOptLevel>,\n-\n-    /// Some(level) to optimize binary size, or None to not affect program size.\n-    opt_size: Option<llvm::CodeGenOptSize>,\n-\n-    pgo_gen: Option<String>,\n-    pgo_use: String,\n-\n-    // Flags indicating which outputs to produce.\n-    pub emit_pre_thin_lto_bc: bool,\n-    emit_no_opt_bc: bool,\n-    emit_bc: bool,\n-    emit_bc_compressed: bool,\n-    emit_lto_bc: bool,\n-    emit_ir: bool,\n-    emit_asm: bool,\n-    emit_obj: bool,\n-    // Miscellaneous flags.  These are mostly copied from command-line\n-    // options.\n-    pub verify_llvm_ir: bool,\n-    no_prepopulate_passes: bool,\n-    no_builtins: bool,\n-    time_passes: bool,\n-    vectorize_loop: bool,\n-    vectorize_slp: bool,\n-    merge_functions: bool,\n-    inline_threshold: Option<usize>,\n-    // Instead of creating an object file by doing LLVM codegen, just\n-    // make the object file bitcode. Provides easy compatibility with\n-    // emscripten's ecc compiler, when used as the linker.\n-    obj_is_bitcode: bool,\n-    no_integrated_as: bool,\n-    embed_bitcode: bool,\n-    embed_bitcode_marker: bool,\n-}\n-\n-impl ModuleConfig {\n-    fn new(passes: Vec<String>) -> ModuleConfig {\n-        ModuleConfig {\n-            passes,\n-            opt_level: None,\n-            opt_size: None,\n-\n-            pgo_gen: None,\n-            pgo_use: String::new(),\n-\n-            emit_no_opt_bc: false,\n-            emit_pre_thin_lto_bc: false,\n-            emit_bc: false,\n-            emit_bc_compressed: false,\n-            emit_lto_bc: false,\n-            emit_ir: false,\n-            emit_asm: false,\n-            emit_obj: false,\n-            obj_is_bitcode: false,\n-            embed_bitcode: false,\n-            embed_bitcode_marker: false,\n-            no_integrated_as: false,\n-\n-            verify_llvm_ir: false,\n-            no_prepopulate_passes: false,\n-            no_builtins: false,\n-            time_passes: false,\n-            vectorize_loop: false,\n-            vectorize_slp: false,\n-            merge_functions: false,\n-            inline_threshold: None\n-        }\n-    }\n-\n-    fn set_flags(&mut self, sess: &Session, no_builtins: bool) {\n-        self.verify_llvm_ir = sess.verify_llvm_ir();\n-        self.no_prepopulate_passes = sess.opts.cg.no_prepopulate_passes;\n-        self.no_builtins = no_builtins || sess.target.target.options.no_builtins;\n-        self.time_passes = sess.time_passes();\n-        self.inline_threshold = sess.opts.cg.inline_threshold;\n-        self.obj_is_bitcode = sess.target.target.options.obj_is_bitcode ||\n-                              sess.opts.debugging_opts.cross_lang_lto.enabled();\n-        let embed_bitcode = sess.target.target.options.embed_bitcode ||\n-                            sess.opts.debugging_opts.embed_bitcode;\n-        if embed_bitcode {\n-            match sess.opts.optimize {\n-                config::OptLevel::No |\n-                config::OptLevel::Less => {\n-                    self.embed_bitcode_marker = embed_bitcode;\n-                }\n-                _ => self.embed_bitcode = embed_bitcode,\n-            }\n-        }\n-\n-        // Copy what clang does by turning on loop vectorization at O2 and\n-        // slp vectorization at O3. Otherwise configure other optimization aspects\n-        // of this pass manager builder.\n-        // Turn off vectorization for emscripten, as it's not very well supported.\n-        self.vectorize_loop = !sess.opts.cg.no_vectorize_loops &&\n-                             (sess.opts.optimize == config::OptLevel::Default ||\n-                              sess.opts.optimize == config::OptLevel::Aggressive) &&\n-                             !sess.target.target.options.is_like_emscripten;\n-\n-        self.vectorize_slp = !sess.opts.cg.no_vectorize_slp &&\n-                            sess.opts.optimize == config::OptLevel::Aggressive &&\n-                            !sess.target.target.options.is_like_emscripten;\n-\n-        self.merge_functions = sess.opts.optimize == config::OptLevel::Default ||\n-                               sess.opts.optimize == config::OptLevel::Aggressive;\n-    }\n-\n-    pub fn bitcode_needed(&self) -> bool {\n-        self.emit_bc || self.obj_is_bitcode\n-            || self.emit_bc_compressed || self.embed_bitcode\n-    }\n-}\n-\n-/// Assembler name and command used by codegen when no_integrated_as is enabled\n-struct AssemblerCommand {\n-    name: PathBuf,\n-    cmd: Command,\n-}\n-\n-/// Additional resources used by optimize_and_codegen (not module specific)\n-#[derive(Clone)]\n-pub struct CodegenContext {\n-    // Resources needed when running LTO\n-    pub time_passes: bool,\n-    pub lto: Lto,\n-    pub no_landing_pads: bool,\n-    pub save_temps: bool,\n-    pub fewer_names: bool,\n-    pub exported_symbols: Option<Arc<ExportedSymbols>>,\n-    pub opts: Arc<config::Options>,\n-    pub crate_types: Vec<config::CrateType>,\n-    pub each_linked_rlib_for_lto: Vec<(CrateNum, PathBuf)>,\n-    output_filenames: Arc<OutputFilenames>,\n-    regular_module_config: Arc<ModuleConfig>,\n-    metadata_module_config: Arc<ModuleConfig>,\n-    allocator_module_config: Arc<ModuleConfig>,\n-    pub tm_factory: Arc<dyn Fn() -> Result<&'static mut llvm::TargetMachine, String> + Send + Sync>,\n-    pub msvc_imps_needed: bool,\n-    pub target_pointer_width: String,\n-    debuginfo: config::DebugInfo,\n-\n-    // Number of cgus excluding the allocator/metadata modules\n-    pub total_cgus: usize,\n-    // Handler to use for diagnostics produced during codegen.\n-    pub diag_emitter: SharedEmitter,\n-    // LLVM passes added by plugins.\n-    pub plugin_passes: Vec<String>,\n-    // LLVM optimizations for which we want to print remarks.\n-    pub remark: Passes,\n-    // Worker thread number\n-    pub worker: usize,\n-    // The incremental compilation session directory, or None if we are not\n-    // compiling incrementally\n-    pub incr_comp_session_dir: Option<PathBuf>,\n-    // Used to update CGU re-use information during the thinlto phase.\n-    pub cgu_reuse_tracker: CguReuseTracker,\n-    // Channel back to the main control thread to send messages to\n-    coordinator_send: Sender<Box<dyn Any + Send>>,\n-    // A reference to the TimeGraph so we can register timings. None means that\n-    // measuring is disabled.\n-    time_graph: Option<TimeGraph>,\n-    // The assembler command if no_integrated_as option is enabled, None otherwise\n-    assembler_cmd: Option<Arc<AssemblerCommand>>,\n-}\n-\n-impl CodegenContext {\n-    pub fn create_diag_handler(&self) -> Handler {\n-        Handler::with_emitter(true, false, Box::new(self.diag_emitter.clone()))\n-    }\n-\n-    pub(crate) fn config(&self, kind: ModuleKind) -> &ModuleConfig {\n-        match kind {\n-            ModuleKind::Regular => &self.regular_module_config,\n-            ModuleKind::Metadata => &self.metadata_module_config,\n-            ModuleKind::Allocator => &self.allocator_module_config,\n-        }\n+pub(crate) fn save_temp_bitcode(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    module: &ModuleCodegen<ModuleLlvm>,\n+    name: &str\n+) {\n+    if !cgcx.save_temps {\n+        return\n     }\n-\n-    pub(crate) fn save_temp_bitcode(&self, module: &ModuleCodegen, name: &str) {\n-        if !self.save_temps {\n-            return\n-        }\n-        unsafe {\n-            let ext = format!(\"{}.bc\", name);\n-            let cgu = Some(&module.name[..]);\n-            let path = self.output_filenames.temp_path_ext(&ext, cgu);\n-            let cstr = path2cstr(&path);\n-            let llmod = module.module_llvm.llmod();\n-            llvm::LLVMWriteBitcodeToFile(llmod, cstr.as_ptr());\n-        }\n+    unsafe {\n+        let ext = format!(\"{}.bc\", name);\n+        let cgu = Some(&module.name[..]);\n+        let path = cgcx.output_filenames.temp_path_ext(&ext, cgu);\n+        let cstr = path2cstr(&path);\n+        let llmod = module.module_llvm.llmod();\n+        llvm::LLVMWriteBitcodeToFile(llmod, cstr.as_ptr());\n     }\n }\n \n pub struct DiagnosticHandlers<'a> {\n-    data: *mut (&'a CodegenContext, &'a Handler),\n+    data: *mut (&'a CodegenContext<LlvmCodegenBackend>, &'a Handler),\n     llcx: &'a llvm::Context,\n }\n \n impl<'a> DiagnosticHandlers<'a> {\n-    pub fn new(cgcx: &'a CodegenContext,\n+    pub fn new(cgcx: &'a CodegenContext<LlvmCodegenBackend>,\n                handler: &'a Handler,\n                llcx: &'a llvm::Context) -> Self {\n         let data = Box::into_raw(Box::new((cgcx, handler)));\n@@ -452,7 +246,7 @@ impl<'a> Drop for DiagnosticHandlers<'a> {\n     }\n }\n \n-unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext,\n+unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext<LlvmCodegenBackend>,\n                                                msg: &'b str,\n                                                cookie: c_uint) {\n     cgcx.diag_emitter.inline_asm_error(cookie as u32, msg.to_owned());\n@@ -464,7 +258,7 @@ unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic,\n     if user.is_null() {\n         return\n     }\n-    let (cgcx, _) = *(user as *const (&CodegenContext, &Handler));\n+    let (cgcx, _) = *(user as *const (&CodegenContext<LlvmCodegenBackend>, &Handler));\n \n     let msg = llvm::build_string(|s| llvm::LLVMRustWriteSMDiagnosticToString(diag, s))\n         .expect(\"non-UTF8 SMDiagnostic\");\n@@ -476,7 +270,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void\n     if user.is_null() {\n         return\n     }\n-    let (cgcx, diag_handler) = *(user as *const (&CodegenContext, &Handler));\n+    let (cgcx, diag_handler) = *(user as *const (&CodegenContext<LlvmCodegenBackend>, &Handler));\n \n     match llvm::diagnostic::Diagnostic::unpack(info) {\n         llvm::diagnostic::InlineAsm(inline) => {\n@@ -513,9 +307,9 @@ unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void\n }\n \n // Unsafe due to LLVM calls.\n-unsafe fn optimize(cgcx: &CodegenContext,\n+pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                    diag_handler: &Handler,\n-                   module: &ModuleCodegen,\n+                   module: &ModuleCodegen<ModuleLlvm>,\n                    config: &ModuleConfig,\n                    timeline: &mut Timeline)\n     -> Result<(), FatalError>\n@@ -573,7 +367,8 @@ unsafe fn optimize(cgcx: &CodegenContext,\n             if !config.no_prepopulate_passes {\n                 llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n                 llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n-                let opt_level = config.opt_level.unwrap_or(llvm::CodeGenOptLevel::None);\n+                let opt_level = config.opt_level.map(get_llvm_opt_level)\n+                    .unwrap_or(llvm::CodeGenOptLevel::None);\n                 let prepare_for_thin_lto = cgcx.lto == Lto::Thin || cgcx.lto == Lto::ThinLocal ||\n                     (cgcx.lto != Lto::Fat && cgcx.opts.debugging_opts.cross_lang_lto.enabled());\n                 have_name_anon_globals_pass = have_name_anon_globals_pass || prepare_for_thin_lto;\n@@ -645,37 +440,9 @@ unsafe fn optimize(cgcx: &CodegenContext,\n     Ok(())\n }\n \n-fn generate_lto_work(cgcx: &CodegenContext,\n-                     modules: Vec<ModuleCodegen>,\n-                     import_only_modules: Vec<(SerializedModule, WorkProduct)>)\n-    -> Vec<(WorkItem, u64)>\n-{\n-    let mut timeline = cgcx.time_graph.as_ref().map(|tg| {\n-        tg.start(CODEGEN_WORKER_TIMELINE,\n-                 CODEGEN_WORK_PACKAGE_KIND,\n-                 \"generate lto\")\n-    }).unwrap_or(Timeline::noop());\n-    let (lto_modules, copy_jobs) = lto::run(cgcx, modules, import_only_modules, &mut timeline)\n-        .unwrap_or_else(|e| e.raise());\n-\n-    let lto_modules = lto_modules.into_iter().map(|module| {\n-        let cost = module.cost();\n-        (WorkItem::LTO(module), cost)\n-    });\n-\n-    let copy_jobs = copy_jobs.into_iter().map(|wp| {\n-        (WorkItem::CopyPostLtoArtifacts(CachedModuleCodegen {\n-            name: wp.cgu_name.clone(),\n-            source: wp,\n-        }), 0)\n-    });\n-\n-    lto_modules.chain(copy_jobs).collect()\n-}\n-\n-unsafe fn codegen(cgcx: &CodegenContext,\n+pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                   diag_handler: &Handler,\n-                  module: ModuleCodegen,\n+                  module: ModuleCodegen<ModuleLlvm>,\n                   config: &ModuleConfig,\n                   timeline: &mut Timeline)\n     -> Result<CompiledModule, FatalError>\n@@ -880,14 +647,14 @@ unsafe fn codegen(cgcx: &CodegenContext,\n ///\n /// Basically all of this is us attempting to follow in the footsteps of clang\n /// on iOS. See #35968 for lots more info.\n-unsafe fn embed_bitcode(cgcx: &CodegenContext,\n+unsafe fn embed_bitcode(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                         llcx: &llvm::Context,\n                         llmod: &llvm::Module,\n                         bitcode: Option<&[u8]>) {\n-    let llconst = C_bytes_in_context(llcx, bitcode.unwrap_or(&[]));\n+    let llconst = common::bytes_in_context(llcx, bitcode.unwrap_or(&[]));\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n-        val_ty(llconst),\n+        common::val_ty(llconst),\n         \"rustc.embedded.module\\0\".as_ptr() as *const _,\n     );\n     llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -904,10 +671,10 @@ unsafe fn embed_bitcode(cgcx: &CodegenContext,\n     llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n     llvm::LLVMSetGlobalConstant(llglobal, llvm::True);\n \n-    let llconst = C_bytes_in_context(llcx, &[]);\n+    let llconst = common::bytes_in_context(llcx, &[]);\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n-        val_ty(llconst),\n+        common::val_ty(llconst),\n         \"rustc.embedded.cmdline\\0\".as_ptr() as *const _,\n     );\n     llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -920,1279 +687,6 @@ unsafe fn embed_bitcode(cgcx: &CodegenContext,\n     llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n }\n \n-pub(crate) struct CompiledModules {\n-    pub modules: Vec<CompiledModule>,\n-    pub metadata_module: CompiledModule,\n-    pub allocator_module: Option<CompiledModule>,\n-}\n-\n-fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n-    sess.crate_types.borrow().contains(&config::CrateType::Rlib) &&\n-    sess.opts.output_types.contains_key(&OutputType::Exe)\n-}\n-\n-fn need_pre_thin_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n-    if sess.opts.incremental.is_none() {\n-        return false\n-    }\n-\n-    match sess.lto() {\n-        Lto::Fat |\n-        Lto::No => false,\n-        Lto::Thin |\n-        Lto::ThinLocal => true,\n-    }\n-}\n-\n-pub fn start_async_codegen(tcx: TyCtxt,\n-                           time_graph: Option<TimeGraph>,\n-                           metadata: EncodedMetadata,\n-                           coordinator_receive: Receiver<Box<dyn Any + Send>>,\n-                           total_cgus: usize)\n-                           -> OngoingCodegen {\n-    let sess = tcx.sess;\n-    let crate_name = tcx.crate_name(LOCAL_CRATE);\n-    let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n-    let no_builtins = attr::contains_name(&tcx.hir.krate().attrs, \"no_builtins\");\n-    let subsystem = attr::first_attr_value_str_by_name(&tcx.hir.krate().attrs,\n-                                                       \"windows_subsystem\");\n-    let windows_subsystem = subsystem.map(|subsystem| {\n-        if subsystem != \"windows\" && subsystem != \"console\" {\n-            tcx.sess.fatal(&format!(\"invalid windows subsystem `{}`, only \\\n-                                     `windows` and `console` are allowed\",\n-                                    subsystem));\n-        }\n-        subsystem.to_string()\n-    });\n-\n-    let linker_info = LinkerInfo::new(tcx);\n-    let crate_info = CrateInfo::new(tcx);\n-\n-    // Figure out what we actually need to build.\n-    let mut modules_config = ModuleConfig::new(sess.opts.cg.passes.clone());\n-    let mut metadata_config = ModuleConfig::new(vec![]);\n-    let mut allocator_config = ModuleConfig::new(vec![]);\n-\n-    if let Some(ref sanitizer) = sess.opts.debugging_opts.sanitizer {\n-        match *sanitizer {\n-            Sanitizer::Address => {\n-                modules_config.passes.push(\"asan\".to_owned());\n-                modules_config.passes.push(\"asan-module\".to_owned());\n-            }\n-            Sanitizer::Memory => {\n-                modules_config.passes.push(\"msan\".to_owned())\n-            }\n-            Sanitizer::Thread => {\n-                modules_config.passes.push(\"tsan\".to_owned())\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    if sess.opts.debugging_opts.profile {\n-        modules_config.passes.push(\"insert-gcov-profiling\".to_owned())\n-    }\n-\n-    modules_config.pgo_gen = sess.opts.debugging_opts.pgo_gen.clone();\n-    modules_config.pgo_use = sess.opts.debugging_opts.pgo_use.clone();\n-\n-    modules_config.opt_level = Some(get_llvm_opt_level(sess.opts.optimize));\n-    modules_config.opt_size = Some(get_llvm_opt_size(sess.opts.optimize));\n-\n-    // Save all versions of the bytecode if we're saving our temporaries.\n-    if sess.opts.cg.save_temps {\n-        modules_config.emit_no_opt_bc = true;\n-        modules_config.emit_pre_thin_lto_bc = true;\n-        modules_config.emit_bc = true;\n-        modules_config.emit_lto_bc = true;\n-        metadata_config.emit_bc = true;\n-        allocator_config.emit_bc = true;\n-    }\n-\n-    // Emit compressed bitcode files for the crate if we're emitting an rlib.\n-    // Whenever an rlib is created, the bitcode is inserted into the archive in\n-    // order to allow LTO against it.\n-    if need_crate_bitcode_for_rlib(sess) {\n-        modules_config.emit_bc_compressed = true;\n-        allocator_config.emit_bc_compressed = true;\n-    }\n-\n-    modules_config.emit_pre_thin_lto_bc =\n-        need_pre_thin_lto_bitcode_for_incr_comp(sess);\n-\n-    modules_config.no_integrated_as = tcx.sess.opts.cg.no_integrated_as ||\n-        tcx.sess.target.target.options.no_integrated_as;\n-\n-    for output_type in sess.opts.output_types.keys() {\n-        match *output_type {\n-            OutputType::Bitcode => { modules_config.emit_bc = true; }\n-            OutputType::LlvmAssembly => { modules_config.emit_ir = true; }\n-            OutputType::Assembly => {\n-                modules_config.emit_asm = true;\n-                // If we're not using the LLVM assembler, this function\n-                // could be invoked specially with output_type_assembly, so\n-                // in this case we still want the metadata object file.\n-                if !sess.opts.output_types.contains_key(&OutputType::Assembly) {\n-                    metadata_config.emit_obj = true;\n-                    allocator_config.emit_obj = true;\n-                }\n-            }\n-            OutputType::Object => { modules_config.emit_obj = true; }\n-            OutputType::Metadata => { metadata_config.emit_obj = true; }\n-            OutputType::Exe => {\n-                modules_config.emit_obj = true;\n-                metadata_config.emit_obj = true;\n-                allocator_config.emit_obj = true;\n-            },\n-            OutputType::Mir => {}\n-            OutputType::DepInfo => {}\n-        }\n-    }\n-\n-    modules_config.set_flags(sess, no_builtins);\n-    metadata_config.set_flags(sess, no_builtins);\n-    allocator_config.set_flags(sess, no_builtins);\n-\n-    // Exclude metadata and allocator modules from time_passes output, since\n-    // they throw off the \"LLVM passes\" measurement.\n-    metadata_config.time_passes = false;\n-    allocator_config.time_passes = false;\n-\n-    let (shared_emitter, shared_emitter_main) = SharedEmitter::new();\n-    let (codegen_worker_send, codegen_worker_receive) = channel();\n-\n-    let coordinator_thread = start_executing_work(tcx,\n-                                                  &crate_info,\n-                                                  shared_emitter,\n-                                                  codegen_worker_send,\n-                                                  coordinator_receive,\n-                                                  total_cgus,\n-                                                  sess.jobserver.clone(),\n-                                                  time_graph.clone(),\n-                                                  Arc::new(modules_config),\n-                                                  Arc::new(metadata_config),\n-                                                  Arc::new(allocator_config));\n-\n-    OngoingCodegen {\n-        crate_name,\n-        crate_hash,\n-        metadata,\n-        windows_subsystem,\n-        linker_info,\n-        crate_info,\n-\n-        time_graph,\n-        coordinator_send: tcx.tx_to_llvm_workers.lock().clone(),\n-        codegen_worker_receive,\n-        shared_emitter_main,\n-        future: coordinator_thread,\n-        output_filenames: tcx.output_filenames(LOCAL_CRATE),\n-    }\n-}\n-\n-fn copy_all_cgu_workproducts_to_incr_comp_cache_dir(\n-    sess: &Session,\n-    compiled_modules: &CompiledModules,\n-) -> FxHashMap<WorkProductId, WorkProduct> {\n-    let mut work_products = FxHashMap::default();\n-\n-    if sess.opts.incremental.is_none() {\n-        return work_products;\n-    }\n-\n-    for module in compiled_modules.modules.iter().filter(|m| m.kind == ModuleKind::Regular) {\n-        let mut files = vec![];\n-\n-        if let Some(ref path) = module.object {\n-            files.push((WorkProductFileKind::Object, path.clone()));\n-        }\n-        if let Some(ref path) = module.bytecode {\n-            files.push((WorkProductFileKind::Bytecode, path.clone()));\n-        }\n-        if let Some(ref path) = module.bytecode_compressed {\n-            files.push((WorkProductFileKind::BytecodeCompressed, path.clone()));\n-        }\n-\n-        if let Some((id, product)) =\n-            copy_cgu_workproducts_to_incr_comp_cache_dir(sess, &module.name, &files)\n-        {\n-            work_products.insert(id, product);\n-        }\n-    }\n-\n-    work_products\n-}\n-\n-fn produce_final_output_artifacts(sess: &Session,\n-                                  compiled_modules: &CompiledModules,\n-                                  crate_output: &OutputFilenames) {\n-    let mut user_wants_bitcode = false;\n-    let mut user_wants_objects = false;\n-\n-    // Produce final compile outputs.\n-    let copy_gracefully = |from: &Path, to: &Path| {\n-        if let Err(e) = fs::copy(from, to) {\n-            sess.err(&format!(\"could not copy {:?} to {:?}: {}\", from, to, e));\n-        }\n-    };\n-\n-    let copy_if_one_unit = |output_type: OutputType,\n-                            keep_numbered: bool| {\n-        if compiled_modules.modules.len() == 1 {\n-            // 1) Only one codegen unit.  In this case it's no difficulty\n-            //    to copy `foo.0.x` to `foo.x`.\n-            let module_name = Some(&compiled_modules.modules[0].name[..]);\n-            let path = crate_output.temp_path(output_type, module_name);\n-            copy_gracefully(&path,\n-                            &crate_output.path(output_type));\n-            if !sess.opts.cg.save_temps && !keep_numbered {\n-                // The user just wants `foo.x`, not `foo.#module-name#.x`.\n-                remove(sess, &path);\n-            }\n-        } else {\n-            let ext = crate_output.temp_path(output_type, None)\n-                                  .extension()\n-                                  .unwrap()\n-                                  .to_str()\n-                                  .unwrap()\n-                                  .to_owned();\n-\n-            if crate_output.outputs.contains_key(&output_type) {\n-                // 2) Multiple codegen units, with `--emit foo=some_name`.  We have\n-                //    no good solution for this case, so warn the user.\n-                sess.warn(&format!(\"ignoring emit path because multiple .{} files \\\n-                                    were produced\", ext));\n-            } else if crate_output.single_output_file.is_some() {\n-                // 3) Multiple codegen units, with `-o some_name`.  We have\n-                //    no good solution for this case, so warn the user.\n-                sess.warn(&format!(\"ignoring -o because multiple .{} files \\\n-                                    were produced\", ext));\n-            } else {\n-                // 4) Multiple codegen units, but no explicit name.  We\n-                //    just leave the `foo.0.x` files in place.\n-                // (We don't have to do any work in this case.)\n-            }\n-        }\n-    };\n-\n-    // Flag to indicate whether the user explicitly requested bitcode.\n-    // Otherwise, we produced it only as a temporary output, and will need\n-    // to get rid of it.\n-    for output_type in crate_output.outputs.keys() {\n-        match *output_type {\n-            OutputType::Bitcode => {\n-                user_wants_bitcode = true;\n-                // Copy to .bc, but always keep the .0.bc.  There is a later\n-                // check to figure out if we should delete .0.bc files, or keep\n-                // them for making an rlib.\n-                copy_if_one_unit(OutputType::Bitcode, true);\n-            }\n-            OutputType::LlvmAssembly => {\n-                copy_if_one_unit(OutputType::LlvmAssembly, false);\n-            }\n-            OutputType::Assembly => {\n-                copy_if_one_unit(OutputType::Assembly, false);\n-            }\n-            OutputType::Object => {\n-                user_wants_objects = true;\n-                copy_if_one_unit(OutputType::Object, true);\n-            }\n-            OutputType::Mir |\n-            OutputType::Metadata |\n-            OutputType::Exe |\n-            OutputType::DepInfo => {}\n-        }\n-    }\n-\n-    // Clean up unwanted temporary files.\n-\n-    // We create the following files by default:\n-    //  - #crate#.#module-name#.bc\n-    //  - #crate#.#module-name#.o\n-    //  - #crate#.crate.metadata.bc\n-    //  - #crate#.crate.metadata.o\n-    //  - #crate#.o (linked from crate.##.o)\n-    //  - #crate#.bc (copied from crate.##.bc)\n-    // We may create additional files if requested by the user (through\n-    // `-C save-temps` or `--emit=` flags).\n-\n-    if !sess.opts.cg.save_temps {\n-        // Remove the temporary .#module-name#.o objects.  If the user didn't\n-        // explicitly request bitcode (with --emit=bc), and the bitcode is not\n-        // needed for building an rlib, then we must remove .#module-name#.bc as\n-        // well.\n-\n-        // Specific rules for keeping .#module-name#.bc:\n-        //  - If the user requested bitcode (`user_wants_bitcode`), and\n-        //    codegen_units > 1, then keep it.\n-        //  - If the user requested bitcode but codegen_units == 1, then we\n-        //    can toss .#module-name#.bc because we copied it to .bc earlier.\n-        //  - If we're not building an rlib and the user didn't request\n-        //    bitcode, then delete .#module-name#.bc.\n-        // If you change how this works, also update back::link::link_rlib,\n-        // where .#module-name#.bc files are (maybe) deleted after making an\n-        // rlib.\n-        let needs_crate_object = crate_output.outputs.contains_key(&OutputType::Exe);\n-\n-        let keep_numbered_bitcode = user_wants_bitcode && sess.codegen_units() > 1;\n-\n-        let keep_numbered_objects = needs_crate_object ||\n-                (user_wants_objects && sess.codegen_units() > 1);\n-\n-        for module in compiled_modules.modules.iter() {\n-            if let Some(ref path) = module.object {\n-                if !keep_numbered_objects {\n-                    remove(sess, path);\n-                }\n-            }\n-\n-            if let Some(ref path) = module.bytecode {\n-                if !keep_numbered_bitcode {\n-                    remove(sess, path);\n-                }\n-            }\n-        }\n-\n-        if !user_wants_bitcode {\n-            if let Some(ref path) = compiled_modules.metadata_module.bytecode {\n-                remove(sess, &path);\n-            }\n-\n-            if let Some(ref allocator_module) = compiled_modules.allocator_module {\n-                if let Some(ref path) = allocator_module.bytecode {\n-                    remove(sess, path);\n-                }\n-            }\n-        }\n-    }\n-\n-    // We leave the following files around by default:\n-    //  - #crate#.o\n-    //  - #crate#.crate.metadata.o\n-    //  - #crate#.bc\n-    // These are used in linking steps and will be cleaned up afterward.\n-}\n-\n-pub(crate) fn dump_incremental_data(_codegen_results: &CodegenResults) {\n-    // FIXME(mw): This does not work at the moment because the situation has\n-    //            become more complicated due to incremental LTO. Now a CGU\n-    //            can have more than two caching states.\n-    // println!(\"[incremental] Re-using {} out of {} modules\",\n-    //           codegen_results.modules.iter().filter(|m| m.pre_existing).count(),\n-    //           codegen_results.modules.len());\n-}\n-\n-enum WorkItem {\n-    /// Optimize a newly codegened, totally unoptimized module.\n-    Optimize(ModuleCodegen),\n-    /// Copy the post-LTO artifacts from the incremental cache to the output\n-    /// directory.\n-    CopyPostLtoArtifacts(CachedModuleCodegen),\n-    /// Perform (Thin)LTO on the given module.\n-    LTO(lto::LtoModuleCodegen),\n-}\n-\n-impl WorkItem {\n-    fn module_kind(&self) -> ModuleKind {\n-        match *self {\n-            WorkItem::Optimize(ref m) => m.kind,\n-            WorkItem::CopyPostLtoArtifacts(_) |\n-            WorkItem::LTO(_) => ModuleKind::Regular,\n-        }\n-    }\n-\n-    fn name(&self) -> String {\n-        match *self {\n-            WorkItem::Optimize(ref m) => format!(\"optimize: {}\", m.name),\n-            WorkItem::CopyPostLtoArtifacts(ref m) => format!(\"copy post LTO artifacts: {}\", m.name),\n-            WorkItem::LTO(ref m) => format!(\"lto: {}\", m.name()),\n-        }\n-    }\n-}\n-\n-enum WorkItemResult {\n-    Compiled(CompiledModule),\n-    NeedsLTO(ModuleCodegen),\n-}\n-\n-fn execute_work_item(cgcx: &CodegenContext,\n-                     work_item: WorkItem,\n-                     timeline: &mut Timeline)\n-    -> Result<WorkItemResult, FatalError>\n-{\n-    let module_config = cgcx.config(work_item.module_kind());\n-\n-    match work_item {\n-        WorkItem::Optimize(module) => {\n-            execute_optimize_work_item(cgcx, module, module_config, timeline)\n-        }\n-        WorkItem::CopyPostLtoArtifacts(module) => {\n-            execute_copy_from_cache_work_item(cgcx, module, module_config, timeline)\n-        }\n-        WorkItem::LTO(module) => {\n-            execute_lto_work_item(cgcx, module, module_config, timeline)\n-        }\n-    }\n-}\n-\n-fn execute_optimize_work_item(cgcx: &CodegenContext,\n-                              module: ModuleCodegen,\n-                              module_config: &ModuleConfig,\n-                              timeline: &mut Timeline)\n-    -> Result<WorkItemResult, FatalError>\n-{\n-    let diag_handler = cgcx.create_diag_handler();\n-\n-    unsafe {\n-        optimize(cgcx, &diag_handler, &module, module_config, timeline)?;\n-    }\n-\n-    let linker_does_lto = cgcx.opts.debugging_opts.cross_lang_lto.enabled();\n-\n-    // After we've done the initial round of optimizations we need to\n-    // decide whether to synchronously codegen this module or ship it\n-    // back to the coordinator thread for further LTO processing (which\n-    // has to wait for all the initial modules to be optimized).\n-    //\n-    // Here we dispatch based on the `cgcx.lto` and kind of module we're\n-    // codegenning...\n-    let needs_lto = match cgcx.lto {\n-        Lto::No => false,\n-\n-        // If the linker does LTO, we don't have to do it. Note that we\n-        // keep doing full LTO, if it is requested, as not to break the\n-        // assumption that the output will be a single module.\n-        Lto::Thin | Lto::ThinLocal if linker_does_lto => false,\n-\n-        // Here we've got a full crate graph LTO requested. We ignore\n-        // this, however, if the crate type is only an rlib as there's\n-        // no full crate graph to process, that'll happen later.\n-        //\n-        // This use case currently comes up primarily for targets that\n-        // require LTO so the request for LTO is always unconditionally\n-        // passed down to the backend, but we don't actually want to do\n-        // anything about it yet until we've got a final product.\n-        Lto::Fat | Lto::Thin => {\n-            cgcx.crate_types.len() != 1 ||\n-                cgcx.crate_types[0] != config::CrateType::Rlib\n-        }\n-\n-        // When we're automatically doing ThinLTO for multi-codegen-unit\n-        // builds we don't actually want to LTO the allocator modules if\n-        // it shows up. This is due to various linker shenanigans that\n-        // we'll encounter later.\n-        Lto::ThinLocal => {\n-            module.kind != ModuleKind::Allocator\n-        }\n-    };\n-\n-    // Metadata modules never participate in LTO regardless of the lto\n-    // settings.\n-    let needs_lto = needs_lto && module.kind != ModuleKind::Metadata;\n-\n-    if needs_lto {\n-        Ok(WorkItemResult::NeedsLTO(module))\n-    } else {\n-        let module = unsafe {\n-            codegen(cgcx, &diag_handler, module, module_config, timeline)?\n-        };\n-        Ok(WorkItemResult::Compiled(module))\n-    }\n-}\n-\n-fn execute_copy_from_cache_work_item(cgcx: &CodegenContext,\n-                                     module: CachedModuleCodegen,\n-                                     module_config: &ModuleConfig,\n-                                     _: &mut Timeline)\n-    -> Result<WorkItemResult, FatalError>\n-{\n-    let incr_comp_session_dir = cgcx.incr_comp_session_dir\n-                                    .as_ref()\n-                                    .unwrap();\n-    let mut object = None;\n-    let mut bytecode = None;\n-    let mut bytecode_compressed = None;\n-    for (kind, saved_file) in &module.source.saved_files {\n-        let obj_out = match kind {\n-            WorkProductFileKind::Object => {\n-                let path = cgcx.output_filenames.temp_path(OutputType::Object,\n-                                                           Some(&module.name));\n-                object = Some(path.clone());\n-                path\n-            }\n-            WorkProductFileKind::Bytecode => {\n-                let path = cgcx.output_filenames.temp_path(OutputType::Bitcode,\n-                                                           Some(&module.name));\n-                bytecode = Some(path.clone());\n-                path\n-            }\n-            WorkProductFileKind::BytecodeCompressed => {\n-                let path = cgcx.output_filenames.temp_path(OutputType::Bitcode,\n-                                                           Some(&module.name))\n-                    .with_extension(RLIB_BYTECODE_EXTENSION);\n-                bytecode_compressed = Some(path.clone());\n-                path\n-            }\n-        };\n-        let source_file = in_incr_comp_dir(&incr_comp_session_dir,\n-                                           &saved_file);\n-        debug!(\"copying pre-existing module `{}` from {:?} to {}\",\n-               module.name,\n-               source_file,\n-               obj_out.display());\n-        if let Err(err) = link_or_copy(&source_file, &obj_out) {\n-            let diag_handler = cgcx.create_diag_handler();\n-            diag_handler.err(&format!(\"unable to copy {} to {}: {}\",\n-                                      source_file.display(),\n-                                      obj_out.display(),\n-                                      err));\n-        }\n-    }\n-\n-    assert_eq!(object.is_some(), module_config.emit_obj);\n-    assert_eq!(bytecode.is_some(), module_config.emit_bc);\n-    assert_eq!(bytecode_compressed.is_some(), module_config.emit_bc_compressed);\n-\n-    Ok(WorkItemResult::Compiled(CompiledModule {\n-        name: module.name,\n-        kind: ModuleKind::Regular,\n-        object,\n-        bytecode,\n-        bytecode_compressed,\n-    }))\n-}\n-\n-fn execute_lto_work_item(cgcx: &CodegenContext,\n-                         mut module: lto::LtoModuleCodegen,\n-                         module_config: &ModuleConfig,\n-                         timeline: &mut Timeline)\n-    -> Result<WorkItemResult, FatalError>\n-{\n-    let diag_handler = cgcx.create_diag_handler();\n-\n-    unsafe {\n-        let module = module.optimize(cgcx, timeline)?;\n-        let module = codegen(cgcx, &diag_handler, module, module_config, timeline)?;\n-        Ok(WorkItemResult::Compiled(module))\n-    }\n-}\n-\n-enum Message {\n-    Token(io::Result<Acquired>),\n-    NeedsLTO {\n-        result: ModuleCodegen,\n-        worker_id: usize,\n-    },\n-    Done {\n-        result: Result<CompiledModule, ()>,\n-        worker_id: usize,\n-    },\n-    CodegenDone {\n-        llvm_work_item: WorkItem,\n-        cost: u64,\n-    },\n-    AddImportOnlyModule {\n-        module_data: SerializedModule,\n-        work_product: WorkProduct,\n-    },\n-    CodegenComplete,\n-    CodegenItem,\n-    CodegenAborted,\n-}\n-\n-struct Diagnostic {\n-    msg: String,\n-    code: Option<DiagnosticId>,\n-    lvl: Level,\n-}\n-\n-#[derive(PartialEq, Clone, Copy, Debug)]\n-enum MainThreadWorkerState {\n-    Idle,\n-    Codegenning,\n-    LLVMing,\n-}\n-\n-fn start_executing_work(tcx: TyCtxt,\n-                        crate_info: &CrateInfo,\n-                        shared_emitter: SharedEmitter,\n-                        codegen_worker_send: Sender<Message>,\n-                        coordinator_receive: Receiver<Box<dyn Any + Send>>,\n-                        total_cgus: usize,\n-                        jobserver: Client,\n-                        time_graph: Option<TimeGraph>,\n-                        modules_config: Arc<ModuleConfig>,\n-                        metadata_config: Arc<ModuleConfig>,\n-                        allocator_config: Arc<ModuleConfig>)\n-                        -> thread::JoinHandle<Result<CompiledModules, ()>> {\n-    let coordinator_send = tcx.tx_to_llvm_workers.lock().clone();\n-    let sess = tcx.sess;\n-\n-    // Compute the set of symbols we need to retain when doing LTO (if we need to)\n-    let exported_symbols = {\n-        let mut exported_symbols = FxHashMap::default();\n-\n-        let copy_symbols = |cnum| {\n-            let symbols = tcx.exported_symbols(cnum)\n-                             .iter()\n-                             .map(|&(s, lvl)| (s.symbol_name(tcx).to_string(), lvl))\n-                             .collect();\n-            Arc::new(symbols)\n-        };\n-\n-        match sess.lto() {\n-            Lto::No => None,\n-            Lto::ThinLocal => {\n-                exported_symbols.insert(LOCAL_CRATE, copy_symbols(LOCAL_CRATE));\n-                Some(Arc::new(exported_symbols))\n-            }\n-            Lto::Fat | Lto::Thin => {\n-                exported_symbols.insert(LOCAL_CRATE, copy_symbols(LOCAL_CRATE));\n-                for &cnum in tcx.crates().iter() {\n-                    exported_symbols.insert(cnum, copy_symbols(cnum));\n-                }\n-                Some(Arc::new(exported_symbols))\n-            }\n-        }\n-    };\n-\n-    // First up, convert our jobserver into a helper thread so we can use normal\n-    // mpsc channels to manage our messages and such.\n-    // After we've requested tokens then we'll, when we can,\n-    // get tokens on `coordinator_receive` which will\n-    // get managed in the main loop below.\n-    let coordinator_send2 = coordinator_send.clone();\n-    let helper = jobserver.into_helper_thread(move |token| {\n-        drop(coordinator_send2.send(Box::new(Message::Token(token))));\n-    }).expect(\"failed to spawn helper thread\");\n-\n-    let mut each_linked_rlib_for_lto = Vec::new();\n-    drop(link::each_linked_rlib(sess, crate_info, &mut |cnum, path| {\n-        if link::ignored_for_lto(sess, crate_info, cnum) {\n-            return\n-        }\n-        each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n-    }));\n-\n-    let assembler_cmd = if modules_config.no_integrated_as {\n-        // HACK: currently we use linker (gcc) as our assembler\n-        let (linker, flavor) = link::linker_and_flavor(sess);\n-\n-        let (name, mut cmd) = get_linker(sess, &linker, flavor);\n-        cmd.args(&sess.target.target.options.asm_args);\n-\n-        Some(Arc::new(AssemblerCommand { name, cmd }))\n-    } else {\n-        None\n-    };\n-\n-    let cgcx = CodegenContext {\n-        crate_types: sess.crate_types.borrow().clone(),\n-        each_linked_rlib_for_lto,\n-        lto: sess.lto(),\n-        no_landing_pads: sess.no_landing_pads(),\n-        fewer_names: sess.fewer_names(),\n-        save_temps: sess.opts.cg.save_temps,\n-        opts: Arc::new(sess.opts.clone()),\n-        time_passes: sess.time_passes(),\n-        exported_symbols,\n-        plugin_passes: sess.plugin_llvm_passes.borrow().clone(),\n-        remark: sess.opts.cg.remark.clone(),\n-        worker: 0,\n-        incr_comp_session_dir: sess.incr_comp_session_dir_opt().map(|r| r.clone()),\n-        cgu_reuse_tracker: sess.cgu_reuse_tracker.clone(),\n-        coordinator_send,\n-        diag_emitter: shared_emitter.clone(),\n-        time_graph,\n-        output_filenames: tcx.output_filenames(LOCAL_CRATE),\n-        regular_module_config: modules_config,\n-        metadata_module_config: metadata_config,\n-        allocator_module_config: allocator_config,\n-        tm_factory: target_machine_factory(tcx.sess, false),\n-        total_cgus,\n-        msvc_imps_needed: msvc_imps_needed(tcx),\n-        target_pointer_width: tcx.sess.target.target.target_pointer_width.clone(),\n-        debuginfo: tcx.sess.opts.debuginfo,\n-        assembler_cmd,\n-    };\n-\n-    // This is the \"main loop\" of parallel work happening for parallel codegen.\n-    // It's here that we manage parallelism, schedule work, and work with\n-    // messages coming from clients.\n-    //\n-    // There are a few environmental pre-conditions that shape how the system\n-    // is set up:\n-    //\n-    // - Error reporting only can happen on the main thread because that's the\n-    //   only place where we have access to the compiler `Session`.\n-    // - LLVM work can be done on any thread.\n-    // - Codegen can only happen on the main thread.\n-    // - Each thread doing substantial work most be in possession of a `Token`\n-    //   from the `Jobserver`.\n-    // - The compiler process always holds one `Token`. Any additional `Tokens`\n-    //   have to be requested from the `Jobserver`.\n-    //\n-    // Error Reporting\n-    // ===============\n-    // The error reporting restriction is handled separately from the rest: We\n-    // set up a `SharedEmitter` the holds an open channel to the main thread.\n-    // When an error occurs on any thread, the shared emitter will send the\n-    // error message to the receiver main thread (`SharedEmitterMain`). The\n-    // main thread will periodically query this error message queue and emit\n-    // any error messages it has received. It might even abort compilation if\n-    // has received a fatal error. In this case we rely on all other threads\n-    // being torn down automatically with the main thread.\n-    // Since the main thread will often be busy doing codegen work, error\n-    // reporting will be somewhat delayed, since the message queue can only be\n-    // checked in between to work packages.\n-    //\n-    // Work Processing Infrastructure\n-    // ==============================\n-    // The work processing infrastructure knows three major actors:\n-    //\n-    // - the coordinator thread,\n-    // - the main thread, and\n-    // - LLVM worker threads\n-    //\n-    // The coordinator thread is running a message loop. It instructs the main\n-    // thread about what work to do when, and it will spawn off LLVM worker\n-    // threads as open LLVM WorkItems become available.\n-    //\n-    // The job of the main thread is to codegen CGUs into LLVM work package\n-    // (since the main thread is the only thread that can do this). The main\n-    // thread will block until it receives a message from the coordinator, upon\n-    // which it will codegen one CGU, send it to the coordinator and block\n-    // again. This way the coordinator can control what the main thread is\n-    // doing.\n-    //\n-    // The coordinator keeps a queue of LLVM WorkItems, and when a `Token` is\n-    // available, it will spawn off a new LLVM worker thread and let it process\n-    // that a WorkItem. When a LLVM worker thread is done with its WorkItem,\n-    // it will just shut down, which also frees all resources associated with\n-    // the given LLVM module, and sends a message to the coordinator that the\n-    // has been completed.\n-    //\n-    // Work Scheduling\n-    // ===============\n-    // The scheduler's goal is to minimize the time it takes to complete all\n-    // work there is, however, we also want to keep memory consumption low\n-    // if possible. These two goals are at odds with each other: If memory\n-    // consumption were not an issue, we could just let the main thread produce\n-    // LLVM WorkItems at full speed, assuring maximal utilization of\n-    // Tokens/LLVM worker threads. However, since codegen usual is faster\n-    // than LLVM processing, the queue of LLVM WorkItems would fill up and each\n-    // WorkItem potentially holds on to a substantial amount of memory.\n-    //\n-    // So the actual goal is to always produce just enough LLVM WorkItems as\n-    // not to starve our LLVM worker threads. That means, once we have enough\n-    // WorkItems in our queue, we can block the main thread, so it does not\n-    // produce more until we need them.\n-    //\n-    // Doing LLVM Work on the Main Thread\n-    // ----------------------------------\n-    // Since the main thread owns the compiler processes implicit `Token`, it is\n-    // wasteful to keep it blocked without doing any work. Therefore, what we do\n-    // in this case is: We spawn off an additional LLVM worker thread that helps\n-    // reduce the queue. The work it is doing corresponds to the implicit\n-    // `Token`. The coordinator will mark the main thread as being busy with\n-    // LLVM work. (The actual work happens on another OS thread but we just care\n-    // about `Tokens`, not actual threads).\n-    //\n-    // When any LLVM worker thread finishes while the main thread is marked as\n-    // \"busy with LLVM work\", we can do a little switcheroo: We give the Token\n-    // of the just finished thread to the LLVM worker thread that is working on\n-    // behalf of the main thread's implicit Token, thus freeing up the main\n-    // thread again. The coordinator can then again decide what the main thread\n-    // should do. This allows the coordinator to make decisions at more points\n-    // in time.\n-    //\n-    // Striking a Balance between Throughput and Memory Consumption\n-    // ------------------------------------------------------------\n-    // Since our two goals, (1) use as many Tokens as possible and (2) keep\n-    // memory consumption as low as possible, are in conflict with each other,\n-    // we have to find a trade off between them. Right now, the goal is to keep\n-    // all workers busy, which means that no worker should find the queue empty\n-    // when it is ready to start.\n-    // How do we do achieve this? Good question :) We actually never know how\n-    // many `Tokens` are potentially available so it's hard to say how much to\n-    // fill up the queue before switching the main thread to LLVM work. Also we\n-    // currently don't have a means to estimate how long a running LLVM worker\n-    // will still be busy with it's current WorkItem. However, we know the\n-    // maximal count of available Tokens that makes sense (=the number of CPU\n-    // cores), so we can take a conservative guess. The heuristic we use here\n-    // is implemented in the `queue_full_enough()` function.\n-    //\n-    // Some Background on Jobservers\n-    // -----------------------------\n-    // It's worth also touching on the management of parallelism here. We don't\n-    // want to just spawn a thread per work item because while that's optimal\n-    // parallelism it may overload a system with too many threads or violate our\n-    // configuration for the maximum amount of cpu to use for this process. To\n-    // manage this we use the `jobserver` crate.\n-    //\n-    // Job servers are an artifact of GNU make and are used to manage\n-    // parallelism between processes. A jobserver is a glorified IPC semaphore\n-    // basically. Whenever we want to run some work we acquire the semaphore,\n-    // and whenever we're done with that work we release the semaphore. In this\n-    // manner we can ensure that the maximum number of parallel workers is\n-    // capped at any one point in time.\n-    //\n-    // LTO and the coordinator thread\n-    // ------------------------------\n-    //\n-    // The final job the coordinator thread is responsible for is managing LTO\n-    // and how that works. When LTO is requested what we'll to is collect all\n-    // optimized LLVM modules into a local vector on the coordinator. Once all\n-    // modules have been codegened and optimized we hand this to the `lto`\n-    // module for further optimization. The `lto` module will return back a list\n-    // of more modules to work on, which the coordinator will continue to spawn\n-    // work for.\n-    //\n-    // Each LLVM module is automatically sent back to the coordinator for LTO if\n-    // necessary. There's already optimizations in place to avoid sending work\n-    // back to the coordinator if LTO isn't requested.\n-    return thread::spawn(move || {\n-        // We pretend to be within the top-level LLVM time-passes task here:\n-        set_time_depth(1);\n-\n-        let max_workers = ::num_cpus::get();\n-        let mut worker_id_counter = 0;\n-        let mut free_worker_ids = Vec::new();\n-        let mut get_worker_id = |free_worker_ids: &mut Vec<usize>| {\n-            if let Some(id) = free_worker_ids.pop() {\n-                id\n-            } else {\n-                let id = worker_id_counter;\n-                worker_id_counter += 1;\n-                id\n-            }\n-        };\n-\n-        // This is where we collect codegen units that have gone all the way\n-        // through codegen and LLVM.\n-        let mut compiled_modules = vec![];\n-        let mut compiled_metadata_module = None;\n-        let mut compiled_allocator_module = None;\n-        let mut needs_lto = Vec::new();\n-        let mut lto_import_only_modules = Vec::new();\n-        let mut started_lto = false;\n-        let mut codegen_aborted = false;\n-\n-        // This flag tracks whether all items have gone through codegens\n-        let mut codegen_done = false;\n-\n-        // This is the queue of LLVM work items that still need processing.\n-        let mut work_items = Vec::<(WorkItem, u64)>::new();\n-\n-        // This are the Jobserver Tokens we currently hold. Does not include\n-        // the implicit Token the compiler process owns no matter what.\n-        let mut tokens = Vec::new();\n-\n-        let mut main_thread_worker_state = MainThreadWorkerState::Idle;\n-        let mut running = 0;\n-\n-        let mut llvm_start_time = None;\n-\n-        // Run the message loop while there's still anything that needs message\n-        // processing. Note that as soon as codegen is aborted we simply want to\n-        // wait for all existing work to finish, so many of the conditions here\n-        // only apply if codegen hasn't been aborted as they represent pending\n-        // work to be done.\n-        while !codegen_done ||\n-              running > 0 ||\n-              (!codegen_aborted && (\n-                  work_items.len() > 0 ||\n-                  needs_lto.len() > 0 ||\n-                  lto_import_only_modules.len() > 0 ||\n-                  main_thread_worker_state != MainThreadWorkerState::Idle\n-              ))\n-        {\n-\n-            // While there are still CGUs to be codegened, the coordinator has\n-            // to decide how to utilize the compiler processes implicit Token:\n-            // For codegenning more CGU or for running them through LLVM.\n-            if !codegen_done {\n-                if main_thread_worker_state == MainThreadWorkerState::Idle {\n-                    if !queue_full_enough(work_items.len(), running, max_workers) {\n-                        // The queue is not full enough, codegen more items:\n-                        if let Err(_) = codegen_worker_send.send(Message::CodegenItem) {\n-                            panic!(\"Could not send Message::CodegenItem to main thread\")\n-                        }\n-                        main_thread_worker_state = MainThreadWorkerState::Codegenning;\n-                    } else {\n-                        // The queue is full enough to not let the worker\n-                        // threads starve. Use the implicit Token to do some\n-                        // LLVM work too.\n-                        let (item, _) = work_items.pop()\n-                            .expect(\"queue empty - queue_full_enough() broken?\");\n-                        let cgcx = CodegenContext {\n-                            worker: get_worker_id(&mut free_worker_ids),\n-                            .. cgcx.clone()\n-                        };\n-                        maybe_start_llvm_timer(cgcx.config(item.module_kind()),\n-                                               &mut llvm_start_time);\n-                        main_thread_worker_state = MainThreadWorkerState::LLVMing;\n-                        spawn_work(cgcx, item);\n-                    }\n-                }\n-            } else if codegen_aborted {\n-                // don't queue up any more work if codegen was aborted, we're\n-                // just waiting for our existing children to finish\n-            } else {\n-                // If we've finished everything related to normal codegen\n-                // then it must be the case that we've got some LTO work to do.\n-                // Perform the serial work here of figuring out what we're\n-                // going to LTO and then push a bunch of work items onto our\n-                // queue to do LTO\n-                if work_items.len() == 0 &&\n-                   running == 0 &&\n-                   main_thread_worker_state == MainThreadWorkerState::Idle {\n-                    assert!(!started_lto);\n-                    assert!(needs_lto.len() + lto_import_only_modules.len() > 0);\n-                    started_lto = true;\n-                    let modules = mem::replace(&mut needs_lto, Vec::new());\n-                    let import_only_modules =\n-                        mem::replace(&mut lto_import_only_modules, Vec::new());\n-                    for (work, cost) in generate_lto_work(&cgcx, modules, import_only_modules) {\n-                        let insertion_index = work_items\n-                            .binary_search_by_key(&cost, |&(_, cost)| cost)\n-                            .unwrap_or_else(|e| e);\n-                        work_items.insert(insertion_index, (work, cost));\n-                        if !cgcx.opts.debugging_opts.no_parallel_llvm {\n-                            helper.request_token();\n-                        }\n-                    }\n-                }\n-\n-                // In this branch, we know that everything has been codegened,\n-                // so it's just a matter of determining whether the implicit\n-                // Token is free to use for LLVM work.\n-                match main_thread_worker_state {\n-                    MainThreadWorkerState::Idle => {\n-                        if let Some((item, _)) = work_items.pop() {\n-                            let cgcx = CodegenContext {\n-                                worker: get_worker_id(&mut free_worker_ids),\n-                                .. cgcx.clone()\n-                            };\n-                            maybe_start_llvm_timer(cgcx.config(item.module_kind()),\n-                                                   &mut llvm_start_time);\n-                            main_thread_worker_state = MainThreadWorkerState::LLVMing;\n-                            spawn_work(cgcx, item);\n-                        } else {\n-                            // There is no unstarted work, so let the main thread\n-                            // take over for a running worker. Otherwise the\n-                            // implicit token would just go to waste.\n-                            // We reduce the `running` counter by one. The\n-                            // `tokens.truncate()` below will take care of\n-                            // giving the Token back.\n-                            debug_assert!(running > 0);\n-                            running -= 1;\n-                            main_thread_worker_state = MainThreadWorkerState::LLVMing;\n-                        }\n-                    }\n-                    MainThreadWorkerState::Codegenning => {\n-                        bug!(\"codegen worker should not be codegenning after \\\n-                              codegen was already completed\")\n-                    }\n-                    MainThreadWorkerState::LLVMing => {\n-                        // Already making good use of that token\n-                    }\n-                }\n-            }\n-\n-            // Spin up what work we can, only doing this while we've got available\n-            // parallelism slots and work left to spawn.\n-            while !codegen_aborted && work_items.len() > 0 && running < tokens.len() {\n-                let (item, _) = work_items.pop().unwrap();\n-\n-                maybe_start_llvm_timer(cgcx.config(item.module_kind()),\n-                                       &mut llvm_start_time);\n-\n-                let cgcx = CodegenContext {\n-                    worker: get_worker_id(&mut free_worker_ids),\n-                    .. cgcx.clone()\n-                };\n-\n-                spawn_work(cgcx, item);\n-                running += 1;\n-            }\n-\n-            // Relinquish accidentally acquired extra tokens\n-            tokens.truncate(running);\n-\n-            let msg = coordinator_receive.recv().unwrap();\n-            match *msg.downcast::<Message>().ok().unwrap() {\n-                // Save the token locally and the next turn of the loop will use\n-                // this to spawn a new unit of work, or it may get dropped\n-                // immediately if we have no more work to spawn.\n-                Message::Token(token) => {\n-                    match token {\n-                        Ok(token) => {\n-                            tokens.push(token);\n-\n-                            if main_thread_worker_state == MainThreadWorkerState::LLVMing {\n-                                // If the main thread token is used for LLVM work\n-                                // at the moment, we turn that thread into a regular\n-                                // LLVM worker thread, so the main thread is free\n-                                // to react to codegen demand.\n-                                main_thread_worker_state = MainThreadWorkerState::Idle;\n-                                running += 1;\n-                            }\n-                        }\n-                        Err(e) => {\n-                            let msg = &format!(\"failed to acquire jobserver token: {}\", e);\n-                            shared_emitter.fatal(msg);\n-                            // Exit the coordinator thread\n-                            panic!(\"{}\", msg)\n-                        }\n-                    }\n-                }\n-\n-                Message::CodegenDone { llvm_work_item, cost } => {\n-                    // We keep the queue sorted by estimated processing cost,\n-                    // so that more expensive items are processed earlier. This\n-                    // is good for throughput as it gives the main thread more\n-                    // time to fill up the queue and it avoids scheduling\n-                    // expensive items to the end.\n-                    // Note, however, that this is not ideal for memory\n-                    // consumption, as LLVM module sizes are not evenly\n-                    // distributed.\n-                    let insertion_index =\n-                        work_items.binary_search_by_key(&cost, |&(_, cost)| cost);\n-                    let insertion_index = match insertion_index {\n-                        Ok(idx) | Err(idx) => idx\n-                    };\n-                    work_items.insert(insertion_index, (llvm_work_item, cost));\n-\n-                    if !cgcx.opts.debugging_opts.no_parallel_llvm {\n-                        helper.request_token();\n-                    }\n-                    assert!(!codegen_aborted);\n-                    assert_eq!(main_thread_worker_state,\n-                               MainThreadWorkerState::Codegenning);\n-                    main_thread_worker_state = MainThreadWorkerState::Idle;\n-                }\n-\n-                Message::CodegenComplete => {\n-                    codegen_done = true;\n-                    assert!(!codegen_aborted);\n-                    assert_eq!(main_thread_worker_state,\n-                               MainThreadWorkerState::Codegenning);\n-                    main_thread_worker_state = MainThreadWorkerState::Idle;\n-                }\n-\n-                // If codegen is aborted that means translation was aborted due\n-                // to some normal-ish compiler error. In this situation we want\n-                // to exit as soon as possible, but we want to make sure all\n-                // existing work has finished. Flag codegen as being done, and\n-                // then conditions above will ensure no more work is spawned but\n-                // we'll keep executing this loop until `running` hits 0.\n-                Message::CodegenAborted => {\n-                    assert!(!codegen_aborted);\n-                    codegen_done = true;\n-                    codegen_aborted = true;\n-                    assert_eq!(main_thread_worker_state,\n-                               MainThreadWorkerState::Codegenning);\n-                }\n-\n-                // If a thread exits successfully then we drop a token associated\n-                // with that worker and update our `running` count. We may later\n-                // re-acquire a token to continue running more work. We may also not\n-                // actually drop a token here if the worker was running with an\n-                // \"ephemeral token\"\n-                //\n-                // Note that if the thread failed that means it panicked, so we\n-                // abort immediately.\n-                Message::Done { result: Ok(compiled_module), worker_id } => {\n-                    if main_thread_worker_state == MainThreadWorkerState::LLVMing {\n-                        main_thread_worker_state = MainThreadWorkerState::Idle;\n-                    } else {\n-                        running -= 1;\n-                    }\n-\n-                    free_worker_ids.push(worker_id);\n-\n-                    match compiled_module.kind {\n-                        ModuleKind::Regular => {\n-                            compiled_modules.push(compiled_module);\n-                        }\n-                        ModuleKind::Metadata => {\n-                            assert!(compiled_metadata_module.is_none());\n-                            compiled_metadata_module = Some(compiled_module);\n-                        }\n-                        ModuleKind::Allocator => {\n-                            assert!(compiled_allocator_module.is_none());\n-                            compiled_allocator_module = Some(compiled_module);\n-                        }\n-                    }\n-                }\n-                Message::NeedsLTO { result, worker_id } => {\n-                    assert!(!started_lto);\n-                    if main_thread_worker_state == MainThreadWorkerState::LLVMing {\n-                        main_thread_worker_state = MainThreadWorkerState::Idle;\n-                    } else {\n-                        running -= 1;\n-                    }\n-                    free_worker_ids.push(worker_id);\n-                    needs_lto.push(result);\n-                }\n-                Message::AddImportOnlyModule { module_data, work_product } => {\n-                    assert!(!started_lto);\n-                    assert!(!codegen_done);\n-                    assert_eq!(main_thread_worker_state,\n-                               MainThreadWorkerState::Codegenning);\n-                    lto_import_only_modules.push((module_data, work_product));\n-                    main_thread_worker_state = MainThreadWorkerState::Idle;\n-                }\n-                Message::Done { result: Err(()), worker_id: _ } => {\n-                    bug!(\"worker thread panicked\");\n-                }\n-                Message::CodegenItem => {\n-                    bug!(\"the coordinator should not receive codegen requests\")\n-                }\n-            }\n-        }\n-\n-        if let Some(llvm_start_time) = llvm_start_time {\n-            let total_llvm_time = Instant::now().duration_since(llvm_start_time);\n-            // This is the top-level timing for all of LLVM, set the time-depth\n-            // to zero.\n-            set_time_depth(0);\n-            print_time_passes_entry(cgcx.time_passes,\n-                                    \"LLVM passes\",\n-                                    total_llvm_time);\n-        }\n-\n-        // Regardless of what order these modules completed in, report them to\n-        // the backend in the same order every time to ensure that we're handing\n-        // out deterministic results.\n-        compiled_modules.sort_by(|a, b| a.name.cmp(&b.name));\n-\n-        let compiled_metadata_module = compiled_metadata_module\n-            .expect(\"Metadata module not compiled?\");\n-\n-        Ok(CompiledModules {\n-            modules: compiled_modules,\n-            metadata_module: compiled_metadata_module,\n-            allocator_module: compiled_allocator_module,\n-        })\n-    });\n-\n-    // A heuristic that determines if we have enough LLVM WorkItems in the\n-    // queue so that the main thread can do LLVM work instead of codegen\n-    fn queue_full_enough(items_in_queue: usize,\n-                         workers_running: usize,\n-                         max_workers: usize) -> bool {\n-        // Tune me, plz.\n-        items_in_queue > 0 &&\n-        items_in_queue >= max_workers.saturating_sub(workers_running / 2)\n-    }\n-\n-    fn maybe_start_llvm_timer(config: &ModuleConfig,\n-                              llvm_start_time: &mut Option<Instant>) {\n-        // We keep track of the -Ztime-passes output manually,\n-        // since the closure-based interface does not fit well here.\n-        if config.time_passes {\n-            if llvm_start_time.is_none() {\n-                *llvm_start_time = Some(Instant::now());\n-            }\n-        }\n-    }\n-}\n-\n-pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n-pub const CODEGEN_WORKER_TIMELINE: time_graph::TimelineId =\n-    time_graph::TimelineId(CODEGEN_WORKER_ID);\n-pub const CODEGEN_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n-    time_graph::WorkPackageKind(&[\"#DE9597\", \"#FED1D3\", \"#FDC5C7\", \"#B46668\", \"#88494B\"]);\n-const LLVM_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n-    time_graph::WorkPackageKind(&[\"#7DB67A\", \"#C6EEC4\", \"#ACDAAA\", \"#579354\", \"#3E6F3C\"]);\n-\n-fn spawn_work(cgcx: CodegenContext, work: WorkItem) {\n-    let depth = time_depth();\n-\n-    thread::spawn(move || {\n-        set_time_depth(depth);\n-\n-        // Set up a destructor which will fire off a message that we're done as\n-        // we exit.\n-        struct Bomb {\n-            coordinator_send: Sender<Box<dyn Any + Send>>,\n-            result: Option<WorkItemResult>,\n-            worker_id: usize,\n-        }\n-        impl Drop for Bomb {\n-            fn drop(&mut self) {\n-                let worker_id = self.worker_id;\n-                let msg = match self.result.take() {\n-                    Some(WorkItemResult::Compiled(m)) => {\n-                        Message::Done { result: Ok(m), worker_id }\n-                    }\n-                    Some(WorkItemResult::NeedsLTO(m)) => {\n-                        Message::NeedsLTO { result: m, worker_id }\n-                    }\n-                    None => Message::Done { result: Err(()), worker_id }\n-                };\n-                drop(self.coordinator_send.send(Box::new(msg)));\n-            }\n-        }\n-\n-        let mut bomb = Bomb {\n-            coordinator_send: cgcx.coordinator_send.clone(),\n-            result: None,\n-            worker_id: cgcx.worker,\n-        };\n-\n-        // Execute the work itself, and if it finishes successfully then flag\n-        // ourselves as a success as well.\n-        //\n-        // Note that we ignore any `FatalError` coming out of `execute_work_item`,\n-        // as a diagnostic was already sent off to the main thread - just\n-        // surface that there was an error in this worker.\n-        bomb.result = {\n-            let timeline = cgcx.time_graph.as_ref().map(|tg| {\n-                tg.start(time_graph::TimelineId(cgcx.worker),\n-                         LLVM_WORK_PACKAGE_KIND,\n-                         &work.name())\n-            });\n-            let mut timeline = timeline.unwrap_or(Timeline::noop());\n-            execute_work_item(&cgcx, work, &mut timeline).ok()\n-        };\n-    });\n-}\n-\n-pub fn run_assembler(cgcx: &CodegenContext, handler: &Handler, assembly: &Path, object: &Path) {\n-    let assembler = cgcx.assembler_cmd\n-        .as_ref()\n-        .expect(\"cgcx.assembler_cmd is missing?\");\n-\n-    let pname = &assembler.name;\n-    let mut cmd = assembler.cmd.clone();\n-    cmd.arg(\"-c\").arg(\"-o\").arg(object).arg(assembly);\n-    debug!(\"{:?}\", cmd);\n-\n-    match cmd.output() {\n-        Ok(prog) => {\n-            if !prog.status.success() {\n-                let mut note = prog.stderr.clone();\n-                note.extend_from_slice(&prog.stdout);\n-\n-                handler.struct_err(&format!(\"linking with `{}` failed: {}\",\n-                                            pname.display(),\n-                                            prog.status))\n-                       .note(&format!(\"{:?}\", &cmd))\n-                       .note(str::from_utf8(&note[..]).unwrap())\n-                       .emit();\n-                handler.abort_if_errors();\n-            }\n-        },\n-        Err(e) => {\n-            handler.err(&format!(\"could not exec the linker `{}`: {}\", pname.display(), e));\n-            handler.abort_if_errors();\n-        }\n-    }\n-}\n-\n pub unsafe fn with_llvm_pmb(llmod: &llvm::Module,\n                             config: &ModuleConfig,\n                             opt_level: llvm::CodeGenOptLevel,\n@@ -2204,7 +698,7 @@ pub unsafe fn with_llvm_pmb(llmod: &llvm::Module,\n     // reasonable defaults and prepare it to actually populate the pass\n     // manager.\n     let builder = llvm::LLVMPassManagerBuilderCreate();\n-    let opt_size = config.opt_size.unwrap_or(llvm::CodeGenOptSizeNone);\n+    let opt_size = config.opt_size.map(get_llvm_opt_size).unwrap_or(llvm::CodeGenOptSizeNone);\n     let inline_threshold = config.inline_threshold;\n \n     let pgo_gen_path = config.pgo_gen.as_ref().map(|s| {\n@@ -2272,295 +766,16 @@ pub unsafe fn with_llvm_pmb(llmod: &llvm::Module,\n     llvm::LLVMPassManagerBuilderDispose(builder);\n }\n \n-\n-enum SharedEmitterMessage {\n-    Diagnostic(Diagnostic),\n-    InlineAsmError(u32, String),\n-    AbortIfErrors,\n-    Fatal(String),\n-}\n-\n-#[derive(Clone)]\n-pub struct SharedEmitter {\n-    sender: Sender<SharedEmitterMessage>,\n-}\n-\n-pub struct SharedEmitterMain {\n-    receiver: Receiver<SharedEmitterMessage>,\n-}\n-\n-impl SharedEmitter {\n-    pub fn new() -> (SharedEmitter, SharedEmitterMain) {\n-        let (sender, receiver) = channel();\n-\n-        (SharedEmitter { sender }, SharedEmitterMain { receiver })\n-    }\n-\n-    fn inline_asm_error(&self, cookie: u32, msg: String) {\n-        drop(self.sender.send(SharedEmitterMessage::InlineAsmError(cookie, msg)));\n-    }\n-\n-    fn fatal(&self, msg: &str) {\n-        drop(self.sender.send(SharedEmitterMessage::Fatal(msg.to_string())));\n-    }\n-}\n-\n-impl Emitter for SharedEmitter {\n-    fn emit(&mut self, db: &DiagnosticBuilder) {\n-        drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n-            msg: db.message(),\n-            code: db.code.clone(),\n-            lvl: db.level,\n-        })));\n-        for child in &db.children {\n-            drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n-                msg: child.message(),\n-                code: None,\n-                lvl: child.level,\n-            })));\n-        }\n-        drop(self.sender.send(SharedEmitterMessage::AbortIfErrors));\n-    }\n-}\n-\n-impl SharedEmitterMain {\n-    pub fn check(&self, sess: &Session, blocking: bool) {\n-        loop {\n-            let message = if blocking {\n-                match self.receiver.recv() {\n-                    Ok(message) => Ok(message),\n-                    Err(_) => Err(()),\n-                }\n-            } else {\n-                match self.receiver.try_recv() {\n-                    Ok(message) => Ok(message),\n-                    Err(_) => Err(()),\n-                }\n-            };\n-\n-            match message {\n-                Ok(SharedEmitterMessage::Diagnostic(diag)) => {\n-                    let handler = sess.diagnostic();\n-                    match diag.code {\n-                        Some(ref code) => {\n-                            handler.emit_with_code(&MultiSpan::new(),\n-                                                   &diag.msg,\n-                                                   code.clone(),\n-                                                   diag.lvl);\n-                        }\n-                        None => {\n-                            handler.emit(&MultiSpan::new(),\n-                                         &diag.msg,\n-                                         diag.lvl);\n-                        }\n-                    }\n-                }\n-                Ok(SharedEmitterMessage::InlineAsmError(cookie, msg)) => {\n-                    match Mark::from_u32(cookie).expn_info() {\n-                        Some(ei) => sess.span_err(ei.call_site, &msg),\n-                        None     => sess.err(&msg),\n-                    }\n-                }\n-                Ok(SharedEmitterMessage::AbortIfErrors) => {\n-                    sess.abort_if_errors();\n-                }\n-                Ok(SharedEmitterMessage::Fatal(msg)) => {\n-                    sess.fatal(&msg);\n-                }\n-                Err(_) => {\n-                    break;\n-                }\n-            }\n-\n-        }\n-    }\n-}\n-\n-pub struct OngoingCodegen {\n-    crate_name: Symbol,\n-    crate_hash: Svh,\n-    metadata: EncodedMetadata,\n-    windows_subsystem: Option<String>,\n-    linker_info: LinkerInfo,\n-    crate_info: CrateInfo,\n-    time_graph: Option<TimeGraph>,\n-    coordinator_send: Sender<Box<dyn Any + Send>>,\n-    codegen_worker_receive: Receiver<Message>,\n-    shared_emitter_main: SharedEmitterMain,\n-    future: thread::JoinHandle<Result<CompiledModules, ()>>,\n-    output_filenames: Arc<OutputFilenames>,\n-}\n-\n-impl OngoingCodegen {\n-    pub(crate) fn join(\n-        self,\n-        sess: &Session\n-    ) -> (CodegenResults, FxHashMap<WorkProductId, WorkProduct>) {\n-        self.shared_emitter_main.check(sess, true);\n-        let compiled_modules = match self.future.join() {\n-            Ok(Ok(compiled_modules)) => compiled_modules,\n-            Ok(Err(())) => {\n-                sess.abort_if_errors();\n-                panic!(\"expected abort due to worker thread errors\")\n-            },\n-            Err(_) => {\n-                bug!(\"panic during codegen/LLVM phase\");\n-            }\n-        };\n-\n-        sess.cgu_reuse_tracker.check_expected_reuse(sess);\n-\n-        sess.abort_if_errors();\n-\n-        if let Some(time_graph) = self.time_graph {\n-            time_graph.dump(&format!(\"{}-timings\", self.crate_name));\n-        }\n-\n-        let work_products =\n-            copy_all_cgu_workproducts_to_incr_comp_cache_dir(sess,\n-                                                             &compiled_modules);\n-        produce_final_output_artifacts(sess,\n-                                       &compiled_modules,\n-                                       &self.output_filenames);\n-\n-        // FIXME: time_llvm_passes support - does this use a global context or\n-        // something?\n-        if sess.codegen_units() == 1 && sess.time_llvm_passes() {\n-            unsafe { llvm::LLVMRustPrintPassTimings(); }\n-        }\n-\n-        (CodegenResults {\n-            crate_name: self.crate_name,\n-            crate_hash: self.crate_hash,\n-            metadata: self.metadata,\n-            windows_subsystem: self.windows_subsystem,\n-            linker_info: self.linker_info,\n-            crate_info: self.crate_info,\n-\n-            modules: compiled_modules.modules,\n-            allocator_module: compiled_modules.allocator_module,\n-            metadata_module: compiled_modules.metadata_module,\n-        }, work_products)\n-    }\n-\n-    pub(crate) fn submit_pre_codegened_module_to_llvm(&self,\n-                                                      tcx: TyCtxt,\n-                                                      module: ModuleCodegen) {\n-        self.wait_for_signal_to_codegen_item();\n-        self.check_for_errors(tcx.sess);\n-\n-        // These are generally cheap and won't through off scheduling.\n-        let cost = 0;\n-        submit_codegened_module_to_llvm(tcx, module, cost);\n-    }\n-\n-    pub fn codegen_finished(&self, tcx: TyCtxt) {\n-        self.wait_for_signal_to_codegen_item();\n-        self.check_for_errors(tcx.sess);\n-        drop(self.coordinator_send.send(Box::new(Message::CodegenComplete)));\n-    }\n-\n-    /// Consume this context indicating that codegen was entirely aborted, and\n-    /// we need to exit as quickly as possible.\n-    ///\n-    /// This method blocks the current thread until all worker threads have\n-    /// finished, and all worker threads should have exited or be real close to\n-    /// exiting at this point.\n-    pub fn codegen_aborted(self) {\n-        // Signal to the coordinator it should spawn no more work and start\n-        // shutdown.\n-        drop(self.coordinator_send.send(Box::new(Message::CodegenAborted)));\n-        drop(self.future.join());\n-    }\n-\n-    pub fn check_for_errors(&self, sess: &Session) {\n-        self.shared_emitter_main.check(sess, false);\n-    }\n-\n-    pub fn wait_for_signal_to_codegen_item(&self) {\n-        match self.codegen_worker_receive.recv() {\n-            Ok(Message::CodegenItem) => {\n-                // Nothing to do\n-            }\n-            Ok(_) => panic!(\"unexpected message\"),\n-            Err(_) => {\n-                // One of the LLVM threads must have panicked, fall through so\n-                // error handling can be reached.\n-            }\n-        }\n-    }\n-}\n-\n-// impl Drop for OngoingCodegen {\n-//     fn drop(&mut self) {\n-//     }\n-// }\n-\n-pub(crate) fn submit_codegened_module_to_llvm(tcx: TyCtxt,\n-                                              module: ModuleCodegen,\n-                                              cost: u64) {\n-    let llvm_work_item = WorkItem::Optimize(module);\n-    drop(tcx.tx_to_llvm_workers.lock().send(Box::new(Message::CodegenDone {\n-        llvm_work_item,\n-        cost,\n-    })));\n-}\n-\n-pub(crate) fn submit_post_lto_module_to_llvm(tcx: TyCtxt,\n-                                             module: CachedModuleCodegen) {\n-    let llvm_work_item = WorkItem::CopyPostLtoArtifacts(module);\n-    drop(tcx.tx_to_llvm_workers.lock().send(Box::new(Message::CodegenDone {\n-        llvm_work_item,\n-        cost: 0,\n-    })));\n-}\n-\n-pub(crate) fn submit_pre_lto_module_to_llvm(tcx: TyCtxt,\n-                                            module: CachedModuleCodegen) {\n-    let filename = pre_lto_bitcode_filename(&module.name);\n-    let bc_path = in_incr_comp_dir_sess(tcx.sess, &filename);\n-    let file = fs::File::open(&bc_path).unwrap_or_else(|e| {\n-        panic!(\"failed to open bitcode file `{}`: {}\", bc_path.display(), e)\n-    });\n-\n-    let mmap = unsafe {\n-        memmap::Mmap::map(&file).unwrap_or_else(|e| {\n-            panic!(\"failed to mmap bitcode file `{}`: {}\", bc_path.display(), e)\n-        })\n-    };\n-\n-    // Schedule the module to be loaded\n-    drop(tcx.tx_to_llvm_workers.lock().send(Box::new(Message::AddImportOnlyModule {\n-        module_data: SerializedModule::FromUncompressedFile(mmap),\n-        work_product: module.source,\n-    })));\n-}\n-\n-pub(super) fn pre_lto_bitcode_filename(module_name: &str) -> String {\n-    format!(\"{}.{}\", module_name, PRE_THIN_LTO_BC_EXT)\n-}\n-\n-fn msvc_imps_needed(tcx: TyCtxt) -> bool {\n-    // This should never be true (because it's not supported). If it is true,\n-    // something is wrong with commandline arg validation.\n-    assert!(!(tcx.sess.opts.debugging_opts.cross_lang_lto.enabled() &&\n-              tcx.sess.target.target.options.is_like_msvc &&\n-              tcx.sess.opts.cg.prefer_dynamic));\n-\n-    tcx.sess.target.target.options.is_like_msvc &&\n-        tcx.sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateType::Rlib) &&\n-    // ThinLTO can't handle this workaround in all cases, so we don't\n-    // emit the `__imp_` symbols. Instead we make them unnecessary by disallowing\n-    // dynamic linking when cross-language LTO is enabled.\n-    !tcx.sess.opts.debugging_opts.cross_lang_lto.enabled()\n-}\n-\n // Create a `__imp_<symbol> = &symbol` global for every public static `symbol`.\n // This is required to satisfy `dllimport` references to static data in .rlibs\n // when using MSVC linker.  We do this only for data, as linker can fix up\n // code references on its own.\n // See #26591, #27438\n-fn create_msvc_imps(cgcx: &CodegenContext, llcx: &llvm::Context, llmod: &llvm::Module) {\n+fn create_msvc_imps(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    llcx: &llvm::Context,\n+    llmod: &llvm::Module\n+) {\n     if !cgcx.msvc_imps_needed {\n         return\n     }"}, {"sha": "78693a395b3907f03d0be552e3318d0b83f9bddd", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 47, "deletions": 1041, "changes": 1088, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -24,585 +24,39 @@\n //!     int) and rec(x=int, y=int, z=int) will have the same llvm::Type.\n \n use super::ModuleLlvm;\n-use super::ModuleCodegen;\n-use super::ModuleKind;\n-use super::CachedModuleCodegen;\n+use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n+use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n+use super::LlvmCodegenBackend;\n \n-use abi;\n-use back::write::{self, OngoingCodegen};\n-use llvm::{self, TypeKind, get_param};\n+use llvm;\n use metadata;\n-use rustc::dep_graph::cgu_reuse_tracker::CguReuse;\n-use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc::middle::lang_items::StartFnLangItem;\n-use rustc::middle::weak_lang_items;\n-use rustc::mir::mono::{Linkage, Visibility, Stats, CodegenUnitNameBuilder};\n+use rustc::mir::mono::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata};\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx};\n-use rustc::ty::query::Providers;\n-use rustc::middle::cstore::{self, LinkagePreference};\n+use rustc::ty::TyCtxt;\n use rustc::middle::exported_symbols;\n-use rustc::util::common::{time, print_time_passes_entry};\n-use rustc::util::profiling::ProfileCategory;\n-use rustc::session::config::{self, DebugInfo, EntryFnType, Lto};\n-use rustc::session::Session;\n-use rustc_incremental;\n-use allocator;\n-use mir::place::PlaceRef;\n-use attributes;\n-use builder::{Builder, MemFlags};\n-use callee;\n-use common::{C_bool, C_bytes_in_context, C_usize};\n-use rustc_mir::monomorphize::item::DefPathBasedNames;\n-use common::{C_struct_in_context, C_array, val_ty};\n-use consts;\n+use rustc::session::config::{self, DebugInfo};\n+use builder::Builder;\n+use common;\n use context::CodegenCx;\n-use debuginfo;\n-use declare;\n-use meth;\n-use mir;\n-use monomorphize::Instance;\n-use monomorphize::partitioning::{CodegenUnit, CodegenUnitExt};\n-use rustc_codegen_utils::symbol_names_test;\n-use time_graph;\n-use mono_item::{MonoItem, MonoItemExt};\n-use type_::Type;\n-use type_of::LayoutLlvmExt;\n-use rustc::util::nodemap::FxHashMap;\n-use CrateInfo;\n+use monomorphize::partitioning::CodegenUnitExt;\n+use rustc_codegen_ssa::mono_item::MonoItemExt;\n use rustc_data_structures::small_c_str::SmallCStr;\n-use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::indexed_vec::Idx;\n \n-use std::any::Any;\n-use std::cmp;\n+use rustc_codegen_ssa::traits::*;\n+use rustc_codegen_ssa::back::write::submit_codegened_module_to_llvm;\n+\n use std::ffi::CString;\n-use std::ops::{Deref, DerefMut};\n-use std::sync::mpsc;\n-use std::time::{Instant, Duration};\n-use syntax_pos::Span;\n+use std::time::Instant;\n use syntax_pos::symbol::InternedString;\n-use syntax::attr;\n-use rustc::hir::{self, CodegenFnAttrs};\n+use rustc::hir::CodegenFnAttrs;\n \n use value::Value;\n \n-use mir::operand::OperandValue;\n-\n-use rustc_codegen_utils::check_for_rustc_errors_attr;\n-\n-pub struct StatRecorder<'a, 'll: 'a, 'tcx: 'll> {\n-    cx: &'a CodegenCx<'ll, 'tcx>,\n-    name: Option<String>,\n-    istart: usize,\n-}\n-\n-impl StatRecorder<'a, 'll, 'tcx> {\n-    pub fn new(cx: &'a CodegenCx<'ll, 'tcx>, name: String) -> Self {\n-        let istart = cx.stats.borrow().n_llvm_insns;\n-        StatRecorder {\n-            cx,\n-            name: Some(name),\n-            istart,\n-        }\n-    }\n-}\n-\n-impl Drop for StatRecorder<'a, 'll, 'tcx> {\n-    fn drop(&mut self) {\n-        if self.cx.sess().codegen_stats() {\n-            let mut stats = self.cx.stats.borrow_mut();\n-            let iend = stats.n_llvm_insns;\n-            stats.fn_stats.push((self.name.take().unwrap(), iend - self.istart));\n-            stats.n_fns += 1;\n-            // Reset LLVM insn count to avoid compound costs.\n-            stats.n_llvm_insns = self.istart;\n-        }\n-    }\n-}\n-\n-pub fn bin_op_to_icmp_predicate(op: hir::BinOpKind,\n-                                signed: bool)\n-                                -> llvm::IntPredicate {\n-    match op {\n-        hir::BinOpKind::Eq => llvm::IntEQ,\n-        hir::BinOpKind::Ne => llvm::IntNE,\n-        hir::BinOpKind::Lt => if signed { llvm::IntSLT } else { llvm::IntULT },\n-        hir::BinOpKind::Le => if signed { llvm::IntSLE } else { llvm::IntULE },\n-        hir::BinOpKind::Gt => if signed { llvm::IntSGT } else { llvm::IntUGT },\n-        hir::BinOpKind::Ge => if signed { llvm::IntSGE } else { llvm::IntUGE },\n-        op => {\n-            bug!(\"comparison_op_to_icmp_predicate: expected comparison operator, \\\n-                  found {:?}\",\n-                 op)\n-        }\n-    }\n-}\n-\n-pub fn bin_op_to_fcmp_predicate(op: hir::BinOpKind) -> llvm::RealPredicate {\n-    match op {\n-        hir::BinOpKind::Eq => llvm::RealOEQ,\n-        hir::BinOpKind::Ne => llvm::RealUNE,\n-        hir::BinOpKind::Lt => llvm::RealOLT,\n-        hir::BinOpKind::Le => llvm::RealOLE,\n-        hir::BinOpKind::Gt => llvm::RealOGT,\n-        hir::BinOpKind::Ge => llvm::RealOGE,\n-        op => {\n-            bug!(\"comparison_op_to_fcmp_predicate: expected comparison operator, \\\n-                  found {:?}\",\n-                 op);\n-        }\n-    }\n-}\n-\n-pub fn compare_simd_types(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    lhs: &'ll Value,\n-    rhs: &'ll Value,\n-    t: Ty<'tcx>,\n-    ret_ty: &'ll Type,\n-    op: hir::BinOpKind\n-) -> &'ll Value {\n-    let signed = match t.sty {\n-        ty::Float(_) => {\n-            let cmp = bin_op_to_fcmp_predicate(op);\n-            return bx.sext(bx.fcmp(cmp, lhs, rhs), ret_ty);\n-        },\n-        ty::Uint(_) => false,\n-        ty::Int(_) => true,\n-        _ => bug!(\"compare_simd_types: invalid SIMD type\"),\n-    };\n-\n-    let cmp = bin_op_to_icmp_predicate(op, signed);\n-    // LLVM outputs an `< size x i1 >`, so we need to perform a sign extension\n-    // to get the correctly sized type. This will compile to a single instruction\n-    // once the IR is converted to assembly if the SIMD instruction is supported\n-    // by the target architecture.\n-    bx.sext(bx.icmp(cmp, lhs, rhs), ret_ty)\n-}\n-\n-/// Retrieve the information we are losing (making dynamic) in an unsizing\n-/// adjustment.\n-///\n-/// The `old_info` argument is a bit funny. It is intended for use\n-/// in an upcast, where the new vtable for an object will be derived\n-/// from the old one.\n-pub fn unsized_info(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    source: Ty<'tcx>,\n-    target: Ty<'tcx>,\n-    old_info: Option<&'ll Value>,\n-) -> &'ll Value {\n-    let (source, target) = cx.tcx.struct_lockstep_tails(source, target);\n-    match (&source.sty, &target.sty) {\n-        (&ty::Array(_, len), &ty::Slice(_)) => {\n-            C_usize(cx, len.unwrap_usize(cx.tcx))\n-        }\n-        (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n-            // For now, upcasts are limited to changes in marker\n-            // traits, and hence never actually require an actual\n-            // change to the vtable.\n-            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n-        }\n-        (_, &ty::Dynamic(ref data, ..)) => {\n-            let vtable_ptr = cx.layout_of(cx.tcx.mk_mut_ptr(target))\n-                .field(cx, abi::FAT_PTR_EXTRA);\n-            consts::ptrcast(meth::get_vtable(cx, source, data.principal()),\n-                            vtable_ptr.llvm_type(cx))\n-        }\n-        _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n-                  source,\n-                  target),\n-    }\n-}\n-\n-/// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n-pub fn unsize_thin_ptr(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    src: &'ll Value,\n-    src_ty: Ty<'tcx>,\n-    dst_ty: Ty<'tcx>\n-) -> (&'ll Value, &'ll Value) {\n-    debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n-    match (&src_ty.sty, &dst_ty.sty) {\n-        (&ty::Ref(_, a, _),\n-         &ty::Ref(_, b, _)) |\n-        (&ty::Ref(_, a, _),\n-         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) |\n-        (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }),\n-         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            assert!(bx.cx.type_is_sized(a));\n-            let ptr_ty = bx.cx.layout_of(b).llvm_type(bx.cx).ptr_to();\n-            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx, a, b, None))\n-        }\n-        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n-            let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n-            assert!(bx.cx.type_is_sized(a));\n-            let ptr_ty = bx.cx.layout_of(b).llvm_type(bx.cx).ptr_to();\n-            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx, a, b, None))\n-        }\n-        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n-            assert_eq!(def_a, def_b);\n-\n-            let src_layout = bx.cx.layout_of(src_ty);\n-            let dst_layout = bx.cx.layout_of(dst_ty);\n-            let mut result = None;\n-            for i in 0..src_layout.fields.count() {\n-                let src_f = src_layout.field(bx.cx, i);\n-                assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n-                assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n-                if src_f.is_zst() {\n-                    continue;\n-                }\n-                assert_eq!(src_layout.size, src_f.size);\n-\n-                let dst_f = dst_layout.field(bx.cx, i);\n-                assert_ne!(src_f.ty, dst_f.ty);\n-                assert_eq!(result, None);\n-                result = Some(unsize_thin_ptr(bx, src, src_f.ty, dst_f.ty));\n-            }\n-            let (lldata, llextra) = result.unwrap();\n-            // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-            (bx.bitcast(lldata, dst_layout.scalar_pair_element_llvm_type(bx.cx, 0, true)),\n-             bx.bitcast(llextra, dst_layout.scalar_pair_element_llvm_type(bx.cx, 1, true)))\n-        }\n-        _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n-    }\n-}\n-\n-/// Coerce `src`, which is a reference to a value of type `src_ty`,\n-/// to a value of type `dst_ty` and store the result in `dst`\n-pub fn coerce_unsized_into(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    src: PlaceRef<'ll, 'tcx>,\n-    dst: PlaceRef<'ll, 'tcx>\n-) {\n-    let src_ty = src.layout.ty;\n-    let dst_ty = dst.layout.ty;\n-    let coerce_ptr = || {\n-        let (base, info) = match src.load(bx).val {\n-            OperandValue::Pair(base, info) => {\n-                // fat-ptr to fat-ptr unsize preserves the vtable\n-                // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n-                // So we need to pointercast the base to ensure\n-                // the types match up.\n-                let thin_ptr = dst.layout.field(bx.cx, abi::FAT_PTR_ADDR);\n-                (bx.pointercast(base, thin_ptr.llvm_type(bx.cx)), info)\n-            }\n-            OperandValue::Immediate(base) => {\n-                unsize_thin_ptr(bx, base, src_ty, dst_ty)\n-            }\n-            OperandValue::Ref(..) => bug!()\n-        };\n-        OperandValue::Pair(base, info).store(bx, dst);\n-    };\n-    match (&src_ty.sty, &dst_ty.sty) {\n-        (&ty::Ref(..), &ty::Ref(..)) |\n-        (&ty::Ref(..), &ty::RawPtr(..)) |\n-        (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n-            coerce_ptr()\n-        }\n-        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n-            coerce_ptr()\n-        }\n-\n-        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n-            assert_eq!(def_a, def_b);\n \n-            for i in 0..def_a.variants[VariantIdx::new(0)].fields.len() {\n-                let src_f = src.project_field(bx, i);\n-                let dst_f = dst.project_field(bx, i);\n-\n-                if dst_f.layout.is_zst() {\n-                    continue;\n-                }\n-\n-                if src_f.layout.ty == dst_f.layout.ty {\n-                    memcpy_ty(bx, dst_f.llval, dst_f.align, src_f.llval, src_f.align,\n-                              src_f.layout, MemFlags::empty());\n-                } else {\n-                    coerce_unsized_into(bx, src_f, dst_f);\n-                }\n-            }\n-        }\n-        _ => bug!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n-                  src_ty,\n-                  dst_ty),\n-    }\n-}\n-\n-pub fn cast_shift_expr_rhs(\n-    cx: &Builder<'_, 'll, '_>, op: hir::BinOpKind, lhs: &'ll Value, rhs: &'ll Value\n-) -> &'ll Value {\n-    cast_shift_rhs(op, lhs, rhs, |a, b| cx.trunc(a, b), |a, b| cx.zext(a, b))\n-}\n-\n-fn cast_shift_rhs<'ll, F, G>(op: hir::BinOpKind,\n-                             lhs: &'ll Value,\n-                             rhs: &'ll Value,\n-                             trunc: F,\n-                             zext: G)\n-                             -> &'ll Value\n-    where F: FnOnce(&'ll Value, &'ll Type) -> &'ll Value,\n-          G: FnOnce(&'ll Value, &'ll Type) -> &'ll Value\n-{\n-    // Shifts may have any size int on the rhs\n-    if op.is_shift() {\n-        let mut rhs_llty = val_ty(rhs);\n-        let mut lhs_llty = val_ty(lhs);\n-        if rhs_llty.kind() == TypeKind::Vector {\n-            rhs_llty = rhs_llty.element_type()\n-        }\n-        if lhs_llty.kind() == TypeKind::Vector {\n-            lhs_llty = lhs_llty.element_type()\n-        }\n-        let rhs_sz = rhs_llty.int_width();\n-        let lhs_sz = lhs_llty.int_width();\n-        if lhs_sz < rhs_sz {\n-            trunc(rhs, lhs_llty)\n-        } else if lhs_sz > rhs_sz {\n-            // FIXME (#1877: If in the future shifting by negative\n-            // values is no longer undefined then this is wrong.\n-            zext(rhs, lhs_llty)\n-        } else {\n-            rhs\n-        }\n-    } else {\n-        rhs\n-    }\n-}\n-\n-/// Returns whether this session's target will use SEH-based unwinding.\n-///\n-/// This is only true for MSVC targets, and even then the 64-bit MSVC target\n-/// currently uses SEH-ish unwinding with DWARF info tables to the side (same as\n-/// 64-bit MinGW) instead of \"full SEH\".\n-pub fn wants_msvc_seh(sess: &Session) -> bool {\n-    sess.target.target.options.is_like_msvc\n-}\n-\n-pub fn call_assume(bx: &Builder<'_, 'll, '_>, val: &'ll Value) {\n-    let assume_intrinsic = bx.cx.get_intrinsic(\"llvm.assume\");\n-    bx.call(assume_intrinsic, &[val], None);\n-}\n-\n-pub fn from_immediate(bx: &Builder<'_, 'll, '_>, val: &'ll Value) -> &'ll Value {\n-    if val_ty(val) == Type::i1(bx.cx) {\n-        bx.zext(val, Type::i8(bx.cx))\n-    } else {\n-        val\n-    }\n-}\n-\n-pub fn to_immediate(\n-    bx: &Builder<'_, 'll, '_>,\n-    val: &'ll Value,\n-    layout: layout::TyLayout,\n-) -> &'ll Value {\n-    if let layout::Abi::Scalar(ref scalar) = layout.abi {\n-        return to_immediate_scalar(bx, val, scalar);\n-    }\n-    val\n-}\n-\n-pub fn to_immediate_scalar(\n-    bx: &Builder<'_, 'll, '_>,\n-    val: &'ll Value,\n-    scalar: &layout::Scalar,\n-) -> &'ll Value {\n-    if scalar.is_bool() {\n-        return bx.trunc(val, Type::i1(bx.cx));\n-    }\n-    val\n-}\n-\n-pub fn call_memcpy(\n-    bx: &Builder<'_, 'll, '_>,\n-    dst: &'ll Value,\n-    dst_align: Align,\n-    src: &'ll Value,\n-    src_align: Align,\n-    n_bytes: &'ll Value,\n-    flags: MemFlags,\n-) {\n-    if flags.contains(MemFlags::NONTEMPORAL) {\n-        // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n-        let val = bx.load(src, src_align);\n-        let ptr = bx.pointercast(dst, val_ty(val).ptr_to());\n-        bx.store_with_flags(val, ptr, dst_align, flags);\n-        return;\n-    }\n-    let cx = bx.cx;\n-    let src_ptr = bx.pointercast(src, Type::i8p(cx));\n-    let dst_ptr = bx.pointercast(dst, Type::i8p(cx));\n-    let size = bx.intcast(n_bytes, cx.isize_ty, false);\n-    let volatile = flags.contains(MemFlags::VOLATILE);\n-    bx.memcpy(dst_ptr, dst_align.abi(), src_ptr, src_align.abi(), size, volatile);\n-}\n-\n-pub fn memcpy_ty(\n-    bx: &Builder<'_, 'll, 'tcx>,\n-    dst: &'ll Value,\n-    dst_align: Align,\n-    src: &'ll Value,\n-    src_align: Align,\n-    layout: TyLayout<'tcx>,\n-    flags: MemFlags,\n-) {\n-    let size = layout.size.bytes();\n-    if size == 0 {\n-        return;\n-    }\n-\n-    call_memcpy(bx, dst, dst_align, src, src_align, C_usize(bx.cx, size), flags);\n-}\n-\n-pub fn call_memset(\n-    bx: &Builder<'_, 'll, '_>,\n-    ptr: &'ll Value,\n-    fill_byte: &'ll Value,\n-    size: &'ll Value,\n-    align: &'ll Value,\n-    volatile: bool,\n-) -> &'ll Value {\n-    let ptr_width = &bx.cx.sess().target.target.target_pointer_width;\n-    let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n-    let llintrinsicfn = bx.cx.get_intrinsic(&intrinsic_key);\n-    let volatile = C_bool(bx.cx, volatile);\n-    bx.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n-}\n-\n-pub fn codegen_instance<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, instance: Instance<'tcx>) {\n-    let _s = if cx.sess().codegen_stats() {\n-        let mut instance_name = String::new();\n-        DefPathBasedNames::new(cx.tcx, true, true)\n-            .push_def_path(instance.def_id(), &mut instance_name);\n-        Some(StatRecorder::new(cx, instance_name))\n-    } else {\n-        None\n-    };\n-\n-    // this is an info! to allow collecting monomorphization statistics\n-    // and to allow finding the last function before LLVM aborts from\n-    // release builds.\n-    info!(\"codegen_instance({})\", instance);\n-\n-    let sig = instance.fn_sig(cx.tcx);\n-    let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-\n-    let lldecl = cx.instances.borrow().get(&instance).cloned().unwrap_or_else(||\n-        bug!(\"Instance `{:?}` not already declared\", instance));\n-\n-    cx.stats.borrow_mut().n_closures += 1;\n-\n-    let mir = cx.tcx.instance_mir(instance.def);\n-    mir::codegen_mir(cx, lldecl, &mir, instance, sig);\n-}\n-\n-pub fn set_link_section(llval: &Value, attrs: &CodegenFnAttrs) {\n-    let sect = match attrs.link_section {\n-        Some(name) => name,\n-        None => return,\n-    };\n-    unsafe {\n-        let buf = SmallCStr::new(&sect.as_str());\n-        llvm::LLVMSetSection(llval, buf.as_ptr());\n-    }\n-}\n-\n-/// Create the `main` function which will initialize the rust runtime and call\n-/// users main function.\n-fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n-    let (main_def_id, span) = match *cx.sess().entry_fn.borrow() {\n-        Some((id, span, _)) => {\n-            (cx.tcx.hir.local_def_id(id), span)\n-        }\n-        None => return,\n-    };\n-\n-    let instance = Instance::mono(cx.tcx, main_def_id);\n-\n-    if !cx.codegen_unit.contains_item(&MonoItem::Fn(instance)) {\n-        // We want to create the wrapper in the same codegen unit as Rust's main\n-        // function.\n-        return;\n-    }\n-\n-    let main_llfn = callee::get_fn(cx, instance);\n-\n-    let et = cx.sess().entry_fn.get().map(|e| e.2);\n-    match et {\n-        Some(EntryFnType::Main) => create_entry_fn(cx, span, main_llfn, main_def_id, true),\n-        Some(EntryFnType::Start) => create_entry_fn(cx, span, main_llfn, main_def_id, false),\n-        None => {}    // Do nothing.\n-    }\n-\n-    fn create_entry_fn(\n-        cx: &CodegenCx<'ll, '_>,\n-        sp: Span,\n-        rust_main: &'ll Value,\n-        rust_main_def_id: DefId,\n-        use_start_lang_item: bool,\n-    ) {\n-        let llfty = Type::func(&[Type::c_int(cx), Type::i8p(cx).ptr_to()], Type::c_int(cx));\n-\n-        let main_ret_ty = cx.tcx.fn_sig(rust_main_def_id).output();\n-        // Given that `main()` has no arguments,\n-        // then its return type cannot have\n-        // late-bound regions, since late-bound\n-        // regions must appear in the argument\n-        // listing.\n-        let main_ret_ty = cx.tcx.erase_regions(\n-            &main_ret_ty.no_bound_vars().unwrap(),\n-        );\n-\n-        if declare::get_defined_value(cx, \"main\").is_some() {\n-            // FIXME: We should be smart and show a better diagnostic here.\n-            cx.sess().struct_span_err(sp, \"entry symbol `main` defined multiple times\")\n-                     .help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\")\n-                     .emit();\n-            cx.sess().abort_if_errors();\n-            bug!();\n-        }\n-        let llfn = declare::declare_cfn(cx, \"main\", llfty);\n-\n-        // `main` should respect same config for frame pointer elimination as rest of code\n-        attributes::set_frame_pointer_elimination(cx, llfn);\n-        attributes::apply_target_cpu_attr(cx, llfn);\n-\n-        let bx = Builder::new_block(cx, llfn, \"top\");\n-\n-        debuginfo::gdb::insert_reference_to_gdb_debug_scripts_section_global(&bx);\n-\n-        // Params from native main() used as args for rust start function\n-        let param_argc = get_param(llfn, 0);\n-        let param_argv = get_param(llfn, 1);\n-        let arg_argc = bx.intcast(param_argc, cx.isize_ty, true);\n-        let arg_argv = param_argv;\n-\n-        let (start_fn, args) = if use_start_lang_item {\n-            let start_def_id = cx.tcx.require_lang_item(StartFnLangItem);\n-            let start_fn = callee::resolve_and_get_fn(\n-                cx,\n-                start_def_id,\n-                cx.tcx.intern_substs(&[main_ret_ty.into()]),\n-            );\n-            (start_fn, vec![bx.pointercast(rust_main, Type::i8p(cx).ptr_to()),\n-                            arg_argc, arg_argv])\n-        } else {\n-            debug!(\"using user-defined start fn\");\n-            (rust_main, vec![arg_argc, arg_argv])\n-        };\n-\n-        let result = bx.call(start_fn, &args, None);\n-        bx.ret(bx.intcast(result, Type::c_int(cx), true));\n-    }\n-}\n-\n-fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-                            llvm_module: &ModuleLlvm)\n-                            -> EncodedMetadata {\n+pub fn write_metadata<'a, 'gcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    llvm_module: &ModuleLlvm\n+) -> EncodedMetadata {\n     use std::io::Write;\n     use flate2::Compression;\n     use flate2::write::DeflateEncoder;\n@@ -643,12 +97,12 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     DeflateEncoder::new(&mut compressed, Compression::fast())\n         .write_all(&metadata.raw_data).unwrap();\n \n-    let llmeta = C_bytes_in_context(metadata_llcx, &compressed);\n-    let llconst = C_struct_in_context(metadata_llcx, &[llmeta], false);\n+    let llmeta = common::bytes_in_context(metadata_llcx, &compressed);\n+    let llconst = common::struct_in_context(metadata_llcx, &[llmeta], false);\n     let name = exported_symbols::metadata_symbol_name(tcx);\n     let buf = CString::new(name).unwrap();\n     let llglobal = unsafe {\n-        llvm::LLVMAddGlobal(metadata_llmod, val_ty(llconst), buf.as_ptr())\n+        llvm::LLVMAddGlobal(metadata_llmod, common::val_ty(llconst), buf.as_ptr())\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -692,398 +146,7 @@ pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n     }\n }\n \n-fn determine_cgu_reuse<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 cgu: &CodegenUnit<'tcx>)\n-                                 -> CguReuse {\n-    if !tcx.dep_graph.is_fully_enabled() {\n-        return CguReuse::No\n-    }\n-\n-    let work_product_id = &cgu.work_product_id();\n-    if tcx.dep_graph.previous_work_product(work_product_id).is_none() {\n-        // We don't have anything cached for this CGU. This can happen\n-        // if the CGU did not exist in the previous session.\n-        return CguReuse::No\n-    }\n-\n-    // Try to mark the CGU as green. If it we can do so, it means that nothing\n-    // affecting the LLVM module has changed and we can re-use a cached version.\n-    // If we compile with any kind of LTO, this means we can re-use the bitcode\n-    // of the Pre-LTO stage (possibly also the Post-LTO version but we'll only\n-    // know that later). If we are not doing LTO, there is only one optimized\n-    // version of each module, so we re-use that.\n-    let dep_node = cgu.codegen_dep_node(tcx);\n-    assert!(!tcx.dep_graph.dep_node_exists(&dep_node),\n-        \"CompileCodegenUnit dep-node for CGU `{}` already exists before marking.\",\n-        cgu.name());\n-\n-    if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n-        // We can re-use either the pre- or the post-thinlto state\n-        if tcx.sess.lto() != Lto::No {\n-            CguReuse::PreLto\n-        } else {\n-            CguReuse::PostLto\n-        }\n-    } else {\n-        CguReuse::No\n-    }\n-}\n-\n-pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               rx: mpsc::Receiver<Box<dyn Any + Send>>)\n-                               -> OngoingCodegen\n-{\n-    check_for_rustc_errors_attr(tcx);\n-\n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n-\n-    // Codegen the metadata.\n-    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen));\n-\n-    let metadata_cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n-                                                            &[\"crate\"],\n-                                                            Some(\"metadata\")).as_str()\n-                                                                             .to_string();\n-    let metadata_llvm_module = ModuleLlvm::new(tcx.sess, &metadata_cgu_name);\n-    let metadata = time(tcx.sess, \"write metadata\", || {\n-        write_metadata(tcx, &metadata_llvm_module)\n-    });\n-    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen));\n-\n-    let metadata_module = ModuleCodegen {\n-        name: metadata_cgu_name,\n-        module_llvm: metadata_llvm_module,\n-        kind: ModuleKind::Metadata,\n-    };\n-\n-    let time_graph = if tcx.sess.opts.debugging_opts.codegen_time_graph {\n-        Some(time_graph::TimeGraph::new())\n-    } else {\n-        None\n-    };\n-\n-    // Skip crate items and just output metadata in -Z no-codegen mode.\n-    if tcx.sess.opts.debugging_opts.no_codegen ||\n-       !tcx.sess.opts.output_types.should_codegen() {\n-        let ongoing_codegen = write::start_async_codegen(\n-            tcx,\n-            time_graph,\n-            metadata,\n-            rx,\n-            1);\n-\n-        ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, metadata_module);\n-        ongoing_codegen.codegen_finished(tcx);\n-\n-        assert_and_save_dep_graph(tcx);\n-\n-        ongoing_codegen.check_for_errors(tcx.sess);\n-\n-        return ongoing_codegen;\n-    }\n-\n-    // Run the monomorphization collector and partition the collected items into\n-    // codegen units.\n-    let codegen_units = tcx.collect_and_partition_mono_items(LOCAL_CRATE).1;\n-    let codegen_units = (*codegen_units).clone();\n-\n-    // Force all codegen_unit queries so they are already either red or green\n-    // when compile_codegen_unit accesses them. We are not able to re-execute\n-    // the codegen_unit query from just the DepNode, so an unknown color would\n-    // lead to having to re-execute compile_codegen_unit, possibly\n-    // unnecessarily.\n-    if tcx.dep_graph.is_fully_enabled() {\n-        for cgu in &codegen_units {\n-            tcx.codegen_unit(cgu.name().clone());\n-        }\n-    }\n-\n-    let ongoing_codegen = write::start_async_codegen(\n-        tcx,\n-        time_graph.clone(),\n-        metadata,\n-        rx,\n-        codegen_units.len());\n-    let ongoing_codegen = AbortCodegenOnDrop(Some(ongoing_codegen));\n-\n-    // Codegen an allocator shim, if necessary.\n-    //\n-    // If the crate doesn't have an `allocator_kind` set then there's definitely\n-    // no shim to generate. Otherwise we also check our dependency graph for all\n-    // our output crate types. If anything there looks like its a `Dynamic`\n-    // linkage, then it's already got an allocator shim and we'll be using that\n-    // one instead. If nothing exists then it's our job to generate the\n-    // allocator!\n-    let any_dynamic_crate = tcx.sess.dependency_formats.borrow()\n-        .iter()\n-        .any(|(_, list)| {\n-            use rustc::middle::dependency_format::Linkage;\n-            list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n-        });\n-    let allocator_module = if any_dynamic_crate {\n-        None\n-    } else if let Some(kind) = *tcx.sess.allocator_kind.get() {\n-        let llmod_id = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n-                                                       &[\"crate\"],\n-                                                       Some(\"allocator\")).as_str()\n-                                                                         .to_string();\n-        let modules = ModuleLlvm::new(tcx.sess, &llmod_id);\n-        time(tcx.sess, \"write allocator module\", || {\n-            unsafe {\n-                allocator::codegen(tcx, &modules, kind)\n-            }\n-        });\n-\n-        Some(ModuleCodegen {\n-            name: llmod_id,\n-            module_llvm: modules,\n-            kind: ModuleKind::Allocator,\n-        })\n-    } else {\n-        None\n-    };\n-\n-    if let Some(allocator_module) = allocator_module {\n-        ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, allocator_module);\n-    }\n-\n-    ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, metadata_module);\n-\n-    // We sort the codegen units by size. This way we can schedule work for LLVM\n-    // a bit more efficiently.\n-    let codegen_units = {\n-        let mut codegen_units = codegen_units;\n-        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n-        codegen_units\n-    };\n-\n-    let mut total_codegen_time = Duration::new(0, 0);\n-    let mut all_stats = Stats::default();\n-\n-    for cgu in codegen_units.into_iter() {\n-        ongoing_codegen.wait_for_signal_to_codegen_item();\n-        ongoing_codegen.check_for_errors(tcx.sess);\n-\n-        let cgu_reuse = determine_cgu_reuse(tcx, &cgu);\n-        tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n-\n-        match cgu_reuse {\n-            CguReuse::No => {\n-                let _timing_guard = time_graph.as_ref().map(|time_graph| {\n-                    time_graph.start(write::CODEGEN_WORKER_TIMELINE,\n-                                     write::CODEGEN_WORK_PACKAGE_KIND,\n-                                     &format!(\"codegen {}\", cgu.name()))\n-                });\n-                let start_time = Instant::now();\n-                let stats = compile_codegen_unit(tcx, *cgu.name());\n-                all_stats.extend(stats);\n-                total_codegen_time += start_time.elapsed();\n-                false\n-            }\n-            CguReuse::PreLto => {\n-                write::submit_pre_lto_module_to_llvm(tcx, CachedModuleCodegen {\n-                    name: cgu.name().to_string(),\n-                    source: cgu.work_product(tcx),\n-                });\n-                true\n-            }\n-            CguReuse::PostLto => {\n-                write::submit_post_lto_module_to_llvm(tcx, CachedModuleCodegen {\n-                    name: cgu.name().to_string(),\n-                    source: cgu.work_product(tcx),\n-                });\n-                true\n-            }\n-        };\n-    }\n-\n-    ongoing_codegen.codegen_finished(tcx);\n-\n-    // Since the main thread is sometimes blocked during codegen, we keep track\n-    // -Ztime-passes output manually.\n-    print_time_passes_entry(tcx.sess.time_passes(),\n-                            \"codegen to LLVM IR\",\n-                            total_codegen_time);\n-\n-    rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n-\n-    symbol_names_test::report_symbol_names(tcx);\n-\n-    if tcx.sess.codegen_stats() {\n-        println!(\"--- codegen stats ---\");\n-        println!(\"n_glues_created: {}\", all_stats.n_glues_created);\n-        println!(\"n_null_glues: {}\", all_stats.n_null_glues);\n-        println!(\"n_real_glues: {}\", all_stats.n_real_glues);\n-\n-        println!(\"n_fns: {}\", all_stats.n_fns);\n-        println!(\"n_inlines: {}\", all_stats.n_inlines);\n-        println!(\"n_closures: {}\", all_stats.n_closures);\n-        println!(\"fn stats:\");\n-        all_stats.fn_stats.sort_by_key(|&(_, insns)| insns);\n-        for &(ref name, insns) in all_stats.fn_stats.iter() {\n-            println!(\"{} insns, {}\", insns, *name);\n-        }\n-    }\n-\n-    if tcx.sess.count_llvm_insns() {\n-        for (k, v) in all_stats.llvm_insns.iter() {\n-            println!(\"{:7} {}\", *v, *k);\n-        }\n-    }\n-\n-    ongoing_codegen.check_for_errors(tcx.sess);\n-\n-    assert_and_save_dep_graph(tcx);\n-    ongoing_codegen.into_inner()\n-}\n-\n-/// A curious wrapper structure whose only purpose is to call `codegen_aborted`\n-/// when it's dropped abnormally.\n-///\n-/// In the process of working on rust-lang/rust#55238 a mysterious segfault was\n-/// stumbled upon. The segfault was never reproduced locally, but it was\n-/// suspected to be related to the fact that codegen worker threads were\n-/// sticking around by the time the main thread was exiting, causing issues.\n-///\n-/// This structure is an attempt to fix that issue where the `codegen_aborted`\n-/// message will block until all workers have finished. This should ensure that\n-/// even if the main codegen thread panics we'll wait for pending work to\n-/// complete before returning from the main thread, hopefully avoiding\n-/// segfaults.\n-///\n-/// If you see this comment in the code, then it means that this workaround\n-/// worked! We may yet one day track down the mysterious cause of that\n-/// segfault...\n-struct AbortCodegenOnDrop(Option<OngoingCodegen>);\n-\n-impl AbortCodegenOnDrop {\n-    fn into_inner(mut self) -> OngoingCodegen {\n-        self.0.take().unwrap()\n-    }\n-}\n-\n-impl Deref for AbortCodegenOnDrop {\n-    type Target = OngoingCodegen;\n-\n-    fn deref(&self) -> &OngoingCodegen {\n-        self.0.as_ref().unwrap()\n-    }\n-}\n-\n-impl DerefMut for AbortCodegenOnDrop {\n-    fn deref_mut(&mut self) -> &mut OngoingCodegen {\n-        self.0.as_mut().unwrap()\n-    }\n-}\n-\n-impl Drop for AbortCodegenOnDrop {\n-    fn drop(&mut self) {\n-        if let Some(codegen) = self.0.take() {\n-            codegen.codegen_aborted();\n-        }\n-    }\n-}\n-\n-fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    time(tcx.sess,\n-         \"assert dep graph\",\n-         || rustc_incremental::assert_dep_graph(tcx));\n-\n-    time(tcx.sess,\n-         \"serialize dep graph\",\n-         || rustc_incremental::save_dep_graph(tcx));\n-}\n-\n-impl CrateInfo {\n-    pub fn new(tcx: TyCtxt) -> CrateInfo {\n-        let mut info = CrateInfo {\n-            panic_runtime: None,\n-            compiler_builtins: None,\n-            profiler_runtime: None,\n-            sanitizer_runtime: None,\n-            is_no_builtins: Default::default(),\n-            native_libraries: Default::default(),\n-            used_libraries: tcx.native_libraries(LOCAL_CRATE),\n-            link_args: tcx.link_args(LOCAL_CRATE),\n-            crate_name: Default::default(),\n-            used_crates_dynamic: cstore::used_crates(tcx, LinkagePreference::RequireDynamic),\n-            used_crates_static: cstore::used_crates(tcx, LinkagePreference::RequireStatic),\n-            used_crate_source: Default::default(),\n-            wasm_imports: Default::default(),\n-            lang_item_to_crate: Default::default(),\n-            missing_lang_items: Default::default(),\n-        };\n-        let lang_items = tcx.lang_items();\n-\n-        let load_wasm_items = tcx.sess.crate_types.borrow()\n-            .iter()\n-            .any(|c| *c != config::CrateType::Rlib) &&\n-            tcx.sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\";\n-\n-        if load_wasm_items {\n-            info.load_wasm_imports(tcx, LOCAL_CRATE);\n-        }\n-\n-        let crates = tcx.crates();\n-\n-        let n_crates = crates.len();\n-        info.native_libraries.reserve(n_crates);\n-        info.crate_name.reserve(n_crates);\n-        info.used_crate_source.reserve(n_crates);\n-        info.missing_lang_items.reserve(n_crates);\n-\n-        for &cnum in crates.iter() {\n-            info.native_libraries.insert(cnum, tcx.native_libraries(cnum));\n-            info.crate_name.insert(cnum, tcx.crate_name(cnum).to_string());\n-            info.used_crate_source.insert(cnum, tcx.used_crate_source(cnum));\n-            if tcx.is_panic_runtime(cnum) {\n-                info.panic_runtime = Some(cnum);\n-            }\n-            if tcx.is_compiler_builtins(cnum) {\n-                info.compiler_builtins = Some(cnum);\n-            }\n-            if tcx.is_profiler_runtime(cnum) {\n-                info.profiler_runtime = Some(cnum);\n-            }\n-            if tcx.is_sanitizer_runtime(cnum) {\n-                info.sanitizer_runtime = Some(cnum);\n-            }\n-            if tcx.is_no_builtins(cnum) {\n-                info.is_no_builtins.insert(cnum);\n-            }\n-            if load_wasm_items {\n-                info.load_wasm_imports(tcx, cnum);\n-            }\n-            let missing = tcx.missing_lang_items(cnum);\n-            for &item in missing.iter() {\n-                if let Ok(id) = lang_items.require(item) {\n-                    info.lang_item_to_crate.insert(item, id.krate);\n-                }\n-            }\n-\n-            // No need to look for lang items that are whitelisted and don't\n-            // actually need to exist.\n-            let missing = missing.iter()\n-                .cloned()\n-                .filter(|&l| !weak_lang_items::whitelisted(tcx, l))\n-                .collect();\n-            info.missing_lang_items.insert(cnum, missing);\n-        }\n-\n-        return info\n-    }\n-\n-    fn load_wasm_imports(&mut self, tcx: TyCtxt, cnum: CrateNum) {\n-        self.wasm_imports.extend(tcx.wasm_import_module_map(cnum).iter().map(|(&id, module)| {\n-            let instance = Instance::mono(tcx, id);\n-            let import_name = tcx.symbol_name(instance);\n-\n-            (import_name.to_string(), module.clone())\n-        }));\n-    }\n-}\n-\n-fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn compile_codegen_unit<'ll, 'tcx>(tcx: TyCtxt<'ll, 'tcx, 'tcx>,\n                                   cgu_name: InternedString)\n                                   -> Stats {\n     let start_time = Instant::now();\n@@ -1100,69 +163,54 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let cost = time_to_codegen.as_secs() * 1_000_000_000 +\n                time_to_codegen.subsec_nanos() as u64;\n \n-    write::submit_codegened_module_to_llvm(tcx,\n-                                           module,\n-                                           cost);\n+    submit_codegened_module_to_llvm(&LlvmCodegenBackend(()), tcx, module, cost);\n     return stats;\n \n-    fn module_codegen<'a, 'tcx>(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn module_codegen<'ll, 'tcx>(\n+        tcx: TyCtxt<'ll, 'tcx, 'tcx>,\n         cgu_name: InternedString)\n-        -> (Stats, ModuleCodegen)\n+        -> (Stats, ModuleCodegen<ModuleLlvm>)\n     {\n+        let backend = LlvmCodegenBackend(());\n         let cgu = tcx.codegen_unit(cgu_name);\n-\n         // Instantiate monomorphizations without filling out definitions yet...\n-        let llvm_module = ModuleLlvm::new(tcx.sess, &cgu_name.as_str());\n+        let llvm_module = backend.new_metadata(tcx.sess, &cgu_name.as_str());\n         let stats = {\n             let cx = CodegenCx::new(tcx, cgu, &llvm_module);\n             let mono_items = cx.codegen_unit\n                                .items_in_deterministic_order(cx.tcx);\n             for &(mono_item, (linkage, visibility)) in &mono_items {\n-                mono_item.predefine(&cx, linkage, visibility);\n+                mono_item.predefine::<Builder>(&cx, linkage, visibility);\n             }\n \n             // ... and now that we have everything pre-defined, fill out those definitions.\n             for &(mono_item, _) in &mono_items {\n-                mono_item.define(&cx);\n+                mono_item.define::<Builder>(&cx);\n             }\n \n             // If this codegen unit contains the main function, also create the\n             // wrapper here\n-            maybe_create_entry_wrapper(&cx);\n+            maybe_create_entry_wrapper::<Builder>(&cx);\n \n             // Run replace-all-uses-with for statics that need it\n-            for &(old_g, new_g) in cx.statics_to_rauw.borrow().iter() {\n+            for &(old_g, new_g) in cx.statics_to_rauw().borrow().iter() {\n                 unsafe {\n-                    let bitcast = llvm::LLVMConstPointerCast(new_g, val_ty(old_g));\n-                    llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n-                    llvm::LLVMDeleteGlobal(old_g);\n+                    cx.static_replace_all_uses(old_g, new_g)\n                 }\n             }\n \n             // Create the llvm.used variable\n             // This variable has type [N x i8*] and is stored in the llvm.metadata section\n-            if !cx.used_statics.borrow().is_empty() {\n-                let name = const_cstr!(\"llvm.used\");\n-                let section = const_cstr!(\"llvm.metadata\");\n-                let array = C_array(Type::i8(&cx).ptr_to(), &*cx.used_statics.borrow());\n-\n-                unsafe {\n-                    let g = llvm::LLVMAddGlobal(cx.llmod,\n-                                                val_ty(array),\n-                                                name.as_ptr());\n-                    llvm::LLVMSetInitializer(g, array);\n-                    llvm::LLVMRustSetLinkage(g, llvm::Linkage::AppendingLinkage);\n-                    llvm::LLVMSetSection(g, section.as_ptr());\n-                }\n+            if !cx.used_statics().borrow().is_empty() {\n+                cx.create_used_variable()\n             }\n \n             // Finalize debuginfo\n             if cx.sess().opts.debuginfo != DebugInfo::None {\n-                debuginfo::finalize(&cx);\n+                cx.debuginfo_finalize();\n             }\n \n-            cx.stats.into_inner()\n+            cx.consume_stats().into_inner()\n         };\n \n         (stats, ModuleCodegen {\n@@ -1173,35 +221,15 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-pub fn provide_both(providers: &mut Providers) {\n-    providers.dllimport_foreign_items = |tcx, krate| {\n-        let module_map = tcx.foreign_modules(krate);\n-        let module_map = module_map.iter()\n-            .map(|lib| (lib.def_id, lib))\n-            .collect::<FxHashMap<_, _>>();\n-\n-        let dllimports = tcx.native_libraries(krate)\n-            .iter()\n-            .filter(|lib| {\n-                if lib.kind != cstore::NativeLibraryKind::NativeUnknown {\n-                    return false\n-                }\n-                let cfg = match lib.cfg {\n-                    Some(ref cfg) => cfg,\n-                    None => return true,\n-                };\n-                attr::cfg_matches(cfg, &tcx.sess.parse_sess, None)\n-            })\n-            .filter_map(|lib| lib.foreign_module)\n-            .map(|id| &module_map[&id])\n-            .flat_map(|module| module.foreign_items.iter().cloned())\n-            .collect();\n-        Lrc::new(dllimports)\n-    };\n-\n-    providers.is_dllimport_foreign_item = |tcx, def_id| {\n-        tcx.dllimport_foreign_items(def_id.krate).contains(&def_id)\n+pub fn set_link_section(llval: &Value, attrs: &CodegenFnAttrs) {\n+    let sect = match attrs.link_section {\n+        Some(name) => name,\n+        None => return,\n     };\n+    unsafe {\n+        let buf = SmallCStr::new(&sect.as_str());\n+        llvm::LLVMSetSection(llval, buf.as_ptr());\n+    }\n }\n \n pub fn linkage_to_llvm(linkage: Linkage) -> llvm::Linkage {\n@@ -1227,25 +255,3 @@ pub fn visibility_to_llvm(linkage: Visibility) -> llvm::Visibility {\n         Visibility::Protected => llvm::Visibility::Protected,\n     }\n }\n-\n-// FIXME(mw): Anything that is produced via DepGraph::with_task() must implement\n-//            the HashStable trait. Normally DepGraph::with_task() calls are\n-//            hidden behind queries, but CGU creation is a special case in two\n-//            ways: (1) it's not a query and (2) CGU are output nodes, so their\n-//            Fingerprints are not actually needed. It remains to be clarified\n-//            how exactly this case will be handled in the red/green system but\n-//            for now we content ourselves with providing a no-op HashStable\n-//            implementation for CGUs.\n-mod temp_stable_hash_impls {\n-    use rustc_data_structures::stable_hasher::{StableHasherResult, StableHasher,\n-                                               HashStable};\n-    use ModuleCodegen;\n-\n-    impl<HCX> HashStable<HCX> for ModuleCodegen {\n-        fn hash_stable<W: StableHasherResult>(&self,\n-                                              _: &mut HCX,\n-                                              _: &mut StableHasher<W>) {\n-            // do nothing\n-        }\n-    }\n-}"}, {"sha": "34e4f4d7e1835b7e24bae6014d708b7968b00213", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 470, "deletions": 268, "changes": 738, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -9,18 +9,26 @@\n // except according to those terms.\n \n use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n-use llvm::{IntPredicate, RealPredicate, False, OperandBundleDef};\n-use llvm::{self, BasicBlock};\n-use common::*;\n+use llvm::{self, False, BasicBlock};\n+use rustc_codegen_ssa::common::{IntPredicate, TypeKind, RealPredicate};\n+use rustc_codegen_ssa::{self, MemFlags};\n+use common::Funclet;\n+use context::CodegenCx;\n use type_::Type;\n+use type_of::LayoutLlvmExt;\n use value::Value;\n use libc::{c_uint, c_char};\n-use rustc::ty::TyCtxt;\n-use rustc::ty::layout::{Align, Size};\n-use rustc::session::{config, Session};\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::{self, Align, Size, TyLayout};\n+use rustc::session::config;\n use rustc_data_structures::small_c_str::SmallCStr;\n-\n+use rustc_codegen_ssa::traits::*;\n+use syntax;\n+use rustc_codegen_ssa::base::to_immediate;\n+use rustc_codegen_ssa::mir::operand::{OperandValue, OperandRef};\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n use std::borrow::Cow;\n+use std::ffi::CStr;\n use std::ops::Range;\n use std::ptr;\n \n@@ -46,17 +54,49 @@ fn noname() -> *const c_char {\n     &CNULL\n }\n \n-bitflags! {\n-    pub struct MemFlags: u8 {\n-        const VOLATILE = 1 << 0;\n-        const NONTEMPORAL = 1 << 1;\n-        const UNALIGNED = 1 << 2;\n+impl BackendTypes for Builder<'_, 'll, 'tcx> {\n+    type Value = <CodegenCx<'ll, 'tcx> as BackendTypes>::Value;\n+    type BasicBlock = <CodegenCx<'ll, 'tcx> as BackendTypes>::BasicBlock;\n+    type Type = <CodegenCx<'ll, 'tcx> as BackendTypes>::Type;\n+    type Context = <CodegenCx<'ll, 'tcx> as BackendTypes>::Context;\n+    type Funclet = <CodegenCx<'ll, 'tcx> as BackendTypes>::Funclet;\n+\n+    type DIScope = <CodegenCx<'ll, 'tcx> as BackendTypes>::DIScope;\n+}\n+\n+impl ty::layout::HasDataLayout for Builder<'_, '_, '_> {\n+    fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n+        self.cx.data_layout()\n+    }\n+}\n+\n+impl ty::layout::HasTyCtxt<'tcx> for Builder<'_, '_, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.cx.tcx\n+    }\n+}\n+\n+impl ty::layout::LayoutOf for Builder<'_, '_, 'tcx> {\n+    type Ty = Ty<'tcx>;\n+    type TyLayout = TyLayout<'tcx>;\n+\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+        self.cx.layout_of(ty)\n     }\n }\n \n-impl Builder<'a, 'll, 'tcx> {\n-    pub fn new_block<'b>(cx: &'a CodegenCx<'ll, 'tcx>, llfn: &'ll Value, name: &'b str) -> Self {\n-        let bx = Builder::with_cx(cx);\n+\n+impl HasCodegen<'tcx> for Builder<'_, 'll, 'tcx> {\n+    type CodegenCx = CodegenCx<'ll, 'tcx>;\n+}\n+\n+impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n+    fn new_block<'b>(\n+        cx: &'a CodegenCx<'ll, 'tcx>,\n+        llfn: &'ll Value,\n+        name: &'b str\n+    ) -> Self {\n+        let mut bx = Builder::with_cx(cx);\n         let llbb = unsafe {\n             let name = SmallCStr::new(name);\n             llvm::LLVMAppendBasicBlockInContext(\n@@ -69,7 +109,7 @@ impl Builder<'a, 'll, 'tcx> {\n         bx\n     }\n \n-    pub fn with_cx(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n+    fn with_cx(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n         // Create a fresh builder from the crate context.\n         let llbuilder = unsafe {\n             llvm::LLVMCreateBuilderInContext(cx.llcx)\n@@ -80,85 +120,77 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn build_sibling_block<'b>(&self, name: &'b str) -> Builder<'a, 'll, 'tcx> {\n+    fn build_sibling_block<'b>(&self, name: &'b str) -> Self {\n         Builder::new_block(self.cx, self.llfn(), name)\n     }\n \n-    pub fn sess(&self) -> &Session {\n-        self.cx.sess()\n-    }\n-\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.cx.tcx\n-    }\n-\n-    pub fn llfn(&self) -> &'ll Value {\n+    fn llfn(&self) -> &'ll Value {\n         unsafe {\n             llvm::LLVMGetBasicBlockParent(self.llbb())\n         }\n     }\n \n-    pub fn llbb(&self) -> &'ll BasicBlock {\n+    fn llbb(&self) -> &'ll BasicBlock {\n         unsafe {\n             llvm::LLVMGetInsertBlock(self.llbuilder)\n         }\n     }\n \n     fn count_insn(&self, category: &str) {\n-        if self.cx.sess().codegen_stats() {\n-            self.cx.stats.borrow_mut().n_llvm_insns += 1;\n+        if self.cx().sess().codegen_stats() {\n+            self.cx().stats.borrow_mut().n_llvm_insns += 1;\n         }\n-        if self.cx.sess().count_llvm_insns() {\n-            *self.cx.stats\n-                    .borrow_mut()\n-                    .llvm_insns\n-                    .entry(category.to_string())\n-                    .or_insert(0) += 1;\n+        if self.cx().sess().count_llvm_insns() {\n+            *self.cx().stats\n+                      .borrow_mut()\n+                      .llvm_insns\n+                      .entry(category.to_string())\n+                      .or_insert(0) += 1;\n         }\n     }\n \n-    pub fn set_value_name(&self, value: &'ll Value, name: &str) {\n+    fn set_value_name(&mut self, value: &'ll Value, name: &str) {\n         let cname = SmallCStr::new(name);\n         unsafe {\n             llvm::LLVMSetValueName(value, cname.as_ptr());\n         }\n     }\n \n-    pub fn position_at_end(&self, llbb: &'ll BasicBlock) {\n+    fn position_at_end(&mut self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(self.llbuilder, llbb);\n         }\n     }\n \n-    pub fn position_at_start(&self, llbb: &'ll BasicBlock) {\n+    fn position_at_start(&mut self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n         }\n     }\n \n-    pub fn ret_void(&self) {\n+    fn ret_void(&mut self) {\n         self.count_insn(\"retvoid\");\n         unsafe {\n             llvm::LLVMBuildRetVoid(self.llbuilder);\n         }\n     }\n \n-    pub fn ret(&self, v: &'ll Value) {\n+    fn ret(&mut self, v: &'ll Value) {\n         self.count_insn(\"ret\");\n         unsafe {\n             llvm::LLVMBuildRet(self.llbuilder, v);\n         }\n     }\n \n-    pub fn br(&self, dest: &'ll BasicBlock) {\n+    fn br(&mut self, dest: &'ll BasicBlock) {\n         self.count_insn(\"br\");\n         unsafe {\n             llvm::LLVMBuildBr(self.llbuilder, dest);\n         }\n     }\n \n-    pub fn cond_br(\n-        &self,\n+    fn cond_br(\n+        &mut self,\n         cond: &'ll Value,\n         then_llbb: &'ll BasicBlock,\n         else_llbb: &'ll BasicBlock,\n@@ -169,8 +201,8 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn switch(\n-        &self,\n+    fn switch(\n+        &mut self,\n         v: &'ll Value,\n         else_llbb: &'ll BasicBlock,\n         num_cases: usize,\n@@ -180,20 +212,23 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn invoke(&self,\n-                  llfn: &'ll Value,\n-                  args: &[&'ll Value],\n-                  then: &'ll BasicBlock,\n-                  catch: &'ll BasicBlock,\n-                  bundle: Option<&OperandBundleDef<'ll>>) -> &'ll Value {\n+    fn invoke(\n+        &mut self,\n+        llfn: &'ll Value,\n+        args: &[&'ll Value],\n+        then: &'ll BasicBlock,\n+        catch: &'ll BasicBlock,\n+        funclet: Option<&Funclet<'ll>>,\n+    ) -> &'ll Value {\n         self.count_insn(\"invoke\");\n \n         debug!(\"Invoke {:?} with args ({:?})\",\n                llfn,\n                args);\n \n         let args = self.check_call(\"invoke\", llfn, args);\n-        let bundle = bundle.map(|b| &*b.raw);\n+        let bundle = funclet.map(|funclet| funclet.bundle());\n+        let bundle = bundle.as_ref().map(|b| &*b.raw);\n \n         unsafe {\n             llvm::LLVMRustBuildInvoke(self.llbuilder,\n@@ -207,29 +242,29 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn unreachable(&self) {\n+    fn unreachable(&mut self) {\n         self.count_insn(\"unreachable\");\n         unsafe {\n             llvm::LLVMBuildUnreachable(self.llbuilder);\n         }\n     }\n \n     /* Arithmetic */\n-    pub fn add(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn add(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"add\");\n         unsafe {\n             llvm::LLVMBuildAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fadd(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fadd(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fadd\");\n         unsafe {\n             llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fadd_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fadd_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fadd\");\n         unsafe {\n             let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname());\n@@ -238,21 +273,21 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn sub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn sub(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"sub\");\n         unsafe {\n             llvm::LLVMBuildSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fsub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fsub(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fsub\");\n         unsafe {\n             llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fsub_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fsub_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fsub\");\n         unsafe {\n             let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname());\n@@ -261,21 +296,21 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn mul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn mul(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"mul\");\n         unsafe {\n             llvm::LLVMBuildMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fmul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fmul(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fmul\");\n         unsafe {\n             llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fmul_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fmul_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fmul\");\n         unsafe {\n             let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname());\n@@ -285,42 +320,42 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n \n-    pub fn udiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn udiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"udiv\");\n         unsafe {\n             llvm::LLVMBuildUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn exactudiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn exactudiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"exactudiv\");\n         unsafe {\n             llvm::LLVMBuildExactUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn sdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn sdiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"sdiv\");\n         unsafe {\n             llvm::LLVMBuildSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn exactsdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn exactsdiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"exactsdiv\");\n         unsafe {\n             llvm::LLVMBuildExactSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fdiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fdiv\");\n         unsafe {\n             llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fdiv_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fdiv_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fdiv\");\n         unsafe {\n             let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname());\n@@ -329,28 +364,28 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn urem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn urem(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"urem\");\n         unsafe {\n             llvm::LLVMBuildURem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn srem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn srem(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"srem\");\n         unsafe {\n             llvm::LLVMBuildSRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn frem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn frem(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"frem\");\n         unsafe {\n             llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn frem_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn frem_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"frem\");\n         unsafe {\n             let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname());\n@@ -359,78 +394,78 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn shl(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn shl(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"shl\");\n         unsafe {\n             llvm::LLVMBuildShl(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn lshr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn lshr(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"lshr\");\n         unsafe {\n             llvm::LLVMBuildLShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn ashr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn ashr(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"ashr\");\n         unsafe {\n             llvm::LLVMBuildAShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn and(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn and(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"and\");\n         unsafe {\n             llvm::LLVMBuildAnd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn or(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn or(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"or\");\n         unsafe {\n             llvm::LLVMBuildOr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn xor(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn xor(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"xor\");\n         unsafe {\n             llvm::LLVMBuildXor(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn neg(&self, v: &'ll Value) -> &'ll Value {\n+    fn neg(&mut self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"neg\");\n         unsafe {\n             llvm::LLVMBuildNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn fneg(&self, v: &'ll Value) -> &'ll Value {\n+    fn fneg(&mut self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fneg\");\n         unsafe {\n             llvm::LLVMBuildFNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn not(&self, v: &'ll Value) -> &'ll Value {\n+    fn not(&mut self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"not\");\n         unsafe {\n             llvm::LLVMBuildNot(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n-        let bx = Builder::with_cx(self.cx);\n+    fn alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+        let mut bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n         bx.dynamic_alloca(ty, name, align)\n     }\n \n-    pub fn dynamic_alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+    fn dynamic_alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n         self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n@@ -445,7 +480,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn array_alloca(&self,\n+    fn array_alloca(&mut self,\n                         ty: &'ll Type,\n                         len: &'ll Value,\n                         name: &str,\n@@ -464,7 +499,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn load(&self, ptr: &'ll Value, align: Align) -> &'ll Value {\n+    fn load(&mut self, ptr: &'ll Value, align: Align) -> &'ll Value {\n         self.count_insn(\"load\");\n         unsafe {\n             let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n@@ -473,7 +508,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn volatile_load(&self, ptr: &'ll Value) -> &'ll Value {\n+    fn volatile_load(&mut self, ptr: &'ll Value) -> &'ll Value {\n         self.count_insn(\"load.volatile\");\n         unsafe {\n             let insn = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n@@ -482,19 +517,100 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn atomic_load(&self, ptr: &'ll Value, order: AtomicOrdering, size: Size) -> &'ll Value {\n+    fn atomic_load(\n+        &mut self,\n+        ptr: &'ll Value,\n+        order: rustc_codegen_ssa::common::AtomicOrdering,\n+        size: Size,\n+    ) -> &'ll Value {\n         self.count_insn(\"load.atomic\");\n         unsafe {\n-            let load = llvm::LLVMRustBuildAtomicLoad(self.llbuilder, ptr, noname(), order);\n+            let load = llvm::LLVMRustBuildAtomicLoad(\n+                self.llbuilder,\n+                ptr,\n+                noname(),\n+                AtomicOrdering::from_generic(order),\n+            );\n             // LLVM requires the alignment of atomic loads to be at least the size of the type.\n             llvm::LLVMSetAlignment(load, size.bytes() as c_uint);\n             load\n         }\n     }\n \n+    fn load_operand(\n+        &mut self,\n+        place: PlaceRef<'tcx, &'ll Value>\n+    ) -> OperandRef<'tcx, &'ll Value> {\n+        debug!(\"PlaceRef::load: {:?}\", place);\n+\n+        assert_eq!(place.llextra.is_some(), place.layout.is_unsized());\n+\n+        if place.layout.is_zst() {\n+            return OperandRef::new_zst(self.cx(), place.layout);\n+        }\n+\n+        fn scalar_load_metadata<'a, 'll, 'tcx>(\n+            bx: &mut Builder<'a, 'll, 'tcx>,\n+            load: &'ll Value,\n+            scalar: &layout::Scalar\n+        ) {\n+            let vr = scalar.valid_range.clone();\n+            match scalar.value {\n+                layout::Int(..) => {\n+                    let range = scalar.valid_range_exclusive(bx.cx());\n+                    if range.start != range.end {\n+                        bx.range_metadata(load, range);\n+                    }\n+                }\n+                layout::Pointer if vr.start() < vr.end() && !vr.contains(&0) => {\n+                    bx.nonnull_metadata(load);\n+                }\n+                _ => {}\n+            }\n+        }\n \n-    pub fn range_metadata(&self, load: &'ll Value, range: Range<u128>) {\n-        if self.sess().target.target.arch == \"amdgpu\" {\n+        let val = if let Some(llextra) = place.llextra {\n+            OperandValue::Ref(place.llval, Some(llextra), place.align)\n+        } else if place.layout.is_llvm_immediate() {\n+            let mut const_llval = None;\n+            unsafe {\n+                if let Some(global) = llvm::LLVMIsAGlobalVariable(place.llval) {\n+                    if llvm::LLVMIsGlobalConstant(global) == llvm::True {\n+                        const_llval = llvm::LLVMGetInitializer(global);\n+                    }\n+                }\n+            }\n+            let llval = const_llval.unwrap_or_else(|| {\n+                let load = self.load(place.llval, place.align);\n+                if let layout::Abi::Scalar(ref scalar) = place.layout.abi {\n+                    scalar_load_metadata(self, load, scalar);\n+                }\n+                load\n+            });\n+            OperandValue::Immediate(to_immediate(self, llval, place.layout))\n+        } else if let layout::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n+            let mut load = |i, scalar: &layout::Scalar| {\n+                let llptr = self.struct_gep(place.llval, i as u64);\n+                let load = self.load(llptr, place.align);\n+                scalar_load_metadata(self, load, scalar);\n+                if scalar.is_bool() {\n+                    self.trunc(load, self.cx().type_i1())\n+                } else {\n+                    load\n+                }\n+            };\n+            OperandValue::Pair(load(0, a), load(1, b))\n+        } else {\n+            OperandValue::Ref(place.llval, None, place.align)\n+        };\n+\n+        OperandRef { val, layout: place.layout }\n+    }\n+\n+\n+\n+    fn range_metadata(&mut self, load: &'ll Value, range: Range<u128>) {\n+        if self.cx().sess().target.target.arch == \"amdgpu\" {\n             // amdgpu/LLVM does something weird and thinks a i64 value is\n             // split into a v2i32, halving the bitwidth LLVM expects,\n             // tripping an assertion. So, for now, just disable this\n@@ -503,10 +619,10 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n \n         unsafe {\n-            let llty = val_ty(load);\n+            let llty = self.cx.val_ty(load);\n             let v = [\n-                C_uint_big(llty, range.start),\n-                C_uint_big(llty, range.end)\n+                self.cx.const_uint_big(llty, range.start),\n+                self.cx.const_uint_big(llty, range.end)\n             ];\n \n             llvm::LLVMSetMetadata(load, llvm::MD_range as c_uint,\n@@ -516,19 +632,19 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn nonnull_metadata(&self, load: &'ll Value) {\n+    fn nonnull_metadata(&mut self, load: &'ll Value) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_nonnull as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n         }\n     }\n \n-    pub fn store(&self, val: &'ll Value, ptr: &'ll Value, align: Align) -> &'ll Value {\n+    fn store(&mut self, val: &'ll Value, ptr: &'ll Value, align: Align) -> &'ll Value {\n         self.store_with_flags(val, ptr, align, MemFlags::empty())\n     }\n \n-    pub fn store_with_flags(\n-        &self,\n+    fn store_with_flags(\n+        &mut self,\n         val: &'ll Value,\n         ptr: &'ll Value,\n         align: Align,\n@@ -553,173 +669,165 @@ impl Builder<'a, 'll, 'tcx> {\n                 // *always* point to a metadata value of the integer 1.\n                 //\n                 // [1]: http://llvm.org/docs/LangRef.html#store-instruction\n-                let one = C_i32(self.cx, 1);\n+                let one = self.cx.const_i32(1);\n                 let node = llvm::LLVMMDNodeInContext(self.cx.llcx, &one, 1);\n                 llvm::LLVMSetMetadata(store, llvm::MD_nontemporal as c_uint, node);\n             }\n             store\n         }\n     }\n \n-    pub fn atomic_store(&self, val: &'ll Value, ptr: &'ll Value,\n-                        order: AtomicOrdering, size: Size) {\n+   fn atomic_store(&mut self, val: &'ll Value, ptr: &'ll Value,\n+                   order: rustc_codegen_ssa::common::AtomicOrdering, size: Size) {\n         debug!(\"Store {:?} -> {:?}\", val, ptr);\n         self.count_insn(\"store.atomic\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n-            let store = llvm::LLVMRustBuildAtomicStore(self.llbuilder, val, ptr, order);\n+            let store = llvm::LLVMRustBuildAtomicStore(\n+                self.llbuilder,\n+                val,\n+                ptr,\n+                AtomicOrdering::from_generic(order),\n+            );\n             // LLVM requires the alignment of atomic stores to be at least the size of the type.\n             llvm::LLVMSetAlignment(store, size.bytes() as c_uint);\n         }\n     }\n \n-    pub fn gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n+    fn gep(&mut self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"gep\");\n         unsafe {\n             llvm::LLVMBuildGEP(self.llbuilder, ptr, indices.as_ptr(),\n                                indices.len() as c_uint, noname())\n         }\n     }\n \n-    pub fn inbounds_gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n+    fn inbounds_gep(&mut self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"inboundsgep\");\n         unsafe {\n             llvm::LLVMBuildInBoundsGEP(\n                 self.llbuilder, ptr, indices.as_ptr(), indices.len() as c_uint, noname())\n         }\n     }\n \n-    pub fn struct_gep(&self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n-        self.count_insn(\"structgep\");\n-        assert_eq!(idx as c_uint as u64, idx);\n-        unsafe {\n-            llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n-        }\n-    }\n-\n     /* Casts */\n-    pub fn trunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn trunc(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"trunc\");\n         unsafe {\n             llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn zext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"zext\");\n-        unsafe {\n-            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n-        }\n-    }\n-\n-    pub fn sext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn sext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"sext\");\n         unsafe {\n             llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fptoui(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn fptoui(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fptoui\");\n         unsafe {\n             llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fptosi(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn fptosi(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fptosi\");\n         unsafe {\n             llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty,noname())\n         }\n     }\n \n-    pub fn uitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn uitofp(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"uitofp\");\n         unsafe {\n             llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn sitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn sitofp(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"sitofp\");\n         unsafe {\n             llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fptrunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn fptrunc(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fptrunc\");\n         unsafe {\n             llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fpext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn fpext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fpext\");\n         unsafe {\n             llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn ptrtoint(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn ptrtoint(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"ptrtoint\");\n         unsafe {\n             llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn inttoptr(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn inttoptr(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"inttoptr\");\n         unsafe {\n             llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn bitcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn bitcast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"bitcast\");\n         unsafe {\n             llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn pointercast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"pointercast\");\n+\n+    fn intcast(&mut self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &'ll Value {\n+        self.count_insn(\"intcast\");\n         unsafe {\n-            llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty, is_signed)\n         }\n     }\n \n-    pub fn intcast(&self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &'ll Value {\n-        self.count_insn(\"intcast\");\n+    fn pointercast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        self.count_insn(\"pointercast\");\n         unsafe {\n-            llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty, is_signed)\n+            llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     /* Comparisons */\n-    pub fn icmp(&self, op: IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn icmp(&mut self, op: IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"icmp\");\n+        let op = llvm::IntPredicate::from_generic(op);\n         unsafe {\n             llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fcmp(&self, op: RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fcmp(&mut self, op: RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fcmp\");\n         unsafe {\n             llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n     }\n \n     /* Miscellaneous instructions */\n-    pub fn empty_phi(&self, ty: &'ll Type) -> &'ll Value {\n+    fn empty_phi(&mut self, ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"emptyphi\");\n         unsafe {\n             llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n         }\n     }\n \n-    pub fn phi(&self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n+    fn phi(&mut self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n         assert_eq!(vals.len(), bbs.len());\n         let phi = self.empty_phi(ty);\n         self.count_insn(\"addincoming\");\n@@ -731,10 +839,10 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn inline_asm_call(&self, asm: *const c_char, cons: *const c_char,\n-                           inputs: &[&'ll Value], output: &'ll Type,\n-                           volatile: bool, alignstack: bool,\n-                           dia: AsmDialect) -> Option<&'ll Value> {\n+    fn inline_asm_call(&mut self, asm: &CStr, cons: &CStr,\n+                       inputs: &[&'ll Value], output: &'ll Type,\n+                       volatile: bool, alignstack: bool,\n+                       dia: syntax::ast::AsmDialect) -> Option<&'ll Value> {\n         self.count_insn(\"inlineasm\");\n \n         let volatile = if volatile { llvm::True }\n@@ -744,18 +852,24 @@ impl Builder<'a, 'll, 'tcx> {\n \n         let argtys = inputs.iter().map(|v| {\n             debug!(\"Asm Input Type: {:?}\", *v);\n-            val_ty(*v)\n+            self.cx.val_ty(*v)\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {:?}\", output);\n-        let fty = Type::func(&argtys[..], output);\n+        let fty = self.cx().type_func(&argtys[..], output);\n         unsafe {\n             // Ask LLVM to verify that the constraints are well-formed.\n-            let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons);\n+            let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons.as_ptr());\n             debug!(\"Constraint verification result: {:?}\", constraints_ok);\n             if constraints_ok {\n                 let v = llvm::LLVMRustInlineAsm(\n-                    fty, asm, cons, volatile, alignstack, dia);\n+                    fty,\n+                    asm.as_ptr(),\n+                    cons.as_ptr(),\n+                    volatile,\n+                    alignstack,\n+                    AsmDialect::from_generic(dia),\n+                );\n                 Some(self.call(v, inputs, None))\n             } else {\n                 // LLVM has detected an issue with our constraints, bail out\n@@ -764,58 +878,80 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn call(&self, llfn: &'ll Value, args: &[&'ll Value],\n-                bundle: Option<&OperandBundleDef<'ll>>) -> &'ll Value {\n-        self.count_insn(\"call\");\n-\n-        debug!(\"Call {:?} with args ({:?})\",\n-               llfn,\n-               args);\n-\n-        let args = self.check_call(\"call\", llfn, args);\n-        let bundle = bundle.map(|b| &*b.raw);\n-\n+    fn memcpy(&mut self, dst: &'ll Value, dst_align: Align,\n+                  src: &'ll Value, src_align: Align,\n+                  size: &'ll Value, flags: MemFlags) {\n+        if flags.contains(MemFlags::NONTEMPORAL) {\n+            // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n+            let val = self.load(src, src_align);\n+            let ptr = self.pointercast(dst, self.cx().type_ptr_to(self.cx().val_ty(val)));\n+            self.store_with_flags(val, ptr, dst_align, flags);\n+            return;\n+        }\n+        let size = self.intcast(size, self.cx().type_isize(), false);\n+        let is_volatile = flags.contains(MemFlags::VOLATILE);\n+        let dst = self.pointercast(dst, self.cx().type_i8p());\n+        let src = self.pointercast(src, self.cx().type_i8p());\n         unsafe {\n-            llvm::LLVMRustBuildCall(self.llbuilder, llfn, args.as_ptr(),\n-                                    args.len() as c_uint, bundle, noname())\n+            llvm::LLVMRustBuildMemCpy(self.llbuilder, dst, dst_align.abi() as c_uint,\n+                                      src, src_align.abi() as c_uint, size, is_volatile);\n         }\n     }\n \n-    pub fn memcpy(&self, dst: &'ll Value, dst_align: u64,\n-                  src: &'ll Value, src_align: u64,\n-                  size: &'ll Value, is_volatile: bool) -> &'ll Value {\n+    fn memmove(&mut self, dst: &'ll Value, dst_align: Align,\n+                  src: &'ll Value, src_align: Align,\n+                  size: &'ll Value, flags: MemFlags) {\n+        if flags.contains(MemFlags::NONTEMPORAL) {\n+            // HACK(nox): This is inefficient but there is no nontemporal memmove.\n+            let val = self.load(src, src_align);\n+            let ptr = self.pointercast(dst, self.cx().type_ptr_to(self.cx().val_ty(val)));\n+            self.store_with_flags(val, ptr, dst_align, flags);\n+            return;\n+        }\n+        let size = self.intcast(size, self.cx().type_isize(), false);\n+        let is_volatile = flags.contains(MemFlags::VOLATILE);\n+        let dst = self.pointercast(dst, self.cx().type_i8p());\n+        let src = self.pointercast(src, self.cx().type_i8p());\n         unsafe {\n-            llvm::LLVMRustBuildMemCpy(self.llbuilder, dst, dst_align as c_uint,\n-                                      src, src_align as c_uint, size, is_volatile)\n+            llvm::LLVMRustBuildMemMove(self.llbuilder, dst, dst_align.abi() as c_uint,\n+                                      src, src_align.abi() as c_uint, size, is_volatile);\n         }\n     }\n \n-    pub fn memmove(&self, dst: &'ll Value, dst_align: u64,\n-                  src: &'ll Value, src_align: u64,\n-                  size: &'ll Value, is_volatile: bool) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMRustBuildMemMove(self.llbuilder, dst, dst_align as c_uint,\n-                                      src, src_align as c_uint, size, is_volatile)\n-        }\n+    fn memset(\n+        &mut self,\n+        ptr: &'ll Value,\n+        fill_byte: &'ll Value,\n+        size: &'ll Value,\n+        align: Align,\n+        flags: MemFlags,\n+    ) {\n+        let ptr_width = &self.cx().sess().target.target.target_pointer_width;\n+        let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n+        let llintrinsicfn = self.cx().get_intrinsic(&intrinsic_key);\n+        let ptr = self.pointercast(ptr, self.cx().type_i8p());\n+        let align = self.cx().const_u32(align.abi() as u32);\n+        let volatile = self.cx().const_bool(flags.contains(MemFlags::VOLATILE));\n+        self.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None);\n     }\n \n-    pub fn minnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn minnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"minnum\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs);\n             instr.expect(\"LLVMRustBuildMinNum is not available in LLVM version < 6.0\")\n         }\n     }\n-    pub fn maxnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn maxnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"maxnum\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs);\n             instr.expect(\"LLVMRustBuildMaxNum is not available in LLVM version < 6.0\")\n         }\n     }\n \n-    pub fn select(\n-        &self, cond: &'ll Value,\n+    fn select(\n+        &mut self, cond: &'ll Value,\n         then_val: &'ll Value,\n         else_val: &'ll Value,\n     ) -> &'ll Value {\n@@ -826,22 +962,22 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     #[allow(dead_code)]\n-    pub fn va_arg(&self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+    fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"vaarg\");\n         unsafe {\n             llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n         }\n     }\n \n-    pub fn extract_element(&self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value {\n+    fn extract_element(&mut self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value {\n         self.count_insn(\"extractelement\");\n         unsafe {\n             llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, noname())\n         }\n     }\n \n-    pub fn insert_element(\n-        &self, vec: &'ll Value,\n+    fn insert_element(\n+        &mut self, vec: &'ll Value,\n         elt: &'ll Value,\n         idx: &'ll Value,\n     ) -> &'ll Value {\n@@ -851,24 +987,24 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn shuffle_vector(&self, v1: &'ll Value, v2: &'ll Value, mask: &'ll Value) -> &'ll Value {\n+    fn shuffle_vector(&mut self, v1: &'ll Value, v2: &'ll Value, mask: &'ll Value) -> &'ll Value {\n         self.count_insn(\"shufflevector\");\n         unsafe {\n             llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n         }\n     }\n \n-    pub fn vector_splat(&self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n+    fn vector_splat(&mut self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let elt_ty = val_ty(elt);\n-            let undef = llvm::LLVMGetUndef(Type::vector(elt_ty, num_elts as u64));\n-            let vec = self.insert_element(undef, elt, C_i32(self.cx, 0));\n-            let vec_i32_ty = Type::vector(Type::i32(self.cx), num_elts as u64);\n-            self.shuffle_vector(vec, undef, C_null(vec_i32_ty))\n+            let elt_ty = self.cx.val_ty(elt);\n+            let undef = llvm::LLVMGetUndef(self.cx().type_vector(elt_ty, num_elts as u64));\n+            let vec = self.insert_element(undef, elt, self.cx.const_i32(0));\n+            let vec_i32_ty = self.cx().type_vector(self.cx().type_i32(), num_elts as u64);\n+            self.shuffle_vector(vec, undef, self.cx().const_null(vec_i32_ty))\n         }\n     }\n \n-    pub fn vector_reduce_fadd_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fadd_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fadd_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n@@ -879,7 +1015,7 @@ impl Builder<'a, 'll, 'tcx> {\n             instr\n         }\n     }\n-    pub fn vector_reduce_fmul_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fmul_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmul_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n@@ -890,68 +1026,68 @@ impl Builder<'a, 'll, 'tcx> {\n             instr\n         }\n     }\n-    pub fn vector_reduce_add(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_add(&mut self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.add\");\n         unsafe { llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src) }\n     }\n-    pub fn vector_reduce_mul(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_mul(&mut self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.mul\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src) }\n     }\n-    pub fn vector_reduce_and(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_and(&mut self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.and\");\n         unsafe { llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src) }\n     }\n-    pub fn vector_reduce_or(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_or(&mut self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.or\");\n         unsafe { llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src) }\n     }\n-    pub fn vector_reduce_xor(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_xor(&mut self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.xor\");\n         unsafe { llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src) }\n     }\n-    pub fn vector_reduce_fmin(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fmin(&mut self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmin\");\n         unsafe { llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n-    pub fn vector_reduce_fmax(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fmax(&mut self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmax\");\n         unsafe { llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n-    pub fn vector_reduce_fmin_fast(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fmin_fast(&mut self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmin_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    pub fn vector_reduce_fmax_fast(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fmax_fast(&mut self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmax_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    pub fn vector_reduce_min(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n+    fn vector_reduce_min(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"vector.reduce.min\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed) }\n     }\n-    pub fn vector_reduce_max(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n+    fn vector_reduce_max(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"vector.reduce.max\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed) }\n     }\n \n-    pub fn extract_value(&self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n+    fn extract_value(&mut self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n         self.count_insn(\"extractvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n         }\n     }\n \n-    pub fn insert_value(&self, agg_val: &'ll Value, elt: &'ll Value,\n+    fn insert_value(&mut self, agg_val: &'ll Value, elt: &'ll Value,\n                        idx: u64) -> &'ll Value {\n         self.count_insn(\"insertvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n@@ -961,7 +1097,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn landing_pad(&self, ty: &'ll Type, pers_fn: &'ll Value,\n+    fn landing_pad(&mut self, ty: &'ll Type, pers_fn: &'ll Value,\n                        num_clauses: usize) -> &'ll Value {\n         self.count_insn(\"landingpad\");\n         unsafe {\n@@ -970,29 +1106,29 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn add_clause(&self, landing_pad: &'ll Value, clause: &'ll Value) {\n+    fn add_clause(&mut self, landing_pad: &'ll Value, clause: &'ll Value) {\n         unsafe {\n             llvm::LLVMAddClause(landing_pad, clause);\n         }\n     }\n \n-    pub fn set_cleanup(&self, landing_pad: &'ll Value) {\n+    fn set_cleanup(&mut self, landing_pad: &'ll Value) {\n         self.count_insn(\"setcleanup\");\n         unsafe {\n             llvm::LLVMSetCleanup(landing_pad, llvm::True);\n         }\n     }\n \n-    pub fn resume(&self, exn: &'ll Value) -> &'ll Value {\n+    fn resume(&mut self, exn: &'ll Value) -> &'ll Value {\n         self.count_insn(\"resume\");\n         unsafe {\n             llvm::LLVMBuildResume(self.llbuilder, exn)\n         }\n     }\n \n-    pub fn cleanup_pad(&self,\n+    fn cleanup_pad(&mut self,\n                        parent: Option<&'ll Value>,\n-                       args: &[&'ll Value]) -> &'ll Value {\n+                       args: &[&'ll Value]) -> Funclet<'ll> {\n         self.count_insn(\"cleanuppad\");\n         let name = const_cstr!(\"cleanuppad\");\n         let ret = unsafe {\n@@ -1002,43 +1138,43 @@ impl Builder<'a, 'll, 'tcx> {\n                                           args.as_ptr(),\n                                           name.as_ptr())\n         };\n-        ret.expect(\"LLVM does not have support for cleanuppad\")\n+        Funclet::new(ret.expect(\"LLVM does not have support for cleanuppad\"))\n     }\n \n-    pub fn cleanup_ret(\n-        &self, cleanup: &'ll Value,\n+    fn cleanup_ret(\n+        &mut self, funclet: &Funclet<'ll>,\n         unwind: Option<&'ll BasicBlock>,\n     ) -> &'ll Value {\n         self.count_insn(\"cleanupret\");\n         let ret = unsafe {\n-            llvm::LLVMRustBuildCleanupRet(self.llbuilder, cleanup, unwind)\n+            llvm::LLVMRustBuildCleanupRet(self.llbuilder, funclet.cleanuppad(), unwind)\n         };\n         ret.expect(\"LLVM does not have support for cleanupret\")\n     }\n \n-    pub fn catch_pad(&self,\n+    fn catch_pad(&mut self,\n                      parent: &'ll Value,\n-                     args: &[&'ll Value]) -> &'ll Value {\n+                     args: &[&'ll Value]) -> Funclet<'ll> {\n         self.count_insn(\"catchpad\");\n         let name = const_cstr!(\"catchpad\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchPad(self.llbuilder, parent,\n                                         args.len() as c_uint, args.as_ptr(),\n                                         name.as_ptr())\n         };\n-        ret.expect(\"LLVM does not have support for catchpad\")\n+        Funclet::new(ret.expect(\"LLVM does not have support for catchpad\"))\n     }\n \n-    pub fn catch_ret(&self, pad: &'ll Value, unwind: &'ll BasicBlock) -> &'ll Value {\n+    fn catch_ret(&mut self, funclet: &Funclet<'ll>, unwind: &'ll BasicBlock) -> &'ll Value {\n         self.count_insn(\"catchret\");\n         let ret = unsafe {\n-            llvm::LLVMRustBuildCatchRet(self.llbuilder, pad, unwind)\n+            llvm::LLVMRustBuildCatchRet(self.llbuilder, funclet.cleanuppad(), unwind)\n         };\n         ret.expect(\"LLVM does not have support for catchret\")\n     }\n \n-    pub fn catch_switch(\n-        &self,\n+    fn catch_switch(\n+        &mut self,\n         parent: Option<&'ll Value>,\n         unwind: Option<&'ll BasicBlock>,\n         num_handlers: usize,\n@@ -1053,80 +1189,101 @@ impl Builder<'a, 'll, 'tcx> {\n         ret.expect(\"LLVM does not have support for catchswitch\")\n     }\n \n-    pub fn add_handler(&self, catch_switch: &'ll Value, handler: &'ll BasicBlock) {\n+    fn add_handler(&mut self, catch_switch: &'ll Value, handler: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMRustAddHandler(catch_switch, handler);\n         }\n     }\n \n-    pub fn set_personality_fn(&self, personality: &'ll Value) {\n+    fn set_personality_fn(&mut self, personality: &'ll Value) {\n         unsafe {\n             llvm::LLVMSetPersonalityFn(self.llfn(), personality);\n         }\n     }\n \n     // Atomic Operations\n-    pub fn atomic_cmpxchg(\n-        &self,\n+    fn atomic_cmpxchg(\n+        &mut self,\n         dst: &'ll Value,\n         cmp: &'ll Value,\n         src: &'ll Value,\n-        order: AtomicOrdering,\n-        failure_order: AtomicOrdering,\n-        weak: llvm::Bool,\n+        order: rustc_codegen_ssa::common::AtomicOrdering,\n+        failure_order: rustc_codegen_ssa::common::AtomicOrdering,\n+        weak: bool,\n     ) -> &'ll Value {\n-        unsafe {\n-            llvm::LLVMRustBuildAtomicCmpXchg(self.llbuilder, dst, cmp, src,\n-                                             order, failure_order, weak)\n+        let weak = if weak { llvm::True } else { llvm::False };\n+        unsafe {\n+            llvm::LLVMRustBuildAtomicCmpXchg(\n+                self.llbuilder,\n+                dst,\n+                cmp,\n+                src,\n+                AtomicOrdering::from_generic(order),\n+                AtomicOrdering::from_generic(failure_order),\n+                weak\n+            )\n         }\n     }\n-    pub fn atomic_rmw(\n-        &self,\n-        op: AtomicRmwBinOp,\n+    fn atomic_rmw(\n+        &mut self,\n+        op: rustc_codegen_ssa::common::AtomicRmwBinOp,\n         dst: &'ll Value,\n         src: &'ll Value,\n-        order: AtomicOrdering,\n+        order: rustc_codegen_ssa::common::AtomicOrdering,\n     ) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildAtomicRMW(self.llbuilder, op, dst, src, order, False)\n+            llvm::LLVMBuildAtomicRMW(\n+                self.llbuilder,\n+                AtomicRmwBinOp::from_generic(op),\n+                dst,\n+                src,\n+                AtomicOrdering::from_generic(order),\n+                False)\n         }\n     }\n \n-    pub fn atomic_fence(&self, order: AtomicOrdering, scope: SynchronizationScope) {\n+    fn atomic_fence(\n+        &mut self,\n+        order: rustc_codegen_ssa::common::AtomicOrdering,\n+        scope: rustc_codegen_ssa::common::SynchronizationScope\n+    ) {\n         unsafe {\n-            llvm::LLVMRustBuildAtomicFence(self.llbuilder, order, scope);\n+            llvm::LLVMRustBuildAtomicFence(\n+                self.llbuilder,\n+                AtomicOrdering::from_generic(order),\n+                SynchronizationScope::from_generic(scope)\n+            );\n         }\n     }\n \n-    pub fn add_case(&self, s: &'ll Value, on_val: &'ll Value, dest: &'ll BasicBlock) {\n+    fn add_case(&mut self, s: &'ll Value, on_val: &'ll Value, dest: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMAddCase(s, on_val, dest)\n         }\n     }\n \n-    pub fn add_incoming_to_phi(&self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock) {\n+    fn add_incoming_to_phi(&mut self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock) {\n         self.count_insn(\"addincoming\");\n         unsafe {\n             llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n         }\n     }\n \n-    pub fn set_invariant_load(&self, load: &'ll Value) {\n+    fn set_invariant_load(&mut self, load: &'ll Value) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_invariant_load as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n         }\n     }\n \n-    /// Returns the ptr value that should be used for storing `val`.\n-    fn check_store<'b>(&self,\n+    fn check_store<'b>(&mut self,\n                        val: &'ll Value,\n                        ptr: &'ll Value) -> &'ll Value {\n-        let dest_ptr_ty = val_ty(ptr);\n-        let stored_ty = val_ty(val);\n-        let stored_ptr_ty = stored_ty.ptr_to();\n+        let dest_ptr_ty = self.cx.val_ty(ptr);\n+        let stored_ty = self.cx.val_ty(val);\n+        let stored_ptr_ty = self.cx.type_ptr_to(stored_ty);\n \n-        assert_eq!(dest_ptr_ty.kind(), llvm::TypeKind::Pointer);\n+        assert_eq!(self.cx.type_kind(dest_ptr_ty), TypeKind::Pointer);\n \n         if dest_ptr_ty == stored_ptr_ty {\n             ptr\n@@ -1138,24 +1295,23 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    /// Returns the args that should be used for a call to `llfn`.\n-    fn check_call<'b>(&self,\n+    fn check_call<'b>(&mut self,\n                       typ: &str,\n                       llfn: &'ll Value,\n                       args: &'b [&'ll Value]) -> Cow<'b, [&'ll Value]> {\n-        let mut fn_ty = val_ty(llfn);\n+        let mut fn_ty = self.cx.val_ty(llfn);\n         // Strip off pointers\n-        while fn_ty.kind() == llvm::TypeKind::Pointer {\n-            fn_ty = fn_ty.element_type();\n+        while self.cx.type_kind(fn_ty) == TypeKind::Pointer {\n+            fn_ty = self.cx.element_type(fn_ty);\n         }\n \n-        assert!(fn_ty.kind() == llvm::TypeKind::Function,\n+        assert!(self.cx.type_kind(fn_ty) == TypeKind::Function,\n                 \"builder::{} not passed a function, but {:?}\", typ, fn_ty);\n \n-        let param_tys = fn_ty.func_params();\n+        let param_tys = self.cx.func_params_types(fn_ty);\n \n         let all_args_match = param_tys.iter()\n-            .zip(args.iter().map(|&v| val_ty(v)))\n+            .zip(args.iter().map(|&v| self.cx().val_ty(v)))\n             .all(|(expected_ty, actual_ty)| *expected_ty == actual_ty);\n \n         if all_args_match {\n@@ -1166,7 +1322,7 @@ impl Builder<'a, 'll, 'tcx> {\n             .zip(args.iter())\n             .enumerate()\n             .map(|(i, (expected_ty, &actual_val))| {\n-                let actual_ty = val_ty(actual_val);\n+                let actual_ty = self.cx().val_ty(actual_val);\n                 if expected_ty != actual_ty {\n                     debug!(\"Type mismatch in function call of {:?}. \\\n                             Expected {:?} for param {}, got {:?}; injecting bitcast\",\n@@ -1181,23 +1337,15 @@ impl Builder<'a, 'll, 'tcx> {\n         Cow::Owned(casted_args)\n     }\n \n-    pub fn lifetime_start(&self, ptr: &'ll Value, size: Size) {\n+    fn lifetime_start(&mut self, ptr: &'ll Value, size: Size) {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.start\", ptr, size);\n     }\n \n-    pub fn lifetime_end(&self, ptr: &'ll Value, size: Size) {\n+    fn lifetime_end(&mut self, ptr: &'ll Value, size: Size) {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.end\", ptr, size);\n     }\n \n-    /// If LLVM lifetime intrinsic support is enabled (i.e. optimizations\n-    /// on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n-    /// and the intrinsic for `lt` and passes them to `emit`, which is in\n-    /// charge of generating code to call the passed intrinsic on whatever\n-    /// block of generated code is targeted for the intrinsic.\n-    ///\n-    /// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n-    /// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n-    fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n+    fn call_lifetime_intrinsic(&mut self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n         if self.cx.sess().opts.optimize == config::OptLevel::No {\n             return;\n         }\n@@ -1209,7 +1357,61 @@ impl Builder<'a, 'll, 'tcx> {\n \n         let lifetime_intrinsic = self.cx.get_intrinsic(intrinsic);\n \n-        let ptr = self.pointercast(ptr, Type::i8p(self.cx));\n-        self.call(lifetime_intrinsic, &[C_u64(self.cx, size), ptr], None);\n+        let ptr = self.pointercast(ptr, self.cx.type_i8p());\n+        self.call(lifetime_intrinsic, &[self.cx.const_u64(size), ptr], None);\n+    }\n+\n+    fn call(\n+        &mut self,\n+        llfn: &'ll Value,\n+        args: &[&'ll Value],\n+        funclet: Option<&Funclet<'ll>>,\n+    ) -> &'ll Value {\n+        self.count_insn(\"call\");\n+\n+        debug!(\"Call {:?} with args ({:?})\",\n+               llfn,\n+               args);\n+\n+        let args = self.check_call(\"call\", llfn, args);\n+        let bundle = funclet.map(|funclet| funclet.bundle());\n+        let bundle = bundle.as_ref().map(|b| &*b.raw);\n+\n+        unsafe {\n+            llvm::LLVMRustBuildCall(\n+                self.llbuilder,\n+                llfn,\n+                args.as_ptr() as *const &llvm::Value,\n+                args.len() as c_uint,\n+                bundle, noname()\n+            )\n+        }\n+    }\n+\n+    fn zext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        self.count_insn(\"zext\");\n+        unsafe {\n+            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n+        }\n+    }\n+\n+    fn struct_gep(&mut self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n+        self.count_insn(\"structgep\");\n+        assert_eq!(idx as c_uint as u64, idx);\n+        unsafe {\n+            llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n+        }\n+    }\n+\n+    fn cx(&self) -> &CodegenCx<'ll, 'tcx> {\n+        self.cx\n+    }\n+\n+    unsafe fn delete_basic_block(&mut self, bb: &'ll BasicBlock) {\n+        llvm::LLVMDeleteBasicBlock(bb);\n+    }\n+\n+    fn do_not_inline(&mut self, llret: &'ll Value) {\n+        llvm::Attribute::NoInline.apply_callsite(llvm::AttributePlace::Function, llret);\n     }\n }"}, {"sha": "e79880e8de06e2f4a7226b3fb04e75a683fd9dc7", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 13, "deletions": 49, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -15,18 +15,14 @@\n //! closure.\n \n use attributes;\n-use common::{self, CodegenCx};\n-use consts;\n-use declare;\n use llvm;\n use monomorphize::Instance;\n-use type_of::LayoutLlvmExt;\n+use context::CodegenCx;\n use value::Value;\n+use rustc_codegen_ssa::traits::*;\n \n-use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, TypeFoldable};\n-use rustc::ty::layout::LayoutOf;\n-use rustc::ty::subst::Substs;\n+use rustc::ty::TypeFoldable;\n+use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n@@ -39,16 +35,16 @@ pub fn get_fn(\n     cx: &CodegenCx<'ll, 'tcx>,\n     instance: Instance<'tcx>,\n ) -> &'ll Value {\n-    let tcx = cx.tcx;\n+    let tcx = cx.tcx();\n \n     debug!(\"get_fn(instance={:?})\", instance);\n \n     assert!(!instance.substs.needs_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n     assert!(!instance.substs.has_param_types());\n \n-    let sig = instance.fn_sig(cx.tcx);\n-    if let Some(&llfn) = cx.instances.borrow().get(&instance) {\n+    let sig = instance.fn_sig(cx.tcx());\n+    if let Some(&llfn) = cx.instances().borrow().get(&instance) {\n         return llfn;\n     }\n \n@@ -57,9 +53,9 @@ pub fn get_fn(\n \n     // Create a fn pointer with the substituted signature.\n     let fn_ptr_ty = tcx.mk_fn_ptr(sig);\n-    let llptrty = cx.layout_of(fn_ptr_ty).llvm_type(cx);\n+    let llptrty = cx.backend_type(cx.layout_of(fn_ptr_ty));\n \n-    let llfn = if let Some(llfn) = declare::get_declared_value(cx, &sym) {\n+    let llfn = if let Some(llfn) = cx.get_declared_value(&sym) {\n         // This is subtle and surprising, but sometimes we have to bitcast\n         // the resulting fn pointer.  The reason has to do with external\n         // functions.  If you have two crates that both bind the same C\n@@ -83,16 +79,16 @@ pub fn get_fn(\n         // This can occur on either a crate-local or crate-external\n         // reference. It also occurs when testing libcore and in some\n         // other weird situations. Annoying.\n-        if common::val_ty(llfn) != llptrty {\n+        if cx.val_ty(llfn) != llptrty {\n             debug!(\"get_fn: casting {:?} to {:?}\", llfn, llptrty);\n-            consts::ptrcast(llfn, llptrty)\n+            cx.static_ptrcast(llfn, llptrty)\n         } else {\n             debug!(\"get_fn: not casting pointer!\");\n             llfn\n         }\n     } else {\n-        let llfn = declare::declare_fn(cx, &sym, sig);\n-        assert_eq!(common::val_ty(llfn), llptrty);\n+        let llfn = cx.declare_fn(&sym, sig);\n+        assert_eq!(cx.val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n \n         if instance.def.is_inline(tcx) {\n@@ -204,35 +200,3 @@ pub fn get_fn(\n \n     llfn\n }\n-\n-pub fn resolve_and_get_fn(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    def_id: DefId,\n-    substs: &'tcx Substs<'tcx>,\n-) -> &'ll Value {\n-    get_fn(\n-        cx,\n-        ty::Instance::resolve(\n-            cx.tcx,\n-            ty::ParamEnv::reveal_all(),\n-            def_id,\n-            substs\n-        ).unwrap()\n-    )\n-}\n-\n-pub fn resolve_and_get_fn_for_vtable(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    def_id: DefId,\n-    substs: &'tcx Substs<'tcx>,\n-) -> &'ll Value {\n-    get_fn(\n-        cx,\n-        ty::Instance::resolve_for_vtable(\n-            cx.tcx,\n-            ty::ParamEnv::reveal_all(),\n-            def_id,\n-            substs\n-        ).unwrap()\n-    )\n-}"}, {"sha": "2fc505d42db52c120510550d4c9e2737cccebc4e", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 248, "deletions": 252, "changes": 500, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -12,42 +12,26 @@\n \n //! Code that is useful in various codegen modules.\n \n-use llvm::{self, TypeKind};\n-use llvm::{True, False, Bool, OperandBundleDef};\n-use rustc::hir::def_id::DefId;\n-use rustc::middle::lang_items::LangItem;\n+use llvm::{self, True, False, Bool, BasicBlock, OperandBundleDef};\n use abi;\n-use base;\n-use builder::Builder;\n use consts;\n-use declare;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n+use rustc_codegen_ssa::traits::*;\n \n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{HasDataLayout, LayoutOf};\n-use rustc::hir;\n+use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size};\n+use rustc::mir::interpret::{Scalar, AllocType, Allocation};\n+use consts::const_alloc_to_llvm;\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n \n use libc::{c_uint, c_char};\n \n use syntax::symbol::LocalInternedString;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax::ast::Mutability;\n \n pub use context::CodegenCx;\n \n-pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.needs_drop(tcx, ty::ParamEnv::reveal_all())\n-}\n-\n-pub fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_sized(tcx.at(DUMMY_SP), ty::ParamEnv::reveal_all())\n-}\n-\n-pub fn type_is_freeze<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_freeze(tcx, ty::ParamEnv::reveal_all(), DUMMY_SP)\n-}\n-\n /*\n * A note on nomenclature of linking: \"extern\", \"foreign\", and \"upcall\".\n *\n@@ -110,295 +94,307 @@ impl Funclet<'ll> {\n     }\n }\n \n-pub fn val_ty(v: &'ll Value) -> &'ll Type {\n-    unsafe {\n-        llvm::LLVMTypeOf(v)\n-    }\n-}\n+impl BackendTypes for CodegenCx<'ll, 'tcx> {\n+    type Value = &'ll Value;\n+    type BasicBlock = &'ll BasicBlock;\n+    type Type = &'ll Type;\n+    type Context = &'ll llvm::Context;\n+    type Funclet = Funclet<'ll>;\n \n-// LLVM constant constructors.\n-pub fn C_null(t: &'ll Type) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMConstNull(t)\n-    }\n+    type DIScope = &'ll llvm::debuginfo::DIScope;\n }\n \n-pub fn C_undef(t: &'ll Type) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMGetUndef(t)\n+impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn const_null(&self, t: &'ll Type) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMConstNull(t)\n+        }\n     }\n-}\n \n-pub fn C_int(t: &'ll Type, i: i64) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMConstInt(t, i as u64, True)\n+    fn const_undef(&self, t: &'ll Type) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMGetUndef(t)\n+        }\n     }\n-}\n \n-pub fn C_uint(t: &'ll Type, i: u64) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMConstInt(t, i, False)\n+    fn const_int(&self, t: &'ll Type, i: i64) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMConstInt(t, i as u64, True)\n+        }\n     }\n-}\n \n-pub fn C_uint_big(t: &'ll Type, u: u128) -> &'ll Value {\n-    unsafe {\n-        let words = [u as u64, (u >> 64) as u64];\n-        llvm::LLVMConstIntOfArbitraryPrecision(t, 2, words.as_ptr())\n+    fn const_uint(&self, t: &'ll Type, i: u64) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMConstInt(t, i, False)\n+        }\n     }\n-}\n-\n-pub fn C_bool(cx: &CodegenCx<'ll, '_>, val: bool) -> &'ll Value {\n-    C_uint(Type::i1(cx), val as u64)\n-}\n-\n-pub fn C_i32(cx: &CodegenCx<'ll, '_>, i: i32) -> &'ll Value {\n-    C_int(Type::i32(cx), i as i64)\n-}\n \n-pub fn C_u32(cx: &CodegenCx<'ll, '_>, i: u32) -> &'ll Value {\n-    C_uint(Type::i32(cx), i as u64)\n-}\n-\n-pub fn C_u64(cx: &CodegenCx<'ll, '_>, i: u64) -> &'ll Value {\n-    C_uint(Type::i64(cx), i)\n-}\n+    fn const_uint_big(&self, t: &'ll Type, u: u128) -> &'ll Value {\n+        unsafe {\n+            let words = [u as u64, (u >> 64) as u64];\n+            llvm::LLVMConstIntOfArbitraryPrecision(t, 2, words.as_ptr())\n+        }\n+    }\n \n-pub fn C_usize(cx: &CodegenCx<'ll, '_>, i: u64) -> &'ll Value {\n-    let bit_size = cx.data_layout().pointer_size.bits();\n-    if bit_size < 64 {\n-        // make sure it doesn't overflow\n-        assert!(i < (1<<bit_size));\n+    fn const_bool(&self, val: bool) -> &'ll Value {\n+        self.const_uint(self.type_i1(), val as u64)\n     }\n \n-    C_uint(cx.isize_ty, i)\n-}\n+    fn const_i32(&self, i: i32) -> &'ll Value {\n+        self.const_int(self.type_i32(), i as i64)\n+    }\n \n-pub fn C_u8(cx: &CodegenCx<'ll, '_>, i: u8) -> &'ll Value {\n-    C_uint(Type::i8(cx), i as u64)\n-}\n+    fn const_u32(&self, i: u32) -> &'ll Value {\n+        self.const_uint(self.type_i32(), i as u64)\n+    }\n \n+    fn const_u64(&self, i: u64) -> &'ll Value {\n+        self.const_uint(self.type_i64(), i)\n+    }\n \n-// This is a 'c-like' raw string, which differs from\n-// our boxed-and-length-annotated strings.\n-pub fn C_cstr(\n-    cx: &CodegenCx<'ll, '_>,\n-    s: LocalInternedString,\n-    null_terminated: bool,\n-) -> &'ll Value {\n-    unsafe {\n-        if let Some(&llval) = cx.const_cstr_cache.borrow().get(&s) {\n-            return llval;\n+    fn const_usize(&self, i: u64) -> &'ll Value {\n+        let bit_size = self.data_layout().pointer_size.bits();\n+        if bit_size < 64 {\n+            // make sure it doesn't overflow\n+            assert!(i < (1<<bit_size));\n         }\n \n-        let sc = llvm::LLVMConstStringInContext(cx.llcx,\n-                                                s.as_ptr() as *const c_char,\n-                                                s.len() as c_uint,\n-                                                !null_terminated as Bool);\n-        let sym = cx.generate_local_symbol_name(\"str\");\n-        let g = declare::define_global(cx, &sym[..], val_ty(sc)).unwrap_or_else(||{\n-            bug!(\"symbol `{}` is already defined\", sym);\n-        });\n-        llvm::LLVMSetInitializer(g, sc);\n-        llvm::LLVMSetGlobalConstant(g, True);\n-        llvm::LLVMRustSetLinkage(g, llvm::Linkage::InternalLinkage);\n-\n-        cx.const_cstr_cache.borrow_mut().insert(s, g);\n-        g\n+        self.const_uint(self.isize_ty, i)\n     }\n-}\n \n-// NB: Do not use `do_spill_noroot` to make this into a constant string, or\n-// you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_str_slice(cx: &CodegenCx<'ll, '_>, s: LocalInternedString) -> &'ll Value {\n-    let len = s.len();\n-    let cs = consts::ptrcast(C_cstr(cx, s, false),\n-        cx.layout_of(cx.tcx.mk_str()).llvm_type(cx).ptr_to());\n-    C_fat_ptr(cx, cs, C_usize(cx, len as u64))\n-}\n+    fn const_u8(&self, i: u8) -> &'ll Value {\n+        self.const_uint(self.type_i8(), i as u64)\n+    }\n \n-pub fn C_fat_ptr(cx: &CodegenCx<'ll, '_>, ptr: &'ll Value, meta: &'ll Value) -> &'ll Value {\n-    assert_eq!(abi::FAT_PTR_ADDR, 0);\n-    assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-    C_struct(cx, &[ptr, meta], false)\n-}\n+    fn const_cstr(\n+        &self,\n+        s: LocalInternedString,\n+        null_terminated: bool,\n+    ) -> &'ll Value {\n+        unsafe {\n+            if let Some(&llval) = self.const_cstr_cache.borrow().get(&s) {\n+                return llval;\n+            }\n \n-pub fn C_struct(cx: &CodegenCx<'ll, '_>, elts: &[&'ll Value], packed: bool) -> &'ll Value {\n-    C_struct_in_context(cx.llcx, elts, packed)\n-}\n+            let sc = llvm::LLVMConstStringInContext(self.llcx,\n+                                                    s.as_ptr() as *const c_char,\n+                                                    s.len() as c_uint,\n+                                                    !null_terminated as Bool);\n+            let sym = self.generate_local_symbol_name(\"str\");\n+            let g = self.define_global(&sym[..], self.val_ty(sc)).unwrap_or_else(||{\n+                bug!(\"symbol `{}` is already defined\", sym);\n+            });\n+            llvm::LLVMSetInitializer(g, sc);\n+            llvm::LLVMSetGlobalConstant(g, True);\n+            llvm::LLVMRustSetLinkage(g, llvm::Linkage::InternalLinkage);\n+\n+            self.const_cstr_cache.borrow_mut().insert(s, g);\n+            g\n+        }\n+    }\n \n-pub fn C_struct_in_context(\n-    llcx: &'ll llvm::Context,\n-    elts: &[&'ll Value],\n-    packed: bool,\n-) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMConstStructInContext(llcx,\n-                                       elts.as_ptr(), elts.len() as c_uint,\n-                                       packed as Bool)\n+    fn const_str_slice(&self, s: LocalInternedString) -> &'ll Value {\n+        let len = s.len();\n+        let cs = consts::ptrcast(self.const_cstr(s, false),\n+            self.type_ptr_to(self.layout_of(self.tcx.mk_str()).llvm_type(self)));\n+        self.const_fat_ptr(cs, self.const_usize(len as u64))\n     }\n-}\n \n-pub fn C_array(ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n-    unsafe {\n-        return llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint);\n+    fn const_fat_ptr(\n+        &self,\n+        ptr: &'ll Value,\n+        meta: &'ll Value\n+    ) -> &'ll Value {\n+        assert_eq!(abi::FAT_PTR_ADDR, 0);\n+        assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+        self.const_struct(&[ptr, meta], false)\n     }\n-}\n \n-pub fn C_vector(elts: &[&'ll Value]) -> &'ll Value {\n-    unsafe {\n-        return llvm::LLVMConstVector(elts.as_ptr(), elts.len() as c_uint);\n+    fn const_struct(\n+        &self,\n+        elts: &[&'ll Value],\n+        packed: bool\n+    ) -> &'ll Value {\n+        struct_in_context(self.llcx, elts, packed)\n     }\n-}\n \n-pub fn C_bytes(cx: &CodegenCx<'ll, '_>, bytes: &[u8]) -> &'ll Value {\n-    C_bytes_in_context(cx.llcx, bytes)\n-}\n+    fn const_array(&self, ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n+        unsafe {\n+            return llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint);\n+        }\n+    }\n \n-pub fn C_bytes_in_context(llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n-    unsafe {\n-        let ptr = bytes.as_ptr() as *const c_char;\n-        return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n+    fn const_vector(&self, elts: &[&'ll Value]) -> &'ll Value {\n+        unsafe {\n+            return llvm::LLVMConstVector(elts.as_ptr(), elts.len() as c_uint);\n+        }\n     }\n-}\n \n-pub fn const_get_elt(v: &'ll Value, idx: u64) -> &'ll Value {\n-    unsafe {\n-        assert_eq!(idx as c_uint as u64, idx);\n-        let us = &[idx as c_uint];\n-        let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n+    fn const_bytes(&self, bytes: &[u8]) -> &'ll Value {\n+        bytes_in_context(self.llcx, bytes)\n+    }\n \n-        debug!(\"const_get_elt(v={:?}, idx={}, r={:?})\",\n-               v, idx, r);\n+    fn const_get_elt(&self, v: &'ll Value, idx: u64) -> &'ll Value {\n+        unsafe {\n+            assert_eq!(idx as c_uint as u64, idx);\n+            let us = &[idx as c_uint];\n+            let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n-        r\n-    }\n-}\n+            debug!(\"const_get_elt(v={:?}, idx={}, r={:?})\",\n+                   v, idx, r);\n \n-pub fn const_get_real(v: &'ll Value) -> Option<(f64, bool)> {\n-    unsafe {\n-        if is_const_real(v) {\n-            let mut loses_info: llvm::Bool = ::std::mem::uninitialized();\n-            let r = llvm::LLVMConstRealGetDouble(v, &mut loses_info);\n-            let loses_info = if loses_info == 1 { true } else { false };\n-            Some((r, loses_info))\n-        } else {\n-            None\n+            r\n         }\n     }\n-}\n \n-pub fn const_to_uint(v: &'ll Value) -> u64 {\n-    unsafe {\n-        llvm::LLVMConstIntGetZExtValue(v)\n+    fn const_get_real(&self, v: &'ll Value) -> Option<(f64, bool)> {\n+        unsafe {\n+            if self.is_const_real(v) {\n+                let mut loses_info: llvm::Bool = ::std::mem::uninitialized();\n+                let r = llvm::LLVMConstRealGetDouble(v, &mut loses_info);\n+                let loses_info = if loses_info == 1 { true } else { false };\n+                Some((r, loses_info))\n+            } else {\n+                None\n+            }\n+        }\n     }\n-}\n \n-pub fn is_const_integral(v: &'ll Value) -> bool {\n-    unsafe {\n-        llvm::LLVMIsAConstantInt(v).is_some()\n+    fn const_to_uint(&self, v: &'ll Value) -> u64 {\n+        unsafe {\n+            llvm::LLVMConstIntGetZExtValue(v)\n+        }\n     }\n-}\n \n-pub fn is_const_real(v: &'ll Value) -> bool {\n-    unsafe {\n-        llvm::LLVMIsAConstantFP(v).is_some()\n+    fn is_const_integral(&self, v: &'ll Value) -> bool {\n+        unsafe {\n+            llvm::LLVMIsAConstantInt(v).is_some()\n+        }\n     }\n-}\n \n+    fn is_const_real(&self, v: &'ll Value) -> bool {\n+        unsafe {\n+            llvm::LLVMIsAConstantFP(v).is_some()\n+        }\n+    }\n \n-#[inline]\n-fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n-    ((hi as u128) << 64) | (lo as u128)\n-}\n-\n-pub fn const_to_opt_u128(v: &'ll Value, sign_ext: bool) -> Option<u128> {\n-    unsafe {\n-        if is_const_integral(v) {\n-            let (mut lo, mut hi) = (0u64, 0u64);\n-            let success = llvm::LLVMRustConstInt128Get(v, sign_ext,\n-                                                       &mut hi, &mut lo);\n-            if success {\n-                Some(hi_lo_to_u128(lo, hi))\n+    fn const_to_opt_u128(&self, v: &'ll Value, sign_ext: bool) -> Option<u128> {\n+        unsafe {\n+            if self.is_const_integral(v) {\n+                let (mut lo, mut hi) = (0u64, 0u64);\n+                let success = llvm::LLVMRustConstInt128Get(v, sign_ext,\n+                                                           &mut hi, &mut lo);\n+                if success {\n+                    Some(hi_lo_to_u128(lo, hi))\n+                } else {\n+                    None\n+                }\n             } else {\n                 None\n             }\n-        } else {\n-            None\n         }\n     }\n-}\n \n-pub fn langcall(tcx: TyCtxt,\n-                span: Option<Span>,\n-                msg: &str,\n-                li: LangItem)\n-                -> DefId {\n-    tcx.lang_items().require(li).unwrap_or_else(|s| {\n-        let msg = format!(\"{} {}\", msg, s);\n-        match span {\n-            Some(span) => tcx.sess.span_fatal(span, &msg[..]),\n-            None => tcx.sess.fatal(&msg[..]),\n+    fn scalar_to_backend(\n+        &self,\n+        cv: Scalar,\n+        layout: &layout::Scalar,\n+        llty: &'ll Type,\n+    ) -> &'ll Value {\n+        let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n+        match cv {\n+            Scalar::Bits { size: 0, .. } => {\n+                assert_eq!(0, layout.value.size(self).bytes());\n+                self.const_undef(self.type_ix(0))\n+            },\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(size as u64, layout.value.size(self).bytes());\n+                let llval = self.const_uint_big(self.type_ix(bitsize), bits);\n+                if layout.value == layout::Pointer {\n+                    unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n+                } else {\n+                    self.static_bitcast(llval, llty)\n+                }\n+            },\n+            Scalar::Ptr(ptr) => {\n+                let alloc_type = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                let base_addr = match alloc_type {\n+                    Some(AllocType::Memory(alloc)) => {\n+                        let init = const_alloc_to_llvm(self, alloc);\n+                        if alloc.mutability == Mutability::Mutable {\n+                            self.static_addr_of_mut(init, alloc.align, None)\n+                        } else {\n+                            self.static_addr_of(init, alloc.align, None)\n+                        }\n+                    }\n+                    Some(AllocType::Function(fn_instance)) => {\n+                        self.get_fn(fn_instance)\n+                    }\n+                    Some(AllocType::Static(def_id)) => {\n+                        assert!(self.tcx.is_static(def_id).is_some());\n+                        self.get_static(def_id)\n+                    }\n+                    None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n+                };\n+                let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n+                    self.static_bitcast(base_addr, self.type_i8p()),\n+                    &self.const_usize(ptr.offset.bytes()),\n+                    1,\n+                ) };\n+                if layout.value != layout::Pointer {\n+                    unsafe { llvm::LLVMConstPtrToInt(llval, llty) }\n+                } else {\n+                    self.static_bitcast(llval, llty)\n+                }\n+            }\n         }\n-    })\n-}\n+    }\n \n-// To avoid UB from LLVM, these two functions mask RHS with an\n-// appropriate mask unconditionally (i.e. the fallback behavior for\n-// all shifts). For 32- and 64-bit types, this matches the semantics\n-// of Java. (See related discussion on #1877 and #10183.)\n-\n-pub fn build_unchecked_lshift(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    lhs: &'ll Value,\n-    rhs: &'ll Value\n-) -> &'ll Value {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shl, lhs, rhs);\n-    // #1877, #10183: Ensure that input is always valid\n-    let rhs = shift_mask_rhs(bx, rhs);\n-    bx.shl(lhs, rhs)\n+    fn from_const_alloc(\n+        &self,\n+        layout: TyLayout<'tcx>,\n+        alloc: &Allocation,\n+        offset: Size,\n+    ) -> PlaceRef<'tcx, &'ll Value> {\n+        let init = const_alloc_to_llvm(self, alloc);\n+        let base_addr = self.static_addr_of(init, layout.align, None);\n+\n+        let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n+            self.static_bitcast(base_addr, self.type_i8p()),\n+            &self.const_usize(offset.bytes()),\n+            1,\n+        )};\n+        let llval = self.static_bitcast(llval, self.type_ptr_to(layout.llvm_type(self)));\n+        PlaceRef::new_sized(llval, layout, alloc.align)\n+    }\n }\n \n-pub fn build_unchecked_rshift(\n-    bx: &Builder<'a, 'll, 'tcx>, lhs_t: Ty<'tcx>, lhs: &'ll Value, rhs: &'ll Value\n-) -> &'ll Value {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shr, lhs, rhs);\n-    // #1877, #10183: Ensure that input is always valid\n-    let rhs = shift_mask_rhs(bx, rhs);\n-    let is_signed = lhs_t.is_signed();\n-    if is_signed {\n-        bx.ashr(lhs, rhs)\n-    } else {\n-        bx.lshr(lhs, rhs)\n+pub fn val_ty(v: &'ll Value) -> &'ll Type {\n+    unsafe {\n+        llvm::LLVMTypeOf(v)\n     }\n }\n \n-fn shift_mask_rhs(bx: &Builder<'a, 'll, 'tcx>, rhs: &'ll Value) -> &'ll Value {\n-    let rhs_llty = val_ty(rhs);\n-    bx.and(rhs, shift_mask_val(bx, rhs_llty, rhs_llty, false))\n+pub fn bytes_in_context(llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n+    unsafe {\n+        let ptr = bytes.as_ptr() as *const c_char;\n+        return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n+    }\n }\n \n-pub fn shift_mask_val(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    llty: &'ll Type,\n-    mask_llty: &'ll Type,\n-    invert: bool\n-) -> &'ll Value {\n-    let kind = llty.kind();\n-    match kind {\n-        TypeKind::Integer => {\n-            // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n-            let val = llty.int_width() - 1;\n-            if invert {\n-                C_int(mask_llty, !val as i64)\n-            } else {\n-                C_uint(mask_llty, val)\n-            }\n-        },\n-        TypeKind::Vector => {\n-            let mask = shift_mask_val(bx, llty.element_type(), mask_llty.element_type(), invert);\n-            bx.vector_splat(mask_llty.vector_length(), mask)\n-        },\n-        _ => bug!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n+pub fn struct_in_context(\n+    llcx: &'a llvm::Context,\n+    elts: &[&'a Value],\n+    packed: bool,\n+) -> &'a Value {\n+    unsafe {\n+        llvm::LLVMConstStructInContext(llcx,\n+                                       elts.as_ptr(), elts.len() as c_uint,\n+                                       packed as Bool)\n     }\n }\n+\n+#[inline]\n+fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n+    ((hi as u128) << 64) | (lo as u128)\n+}"}, {"sha": "821ac931aac72fa5db9cb81065e7248ed59cc4af", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 378, "deletions": 309, "changes": 687, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -11,36 +11,80 @@\n use libc::c_uint;\n use llvm::{self, SetUnnamedAddr, True};\n use rustc::hir::def_id::DefId;\n+use rustc::mir::interpret::{ConstValue, Allocation, read_target_uint,\n+    Pointer, ErrorHandled, GlobalId};\n use rustc::hir::Node;\n use debuginfo;\n-use base;\n use monomorphize::MonoItem;\n-use common::{CodegenCx, val_ty};\n-use declare;\n+use common::CodegenCx;\n use monomorphize::Instance;\n use syntax_pos::Span;\n+use rustc_target::abi::HasDataLayout;\n use syntax_pos::symbol::LocalInternedString;\n+use base;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n use rustc::ty::{self, Ty};\n+use rustc_codegen_ssa::traits::*;\n \n-use rustc::ty::layout::{Align, LayoutOf};\n+use rustc::ty::layout::{self, Size, Align, LayoutOf};\n \n use rustc::hir::{self, CodegenFnAttrs, CodegenFnAttrFlags};\n \n use std::ffi::{CStr, CString};\n \n-pub fn ptrcast(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMConstPointerCast(val, ty)\n+pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n+    let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n+    let dl = cx.data_layout();\n+    let pointer_size = dl.pointer_size.bytes() as usize;\n+\n+    let mut next_offset = 0;\n+    for &(offset, ((), alloc_id)) in alloc.relocations.iter() {\n+        let offset = offset.bytes();\n+        assert_eq!(offset as usize as u64, offset);\n+        let offset = offset as usize;\n+        if offset > next_offset {\n+            llvals.push(cx.const_bytes(&alloc.bytes[next_offset..offset]));\n+        }\n+        let ptr_offset = read_target_uint(\n+            dl.endian,\n+            &alloc.bytes[offset..(offset + pointer_size)],\n+        ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n+        llvals.push(cx.scalar_to_backend(\n+            Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n+            &layout::Scalar {\n+                value: layout::Primitive::Pointer,\n+                valid_range: 0..=!0\n+            },\n+            cx.type_i8p()\n+        ));\n+        next_offset = offset + pointer_size;\n     }\n+    if alloc.bytes.len() >= next_offset {\n+        llvals.push(cx.const_bytes(&alloc.bytes[next_offset ..]));\n+    }\n+\n+    cx.const_struct(&llvals, true)\n }\n \n-pub fn bitcast(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMConstBitCast(val, ty)\n-    }\n+pub fn codegen_static_initializer(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    def_id: DefId,\n+) -> Result<(&'ll Value, &'tcx Allocation), ErrorHandled> {\n+    let instance = ty::Instance::mono(cx.tcx, def_id);\n+    let cid = GlobalId {\n+        instance,\n+        promoted: None,\n+    };\n+    let param_env = ty::ParamEnv::reveal_all();\n+    let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n+\n+    let alloc = match static_.val {\n+        ConstValue::ByRef(_, alloc, n) if n.bytes() == 0 => alloc,\n+        _ => bug!(\"static const eval returned {:#?}\", static_),\n+    };\n+    Ok((const_alloc_to_llvm(cx, alloc), alloc))\n }\n \n fn set_global_alignment(cx: &CodegenCx<'ll, '_>,\n@@ -62,177 +106,6 @@ fn set_global_alignment(cx: &CodegenCx<'ll, '_>,\n     }\n }\n \n-pub fn addr_of_mut(\n-    cx: &CodegenCx<'ll, '_>,\n-    cv: &'ll Value,\n-    align: Align,\n-    kind: Option<&str>,\n-) -> &'ll Value {\n-    unsafe {\n-        let gv = match kind {\n-            Some(kind) if !cx.tcx.sess.fewer_names() => {\n-                let name = cx.generate_local_symbol_name(kind);\n-                let gv = declare::define_global(cx, &name[..], val_ty(cv)).unwrap_or_else(||{\n-                    bug!(\"symbol `{}` is already defined\", name);\n-                });\n-                llvm::LLVMRustSetLinkage(gv, llvm::Linkage::PrivateLinkage);\n-                gv\n-            },\n-            _ => declare::define_private_global(cx, val_ty(cv)),\n-        };\n-        llvm::LLVMSetInitializer(gv, cv);\n-        set_global_alignment(cx, gv, align);\n-        SetUnnamedAddr(gv, true);\n-        gv\n-    }\n-}\n-\n-pub fn addr_of(\n-    cx: &CodegenCx<'ll, '_>,\n-    cv: &'ll Value,\n-    align: Align,\n-    kind: Option<&str>,\n-) -> &'ll Value {\n-    if let Some(&gv) = cx.const_globals.borrow().get(&cv) {\n-        unsafe {\n-            // Upgrade the alignment in cases where the same constant is used with different\n-            // alignment requirements\n-            let llalign = align.abi() as u32;\n-            if llalign > llvm::LLVMGetAlignment(gv) {\n-                llvm::LLVMSetAlignment(gv, llalign);\n-            }\n-        }\n-        return gv;\n-    }\n-    let gv = addr_of_mut(cx, cv, align, kind);\n-    unsafe {\n-        llvm::LLVMSetGlobalConstant(gv, True);\n-    }\n-    cx.const_globals.borrow_mut().insert(cv, gv);\n-    gv\n-}\n-\n-pub fn get_static(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll Value {\n-    let instance = Instance::mono(cx.tcx, def_id);\n-    if let Some(&g) = cx.instances.borrow().get(&instance) {\n-        return g;\n-    }\n-\n-    let defined_in_current_codegen_unit = cx.codegen_unit\n-                                            .items()\n-                                            .contains_key(&MonoItem::Static(def_id));\n-    assert!(!defined_in_current_codegen_unit,\n-            \"consts::get_static() should always hit the cache for \\\n-             statics defined in the same CGU, but did not for `{:?}`\",\n-            def_id);\n-\n-    let ty = instance.ty(cx.tcx);\n-    let sym = cx.tcx.symbol_name(instance).as_str();\n-\n-    debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n-\n-    let g = if let Some(id) = cx.tcx.hir.as_local_node_id(def_id) {\n-\n-        let llty = cx.layout_of(ty).llvm_type(cx);\n-        let (g, attrs) = match cx.tcx.hir.get(id) {\n-            Node::Item(&hir::Item {\n-                ref attrs, span, node: hir::ItemKind::Static(..), ..\n-            }) => {\n-                if declare::get_declared_value(cx, &sym[..]).is_some() {\n-                    span_bug!(span, \"Conflicting symbol names for static?\");\n-                }\n-\n-                let g = declare::define_global(cx, &sym[..], llty).unwrap();\n-\n-                if !cx.tcx.is_reachable_non_generic(def_id) {\n-                    unsafe {\n-                        llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n-                    }\n-                }\n-\n-                (g, attrs)\n-            }\n-\n-            Node::ForeignItem(&hir::ForeignItem {\n-                ref attrs, span, node: hir::ForeignItemKind::Static(..), ..\n-            }) => {\n-                let fn_attrs = cx.tcx.codegen_fn_attrs(def_id);\n-                (check_and_apply_linkage(cx, &fn_attrs, ty, sym, Some(span)), attrs)\n-            }\n-\n-            item => bug!(\"get_static: expected static, found {:?}\", item)\n-        };\n-\n-        debug!(\"get_static: sym={} attrs={:?}\", sym, attrs);\n-\n-        for attr in attrs {\n-            if attr.check_name(\"thread_local\") {\n-                llvm::set_thread_local_mode(g, cx.tls_model);\n-            }\n-        }\n-\n-        g\n-    } else {\n-        // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n-        debug!(\"get_static: sym={} item_attr={:?}\", sym, cx.tcx.item_attrs(def_id));\n-\n-        let attrs = cx.tcx.codegen_fn_attrs(def_id);\n-        let g = check_and_apply_linkage(cx, &attrs, ty, sym, None);\n-\n-        // Thread-local statics in some other crate need to *always* be linked\n-        // against in a thread-local fashion, so we need to be sure to apply the\n-        // thread-local attribute locally if it was present remotely. If we\n-        // don't do this then linker errors can be generated where the linker\n-        // complains that one object files has a thread local version of the\n-        // symbol and another one doesn't.\n-        if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n-            llvm::set_thread_local_mode(g, cx.tls_model);\n-        }\n-\n-        let needs_dll_storage_attr =\n-            cx.use_dll_storage_attrs && !cx.tcx.is_foreign_item(def_id) &&\n-            // ThinLTO can't handle this workaround in all cases, so we don't\n-            // emit the attrs. Instead we make them unnecessary by disallowing\n-            // dynamic linking when cross-language LTO is enabled.\n-            !cx.tcx.sess.opts.debugging_opts.cross_lang_lto.enabled();\n-\n-        // If this assertion triggers, there's something wrong with commandline\n-        // argument validation.\n-        debug_assert!(!(cx.tcx.sess.opts.debugging_opts.cross_lang_lto.enabled() &&\n-                        cx.tcx.sess.target.target.options.is_like_msvc &&\n-                        cx.tcx.sess.opts.cg.prefer_dynamic));\n-\n-        if needs_dll_storage_attr {\n-            // This item is external but not foreign, i.e. it originates from an external Rust\n-            // crate. Since we don't know whether this crate will be linked dynamically or\n-            // statically in the final application, we always mark such symbols as 'dllimport'.\n-            // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs to\n-            // make things work.\n-            //\n-            // However, in some scenarios we defer emission of statics to downstream\n-            // crates, so there are cases where a static with an upstream DefId\n-            // is actually present in the current crate. We can find out via the\n-            // is_codegened_item query.\n-            if !cx.tcx.is_codegened_item(def_id) {\n-                unsafe {\n-                    llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n-                }\n-            }\n-        }\n-        g\n-    };\n-\n-    if cx.use_dll_storage_attrs && cx.tcx.is_dllimport_foreign_item(def_id) {\n-        // For foreign (native) libs we know the exact storage type to use.\n-        unsafe {\n-            llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n-        }\n-    }\n-\n-    cx.instances.borrow_mut().insert(instance, g);\n-    g\n-}\n-\n fn check_and_apply_linkage(\n     cx: &CodegenCx<'ll, 'tcx>,\n     attrs: &CodegenFnAttrs,\n@@ -260,7 +133,7 @@ fn check_and_apply_linkage(\n         };\n         unsafe {\n             // Declare a symbol `foo` with the desired linkage.\n-            let g1 = declare::declare_global(cx, &sym, llty2);\n+            let g1 = cx.declare_global(&sym, llty2);\n             llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n \n             // Declare an internal global `extern_with_linkage_foo` which\n@@ -271,7 +144,7 @@ fn check_and_apply_linkage(\n             // zero.\n             let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n             real_name.push_str(&sym);\n-            let g2 = declare::define_global(cx, &real_name, llty).unwrap_or_else(||{\n+            let g2 = cx.define_global(&real_name, llty).unwrap_or_else(||{\n                 if let Some(span) = span {\n                     cx.sess().span_fatal(\n                         span,\n@@ -288,150 +161,346 @@ fn check_and_apply_linkage(\n     } else {\n         // Generate an external declaration.\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n-        declare::declare_global(cx, &sym, llty)\n+        cx.declare_global(&sym, llty)\n     }\n }\n \n-pub fn codegen_static<'a, 'tcx>(\n-    cx: &CodegenCx<'a, 'tcx>,\n-    def_id: DefId,\n-    is_mutable: bool,\n-) {\n+pub fn ptrcast(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n     unsafe {\n-        let attrs = cx.tcx.codegen_fn_attrs(def_id);\n+        llvm::LLVMConstPointerCast(val, ty)\n+    }\n+}\n \n-        let (v, alloc) = match ::mir::codegen_static_initializer(cx, def_id) {\n-            Ok(v) => v,\n-            // Error has already been reported\n-            Err(_) => return,\n-        };\n+impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n-        let g = get_static(cx, def_id);\n+    fn static_ptrcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+        ptrcast(val, ty)\n+    }\n \n-        // boolean SSA values are i1, but they have to be stored in i8 slots,\n-        // otherwise some LLVM optimization passes don't work as expected\n-        let mut val_llty = val_ty(v);\n-        let v = if val_llty == Type::i1(cx) {\n-            val_llty = Type::i8(cx);\n-            llvm::LLVMConstZExt(v, val_llty)\n-        } else {\n-            v\n-        };\n+    fn static_bitcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMConstBitCast(val, ty)\n+        }\n+    }\n+\n+    fn static_addr_of_mut(\n+        &self,\n+        cv: &'ll Value,\n+        align: Align,\n+        kind: Option<&str>,\n+    ) -> &'ll Value {\n+        unsafe {\n+            let gv = match kind {\n+                Some(kind) if !self.tcx.sess.fewer_names() => {\n+                    let name = self.generate_local_symbol_name(kind);\n+                    let gv = self.define_global(&name[..],\n+                        self.val_ty(cv)).unwrap_or_else(||{\n+                            bug!(\"symbol `{}` is already defined\", name);\n+                    });\n+                    llvm::LLVMRustSetLinkage(gv, llvm::Linkage::PrivateLinkage);\n+                    gv\n+                },\n+                _ => self.define_private_global(self.val_ty(cv)),\n+            };\n+            llvm::LLVMSetInitializer(gv, cv);\n+            set_global_alignment(&self, gv, align);\n+            SetUnnamedAddr(gv, true);\n+            gv\n+        }\n+    }\n+\n+    fn static_addr_of(\n+        &self,\n+        cv: &'ll Value,\n+        align: Align,\n+        kind: Option<&str>,\n+    ) -> &'ll Value {\n+        if let Some(&gv) = self.const_globals.borrow().get(&cv) {\n+            unsafe {\n+                // Upgrade the alignment in cases where the same constant is used with different\n+                // alignment requirements\n+                let llalign = align.abi() as u32;\n+                if llalign > llvm::LLVMGetAlignment(gv) {\n+                    llvm::LLVMSetAlignment(gv, llalign);\n+                }\n+            }\n+            return gv;\n+        }\n+        let gv = self.static_addr_of_mut(cv, align, kind);\n+        unsafe {\n+            llvm::LLVMSetGlobalConstant(gv, True);\n+        }\n+        self.const_globals.borrow_mut().insert(cv, gv);\n+        gv\n+    }\n+\n+    fn get_static(&self, def_id: DefId) -> &'ll Value {\n+        let instance = Instance::mono(self.tcx, def_id);\n+        if let Some(&g) = self.instances.borrow().get(&instance) {\n+            return g;\n+        }\n+\n+        let defined_in_current_codegen_unit = self.codegen_unit\n+                                                .items()\n+                                                .contains_key(&MonoItem::Static(def_id));\n+        assert!(!defined_in_current_codegen_unit,\n+                \"consts::get_static() should always hit the cache for \\\n+                 statics defined in the same CGU, but did not for `{:?}`\",\n+                 def_id);\n+\n+        let ty = instance.ty(self.tcx);\n+        let sym = self.tcx.symbol_name(instance).as_str();\n+\n+        debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n+\n+        let g = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n+\n+            let llty = self.layout_of(ty).llvm_type(self);\n+            let (g, attrs) = match self.tcx.hir.get(id) {\n+                Node::Item(&hir::Item {\n+                    ref attrs, span, node: hir::ItemKind::Static(..), ..\n+                }) => {\n+                    if self.get_declared_value(&sym[..]).is_some() {\n+                        span_bug!(span, \"Conflicting symbol names for static?\");\n+                    }\n+\n+                    let g = self.define_global(&sym[..], llty).unwrap();\n+\n+                    if !self.tcx.is_reachable_non_generic(def_id) {\n+                        unsafe {\n+                            llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n+                        }\n+                    }\n+\n+                    (g, attrs)\n+                }\n+\n+                Node::ForeignItem(&hir::ForeignItem {\n+                    ref attrs, span, node: hir::ForeignItemKind::Static(..), ..\n+                }) => {\n+                    let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n+                    (check_and_apply_linkage(&self, &fn_attrs, ty, sym, Some(span)), attrs)\n+                }\n+\n+                item => bug!(\"get_static: expected static, found {:?}\", item)\n+            };\n+\n+            debug!(\"get_static: sym={} attrs={:?}\", sym, attrs);\n+\n+            for attr in attrs {\n+                if attr.check_name(\"thread_local\") {\n+                    llvm::set_thread_local_mode(g, self.tls_model);\n+                }\n+            }\n \n-        let instance = Instance::mono(cx.tcx, def_id);\n-        let ty = instance.ty(cx.tcx);\n-        let llty = cx.layout_of(ty).llvm_type(cx);\n-        let g = if val_llty == llty {\n             g\n         } else {\n-            // If we created the global with the wrong type,\n-            // correct the type.\n-            let empty_string = const_cstr!(\"\");\n-            let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(g));\n-            let name_string = CString::new(name_str_ref.to_bytes()).unwrap();\n-            llvm::LLVMSetValueName(g, empty_string.as_ptr());\n-\n-            let linkage = llvm::LLVMRustGetLinkage(g);\n-            let visibility = llvm::LLVMRustGetVisibility(g);\n-\n-            let new_g = llvm::LLVMRustGetOrInsertGlobal(\n-                cx.llmod, name_string.as_ptr(), val_llty);\n-\n-            llvm::LLVMRustSetLinkage(new_g, linkage);\n-            llvm::LLVMRustSetVisibility(new_g, visibility);\n-\n-            // To avoid breaking any invariants, we leave around the old\n-            // global for the moment; we'll replace all references to it\n-            // with the new global later. (See base::codegen_backend.)\n-            cx.statics_to_rauw.borrow_mut().push((g, new_g));\n-            new_g\n+            // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n+            debug!(\"get_static: sym={} item_attr={:?}\", sym, self.tcx.item_attrs(def_id));\n+\n+            let attrs = self.tcx.codegen_fn_attrs(def_id);\n+            let g = check_and_apply_linkage(&self, &attrs, ty, sym, None);\n+\n+            // Thread-local statics in some other crate need to *always* be linked\n+            // against in a thread-local fashion, so we need to be sure to apply the\n+            // thread-local attribute locally if it was present remotely. If we\n+            // don't do this then linker errors can be generated where the linker\n+            // complains that one object files has a thread local version of the\n+            // symbol and another one doesn't.\n+            if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n+                llvm::set_thread_local_mode(g, self.tls_model);\n+            }\n+\n+            let needs_dll_storage_attr =\n+                self.use_dll_storage_attrs && !self.tcx.is_foreign_item(def_id) &&\n+                // ThinLTO can't handle this workaround in all cases, so we don't\n+                // emit the attrs. Instead we make them unnecessary by disallowing\n+                // dynamic linking when cross-language LTO is enabled.\n+                !self.tcx.sess.opts.debugging_opts.cross_lang_lto.enabled();\n+\n+            // If this assertion triggers, there's something wrong with commandline\n+            // argument validation.\n+            debug_assert!(!(self.tcx.sess.opts.debugging_opts.cross_lang_lto.enabled() &&\n+                            self.tcx.sess.target.target.options.is_like_msvc &&\n+                            self.tcx.sess.opts.cg.prefer_dynamic));\n+\n+            if needs_dll_storage_attr {\n+                // This item is external but not foreign, i.e. it originates from an external Rust\n+                // crate. Since we don't know whether this crate will be linked dynamically or\n+                // statically in the final application, we always mark such symbols as 'dllimport'.\n+                // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n+                // to make things work.\n+                //\n+                // However, in some scenarios we defer emission of statics to downstream\n+                // crates, so there are cases where a static with an upstream DefId\n+                // is actually present in the current crate. We can find out via the\n+                // is_codegened_item query.\n+                if !self.tcx.is_codegened_item(def_id) {\n+                    unsafe {\n+                        llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+                    }\n+                }\n+            }\n+            g\n         };\n-        set_global_alignment(cx, g, cx.align_of(ty));\n-        llvm::LLVMSetInitializer(g, v);\n-\n-        // As an optimization, all shared statics which do not have interior\n-        // mutability are placed into read-only memory.\n-        if !is_mutable {\n-            if cx.type_is_freeze(ty) {\n-                llvm::LLVMSetGlobalConstant(g, llvm::True);\n+\n+        if self.use_dll_storage_attrs && self.tcx.is_dllimport_foreign_item(def_id) {\n+            // For foreign (native) libs we know the exact storage type to use.\n+            unsafe {\n+                llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n             }\n         }\n \n-        debuginfo::create_global_var_metadata(cx, def_id, g);\n-\n-        if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n-            llvm::set_thread_local_mode(g, cx.tls_model);\n-\n-            // Do not allow LLVM to change the alignment of a TLS on macOS.\n-            //\n-            // By default a global's alignment can be freely increased.\n-            // This allows LLVM to generate more performant instructions\n-            // e.g. using load-aligned into a SIMD register.\n-            //\n-            // However, on macOS 10.10 or below, the dynamic linker does not\n-            // respect any alignment given on the TLS (radar 24221680).\n-            // This will violate the alignment assumption, and causing segfault at runtime.\n-            //\n-            // This bug is very easy to trigger. In `println!` and `panic!`,\n-            // the `LOCAL_STDOUT`/`LOCAL_STDERR` handles are stored in a TLS,\n-            // which the values would be `mem::replace`d on initialization.\n-            // The implementation of `mem::replace` will use SIMD\n-            // whenever the size is 32 bytes or higher. LLVM notices SIMD is used\n-            // and tries to align `LOCAL_STDOUT`/`LOCAL_STDERR` to a 32-byte boundary,\n-            // which macOS's dyld disregarded and causing crashes\n-            // (see issues #51794, #51758, #50867, #48866 and #44056).\n-            //\n-            // To workaround the bug, we trick LLVM into not increasing\n-            // the global's alignment by explicitly assigning a section to it\n-            // (equivalent to automatically generating a `#[link_section]` attribute).\n-            // See the comment in the `GlobalValue::canIncreaseAlignment()` function\n-            // of `lib/IR/Globals.cpp` for why this works.\n-            //\n-            // When the alignment is not increased, the optimized `mem::replace`\n-            // will use load-unaligned instructions instead, and thus avoiding the crash.\n-            //\n-            // We could remove this hack whenever we decide to drop macOS 10.10 support.\n-            if cx.tcx.sess.target.target.options.is_like_osx {\n-                let sect_name = if alloc.bytes.iter().all(|b| *b == 0) {\n-                    CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_bss\\0\")\n-                } else {\n-                    CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_data\\0\")\n-                };\n-                llvm::LLVMSetSection(g, sect_name.as_ptr());\n+        self.instances.borrow_mut().insert(instance, g);\n+        g\n+    }\n+\n+    fn codegen_static(\n+        &self,\n+        def_id: DefId,\n+        is_mutable: bool,\n+    ) {\n+        unsafe {\n+            let attrs = self.tcx.codegen_fn_attrs(def_id);\n+\n+            let (v, alloc) = match codegen_static_initializer(&self, def_id) {\n+                Ok(v) => v,\n+                // Error has already been reported\n+                Err(_) => return,\n+            };\n+\n+            let g = self.get_static(def_id);\n+\n+            // boolean SSA values are i1, but they have to be stored in i8 slots,\n+            // otherwise some LLVM optimization passes don't work as expected\n+            let mut val_llty = self.val_ty(v);\n+            let v = if val_llty == self.type_i1() {\n+                val_llty = self.type_i8();\n+                llvm::LLVMConstZExt(v, val_llty)\n+            } else {\n+                v\n+            };\n+\n+            let instance = Instance::mono(self.tcx, def_id);\n+            let ty = instance.ty(self.tcx);\n+            let llty = self.layout_of(ty).llvm_type(self);\n+            let g = if val_llty == llty {\n+                g\n+            } else {\n+                // If we created the global with the wrong type,\n+                // correct the type.\n+                let empty_string = const_cstr!(\"\");\n+                let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(g));\n+                let name_string = CString::new(name_str_ref.to_bytes()).unwrap();\n+                llvm::LLVMSetValueName(g, empty_string.as_ptr());\n+\n+                let linkage = llvm::LLVMRustGetLinkage(g);\n+                let visibility = llvm::LLVMRustGetVisibility(g);\n+\n+                let new_g = llvm::LLVMRustGetOrInsertGlobal(\n+                    self.llmod, name_string.as_ptr(), val_llty);\n+\n+                llvm::LLVMRustSetLinkage(new_g, linkage);\n+                llvm::LLVMRustSetVisibility(new_g, visibility);\n+\n+                // To avoid breaking any invariants, we leave around the old\n+                // global for the moment; we'll replace all references to it\n+                // with the new global later. (See base::codegen_backend.)\n+                self.statics_to_rauw.borrow_mut().push((g, new_g));\n+                new_g\n+            };\n+            set_global_alignment(&self, g, self.align_of(ty));\n+            llvm::LLVMSetInitializer(g, v);\n+\n+            // As an optimization, all shared statics which do not have interior\n+            // mutability are placed into read-only memory.\n+            if !is_mutable {\n+                if self.type_is_freeze(ty) {\n+                    llvm::LLVMSetGlobalConstant(g, llvm::True);\n+                }\n+            }\n+\n+            debuginfo::create_global_var_metadata(&self, def_id, g);\n+\n+            if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n+                llvm::set_thread_local_mode(g, self.tls_model);\n+\n+                // Do not allow LLVM to change the alignment of a TLS on macOS.\n+                //\n+                // By default a global's alignment can be freely increased.\n+                // This allows LLVM to generate more performant instructions\n+                // e.g. using load-aligned into a SIMD register.\n+                //\n+                // However, on macOS 10.10 or below, the dynamic linker does not\n+                // respect any alignment given on the TLS (radar 24221680).\n+                // This will violate the alignment assumption, and causing segfault at runtime.\n+                //\n+                // This bug is very easy to trigger. In `println!` and `panic!`,\n+                // the `LOCAL_STDOUT`/`LOCAL_STDERR` handles are stored in a TLS,\n+                // which the values would be `mem::replace`d on initialization.\n+                // The implementation of `mem::replace` will use SIMD\n+                // whenever the size is 32 bytes or higher. LLVM notices SIMD is used\n+                // and tries to align `LOCAL_STDOUT`/`LOCAL_STDERR` to a 32-byte boundary,\n+                // which macOS's dyld disregarded and causing crashes\n+                // (see issues #51794, #51758, #50867, #48866 and #44056).\n+                //\n+                // To workaround the bug, we trick LLVM into not increasing\n+                // the global's alignment by explicitly assigning a section to it\n+                // (equivalent to automatically generating a `#[link_section]` attribute).\n+                // See the comment in the `GlobalValue::canIncreaseAlignment()` function\n+                // of `lib/IR/Globals.cpp` for why this works.\n+                //\n+                // When the alignment is not increased, the optimized `mem::replace`\n+                // will use load-unaligned instructions instead, and thus avoiding the crash.\n+                //\n+                // We could remove this hack whenever we decide to drop macOS 10.10 support.\n+                if self.tcx.sess.target.target.options.is_like_osx {\n+                    let sect_name = if alloc.bytes.iter().all(|b| *b == 0) {\n+                        CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_bss\\0\")\n+                    } else {\n+                        CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_data\\0\")\n+                    };\n+                    llvm::LLVMSetSection(g, sect_name.as_ptr());\n+                }\n             }\n-        }\n \n \n-        // Wasm statics with custom link sections get special treatment as they\n-        // go into custom sections of the wasm executable.\n-        if cx.tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n-            if let Some(section) = attrs.link_section {\n-                let section = llvm::LLVMMDStringInContext(\n-                    cx.llcx,\n-                    section.as_str().as_ptr() as *const _,\n-                    section.as_str().len() as c_uint,\n-                );\n-                let alloc = llvm::LLVMMDStringInContext(\n-                    cx.llcx,\n-                    alloc.bytes.as_ptr() as *const _,\n-                    alloc.bytes.len() as c_uint,\n-                );\n-                let data = [section, alloc];\n-                let meta = llvm::LLVMMDNodeInContext(cx.llcx, data.as_ptr(), 2);\n-                llvm::LLVMAddNamedMetadataOperand(\n-                    cx.llmod,\n-                    \"wasm.custom_sections\\0\".as_ptr() as *const _,\n-                    meta,\n-                );\n+            // Wasm statics with custom link sections get special treatment as they\n+            // go into custom sections of the wasm executable.\n+            if self.tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n+                if let Some(section) = attrs.link_section {\n+                    let section = llvm::LLVMMDStringInContext(\n+                        self.llcx,\n+                        section.as_str().as_ptr() as *const _,\n+                        section.as_str().len() as c_uint,\n+                    );\n+                    let alloc = llvm::LLVMMDStringInContext(\n+                        self.llcx,\n+                        alloc.bytes.as_ptr() as *const _,\n+                        alloc.bytes.len() as c_uint,\n+                    );\n+                    let data = [section, alloc];\n+                    let meta = llvm::LLVMMDNodeInContext(self.llcx, data.as_ptr(), 2);\n+                    llvm::LLVMAddNamedMetadataOperand(\n+                        self.llmod,\n+                        \"wasm.custom_sections\\0\".as_ptr() as *const _,\n+                        meta,\n+                    );\n+                }\n+            } else {\n+                base::set_link_section(g, &attrs);\n             }\n-        } else {\n-            base::set_link_section(g, &attrs);\n-        }\n \n-        if attrs.flags.contains(CodegenFnAttrFlags::USED) {\n-            // This static will be stored in the llvm.used variable which is an array of i8*\n-            let cast = llvm::LLVMConstPointerCast(g, Type::i8p(cx));\n-            cx.used_statics.borrow_mut().push(cast);\n+            if attrs.flags.contains(CodegenFnAttrFlags::USED) {\n+                // This static will be stored in the llvm.used variable which is an array of i8*\n+                let cast = llvm::LLVMConstPointerCast(g, self.type_i8p());\n+                self.used_statics.borrow_mut().push(cast);\n+            }\n         }\n     }\n+    unsafe fn static_replace_all_uses(&self, old_g: &'ll Value, new_g: &'ll Value) {\n+        let bitcast = llvm::LLVMConstPointerCast(new_g, self.val_ty(old_g));\n+        llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n+        llvm::LLVMDeleteGlobal(old_g);\n+    }\n }"}, {"sha": "5b088ad290810c02f4bbb617737925020a884e39", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 435, "deletions": 384, "changes": 819, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -9,20 +9,19 @@\n // except according to those terms.\n \n use attributes;\n-use common;\n use llvm;\n+use llvm_util;\n use rustc::dep_graph::DepGraphSafe;\n use rustc::hir;\n use debuginfo;\n-use callee;\n-use base;\n-use declare;\n use monomorphize::Instance;\n use value::Value;\n \n use monomorphize::partitioning::CodegenUnit;\n use type_::Type;\n use type_of::PointeeInfo;\n+use rustc_codegen_ssa::traits::*;\n+use libc::c_uint;\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::small_c_str::SmallCStr;\n@@ -33,6 +32,9 @@ use rustc::ty::layout::{LayoutError, LayoutOf, Size, TyLayout, VariantIdx};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n use rustc_target::spec::{HasTargetSpec, Target};\n+use rustc_codegen_ssa::callee::resolve_and_get_fn;\n+use rustc_codegen_ssa::base::wants_msvc_seh;\n+use callee::get_fn;\n \n use std::ffi::CStr;\n use std::cell::{Cell, RefCell};\n@@ -45,24 +47,23 @@ use abi::Abi;\n /// There is one `CodegenCx` per compilation unit. Each one has its own LLVM\n /// `llvm::Context` so that several compilation units may be optimized in parallel.\n /// All other LLVM data structures in the `CodegenCx` are tied to that `llvm::Context`.\n-pub struct CodegenCx<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct CodegenCx<'ll, 'tcx: 'll> {\n+    pub tcx: TyCtxt<'ll, 'tcx, 'tcx>,\n     pub check_overflow: bool,\n     pub use_dll_storage_attrs: bool,\n     pub tls_model: llvm::ThreadLocalMode,\n \n-    pub llmod: &'a llvm::Module,\n-    pub llcx: &'a llvm::Context,\n+    pub llmod: &'ll llvm::Module,\n+    pub llcx: &'ll llvm::Context,\n     pub stats: RefCell<Stats>,\n     pub codegen_unit: Arc<CodegenUnit<'tcx>>,\n \n     /// Cache instances of monomorphic and polymorphic items\n-    pub instances: RefCell<FxHashMap<Instance<'tcx>, &'a Value>>,\n+    pub instances: RefCell<FxHashMap<Instance<'tcx>, &'ll Value>>,\n     /// Cache generated vtables\n-    pub vtables: RefCell<FxHashMap<(Ty<'tcx>, ty::PolyExistentialTraitRef<'tcx>),\n-                                   &'a Value>>,\n+    pub vtables: RefCell<FxHashMap<(Ty<'tcx>, ty::PolyExistentialTraitRef<'tcx>), &'ll Value>>,\n     /// Cache of constant strings,\n-    pub const_cstr_cache: RefCell<FxHashMap<LocalInternedString, &'a Value>>,\n+    pub const_cstr_cache: RefCell<FxHashMap<LocalInternedString, &'ll Value>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n     /// Key is a Value holding a *T,\n@@ -72,40 +73,39 @@ pub struct CodegenCx<'a, 'tcx: 'a> {\n     /// when we ptrcast, and we have to ptrcast during codegen\n     /// of a [T] const because we form a slice, a (*T,usize) pair, not\n     /// a pointer to an LLVM array type. Similar for trait objects.\n-    pub const_unsized: RefCell<FxHashMap<&'a Value, &'a Value>>,\n+    pub const_unsized: RefCell<FxHashMap<&'ll Value, &'ll Value>>,\n \n     /// Cache of emitted const globals (value -> global)\n-    pub const_globals: RefCell<FxHashMap<&'a Value, &'a Value>>,\n+    pub const_globals: RefCell<FxHashMap<&'ll Value, &'ll Value>>,\n \n     /// List of globals for static variables which need to be passed to the\n     /// LLVM function ReplaceAllUsesWith (RAUW) when codegen is complete.\n     /// (We have to make sure we don't invalidate any Values referring\n     /// to constants.)\n-    pub statics_to_rauw: RefCell<Vec<(&'a Value, &'a Value)>>,\n+    pub statics_to_rauw: RefCell<Vec<(&'ll Value, &'ll Value)>>,\n \n     /// Statics that will be placed in the llvm.used variable\n     /// See http://llvm.org/docs/LangRef.html#the-llvm-used-global-variable for details\n-    pub used_statics: RefCell<Vec<&'a Value>>,\n+    pub used_statics: RefCell<Vec<&'ll Value>>,\n \n-    pub lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<VariantIdx>), &'a Type>>,\n-    pub scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, &'a Type>>,\n+    pub lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<VariantIdx>), &'ll Type>>,\n+    pub scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, &'ll Type>>,\n     pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n-    pub isize_ty: &'a Type,\n+    pub isize_ty: &'ll Type,\n \n-    pub dbg_cx: Option<debuginfo::CrateDebugContext<'a, 'tcx>>,\n+    pub dbg_cx: Option<debuginfo::CrateDebugContext<'ll, 'tcx>>,\n \n-    eh_personality: Cell<Option<&'a Value>>,\n-    eh_unwind_resume: Cell<Option<&'a Value>>,\n-    pub rust_try_fn: Cell<Option<&'a Value>>,\n+    eh_personality: Cell<Option<&'ll Value>>,\n+    eh_unwind_resume: Cell<Option<&'ll Value>>,\n+    pub rust_try_fn: Cell<Option<&'ll Value>>,\n \n-    intrinsics: RefCell<FxHashMap<&'static str, &'a Value>>,\n+    intrinsics: RefCell<FxHashMap<&'static str, &'ll Value>>,\n \n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n }\n \n-impl<'a, 'tcx> DepGraphSafe for CodegenCx<'a, 'tcx> {\n-}\n+impl<'ll, 'tcx> DepGraphSafe for CodegenCx<'ll, 'tcx> {}\n \n pub fn get_reloc_model(sess: &Session) -> llvm::RelocMode {\n     let reloc_model_arg = match sess.opts.cg.relocation_model {\n@@ -218,11 +218,11 @@ pub unsafe fn create_module(\n     llmod\n }\n \n-impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n-    crate fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n+    crate fn new(tcx: TyCtxt<'ll, 'tcx, 'tcx>,\n                  codegen_unit: Arc<CodegenUnit<'tcx>>,\n-                 llvm_module: &'a ::ModuleLlvm)\n-                 -> CodegenCx<'a, 'tcx> {\n+                 llvm_module: &'ll ::ModuleLlvm)\n+                 -> Self {\n         // An interesting part of Windows which MSVC forces our hand on (and\n         // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n         // attributes in LLVM IR as well as native dependencies (in C these\n@@ -316,34 +316,26 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n     }\n }\n \n-impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n-    pub fn sess<'a>(&'a self) -> &'a Session {\n-        &self.tcx.sess\n+impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn vtables(&self) -> &RefCell<FxHashMap<(Ty<'tcx>,\n+                                ty::PolyExistentialTraitRef<'tcx>), &'ll Value>>\n+    {\n+        &self.vtables\n     }\n \n-    pub fn get_intrinsic(&self, key: &str) -> &'b Value {\n-        if let Some(v) = self.intrinsics.borrow().get(key).cloned() {\n-            return v;\n-        }\n+    fn instances(&self) -> &RefCell<FxHashMap<Instance<'tcx>, &'ll Value>> {\n+        &self.instances\n+    }\n \n-        declare_intrinsic(self, key).unwrap_or_else(|| bug!(\"unknown intrinsic '{}'\", key))\n+    fn get_fn(&self, instance: Instance<'tcx>) -> &'ll Value {\n+        get_fn(&&self,instance)\n     }\n \n-    /// Generate a new symbol name with the given prefix. This symbol name must\n-    /// only be used for definitions with `internal` or `private` linkage.\n-    pub fn generate_local_symbol_name(&self, prefix: &str) -> String {\n-        let idx = self.local_gen_sym_counter.get();\n-        self.local_gen_sym_counter.set(idx + 1);\n-        // Include a '.' character, so there can be no accidental conflicts with\n-        // user defined names\n-        let mut name = String::with_capacity(prefix.len() + 6);\n-        name.push_str(prefix);\n-        name.push_str(\".\");\n-        base_n::push_str(idx as u128, base_n::ALPHANUMERIC_ONLY, &mut name);\n-        name\n+    fn get_param(&self, llfn: &'ll Value, index: c_uint) -> &'ll Value {\n+        llvm::get_param(llfn, index)\n     }\n \n-    pub fn eh_personality(&self) -> &'b Value {\n+    fn eh_personality(&self) -> &'ll Value {\n         // The exception handling personality function.\n         //\n         // If our compilation unit has the `eh_personality` lang item somewhere\n@@ -369,17 +361,17 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n         }\n         let tcx = self.tcx;\n         let llfn = match tcx.lang_items().eh_personality() {\n-            Some(def_id) if !base::wants_msvc_seh(self.sess()) => {\n-                callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]))\n+            Some(def_id) if !wants_msvc_seh(self.sess()) => {\n+                resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]))\n             }\n             _ => {\n-                let name = if base::wants_msvc_seh(self.sess()) {\n+                let name = if wants_msvc_seh(self.sess()) {\n                     \"__CxxFrameHandler3\"\n                 } else {\n                     \"rust_eh_personality\"\n                 };\n-                let fty = Type::variadic_func(&[], Type::i32(self));\n-                declare::declare_cfn(self, name, fty)\n+                let fty = self.type_variadic_func(&[], self.type_i32());\n+                self.declare_cfn(name, fty)\n             }\n         };\n         attributes::apply_target_cpu_attr(self, llfn);\n@@ -389,7 +381,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n \n     // Returns a Value of the \"eh_unwind_resume\" lang item if one is defined,\n     // otherwise declares it as an external function.\n-    pub fn eh_unwind_resume(&self) -> &'b Value {\n+    fn eh_unwind_resume(&self) -> &'ll Value {\n         use attributes;\n         let unwresume = &self.eh_unwind_resume;\n         if let Some(llfn) = unwresume.get() {\n@@ -399,7 +391,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n         let tcx = self.tcx;\n         assert!(self.sess().target.target.options.custom_unwind_resume);\n         if let Some(def_id) = tcx.lang_items().eh_unwind_resume() {\n-            let llfn = callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]));\n+            let llfn = resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]));\n             unwresume.set(Some(llfn));\n             return llfn;\n         }\n@@ -412,37 +404,406 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n             Abi::C\n         ));\n \n-        let llfn = declare::declare_fn(self, \"rust_eh_unwind_resume\", sig);\n+        let llfn = self.declare_fn(\"rust_eh_unwind_resume\", sig);\n         attributes::unwind(llfn, true);\n         attributes::apply_target_cpu_attr(self, llfn);\n         unwresume.set(Some(llfn));\n         llfn\n     }\n \n-    pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        common::type_needs_drop(self.tcx, ty)\n+    fn sess(&self) -> &Session {\n+        &self.tcx.sess\n+    }\n+\n+    fn check_overflow(&self) -> bool {\n+        self.check_overflow\n+    }\n+\n+    fn stats(&self) -> &RefCell<Stats> {\n+        &self.stats\n+    }\n+\n+    fn consume_stats(self) -> RefCell<Stats> {\n+        self.stats\n     }\n \n-    pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        common::type_is_sized(self.tcx, ty)\n+    fn codegen_unit(&self) -> &Arc<CodegenUnit<'tcx>> {\n+        &self.codegen_unit\n     }\n \n-    pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        common::type_is_freeze(self.tcx, ty)\n+    fn statics_to_rauw(&self) -> &RefCell<Vec<(&'ll Value, &'ll Value)>> {\n+        &self.statics_to_rauw\n     }\n \n-    pub fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n-        use syntax_pos::DUMMY_SP;\n-        if ty.is_sized(self.tcx.at(DUMMY_SP), ty::ParamEnv::reveal_all()) {\n-            return false;\n+    fn used_statics(&self) -> &RefCell<Vec<&'ll Value>> {\n+        &self.used_statics\n+    }\n+\n+    fn set_frame_pointer_elimination(&self, llfn: &'ll Value) {\n+        attributes::set_frame_pointer_elimination(self, llfn)\n+    }\n+\n+    fn apply_target_cpu_attr(&self, llfn: &'ll Value) {\n+        attributes::apply_target_cpu_attr(self, llfn)\n+    }\n+\n+    fn closure_env_needs_indirect_debuginfo(&self) -> bool {\n+        llvm_util::get_major_version() < 6\n+    }\n+\n+    fn create_used_variable(&self) {\n+        let name = const_cstr!(\"llvm.used\");\n+        let section = const_cstr!(\"llvm.metadata\");\n+        let array = self.const_array(\n+            &self.type_ptr_to(self.type_i8()),\n+            &*self.used_statics.borrow()\n+        );\n+\n+        unsafe {\n+            let g = llvm::LLVMAddGlobal(self.llmod,\n+                                        self.val_ty(array),\n+                                        name.as_ptr());\n+            llvm::LLVMSetInitializer(g, array);\n+            llvm::LLVMRustSetLinkage(g, llvm::Linkage::AppendingLinkage);\n+            llvm::LLVMSetSection(g, section.as_ptr());\n         }\n+    }\n+}\n+\n+impl IntrinsicDeclarationMethods<'tcx> for CodegenCx<'b, 'tcx> {\n+    fn get_intrinsic(&self, key: &str) -> &'b Value {\n+        if let Some(v) = self.intrinsics.borrow().get(key).cloned() {\n+            return v;\n+        }\n+\n+        self.declare_intrinsic(key).unwrap_or_else(|| bug!(\"unknown intrinsic '{}'\", key))\n+    }\n+\n+    fn declare_intrinsic(\n+        &self,\n+        key: &str\n+    ) -> Option<&'b Value> {\n+        macro_rules! ifn {\n+            ($name:expr, fn() -> $ret:expr) => (\n+                if key == $name {\n+                    let f = self.declare_cfn($name, self.type_func(&[], $ret));\n+                    llvm::SetUnnamedAddr(f, false);\n+                    self.intrinsics.borrow_mut().insert($name, f.clone());\n+                    return Some(f);\n+                }\n+            );\n+            ($name:expr, fn(...) -> $ret:expr) => (\n+                if key == $name {\n+                    let f = self.declare_cfn($name, self.type_variadic_func(&[], $ret));\n+                    llvm::SetUnnamedAddr(f, false);\n+                    self.intrinsics.borrow_mut().insert($name, f.clone());\n+                    return Some(f);\n+                }\n+            );\n+            ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n+                if key == $name {\n+                    let f = self.declare_cfn($name, self.type_func(&[$($arg),*], $ret));\n+                    llvm::SetUnnamedAddr(f, false);\n+                    self.intrinsics.borrow_mut().insert($name, f.clone());\n+                    return Some(f);\n+                }\n+            );\n+        }\n+        macro_rules! mk_struct {\n+            ($($field_ty:expr),*) => (self.type_struct( &[$($field_ty),*], false))\n+        }\n+\n+        let i8p = self.type_i8p();\n+        let void = self.type_void();\n+        let i1 = self.type_i1();\n+        let t_i8 = self.type_i8();\n+        let t_i16 = self.type_i16();\n+        let t_i32 = self.type_i32();\n+        let t_i64 = self.type_i64();\n+        let t_i128 = self.type_i128();\n+        let t_f32 = self.type_f32();\n+        let t_f64 = self.type_f64();\n+\n+        let t_v2f32 = self.type_vector(t_f32, 2);\n+        let t_v4f32 = self.type_vector(t_f32, 4);\n+        let t_v8f32 = self.type_vector(t_f32, 8);\n+        let t_v16f32 = self.type_vector(t_f32, 16);\n+\n+        let t_v2f64 = self.type_vector(t_f64, 2);\n+        let t_v4f64 = self.type_vector(t_f64, 4);\n+        let t_v8f64 = self.type_vector(t_f64, 8);\n+\n+        ifn!(\"llvm.memset.p0i8.i16\", fn(i8p, t_i8, t_i16, t_i32, i1) -> void);\n+        ifn!(\"llvm.memset.p0i8.i32\", fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n+        ifn!(\"llvm.memset.p0i8.i64\", fn(i8p, t_i8, t_i64, t_i32, i1) -> void);\n+\n+        ifn!(\"llvm.trap\", fn() -> void);\n+        ifn!(\"llvm.debugtrap\", fn() -> void);\n+        ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);\n+\n+        ifn!(\"llvm.powi.f32\", fn(t_f32, t_i32) -> t_f32);\n+        ifn!(\"llvm.powi.v2f32\", fn(t_v2f32, t_i32) -> t_v2f32);\n+        ifn!(\"llvm.powi.v4f32\", fn(t_v4f32, t_i32) -> t_v4f32);\n+        ifn!(\"llvm.powi.v8f32\", fn(t_v8f32, t_i32) -> t_v8f32);\n+        ifn!(\"llvm.powi.v16f32\", fn(t_v16f32, t_i32) -> t_v16f32);\n+        ifn!(\"llvm.powi.f64\", fn(t_f64, t_i32) -> t_f64);\n+        ifn!(\"llvm.powi.v2f64\", fn(t_v2f64, t_i32) -> t_v2f64);\n+        ifn!(\"llvm.powi.v4f64\", fn(t_v4f64, t_i32) -> t_v4f64);\n+        ifn!(\"llvm.powi.v8f64\", fn(t_v8f64, t_i32) -> t_v8f64);\n+\n+        ifn!(\"llvm.pow.f32\", fn(t_f32, t_f32) -> t_f32);\n+        ifn!(\"llvm.pow.v2f32\", fn(t_v2f32, t_v2f32) -> t_v2f32);\n+        ifn!(\"llvm.pow.v4f32\", fn(t_v4f32, t_v4f32) -> t_v4f32);\n+        ifn!(\"llvm.pow.v8f32\", fn(t_v8f32, t_v8f32) -> t_v8f32);\n+        ifn!(\"llvm.pow.v16f32\", fn(t_v16f32, t_v16f32) -> t_v16f32);\n+        ifn!(\"llvm.pow.f64\", fn(t_f64, t_f64) -> t_f64);\n+        ifn!(\"llvm.pow.v2f64\", fn(t_v2f64, t_v2f64) -> t_v2f64);\n+        ifn!(\"llvm.pow.v4f64\", fn(t_v4f64, t_v4f64) -> t_v4f64);\n+        ifn!(\"llvm.pow.v8f64\", fn(t_v8f64, t_v8f64) -> t_v8f64);\n+\n+        ifn!(\"llvm.sqrt.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.sqrt.v2f32\", fn(t_v2f32) -> t_v2f32);\n+        ifn!(\"llvm.sqrt.v4f32\", fn(t_v4f32) -> t_v4f32);\n+        ifn!(\"llvm.sqrt.v8f32\", fn(t_v8f32) -> t_v8f32);\n+        ifn!(\"llvm.sqrt.v16f32\", fn(t_v16f32) -> t_v16f32);\n+        ifn!(\"llvm.sqrt.f64\", fn(t_f64) -> t_f64);\n+        ifn!(\"llvm.sqrt.v2f64\", fn(t_v2f64) -> t_v2f64);\n+        ifn!(\"llvm.sqrt.v4f64\", fn(t_v4f64) -> t_v4f64);\n+        ifn!(\"llvm.sqrt.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n+        ifn!(\"llvm.sin.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.sin.v2f32\", fn(t_v2f32) -> t_v2f32);\n+        ifn!(\"llvm.sin.v4f32\", fn(t_v4f32) -> t_v4f32);\n+        ifn!(\"llvm.sin.v8f32\", fn(t_v8f32) -> t_v8f32);\n+        ifn!(\"llvm.sin.v16f32\", fn(t_v16f32) -> t_v16f32);\n+        ifn!(\"llvm.sin.f64\", fn(t_f64) -> t_f64);\n+        ifn!(\"llvm.sin.v2f64\", fn(t_v2f64) -> t_v2f64);\n+        ifn!(\"llvm.sin.v4f64\", fn(t_v4f64) -> t_v4f64);\n+        ifn!(\"llvm.sin.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n+        ifn!(\"llvm.cos.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.cos.v2f32\", fn(t_v2f32) -> t_v2f32);\n+        ifn!(\"llvm.cos.v4f32\", fn(t_v4f32) -> t_v4f32);\n+        ifn!(\"llvm.cos.v8f32\", fn(t_v8f32) -> t_v8f32);\n+        ifn!(\"llvm.cos.v16f32\", fn(t_v16f32) -> t_v16f32);\n+        ifn!(\"llvm.cos.f64\", fn(t_f64) -> t_f64);\n+        ifn!(\"llvm.cos.v2f64\", fn(t_v2f64) -> t_v2f64);\n+        ifn!(\"llvm.cos.v4f64\", fn(t_v4f64) -> t_v4f64);\n+        ifn!(\"llvm.cos.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n+        ifn!(\"llvm.exp.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.exp.v2f32\", fn(t_v2f32) -> t_v2f32);\n+        ifn!(\"llvm.exp.v4f32\", fn(t_v4f32) -> t_v4f32);\n+        ifn!(\"llvm.exp.v8f32\", fn(t_v8f32) -> t_v8f32);\n+        ifn!(\"llvm.exp.v16f32\", fn(t_v16f32) -> t_v16f32);\n+        ifn!(\"llvm.exp.f64\", fn(t_f64) -> t_f64);\n+        ifn!(\"llvm.exp.v2f64\", fn(t_v2f64) -> t_v2f64);\n+        ifn!(\"llvm.exp.v4f64\", fn(t_v4f64) -> t_v4f64);\n+        ifn!(\"llvm.exp.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n+        ifn!(\"llvm.exp2.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.exp2.v2f32\", fn(t_v2f32) -> t_v2f32);\n+        ifn!(\"llvm.exp2.v4f32\", fn(t_v4f32) -> t_v4f32);\n+        ifn!(\"llvm.exp2.v8f32\", fn(t_v8f32) -> t_v8f32);\n+        ifn!(\"llvm.exp2.v16f32\", fn(t_v16f32) -> t_v16f32);\n+        ifn!(\"llvm.exp2.f64\", fn(t_f64) -> t_f64);\n+        ifn!(\"llvm.exp2.v2f64\", fn(t_v2f64) -> t_v2f64);\n+        ifn!(\"llvm.exp2.v4f64\", fn(t_v4f64) -> t_v4f64);\n+        ifn!(\"llvm.exp2.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n+        ifn!(\"llvm.log.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.log.v2f32\", fn(t_v2f32) -> t_v2f32);\n+        ifn!(\"llvm.log.v4f32\", fn(t_v4f32) -> t_v4f32);\n+        ifn!(\"llvm.log.v8f32\", fn(t_v8f32) -> t_v8f32);\n+        ifn!(\"llvm.log.v16f32\", fn(t_v16f32) -> t_v16f32);\n+        ifn!(\"llvm.log.f64\", fn(t_f64) -> t_f64);\n+        ifn!(\"llvm.log.v2f64\", fn(t_v2f64) -> t_v2f64);\n+        ifn!(\"llvm.log.v4f64\", fn(t_v4f64) -> t_v4f64);\n+        ifn!(\"llvm.log.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n+        ifn!(\"llvm.log10.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.log10.v2f32\", fn(t_v2f32) -> t_v2f32);\n+        ifn!(\"llvm.log10.v4f32\", fn(t_v4f32) -> t_v4f32);\n+        ifn!(\"llvm.log10.v8f32\", fn(t_v8f32) -> t_v8f32);\n+        ifn!(\"llvm.log10.v16f32\", fn(t_v16f32) -> t_v16f32);\n+        ifn!(\"llvm.log10.f64\", fn(t_f64) -> t_f64);\n+        ifn!(\"llvm.log10.v2f64\", fn(t_v2f64) -> t_v2f64);\n+        ifn!(\"llvm.log10.v4f64\", fn(t_v4f64) -> t_v4f64);\n+        ifn!(\"llvm.log10.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n+        ifn!(\"llvm.log2.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.log2.v2f32\", fn(t_v2f32) -> t_v2f32);\n+        ifn!(\"llvm.log2.v4f32\", fn(t_v4f32) -> t_v4f32);\n+        ifn!(\"llvm.log2.v8f32\", fn(t_v8f32) -> t_v8f32);\n+        ifn!(\"llvm.log2.v16f32\", fn(t_v16f32) -> t_v16f32);\n+        ifn!(\"llvm.log2.f64\", fn(t_f64) -> t_f64);\n+        ifn!(\"llvm.log2.v2f64\", fn(t_v2f64) -> t_v2f64);\n+        ifn!(\"llvm.log2.v4f64\", fn(t_v4f64) -> t_v4f64);\n+        ifn!(\"llvm.log2.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n+        ifn!(\"llvm.fma.f32\", fn(t_f32, t_f32, t_f32) -> t_f32);\n+        ifn!(\"llvm.fma.v2f32\", fn(t_v2f32, t_v2f32, t_v2f32) -> t_v2f32);\n+        ifn!(\"llvm.fma.v4f32\", fn(t_v4f32, t_v4f32, t_v4f32) -> t_v4f32);\n+        ifn!(\"llvm.fma.v8f32\", fn(t_v8f32, t_v8f32, t_v8f32) -> t_v8f32);\n+        ifn!(\"llvm.fma.v16f32\", fn(t_v16f32, t_v16f32, t_v16f32) -> t_v16f32);\n+        ifn!(\"llvm.fma.f64\", fn(t_f64, t_f64, t_f64) -> t_f64);\n+        ifn!(\"llvm.fma.v2f64\", fn(t_v2f64, t_v2f64, t_v2f64) -> t_v2f64);\n+        ifn!(\"llvm.fma.v4f64\", fn(t_v4f64, t_v4f64, t_v4f64) -> t_v4f64);\n+        ifn!(\"llvm.fma.v8f64\", fn(t_v8f64, t_v8f64, t_v8f64) -> t_v8f64);\n+\n+        ifn!(\"llvm.fabs.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.fabs.v2f32\", fn(t_v2f32) -> t_v2f32);\n+        ifn!(\"llvm.fabs.v4f32\", fn(t_v4f32) -> t_v4f32);\n+        ifn!(\"llvm.fabs.v8f32\", fn(t_v8f32) -> t_v8f32);\n+        ifn!(\"llvm.fabs.v16f32\", fn(t_v16f32) -> t_v16f32);\n+        ifn!(\"llvm.fabs.f64\", fn(t_f64) -> t_f64);\n+        ifn!(\"llvm.fabs.v2f64\", fn(t_v2f64) -> t_v2f64);\n+        ifn!(\"llvm.fabs.v4f64\", fn(t_v4f64) -> t_v4f64);\n+        ifn!(\"llvm.fabs.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n+        ifn!(\"llvm.floor.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.floor.v2f32\", fn(t_v2f32) -> t_v2f32);\n+        ifn!(\"llvm.floor.v4f32\", fn(t_v4f32) -> t_v4f32);\n+        ifn!(\"llvm.floor.v8f32\", fn(t_v8f32) -> t_v8f32);\n+        ifn!(\"llvm.floor.v16f32\", fn(t_v16f32) -> t_v16f32);\n+        ifn!(\"llvm.floor.f64\", fn(t_f64) -> t_f64);\n+        ifn!(\"llvm.floor.v2f64\", fn(t_v2f64) -> t_v2f64);\n+        ifn!(\"llvm.floor.v4f64\", fn(t_v4f64) -> t_v4f64);\n+        ifn!(\"llvm.floor.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n+        ifn!(\"llvm.ceil.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.ceil.v2f32\", fn(t_v2f32) -> t_v2f32);\n+        ifn!(\"llvm.ceil.v4f32\", fn(t_v4f32) -> t_v4f32);\n+        ifn!(\"llvm.ceil.v8f32\", fn(t_v8f32) -> t_v8f32);\n+        ifn!(\"llvm.ceil.v16f32\", fn(t_v16f32) -> t_v16f32);\n+        ifn!(\"llvm.ceil.f64\", fn(t_f64) -> t_f64);\n+        ifn!(\"llvm.ceil.v2f64\", fn(t_v2f64) -> t_v2f64);\n+        ifn!(\"llvm.ceil.v4f64\", fn(t_v4f64) -> t_v4f64);\n+        ifn!(\"llvm.ceil.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n+        ifn!(\"llvm.trunc.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.trunc.f64\", fn(t_f64) -> t_f64);\n+\n+        ifn!(\"llvm.copysign.f32\", fn(t_f32, t_f32) -> t_f32);\n+        ifn!(\"llvm.copysign.f64\", fn(t_f64, t_f64) -> t_f64);\n+        ifn!(\"llvm.round.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.round.f64\", fn(t_f64) -> t_f64);\n+\n+        ifn!(\"llvm.rint.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.rint.f64\", fn(t_f64) -> t_f64);\n+        ifn!(\"llvm.nearbyint.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.nearbyint.f64\", fn(t_f64) -> t_f64);\n+\n+        ifn!(\"llvm.ctpop.i8\", fn(t_i8) -> t_i8);\n+        ifn!(\"llvm.ctpop.i16\", fn(t_i16) -> t_i16);\n+        ifn!(\"llvm.ctpop.i32\", fn(t_i32) -> t_i32);\n+        ifn!(\"llvm.ctpop.i64\", fn(t_i64) -> t_i64);\n+        ifn!(\"llvm.ctpop.i128\", fn(t_i128) -> t_i128);\n+\n+        ifn!(\"llvm.ctlz.i8\", fn(t_i8 , i1) -> t_i8);\n+        ifn!(\"llvm.ctlz.i16\", fn(t_i16, i1) -> t_i16);\n+        ifn!(\"llvm.ctlz.i32\", fn(t_i32, i1) -> t_i32);\n+        ifn!(\"llvm.ctlz.i64\", fn(t_i64, i1) -> t_i64);\n+        ifn!(\"llvm.ctlz.i128\", fn(t_i128, i1) -> t_i128);\n+\n+        ifn!(\"llvm.cttz.i8\", fn(t_i8 , i1) -> t_i8);\n+        ifn!(\"llvm.cttz.i16\", fn(t_i16, i1) -> t_i16);\n+        ifn!(\"llvm.cttz.i32\", fn(t_i32, i1) -> t_i32);\n+        ifn!(\"llvm.cttz.i64\", fn(t_i64, i1) -> t_i64);\n+        ifn!(\"llvm.cttz.i128\", fn(t_i128, i1) -> t_i128);\n+\n+        ifn!(\"llvm.bswap.i16\", fn(t_i16) -> t_i16);\n+        ifn!(\"llvm.bswap.i32\", fn(t_i32) -> t_i32);\n+        ifn!(\"llvm.bswap.i64\", fn(t_i64) -> t_i64);\n+        ifn!(\"llvm.bswap.i128\", fn(t_i128) -> t_i128);\n+\n+        ifn!(\"llvm.bitreverse.i8\", fn(t_i8) -> t_i8);\n+        ifn!(\"llvm.bitreverse.i16\", fn(t_i16) -> t_i16);\n+        ifn!(\"llvm.bitreverse.i32\", fn(t_i32) -> t_i32);\n+        ifn!(\"llvm.bitreverse.i64\", fn(t_i64) -> t_i64);\n+        ifn!(\"llvm.bitreverse.i128\", fn(t_i128) -> t_i128);\n+\n+    ifn!(\"llvm.fshl.i8\", fn(t_i8, t_i8, t_i8) -> t_i8);\n+    ifn!(\"llvm.fshl.i16\", fn(t_i16, t_i16, t_i16) -> t_i16);\n+    ifn!(\"llvm.fshl.i32\", fn(t_i32, t_i32, t_i32) -> t_i32);\n+    ifn!(\"llvm.fshl.i64\", fn(t_i64, t_i64, t_i64) -> t_i64);\n+    ifn!(\"llvm.fshl.i128\", fn(t_i128, t_i128, t_i128) -> t_i128);\n \n-        let tail = self.tcx.struct_tail(ty);\n-        match tail.sty {\n-            ty::Foreign(..) => false,\n-            ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n-            _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n+    ifn!(\"llvm.fshr.i8\", fn(t_i8, t_i8, t_i8) -> t_i8);\n+    ifn!(\"llvm.fshr.i16\", fn(t_i16, t_i16, t_i16) -> t_i16);\n+    ifn!(\"llvm.fshr.i32\", fn(t_i32, t_i32, t_i32) -> t_i32);\n+    ifn!(\"llvm.fshr.i64\", fn(t_i64, t_i64, t_i64) -> t_i64);\n+    ifn!(\"llvm.fshr.i128\", fn(t_i128, t_i128, t_i128) -> t_i128);\n+\n+        ifn!(\"llvm.sadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+        ifn!(\"llvm.sadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+        ifn!(\"llvm.sadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+        ifn!(\"llvm.sadd.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+        ifn!(\"llvm.sadd.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n+\n+        ifn!(\"llvm.uadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+        ifn!(\"llvm.uadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+        ifn!(\"llvm.uadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+        ifn!(\"llvm.uadd.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+        ifn!(\"llvm.uadd.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n+\n+        ifn!(\"llvm.ssub.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+        ifn!(\"llvm.ssub.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+        ifn!(\"llvm.ssub.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+        ifn!(\"llvm.ssub.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+        ifn!(\"llvm.ssub.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n+\n+        ifn!(\"llvm.usub.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+        ifn!(\"llvm.usub.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+        ifn!(\"llvm.usub.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+        ifn!(\"llvm.usub.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+        ifn!(\"llvm.usub.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n+\n+        ifn!(\"llvm.smul.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+        ifn!(\"llvm.smul.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+        ifn!(\"llvm.smul.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+        ifn!(\"llvm.smul.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+        ifn!(\"llvm.smul.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n+\n+        ifn!(\"llvm.umul.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+        ifn!(\"llvm.umul.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+        ifn!(\"llvm.umul.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+        ifn!(\"llvm.umul.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+        ifn!(\"llvm.umul.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n+\n+        ifn!(\"llvm.lifetime.start\", fn(t_i64,i8p) -> void);\n+        ifn!(\"llvm.lifetime.end\", fn(t_i64, i8p) -> void);\n+\n+        ifn!(\"llvm.expect.i1\", fn(i1, i1) -> i1);\n+        ifn!(\"llvm.eh.typeid.for\", fn(i8p) -> t_i32);\n+        ifn!(\"llvm.localescape\", fn(...) -> void);\n+        ifn!(\"llvm.localrecover\", fn(i8p, i8p, t_i32) -> i8p);\n+        ifn!(\"llvm.x86.seh.recoverfp\", fn(i8p, i8p) -> i8p);\n+\n+        ifn!(\"llvm.assume\", fn(i1) -> void);\n+        ifn!(\"llvm.prefetch\", fn(i8p, t_i32, t_i32, t_i32) -> void);\n+\n+        if self.sess().opts.debuginfo != DebugInfo::None {\n+            ifn!(\"llvm.dbg.declare\", fn(self.type_metadata(), self.type_metadata()) -> void);\n+            ifn!(\"llvm.dbg.value\", fn(self.type_metadata(), t_i64, self.type_metadata()) -> void);\n         }\n+        return None;\n+    }\n+}\n+\n+impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n+    /// Generate a new symbol name with the given prefix. This symbol name must\n+    /// only be used for definitions with `internal` or `private` linkage.\n+    pub fn generate_local_symbol_name(&self, prefix: &str) -> String {\n+        let idx = self.local_gen_sym_counter.get();\n+        self.local_gen_sym_counter.set(idx + 1);\n+        // Include a '.' character, so there can be no accidental conflicts with\n+        // user defined names\n+        let mut name = String::with_capacity(prefix.len() + 6);\n+        name.push_str(prefix);\n+        name.push_str(\".\");\n+        base_n::push_str(idx as u128, base_n::ALPHANUMERIC_ONLY, &mut name);\n+        name\n     }\n }\n \n@@ -477,313 +838,3 @@ impl LayoutOf for CodegenCx<'ll, 'tcx> {\n             })\n     }\n }\n-\n-/// Declare any llvm intrinsics that you might need\n-fn declare_intrinsic(cx: &CodegenCx<'ll, '_>, key: &str) -> Option<&'ll Value> {\n-    macro_rules! ifn {\n-        ($name:expr, fn() -> $ret:expr) => (\n-            if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::func(&[], $ret));\n-                llvm::SetUnnamedAddr(f, false);\n-                cx.intrinsics.borrow_mut().insert($name, f.clone());\n-                return Some(f);\n-            }\n-        );\n-        ($name:expr, fn(...) -> $ret:expr) => (\n-            if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::variadic_func(&[], $ret));\n-                llvm::SetUnnamedAddr(f, false);\n-                cx.intrinsics.borrow_mut().insert($name, f.clone());\n-                return Some(f);\n-            }\n-        );\n-        ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n-            if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::func(&[$($arg),*], $ret));\n-                llvm::SetUnnamedAddr(f, false);\n-                cx.intrinsics.borrow_mut().insert($name, f.clone());\n-                return Some(f);\n-            }\n-        );\n-    }\n-    macro_rules! mk_struct {\n-        ($($field_ty:expr),*) => (Type::struct_(cx, &[$($field_ty),*], false))\n-    }\n-\n-    let i8p = Type::i8p(cx);\n-    let void = Type::void(cx);\n-    let i1 = Type::i1(cx);\n-    let t_i8 = Type::i8(cx);\n-    let t_i16 = Type::i16(cx);\n-    let t_i32 = Type::i32(cx);\n-    let t_i64 = Type::i64(cx);\n-    let t_i128 = Type::i128(cx);\n-    let t_f32 = Type::f32(cx);\n-    let t_f64 = Type::f64(cx);\n-\n-    let t_v2f32 = Type::vector(t_f32, 2);\n-    let t_v4f32 = Type::vector(t_f32, 4);\n-    let t_v8f32 = Type::vector(t_f32, 8);\n-    let t_v16f32 = Type::vector(t_f32, 16);\n-\n-    let t_v2f64 = Type::vector(t_f64, 2);\n-    let t_v4f64 = Type::vector(t_f64, 4);\n-    let t_v8f64 = Type::vector(t_f64, 8);\n-\n-    ifn!(\"llvm.memset.p0i8.i16\", fn(i8p, t_i8, t_i16, t_i32, i1) -> void);\n-    ifn!(\"llvm.memset.p0i8.i32\", fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n-    ifn!(\"llvm.memset.p0i8.i64\", fn(i8p, t_i8, t_i64, t_i32, i1) -> void);\n-\n-    ifn!(\"llvm.trap\", fn() -> void);\n-    ifn!(\"llvm.debugtrap\", fn() -> void);\n-    ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);\n-\n-    ifn!(\"llvm.powi.f32\", fn(t_f32, t_i32) -> t_f32);\n-    ifn!(\"llvm.powi.v2f32\", fn(t_v2f32, t_i32) -> t_v2f32);\n-    ifn!(\"llvm.powi.v4f32\", fn(t_v4f32, t_i32) -> t_v4f32);\n-    ifn!(\"llvm.powi.v8f32\", fn(t_v8f32, t_i32) -> t_v8f32);\n-    ifn!(\"llvm.powi.v16f32\", fn(t_v16f32, t_i32) -> t_v16f32);\n-    ifn!(\"llvm.powi.f64\", fn(t_f64, t_i32) -> t_f64);\n-    ifn!(\"llvm.powi.v2f64\", fn(t_v2f64, t_i32) -> t_v2f64);\n-    ifn!(\"llvm.powi.v4f64\", fn(t_v4f64, t_i32) -> t_v4f64);\n-    ifn!(\"llvm.powi.v8f64\", fn(t_v8f64, t_i32) -> t_v8f64);\n-\n-    ifn!(\"llvm.pow.f32\", fn(t_f32, t_f32) -> t_f32);\n-    ifn!(\"llvm.pow.v2f32\", fn(t_v2f32, t_v2f32) -> t_v2f32);\n-    ifn!(\"llvm.pow.v4f32\", fn(t_v4f32, t_v4f32) -> t_v4f32);\n-    ifn!(\"llvm.pow.v8f32\", fn(t_v8f32, t_v8f32) -> t_v8f32);\n-    ifn!(\"llvm.pow.v16f32\", fn(t_v16f32, t_v16f32) -> t_v16f32);\n-    ifn!(\"llvm.pow.f64\", fn(t_f64, t_f64) -> t_f64);\n-    ifn!(\"llvm.pow.v2f64\", fn(t_v2f64, t_v2f64) -> t_v2f64);\n-    ifn!(\"llvm.pow.v4f64\", fn(t_v4f64, t_v4f64) -> t_v4f64);\n-    ifn!(\"llvm.pow.v8f64\", fn(t_v8f64, t_v8f64) -> t_v8f64);\n-\n-    ifn!(\"llvm.sqrt.f32\", fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.sqrt.v2f32\", fn(t_v2f32) -> t_v2f32);\n-    ifn!(\"llvm.sqrt.v4f32\", fn(t_v4f32) -> t_v4f32);\n-    ifn!(\"llvm.sqrt.v8f32\", fn(t_v8f32) -> t_v8f32);\n-    ifn!(\"llvm.sqrt.v16f32\", fn(t_v16f32) -> t_v16f32);\n-    ifn!(\"llvm.sqrt.f64\", fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.sqrt.v2f64\", fn(t_v2f64) -> t_v2f64);\n-    ifn!(\"llvm.sqrt.v4f64\", fn(t_v4f64) -> t_v4f64);\n-    ifn!(\"llvm.sqrt.v8f64\", fn(t_v8f64) -> t_v8f64);\n-\n-    ifn!(\"llvm.sin.f32\", fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.sin.v2f32\", fn(t_v2f32) -> t_v2f32);\n-    ifn!(\"llvm.sin.v4f32\", fn(t_v4f32) -> t_v4f32);\n-    ifn!(\"llvm.sin.v8f32\", fn(t_v8f32) -> t_v8f32);\n-    ifn!(\"llvm.sin.v16f32\", fn(t_v16f32) -> t_v16f32);\n-    ifn!(\"llvm.sin.f64\", fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.sin.v2f64\", fn(t_v2f64) -> t_v2f64);\n-    ifn!(\"llvm.sin.v4f64\", fn(t_v4f64) -> t_v4f64);\n-    ifn!(\"llvm.sin.v8f64\", fn(t_v8f64) -> t_v8f64);\n-\n-    ifn!(\"llvm.cos.f32\", fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.cos.v2f32\", fn(t_v2f32) -> t_v2f32);\n-    ifn!(\"llvm.cos.v4f32\", fn(t_v4f32) -> t_v4f32);\n-    ifn!(\"llvm.cos.v8f32\", fn(t_v8f32) -> t_v8f32);\n-    ifn!(\"llvm.cos.v16f32\", fn(t_v16f32) -> t_v16f32);\n-    ifn!(\"llvm.cos.f64\", fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.cos.v2f64\", fn(t_v2f64) -> t_v2f64);\n-    ifn!(\"llvm.cos.v4f64\", fn(t_v4f64) -> t_v4f64);\n-    ifn!(\"llvm.cos.v8f64\", fn(t_v8f64) -> t_v8f64);\n-\n-    ifn!(\"llvm.exp.f32\", fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.exp.v2f32\", fn(t_v2f32) -> t_v2f32);\n-    ifn!(\"llvm.exp.v4f32\", fn(t_v4f32) -> t_v4f32);\n-    ifn!(\"llvm.exp.v8f32\", fn(t_v8f32) -> t_v8f32);\n-    ifn!(\"llvm.exp.v16f32\", fn(t_v16f32) -> t_v16f32);\n-    ifn!(\"llvm.exp.f64\", fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.exp.v2f64\", fn(t_v2f64) -> t_v2f64);\n-    ifn!(\"llvm.exp.v4f64\", fn(t_v4f64) -> t_v4f64);\n-    ifn!(\"llvm.exp.v8f64\", fn(t_v8f64) -> t_v8f64);\n-\n-    ifn!(\"llvm.exp2.f32\", fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.exp2.v2f32\", fn(t_v2f32) -> t_v2f32);\n-    ifn!(\"llvm.exp2.v4f32\", fn(t_v4f32) -> t_v4f32);\n-    ifn!(\"llvm.exp2.v8f32\", fn(t_v8f32) -> t_v8f32);\n-    ifn!(\"llvm.exp2.v16f32\", fn(t_v16f32) -> t_v16f32);\n-    ifn!(\"llvm.exp2.f64\", fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.exp2.v2f64\", fn(t_v2f64) -> t_v2f64);\n-    ifn!(\"llvm.exp2.v4f64\", fn(t_v4f64) -> t_v4f64);\n-    ifn!(\"llvm.exp2.v8f64\", fn(t_v8f64) -> t_v8f64);\n-\n-    ifn!(\"llvm.log.f32\", fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.log.v2f32\", fn(t_v2f32) -> t_v2f32);\n-    ifn!(\"llvm.log.v4f32\", fn(t_v4f32) -> t_v4f32);\n-    ifn!(\"llvm.log.v8f32\", fn(t_v8f32) -> t_v8f32);\n-    ifn!(\"llvm.log.v16f32\", fn(t_v16f32) -> t_v16f32);\n-    ifn!(\"llvm.log.f64\", fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.log.v2f64\", fn(t_v2f64) -> t_v2f64);\n-    ifn!(\"llvm.log.v4f64\", fn(t_v4f64) -> t_v4f64);\n-    ifn!(\"llvm.log.v8f64\", fn(t_v8f64) -> t_v8f64);\n-\n-    ifn!(\"llvm.log10.f32\", fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.log10.v2f32\", fn(t_v2f32) -> t_v2f32);\n-    ifn!(\"llvm.log10.v4f32\", fn(t_v4f32) -> t_v4f32);\n-    ifn!(\"llvm.log10.v8f32\", fn(t_v8f32) -> t_v8f32);\n-    ifn!(\"llvm.log10.v16f32\", fn(t_v16f32) -> t_v16f32);\n-    ifn!(\"llvm.log10.f64\", fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.log10.v2f64\", fn(t_v2f64) -> t_v2f64);\n-    ifn!(\"llvm.log10.v4f64\", fn(t_v4f64) -> t_v4f64);\n-    ifn!(\"llvm.log10.v8f64\", fn(t_v8f64) -> t_v8f64);\n-\n-    ifn!(\"llvm.log2.f32\", fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.log2.v2f32\", fn(t_v2f32) -> t_v2f32);\n-    ifn!(\"llvm.log2.v4f32\", fn(t_v4f32) -> t_v4f32);\n-    ifn!(\"llvm.log2.v8f32\", fn(t_v8f32) -> t_v8f32);\n-    ifn!(\"llvm.log2.v16f32\", fn(t_v16f32) -> t_v16f32);\n-    ifn!(\"llvm.log2.f64\", fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.log2.v2f64\", fn(t_v2f64) -> t_v2f64);\n-    ifn!(\"llvm.log2.v4f64\", fn(t_v4f64) -> t_v4f64);\n-    ifn!(\"llvm.log2.v8f64\", fn(t_v8f64) -> t_v8f64);\n-\n-    ifn!(\"llvm.fma.f32\", fn(t_f32, t_f32, t_f32) -> t_f32);\n-    ifn!(\"llvm.fma.v2f32\", fn(t_v2f32, t_v2f32, t_v2f32) -> t_v2f32);\n-    ifn!(\"llvm.fma.v4f32\", fn(t_v4f32, t_v4f32, t_v4f32) -> t_v4f32);\n-    ifn!(\"llvm.fma.v8f32\", fn(t_v8f32, t_v8f32, t_v8f32) -> t_v8f32);\n-    ifn!(\"llvm.fma.v16f32\", fn(t_v16f32, t_v16f32, t_v16f32) -> t_v16f32);\n-    ifn!(\"llvm.fma.f64\", fn(t_f64, t_f64, t_f64) -> t_f64);\n-    ifn!(\"llvm.fma.v2f64\", fn(t_v2f64, t_v2f64, t_v2f64) -> t_v2f64);\n-    ifn!(\"llvm.fma.v4f64\", fn(t_v4f64, t_v4f64, t_v4f64) -> t_v4f64);\n-    ifn!(\"llvm.fma.v8f64\", fn(t_v8f64, t_v8f64, t_v8f64) -> t_v8f64);\n-\n-    ifn!(\"llvm.fabs.f32\", fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.fabs.v2f32\", fn(t_v2f32) -> t_v2f32);\n-    ifn!(\"llvm.fabs.v4f32\", fn(t_v4f32) -> t_v4f32);\n-    ifn!(\"llvm.fabs.v8f32\", fn(t_v8f32) -> t_v8f32);\n-    ifn!(\"llvm.fabs.v16f32\", fn(t_v16f32) -> t_v16f32);\n-    ifn!(\"llvm.fabs.f64\", fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.fabs.v2f64\", fn(t_v2f64) -> t_v2f64);\n-    ifn!(\"llvm.fabs.v4f64\", fn(t_v4f64) -> t_v4f64);\n-    ifn!(\"llvm.fabs.v8f64\", fn(t_v8f64) -> t_v8f64);\n-\n-    ifn!(\"llvm.floor.f32\", fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.floor.v2f32\", fn(t_v2f32) -> t_v2f32);\n-    ifn!(\"llvm.floor.v4f32\", fn(t_v4f32) -> t_v4f32);\n-    ifn!(\"llvm.floor.v8f32\", fn(t_v8f32) -> t_v8f32);\n-    ifn!(\"llvm.floor.v16f32\", fn(t_v16f32) -> t_v16f32);\n-    ifn!(\"llvm.floor.f64\", fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.floor.v2f64\", fn(t_v2f64) -> t_v2f64);\n-    ifn!(\"llvm.floor.v4f64\", fn(t_v4f64) -> t_v4f64);\n-    ifn!(\"llvm.floor.v8f64\", fn(t_v8f64) -> t_v8f64);\n-\n-    ifn!(\"llvm.ceil.f32\", fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.ceil.v2f32\", fn(t_v2f32) -> t_v2f32);\n-    ifn!(\"llvm.ceil.v4f32\", fn(t_v4f32) -> t_v4f32);\n-    ifn!(\"llvm.ceil.v8f32\", fn(t_v8f32) -> t_v8f32);\n-    ifn!(\"llvm.ceil.v16f32\", fn(t_v16f32) -> t_v16f32);\n-    ifn!(\"llvm.ceil.f64\", fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.ceil.v2f64\", fn(t_v2f64) -> t_v2f64);\n-    ifn!(\"llvm.ceil.v4f64\", fn(t_v4f64) -> t_v4f64);\n-    ifn!(\"llvm.ceil.v8f64\", fn(t_v8f64) -> t_v8f64);\n-\n-    ifn!(\"llvm.trunc.f32\", fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.trunc.f64\", fn(t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.copysign.f32\", fn(t_f32, t_f32) -> t_f32);\n-    ifn!(\"llvm.copysign.f64\", fn(t_f64, t_f64) -> t_f64);\n-    ifn!(\"llvm.round.f32\", fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.round.f64\", fn(t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.rint.f32\", fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.rint.f64\", fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.nearbyint.f32\", fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.nearbyint.f64\", fn(t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.ctpop.i8\", fn(t_i8) -> t_i8);\n-    ifn!(\"llvm.ctpop.i16\", fn(t_i16) -> t_i16);\n-    ifn!(\"llvm.ctpop.i32\", fn(t_i32) -> t_i32);\n-    ifn!(\"llvm.ctpop.i64\", fn(t_i64) -> t_i64);\n-    ifn!(\"llvm.ctpop.i128\", fn(t_i128) -> t_i128);\n-\n-    ifn!(\"llvm.ctlz.i8\", fn(t_i8 , i1) -> t_i8);\n-    ifn!(\"llvm.ctlz.i16\", fn(t_i16, i1) -> t_i16);\n-    ifn!(\"llvm.ctlz.i32\", fn(t_i32, i1) -> t_i32);\n-    ifn!(\"llvm.ctlz.i64\", fn(t_i64, i1) -> t_i64);\n-    ifn!(\"llvm.ctlz.i128\", fn(t_i128, i1) -> t_i128);\n-\n-    ifn!(\"llvm.cttz.i8\", fn(t_i8 , i1) -> t_i8);\n-    ifn!(\"llvm.cttz.i16\", fn(t_i16, i1) -> t_i16);\n-    ifn!(\"llvm.cttz.i32\", fn(t_i32, i1) -> t_i32);\n-    ifn!(\"llvm.cttz.i64\", fn(t_i64, i1) -> t_i64);\n-    ifn!(\"llvm.cttz.i128\", fn(t_i128, i1) -> t_i128);\n-\n-    ifn!(\"llvm.bswap.i16\", fn(t_i16) -> t_i16);\n-    ifn!(\"llvm.bswap.i32\", fn(t_i32) -> t_i32);\n-    ifn!(\"llvm.bswap.i64\", fn(t_i64) -> t_i64);\n-    ifn!(\"llvm.bswap.i128\", fn(t_i128) -> t_i128);\n-\n-    ifn!(\"llvm.bitreverse.i8\", fn(t_i8) -> t_i8);\n-    ifn!(\"llvm.bitreverse.i16\", fn(t_i16) -> t_i16);\n-    ifn!(\"llvm.bitreverse.i32\", fn(t_i32) -> t_i32);\n-    ifn!(\"llvm.bitreverse.i64\", fn(t_i64) -> t_i64);\n-    ifn!(\"llvm.bitreverse.i128\", fn(t_i128) -> t_i128);\n-\n-    ifn!(\"llvm.fshl.i8\", fn(t_i8, t_i8, t_i8) -> t_i8);\n-    ifn!(\"llvm.fshl.i16\", fn(t_i16, t_i16, t_i16) -> t_i16);\n-    ifn!(\"llvm.fshl.i32\", fn(t_i32, t_i32, t_i32) -> t_i32);\n-    ifn!(\"llvm.fshl.i64\", fn(t_i64, t_i64, t_i64) -> t_i64);\n-    ifn!(\"llvm.fshl.i128\", fn(t_i128, t_i128, t_i128) -> t_i128);\n-\n-    ifn!(\"llvm.fshr.i8\", fn(t_i8, t_i8, t_i8) -> t_i8);\n-    ifn!(\"llvm.fshr.i16\", fn(t_i16, t_i16, t_i16) -> t_i16);\n-    ifn!(\"llvm.fshr.i32\", fn(t_i32, t_i32, t_i32) -> t_i32);\n-    ifn!(\"llvm.fshr.i64\", fn(t_i64, t_i64, t_i64) -> t_i64);\n-    ifn!(\"llvm.fshr.i128\", fn(t_i128, t_i128, t_i128) -> t_i128);\n-\n-    ifn!(\"llvm.sadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.sadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.sadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.sadd.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-    ifn!(\"llvm.sadd.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n-\n-    ifn!(\"llvm.uadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.uadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.uadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.uadd.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-    ifn!(\"llvm.uadd.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n-\n-    ifn!(\"llvm.ssub.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.ssub.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.ssub.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.ssub.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-    ifn!(\"llvm.ssub.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n-\n-    ifn!(\"llvm.usub.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.usub.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.usub.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.usub.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-    ifn!(\"llvm.usub.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n-\n-    ifn!(\"llvm.smul.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.smul.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.smul.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.smul.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-    ifn!(\"llvm.smul.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n-\n-    ifn!(\"llvm.umul.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.umul.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.umul.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.umul.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-    ifn!(\"llvm.umul.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n-\n-    ifn!(\"llvm.lifetime.start\", fn(t_i64,i8p) -> void);\n-    ifn!(\"llvm.lifetime.end\", fn(t_i64, i8p) -> void);\n-\n-    ifn!(\"llvm.expect.i1\", fn(i1, i1) -> i1);\n-    ifn!(\"llvm.eh.typeid.for\", fn(i8p) -> t_i32);\n-    ifn!(\"llvm.localescape\", fn(...) -> void);\n-    ifn!(\"llvm.localrecover\", fn(i8p, i8p, t_i32) -> i8p);\n-    ifn!(\"llvm.x86.seh.recoverfp\", fn(i8p, i8p) -> i8p);\n-\n-    ifn!(\"llvm.assume\", fn(i1) -> void);\n-    ifn!(\"llvm.prefetch\", fn(i8p, t_i32, t_i32, t_i32) -> void);\n-\n-    if cx.sess().opts.debuginfo != DebugInfo::None {\n-        ifn!(\"llvm.dbg.declare\", fn(Type::metadata(cx), Type::metadata(cx)) -> void);\n-        ifn!(\"llvm.dbg.value\", fn(Type::metadata(cx), t_i64, Type::metadata(cx)) -> void);\n-    }\n-\n-    None\n-}"}, {"sha": "c18e126e52003960fe1412be3bf8ef479282e378", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{FunctionDebugContext, FunctionDebugContextData};\n+use rustc_codegen_ssa::debuginfo::{FunctionDebugContext, FunctionDebugContextData, MirDebugScope};\n use super::metadata::file_metadata;\n use super::utils::{DIB, span_start};\n \n use llvm;\n-use llvm::debuginfo::DIScope;\n+use llvm::debuginfo::{DIScope, DISubprogram};\n use common::CodegenCx;\n use rustc::mir::{Mir, SourceScope};\n \n@@ -26,28 +26,13 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use syntax_pos::BytePos;\n \n-#[derive(Clone, Copy, Debug)]\n-pub struct MirDebugScope<'ll> {\n-    pub scope_metadata: Option<&'ll DIScope>,\n-    // Start and end offsets of the file to which this DIScope belongs.\n-    // These are used to quickly determine whether some span refers to the same file.\n-    pub file_start_pos: BytePos,\n-    pub file_end_pos: BytePos,\n-}\n-\n-impl MirDebugScope<'ll> {\n-    pub fn is_valid(&self) -> bool {\n-        self.scope_metadata.is_some()\n-    }\n-}\n-\n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n pub fn create_mir_scopes(\n     cx: &CodegenCx<'ll, '_>,\n     mir: &Mir,\n-    debug_context: &FunctionDebugContext<'ll>,\n-) -> IndexVec<SourceScope, MirDebugScope<'ll>> {\n+    debug_context: &FunctionDebugContext<&'ll DISubprogram>,\n+) -> IndexVec<SourceScope, MirDebugScope<&'ll DIScope>> {\n     let null_scope = MirDebugScope {\n         scope_metadata: None,\n         file_start_pos: BytePos(0),\n@@ -82,9 +67,9 @@ pub fn create_mir_scopes(\n fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n                   mir: &Mir,\n                   has_variables: &BitSet<SourceScope>,\n-                  debug_context: &FunctionDebugContextData<'ll>,\n+                  debug_context: &FunctionDebugContextData<&'ll DISubprogram>,\n                   scope: SourceScope,\n-                  scopes: &mut IndexVec<SourceScope, MirDebugScope<'ll>>) {\n+                  scopes: &mut IndexVec<SourceScope, MirDebugScope<&'ll DIScope>>) {\n     if scopes[scope].is_valid() {\n         return;\n     }"}, {"sha": "0046a07236673b07f876aa87e6ca3cfd116bfa34", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -12,24 +12,23 @@\n \n use llvm;\n \n-use common::{C_bytes, CodegenCx, C_i32};\n+use common::CodegenCx;\n use builder::Builder;\n-use declare;\n use rustc::session::config::DebugInfo;\n-use type_::Type;\n use value::Value;\n+use rustc_codegen_ssa::traits::*;\n \n use syntax::attr;\n \n \n /// Inserts a side-effect free instruction sequence that makes sure that the\n /// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n-pub fn insert_reference_to_gdb_debug_scripts_section_global(bx: &Builder) {\n-    if needs_gdb_debug_scripts_section(bx.cx) {\n-        let gdb_debug_scripts_section = get_or_insert_gdb_debug_scripts_section_global(bx.cx);\n+pub fn insert_reference_to_gdb_debug_scripts_section_global(bx: &mut Builder) {\n+    if needs_gdb_debug_scripts_section(bx.cx()) {\n+        let gdb_debug_scripts_section = get_or_insert_gdb_debug_scripts_section_global(bx.cx());\n         // Load just the first byte as that's all that's necessary to force\n         // LLVM to keep around the reference to the global.\n-        let indices = [C_i32(bx.cx, 0), C_i32(bx.cx, 0)];\n+        let indices = [bx.cx().const_i32(0), bx.cx().const_i32(0)];\n         let element = bx.inbounds_gep(gdb_debug_scripts_section, &indices);\n         let volative_load_instruction = bx.volatile_load(element);\n         unsafe {\n@@ -55,15 +54,15 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n         let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n \n         unsafe {\n-            let llvm_type = Type::array(Type::i8(cx),\n+            let llvm_type = cx.type_array(cx.type_i8(),\n                                         section_contents.len() as u64);\n \n-            let section_var = declare::define_global(cx, section_var_name,\n+            let section_var = cx.define_global(section_var_name,\n                                                      llvm_type).unwrap_or_else(||{\n                 bug!(\"symbol `{}` is already defined\", section_var_name)\n             });\n             llvm::LLVMSetSection(section_var, section_name.as_ptr() as *const _);\n-            llvm::LLVMSetInitializer(section_var, C_bytes(cx, section_contents));\n+            llvm::LLVMSetInitializer(section_var, cx.const_bytes(section_contents));\n             llvm::LLVMSetGlobalConstant(section_var, llvm::True);\n             llvm::LLVMSetUnnamedAddr(section_var, llvm::True);\n             llvm::LLVMRustSetLinkage(section_var, llvm::Linkage::LinkOnceODRLinkage);"}, {"sha": "1c787a969324b6c6ac4d04d4a53bc9a00ac853db", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -17,6 +17,7 @@ use super::utils::{debug_context, DIB, span_start,\n use super::namespace::mangled_name_of_instance;\n use super::type_names::compute_debuginfo_type_name;\n use super::{CrateDebugContext};\n+use rustc_codegen_ssa::traits::*;\n use abi;\n use value::Value;\n \n@@ -32,7 +33,7 @@ use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ich::NodeIdHashingMode;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::ty::Instance;\n-use common::{CodegenCx, C_u64};\n+use common::CodegenCx;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, HasDataLayout, Integer, IntegerExt, LayoutOf,\n                         PrimitiveExt, Size, TyLayout};\n@@ -1810,7 +1811,7 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, '_>,\n                     member_description.offset.bits(),\n                     match member_description.discriminant {\n                         None => None,\n-                        Some(value) => Some(C_u64(cx, value)),\n+                        Some(value) => Some(cx.const_u64(value)),\n                     },\n                     member_description.flags,\n                     member_description.type_metadata))\n@@ -1966,22 +1967,6 @@ pub fn create_global_var_metadata(\n     }\n }\n \n-// Creates an \"extension\" of an existing DIScope into another file.\n-pub fn extend_scope_to_file(\n-    cx: &CodegenCx<'ll, '_>,\n-    scope_metadata: &'ll DIScope,\n-    file: &syntax_pos::SourceFile,\n-    defining_crate: CrateNum,\n-) -> &'ll DILexicalBlock {\n-    let file_metadata = file_metadata(cx, &file.name, defining_crate);\n-    unsafe {\n-        llvm::LLVMRustDIBuilderCreateLexicalBlockFile(\n-            DIB(cx),\n-            scope_metadata,\n-            file_metadata)\n-    }\n-}\n-\n /// Creates debug information for the given vtable, which is for the\n /// given type.\n ///\n@@ -2037,3 +2022,19 @@ pub fn create_vtable_metadata(\n                                                     0);\n     }\n }\n+\n+// Creates an \"extension\" of an existing DIScope into another file.\n+pub fn extend_scope_to_file(\n+    cx: &CodegenCx<'ll, '_>,\n+    scope_metadata: &'ll DIScope,\n+    file: &syntax_pos::SourceFile,\n+    defining_crate: CrateNum,\n+) -> &'ll DILexicalBlock {\n+    let file_metadata = file_metadata(cx, &file.name, defining_crate);\n+    unsafe {\n+        llvm::LLVMRustDIBuilderCreateLexicalBlockFile(\n+            DIB(cx),\n+            scope_metadata,\n+            file_metadata)\n+    }\n+}"}, {"sha": "9784cc6cf9c80054f0126da502405bea656b12a8", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 358, "deletions": 353, "changes": 711, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -11,8 +11,8 @@\n // See doc.rs for documentation.\n mod doc;\n \n-use self::VariableAccess::*;\n-use self::VariableKind::*;\n+use rustc_codegen_ssa::debuginfo::VariableAccess::*;\n+use rustc_codegen_ssa::debuginfo::VariableKind::*;\n \n use self::utils::{DIB, span_start, create_DIArray, is_node_local_to_unit};\n use self::namespace::mangled_name_of_instance;\n@@ -21,7 +21,8 @@ use self::metadata::{type_metadata, file_metadata, TypeMap};\n use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n \n use llvm;\n-use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilder, DISubprogram, DIArray, DIFlags};\n+use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilder, DISubprogram, DIArray, DIFlags,\n+    DILexicalBlock};\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{DefId, CrateNum};\n use rustc::ty::subst::{Substs, UnpackedKind};\n@@ -35,7 +36,10 @@ use rustc::mir;\n use rustc::session::config::{self, DebugInfo};\n use rustc::util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n use rustc_data_structures::small_c_str::SmallCStr;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use value::Value;\n+use rustc_codegen_ssa::debuginfo::{FunctionDebugContext, MirDebugScope, VariableAccess,\n+    VariableKind, FunctionDebugContextData};\n \n use libc::c_uint;\n use std::cell::{Cell, RefCell};\n@@ -44,7 +48,8 @@ use std::ffi::CString;\n use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n-use rustc::ty::layout::{self, LayoutOf};\n+use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n+use rustc_codegen_ssa::traits::*;\n \n pub mod gdb;\n mod utils;\n@@ -54,10 +59,8 @@ pub mod metadata;\n mod create_scope_map;\n mod source_loc;\n \n-pub use self::create_scope_map::{create_mir_scopes, MirDebugScope};\n-pub use self::source_loc::start_emitting_source_locations;\n+pub use self::create_scope_map::{create_mir_scopes};\n pub use self::metadata::create_global_var_metadata;\n-pub use self::metadata::create_vtable_metadata;\n pub use self::metadata::extend_scope_to_file;\n pub use self::source_loc::set_source_location;\n \n@@ -109,54 +112,6 @@ impl<'a, 'tcx> CrateDebugContext<'a, 'tcx> {\n     }\n }\n \n-pub enum FunctionDebugContext<'ll> {\n-    RegularContext(FunctionDebugContextData<'ll>),\n-    DebugInfoDisabled,\n-    FunctionWithoutDebugInfo,\n-}\n-\n-impl FunctionDebugContext<'ll> {\n-    pub fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData<'ll> {\n-        match *self {\n-            FunctionDebugContext::RegularContext(ref data) => data,\n-            FunctionDebugContext::DebugInfoDisabled => {\n-                span_bug!(span, \"{}\", FunctionDebugContext::debuginfo_disabled_message());\n-            }\n-            FunctionDebugContext::FunctionWithoutDebugInfo => {\n-                span_bug!(span, \"{}\", FunctionDebugContext::should_be_ignored_message());\n-            }\n-        }\n-    }\n-\n-    fn debuginfo_disabled_message() -> &'static str {\n-        \"debuginfo: Error trying to access FunctionDebugContext although debug info is disabled!\"\n-    }\n-\n-    fn should_be_ignored_message() -> &'static str {\n-        \"debuginfo: Error trying to access FunctionDebugContext for function that should be \\\n-         ignored by debug info!\"\n-    }\n-}\n-\n-pub struct FunctionDebugContextData<'ll> {\n-    fn_metadata: &'ll DISubprogram,\n-    source_locations_enabled: Cell<bool>,\n-    pub defining_crate: CrateNum,\n-}\n-\n-pub enum VariableAccess<'a, 'll> {\n-    // The llptr given is an alloca containing the variable's value\n-    DirectVariable { alloca: &'ll Value },\n-    // The llptr given is an alloca containing the start of some pointer chain\n-    // leading to the variable's content.\n-    IndirectVariable { alloca: &'ll Value, address_operations: &'a [i64] }\n-}\n-\n-pub enum VariableKind {\n-    ArgumentVariable(usize /*index*/),\n-    LocalVariable,\n-}\n-\n /// Create any deferred debug metadata nodes\n pub fn finalize(cx: &CodegenCx) {\n     if cx.dbg_cx.is_none() {\n@@ -202,348 +157,398 @@ pub fn finalize(cx: &CodegenCx) {\n     };\n }\n \n-/// Creates the function-specific debug context.\n-///\n-/// Returns the FunctionDebugContext for the function which holds state needed\n-/// for debug info creation. The function may also return another variant of the\n-/// FunctionDebugContext enum which indicates why no debuginfo should be created\n-/// for the function.\n-pub fn create_function_debug_context(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    instance: Instance<'tcx>,\n-    sig: ty::FnSig<'tcx>,\n-    llfn: &'ll Value,\n-    mir: &mir::Mir,\n-) -> FunctionDebugContext<'ll> {\n-    if cx.sess().opts.debuginfo == DebugInfo::None {\n-        return FunctionDebugContext::DebugInfoDisabled;\n+impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    fn declare_local(\n+        &mut self,\n+        dbg_context: &FunctionDebugContext<&'ll DISubprogram>,\n+        variable_name: ast::Name,\n+        variable_type: Ty<'tcx>,\n+        scope_metadata: &'ll DIScope,\n+        variable_access: VariableAccess<'_, &'ll Value>,\n+        variable_kind: VariableKind,\n+        span: Span,\n+    ) {\n+        assert!(!dbg_context.get_ref(span).source_locations_enabled.get());\n+        let cx = self.cx();\n+\n+        let file = span_start(cx, span).file;\n+        let file_metadata = file_metadata(cx,\n+                                          &file.name,\n+                                          dbg_context.get_ref(span).defining_crate);\n+\n+        let loc = span_start(cx, span);\n+        let type_metadata = type_metadata(cx, variable_type, span);\n+\n+        let (argument_index, dwarf_tag) = match variable_kind {\n+            ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),\n+            LocalVariable => (0, DW_TAG_auto_variable)\n+        };\n+        let align = cx.align_of(variable_type);\n+\n+        let name = SmallCStr::new(&variable_name.as_str());\n+        match (variable_access, &[][..]) {\n+            (DirectVariable { alloca }, address_operations) |\n+            (IndirectVariable {alloca, address_operations}, _) => {\n+                let metadata = unsafe {\n+                    llvm::LLVMRustDIBuilderCreateVariable(\n+                        DIB(cx),\n+                        dwarf_tag,\n+                        scope_metadata,\n+                        name.as_ptr(),\n+                        file_metadata,\n+                        loc.line as c_uint,\n+                        type_metadata,\n+                        cx.sess().opts.optimize != config::OptLevel::No,\n+                        DIFlags::FlagZero,\n+                        argument_index,\n+                        align.abi() as u32,\n+                    )\n+                };\n+                source_loc::set_debug_location(self,\n+                    InternalDebugLocation::new(scope_metadata, loc.line, loc.col.to_usize()));\n+                unsafe {\n+                    let debug_loc = llvm::LLVMGetCurrentDebugLocation(self.llbuilder);\n+                    let instr = llvm::LLVMRustDIBuilderInsertDeclareAtEnd(\n+                        DIB(cx),\n+                        alloca,\n+                        metadata,\n+                        address_operations.as_ptr(),\n+                        address_operations.len() as c_uint,\n+                        debug_loc,\n+                        self.llbb());\n+\n+                    llvm::LLVMSetInstDebugLocation(self.llbuilder, instr);\n+                }\n+                source_loc::set_debug_location(self, UnknownLocation);\n+            }\n+        }\n+    }\n+\n+    fn set_source_location(\n+        &mut self,\n+        debug_context: &FunctionDebugContext<&'ll DISubprogram>,\n+        scope: Option<&'ll DIScope>,\n+        span: Span,\n+    ) {\n+        set_source_location(debug_context, &self, scope, span)\n     }\n+    fn insert_reference_to_gdb_debug_scripts_section_global(&mut self) {\n+        gdb::insert_reference_to_gdb_debug_scripts_section_global(self)\n+    }\n+}\n \n-    if let InstanceDef::Item(def_id) = instance.def {\n-        if cx.tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::NO_DEBUG) {\n-            return FunctionDebugContext::FunctionWithoutDebugInfo;\n+impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn create_function_debug_context(\n+        &self,\n+        instance: Instance<'tcx>,\n+        sig: ty::FnSig<'tcx>,\n+        llfn: &'ll Value,\n+        mir: &mir::Mir,\n+    ) -> FunctionDebugContext<&'ll DISubprogram> {\n+        if self.sess().opts.debuginfo == DebugInfo::None {\n+            return FunctionDebugContext::DebugInfoDisabled;\n+        }\n+\n+        if let InstanceDef::Item(def_id) = instance.def {\n+            if self.tcx().codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::NO_DEBUG) {\n+                return FunctionDebugContext::FunctionWithoutDebugInfo;\n+            }\n         }\n-    }\n \n-    let span = mir.span;\n+        let span = mir.span;\n \n-    // This can be the case for functions inlined from another crate\n-    if span.is_dummy() {\n-        // FIXME(simulacrum): Probably can't happen; remove.\n-        return FunctionDebugContext::FunctionWithoutDebugInfo;\n-    }\n+        // This can be the case for functions inlined from another crate\n+        if span.is_dummy() {\n+            // FIXME(simulacrum): Probably can't happen; remove.\n+            return FunctionDebugContext::FunctionWithoutDebugInfo;\n+        }\n \n-    let def_id = instance.def_id();\n-    let containing_scope = get_containing_scope(cx, instance);\n-    let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, &loc.file.name, def_id.krate);\n+        let def_id = instance.def_id();\n+        let containing_scope = get_containing_scope(self, instance);\n+        let loc = span_start(self, span);\n+        let file_metadata = file_metadata(self, &loc.file.name, def_id.krate);\n \n-    let function_type_metadata = unsafe {\n-        let fn_signature = get_function_signature(cx, sig);\n-        llvm::LLVMRustDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n-    };\n+        let function_type_metadata = unsafe {\n+            let fn_signature = get_function_signature(self, sig);\n+            llvm::LLVMRustDIBuilderCreateSubroutineType(DIB(self), file_metadata, fn_signature)\n+        };\n \n-    // Find the enclosing function, in case this is a closure.\n-    let def_key = cx.tcx.def_key(def_id);\n-    let mut name = def_key.disambiguated_data.data.to_string();\n+        // Find the enclosing function, in case this is a closure.\n+        let def_key = self.tcx().def_key(def_id);\n+        let mut name = def_key.disambiguated_data.data.to_string();\n \n-    let enclosing_fn_def_id = cx.tcx.closure_base_def_id(def_id);\n+        let enclosing_fn_def_id = self.tcx().closure_base_def_id(def_id);\n \n-    // Get_template_parameters() will append a `<...>` clause to the function\n-    // name if necessary.\n-    let generics = cx.tcx.generics_of(enclosing_fn_def_id);\n-    let substs = instance.substs.truncate_to(cx.tcx, generics);\n-    let template_parameters = get_template_parameters(cx,\n-                                                      &generics,\n-                                                      substs,\n-                                                      file_metadata,\n-                                                      &mut name);\n+        // Get_template_parameters() will append a `<...>` clause to the function\n+        // name if necessary.\n+        let generics = self.tcx().generics_of(enclosing_fn_def_id);\n+        let substs = instance.substs.truncate_to(self.tcx(), generics);\n+        let template_parameters = get_template_parameters(self,\n+                                                          &generics,\n+                                                          substs,\n+                                                          file_metadata,\n+                                                          &mut name);\n \n-    // Get the linkage_name, which is just the symbol name\n-    let linkage_name = mangled_name_of_instance(cx, instance);\n+        // Get the linkage_name, which is just the symbol name\n+        let linkage_name = mangled_name_of_instance(self, instance);\n \n-    let scope_line = span_start(cx, span).line;\n-    let is_local_to_unit = is_node_local_to_unit(cx, def_id);\n+        let scope_line = span_start(self, span).line;\n+        let is_local_to_unit = is_node_local_to_unit(self, def_id);\n \n-    let function_name = CString::new(name).unwrap();\n-    let linkage_name = SmallCStr::new(&linkage_name.as_str());\n+        let function_name = CString::new(name).unwrap();\n+        let linkage_name = SmallCStr::new(&linkage_name.as_str());\n \n-    let mut flags = DIFlags::FlagPrototyped;\n+        let mut flags = DIFlags::FlagPrototyped;\n \n-    let local_id = cx.tcx.hir.as_local_node_id(def_id);\n-    if let Some((id, _, _)) = *cx.sess().entry_fn.borrow() {\n-        if local_id == Some(id) {\n-            flags |= DIFlags::FlagMainSubprogram;\n+        let local_id = self.tcx().hir.as_local_node_id(def_id);\n+        if let Some((id, _, _)) = *self.sess().entry_fn.borrow() {\n+            if local_id == Some(id) {\n+                flags |= DIFlags::FlagMainSubprogram;\n+            }\n         }\n-    }\n \n-    if cx.layout_of(sig.output()).abi.is_uninhabited() {\n-        flags |= DIFlags::FlagNoReturn;\n-    }\n+        if self.layout_of(sig.output()).abi.is_uninhabited() {\n+            flags |= DIFlags::FlagNoReturn;\n+        }\n \n-    let fn_metadata = unsafe {\n-        llvm::LLVMRustDIBuilderCreateFunction(\n-            DIB(cx),\n-            containing_scope,\n-            function_name.as_ptr(),\n-            linkage_name.as_ptr(),\n-            file_metadata,\n-            loc.line as c_uint,\n-            function_type_metadata,\n-            is_local_to_unit,\n-            true,\n-            scope_line as c_uint,\n-            flags,\n-            cx.sess().opts.optimize != config::OptLevel::No,\n-            llfn,\n-            template_parameters,\n-            None)\n-    };\n+        let fn_metadata = unsafe {\n+            llvm::LLVMRustDIBuilderCreateFunction(\n+                DIB(self),\n+                containing_scope,\n+                function_name.as_ptr(),\n+                linkage_name.as_ptr(),\n+                file_metadata,\n+                loc.line as c_uint,\n+                function_type_metadata,\n+                is_local_to_unit,\n+                true,\n+                scope_line as c_uint,\n+                flags,\n+                self.sess().opts.optimize != config::OptLevel::No,\n+                llfn,\n+                template_parameters,\n+                None)\n+        };\n \n-    // Initialize fn debug context (including scope map and namespace map)\n-    let fn_debug_context = FunctionDebugContextData {\n-        fn_metadata,\n-        source_locations_enabled: Cell::new(false),\n-        defining_crate: def_id.krate,\n-    };\n+        // Initialize fn debug context (including scope map and namespace map)\n+        let fn_debug_context = FunctionDebugContextData {\n+            fn_metadata,\n+            source_locations_enabled: Cell::new(false),\n+            defining_crate: def_id.krate,\n+        };\n \n-    return FunctionDebugContext::RegularContext(fn_debug_context);\n+        return FunctionDebugContext::RegularContext(fn_debug_context);\n \n-    fn get_function_signature(\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        sig: ty::FnSig<'tcx>,\n-    ) -> &'ll DIArray {\n-        if cx.sess().opts.debuginfo == DebugInfo::Limited {\n-            return create_DIArray(DIB(cx), &[]);\n-        }\n+        fn get_function_signature<'ll, 'tcx>(\n+            cx: &CodegenCx<'ll, 'tcx>,\n+            sig: ty::FnSig<'tcx>,\n+        ) -> &'ll DIArray {\n+            if cx.sess().opts.debuginfo == DebugInfo::Limited {\n+                return create_DIArray(DIB(cx), &[]);\n+            }\n \n-        let mut signature = Vec::with_capacity(sig.inputs().len() + 1);\n+            let mut signature = Vec::with_capacity(sig.inputs().len() + 1);\n \n-        // Return type -- llvm::DIBuilder wants this at index 0\n-        signature.push(match sig.output().sty {\n-            ty::Tuple(ref tys) if tys.is_empty() => None,\n-            _ => Some(type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP))\n-        });\n+            // Return type -- llvm::DIBuilder wants this at index 0\n+            signature.push(match sig.output().sty {\n+                ty::Tuple(ref tys) if tys.is_empty() => None,\n+                _ => Some(type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP))\n+            });\n \n-        let inputs = if sig.abi == Abi::RustCall {\n-            &sig.inputs()[..sig.inputs().len() - 1]\n-        } else {\n-            sig.inputs()\n-        };\n+            let inputs = if sig.abi == Abi::RustCall {\n+                &sig.inputs()[..sig.inputs().len() - 1]\n+            } else {\n+                sig.inputs()\n+            };\n \n-        // Arguments types\n-        if cx.sess().target.target.options.is_like_msvc {\n-            // FIXME(#42800):\n-            // There is a bug in MSDIA that leads to a crash when it encounters\n-            // a fixed-size array of `u8` or something zero-sized in a\n-            // function-type (see #40477).\n-            // As a workaround, we replace those fixed-size arrays with a\n-            // pointer-type. So a function `fn foo(a: u8, b: [u8; 4])` would\n-            // appear as `fn foo(a: u8, b: *const u8)` in debuginfo,\n-            // and a function `fn bar(x: [(); 7])` as `fn bar(x: *const ())`.\n-            // This transformed type is wrong, but these function types are\n-            // already inaccurate due to ABI adjustments (see #42800).\n-            signature.extend(inputs.iter().map(|&t| {\n-                let t = match t.sty {\n-                    ty::Array(ct, _)\n-                        if (ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() => {\n-                        cx.tcx.mk_imm_ptr(ct)\n-                    }\n-                    _ => t\n-                };\n-                Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n-            }));\n-        } else {\n-            signature.extend(inputs.iter().map(|t| {\n-                Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n-            }));\n-        }\n+            // Arguments types\n+            if cx.sess().target.target.options.is_like_msvc {\n+                // FIXME(#42800):\n+                // There is a bug in MSDIA that leads to a crash when it encounters\n+                // a fixed-size array of `u8` or something zero-sized in a\n+                // function-type (see #40477).\n+                // As a workaround, we replace those fixed-size arrays with a\n+                // pointer-type. So a function `fn foo(a: u8, b: [u8; 4])` would\n+                // appear as `fn foo(a: u8, b: *const u8)` in debuginfo,\n+                // and a function `fn bar(x: [(); 7])` as `fn bar(x: *const ())`.\n+                // This transformed type is wrong, but these function types are\n+                // already inaccurate due to ABI adjustments (see #42800).\n+                signature.extend(inputs.iter().map(|&t| {\n+                    let t = match t.sty {\n+                        ty::Array(ct, _)\n+                            if (ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() => {\n+                            cx.tcx.mk_imm_ptr(ct)\n+                        }\n+                        _ => t\n+                    };\n+                    Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n+                }));\n+            } else {\n+                signature.extend(inputs.iter().map(|t| {\n+                    Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n+                }));\n+            }\n \n-        if sig.abi == Abi::RustCall && !sig.inputs().is_empty() {\n-            if let ty::Tuple(args) = sig.inputs()[sig.inputs().len() - 1].sty {\n-                signature.extend(\n-                    args.iter().map(|argument_type| {\n-                        Some(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP))\n-                    })\n-                );\n+            if sig.abi == Abi::RustCall && !sig.inputs().is_empty() {\n+                if let ty::Tuple(args) = sig.inputs()[sig.inputs().len() - 1].sty {\n+                    signature.extend(\n+                        args.iter().map(|argument_type| {\n+                            Some(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP))\n+                        })\n+                    );\n+                }\n             }\n+\n+            create_DIArray(DIB(cx), &signature[..])\n         }\n \n-        create_DIArray(DIB(cx), &signature[..])\n-    }\n+        fn get_template_parameters<'ll, 'tcx>(\n+            cx: &CodegenCx<'ll, 'tcx>,\n+            generics: &ty::Generics,\n+            substs: &Substs<'tcx>,\n+            file_metadata: &'ll DIFile,\n+            name_to_append_suffix_to: &mut String,\n+        ) -> &'ll DIArray {\n+            if substs.types().next().is_none() {\n+                return create_DIArray(DIB(cx), &[]);\n+            }\n \n-    fn get_template_parameters(\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        generics: &ty::Generics,\n-        substs: &Substs<'tcx>,\n-        file_metadata: &'ll DIFile,\n-        name_to_append_suffix_to: &mut String,\n-    ) -> &'ll DIArray {\n-        if substs.types().next().is_none() {\n-            return create_DIArray(DIB(cx), &[]);\n-        }\n+            name_to_append_suffix_to.push('<');\n+            for (i, actual_type) in substs.types().enumerate() {\n+                if i != 0 {\n+                    name_to_append_suffix_to.push_str(\",\");\n+                }\n \n-        name_to_append_suffix_to.push('<');\n-        for (i, actual_type) in substs.types().enumerate() {\n-            if i != 0 {\n-                name_to_append_suffix_to.push_str(\",\");\n+                let actual_type =\n+                    cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), actual_type);\n+                // Add actual type name to <...> clause of function name\n+                let actual_type_name = compute_debuginfo_type_name(cx,\n+                                                                   actual_type,\n+                                                                   true);\n+                name_to_append_suffix_to.push_str(&actual_type_name[..]);\n             }\n+            name_to_append_suffix_to.push('>');\n+\n+            // Again, only create type information if full debuginfo is enabled\n+            let template_params: Vec<_> = if cx.sess().opts.debuginfo == DebugInfo::Full {\n+                let names = get_parameter_names(cx, generics);\n+                substs.iter().zip(names).filter_map(|(kind, name)| {\n+                    if let UnpackedKind::Type(ty) = kind.unpack() {\n+                        let actual_type =\n+                            cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n+                        let actual_type_metadata =\n+                            type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n+                        let name = SmallCStr::new(&name.as_str());\n+                        Some(unsafe {\n+                            Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n+                                DIB(cx),\n+                                None,\n+                                name.as_ptr(),\n+                                actual_type_metadata,\n+                                file_metadata,\n+                                0,\n+                                0,\n+                            ))\n+                        })\n+                    } else {\n+                        None\n+                    }\n+                }).collect()\n+            } else {\n+                vec![]\n+            };\n+\n+            return create_DIArray(DIB(cx), &template_params[..]);\n+        }\n \n-            let actual_type = cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), actual_type);\n-            // Add actual type name to <...> clause of function name\n-            let actual_type_name = compute_debuginfo_type_name(cx,\n-                                                               actual_type,\n-                                                               true);\n-            name_to_append_suffix_to.push_str(&actual_type_name[..]);\n+        fn get_parameter_names(cx: &CodegenCx,\n+                               generics: &ty::Generics)\n+                               -> Vec<InternedString> {\n+            let mut names = generics.parent.map_or(vec![], |def_id| {\n+                get_parameter_names(cx, cx.tcx.generics_of(def_id))\n+            });\n+            names.extend(generics.params.iter().map(|param| param.name));\n+            names\n         }\n-        name_to_append_suffix_to.push('>');\n-\n-        // Again, only create type information if full debuginfo is enabled\n-        let template_params: Vec<_> = if cx.sess().opts.debuginfo == DebugInfo::Full {\n-            let names = get_parameter_names(cx, generics);\n-            substs.iter().zip(names).filter_map(|(kind, name)| {\n-                if let UnpackedKind::Type(ty) = kind.unpack() {\n-                    let actual_type = cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n-                    let actual_type_metadata =\n-                        type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n-                    let name = SmallCStr::new(&name.as_str());\n-                    Some(unsafe {\n-                        Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n-                            DIB(cx),\n-                            None,\n-                            name.as_ptr(),\n-                            actual_type_metadata,\n-                            file_metadata,\n-                            0,\n-                            0,\n-                        ))\n-                    })\n+\n+        fn get_containing_scope<'ll, 'tcx>(\n+            cx: &CodegenCx<'ll, 'tcx>,\n+            instance: Instance<'tcx>,\n+        ) -> &'ll DIScope {\n+            // First, let's see if this is a method within an inherent impl. Because\n+            // if yes, we want to make the result subroutine DIE a child of the\n+            // subroutine's self-type.\n+            let self_type = cx.tcx.impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n+                // If the method does *not* belong to a trait, proceed\n+                if cx.tcx.trait_id_of_impl(impl_def_id).is_none() {\n+                    let impl_self_ty = cx.tcx.subst_and_normalize_erasing_regions(\n+                        instance.substs,\n+                        ty::ParamEnv::reveal_all(),\n+                        &cx.tcx.type_of(impl_def_id),\n+                    );\n+\n+                    // Only \"class\" methods are generally understood by LLVM,\n+                    // so avoid methods on other types (e.g. `<*mut T>::null`).\n+                    match impl_self_ty.sty {\n+                        ty::Adt(def, ..) if !def.is_box() => {\n+                            Some(type_metadata(cx, impl_self_ty, syntax_pos::DUMMY_SP))\n+                        }\n+                        _ => None\n+                    }\n                 } else {\n+                    // For trait method impls we still use the \"parallel namespace\"\n+                    // strategy\n                     None\n                 }\n-            }).collect()\n-        } else {\n-            vec![]\n-        };\n+            });\n+\n+            self_type.unwrap_or_else(|| {\n+                namespace::item_namespace(cx, DefId {\n+                    krate: instance.def_id().krate,\n+                    index: cx.tcx\n+                             .def_key(instance.def_id())\n+                             .parent\n+                             .expect(\"get_containing_scope: missing parent?\")\n+                })\n+            })\n+        }\n+    }\n \n-        create_DIArray(DIB(cx), &template_params[..])\n+    fn create_vtable_metadata(\n+        &self,\n+        ty: Ty<'tcx>,\n+        vtable: Self::Value,\n+    ) {\n+        metadata::create_vtable_metadata(self, ty, vtable)\n     }\n \n-    fn get_parameter_names(cx: &CodegenCx,\n-                           generics: &ty::Generics)\n-                           -> Vec<InternedString> {\n-        let mut names = generics.parent.map_or(vec![], |def_id| {\n-            get_parameter_names(cx, cx.tcx.generics_of(def_id))\n-        });\n-        names.extend(generics.params.iter().map(|param| param.name));\n-        names\n+    fn create_mir_scopes(\n+        &self,\n+        mir: &mir::Mir,\n+        debug_context: &FunctionDebugContext<&'ll DISubprogram>,\n+    ) -> IndexVec<mir::SourceScope, MirDebugScope<&'ll DIScope>> {\n+        create_scope_map::create_mir_scopes(self, mir, debug_context)\n     }\n \n-    fn get_containing_scope(\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        instance: Instance<'tcx>,\n-    ) -> &'ll DIScope {\n-        // First, let's see if this is a method within an inherent impl. Because\n-        // if yes, we want to make the result subroutine DIE a child of the\n-        // subroutine's self-type.\n-        let self_type = cx.tcx.impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n-            // If the method does *not* belong to a trait, proceed\n-            if cx.tcx.trait_id_of_impl(impl_def_id).is_none() {\n-                let impl_self_ty = cx.tcx.subst_and_normalize_erasing_regions(\n-                    instance.substs,\n-                    ty::ParamEnv::reveal_all(),\n-                    &cx.tcx.type_of(impl_def_id),\n-                );\n-\n-                // Only \"class\" methods are generally understood by LLVM,\n-                // so avoid methods on other types (e.g. `<*mut T>::null`).\n-                match impl_self_ty.sty {\n-                    ty::Adt(def, ..) if !def.is_box() => {\n-                        Some(type_metadata(cx, impl_self_ty, syntax_pos::DUMMY_SP))\n-                    }\n-                    _ => None\n-                }\n-            } else {\n-                // For trait method impls we still use the \"parallel namespace\"\n-                // strategy\n-                None\n-            }\n-        });\n-\n-        self_type.unwrap_or_else(|| {\n-            namespace::item_namespace(cx, DefId {\n-                krate: instance.def_id().krate,\n-                index: cx.tcx\n-                         .def_key(instance.def_id())\n-                         .parent\n-                         .expect(\"get_containing_scope: missing parent?\")\n-            })\n-        })\n+    fn extend_scope_to_file(\n+         &self,\n+         scope_metadata: &'ll DIScope,\n+         file: &syntax_pos::SourceFile,\n+         defining_crate: CrateNum,\n+     ) -> &'ll DILexicalBlock {\n+         metadata::extend_scope_to_file(&self, scope_metadata, file, defining_crate)\n+     }\n+\n+    fn debuginfo_finalize(&self) {\n+        finalize(self)\n     }\n-}\n \n-pub fn declare_local(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    dbg_context: &FunctionDebugContext<'ll>,\n-    variable_name: ast::Name,\n-    variable_type: Ty<'tcx>,\n-    scope_metadata: &'ll DIScope,\n-    variable_access: VariableAccess<'_, 'll>,\n-    variable_kind: VariableKind,\n-    span: Span,\n-) {\n-    assert!(!dbg_context.get_ref(span).source_locations_enabled.get());\n-    let cx = bx.cx;\n-\n-    let file = span_start(cx, span).file;\n-    let file_metadata = file_metadata(cx,\n-                                      &file.name,\n-                                      dbg_context.get_ref(span).defining_crate);\n-\n-    let loc = span_start(cx, span);\n-    let type_metadata = type_metadata(cx, variable_type, span);\n-\n-    let (argument_index, dwarf_tag) = match variable_kind {\n-        ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),\n-        LocalVariable => (0, DW_TAG_auto_variable)\n-    };\n-    let align = cx.align_of(variable_type);\n-\n-    let name = SmallCStr::new(&variable_name.as_str());\n-    match (variable_access, &[][..]) {\n-        (DirectVariable { alloca }, address_operations) |\n-        (IndirectVariable {alloca, address_operations}, _) => {\n-            let metadata = unsafe {\n-                llvm::LLVMRustDIBuilderCreateVariable(\n-                    DIB(cx),\n-                    dwarf_tag,\n-                    scope_metadata,\n-                    name.as_ptr(),\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    type_metadata,\n-                    cx.sess().opts.optimize != config::OptLevel::No,\n-                    DIFlags::FlagZero,\n-                    argument_index,\n-                    align.abi() as u32,\n-                )\n-            };\n-            source_loc::set_debug_location(bx,\n-                InternalDebugLocation::new(scope_metadata, loc.line, loc.col.to_usize()));\n-            unsafe {\n-                let debug_loc = llvm::LLVMGetCurrentDebugLocation(bx.llbuilder);\n-                let instr = llvm::LLVMRustDIBuilderInsertDeclareAtEnd(\n-                    DIB(cx),\n-                    alloca,\n-                    metadata,\n-                    address_operations.as_ptr(),\n-                    address_operations.len() as c_uint,\n-                    debug_loc,\n-                    bx.llbb());\n-\n-                llvm::LLVMSetInstDebugLocation(bx.llbuilder, instr);\n-            }\n-            source_loc::set_debug_location(bx, UnknownLocation);\n+    fn debuginfo_upvar_decls_ops_sequence(&self, byte_offset_of_var_in_env: u64) -> [i64; 4] {\n+        unsafe {\n+            [llvm::LLVMRustDIBuilderCreateOpDeref(),\n+             llvm::LLVMRustDIBuilderCreateOpPlusUconst(),\n+             byte_offset_of_var_in_env as i64,\n+             llvm::LLVMRustDIBuilderCreateOpDeref()]\n         }\n     }\n }"}, {"sha": "c6772e8c98e367d65b05dfbc17be1f717e78448e", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -12,20 +12,21 @@ use self::InternalDebugLocation::*;\n \n use super::utils::{debug_context, span_start};\n use super::metadata::UNKNOWN_COLUMN_NUMBER;\n-use super::FunctionDebugContext;\n+use rustc_codegen_ssa::debuginfo::FunctionDebugContext;\n \n use llvm;\n use llvm::debuginfo::DIScope;\n use builder::Builder;\n+use rustc_codegen_ssa::traits::*;\n \n use libc::c_uint;\n use syntax_pos::{Span, Pos};\n \n /// Sets the current debug location at the beginning of the span.\n ///\n /// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...).\n-pub fn set_source_location(\n-    debug_context: &FunctionDebugContext<'ll>,\n+pub fn set_source_location<D>(\n+    debug_context: &FunctionDebugContext<D>,\n     bx: &Builder<'_, 'll, '_>,\n     scope: Option<&'ll DIScope>,\n     span: Span,\n@@ -40,27 +41,15 @@ pub fn set_source_location(\n     };\n \n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n-        debug!(\"set_source_location: {}\", bx.sess().source_map().span_to_string(span));\n-        let loc = span_start(bx.cx, span);\n+        debug!(\"set_source_location: {}\", bx.cx().sess().source_map().span_to_string(span));\n+        let loc = span_start(bx.cx(), span);\n         InternalDebugLocation::new(scope.unwrap(), loc.line, loc.col.to_usize())\n     } else {\n         UnknownLocation\n     };\n     set_debug_location(bx, dbg_loc);\n }\n \n-/// Enables emitting source locations for the given functions.\n-///\n-/// Since we don't want source locations to be emitted for the function prelude,\n-/// they are disabled when beginning to codegen a new function. This functions\n-/// switches source location emitting on and must therefore be called before the\n-/// first real statement/expression of the function is codegened.\n-pub fn start_emitting_source_locations(dbg_context: &FunctionDebugContext<'ll>) {\n-    if let FunctionDebugContext::RegularContext(ref data) = *dbg_context {\n-        data.source_locations_enabled.set(true);\n-    }\n-}\n-\n \n #[derive(Copy, Clone, PartialEq)]\n pub enum InternalDebugLocation<'ll> {\n@@ -78,13 +67,16 @@ impl InternalDebugLocation<'ll> {\n     }\n }\n \n-pub fn set_debug_location(bx: &Builder<'_, 'll, '_>, debug_location: InternalDebugLocation<'ll>) {\n+pub fn set_debug_location(\n+    bx: &Builder<'_, 'll, '_>,\n+    debug_location: InternalDebugLocation<'ll>\n+) {\n     let metadata_node = match debug_location {\n         KnownLocation { scope, line, col } => {\n             // For MSVC, set the column number to zero.\n             // Otherwise, emit it. This mimics clang behaviour.\n             // See discussion in https://github.com/rust-lang/rust/issues/42921\n-            let col_used =  if bx.cx.sess().target.target.options.is_like_msvc {\n+            let col_used =  if bx.cx().sess().target.target.options.is_like_msvc {\n                 UNKNOWN_COLUMN_NUMBER\n             } else {\n                 col as c_uint\n@@ -93,7 +85,7 @@ pub fn set_debug_location(bx: &Builder<'_, 'll, '_>, debug_location: InternalDeb\n \n             unsafe {\n                 Some(llvm::LLVMRustDIBuilderCreateDebugLocation(\n-                    debug_context(bx.cx).llcontext,\n+                    debug_context(bx.cx()).llcontext,\n                     line as c_uint,\n                     col_used,\n                     scope,"}, {"sha": "c3a15ccca0a9d0f340dc4e5589cc29c8fb45cd25", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -14,6 +14,7 @@ use common::CodegenCx;\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n+use rustc_codegen_ssa::traits::*;\n \n use rustc::hir;\n "}, {"sha": "89262beb356db749ee8299184b663b20d4abd945", "filename": "src/librustc_codegen_llvm/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -19,6 +19,7 @@ use rustc::ty::DefIdTree;\n use llvm;\n use llvm::debuginfo::{DIScope, DIBuilder, DIDescriptor, DIArray};\n use common::{CodegenCx};\n+use rustc_codegen_ssa::traits::*;\n \n use syntax_pos::{self, Span};\n "}, {"sha": "c23aab409a9a8d3ba906047ecf0f3abe9a4e1eb2", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 88, "deletions": 116, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -31,22 +31,9 @@ use abi::{Abi, FnType, FnTypeExt};\n use attributes;\n use context::CodegenCx;\n use type_::Type;\n+use rustc_codegen_ssa::traits::*;\n use value::Value;\n \n-\n-/// Declare a global value.\n-///\n-/// If there\u2019s a value with the same name already declared, the function will\n-/// return its Value instead.\n-pub fn declare_global(cx: &CodegenCx<'ll, '_>, name: &str, ty: &'ll Type) -> &'ll Value {\n-    debug!(\"declare_global(name={:?})\", name);\n-    let namebuf = SmallCStr::new(name);\n-    unsafe {\n-        llvm::LLVMRustGetOrInsertGlobal(cx.llmod, namebuf.as_ptr(), ty)\n-    }\n-}\n-\n-\n /// Declare a function.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n@@ -108,123 +95,108 @@ fn declare_raw_fn(\n     llfn\n }\n \n+impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n-/// Declare a C ABI function.\n-///\n-/// Only use this for foreign function ABIs and glue. For Rust functions use\n-/// `declare_fn` instead.\n-///\n-/// If there\u2019s a value with the same name already declared, the function will\n-/// update the declaration and return existing Value instead.\n-pub fn declare_cfn(cx: &CodegenCx<'ll, '_>, name: &str, fn_type: &'ll Type) -> &'ll Value {\n-    declare_raw_fn(cx, name, llvm::CCallConv, fn_type)\n-}\n-\n-\n-/// Declare a Rust function.\n-///\n-/// If there\u2019s a value with the same name already declared, the function will\n-/// update the declaration and return existing Value instead.\n-pub fn declare_fn(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    name: &str,\n-    sig: PolyFnSig<'tcx>,\n-) -> &'ll Value {\n-    debug!(\"declare_rust_fn(name={:?}, sig={:?})\", name, sig);\n-    let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-    debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n-\n-    let fty = FnType::new(cx, sig, &[]);\n-    let llfn = declare_raw_fn(cx, name, fty.llvm_cconv(), fty.llvm_type(cx));\n-\n-    if cx.layout_of(sig.output()).abi.is_uninhabited() {\n-        llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n+    fn declare_global(\n+        &self,\n+        name: &str, ty: &'ll Type\n+    ) -> &'ll Value {\n+        debug!(\"declare_global(name={:?})\", name);\n+        let namebuf = SmallCStr::new(name);\n+        unsafe {\n+            llvm::LLVMRustGetOrInsertGlobal(self.llmod, namebuf.as_ptr(), ty)\n+        }\n     }\n \n-    if sig.abi != Abi::Rust && sig.abi != Abi::RustCall {\n-        attributes::unwind(llfn, false);\n+    fn declare_cfn(\n+        &self,\n+        name: &str,\n+        fn_type: &'ll Type\n+    ) -> &'ll Value {\n+        declare_raw_fn(self, name, llvm::CCallConv, fn_type)\n     }\n \n-    fty.apply_attrs_llfn(llfn);\n+    fn declare_fn(\n+        &self,\n+        name: &str,\n+        sig: PolyFnSig<'tcx>,\n+    ) -> &'ll Value {\n+        debug!(\"declare_rust_fn(name={:?}, sig={:?})\", name, sig);\n+        let sig = self.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+        debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n-    llfn\n-}\n+        let fty = FnType::new(self, sig, &[]);\n+        let llfn = declare_raw_fn(self, name, fty.llvm_cconv(), fty.llvm_type(self));\n \n+        if self.layout_of(sig.output()).abi.is_uninhabited() {\n+            llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n+        }\n \n-/// Declare a global with an intention to define it.\n-///\n-/// Use this function when you intend to define a global. This function will\n-/// return None if the name already has a definition associated with it. In that\n-/// case an error should be reported to the user, because it usually happens due\n-/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-pub fn define_global(cx: &CodegenCx<'ll, '_>, name: &str, ty: &'ll Type) -> Option<&'ll Value> {\n-    if get_defined_value(cx, name).is_some() {\n-        None\n-    } else {\n-        Some(declare_global(cx, name, ty))\n+        if sig.abi != Abi::Rust && sig.abi != Abi::RustCall {\n+            attributes::unwind(llfn, false);\n+        }\n+\n+        fty.apply_attrs_llfn(llfn);\n+\n+        llfn\n     }\n-}\n \n-/// Declare a private global\n-///\n-/// Use this function when you intend to define a global without a name.\n-pub fn define_private_global(cx: &CodegenCx<'ll, '_>, ty: &'ll Type) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMRustInsertPrivateGlobal(cx.llmod, ty)\n+    fn define_global(\n+        &self,\n+        name: &str,\n+        ty: &'ll Type\n+    ) -> Option<&'ll Value> {\n+        if self.get_defined_value(name).is_some() {\n+            None\n+        } else {\n+            Some(self.declare_global(name, ty))\n+        }\n     }\n-}\n \n-/// Declare a Rust function with an intention to define it.\n-///\n-/// Use this function when you intend to define a function. This function will\n-/// return panic if the name already has a definition associated with it. This\n-/// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_fn(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    name: &str,\n-    fn_sig: PolyFnSig<'tcx>,\n-) -> &'ll Value {\n-    if get_defined_value(cx, name).is_some() {\n-        cx.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n-    } else {\n-        declare_fn(cx, name, fn_sig)\n+    fn define_private_global(&self, ty: &'ll Type) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMRustInsertPrivateGlobal(self.llmod, ty)\n+        }\n     }\n-}\n \n-/// Declare a Rust function with an intention to define it.\n-///\n-/// Use this function when you intend to define a function. This function will\n-/// return panic if the name already has a definition associated with it. This\n-/// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_internal_fn(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    name: &str,\n-    fn_sig: PolyFnSig<'tcx>,\n-) -> &'ll Value {\n-    let llfn = define_fn(cx, name, fn_sig);\n-    unsafe { llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage) };\n-    llfn\n-}\n+    fn define_fn(\n+        &self,\n+        name: &str,\n+        fn_sig: PolyFnSig<'tcx>,\n+    ) -> &'ll Value {\n+        if self.get_defined_value(name).is_some() {\n+            self.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n+        } else {\n+            self.declare_fn(name, fn_sig)\n+        }\n+    }\n \n+    fn define_internal_fn(\n+        &self,\n+        name: &str,\n+        fn_sig: PolyFnSig<'tcx>,\n+    ) -> &'ll Value {\n+        let llfn = self.define_fn(name, fn_sig);\n+        unsafe { llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage) };\n+        llfn\n+    }\n \n-/// Get declared value by name.\n-pub fn get_declared_value(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Value> {\n-    debug!(\"get_declared_value(name={:?})\", name);\n-    let namebuf = SmallCStr::new(name);\n-    unsafe { llvm::LLVMRustGetNamedValue(cx.llmod, namebuf.as_ptr()) }\n-}\n+    fn get_declared_value(&self, name: &str) -> Option<&'ll Value> {\n+        debug!(\"get_declared_value(name={:?})\", name);\n+        let namebuf = SmallCStr::new(name);\n+        unsafe { llvm::LLVMRustGetNamedValue(self.llmod, namebuf.as_ptr()) }\n+    }\n \n-/// Get defined or externally defined (AvailableExternally linkage) value by\n-/// name.\n-pub fn get_defined_value(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Value> {\n-    get_declared_value(cx, name).and_then(|val|{\n-        let declaration = unsafe {\n-            llvm::LLVMIsDeclaration(val) != 0\n-        };\n-        if !declaration {\n-            Some(val)\n-        } else {\n-            None\n-        }\n-    })\n+    fn get_defined_value(&self, name: &str) -> Option<&'ll Value> {\n+        self.get_declared_value(name).and_then(|val|{\n+            let declaration = unsafe {\n+                llvm::LLVMIsDeclaration(val) != 0\n+            };\n+            if !declaration {\n+                Some(val)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n }"}, {"sha": "94776f17c7989074aea7cf6b89a75776788d76dd", "filename": "src/librustc_codegen_llvm/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdiagnostics.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -47,37 +47,4 @@ unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!\n ```\n \"##,\n \n-E0668: r##\"\n-Malformed inline assembly rejected by LLVM.\n-\n-LLVM checks the validity of the constraints and the assembly string passed to\n-it. This error implies that LLVM seems something wrong with the inline\n-assembly call.\n-\n-In particular, it can happen if you forgot the closing bracket of a register\n-constraint (see issue #51430):\n-```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n-#![feature(asm)]\n-\n-fn main() {\n-    let rax: u64;\n-    unsafe {\n-        asm!(\"\" :\"={rax\"(rax));\n-        println!(\"Accumulator is: {}\", rax);\n-    }\n-}\n-```\n-\"##,\n-\n-E0669: r##\"\n-Cannot convert inline assembly operand to a single LLVM value.\n-\n-This error usually happens when trying to pass in a value to an input inline\n-assembly operand that is actually a pair of values. In particular, this can\n-happen when trying to pass in a slice, for instance a `&str`. In Rust, these\n-values are represented internally as a pair of values, the pointer and its\n-length. When passed as an input operand, this pair of values can not be\n-coerced into a register and thus we must fail with an error.\n-\"##,\n-\n }"}, {"sha": "b2f1f933da4db645dc6dd88f633197e11193d64d", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 737, "deletions": 672, "changes": 1409, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -12,25 +12,28 @@\n \n use attributes;\n use intrinsics::{self, Intrinsic};\n-use llvm::{self, TypeKind};\n+use llvm;\n use llvm_util;\n use abi::{Abi, FnType, LlvmType, PassMode};\n-use mir::place::PlaceRef;\n-use mir::operand::{OperandRef, OperandValue};\n-use base::*;\n-use common::*;\n-use declare;\n-use glue;\n+use rustc_codegen_ssa::MemFlags;\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n+use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n+use rustc_codegen_ssa::glue;\n+use rustc_codegen_ssa::base::{to_immediate, wants_msvc_seh, compare_simd_types};\n+use context::CodegenCx;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::LayoutOf;\n+use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n+use rustc_codegen_ssa::common::TypeKind;\n use rustc::hir;\n use syntax::ast;\n use syntax::symbol::Symbol;\n use builder::Builder;\n use value::Value;\n \n+use rustc_codegen_ssa::traits::*;\n+\n use rustc::session::Session;\n use syntax_pos::Span;\n \n@@ -84,677 +87,740 @@ fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Valu\n     Some(cx.get_intrinsic(&llvm_name))\n }\n \n-/// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n-/// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n-/// add them to librustc_codegen_llvm/context.rs\n-pub fn codegen_intrinsic_call(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    callee_ty: Ty<'tcx>,\n-    fn_ty: &FnType<'tcx, Ty<'tcx>>,\n-    args: &[OperandRef<'ll, 'tcx>],\n-    llresult: &'ll Value,\n-    span: Span,\n-) {\n-    let cx = bx.cx;\n-    let tcx = cx.tcx;\n+impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    fn codegen_intrinsic_call(\n+        &mut self,\n+        callee_ty: Ty<'tcx>,\n+        fn_ty: &FnType<'tcx, Ty<'tcx>>,\n+        args: &[OperandRef<'tcx, &'ll Value>],\n+        llresult: &'ll Value,\n+        span: Span,\n+    ) {\n+        let tcx = self.cx().tcx;\n \n-    let (def_id, substs) = match callee_ty.sty {\n-        ty::FnDef(def_id, substs) => (def_id, substs),\n-        _ => bug!(\"expected fn item type, found {}\", callee_ty)\n-    };\n+        let (def_id, substs) = match callee_ty.sty {\n+            ty::FnDef(def_id, substs) => (def_id, substs),\n+            _ => bug!(\"expected fn item type, found {}\", callee_ty)\n+        };\n \n-    let sig = callee_ty.fn_sig(tcx);\n-    let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-    let arg_tys = sig.inputs();\n-    let ret_ty = sig.output();\n-    let name = &*tcx.item_name(def_id).as_str();\n-\n-    let llret_ty = cx.layout_of(ret_ty).llvm_type(cx);\n-    let result = PlaceRef::new_sized(llresult, fn_ty.ret.layout, fn_ty.ret.layout.align);\n-\n-    let simple = get_simple_intrinsic(cx, name);\n-    let llval = match name {\n-        _ if simple.is_some() => {\n-            bx.call(simple.unwrap(),\n-                    &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n-                    None)\n-        }\n-        \"unreachable\" => {\n-            return;\n-        },\n-        \"likely\" => {\n-            let expect = cx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bx.call(expect, &[args[0].immediate(), C_bool(cx, true)], None)\n-        }\n-        \"unlikely\" => {\n-            let expect = cx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bx.call(expect, &[args[0].immediate(), C_bool(cx, false)], None)\n-        }\n-        \"try\" => {\n-            try_intrinsic(bx, cx,\n-                          args[0].immediate(),\n-                          args[1].immediate(),\n-                          args[2].immediate(),\n-                          llresult);\n-            return;\n-        }\n-        \"breakpoint\" => {\n-            let llfn = cx.get_intrinsic(&(\"llvm.debugtrap\"));\n-            bx.call(llfn, &[], None)\n-        }\n-        \"size_of\" => {\n-            let tp_ty = substs.type_at(0);\n-            C_usize(cx, cx.size_of(tp_ty).bytes())\n-        }\n-        \"size_of_val\" => {\n-            let tp_ty = substs.type_at(0);\n-            if let OperandValue::Pair(_, meta) = args[0].val {\n-                let (llsize, _) =\n-                    glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n-                llsize\n-            } else {\n-                C_usize(cx, cx.size_of(tp_ty).bytes())\n+        let sig = callee_ty.fn_sig(tcx);\n+        let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+        let arg_tys = sig.inputs();\n+        let ret_ty = sig.output();\n+        let name = &*tcx.item_name(def_id).as_str();\n+\n+        let llret_ty = self.cx().layout_of(ret_ty).llvm_type(self.cx());\n+        let result = PlaceRef::new_sized(llresult, fn_ty.ret.layout, fn_ty.ret.layout.align);\n+\n+        let simple = get_simple_intrinsic(self.cx(), name);\n+        let llval = match name {\n+            _ if simple.is_some() => {\n+                self.call(simple.unwrap(),\n+                        &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n+                        None)\n             }\n-        }\n-        \"min_align_of\" => {\n-            let tp_ty = substs.type_at(0);\n-            C_usize(cx, cx.align_of(tp_ty).abi())\n-        }\n-        \"min_align_of_val\" => {\n-            let tp_ty = substs.type_at(0);\n-            if let OperandValue::Pair(_, meta) = args[0].val {\n-                let (_, llalign) =\n-                    glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n-                llalign\n-            } else {\n-                C_usize(cx, cx.align_of(tp_ty).abi())\n+            \"unreachable\" => {\n+                return;\n+            },\n+            \"likely\" => {\n+                let expect = self.cx().get_intrinsic(&(\"llvm.expect.i1\"));\n+                self.call(expect, &[args[0].immediate(), self.cx().const_bool(true)], None)\n             }\n-        }\n-        \"pref_align_of\" => {\n-            let tp_ty = substs.type_at(0);\n-            C_usize(cx, cx.align_of(tp_ty).pref())\n-        }\n-        \"type_name\" => {\n-            let tp_ty = substs.type_at(0);\n-            let ty_name = Symbol::intern(&tp_ty.to_string()).as_str();\n-            C_str_slice(cx, ty_name)\n-        }\n-        \"type_id\" => {\n-            C_u64(cx, cx.tcx.type_id_hash(substs.type_at(0)))\n-        }\n-        \"init\" => {\n-            let ty = substs.type_at(0);\n-            if !cx.layout_of(ty).is_zst() {\n-                // Just zero out the stack slot.\n-                // If we store a zero constant, LLVM will drown in vreg allocation for large data\n-                // structures, and the generated code will be awful. (A telltale sign of this is\n-                // large quantities of `mov [byte ptr foo],0` in the generated code.)\n-                memset_intrinsic(bx, false, ty, llresult, C_u8(cx, 0), C_usize(cx, 1));\n+            \"unlikely\" => {\n+                let expect = self.cx().get_intrinsic(&(\"llvm.expect.i1\"));\n+                self.call(expect, &[args[0].immediate(), self.cx().const_bool(false)], None)\n             }\n-            return;\n-        }\n-        // Effectively no-ops\n-        \"uninit\" | \"forget\" => {\n-            return;\n-        }\n-        \"needs_drop\" => {\n-            let tp_ty = substs.type_at(0);\n-\n-            C_bool(cx, bx.cx.type_needs_drop(tp_ty))\n-        }\n-        \"offset\" => {\n-            let ptr = args[0].immediate();\n-            let offset = args[1].immediate();\n-            bx.inbounds_gep(ptr, &[offset])\n-        }\n-        \"arith_offset\" => {\n-            let ptr = args[0].immediate();\n-            let offset = args[1].immediate();\n-            bx.gep(ptr, &[offset])\n-        }\n-\n-        \"copy_nonoverlapping\" => {\n-            copy_intrinsic(bx, false, false, substs.type_at(0),\n-                           args[1].immediate(), args[0].immediate(), args[2].immediate())\n-        }\n-        \"copy\" => {\n-            copy_intrinsic(bx, true, false, substs.type_at(0),\n-                           args[1].immediate(), args[0].immediate(), args[2].immediate())\n-        }\n-        \"write_bytes\" => {\n-            memset_intrinsic(bx, false, substs.type_at(0),\n-                             args[0].immediate(), args[1].immediate(), args[2].immediate())\n-        }\n-\n-        \"volatile_copy_nonoverlapping_memory\" => {\n-            copy_intrinsic(bx, false, true, substs.type_at(0),\n-                           args[0].immediate(), args[1].immediate(), args[2].immediate())\n-        }\n-        \"volatile_copy_memory\" => {\n-            copy_intrinsic(bx, true, true, substs.type_at(0),\n-                           args[0].immediate(), args[1].immediate(), args[2].immediate())\n-        }\n-        \"volatile_set_memory\" => {\n-            memset_intrinsic(bx, true, substs.type_at(0),\n-                             args[0].immediate(), args[1].immediate(), args[2].immediate())\n-        }\n-        \"volatile_load\" | \"unaligned_volatile_load\" => {\n-            let tp_ty = substs.type_at(0);\n-            let mut ptr = args[0].immediate();\n-            if let PassMode::Cast(ty) = fn_ty.ret.mode {\n-                ptr = bx.pointercast(ptr, ty.llvm_type(cx).ptr_to());\n+            \"try\" => {\n+                try_intrinsic(self,\n+                              args[0].immediate(),\n+                              args[1].immediate(),\n+                              args[2].immediate(),\n+                              llresult);\n+                return;\n             }\n-            let load = bx.volatile_load(ptr);\n-            let align = if name == \"unaligned_volatile_load\" {\n-                1\n-            } else {\n-                cx.align_of(tp_ty).abi() as u32\n-            };\n-            unsafe {\n-                llvm::LLVMSetAlignment(load, align);\n+            \"breakpoint\" => {\n+                let llfn = self.cx().get_intrinsic(&(\"llvm.debugtrap\"));\n+                self.call(llfn, &[], None)\n             }\n-            to_immediate(bx, load, cx.layout_of(tp_ty))\n-        },\n-        \"volatile_store\" => {\n-            let dst = args[0].deref(bx.cx);\n-            args[1].val.volatile_store(bx, dst);\n-            return;\n-        },\n-        \"unaligned_volatile_store\" => {\n-            let dst = args[0].deref(bx.cx);\n-            args[1].val.unaligned_volatile_store(bx, dst);\n-            return;\n-        },\n-        \"prefetch_read_data\" | \"prefetch_write_data\" |\n-        \"prefetch_read_instruction\" | \"prefetch_write_instruction\" => {\n-            let expect = cx.get_intrinsic(&(\"llvm.prefetch\"));\n-            let (rw, cache_type) = match name {\n-                \"prefetch_read_data\" => (0, 1),\n-                \"prefetch_write_data\" => (1, 1),\n-                \"prefetch_read_instruction\" => (0, 0),\n-                \"prefetch_write_instruction\" => (1, 0),\n-                _ => bug!()\n-            };\n-            bx.call(expect, &[\n-                args[0].immediate(),\n-                C_i32(cx, rw),\n-                args[1].immediate(),\n-                C_i32(cx, cache_type)\n-            ], None)\n-        },\n-        \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n-        \"bitreverse\" | \"add_with_overflow\" | \"sub_with_overflow\" |\n-        \"mul_with_overflow\" | \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n-        \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" | \"exact_div\" |\n-        \"rotate_left\" | \"rotate_right\" => {\n-            let ty = arg_tys[0];\n-            match int_type_width_signed(ty, cx) {\n-                Some((width, signed)) =>\n-                    match name {\n-                        \"ctlz\" | \"cttz\" => {\n-                            let y = C_bool(bx.cx, false);\n-                            let llfn = cx.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n-                            bx.call(llfn, &[args[0].immediate(), y], None)\n-                        }\n-                        \"ctlz_nonzero\" | \"cttz_nonzero\" => {\n-                            let y = C_bool(bx.cx, true);\n-                            let llvm_name = &format!(\"llvm.{}.i{}\", &name[..4], width);\n-                            let llfn = cx.get_intrinsic(llvm_name);\n-                            bx.call(llfn, &[args[0].immediate(), y], None)\n-                        }\n-                        \"ctpop\" => bx.call(cx.get_intrinsic(&format!(\"llvm.ctpop.i{}\", width)),\n-                                        &[args[0].immediate()], None),\n-                        \"bswap\" => {\n-                            if width == 8 {\n-                                args[0].immediate() // byte swap a u8/i8 is just a no-op\n-                            } else {\n-                                bx.call(cx.get_intrinsic(&format!(\"llvm.bswap.i{}\", width)),\n-                                        &[args[0].immediate()], None)\n-                            }\n-                        }\n-                        \"bitreverse\" => {\n-                            bx.call(cx.get_intrinsic(&format!(\"llvm.bitreverse.i{}\", width)),\n-                                &[args[0].immediate()], None)\n-                        }\n-                        \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" => {\n-                            let intrinsic = format!(\"llvm.{}{}.with.overflow.i{}\",\n-                                                    if signed { 's' } else { 'u' },\n-                                                    &name[..3], width);\n-                            let llfn = bx.cx.get_intrinsic(&intrinsic);\n-\n-                            // Convert `i1` to a `bool`, and write it to the out parameter\n-                            let pair = bx.call(llfn, &[\n-                                args[0].immediate(),\n-                                args[1].immediate()\n-                            ], None);\n-                            let val = bx.extract_value(pair, 0);\n-                            let overflow = bx.zext(bx.extract_value(pair, 1), Type::bool(cx));\n-\n-                            let dest = result.project_field(bx, 0);\n-                            bx.store(val, dest.llval, dest.align);\n-                            let dest = result.project_field(bx, 1);\n-                            bx.store(overflow, dest.llval, dest.align);\n-\n-                            return;\n-                        },\n-                        \"overflowing_add\" => bx.add(args[0].immediate(), args[1].immediate()),\n-                        \"overflowing_sub\" => bx.sub(args[0].immediate(), args[1].immediate()),\n-                        \"overflowing_mul\" => bx.mul(args[0].immediate(), args[1].immediate()),\n-                        \"exact_div\" =>\n-                            if signed {\n-                                bx.exactsdiv(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                bx.exactudiv(args[0].immediate(), args[1].immediate())\n-                            },\n-                        \"unchecked_div\" =>\n-                            if signed {\n-                                bx.sdiv(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                bx.udiv(args[0].immediate(), args[1].immediate())\n-                            },\n-                        \"unchecked_rem\" =>\n-                            if signed {\n-                                bx.srem(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                bx.urem(args[0].immediate(), args[1].immediate())\n-                            },\n-                        \"unchecked_shl\" => bx.shl(args[0].immediate(), args[1].immediate()),\n-                        \"unchecked_shr\" =>\n-                            if signed {\n-                                bx.ashr(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                bx.lshr(args[0].immediate(), args[1].immediate())\n-                            },\n-                        \"rotate_left\" | \"rotate_right\" => {\n-                            let is_left = name == \"rotate_left\";\n-                            let val = args[0].immediate();\n-                            let raw_shift = args[1].immediate();\n-                            if llvm_util::get_major_version() >= 7 {\n-                                // rotate = funnel shift with first two args the same\n-                                let llvm_name = &format!(\"llvm.fsh{}.i{}\",\n-                                                         if is_left { 'l' } else { 'r' }, width);\n-                                let llfn = cx.get_intrinsic(llvm_name);\n-                                bx.call(llfn, &[val, val, raw_shift], None)\n-                            } else {\n-                                // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n-                                // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n-                                let width = C_uint(Type::ix(cx, width), width);\n-                                let shift = bx.urem(raw_shift, width);\n-                                let inv_shift = bx.urem(bx.sub(width, raw_shift), width);\n-                                let shift1 = bx.shl(val, if is_left { shift } else { inv_shift });\n-                                let shift2 = bx.lshr(val, if !is_left { shift } else { inv_shift });\n-                                bx.or(shift1, shift2)\n-                            }\n-                        },\n-                        _ => bug!(),\n-                    },\n-                None => {\n-                    span_invalid_monomorphization_error(\n-                        tcx.sess, span,\n-                        &format!(\"invalid monomorphization of `{}` intrinsic: \\\n-                                  expected basic integer type, found `{}`\", name, ty));\n-                    return;\n+            \"size_of\" => {\n+                let tp_ty = substs.type_at(0);\n+                self.cx().const_usize(self.cx().size_of(tp_ty).bytes())\n+            }\n+            \"size_of_val\" => {\n+                let tp_ty = substs.type_at(0);\n+                if let OperandValue::Pair(_, meta) = args[0].val {\n+                    let (llsize, _) =\n+                        glue::size_and_align_of_dst(self, tp_ty, Some(meta));\n+                    llsize\n+                } else {\n+                    self.cx().const_usize(self.cx().size_of(tp_ty).bytes())\n                 }\n             }\n-        },\n-        \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n-            let sty = &arg_tys[0].sty;\n-            match float_type_width(sty) {\n-                Some(_width) =>\n-                    match name {\n-                        \"fadd_fast\" => bx.fadd_fast(args[0].immediate(), args[1].immediate()),\n-                        \"fsub_fast\" => bx.fsub_fast(args[0].immediate(), args[1].immediate()),\n-                        \"fmul_fast\" => bx.fmul_fast(args[0].immediate(), args[1].immediate()),\n-                        \"fdiv_fast\" => bx.fdiv_fast(args[0].immediate(), args[1].immediate()),\n-                        \"frem_fast\" => bx.frem_fast(args[0].immediate(), args[1].immediate()),\n-                        _ => bug!(),\n-                    },\n-                None => {\n-                    span_invalid_monomorphization_error(\n-                        tcx.sess, span,\n-                        &format!(\"invalid monomorphization of `{}` intrinsic: \\\n-                                  expected basic float type, found `{}`\", name, sty));\n-                    return;\n+            \"min_align_of\" => {\n+                let tp_ty = substs.type_at(0);\n+                self.cx().const_usize(self.cx().align_of(tp_ty).abi())\n+            }\n+            \"min_align_of_val\" => {\n+                let tp_ty = substs.type_at(0);\n+                if let OperandValue::Pair(_, meta) = args[0].val {\n+                    let (_, llalign) =\n+                        glue::size_and_align_of_dst(self, tp_ty, Some(meta));\n+                    llalign\n+                } else {\n+                    self.cx().const_usize(self.cx().align_of(tp_ty).abi())\n                 }\n             }\n+            \"pref_align_of\" => {\n+                let tp_ty = substs.type_at(0);\n+                self.cx().const_usize(self.cx().align_of(tp_ty).pref())\n+            }\n+            \"type_name\" => {\n+                let tp_ty = substs.type_at(0);\n+                let ty_name = Symbol::intern(&tp_ty.to_string()).as_str();\n+                self.cx().const_str_slice(ty_name)\n+            }\n+            \"type_id\" => {\n+                self.cx().const_u64(self.cx().tcx.type_id_hash(substs.type_at(0)))\n+            }\n+            \"init\" => {\n+                let ty = substs.type_at(0);\n+                if !self.cx().layout_of(ty).is_zst() {\n+                    // Just zero out the stack slot.\n+                    // If we store a zero constant, LLVM will drown in vreg allocation for large\n+                    // data structures, and the generated code will be awful. (A telltale sign of\n+                    // this is large quantities of `mov [byte ptr foo],0` in the generated code.)\n+                    memset_intrinsic(\n+                        self,\n+                        false,\n+                        ty,\n+                        llresult,\n+                        self.cx().const_u8(0),\n+                        self.cx().const_usize(1)\n+                    );\n+                }\n+                return;\n+            }\n+            // Effectively no-ops\n+            \"uninit\" | \"forget\" => {\n+                return;\n+            }\n+            \"needs_drop\" => {\n+                let tp_ty = substs.type_at(0);\n \n-        },\n-\n-        \"discriminant_value\" => {\n-            args[0].deref(bx.cx).codegen_get_discr(bx, ret_ty)\n-        }\n-\n-        name if name.starts_with(\"simd_\") => {\n-            match generic_simd_intrinsic(bx, name,\n-                                         callee_ty,\n-                                         args,\n-                                         ret_ty, llret_ty,\n-                                         span) {\n-                Ok(llval) => llval,\n-                Err(()) => return\n+                self.cx().const_bool(self.cx().type_needs_drop(tp_ty))\n+            }\n+            \"offset\" => {\n+                let ptr = args[0].immediate();\n+                let offset = args[1].immediate();\n+                self.inbounds_gep(ptr, &[offset])\n+            }\n+            \"arith_offset\" => {\n+                let ptr = args[0].immediate();\n+                let offset = args[1].immediate();\n+                self.gep(ptr, &[offset])\n             }\n-        }\n-        // This requires that atomic intrinsics follow a specific naming pattern:\n-        // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n-        name if name.starts_with(\"atomic_\") => {\n-            use llvm::AtomicOrdering::*;\n-\n-            let split: Vec<&str> = name.split('_').collect();\n-\n-            let is_cxchg = split[1] == \"cxchg\" || split[1] == \"cxchgweak\";\n-            let (order, failorder) = match split.len() {\n-                2 => (SequentiallyConsistent, SequentiallyConsistent),\n-                3 => match split[2] {\n-                    \"unordered\" => (Unordered, Unordered),\n-                    \"relaxed\" => (Monotonic, Monotonic),\n-                    \"acq\"     => (Acquire, Acquire),\n-                    \"rel\"     => (Release, Monotonic),\n-                    \"acqrel\"  => (AcquireRelease, Acquire),\n-                    \"failrelaxed\" if is_cxchg =>\n-                        (SequentiallyConsistent, Monotonic),\n-                    \"failacq\" if is_cxchg =>\n-                        (SequentiallyConsistent, Acquire),\n-                    _ => cx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n-                },\n-                4 => match (split[2], split[3]) {\n-                    (\"acq\", \"failrelaxed\") if is_cxchg =>\n-                        (Acquire, Monotonic),\n-                    (\"acqrel\", \"failrelaxed\") if is_cxchg =>\n-                        (AcquireRelease, Monotonic),\n-                    _ => cx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n-                },\n-                _ => cx.sess().fatal(\"Atomic intrinsic not in correct format\"),\n-            };\n \n-            let invalid_monomorphization = |ty| {\n-                span_invalid_monomorphization_error(tcx.sess, span,\n-                    &format!(\"invalid monomorphization of `{}` intrinsic: \\\n-                              expected basic integer type, found `{}`\", name, ty));\n-            };\n+            \"copy_nonoverlapping\" => {\n+                copy_intrinsic(self, false, false, substs.type_at(0),\n+                               args[1].immediate(), args[0].immediate(), args[2].immediate());\n+                return;\n+            }\n+            \"copy\" => {\n+                copy_intrinsic(self, true, false, substs.type_at(0),\n+                               args[1].immediate(), args[0].immediate(), args[2].immediate());\n+                return;\n+            }\n+            \"write_bytes\" => {\n+                memset_intrinsic(self, false, substs.type_at(0),\n+                                 args[0].immediate(), args[1].immediate(), args[2].immediate());\n+                return;\n+            }\n \n-            match split[1] {\n-                \"cxchg\" | \"cxchgweak\" => {\n-                    let ty = substs.type_at(0);\n-                    if int_type_width_signed(ty, cx).is_some() {\n-                        let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n-                        let pair = bx.atomic_cmpxchg(\n-                            args[0].immediate(),\n-                            args[1].immediate(),\n-                            args[2].immediate(),\n-                            order,\n-                            failorder,\n-                            weak);\n-                        let val = bx.extract_value(pair, 0);\n-                        let success = bx.zext(bx.extract_value(pair, 1), Type::bool(bx.cx));\n-\n-                        let dest = result.project_field(bx, 0);\n-                        bx.store(val, dest.llval, dest.align);\n-                        let dest = result.project_field(bx, 1);\n-                        bx.store(success, dest.llval, dest.align);\n-                        return;\n-                    } else {\n-                        return invalid_monomorphization(ty);\n-                    }\n+            \"volatile_copy_nonoverlapping_memory\" => {\n+                copy_intrinsic(self, false, true, substs.type_at(0),\n+                               args[0].immediate(), args[1].immediate(), args[2].immediate());\n+                return;\n+            }\n+            \"volatile_copy_memory\" => {\n+                copy_intrinsic(self, true, true, substs.type_at(0),\n+                               args[0].immediate(), args[1].immediate(), args[2].immediate());\n+                return;\n+            }\n+            \"volatile_set_memory\" => {\n+                memset_intrinsic(self, true, substs.type_at(0),\n+                                 args[0].immediate(), args[1].immediate(), args[2].immediate());\n+                return;\n+            }\n+            \"volatile_load\" | \"unaligned_volatile_load\" => {\n+                let tp_ty = substs.type_at(0);\n+                let mut ptr = args[0].immediate();\n+                if let PassMode::Cast(ty) = fn_ty.ret.mode {\n+                    ptr = self.pointercast(ptr, self.cx().type_ptr_to(ty.llvm_type(self.cx())));\n                 }\n-\n-                \"load\" => {\n-                    let ty = substs.type_at(0);\n-                    if int_type_width_signed(ty, cx).is_some() {\n-                        let size = cx.size_of(ty);\n-                        bx.atomic_load(args[0].immediate(), order, size)\n-                    } else {\n-                        return invalid_monomorphization(ty);\n+                let load = self.volatile_load(ptr);\n+                let align = if name == \"unaligned_volatile_load\" {\n+                    1\n+                } else {\n+                    self.cx().align_of(tp_ty).abi() as u32\n+                };\n+                unsafe {\n+                    llvm::LLVMSetAlignment(load, align);\n+                }\n+                to_immediate(self, load, self.cx().layout_of(tp_ty))\n+            },\n+            \"volatile_store\" => {\n+                let dst = args[0].deref(self.cx());\n+                args[1].val.volatile_store(self, dst);\n+                return;\n+            },\n+            \"unaligned_volatile_store\" => {\n+                let dst = args[0].deref(self.cx());\n+                args[1].val.unaligned_volatile_store(self, dst);\n+                return;\n+            },\n+            \"prefetch_read_data\" | \"prefetch_write_data\" |\n+            \"prefetch_read_instruction\" | \"prefetch_write_instruction\" => {\n+                let expect = self.cx().get_intrinsic(&(\"llvm.prefetch\"));\n+                let (rw, cache_type) = match name {\n+                    \"prefetch_read_data\" => (0, 1),\n+                    \"prefetch_write_data\" => (1, 1),\n+                    \"prefetch_read_instruction\" => (0, 0),\n+                    \"prefetch_write_instruction\" => (1, 0),\n+                    _ => bug!()\n+                };\n+                self.call(expect, &[\n+                    args[0].immediate(),\n+                    self.cx().const_i32(rw),\n+                    args[1].immediate(),\n+                    self.cx().const_i32(cache_type)\n+                ], None)\n+            },\n+            \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n+            \"bitreverse\" | \"add_with_overflow\" | \"sub_with_overflow\" |\n+            \"mul_with_overflow\" | \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n+            \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" | \"exact_div\" |\n+            \"rotate_left\" | \"rotate_right\" => {\n+                let ty = arg_tys[0];\n+                match int_type_width_signed(ty, self.cx()) {\n+                    Some((width, signed)) =>\n+                        match name {\n+                            \"ctlz\" | \"cttz\" => {\n+                                let y = self.cx().const_bool(false);\n+                                let llfn = self.cx().get_intrinsic(\n+                                    &format!(\"llvm.{}.i{}\", name, width),\n+                                );\n+                                self.call(llfn, &[args[0].immediate(), y], None)\n+                            }\n+                            \"ctlz_nonzero\" | \"cttz_nonzero\" => {\n+                                let y = self.cx().const_bool(true);\n+                                let llvm_name = &format!(\"llvm.{}.i{}\", &name[..4], width);\n+                                let llfn = self.cx().get_intrinsic(llvm_name);\n+                                self.call(llfn, &[args[0].immediate(), y], None)\n+                            }\n+                            \"ctpop\" => self.call(\n+                                self.cx().get_intrinsic(&format!(\"llvm.ctpop.i{}\", width)),\n+                                &[args[0].immediate()],\n+                                None\n+                            ),\n+                            \"bswap\" => {\n+                                if width == 8 {\n+                                    args[0].immediate() // byte swap a u8/i8 is just a no-op\n+                                } else {\n+                                    self.call(\n+                                        self.cx().get_intrinsic(\n+                                            &format!(\"llvm.bswap.i{}\", width),\n+                                        ),\n+                                        &[args[0].immediate()],\n+                                        None,\n+                                    )\n+                                }\n+                            }\n+                            \"bitreverse\" => {\n+                                self.call(\n+                                    self.cx().get_intrinsic(\n+                                        &format!(\"llvm.bitreverse.i{}\", width),\n+                                    ),\n+                                    &[args[0].immediate()],\n+                                    None,\n+                                )\n+                            }\n+                            \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" => {\n+                                let intrinsic = format!(\"llvm.{}{}.with.overflow.i{}\",\n+                                                        if signed { 's' } else { 'u' },\n+                                                        &name[..3], width);\n+                                let llfn = self.cx().get_intrinsic(&intrinsic);\n+\n+                                // Convert `i1` to a `bool`, and write it to the out parameter\n+                                let pair = self.call(llfn, &[\n+                                    args[0].immediate(),\n+                                    args[1].immediate()\n+                                ], None);\n+                                let val = self.extract_value(pair, 0);\n+                                let overflow = self.extract_value(pair, 1);\n+                                let overflow = self.zext(overflow, self.cx().type_bool());\n+\n+                                let dest = result.project_field(self, 0);\n+                                self.store(val, dest.llval, dest.align);\n+                                let dest = result.project_field(self, 1);\n+                                self.store(overflow, dest.llval, dest.align);\n+\n+                                return;\n+                            },\n+                            \"overflowing_add\" => self.add(args[0].immediate(), args[1].immediate()),\n+                            \"overflowing_sub\" => self.sub(args[0].immediate(), args[1].immediate()),\n+                            \"overflowing_mul\" => self.mul(args[0].immediate(), args[1].immediate()),\n+                            \"exact_div\" =>\n+                                if signed {\n+                                    self.exactsdiv(args[0].immediate(), args[1].immediate())\n+                                } else {\n+                                    self.exactudiv(args[0].immediate(), args[1].immediate())\n+                                },\n+                            \"unchecked_div\" =>\n+                                if signed {\n+                                    self.sdiv(args[0].immediate(), args[1].immediate())\n+                                } else {\n+                                    self.udiv(args[0].immediate(), args[1].immediate())\n+                                },\n+                            \"unchecked_rem\" =>\n+                                if signed {\n+                                    self.srem(args[0].immediate(), args[1].immediate())\n+                                } else {\n+                                    self.urem(args[0].immediate(), args[1].immediate())\n+                                },\n+                            \"unchecked_shl\" => self.shl(args[0].immediate(), args[1].immediate()),\n+                            \"unchecked_shr\" =>\n+                                if signed {\n+                                    self.ashr(args[0].immediate(), args[1].immediate())\n+                                } else {\n+                                    self.lshr(args[0].immediate(), args[1].immediate())\n+                                },\n+                            \"rotate_left\" | \"rotate_right\" => {\n+                                let is_left = name == \"rotate_left\";\n+                                let val = args[0].immediate();\n+                                let raw_shift = args[1].immediate();\n+                                if llvm_util::get_major_version() >= 7 {\n+                                    // rotate = funnel shift with first two args the same\n+                                    let llvm_name = &format!(\"llvm.fsh{}.i{}\",\n+                                                            if is_left { 'l' } else { 'r' }, width);\n+                                    let llfn = self.cx().get_intrinsic(llvm_name);\n+                                    self.call(llfn, &[val, val, raw_shift], None)\n+                                } else {\n+                                    // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n+                                    // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n+                                    let width = self.cx().const_uint(\n+                                        self.cx().type_ix(width),\n+                                        width,\n+                                    );\n+                                    let shift = self.urem(raw_shift, width);\n+                                    let width_minus_raw_shift = self.sub(width, raw_shift);\n+                                    let inv_shift = self.urem(width_minus_raw_shift, width);\n+                                    let shift1 = self.shl(\n+                                        val,\n+                                        if is_left { shift } else { inv_shift },\n+                                    );\n+                                    let shift2 = self.lshr(\n+                                        val,\n+                                        if !is_left { shift } else { inv_shift },\n+                                    );\n+                                    self.or(shift1, shift2)\n+                                }\n+                            },\n+                            _ => bug!(),\n+                        },\n+                    None => {\n+                        span_invalid_monomorphization_error(\n+                            tcx.sess, span,\n+                            &format!(\"invalid monomorphization of `{}` intrinsic: \\\n+                                      expected basic integer type, found `{}`\", name, ty));\n+                        return;\n                     }\n                 }\n \n-                \"store\" => {\n-                    let ty = substs.type_at(0);\n-                    if int_type_width_signed(ty, cx).is_some() {\n-                        let size = cx.size_of(ty);\n-                        bx.atomic_store(args[1].immediate(), args[0].immediate(), order, size);\n+            },\n+            \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n+                let sty = &arg_tys[0].sty;\n+                match float_type_width(sty) {\n+                    Some(_width) =>\n+                        match name {\n+                            \"fadd_fast\" => self.fadd_fast(args[0].immediate(), args[1].immediate()),\n+                            \"fsub_fast\" => self.fsub_fast(args[0].immediate(), args[1].immediate()),\n+                            \"fmul_fast\" => self.fmul_fast(args[0].immediate(), args[1].immediate()),\n+                            \"fdiv_fast\" => self.fdiv_fast(args[0].immediate(), args[1].immediate()),\n+                            \"frem_fast\" => self.frem_fast(args[0].immediate(), args[1].immediate()),\n+                            _ => bug!(),\n+                        },\n+                    None => {\n+                        span_invalid_monomorphization_error(\n+                            tcx.sess, span,\n+                            &format!(\"invalid monomorphization of `{}` intrinsic: \\\n+                                      expected basic float type, found `{}`\", name, sty));\n                         return;\n-                    } else {\n-                        return invalid_monomorphization(ty);\n                     }\n                 }\n \n-                \"fence\" => {\n-                    bx.atomic_fence(order, llvm::SynchronizationScope::CrossThread);\n-                    return;\n-                }\n+            },\n \n-                \"singlethreadfence\" => {\n-                    bx.atomic_fence(order, llvm::SynchronizationScope::SingleThread);\n-                    return;\n-                }\n+            \"discriminant_value\" => {\n+                args[0].deref(self.cx()).codegen_get_discr(self, ret_ty)\n+            }\n \n-                // These are all AtomicRMW ops\n-                op => {\n-                    let atom_op = match op {\n-                        \"xchg\"  => llvm::AtomicXchg,\n-                        \"xadd\"  => llvm::AtomicAdd,\n-                        \"xsub\"  => llvm::AtomicSub,\n-                        \"and\"   => llvm::AtomicAnd,\n-                        \"nand\"  => llvm::AtomicNand,\n-                        \"or\"    => llvm::AtomicOr,\n-                        \"xor\"   => llvm::AtomicXor,\n-                        \"max\"   => llvm::AtomicMax,\n-                        \"min\"   => llvm::AtomicMin,\n-                        \"umax\"  => llvm::AtomicUMax,\n-                        \"umin\"  => llvm::AtomicUMin,\n-                        _ => cx.sess().fatal(\"unknown atomic operation\")\n-                    };\n-\n-                    let ty = substs.type_at(0);\n-                    if int_type_width_signed(ty, cx).is_some() {\n-                        bx.atomic_rmw(atom_op, args[0].immediate(), args[1].immediate(), order)\n-                    } else {\n-                        return invalid_monomorphization(ty);\n-                    }\n+            name if name.starts_with(\"simd_\") => {\n+                match generic_simd_intrinsic(self, name,\n+                                             callee_ty,\n+                                             args,\n+                                             ret_ty, llret_ty,\n+                                             span) {\n+                    Ok(llval) => llval,\n+                    Err(()) => return\n                 }\n             }\n-        }\n-\n-        \"nontemporal_store\" => {\n-            let dst = args[0].deref(bx.cx);\n-            args[1].val.nontemporal_store(bx, dst);\n-            return;\n-        }\n+            // This requires that atomic intrinsics follow a specific naming pattern:\n+            // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n+            name if name.starts_with(\"atomic_\") => {\n+                use rustc_codegen_ssa::common::AtomicOrdering::*;\n+                use rustc_codegen_ssa::common::\n+                    {SynchronizationScope, AtomicRmwBinOp};\n+\n+                let split: Vec<&str> = name.split('_').collect();\n+\n+                let is_cxchg = split[1] == \"cxchg\" || split[1] == \"cxchgweak\";\n+                let (order, failorder) = match split.len() {\n+                    2 => (SequentiallyConsistent, SequentiallyConsistent),\n+                    3 => match split[2] {\n+                        \"unordered\" => (Unordered, Unordered),\n+                        \"relaxed\" => (Monotonic, Monotonic),\n+                        \"acq\"     => (Acquire, Acquire),\n+                        \"rel\"     => (Release, Monotonic),\n+                        \"acqrel\"  => (AcquireRelease, Acquire),\n+                        \"failrelaxed\" if is_cxchg =>\n+                            (SequentiallyConsistent, Monotonic),\n+                        \"failacq\" if is_cxchg =>\n+                            (SequentiallyConsistent, Acquire),\n+                        _ => self.cx().sess().fatal(\"unknown ordering in atomic intrinsic\")\n+                    },\n+                    4 => match (split[2], split[3]) {\n+                        (\"acq\", \"failrelaxed\") if is_cxchg =>\n+                            (Acquire, Monotonic),\n+                        (\"acqrel\", \"failrelaxed\") if is_cxchg =>\n+                            (AcquireRelease, Monotonic),\n+                        _ => self.cx().sess().fatal(\"unknown ordering in atomic intrinsic\")\n+                    },\n+                    _ => self.cx().sess().fatal(\"Atomic intrinsic not in correct format\"),\n+                };\n \n-        _ => {\n-            let intr = Intrinsic::find(&name).unwrap_or_else(||\n-                bug!(\"unknown intrinsic '{}'\", name));\n+                let invalid_monomorphization = |ty| {\n+                    span_invalid_monomorphization_error(tcx.sess, span,\n+                        &format!(\"invalid monomorphization of `{}` intrinsic: \\\n+                                  expected basic integer type, found `{}`\", name, ty));\n+                };\n \n-            fn one<T>(x: Vec<T>) -> T {\n-                assert_eq!(x.len(), 1);\n-                x.into_iter().next().unwrap()\n-            }\n-            fn ty_to_type(cx: &CodegenCx<'ll, '_>, t: &intrinsics::Type) -> Vec<&'ll Type> {\n-                use intrinsics::Type::*;\n-                match *t {\n-                    Void => vec![Type::void(cx)],\n-                    Integer(_signed, _width, llvm_width) => {\n-                        vec![Type::ix(cx, llvm_width as u64)]\n+                match split[1] {\n+                    \"cxchg\" | \"cxchgweak\" => {\n+                        let ty = substs.type_at(0);\n+                        if int_type_width_signed(ty, self.cx()).is_some() {\n+                            let weak = split[1] == \"cxchgweak\";\n+                            let pair = self.atomic_cmpxchg(\n+                                args[0].immediate(),\n+                                args[1].immediate(),\n+                                args[2].immediate(),\n+                                order,\n+                                failorder,\n+                                weak);\n+                            let val = self.extract_value(pair, 0);\n+                            let success = self.extract_value(pair, 1);\n+                            let success = self.zext(success, self.cx().type_bool());\n+\n+                            let dest = result.project_field(self, 0);\n+                            self.store(val, dest.llval, dest.align);\n+                            let dest = result.project_field(self, 1);\n+                            self.store(success, dest.llval, dest.align);\n+                            return;\n+                        } else {\n+                            return invalid_monomorphization(ty);\n+                        }\n                     }\n-                    Float(x) => {\n-                        match x {\n-                            32 => vec![Type::f32(cx)],\n-                            64 => vec![Type::f64(cx)],\n-                            _ => bug!()\n+\n+                    \"load\" => {\n+                        let ty = substs.type_at(0);\n+                        if int_type_width_signed(ty, self.cx()).is_some() {\n+                            let size = self.cx().size_of(ty);\n+                            self.atomic_load(args[0].immediate(), order, size)\n+                        } else {\n+                            return invalid_monomorphization(ty);\n                         }\n                     }\n-                    Pointer(ref t, ref llvm_elem, _const) => {\n-                        let t = llvm_elem.as_ref().unwrap_or(t);\n-                        let elem = one(ty_to_type(cx, t));\n-                        vec![elem.ptr_to()]\n+\n+                    \"store\" => {\n+                        let ty = substs.type_at(0);\n+                        if int_type_width_signed(ty, self.cx()).is_some() {\n+                            let size = self.cx().size_of(ty);\n+                            self.atomic_store(\n+                                args[1].immediate(),\n+                                args[0].immediate(),\n+                                order,\n+                                size\n+                            );\n+                            return;\n+                        } else {\n+                            return invalid_monomorphization(ty);\n+                        }\n                     }\n-                    Vector(ref t, ref llvm_elem, length) => {\n-                        let t = llvm_elem.as_ref().unwrap_or(t);\n-                        let elem = one(ty_to_type(cx, t));\n-                        vec![Type::vector(elem, length as u64)]\n+\n+                    \"fence\" => {\n+                        self.atomic_fence(order, SynchronizationScope::CrossThread);\n+                        return;\n                     }\n-                    Aggregate(false, ref contents) => {\n-                        let elems = contents.iter()\n-                                            .map(|t| one(ty_to_type(cx, t)))\n-                                            .collect::<Vec<_>>();\n-                        vec![Type::struct_(cx, &elems, false)]\n+\n+                    \"singlethreadfence\" => {\n+                        self.atomic_fence(order, SynchronizationScope::SingleThread);\n+                        return;\n                     }\n-                    Aggregate(true, ref contents) => {\n-                        contents.iter()\n-                                .flat_map(|t| ty_to_type(cx, t))\n-                                .collect()\n+\n+                    // These are all AtomicRMW ops\n+                    op => {\n+                        let atom_op = match op {\n+                            \"xchg\"  => AtomicRmwBinOp::AtomicXchg,\n+                            \"xadd\"  => AtomicRmwBinOp::AtomicAdd,\n+                            \"xsub\"  => AtomicRmwBinOp::AtomicSub,\n+                            \"and\"   => AtomicRmwBinOp::AtomicAnd,\n+                            \"nand\"  => AtomicRmwBinOp::AtomicNand,\n+                            \"or\"    => AtomicRmwBinOp::AtomicOr,\n+                            \"xor\"   => AtomicRmwBinOp::AtomicXor,\n+                            \"max\"   => AtomicRmwBinOp::AtomicMax,\n+                            \"min\"   => AtomicRmwBinOp::AtomicMin,\n+                            \"umax\"  => AtomicRmwBinOp::AtomicUMax,\n+                            \"umin\"  => AtomicRmwBinOp::AtomicUMin,\n+                            _ => self.cx().sess().fatal(\"unknown atomic operation\")\n+                        };\n+\n+                        let ty = substs.type_at(0);\n+                        if int_type_width_signed(ty, self.cx()).is_some() {\n+                            self.atomic_rmw(\n+                                atom_op,\n+                                args[0].immediate(),\n+                                args[1].immediate(),\n+                                order\n+                            )\n+                        } else {\n+                            return invalid_monomorphization(ty);\n+                        }\n                     }\n                 }\n             }\n \n-            // This allows an argument list like `foo, (bar, baz),\n-            // qux` to be converted into `foo, bar, baz, qux`, integer\n-            // arguments to be truncated as needed and pointers to be\n-            // cast.\n-            fn modify_as_needed(\n-                bx: &Builder<'a, 'll, 'tcx>,\n-                t: &intrinsics::Type,\n-                arg: &OperandRef<'ll, 'tcx>,\n-            ) -> Vec<&'ll Value> {\n-                match *t {\n-                    intrinsics::Type::Aggregate(true, ref contents) => {\n-                        // We found a tuple that needs squishing! So\n-                        // run over the tuple and load each field.\n-                        //\n-                        // This assumes the type is \"simple\", i.e. no\n-                        // destructors, and the contents are SIMD\n-                        // etc.\n-                        assert!(!bx.cx.type_needs_drop(arg.layout.ty));\n-                        let (ptr, align) = match arg.val {\n-                            OperandValue::Ref(ptr, None, align) => (ptr, align),\n-                            _ => bug!()\n-                        };\n-                        let arg = PlaceRef::new_sized(ptr, arg.layout, align);\n-                        (0..contents.len()).map(|i| {\n-                            arg.project_field(bx, i).load(bx).immediate()\n-                        }).collect()\n-                    }\n-                    intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n-                        let llvm_elem = one(ty_to_type(bx.cx, llvm_elem));\n-                        vec![bx.pointercast(arg.immediate(), llvm_elem.ptr_to())]\n-                    }\n-                    intrinsics::Type::Vector(_, Some(ref llvm_elem), length) => {\n-                        let llvm_elem = one(ty_to_type(bx.cx, llvm_elem));\n-                        vec![bx.bitcast(arg.immediate(), Type::vector(llvm_elem, length as u64))]\n+            \"nontemporal_store\" => {\n+                let dst = args[0].deref(self.cx());\n+                args[1].val.nontemporal_store(self, dst);\n+                return;\n+            }\n+\n+            _ => {\n+                let intr = match Intrinsic::find(&name) {\n+                    Some(intr) => intr,\n+                    None => bug!(\"unknown intrinsic '{}'\", name),\n+                };\n+                fn one<T>(x: Vec<T>) -> T {\n+                    assert_eq!(x.len(), 1);\n+                    x.into_iter().next().unwrap()\n+                }\n+                fn ty_to_type<'ll>(\n+                    cx: &CodegenCx<'ll, '_>,\n+                     t: &intrinsics::Type\n+                 ) -> Vec<&'ll Type> {\n+                    use intrinsics::Type::*;\n+                    match *t {\n+                        Void => vec![cx.type_void()],\n+                        Integer(_signed, _width, llvm_width) => {\n+                            vec![cx.type_ix( llvm_width as u64)]\n+                        }\n+                        Float(x) => {\n+                            match x {\n+                                32 => vec![cx.type_f32()],\n+                                64 => vec![cx.type_f64()],\n+                                _ => bug!()\n+                            }\n+                        }\n+                        Pointer(ref t, ref llvm_elem, _const) => {\n+                            let t = llvm_elem.as_ref().unwrap_or(t);\n+                            let elem = one(ty_to_type(cx, t));\n+                            vec![cx.type_ptr_to(elem)]\n+                        }\n+                        Vector(ref t, ref llvm_elem, length) => {\n+                            let t = llvm_elem.as_ref().unwrap_or(t);\n+                            let elem = one(ty_to_type(cx, t));\n+                            vec![cx.type_vector(elem, length as u64)]\n+                        }\n+                        Aggregate(false, ref contents) => {\n+                            let elems = contents.iter()\n+                                                .map(|t| one(ty_to_type(cx, t)))\n+                                                .collect::<Vec<_>>();\n+                            vec![cx.type_struct( &elems, false)]\n+                        }\n+                        Aggregate(true, ref contents) => {\n+                            contents.iter()\n+                                    .flat_map(|t| ty_to_type(cx, t))\n+                                    .collect()\n+                        }\n                     }\n-                    intrinsics::Type::Integer(_, width, llvm_width) if width != llvm_width => {\n-                        // the LLVM intrinsic uses a smaller integer\n-                        // size than the C intrinsic's signature, so\n-                        // we have to trim it down here.\n-                        vec![bx.trunc(arg.immediate(), Type::ix(bx.cx, llvm_width as u64))]\n+                }\n+\n+                // This allows an argument list like `foo, (bar, baz),\n+                // qux` to be converted into `foo, bar, baz, qux`, integer\n+                // arguments to be truncated as needed and pointers to be\n+                // cast.\n+                fn modify_as_needed<'ll, 'tcx>(\n+                    bx: &mut Builder<'_, 'll, 'tcx>,\n+                    t: &intrinsics::Type,\n+                    arg: &OperandRef<'tcx, &'ll Value>,\n+                ) -> Vec<&'ll Value> {\n+                    match *t {\n+                        intrinsics::Type::Aggregate(true, ref contents) => {\n+                            // We found a tuple that needs squishing! So\n+                            // run over the tuple and load each field.\n+                            //\n+                            // This assumes the type is \"simple\", i.e. no\n+                            // destructors, and the contents are SIMD\n+                            // etc.\n+                            assert!(!bx.cx().type_needs_drop(arg.layout.ty));\n+                            let (ptr, align) = match arg.val {\n+                                OperandValue::Ref(ptr, None, align) => (ptr, align),\n+                                _ => bug!()\n+                            };\n+                            let arg = PlaceRef::new_sized(ptr, arg.layout, align);\n+                            (0..contents.len()).map(|i| {\n+                                let field = arg.project_field(bx, i);\n+                                bx.load_operand(field).immediate()\n+                            }).collect()\n+                        }\n+                        intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n+                            let llvm_elem = one(ty_to_type(bx.cx(), llvm_elem));\n+                            vec![bx.pointercast(arg.immediate(), bx.cx().type_ptr_to(llvm_elem))]\n+                        }\n+                        intrinsics::Type::Vector(_, Some(ref llvm_elem), length) => {\n+                            let llvm_elem = one(ty_to_type(bx.cx(), llvm_elem));\n+                            vec![\n+                                bx.bitcast(arg.immediate(),\n+                                bx.cx().type_vector(llvm_elem, length as u64))\n+                            ]\n+                        }\n+                        intrinsics::Type::Integer(_, width, llvm_width) if width != llvm_width => {\n+                            // the LLVM intrinsic uses a smaller integer\n+                            // size than the C intrinsic's signature, so\n+                            // we have to trim it down here.\n+                            vec![bx.trunc(arg.immediate(), bx.cx().type_ix(llvm_width as u64))]\n+                        }\n+                        _ => vec![arg.immediate()],\n                     }\n-                    _ => vec![arg.immediate()],\n                 }\n-            }\n \n \n-            let inputs = intr.inputs.iter()\n-                                    .flat_map(|t| ty_to_type(cx, t))\n-                                    .collect::<Vec<_>>();\n+                let inputs = intr.inputs.iter()\n+                                        .flat_map(|t| ty_to_type(self.cx(), t))\n+                                        .collect::<Vec<_>>();\n \n-            let outputs = one(ty_to_type(cx, &intr.output));\n+                let outputs = one(ty_to_type(self.cx(), &intr.output));\n \n-            let llargs: Vec<_> = intr.inputs.iter().zip(args).flat_map(|(t, arg)| {\n-                modify_as_needed(bx, t, arg)\n-            }).collect();\n-            assert_eq!(inputs.len(), llargs.len());\n+                let llargs: Vec<_> = intr.inputs.iter().zip(args).flat_map(|(t, arg)| {\n+                    modify_as_needed(self, t, arg)\n+                }).collect();\n+                assert_eq!(inputs.len(), llargs.len());\n \n-            let val = match intr.definition {\n-                intrinsics::IntrinsicDef::Named(name) => {\n-                    let f = declare::declare_cfn(cx,\n-                                                 name,\n-                                                 Type::func(&inputs, outputs));\n-                    bx.call(f, &llargs, None)\n-                }\n-            };\n+                let val = match intr.definition {\n+                    intrinsics::IntrinsicDef::Named(name) => {\n+                        let f = self.cx().declare_cfn(\n+                            name,\n+                            self.cx().type_func(&inputs, outputs),\n+                        );\n+                        self.call(f, &llargs, None)\n+                    }\n+                };\n \n-            match *intr.output {\n-                intrinsics::Type::Aggregate(flatten, ref elems) => {\n-                    // the output is a tuple so we need to munge it properly\n-                    assert!(!flatten);\n+                match *intr.output {\n+                    intrinsics::Type::Aggregate(flatten, ref elems) => {\n+                        // the output is a tuple so we need to munge it properly\n+                        assert!(!flatten);\n \n-                    for i in 0..elems.len() {\n-                        let dest = result.project_field(bx, i);\n-                        let val = bx.extract_value(val, i as u64);\n-                        bx.store(val, dest.llval, dest.align);\n+                        for i in 0..elems.len() {\n+                            let dest = result.project_field(self, i);\n+                            let val = self.extract_value(val, i as u64);\n+                            self.store(val, dest.llval, dest.align);\n+                        }\n+                        return;\n                     }\n-                    return;\n+                    _ => val,\n                 }\n-                _ => val,\n             }\n-        }\n-    };\n+        };\n \n-    if !fn_ty.ret.is_ignore() {\n-        if let PassMode::Cast(ty) = fn_ty.ret.mode {\n-            let ptr = bx.pointercast(result.llval, ty.llvm_type(cx).ptr_to());\n-            bx.store(llval, ptr, result.align);\n-        } else {\n-            OperandRef::from_immediate_or_packed_pair(bx, llval, result.layout)\n-                .val.store(bx, result);\n+        if !fn_ty.ret.is_ignore() {\n+            if let PassMode::Cast(ty) = fn_ty.ret.mode {\n+                let ptr_llty = self.cx().type_ptr_to(ty.llvm_type(self.cx()));\n+                let ptr = self.pointercast(result.llval, ptr_llty);\n+                self.store(llval, ptr, result.align);\n+            } else {\n+                OperandRef::from_immediate_or_packed_pair(self, llval, result.layout)\n+                    .val.store(self, result);\n+            }\n         }\n     }\n }\n \n fn copy_intrinsic(\n-    bx: &Builder<'a, 'll, 'tcx>,\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n     allow_overlap: bool,\n     volatile: bool,\n     ty: Ty<'tcx>,\n     dst: &'ll Value,\n     src: &'ll Value,\n     count: &'ll Value,\n-) -> &'ll Value {\n-    let cx = bx.cx;\n-    let (size, align) = cx.size_and_align_of(ty);\n-    let size = C_usize(cx, size.bytes());\n-    let align = align.abi();\n-    let dst_ptr = bx.pointercast(dst, Type::i8p(cx));\n-    let src_ptr = bx.pointercast(src, Type::i8p(cx));\n+) {\n+    let (size, align) = bx.cx().size_and_align_of(ty);\n+    let size = bx.mul(bx.cx().const_usize(size.bytes()), count);\n+    let flags = if volatile {\n+        MemFlags::VOLATILE\n+    } else {\n+        MemFlags::empty()\n+    };\n     if allow_overlap {\n-        bx.memmove(dst_ptr, align, src_ptr, align, bx.mul(size, count), volatile)\n+        bx.memmove(dst, align, src, align, size, flags);\n     } else {\n-        bx.memcpy(dst_ptr, align, src_ptr, align, bx.mul(size, count), volatile)\n+        bx.memcpy(dst, align, src, align, size, flags);\n     }\n }\n \n fn memset_intrinsic(\n-    bx: &Builder<'a, 'll, 'tcx>,\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n     volatile: bool,\n     ty: Ty<'tcx>,\n     dst: &'ll Value,\n     val: &'ll Value,\n     count: &'ll Value\n-) -> &'ll Value {\n-    let cx = bx.cx;\n-    let (size, align) = cx.size_and_align_of(ty);\n-    let size = C_usize(cx, size.bytes());\n-    let align = C_i32(cx, align.abi() as i32);\n-    let dst = bx.pointercast(dst, Type::i8p(cx));\n-    call_memset(bx, dst, val, bx.mul(size, count), align, volatile)\n+) {\n+    let (size, align) = bx.cx().size_and_align_of(ty);\n+    let size = bx.mul(bx.cx().const_usize(size.bytes()), count);\n+    let flags = if volatile {\n+        MemFlags::VOLATILE\n+    } else {\n+        MemFlags::empty()\n+    };\n+    bx.memset(dst, val, size, align, flags);\n }\n \n fn try_intrinsic(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    cx: &CodegenCx<'ll, 'tcx>,\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n     func: &'ll Value,\n     data: &'ll Value,\n     local_ptr: &'ll Value,\n     dest: &'ll Value,\n ) {\n-    if bx.sess().no_landing_pads() {\n+    if bx.cx().sess().no_landing_pads() {\n         bx.call(func, &[data], None);\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n-        bx.store(C_null(Type::i8p(&bx.cx)), dest, ptr_align);\n-    } else if wants_msvc_seh(bx.sess()) {\n-        codegen_msvc_try(bx, cx, func, data, local_ptr, dest);\n+        bx.store(bx.cx().const_null(bx.cx().type_i8p()), dest, ptr_align);\n+    } else if wants_msvc_seh(bx.cx().sess()) {\n+        codegen_msvc_try(bx, func, data, local_ptr, dest);\n     } else {\n-        codegen_gnu_try(bx, cx, func, data, local_ptr, dest);\n+        codegen_gnu_try(bx, func, data, local_ptr, dest);\n     }\n }\n \n@@ -766,22 +832,19 @@ fn try_intrinsic(\n // writing, however, LLVM does not recommend the usage of these new instructions\n // as the old ones are still more optimized.\n fn codegen_msvc_try(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    cx: &CodegenCx<'ll, 'tcx>,\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n     func: &'ll Value,\n     data: &'ll Value,\n     local_ptr: &'ll Value,\n     dest: &'ll Value,\n ) {\n-    let llfn = get_rust_try_fn(cx, &mut |bx| {\n-        let cx = bx.cx;\n+    let llfn = get_rust_try_fn(bx.cx(), &mut |mut bx| {\n+        bx.set_personality_fn(bx.cx().eh_personality());\n \n-        bx.set_personality_fn(bx.cx.eh_personality());\n-\n-        let normal = bx.build_sibling_block(\"normal\");\n-        let catchswitch = bx.build_sibling_block(\"catchswitch\");\n-        let catchpad = bx.build_sibling_block(\"catchpad\");\n-        let caught = bx.build_sibling_block(\"caught\");\n+        let mut normal = bx.build_sibling_block(\"normal\");\n+        let mut catchswitch = bx.build_sibling_block(\"catchswitch\");\n+        let mut catchpad = bx.build_sibling_block(\"catchpad\");\n+        let mut caught = bx.build_sibling_block(\"caught\");\n \n         let func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n@@ -826,34 +889,35 @@ fn codegen_msvc_try(\n         //      }\n         //\n         // More information can be found in libstd's seh.rs implementation.\n-        let i64p = Type::i64(cx).ptr_to();\n+        let i64p = bx.cx().type_ptr_to(bx.cx().type_i64());\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         let slot = bx.alloca(i64p, \"slot\", ptr_align);\n         bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n-        normal.ret(C_i32(cx, 0));\n+        normal.ret(bx.cx().const_i32(0));\n \n         let cs = catchswitch.catch_switch(None, None, 1);\n         catchswitch.add_handler(cs, catchpad.llbb());\n \n-        let tcx = cx.tcx;\n-        let tydesc = match tcx.lang_items().msvc_try_filter() {\n-            Some(did) => ::consts::get_static(cx, did),\n+        let tydesc = match bx.tcx().lang_items().msvc_try_filter() {\n+            Some(did) => bx.cx().get_static(did),\n             None => bug!(\"msvc_try_filter not defined\"),\n         };\n-        let tok = catchpad.catch_pad(cs, &[tydesc, C_i32(cx, 0), slot]);\n+        let funclet = catchpad.catch_pad(cs, &[tydesc, bx.cx().const_i32(0), slot]);\n         let addr = catchpad.load(slot, ptr_align);\n \n         let i64_align = bx.tcx().data_layout.i64_align;\n         let arg1 = catchpad.load(addr, i64_align);\n-        let val1 = C_i32(cx, 1);\n-        let arg2 = catchpad.load(catchpad.inbounds_gep(addr, &[val1]), i64_align);\n+        let val1 = bx.cx().const_i32(1);\n+        let gep1 = catchpad.inbounds_gep(addr, &[val1]);\n+        let arg2 = catchpad.load(gep1, i64_align);\n         let local_ptr = catchpad.bitcast(local_ptr, i64p);\n+        let gep2 = catchpad.inbounds_gep(local_ptr, &[val1]);\n         catchpad.store(arg1, local_ptr, i64_align);\n-        catchpad.store(arg2, catchpad.inbounds_gep(local_ptr, &[val1]), i64_align);\n-        catchpad.catch_ret(tok, caught.llbb());\n+        catchpad.store(arg2, gep2, i64_align);\n+        catchpad.catch_ret(&funclet, caught.llbb());\n \n-        caught.ret(C_i32(cx, 1));\n+        caught.ret(bx.cx().const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n@@ -875,16 +939,13 @@ fn codegen_msvc_try(\n // functions in play. By calling a shim we're guaranteed that our shim will have\n // the right personality function.\n fn codegen_gnu_try(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    cx: &CodegenCx<'ll, 'tcx>,\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n     func: &'ll Value,\n     data: &'ll Value,\n     local_ptr: &'ll Value,\n     dest: &'ll Value,\n ) {\n-    let llfn = get_rust_try_fn(cx, &mut |bx| {\n-        let cx = bx.cx;\n-\n+    let llfn = get_rust_try_fn(bx.cx(), &mut |mut bx| {\n         // Codegens the shims described above:\n         //\n         //   bx:\n@@ -902,28 +963,29 @@ fn codegen_gnu_try(\n         // expected to be `*mut *mut u8` for this to actually work, but that's\n         // managed by the standard library.\n \n-        let then = bx.build_sibling_block(\"then\");\n-        let catch = bx.build_sibling_block(\"catch\");\n+        let mut then = bx.build_sibling_block(\"then\");\n+        let mut catch = bx.build_sibling_block(\"catch\");\n \n         let func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n         let local_ptr = llvm::get_param(bx.llfn(), 2);\n         bx.invoke(func, &[data], then.llbb(), catch.llbb(), None);\n-        then.ret(C_i32(cx, 0));\n+        then.ret(bx.cx().const_i32(0));\n \n         // Type indicator for the exception being thrown.\n         //\n         // The first value in this tuple is a pointer to the exception object\n         // being thrown.  The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n         // rust_try ignores the selector.\n-        let lpad_ty = Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)], false);\n-        let vals = catch.landing_pad(lpad_ty, bx.cx.eh_personality(), 1);\n-        catch.add_clause(vals, C_null(Type::i8p(cx)));\n+        let lpad_ty = bx.cx().type_struct(&[bx.cx().type_i8p(), bx.cx().type_i32()], false);\n+        let vals = catch.landing_pad(lpad_ty, bx.cx().eh_personality(), 1);\n+        catch.add_clause(vals, bx.cx().const_null(bx.cx().type_i8p()));\n         let ptr = catch.extract_value(vals, 0);\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n-        catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(cx).ptr_to()), ptr_align);\n-        catch.ret(C_i32(cx, 1));\n+        let bitcast = catch.bitcast(local_ptr, bx.cx().type_ptr_to(bx.cx().type_i8p()));\n+        catch.store(ptr, bitcast, ptr_align);\n+        catch.ret(bx.cx().const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n@@ -949,7 +1011,7 @@ fn gen_fn<'ll, 'tcx>(\n         hir::Unsafety::Unsafe,\n         Abi::Rust\n     ));\n-    let llfn = declare::define_internal_fn(cx, name, rust_fn_sig);\n+    let llfn = cx.define_internal_fn(name, rust_fn_sig);\n     attributes::from_fn_attrs(cx, llfn, None);\n     let bx = Builder::new_block(cx, llfn, \"entry-block\");\n     codegen(bx);\n@@ -989,10 +1051,10 @@ fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n }\n \n fn generic_simd_intrinsic(\n-    bx: &Builder<'a, 'll, 'tcx>,\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n     name: &str,\n     callee_ty: Ty<'tcx>,\n-    args: &[OperandRef<'ll, 'tcx>],\n+    args: &[OperandRef<'tcx, &'ll Value>],\n     ret_ty: Ty<'tcx>,\n     llret_ty: &'ll Type,\n     span: Span\n@@ -1004,7 +1066,7 @@ fn generic_simd_intrinsic(\n         };\n         ($msg: tt, $($fmt: tt)*) => {\n             span_invalid_monomorphization_error(\n-                bx.sess(), span,\n+                bx.cx().sess(), span,\n                 &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n                          name, $($fmt)*));\n         }\n@@ -1065,7 +1127,7 @@ fn generic_simd_intrinsic(\n                   found `{}` with length {}\",\n                  in_len, in_ty,\n                  ret_ty, out_len);\n-        require!(llret_ty.element_type().kind() == TypeKind::Integer,\n+        require!(bx.cx().type_kind(bx.cx().element_type(llret_ty)) == TypeKind::Integer,\n                  \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n                  ret_ty,\n                  ret_ty.simd_type(tcx));\n@@ -1101,8 +1163,8 @@ fn generic_simd_intrinsic(\n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {\n                 let arg_idx = i;\n-                let val = const_get_elt(vector, i as u64);\n-                match const_to_opt_u128(val, true) {\n+                let val = bx.cx().const_get_elt(vector, i as u64);\n+                match bx.cx().const_to_opt_u128(val, true) {\n                     None => {\n                         emit_error!(\"shuffle index #{} is not a constant\", arg_idx);\n                         None\n@@ -1112,18 +1174,18 @@ fn generic_simd_intrinsic(\n                                     arg_idx, total_len);\n                         None\n                     }\n-                    Some(idx) => Some(C_i32(bx.cx, idx as i32)),\n+                    Some(idx) => Some(bx.cx().const_i32(idx as i32)),\n                 }\n             })\n             .collect();\n         let indices = match indices {\n             Some(i) => i,\n-            None => return Ok(C_null(llret_ty))\n+            None => return Ok(bx.cx().const_null(llret_ty))\n         };\n \n         return Ok(bx.shuffle_vector(args[0].immediate(),\n                                     args[1].immediate(),\n-                                    C_vector(&indices)))\n+                                    bx.cx().const_vector(&indices)))\n     }\n \n     if name == \"simd_insert\" {\n@@ -1154,8 +1216,8 @@ fn generic_simd_intrinsic(\n             _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty)\n         }\n         // truncate the mask to a vector of i1s\n-        let i1 = Type::i1(bx.cx);\n-        let i1xn = Type::vector(i1, m_len as u64);\n+        let i1 = bx.cx().type_i1();\n+        let i1xn = bx.cx().type_vector(i1, m_len as u64);\n         let m_i1s = bx.trunc(args[0].immediate(), i1xn);\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n@@ -1165,17 +1227,17 @@ fn generic_simd_intrinsic(\n         in_elem: &::rustc::ty::TyS,\n         in_ty: &::rustc::ty::TyS,\n         in_len: usize,\n-        bx: &Builder<'a, 'll, 'tcx>,\n+        bx: &mut Builder<'a, 'll, 'tcx>,\n         span: Span,\n-        args: &[OperandRef<'ll, 'tcx>],\n+        args: &[OperandRef<'tcx, &'ll Value>],\n     ) -> Result<&'ll Value, ()> {\n         macro_rules! emit_error {\n             ($msg: tt) => {\n                 emit_error!($msg, )\n             };\n             ($msg: tt, $($fmt: tt)*) => {\n                 span_invalid_monomorphization_error(\n-                    bx.sess(), span,\n+                    bx.cx().sess(), span,\n                     &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n                              name, $($fmt)*));\n             }\n@@ -1216,7 +1278,7 @@ fn generic_simd_intrinsic(\n         };\n \n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", name, in_len, ety);\n-        let intrinsic = bx.cx.get_intrinsic(&llvm_name);\n+        let intrinsic = bx.cx().get_intrinsic(&llvm_name);\n         let c = bx.call(intrinsic,\n                         &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n                         None);\n@@ -1287,16 +1349,16 @@ fn generic_simd_intrinsic(\n                       mut no_pointers: usize) -> &'ll Type {\n         // FIXME: use cx.layout_of(ty).llvm_type() ?\n         let mut elem_ty = match elem_ty.sty {\n-            ty::Int(v) => Type::int_from_ty(cx, v),\n-            ty::Uint(v) => Type::uint_from_ty(cx, v),\n-            ty::Float(v) => Type::float_from_ty(cx, v),\n+            ty::Int(v) => cx.type_int_from_ty( v),\n+            ty::Uint(v) => cx.type_uint_from_ty( v),\n+            ty::Float(v) => cx.type_float_from_ty( v),\n             _ => unreachable!(),\n         };\n         while no_pointers > 0 {\n-            elem_ty = elem_ty.ptr_to();\n+            elem_ty = cx.type_ptr_to(elem_ty);\n             no_pointers -= 1;\n         }\n-        Type::vector(elem_ty, vec_len as u64)\n+        cx.type_vector(elem_ty, vec_len as u64)\n     }\n \n \n@@ -1373,29 +1435,32 @@ fn generic_simd_intrinsic(\n         }\n \n         // Alignment of T, must be a constant integer value:\n-        let alignment_ty = Type::i32(bx.cx);\n-        let alignment = C_i32(bx.cx, bx.cx.align_of(in_elem).abi() as i32);\n+        let alignment_ty = bx.cx().type_i32();\n+        let alignment = bx.cx().const_i32(bx.cx().align_of(in_elem).abi() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n-            let i1 = Type::i1(bx.cx);\n-            let i1xn = Type::vector(i1, in_len as u64);\n+            let i1 = bx.cx().type_i1();\n+            let i1xn = bx.cx().type_vector(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n         // Type of the vector of pointers:\n-        let llvm_pointer_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count);\n+        let llvm_pointer_vec_ty = llvm_vector_ty(bx.cx(), underlying_ty, in_len, pointer_count);\n         let llvm_pointer_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count);\n \n         // Type of the vector of elements:\n-        let llvm_elem_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count - 1);\n+        let llvm_elem_vec_ty = llvm_vector_ty(bx.cx(), underlying_ty, in_len, pointer_count - 1);\n         let llvm_elem_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count - 1);\n \n         let llvm_intrinsic = format!(\"llvm.masked.gather.{}.{}\",\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n-        let f = declare::declare_cfn(bx.cx, &llvm_intrinsic,\n-                                     Type::func(&[llvm_pointer_vec_ty, alignment_ty, mask_ty,\n-                                                  llvm_elem_vec_ty], llvm_elem_vec_ty));\n+        let f = bx.cx().declare_cfn(&llvm_intrinsic,\n+                                     bx.cx().type_func(&[\n+                                         llvm_pointer_vec_ty,\n+                                         alignment_ty,\n+                                         mask_ty,\n+                                         llvm_elem_vec_ty], llvm_elem_vec_ty));\n         llvm::SetUnnamedAddr(f, false);\n         let v = bx.call(f, &[args[1].immediate(), alignment, mask, args[0].immediate()],\n                         None);\n@@ -1470,30 +1535,30 @@ fn generic_simd_intrinsic(\n         }\n \n         // Alignment of T, must be a constant integer value:\n-        let alignment_ty = Type::i32(bx.cx);\n-        let alignment = C_i32(bx.cx, bx.cx.align_of(in_elem).abi() as i32);\n+        let alignment_ty = bx.cx().type_i32();\n+        let alignment = bx.cx().const_i32(bx.cx().align_of(in_elem).abi() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n-            let i1 = Type::i1(bx.cx);\n-            let i1xn = Type::vector(i1, in_len as u64);\n+            let i1 = bx.cx().type_i1();\n+            let i1xn = bx.cx().type_vector(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n-        let ret_t = Type::void(bx.cx);\n+        let ret_t = bx.cx().type_void();\n \n         // Type of the vector of pointers:\n-        let llvm_pointer_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count);\n+        let llvm_pointer_vec_ty = llvm_vector_ty(bx.cx(), underlying_ty, in_len, pointer_count);\n         let llvm_pointer_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count);\n \n         // Type of the vector of elements:\n-        let llvm_elem_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count - 1);\n+        let llvm_elem_vec_ty = llvm_vector_ty(bx.cx(), underlying_ty, in_len, pointer_count - 1);\n         let llvm_elem_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count - 1);\n \n         let llvm_intrinsic = format!(\"llvm.masked.scatter.{}.{}\",\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n-        let f = declare::declare_cfn(bx.cx, &llvm_intrinsic,\n-                                     Type::func(&[llvm_elem_vec_ty,\n+        let f = bx.cx().declare_cfn(&llvm_intrinsic,\n+                                     bx.cx().type_func(&[llvm_elem_vec_ty,\n                                                   llvm_pointer_vec_ty,\n                                                   alignment_ty,\n                                                   mask_ty], ret_t));\n@@ -1533,7 +1598,7 @@ fn generic_simd_intrinsic(\n                             //   code is generated\n                             // * if the accumulator of the fmul isn't 1, incorrect\n                             //   code is generated\n-                            match const_get_real(acc) {\n+                            match bx.cx().const_get_real(acc) {\n                                 None => return_error!(\"accumulator of {} is not a constant\", $name),\n                                 Some((v, loses_info)) => {\n                                     if $name.contains(\"mul\") && v != 1.0_f64 {\n@@ -1549,8 +1614,8 @@ fn generic_simd_intrinsic(\n                         } else {\n                             // unordered arithmetic reductions do not:\n                             match f.bit_width() {\n-                                32 => C_undef(Type::f32(bx.cx)),\n-                                64 => C_undef(Type::f64(bx.cx)),\n+                                32 => bx.cx().const_undef(bx.cx().type_f32()),\n+                                64 => bx.cx().const_undef(bx.cx().type_f64()),\n                                 v => {\n                                     return_error!(r#\"\n unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n@@ -1627,8 +1692,8 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     }\n \n                     // boolean reductions operate on vectors of i1s:\n-                    let i1 = Type::i1(bx.cx);\n-                    let i1xn = Type::vector(i1, in_len as u64);\n+                    let i1 = bx.cx().type_i1();\n+                    let i1xn = bx.cx().type_vector(i1, in_len as u64);\n                     bx.trunc(args[0].immediate(), i1xn)\n                 };\n                 return match in_elem.sty {\n@@ -1638,7 +1703,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                             if !$boolean {\n                                 r\n                             } else {\n-                                bx.zext(r, Type::bool(bx.cx))\n+                                bx.zext(r, bx.cx().type_bool())\n                             }\n                         )\n                     },"}, {"sha": "f904a928d53e609bb8de34d4e09be181b4b5a8b2", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 124, "deletions": 114, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -37,11 +37,10 @@\n #![feature(static_nobundle)]\n \n use back::write::create_target_machine;\n-use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n \n-#[macro_use] extern crate bitflags;\n extern crate flate2;\n+#[macro_use] extern crate bitflags;\n extern crate libc;\n #[macro_use] extern crate rustc;\n extern crate jobserver;\n@@ -56,6 +55,7 @@ extern crate rustc_incremental;\n extern crate rustc_llvm;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_codegen_utils;\n+extern crate rustc_codegen_ssa;\n extern crate rustc_fs_util;\n \n #[macro_use] extern crate log;\n@@ -67,28 +67,30 @@ extern crate cc; // Used to locate MSVC\n extern crate tempfile;\n extern crate memmap;\n \n-use back::bytecode::RLIB_BYTECODE_EXTENSION;\n-\n+use rustc_codegen_ssa::traits::*;\n+use rustc_codegen_ssa::back::write::{CodegenContext, ModuleConfig};\n+use rustc_codegen_ssa::back::lto::{SerializedModule, LtoModuleCodegen, ThinModule};\n+use rustc_codegen_ssa::CompiledModule;\n+use errors::{FatalError, Handler};\n+use rustc::dep_graph::WorkProduct;\n+use rustc::util::time_graph::Timeline;\n+use syntax_pos::symbol::InternedString;\n+use rustc::mir::mono::Stats;\n pub use llvm_util::target_features;\n use std::any::Any;\n-use std::sync::mpsc;\n-use rustc_data_structures::sync::Lrc;\n+use std::sync::{mpsc, Arc};\n \n use rustc::dep_graph::DepGraph;\n-use rustc::hir::def_id::CrateNum;\n-use rustc::middle::cstore::MetadataLoader;\n-use rustc::middle::cstore::{NativeLibrary, CrateSource, LibSource};\n-use rustc::middle::lang_items::LangItem;\n+use rustc::middle::allocator::AllocatorKind;\n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n use rustc::session::{Session, CompileIncomplete};\n use rustc::session::config::{OutputFilenames, OutputType, PrintRequest};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::time_graph;\n-use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc::util::profiling::ProfileCategory;\n use rustc_mir::monomorphize;\n-use rustc_codegen_utils::{CompiledModule, ModuleKind};\n+use rustc_codegen_ssa::ModuleCodegen;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n-use rustc_data_structures::svh::Svh;\n \n mod diagnostics;\n \n@@ -114,22 +116,110 @@ mod consts;\n mod context;\n mod debuginfo;\n mod declare;\n-mod glue;\n mod intrinsic;\n-pub mod llvm;\n+\n+// The following is a work around that replaces `pub mod llvm;` and that fixes issue 53912.\n+#[path = \"llvm/mod.rs\"] mod llvm_; pub mod llvm { pub use super::llvm_::*; }\n+\n mod llvm_util;\n mod metadata;\n-mod meth;\n-mod mir;\n mod mono_item;\n mod type_;\n mod type_of;\n mod value;\n \n+#[derive(Clone)]\n pub struct LlvmCodegenBackend(());\n \n-impl !Send for LlvmCodegenBackend {} // Llvm is on a per-thread basis\n-impl !Sync for LlvmCodegenBackend {}\n+impl ExtraBackendMethods for LlvmCodegenBackend {\n+    fn new_metadata(&self, sess: &Session, mod_name: &str) -> ModuleLlvm {\n+        ModuleLlvm::new(sess, mod_name)\n+    }\n+    fn write_metadata<'b, 'gcx>(\n+        &self,\n+        tcx: TyCtxt<'b, 'gcx, 'gcx>,\n+        metadata: &ModuleLlvm\n+    ) -> EncodedMetadata {\n+        base::write_metadata(tcx, metadata)\n+    }\n+    fn codegen_allocator(&self, tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind) {\n+        unsafe { allocator::codegen(tcx, mods, kind) }\n+    }\n+    fn compile_codegen_unit<'a, 'tcx: 'a>(\n+        &self,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        cgu_name: InternedString,\n+    ) -> Stats {\n+        base::compile_codegen_unit(tcx, cgu_name)\n+    }\n+    fn target_machine_factory(\n+        &self,\n+        sess: &Session,\n+        find_features: bool\n+    ) -> Arc<dyn Fn() ->\n+        Result<&'static mut llvm::TargetMachine, String> + Send + Sync> {\n+        back::write::target_machine_factory(sess, find_features)\n+    }\n+    fn target_cpu<'b>(&self, sess: &'b Session) -> &'b str {\n+        llvm_util::target_cpu(sess)\n+    }\n+}\n+\n+impl WriteBackendMethods for LlvmCodegenBackend {\n+    type Module = ModuleLlvm;\n+    type ModuleBuffer = back::lto::ModuleBuffer;\n+    type Context = llvm::Context;\n+    type TargetMachine = &'static mut llvm::TargetMachine;\n+    type ThinData = back::lto::ThinData;\n+    type ThinBuffer = back::lto::ThinBuffer;\n+    fn print_pass_timings(&self) {\n+            unsafe { llvm::LLVMRustPrintPassTimings(); }\n+    }\n+    fn run_lto(\n+        cgcx: &CodegenContext<Self>,\n+        modules: Vec<ModuleCodegen<Self::Module>>,\n+        cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n+        timeline: &mut Timeline\n+    ) -> Result<(Vec<LtoModuleCodegen<Self>>, Vec<WorkProduct>), FatalError> {\n+        back::lto::run(cgcx, modules, cached_modules, timeline)\n+    }\n+    unsafe fn optimize(\n+        cgcx: &CodegenContext<Self>,\n+        diag_handler: &Handler,\n+        module: &ModuleCodegen<Self::Module>,\n+        config: &ModuleConfig,\n+        timeline: &mut Timeline\n+    ) -> Result<(), FatalError> {\n+        back::write::optimize(cgcx, diag_handler, module, config, timeline)\n+    }\n+    unsafe fn optimize_thin(\n+        cgcx: &CodegenContext<Self>,\n+        thin: &mut ThinModule<Self>,\n+        timeline: &mut Timeline\n+    ) -> Result<ModuleCodegen<Self::Module>, FatalError> {\n+        back::lto::optimize_thin_module(thin, cgcx, timeline)\n+    }\n+    unsafe fn codegen(\n+        cgcx: &CodegenContext<Self>,\n+        diag_handler: &Handler,\n+        module: ModuleCodegen<Self::Module>,\n+        config: &ModuleConfig,\n+        timeline: &mut Timeline\n+    ) -> Result<CompiledModule, FatalError> {\n+        back::write::codegen(cgcx, diag_handler, module, config, timeline)\n+    }\n+    fn run_lto_pass_manager(\n+        cgcx: &CodegenContext<Self>,\n+        module: &ModuleCodegen<Self::Module>,\n+        config: &ModuleConfig,\n+        thin: bool\n+    ) {\n+        back::lto::run_pass_manager(cgcx, module, config, thin)\n+    }\n+}\n+\n+unsafe impl Send for LlvmCodegenBackend {} // Llvm is on a per-thread basis\n+unsafe impl Sync for LlvmCodegenBackend {}\n \n impl LlvmCodegenBackend {\n     pub fn new() -> Box<dyn CodegenBackend> {\n@@ -190,24 +280,24 @@ impl CodegenBackend for LlvmCodegenBackend {\n     }\n \n     fn provide(&self, providers: &mut ty::query::Providers) {\n-        rustc_codegen_utils::symbol_export::provide(providers);\n         rustc_codegen_utils::symbol_names::provide(providers);\n-        base::provide_both(providers);\n+        rustc_codegen_ssa::back::symbol_export::provide(providers);\n+        rustc_codegen_ssa::base::provide_both(providers);\n         attributes::provide(providers);\n     }\n \n     fn provide_extern(&self, providers: &mut ty::query::Providers) {\n-        rustc_codegen_utils::symbol_export::provide_extern(providers);\n-        base::provide_both(providers);\n+        rustc_codegen_ssa::back::symbol_export::provide_extern(providers);\n+        rustc_codegen_ssa::base::provide_both(providers);\n         attributes::provide_extern(providers);\n     }\n \n-    fn codegen_crate<'a, 'tcx>(\n+    fn codegen_crate<'b, 'tcx>(\n         &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'b, 'tcx, 'tcx>,\n         rx: mpsc::Receiver<Box<dyn Any + Send>>\n     ) -> Box<dyn Any> {\n-        box base::codegen_crate(tcx, rx)\n+        box rustc_codegen_ssa::base::codegen_crate(LlvmCodegenBackend(()), tcx, rx)\n     }\n \n     fn join_codegen_and_link(\n@@ -218,12 +308,13 @@ impl CodegenBackend for LlvmCodegenBackend {\n         outputs: &OutputFilenames,\n     ) -> Result<(), CompileIncomplete>{\n         use rustc::util::common::time;\n-        let (ongoing_codegen, work_products) =\n-            ongoing_codegen.downcast::<::back::write::OngoingCodegen>()\n+        let (codegen_results, work_products) =\n+            ongoing_codegen.downcast::\n+                <rustc_codegen_ssa::back::write::OngoingCodegen<LlvmCodegenBackend>>()\n                 .expect(\"Expected LlvmCodegenBackend's OngoingCodegen, found Box<Any>\")\n                 .join(sess);\n         if sess.opts.debugging_opts.incremental_info {\n-            back::write::dump_incremental_data(&ongoing_codegen);\n+            rustc_codegen_ssa::back::write::dump_incremental_data(&codegen_results);\n         }\n \n         time(sess,\n@@ -241,14 +332,14 @@ impl CodegenBackend for LlvmCodegenBackend {\n         // This should produce either a finished executable or library.\n         sess.profiler(|p| p.start_activity(ProfileCategory::Linking));\n         time(sess, \"linking\", || {\n-            back::link::link_binary(sess, &ongoing_codegen,\n-                                    outputs, &ongoing_codegen.crate_name.as_str());\n+            back::link::link_binary(sess, &codegen_results,\n+                                    outputs, &codegen_results.crate_name.as_str());\n         });\n         sess.profiler(|p| p.end_activity(ProfileCategory::Linking));\n \n         // Now that we won't touch anything in the incremental compilation directory\n         // any more, we can finalize it (which involves renaming it)\n-        rustc_incremental::finalize_session_directory(sess, ongoing_codegen.crate_hash);\n+        rustc_incremental::finalize_session_directory(sess, codegen_results.crate_hash);\n \n         Ok(())\n     }\n@@ -260,57 +351,7 @@ pub fn __rustc_codegen_backend() -> Box<dyn CodegenBackend> {\n     LlvmCodegenBackend::new()\n }\n \n-struct ModuleCodegen {\n-    /// The name of the module. When the crate may be saved between\n-    /// compilations, incremental compilation requires that name be\n-    /// unique amongst **all** crates.  Therefore, it should contain\n-    /// something unique to this crate (e.g., a module path) as well\n-    /// as the crate name and disambiguator.\n-    /// We currently generate these names via CodegenUnit::build_cgu_name().\n-    name: String,\n-    module_llvm: ModuleLlvm,\n-    kind: ModuleKind,\n-}\n-\n-struct CachedModuleCodegen {\n-    name: String,\n-    source: WorkProduct,\n-}\n-\n-impl ModuleCodegen {\n-    fn into_compiled_module(self,\n-                            emit_obj: bool,\n-                            emit_bc: bool,\n-                            emit_bc_compressed: bool,\n-                            outputs: &OutputFilenames) -> CompiledModule {\n-        let object = if emit_obj {\n-            Some(outputs.temp_path(OutputType::Object, Some(&self.name)))\n-        } else {\n-            None\n-        };\n-        let bytecode = if emit_bc {\n-            Some(outputs.temp_path(OutputType::Bitcode, Some(&self.name)))\n-        } else {\n-            None\n-        };\n-        let bytecode_compressed = if emit_bc_compressed {\n-            Some(outputs.temp_path(OutputType::Bitcode, Some(&self.name))\n-                        .with_extension(RLIB_BYTECODE_EXTENSION))\n-        } else {\n-            None\n-        };\n-\n-        CompiledModule {\n-            name: self.name.clone(),\n-            kind: self.kind,\n-            object,\n-            bytecode,\n-            bytecode_compressed,\n-        }\n-    }\n-}\n-\n-struct ModuleLlvm {\n+pub struct ModuleLlvm {\n     llcx: &'static mut llvm::Context,\n     llmod_raw: *const llvm::Module,\n     tm: &'static mut llvm::TargetMachine,\n@@ -349,35 +390,4 @@ impl Drop for ModuleLlvm {\n     }\n }\n \n-struct CodegenResults {\n-    crate_name: Symbol,\n-    modules: Vec<CompiledModule>,\n-    allocator_module: Option<CompiledModule>,\n-    metadata_module: CompiledModule,\n-    crate_hash: Svh,\n-    metadata: rustc::middle::cstore::EncodedMetadata,\n-    windows_subsystem: Option<String>,\n-    linker_info: rustc_codegen_utils::linker::LinkerInfo,\n-    crate_info: CrateInfo,\n-}\n-\n-/// Misc info we load from metadata to persist beyond the tcx\n-struct CrateInfo {\n-    panic_runtime: Option<CrateNum>,\n-    compiler_builtins: Option<CrateNum>,\n-    profiler_runtime: Option<CrateNum>,\n-    sanitizer_runtime: Option<CrateNum>,\n-    is_no_builtins: FxHashSet<CrateNum>,\n-    native_libraries: FxHashMap<CrateNum, Lrc<Vec<NativeLibrary>>>,\n-    crate_name: FxHashMap<CrateNum, String>,\n-    used_libraries: Lrc<Vec<NativeLibrary>>,\n-    link_args: Lrc<Vec<String>>,\n-    used_crate_source: FxHashMap<CrateNum, Lrc<CrateSource>>,\n-    used_crates_static: Vec<(CrateNum, LibSource)>,\n-    used_crates_dynamic: Vec<(CrateNum, LibSource)>,\n-    wasm_imports: FxHashMap<String, String>,\n-    lang_item_to_crate: FxHashMap<LangItem, CrateNum>,\n-    missing_lang_items: FxHashMap<CrateNum, Vec<LangItem>>,\n-}\n-\n __build_diagnostic_array! { librustc_codegen_llvm, DIAGNOSTICS }"}, {"sha": "f1a966d7654388c1389e0a5b37c1cb007b25c829", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -19,6 +19,8 @@ use libc::{c_uint, c_int, size_t, c_char};\n use libc::{c_ulonglong, c_void};\n \n use std::marker::PhantomData;\n+use syntax;\n+use rustc_codegen_ssa;\n \n use super::RustString;\n \n@@ -141,6 +143,23 @@ pub enum IntPredicate {\n     IntSLE = 41,\n }\n \n+impl IntPredicate {\n+    pub fn from_generic(intpre: rustc_codegen_ssa::common::IntPredicate) -> Self {\n+        match intpre {\n+            rustc_codegen_ssa::common::IntPredicate::IntEQ => IntPredicate::IntEQ,\n+            rustc_codegen_ssa::common::IntPredicate::IntNE => IntPredicate::IntNE,\n+            rustc_codegen_ssa::common::IntPredicate::IntUGT => IntPredicate::IntUGT,\n+            rustc_codegen_ssa::common::IntPredicate::IntUGE => IntPredicate::IntUGE,\n+            rustc_codegen_ssa::common::IntPredicate::IntULT => IntPredicate::IntULT,\n+            rustc_codegen_ssa::common::IntPredicate::IntULE => IntPredicate::IntULE,\n+            rustc_codegen_ssa::common::IntPredicate::IntSGT => IntPredicate::IntSGT,\n+            rustc_codegen_ssa::common::IntPredicate::IntSGE => IntPredicate::IntSGE,\n+            rustc_codegen_ssa::common::IntPredicate::IntSLT => IntPredicate::IntSLT,\n+            rustc_codegen_ssa::common::IntPredicate::IntSLE => IntPredicate::IntSLE,\n+        }\n+    }\n+}\n+\n /// LLVMRealPredicate\n #[derive(Copy, Clone)]\n #[repr(C)]\n@@ -163,6 +182,31 @@ pub enum RealPredicate {\n     RealPredicateTrue = 15,\n }\n \n+impl RealPredicate {\n+    pub fn from_generic(realpred: rustc_codegen_ssa::common::RealPredicate) -> Self {\n+        match realpred {\n+            rustc_codegen_ssa::common::RealPredicate::RealPredicateFalse =>\n+                RealPredicate::RealPredicateFalse,\n+            rustc_codegen_ssa::common::RealPredicate::RealOEQ => RealPredicate::RealOEQ,\n+            rustc_codegen_ssa::common::RealPredicate::RealOGT => RealPredicate::RealOGT,\n+            rustc_codegen_ssa::common::RealPredicate::RealOGE => RealPredicate::RealOGE,\n+            rustc_codegen_ssa::common::RealPredicate::RealOLT => RealPredicate::RealOLT,\n+            rustc_codegen_ssa::common::RealPredicate::RealOLE => RealPredicate::RealOLE,\n+            rustc_codegen_ssa::common::RealPredicate::RealONE => RealPredicate::RealONE,\n+            rustc_codegen_ssa::common::RealPredicate::RealORD => RealPredicate::RealORD,\n+            rustc_codegen_ssa::common::RealPredicate::RealUNO => RealPredicate::RealUNO,\n+            rustc_codegen_ssa::common::RealPredicate::RealUEQ => RealPredicate::RealUEQ,\n+            rustc_codegen_ssa::common::RealPredicate::RealUGT => RealPredicate::RealUGT,\n+            rustc_codegen_ssa::common::RealPredicate::RealUGE => RealPredicate::RealUGE,\n+            rustc_codegen_ssa::common::RealPredicate::RealULT => RealPredicate::RealULT,\n+            rustc_codegen_ssa::common::RealPredicate::RealULE => RealPredicate::RealULE,\n+            rustc_codegen_ssa::common::RealPredicate::RealUNE => RealPredicate::RealUNE,\n+            rustc_codegen_ssa::common::RealPredicate::RealPredicateTrue =>\n+                RealPredicate::RealPredicateTrue\n+        }\n+    }\n+}\n+\n /// LLVMTypeKind\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[repr(C)]\n@@ -186,6 +230,30 @@ pub enum TypeKind {\n     Token = 16,\n }\n \n+impl TypeKind {\n+    pub fn to_generic(self) -> rustc_codegen_ssa::common::TypeKind {\n+        match self {\n+            TypeKind::Void => rustc_codegen_ssa::common::TypeKind::Void,\n+            TypeKind::Half => rustc_codegen_ssa::common::TypeKind::Half,\n+            TypeKind::Float => rustc_codegen_ssa::common::TypeKind::Float,\n+            TypeKind::Double => rustc_codegen_ssa::common::TypeKind::Double,\n+            TypeKind::X86_FP80 => rustc_codegen_ssa::common::TypeKind::X86_FP80,\n+            TypeKind::FP128 => rustc_codegen_ssa::common::TypeKind::FP128,\n+            TypeKind::PPC_FP128 => rustc_codegen_ssa::common::TypeKind::PPC_FP128,\n+            TypeKind::Label => rustc_codegen_ssa::common::TypeKind::Label,\n+            TypeKind::Integer => rustc_codegen_ssa::common::TypeKind::Integer,\n+            TypeKind::Function => rustc_codegen_ssa::common::TypeKind::Function,\n+            TypeKind::Struct => rustc_codegen_ssa::common::TypeKind::Struct,\n+            TypeKind::Array => rustc_codegen_ssa::common::TypeKind::Array,\n+            TypeKind::Pointer => rustc_codegen_ssa::common::TypeKind::Pointer,\n+            TypeKind::Vector => rustc_codegen_ssa::common::TypeKind::Vector,\n+            TypeKind::Metadata => rustc_codegen_ssa::common::TypeKind::Metadata,\n+            TypeKind::X86_MMX => rustc_codegen_ssa::common::TypeKind::X86_MMX,\n+            TypeKind::Token => rustc_codegen_ssa::common::TypeKind::Token,\n+        }\n+    }\n+}\n+\n /// LLVMAtomicRmwBinOp\n #[derive(Copy, Clone)]\n #[repr(C)]\n@@ -203,6 +271,24 @@ pub enum AtomicRmwBinOp {\n     AtomicUMin = 10,\n }\n \n+impl AtomicRmwBinOp {\n+    pub fn from_generic(op: rustc_codegen_ssa::common::AtomicRmwBinOp) -> Self {\n+        match op {\n+            rustc_codegen_ssa::common::AtomicRmwBinOp::AtomicXchg => AtomicRmwBinOp::AtomicXchg,\n+            rustc_codegen_ssa::common::AtomicRmwBinOp::AtomicAdd => AtomicRmwBinOp::AtomicAdd,\n+            rustc_codegen_ssa::common::AtomicRmwBinOp::AtomicSub => AtomicRmwBinOp::AtomicSub,\n+            rustc_codegen_ssa::common::AtomicRmwBinOp::AtomicAnd => AtomicRmwBinOp::AtomicAnd,\n+            rustc_codegen_ssa::common::AtomicRmwBinOp::AtomicNand => AtomicRmwBinOp::AtomicNand,\n+            rustc_codegen_ssa::common::AtomicRmwBinOp::AtomicOr => AtomicRmwBinOp::AtomicOr,\n+            rustc_codegen_ssa::common::AtomicRmwBinOp::AtomicXor => AtomicRmwBinOp::AtomicXor,\n+            rustc_codegen_ssa::common::AtomicRmwBinOp::AtomicMax => AtomicRmwBinOp::AtomicMax,\n+            rustc_codegen_ssa::common::AtomicRmwBinOp::AtomicMin => AtomicRmwBinOp::AtomicMin,\n+            rustc_codegen_ssa::common::AtomicRmwBinOp::AtomicUMax => AtomicRmwBinOp::AtomicUMax,\n+            rustc_codegen_ssa::common::AtomicRmwBinOp::AtomicUMin => AtomicRmwBinOp::AtomicUMin\n+        }\n+    }\n+}\n+\n /// LLVMAtomicOrdering\n #[derive(Copy, Clone)]\n #[repr(C)]\n@@ -218,6 +304,23 @@ pub enum AtomicOrdering {\n     SequentiallyConsistent = 7,\n }\n \n+impl AtomicOrdering {\n+    pub fn from_generic(ao: rustc_codegen_ssa::common::AtomicOrdering) -> Self {\n+        match ao {\n+            rustc_codegen_ssa::common::AtomicOrdering::NotAtomic => AtomicOrdering::NotAtomic,\n+            rustc_codegen_ssa::common::AtomicOrdering::Unordered => AtomicOrdering::Unordered,\n+            rustc_codegen_ssa::common::AtomicOrdering::Monotonic => AtomicOrdering::Monotonic,\n+            rustc_codegen_ssa::common::AtomicOrdering::Acquire => AtomicOrdering::Acquire,\n+            rustc_codegen_ssa::common::AtomicOrdering::Release => AtomicOrdering::Release,\n+            rustc_codegen_ssa::common::AtomicOrdering::AcquireRelease =>\n+                AtomicOrdering::AcquireRelease,\n+            rustc_codegen_ssa::common::AtomicOrdering::SequentiallyConsistent =>\n+                AtomicOrdering::SequentiallyConsistent\n+        }\n+    }\n+}\n+\n+\n /// LLVMRustSynchronizationScope\n #[derive(Copy, Clone)]\n #[repr(C)]\n@@ -229,6 +332,18 @@ pub enum SynchronizationScope {\n     CrossThread,\n }\n \n+impl SynchronizationScope {\n+    pub fn from_generic(sc: rustc_codegen_ssa::common::SynchronizationScope) -> Self {\n+        match sc {\n+            rustc_codegen_ssa::common::SynchronizationScope::Other => SynchronizationScope::Other,\n+            rustc_codegen_ssa::common::SynchronizationScope::SingleThread =>\n+                SynchronizationScope::SingleThread,\n+            rustc_codegen_ssa::common::SynchronizationScope::CrossThread =>\n+                SynchronizationScope::CrossThread,\n+        }\n+    }\n+}\n+\n /// LLVMRustFileType\n #[derive(Copy, Clone)]\n #[repr(C)]\n@@ -269,6 +384,15 @@ pub enum AsmDialect {\n     Intel,\n }\n \n+impl AsmDialect {\n+    pub fn from_generic(asm: syntax::ast::AsmDialect) -> Self {\n+        match asm {\n+            syntax::ast::AsmDialect::Att => AsmDialect::Att,\n+            syntax::ast::AsmDialect::Intel => AsmDialect::Intel\n+        }\n+    }\n+}\n+\n /// LLVMRustCodeGenOptLevel\n #[derive(Copy, Clone, PartialEq)]\n #[repr(C)]"}, {"sha": "586a490774023f9f000a68b8c63da9eb2b4636c1", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "removed", "additions": 0, "deletions": 224, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/ee821736ccdf1d370bf2c906ce3c133c0fc295d4/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee821736ccdf1d370bf2c906ce3c133c0fc295d4/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=ee821736ccdf1d370bf2c906ce3c133c0fc295d4", "patch": "@@ -1,224 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use llvm;\n-use rustc::mir::interpret::{ErrorHandled, read_target_uint};\n-use rustc_mir::const_eval::const_field;\n-use rustc::hir::def_id::DefId;\n-use rustc::mir;\n-use rustc_data_structures::indexed_vec::Idx;\n-use rustc::mir::interpret::{GlobalId, Pointer, Scalar, Allocation, ConstValue, AllocType};\n-use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Size};\n-use builder::Builder;\n-use common::{CodegenCx};\n-use common::{C_bytes, C_struct, C_uint_big, C_undef, C_usize};\n-use consts;\n-use type_of::LayoutLlvmExt;\n-use type_::Type;\n-use syntax::ast::Mutability;\n-use syntax::source_map::Span;\n-use value::Value;\n-\n-use super::super::callee;\n-use super::FunctionCx;\n-\n-pub fn scalar_to_llvm(\n-    cx: &CodegenCx<'ll, '_>,\n-    cv: Scalar,\n-    layout: &layout::Scalar,\n-    llty: &'ll Type,\n-) -> &'ll Value {\n-    let bitsize = if layout.is_bool() { 1 } else { layout.value.size(cx).bits() };\n-    match cv {\n-        Scalar::Bits { size: 0, .. } => {\n-            assert_eq!(0, layout.value.size(cx).bytes());\n-            C_undef(Type::ix(cx, 0))\n-        },\n-        Scalar::Bits { bits, size } => {\n-            assert_eq!(size as u64, layout.value.size(cx).bytes());\n-            let llval = C_uint_big(Type::ix(cx, bitsize), bits);\n-            if layout.value == layout::Pointer {\n-                unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n-            } else {\n-                consts::bitcast(llval, llty)\n-            }\n-        },\n-        Scalar::Ptr(ptr) => {\n-            let alloc_type = cx.tcx.alloc_map.lock().get(ptr.alloc_id);\n-            let base_addr = match alloc_type {\n-                Some(AllocType::Memory(alloc)) => {\n-                    let init = const_alloc_to_llvm(cx, alloc);\n-                    if alloc.mutability == Mutability::Mutable {\n-                        consts::addr_of_mut(cx, init, alloc.align, None)\n-                    } else {\n-                        consts::addr_of(cx, init, alloc.align, None)\n-                    }\n-                }\n-                Some(AllocType::Function(fn_instance)) => {\n-                    callee::get_fn(cx, fn_instance)\n-                }\n-                Some(AllocType::Static(def_id)) => {\n-                    assert!(cx.tcx.is_static(def_id).is_some());\n-                    consts::get_static(cx, def_id)\n-                }\n-                None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n-            };\n-            let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n-                consts::bitcast(base_addr, Type::i8p(cx)),\n-                &C_usize(cx, ptr.offset.bytes()),\n-                1,\n-            ) };\n-            if layout.value != layout::Pointer {\n-                unsafe { llvm::LLVMConstPtrToInt(llval, llty) }\n-            } else {\n-                consts::bitcast(llval, llty)\n-            }\n-        }\n-    }\n-}\n-\n-pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n-    let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n-    let dl = cx.data_layout();\n-    let pointer_size = dl.pointer_size.bytes() as usize;\n-\n-    let mut next_offset = 0;\n-    for &(offset, ((), alloc_id)) in alloc.relocations.iter() {\n-        let offset = offset.bytes();\n-        assert_eq!(offset as usize as u64, offset);\n-        let offset = offset as usize;\n-        if offset > next_offset {\n-            llvals.push(C_bytes(cx, &alloc.bytes[next_offset..offset]));\n-        }\n-        let ptr_offset = read_target_uint(\n-            dl.endian,\n-            &alloc.bytes[offset..(offset + pointer_size)],\n-        ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n-        llvals.push(scalar_to_llvm(\n-            cx,\n-            Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n-            &layout::Scalar {\n-                value: layout::Primitive::Pointer,\n-                valid_range: 0..=!0\n-            },\n-            Type::i8p(cx)\n-        ));\n-        next_offset = offset + pointer_size;\n-    }\n-    if alloc.bytes.len() >= next_offset {\n-        llvals.push(C_bytes(cx, &alloc.bytes[next_offset ..]));\n-    }\n-\n-    C_struct(cx, &llvals, true)\n-}\n-\n-pub fn codegen_static_initializer(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    def_id: DefId,\n-) -> Result<(&'ll Value, &'tcx Allocation), ErrorHandled> {\n-    let instance = ty::Instance::mono(cx.tcx, def_id);\n-    let cid = GlobalId {\n-        instance,\n-        promoted: None,\n-    };\n-    let param_env = ty::ParamEnv::reveal_all();\n-    let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n-\n-    let alloc = match static_.val {\n-        ConstValue::ByRef(_, alloc, n) if n.bytes() == 0 => alloc,\n-        _ => bug!(\"static const eval returned {:#?}\", static_),\n-    };\n-    Ok((const_alloc_to_llvm(cx, alloc), alloc))\n-}\n-\n-impl FunctionCx<'a, 'll, 'tcx> {\n-    fn fully_evaluate(\n-        &mut self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n-        constant: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, ErrorHandled> {\n-        match constant.val {\n-            ConstValue::Unevaluated(def_id, ref substs) => {\n-                let tcx = bx.tcx();\n-                let param_env = ty::ParamEnv::reveal_all();\n-                let instance = ty::Instance::resolve(tcx, param_env, def_id, substs).unwrap();\n-                let cid = GlobalId {\n-                    instance,\n-                    promoted: None,\n-                };\n-                tcx.const_eval(param_env.and(cid))\n-            },\n-            _ => Ok(constant),\n-        }\n-    }\n-\n-    pub fn eval_mir_constant(\n-        &mut self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n-        constant: &mir::Constant<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, ErrorHandled> {\n-        let c = self.monomorphize(&constant.literal);\n-        self.fully_evaluate(bx, c)\n-    }\n-\n-    /// process constant containing SIMD shuffle indices\n-    pub fn simd_shuffle_indices(\n-        &mut self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n-        span: Span,\n-        ty: Ty<'tcx>,\n-        constant: Result<&'tcx ty::Const<'tcx>, ErrorHandled>,\n-    ) -> (&'ll Value, Ty<'tcx>) {\n-        constant\n-            .and_then(|c| {\n-                let field_ty = c.ty.builtin_index().unwrap();\n-                let fields = match c.ty.sty {\n-                    ty::Array(_, n) => n.unwrap_usize(bx.tcx()),\n-                    ref other => bug!(\"invalid simd shuffle type: {}\", other),\n-                };\n-                let values: Result<Vec<_>, ErrorHandled> = (0..fields).map(|field| {\n-                    let field = const_field(\n-                        bx.tcx(),\n-                        ty::ParamEnv::reveal_all(),\n-                        self.instance,\n-                        None,\n-                        mir::Field::new(field as usize),\n-                        c,\n-                    )?;\n-                    if let Some(prim) = field.val.try_to_scalar() {\n-                        let layout = bx.cx.layout_of(field_ty);\n-                        let scalar = match layout.abi {\n-                            layout::Abi::Scalar(ref x) => x,\n-                            _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n-                        };\n-                        Ok(scalar_to_llvm(\n-                            bx.cx, prim, scalar,\n-                            layout.immediate_llvm_type(bx.cx),\n-                        ))\n-                    } else {\n-                        bug!(\"simd shuffle field {:?}\", field)\n-                    }\n-                }).collect();\n-                let llval = C_struct(bx.cx, &values?, false);\n-                Ok((llval, c.ty))\n-            })\n-            .unwrap_or_else(|_| {\n-                bx.tcx().sess.span_err(\n-                    span,\n-                    \"could not evaluate shuffle_indices at compile time\",\n-                );\n-                // We've errored, so we don't have to produce working code.\n-                let ty = self.monomorphize(&ty);\n-                let llty = bx.cx.layout_of(ty).llvm_type(bx.cx);\n-                (C_undef(llty), ty)\n-            })\n-    }\n-}"}, {"sha": "9b2d17d65caa30fe5c20c8b26c79ea2ea18d72cb", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 52, "deletions": 151, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -8,181 +8,82 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Walks the crate looking for items/impl-items/trait-items that have\n-//! either a `rustc_symbol_name` or `rustc_item_path` attribute and\n-//! generates an error giving, respectively, the symbol name or\n-//! item-path. This is used for unit testing the code that generates\n-//! paths etc in all kinds of annoying scenarios.\n-\n-use asm;\n use attributes;\n use base;\n-use consts;\n use context::CodegenCx;\n-use declare;\n use llvm;\n use monomorphize::Instance;\n use type_of::LayoutLlvmExt;\n-use rustc::hir;\n-use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::mir::mono::{Linkage, Visibility};\n use rustc::ty::TypeFoldable;\n-use rustc::ty::layout::LayoutOf;\n-use std::fmt;\n+use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n+use rustc_codegen_ssa::traits::*;\n \n pub use rustc::mir::mono::MonoItem;\n \n-pub use rustc_mir::monomorphize::item::MonoItemExt as BaseMonoItemExt;\n-\n-pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n-    fn define(&self, cx: &CodegenCx<'a, 'tcx>) {\n-        debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx),\n-               self.to_raw_string(),\n-               cx.codegen_unit.name());\n+impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn predefine_static(&self,\n+                                  def_id: DefId,\n+                                  linkage: Linkage,\n+                                  visibility: Visibility,\n+                                  symbol_name: &str) {\n+        let instance = Instance::mono(self.tcx, def_id);\n+        let ty = instance.ty(self.tcx);\n+        let llty = self.layout_of(ty).llvm_type(self);\n+\n+        let g = self.define_global(symbol_name, llty).unwrap_or_else(|| {\n+            self.sess().span_fatal(self.tcx.def_span(def_id),\n+                &format!(\"symbol `{}` is already defined\", symbol_name))\n+        });\n \n-        match *self.as_mono_item() {\n-            MonoItem::Static(def_id) => {\n-                let tcx = cx.tcx;\n-                let is_mutable = match tcx.describe_def(def_id) {\n-                    Some(Def::Static(_, is_mutable)) => is_mutable,\n-                    Some(other) => {\n-                        bug!(\"Expected Def::Static, found {:?}\", other)\n-                    }\n-                    None => {\n-                        bug!(\"Expected Def::Static for {:?}, found nothing\", def_id)\n-                    }\n-                };\n-                consts::codegen_static(&cx, def_id, is_mutable);\n-            }\n-            MonoItem::GlobalAsm(node_id) => {\n-                let item = cx.tcx.hir.expect_item(node_id);\n-                if let hir::ItemKind::GlobalAsm(ref ga) = item.node {\n-                    asm::codegen_global_asm(cx, ga);\n-                } else {\n-                    span_bug!(item.span, \"Mismatch between hir::Item type and MonoItem type\")\n-                }\n-            }\n-            MonoItem::Fn(instance) => {\n-                base::codegen_instance(&cx, instance);\n-            }\n+        unsafe {\n+            llvm::LLVMRustSetLinkage(g, base::linkage_to_llvm(linkage));\n+            llvm::LLVMRustSetVisibility(g, base::visibility_to_llvm(visibility));\n         }\n \n-        debug!(\"END IMPLEMENTING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx),\n-               self.to_raw_string(),\n-               cx.codegen_unit.name());\n+        self.instances.borrow_mut().insert(instance, g);\n     }\n \n-    fn predefine(&self,\n-                 cx: &CodegenCx<'a, 'tcx>,\n-                 linkage: Linkage,\n-                 visibility: Visibility) {\n-        debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx),\n-               self.to_raw_string(),\n-               cx.codegen_unit.name());\n-\n-        let symbol_name = self.symbol_name(cx.tcx).as_str();\n-\n-        debug!(\"symbol {}\", &symbol_name);\n-\n-        match *self.as_mono_item() {\n-            MonoItem::Static(def_id) => {\n-                predefine_static(cx, def_id, linkage, visibility, &symbol_name);\n-            }\n-            MonoItem::Fn(instance) => {\n-                predefine_fn(cx, instance, linkage, visibility, &symbol_name);\n-            }\n-            MonoItem::GlobalAsm(..) => {}\n+    fn predefine_fn(&self,\n+                              instance: Instance<'tcx>,\n+                              linkage: Linkage,\n+                              visibility: Visibility,\n+                              symbol_name: &str) {\n+        assert!(!instance.substs.needs_infer() &&\n+                !instance.substs.has_param_types());\n+\n+        let mono_sig = instance.fn_sig(self.tcx());\n+        let attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n+        let lldecl = self.declare_fn(symbol_name, mono_sig);\n+        unsafe { llvm::LLVMRustSetLinkage(lldecl, base::linkage_to_llvm(linkage)) };\n+        base::set_link_section(lldecl, &attrs);\n+        if linkage == Linkage::LinkOnceODR ||\n+            linkage == Linkage::WeakODR {\n+            llvm::SetUniqueComdat(self.llmod, lldecl);\n         }\n \n-        debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx),\n-               self.to_raw_string(),\n-               cx.codegen_unit.name());\n-    }\n-\n-    fn to_raw_string(&self) -> String {\n-        match *self.as_mono_item() {\n-            MonoItem::Fn(instance) => {\n-                format!(\"Fn({:?}, {})\",\n-                        instance.def,\n-                        instance.substs.as_ptr() as usize)\n-            }\n-            MonoItem::Static(id) => {\n-                format!(\"Static({:?})\", id)\n+        // If we're compiling the compiler-builtins crate, e.g. the equivalent of\n+        // compiler-rt, then we want to implicitly compile everything with hidden\n+        // visibility as we're going to link this object all over the place but\n+        // don't want the symbols to get exported.\n+        if linkage != Linkage::Internal && linkage != Linkage::Private &&\n+           self.tcx.is_compiler_builtins(LOCAL_CRATE) {\n+            unsafe {\n+                llvm::LLVMRustSetVisibility(lldecl, llvm::Visibility::Hidden);\n             }\n-            MonoItem::GlobalAsm(id) => {\n-                format!(\"GlobalAsm({:?})\", id)\n+        } else {\n+            unsafe {\n+                llvm::LLVMRustSetVisibility(lldecl, base::visibility_to_llvm(visibility));\n             }\n         }\n-    }\n-}\n \n-impl<'a, 'tcx> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {}\n-\n-fn predefine_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                              def_id: DefId,\n-                              linkage: Linkage,\n-                              visibility: Visibility,\n-                              symbol_name: &str) {\n-    let instance = Instance::mono(cx.tcx, def_id);\n-    let ty = instance.ty(cx.tcx);\n-    let llty = cx.layout_of(ty).llvm_type(cx);\n-\n-    let g = declare::define_global(cx, symbol_name, llty).unwrap_or_else(|| {\n-        cx.sess().span_fatal(cx.tcx.def_span(def_id),\n-            &format!(\"symbol `{}` is already defined\", symbol_name))\n-    });\n-\n-    unsafe {\n-        llvm::LLVMRustSetLinkage(g, base::linkage_to_llvm(linkage));\n-        llvm::LLVMRustSetVisibility(g, base::visibility_to_llvm(visibility));\n-    }\n-\n-    cx.instances.borrow_mut().insert(instance, g);\n-}\n-\n-fn predefine_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                          instance: Instance<'tcx>,\n-                          linkage: Linkage,\n-                          visibility: Visibility,\n-                          symbol_name: &str) {\n-    assert!(!instance.substs.needs_infer() &&\n-            !instance.substs.has_param_types());\n-\n-    let mono_sig = instance.fn_sig(cx.tcx);\n-    let attrs = cx.tcx.codegen_fn_attrs(instance.def_id());\n-    let lldecl = declare::declare_fn(cx, symbol_name, mono_sig);\n-    unsafe { llvm::LLVMRustSetLinkage(lldecl, base::linkage_to_llvm(linkage)) };\n-    base::set_link_section(lldecl, &attrs);\n-    if linkage == Linkage::LinkOnceODR ||\n-        linkage == Linkage::WeakODR {\n-        llvm::SetUniqueComdat(cx.llmod, lldecl);\n-    }\n-\n-    // If we're compiling the compiler-builtins crate, e.g. the equivalent of\n-    // compiler-rt, then we want to implicitly compile everything with hidden\n-    // visibility as we're going to link this object all over the place but\n-    // don't want the symbols to get exported.\n-    if linkage != Linkage::Internal && linkage != Linkage::Private &&\n-       cx.tcx.is_compiler_builtins(LOCAL_CRATE) {\n-        unsafe {\n-            llvm::LLVMRustSetVisibility(lldecl, llvm::Visibility::Hidden);\n+        debug!(\"predefine_fn: mono_sig = {:?} instance = {:?}\", mono_sig, instance);\n+        if instance.def.is_inline(self.tcx) {\n+            attributes::inline(self, lldecl, attributes::InlineAttr::Hint);\n         }\n-    } else {\n-        unsafe {\n-            llvm::LLVMRustSetVisibility(lldecl, base::visibility_to_llvm(visibility));\n-        }\n-    }\n+        attributes::from_fn_attrs(self, lldecl, Some(instance.def.def_id()));\n \n-    debug!(\"predefine_fn: mono_sig = {:?} instance = {:?}\", mono_sig, instance);\n-    if instance.def.is_inline(cx.tcx) {\n-        attributes::inline(cx, lldecl, attributes::InlineAttr::Hint);\n+        self.instances.borrow_mut().insert(instance, lldecl);\n     }\n-    attributes::from_fn_attrs(cx, lldecl, Some(instance.def.def_id()));\n-\n-    cx.instances.borrow_mut().insert(instance, lldecl);\n }"}, {"sha": "5c4ebc35240d45042031f66e9b1cdc47f3e70727", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 143, "deletions": 147, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -13,15 +13,23 @@\n pub use llvm::Type;\n \n use llvm;\n-use llvm::{Bool, False, True, TypeKind};\n-\n+use llvm::{Bool, False, True};\n use context::CodegenCx;\n+use rustc_codegen_ssa::traits::*;\n+use value::Value;\n \n-use syntax::ast;\n-use rustc::ty::layout::{self, Align, Size};\n+use rustc::util::nodemap::FxHashMap;\n+use rustc::ty::Ty;\n+use rustc::ty::layout::TyLayout;\n+use rustc_target::abi::call::{CastTarget, FnType, Reg};\n use rustc_data_structures::small_c_str::SmallCStr;\n+use common;\n+use rustc_codegen_ssa::common::TypeKind;\n+use type_of::LayoutLlvmExt;\n+use abi::{LlvmType, FnTypeExt};\n \n use std::fmt;\n+use std::cell::RefCell;\n \n use libc::c_uint;\n \n@@ -39,233 +47,182 @@ impl fmt::Debug for Type {\n     }\n }\n \n-impl Type {\n-    pub fn void(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn type_void(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMVoidTypeInContext(cx.llcx)\n+            llvm::LLVMVoidTypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn metadata(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    fn type_metadata(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMRustMetadataTypeInContext(cx.llcx)\n+            llvm::LLVMRustMetadataTypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn i1(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    fn type_i1(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMInt1TypeInContext(cx.llcx)\n+            llvm::LLVMInt1TypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn i8(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    fn type_i8(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMInt8TypeInContext(cx.llcx)\n+            llvm::LLVMInt8TypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn i8_llcx(llcx: &llvm::Context) -> &Type {\n-        unsafe {\n-            llvm::LLVMInt8TypeInContext(llcx)\n-        }\n-    }\n \n-    pub fn i16(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    fn type_i16(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMInt16TypeInContext(cx.llcx)\n-        }\n-    }\n \n-    pub fn i32(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n-        unsafe {\n-            llvm::LLVMInt32TypeInContext(cx.llcx)\n+            llvm::LLVMInt16TypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn i64(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    fn type_i32(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMInt64TypeInContext(cx.llcx)\n+            llvm::LLVMInt32TypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn i128(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    fn type_i64(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMIntTypeInContext(cx.llcx, 128)\n+            llvm::LLVMInt64TypeInContext(self.llcx)\n         }\n     }\n \n-    // Creates an integer type with the given number of bits, e.g. i24\n-    pub fn ix(cx: &CodegenCx<'ll, '_>, num_bits: u64) -> &'ll Type {\n+    fn type_i128(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMIntTypeInContext(cx.llcx, num_bits as c_uint)\n+            llvm::LLVMIntTypeInContext(self.llcx, 128)\n         }\n     }\n \n-    // Creates an integer type with the given number of bits, e.g. i24\n-    pub fn ix_llcx(llcx: &llvm::Context, num_bits: u64) -> &Type {\n+    fn type_ix(&self, num_bits: u64) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMIntTypeInContext(llcx, num_bits as c_uint)\n+            llvm::LLVMIntTypeInContext(self.llcx, num_bits as c_uint)\n         }\n     }\n \n-    pub fn f32(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n-        unsafe {\n-            llvm::LLVMFloatTypeInContext(cx.llcx)\n-        }\n+    fn type_isize(&self) -> &'ll Type {\n+        self.isize_ty\n     }\n \n-    pub fn f64(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    fn type_f32(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMDoubleTypeInContext(cx.llcx)\n-        }\n-    }\n-\n-    pub fn bool(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n-        Type::i8(cx)\n-    }\n-\n-    pub fn char(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n-        Type::i32(cx)\n-    }\n-\n-    pub fn i8p(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n-        Type::i8(cx).ptr_to()\n-    }\n-\n-    pub fn i8p_llcx(llcx: &llvm::Context) -> &Type {\n-        Type::i8_llcx(llcx).ptr_to()\n-    }\n-\n-    pub fn isize(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n-        cx.isize_ty\n-    }\n-\n-    pub fn c_int(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n-        match &cx.tcx.sess.target.target.target_c_int_width[..] {\n-            \"16\" => Type::i16(cx),\n-            \"32\" => Type::i32(cx),\n-            \"64\" => Type::i64(cx),\n-            width => bug!(\"Unsupported target_c_int_width: {}\", width),\n-        }\n-    }\n-\n-    pub fn int_from_ty(cx: &CodegenCx<'ll, '_>, t: ast::IntTy) -> &'ll Type {\n-        match t {\n-            ast::IntTy::Isize => cx.isize_ty,\n-            ast::IntTy::I8 => Type::i8(cx),\n-            ast::IntTy::I16 => Type::i16(cx),\n-            ast::IntTy::I32 => Type::i32(cx),\n-            ast::IntTy::I64 => Type::i64(cx),\n-            ast::IntTy::I128 => Type::i128(cx),\n+            llvm::LLVMFloatTypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn uint_from_ty(cx: &CodegenCx<'ll, '_>, t: ast::UintTy) -> &'ll Type {\n-        match t {\n-            ast::UintTy::Usize => cx.isize_ty,\n-            ast::UintTy::U8 => Type::i8(cx),\n-            ast::UintTy::U16 => Type::i16(cx),\n-            ast::UintTy::U32 => Type::i32(cx),\n-            ast::UintTy::U64 => Type::i64(cx),\n-            ast::UintTy::U128 => Type::i128(cx),\n+    fn type_f64(&self) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMDoubleTypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn float_from_ty(cx: &CodegenCx<'ll, '_>, t: ast::FloatTy) -> &'ll Type {\n-        match t {\n-            ast::FloatTy::F32 => Type::f32(cx),\n-            ast::FloatTy::F64 => Type::f64(cx),\n+    fn type_x86_mmx(&self) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMX86MMXTypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn func(args: &[&'ll Type], ret: &'ll Type) -> &'ll Type {\n+    fn type_func(\n+        &self,\n+        args: &[&'ll Type],\n+        ret: &'ll Type\n+    ) -> &'ll Type {\n         unsafe {\n             llvm::LLVMFunctionType(ret, args.as_ptr(),\n                                    args.len() as c_uint, False)\n         }\n     }\n \n-    pub fn variadic_func(args: &[&'ll Type], ret: &'ll Type) -> &'ll Type {\n+    fn type_variadic_func(\n+        &self,\n+        args: &[&'ll Type],\n+        ret: &'ll Type\n+    ) -> &'ll Type {\n         unsafe {\n             llvm::LLVMFunctionType(ret, args.as_ptr(),\n                                    args.len() as c_uint, True)\n         }\n     }\n \n-    pub fn struct_(cx: &CodegenCx<'ll, '_>, els: &[&'ll Type], packed: bool) -> &'ll Type {\n+    fn type_struct(\n+        &self,\n+        els: &[&'ll Type],\n+        packed: bool\n+    ) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMStructTypeInContext(cx.llcx, els.as_ptr(),\n+            llvm::LLVMStructTypeInContext(self.llcx, els.as_ptr(),\n                                           els.len() as c_uint,\n                                           packed as Bool)\n         }\n     }\n \n-    pub fn named_struct(cx: &CodegenCx<'ll, '_>, name: &str) -> &'ll Type {\n+    fn type_named_struct(&self, name: &str) -> &'ll Type {\n         let name = SmallCStr::new(name);\n         unsafe {\n-            llvm::LLVMStructCreateNamed(cx.llcx, name.as_ptr())\n+            llvm::LLVMStructCreateNamed(self.llcx, name.as_ptr())\n         }\n     }\n \n \n-    pub fn array(ty: &Type, len: u64) -> &Type {\n+    fn type_array(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n         unsafe {\n             llvm::LLVMRustArrayType(ty, len)\n         }\n     }\n \n-    pub fn vector(ty: &Type, len: u64) -> &Type {\n+    fn type_vector(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n         unsafe {\n             llvm::LLVMVectorType(ty, len as c_uint)\n         }\n     }\n \n-    pub fn kind(&self) -> TypeKind {\n+    fn type_kind(&self, ty: &'ll Type) -> TypeKind {\n         unsafe {\n-            llvm::LLVMRustGetTypeKind(self)\n+            llvm::LLVMRustGetTypeKind(ty).to_generic()\n         }\n     }\n \n-    pub fn set_struct_body(&'ll self, els: &[&'ll Type], packed: bool) {\n+    fn set_struct_body(&self, ty: &'ll Type, els: &[&'ll Type], packed: bool) {\n         unsafe {\n-            llvm::LLVMStructSetBody(self, els.as_ptr(),\n+            llvm::LLVMStructSetBody(ty, els.as_ptr(),\n                                     els.len() as c_uint, packed as Bool)\n         }\n     }\n \n-    pub fn ptr_to(&self) -> &Type {\n-        assert_ne!(self.kind(), TypeKind::Function,\n+    fn type_ptr_to(&self, ty: &'ll Type) -> &'ll Type {\n+        assert_ne!(self.type_kind(ty), TypeKind::Function,\n                    \"don't call ptr_to on function types, use ptr_to_llvm_type on FnType instead\");\n-        unsafe {\n-            llvm::LLVMPointerType(self, 0)\n-        }\n+        ty.ptr_to()\n     }\n \n-    pub fn element_type(&self) -> &Type {\n+    fn element_type(&self, ty: &'ll Type) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMGetElementType(self)\n+            llvm::LLVMGetElementType(ty)\n         }\n     }\n \n-    /// Return the number of elements in `self` if it is a LLVM vector type.\n-    pub fn vector_length(&self) -> usize {\n+    fn vector_length(&self, ty: &'ll Type) -> usize {\n         unsafe {\n-            llvm::LLVMGetVectorSize(self) as usize\n+            llvm::LLVMGetVectorSize(ty) as usize\n         }\n     }\n \n-    pub fn func_params(&self) -> Vec<&Type> {\n+    fn func_params_types(&self, ty: &'ll Type) -> Vec<&'ll Type> {\n         unsafe {\n-            let n_args = llvm::LLVMCountParamTypes(self) as usize;\n+            let n_args = llvm::LLVMCountParamTypes(ty) as usize;\n             let mut args = Vec::with_capacity(n_args);\n-            llvm::LLVMGetParamTypes(self, args.as_mut_ptr());\n+            llvm::LLVMGetParamTypes(ty, args.as_mut_ptr());\n             args.set_len(n_args);\n             args\n         }\n     }\n \n-    pub fn float_width(&self) -> usize {\n-        match self.kind() {\n+    fn float_width(&self, ty: &'ll Type) -> usize {\n+        match self.type_kind(ty) {\n             TypeKind::Float => 32,\n             TypeKind::Double => 64,\n             TypeKind::X86_FP80 => 80,\n@@ -274,45 +231,84 @@ impl Type {\n         }\n     }\n \n-    /// Retrieve the bit width of the integer type `self`.\n-    pub fn int_width(&self) -> u64 {\n+    fn int_width(&self, ty: &'ll Type) -> u64 {\n         unsafe {\n-            llvm::LLVMGetIntTypeWidth(self) as u64\n+            llvm::LLVMGetIntTypeWidth(ty) as u64\n         }\n     }\n \n-    pub fn from_integer(cx: &CodegenCx<'ll, '_>, i: layout::Integer) -> &'ll Type {\n-        use rustc::ty::layout::Integer::*;\n-        match i {\n-            I8 => Type::i8(cx),\n-            I16 => Type::i16(cx),\n-            I32 => Type::i32(cx),\n-            I64 => Type::i64(cx),\n-            I128 => Type::i128(cx),\n+    fn val_ty(&self, v: &'ll Value) -> &'ll Type {\n+        common::val_ty(v)\n+    }\n+\n+    fn scalar_lltypes(&self) -> &RefCell<FxHashMap<Ty<'tcx>, Self::Type>> {\n+        &self.scalar_lltypes\n+    }\n+}\n+\n+impl Type {\n+    pub fn i8_llcx(llcx: &llvm::Context) -> &Type {\n+        unsafe {\n+            llvm::LLVMInt8TypeInContext(llcx)\n         }\n     }\n \n-    /// Return a LLVM type that has at most the required alignment,\n-    /// as a conservative approximation for unknown pointee types.\n-    pub fn pointee_for_abi_align(cx: &CodegenCx<'ll, '_>, align: Align) -> &'ll Type {\n-        // FIXME(eddyb) We could find a better approximation if ity.align < align.\n-        let ity = layout::Integer::approximate_abi_align(cx, align);\n-        Type::from_integer(cx, ity)\n+    // Creates an integer type with the given number of bits, e.g. i24\n+    pub fn ix_llcx(\n+        llcx: &llvm::Context,\n+        num_bits: u64\n+    ) -> &Type {\n+        unsafe {\n+            llvm::LLVMIntTypeInContext(llcx, num_bits as c_uint)\n+        }\n     }\n \n-    /// Return a LLVM type that has at most the required alignment,\n-    /// and exactly the required size, as a best-effort padding array.\n-    pub fn padding_filler(cx: &CodegenCx<'ll, '_>, size: Size, align: Align) -> &'ll Type {\n-        let unit = layout::Integer::approximate_abi_align(cx, align);\n-        let size = size.bytes();\n-        let unit_size = unit.size().bytes();\n-        assert_eq!(size % unit_size, 0);\n-        Type::array(Type::from_integer(cx, unit), size / unit_size)\n+    pub fn i8p_llcx(llcx: &'ll llvm::Context) -> &'ll Type {\n+        Type::i8_llcx(llcx).ptr_to()\n     }\n \n-    pub fn x86_mmx(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    fn ptr_to(&self) -> &Type {\n         unsafe {\n-            llvm::LLVMX86MMXTypeInContext(cx.llcx)\n+            llvm::LLVMPointerType(&self, 0)\n         }\n     }\n }\n+\n+\n+impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn backend_type(&self, layout: TyLayout<'tcx>) -> &'ll Type {\n+        layout.llvm_type(self)\n+    }\n+    fn immediate_backend_type(&self, layout: TyLayout<'tcx>) -> &'ll Type {\n+        layout.immediate_llvm_type(self)\n+    }\n+    fn is_backend_immediate(&self, layout: TyLayout<'tcx>) -> bool {\n+        layout.is_llvm_immediate()\n+    }\n+    fn is_backend_scalar_pair(&self, layout: TyLayout<'tcx>) -> bool {\n+        layout.is_llvm_scalar_pair()\n+    }\n+    fn backend_field_index(&self, layout: TyLayout<'tcx>, index: usize) -> u64 {\n+        layout.llvm_field_index(index)\n+    }\n+    fn scalar_pair_element_backend_type<'a>(\n+        &self,\n+        layout: TyLayout<'tcx>,\n+        index: usize,\n+        immediate: bool\n+    ) -> &'ll Type {\n+        layout.scalar_pair_element_llvm_type(self, index, immediate)\n+    }\n+    fn cast_backend_type(&self, ty: &CastTarget) -> &'ll Type {\n+        ty.llvm_type(self)\n+    }\n+    fn fn_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> &'ll Type {\n+        ty.llvm_type(self)\n+    }\n+    fn fn_ptr_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> &'ll Type {\n+        ty.ptr_to_llvm_type(self)\n+    }\n+    fn reg_backend_type(&self, ty: &Reg) -> &'ll Type {\n+        ty.llvm_type(self)\n+    }\n+}"}, {"sha": "90c02cddb2b6058c42f0d6dd2d0d3a7f4ec3dec0", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -16,6 +16,7 @@ use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n use rustc_target::abi::FloatTy;\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use type_::Type;\n+use rustc_codegen_ssa::traits::*;\n \n use std::fmt::Write;\n \n@@ -37,14 +38,14 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 (cx.sess().target.target.arch == \"x86\" ||\n                  cx.sess().target.target.arch == \"x86_64\");\n             if use_x86_mmx {\n-                return Type::x86_mmx(cx)\n+                return cx.type_x86_mmx()\n             } else {\n                 let element = layout.scalar_llvm_type_at(cx, element, Size::ZERO);\n-                return Type::vector(element, count);\n+                return cx.type_vector(element, count);\n             }\n         }\n         layout::Abi::ScalarPair(..) => {\n-            return Type::struct_(cx, &[\n+            return cx.type_struct( &[\n                 layout.scalar_pair_element_llvm_type(cx, 0, false),\n                 layout.scalar_pair_element_llvm_type(cx, 1, false),\n             ], false);\n@@ -79,30 +80,30 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n     match layout.fields {\n         layout::FieldPlacement::Union(_) => {\n-            let fill = Type::padding_filler(cx, layout.size, layout.align);\n+            let fill = cx.type_padding_filler( layout.size, layout.align);\n             let packed = false;\n             match name {\n                 None => {\n-                    Type::struct_(cx, &[fill], packed)\n+                    cx.type_struct( &[fill], packed)\n                 }\n                 Some(ref name) => {\n-                    let llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(&[fill], packed);\n+                    let llty = cx.type_named_struct( name);\n+                    cx.set_struct_body(llty, &[fill], packed);\n                     llty\n                 }\n             }\n         }\n         layout::FieldPlacement::Array { count, .. } => {\n-            Type::array(layout.field(cx, 0).llvm_type(cx), count)\n+            cx.type_array(layout.field(cx, 0).llvm_type(cx), count)\n         }\n         layout::FieldPlacement::Arbitrary { .. } => {\n             match name {\n                 None => {\n                     let (llfields, packed) = struct_llfields(cx, layout);\n-                    Type::struct_(cx, &llfields, packed)\n+                    cx.type_struct( &llfields, packed)\n                 }\n                 Some(ref name) => {\n-                    let llty = Type::named_struct(cx, name);\n+                    let llty = cx.type_named_struct( name);\n                     *defer = Some((llty, layout));\n                     llty\n                 }\n@@ -136,7 +137,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         let padding = target_offset - offset;\n         let padding_align = prev_effective_align.min(effective_field_align);\n         assert_eq!(offset.abi_align(padding_align) + padding, target_offset);\n-        result.push(Type::padding_filler(cx, padding, padding_align));\n+        result.push(cx.type_padding_filler( padding, padding_align));\n         debug!(\"    padding before: {:?}\", padding);\n \n         result.push(field.llvm_type(cx));\n@@ -153,7 +154,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         assert_eq!(offset.abi_align(padding_align) + padding, layout.size);\n         debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n                padding, offset, layout.size);\n-        result.push(Type::padding_filler(cx, padding, padding_align));\n+        result.push(cx.type_padding_filler(padding, padding_align));\n         assert_eq!(result.len(), 1 + field_count * 2);\n     } else {\n         debug!(\"struct_llfields: offset: {:?} stride: {:?}\",\n@@ -255,17 +256,17 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             let llty = match self.ty.sty {\n                 ty::Ref(_, ty, _) |\n                 ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                    cx.layout_of(ty).llvm_type(cx).ptr_to()\n+                    cx.type_ptr_to(cx.layout_of(ty).llvm_type(cx))\n                 }\n                 ty::Adt(def, _) if def.is_box() => {\n-                    cx.layout_of(self.ty.boxed_ty()).llvm_type(cx).ptr_to()\n+                    cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).llvm_type(cx))\n                 }\n                 ty::FnPtr(sig) => {\n                     let sig = cx.tcx.normalize_erasing_late_bound_regions(\n                         ty::ParamEnv::reveal_all(),\n                         &sig,\n                     );\n-                    FnType::new(cx, sig, &[]).ptr_to_llvm_type(cx)\n+                    cx.fn_ptr_backend_type(&FnType::new(cx, sig, &[]))\n                 }\n                 _ => self.scalar_llvm_type_at(cx, scalar, Size::ZERO)\n             };\n@@ -307,7 +308,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n         if let Some((llty, layout)) = defer {\n             let (llfields, packed) = struct_llfields(cx, layout);\n-            llty.set_struct_body(&llfields, packed)\n+            cx.set_struct_body(llty, &llfields, packed)\n         }\n \n         llty\n@@ -316,7 +317,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type {\n         if let layout::Abi::Scalar(ref scalar) = self.abi {\n             if scalar.is_bool() {\n-                return Type::i1(cx);\n+                return cx.type_i1();\n             }\n         }\n         self.llvm_type(cx)\n@@ -325,17 +326,17 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     fn scalar_llvm_type_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n                                scalar: &layout::Scalar, offset: Size) -> &'a Type {\n         match scalar.value {\n-            layout::Int(i, _) => Type::from_integer(cx, i),\n-            layout::Float(FloatTy::F32) => Type::f32(cx),\n-            layout::Float(FloatTy::F64) => Type::f64(cx),\n+            layout::Int(i, _) => cx.type_from_integer( i),\n+            layout::Float(FloatTy::F32) => cx.type_f32(),\n+            layout::Float(FloatTy::F64) => cx.type_f64(),\n             layout::Pointer => {\n                 // If we know the alignment, pick something better than i8.\n                 let pointee = if let Some(pointee) = self.pointee_info_at(cx, offset) {\n-                    Type::pointee_for_abi_align(cx, pointee.align)\n+                    cx.type_pointee_for_abi_align( pointee.align)\n                 } else {\n-                    Type::i8(cx)\n+                    cx.type_i8()\n                 };\n-                pointee.ptr_to()\n+                cx.type_ptr_to(pointee)\n             }\n         }\n     }\n@@ -369,7 +370,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         // when immediate.  We need to load/store `bool` as `i8` to avoid\n         // crippling LLVM optimizations or triggering other LLVM bugs with `i1`.\n         if immediate && scalar.is_bool() {\n-            return Type::i1(cx);\n+            return cx.type_i1();\n         }\n \n         let offset = if index == 0 {"}, {"sha": "a158c34f9d1c2a1257bbfd6bded4221133ffa36a", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -0,0 +1,15 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_codegen_ssa\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_codegen_ssa\"\n+path = \"lib.rs\"\n+test = false\n+\n+[dependencies]\n+cc = \"1.0.1\"\n+num_cpus = \"1.0\"\n+rustc-demangle = \"0.1.4\"\n+memmap = \"0.6\""}, {"sha": "9e1d429180367c199e435743644faeaa32cbc9fa", "filename": "src/librustc_codegen_ssa/README.md", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FREADME.md?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -0,0 +1,121 @@\n+# Refactoring of `rustc_codegen_llvm`\n+by Denis Merigoux, October 23rd 2018\n+\n+## State of the code before the refactoring\n+\n+All the code related to the compilation of MIR into LLVM IR was contained inside the `rustc_codegen_llvm` crate. Here is the breakdown of the most important elements:\n+* the `back` folder (7,800 LOC) implements the mechanisms for creating the different object files and archive through LLVM, but also the communication mechanisms for parallel code generation;\n+* the `debuginfo` (3,200 LOC) folder contains all code that passes debug information down to LLVM;\n+* the `llvm` (2,200 LOC) folder defines the FFI necessary to communicate with LLVM using the C++ API;\n+* the `mir` (4,300 LOC) folder implements the actual lowering from MIR to LLVM IR;\n+* the `base.rs` (1,300 LOC) file contains some helper functions but also the high-level code that launches the code generation and distributes the work.\n+* the `builder.rs` (1,200 LOC) file contains all the functions generating individual LLVM IR instructions inside a basic block;\n+* the `common.rs` (450 LOC) contains various helper functions and all the functions generating LLVM static values;\n+* the `type_.rs` (300 LOC) defines most of the type translations to LLVM IR.\n+\n+The goal of this refactoring is to separate inside this crate code that is specific to the LLVM from code that can be reused for other rustc backends. For instance, the `mir` folder is almost entirely backend-specific but it relies heavily on other parts of the crate. The separation of the code must not affect the logic of the code nor its performance.\n+\n+For these reasons, the separation process involves two transformations that have to be done at the same time for the resulting code to compile :\n+\n+1. replace all the LLVM-specific types by generics inside function signatures and structure definitions;\n+2. encapsulate all functions calling the LLVM FFI inside a set of traits that will define the interface between backend-agnostic code and the backend.\n+\n+While the LLVM-specific code will be left in `rustc_codegen_llvm`, all the new traits and backend-agnostic code will be moved in `rustc_codegen_ssa` (name suggestion by @eddyb).\n+\n+## Generic types and structures\n+\n+@irinagpopa started to parametrize the types of `rustc_codegen_llvm` by a generic `Value` type, implemented in LLVM by a reference `&'ll Value`. This work has been extended to all structures inside the `mir` folder and elsewhere, as well as for LLVM's `BasicBlock` and `Type` types.\n+\n+The two most important structures for the LLVM codegen are `CodegenCx` and `Builder`. They are parametrized by multiple liftime parameters and the type for `Value`.\n+\n+```rust\n+struct CodegenCx<'ll, 'tcx: 'll> {\n+  /* ... */\n+}\n+\n+struct Builder<'a, 'll: 'a, 'tcx: 'll> {\n+  cx: &'a CodegenCx<'ll, 'tcx>,\n+  /* ... */\n+}\n+```\n+\n+`CodegenCx` is used to compile one codegen-unit that can contain multiple functions, whereas `Builder` is created to compile one basic block.\n+\n+The code in `rustc_codegen_llvm` has to deal with multiple explicit lifetime parameters, that correspond to the following:\n+* `'tcx` is the longest lifetime, that corresponds to the original `TyCtxt` containing the program's information;\n+* `'a` is a short-lived reference of a `CodegenCx` or another object inside a struct;\n+* `'ll` is the lifetime of references to LLVM objects such as `Value` or `Type`.\n+\n+Although there are already many lifetime parameters in the code, making it generic uncovered situations where the borrow-checker was passing only due to the special nature of the LLVM objects manipulated (they are extern pointers). For instance, a additional lifetime parameter had to be added to `LocalAnalyser` in `analyse.rs`, leading to the definition:\n+\n+```rust\n+struct LocalAnalyzer<'mir, 'a: 'mir, 'tcx: 'a> {\n+  /* ... */\n+}\n+```\n+\n+However, the two most important structures `CodegenCx` and `Builder` are not defined in the backend-agnostic code. Indeed, their content is highly specific of the backend and it makes more sense to leave their definition to the backend implementor than to allow just a narrow spot via a generic field for the backend's context.\n+\n+## Traits and interface\n+\n+Because they have to be defined by the backend, `CodegenCx` and `Builder` will be the structures implementing all the traits defining the backend's interface. These traits are defined in the folder `rustc_codegen_ssa/traits` and all the backend-agnostic code is parametrized by them. For instance, let us explain how a function in `base.rs` is parametrized:\n+\n+```rust\n+pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    cx: &'a Bx::CodegenCx,\n+    instance: Instance<'tcx>\n+) {\n+    /* ... */\n+}\n+```\n+\n+In this signature, we have the two lifetime parameters explained earlier and the master type `Bx` which satisfies the trait `BuilderMethods` corresponding to the interface satisfied by the `Builder` struct. The `BuilderMethods` defines an associated type `Bx::CodegenCx` that itself satisfies the `CodegenMethods` traits implemented by the struct `CodegenCx`.\n+\n+On the trait side, here is an example with part of the definition of `BuilderMethods` in `traits/builder.rs`:\n+\n+```rust\n+pub trait BuilderMethods<'a, 'tcx: 'a>:\n+    HasCodegen<'tcx>\n+    + DebugInfoBuilderMethods<'tcx>\n+    + ArgTypeMethods<'tcx>\n+    + AbiBuilderMethods<'tcx>\n+    + IntrinsicCallMethods<'tcx>\n+    + AsmBuilderMethods<'tcx>\n+{\n+    fn new_block<'b>(\n+        cx: &'a Self::CodegenCx,\n+        llfn: Self::Value,\n+        name: &'b str\n+    ) -> Self;\n+    /* ... */\n+    fn cond_br(\n+        &mut self,\n+        cond: Self::Value,\n+        then_llbb: Self::BasicBlock,\n+        else_llbb: Self::BasicBlock,\n+    );\n+    /* ... */\n+}\n+```\n+\n+Finally, a master structure implementing the `ExtraBackendMethods` trait is used for high-level codegen-driving functions like `codegen_crate` in `base.rs`. For LLVM, it is the empty `LlvmCodegenBackend`. `ExtraBackendMethods` should be implemented by the same structure that implements the `CodegenBackend` defined in `rustc_codegen_utils/codegen_backend.rs`.\n+\n+During the traitification process, certain functions have been converted from methods of a local structure to methods of `CodegenCx` or `Builder` and a corresponding `self` parameter has been added. Indeed, LLVM stores information internally that it can access when called through its API. This information does not show up in a Rust data structure carried around when these methods are called. However, when implementing a Rust backend for `rustc`, these methods will need information from `CodegenCx`, hence the additional parameter (unused in the LLVM implementation of the trait).\n+\n+## State of the code after the refactoring\n+\n+The traits offer an API which is very similar to the API of LLVM. This is not the best solution since LLVM has a very special way of doing things: when addding another backend, the traits definition might be changed in order to offer more flexibility.\n+\n+However, the current separation between backend-agnostic and LLVM-specific code has allows the reuse of a significant part of the old `rustc_codegen_llvm`. Here is the new LOC breakdown between backend-agnostic (BA) and LLVM for the most important elements:\n+\n+* `back` folder: 3,800 (BA) vs 4,100 (LLVM);\n+* `mir` folder: 4,400 (BA) vs 0 (LLVM);\n+* `base.rs`: 1,100 (BA) vs 250 (LLVM);\n+* `builder.rs`: 1,400 (BA) vs 0 (LLVM);\n+* `common.rs`: 350 (BA) vs 350 (LLVM);\n+\n+The `debuginfo` folder has been left almost untouched by the splitting and is specific to LLVM. Only its high-level features have been traitified.\n+\n+The new `traits` folder has 1500 LOC only for trait definitions. Overall, the 27,000 LOC-sized old `rustc_codegen_llvm` code has been split into the new 18,500 LOC-sized new `rustc_codegen_llvm` and the 12,000 LOC-sized `rustc_codegen_ssa`. We can say that this refactoring allowed the reuse of approximately 10,000 LOC that would otherwise have had to be duplicated between the multiple backends of `rustc`.\n+\n+The refactored version of `rustc`'s backend introduced no regression over the test suite nor in performance benchmark, which is in coherence with the nature of the refactoring that used only compile-time parametricity (no trait objects)."}, {"sha": "b5e1deb0d5df3f4837527340eee8d3cc85c17df0", "filename": "src/librustc_codegen_ssa/back/archive.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Farchive.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::session::Session;\n+\n+use std::path::PathBuf;\n+\n+pub fn find_library(name: &str, search_paths: &[PathBuf], sess: &Session)\n+                    -> PathBuf {\n+    // On Windows, static libraries sometimes show up as libfoo.a and other\n+    // times show up as foo.lib\n+    let oslibname = format!(\"{}{}{}\",\n+                            sess.target.target.options.staticlib_prefix,\n+                            name,\n+                            sess.target.target.options.staticlib_suffix);\n+    let unixlibname = format!(\"lib{}.a\", name);\n+\n+    for path in search_paths {\n+        debug!(\"looking for {} inside {:?}\", name, path);\n+        let test = path.join(&oslibname);\n+        if test.exists() { return test }\n+        if oslibname != unixlibname {\n+            let test = path.join(&unixlibname);\n+            if test.exists() { return test }\n+        }\n+    }\n+    sess.fatal(&format!(\"could not find native static library `{}`, \\\n+                         perhaps an -L flag is missing?\", name));\n+}"}, {"sha": "9ebbdd7c3c936eefdde8466292c4cb34f5337458", "filename": "src/librustc_codegen_ssa/back/command.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "previous_filename": "src/librustc_codegen_utils/command.rs"}, {"sha": "b0575b841d5d5daa1dcfa1e8c3e2331af208b9f5", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -0,0 +1,208 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// For all the linkers we support, and information they might\n+/// need out of the shared crate context before we get rid of it.\n+\n+use rustc::session::{Session, config};\n+use rustc::session::search_paths::PathKind;\n+use rustc::middle::dependency_format::Linkage;\n+use rustc::middle::cstore::LibSource;\n+use rustc_target::spec::LinkerFlavor;\n+use rustc::hir::def_id::CrateNum;\n+\n+use super::command::Command;\n+use CrateInfo;\n+\n+use cc::windows_registry;\n+use std::fs;\n+use std::path::{Path, PathBuf};\n+use std::env;\n+\n+pub fn remove(sess: &Session, path: &Path) {\n+    if let Err(e) = fs::remove_file(path) {\n+        sess.err(&format!(\"failed to remove {}: {}\",\n+                          path.display(),\n+                          e));\n+    }\n+}\n+\n+// The third parameter is for env vars, used on windows to set up the\n+// path for MSVC to find its DLLs, and gcc to find its bundled\n+// toolchain\n+pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathBuf, Command) {\n+    let msvc_tool = windows_registry::find_tool(&sess.opts.target_triple.triple(), \"link.exe\");\n+\n+    // If our linker looks like a batch script on Windows then to execute this\n+    // we'll need to spawn `cmd` explicitly. This is primarily done to handle\n+    // emscripten where the linker is `emcc.bat` and needs to be spawned as\n+    // `cmd /c emcc.bat ...`.\n+    //\n+    // This worked historically but is needed manually since #42436 (regression\n+    // was tagged as #42791) and some more info can be found on #44443 for\n+    // emscripten itself.\n+    let mut cmd = match linker.to_str() {\n+        Some(linker) if cfg!(windows) && linker.ends_with(\".bat\") => Command::bat_script(linker),\n+        _ => match flavor {\n+            LinkerFlavor::Lld(f) => Command::lld(linker, f),\n+            LinkerFlavor::Msvc\n+                if sess.opts.cg.linker.is_none() && sess.target.target.options.linker.is_none() =>\n+            {\n+                Command::new(msvc_tool.as_ref().map(|t| t.path()).unwrap_or(linker))\n+            },\n+            _ => Command::new(linker),\n+        }\n+    };\n+\n+    // The compiler's sysroot often has some bundled tools, so add it to the\n+    // PATH for the child.\n+    let mut new_path = sess.host_filesearch(PathKind::All)\n+                           .get_tools_search_paths();\n+    let mut msvc_changed_path = false;\n+    if sess.target.target.options.is_like_msvc {\n+        if let Some(ref tool) = msvc_tool {\n+            cmd.args(tool.args());\n+            for &(ref k, ref v) in tool.env() {\n+                if k == \"PATH\" {\n+                    new_path.extend(env::split_paths(v));\n+                    msvc_changed_path = true;\n+                } else {\n+                    cmd.env(k, v);\n+                }\n+            }\n+        }\n+    }\n+\n+    if !msvc_changed_path {\n+        if let Some(path) = env::var_os(\"PATH\") {\n+            new_path.extend(env::split_paths(&path));\n+        }\n+    }\n+    cmd.env(\"PATH\", env::join_paths(new_path).unwrap());\n+\n+    (linker.to_path_buf(), cmd)\n+}\n+\n+pub fn each_linked_rlib(sess: &Session,\n+                               info: &CrateInfo,\n+                               f: &mut dyn FnMut(CrateNum, &Path)) -> Result<(), String> {\n+    let crates = info.used_crates_static.iter();\n+    let fmts = sess.dependency_formats.borrow();\n+    let fmts = fmts.get(&config::CrateType::Executable)\n+                   .or_else(|| fmts.get(&config::CrateType::Staticlib))\n+                   .or_else(|| fmts.get(&config::CrateType::Cdylib))\n+                   .or_else(|| fmts.get(&config::CrateType::ProcMacro));\n+    let fmts = match fmts {\n+        Some(f) => f,\n+        None => return Err(\"could not find formats for rlibs\".to_string())\n+    };\n+    for &(cnum, ref path) in crates {\n+        match fmts.get(cnum.as_usize() - 1) {\n+            Some(&Linkage::NotLinked) |\n+            Some(&Linkage::IncludedFromDylib) => continue,\n+            Some(_) => {}\n+            None => return Err(\"could not find formats for rlibs\".to_string())\n+        }\n+        let name = &info.crate_name[&cnum];\n+        let path = match *path {\n+            LibSource::Some(ref p) => p,\n+            LibSource::MetadataOnly => {\n+                return Err(format!(\"could not find rlib for: `{}`, found rmeta (metadata) file\",\n+                                   name))\n+            }\n+            LibSource::None => {\n+                return Err(format!(\"could not find rlib for: `{}`\", name))\n+            }\n+        };\n+        f(cnum, &path);\n+    }\n+    Ok(())\n+}\n+\n+/// Returns a boolean indicating whether the specified crate should be ignored\n+/// during LTO.\n+///\n+/// Crates ignored during LTO are not lumped together in the \"massive object\n+/// file\" that we create and are linked in their normal rlib states. See\n+/// comments below for what crates do not participate in LTO.\n+///\n+/// It's unusual for a crate to not participate in LTO. Typically only\n+/// compiler-specific and unstable crates have a reason to not participate in\n+/// LTO.\n+pub fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum) -> bool {\n+    // If our target enables builtin function lowering in LLVM then the\n+    // crates providing these functions don't participate in LTO (e.g.\n+    // no_builtins or compiler builtins crates).\n+    !sess.target.target.options.no_builtins &&\n+        (info.compiler_builtins == Some(cnum) || info.is_no_builtins.contains(&cnum))\n+}\n+\n+pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n+    fn infer_from(\n+        sess: &Session,\n+        linker: Option<PathBuf>,\n+        flavor: Option<LinkerFlavor>,\n+    ) -> Option<(PathBuf, LinkerFlavor)> {\n+        match (linker, flavor) {\n+            (Some(linker), Some(flavor)) => Some((linker, flavor)),\n+            // only the linker flavor is known; use the default linker for the selected flavor\n+            (None, Some(flavor)) => Some((PathBuf::from(match flavor {\n+                LinkerFlavor::Em  => if cfg!(windows) { \"emcc.bat\" } else { \"emcc\" },\n+                LinkerFlavor::Gcc => \"cc\",\n+                LinkerFlavor::Ld => \"ld\",\n+                LinkerFlavor::Msvc => \"link.exe\",\n+                LinkerFlavor::Lld(_) => \"lld\",\n+            }), flavor)),\n+            (Some(linker), None) => {\n+                let stem = linker.file_stem().and_then(|stem| stem.to_str()).unwrap_or_else(|| {\n+                    sess.fatal(\"couldn't extract file stem from specified linker\");\n+                }).to_owned();\n+\n+                let flavor = if stem == \"emcc\" {\n+                    LinkerFlavor::Em\n+                } else if stem == \"gcc\" || stem.ends_with(\"-gcc\") {\n+                    LinkerFlavor::Gcc\n+                } else if stem == \"ld\" || stem == \"ld.lld\" || stem.ends_with(\"-ld\") {\n+                    LinkerFlavor::Ld\n+                } else if stem == \"link\" || stem == \"lld-link\" {\n+                    LinkerFlavor::Msvc\n+                } else if stem == \"lld\" || stem == \"rust-lld\" {\n+                    LinkerFlavor::Lld(sess.target.target.options.lld_flavor)\n+                } else {\n+                    // fall back to the value in the target spec\n+                    sess.target.target.linker_flavor\n+                };\n+\n+                Some((linker, flavor))\n+            },\n+            (None, None) => None,\n+        }\n+    }\n+\n+    // linker and linker flavor specified via command line have precedence over what the target\n+    // specification specifies\n+    if let Some(ret) = infer_from(\n+        sess,\n+        sess.opts.cg.linker.clone(),\n+        sess.opts.debugging_opts.linker_flavor,\n+    ) {\n+        return ret;\n+    }\n+\n+    if let Some(ret) = infer_from(\n+        sess,\n+        sess.target.target.options.linker.clone().map(PathBuf::from),\n+        Some(sess.target.target.linker_flavor),\n+    ) {\n+        return ret;\n+    }\n+\n+    bug!(\"Not enough information provided to determine how to invoke the linker\");\n+}"}, {"sha": "da9cfbb94d1c5425ba2df5239fc51a1723e2337e", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "renamed", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -8,14 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use super::symbol_export;\n+use super::command::Command;\n+use super::archive;\n+\n use rustc_data_structures::fx::FxHashMap;\n use std::ffi::{OsStr, OsString};\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufWriter};\n use std::path::{Path, PathBuf};\n \n-use command::Command;\n use rustc::hir::def_id::{LOCAL_CRATE, CrateNum};\n use rustc::middle::dependency_format::Linkage;\n use rustc::session::Session;\n@@ -256,7 +259,7 @@ impl<'a> Linker for GccLinker<'a> {\n             // -force_load is the macOS equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n             self.linker_arg(\"-force_load\");\n-            let lib = ::find_library(lib, search_path, &self.sess);\n+            let lib = archive::find_library(lib, search_path, &self.sess);\n             self.linker_arg(&lib);\n         }\n     }\n@@ -878,36 +881,6 @@ impl<'a> Linker for EmLinker<'a> {\n     }\n }\n \n-fn exported_symbols(tcx: TyCtxt, crate_type: CrateType) -> Vec<String> {\n-    let mut symbols = Vec::new();\n-\n-    let export_threshold =\n-        ::symbol_export::crates_export_threshold(&[crate_type]);\n-    for &(symbol, level) in tcx.exported_symbols(LOCAL_CRATE).iter() {\n-        if level.is_below_threshold(export_threshold) {\n-            symbols.push(symbol.symbol_name(tcx).to_string());\n-        }\n-    }\n-\n-    let formats = tcx.sess.dependency_formats.borrow();\n-    let deps = formats[&crate_type].iter();\n-\n-    for (index, dep_format) in deps.enumerate() {\n-        let cnum = CrateNum::new(index + 1);\n-        // For each dependency that we are linking to statically ...\n-        if *dep_format == Linkage::Static {\n-            // ... we add its symbol list to our export list.\n-            for &(symbol, level) in tcx.exported_symbols(cnum).iter() {\n-                if level.is_below_threshold(export_threshold) {\n-                    symbols.push(symbol.symbol_name(tcx).to_string());\n-                }\n-            }\n-        }\n-    }\n-\n-    symbols\n-}\n-\n pub struct WasmLd<'a> {\n     cmd: Command,\n     sess: &'a Session,\n@@ -1075,3 +1048,32 @@ impl<'a> Linker for WasmLd<'a> {\n         // Do nothing for now\n     }\n }\n+\n+fn exported_symbols(tcx: TyCtxt, crate_type: CrateType) -> Vec<String> {\n+    let mut symbols = Vec::new();\n+\n+    let export_threshold = symbol_export::crates_export_threshold(&[crate_type]);\n+    for &(symbol, level) in tcx.exported_symbols(LOCAL_CRATE).iter() {\n+        if level.is_below_threshold(export_threshold) {\n+            symbols.push(symbol.symbol_name(tcx).to_string());\n+        }\n+    }\n+\n+    let formats = tcx.sess.dependency_formats.borrow();\n+    let deps = formats[&crate_type].iter();\n+\n+    for (index, dep_format) in deps.enumerate() {\n+        let cnum = CrateNum::new(index + 1);\n+        // For each dependency that we are linking to statically ...\n+        if *dep_format == Linkage::Static {\n+            // ... we add its symbol list to our export list.\n+            for &(symbol, level) in tcx.exported_symbols(cnum).iter() {\n+                if level.is_below_threshold(export_threshold) {\n+                    symbols.push(symbol.symbol_name(tcx).to_string());\n+                }\n+            }\n+        }\n+    }\n+\n+    symbols\n+}", "previous_filename": "src/librustc_codegen_utils/linker.rs"}, {"sha": "8d03edca004f6fa95bd0a22c9eb822a96ce69914", "filename": "src/librustc_codegen_ssa/back/lto.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flto.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::write::CodegenContext;\n+use traits::*;\n+use ModuleCodegen;\n+\n+use rustc::util::time_graph::Timeline;\n+use rustc_errors::FatalError;\n+\n+use std::sync::Arc;\n+use std::ffi::CString;\n+\n+pub struct ThinModule<B: WriteBackendMethods> {\n+    pub shared: Arc<ThinShared<B>>,\n+    pub idx: usize,\n+}\n+\n+impl<B: WriteBackendMethods> ThinModule<B> {\n+    pub fn name(&self) -> &str {\n+        self.shared.module_names[self.idx].to_str().unwrap()\n+    }\n+\n+    pub fn cost(&self) -> u64 {\n+        // Yes, that's correct, we're using the size of the bytecode as an\n+        // indicator for how costly this codegen unit is.\n+        self.data().len() as u64\n+    }\n+\n+    pub fn data(&self) -> &[u8] {\n+        let a = self.shared.thin_buffers.get(self.idx).map(|b| b.data());\n+        a.unwrap_or_else(|| {\n+            let len = self.shared.thin_buffers.len();\n+            self.shared.serialized_modules[self.idx - len].data()\n+        })\n+    }\n+}\n+\n+pub struct ThinShared<B: WriteBackendMethods> {\n+    pub data: B::ThinData,\n+    pub thin_buffers: Vec<B::ThinBuffer>,\n+    pub serialized_modules: Vec<SerializedModule<B::ModuleBuffer>>,\n+    pub module_names: Vec<CString>,\n+}\n+\n+\n+pub enum LtoModuleCodegen<B: WriteBackendMethods> {\n+    Fat {\n+        module: Option<ModuleCodegen<B::Module>>,\n+        _serialized_bitcode: Vec<SerializedModule<B::ModuleBuffer>>,\n+    },\n+\n+    Thin(ThinModule<B>),\n+}\n+\n+impl<B: WriteBackendMethods> LtoModuleCodegen<B> {\n+    pub fn name(&self) -> &str {\n+        match *self {\n+            LtoModuleCodegen::Fat { .. } => \"everything\",\n+            LtoModuleCodegen::Thin(ref m) => m.name(),\n+        }\n+    }\n+\n+    /// Optimize this module within the given codegen context.\n+    ///\n+    /// This function is unsafe as it'll return a `ModuleCodegen` still\n+    /// points to LLVM data structures owned by this `LtoModuleCodegen`.\n+    /// It's intended that the module returned is immediately code generated and\n+    /// dropped, and then this LTO module is dropped.\n+    pub unsafe fn optimize(\n+        &mut self,\n+        cgcx: &CodegenContext<B>,\n+        timeline: &mut Timeline\n+    ) -> Result<ModuleCodegen<B::Module>, FatalError> {\n+        match *self {\n+            LtoModuleCodegen::Fat { ref mut module, .. } => {\n+                let module = module.take().unwrap();\n+                {\n+                    let config = cgcx.config(module.kind);\n+                    B::run_lto_pass_manager(cgcx, &module, config, false);\n+                    timeline.record(\"fat-done\");\n+                }\n+                Ok(module)\n+            }\n+            LtoModuleCodegen::Thin(ref mut thin) => B::optimize_thin(cgcx, thin, timeline),\n+        }\n+    }\n+\n+    /// A \"gauge\" of how costly it is to optimize this module, used to sort\n+    /// biggest modules first.\n+    pub fn cost(&self) -> u64 {\n+        match *self {\n+            // Only one module with fat LTO, so the cost doesn't matter.\n+            LtoModuleCodegen::Fat { .. } => 0,\n+            LtoModuleCodegen::Thin(ref m) => m.cost(),\n+        }\n+    }\n+}\n+\n+\n+pub enum SerializedModule<M: ModuleBufferMethods> {\n+    Local(M),\n+    FromRlib(Vec<u8>),\n+    FromUncompressedFile(memmap::Mmap),\n+}\n+\n+impl<M: ModuleBufferMethods> SerializedModule<M> {\n+    pub fn data(&self) -> &[u8] {\n+        match *self {\n+            SerializedModule::Local(ref m) => m.data(),\n+            SerializedModule::FromRlib(ref m) => m,\n+            SerializedModule::FromUncompressedFile(ref m) => m,\n+        }\n+    }\n+}"}, {"sha": "3d7ead74d1c5dc69d38a5d94919c0d1a814698cd", "filename": "src/librustc_codegen_ssa/back/mod.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod write;\n+pub mod linker;\n+pub mod lto;\n+pub mod link;\n+pub mod command;\n+pub mod symbol_export;\n+pub mod archive;"}, {"sha": "dff7e518630e4d23628aea3f6db9000caf04a35a", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "previous_filename": "src/librustc_codegen_utils/symbol_export.rs"}, {"sha": "46aee5339ba9e4396379ebf5bf58acce3566cfef", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "added", "additions": 1853, "deletions": 0, "changes": 1853, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -0,0 +1,1853 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use {ModuleCodegen, ModuleKind, CachedModuleCodegen, CompiledModule, CrateInfo, CodegenResults,\n+    RLIB_BYTECODE_EXTENSION};\n+use super::linker::LinkerInfo;\n+use super::lto::{self, SerializedModule};\n+use super::link::{self, remove, get_linker};\n+use super::command::Command;\n+use super::symbol_export::ExportedSymbols;\n+\n+use memmap;\n+use rustc_incremental::{copy_cgu_workproducts_to_incr_comp_cache_dir,\n+                        in_incr_comp_dir, in_incr_comp_dir_sess};\n+use rustc::dep_graph::{WorkProduct, WorkProductId, WorkProductFileKind};\n+use rustc::dep_graph::cgu_reuse_tracker::CguReuseTracker;\n+use rustc::middle::cstore::EncodedMetadata;\n+use rustc::session::config::{self, OutputFilenames, OutputType, Passes, Sanitizer, Lto};\n+use rustc::session::Session;\n+use rustc::util::nodemap::FxHashMap;\n+use rustc::util::time_graph::{self, TimeGraph, Timeline};\n+use traits::*;\n+use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n+use rustc::ty::TyCtxt;\n+use rustc::util::common::{time_depth, set_time_depth, print_time_passes_entry};\n+use rustc_fs_util::link_or_copy;\n+use rustc_data_structures::svh::Svh;\n+use rustc_errors::{Handler, Level, DiagnosticBuilder, FatalError, DiagnosticId};\n+use rustc_errors::emitter::{Emitter};\n+use syntax::attr;\n+use syntax::ext::hygiene::Mark;\n+use syntax_pos::MultiSpan;\n+use syntax_pos::symbol::Symbol;\n+use jobserver::{Client, Acquired};\n+\n+use std::any::Any;\n+use std::fs;\n+use std::io;\n+use std::mem;\n+use std::path::{Path, PathBuf};\n+use std::str;\n+use std::sync::Arc;\n+use std::sync::mpsc::{channel, Sender, Receiver};\n+use std::time::Instant;\n+use std::thread;\n+\n+const PRE_THIN_LTO_BC_EXT: &str = \"pre-thin-lto.bc\";\n+\n+/// Module-specific configuration for `optimize_and_codegen`.\n+pub struct ModuleConfig {\n+    /// Names of additional optimization passes to run.\n+    pub passes: Vec<String>,\n+    /// Some(level) to optimize at a certain level, or None to run\n+    /// absolutely no optimizations (used for the metadata module).\n+    pub opt_level: Option<config::OptLevel>,\n+\n+    /// Some(level) to optimize binary size, or None to not affect program size.\n+    pub opt_size: Option<config::OptLevel>,\n+\n+    pub pgo_gen: Option<String>,\n+    pub pgo_use: String,\n+\n+    // Flags indicating which outputs to produce.\n+    pub emit_pre_thin_lto_bc: bool,\n+    pub emit_no_opt_bc: bool,\n+    pub emit_bc: bool,\n+    pub emit_bc_compressed: bool,\n+    pub emit_lto_bc: bool,\n+    pub emit_ir: bool,\n+    pub emit_asm: bool,\n+    pub emit_obj: bool,\n+    // Miscellaneous flags.  These are mostly copied from command-line\n+    // options.\n+    pub verify_llvm_ir: bool,\n+    pub no_prepopulate_passes: bool,\n+    pub no_builtins: bool,\n+    pub time_passes: bool,\n+    pub vectorize_loop: bool,\n+    pub vectorize_slp: bool,\n+    pub merge_functions: bool,\n+    pub inline_threshold: Option<usize>,\n+    // Instead of creating an object file by doing LLVM codegen, just\n+    // make the object file bitcode. Provides easy compatibility with\n+    // emscripten's ecc compiler, when used as the linker.\n+    pub obj_is_bitcode: bool,\n+    pub no_integrated_as: bool,\n+    pub embed_bitcode: bool,\n+    pub embed_bitcode_marker: bool,\n+}\n+\n+impl ModuleConfig {\n+    fn new(passes: Vec<String>) -> ModuleConfig {\n+        ModuleConfig {\n+            passes,\n+            opt_level: None,\n+            opt_size: None,\n+\n+            pgo_gen: None,\n+            pgo_use: String::new(),\n+\n+            emit_no_opt_bc: false,\n+            emit_pre_thin_lto_bc: false,\n+            emit_bc: false,\n+            emit_bc_compressed: false,\n+            emit_lto_bc: false,\n+            emit_ir: false,\n+            emit_asm: false,\n+            emit_obj: false,\n+            obj_is_bitcode: false,\n+            embed_bitcode: false,\n+            embed_bitcode_marker: false,\n+            no_integrated_as: false,\n+\n+            verify_llvm_ir: false,\n+            no_prepopulate_passes: false,\n+            no_builtins: false,\n+            time_passes: false,\n+            vectorize_loop: false,\n+            vectorize_slp: false,\n+            merge_functions: false,\n+            inline_threshold: None\n+        }\n+    }\n+\n+    fn set_flags(&mut self, sess: &Session, no_builtins: bool) {\n+        self.verify_llvm_ir = sess.verify_llvm_ir();\n+        self.no_prepopulate_passes = sess.opts.cg.no_prepopulate_passes;\n+        self.no_builtins = no_builtins || sess.target.target.options.no_builtins;\n+        self.time_passes = sess.time_passes();\n+        self.inline_threshold = sess.opts.cg.inline_threshold;\n+        self.obj_is_bitcode = sess.target.target.options.obj_is_bitcode ||\n+                              sess.opts.debugging_opts.cross_lang_lto.enabled();\n+        let embed_bitcode = sess.target.target.options.embed_bitcode ||\n+                            sess.opts.debugging_opts.embed_bitcode;\n+        if embed_bitcode {\n+            match sess.opts.optimize {\n+                config::OptLevel::No |\n+                config::OptLevel::Less => {\n+                    self.embed_bitcode_marker = embed_bitcode;\n+                }\n+                _ => self.embed_bitcode = embed_bitcode,\n+            }\n+        }\n+\n+        // Copy what clang does by turning on loop vectorization at O2 and\n+        // slp vectorization at O3. Otherwise configure other optimization aspects\n+        // of this pass manager builder.\n+        // Turn off vectorization for emscripten, as it's not very well supported.\n+        self.vectorize_loop = !sess.opts.cg.no_vectorize_loops &&\n+                             (sess.opts.optimize == config::OptLevel::Default ||\n+                              sess.opts.optimize == config::OptLevel::Aggressive) &&\n+                             !sess.target.target.options.is_like_emscripten;\n+\n+        self.vectorize_slp = !sess.opts.cg.no_vectorize_slp &&\n+                            sess.opts.optimize == config::OptLevel::Aggressive &&\n+                            !sess.target.target.options.is_like_emscripten;\n+\n+        self.merge_functions = sess.opts.optimize == config::OptLevel::Default ||\n+                               sess.opts.optimize == config::OptLevel::Aggressive;\n+    }\n+\n+    pub fn bitcode_needed(&self) -> bool {\n+        self.emit_bc || self.obj_is_bitcode\n+            || self.emit_bc_compressed || self.embed_bitcode\n+    }\n+}\n+\n+/// Assembler name and command used by codegen when no_integrated_as is enabled\n+pub struct AssemblerCommand {\n+    name: PathBuf,\n+    cmd: Command,\n+}\n+\n+// HACK(eddyb) work around `#[derive]` producing wrong bounds for `Clone`.\n+pub struct TargetMachineFactory<B: WriteBackendMethods>(\n+    pub Arc<dyn Fn() -> Result<B::TargetMachine, String> + Send + Sync>,\n+);\n+\n+impl<B: WriteBackendMethods> Clone for TargetMachineFactory<B> {\n+    fn clone(&self) -> Self {\n+        TargetMachineFactory(self.0.clone())\n+    }\n+}\n+\n+/// Additional resources used by optimize_and_codegen (not module specific)\n+#[derive(Clone)]\n+pub struct CodegenContext<B: WriteBackendMethods> {\n+    // Resources needed when running LTO\n+    pub backend: B,\n+    pub time_passes: bool,\n+    pub lto: Lto,\n+    pub no_landing_pads: bool,\n+    pub save_temps: bool,\n+    pub fewer_names: bool,\n+    pub exported_symbols: Option<Arc<ExportedSymbols>>,\n+    pub opts: Arc<config::Options>,\n+    pub crate_types: Vec<config::CrateType>,\n+    pub each_linked_rlib_for_lto: Vec<(CrateNum, PathBuf)>,\n+    pub output_filenames: Arc<OutputFilenames>,\n+    pub regular_module_config: Arc<ModuleConfig>,\n+    pub metadata_module_config: Arc<ModuleConfig>,\n+    pub allocator_module_config: Arc<ModuleConfig>,\n+    pub tm_factory: TargetMachineFactory<B>,\n+    pub msvc_imps_needed: bool,\n+    pub target_pointer_width: String,\n+    pub debuginfo: config::DebugInfo,\n+\n+    // Number of cgus excluding the allocator/metadata modules\n+    pub total_cgus: usize,\n+    // Handler to use for diagnostics produced during codegen.\n+    pub diag_emitter: SharedEmitter,\n+    // LLVM passes added by plugins.\n+    pub plugin_passes: Vec<String>,\n+    // LLVM optimizations for which we want to print remarks.\n+    pub remark: Passes,\n+    // Worker thread number\n+    pub worker: usize,\n+    // The incremental compilation session directory, or None if we are not\n+    // compiling incrementally\n+    pub incr_comp_session_dir: Option<PathBuf>,\n+    // Used to update CGU re-use information during the thinlto phase.\n+    pub cgu_reuse_tracker: CguReuseTracker,\n+    // Channel back to the main control thread to send messages to\n+    pub coordinator_send: Sender<Box<dyn Any + Send>>,\n+    // A reference to the TimeGraph so we can register timings. None means that\n+    // measuring is disabled.\n+    pub time_graph: Option<TimeGraph>,\n+    // The assembler command if no_integrated_as option is enabled, None otherwise\n+    pub assembler_cmd: Option<Arc<AssemblerCommand>>\n+}\n+\n+impl<B: WriteBackendMethods> CodegenContext<B> {\n+    pub fn create_diag_handler(&self) -> Handler {\n+        Handler::with_emitter(true, false, Box::new(self.diag_emitter.clone()))\n+    }\n+\n+    pub fn config(&self, kind: ModuleKind) -> &ModuleConfig {\n+        match kind {\n+            ModuleKind::Regular => &self.regular_module_config,\n+            ModuleKind::Metadata => &self.metadata_module_config,\n+            ModuleKind::Allocator => &self.allocator_module_config,\n+        }\n+    }\n+}\n+\n+fn generate_lto_work<B: ExtraBackendMethods>(\n+    cgcx: &CodegenContext<B>,\n+    modules: Vec<ModuleCodegen<B::Module>>,\n+    import_only_modules: Vec<(SerializedModule<B::ModuleBuffer>, WorkProduct)>\n+) -> Vec<(WorkItem<B>, u64)> {\n+    let mut timeline = cgcx.time_graph.as_ref().map(|tg| {\n+        tg.start(CODEGEN_WORKER_TIMELINE,\n+                 CODEGEN_WORK_PACKAGE_KIND,\n+                 \"generate lto\")\n+    }).unwrap_or(Timeline::noop());\n+    let (lto_modules, copy_jobs) = B::run_lto(cgcx, modules, import_only_modules, &mut timeline)\n+        .unwrap_or_else(|e| e.raise());\n+\n+    let lto_modules = lto_modules.into_iter().map(|module| {\n+        let cost = module.cost();\n+        (WorkItem::LTO(module), cost)\n+    });\n+\n+    let copy_jobs = copy_jobs.into_iter().map(|wp| {\n+        (WorkItem::CopyPostLtoArtifacts(CachedModuleCodegen {\n+            name: wp.cgu_name.clone(),\n+            source: wp,\n+        }), 0)\n+    });\n+\n+    lto_modules.chain(copy_jobs).collect()\n+}\n+\n+pub struct CompiledModules {\n+    pub modules: Vec<CompiledModule>,\n+    pub metadata_module: CompiledModule,\n+    pub allocator_module: Option<CompiledModule>,\n+}\n+\n+fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n+    sess.crate_types.borrow().contains(&config::CrateType::Rlib) &&\n+    sess.opts.output_types.contains_key(&OutputType::Exe)\n+}\n+\n+fn need_pre_thin_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n+    if sess.opts.incremental.is_none() {\n+        return false\n+    }\n+\n+    match sess.lto() {\n+        Lto::Fat |\n+        Lto::No => false,\n+        Lto::Thin |\n+        Lto::ThinLocal => true,\n+    }\n+}\n+\n+pub fn start_async_codegen<B: ExtraBackendMethods>(\n+    backend: B,\n+    tcx: TyCtxt,\n+    time_graph: Option<TimeGraph>,\n+    metadata: EncodedMetadata,\n+    coordinator_receive: Receiver<Box<dyn Any + Send>>,\n+    total_cgus: usize\n+) -> OngoingCodegen<B> {\n+    let sess = tcx.sess;\n+    let crate_name = tcx.crate_name(LOCAL_CRATE);\n+    let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n+    let no_builtins = attr::contains_name(&tcx.hir.krate().attrs, \"no_builtins\");\n+    let subsystem = attr::first_attr_value_str_by_name(&tcx.hir.krate().attrs,\n+                                                       \"windows_subsystem\");\n+    let windows_subsystem = subsystem.map(|subsystem| {\n+        if subsystem != \"windows\" && subsystem != \"console\" {\n+            tcx.sess.fatal(&format!(\"invalid windows subsystem `{}`, only \\\n+                                     `windows` and `console` are allowed\",\n+                                    subsystem));\n+        }\n+        subsystem.to_string()\n+    });\n+\n+    let linker_info = LinkerInfo::new(tcx);\n+    let crate_info = CrateInfo::new(tcx);\n+\n+    // Figure out what we actually need to build.\n+    let mut modules_config = ModuleConfig::new(sess.opts.cg.passes.clone());\n+    let mut metadata_config = ModuleConfig::new(vec![]);\n+    let mut allocator_config = ModuleConfig::new(vec![]);\n+\n+    if let Some(ref sanitizer) = sess.opts.debugging_opts.sanitizer {\n+        match *sanitizer {\n+            Sanitizer::Address => {\n+                modules_config.passes.push(\"asan\".to_owned());\n+                modules_config.passes.push(\"asan-module\".to_owned());\n+            }\n+            Sanitizer::Memory => {\n+                modules_config.passes.push(\"msan\".to_owned())\n+            }\n+            Sanitizer::Thread => {\n+                modules_config.passes.push(\"tsan\".to_owned())\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    if sess.opts.debugging_opts.profile {\n+        modules_config.passes.push(\"insert-gcov-profiling\".to_owned())\n+    }\n+\n+    modules_config.pgo_gen = sess.opts.debugging_opts.pgo_gen.clone();\n+    modules_config.pgo_use = sess.opts.debugging_opts.pgo_use.clone();\n+\n+    modules_config.opt_level = Some(sess.opts.optimize);\n+    modules_config.opt_size = Some(sess.opts.optimize);\n+\n+    // Save all versions of the bytecode if we're saving our temporaries.\n+    if sess.opts.cg.save_temps {\n+        modules_config.emit_no_opt_bc = true;\n+        modules_config.emit_pre_thin_lto_bc = true;\n+        modules_config.emit_bc = true;\n+        modules_config.emit_lto_bc = true;\n+        metadata_config.emit_bc = true;\n+        allocator_config.emit_bc = true;\n+    }\n+\n+    // Emit compressed bitcode files for the crate if we're emitting an rlib.\n+    // Whenever an rlib is created, the bitcode is inserted into the archive in\n+    // order to allow LTO against it.\n+    if need_crate_bitcode_for_rlib(sess) {\n+        modules_config.emit_bc_compressed = true;\n+        allocator_config.emit_bc_compressed = true;\n+    }\n+\n+    modules_config.emit_pre_thin_lto_bc =\n+        need_pre_thin_lto_bitcode_for_incr_comp(sess);\n+\n+    modules_config.no_integrated_as = tcx.sess.opts.cg.no_integrated_as ||\n+        tcx.sess.target.target.options.no_integrated_as;\n+\n+    for output_type in sess.opts.output_types.keys() {\n+        match *output_type {\n+            OutputType::Bitcode => { modules_config.emit_bc = true; }\n+            OutputType::LlvmAssembly => { modules_config.emit_ir = true; }\n+            OutputType::Assembly => {\n+                modules_config.emit_asm = true;\n+                // If we're not using the LLVM assembler, this function\n+                // could be invoked specially with output_type_assembly, so\n+                // in this case we still want the metadata object file.\n+                if !sess.opts.output_types.contains_key(&OutputType::Assembly) {\n+                    metadata_config.emit_obj = true;\n+                    allocator_config.emit_obj = true;\n+                }\n+            }\n+            OutputType::Object => { modules_config.emit_obj = true; }\n+            OutputType::Metadata => { metadata_config.emit_obj = true; }\n+            OutputType::Exe => {\n+                modules_config.emit_obj = true;\n+                metadata_config.emit_obj = true;\n+                allocator_config.emit_obj = true;\n+            },\n+            OutputType::Mir => {}\n+            OutputType::DepInfo => {}\n+        }\n+    }\n+\n+    modules_config.set_flags(sess, no_builtins);\n+    metadata_config.set_flags(sess, no_builtins);\n+    allocator_config.set_flags(sess, no_builtins);\n+\n+    // Exclude metadata and allocator modules from time_passes output, since\n+    // they throw off the \"LLVM passes\" measurement.\n+    metadata_config.time_passes = false;\n+    allocator_config.time_passes = false;\n+\n+    let (shared_emitter, shared_emitter_main) = SharedEmitter::new();\n+    let (codegen_worker_send, codegen_worker_receive) = channel();\n+\n+    let coordinator_thread = start_executing_work(backend.clone(),\n+                                                  tcx,\n+                                                  &crate_info,\n+                                                  shared_emitter,\n+                                                  codegen_worker_send,\n+                                                  coordinator_receive,\n+                                                  total_cgus,\n+                                                  sess.jobserver.clone(),\n+                                                  time_graph.clone(),\n+                                                  Arc::new(modules_config),\n+                                                  Arc::new(metadata_config),\n+                                                  Arc::new(allocator_config));\n+\n+    OngoingCodegen {\n+        backend,\n+        crate_name,\n+        crate_hash,\n+        metadata,\n+        windows_subsystem,\n+        linker_info,\n+        crate_info,\n+\n+        time_graph,\n+        coordinator_send: tcx.tx_to_llvm_workers.lock().clone(),\n+        codegen_worker_receive,\n+        shared_emitter_main,\n+        future: coordinator_thread,\n+        output_filenames: tcx.output_filenames(LOCAL_CRATE),\n+    }\n+}\n+\n+fn copy_all_cgu_workproducts_to_incr_comp_cache_dir(\n+    sess: &Session,\n+    compiled_modules: &CompiledModules,\n+) -> FxHashMap<WorkProductId, WorkProduct> {\n+    let mut work_products = FxHashMap::default();\n+\n+    if sess.opts.incremental.is_none() {\n+        return work_products;\n+    }\n+\n+    for module in compiled_modules.modules.iter().filter(|m| m.kind == ModuleKind::Regular) {\n+        let mut files = vec![];\n+\n+        if let Some(ref path) = module.object {\n+            files.push((WorkProductFileKind::Object, path.clone()));\n+        }\n+        if let Some(ref path) = module.bytecode {\n+            files.push((WorkProductFileKind::Bytecode, path.clone()));\n+        }\n+        if let Some(ref path) = module.bytecode_compressed {\n+            files.push((WorkProductFileKind::BytecodeCompressed, path.clone()));\n+        }\n+\n+        if let Some((id, product)) =\n+                copy_cgu_workproducts_to_incr_comp_cache_dir(sess, &module.name, &files) {\n+            work_products.insert(id, product);\n+        }\n+    }\n+\n+    work_products\n+}\n+\n+fn produce_final_output_artifacts(sess: &Session,\n+                                  compiled_modules: &CompiledModules,\n+                                  crate_output: &OutputFilenames) {\n+    let mut user_wants_bitcode = false;\n+    let mut user_wants_objects = false;\n+\n+    // Produce final compile outputs.\n+    let copy_gracefully = |from: &Path, to: &Path| {\n+        if let Err(e) = fs::copy(from, to) {\n+            sess.err(&format!(\"could not copy {:?} to {:?}: {}\", from, to, e));\n+        }\n+    };\n+\n+    let copy_if_one_unit = |output_type: OutputType,\n+                            keep_numbered: bool| {\n+        if compiled_modules.modules.len() == 1 {\n+            // 1) Only one codegen unit.  In this case it's no difficulty\n+            //    to copy `foo.0.x` to `foo.x`.\n+            let module_name = Some(&compiled_modules.modules[0].name[..]);\n+            let path = crate_output.temp_path(output_type, module_name);\n+            copy_gracefully(&path,\n+                            &crate_output.path(output_type));\n+            if !sess.opts.cg.save_temps && !keep_numbered {\n+                // The user just wants `foo.x`, not `foo.#module-name#.x`.\n+                remove(sess, &path);\n+            }\n+        } else {\n+            let ext = crate_output.temp_path(output_type, None)\n+                                  .extension()\n+                                  .unwrap()\n+                                  .to_str()\n+                                  .unwrap()\n+                                  .to_owned();\n+\n+            if crate_output.outputs.contains_key(&output_type) {\n+                // 2) Multiple codegen units, with `--emit foo=some_name`.  We have\n+                //    no good solution for this case, so warn the user.\n+                sess.warn(&format!(\"ignoring emit path because multiple .{} files \\\n+                                    were produced\", ext));\n+            } else if crate_output.single_output_file.is_some() {\n+                // 3) Multiple codegen units, with `-o some_name`.  We have\n+                //    no good solution for this case, so warn the user.\n+                sess.warn(&format!(\"ignoring -o because multiple .{} files \\\n+                                    were produced\", ext));\n+            } else {\n+                // 4) Multiple codegen units, but no explicit name.  We\n+                //    just leave the `foo.0.x` files in place.\n+                // (We don't have to do any work in this case.)\n+            }\n+        }\n+    };\n+\n+    // Flag to indicate whether the user explicitly requested bitcode.\n+    // Otherwise, we produced it only as a temporary output, and will need\n+    // to get rid of it.\n+    for output_type in crate_output.outputs.keys() {\n+        match *output_type {\n+            OutputType::Bitcode => {\n+                user_wants_bitcode = true;\n+                // Copy to .bc, but always keep the .0.bc.  There is a later\n+                // check to figure out if we should delete .0.bc files, or keep\n+                // them for making an rlib.\n+                copy_if_one_unit(OutputType::Bitcode, true);\n+            }\n+            OutputType::LlvmAssembly => {\n+                copy_if_one_unit(OutputType::LlvmAssembly, false);\n+            }\n+            OutputType::Assembly => {\n+                copy_if_one_unit(OutputType::Assembly, false);\n+            }\n+            OutputType::Object => {\n+                user_wants_objects = true;\n+                copy_if_one_unit(OutputType::Object, true);\n+            }\n+            OutputType::Mir |\n+            OutputType::Metadata |\n+            OutputType::Exe |\n+            OutputType::DepInfo => {}\n+        }\n+    }\n+\n+    // Clean up unwanted temporary files.\n+\n+    // We create the following files by default:\n+    //  - #crate#.#module-name#.bc\n+    //  - #crate#.#module-name#.o\n+    //  - #crate#.crate.metadata.bc\n+    //  - #crate#.crate.metadata.o\n+    //  - #crate#.o (linked from crate.##.o)\n+    //  - #crate#.bc (copied from crate.##.bc)\n+    // We may create additional files if requested by the user (through\n+    // `-C save-temps` or `--emit=` flags).\n+\n+    if !sess.opts.cg.save_temps {\n+        // Remove the temporary .#module-name#.o objects.  If the user didn't\n+        // explicitly request bitcode (with --emit=bc), and the bitcode is not\n+        // needed for building an rlib, then we must remove .#module-name#.bc as\n+        // well.\n+\n+        // Specific rules for keeping .#module-name#.bc:\n+        //  - If the user requested bitcode (`user_wants_bitcode`), and\n+        //    codegen_units > 1, then keep it.\n+        //  - If the user requested bitcode but codegen_units == 1, then we\n+        //    can toss .#module-name#.bc because we copied it to .bc earlier.\n+        //  - If we're not building an rlib and the user didn't request\n+        //    bitcode, then delete .#module-name#.bc.\n+        // If you change how this works, also update back::link::link_rlib,\n+        // where .#module-name#.bc files are (maybe) deleted after making an\n+        // rlib.\n+        let needs_crate_object = crate_output.outputs.contains_key(&OutputType::Exe);\n+\n+        let keep_numbered_bitcode = user_wants_bitcode && sess.codegen_units() > 1;\n+\n+        let keep_numbered_objects = needs_crate_object ||\n+                (user_wants_objects && sess.codegen_units() > 1);\n+\n+        for module in compiled_modules.modules.iter() {\n+            if let Some(ref path) = module.object {\n+                if !keep_numbered_objects {\n+                    remove(sess, path);\n+                }\n+            }\n+\n+            if let Some(ref path) = module.bytecode {\n+                if !keep_numbered_bitcode {\n+                    remove(sess, path);\n+                }\n+            }\n+        }\n+\n+        if !user_wants_bitcode {\n+            if let Some(ref path) = compiled_modules.metadata_module.bytecode {\n+                remove(sess, &path);\n+            }\n+\n+            if let Some(ref allocator_module) = compiled_modules.allocator_module {\n+                if let Some(ref path) = allocator_module.bytecode {\n+                    remove(sess, path);\n+                }\n+            }\n+        }\n+    }\n+\n+    // We leave the following files around by default:\n+    //  - #crate#.o\n+    //  - #crate#.crate.metadata.o\n+    //  - #crate#.bc\n+    // These are used in linking steps and will be cleaned up afterward.\n+}\n+\n+pub fn dump_incremental_data(_codegen_results: &CodegenResults) {\n+    // FIXME(mw): This does not work at the moment because the situation has\n+    //            become more complicated due to incremental LTO. Now a CGU\n+    //            can have more than two caching states.\n+    // println!(\"[incremental] Re-using {} out of {} modules\",\n+    //           codegen_results.modules.iter().filter(|m| m.pre_existing).count(),\n+    //           codegen_results.modules.len());\n+}\n+\n+pub enum WorkItem<B: WriteBackendMethods> {\n+    /// Optimize a newly codegened, totally unoptimized module.\n+    Optimize(ModuleCodegen<B::Module>),\n+    /// Copy the post-LTO artifacts from the incremental cache to the output\n+    /// directory.\n+    CopyPostLtoArtifacts(CachedModuleCodegen),\n+    /// Perform (Thin)LTO on the given module.\n+    LTO(lto::LtoModuleCodegen<B>),\n+}\n+\n+impl<B: WriteBackendMethods> WorkItem<B> {\n+    pub fn module_kind(&self) -> ModuleKind {\n+        match *self {\n+            WorkItem::Optimize(ref m) => m.kind,\n+            WorkItem::CopyPostLtoArtifacts(_) |\n+            WorkItem::LTO(_) => ModuleKind::Regular,\n+        }\n+    }\n+\n+    pub fn name(&self) -> String {\n+        match *self {\n+            WorkItem::Optimize(ref m) => format!(\"optimize: {}\", m.name),\n+            WorkItem::CopyPostLtoArtifacts(ref m) => format!(\"copy post LTO artifacts: {}\", m.name),\n+            WorkItem::LTO(ref m) => format!(\"lto: {}\", m.name()),\n+        }\n+    }\n+}\n+\n+enum WorkItemResult<M> {\n+    Compiled(CompiledModule),\n+    NeedsLTO(ModuleCodegen<M>),\n+}\n+\n+fn execute_work_item<B: ExtraBackendMethods>(\n+    cgcx: &CodegenContext<B>,\n+    work_item: WorkItem<B>,\n+    timeline: &mut Timeline\n+) -> Result<WorkItemResult<B::Module>, FatalError> {\n+    let module_config = cgcx.config(work_item.module_kind());\n+\n+    match work_item {\n+        WorkItem::Optimize(module) => {\n+            execute_optimize_work_item(cgcx, module, module_config, timeline)\n+        }\n+        WorkItem::CopyPostLtoArtifacts(module) => {\n+            execute_copy_from_cache_work_item(cgcx, module, module_config, timeline)\n+        }\n+        WorkItem::LTO(module) => {\n+            execute_lto_work_item(cgcx, module, module_config, timeline)\n+        }\n+    }\n+}\n+\n+fn execute_optimize_work_item<B: ExtraBackendMethods>(\n+    cgcx: &CodegenContext<B>,\n+    module: ModuleCodegen<B::Module>,\n+    module_config: &ModuleConfig,\n+    timeline: &mut Timeline\n+) -> Result<WorkItemResult<B::Module>, FatalError> {\n+    let diag_handler = cgcx.create_diag_handler();\n+\n+    unsafe {\n+        B::optimize(cgcx, &diag_handler, &module, module_config, timeline)?;\n+    }\n+\n+    let linker_does_lto = cgcx.opts.debugging_opts.cross_lang_lto.enabled();\n+\n+    // After we've done the initial round of optimizations we need to\n+    // decide whether to synchronously codegen this module or ship it\n+    // back to the coordinator thread for further LTO processing (which\n+    // has to wait for all the initial modules to be optimized).\n+    //\n+    // Here we dispatch based on the `cgcx.lto` and kind of module we're\n+    // codegenning...\n+    let needs_lto = match cgcx.lto {\n+        Lto::No => false,\n+\n+        // If the linker does LTO, we don't have to do it. Note that we\n+        // keep doing full LTO, if it is requested, as not to break the\n+        // assumption that the output will be a single module.\n+        Lto::Thin | Lto::ThinLocal if linker_does_lto => false,\n+\n+        // Here we've got a full crate graph LTO requested. We ignore\n+        // this, however, if the crate type is only an rlib as there's\n+        // no full crate graph to process, that'll happen later.\n+        //\n+        // This use case currently comes up primarily for targets that\n+        // require LTO so the request for LTO is always unconditionally\n+        // passed down to the backend, but we don't actually want to do\n+        // anything about it yet until we've got a final product.\n+        Lto::Fat | Lto::Thin => {\n+            cgcx.crate_types.len() != 1 ||\n+                cgcx.crate_types[0] != config::CrateType::Rlib\n+        }\n+\n+        // When we're automatically doing ThinLTO for multi-codegen-unit\n+        // builds we don't actually want to LTO the allocator modules if\n+        // it shows up. This is due to various linker shenanigans that\n+        // we'll encounter later.\n+        Lto::ThinLocal => {\n+            module.kind != ModuleKind::Allocator\n+        }\n+    };\n+\n+    // Metadata modules never participate in LTO regardless of the lto\n+    // settings.\n+    let needs_lto = needs_lto && module.kind != ModuleKind::Metadata;\n+\n+    if needs_lto {\n+        Ok(WorkItemResult::NeedsLTO(module))\n+    } else {\n+        let module = unsafe { B::codegen(cgcx, &diag_handler, module, module_config, timeline)? };\n+        Ok(WorkItemResult::Compiled(module))\n+    }\n+}\n+\n+fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n+    cgcx: &CodegenContext<B>,\n+    module: CachedModuleCodegen,\n+    module_config: &ModuleConfig,\n+    _: &mut Timeline\n+) -> Result<WorkItemResult<B::Module>, FatalError> {\n+    let incr_comp_session_dir = cgcx.incr_comp_session_dir\n+                                    .as_ref()\n+                                    .unwrap();\n+    let mut object = None;\n+    let mut bytecode = None;\n+    let mut bytecode_compressed = None;\n+    for (kind, saved_file) in &module.source.saved_files {\n+        let obj_out = match kind {\n+            WorkProductFileKind::Object => {\n+                let path = cgcx.output_filenames.temp_path(OutputType::Object,\n+                                                           Some(&module.name));\n+                object = Some(path.clone());\n+                path\n+            }\n+            WorkProductFileKind::Bytecode => {\n+                let path = cgcx.output_filenames.temp_path(OutputType::Bitcode,\n+                                                           Some(&module.name));\n+                bytecode = Some(path.clone());\n+                path\n+            }\n+            WorkProductFileKind::BytecodeCompressed => {\n+                let path = cgcx.output_filenames.temp_path(OutputType::Bitcode,\n+                                                           Some(&module.name))\n+                    .with_extension(RLIB_BYTECODE_EXTENSION);\n+                bytecode_compressed = Some(path.clone());\n+                path\n+            }\n+        };\n+        let source_file = in_incr_comp_dir(&incr_comp_session_dir,\n+                                           &saved_file);\n+        debug!(\"copying pre-existing module `{}` from {:?} to {}\",\n+               module.name,\n+               source_file,\n+               obj_out.display());\n+        if let Err(err) = link_or_copy(&source_file, &obj_out) {\n+            let diag_handler = cgcx.create_diag_handler();\n+            diag_handler.err(&format!(\"unable to copy {} to {}: {}\",\n+                                      source_file.display(),\n+                                      obj_out.display(),\n+                                      err));\n+        }\n+    }\n+\n+    assert_eq!(object.is_some(), module_config.emit_obj);\n+    assert_eq!(bytecode.is_some(), module_config.emit_bc);\n+    assert_eq!(bytecode_compressed.is_some(), module_config.emit_bc_compressed);\n+\n+    Ok(WorkItemResult::Compiled(CompiledModule {\n+        name: module.name,\n+        kind: ModuleKind::Regular,\n+        object,\n+        bytecode,\n+        bytecode_compressed,\n+    }))\n+}\n+\n+fn execute_lto_work_item<B: ExtraBackendMethods>(\n+    cgcx: &CodegenContext<B>,\n+    mut module: lto::LtoModuleCodegen<B>,\n+    module_config: &ModuleConfig,\n+    timeline: &mut Timeline\n+) -> Result<WorkItemResult<B::Module>, FatalError> {\n+    let diag_handler = cgcx.create_diag_handler();\n+\n+    unsafe {\n+        let module = module.optimize(cgcx, timeline)?;\n+        let module = B::codegen(cgcx, &diag_handler, module, module_config, timeline)?;\n+        Ok(WorkItemResult::Compiled(module))\n+    }\n+}\n+\n+pub enum Message<B: WriteBackendMethods> {\n+    Token(io::Result<Acquired>),\n+    NeedsLTO {\n+        result: ModuleCodegen<B::Module>,\n+        worker_id: usize,\n+    },\n+    Done {\n+        result: Result<CompiledModule, ()>,\n+        worker_id: usize,\n+    },\n+    CodegenDone {\n+        llvm_work_item: WorkItem<B>,\n+        cost: u64,\n+    },\n+    AddImportOnlyModule {\n+        module_data: SerializedModule<B::ModuleBuffer>,\n+        work_product: WorkProduct,\n+    },\n+    CodegenComplete,\n+    CodegenItem,\n+    CodegenAborted,\n+}\n+\n+struct Diagnostic {\n+    msg: String,\n+    code: Option<DiagnosticId>,\n+    lvl: Level,\n+}\n+\n+#[derive(PartialEq, Clone, Copy, Debug)]\n+enum MainThreadWorkerState {\n+    Idle,\n+    Codegenning,\n+    LLVMing,\n+}\n+\n+fn start_executing_work<B: ExtraBackendMethods>(\n+    backend: B,\n+    tcx: TyCtxt,\n+    crate_info: &CrateInfo,\n+    shared_emitter: SharedEmitter,\n+    codegen_worker_send: Sender<Message<B>>,\n+    coordinator_receive: Receiver<Box<dyn Any + Send>>,\n+    total_cgus: usize,\n+    jobserver: Client,\n+    time_graph: Option<TimeGraph>,\n+    modules_config: Arc<ModuleConfig>,\n+    metadata_config: Arc<ModuleConfig>,\n+    allocator_config: Arc<ModuleConfig>\n+) -> thread::JoinHandle<Result<CompiledModules, ()>> {\n+    let coordinator_send = tcx.tx_to_llvm_workers.lock().clone();\n+    let sess = tcx.sess;\n+\n+    // Compute the set of symbols we need to retain when doing LTO (if we need to)\n+    let exported_symbols = {\n+        let mut exported_symbols = FxHashMap::default();\n+\n+        let copy_symbols = |cnum| {\n+            let symbols = tcx.exported_symbols(cnum)\n+                             .iter()\n+                             .map(|&(s, lvl)| (s.symbol_name(tcx).to_string(), lvl))\n+                             .collect();\n+            Arc::new(symbols)\n+        };\n+\n+        match sess.lto() {\n+            Lto::No => None,\n+            Lto::ThinLocal => {\n+                exported_symbols.insert(LOCAL_CRATE, copy_symbols(LOCAL_CRATE));\n+                Some(Arc::new(exported_symbols))\n+            }\n+            Lto::Fat | Lto::Thin => {\n+                exported_symbols.insert(LOCAL_CRATE, copy_symbols(LOCAL_CRATE));\n+                for &cnum in tcx.crates().iter() {\n+                    exported_symbols.insert(cnum, copy_symbols(cnum));\n+                }\n+                Some(Arc::new(exported_symbols))\n+            }\n+        }\n+    };\n+\n+    // First up, convert our jobserver into a helper thread so we can use normal\n+    // mpsc channels to manage our messages and such.\n+    // After we've requested tokens then we'll, when we can,\n+    // get tokens on `coordinator_receive` which will\n+    // get managed in the main loop below.\n+    let coordinator_send2 = coordinator_send.clone();\n+    let helper = jobserver.into_helper_thread(move |token| {\n+        drop(coordinator_send2.send(Box::new(Message::Token::<B>(token))));\n+    }).expect(\"failed to spawn helper thread\");\n+\n+    let mut each_linked_rlib_for_lto = Vec::new();\n+    drop(link::each_linked_rlib(sess, crate_info, &mut |cnum, path| {\n+        if link::ignored_for_lto(sess, crate_info, cnum) {\n+            return\n+        }\n+        each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n+    }));\n+\n+    let assembler_cmd = if modules_config.no_integrated_as {\n+        // HACK: currently we use linker (gcc) as our assembler\n+        let (linker, flavor) = link::linker_and_flavor(sess);\n+\n+        let (name, mut cmd) = get_linker(sess, &linker, flavor);\n+        cmd.args(&sess.target.target.options.asm_args);\n+        Some(Arc::new(AssemblerCommand {\n+            name,\n+            cmd,\n+        }))\n+    } else {\n+        None\n+    };\n+\n+    let cgcx = CodegenContext::<B> {\n+        backend: backend.clone(),\n+        crate_types: sess.crate_types.borrow().clone(),\n+        each_linked_rlib_for_lto,\n+        lto: sess.lto(),\n+        no_landing_pads: sess.no_landing_pads(),\n+        fewer_names: sess.fewer_names(),\n+        save_temps: sess.opts.cg.save_temps,\n+        opts: Arc::new(sess.opts.clone()),\n+        time_passes: sess.time_passes(),\n+        exported_symbols,\n+        plugin_passes: sess.plugin_llvm_passes.borrow().clone(),\n+        remark: sess.opts.cg.remark.clone(),\n+        worker: 0,\n+        incr_comp_session_dir: sess.incr_comp_session_dir_opt().map(|r| r.clone()),\n+        cgu_reuse_tracker: sess.cgu_reuse_tracker.clone(),\n+        coordinator_send,\n+        diag_emitter: shared_emitter.clone(),\n+        time_graph,\n+        output_filenames: tcx.output_filenames(LOCAL_CRATE),\n+        regular_module_config: modules_config,\n+        metadata_module_config: metadata_config,\n+        allocator_module_config: allocator_config,\n+        tm_factory: TargetMachineFactory(backend.target_machine_factory(tcx.sess, false)),\n+        total_cgus,\n+        msvc_imps_needed: msvc_imps_needed(tcx),\n+        target_pointer_width: tcx.sess.target.target.target_pointer_width.clone(),\n+        debuginfo: tcx.sess.opts.debuginfo,\n+        assembler_cmd,\n+    };\n+\n+    // This is the \"main loop\" of parallel work happening for parallel codegen.\n+    // It's here that we manage parallelism, schedule work, and work with\n+    // messages coming from clients.\n+    //\n+    // There are a few environmental pre-conditions that shape how the system\n+    // is set up:\n+    //\n+    // - Error reporting only can happen on the main thread because that's the\n+    //   only place where we have access to the compiler `Session`.\n+    // - LLVM work can be done on any thread.\n+    // - Codegen can only happen on the main thread.\n+    // - Each thread doing substantial work most be in possession of a `Token`\n+    //   from the `Jobserver`.\n+    // - The compiler process always holds one `Token`. Any additional `Tokens`\n+    //   have to be requested from the `Jobserver`.\n+    //\n+    // Error Reporting\n+    // ===============\n+    // The error reporting restriction is handled separately from the rest: We\n+    // set up a `SharedEmitter` the holds an open channel to the main thread.\n+    // When an error occurs on any thread, the shared emitter will send the\n+    // error message to the receiver main thread (`SharedEmitterMain`). The\n+    // main thread will periodically query this error message queue and emit\n+    // any error messages it has received. It might even abort compilation if\n+    // has received a fatal error. In this case we rely on all other threads\n+    // being torn down automatically with the main thread.\n+    // Since the main thread will often be busy doing codegen work, error\n+    // reporting will be somewhat delayed, since the message queue can only be\n+    // checked in between to work packages.\n+    //\n+    // Work Processing Infrastructure\n+    // ==============================\n+    // The work processing infrastructure knows three major actors:\n+    //\n+    // - the coordinator thread,\n+    // - the main thread, and\n+    // - LLVM worker threads\n+    //\n+    // The coordinator thread is running a message loop. It instructs the main\n+    // thread about what work to do when, and it will spawn off LLVM worker\n+    // threads as open LLVM WorkItems become available.\n+    //\n+    // The job of the main thread is to codegen CGUs into LLVM work package\n+    // (since the main thread is the only thread that can do this). The main\n+    // thread will block until it receives a message from the coordinator, upon\n+    // which it will codegen one CGU, send it to the coordinator and block\n+    // again. This way the coordinator can control what the main thread is\n+    // doing.\n+    //\n+    // The coordinator keeps a queue of LLVM WorkItems, and when a `Token` is\n+    // available, it will spawn off a new LLVM worker thread and let it process\n+    // that a WorkItem. When a LLVM worker thread is done with its WorkItem,\n+    // it will just shut down, which also frees all resources associated with\n+    // the given LLVM module, and sends a message to the coordinator that the\n+    // has been completed.\n+    //\n+    // Work Scheduling\n+    // ===============\n+    // The scheduler's goal is to minimize the time it takes to complete all\n+    // work there is, however, we also want to keep memory consumption low\n+    // if possible. These two goals are at odds with each other: If memory\n+    // consumption were not an issue, we could just let the main thread produce\n+    // LLVM WorkItems at full speed, assuring maximal utilization of\n+    // Tokens/LLVM worker threads. However, since codegen usual is faster\n+    // than LLVM processing, the queue of LLVM WorkItems would fill up and each\n+    // WorkItem potentially holds on to a substantial amount of memory.\n+    //\n+    // So the actual goal is to always produce just enough LLVM WorkItems as\n+    // not to starve our LLVM worker threads. That means, once we have enough\n+    // WorkItems in our queue, we can block the main thread, so it does not\n+    // produce more until we need them.\n+    //\n+    // Doing LLVM Work on the Main Thread\n+    // ----------------------------------\n+    // Since the main thread owns the compiler processes implicit `Token`, it is\n+    // wasteful to keep it blocked without doing any work. Therefore, what we do\n+    // in this case is: We spawn off an additional LLVM worker thread that helps\n+    // reduce the queue. The work it is doing corresponds to the implicit\n+    // `Token`. The coordinator will mark the main thread as being busy with\n+    // LLVM work. (The actual work happens on another OS thread but we just care\n+    // about `Tokens`, not actual threads).\n+    //\n+    // When any LLVM worker thread finishes while the main thread is marked as\n+    // \"busy with LLVM work\", we can do a little switcheroo: We give the Token\n+    // of the just finished thread to the LLVM worker thread that is working on\n+    // behalf of the main thread's implicit Token, thus freeing up the main\n+    // thread again. The coordinator can then again decide what the main thread\n+    // should do. This allows the coordinator to make decisions at more points\n+    // in time.\n+    //\n+    // Striking a Balance between Throughput and Memory Consumption\n+    // ------------------------------------------------------------\n+    // Since our two goals, (1) use as many Tokens as possible and (2) keep\n+    // memory consumption as low as possible, are in conflict with each other,\n+    // we have to find a trade off between them. Right now, the goal is to keep\n+    // all workers busy, which means that no worker should find the queue empty\n+    // when it is ready to start.\n+    // How do we do achieve this? Good question :) We actually never know how\n+    // many `Tokens` are potentially available so it's hard to say how much to\n+    // fill up the queue before switching the main thread to LLVM work. Also we\n+    // currently don't have a means to estimate how long a running LLVM worker\n+    // will still be busy with it's current WorkItem. However, we know the\n+    // maximal count of available Tokens that makes sense (=the number of CPU\n+    // cores), so we can take a conservative guess. The heuristic we use here\n+    // is implemented in the `queue_full_enough()` function.\n+    //\n+    // Some Background on Jobservers\n+    // -----------------------------\n+    // It's worth also touching on the management of parallelism here. We don't\n+    // want to just spawn a thread per work item because while that's optimal\n+    // parallelism it may overload a system with too many threads or violate our\n+    // configuration for the maximum amount of cpu to use for this process. To\n+    // manage this we use the `jobserver` crate.\n+    //\n+    // Job servers are an artifact of GNU make and are used to manage\n+    // parallelism between processes. A jobserver is a glorified IPC semaphore\n+    // basically. Whenever we want to run some work we acquire the semaphore,\n+    // and whenever we're done with that work we release the semaphore. In this\n+    // manner we can ensure that the maximum number of parallel workers is\n+    // capped at any one point in time.\n+    //\n+    // LTO and the coordinator thread\n+    // ------------------------------\n+    //\n+    // The final job the coordinator thread is responsible for is managing LTO\n+    // and how that works. When LTO is requested what we'll to is collect all\n+    // optimized LLVM modules into a local vector on the coordinator. Once all\n+    // modules have been codegened and optimized we hand this to the `lto`\n+    // module for further optimization. The `lto` module will return back a list\n+    // of more modules to work on, which the coordinator will continue to spawn\n+    // work for.\n+    //\n+    // Each LLVM module is automatically sent back to the coordinator for LTO if\n+    // necessary. There's already optimizations in place to avoid sending work\n+    // back to the coordinator if LTO isn't requested.\n+    return thread::spawn(move || {\n+        // We pretend to be within the top-level LLVM time-passes task here:\n+        set_time_depth(1);\n+\n+        let max_workers = ::num_cpus::get();\n+        let mut worker_id_counter = 0;\n+        let mut free_worker_ids = Vec::new();\n+        let mut get_worker_id = |free_worker_ids: &mut Vec<usize>| {\n+            if let Some(id) = free_worker_ids.pop() {\n+                id\n+            } else {\n+                let id = worker_id_counter;\n+                worker_id_counter += 1;\n+                id\n+            }\n+        };\n+\n+        // This is where we collect codegen units that have gone all the way\n+        // through codegen and LLVM.\n+        let mut compiled_modules = vec![];\n+        let mut compiled_metadata_module = None;\n+        let mut compiled_allocator_module = None;\n+        let mut needs_lto = Vec::new();\n+        let mut lto_import_only_modules = Vec::new();\n+        let mut started_lto = false;\n+        let mut codegen_aborted = false;\n+\n+        // This flag tracks whether all items have gone through codegens\n+        let mut codegen_done = false;\n+\n+        // This is the queue of LLVM work items that still need processing.\n+        let mut work_items = Vec::<(WorkItem<B>, u64)>::new();\n+\n+        // This are the Jobserver Tokens we currently hold. Does not include\n+        // the implicit Token the compiler process owns no matter what.\n+        let mut tokens = Vec::new();\n+\n+        let mut main_thread_worker_state = MainThreadWorkerState::Idle;\n+        let mut running = 0;\n+\n+        let mut llvm_start_time = None;\n+\n+        // Run the message loop while there's still anything that needs message\n+        // processing. Note that as soon as codegen is aborted we simply want to\n+        // wait for all existing work to finish, so many of the conditions here\n+        // only apply if codegen hasn't been aborted as they represent pending\n+        // work to be done.\n+        while !codegen_done ||\n+              running > 0 ||\n+              (!codegen_aborted && (\n+                  work_items.len() > 0 ||\n+                  needs_lto.len() > 0 ||\n+                  lto_import_only_modules.len() > 0 ||\n+                  main_thread_worker_state != MainThreadWorkerState::Idle\n+              ))\n+        {\n+\n+            // While there are still CGUs to be codegened, the coordinator has\n+            // to decide how to utilize the compiler processes implicit Token:\n+            // For codegenning more CGU or for running them through LLVM.\n+            if !codegen_done {\n+                if main_thread_worker_state == MainThreadWorkerState::Idle {\n+                    if !queue_full_enough(work_items.len(), running, max_workers) {\n+                        // The queue is not full enough, codegen more items:\n+                        if let Err(_) = codegen_worker_send.send(Message::CodegenItem) {\n+                            panic!(\"Could not send Message::CodegenItem to main thread\")\n+                        }\n+                        main_thread_worker_state = MainThreadWorkerState::Codegenning;\n+                    } else {\n+                        // The queue is full enough to not let the worker\n+                        // threads starve. Use the implicit Token to do some\n+                        // LLVM work too.\n+                        let (item, _) = work_items.pop()\n+                            .expect(\"queue empty - queue_full_enough() broken?\");\n+                        let cgcx = CodegenContext {\n+                            worker: get_worker_id(&mut free_worker_ids),\n+                            .. cgcx.clone()\n+                        };\n+                        maybe_start_llvm_timer(cgcx.config(item.module_kind()),\n+                                               &mut llvm_start_time);\n+                        main_thread_worker_state = MainThreadWorkerState::LLVMing;\n+                        spawn_work(cgcx, item);\n+                    }\n+                }\n+            } else if codegen_aborted {\n+                // don't queue up any more work if codegen was aborted, we're\n+                // just waiting for our existing children to finish\n+            } else {\n+                // If we've finished everything related to normal codegen\n+                // then it must be the case that we've got some LTO work to do.\n+                // Perform the serial work here of figuring out what we're\n+                // going to LTO and then push a bunch of work items onto our\n+                // queue to do LTO\n+                if work_items.len() == 0 &&\n+                   running == 0 &&\n+                   main_thread_worker_state == MainThreadWorkerState::Idle {\n+                    assert!(!started_lto);\n+                    assert!(needs_lto.len() + lto_import_only_modules.len() > 0);\n+                    started_lto = true;\n+                    let modules = mem::replace(&mut needs_lto, Vec::new());\n+                    let import_only_modules =\n+                        mem::replace(&mut lto_import_only_modules, Vec::new());\n+                    for (work, cost) in generate_lto_work(&cgcx, modules, import_only_modules) {\n+                        let insertion_index = work_items\n+                            .binary_search_by_key(&cost, |&(_, cost)| cost)\n+                            .unwrap_or_else(|e| e);\n+                        work_items.insert(insertion_index, (work, cost));\n+                        if !cgcx.opts.debugging_opts.no_parallel_llvm {\n+                            helper.request_token();\n+                        }\n+                    }\n+                }\n+\n+                // In this branch, we know that everything has been codegened,\n+                // so it's just a matter of determining whether the implicit\n+                // Token is free to use for LLVM work.\n+                match main_thread_worker_state {\n+                    MainThreadWorkerState::Idle => {\n+                        if let Some((item, _)) = work_items.pop() {\n+                            let cgcx = CodegenContext {\n+                                worker: get_worker_id(&mut free_worker_ids),\n+                                .. cgcx.clone()\n+                            };\n+                            maybe_start_llvm_timer(cgcx.config(item.module_kind()),\n+                                                   &mut llvm_start_time);\n+                            main_thread_worker_state = MainThreadWorkerState::LLVMing;\n+                            spawn_work(cgcx, item);\n+                        } else {\n+                            // There is no unstarted work, so let the main thread\n+                            // take over for a running worker. Otherwise the\n+                            // implicit token would just go to waste.\n+                            // We reduce the `running` counter by one. The\n+                            // `tokens.truncate()` below will take care of\n+                            // giving the Token back.\n+                            debug_assert!(running > 0);\n+                            running -= 1;\n+                            main_thread_worker_state = MainThreadWorkerState::LLVMing;\n+                        }\n+                    }\n+                    MainThreadWorkerState::Codegenning => {\n+                        bug!(\"codegen worker should not be codegenning after \\\n+                              codegen was already completed\")\n+                    }\n+                    MainThreadWorkerState::LLVMing => {\n+                        // Already making good use of that token\n+                    }\n+                }\n+            }\n+\n+            // Spin up what work we can, only doing this while we've got available\n+            // parallelism slots and work left to spawn.\n+            while !codegen_aborted && work_items.len() > 0 && running < tokens.len() {\n+                let (item, _) = work_items.pop().unwrap();\n+\n+                maybe_start_llvm_timer(cgcx.config(item.module_kind()),\n+                                       &mut llvm_start_time);\n+\n+                let cgcx = CodegenContext {\n+                    worker: get_worker_id(&mut free_worker_ids),\n+                    .. cgcx.clone()\n+                };\n+\n+                spawn_work(cgcx, item);\n+                running += 1;\n+            }\n+\n+            // Relinquish accidentally acquired extra tokens\n+            tokens.truncate(running);\n+\n+            let msg = coordinator_receive.recv().unwrap();\n+            match *msg.downcast::<Message<B>>().ok().unwrap() {\n+                // Save the token locally and the next turn of the loop will use\n+                // this to spawn a new unit of work, or it may get dropped\n+                // immediately if we have no more work to spawn.\n+                Message::Token(token) => {\n+                    match token {\n+                        Ok(token) => {\n+                            tokens.push(token);\n+\n+                            if main_thread_worker_state == MainThreadWorkerState::LLVMing {\n+                                // If the main thread token is used for LLVM work\n+                                // at the moment, we turn that thread into a regular\n+                                // LLVM worker thread, so the main thread is free\n+                                // to react to codegen demand.\n+                                main_thread_worker_state = MainThreadWorkerState::Idle;\n+                                running += 1;\n+                            }\n+                        }\n+                        Err(e) => {\n+                            let msg = &format!(\"failed to acquire jobserver token: {}\", e);\n+                            shared_emitter.fatal(msg);\n+                            // Exit the coordinator thread\n+                            panic!(\"{}\", msg)\n+                        }\n+                    }\n+                }\n+\n+                Message::CodegenDone { llvm_work_item, cost } => {\n+                    // We keep the queue sorted by estimated processing cost,\n+                    // so that more expensive items are processed earlier. This\n+                    // is good for throughput as it gives the main thread more\n+                    // time to fill up the queue and it avoids scheduling\n+                    // expensive items to the end.\n+                    // Note, however, that this is not ideal for memory\n+                    // consumption, as LLVM module sizes are not evenly\n+                    // distributed.\n+                    let insertion_index =\n+                        work_items.binary_search_by_key(&cost, |&(_, cost)| cost);\n+                    let insertion_index = match insertion_index {\n+                        Ok(idx) | Err(idx) => idx\n+                    };\n+                    work_items.insert(insertion_index, (llvm_work_item, cost));\n+\n+                    if !cgcx.opts.debugging_opts.no_parallel_llvm {\n+                        helper.request_token();\n+                    }\n+                    assert!(!codegen_aborted);\n+                    assert_eq!(main_thread_worker_state,\n+                               MainThreadWorkerState::Codegenning);\n+                    main_thread_worker_state = MainThreadWorkerState::Idle;\n+                }\n+\n+                Message::CodegenComplete => {\n+                    codegen_done = true;\n+                    assert!(!codegen_aborted);\n+                    assert_eq!(main_thread_worker_state,\n+                               MainThreadWorkerState::Codegenning);\n+                    main_thread_worker_state = MainThreadWorkerState::Idle;\n+                }\n+\n+                // If codegen is aborted that means translation was aborted due\n+                // to some normal-ish compiler error. In this situation we want\n+                // to exit as soon as possible, but we want to make sure all\n+                // existing work has finished. Flag codegen as being done, and\n+                // then conditions above will ensure no more work is spawned but\n+                // we'll keep executing this loop until `running` hits 0.\n+                Message::CodegenAborted => {\n+                    assert!(!codegen_aborted);\n+                    codegen_done = true;\n+                    codegen_aborted = true;\n+                    assert_eq!(main_thread_worker_state,\n+                               MainThreadWorkerState::Codegenning);\n+                }\n+\n+                // If a thread exits successfully then we drop a token associated\n+                // with that worker and update our `running` count. We may later\n+                // re-acquire a token to continue running more work. We may also not\n+                // actually drop a token here if the worker was running with an\n+                // \"ephemeral token\"\n+                //\n+                // Note that if the thread failed that means it panicked, so we\n+                // abort immediately.\n+                Message::Done { result: Ok(compiled_module), worker_id } => {\n+                    if main_thread_worker_state == MainThreadWorkerState::LLVMing {\n+                        main_thread_worker_state = MainThreadWorkerState::Idle;\n+                    } else {\n+                        running -= 1;\n+                    }\n+\n+                    free_worker_ids.push(worker_id);\n+\n+                    match compiled_module.kind {\n+                        ModuleKind::Regular => {\n+                            compiled_modules.push(compiled_module);\n+                        }\n+                        ModuleKind::Metadata => {\n+                            assert!(compiled_metadata_module.is_none());\n+                            compiled_metadata_module = Some(compiled_module);\n+                        }\n+                        ModuleKind::Allocator => {\n+                            assert!(compiled_allocator_module.is_none());\n+                            compiled_allocator_module = Some(compiled_module);\n+                        }\n+                    }\n+                }\n+                Message::NeedsLTO { result, worker_id } => {\n+                    assert!(!started_lto);\n+                    if main_thread_worker_state == MainThreadWorkerState::LLVMing {\n+                        main_thread_worker_state = MainThreadWorkerState::Idle;\n+                    } else {\n+                        running -= 1;\n+                    }\n+                    free_worker_ids.push(worker_id);\n+                    needs_lto.push(result);\n+                }\n+                Message::AddImportOnlyModule { module_data, work_product } => {\n+                    assert!(!started_lto);\n+                    assert!(!codegen_done);\n+                    assert_eq!(main_thread_worker_state,\n+                               MainThreadWorkerState::Codegenning);\n+                    lto_import_only_modules.push((module_data, work_product));\n+                    main_thread_worker_state = MainThreadWorkerState::Idle;\n+                }\n+                Message::Done { result: Err(()), worker_id: _ } => {\n+                    bug!(\"worker thread panicked\");\n+                }\n+                Message::CodegenItem => {\n+                    bug!(\"the coordinator should not receive codegen requests\")\n+                }\n+            }\n+        }\n+\n+        if let Some(llvm_start_time) = llvm_start_time {\n+            let total_llvm_time = Instant::now().duration_since(llvm_start_time);\n+            // This is the top-level timing for all of LLVM, set the time-depth\n+            // to zero.\n+            set_time_depth(0);\n+            print_time_passes_entry(cgcx.time_passes,\n+                                    \"LLVM passes\",\n+                                    total_llvm_time);\n+        }\n+\n+        // Regardless of what order these modules completed in, report them to\n+        // the backend in the same order every time to ensure that we're handing\n+        // out deterministic results.\n+        compiled_modules.sort_by(|a, b| a.name.cmp(&b.name));\n+\n+        let compiled_metadata_module = compiled_metadata_module\n+            .expect(\"Metadata module not compiled?\");\n+\n+        Ok(CompiledModules {\n+            modules: compiled_modules,\n+            metadata_module: compiled_metadata_module,\n+            allocator_module: compiled_allocator_module,\n+        })\n+    });\n+\n+    // A heuristic that determines if we have enough LLVM WorkItems in the\n+    // queue so that the main thread can do LLVM work instead of codegen\n+    fn queue_full_enough(items_in_queue: usize,\n+                         workers_running: usize,\n+                         max_workers: usize) -> bool {\n+        // Tune me, plz.\n+        items_in_queue > 0 &&\n+        items_in_queue >= max_workers.saturating_sub(workers_running / 2)\n+    }\n+\n+    fn maybe_start_llvm_timer(config: &ModuleConfig,\n+                              llvm_start_time: &mut Option<Instant>) {\n+        // We keep track of the -Ztime-passes output manually,\n+        // since the closure-based interface does not fit well here.\n+        if config.time_passes {\n+            if llvm_start_time.is_none() {\n+                *llvm_start_time = Some(Instant::now());\n+            }\n+        }\n+    }\n+}\n+\n+pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n+pub const CODEGEN_WORKER_TIMELINE: time_graph::TimelineId =\n+    time_graph::TimelineId(CODEGEN_WORKER_ID);\n+pub const CODEGEN_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n+    time_graph::WorkPackageKind(&[\"#DE9597\", \"#FED1D3\", \"#FDC5C7\", \"#B46668\", \"#88494B\"]);\n+const LLVM_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n+    time_graph::WorkPackageKind(&[\"#7DB67A\", \"#C6EEC4\", \"#ACDAAA\", \"#579354\", \"#3E6F3C\"]);\n+\n+fn spawn_work<B: ExtraBackendMethods>(\n+    cgcx: CodegenContext<B>,\n+    work: WorkItem<B>\n+) {\n+    let depth = time_depth();\n+\n+    thread::spawn(move || {\n+        set_time_depth(depth);\n+\n+        // Set up a destructor which will fire off a message that we're done as\n+        // we exit.\n+        struct Bomb<B: ExtraBackendMethods> {\n+            coordinator_send: Sender<Box<dyn Any + Send>>,\n+            result: Option<WorkItemResult<B::Module>>,\n+            worker_id: usize,\n+        }\n+        impl<B: ExtraBackendMethods> Drop for Bomb<B> {\n+            fn drop(&mut self) {\n+                let worker_id = self.worker_id;\n+                let msg = match self.result.take() {\n+                    Some(WorkItemResult::Compiled(m)) => {\n+                        Message::Done::<B> { result: Ok(m), worker_id }\n+                    }\n+                    Some(WorkItemResult::NeedsLTO(m)) => {\n+                        Message::NeedsLTO::<B> { result: m, worker_id }\n+                    }\n+                    None => Message::Done::<B> { result: Err(()), worker_id }\n+                };\n+                drop(self.coordinator_send.send(Box::new(msg)));\n+            }\n+        }\n+\n+        let mut bomb = Bomb::<B> {\n+            coordinator_send: cgcx.coordinator_send.clone(),\n+            result: None,\n+            worker_id: cgcx.worker,\n+        };\n+\n+        // Execute the work itself, and if it finishes successfully then flag\n+        // ourselves as a success as well.\n+        //\n+        // Note that we ignore any `FatalError` coming out of `execute_work_item`,\n+        // as a diagnostic was already sent off to the main thread - just\n+        // surface that there was an error in this worker.\n+        bomb.result = {\n+            let timeline = cgcx.time_graph.as_ref().map(|tg| {\n+                tg.start(time_graph::TimelineId(cgcx.worker),\n+                         LLVM_WORK_PACKAGE_KIND,\n+                         &work.name())\n+            });\n+            let mut timeline = timeline.unwrap_or(Timeline::noop());\n+            execute_work_item(&cgcx, work, &mut timeline).ok()\n+        };\n+    });\n+}\n+\n+pub fn run_assembler<B: ExtraBackendMethods>(\n+    cgcx: &CodegenContext<B>,\n+    handler: &Handler,\n+    assembly: &Path,\n+    object: &Path\n+) {\n+    let assembler = cgcx.assembler_cmd\n+        .as_ref()\n+        .expect(\"cgcx.assembler_cmd is missing?\");\n+\n+    let pname = &assembler.name;\n+    let mut cmd = assembler.cmd.clone();\n+    cmd.arg(\"-c\").arg(\"-o\").arg(object).arg(assembly);\n+    debug!(\"{:?}\", cmd);\n+\n+    match cmd.output() {\n+        Ok(prog) => {\n+            if !prog.status.success() {\n+                let mut note = prog.stderr.clone();\n+                note.extend_from_slice(&prog.stdout);\n+\n+                handler.struct_err(&format!(\"linking with `{}` failed: {}\",\n+                                            pname.display(),\n+                                            prog.status))\n+                    .note(&format!(\"{:?}\", &cmd))\n+                    .note(str::from_utf8(&note[..]).unwrap())\n+                    .emit();\n+                handler.abort_if_errors();\n+            }\n+        },\n+        Err(e) => {\n+            handler.err(&format!(\"could not exec the linker `{}`: {}\", pname.display(), e));\n+            handler.abort_if_errors();\n+        }\n+    }\n+}\n+\n+\n+enum SharedEmitterMessage {\n+    Diagnostic(Diagnostic),\n+    InlineAsmError(u32, String),\n+    AbortIfErrors,\n+    Fatal(String),\n+}\n+\n+#[derive(Clone)]\n+pub struct SharedEmitter {\n+    sender: Sender<SharedEmitterMessage>,\n+}\n+\n+pub struct SharedEmitterMain {\n+    receiver: Receiver<SharedEmitterMessage>,\n+}\n+\n+impl SharedEmitter {\n+    pub fn new() -> (SharedEmitter, SharedEmitterMain) {\n+        let (sender, receiver) = channel();\n+\n+        (SharedEmitter { sender }, SharedEmitterMain { receiver })\n+    }\n+\n+    pub fn inline_asm_error(&self, cookie: u32, msg: String) {\n+        drop(self.sender.send(SharedEmitterMessage::InlineAsmError(cookie, msg)));\n+    }\n+\n+    pub fn fatal(&self, msg: &str) {\n+        drop(self.sender.send(SharedEmitterMessage::Fatal(msg.to_string())));\n+    }\n+}\n+\n+impl Emitter for SharedEmitter {\n+    fn emit(&mut self, db: &DiagnosticBuilder) {\n+        drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n+            msg: db.message(),\n+            code: db.code.clone(),\n+            lvl: db.level,\n+        })));\n+        for child in &db.children {\n+            drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n+                msg: child.message(),\n+                code: None,\n+                lvl: child.level,\n+            })));\n+        }\n+        drop(self.sender.send(SharedEmitterMessage::AbortIfErrors));\n+    }\n+}\n+\n+impl SharedEmitterMain {\n+    pub fn check(&self, sess: &Session, blocking: bool) {\n+        loop {\n+            let message = if blocking {\n+                match self.receiver.recv() {\n+                    Ok(message) => Ok(message),\n+                    Err(_) => Err(()),\n+                }\n+            } else {\n+                match self.receiver.try_recv() {\n+                    Ok(message) => Ok(message),\n+                    Err(_) => Err(()),\n+                }\n+            };\n+\n+            match message {\n+                Ok(SharedEmitterMessage::Diagnostic(diag)) => {\n+                    let handler = sess.diagnostic();\n+                    match diag.code {\n+                        Some(ref code) => {\n+                            handler.emit_with_code(&MultiSpan::new(),\n+                                                   &diag.msg,\n+                                                   code.clone(),\n+                                                   diag.lvl);\n+                        }\n+                        None => {\n+                            handler.emit(&MultiSpan::new(),\n+                                         &diag.msg,\n+                                         diag.lvl);\n+                        }\n+                    }\n+                }\n+                Ok(SharedEmitterMessage::InlineAsmError(cookie, msg)) => {\n+                    match Mark::from_u32(cookie).expn_info() {\n+                        Some(ei) => sess.span_err(ei.call_site, &msg),\n+                        None     => sess.err(&msg),\n+                    }\n+                }\n+                Ok(SharedEmitterMessage::AbortIfErrors) => {\n+                    sess.abort_if_errors();\n+                }\n+                Ok(SharedEmitterMessage::Fatal(msg)) => {\n+                    sess.fatal(&msg);\n+                }\n+                Err(_) => {\n+                    break;\n+                }\n+            }\n+\n+        }\n+    }\n+}\n+\n+pub struct OngoingCodegen<B: ExtraBackendMethods> {\n+    pub backend: B,\n+    pub crate_name: Symbol,\n+    pub crate_hash: Svh,\n+    pub metadata: EncodedMetadata,\n+    pub windows_subsystem: Option<String>,\n+    pub linker_info: LinkerInfo,\n+    pub crate_info: CrateInfo,\n+    pub time_graph: Option<TimeGraph>,\n+    pub coordinator_send: Sender<Box<dyn Any + Send>>,\n+    pub codegen_worker_receive: Receiver<Message<B>>,\n+    pub shared_emitter_main: SharedEmitterMain,\n+    pub future: thread::JoinHandle<Result<CompiledModules, ()>>,\n+    pub output_filenames: Arc<OutputFilenames>,\n+}\n+\n+impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n+    pub fn join(\n+        self,\n+        sess: &Session\n+    ) -> (CodegenResults, FxHashMap<WorkProductId, WorkProduct>) {\n+        self.shared_emitter_main.check(sess, true);\n+        let compiled_modules = match self.future.join() {\n+            Ok(Ok(compiled_modules)) => compiled_modules,\n+            Ok(Err(())) => {\n+                sess.abort_if_errors();\n+                panic!(\"expected abort due to worker thread errors\")\n+            },\n+            Err(_) => {\n+                bug!(\"panic during codegen/LLVM phase\");\n+            }\n+        };\n+\n+        sess.cgu_reuse_tracker.check_expected_reuse(sess);\n+\n+        sess.abort_if_errors();\n+\n+        if let Some(time_graph) = self.time_graph {\n+            time_graph.dump(&format!(\"{}-timings\", self.crate_name));\n+        }\n+\n+        let work_products =\n+            copy_all_cgu_workproducts_to_incr_comp_cache_dir(sess,\n+                                                             &compiled_modules);\n+        produce_final_output_artifacts(sess,\n+                                       &compiled_modules,\n+                                       &self.output_filenames);\n+\n+        // FIXME: time_llvm_passes support - does this use a global context or\n+        // something?\n+        if sess.codegen_units() == 1 && sess.time_llvm_passes() {\n+            self.backend.print_pass_timings()\n+        }\n+\n+        (CodegenResults {\n+            crate_name: self.crate_name,\n+            crate_hash: self.crate_hash,\n+            metadata: self.metadata,\n+            windows_subsystem: self.windows_subsystem,\n+            linker_info: self.linker_info,\n+            crate_info: self.crate_info,\n+\n+            modules: compiled_modules.modules,\n+            allocator_module: compiled_modules.allocator_module,\n+            metadata_module: compiled_modules.metadata_module,\n+        }, work_products)\n+    }\n+\n+    pub fn submit_pre_codegened_module_to_llvm(&self,\n+                                                       tcx: TyCtxt,\n+                                                       module: ModuleCodegen<B::Module>) {\n+        self.wait_for_signal_to_codegen_item();\n+        self.check_for_errors(tcx.sess);\n+\n+        // These are generally cheap and won't through off scheduling.\n+        let cost = 0;\n+        submit_codegened_module_to_llvm(&self.backend, tcx, module, cost);\n+    }\n+\n+    pub fn codegen_finished(&self, tcx: TyCtxt) {\n+        self.wait_for_signal_to_codegen_item();\n+        self.check_for_errors(tcx.sess);\n+        drop(self.coordinator_send.send(Box::new(Message::CodegenComplete::<B>)));\n+    }\n+\n+    /// Consume this context indicating that codegen was entirely aborted, and\n+    /// we need to exit as quickly as possible.\n+    ///\n+    /// This method blocks the current thread until all worker threads have\n+    /// finished, and all worker threads should have exited or be real close to\n+    /// exiting at this point.\n+    pub fn codegen_aborted(self) {\n+        // Signal to the coordinator it should spawn no more work and start\n+        // shutdown.\n+        drop(self.coordinator_send.send(Box::new(Message::CodegenAborted::<B>)));\n+        drop(self.future.join());\n+    }\n+\n+    pub fn check_for_errors(&self, sess: &Session) {\n+        self.shared_emitter_main.check(sess, false);\n+    }\n+\n+    pub fn wait_for_signal_to_codegen_item(&self) {\n+        match self.codegen_worker_receive.recv() {\n+            Ok(Message::CodegenItem) => {\n+                // Nothing to do\n+            }\n+            Ok(_) => panic!(\"unexpected message\"),\n+            Err(_) => {\n+                // One of the LLVM threads must have panicked, fall through so\n+                // error handling can be reached.\n+            }\n+        }\n+    }\n+}\n+\n+pub fn submit_codegened_module_to_llvm<B: ExtraBackendMethods>(\n+    _backend: &B,\n+    tcx: TyCtxt,\n+    module: ModuleCodegen<B::Module>,\n+    cost: u64\n+) {\n+    let llvm_work_item = WorkItem::Optimize(module);\n+    drop(tcx.tx_to_llvm_workers.lock().send(Box::new(Message::CodegenDone::<B> {\n+        llvm_work_item,\n+        cost,\n+    })));\n+}\n+\n+pub fn submit_post_lto_module_to_llvm<B: ExtraBackendMethods>(\n+    _backend: &B,\n+    tcx: TyCtxt,\n+    module: CachedModuleCodegen\n+) {\n+    let llvm_work_item = WorkItem::CopyPostLtoArtifacts(module);\n+    drop(tcx.tx_to_llvm_workers.lock().send(Box::new(Message::CodegenDone::<B> {\n+        llvm_work_item,\n+        cost: 0,\n+    })));\n+}\n+\n+pub fn submit_pre_lto_module_to_llvm<B: ExtraBackendMethods>(\n+    _backend: &B,\n+    tcx: TyCtxt,\n+    module: CachedModuleCodegen\n+) {\n+    let filename = pre_lto_bitcode_filename(&module.name);\n+    let bc_path = in_incr_comp_dir_sess(tcx.sess, &filename);\n+    let file = fs::File::open(&bc_path).unwrap_or_else(|e| {\n+        panic!(\"failed to open bitcode file `{}`: {}\", bc_path.display(), e)\n+    });\n+\n+    let mmap = unsafe {\n+        memmap::Mmap::map(&file).unwrap_or_else(|e| {\n+            panic!(\"failed to mmap bitcode file `{}`: {}\", bc_path.display(), e)\n+        })\n+    };\n+    // Schedule the module to be loaded\n+    drop(tcx.tx_to_llvm_workers.lock().send(Box::new(Message::AddImportOnlyModule::<B> {\n+        module_data: SerializedModule::FromUncompressedFile(mmap),\n+        work_product: module.source,\n+    })));\n+}\n+\n+pub fn pre_lto_bitcode_filename(module_name: &str) -> String {\n+    format!(\"{}.{}\", module_name, PRE_THIN_LTO_BC_EXT)\n+}\n+\n+fn msvc_imps_needed(tcx: TyCtxt) -> bool {\n+    // This should never be true (because it's not supported). If it is true,\n+    // something is wrong with commandline arg validation.\n+    assert!(!(tcx.sess.opts.debugging_opts.cross_lang_lto.enabled() &&\n+              tcx.sess.target.target.options.is_like_msvc &&\n+              tcx.sess.opts.cg.prefer_dynamic));\n+\n+    tcx.sess.target.target.options.is_like_msvc &&\n+        tcx.sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateType::Rlib) &&\n+    // ThinLTO can't handle this workaround in all cases, so we don't\n+    // emit the `__imp_` symbols. Instead we make them unnecessary by disallowing\n+    // dynamic linking when cross-language LTO is enabled.\n+    !tcx.sess.opts.debugging_opts.cross_lang_lto.enabled()\n+}"}, {"sha": "856bb9533c859013c4cc23b55bd93f577a4e973a", "filename": "src/librustc_codegen_ssa/base.rs", "status": "added", "additions": 985, "deletions": 0, "changes": 985, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -0,0 +1,985 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Codegen the completed AST to the LLVM IR.\n+//!\n+//! Some functions here, such as codegen_block and codegen_expr, return a value --\n+//! the result of the codegen to LLVM -- while others, such as codegen_fn\n+//! and mono_item, are called only for the side effect of adding a\n+//! particular definition to the LLVM IR output we're producing.\n+//!\n+//! Hopefully useful general knowledge about codegen:\n+//!\n+//!   * There's no way to find out the Ty type of a Value.  Doing so\n+//!     would be \"trying to get the eggs out of an omelette\" (credit:\n+//!     pcwalton).  You can, instead, find out its llvm::Type by calling val_ty,\n+//!     but one llvm::Type corresponds to many `Ty`s; for instance, tup(int, int,\n+//!     int) and rec(x=int, y=int, z=int) will have the same llvm::Type.\n+\n+use {ModuleCodegen, ModuleKind, CachedModuleCodegen};\n+\n+use rustc::dep_graph::cgu_reuse_tracker::CguReuse;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::middle::lang_items::StartFnLangItem;\n+use rustc::middle::weak_lang_items;\n+use rustc::mir::mono::{Stats, CodegenUnitNameBuilder};\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n+use rustc::ty::query::Providers;\n+use rustc::middle::cstore::{self, LinkagePreference};\n+use rustc::util::common::{time, print_time_passes_entry};\n+use rustc::util::profiling::ProfileCategory;\n+use rustc::session::config::{self, EntryFnType, Lto};\n+use rustc::session::Session;\n+use mir::place::PlaceRef;\n+use back::write::{OngoingCodegen, start_async_codegen, submit_pre_lto_module_to_llvm,\n+    submit_post_lto_module_to_llvm};\n+use {MemFlags, CrateInfo};\n+use callee;\n+use rustc_mir::monomorphize::item::DefPathBasedNames;\n+use common::{RealPredicate, TypeKind, IntPredicate};\n+use meth;\n+use mir;\n+use rustc::util::time_graph;\n+use rustc_mir::monomorphize::Instance;\n+use rustc_mir::monomorphize::partitioning::{CodegenUnit, CodegenUnitExt};\n+use mono_item::MonoItem;\n+use rustc::util::nodemap::FxHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_codegen_utils::{symbol_names_test, check_for_rustc_errors_attr};\n+use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n+\n+use traits::*;\n+\n+use std::any::Any;\n+use std::cmp;\n+use std::ops::{Deref, DerefMut};\n+use std::time::{Instant, Duration};\n+use std::sync::mpsc;\n+use syntax_pos::Span;\n+use syntax::attr;\n+use rustc::hir;\n+\n+use mir::operand::OperandValue;\n+\n+use std::marker::PhantomData;\n+\n+pub struct StatRecorder<'a, 'tcx, Cx: 'a + CodegenMethods<'tcx>> {\n+    cx: &'a Cx,\n+    name: Option<String>,\n+    istart: usize,\n+    _marker: PhantomData<&'tcx ()>,\n+}\n+\n+impl<'a, 'tcx, Cx: CodegenMethods<'tcx>> StatRecorder<'a, 'tcx, Cx> {\n+    pub fn new(cx: &'a Cx, name: String) -> Self {\n+        let istart = cx.stats().borrow().n_llvm_insns;\n+        StatRecorder {\n+            cx,\n+            name: Some(name),\n+            istart,\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, Cx: CodegenMethods<'tcx>> Drop for StatRecorder<'a, 'tcx, Cx> {\n+    fn drop(&mut self) {\n+        if self.cx.sess().codegen_stats() {\n+            let mut stats = self.cx.stats().borrow_mut();\n+            let iend = stats.n_llvm_insns;\n+            stats.fn_stats.push((self.name.take().unwrap(), iend - self.istart));\n+            stats.n_fns += 1;\n+            // Reset LLVM insn count to avoid compound costs.\n+            stats.n_llvm_insns = self.istart;\n+        }\n+    }\n+}\n+\n+pub fn bin_op_to_icmp_predicate(op: hir::BinOpKind,\n+                                signed: bool)\n+                                -> IntPredicate {\n+    match op {\n+        hir::BinOpKind::Eq => IntPredicate::IntEQ,\n+        hir::BinOpKind::Ne => IntPredicate::IntNE,\n+        hir::BinOpKind::Lt => if signed { IntPredicate::IntSLT } else { IntPredicate::IntULT },\n+        hir::BinOpKind::Le => if signed { IntPredicate::IntSLE } else { IntPredicate::IntULE },\n+        hir::BinOpKind::Gt => if signed { IntPredicate::IntSGT } else { IntPredicate::IntUGT },\n+        hir::BinOpKind::Ge => if signed { IntPredicate::IntSGE } else { IntPredicate::IntUGE },\n+        op => {\n+            bug!(\"comparison_op_to_icmp_predicate: expected comparison operator, \\\n+                  found {:?}\",\n+                 op)\n+        }\n+    }\n+}\n+\n+pub fn bin_op_to_fcmp_predicate(op: hir::BinOpKind) -> RealPredicate {\n+    match op {\n+        hir::BinOpKind::Eq => RealPredicate::RealOEQ,\n+        hir::BinOpKind::Ne => RealPredicate::RealUNE,\n+        hir::BinOpKind::Lt => RealPredicate::RealOLT,\n+        hir::BinOpKind::Le => RealPredicate::RealOLE,\n+        hir::BinOpKind::Gt => RealPredicate::RealOGT,\n+        hir::BinOpKind::Ge => RealPredicate::RealOGE,\n+        op => {\n+            bug!(\"comparison_op_to_fcmp_predicate: expected comparison operator, \\\n+                  found {:?}\",\n+                 op);\n+        }\n+    }\n+}\n+\n+pub fn compare_simd_types<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    lhs: Bx::Value,\n+    rhs: Bx::Value,\n+    t: Ty<'tcx>,\n+    ret_ty: Bx::Type,\n+    op: hir::BinOpKind\n+) -> Bx::Value {\n+    let signed = match t.sty {\n+        ty::Float(_) => {\n+            let cmp = bin_op_to_fcmp_predicate(op);\n+            let cmp = bx.fcmp(cmp, lhs, rhs);\n+            return bx.sext(cmp, ret_ty);\n+        },\n+        ty::Uint(_) => false,\n+        ty::Int(_) => true,\n+        _ => bug!(\"compare_simd_types: invalid SIMD type\"),\n+    };\n+\n+    let cmp = bin_op_to_icmp_predicate(op, signed);\n+    let cmp = bx.icmp(cmp, lhs, rhs);\n+    // LLVM outputs an `< size x i1 >`, so we need to perform a sign extension\n+    // to get the correctly sized type. This will compile to a single instruction\n+    // once the IR is converted to assembly if the SIMD instruction is supported\n+    // by the target architecture.\n+    bx.sext(cmp, ret_ty)\n+}\n+\n+/// Retrieve the information we are losing (making dynamic) in an unsizing\n+/// adjustment.\n+///\n+/// The `old_info` argument is a bit funny. It is intended for use\n+/// in an upcast, where the new vtable for an object will be derived\n+/// from the old one.\n+pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n+    cx: &Cx,\n+    source: Ty<'tcx>,\n+    target: Ty<'tcx>,\n+    old_info: Option<Cx::Value>,\n+) -> Cx::Value {\n+    let (source, target) = cx.tcx().struct_lockstep_tails(source, target);\n+    match (&source.sty, &target.sty) {\n+        (&ty::Array(_, len), &ty::Slice(_)) => {\n+            cx.const_usize(len.unwrap_usize(cx.tcx()))\n+        }\n+        (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n+            // For now, upcasts are limited to changes in marker\n+            // traits, and hence never actually require an actual\n+            // change to the vtable.\n+            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n+        }\n+        (_, &ty::Dynamic(ref data, ..)) => {\n+            let vtable_ptr = cx.layout_of(cx.tcx().mk_mut_ptr(target))\n+                .field(cx, FAT_PTR_EXTRA);\n+            cx.static_ptrcast(meth::get_vtable(cx, source, data.principal()),\n+                            cx.backend_type(vtable_ptr))\n+        }\n+        _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n+                  source,\n+                  target),\n+    }\n+}\n+\n+/// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n+pub fn unsize_thin_ptr<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    src: Bx::Value,\n+    src_ty: Ty<'tcx>,\n+    dst_ty: Ty<'tcx>\n+) -> (Bx::Value, Bx::Value) {\n+    debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n+    match (&src_ty.sty, &dst_ty.sty) {\n+        (&ty::Ref(_, a, _),\n+         &ty::Ref(_, b, _)) |\n+        (&ty::Ref(_, a, _),\n+         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) |\n+        (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }),\n+         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n+            assert!(bx.cx().type_is_sized(a));\n+            let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n+            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n+        }\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n+            let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n+            assert!(bx.cx().type_is_sized(a));\n+            let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n+            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n+        }\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n+            assert_eq!(def_a, def_b);\n+\n+            let src_layout = bx.cx().layout_of(src_ty);\n+            let dst_layout = bx.cx().layout_of(dst_ty);\n+            let mut result = None;\n+            for i in 0..src_layout.fields.count() {\n+                let src_f = src_layout.field(bx.cx(), i);\n+                assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n+                assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n+                if src_f.is_zst() {\n+                    continue;\n+                }\n+                assert_eq!(src_layout.size, src_f.size);\n+\n+                let dst_f = dst_layout.field(bx.cx(), i);\n+                assert_ne!(src_f.ty, dst_f.ty);\n+                assert_eq!(result, None);\n+                result = Some(unsize_thin_ptr(bx, src, src_f.ty, dst_f.ty));\n+            }\n+            let (lldata, llextra) = result.unwrap();\n+            // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+            (bx.bitcast(lldata, bx.cx().scalar_pair_element_backend_type(dst_layout, 0, true)),\n+             bx.bitcast(llextra, bx.cx().scalar_pair_element_backend_type(dst_layout, 1, true)))\n+        }\n+        _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n+    }\n+}\n+\n+/// Coerce `src`, which is a reference to a value of type `src_ty`,\n+/// to a value of type `dst_ty` and store the result in `dst`\n+pub fn coerce_unsized_into<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    src: PlaceRef<'tcx, Bx::Value>,\n+    dst: PlaceRef<'tcx, Bx::Value>\n+)  {\n+    let src_ty = src.layout.ty;\n+    let dst_ty = dst.layout.ty;\n+    let mut coerce_ptr = || {\n+        let (base, info) = match bx.load_operand(src).val {\n+            OperandValue::Pair(base, info) => {\n+                // fat-ptr to fat-ptr unsize preserves the vtable\n+                // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n+                // So we need to pointercast the base to ensure\n+                // the types match up.\n+                let thin_ptr = dst.layout.field(bx.cx(), FAT_PTR_ADDR);\n+                (bx.pointercast(base, bx.cx().backend_type(thin_ptr)), info)\n+            }\n+            OperandValue::Immediate(base) => {\n+                unsize_thin_ptr(bx, base, src_ty, dst_ty)\n+            }\n+            OperandValue::Ref(..) => bug!()\n+        };\n+        OperandValue::Pair(base, info).store(bx, dst);\n+    };\n+    match (&src_ty.sty, &dst_ty.sty) {\n+        (&ty::Ref(..), &ty::Ref(..)) |\n+        (&ty::Ref(..), &ty::RawPtr(..)) |\n+        (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n+            coerce_ptr()\n+        }\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n+            coerce_ptr()\n+        }\n+\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n+            assert_eq!(def_a, def_b);\n+\n+            for i in 0..def_a.variants[VariantIdx::new(0)].fields.len() {\n+                let src_f = src.project_field(bx, i);\n+                let dst_f = dst.project_field(bx, i);\n+\n+                if dst_f.layout.is_zst() {\n+                    continue;\n+                }\n+\n+                if src_f.layout.ty == dst_f.layout.ty {\n+                    memcpy_ty(bx, dst_f.llval, dst_f.align, src_f.llval, src_f.align,\n+                              src_f.layout, MemFlags::empty());\n+                } else {\n+                    coerce_unsized_into(bx, src_f, dst_f);\n+                }\n+            }\n+        }\n+        _ => bug!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n+                  src_ty,\n+                  dst_ty),\n+    }\n+}\n+\n+pub fn cast_shift_expr_rhs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    op: hir::BinOpKind,\n+    lhs: Bx::Value,\n+    rhs: Bx::Value\n+) -> Bx::Value {\n+    cast_shift_rhs(bx, op, lhs, rhs)\n+}\n+\n+fn cast_shift_rhs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    op: hir::BinOpKind,\n+    lhs: Bx::Value,\n+    rhs: Bx::Value,\n+) -> Bx::Value {\n+    // Shifts may have any size int on the rhs\n+    if op.is_shift() {\n+        let mut rhs_llty = bx.cx().val_ty(rhs);\n+        let mut lhs_llty = bx.cx().val_ty(lhs);\n+        if bx.cx().type_kind(rhs_llty) == TypeKind::Vector {\n+            rhs_llty = bx.cx().element_type(rhs_llty)\n+        }\n+        if bx.cx().type_kind(lhs_llty) == TypeKind::Vector {\n+            lhs_llty = bx.cx().element_type(lhs_llty)\n+        }\n+        let rhs_sz = bx.cx().int_width(rhs_llty);\n+        let lhs_sz = bx.cx().int_width(lhs_llty);\n+        if lhs_sz < rhs_sz {\n+            bx.trunc(rhs, lhs_llty)\n+        } else if lhs_sz > rhs_sz {\n+            // FIXME (#1877: If in the future shifting by negative\n+            // values is no longer undefined then this is wrong.\n+            bx.zext(rhs, lhs_llty)\n+        } else {\n+            rhs\n+        }\n+    } else {\n+        rhs\n+    }\n+}\n+\n+/// Returns whether this session's target will use SEH-based unwinding.\n+///\n+/// This is only true for MSVC targets, and even then the 64-bit MSVC target\n+/// currently uses SEH-ish unwinding with DWARF info tables to the side (same as\n+/// 64-bit MinGW) instead of \"full SEH\".\n+pub fn wants_msvc_seh(sess: &Session) -> bool {\n+    sess.target.target.options.is_like_msvc\n+}\n+\n+pub fn call_assume<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    val: Bx::Value\n+) {\n+    let assume_intrinsic = bx.cx().get_intrinsic(\"llvm.assume\");\n+    bx.call(assume_intrinsic, &[val], None);\n+}\n+\n+pub fn from_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    val: Bx::Value\n+) -> Bx::Value {\n+    if bx.cx().val_ty(val) == bx.cx().type_i1() {\n+        bx.zext(val, bx.cx().type_i8())\n+    } else {\n+        val\n+    }\n+}\n+\n+pub fn to_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    val: Bx::Value,\n+    layout: layout::TyLayout,\n+) -> Bx::Value {\n+    if let layout::Abi::Scalar(ref scalar) = layout.abi {\n+        return to_immediate_scalar(bx, val, scalar);\n+    }\n+    val\n+}\n+\n+pub fn to_immediate_scalar<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    val: Bx::Value,\n+    scalar: &layout::Scalar,\n+) -> Bx::Value {\n+    if scalar.is_bool() {\n+        return bx.trunc(val, bx.cx().type_i1());\n+    }\n+    val\n+}\n+\n+pub fn memcpy_ty<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    dst: Bx::Value,\n+    dst_align: Align,\n+    src: Bx::Value,\n+    src_align: Align,\n+    layout: TyLayout<'tcx>,\n+    flags: MemFlags,\n+) {\n+    let size = layout.size.bytes();\n+    if size == 0 {\n+        return;\n+    }\n+\n+    bx.memcpy(dst, dst_align, src, src_align, bx.cx().const_usize(size), flags);\n+}\n+\n+pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    cx: &'a Bx::CodegenCx,\n+    instance: Instance<'tcx>,\n+) {\n+    let _s = if cx.sess().codegen_stats() {\n+        let mut instance_name = String::new();\n+        DefPathBasedNames::new(cx.tcx(), true, true)\n+            .push_def_path(instance.def_id(), &mut instance_name);\n+        Some(StatRecorder::new(cx, instance_name))\n+    } else {\n+        None\n+    };\n+\n+    // this is an info! to allow collecting monomorphization statistics\n+    // and to allow finding the last function before LLVM aborts from\n+    // release builds.\n+    info!(\"codegen_instance({})\", instance);\n+\n+    let sig = instance.fn_sig(cx.tcx());\n+    let sig = cx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+\n+    let lldecl = cx.instances().borrow().get(&instance).cloned().unwrap_or_else(||\n+        bug!(\"Instance `{:?}` not already declared\", instance));\n+\n+    cx.stats().borrow_mut().n_closures += 1;\n+\n+    let mir = cx.tcx().instance_mir(instance.def);\n+    mir::codegen_mir::<Bx>(cx, lldecl, &mir, instance, sig);\n+}\n+\n+/// Create the `main` function which will initialize the rust runtime and call\n+/// users main function.\n+pub fn maybe_create_entry_wrapper<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    cx: &'a Bx::CodegenCx\n+) {\n+    let (main_def_id, span) = match *cx.sess().entry_fn.borrow() {\n+        Some((id, span, _)) => {\n+            (cx.tcx().hir.local_def_id(id), span)\n+        }\n+        None => return,\n+    };\n+\n+    let instance = Instance::mono(cx.tcx(), main_def_id);\n+\n+    if !cx.codegen_unit().contains_item(&MonoItem::Fn(instance)) {\n+        // We want to create the wrapper in the same codegen unit as Rust's main\n+        // function.\n+        return;\n+    }\n+\n+    let main_llfn = cx.get_fn(instance);\n+\n+    let et = cx.sess().entry_fn.get().map(|e| e.2);\n+    match et {\n+        Some(EntryFnType::Main) => create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, true),\n+        Some(EntryFnType::Start) => create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, false),\n+        None => {}    // Do nothing.\n+    }\n+\n+    fn create_entry_fn<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+        cx: &'a Bx::CodegenCx,\n+        sp: Span,\n+        rust_main: Bx::Value,\n+        rust_main_def_id: DefId,\n+        use_start_lang_item: bool,\n+    ) {\n+        let llfty =\n+            cx.type_func(&[cx.type_int(), cx.type_ptr_to(cx.type_i8p())], cx.type_int());\n+\n+        let main_ret_ty = cx.tcx().fn_sig(rust_main_def_id).output();\n+        // Given that `main()` has no arguments,\n+        // then its return type cannot have\n+        // late-bound regions, since late-bound\n+        // regions must appear in the argument\n+        // listing.\n+        let main_ret_ty = cx.tcx().erase_regions(\n+            &main_ret_ty.no_bound_vars().unwrap(),\n+        );\n+\n+        if cx.get_defined_value(\"main\").is_some() {\n+            // FIXME: We should be smart and show a better diagnostic here.\n+            cx.sess().struct_span_err(sp, \"entry symbol `main` defined multiple times\")\n+                     .help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\")\n+                     .emit();\n+            cx.sess().abort_if_errors();\n+            bug!();\n+        }\n+        let llfn = cx.declare_cfn(\"main\", llfty);\n+\n+        // `main` should respect same config for frame pointer elimination as rest of code\n+        cx.set_frame_pointer_elimination(llfn);\n+        cx.apply_target_cpu_attr(llfn);\n+\n+        let mut bx = Bx::new_block(&cx, llfn, \"top\");\n+\n+        bx.insert_reference_to_gdb_debug_scripts_section_global();\n+\n+        // Params from native main() used as args for rust start function\n+        let param_argc = cx.get_param(llfn, 0);\n+        let param_argv = cx.get_param(llfn, 1);\n+        let arg_argc = bx.intcast(param_argc, cx.type_isize(), true);\n+        let arg_argv = param_argv;\n+\n+        let (start_fn, args) = if use_start_lang_item {\n+            let start_def_id = cx.tcx().require_lang_item(StartFnLangItem);\n+            let start_fn = callee::resolve_and_get_fn(\n+                cx,\n+                start_def_id,\n+                cx.tcx().intern_substs(&[main_ret_ty.into()]),\n+            );\n+            (start_fn, vec![bx.pointercast(rust_main, cx.type_ptr_to(cx.type_i8p())),\n+                            arg_argc, arg_argv])\n+        } else {\n+            debug!(\"using user-defined start fn\");\n+            (rust_main, vec![arg_argc, arg_argv])\n+        };\n+\n+        let result = bx.call(start_fn, &args, None);\n+        let cast = bx.intcast(result, cx.type_int(), true);\n+        bx.ret(cast);\n+    }\n+}\n+\n+pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n+pub const CODEGEN_WORKER_TIMELINE: time_graph::TimelineId =\n+    time_graph::TimelineId(CODEGEN_WORKER_ID);\n+pub const CODEGEN_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n+    time_graph::WorkPackageKind(&[\"#DE9597\", \"#FED1D3\", \"#FDC5C7\", \"#B46668\", \"#88494B\"]);\n+\n+\n+pub fn codegen_crate<B: ExtraBackendMethods>(\n+    backend: B,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    rx: mpsc::Receiver<Box<dyn Any + Send>>\n+) -> OngoingCodegen<B> {\n+\n+    check_for_rustc_errors_attr(tcx);\n+\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+\n+    // Codegen the metadata.\n+    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen));\n+\n+    let metadata_cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n+                                                            &[\"crate\"],\n+                                                            Some(\"metadata\")).as_str()\n+                                                                             .to_string();\n+    let metadata_llvm_module = backend.new_metadata(tcx.sess, &metadata_cgu_name);\n+    let metadata = time(tcx.sess, \"write metadata\", || {\n+        backend.write_metadata(tcx, &metadata_llvm_module)\n+    });\n+    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen));\n+\n+    let metadata_module = ModuleCodegen {\n+        name: metadata_cgu_name,\n+        module_llvm: metadata_llvm_module,\n+        kind: ModuleKind::Metadata,\n+    };\n+\n+    let time_graph = if tcx.sess.opts.debugging_opts.codegen_time_graph {\n+        Some(time_graph::TimeGraph::new())\n+    } else {\n+        None\n+    };\n+\n+    // Skip crate items and just output metadata in -Z no-codegen mode.\n+    if tcx.sess.opts.debugging_opts.no_codegen ||\n+       !tcx.sess.opts.output_types.should_codegen() {\n+        let ongoing_codegen = start_async_codegen(\n+            backend,\n+            tcx,\n+            time_graph,\n+            metadata,\n+            rx,\n+            1);\n+\n+        ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, metadata_module);\n+        ongoing_codegen.codegen_finished(tcx);\n+\n+        assert_and_save_dep_graph(tcx);\n+\n+        ongoing_codegen.check_for_errors(tcx.sess);\n+\n+        return ongoing_codegen;\n+    }\n+\n+    // Run the monomorphization collector and partition the collected items into\n+    // codegen units.\n+    let codegen_units = tcx.collect_and_partition_mono_items(LOCAL_CRATE).1;\n+    let codegen_units = (*codegen_units).clone();\n+\n+    // Force all codegen_unit queries so they are already either red or green\n+    // when compile_codegen_unit accesses them. We are not able to re-execute\n+    // the codegen_unit query from just the DepNode, so an unknown color would\n+    // lead to having to re-execute compile_codegen_unit, possibly\n+    // unnecessarily.\n+    if tcx.dep_graph.is_fully_enabled() {\n+        for cgu in &codegen_units {\n+            tcx.codegen_unit(cgu.name().clone());\n+        }\n+    }\n+\n+    let ongoing_codegen = start_async_codegen(\n+        backend.clone(),\n+        tcx,\n+        time_graph.clone(),\n+        metadata,\n+        rx,\n+        codegen_units.len());\n+    let ongoing_codegen = AbortCodegenOnDrop::<B>(Some(ongoing_codegen));\n+\n+    // Codegen an allocator shim, if necessary.\n+    //\n+    // If the crate doesn't have an `allocator_kind` set then there's definitely\n+    // no shim to generate. Otherwise we also check our dependency graph for all\n+    // our output crate types. If anything there looks like its a `Dynamic`\n+    // linkage, then it's already got an allocator shim and we'll be using that\n+    // one instead. If nothing exists then it's our job to generate the\n+    // allocator!\n+    let any_dynamic_crate = tcx.sess.dependency_formats.borrow()\n+        .iter()\n+        .any(|(_, list)| {\n+            use rustc::middle::dependency_format::Linkage;\n+            list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n+        });\n+    let allocator_module = if any_dynamic_crate {\n+        None\n+    } else if let Some(kind) = *tcx.sess.allocator_kind.get() {\n+        let llmod_id = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n+                                                       &[\"crate\"],\n+                                                       Some(\"allocator\")).as_str()\n+                                                                         .to_string();\n+        let modules = backend.new_metadata(tcx.sess, &llmod_id);\n+        time(tcx.sess, \"write allocator module\", || {\n+            backend.codegen_allocator(tcx, &modules, kind)\n+        });\n+\n+        Some(ModuleCodegen {\n+            name: llmod_id,\n+            module_llvm: modules,\n+            kind: ModuleKind::Allocator,\n+        })\n+    } else {\n+        None\n+    };\n+\n+    if let Some(allocator_module) = allocator_module {\n+        ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, allocator_module);\n+    }\n+\n+    ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, metadata_module);\n+\n+    // We sort the codegen units by size. This way we can schedule work for LLVM\n+    // a bit more efficiently.\n+    let codegen_units = {\n+        let mut codegen_units = codegen_units;\n+        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n+        codegen_units\n+    };\n+\n+    let mut total_codegen_time = Duration::new(0, 0);\n+    let mut all_stats = Stats::default();\n+\n+    for cgu in codegen_units.into_iter() {\n+        ongoing_codegen.wait_for_signal_to_codegen_item();\n+        ongoing_codegen.check_for_errors(tcx.sess);\n+\n+        let cgu_reuse = determine_cgu_reuse(tcx, &cgu);\n+        tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n+\n+        match cgu_reuse {\n+            CguReuse::No => {\n+                let _timing_guard = time_graph.as_ref().map(|time_graph| {\n+                    time_graph.start(CODEGEN_WORKER_TIMELINE,\n+                                     CODEGEN_WORK_PACKAGE_KIND,\n+                                     &format!(\"codegen {}\", cgu.name()))\n+                });\n+                let start_time = Instant::now();\n+                let stats = backend.compile_codegen_unit(tcx, *cgu.name());\n+                all_stats.extend(stats);\n+                total_codegen_time += start_time.elapsed();\n+                false\n+            }\n+            CguReuse::PreLto => {\n+                submit_pre_lto_module_to_llvm(&backend, tcx, CachedModuleCodegen {\n+                    name: cgu.name().to_string(),\n+                    source: cgu.work_product(tcx),\n+                });\n+                true\n+            }\n+            CguReuse::PostLto => {\n+                submit_post_lto_module_to_llvm(&backend, tcx, CachedModuleCodegen {\n+                    name: cgu.name().to_string(),\n+                    source: cgu.work_product(tcx),\n+                });\n+                true\n+            }\n+        };\n+    }\n+\n+    ongoing_codegen.codegen_finished(tcx);\n+\n+    // Since the main thread is sometimes blocked during codegen, we keep track\n+    // -Ztime-passes output manually.\n+    print_time_passes_entry(tcx.sess.time_passes(),\n+                            \"codegen to LLVM IR\",\n+                            total_codegen_time);\n+\n+    ::rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n+\n+    symbol_names_test::report_symbol_names(tcx);\n+\n+    if tcx.sess.codegen_stats() {\n+        println!(\"--- codegen stats ---\");\n+        println!(\"n_glues_created: {}\", all_stats.n_glues_created);\n+        println!(\"n_null_glues: {}\", all_stats.n_null_glues);\n+        println!(\"n_real_glues: {}\", all_stats.n_real_glues);\n+\n+        println!(\"n_fns: {}\", all_stats.n_fns);\n+        println!(\"n_inlines: {}\", all_stats.n_inlines);\n+        println!(\"n_closures: {}\", all_stats.n_closures);\n+        println!(\"fn stats:\");\n+        all_stats.fn_stats.sort_by_key(|&(_, insns)| insns);\n+        for &(ref name, insns) in all_stats.fn_stats.iter() {\n+            println!(\"{} insns, {}\", insns, *name);\n+        }\n+    }\n+\n+    if tcx.sess.count_llvm_insns() {\n+        for (k, v) in all_stats.llvm_insns.iter() {\n+            println!(\"{:7} {}\", *v, *k);\n+        }\n+    }\n+\n+    ongoing_codegen.check_for_errors(tcx.sess);\n+\n+    assert_and_save_dep_graph(tcx);\n+    ongoing_codegen.into_inner()\n+}\n+\n+/// A curious wrapper structure whose only purpose is to call `codegen_aborted`\n+/// when it's dropped abnormally.\n+///\n+/// In the process of working on rust-lang/rust#55238 a mysterious segfault was\n+/// stumbled upon. The segfault was never reproduced locally, but it was\n+/// suspected to be related to the fact that codegen worker threads were\n+/// sticking around by the time the main thread was exiting, causing issues.\n+///\n+/// This structure is an attempt to fix that issue where the `codegen_aborted`\n+/// message will block until all workers have finished. This should ensure that\n+/// even if the main codegen thread panics we'll wait for pending work to\n+/// complete before returning from the main thread, hopefully avoiding\n+/// segfaults.\n+///\n+/// If you see this comment in the code, then it means that this workaround\n+/// worked! We may yet one day track down the mysterious cause of that\n+/// segfault...\n+struct AbortCodegenOnDrop<B: ExtraBackendMethods>(Option<OngoingCodegen<B>>);\n+\n+impl<B: ExtraBackendMethods> AbortCodegenOnDrop<B> {\n+    fn into_inner(mut self) -> OngoingCodegen<B> {\n+        self.0.take().unwrap()\n+    }\n+}\n+\n+impl<B: ExtraBackendMethods> Deref for AbortCodegenOnDrop<B> {\n+    type Target = OngoingCodegen<B>;\n+\n+    fn deref(&self) -> &OngoingCodegen<B> {\n+        self.0.as_ref().unwrap()\n+    }\n+}\n+\n+impl<B: ExtraBackendMethods> DerefMut for AbortCodegenOnDrop<B> {\n+    fn deref_mut(&mut self) -> &mut OngoingCodegen<B> {\n+        self.0.as_mut().unwrap()\n+    }\n+}\n+\n+impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n+    fn drop(&mut self) {\n+        if let Some(codegen) = self.0.take() {\n+            codegen.codegen_aborted();\n+        }\n+    }\n+}\n+\n+fn assert_and_save_dep_graph<'ll, 'tcx>(tcx: TyCtxt<'ll, 'tcx, 'tcx>) {\n+    time(tcx.sess,\n+         \"assert dep graph\",\n+         || ::rustc_incremental::assert_dep_graph(tcx));\n+\n+    time(tcx.sess,\n+         \"serialize dep graph\",\n+         || ::rustc_incremental::save_dep_graph(tcx));\n+}\n+\n+impl CrateInfo {\n+    pub fn new(tcx: TyCtxt) -> CrateInfo {\n+        let mut info = CrateInfo {\n+            panic_runtime: None,\n+            compiler_builtins: None,\n+            profiler_runtime: None,\n+            sanitizer_runtime: None,\n+            is_no_builtins: Default::default(),\n+            native_libraries: Default::default(),\n+            used_libraries: tcx.native_libraries(LOCAL_CRATE),\n+            link_args: tcx.link_args(LOCAL_CRATE),\n+            crate_name: Default::default(),\n+            used_crates_dynamic: cstore::used_crates(tcx, LinkagePreference::RequireDynamic),\n+            used_crates_static: cstore::used_crates(tcx, LinkagePreference::RequireStatic),\n+            used_crate_source: Default::default(),\n+            wasm_imports: Default::default(),\n+            lang_item_to_crate: Default::default(),\n+            missing_lang_items: Default::default(),\n+        };\n+        let lang_items = tcx.lang_items();\n+\n+        let load_wasm_items = tcx.sess.crate_types.borrow()\n+            .iter()\n+            .any(|c| *c != config::CrateType::Rlib) &&\n+            tcx.sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\";\n+\n+        if load_wasm_items {\n+            info.load_wasm_imports(tcx, LOCAL_CRATE);\n+        }\n+\n+        let crates = tcx.crates();\n+\n+        let n_crates = crates.len();\n+        info.native_libraries.reserve(n_crates);\n+        info.crate_name.reserve(n_crates);\n+        info.used_crate_source.reserve(n_crates);\n+        info.missing_lang_items.reserve(n_crates);\n+\n+        for &cnum in crates.iter() {\n+            info.native_libraries.insert(cnum, tcx.native_libraries(cnum));\n+            info.crate_name.insert(cnum, tcx.crate_name(cnum).to_string());\n+            info.used_crate_source.insert(cnum, tcx.used_crate_source(cnum));\n+            if tcx.is_panic_runtime(cnum) {\n+                info.panic_runtime = Some(cnum);\n+            }\n+            if tcx.is_compiler_builtins(cnum) {\n+                info.compiler_builtins = Some(cnum);\n+            }\n+            if tcx.is_profiler_runtime(cnum) {\n+                info.profiler_runtime = Some(cnum);\n+            }\n+            if tcx.is_sanitizer_runtime(cnum) {\n+                info.sanitizer_runtime = Some(cnum);\n+            }\n+            if tcx.is_no_builtins(cnum) {\n+                info.is_no_builtins.insert(cnum);\n+            }\n+            if load_wasm_items {\n+                info.load_wasm_imports(tcx, cnum);\n+            }\n+            let missing = tcx.missing_lang_items(cnum);\n+            for &item in missing.iter() {\n+                if let Ok(id) = lang_items.require(item) {\n+                    info.lang_item_to_crate.insert(item, id.krate);\n+                }\n+            }\n+\n+            // No need to look for lang items that are whitelisted and don't\n+            // actually need to exist.\n+            let missing = missing.iter()\n+                .cloned()\n+                .filter(|&l| !weak_lang_items::whitelisted(tcx, l))\n+                .collect();\n+            info.missing_lang_items.insert(cnum, missing);\n+        }\n+\n+        return info\n+    }\n+\n+    fn load_wasm_imports(&mut self, tcx: TyCtxt, cnum: CrateNum) {\n+        self.wasm_imports.extend(tcx.wasm_import_module_map(cnum).iter().map(|(&id, module)| {\n+            let instance = Instance::mono(tcx, id);\n+            let import_name = tcx.symbol_name(instance);\n+\n+            (import_name.to_string(), module.clone())\n+        }));\n+    }\n+}\n+\n+fn is_codegened_item(tcx: TyCtxt, id: DefId) -> bool {\n+    let (all_mono_items, _) =\n+        tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n+    all_mono_items.contains(&id)\n+}\n+\n+pub fn provide_both(providers: &mut Providers) {\n+    providers.dllimport_foreign_items = |tcx, krate| {\n+        let module_map = tcx.foreign_modules(krate);\n+        let module_map = module_map.iter()\n+            .map(|lib| (lib.def_id, lib))\n+            .collect::<FxHashMap<_, _>>();\n+\n+        let dllimports = tcx.native_libraries(krate)\n+            .iter()\n+            .filter(|lib| {\n+                if lib.kind != cstore::NativeLibraryKind::NativeUnknown {\n+                    return false\n+                }\n+                let cfg = match lib.cfg {\n+                    Some(ref cfg) => cfg,\n+                    None => return true,\n+                };\n+                attr::cfg_matches(cfg, &tcx.sess.parse_sess, None)\n+            })\n+            .filter_map(|lib| lib.foreign_module)\n+            .map(|id| &module_map[&id])\n+            .flat_map(|module| module.foreign_items.iter().cloned())\n+            .collect();\n+        Lrc::new(dllimports)\n+    };\n+\n+    providers.is_dllimport_foreign_item = |tcx, def_id| {\n+        tcx.dllimport_foreign_items(def_id.krate).contains(&def_id)\n+    };\n+}\n+\n+fn determine_cgu_reuse<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 cgu: &CodegenUnit<'tcx>)\n+                                 -> CguReuse {\n+    if !tcx.dep_graph.is_fully_enabled() {\n+        return CguReuse::No\n+    }\n+\n+    let work_product_id = &cgu.work_product_id();\n+    if tcx.dep_graph.previous_work_product(work_product_id).is_none() {\n+        // We don't have anything cached for this CGU. This can happen\n+        // if the CGU did not exist in the previous session.\n+        return CguReuse::No\n+    }\n+\n+    // Try to mark the CGU as green. If it we can do so, it means that nothing\n+    // affecting the LLVM module has changed and we can re-use a cached version.\n+    // If we compile with any kind of LTO, this means we can re-use the bitcode\n+    // of the Pre-LTO stage (possibly also the Post-LTO version but we'll only\n+    // know that later). If we are not doing LTO, there is only one optimized\n+    // version of each module, so we re-use that.\n+    let dep_node = cgu.codegen_dep_node(tcx);\n+    assert!(!tcx.dep_graph.dep_node_exists(&dep_node),\n+        \"CompileCodegenUnit dep-node for CGU `{}` already exists before marking.\",\n+        cgu.name());\n+\n+    if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n+        // We can re-use either the pre- or the post-thinlto state\n+        if tcx.sess.lto() != Lto::No {\n+            CguReuse::PreLto\n+        } else {\n+            CguReuse::PostLto\n+        }\n+    } else {\n+        CguReuse::No\n+    }\n+}"}, {"sha": "5ff1d9b59923a789eb77fe20231c414aa34890ef", "filename": "src/librustc_codegen_ssa/callee.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcallee.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use traits::*;\n+use rustc::ty;\n+use rustc::ty::subst::Substs;\n+use rustc::hir::def_id::DefId;\n+\n+pub fn resolve_and_get_fn<'tcx, Cx: CodegenMethods<'tcx>>(\n+    cx: &Cx,\n+    def_id: DefId,\n+    substs: &'tcx Substs<'tcx>,\n+) -> Cx::Value {\n+    cx.get_fn(\n+        ty::Instance::resolve(\n+            cx.tcx(),\n+            ty::ParamEnv::reveal_all(),\n+            def_id,\n+            substs\n+        ).unwrap()\n+    )\n+}\n+\n+pub fn resolve_and_get_fn_for_vtable<'tcx,\n+    Cx: Backend<'tcx> + MiscMethods<'tcx> + TypeMethods<'tcx>\n+>(\n+    cx: &Cx,\n+    def_id: DefId,\n+    substs: &'tcx Substs<'tcx>,\n+) -> Cx::Value {\n+    cx.get_fn(\n+        ty::Instance::resolve_for_vtable(\n+            cx.tcx(),\n+            ty::ParamEnv::reveal_all(),\n+            def_id,\n+            substs\n+        ).unwrap()\n+    )\n+}"}, {"sha": "6259318a3c97f2aba734bdd56bc7104224aed5a1", "filename": "src/librustc_codegen_ssa/common.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -0,0 +1,230 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![allow(non_camel_case_types, non_snake_case)]\n+\n+use rustc::ty::{self, Ty, TyCtxt};\n+use syntax_pos::{DUMMY_SP, Span};\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::middle::lang_items::LangItem;\n+use base;\n+use traits::*;\n+\n+use rustc::hir;\n+use traits::BuilderMethods;\n+\n+pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    ty.needs_drop(tcx, ty::ParamEnv::reveal_all())\n+}\n+\n+pub fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    ty.is_sized(tcx.at(DUMMY_SP), ty::ParamEnv::reveal_all())\n+}\n+\n+pub fn type_is_freeze<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    ty.is_freeze(tcx, ty::ParamEnv::reveal_all(), DUMMY_SP)\n+}\n+\n+pub enum IntPredicate {\n+    IntEQ,\n+    IntNE,\n+    IntUGT,\n+    IntUGE,\n+    IntULT,\n+    IntULE,\n+    IntSGT,\n+    IntSGE,\n+    IntSLT,\n+    IntSLE\n+}\n+\n+\n+#[allow(dead_code)]\n+pub enum RealPredicate {\n+    RealPredicateFalse,\n+    RealOEQ,\n+    RealOGT,\n+    RealOGE,\n+    RealOLT,\n+    RealOLE,\n+    RealONE,\n+    RealORD,\n+    RealUNO,\n+    RealUEQ,\n+    RealUGT,\n+    RealUGE,\n+    RealULT,\n+    RealULE,\n+    RealUNE,\n+    RealPredicateTrue\n+}\n+\n+pub enum AtomicRmwBinOp {\n+    AtomicXchg,\n+    AtomicAdd,\n+    AtomicSub,\n+    AtomicAnd,\n+    AtomicNand,\n+    AtomicOr,\n+    AtomicXor,\n+    AtomicMax,\n+    AtomicMin,\n+    AtomicUMax,\n+    AtomicUMin\n+}\n+\n+pub enum AtomicOrdering {\n+    #[allow(dead_code)]\n+    NotAtomic,\n+    Unordered,\n+    Monotonic,\n+    // Consume,  // Not specified yet.\n+    Acquire,\n+    Release,\n+    AcquireRelease,\n+    SequentiallyConsistent,\n+}\n+\n+pub enum SynchronizationScope {\n+    // FIXME: figure out if this variant is needed at all.\n+    #[allow(dead_code)]\n+    Other,\n+    SingleThread,\n+    CrossThread,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum TypeKind {\n+    Void,\n+    Half,\n+    Float,\n+    Double,\n+    X86_FP80,\n+    FP128,\n+    PPC_FP128,\n+    Label,\n+    Integer,\n+    Function,\n+    Struct,\n+    Array,\n+    Pointer,\n+    Vector,\n+    Metadata,\n+    X86_MMX,\n+    Token,\n+}\n+\n+// FIXME(mw): Anything that is produced via DepGraph::with_task() must implement\n+//            the HashStable trait. Normally DepGraph::with_task() calls are\n+//            hidden behind queries, but CGU creation is a special case in two\n+//            ways: (1) it's not a query and (2) CGU are output nodes, so their\n+//            Fingerprints are not actually needed. It remains to be clarified\n+//            how exactly this case will be handled in the red/green system but\n+//            for now we content ourselves with providing a no-op HashStable\n+//            implementation for CGUs.\n+mod temp_stable_hash_impls {\n+    use rustc_data_structures::stable_hasher::{StableHasherResult, StableHasher,\n+                                               HashStable};\n+    use ModuleCodegen;\n+\n+    impl<HCX, M> HashStable<HCX> for ModuleCodegen<M> {\n+        fn hash_stable<W: StableHasherResult>(&self,\n+                                              _: &mut HCX,\n+                                              _: &mut StableHasher<W>) {\n+            // do nothing\n+        }\n+    }\n+}\n+\n+pub fn langcall(tcx: TyCtxt,\n+                span: Option<Span>,\n+                msg: &str,\n+                li: LangItem)\n+                -> DefId {\n+    tcx.lang_items().require(li).unwrap_or_else(|s| {\n+        let msg = format!(\"{} {}\", msg, s);\n+        match span {\n+            Some(span) => tcx.sess.span_fatal(span, &msg[..]),\n+            None => tcx.sess.fatal(&msg[..]),\n+        }\n+    })\n+}\n+\n+// To avoid UB from LLVM, these two functions mask RHS with an\n+// appropriate mask unconditionally (i.e. the fallback behavior for\n+// all shifts). For 32- and 64-bit types, this matches the semantics\n+// of Java. (See related discussion on #1877 and #10183.)\n+\n+pub fn build_unchecked_lshift<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    lhs: Bx::Value,\n+    rhs: Bx::Value\n+) -> Bx::Value {\n+    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shl, lhs, rhs);\n+    // #1877, #10183: Ensure that input is always valid\n+    let rhs = shift_mask_rhs(bx, rhs);\n+    bx.shl(lhs, rhs)\n+}\n+\n+pub fn build_unchecked_rshift<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    lhs_t: Ty<'tcx>,\n+    lhs: Bx::Value,\n+    rhs: Bx::Value\n+) -> Bx::Value {\n+    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shr, lhs, rhs);\n+    // #1877, #10183: Ensure that input is always valid\n+    let rhs = shift_mask_rhs(bx, rhs);\n+    let is_signed = lhs_t.is_signed();\n+    if is_signed {\n+        bx.ashr(lhs, rhs)\n+    } else {\n+        bx.lshr(lhs, rhs)\n+    }\n+}\n+\n+fn shift_mask_rhs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    rhs: Bx::Value\n+) -> Bx::Value {\n+    let rhs_llty = bx.cx().val_ty(rhs);\n+    let shift_val = shift_mask_val(bx, rhs_llty, rhs_llty, false);\n+    bx.and(rhs, shift_val)\n+}\n+\n+pub fn shift_mask_val<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    llty: Bx::Type,\n+    mask_llty: Bx::Type,\n+    invert: bool\n+) -> Bx::Value {\n+    let kind = bx.cx().type_kind(llty);\n+    match kind {\n+        TypeKind::Integer => {\n+            // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n+            let val = bx.cx().int_width(llty) - 1;\n+            if invert {\n+                bx.cx().const_int(mask_llty, !val as i64)\n+            } else {\n+                bx.cx().const_uint(mask_llty, val)\n+            }\n+        },\n+        TypeKind::Vector => {\n+            let mask = shift_mask_val(\n+                bx,\n+                bx.cx().element_type(llty),\n+                bx.cx().element_type(mask_llty),\n+                invert\n+            );\n+            bx.vector_splat(bx.cx().vector_length(mask_llty), mask)\n+        },\n+        _ => bug!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n+    }\n+}"}, {"sha": "0fc61422bb3a20beba657623d8df9d2ade68d64a", "filename": "src/librustc_codegen_ssa/debuginfo.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax_pos::{BytePos, Span};\n+use rustc::hir::def_id::CrateNum;\n+use std::cell::Cell;\n+\n+pub enum FunctionDebugContext<D> {\n+    RegularContext(FunctionDebugContextData<D>),\n+    DebugInfoDisabled,\n+    FunctionWithoutDebugInfo,\n+}\n+\n+impl<D> FunctionDebugContext<D> {\n+    pub fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData<D> {\n+        match *self {\n+            FunctionDebugContext::RegularContext(ref data) => data,\n+            FunctionDebugContext::DebugInfoDisabled => {\n+                span_bug!(span, \"{}\", FunctionDebugContext::<D>::debuginfo_disabled_message());\n+            }\n+            FunctionDebugContext::FunctionWithoutDebugInfo => {\n+                span_bug!(span, \"{}\", FunctionDebugContext::<D>::should_be_ignored_message());\n+            }\n+        }\n+    }\n+\n+    fn debuginfo_disabled_message() -> &'static str {\n+        \"debuginfo: Error trying to access FunctionDebugContext although debug info is disabled!\"\n+    }\n+\n+    fn should_be_ignored_message() -> &'static str {\n+        \"debuginfo: Error trying to access FunctionDebugContext for function that should be \\\n+         ignored by debug info!\"\n+    }\n+}\n+\n+/// Enables emitting source locations for the given functions.\n+///\n+/// Since we don't want source locations to be emitted for the function prelude,\n+/// they are disabled when beginning to codegen a new function. This functions\n+/// switches source location emitting on and must therefore be called before the\n+/// first real statement/expression of the function is codegened.\n+pub fn start_emitting_source_locations<D>(dbg_context: &FunctionDebugContext<D>) {\n+    match *dbg_context {\n+        FunctionDebugContext::RegularContext(ref data) => {\n+            data.source_locations_enabled.set(true)\n+        },\n+        _ => { /* safe to ignore */ }\n+    }\n+}\n+\n+pub struct FunctionDebugContextData<D> {\n+    pub fn_metadata: D,\n+    pub source_locations_enabled: Cell<bool>,\n+    pub defining_crate: CrateNum,\n+}\n+\n+pub enum VariableAccess<'a, V> {\n+    // The llptr given is an alloca containing the variable's value\n+    DirectVariable { alloca: V },\n+    // The llptr given is an alloca containing the start of some pointer chain\n+    // leading to the variable's content.\n+    IndirectVariable { alloca: V, address_operations: &'a [i64] }\n+}\n+\n+pub enum VariableKind {\n+    ArgumentVariable(usize /*index*/),\n+    LocalVariable,\n+}\n+\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct MirDebugScope<D> {\n+    pub scope_metadata: Option<D>,\n+    // Start and end offsets of the file to which this DIScope belongs.\n+    // These are used to quickly determine whether some span refers to the same file.\n+    pub file_start_pos: BytePos,\n+    pub file_end_pos: BytePos,\n+}\n+\n+impl<D> MirDebugScope<D> {\n+    pub fn is_valid(&self) -> bool {\n+        !self.scope_metadata.is_none()\n+    }\n+}"}, {"sha": "abe19068889c1008153b090b2a982e1af6d74943", "filename": "src/librustc_codegen_ssa/diagnostics.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdiagnostics.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+register_long_diagnostics! {\n+\n+E0668: r##\"\n+Malformed inline assembly rejected by LLVM.\n+\n+LLVM checks the validity of the constraints and the assembly string passed to\n+it. This error implies that LLVM seems something wrong with the inline\n+assembly call.\n+\n+In particular, it can happen if you forgot the closing bracket of a register\n+constraint (see issue #51430):\n+```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n+#![feature(asm)]\n+\n+fn main() {\n+    let rax: u64;\n+    unsafe {\n+        asm!(\"\" :\"={rax\"(rax));\n+        println!(\"Accumulator is: {}\", rax);\n+    }\n+}\n+```\n+\"##,\n+\n+E0669: r##\"\n+Cannot convert inline assembly operand to a single LLVM value.\n+\n+This error usually happens when trying to pass in a value to an input inline\n+assembly operand that is actually a pair of values. In particular, this can\n+happen when trying to pass in a slice, for instance a `&str`. In Rust, these\n+values are represented internally as a pair of values, the pointer and its\n+length. When passed as an input operand, this pair of values can not be\n+coerced into a register and thus we must fail with an error.\n+\"##,\n+\n+}"}, {"sha": "515f36b5c65deb6e35d0757afeb9fbb76aeceb43", "filename": "src/librustc_codegen_ssa/glue.rs", "status": "renamed", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fglue.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -14,24 +14,25 @@\n \n use std;\n \n-use builder::Builder;\n-use common::*;\n-use llvm;\n+use common::IntPredicate;\n use meth;\n use rustc::ty::layout::LayoutOf;\n use rustc::ty::{self, Ty};\n-use value::Value;\n+use traits::*;\n \n-pub fn size_and_align_of_dst(bx: &Builder<'_, 'll, 'tcx>, t: Ty<'tcx>, info: Option<&'ll Value>)\n-                                       -> (&'ll Value, &'ll Value) {\n+pub fn size_and_align_of_dst<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    t: Ty<'tcx>,\n+    info: Option<Bx::Value>\n+) -> (Bx::Value, Bx::Value) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, info);\n-    if bx.cx.type_is_sized(t) {\n-        let (size, align) = bx.cx.size_and_align_of(t);\n+    if bx.cx().type_is_sized(t) {\n+        let (size, align) = bx.cx().layout_of(t).size_and_align();\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n                t, info, size, align);\n-        let size = C_usize(bx.cx, size.bytes());\n-        let align = C_usize(bx.cx, align.abi());\n+        let size = bx.cx().const_usize(size.bytes());\n+        let align = bx.cx().const_usize(align.abi());\n         return (size, align);\n     }\n     match t.sty {\n@@ -44,30 +45,29 @@ pub fn size_and_align_of_dst(bx: &Builder<'_, 'll, 'tcx>, t: Ty<'tcx>, info: Opt\n             let unit = t.sequence_element_type(bx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            let (size, align) = bx.cx.size_and_align_of(unit);\n-            (bx.mul(info.unwrap(), C_usize(bx.cx, size.bytes())),\n-             C_usize(bx.cx, align.abi()))\n+            let (size, align) = bx.cx().layout_of(unit).size_and_align();\n+            (bx.mul(info.unwrap(), bx.cx().const_usize(size.bytes())),\n+             bx.cx().const_usize(align.abi()))\n         }\n         _ => {\n-            let cx = bx.cx;\n             // First get the size of all statically known fields.\n             // Don't use size_of because it also rounds up to alignment, which we\n             // want to avoid, as the unsized field's alignment could be smaller.\n             assert!(!t.is_simd());\n-            let layout = cx.layout_of(t);\n+            let layout = bx.cx().layout_of(t);\n             debug!(\"DST {} layout: {:?}\", t, layout);\n \n             let i = layout.fields.count() - 1;\n             let sized_size = layout.fields.offset(i).bytes();\n             let sized_align = layout.align.abi();\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n-            let sized_size = C_usize(cx, sized_size);\n-            let sized_align = C_usize(cx, sized_align);\n+            let sized_size = bx.cx().const_usize(sized_size);\n+            let sized_align = bx.cx().const_usize(sized_align);\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let field_ty = layout.field(cx, i).ty;\n+            let field_ty = layout.field(bx.cx(), i).ty;\n             let (unsized_size, mut unsized_align) = size_and_align_of_dst(bx, field_ty, info);\n \n             // FIXME (#26403, #27023): We should be adding padding\n@@ -89,16 +89,17 @@ pub fn size_and_align_of_dst(bx: &Builder<'_, 'll, 'tcx>, t: Ty<'tcx>, info: Opt\n \n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n-            let align = match (const_to_opt_u128(sized_align, false),\n-                               const_to_opt_u128(unsized_align, false)) {\n+            let align = match (bx.cx().const_to_opt_u128(sized_align, false),\n+                               bx.cx().const_to_opt_u128(unsized_align, false)) {\n                 (Some(sized_align), Some(unsized_align)) => {\n                     // If both alignments are constant, (the sized_align should always be), then\n                     // pick the correct alignment statically.\n-                    C_usize(cx, std::cmp::max(sized_align, unsized_align) as u64)\n+                    bx.cx().const_usize(std::cmp::max(sized_align, unsized_align) as u64)\n+                }\n+                _ => {\n+                    let cmp = bx.icmp(IntPredicate::IntUGT, sized_align, unsized_align);\n+                    bx.select(cmp, sized_align, unsized_align)\n                 }\n-                _ => bx.select(bx.icmp(llvm::IntUGT, sized_align, unsized_align),\n-                               sized_align,\n-                               unsized_align)\n             };\n \n             // Issue #27023: must add any necessary padding to `size`\n@@ -111,9 +112,11 @@ pub fn size_and_align_of_dst(bx: &Builder<'_, 'll, 'tcx>, t: Ty<'tcx>, info: Opt\n             // emulated via the semi-standard fast bit trick:\n             //\n             //   `(size + (align-1)) & -align`\n-\n-            let addend = bx.sub(align, C_usize(bx.cx, 1));\n-            let size = bx.and(bx.add(size, addend), bx.neg(align));\n+            let one = bx.cx().const_usize(1);\n+            let addend = bx.sub(align, one);\n+            let add = bx.add(size, addend);\n+            let neg =  bx.neg(align);\n+            let size = bx.and(add, neg);\n \n             (size, align)\n         }", "previous_filename": "src/librustc_codegen_llvm/glue.rs"}, {"sha": "24ede4db6e3df0bc7402cb219b86fac138644894", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -0,0 +1,187 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+\n+#![feature(box_patterns)]\n+#![feature(box_syntax)]\n+#![feature(custom_attribute)]\n+#![feature(libc)]\n+#![feature(rustc_diagnostic_macros)]\n+#![feature(in_band_lifetimes)]\n+#![feature(slice_sort_by_cached_key)]\n+#![feature(nll)]\n+#![allow(unused_attributes)]\n+#![allow(dead_code)]\n+#![feature(quote)]\n+\n+//! This crate contains codegen code that is used by all codegen backends (LLVM and others).\n+//! The backend-agnostic functions of this crate use functions defined in various traits that\n+//! have to be implemented by each backends.\n+\n+#[macro_use] extern crate bitflags;\n+#[macro_use] extern crate log;\n+extern crate rustc_apfloat;\n+#[macro_use]  extern crate rustc;\n+extern crate rustc_target;\n+extern crate rustc_mir;\n+#[macro_use] extern crate syntax;\n+extern crate syntax_pos;\n+extern crate rustc_incremental;\n+extern crate rustc_codegen_utils;\n+extern crate rustc_data_structures;\n+extern crate rustc_allocator;\n+extern crate rustc_fs_util;\n+extern crate serialize;\n+extern crate rustc_errors;\n+extern crate rustc_demangle;\n+extern crate cc;\n+extern crate libc;\n+extern crate jobserver;\n+extern crate memmap;\n+extern crate num_cpus;\n+\n+use std::path::PathBuf;\n+use rustc::dep_graph::WorkProduct;\n+use rustc::session::config::{OutputFilenames, OutputType};\n+use rustc::middle::lang_items::LangItem;\n+use rustc::hir::def_id::CrateNum;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::svh::Svh;\n+use rustc::middle::cstore::{LibSource, CrateSource, NativeLibrary};\n+use syntax_pos::symbol::Symbol;\n+\n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+mod diagnostics;\n+\n+pub mod common;\n+pub mod traits;\n+pub mod mir;\n+pub mod debuginfo;\n+pub mod base;\n+pub mod callee;\n+pub mod glue;\n+pub mod meth;\n+pub mod mono_item;\n+pub mod back;\n+\n+pub struct ModuleCodegen<M> {\n+    /// The name of the module. When the crate may be saved between\n+    /// compilations, incremental compilation requires that name be\n+    /// unique amongst **all** crates.  Therefore, it should contain\n+    /// something unique to this crate (e.g., a module path) as well\n+    /// as the crate name and disambiguator.\n+    /// We currently generate these names via CodegenUnit::build_cgu_name().\n+    pub name: String,\n+    pub module_llvm: M,\n+    pub kind: ModuleKind,\n+}\n+\n+pub const RLIB_BYTECODE_EXTENSION: &str = \"bc.z\";\n+\n+impl<M> ModuleCodegen<M> {\n+    pub fn into_compiled_module(self,\n+                            emit_obj: bool,\n+                            emit_bc: bool,\n+                            emit_bc_compressed: bool,\n+                            outputs: &OutputFilenames) -> CompiledModule {\n+        let object = if emit_obj {\n+            Some(outputs.temp_path(OutputType::Object, Some(&self.name)))\n+        } else {\n+            None\n+        };\n+        let bytecode = if emit_bc {\n+            Some(outputs.temp_path(OutputType::Bitcode, Some(&self.name)))\n+        } else {\n+            None\n+        };\n+        let bytecode_compressed = if emit_bc_compressed {\n+            Some(outputs.temp_path(OutputType::Bitcode, Some(&self.name))\n+                    .with_extension(RLIB_BYTECODE_EXTENSION))\n+        } else {\n+            None\n+        };\n+\n+        CompiledModule {\n+            name: self.name.clone(),\n+            kind: self.kind,\n+            object,\n+            bytecode,\n+            bytecode_compressed,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct CompiledModule {\n+    pub name: String,\n+    pub kind: ModuleKind,\n+    pub object: Option<PathBuf>,\n+    pub bytecode: Option<PathBuf>,\n+    pub bytecode_compressed: Option<PathBuf>,\n+}\n+\n+pub struct CachedModuleCodegen {\n+    pub name: String,\n+    pub source: WorkProduct,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum ModuleKind {\n+    Regular,\n+    Metadata,\n+    Allocator,\n+}\n+\n+bitflags! {\n+    pub struct MemFlags: u8 {\n+        const VOLATILE = 1 << 0;\n+        const NONTEMPORAL = 1 << 1;\n+        const UNALIGNED = 1 << 2;\n+    }\n+}\n+\n+/// Misc info we load from metadata to persist beyond the tcx\n+pub struct CrateInfo {\n+    pub panic_runtime: Option<CrateNum>,\n+    pub compiler_builtins: Option<CrateNum>,\n+    pub profiler_runtime: Option<CrateNum>,\n+    pub sanitizer_runtime: Option<CrateNum>,\n+    pub is_no_builtins: FxHashSet<CrateNum>,\n+    pub native_libraries: FxHashMap<CrateNum, Lrc<Vec<NativeLibrary>>>,\n+    pub crate_name: FxHashMap<CrateNum, String>,\n+    pub used_libraries: Lrc<Vec<NativeLibrary>>,\n+    pub link_args: Lrc<Vec<String>>,\n+    pub used_crate_source: FxHashMap<CrateNum, Lrc<CrateSource>>,\n+    pub used_crates_static: Vec<(CrateNum, LibSource)>,\n+    pub used_crates_dynamic: Vec<(CrateNum, LibSource)>,\n+    pub wasm_imports: FxHashMap<String, String>,\n+    pub lang_item_to_crate: FxHashMap<LangItem, CrateNum>,\n+    pub missing_lang_items: FxHashMap<CrateNum, Vec<LangItem>>,\n+}\n+\n+\n+pub struct CodegenResults {\n+    pub crate_name: Symbol,\n+    pub modules: Vec<CompiledModule>,\n+    pub allocator_module: Option<CompiledModule>,\n+    pub metadata_module: CompiledModule,\n+    pub crate_hash: Svh,\n+    pub metadata: rustc::middle::cstore::EncodedMetadata,\n+    pub windows_subsystem: Option<String>,\n+    pub linker_info: back::linker::LinkerInfo,\n+    pub crate_info: CrateInfo,\n+}\n+\n+__build_diagnostic_array! { librustc_codegen_ssa, DIAGNOSTICS }"}, {"sha": "06c4f7a87d88017de8337a6c123700da70ea0950", "filename": "src/librustc_codegen_ssa/meth.rs", "status": "renamed", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmeth.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -8,18 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{FnType, FnTypeExt};\n+use rustc_target::abi::call::FnType;\n use callee;\n-use common::*;\n-use builder::Builder;\n-use consts;\n-use monomorphize;\n-use type_::Type;\n-use value::Value;\n+use rustc_mir::monomorphize;\n+\n+use traits::*;\n \n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::HasDataLayout;\n-use debuginfo;\n \n #[derive(Copy, Clone, Debug)]\n pub struct VirtualIndex(u64);\n@@ -28,33 +23,45 @@ pub const DESTRUCTOR: VirtualIndex = VirtualIndex(0);\n pub const SIZE: VirtualIndex = VirtualIndex(1);\n pub const ALIGN: VirtualIndex = VirtualIndex(2);\n \n-impl<'a, 'tcx> VirtualIndex {\n+impl<'a, 'tcx: 'a> VirtualIndex {\n     pub fn from_index(index: usize) -> Self {\n         VirtualIndex(index as u64 + 3)\n     }\n \n-    pub fn get_fn(self, bx: &Builder<'a, 'll, 'tcx>,\n-                  llvtable: &'ll Value,\n-                  fn_ty: &FnType<'tcx, Ty<'tcx>>) -> &'ll Value {\n+    pub fn get_fn<Bx: BuilderMethods<'a, 'tcx>>(\n+        self,\n+        bx: &mut Bx,\n+        llvtable: Bx::Value,\n+        fn_ty: &FnType<'tcx, Ty<'tcx>>\n+    ) -> Bx::Value {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", llvtable, self);\n \n-        let llvtable = bx.pointercast(llvtable, fn_ty.ptr_to_llvm_type(bx.cx).ptr_to());\n+        let llvtable = bx.pointercast(\n+            llvtable,\n+            bx.cx().type_ptr_to(bx.cx().fn_ptr_backend_type(fn_ty))\n+        );\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n-        let ptr = bx.load(bx.inbounds_gep(llvtable, &[C_usize(bx.cx, self.0)]), ptr_align);\n+        let gep = bx.inbounds_gep(llvtable, &[bx.cx().const_usize(self.0)]);\n+        let ptr = bx.load(gep, ptr_align);\n         bx.nonnull_metadata(ptr);\n         // Vtable loads are invariant\n         bx.set_invariant_load(ptr);\n         ptr\n     }\n \n-    pub fn get_usize(self, bx: &Builder<'a, 'll, 'tcx>, llvtable: &'ll Value) -> &'ll Value {\n+    pub fn get_usize<Bx: BuilderMethods<'a, 'tcx>>(\n+        self,\n+        bx: &mut Bx,\n+        llvtable: Bx::Value\n+    ) -> Bx::Value {\n         // Load the data pointer from the object.\n         debug!(\"get_int({:?}, {:?})\", llvtable, self);\n \n-        let llvtable = bx.pointercast(llvtable, Type::isize(bx.cx).ptr_to());\n+        let llvtable = bx.pointercast(llvtable, bx.cx().type_ptr_to(bx.cx().type_isize()));\n         let usize_align = bx.tcx().data_layout.pointer_align;\n-        let ptr = bx.load(bx.inbounds_gep(llvtable, &[C_usize(bx.cx, self.0)]), usize_align);\n+        let gep = bx.inbounds_gep(llvtable, &[bx.cx().const_usize(self.0)]);\n+        let ptr = bx.load(gep, usize_align);\n         // Vtable loads are invariant\n         bx.set_invariant_load(ptr);\n         ptr\n@@ -69,22 +76,22 @@ impl<'a, 'tcx> VirtualIndex {\n /// The `trait_ref` encodes the erased self type. Hence if we are\n /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n /// `trait_ref` would map `T:Trait`.\n-pub fn get_vtable(\n-    cx: &CodegenCx<'ll, 'tcx>,\n+pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n+    cx: &Cx,\n     ty: Ty<'tcx>,\n     trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n-) -> &'ll Value {\n-    let tcx = cx.tcx;\n+) -> Cx::Value {\n+    let tcx = cx.tcx();\n \n     debug!(\"get_vtable(ty={:?}, trait_ref={:?})\", ty, trait_ref);\n \n     // Check the cache.\n-    if let Some(&val) = cx.vtables.borrow().get(&(ty, trait_ref)) {\n+    if let Some(&val) = cx.vtables().borrow().get(&(ty, trait_ref)) {\n         return val;\n     }\n \n     // Not in the cache. Build it.\n-    let nullptr = C_null(Type::i8p(cx));\n+    let nullptr = cx.const_null(cx.type_i8p());\n \n     let methods = tcx.vtable_methods(trait_ref.with_self_ty(tcx, ty));\n     let methods = methods.iter().cloned().map(|opt_mth| {\n@@ -93,23 +100,23 @@ pub fn get_vtable(\n         })\n     });\n \n-    let (size, align) = cx.size_and_align_of(ty);\n+    let (size, align) = cx.layout_of(ty).size_and_align();\n     // /////////////////////////////////////////////////////////////////////////////////////////////\n     // If you touch this code, be sure to also make the corresponding changes to\n     // `get_vtable` in rust_mir/interpret/traits.rs\n     // /////////////////////////////////////////////////////////////////////////////////////////////\n     let components: Vec<_> = [\n-        callee::get_fn(cx, monomorphize::resolve_drop_in_place(cx.tcx, ty)),\n-        C_usize(cx, size.bytes()),\n-        C_usize(cx, align.abi())\n+        cx.get_fn(monomorphize::resolve_drop_in_place(cx.tcx(), ty)),\n+        cx.const_usize(size.bytes()),\n+        cx.const_usize(align.abi())\n     ].iter().cloned().chain(methods).collect();\n \n-    let vtable_const = C_struct(cx, &components, false);\n+    let vtable_const = cx.const_struct(&components, false);\n     let align = cx.data_layout().pointer_align;\n-    let vtable = consts::addr_of(cx, vtable_const, align, Some(\"vtable\"));\n+    let vtable = cx.static_addr_of(vtable_const, align, Some(\"vtable\"));\n \n-    debuginfo::create_vtable_metadata(cx, ty, vtable);\n+    cx.create_vtable_metadata(ty, vtable);\n \n-    cx.vtables.borrow_mut().insert((ty, trait_ref), vtable);\n+    cx.vtables().borrow_mut().insert((ty, trait_ref), vtable);\n     vtable\n }", "previous_filename": "src/librustc_codegen_llvm/meth.rs"}, {"sha": "c7e2c76c3e503b82ddd288edad10241adfdaed50", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "renamed", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -18,11 +18,13 @@ use rustc::mir::{self, Location, TerminatorKind};\n use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::traversal;\n use rustc::ty;\n-use rustc::ty::layout::LayoutOf;\n-use type_of::LayoutLlvmExt;\n+use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n use super::FunctionCx;\n+use traits::*;\n \n-pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx>) -> BitSet<mir::Local> {\n+pub fn non_ssa_locals<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    fx: &FunctionCx<'a, 'tcx, Bx>\n+) -> BitSet<mir::Local> {\n     let mir = fx.mir;\n     let mut analyzer = LocalAnalyzer::new(fx);\n \n@@ -32,10 +34,10 @@ pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx>) -> BitSet<mir::Local> {\n         let ty = fx.monomorphize(&ty);\n         debug!(\"local {} has type {:?}\", index, ty);\n         let layout = fx.cx.layout_of(ty);\n-        if layout.is_llvm_immediate() {\n+        if fx.cx.is_backend_immediate(layout) {\n             // These sorts of types are immediates that we can store\n             // in an Value without an alloca.\n-        } else if layout.is_llvm_scalar_pair() {\n+        } else if fx.cx.is_backend_scalar_pair(layout) {\n             // We allow pairs and uses of any of their 2 fields.\n         } else {\n             // These sorts of types require an alloca. Note that\n@@ -51,17 +53,17 @@ pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx>) -> BitSet<mir::Local> {\n     analyzer.non_ssa_locals\n }\n \n-struct LocalAnalyzer<'mir, 'a: 'mir, 'll: 'a, 'tcx: 'll> {\n-    fx: &'mir FunctionCx<'a, 'll, 'tcx>,\n+struct LocalAnalyzer<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> {\n+    fx: &'mir FunctionCx<'a, 'tcx, Bx>,\n     dominators: Dominators<mir::BasicBlock>,\n     non_ssa_locals: BitSet<mir::Local>,\n     // The location of the first visited direct assignment to each\n     // local, or an invalid location (out of bounds `block` index).\n     first_assignment: IndexVec<mir::Local, Location>\n }\n \n-impl LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n-    fn new(fx: &'mir FunctionCx<'a, 'll, 'tcx>) -> Self {\n+impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n+    fn new(fx: &'mir FunctionCx<'a, 'tcx, Bx>) -> Self {\n         let invalid_location =\n             mir::BasicBlock::new(fx.mir.basic_blocks().len()).start_location();\n         let mut analyzer = LocalAnalyzer {\n@@ -102,7 +104,8 @@ impl LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n     }\n }\n \n-impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n+impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n+    for LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n     fn visit_assign(&mut self,\n                     block: mir::BasicBlock,\n                     place: &mir::Place<'tcx>,\n@@ -141,7 +144,7 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n             _ => None,\n         };\n         if let Some((def_id, args)) = check {\n-            if Some(def_id) == self.fx.cx.tcx.lang_items().box_free_fn() {\n+            if Some(def_id) == self.fx.cx.tcx().lang_items().box_free_fn() {\n                 // box_free(x) shares with `drop x` the property that it\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca.\n@@ -173,21 +176,21 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n                 _ => false\n             };\n             if is_consume {\n-                let base_ty = proj.base.ty(self.fx.mir, cx.tcx);\n+                let base_ty = proj.base.ty(self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access.\n                 let elem_ty = base_ty\n-                    .projection_ty(cx.tcx, &proj.elem)\n-                    .to_ty(cx.tcx);\n+                    .projection_ty(cx.tcx(), &proj.elem)\n+                    .to_ty(cx.tcx());\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n                 if cx.layout_of(elem_ty).is_zst() {\n                     return;\n                 }\n \n                 if let mir::ProjectionElem::Field(..) = proj.elem {\n-                    let layout = cx.layout_of(base_ty.to_ty(cx.tcx));\n-                    if layout.is_llvm_immediate() || layout.is_llvm_scalar_pair() {\n+                    let layout = cx.layout_of(base_ty.to_ty(cx.tcx()));\n+                    if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n                         // Recurse with the same context, instead of `Projection`,\n                         // potentially stopping at non-operand projections,\n                         // which would trigger `not_ssa` on locals.\n@@ -252,8 +255,8 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n             }\n \n             PlaceContext::MutatingUse(MutatingUseContext::Drop) => {\n-                let ty = mir::Place::Local(local).ty(self.fx.mir, self.fx.cx.tcx);\n-                let ty = self.fx.monomorphize(&ty.to_ty(self.fx.cx.tcx));\n+                let ty = mir::Place::Local(local).ty(self.fx.mir, self.fx.cx.tcx());\n+                let ty = self.fx.monomorphize(&ty.to_ty(self.fx.cx.tcx()));\n \n                 // Only need the place if we're actually dropping it.\n                 if self.fx.cx.type_needs_drop(ty) {", "previous_filename": "src/librustc_codegen_llvm/mir/analyze.rs"}, {"sha": "1702ad19b76fd04e22c8f9e98f778f21c75953f8", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "renamed", "additions": 274, "deletions": 217, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -8,23 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, BasicBlock};\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, LayoutOf};\n+use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n use rustc::mir;\n use rustc::mir::interpret::EvalErrorKind;\n-use abi::{Abi, ArgType, ArgTypeExt, FnType, FnTypeExt, LlvmType, PassMode};\n+use rustc_target::abi::call::{ArgType, FnType, PassMode};\n+use rustc_target::spec::abi::Abi;\n use base;\n-use callee;\n-use builder::{Builder, MemFlags};\n-use common::{self, C_bool, C_str_slice, C_struct, C_u32, C_uint_big, C_undef};\n-use consts;\n+use MemFlags;\n+use common::{self, IntPredicate};\n use meth;\n-use monomorphize;\n-use type_of::LayoutLlvmExt;\n-use type_::Type;\n-use value::Value;\n+use rustc_mir::monomorphize;\n+\n+use traits::*;\n \n use syntax::symbol::Symbol;\n use syntax_pos::Pos;\n@@ -34,8 +31,11 @@ use super::place::PlaceRef;\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n-impl FunctionCx<'a, 'll, 'tcx> {\n-    pub fn codegen_block(&mut self, bb: mir::BasicBlock) {\n+impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    pub fn codegen_block(\n+        &mut self,\n+        bb: mir::BasicBlock,\n+    ) {\n         let mut bx = self.build_block(bb);\n         let data = &self.mir[bb];\n \n@@ -48,21 +48,33 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         self.codegen_terminator(bx, bb, data.terminator());\n     }\n \n-    fn codegen_terminator(&mut self,\n-                          mut bx: Builder<'a, 'll, 'tcx>,\n-                          bb: mir::BasicBlock,\n-                          terminator: &mir::Terminator<'tcx>)\n-    {\n+    fn codegen_terminator(\n+        &mut self,\n+        mut bx: Bx,\n+        bb: mir::BasicBlock,\n+        terminator: &mir::Terminator<'tcx>\n+    ) {\n         debug!(\"codegen_terminator: {:?}\", terminator);\n \n         // Create the cleanup bundle, if needed.\n-        let tcx = bx.tcx();\n+        let tcx = self.cx.tcx();\n         let span = terminator.source_info.span;\n         let funclet_bb = self.cleanup_kinds[bb].funclet_bb(bb);\n-        let funclet = funclet_bb.and_then(|funclet_bb| self.funclets[funclet_bb].as_ref());\n \n-        let cleanup_pad = funclet.map(|lp| lp.cleanuppad());\n-        let cleanup_bundle = funclet.map(|l| l.bundle());\n+        // HACK(eddyb) force the right lifetimes, NLL can't figure them out.\n+        fn funclet_closure_factory<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+            funclet_bb: Option<mir::BasicBlock>\n+        ) -> impl for<'b> Fn(\n+            &'b FunctionCx<'a, 'tcx, Bx>,\n+        ) -> Option<&'b Bx::Funclet> {\n+            move |this| {\n+                match funclet_bb {\n+                    Some(funclet_bb) => this.funclets[funclet_bb].as_ref(),\n+                    None => None,\n+                }\n+            }\n+        }\n+        let funclet = funclet_closure_factory(funclet_bb);\n \n         let lltarget = |this: &mut Self, target: mir::BasicBlock| {\n             let lltarget = this.blocks[target];\n@@ -90,32 +102,33 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n                 debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n                 let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", bb, target);\n-                let trampoline = this.new_block(name);\n-                trampoline.cleanup_ret(cleanup_pad.unwrap(), Some(lltarget));\n+                let mut trampoline = this.new_block(name);\n+                trampoline.cleanup_ret(funclet(this).unwrap(), Some(lltarget));\n                 trampoline.llbb()\n             } else {\n                 lltarget\n             }\n         };\n \n-        let funclet_br = |this: &mut Self, bx: Builder<'_, 'll, '_>, target: mir::BasicBlock| {\n-            let (lltarget, is_cleanupret) = lltarget(this, target);\n-            if is_cleanupret {\n-                // micro-optimization: generate a `ret` rather than a jump\n-                // to a trampoline.\n-                bx.cleanup_ret(cleanup_pad.unwrap(), Some(lltarget));\n-            } else {\n-                bx.br(lltarget);\n-            }\n-        };\n+        let funclet_br =\n+            |this: &mut Self, bx: &mut Bx, target: mir::BasicBlock| {\n+                let (lltarget, is_cleanupret) = lltarget(this, target);\n+                if is_cleanupret {\n+                    // micro-optimization: generate a `ret` rather than a jump\n+                    // to a trampoline.\n+                    bx.cleanup_ret(funclet(this).unwrap(), Some(lltarget));\n+                } else {\n+                    bx.br(lltarget);\n+                }\n+            };\n \n         let do_call = |\n             this: &mut Self,\n-            bx: Builder<'a, 'll, 'tcx>,\n+            bx: &mut Bx,\n             fn_ty: FnType<'tcx, Ty<'tcx>>,\n-            fn_ptr: &'ll Value,\n-            llargs: &[&'ll Value],\n-            destination: Option<(ReturnDest<'ll, 'tcx>, mir::BasicBlock)>,\n+            fn_ptr: Bx::Value,\n+            llargs: &[Bx::Value],\n+            destination: Option<(ReturnDest<'tcx, Bx::Value>, mir::BasicBlock)>,\n             cleanup: Option<mir::BasicBlock>\n         | {\n             if let Some(cleanup) = cleanup {\n@@ -128,70 +141,72 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                                           &llargs,\n                                           ret_bx,\n                                           llblock(this, cleanup),\n-                                          cleanup_bundle);\n-                fn_ty.apply_attrs_callsite(&bx, invokeret);\n+                                          funclet(this));\n+                bx.apply_attrs_callsite(&fn_ty, invokeret);\n \n                 if let Some((ret_dest, target)) = destination {\n-                    let ret_bx = this.build_block(target);\n-                    this.set_debug_loc(&ret_bx, terminator.source_info);\n-                    this.store_return(&ret_bx, ret_dest, &fn_ty.ret, invokeret);\n+                    let mut ret_bx = this.build_block(target);\n+                    this.set_debug_loc(&mut ret_bx, terminator.source_info);\n+                    this.store_return(&mut ret_bx, ret_dest, &fn_ty.ret, invokeret);\n                 }\n             } else {\n-                let llret = bx.call(fn_ptr, &llargs, cleanup_bundle);\n-                fn_ty.apply_attrs_callsite(&bx, llret);\n+                let llret = bx.call(fn_ptr, &llargs, funclet(this));\n+                bx.apply_attrs_callsite(&fn_ty, llret);\n                 if this.mir[bb].is_cleanup {\n                     // Cleanup is always the cold path. Don't inline\n                     // drop glue. Also, when there is a deeply-nested\n                     // struct, there are \"symmetry\" issues that cause\n                     // exponential inlining - see issue #41696.\n-                    llvm::Attribute::NoInline.apply_callsite(llvm::AttributePlace::Function, llret);\n+                    bx.do_not_inline(llret);\n                 }\n \n                 if let Some((ret_dest, target)) = destination {\n-                    this.store_return(&bx, ret_dest, &fn_ty.ret, llret);\n+                    this.store_return(bx, ret_dest, &fn_ty.ret, llret);\n                     funclet_br(this, bx, target);\n                 } else {\n                     bx.unreachable();\n                 }\n             }\n         };\n \n-        self.set_debug_loc(&bx, terminator.source_info);\n+        self.set_debug_loc(&mut bx, terminator.source_info);\n         match terminator.kind {\n             mir::TerminatorKind::Resume => {\n-                if let Some(cleanup_pad) = cleanup_pad {\n-                    bx.cleanup_ret(cleanup_pad, None);\n+                if let Some(funclet) = funclet(self) {\n+                    bx.cleanup_ret(funclet, None);\n                 } else {\n-                    let slot = self.get_personality_slot(&bx);\n-                    let lp0 = slot.project_field(&bx, 0).load(&bx).immediate();\n-                    let lp1 = slot.project_field(&bx, 1).load(&bx).immediate();\n-                    slot.storage_dead(&bx);\n-\n-                    if !bx.sess().target.target.options.custom_unwind_resume {\n-                        let mut lp = C_undef(self.landing_pad_type());\n+                    let slot = self.get_personality_slot(&mut bx);\n+                    let lp0 = slot.project_field(&mut bx, 0);\n+                    let lp0 = bx.load_operand(lp0).immediate();\n+                    let lp1 = slot.project_field(&mut bx, 1);\n+                    let lp1 = bx.load_operand(lp1).immediate();\n+                    slot.storage_dead(&mut bx);\n+\n+                    if !bx.cx().sess().target.target.options.custom_unwind_resume {\n+                        let mut lp = bx.cx().const_undef(self.landing_pad_type());\n                         lp = bx.insert_value(lp, lp0, 0);\n                         lp = bx.insert_value(lp, lp1, 1);\n                         bx.resume(lp);\n                     } else {\n-                        bx.call(bx.cx.eh_unwind_resume(), &[lp0], cleanup_bundle);\n+                        bx.call(bx.cx().eh_unwind_resume(), &[lp0], funclet(self));\n                         bx.unreachable();\n                     }\n                 }\n             }\n \n             mir::TerminatorKind::Abort => {\n                 // Call core::intrinsics::abort()\n-                let fnname = bx.cx.get_intrinsic(&(\"llvm.trap\"));\n+                let fnname = bx.cx().get_intrinsic(&(\"llvm.trap\"));\n                 bx.call(fnname, &[], None);\n                 bx.unreachable();\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n-                funclet_br(self, bx, target);\n+                funclet_br(self, &mut bx, target);\n             }\n \n             mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n-                let discr = self.codegen_operand(&bx, discr);\n+                let discr = self.codegen_operand(&mut bx, discr);\n                 if targets.len() == 2 {\n                     // If there are two targets, emit br instead of switch\n                     let lltrue = llblock(self, targets[0]);\n@@ -205,19 +220,23 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                             bx.cond_br(discr.immediate(), lltrue, llfalse);\n                         }\n                     } else {\n-                        let switch_llty = bx.cx.layout_of(switch_ty).immediate_llvm_type(bx.cx);\n-                        let llval = C_uint_big(switch_llty, values[0]);\n-                        let cmp = bx.icmp(llvm::IntEQ, discr.immediate(), llval);\n+                        let switch_llty = bx.cx().immediate_backend_type(\n+                            bx.cx().layout_of(switch_ty)\n+                        );\n+                        let llval = bx.cx().const_uint_big(switch_llty, values[0]);\n+                        let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n                         bx.cond_br(cmp, lltrue, llfalse);\n                     }\n                 } else {\n                     let (otherwise, targets) = targets.split_last().unwrap();\n                     let switch = bx.switch(discr.immediate(),\n                                            llblock(self, *otherwise),\n                                            values.len());\n-                    let switch_llty = bx.cx.layout_of(switch_ty).immediate_llvm_type(bx.cx);\n+                    let switch_llty = bx.cx().immediate_backend_type(\n+                        bx.cx().layout_of(switch_ty)\n+                    );\n                     for (&value, target) in values.iter().zip(targets) {\n-                        let llval = C_uint_big(switch_llty, value);\n+                        let llval = bx.cx().const_uint_big(switch_llty, value);\n                         let llbb = llblock(self, *target);\n                         bx.add_case(switch, llval, llbb)\n                     }\n@@ -232,11 +251,12 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     }\n \n                     PassMode::Direct(_) | PassMode::Pair(..) => {\n-                        let op = self.codegen_consume(&bx, &mir::Place::Local(mir::RETURN_PLACE));\n+                        let op =\n+                            self.codegen_consume(&mut bx, &mir::Place::Local(mir::RETURN_PLACE));\n                         if let Ref(llval, _, align) = op.val {\n                             bx.load(llval, align)\n                         } else {\n-                            op.immediate_or_packed_pair(&bx)\n+                            op.immediate_or_packed_pair(&mut bx)\n                         }\n                     }\n \n@@ -254,8 +274,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         };\n                         let llslot = match op.val {\n                             Immediate(_) | Pair(..) => {\n-                                let scratch = PlaceRef::alloca(&bx, self.fn_ty.ret.layout, \"ret\");\n-                                op.val.store(&bx, scratch);\n+                                let scratch =\n+                                    PlaceRef::alloca(&mut bx, self.fn_ty.ret.layout, \"ret\");\n+                                op.val.store(&mut bx, scratch);\n                                 scratch.llval\n                             }\n                             Ref(llval, _, align) => {\n@@ -264,9 +285,10 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                                 llval\n                             }\n                         };\n-                        bx.load(\n-                            bx.pointercast(llslot, cast_ty.llvm_type(bx.cx).ptr_to()),\n-                            self.fn_ty.ret.layout.align)\n+                        let addr = bx.pointercast(llslot, bx.cx().type_ptr_to(\n+                            bx.cx().cast_backend_type(&cast_ty)\n+                        ));\n+                        bx.load(addr, self.fn_ty.ret.layout.align)\n                     }\n                 };\n                 bx.ret(llval);\n@@ -279,15 +301,15 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n                 let ty = location.ty(self.mir, bx.tcx()).to_ty(bx.tcx());\n                 let ty = self.monomorphize(&ty);\n-                let drop_fn = monomorphize::resolve_drop_in_place(bx.cx.tcx, ty);\n+                let drop_fn = monomorphize::resolve_drop_in_place(bx.cx().tcx(), ty);\n \n                 if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n                     // we don't actually need to drop anything.\n-                    funclet_br(self, bx, target);\n+                    funclet_br(self, &mut bx, target);\n                     return\n                 }\n \n-                let place = self.codegen_place(&bx, location);\n+                let place = self.codegen_place(&mut bx, location);\n                 let (args1, args2);\n                 let mut args = if let Some(llextra) = place.llextra {\n                     args2 = [place.llval, llextra];\n@@ -298,29 +320,29 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 };\n                 let (drop_fn, fn_ty) = match ty.sty {\n                     ty::Dynamic(..) => {\n-                        let sig = drop_fn.fn_sig(bx.cx.tcx);\n-                        let sig = bx.tcx().normalize_erasing_late_bound_regions(\n+                        let sig = drop_fn.fn_sig(tcx);\n+                        let sig = tcx.normalize_erasing_late_bound_regions(\n                             ty::ParamEnv::reveal_all(),\n                             &sig,\n                         );\n-                        let fn_ty = FnType::new_vtable(bx.cx, sig, &[]);\n+                        let fn_ty = bx.cx().new_vtable(sig, &[]);\n                         let vtable = args[1];\n                         args = &args[..1];\n-                        (meth::DESTRUCTOR.get_fn(&bx, vtable, &fn_ty), fn_ty)\n+                        (meth::DESTRUCTOR.get_fn(&mut bx, vtable, &fn_ty), fn_ty)\n                     }\n                     _ => {\n-                        (callee::get_fn(bx.cx, drop_fn),\n-                         FnType::of_instance(bx.cx, &drop_fn))\n+                        (bx.cx().get_fn(drop_fn),\n+                         bx.cx().fn_type_of_instance(&drop_fn))\n                     }\n                 };\n-                do_call(self, bx, fn_ty, drop_fn, args,\n+                do_call(self, &mut bx, fn_ty, drop_fn, args,\n                         Some((ReturnDest::Nothing, target)),\n                         unwind);\n             }\n \n             mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                let cond = self.codegen_operand(&bx, cond).immediate();\n-                let mut const_cond = common::const_to_opt_u128(cond, false).map(|c| c == 1);\n+                let cond = self.codegen_operand(&mut bx, cond).immediate();\n+                let mut const_cond = bx.cx().const_to_opt_u128(cond, false).map(|c| c == 1);\n \n                 // This case can currently arise only from functions marked\n                 // with #[rustc_inherit_overflow_checks] and inlined from\n@@ -329,21 +351,21 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 // NOTE: Unlike binops, negation doesn't have its own\n                 // checked operation, just a comparison with the minimum\n                 // value, so we have to check for the assert message.\n-                if !bx.cx.check_overflow {\n+                if !bx.cx().check_overflow() {\n                     if let mir::interpret::EvalErrorKind::OverflowNeg = *msg {\n                         const_cond = Some(expected);\n                     }\n                 }\n \n                 // Don't codegen the panic block if success if known.\n                 if const_cond == Some(expected) {\n-                    funclet_br(self, bx, target);\n+                    funclet_br(self, &mut bx, target);\n                     return;\n                 }\n \n                 // Pass the condition through llvm.expect for branch hinting.\n-                let expect = bx.cx.get_intrinsic(&\"llvm.expect.i1\");\n-                let cond = bx.call(expect, &[cond, C_bool(bx.cx, expected)], None);\n+                let expect = bx.cx().get_intrinsic(&\"llvm.expect.i1\");\n+                let cond = bx.call(expect, &[cond, bx.cx().const_bool(expected)], None);\n \n                 // Create the failure block and the conditional branch to it.\n                 let lltarget = llblock(self, target);\n@@ -356,14 +378,14 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n                 // After this point, bx is the block for the call to panic.\n                 bx = panic_block;\n-                self.set_debug_loc(&bx, terminator.source_info);\n+                self.set_debug_loc(&mut bx, terminator.source_info);\n \n                 // Get the location information.\n-                let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n+                let loc = bx.cx().sess().source_map().lookup_char_pos(span.lo());\n                 let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-                let filename = C_str_slice(bx.cx, filename);\n-                let line = C_u32(bx.cx, loc.line as u32);\n-                let col = C_u32(bx.cx, loc.col.to_usize() as u32 + 1);\n+                let filename = bx.cx().const_str_slice(filename);\n+                let line = bx.cx().const_u32(loc.line as u32);\n+                let col = bx.cx().const_u32(loc.col.to_usize() as u32 + 1);\n                 let align = tcx.data_layout.aggregate_align\n                     .max(tcx.data_layout.i32_align)\n                     .max(tcx.data_layout.pointer_align);\n@@ -374,25 +396,28 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         let len = self.codegen_operand(&mut bx, len).immediate();\n                         let index = self.codegen_operand(&mut bx, index).immediate();\n \n-                        let file_line_col = C_struct(bx.cx, &[filename, line, col], false);\n-                        let file_line_col = consts::addr_of(bx.cx,\n-                                                            file_line_col,\n-                                                            align,\n-                                                            Some(\"panic_bounds_check_loc\"));\n+                        let file_line_col = bx.cx().const_struct(&[filename, line, col], false);\n+                        let file_line_col = bx.cx().static_addr_of(\n+                            file_line_col,\n+                            align,\n+                            Some(\"panic_bounds_check_loc\")\n+                        );\n                         (lang_items::PanicBoundsCheckFnLangItem,\n                          vec![file_line_col, index, len])\n                     }\n                     _ => {\n                         let str = msg.description();\n                         let msg_str = Symbol::intern(str).as_str();\n-                        let msg_str = C_str_slice(bx.cx, msg_str);\n-                        let msg_file_line_col = C_struct(bx.cx,\n-                                                         &[msg_str, filename, line, col],\n-                                                         false);\n-                        let msg_file_line_col = consts::addr_of(bx.cx,\n-                                                                msg_file_line_col,\n-                                                                align,\n-                                                                Some(\"panic_loc\"));\n+                        let msg_str = bx.cx().const_str_slice(msg_str);\n+                        let msg_file_line_col = bx.cx().const_struct(\n+                            &[msg_str, filename, line, col],\n+                            false\n+                        );\n+                        let msg_file_line_col = bx.cx().static_addr_of(\n+                            msg_file_line_col,\n+                            align,\n+                            Some(\"panic_loc\")\n+                        );\n                         (lang_items::PanicFnLangItem,\n                          vec![msg_file_line_col])\n                     }\n@@ -401,11 +426,11 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 // Obtain the panic entry point.\n                 let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let fn_ty = FnType::of_instance(bx.cx, &instance);\n-                let llfn = callee::get_fn(bx.cx, instance);\n+                let fn_ty = bx.cx().fn_type_of_instance(&instance);\n+                let llfn = bx.cx().get_fn(instance);\n \n                 // Codegen the actual panic invoke/call.\n-                do_call(self, bx, fn_ty, llfn, &args, None, cleanup);\n+                do_call(self, &mut bx, fn_ty, llfn, &args, None, cleanup);\n             }\n \n             mir::TerminatorKind::DropAndReplace { .. } => {\n@@ -420,11 +445,11 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 from_hir_call: _\n             } => {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n-                let callee = self.codegen_operand(&bx, func);\n+                let callee = self.codegen_operand(&mut bx, func);\n \n                 let (instance, mut llfn) = match callee.layout.ty.sty {\n                     ty::FnDef(def_id, substs) => {\n-                        (Some(ty::Instance::resolve(bx.cx.tcx,\n+                        (Some(ty::Instance::resolve(bx.cx().tcx(),\n                                                     ty::ParamEnv::reveal_all(),\n                                                     def_id,\n                                                     substs).unwrap()),\n@@ -454,16 +479,16 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 if intrinsic == Some(\"transmute\") {\n                     if let Some(destination_ref) = destination.as_ref() {\n                         let &(ref dest, target) = destination_ref;\n-                        self.codegen_transmute(&bx, &args[0], dest);\n-                        funclet_br(self, bx, target);\n+                        self.codegen_transmute(&mut bx, &args[0], dest);\n+                        funclet_br(self, &mut bx, target);\n                     } else {\n                         // If we are trying to transmute to an uninhabited type,\n                         // it is likely there is no allotted destination. In fact,\n                         // transmuting to an uninhabited type is UB, which means\n                         // we can do what we like. Here, we declare that transmuting\n                         // into an uninhabited type is impossible, so anything following\n                         // it must be unreachable.\n-                        assert_eq!(bx.cx.layout_of(sig.output()).abi, layout::Abi::Uninhabited);\n+                        assert_eq!(bx.cx().layout_of(sig.output()).abi, layout::Abi::Uninhabited);\n                         bx.unreachable();\n                     }\n                     return;\n@@ -477,26 +502,26 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n                 let fn_ty = match def {\n                     Some(ty::InstanceDef::Virtual(..)) => {\n-                        FnType::new_vtable(bx.cx, sig, &extra_args)\n+                        bx.cx().new_vtable(sig, &extra_args)\n                     }\n                     Some(ty::InstanceDef::DropGlue(_, None)) => {\n                         // empty drop glue - a nop.\n                         let &(_, target) = destination.as_ref().unwrap();\n-                        funclet_br(self, bx, target);\n+                        funclet_br(self, &mut bx, target);\n                         return;\n                     }\n-                    _ => FnType::new(bx.cx, sig, &extra_args)\n+                    _ => bx.cx().new_fn_type(sig, &extra_args)\n                 };\n \n                 // emit a panic instead of instantiating an uninhabited type\n                 if (intrinsic == Some(\"init\") || intrinsic == Some(\"uninit\")) &&\n                     fn_ty.ret.layout.abi.is_uninhabited()\n                 {\n-                    let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n+                    let loc = bx.cx().sess().source_map().lookup_char_pos(span.lo());\n                     let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-                    let filename = C_str_slice(bx.cx, filename);\n-                    let line = C_u32(bx.cx, loc.line as u32);\n-                    let col = C_u32(bx.cx, loc.col.to_usize() as u32 + 1);\n+                    let filename = bx.cx().const_str_slice(filename);\n+                    let line = bx.cx().const_u32(loc.line as u32);\n+                    let col = bx.cx().const_u32(loc.col.to_usize() as u32 + 1);\n                     let align = tcx.data_layout.aggregate_align\n                         .max(tcx.data_layout.i32_align)\n                         .max(tcx.data_layout.pointer_align);\n@@ -507,26 +532,28 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         if intrinsic == Some(\"init\") { \"zeroed\" } else { \"uninitialized\" }\n                     );\n                     let msg_str = Symbol::intern(&str).as_str();\n-                    let msg_str = C_str_slice(bx.cx, msg_str);\n-                    let msg_file_line_col = C_struct(bx.cx,\n-                                                     &[msg_str, filename, line, col],\n-                                                     false);\n-                    let msg_file_line_col = consts::addr_of(bx.cx,\n-                                                            msg_file_line_col,\n-                                                            align,\n-                                                            Some(\"panic_loc\"));\n+                    let msg_str = bx.cx().const_str_slice(msg_str);\n+                    let msg_file_line_col = bx.cx().const_struct(\n+                        &[msg_str, filename, line, col],\n+                        false,\n+                    );\n+                    let msg_file_line_col = bx.cx().static_addr_of(\n+                        msg_file_line_col,\n+                        align,\n+                        Some(\"panic_loc\"),\n+                    );\n \n                     // Obtain the panic entry point.\n                     let def_id =\n                         common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n                     let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                    let fn_ty = FnType::of_instance(bx.cx, &instance);\n-                    let llfn = callee::get_fn(bx.cx, instance);\n+                    let fn_ty = bx.cx().fn_type_of_instance(&instance);\n+                    let llfn = bx.cx().get_fn(instance);\n \n                     // Codegen the actual panic invoke/call.\n                     do_call(\n                         self,\n-                        bx,\n+                        &mut bx,\n                         fn_ty,\n                         llfn,\n                         &[msg_file_line_col],\n@@ -543,19 +570,17 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 // Prepare the return value destination\n                 let ret_dest = if let Some((ref dest, _)) = *destination {\n                     let is_intrinsic = intrinsic.is_some();\n-                    self.make_return_dest(&bx, dest, &fn_ty.ret, &mut llargs,\n+                    self.make_return_dest(&mut bx, dest, &fn_ty.ret, &mut llargs,\n                                           is_intrinsic)\n                 } else {\n                     ReturnDest::Nothing\n                 };\n \n                 if intrinsic.is_some() && intrinsic != Some(\"drop_in_place\") {\n-                    use intrinsic::codegen_intrinsic_call;\n-\n                     let dest = match ret_dest {\n                         _ if fn_ty.ret.is_indirect() => llargs[0],\n                         ReturnDest::Nothing => {\n-                            C_undef(fn_ty.ret.memory_ty(bx.cx).ptr_to())\n+                            bx.cx().const_undef(bx.cx().type_ptr_to(bx.memory_ty(&fn_ty.ret)))\n                         }\n                         ReturnDest::IndirectOperand(dst, _) |\n                         ReturnDest::Store(dst) => dst.llval,\n@@ -589,7 +614,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                                     );\n                                     return OperandRef {\n                                         val: Immediate(llval),\n-                                        layout: bx.cx.layout_of(ty),\n+                                        layout: bx.cx().layout_of(ty),\n                                     };\n \n                                 },\n@@ -607,26 +632,26 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                                     );\n                                     return OperandRef {\n                                         val: Immediate(llval),\n-                                        layout: bx.cx.layout_of(ty)\n+                                        layout: bx.cx().layout_of(ty)\n                                     };\n                                 }\n                             }\n                         }\n \n-                        self.codegen_operand(&bx, arg)\n+                        self.codegen_operand(&mut bx, arg)\n                     }).collect();\n \n \n-                    let callee_ty = instance.as_ref().unwrap().ty(bx.cx.tcx);\n-                    codegen_intrinsic_call(&bx, callee_ty, &fn_ty, &args, dest,\n-                                           terminator.source_info.span);\n+                    let callee_ty = instance.as_ref().unwrap().ty(bx.cx().tcx());\n+                    bx.codegen_intrinsic_call(callee_ty, &fn_ty, &args, dest,\n+                                               terminator.source_info.span);\n \n                     if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n-                        self.store_return(&bx, ret_dest, &fn_ty.ret, dst.llval);\n+                        self.store_return(&mut bx, ret_dest, &fn_ty.ret, dst.llval);\n                     }\n \n                     if let Some((_, target)) = *destination {\n-                        funclet_br(self, bx, target);\n+                        funclet_br(self, &mut bx, target);\n                     } else {\n                         bx.unreachable();\n                     }\n@@ -643,7 +668,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 };\n \n                 'make_args: for (i, arg) in first_args.iter().enumerate() {\n-                    let mut op = self.codegen_operand(&bx, arg);\n+                    let mut op = self.codegen_operand(&mut bx, arg);\n \n                     if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n                         if let Pair(..) = op.val {\n@@ -657,7 +682,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                                             && !op.layout.ty.is_region_ptr()\n                             {\n                                 'iter_fields: for i in 0..op.layout.fields.count() {\n-                                    let field = op.extract_field(&bx, i);\n+                                    let field = op.extract_field(&mut bx, i);\n                                     if !field.layout.is_zst() {\n                                         // we found the one non-zero-sized field that is allowed\n                                         // now find *its* non-zero-sized field, or stop if it's a\n@@ -676,7 +701,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                             match op.val {\n                                 Pair(data_ptr, meta) => {\n                                     llfn = Some(meth::VirtualIndex::from_index(idx)\n-                                        .get_fn(&bx, meta, &fn_ty));\n+                                        .get_fn(&mut bx, meta, &fn_ty));\n                                     llargs.push(data_ptr);\n                                     continue 'make_args\n                                 }\n@@ -685,7 +710,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         } else if let Ref(data_ptr, Some(meta), _) = op.val {\n                             // by-value dynamic dispatch\n                             llfn = Some(meth::VirtualIndex::from_index(idx)\n-                                .get_fn(&bx, meta, &fn_ty));\n+                                .get_fn(&mut bx, meta, &fn_ty));\n                             llargs.push(data_ptr);\n                             continue;\n                         } else {\n@@ -698,27 +723,27 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     match (arg, op.val) {\n                         (&mir::Operand::Copy(_), Ref(_, None, _)) |\n                         (&mir::Operand::Constant(_), Ref(_, None, _)) => {\n-                            let tmp = PlaceRef::alloca(&bx, op.layout, \"const\");\n-                            op.val.store(&bx, tmp);\n+                            let tmp = PlaceRef::alloca(&mut bx, op.layout, \"const\");\n+                            op.val.store(&mut bx, tmp);\n                             op.val = Ref(tmp.llval, None, tmp.align);\n                         }\n                         _ => {}\n                     }\n \n-                    self.codegen_argument(&bx, op, &mut llargs, &fn_ty.args[i]);\n+                    self.codegen_argument(&mut bx, op, &mut llargs, &fn_ty.args[i]);\n                 }\n                 if let Some(tup) = untuple {\n-                    self.codegen_arguments_untupled(&bx, tup, &mut llargs,\n+                    self.codegen_arguments_untupled(&mut bx, tup, &mut llargs,\n                         &fn_ty.args[first_args.len()..])\n                 }\n \n                 let fn_ptr = match (llfn, instance) {\n                     (Some(llfn), _) => llfn,\n-                    (None, Some(instance)) => callee::get_fn(bx.cx, instance),\n+                    (None, Some(instance)) => bx.cx().get_fn(instance),\n                     _ => span_bug!(span, \"no llfn for call\"),\n                 };\n \n-                do_call(self, bx, fn_ty, fn_ptr, &llargs,\n+                do_call(self, &mut bx, fn_ty, fn_ptr, &llargs,\n                         destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n                         cleanup);\n             }\n@@ -729,14 +754,16 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn codegen_argument(&mut self,\n-                      bx: &Builder<'a, 'll, 'tcx>,\n-                      op: OperandRef<'ll, 'tcx>,\n-                      llargs: &mut Vec<&'ll Value>,\n-                      arg: &ArgType<'tcx, Ty<'tcx>>) {\n+    fn codegen_argument(\n+        &mut self,\n+        bx: &mut Bx,\n+        op: OperandRef<'tcx, Bx::Value>,\n+        llargs: &mut Vec<Bx::Value>,\n+        arg: &ArgType<'tcx, Ty<'tcx>>\n+    ) {\n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n-            llargs.push(C_undef(ty.llvm_type(bx.cx)));\n+            llargs.push(bx.cx().const_undef(bx.cx().reg_backend_type(&ty)))\n         }\n \n         if arg.is_ignore() {\n@@ -796,8 +823,10 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n             if let PassMode::Cast(ty) = arg.mode {\n-                llval = bx.load(bx.pointercast(llval, ty.llvm_type(bx.cx).ptr_to()),\n-                                align.min(arg.layout.align));\n+                let addr = bx.pointercast(llval, bx.cx().type_ptr_to(\n+                    bx.cx().cast_backend_type(&ty))\n+                );\n+                llval = bx.load(addr, align.min(arg.layout.align));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n                 // may have a type we don't treat as immediate, but the ABI\n@@ -818,19 +847,22 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         llargs.push(llval);\n     }\n \n-    fn codegen_arguments_untupled(&mut self,\n-                                  bx: &Builder<'a, 'll, 'tcx>,\n-                                  operand: &mir::Operand<'tcx>,\n-                                  llargs: &mut Vec<&'ll Value>,\n-                                  args: &[ArgType<'tcx, Ty<'tcx>>]) {\n+    fn codegen_arguments_untupled(\n+        &mut self,\n+        bx: &mut Bx,\n+        operand: &mir::Operand<'tcx>,\n+        llargs: &mut Vec<Bx::Value>,\n+        args: &[ArgType<'tcx, Ty<'tcx>>]\n+    ) {\n         let tuple = self.codegen_operand(bx, operand);\n \n         // Handle both by-ref and immediate tuples.\n         if let Ref(llval, None, align) = tuple.val {\n             let tuple_ptr = PlaceRef::new_sized(llval, tuple.layout, align);\n             for i in 0..tuple.layout.fields.count() {\n                 let field_ptr = tuple_ptr.project_field(bx, i);\n-                self.codegen_argument(bx, field_ptr.load(bx), llargs, &args[i]);\n+                let field = bx.load_operand(field_ptr);\n+                self.codegen_argument(bx, field, llargs, &args[i]);\n             }\n         } else if let Ref(_, Some(_), _) = tuple.val {\n             bug!(\"closure arguments must be sized\")\n@@ -843,14 +875,17 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn get_personality_slot(&mut self, bx: &Builder<'a, 'll, 'tcx>) -> PlaceRef<'ll, 'tcx> {\n-        let cx = bx.cx;\n+    fn get_personality_slot(\n+        &mut self,\n+        bx: &mut Bx\n+    ) -> PlaceRef<'tcx, Bx::Value> {\n+        let cx = bx.cx();\n         if let Some(slot) = self.personality_slot {\n             slot\n         } else {\n-            let layout = cx.layout_of(cx.tcx.intern_tup(&[\n-                cx.tcx.mk_mut_ptr(cx.tcx.types.u8),\n-                cx.tcx.types.i32\n+            let layout = cx.layout_of(cx.tcx().intern_tup(&[\n+                cx.tcx().mk_mut_ptr(cx.tcx().types.u8),\n+                cx.tcx().types.i32\n             ]));\n             let slot = PlaceRef::alloca(bx, layout, \"personalityslot\");\n             self.personality_slot = Some(slot);\n@@ -861,7 +896,10 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     /// Return the landingpad wrapper around the given basic block\n     ///\n     /// No-op in MSVC SEH scheme.\n-    fn landing_pad_to(&mut self, target_bb: mir::BasicBlock) -> &'ll BasicBlock {\n+    fn landing_pad_to(\n+        &mut self,\n+        target_bb: mir::BasicBlock\n+    ) -> Bx::BasicBlock {\n         if let Some(block) = self.landing_pads[target_bb] {\n             return block;\n         }\n@@ -872,54 +910,65 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         landing_pad\n     }\n \n-    fn landing_pad_uncached(&mut self, target_bb: &'ll BasicBlock) -> &'ll BasicBlock {\n+    fn landing_pad_uncached(\n+        &mut self,\n+        target_bb: Bx::BasicBlock\n+    ) -> Bx::BasicBlock {\n         if base::wants_msvc_seh(self.cx.sess()) {\n             span_bug!(self.mir.span, \"landing pad was not inserted?\")\n         }\n \n-        let bx = self.new_block(\"cleanup\");\n+        let mut bx = self.new_block(\"cleanup\");\n \n         let llpersonality = self.cx.eh_personality();\n         let llretty = self.landing_pad_type();\n         let lp = bx.landing_pad(llretty, llpersonality, 1);\n         bx.set_cleanup(lp);\n \n-        let slot = self.get_personality_slot(&bx);\n-        slot.storage_live(&bx);\n-        Pair(bx.extract_value(lp, 0), bx.extract_value(lp, 1)).store(&bx, slot);\n+        let slot = self.get_personality_slot(&mut bx);\n+        slot.storage_live(&mut bx);\n+        Pair(bx.extract_value(lp, 0), bx.extract_value(lp, 1)).store(&mut bx, slot);\n \n         bx.br(target_bb);\n         bx.llbb()\n     }\n \n-    fn landing_pad_type(&self) -> &'ll Type {\n+    fn landing_pad_type(&self) -> Bx::Type {\n         let cx = self.cx;\n-        Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)], false)\n+        cx.type_struct(&[cx.type_i8p(), cx.type_i32()], false)\n     }\n \n-    fn unreachable_block(&mut self) -> &'ll BasicBlock {\n+    fn unreachable_block(\n+        &mut self\n+    ) -> Bx::BasicBlock {\n         self.unreachable_block.unwrap_or_else(|| {\n-            let bl = self.new_block(\"unreachable\");\n-            bl.unreachable();\n-            self.unreachable_block = Some(bl.llbb());\n-            bl.llbb()\n+            let mut bx = self.new_block(\"unreachable\");\n+            bx.unreachable();\n+            self.unreachable_block = Some(bx.llbb());\n+            bx.llbb()\n         })\n     }\n \n-    pub fn new_block(&self, name: &str) -> Builder<'a, 'll, 'tcx> {\n-        Builder::new_block(self.cx, self.llfn, name)\n+    pub fn new_block(&self, name: &str) -> Bx {\n+        Bx::new_block(self.cx, self.llfn, name)\n     }\n \n-    pub fn build_block(&self, bb: mir::BasicBlock) -> Builder<'a, 'll, 'tcx> {\n-        let bx = Builder::with_cx(self.cx);\n+    pub fn build_block(\n+        &self,\n+        bb: mir::BasicBlock\n+    ) -> Bx {\n+        let mut bx = Bx::with_cx(self.cx);\n         bx.position_at_end(self.blocks[bb]);\n         bx\n     }\n \n-    fn make_return_dest(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n-                        dest: &mir::Place<'tcx>, fn_ret: &ArgType<'tcx, Ty<'tcx>>,\n-                        llargs: &mut Vec<&'ll Value>, is_intrinsic: bool)\n-                        -> ReturnDest<'ll, 'tcx> {\n+    fn make_return_dest(\n+        &mut self,\n+        bx: &mut Bx,\n+        dest: &mir::Place<'tcx>,\n+        fn_ret: &ArgType<'tcx, Ty<'tcx>>,\n+        llargs: &mut Vec<Bx::Value>, is_intrinsic: bool\n+    ) -> ReturnDest<'tcx, Bx::Value> {\n         // If the return is ignored, we can just return a do-nothing ReturnDest\n         if fn_ret.is_ignore() {\n             return ReturnDest::Nothing;\n@@ -973,20 +1022,23 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn codegen_transmute(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n-                         src: &mir::Operand<'tcx>,\n-                         dst: &mir::Place<'tcx>) {\n+    fn codegen_transmute(\n+        &mut self,\n+        bx: &mut Bx,\n+        src: &mir::Operand<'tcx>,\n+        dst: &mir::Place<'tcx>\n+    ) {\n         if let mir::Place::Local(index) = *dst {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n                 LocalRef::UnsizedPlace(_) => bug!(\"transmute must not involve unsized locals\"),\n                 LocalRef::Operand(None) => {\n-                    let dst_layout = bx.cx.layout_of(self.monomorphized_place_ty(dst));\n+                    let dst_layout = bx.cx().layout_of(self.monomorphized_place_ty(dst));\n                     assert!(!dst_layout.ty.has_erasable_regions());\n                     let place = PlaceRef::alloca(bx, dst_layout, \"transmute_temp\");\n                     place.storage_live(bx);\n                     self.codegen_transmute_into(bx, src, place);\n-                    let op = place.load(bx);\n+                    let op = bx.load_operand(place);\n                     place.storage_dead(bx);\n                     self.locals[index] = LocalRef::Operand(Some(op));\n                 }\n@@ -1001,30 +1053,35 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn codegen_transmute_into(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n-                              src: &mir::Operand<'tcx>,\n-                              dst: PlaceRef<'ll, 'tcx>) {\n+    fn codegen_transmute_into(\n+        &mut self,\n+        bx: &mut Bx,\n+        src: &mir::Operand<'tcx>,\n+        dst: PlaceRef<'tcx, Bx::Value>\n+    ) {\n         let src = self.codegen_operand(bx, src);\n-        let llty = src.layout.llvm_type(bx.cx);\n-        let cast_ptr = bx.pointercast(dst.llval, llty.ptr_to());\n+        let llty = bx.cx().backend_type(src.layout);\n+        let cast_ptr = bx.pointercast(dst.llval, bx.cx().type_ptr_to(llty));\n         let align = src.layout.align.min(dst.layout.align);\n         src.val.store(bx, PlaceRef::new_sized(cast_ptr, src.layout, align));\n     }\n \n \n     // Stores the return value of a function call into it's final location.\n-    fn store_return(&mut self,\n-                    bx: &Builder<'a, 'll, 'tcx>,\n-                    dest: ReturnDest<'ll, 'tcx>,\n-                    ret_ty: &ArgType<'tcx, Ty<'tcx>>,\n-                    llval: &'ll Value) {\n+    fn store_return(\n+        &mut self,\n+        bx: &mut Bx,\n+        dest: ReturnDest<'tcx, Bx::Value>,\n+        ret_ty: &ArgType<'tcx, Ty<'tcx>>,\n+        llval: Bx::Value\n+    ) {\n         use self::ReturnDest::*;\n \n         match dest {\n             Nothing => (),\n-            Store(dst) => ret_ty.store(bx, llval, dst),\n+            Store(dst) => bx.store_arg_ty(&ret_ty, llval, dst),\n             IndirectOperand(tmp, index) => {\n-                let op = tmp.load(bx);\n+                let op = bx.load_operand(tmp);\n                 tmp.storage_dead(bx);\n                 self.locals[index] = LocalRef::Operand(Some(op));\n             }\n@@ -1033,8 +1090,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 let op = if let PassMode::Cast(_) = ret_ty.mode {\n                     let tmp = PlaceRef::alloca(bx, ret_ty.layout, \"tmp_ret\");\n                     tmp.storage_live(bx);\n-                    ret_ty.store(bx, llval, tmp);\n-                    let op = tmp.load(bx);\n+                    bx.store_arg_ty(&ret_ty, llval, tmp);\n+                    let op = bx.load_operand(tmp);\n                     tmp.storage_dead(bx);\n                     op\n                 } else {\n@@ -1046,13 +1103,13 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n }\n \n-enum ReturnDest<'ll, 'tcx> {\n+enum ReturnDest<'tcx, V> {\n     // Do nothing, the return value is indirect or ignored\n     Nothing,\n     // Store the return value to the pointer\n-    Store(PlaceRef<'ll, 'tcx>),\n+    Store(PlaceRef<'tcx, V>),\n     // Stores an indirect return value to an operand local place\n-    IndirectOperand(PlaceRef<'ll, 'tcx>, mir::Local),\n+    IndirectOperand(PlaceRef<'tcx, V>, mir::Local),\n     // Stores a direct return value to an operand local place\n     DirectOperand(mir::Local)\n }", "previous_filename": "src/librustc_codegen_llvm/mir/block.rs"}, {"sha": "568e1f0b38ab1c0fa0433b99eaa059d601dc76b9", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::mir::interpret::ErrorHandled;\n+use rustc_mir::const_eval::const_field;\n+use rustc::mir;\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc::mir::interpret::{GlobalId, ConstValue};\n+use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{self, LayoutOf};\n+use syntax::source_map::Span;\n+use traits::*;\n+\n+use super::FunctionCx;\n+\n+impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    fn fully_evaluate(\n+        &mut self,\n+        bx: &Bx,\n+        constant: &'tcx ty::Const<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, ErrorHandled> {\n+        match constant.val {\n+            ConstValue::Unevaluated(def_id, ref substs) => {\n+                let tcx = bx.tcx();\n+                let param_env = ty::ParamEnv::reveal_all();\n+                let instance = ty::Instance::resolve(tcx, param_env, def_id, substs).unwrap();\n+                let cid = GlobalId {\n+                    instance,\n+                    promoted: None,\n+                };\n+                tcx.const_eval(param_env.and(cid))\n+            },\n+            _ => Ok(constant),\n+        }\n+    }\n+\n+    pub fn eval_mir_constant(\n+        &mut self,\n+        bx: &Bx,\n+        constant: &mir::Constant<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, ErrorHandled> {\n+        let c = self.monomorphize(&constant.literal);\n+        self.fully_evaluate(bx, c)\n+    }\n+\n+    /// process constant containing SIMD shuffle indices\n+    pub fn simd_shuffle_indices(\n+        &mut self,\n+        bx: &Bx,\n+        span: Span,\n+        ty: Ty<'tcx>,\n+        constant: Result<&'tcx ty::Const<'tcx>, ErrorHandled>,\n+    ) -> (Bx::Value, Ty<'tcx>) {\n+        constant\n+            .and_then(|c| {\n+                let field_ty = c.ty.builtin_index().unwrap();\n+                let fields = match c.ty.sty {\n+                    ty::Array(_, n) => n.unwrap_usize(bx.tcx()),\n+                    ref other => bug!(\"invalid simd shuffle type: {}\", other),\n+                };\n+                let values: Result<Vec<_>, ErrorHandled> = (0..fields).map(|field| {\n+                    let field = const_field(\n+                        bx.tcx(),\n+                        ty::ParamEnv::reveal_all(),\n+                        self.instance,\n+                        None,\n+                        mir::Field::new(field as usize),\n+                        c,\n+                    )?;\n+                    if let Some(prim) = field.val.try_to_scalar() {\n+                        let layout = bx.cx().layout_of(field_ty);\n+                        let scalar = match layout.abi {\n+                            layout::Abi::Scalar(ref x) => x,\n+                            _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n+                        };\n+                        Ok(bx.cx().scalar_to_backend(\n+                            prim, scalar,\n+                            bx.cx().immediate_backend_type(layout),\n+                        ))\n+                    } else {\n+                        bug!(\"simd shuffle field {:?}\", field)\n+                    }\n+                }).collect();\n+                let llval = bx.cx().const_struct(&values?, false);\n+                Ok((llval, c.ty))\n+            })\n+            .unwrap_or_else(|_| {\n+                bx.tcx().sess.span_err(\n+                    span,\n+                    \"could not evaluate shuffle_indices at compile time\",\n+                );\n+                // We've errored, so we don't have to produce working code.\n+                let ty = self.monomorphize(&ty);\n+                let llty = bx.cx().backend_type(bx.cx().layout_of(ty));\n+                (bx.cx().const_undef(llty), ty)\n+            })\n+    }\n+}"}, {"sha": "0579afe1d49c931459e1e929093d78f95b6239a0", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "renamed", "additions": 113, "deletions": 114, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -8,24 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use common::{C_i32, C_null};\n use libc::c_uint;\n-use llvm::{self, BasicBlock};\n-use llvm::debuginfo::DIScope;\n-use llvm_util;\n use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts};\n-use rustc::ty::layout::{LayoutOf, TyLayout};\n+use rustc::ty::layout::{LayoutOf, TyLayout, HasTyCtxt};\n use rustc::mir::{self, Mir};\n use rustc::ty::subst::Substs;\n use rustc::session::config::DebugInfo;\n use base;\n-use builder::Builder;\n-use common::{CodegenCx, Funclet};\n-use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n-use monomorphize::Instance;\n-use abi::{ArgTypeExt, FnType, FnTypeExt, PassMode};\n-use type_::Type;\n-use value::Value;\n+use debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext};\n+use rustc_mir::monomorphize::Instance;\n+use rustc_target::abi::call::{FnType, PassMode};\n+use traits::*;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;\n@@ -35,25 +28,23 @@ use std::iter;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n \n-pub use self::constant::codegen_static_initializer;\n-\n use self::analyze::CleanupKind;\n use self::place::PlaceRef;\n use rustc::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n \n /// Master context for codegenning from MIR.\n-pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll> {\n+pub struct FunctionCx<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> {\n     instance: Instance<'tcx>,\n \n     mir: &'a mir::Mir<'tcx>,\n \n-    debug_context: FunctionDebugContext<'ll>,\n+    debug_context: FunctionDebugContext<Bx::DIScope>,\n \n-    llfn: &'ll Value,\n+    llfn: Bx::Value,\n \n-    cx: &'a CodegenCx<'ll, 'tcx>,\n+    cx: &'a Bx::CodegenCx,\n \n     fn_ty: FnType<'tcx, Ty<'tcx>>,\n \n@@ -64,24 +55,24 @@ pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll> {\n     /// don't really care about it very much. Anyway, this value\n     /// contains an alloca into which the personality is stored and\n     /// then later loaded when generating the DIVERGE_BLOCK.\n-    personality_slot: Option<PlaceRef<'ll, 'tcx>>,\n+    personality_slot: Option<PlaceRef<'tcx, Bx::Value,>>,\n \n     /// A `Block` for each MIR `BasicBlock`\n-    blocks: IndexVec<mir::BasicBlock, &'ll BasicBlock>,\n+    blocks: IndexVec<mir::BasicBlock, Bx::BasicBlock>,\n \n     /// The funclet status of each basic block\n     cleanup_kinds: IndexVec<mir::BasicBlock, analyze::CleanupKind>,\n \n     /// When targeting MSVC, this stores the cleanup info for each funclet\n     /// BB. This is initialized as we compute the funclets' head block in RPO.\n-    funclets: &'a IndexVec<mir::BasicBlock, Option<Funclet<'ll>>>,\n+    funclets: IndexVec<mir::BasicBlock, Option<Bx::Funclet>>,\n \n     /// This stores the landing-pad block for a given BB, computed lazily on GNU\n     /// and eagerly on MSVC.\n-    landing_pads: IndexVec<mir::BasicBlock, Option<&'ll BasicBlock>>,\n+    landing_pads: IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n \n     /// Cached unreachable block\n-    unreachable_block: Option<&'ll BasicBlock>,\n+    unreachable_block: Option<Bx::BasicBlock>,\n \n     /// The location where each MIR arg/var/tmp/ret is stored. This is\n     /// usually an `PlaceRef` representing an alloca, but not always:\n@@ -98,32 +89,36 @@ pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll> {\n     ///\n     /// Avoiding allocs can also be important for certain intrinsics,\n     /// notably `expect`.\n-    locals: IndexVec<mir::Local, LocalRef<'ll, 'tcx>>,\n+    locals: IndexVec<mir::Local, LocalRef<'tcx, Bx::Value>>,\n \n     /// Debug information for MIR scopes.\n-    scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope<'ll>>,\n+    scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope<Bx::DIScope>>,\n \n     /// If this function is being monomorphized, this contains the type substitutions used.\n     param_substs: &'tcx Substs<'tcx>,\n }\n \n-impl FunctionCx<'a, 'll, 'tcx> {\n+impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {\n-        self.cx.tcx.subst_and_normalize_erasing_regions(\n+        self.cx.tcx().subst_and_normalize_erasing_regions(\n             self.param_substs,\n             ty::ParamEnv::reveal_all(),\n             value,\n         )\n     }\n \n-    pub fn set_debug_loc(&mut self, bx: &Builder<'_, 'll, '_>, source_info: mir::SourceInfo) {\n+    pub fn set_debug_loc(\n+        &mut self,\n+        bx: &mut Bx,\n+        source_info: mir::SourceInfo\n+    ) {\n         let (scope, span) = self.debug_loc(source_info);\n-        debuginfo::set_source_location(&self.debug_context, bx, scope, span);\n+        bx.set_source_location(&self.debug_context, scope, span);\n     }\n \n-    pub fn debug_loc(&mut self, source_info: mir::SourceInfo) -> (Option<&'ll DIScope>, Span) {\n+    pub fn debug_loc(&self, source_info: mir::SourceInfo) -> (Option<Bx::DIScope>, Span) {\n         // Bail out if debug info emission is not enabled.\n         match self.debug_context {\n             FunctionDebugContext::DebugInfoDisabled |\n@@ -163,34 +158,38 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     // corresponding to span's containing source scope.  If so, we need to create a DIScope\n     // \"extension\" into that file.\n     fn scope_metadata_for_loc(&self, scope_id: mir::SourceScope, pos: BytePos)\n-                              -> Option<&'ll DIScope> {\n+                              -> Option<Bx::DIScope> {\n         let scope_metadata = self.scopes[scope_id].scope_metadata;\n         if pos < self.scopes[scope_id].file_start_pos ||\n            pos >= self.scopes[scope_id].file_end_pos {\n-            let cm = self.cx.sess().source_map();\n+            let sm = self.cx.sess().source_map();\n             let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n-            Some(debuginfo::extend_scope_to_file(self.cx,\n-                                                 scope_metadata.unwrap(),\n-                                                 &cm.lookup_char_pos(pos).file,\n-                                                 defining_crate))\n+            Some(self.cx.extend_scope_to_file(\n+                scope_metadata.unwrap(),\n+                &sm.lookup_char_pos(pos).file,\n+                defining_crate\n+            ))\n         } else {\n             scope_metadata\n         }\n     }\n }\n \n-enum LocalRef<'ll, 'tcx> {\n-    Place(PlaceRef<'ll, 'tcx>),\n+enum LocalRef<'tcx, V> {\n+    Place(PlaceRef<'tcx, V>),\n     /// `UnsizedPlace(p)`: `p` itself is a thin pointer (indirect place).\n     /// `*p` is the fat pointer that references the actual unsized place.\n     /// Every time it is initialized, we have to reallocate the place\n     /// and update the fat pointer. That's the reason why it is indirect.\n-    UnsizedPlace(PlaceRef<'ll, 'tcx>),\n-    Operand(Option<OperandRef<'ll, 'tcx>>),\n+    UnsizedPlace(PlaceRef<'tcx, V>),\n+    Operand(Option<OperandRef<'tcx, V>>),\n }\n \n-impl LocalRef<'ll, 'tcx> {\n-    fn new_operand(cx: &CodegenCx<'ll, 'tcx>, layout: TyLayout<'tcx>) -> LocalRef<'ll, 'tcx> {\n+impl<'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n+    fn new_operand<Cx: CodegenMethods<'tcx, Value = V>>(\n+        cx: &Cx,\n+        layout: TyLayout<'tcx>,\n+    ) -> LocalRef<'tcx, V> {\n         if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n@@ -204,18 +203,18 @@ impl LocalRef<'ll, 'tcx> {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn codegen_mir(\n-    cx: &'a CodegenCx<'ll, 'tcx>,\n-    llfn: &'ll Value,\n+pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    cx: &'a Bx::CodegenCx,\n+    llfn: Bx::Value,\n     mir: &'a Mir<'tcx>,\n     instance: Instance<'tcx>,\n     sig: ty::FnSig<'tcx>,\n ) {\n-    let fn_ty = FnType::new(cx, sig, &[]);\n+    let fn_ty = cx.new_fn_type(sig, &[]);\n     debug!(\"fn_ty: {:?}\", fn_ty);\n     let debug_context =\n-        debuginfo::create_function_debug_context(cx, instance, sig, llfn, mir);\n-    let bx = Builder::new_block(cx, llfn, \"start\");\n+        cx.create_function_debug_context(instance, sig, llfn, mir);\n+    let mut bx = Bx::new_block(cx, llfn, \"start\");\n \n     if mir.basic_blocks().iter().any(|bb| bb.is_cleanup) {\n         bx.set_personality_fn(cx.eh_personality());\n@@ -225,7 +224,7 @@ pub fn codegen_mir(\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it.\n     let reentrant_start_block = !mir.predecessors_for(mir::START_BLOCK).is_empty();\n-    let block_bxs: IndexVec<mir::BasicBlock, &'ll BasicBlock> =\n+    let block_bxs: IndexVec<mir::BasicBlock, Bx::BasicBlock> =\n         mir.basic_blocks().indices().map(|bb| {\n             if bb == mir::START_BLOCK && !reentrant_start_block {\n                 bx.llbb()\n@@ -235,8 +234,8 @@ pub fn codegen_mir(\n         }).collect();\n \n     // Compute debuginfo scopes from MIR scopes.\n-    let scopes = debuginfo::create_mir_scopes(cx, mir, &debug_context);\n-    let (landing_pads, funclets) = create_funclets(mir, &bx, &cleanup_kinds, &block_bxs);\n+    let scopes = cx.create_mir_scopes(mir, &debug_context);\n+    let (landing_pads, funclets) = create_funclets(mir, &mut bx, &cleanup_kinds, &block_bxs);\n \n     let mut fx = FunctionCx {\n         instance,\n@@ -249,7 +248,7 @@ pub fn codegen_mir(\n         unreachable_block: None,\n         cleanup_kinds,\n         landing_pads,\n-        funclets: &funclets,\n+        funclets,\n         scopes,\n         locals: IndexVec::new(),\n         debug_context,\n@@ -263,37 +262,38 @@ pub fn codegen_mir(\n \n     // Allocate variable and temp allocas\n     fx.locals = {\n-        let args = arg_local_refs(&bx, &fx, &fx.scopes, &memory_locals);\n+        let args = arg_local_refs(&mut bx, &fx, &fx.scopes, &memory_locals);\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n-            let layout = bx.cx.layout_of(fx.monomorphize(&decl.ty));\n+            let layout = bx.cx().layout_of(fx.monomorphize(&decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n             if let Some(name) = decl.name {\n                 // User variable\n                 let debug_scope = fx.scopes[decl.visibility_scope];\n-                let dbg = debug_scope.is_valid() && bx.sess().opts.debuginfo == DebugInfo::Full;\n+                let dbg = debug_scope.is_valid() &&\n+                    bx.cx().sess().opts.debuginfo == DebugInfo::Full;\n \n                 if !memory_locals.contains(local) && !dbg {\n                     debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n-                    return LocalRef::new_operand(bx.cx, layout);\n+                    return LocalRef::new_operand(bx.cx(), layout);\n                 }\n \n                 debug!(\"alloc: {:?} ({}) -> place\", local, name);\n                 if layout.is_unsized() {\n                     let indirect_place =\n-                        PlaceRef::alloca_unsized_indirect(&bx, layout, &name.as_str());\n+                        PlaceRef::alloca_unsized_indirect(&mut bx, layout, &name.as_str());\n                     // FIXME: add an appropriate debuginfo\n                     LocalRef::UnsizedPlace(indirect_place)\n                 } else {\n-                    let place = PlaceRef::alloca(&bx, layout, &name.as_str());\n+                    let place = PlaceRef::alloca(&mut bx, layout, &name.as_str());\n                     if dbg {\n                         let (scope, span) = fx.debug_loc(mir::SourceInfo {\n                             span: decl.source_info.span,\n                             scope: decl.visibility_scope,\n                         });\n-                        declare_local(&bx, &fx.debug_context, name, layout.ty, scope.unwrap(),\n+                        bx.declare_local(&fx.debug_context, name, layout.ty, scope.unwrap(),\n                             VariableAccess::DirectVariable { alloca: place.llval },\n                             VariableKind::LocalVariable, span);\n                     }\n@@ -303,23 +303,26 @@ pub fn codegen_mir(\n                 // Temporary or return place\n                 if local == mir::RETURN_PLACE && fx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return place) -> place\", local);\n-                    let llretptr = llvm::get_param(llfn, 0);\n+                    let llretptr = fx.cx.get_param(llfn, 0);\n                     LocalRef::Place(PlaceRef::new_sized(llretptr, layout, layout.align))\n                 } else if memory_locals.contains(local) {\n                     debug!(\"alloc: {:?} -> place\", local);\n                     if layout.is_unsized() {\n-                        let indirect_place =\n-                            PlaceRef::alloca_unsized_indirect(&bx, layout, &format!(\"{:?}\", local));\n+                        let indirect_place = PlaceRef::alloca_unsized_indirect(\n+                            &mut bx,\n+                            layout,\n+                            &format!(\"{:?}\", local),\n+                        );\n                         LocalRef::UnsizedPlace(indirect_place)\n                     } else {\n-                        LocalRef::Place(PlaceRef::alloca(&bx, layout, &format!(\"{:?}\", local)))\n+                        LocalRef::Place(PlaceRef::alloca(&mut bx, layout, &format!(\"{:?}\", local)))\n                     }\n                 } else {\n                     // If this is an immediate local, we do not create an\n                     // alloca in advance. Instead we wait until we see the\n                     // definition and update the operand there.\n                     debug!(\"alloc: {:?} -> operand\", local);\n-                    LocalRef::new_operand(bx.cx, layout)\n+                    LocalRef::new_operand(bx.cx(), layout)\n                 }\n             }\n         };\n@@ -357,27 +360,27 @@ pub fn codegen_mir(\n         if !visited.contains(bb.index()) {\n             debug!(\"codegen_mir: block {:?} was not visited\", bb);\n             unsafe {\n-                llvm::LLVMDeleteBasicBlock(fx.blocks[bb]);\n+                bx.delete_basic_block(fx.blocks[bb]);\n             }\n         }\n     }\n }\n \n-fn create_funclets(\n+fn create_funclets<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     mir: &'a Mir<'tcx>,\n-    bx: &Builder<'a, 'll, 'tcx>,\n+    bx: &mut Bx,\n     cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n-    block_bxs: &IndexVec<mir::BasicBlock, &'ll BasicBlock>)\n-    -> (IndexVec<mir::BasicBlock, Option<&'ll BasicBlock>>,\n-        IndexVec<mir::BasicBlock, Option<Funclet<'ll>>>)\n+    block_bxs: &IndexVec<mir::BasicBlock, Bx::BasicBlock>)\n+    -> (IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n+        IndexVec<mir::BasicBlock, Option<Bx::Funclet>>)\n {\n     block_bxs.iter_enumerated().zip(cleanup_kinds).map(|((bb, &llbb), cleanup_kind)| {\n         match *cleanup_kind {\n-            CleanupKind::Funclet if base::wants_msvc_seh(bx.sess()) => {}\n+            CleanupKind::Funclet if base::wants_msvc_seh(bx.cx().sess()) => {}\n             _ => return (None, None)\n         }\n \n-        let cleanup;\n+        let funclet;\n         let ret_llbb;\n         match mir[bb].terminator.as_ref().map(|t| &t.kind) {\n             // This is a basic block that we're aborting the program for,\n@@ -401,8 +404,8 @@ fn create_funclets(\n             //          bar();\n             //      }\n             Some(&mir::TerminatorKind::Abort) => {\n-                let cs_bx = bx.build_sibling_block(&format!(\"cs_funclet{:?}\", bb));\n-                let cp_bx = bx.build_sibling_block(&format!(\"cp_funclet{:?}\", bb));\n+                let mut cs_bx = bx.build_sibling_block(&format!(\"cs_funclet{:?}\", bb));\n+                let mut cp_bx = bx.build_sibling_block(&format!(\"cp_funclet{:?}\", bb));\n                 ret_llbb = cs_bx.llbb();\n \n                 let cs = cs_bx.catch_switch(None, None, 1);\n@@ -412,40 +415,43 @@ fn create_funclets(\n                 // C++ personality function, but `catch (...)` has no type so\n                 // it's null. The 64 here is actually a bitfield which\n                 // represents that this is a catch-all block.\n-                let null = C_null(Type::i8p(bx.cx));\n-                let sixty_four = C_i32(bx.cx, 64);\n-                cleanup = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n+                let null = bx.cx().const_null(bx.cx().type_i8p());\n+                let sixty_four = bx.cx().const_i32(64);\n+                funclet = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n                 cp_bx.br(llbb);\n             }\n             _ => {\n-                let cleanup_bx = bx.build_sibling_block(&format!(\"funclet_{:?}\", bb));\n+                let mut cleanup_bx = bx.build_sibling_block(&format!(\"funclet_{:?}\", bb));\n                 ret_llbb = cleanup_bx.llbb();\n-                cleanup = cleanup_bx.cleanup_pad(None, &[]);\n+                funclet = cleanup_bx.cleanup_pad(None, &[]);\n                 cleanup_bx.br(llbb);\n             }\n         };\n \n-        (Some(ret_llbb), Some(Funclet::new(cleanup)))\n+        (Some(ret_llbb), Some(funclet))\n     }).unzip()\n }\n \n /// Produce, for each argument, a `Value` pointing at the\n /// argument's value. As arguments are places, these are always\n /// indirect.\n-fn arg_local_refs(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    fx: &FunctionCx<'a, 'll, 'tcx>,\n-    scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope<'ll>>,\n+fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    fx: &FunctionCx<'a, 'tcx, Bx>,\n+    scopes: &IndexVec<\n+        mir::SourceScope,\n+        debuginfo::MirDebugScope<Bx::DIScope>\n+    >,\n     memory_locals: &BitSet<mir::Local>,\n-) -> Vec<LocalRef<'ll, 'tcx>> {\n+) -> Vec<LocalRef<'tcx, Bx::Value>> {\n     let mir = fx.mir;\n-    let tcx = bx.tcx();\n+    let tcx = fx.cx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = fx.fn_ty.ret.is_indirect() as usize;\n \n     // Get the argument scope, if it exists and if we need it.\n     let arg_scope = scopes[mir::OUTERMOST_SOURCE_SCOPE];\n-    let arg_scope = if bx.sess().opts.debuginfo == DebugInfo::Full {\n+    let arg_scope = if bx.cx().sess().opts.debuginfo == DebugInfo::Full {\n         arg_scope.scope_metadata\n     } else {\n         None\n@@ -472,14 +478,15 @@ fn arg_local_refs(\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let place = PlaceRef::alloca(bx, bx.cx.layout_of(arg_ty), &name);\n+            let place = PlaceRef::alloca(bx, bx.cx().layout_of(arg_ty), &name);\n             for i in 0..tupled_arg_tys.len() {\n                 let arg = &fx.fn_ty.args[idx];\n                 idx += 1;\n                 if arg.pad.is_some() {\n                     llarg_idx += 1;\n                 }\n-                arg.store_fn_arg(bx, &mut llarg_idx, place.project_field(bx, i));\n+                let pr_field = place.project_field(bx, i);\n+                bx.store_fn_arg(arg, &mut llarg_idx, pr_field);\n             }\n \n             // Now that we have one alloca that contains the aggregate value,\n@@ -488,8 +495,7 @@ fn arg_local_refs(\n                 let variable_access = VariableAccess::DirectVariable {\n                     alloca: place.llval\n                 };\n-                declare_local(\n-                    bx,\n+                bx.declare_local(\n                     &fx.debug_context,\n                     arg_decl.name.unwrap_or(keywords::Invalid.name()),\n                     arg_ty, scope,\n@@ -515,21 +521,21 @@ fn arg_local_refs(\n             let local = |op| LocalRef::Operand(Some(op));\n             match arg.mode {\n                 PassMode::Ignore => {\n-                    return local(OperandRef::new_zst(bx.cx, arg.layout));\n+                    return local(OperandRef::new_zst(bx.cx(), arg.layout));\n                 }\n                 PassMode::Direct(_) => {\n-                    let llarg = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+                    let llarg = bx.cx().get_param(bx.llfn(), llarg_idx as c_uint);\n                     bx.set_value_name(llarg, &name);\n                     llarg_idx += 1;\n                     return local(\n                         OperandRef::from_immediate_or_packed_pair(bx, llarg, arg.layout));\n                 }\n                 PassMode::Pair(..) => {\n-                    let a = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+                    let a = bx.cx().get_param(bx.llfn(), llarg_idx as c_uint);\n                     bx.set_value_name(a, &(name.clone() + \".0\"));\n                     llarg_idx += 1;\n \n-                    let b = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+                    let b = bx.cx().get_param(bx.llfn(), llarg_idx as c_uint);\n                     bx.set_value_name(b, &(name + \".1\"));\n                     llarg_idx += 1;\n \n@@ -546,25 +552,25 @@ fn arg_local_refs(\n             // Don't copy an indirect argument to an alloca, the caller\n             // already put it in a temporary alloca and gave it up.\n             // FIXME: lifetimes\n-            let llarg = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+            let llarg = bx.cx().get_param(bx.llfn(), llarg_idx as c_uint);\n             bx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n             PlaceRef::new_sized(llarg, arg.layout, arg.layout.align)\n         } else if arg.is_unsized_indirect() {\n             // As the storage for the indirect argument lives during\n             // the whole function call, we just copy the fat pointer.\n-            let llarg = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+            let llarg = bx.cx().get_param(bx.llfn(), llarg_idx as c_uint);\n             llarg_idx += 1;\n-            let llextra = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+            let llextra = bx.cx().get_param(bx.llfn(), llarg_idx as c_uint);\n             llarg_idx += 1;\n             let indirect_operand = OperandValue::Pair(llarg, llextra);\n \n             let tmp = PlaceRef::alloca_unsized_indirect(bx, arg.layout, &name);\n-            indirect_operand.store(&bx, tmp);\n+            indirect_operand.store(bx, tmp);\n             tmp\n         } else {\n             let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n-            arg.store_fn_arg(bx, &mut llarg_idx, tmp);\n+            bx.store_fn_arg(arg, &mut llarg_idx, tmp);\n             tmp\n         };\n         arg_scope.map(|scope| {\n@@ -578,8 +584,7 @@ fn arg_local_refs(\n                     alloca: place.llval\n                 };\n \n-                declare_local(\n-                    bx,\n+                bx.declare_local(\n                     &fx.debug_context,\n                     arg_decl.name.unwrap_or(keywords::Invalid.name()),\n                     arg.layout.ty,\n@@ -594,7 +599,7 @@ fn arg_local_refs(\n             // Or is it the closure environment?\n             let (closure_layout, env_ref) = match arg.layout.ty.sty {\n                 ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n-                ty::Ref(_, ty, _)  => (bx.cx.layout_of(ty), true),\n+                ty::Ref(_, ty, _)  => (bx.cx().layout_of(ty), true),\n                 _ => (arg.layout, false)\n             };\n \n@@ -613,10 +618,10 @@ fn arg_local_refs(\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             // (cuviper) It seems to be fine without the alloca on LLVM 6 and later.\n-            let env_alloca = !env_ref && llvm_util::get_major_version() < 6;\n+            let env_alloca = !env_ref && bx.cx().closure_env_needs_indirect_debuginfo();\n             let env_ptr = if env_alloca {\n                 let scratch = PlaceRef::alloca(bx,\n-                    bx.cx.layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n+                    bx.cx().layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n                     \"__debuginfo_env_ptr\");\n                 bx.store(place.llval, scratch.llval, scratch.align);\n                 scratch.llval\n@@ -627,12 +632,7 @@ fn arg_local_refs(\n             for (i, (decl, ty)) in mir.upvar_decls.iter().zip(upvar_tys).enumerate() {\n                 let byte_offset_of_var_in_env = closure_layout.fields.offset(i).bytes();\n \n-                let ops = unsafe {\n-                    [llvm::LLVMRustDIBuilderCreateOpDeref(),\n-                     llvm::LLVMRustDIBuilderCreateOpPlusUconst(),\n-                     byte_offset_of_var_in_env as i64,\n-                     llvm::LLVMRustDIBuilderCreateOpDeref()]\n-                };\n+                let ops = bx.cx().debuginfo_upvar_decls_ops_sequence(byte_offset_of_var_in_env);\n \n                 // The environment and the capture can each be indirect.\n \n@@ -651,8 +651,7 @@ fn arg_local_refs(\n                     alloca: env_ptr,\n                     address_operations: &ops\n                 };\n-                declare_local(\n-                    bx,\n+                bx.declare_local(\n                     &fx.debug_context,\n                     decl.debug_name,\n                     ty,\n@@ -673,7 +672,7 @@ fn arg_local_refs(\n \n mod analyze;\n mod block;\n-mod constant;\n+pub mod constant;\n pub mod place;\n pub mod operand;\n mod rvalue;", "previous_filename": "src/librustc_codegen_llvm/mir/mod.rs"}, {"sha": "d574d89d67e3216815f97384973bd589096feb5c", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "renamed", "additions": 128, "deletions": 97, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "patch": "@@ -14,33 +14,30 @@ use rustc::ty;\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n \n use base;\n-use common::{CodegenCx, C_undef, C_usize};\n-use builder::{Builder, MemFlags};\n-use value::Value;\n-use type_of::LayoutLlvmExt;\n-use type_::Type;\n+use MemFlags;\n use glue;\n \n+use traits::*;\n+\n use std::fmt;\n \n use super::{FunctionCx, LocalRef};\n-use super::constant::scalar_to_llvm;\n use super::place::PlaceRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n /// safety check.\n #[derive(Copy, Clone, Debug)]\n-pub enum OperandValue<'ll> {\n+pub enum OperandValue<V> {\n     /// A reference to the actual operand. The data is guaranteed\n     /// to be valid for the operand's lifetime.\n     /// The second value, if any, is the extra data (vtable or length)\n     /// which indicates that it refers to an unsized rvalue.\n-    Ref(&'ll Value, Option<&'ll Value>, Align),\n+    Ref(V, Option<V>, Align),\n     /// A single LLVM value.\n-    Immediate(&'ll Value),\n+    Immediate(V),\n     /// A pair of immediate LLVM values. Used by fat pointers too.\n-    Pair(&'ll Value, &'ll Value)\n+    Pair(V, V)\n }\n \n /// An `OperandRef` is an \"SSA\" reference to a Rust value, along with\n@@ -52,37 +49,40 @@ pub enum OperandValue<'ll> {\n /// directly is sure to cause problems -- use `OperandRef::store`\n /// instead.\n #[derive(Copy, Clone)]\n-pub struct OperandRef<'ll, 'tcx> {\n+pub struct OperandRef<'tcx, V> {\n     // The value.\n-    pub val: OperandValue<'ll>,\n+    pub val: OperandValue<V>,\n \n     // The layout of value, based on its Rust type.\n     pub layout: TyLayout<'tcx>,\n }\n \n-impl fmt::Debug for OperandRef<'ll, 'tcx> {\n+impl<V: CodegenObject> fmt::Debug for OperandRef<'tcx, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"OperandRef({:?} @ {:?})\", self.val, self.layout)\n     }\n }\n \n-impl OperandRef<'ll, 'tcx> {\n-    pub fn new_zst(cx: &CodegenCx<'ll, 'tcx>,\n-                   layout: TyLayout<'tcx>) -> OperandRef<'ll, 'tcx> {\n+impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n+    pub fn new_zst<Cx: CodegenMethods<'tcx, Value = V>>(\n+        cx: &Cx,\n+        layout: TyLayout<'tcx>\n+    ) -> OperandRef<'tcx, V> {\n         assert!(layout.is_zst());\n         OperandRef {\n-            val: OperandValue::Immediate(C_undef(layout.immediate_llvm_type(cx))),\n+            val: OperandValue::Immediate(cx.const_undef(cx.immediate_backend_type(layout))),\n             layout\n         }\n     }\n \n-    pub fn from_const(bx: &Builder<'a, 'll, 'tcx>,\n-                      val: &'tcx ty::Const<'tcx>)\n-                      -> Result<OperandRef<'ll, 'tcx>, ErrorHandled> {\n-        let layout = bx.cx.layout_of(val.ty);\n+    pub fn from_const<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        bx: &mut Bx,\n+        val: &'tcx ty::Const<'tcx>\n+    ) -> Result<Self, ErrorHandled> {\n+        let layout = bx.cx().layout_of(val.ty);\n \n         if layout.is_zst() {\n-            return Ok(OperandRef::new_zst(bx.cx, layout));\n+            return Ok(OperandRef::new_zst(bx.cx(), layout));\n         }\n \n         let val = match val.val {\n@@ -92,11 +92,10 @@ impl OperandRef<'ll, 'tcx> {\n                     layout::Abi::Scalar(ref x) => x,\n                     _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n                 };\n-                let llval = scalar_to_llvm(\n-                    bx.cx,\n+                let llval = bx.cx().scalar_to_backend(\n                     x,\n                     scalar,\n-                    layout.immediate_llvm_type(bx.cx),\n+                    bx.cx().immediate_backend_type(layout),\n                 );\n                 OperandValue::Immediate(llval)\n             },\n@@ -105,23 +104,20 @@ impl OperandRef<'ll, 'tcx> {\n                     layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n                     _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout)\n                 };\n-                let a_llval = scalar_to_llvm(\n-                    bx.cx,\n+                let a_llval = bx.cx().scalar_to_backend(\n                     a,\n                     a_scalar,\n-                    layout.scalar_pair_element_llvm_type(bx.cx, 0, true),\n+                    bx.cx().scalar_pair_element_backend_type(layout, 0, true),\n                 );\n-                let b_layout = layout.scalar_pair_element_llvm_type(bx.cx, 1, true);\n-                let b_llval = scalar_to_llvm(\n-                    bx.cx,\n+                let b_llval = bx.cx().scalar_to_backend(\n                     b,\n                     b_scalar,\n-                    b_layout,\n+                    bx.cx().scalar_pair_element_backend_type(layout, 1, true),\n                 );\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n             ConstValue::ByRef(_, alloc, offset) => {\n-                return Ok(PlaceRef::from_const_alloc(bx, layout, alloc, offset).load(bx));\n+                return Ok(bx.load_operand(bx.cx().from_const_alloc(layout, alloc, offset)));\n             },\n         };\n \n@@ -133,14 +129,17 @@ impl OperandRef<'ll, 'tcx> {\n \n     /// Asserts that this operand refers to a scalar and returns\n     /// a reference to its value.\n-    pub fn immediate(self) -> &'ll Value {\n+    pub fn immediate(self) -> V {\n         match self.val {\n             OperandValue::Immediate(s) => s,\n             _ => bug!(\"not immediate: {:?}\", self)\n         }\n     }\n \n-    pub fn deref(self, cx: &CodegenCx<'ll, 'tcx>) -> PlaceRef<'ll, 'tcx> {\n+    pub fn deref<Cx: CodegenMethods<'tcx, Value = V>>(\n+        self,\n+        cx: &Cx\n+    ) -> PlaceRef<'tcx, V> {\n         let projected_ty = self.layout.ty.builtin_deref(true)\n             .unwrap_or_else(|| bug!(\"deref of non-pointer {:?}\", self)).ty;\n         let (llptr, llextra) = match self.val {\n@@ -159,48 +158,60 @@ impl OperandRef<'ll, 'tcx> {\n \n     /// If this operand is a `Pair`, we return an aggregate with the two values.\n     /// For other cases, see `immediate`.\n-    pub fn immediate_or_packed_pair(self, bx: &Builder<'a, 'll, 'tcx>) -> &'ll Value {\n+    pub fn immediate_or_packed_pair<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        self,\n+        bx: &mut Bx\n+    ) -> V {\n         if let OperandValue::Pair(a, b) = self.val {\n-            let llty = self.layout.llvm_type(bx.cx);\n+            let llty = bx.cx().backend_type(self.layout);\n             debug!(\"Operand::immediate_or_packed_pair: packing {:?} into {:?}\",\n                    self, llty);\n             // Reconstruct the immediate aggregate.\n-            let mut llpair = C_undef(llty);\n-            llpair = bx.insert_value(llpair, base::from_immediate(bx, a), 0);\n-            llpair = bx.insert_value(llpair, base::from_immediate(bx, b), 1);\n+            let mut llpair = bx.cx().const_undef(llty);\n+            let imm_a = base::from_immediate(bx, a);\n+            let imm_b = base::from_immediate(bx, b);\n+            llpair = bx.insert_value(llpair, imm_a, 0);\n+            llpair = bx.insert_value(llpair, imm_b, 1);\n             llpair\n         } else {\n             self.immediate()\n         }\n     }\n \n     /// If the type is a pair, we return a `Pair`, otherwise, an `Immediate`.\n-    pub fn from_immediate_or_packed_pair(bx: &Builder<'a, 'll, 'tcx>,\n-                                         llval: &'ll Value,\n-                                         layout: TyLayout<'tcx>)\n-                                         -> OperandRef<'ll, 'tcx> {\n+    pub fn from_immediate_or_packed_pair<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        bx: &mut Bx,\n+        llval: V,\n+        layout: TyLayout<'tcx>\n+    ) -> Self {\n         let val = if let layout::Abi::ScalarPair(ref a, ref b) = layout.abi {\n             debug!(\"Operand::from_immediate_or_packed_pair: unpacking {:?} @ {:?}\",\n                     llval, layout);\n \n             // Deconstruct the immediate aggregate.\n-            let a_llval = base::to_immediate_scalar(bx, bx.extract_value(llval, 0), a);\n-            let b_llval = base::to_immediate_scalar(bx, bx.extract_value(llval, 1), b);\n+            let a_llval = bx.extract_value(llval, 0);\n+            let a_llval = base::to_immediate_scalar(bx, a_llval, a);\n+            let b_llval = bx.extract_value(llval, 1);\n+            let b_llval = base::to_immediate_scalar(bx, b_llval, b);\n             OperandValue::Pair(a_llval, b_llval)\n         } else {\n             OperandValue::Immediate(llval)\n         };\n         OperandRef { val, layout }\n     }\n \n-    pub fn extract_field(&self, bx: &Builder<'a, 'll, 'tcx>, i: usize) -> OperandRef<'ll, 'tcx> {\n-        let field = self.layout.field(bx.cx, i);\n+    pub fn extract_field<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        &self,\n+        bx: &mut Bx,\n+        i: usize\n+    ) -> Self {\n+        let field = self.layout.field(bx.cx(), i);\n         let offset = self.layout.fields.offset(i);\n \n         let mut val = match (self.val, &self.layout.abi) {\n             // If the field is ZST, it has no data.\n             _ if field.is_zst() => {\n-                return OperandRef::new_zst(bx.cx, field);\n+                return OperandRef::new_zst(bx.cx(), field);\n             }\n \n             // Newtype of a scalar, scalar pair or vector.\n@@ -213,20 +224,20 @@ impl OperandRef<'ll, 'tcx> {\n             // Extract a scalar component from a pair.\n             (OperandValue::Pair(a_llval, b_llval), &layout::Abi::ScalarPair(ref a, ref b)) => {\n                 if offset.bytes() == 0 {\n-                    assert_eq!(field.size, a.value.size(bx.cx));\n+                    assert_eq!(field.size, a.value.size(bx.cx()));\n                     OperandValue::Immediate(a_llval)\n                 } else {\n-                    assert_eq!(offset, a.value.size(bx.cx)\n-                        .abi_align(b.value.align(bx.cx)));\n-                    assert_eq!(field.size, b.value.size(bx.cx));\n+                    assert_eq!(offset, a.value.size(bx.cx())\n+                        .abi_align(b.value.align(bx.cx())));\n+                    assert_eq!(field.size, b.value.size(bx.cx()));\n                     OperandValue::Immediate(b_llval)\n                 }\n             }\n \n             // `#[repr(simd)]` types are also immediate.\n             (OperandValue::Immediate(llval), &layout::Abi::Vector { .. }) => {\n                 OperandValue::Immediate(\n-                    bx.extract_element(llval, C_usize(bx.cx, i as u64)))\n+                    bx.extract_element(llval, bx.cx().const_usize(i as u64)))\n             }\n \n             _ => bug!(\"OperandRef::extract_field({:?}): not applicable\", self)\n@@ -235,11 +246,11 @@ impl OperandRef<'ll, 'tcx> {\n         // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n         match val {\n             OperandValue::Immediate(ref mut llval) => {\n-                *llval = bx.bitcast(*llval, field.immediate_llvm_type(bx.cx));\n+                *llval = bx.bitcast(*llval, bx.cx().immediate_backend_type(field));\n             }\n             OperandValue::Pair(ref mut a, ref mut b) => {\n-                *a = bx.bitcast(*a, field.scalar_pair_element_llvm_type(bx.cx, 0, true));\n-                *b = bx.bitcast(*b, field.scalar_pair_element_llvm_type(bx.cx, 1, true));\n+                *a = bx.bitcast(*a, bx.cx().scalar_pair_element_backend_type(field, 0, true));\n+                *b = bx.bitcast(*b, bx.cx().scalar_pair_element_backend_type(field, 1, true));\n             }\n             OperandValue::Ref(..) => bug!()\n         }\n@@ -251,27 +262,43 @@ impl OperandRef<'ll, 'tcx> {\n     }\n }\n \n-impl OperandValue<'ll> {\n-    pub fn store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n+impl<'a, 'tcx: 'a, V: CodegenObject> OperandValue<V> {\n+    pub fn store<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        self,\n+        bx: &mut Bx,\n+        dest: PlaceRef<'tcx, V>\n+    ) {\n         self.store_with_flags(bx, dest, MemFlags::empty());\n     }\n \n-    pub fn volatile_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n+    pub fn volatile_store<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        self,\n+        bx: &mut Bx,\n+        dest: PlaceRef<'tcx, V>\n+    ) {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE);\n     }\n \n-    pub fn unaligned_volatile_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n+    pub fn unaligned_volatile_store<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        self,\n+        bx: &mut Bx,\n+        dest: PlaceRef<'tcx, V>,\n+    ) {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE | MemFlags::UNALIGNED);\n     }\n \n-    pub fn nontemporal_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n+    pub fn nontemporal_store<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        self,\n+        bx: &mut Bx,\n+        dest: PlaceRef<'tcx, V>\n+    ) {\n         self.store_with_flags(bx, dest, MemFlags::NONTEMPORAL);\n     }\n \n-    fn store_with_flags(\n+    fn store_with_flags<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n-        dest: PlaceRef<'ll, 'tcx>,\n+        bx: &mut Bx,\n+        dest: PlaceRef<'tcx, V>,\n         flags: MemFlags,\n     ) {\n         debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n@@ -301,8 +328,11 @@ impl OperandValue<'ll> {\n             }\n         }\n     }\n-\n-    pub fn store_unsized(self, bx: &Builder<'a, 'll, 'tcx>, indirect_dest: PlaceRef<'ll, 'tcx>) {\n+    pub fn store_unsized<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        self,\n+        bx: &mut Bx,\n+        indirect_dest: PlaceRef<'tcx, V>\n+    ) {\n         debug!(\"OperandRef::store_unsized: operand={:?}, indirect_dest={:?}\", self, indirect_dest);\n         let flags = MemFlags::empty();\n \n@@ -322,22 +352,22 @@ impl OperandValue<'ll> {\n         let min_align = Align::from_bits(8, 8).unwrap();\n \n         // Allocate an appropriate region on the stack, and copy the value into it\n-        let (llsize, _) = glue::size_and_align_of_dst(&bx, unsized_ty, Some(llextra));\n-        let lldst = bx.array_alloca(Type::i8(bx.cx), llsize, \"unsized_tmp\", max_align);\n-        base::call_memcpy(&bx, lldst, max_align, llptr, min_align, llsize, flags);\n+        let (llsize, _) = glue::size_and_align_of_dst(bx, unsized_ty, Some(llextra));\n+        let lldst = bx.array_alloca(bx.cx().type_i8(), llsize, \"unsized_tmp\", max_align);\n+        bx.memcpy(lldst, max_align, llptr, min_align, llsize, flags);\n \n         // Store the allocated region and the extra to the indirect place.\n         let indirect_operand = OperandValue::Pair(lldst, llextra);\n-        indirect_operand.store(&bx, indirect_dest);\n+        indirect_operand.store(bx, indirect_dest);\n     }\n }\n \n-impl FunctionCx<'a, 'll, 'tcx> {\n-    fn maybe_codegen_consume_direct(&mut self,\n-                                  bx: &Builder<'a, 'll, 'tcx>,\n-                                  place: &mir::Place<'tcx>)\n-                                   -> Option<OperandRef<'ll, 'tcx>>\n-    {\n+impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    fn maybe_codegen_consume_direct(\n+        &mut self,\n+        bx: &mut Bx,\n+        place: &mir::Place<'tcx>\n+    ) -> Option<OperandRef<'tcx, Bx::Value>> {\n         debug!(\"maybe_codegen_consume_direct(place={:?})\", place);\n \n         // watch out for locals that do not have an\n@@ -368,9 +398,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         // ZSTs don't require any actual memory access.\n                         // FIXME(eddyb) deduplicate this with the identical\n                         // checks in `codegen_consume` and `extract_field`.\n-                        let elem = o.layout.field(bx.cx, 0);\n+                        let elem = o.layout.field(bx.cx(), 0);\n                         if elem.is_zst() {\n-                            return Some(OperandRef::new_zst(bx.cx, elem));\n+                            return Some(OperandRef::new_zst(bx.cx(), elem));\n                         }\n                     }\n                     _ => {}\n@@ -381,19 +411,19 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         None\n     }\n \n-    pub fn codegen_consume(&mut self,\n-                         bx: &Builder<'a, 'll, 'tcx>,\n-                         place: &mir::Place<'tcx>)\n-                         -> OperandRef<'ll, 'tcx>\n-    {\n+    pub fn codegen_consume(\n+        &mut self,\n+        bx: &mut Bx,\n+        place: &mir::Place<'tcx>\n+    ) -> OperandRef<'tcx, Bx::Value> {\n         debug!(\"codegen_consume(place={:?})\", place);\n \n         let ty = self.monomorphized_place_ty(place);\n-        let layout = bx.cx.layout_of(ty);\n+        let layout = bx.cx().layout_of(ty);\n \n         // ZSTs don't require any actual memory access.\n         if layout.is_zst() {\n-            return OperandRef::new_zst(bx.cx, layout);\n+            return OperandRef::new_zst(bx.cx(), layout);\n         }\n \n         if let Some(o) = self.maybe_codegen_consume_direct(bx, place) {\n@@ -402,14 +432,15 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n         // for most places, to consume them we just load them\n         // out from their home\n-        self.codegen_place(bx, place).load(bx)\n+        let place = self.codegen_place(bx, place);\n+        bx.load_operand(place)\n     }\n \n-    pub fn codegen_operand(&mut self,\n-                         bx: &Builder<'a, 'll, 'tcx>,\n-                         operand: &mir::Operand<'tcx>)\n-                         -> OperandRef<'ll, 'tcx>\n-    {\n+    pub fn codegen_operand(\n+        &mut self,\n+        bx: &mut Bx,\n+        operand: &mir::Operand<'tcx>\n+    ) -> OperandRef<'tcx, Bx::Value> {\n         debug!(\"codegen_operand(operand={:?})\", operand);\n \n         match *operand {\n@@ -432,15 +463,15 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         }\n                         // Allow RalfJ to sleep soundly knowing that even refactorings that remove\n                         // the above error (or silence it under some conditions) will not cause UB\n-                        let fnname = bx.cx.get_intrinsic(&(\"llvm.trap\"));\n+                        let fnname = bx.cx().get_intrinsic(&(\"llvm.trap\"));\n                         bx.call(fnname, &[], None);\n                         // We've errored, so we don't have to produce working code.\n-                        let layout = bx.cx.layout_of(ty);\n-                        PlaceRef::new_sized(\n-                            C_undef(layout.llvm_type(bx.cx).ptr_to()),\n+                        let layout = bx.cx().layout_of(ty);\n+                        bx.load_operand(PlaceRef::new_sized(\n+                            bx.cx().const_undef(bx.cx().type_ptr_to(bx.cx().backend_type(layout))),\n                             layout,\n                             layout.align,\n-                        ).load(bx)\n+                        ))\n                     })\n             }\n         }", "previous_filename": "src/librustc_codegen_llvm/mir/operand.rs"}, {"sha": "5b36ee8fd183c8ab49b6e8ff59f503bb2a5929a6", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "previous_filename": "src/librustc_codegen_llvm/mir/place.rs"}, {"sha": "6b1efa060fdad8a40d6f6b92f51c57c850e4e44a", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "renamed", "additions": 250, "deletions": 224, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "previous_filename": "src/librustc_codegen_llvm/mir/rvalue.rs"}, {"sha": "a69474142ab58b98d945df9763b57af83dc126e2", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "renamed", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0", "previous_filename": "src/librustc_codegen_llvm/mir/statement.rs"}, {"sha": "53acb3e376c774d933c0d4ed4d67478e9dcdc6da", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}, {"sha": "f35eb84813f753a7777b199346e9bec81951b04f", "filename": "src/librustc_codegen_ssa/traits/abi.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}, {"sha": "93e4869e93733e35228f4dd2e7a965aeff1f6f54", "filename": "src/librustc_codegen_ssa/traits/asm.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}, {"sha": "b4d376cf5f0e29792700ebbac3bf56329e6eb13f", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}, {"sha": "3757c514d2ce96f2684dc37703162c274b729726", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}, {"sha": "c0a5445219565cb86e7fab49ec48be0ae175a41d", "filename": "src/librustc_codegen_ssa/traits/consts.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}, {"sha": "643776fcd64f4ee0bb416dec17606e38d0f89d7e", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}, {"sha": "38ef52e3c8e001762e5b5e4b2562202114899d44", "filename": "src/librustc_codegen_ssa/traits/declare.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}, {"sha": "53a7878796b3112982d2a746adeb9e48122b84d7", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}, {"sha": "0425b8e8e23b1dd0d849773ab5fa7f66fa4d69b5", "filename": "src/librustc_codegen_ssa/traits/misc.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}, {"sha": "5cff31e17b5bc7abdd2f603c48ee2f6e717c665a", "filename": "src/librustc_codegen_ssa/traits/mod.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}, {"sha": "172c48f8a85ffcbd6f3a929806d6f358a0ddd58c", "filename": "src/librustc_codegen_ssa/traits/statics.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}, {"sha": "1aa1f45f51746a28599100d37b13535d38e99644", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}, {"sha": "72522e19af21083aa13dadf365ea53c6f486c073", "filename": "src/librustc_codegen_ssa/traits/write.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}, {"sha": "34a09f30b641162e1ed5541673832dd686935634", "filename": "src/librustc_codegen_utils/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2FCargo.toml?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}, {"sha": "c3edbb633c72298c084c3d353d530eb6416ba068", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=f6e9485bfc245eb5f10b1f2b0a786538d12d1cb0"}]}