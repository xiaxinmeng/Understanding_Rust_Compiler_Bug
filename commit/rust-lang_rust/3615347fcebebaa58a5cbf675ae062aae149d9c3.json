{"sha": "3615347fcebebaa58a5cbf675ae062aae149d9c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2MTUzNDdmY2ViZWJhYTU4YTVjYmY2NzVhZTA2MmFhZTE0OWQ5YzM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-25T20:46:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-25T20:46:08Z"}, "message": "Merge #5065\n\n5065: Simplify diagnostics handling r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "77c2232aa7286e2880a28678e343286b853bfebc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77c2232aa7286e2880a28678e343286b853bfebc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3615347fcebebaa58a5cbf675ae062aae149d9c3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe9Q0QCRBK7hj4Ov3rIwAAdHIIAFjj5owvyopbxcEzzcjgrqBi\nnFDh6hXZecQrIJGRXz/1HACFqLBX+Gn8zh55DfNIlTTWuA/Ndio5LBeUzv4MrxV1\nsaphKMgXM108+UzsrGGof2kAuVL5Kepr7QTleLDzJM2z6ARPoW7+/MLrStcI0+wE\n7uvmXBcgwOIZPptoPLYDPNqfIFOtlrRz2QPIfRbYEFrs0do822gwNYdBVnbMc3B2\nlA/tFjkawp8auKdyTPOKLnkT+liRNJ+u+hxfgSFpcucqLxowKqEtnR50ptwAZe79\ne3S/SAXAwBTA8dAe/ilzEhXKSWKNA1oAkeJiMaIDa61tld1uB41k6YIz5sJR0Ls=\n=24tZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 77c2232aa7286e2880a28678e343286b853bfebc\nparent b5aa92bab94880a289372c66c99117ae5e6e9e1f\nparent df769e5bb4e26a2f150ce2c37b9b9364ee10bab8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593117968 +0000\ncommitter GitHub <noreply@github.com> 1593117968 +0000\n\nMerge #5065\n\n5065: Simplify diagnostics handling r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3615347fcebebaa58a5cbf675ae062aae149d9c3", "html_url": "https://github.com/rust-lang/rust/commit/3615347fcebebaa58a5cbf675ae062aae149d9c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3615347fcebebaa58a5cbf675ae062aae149d9c3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5aa92bab94880a289372c66c99117ae5e6e9e1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5aa92bab94880a289372c66c99117ae5e6e9e1f", "html_url": "https://github.com/rust-lang/rust/commit/b5aa92bab94880a289372c66c99117ae5e6e9e1f"}, {"sha": "df769e5bb4e26a2f150ce2c37b9b9364ee10bab8", "url": "https://api.github.com/repos/rust-lang/rust/commits/df769e5bb4e26a2f150ce2c37b9b9364ee10bab8", "html_url": "https://github.com/rust-lang/rust/commit/df769e5bb4e26a2f150ce2c37b9b9364ee10bab8"}], "stats": {"total": 506, "additions": 239, "deletions": 267}, "files": [{"sha": "f3cdb842bd6215c4731503474cd2d01557a56c2d", "filename": "crates/rust-analyzer/src/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3615347fcebebaa58a5cbf675ae062aae149d9c3/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3615347fcebebaa58a5cbf675ae062aae149d9c3/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs?ref=3615347fcebebaa58a5cbf675ae062aae149d9c3", "patch": "@@ -1,14 +1,15 @@\n //! Book keeping for keeping diagnostics easily in sync with the client.\n pub(crate) mod to_proto;\n \n-use std::{collections::HashMap, sync::Arc};\n+use std::{collections::HashMap, mem, sync::Arc};\n \n use lsp_types::{Diagnostic, Range};\n use ra_ide::FileId;\n+use rustc_hash::FxHashSet;\n \n use crate::lsp_ext;\n \n-pub type CheckFixes = Arc<HashMap<FileId, Vec<Fix>>>;\n+pub(crate) type CheckFixes = Arc<HashMap<FileId, Vec<Fix>>>;\n \n #[derive(Debug, Default, Clone)]\n pub struct DiagnosticsConfig {\n@@ -17,32 +18,26 @@ pub struct DiagnosticsConfig {\n }\n \n #[derive(Debug, Default, Clone)]\n-pub struct DiagnosticCollection {\n-    pub native: HashMap<FileId, Vec<Diagnostic>>,\n-    pub check: HashMap<FileId, Vec<Diagnostic>>,\n-    pub check_fixes: CheckFixes,\n+pub(crate) struct DiagnosticCollection {\n+    pub(crate) native: HashMap<FileId, Vec<Diagnostic>>,\n+    pub(crate) check: HashMap<FileId, Vec<Diagnostic>>,\n+    pub(crate) check_fixes: CheckFixes,\n+    changes: FxHashSet<FileId>,\n }\n \n #[derive(Debug, Clone)]\n-pub struct Fix {\n-    pub range: Range,\n-    pub action: lsp_ext::CodeAction,\n-}\n-\n-#[derive(Debug)]\n-pub enum DiagnosticTask {\n-    ClearCheck,\n-    AddCheck(FileId, Diagnostic, Vec<lsp_ext::CodeAction>),\n-    SetNative(FileId, Vec<Diagnostic>),\n+pub(crate) struct Fix {\n+    pub(crate) range: Range,\n+    pub(crate) action: lsp_ext::CodeAction,\n }\n \n impl DiagnosticCollection {\n-    pub fn clear_check(&mut self) -> Vec<FileId> {\n+    pub(crate) fn clear_check(&mut self) {\n         Arc::make_mut(&mut self.check_fixes).clear();\n-        self.check.drain().map(|(key, _value)| key).collect()\n+        self.changes.extend(self.check.drain().map(|(key, _value)| key))\n     }\n \n-    pub fn add_check_diagnostic(\n+    pub(crate) fn add_check_diagnostic(\n         &mut self,\n         file_id: FileId,\n         diagnostic: Diagnostic,\n@@ -61,30 +56,25 @@ impl DiagnosticCollection {\n             .or_default()\n             .extend(fixes.into_iter().map(|action| Fix { range: diagnostic.range, action }));\n         diagnostics.push(diagnostic);\n+        self.changes.insert(file_id);\n     }\n \n-    pub fn set_native_diagnostics(&mut self, file_id: FileId, diagnostics: Vec<Diagnostic>) {\n+    pub(crate) fn set_native_diagnostics(&mut self, file_id: FileId, diagnostics: Vec<Diagnostic>) {\n         self.native.insert(file_id, diagnostics);\n+        self.changes.insert(file_id);\n     }\n \n-    pub fn diagnostics_for(&self, file_id: FileId) -> impl Iterator<Item = &Diagnostic> {\n+    pub(crate) fn diagnostics_for(&self, file_id: FileId) -> impl Iterator<Item = &Diagnostic> {\n         let native = self.native.get(&file_id).into_iter().flatten();\n         let check = self.check.get(&file_id).into_iter().flatten();\n         native.chain(check)\n     }\n \n-    pub fn handle_task(&mut self, task: DiagnosticTask) -> Vec<FileId> {\n-        match task {\n-            DiagnosticTask::ClearCheck => self.clear_check(),\n-            DiagnosticTask::AddCheck(file_id, diagnostic, fixes) => {\n-                self.add_check_diagnostic(file_id, diagnostic, fixes);\n-                vec![file_id]\n-            }\n-            DiagnosticTask::SetNative(file_id, diagnostics) => {\n-                self.set_native_diagnostics(file_id, diagnostics);\n-                vec![file_id]\n-            }\n+    pub(crate) fn take_changes(&mut self) -> Option<FxHashSet<FileId>> {\n+        if self.changes.is_empty() {\n+            return None;\n         }\n+        Some(mem::take(&mut self.changes))\n     }\n }\n "}, {"sha": "03b373deeaac603e6a3490a81b0b20adef3c544c", "filename": "crates/rust-analyzer/src/dispatch.rs", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3615347fcebebaa58a5cbf675ae062aae149d9c3/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3615347fcebebaa58a5cbf675ae062aae149d9c3/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs?ref=3615347fcebebaa58a5cbf675ae062aae149d9c3", "patch": "@@ -1,5 +1,5 @@\n //! A visitor for downcasting arbitrary request (JSON) into a specific type.\n-use std::{panic, time::Instant};\n+use std::panic;\n \n use serde::{de::DeserializeOwned, Serialize};\n \n@@ -13,7 +13,6 @@ use crate::{\n pub(crate) struct RequestDispatcher<'a> {\n     pub(crate) req: Option<lsp_server::Request>,\n     pub(crate) global_state: &'a mut GlobalState,\n-    pub(crate) request_received: Instant,\n }\n \n impl<'a> RequestDispatcher<'a> {\n@@ -34,12 +33,12 @@ impl<'a> RequestDispatcher<'a> {\n             }\n         };\n         let world = panic::AssertUnwindSafe(&mut *self.global_state);\n-        let task = panic::catch_unwind(move || {\n+        let response = panic::catch_unwind(move || {\n             let result = f(world.0, params);\n-            result_to_task::<R>(id, result)\n+            result_to_response::<R>(id, result)\n         })\n         .map_err(|_| format!(\"sync task {:?} panicked\", R::METHOD))?;\n-        self.global_state.on_task(task);\n+        self.global_state.respond(response);\n         Ok(self)\n     }\n \n@@ -64,25 +63,22 @@ impl<'a> RequestDispatcher<'a> {\n             let world = self.global_state.snapshot();\n             move || {\n                 let result = f(world, params);\n-                result_to_task::<R>(id, result)\n+                Task::Response(result_to_response::<R>(id, result))\n             }\n         });\n \n         Ok(self)\n     }\n \n     pub(crate) fn finish(&mut self) {\n-        match self.req.take() {\n-            None => (),\n-            Some(req) => {\n-                log::error!(\"unknown request: {:?}\", req);\n-                let resp = lsp_server::Response::new_err(\n-                    req.id,\n-                    lsp_server::ErrorCode::MethodNotFound as i32,\n-                    \"unknown request\".to_string(),\n-                );\n-                self.global_state.send(resp.into());\n-            }\n+        if let Some(req) = self.req.take() {\n+            log::error!(\"unknown request: {:?}\", req);\n+            let response = lsp_server::Response::new_err(\n+                req.id,\n+                lsp_server::ErrorCode::MethodNotFound as i32,\n+                \"unknown request\".to_string(),\n+            );\n+            self.global_state.respond(response)\n         }\n     }\n \n@@ -99,21 +95,20 @@ impl<'a> RequestDispatcher<'a> {\n                 return None;\n             }\n         };\n-        self.global_state\n-            .req_queue\n-            .incoming\n-            .register(id.clone(), (R::METHOD, self.request_received));\n         Some((id, params))\n     }\n }\n \n-fn result_to_task<R>(id: lsp_server::RequestId, result: Result<R::Result>) -> Task\n+fn result_to_response<R>(\n+    id: lsp_server::RequestId,\n+    result: Result<R::Result>,\n+) -> lsp_server::Response\n where\n     R: lsp_types::request::Request + 'static,\n     R::Params: DeserializeOwned + 'static,\n     R::Result: Serialize + 'static,\n {\n-    let response = match result {\n+    match result {\n         Ok(resp) => lsp_server::Response::new_ok(id, &resp),\n         Err(e) => match e.downcast::<LspError>() {\n             Ok(lsp_error) => lsp_server::Response::new_err(id, lsp_error.code, lsp_error.message),\n@@ -133,8 +128,7 @@ where\n                 }\n             }\n         },\n-    };\n-    Task::Respond(response)\n+    }\n }\n \n pub(crate) struct NotificationDispatcher<'a> {"}, {"sha": "149b1b5f972e0f9b95721fb06430fb26b1b73778", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3615347fcebebaa58a5cbf675ae062aae149d9c3/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3615347fcebebaa58a5cbf675ae062aae149d9c3/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=3615347fcebebaa58a5cbf675ae062aae149d9c3", "patch": "@@ -253,13 +253,19 @@ impl GlobalState {\n         self.analysis_host.collect_garbage()\n     }\n \n-    pub(crate) fn complete_request(&mut self, request: RequestMetrics) {\n-        self.latest_requests.write().record(request)\n-    }\n-\n     pub(crate) fn send(&mut self, message: lsp_server::Message) {\n         self.sender.send(message).unwrap()\n     }\n+    pub(crate) fn respond(&mut self, response: lsp_server::Response) {\n+        if let Some((method, start)) = self.req_queue.incoming.complete(response.id.clone()) {\n+            let duration = start.elapsed();\n+            log::info!(\"handled req#{} in {:?}\", response.id, duration);\n+            let metrics =\n+                RequestMetrics { id: response.id.clone(), method: method.to_string(), duration };\n+            self.latest_requests.write().record(metrics);\n+            self.send(response.into());\n+        }\n+    }\n     pub(crate) fn show_message(&mut self, typ: lsp_types::MessageType, message: String) {\n         show_message(typ, message, &self.sender)\n     }"}, {"sha": "12b494496fcfb66923e671dae549dd65be352ca2", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3615347fcebebaa58a5cbf675ae062aae149d9c3/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3615347fcebebaa58a5cbf675ae062aae149d9c3/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=3615347fcebebaa58a5cbf675ae062aae149d9c3", "patch": "@@ -31,7 +31,6 @@ use stdx::{format_to, split_delim};\n use crate::{\n     cargo_target_spec::CargoTargetSpec,\n     config::RustfmtConfig,\n-    diagnostics::DiagnosticTask,\n     from_json, from_proto,\n     global_state::GlobalStateSnapshot,\n     lsp_ext::{self, InlayHint, InlayHintsParams},\n@@ -950,7 +949,7 @@ pub(crate) fn handle_ssr(\n pub(crate) fn publish_diagnostics(\n     snap: &GlobalStateSnapshot,\n     file_id: FileId,\n-) -> Result<DiagnosticTask> {\n+) -> Result<Vec<Diagnostic>> {\n     let _p = profile(\"publish_diagnostics\");\n     let line_index = snap.analysis.file_line_index(file_id)?;\n     let diagnostics: Vec<Diagnostic> = snap\n@@ -967,7 +966,7 @@ pub(crate) fn publish_diagnostics(\n             tags: None,\n         })\n         .collect();\n-    Ok(DiagnosticTask::SetNative(file_id, diagnostics))\n+    Ok(diagnostics)\n }\n \n pub(crate) fn handle_inlay_hints("}, {"sha": "1bd9d638941fc8ae55e90470998cd981e482d431", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 186, "deletions": 203, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/3615347fcebebaa58a5cbf675ae062aae149d9c3/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3615347fcebebaa58a5cbf675ae062aae149d9c3/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=3615347fcebebaa58a5cbf675ae062aae149d9c3", "patch": "@@ -15,15 +15,13 @@ use ra_project_model::{PackageRoot, ProjectWorkspace};\n \n use crate::{\n     config::{Config, FilesWatcher, LinkedProject},\n-    diagnostics::DiagnosticTask,\n     dispatch::{NotificationDispatcher, RequestDispatcher},\n     from_proto,\n     global_state::{file_id_to_url, GlobalState, Status},\n     handlers, lsp_ext,\n     lsp_utils::{\n         apply_document_changes, is_canceled, notification_is, notification_new, show_message,\n     },\n-    request_metrics::RequestMetrics,\n     Result,\n };\n \n@@ -126,6 +124,52 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n     Ok(())\n }\n \n+enum Event {\n+    Lsp(lsp_server::Message),\n+    Task(Task),\n+    Vfs(vfs::loader::Message),\n+    Flycheck(flycheck::Message),\n+}\n+\n+#[derive(Debug)]\n+pub(crate) enum Task {\n+    Response(Response),\n+    Diagnostics(Vec<(FileId, Vec<lsp_types::Diagnostic>)>),\n+    Unit,\n+}\n+\n+impl fmt::Debug for Event {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let debug_verbose_not = |not: &Notification, f: &mut fmt::Formatter| {\n+            f.debug_struct(\"Notification\").field(\"method\", &not.method).finish()\n+        };\n+\n+        match self {\n+            Event::Lsp(lsp_server::Message::Notification(not)) => {\n+                if notification_is::<lsp_types::notification::DidOpenTextDocument>(not)\n+                    || notification_is::<lsp_types::notification::DidChangeTextDocument>(not)\n+                {\n+                    return debug_verbose_not(not, f);\n+                }\n+            }\n+            Event::Task(Task::Response(resp)) => {\n+                return f\n+                    .debug_struct(\"Response\")\n+                    .field(\"id\", &resp.id)\n+                    .field(\"error\", &resp.error)\n+                    .finish();\n+            }\n+            _ => (),\n+        }\n+        match self {\n+            Event::Lsp(it) => fmt::Debug::fmt(it, f),\n+            Event::Task(it) => fmt::Debug::fmt(it, f),\n+            Event::Vfs(it) => fmt::Debug::fmt(it, f),\n+            Event::Flycheck(it) => fmt::Debug::fmt(it, f),\n+        }\n+    }\n+}\n+\n impl GlobalState {\n     fn next_event(&self, inbox: &Receiver<lsp_server::Message>) -> Option<Event> {\n         select! {\n@@ -145,101 +189,165 @@ impl GlobalState {\n \n     fn run(mut self, inbox: Receiver<lsp_server::Message>) -> Result<()> {\n         while let Some(event) = self.next_event(&inbox) {\n-            let loop_start = Instant::now();\n-            // NOTE: don't count blocking select! call as a loop-turn time\n-            let _p = profile(\"main_loop_inner/loop-turn\");\n-\n-            log::info!(\"loop turn = {:?}\", event);\n-            let queue_count = self.task_pool.0.len();\n-            if queue_count > 0 {\n-                log::info!(\"queued count = {}\", queue_count);\n+            if let Event::Lsp(lsp_server::Message::Notification(not)) = &event {\n+                if not.method == lsp_types::notification::Exit::METHOD {\n+                    return Ok(());\n+                }\n             }\n+            self.loop_turn(event)?\n+        }\n+        Err(\"client exited without proper shutdown sequence\")?\n+    }\n \n-            let mut became_ready = false;\n-            match event {\n-                Event::Lsp(msg) => match msg {\n-                    lsp_server::Message::Request(req) => self.on_request(loop_start, req)?,\n-                    lsp_server::Message::Notification(not) => {\n-                        if not.method == lsp_types::notification::Exit::METHOD {\n-                            return Ok(());\n+    fn loop_turn(&mut self, event: Event) -> Result<()> {\n+        let loop_start = Instant::now();\n+        // NOTE: don't count blocking select! call as a loop-turn time\n+        let _p = profile(\"main_loop_inner/loop-turn\");\n+\n+        log::info!(\"loop turn = {:?}\", event);\n+        let queue_count = self.task_pool.0.len();\n+        if queue_count > 0 {\n+            log::info!(\"queued count = {}\", queue_count);\n+        }\n+\n+        let mut became_ready = false;\n+        match event {\n+            Event::Lsp(msg) => match msg {\n+                lsp_server::Message::Request(req) => self.on_request(loop_start, req)?,\n+                lsp_server::Message::Notification(not) => {\n+                    self.on_notification(not)?;\n+                }\n+                lsp_server::Message::Response(resp) => {\n+                    let handler = self.req_queue.outgoing.complete(resp.id.clone());\n+                    handler(self, resp)\n+                }\n+            },\n+            Event::Task(task) => {\n+                match task {\n+                    Task::Response(response) => self.respond(response),\n+                    Task::Diagnostics(diagnostics_per_file) => {\n+                        for (file_id, diagnostics) in diagnostics_per_file {\n+                            self.diagnostics.set_native_diagnostics(file_id, diagnostics)\n                         }\n-                        self.on_notification(not)?;\n                     }\n-                    lsp_server::Message::Response(resp) => {\n-                        let handler = self.req_queue.outgoing.complete(resp.id.clone());\n-                        handler(&mut self, resp)\n-                    }\n-                },\n-                Event::Task(task) => {\n-                    self.on_task(task);\n-                    self.maybe_collect_garbage();\n+                    Task::Unit => (),\n                 }\n-                Event::Vfs(task) => match task {\n-                    vfs::loader::Message::Loaded { files } => {\n-                        let vfs = &mut self.vfs.write().0;\n-                        for (path, contents) in files {\n-                            let path = VfsPath::from(path);\n-                            if !self.mem_docs.contains(&path) {\n-                                vfs.set_file_contents(path, contents)\n-                            }\n+                self.maybe_collect_garbage();\n+            }\n+            Event::Vfs(task) => match task {\n+                vfs::loader::Message::Loaded { files } => {\n+                    let vfs = &mut self.vfs.write().0;\n+                    for (path, contents) in files {\n+                        let path = VfsPath::from(path);\n+                        if !self.mem_docs.contains(&path) {\n+                            vfs.set_file_contents(path, contents)\n                         }\n                     }\n-                    vfs::loader::Message::Progress { n_total, n_done } => {\n-                        let state = if n_done == 0 {\n-                            Progress::Begin\n-                        } else if n_done < n_total {\n-                            Progress::Report\n-                        } else {\n-                            assert_eq!(n_done, n_total);\n-                            self.status = Status::Ready;\n-                            became_ready = true;\n-                            Progress::End\n+                }\n+                vfs::loader::Message::Progress { n_total, n_done } => {\n+                    let state = if n_done == 0 {\n+                        Progress::Begin\n+                    } else if n_done < n_total {\n+                        Progress::Report\n+                    } else {\n+                        assert_eq!(n_done, n_total);\n+                        self.status = Status::Ready;\n+                        became_ready = true;\n+                        Progress::End\n+                    };\n+                    report_progress(\n+                        self,\n+                        \"roots scanned\",\n+                        state,\n+                        Some(format!(\"{}/{}\", n_done, n_total)),\n+                        Some(percentage(n_done, n_total)),\n+                    )\n+                }\n+            },\n+            Event::Flycheck(task) => match task {\n+                flycheck::Message::ClearDiagnostics => self.diagnostics.clear_check(),\n+\n+                flycheck::Message::AddDiagnostic { workspace_root, diagnostic } => {\n+                    let diagnostics = crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n+                        &self.config.diagnostics,\n+                        &diagnostic,\n+                        &workspace_root,\n+                    );\n+                    for diag in diagnostics {\n+                        let path = from_proto::vfs_path(&diag.location.uri)?;\n+                        let file_id = match self.vfs.read().0.file_id(&path) {\n+                            Some(file) => FileId(file.0),\n+                            None => {\n+                                log::error!(\n+                                    \"File with cargo diagnostic not found in VFS: {}\",\n+                                    path\n+                                );\n+                                return Ok(());\n+                            }\n                         };\n-                        report_progress(\n-                            &mut self,\n-                            \"roots scanned\",\n-                            state,\n-                            Some(format!(\"{}/{}\", n_done, n_total)),\n-                            Some(percentage(n_done, n_total)),\n-                        )\n+                        self.diagnostics.add_check_diagnostic(file_id, diag.diagnostic, diag.fixes)\n                     }\n-                },\n-                Event::Flycheck(task) => on_check_task(task, &mut self)?,\n-            }\n+                }\n \n-            let state_changed = self.process_changes();\n-            if became_ready {\n-                if let Some(flycheck) = &self.flycheck {\n-                    flycheck.0.update();\n+                flycheck::Message::Progress(status) => {\n+                    let (state, message) = match status {\n+                        flycheck::Progress::Being => (Progress::Begin, None),\n+                        flycheck::Progress::DidCheckCrate(target) => {\n+                            (Progress::Report, Some(target))\n+                        }\n+                        flycheck::Progress::End => (Progress::End, None),\n+                    };\n+\n+                    report_progress(self, \"cargo check\", state, message, None);\n                 }\n+            },\n+        }\n+\n+        let state_changed = self.process_changes();\n+        if became_ready {\n+            if let Some(flycheck) = &self.flycheck {\n+                flycheck.0.update();\n             }\n+        }\n \n-            if self.status == Status::Ready && (state_changed || became_ready) {\n-                let subscriptions = self\n-                    .mem_docs\n-                    .iter()\n-                    .map(|path| self.vfs.read().0.file_id(&path).unwrap())\n-                    .collect::<Vec<_>>();\n+        if self.status == Status::Ready && (state_changed || became_ready) {\n+            let subscriptions = self\n+                .mem_docs\n+                .iter()\n+                .map(|path| self.vfs.read().0.file_id(&path).unwrap())\n+                .collect::<Vec<_>>();\n+\n+            self.update_file_notifications_on_threadpool(subscriptions);\n+        }\n \n-                self.update_file_notifications_on_threadpool(subscriptions);\n+        if let Some(diagnostic_changes) = self.diagnostics.take_changes() {\n+            for file_id in diagnostic_changes {\n+                let url = file_id_to_url(&self.vfs.read().0, file_id);\n+                let diagnostics = self.diagnostics.diagnostics_for(file_id).cloned().collect();\n+                let params =\n+                    lsp_types::PublishDiagnosticsParams { uri: url, diagnostics, version: None };\n+                let not = notification_new::<lsp_types::notification::PublishDiagnostics>(params);\n+                self.send(not.into());\n             }\n+        }\n \n-            let loop_duration = loop_start.elapsed();\n-            if loop_duration > Duration::from_millis(100) {\n-                log::error!(\"overly long loop turn: {:?}\", loop_duration);\n-                if env::var(\"RA_PROFILE\").is_ok() {\n-                    self.show_message(\n-                        lsp_types::MessageType::Error,\n-                        format!(\"overly long loop turn: {:?}\", loop_duration),\n-                    )\n-                }\n+        let loop_duration = loop_start.elapsed();\n+        if loop_duration > Duration::from_millis(100) {\n+            log::warn!(\"overly long loop turn: {:?}\", loop_duration);\n+            if env::var(\"RA_PROFILE\").is_ok() {\n+                self.show_message(\n+                    lsp_types::MessageType::Error,\n+                    format!(\"overly long loop turn: {:?}\", loop_duration),\n+                )\n             }\n         }\n-        Err(\"client exited without proper shutdown sequence\")?\n+        Ok(())\n     }\n \n     fn on_request(&mut self, request_received: Instant, req: Request) -> Result<()> {\n-        RequestDispatcher { req: Some(req), global_state: self, request_received }\n+        self.req_queue.incoming.register(req.id.clone(), (req.method.clone(), request_received));\n+\n+        RequestDispatcher { req: Some(req), global_state: self }\n             .on_sync::<lsp_ext::CollectGarbage>(|s, ()| Ok(s.collect_garbage()))?\n             .on_sync::<lsp_ext::JoinLines>(|s, p| handlers::handle_join_lines(s.snapshot(), p))?\n             .on_sync::<lsp_ext::OnEnter>(|s, p| handlers::handle_on_enter(s.snapshot(), p))?\n@@ -400,27 +508,6 @@ impl GlobalState {\n             .finish();\n         Ok(())\n     }\n-    pub(crate) fn on_task(&mut self, task: Task) {\n-        match task {\n-            Task::Respond(response) => {\n-                if let Some((method, start)) = self.req_queue.incoming.complete(response.id.clone())\n-                {\n-                    let duration = start.elapsed();\n-                    log::info!(\"handled req#{} in {:?}\", response.id, duration);\n-                    self.complete_request(RequestMetrics {\n-                        id: response.id.clone(),\n-                        method: method.to_string(),\n-                        duration,\n-                    });\n-                    self.send(response.into());\n-                }\n-            }\n-            Task::Diagnostics(tasks) => {\n-                tasks.into_iter().for_each(|task| on_diagnostic_task(task, self))\n-            }\n-            Task::Unit => (),\n-        }\n-    }\n     fn update_file_notifications_on_threadpool(&mut self, subscriptions: Vec<FileId>) {\n         log::trace!(\"updating notifications for {:?}\", subscriptions);\n         if self.config.publish_diagnostics {\n@@ -438,6 +525,7 @@ impl GlobalState {\n                                 ()\n                             })\n                             .ok()\n+                            .map(|diags| (file_id, diags))\n                     })\n                     .collect::<Vec<_>>();\n                 Task::Diagnostics(diagnostics)\n@@ -454,115 +542,10 @@ impl GlobalState {\n     }\n }\n \n-#[derive(Debug)]\n-pub(crate) enum Task {\n-    Respond(Response),\n-    Diagnostics(Vec<DiagnosticTask>),\n-    Unit,\n-}\n-\n-enum Event {\n-    Lsp(lsp_server::Message),\n-    Task(Task),\n-    Vfs(vfs::loader::Message),\n-    Flycheck(flycheck::Message),\n-}\n-\n-impl fmt::Debug for Event {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let debug_verbose_not = |not: &Notification, f: &mut fmt::Formatter| {\n-            f.debug_struct(\"Notification\").field(\"method\", &not.method).finish()\n-        };\n-\n-        match self {\n-            Event::Lsp(lsp_server::Message::Notification(not)) => {\n-                if notification_is::<lsp_types::notification::DidOpenTextDocument>(not)\n-                    || notification_is::<lsp_types::notification::DidChangeTextDocument>(not)\n-                {\n-                    return debug_verbose_not(not, f);\n-                }\n-            }\n-            Event::Task(Task::Respond(resp)) => {\n-                return f\n-                    .debug_struct(\"Response\")\n-                    .field(\"id\", &resp.id)\n-                    .field(\"error\", &resp.error)\n-                    .finish();\n-            }\n-            _ => (),\n-        }\n-        match self {\n-            Event::Lsp(it) => fmt::Debug::fmt(it, f),\n-            Event::Task(it) => fmt::Debug::fmt(it, f),\n-            Event::Vfs(it) => fmt::Debug::fmt(it, f),\n-            Event::Flycheck(it) => fmt::Debug::fmt(it, f),\n-        }\n-    }\n-}\n-\n pub(crate) type ReqHandler = fn(&mut GlobalState, Response);\n-pub(crate) type ReqQueue = lsp_server::ReqQueue<(&'static str, Instant), ReqHandler>;\n+pub(crate) type ReqQueue = lsp_server::ReqQueue<(String, Instant), ReqHandler>;\n const DO_NOTHING: ReqHandler = |_, _| ();\n \n-fn on_check_task(task: flycheck::Message, global_state: &mut GlobalState) -> Result<()> {\n-    match task {\n-        flycheck::Message::ClearDiagnostics => {\n-            on_diagnostic_task(DiagnosticTask::ClearCheck, global_state)\n-        }\n-\n-        flycheck::Message::AddDiagnostic { workspace_root, diagnostic } => {\n-            let diagnostics = crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n-                &global_state.config.diagnostics,\n-                &diagnostic,\n-                &workspace_root,\n-            );\n-            for diag in diagnostics {\n-                let path = from_proto::vfs_path(&diag.location.uri)?;\n-                let file_id = match global_state.vfs.read().0.file_id(&path) {\n-                    Some(file) => FileId(file.0),\n-                    None => {\n-                        log::error!(\"File with cargo diagnostic not found in VFS: {}\", path);\n-                        return Ok(());\n-                    }\n-                };\n-\n-                on_diagnostic_task(\n-                    DiagnosticTask::AddCheck(\n-                        file_id,\n-                        diag.diagnostic,\n-                        diag.fixes.into_iter().map(|it| it.into()).collect(),\n-                    ),\n-                    global_state,\n-                )\n-            }\n-        }\n-\n-        flycheck::Message::Progress(status) => {\n-            let (state, message) = match status {\n-                flycheck::Progress::Being => (Progress::Begin, None),\n-                flycheck::Progress::DidCheckCrate(target) => (Progress::Report, Some(target)),\n-                flycheck::Progress::End => (Progress::End, None),\n-            };\n-\n-            report_progress(global_state, \"cargo check\", state, message, None);\n-        }\n-    };\n-\n-    Ok(())\n-}\n-\n-fn on_diagnostic_task(task: DiagnosticTask, global_state: &mut GlobalState) {\n-    let subscriptions = global_state.diagnostics.handle_task(task);\n-\n-    for file_id in subscriptions {\n-        let url = file_id_to_url(&global_state.vfs.read().0, file_id);\n-        let diagnostics = global_state.diagnostics.diagnostics_for(file_id).cloned().collect();\n-        let params = lsp_types::PublishDiagnosticsParams { uri: url, diagnostics, version: None };\n-        let not = notification_new::<lsp_types::notification::PublishDiagnostics>(params);\n-        global_state.send(not.into());\n-    }\n-}\n-\n #[derive(Eq, PartialEq)]\n enum Progress {\n     Begin,"}]}