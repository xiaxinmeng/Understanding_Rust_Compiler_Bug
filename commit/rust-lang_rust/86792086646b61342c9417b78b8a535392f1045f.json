{"sha": "86792086646b61342c9417b78b8a535392f1045f", "node_id": "C_kwDOAAsO6NoAKDg2NzkyMDg2NjQ2YjYxMzQyYzk0MTdiNzhiOGE1MzUzOTJmMTA0NWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-29T12:43:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-29T12:43:59Z"}, "message": "Auto merge of #109670 - lqd:init-mask, r=oli-obk\n\nMake init mask lazy for fully initialized/uninitialized const allocations\n\nThere are a few optimization opportunities in the `InitMask` and related const `Allocation`s (e.g. by taking advantage of the fact that it's a bitset that represents initialization, which is often entirely initialized or uninitialized in a single call, or gradually built up, etc).\n\nThere's a few overwrites to the same state, multiple writes in a row to the same indices, the RLE scheme for `memcpy` doesn't always compress, etc.\n\nHere, we start with:\n- avoiding materializing the bitset's blocks if the allocation is fully initialized/uninitialized\n- dealloc blocks when fully overwriting, including when participating in `memcpy`s\n- take care of the fixme about allocating blocks of 0s before overwriting them to the expected value\n- expanding unit test coverage of the init mask\n\nThis should be most visible on benchmarks and crates where const allocations dominate the runtime (like `ctfe-stress-5` of course), but I was especially looking at the worst cases from #93215.\n\nThis first change allows the majority of `set_range` calls to stay with a lazy init mask when bootstrapping rustc (not that the init mask is a big part of the process in cpu time or memory usage).\n\nr? `@oli-obk`\n\nI have another in-progress branch where I'll switch the singular initialized/uninitialized value to a watermark, recording the point after which everything is uninitialized. That will take care of cases where full initialization is monotonic and done in multiple steps (e.g. an array of a type without padding), which should then allow the vast majority of const allocations' init masks to stay lazy during bootstrapping (though interestingly I've seen such gradual initialization in both left-to-right and right-to-left directions, and I don't think a single watermark can handle both).", "tree": {"sha": "c2e8f4641fc4cb54cff30afdd907d5bc3112f1db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2e8f4641fc4cb54cff30afdd907d5bc3112f1db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86792086646b61342c9417b78b8a535392f1045f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86792086646b61342c9417b78b8a535392f1045f", "html_url": "https://github.com/rust-lang/rust/commit/86792086646b61342c9417b78b8a535392f1045f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86792086646b61342c9417b78b8a535392f1045f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf32b9de1e8f66526c36ad2927458558d2e81093", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf32b9de1e8f66526c36ad2927458558d2e81093", "html_url": "https://github.com/rust-lang/rust/commit/cf32b9de1e8f66526c36ad2927458558d2e81093"}, {"sha": "a857ba25f9630032a34aba5dc45fd5f58351c7f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a857ba25f9630032a34aba5dc45fd5f58351c7f0", "html_url": "https://github.com/rust-lang/rust/commit/a857ba25f9630032a34aba5dc45fd5f58351c7f0"}], "stats": {"total": 550, "additions": 447, "deletions": 103}, "files": [{"sha": "2f2c7b154165a2f6b937d0e804f79644ae38c0f7", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86792086646b61342c9417b78b8a535392f1045f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86792086646b61342c9417b78b8a535392f1045f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=86792086646b61342c9417b78b8a535392f1045f", "patch": "@@ -2,8 +2,6 @@\n \n mod init_mask;\n mod provenance_map;\n-#[cfg(test)]\n-mod tests;\n \n use std::borrow::Cow;\n use std::fmt;"}, {"sha": "9a02bc0cc15f80114e0c28a12b85eec54c41ff31", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/init_mask.rs", "status": "modified", "additions": 250, "deletions": 80, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/86792086646b61342c9417b78b8a535392f1045f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86792086646b61342c9417b78b8a535392f1045f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs?ref=86792086646b61342c9417b78b8a535392f1045f", "patch": "@@ -1,3 +1,6 @@\n+#[cfg(test)]\n+mod tests;\n+\n use std::hash;\n use std::iter;\n use std::ops::Range;\n@@ -10,20 +13,185 @@ type Block = u64;\n \n /// A bitmask where each bit refers to the byte with the same index. If the bit is `true`, the byte\n /// is initialized. If it is `false` the byte is uninitialized.\n-// Note: for performance reasons when interning, some of the `InitMask` fields can be partially\n-// hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n-#[derive(Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable)]\n-#[derive(HashStable)]\n+/// The actual bits are only materialized when needed, and we try to keep this data lazy as long as\n+/// possible. Currently, if all the blocks have the same value, then the mask represents either a\n+/// fully initialized or fully uninitialized const allocation, so we can only store that single\n+/// value.\n+#[derive(Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n pub struct InitMask {\n-    blocks: Vec<Block>,\n+    blocks: InitMaskBlocks,\n     len: Size,\n }\n \n+#[derive(Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n+enum InitMaskBlocks {\n+    Lazy {\n+        /// Whether the lazy init mask is fully initialized or uninitialized.\n+        state: bool,\n+    },\n+    Materialized(InitMaskMaterialized),\n+}\n+\n+impl InitMask {\n+    pub fn new(size: Size, state: bool) -> Self {\n+        // Blocks start lazily allocated, until we have to materialize them.\n+        let blocks = InitMaskBlocks::Lazy { state };\n+        InitMask { len: size, blocks }\n+    }\n+\n+    /// Checks whether the `range` is entirely initialized.\n+    ///\n+    /// Returns `Ok(())` if it's initialized. Otherwise returns a range of byte\n+    /// indexes for the first contiguous span of the uninitialized access.\n+    #[inline]\n+    pub fn is_range_initialized(&self, range: AllocRange) -> Result<(), AllocRange> {\n+        let end = range.end();\n+        if end > self.len {\n+            return Err(AllocRange::from(self.len..end));\n+        }\n+\n+        match self.blocks {\n+            InitMaskBlocks::Lazy { state } => {\n+                // Lazily allocated blocks represent the full mask, and cover the requested range by\n+                // definition.\n+                if state { Ok(()) } else { Err(range) }\n+            }\n+            InitMaskBlocks::Materialized(ref blocks) => {\n+                blocks.is_range_initialized(range.start, end)\n+            }\n+        }\n+    }\n+\n+    /// Sets a specified range to a value. If the range is out-of-bounds, the mask will grow to\n+    /// accomodate it entirely.\n+    pub fn set_range(&mut self, range: AllocRange, new_state: bool) {\n+        let start = range.start;\n+        let end = range.end();\n+\n+        let is_full_overwrite = start == Size::ZERO && end >= self.len;\n+\n+        // Optimize the cases of a full init/uninit state, while handling growth if needed.\n+        match self.blocks {\n+            InitMaskBlocks::Lazy { ref mut state } if is_full_overwrite => {\n+                // This is fully overwriting the mask, and we'll still have a single initialization\n+                // state: the blocks can stay lazy.\n+                *state = new_state;\n+                self.len = end;\n+            }\n+            InitMaskBlocks::Materialized(_) if is_full_overwrite => {\n+                // This is also fully overwriting materialized blocks with a single initialization\n+                // state: we'll have no need for these blocks anymore and can make them lazy.\n+                self.blocks = InitMaskBlocks::Lazy { state: new_state };\n+                self.len = end;\n+            }\n+            InitMaskBlocks::Lazy { state } if state == new_state => {\n+                // Here we're partially overwriting the mask but the initialization state doesn't\n+                // change: the blocks can stay lazy.\n+                if end > self.len {\n+                    self.len = end;\n+                }\n+            }\n+            _ => {\n+                // Otherwise, we have a partial overwrite that can result in a mix of initialization\n+                // states, so we'll need materialized blocks.\n+                let len = self.len;\n+                let blocks = self.materialize_blocks();\n+\n+                // There are 3 cases of interest here, if we have:\n+                //\n+                //         [--------]\n+                //         ^        ^\n+                //         0        len\n+                //\n+                // 1) the range to set can be in-bounds:\n+                //\n+                //            xxxx = [start, end]\n+                //         [--------]\n+                //         ^        ^\n+                //         0        len\n+                //\n+                // Here, we'll simply set the single `start` to `end` range.\n+                //\n+                // 2) the range to set can be partially out-of-bounds:\n+                //\n+                //                xxxx = [start, end]\n+                //         [--------]\n+                //         ^        ^\n+                //         0        len\n+                //\n+                // We have 2 subranges to handle:\n+                // - we'll set the existing `start` to `len` range.\n+                // - we'll grow and set the `len` to `end` range.\n+                //\n+                // 3) the range to set can be fully out-of-bounds:\n+                //\n+                //                   ---xxxx = [start, end]\n+                //         [--------]\n+                //         ^        ^\n+                //         0        len\n+                //\n+                // Since we're growing the mask to a single `new_state` value, we consider the gap\n+                // from `len` to `start` to be part of the range, and have a single subrange to\n+                // handle: we'll grow and set the `len` to `end` range.\n+                //\n+                // Note that we have to materialize, set blocks, and grow the mask. We could\n+                // therefore slightly optimize things in situations where these writes overlap.\n+                // However, as of writing this, growing the mask doesn't happen in practice yet, so\n+                // we don't do this micro-optimization.\n+\n+                if end <= len {\n+                    // Handle case 1.\n+                    blocks.set_range_inbounds(start, end, new_state);\n+                } else {\n+                    if start < len {\n+                        // Handle the first subrange of case 2.\n+                        blocks.set_range_inbounds(start, len, new_state);\n+                    }\n+\n+                    // Handle the second subrange of case 2, and case 3.\n+                    blocks.grow(len, end - len, new_state); // `Size` operation\n+                    self.len = end;\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Materializes this mask's blocks when the mask is lazy.\n+    #[inline]\n+    fn materialize_blocks(&mut self) -> &mut InitMaskMaterialized {\n+        if let InitMaskBlocks::Lazy { state } = self.blocks {\n+            self.blocks = InitMaskBlocks::Materialized(InitMaskMaterialized::new(self.len, state));\n+        }\n+\n+        let InitMaskBlocks::Materialized(ref mut blocks) = self.blocks else {\n+            bug!(\"initmask blocks must be materialized here\")\n+        };\n+        blocks\n+    }\n+\n+    /// Returns the initialization state at the specified in-bounds index.\n+    #[inline]\n+    pub fn get(&self, idx: Size) -> bool {\n+        match self.blocks {\n+            InitMaskBlocks::Lazy { state } => state,\n+            InitMaskBlocks::Materialized(ref blocks) => blocks.get(idx),\n+        }\n+    }\n+}\n+\n+/// The actual materialized blocks of the bitmask, when we can't keep the `InitMask` lazy.\n+// Note: for performance reasons when interning, some of the fields can be partially\n+// hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n+#[derive(Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable, HashStable)]\n+struct InitMaskMaterialized {\n+    blocks: Vec<Block>,\n+}\n+\n // Const allocations are only hashed for interning. However, they can be large, making the hashing\n // expensive especially since it uses `FxHash`: it's better suited to short keys, not potentially\n // big buffers like the allocation's init mask. We can partially hash some fields when they're\n // large.\n-impl hash::Hash for InitMask {\n+impl hash::Hash for InitMaskMaterialized {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         const MAX_BLOCKS_TO_HASH: usize = super::MAX_BYTES_TO_HASH / std::mem::size_of::<Block>();\n         const MAX_BLOCKS_LEN: usize = super::MAX_HASHED_BUFFER_LEN / std::mem::size_of::<Block>();\n@@ -41,18 +209,15 @@ impl hash::Hash for InitMask {\n         } else {\n             self.blocks.hash(state);\n         }\n-\n-        // Hash the other fields as usual.\n-        self.len.hash(state);\n     }\n }\n \n-impl InitMask {\n+impl InitMaskMaterialized {\n     pub const BLOCK_SIZE: u64 = 64;\n \n-    pub fn new(size: Size, state: bool) -> Self {\n-        let mut m = InitMask { blocks: vec![], len: Size::ZERO };\n-        m.grow(size, state);\n+    fn new(size: Size, state: bool) -> Self {\n+        let mut m = InitMaskMaterialized { blocks: vec![] };\n+        m.grow(Size::ZERO, size, state);\n         m\n     }\n \n@@ -62,30 +227,25 @@ impl InitMask {\n         // Each bit in a `Block` represents the initialization state of one byte of an allocation,\n         // so we use `.bytes()` here.\n         let bits = bits.bytes();\n-        let a = bits / InitMask::BLOCK_SIZE;\n-        let b = bits % InitMask::BLOCK_SIZE;\n+        let a = bits / Self::BLOCK_SIZE;\n+        let b = bits % Self::BLOCK_SIZE;\n         (usize::try_from(a).unwrap(), usize::try_from(b).unwrap())\n     }\n \n     #[inline]\n     fn size_from_bit_index(block: impl TryInto<u64>, bit: impl TryInto<u64>) -> Size {\n         let block = block.try_into().ok().unwrap();\n         let bit = bit.try_into().ok().unwrap();\n-        Size::from_bytes(block * InitMask::BLOCK_SIZE + bit)\n+        Size::from_bytes(block * Self::BLOCK_SIZE + bit)\n     }\n \n     /// Checks whether the `range` is entirely initialized.\n     ///\n     /// Returns `Ok(())` if it's initialized. Otherwise returns a range of byte\n     /// indexes for the first contiguous span of the uninitialized access.\n     #[inline]\n-    pub fn is_range_initialized(&self, range: AllocRange) -> Result<(), AllocRange> {\n-        let end = range.end();\n-        if end > self.len {\n-            return Err(AllocRange::from(self.len..end));\n-        }\n-\n-        let uninit_start = self.find_bit(range.start, end, false);\n+    fn is_range_initialized(&self, start: Size, end: Size) -> Result<(), AllocRange> {\n+        let uninit_start = self.find_bit(start, end, false);\n \n         match uninit_start {\n             Some(uninit_start) => {\n@@ -96,81 +256,80 @@ impl InitMask {\n         }\n     }\n \n-    pub fn set_range(&mut self, range: AllocRange, new_state: bool) {\n-        let end = range.end();\n-        let len = self.len;\n-        if end > len {\n-            self.grow(end - len, new_state);\n-        }\n-        self.set_range_inbounds(range.start, end, new_state);\n-    }\n-\n     fn set_range_inbounds(&mut self, start: Size, end: Size, new_state: bool) {\n-        let (blocka, bita) = Self::bit_index(start);\n-        let (blockb, bitb) = Self::bit_index(end);\n-        if blocka == blockb {\n-            // First set all bits except the first `bita`,\n-            // then unset the last `64 - bitb` bits.\n-            let range = if bitb == 0 {\n-                u64::MAX << bita\n+        let (block_a, bit_a) = Self::bit_index(start);\n+        let (block_b, bit_b) = Self::bit_index(end);\n+        if block_a == block_b {\n+            // First set all bits except the first `bit_a`,\n+            // then unset the last `64 - bit_b` bits.\n+            let range = if bit_b == 0 {\n+                u64::MAX << bit_a\n             } else {\n-                (u64::MAX << bita) & (u64::MAX >> (64 - bitb))\n+                (u64::MAX << bit_a) & (u64::MAX >> (64 - bit_b))\n             };\n             if new_state {\n-                self.blocks[blocka] |= range;\n+                self.blocks[block_a] |= range;\n             } else {\n-                self.blocks[blocka] &= !range;\n+                self.blocks[block_a] &= !range;\n             }\n             return;\n         }\n         // across block boundaries\n         if new_state {\n-            // Set `bita..64` to `1`.\n-            self.blocks[blocka] |= u64::MAX << bita;\n-            // Set `0..bitb` to `1`.\n-            if bitb != 0 {\n-                self.blocks[blockb] |= u64::MAX >> (64 - bitb);\n+            // Set `bit_a..64` to `1`.\n+            self.blocks[block_a] |= u64::MAX << bit_a;\n+            // Set `0..bit_b` to `1`.\n+            if bit_b != 0 {\n+                self.blocks[block_b] |= u64::MAX >> (64 - bit_b);\n             }\n             // Fill in all the other blocks (much faster than one bit at a time).\n-            for block in (blocka + 1)..blockb {\n+            for block in (block_a + 1)..block_b {\n                 self.blocks[block] = u64::MAX;\n             }\n         } else {\n-            // Set `bita..64` to `0`.\n-            self.blocks[blocka] &= !(u64::MAX << bita);\n-            // Set `0..bitb` to `0`.\n-            if bitb != 0 {\n-                self.blocks[blockb] &= !(u64::MAX >> (64 - bitb));\n+            // Set `bit_a..64` to `0`.\n+            self.blocks[block_a] &= !(u64::MAX << bit_a);\n+            // Set `0..bit_b` to `0`.\n+            if bit_b != 0 {\n+                self.blocks[block_b] &= !(u64::MAX >> (64 - bit_b));\n             }\n             // Fill in all the other blocks (much faster than one bit at a time).\n-            for block in (blocka + 1)..blockb {\n+            for block in (block_a + 1)..block_b {\n                 self.blocks[block] = 0;\n             }\n         }\n     }\n \n     #[inline]\n-    pub fn get(&self, i: Size) -> bool {\n+    fn get(&self, i: Size) -> bool {\n         let (block, bit) = Self::bit_index(i);\n         (self.blocks[block] & (1 << bit)) != 0\n     }\n \n-    fn grow(&mut self, amount: Size, new_state: bool) {\n+    fn grow(&mut self, len: Size, amount: Size, new_state: bool) {\n         if amount.bytes() == 0 {\n             return;\n         }\n         let unused_trailing_bits =\n-            u64::try_from(self.blocks.len()).unwrap() * Self::BLOCK_SIZE - self.len.bytes();\n+            u64::try_from(self.blocks.len()).unwrap() * Self::BLOCK_SIZE - len.bytes();\n+\n+        // If there's not enough capacity in the currently allocated blocks, allocate some more.\n         if amount.bytes() > unused_trailing_bits {\n             let additional_blocks = amount.bytes() / Self::BLOCK_SIZE + 1;\n-            self.blocks.extend(\n-                // FIXME(oli-obk): optimize this by repeating `new_state as Block`.\n-                iter::repeat(0).take(usize::try_from(additional_blocks).unwrap()),\n-            );\n+\n+            // We allocate the blocks to the correct value for the requested init state, so we won't\n+            // have to manually set them with another write.\n+            let block = if new_state { u64::MAX } else { 0 };\n+            self.blocks\n+                .extend(iter::repeat(block).take(usize::try_from(additional_blocks).unwrap()));\n+        }\n+\n+        // New blocks have already been set here, so we only need to set the unused trailing bits,\n+        // if any.\n+        if unused_trailing_bits > 0 {\n+            let in_bounds_tail = Size::from_bytes(unused_trailing_bits);\n+            self.set_range_inbounds(len, len + in_bounds_tail, new_state); // `Size` operation\n         }\n-        let start = self.len;\n-        self.len += amount;\n-        self.set_range_inbounds(start, start + amount, new_state); // `Size` operation\n     }\n \n     /// Returns the index of the first bit in `start..end` (end-exclusive) that is equal to is_init.\n@@ -188,7 +347,7 @@ impl InitMask {\n         /// ```\n         /// Also, if not stated, assume that `is_init = true`, that is, we are searching for the first 1 bit.\n         fn find_bit_fast(\n-            init_mask: &InitMask,\n+            init_mask: &InitMaskMaterialized,\n             start: Size,\n             end: Size,\n             is_init: bool,\n@@ -223,7 +382,7 @@ impl InitMask {\n                     None\n                 } else {\n                     let bit = bits.trailing_zeros();\n-                    Some(InitMask::size_from_bit_index(block, bit))\n+                    Some(InitMaskMaterialized::size_from_bit_index(block, bit))\n                 }\n             }\n \n@@ -253,9 +412,9 @@ impl InitMask {\n             // This provides the desired behavior of searching blocks 0 and 1 for (a),\n             // and searching only block 0 for (b).\n             // There is no concern of overflows since we checked for `start >= end` above.\n-            let (start_block, start_bit) = InitMask::bit_index(start);\n+            let (start_block, start_bit) = InitMaskMaterialized::bit_index(start);\n             let end_inclusive = Size::from_bytes(end.bytes() - 1);\n-            let (end_block_inclusive, _) = InitMask::bit_index(end_inclusive);\n+            let (end_block_inclusive, _) = InitMaskMaterialized::bit_index(end_inclusive);\n \n             // Handle first block: need to skip `start_bit` bits.\n             //\n@@ -340,7 +499,7 @@ impl InitMask {\n \n         #[cfg_attr(not(debug_assertions), allow(dead_code))]\n         fn find_bit_slow(\n-            init_mask: &InitMask,\n+            init_mask: &InitMaskMaterialized,\n             start: Size,\n             end: Size,\n             is_init: bool,\n@@ -436,10 +595,19 @@ impl<'a> Iterator for InitChunkIter<'a> {\n             return None;\n         }\n \n-        let end_of_chunk =\n-            self.init_mask.find_bit(self.start, self.end, !self.is_init).unwrap_or(self.end);\n+        let end_of_chunk = match self.init_mask.blocks {\n+            InitMaskBlocks::Lazy { .. } => {\n+                // If we're iterating over the chunks of lazy blocks, we just emit a single\n+                // full-size chunk.\n+                self.end\n+            }\n+            InitMaskBlocks::Materialized(ref blocks) => {\n+                let end_of_chunk =\n+                    blocks.find_bit(self.start, self.end, !self.is_init).unwrap_or(self.end);\n+                end_of_chunk\n+            }\n+        };\n         let range = self.start..end_of_chunk;\n-\n         let ret =\n             Some(if self.is_init { InitChunk::Init(range) } else { InitChunk::Uninit(range) });\n \n@@ -504,25 +672,27 @@ impl InitMask {\n \n     /// Applies multiple instances of the run-length encoding to the initialization mask.\n     pub fn apply_copy(&mut self, defined: InitCopy, range: AllocRange, repeat: u64) {\n-        // An optimization where we can just overwrite an entire range of initialization\n-        // bits if they are going to be uniformly `1` or `0`.\n+        // An optimization where we can just overwrite an entire range of initialization bits if\n+        // they are going to be uniformly `1` or `0`. If this happens to be a full-range overwrite,\n+        // we won't need materialized blocks either.\n         if defined.ranges.len() <= 1 {\n-            self.set_range_inbounds(\n-                range.start,\n-                range.start + range.size * repeat, // `Size` operations\n-                defined.initial,\n-            );\n+            let start = range.start;\n+            let end = range.start + range.size * repeat; // `Size` operations\n+            self.set_range(AllocRange::from(start..end), defined.initial);\n             return;\n         }\n \n+        // We're about to do one or more partial writes, so we ensure the blocks are materialized.\n+        let blocks = self.materialize_blocks();\n+\n         for mut j in 0..repeat {\n             j *= range.size.bytes();\n             j += range.start.bytes();\n             let mut cur = defined.initial;\n             for range in &defined.ranges {\n                 let old_j = j;\n                 j += range;\n-                self.set_range_inbounds(Size::from_bytes(old_j), Size::from_bytes(j), cur);\n+                blocks.set_range_inbounds(Size::from_bytes(old_j), Size::from_bytes(j), cur);\n                 cur = !cur;\n             }\n         }"}, {"sha": "1a7934bc210dbc07a49df6aa11764bc4a6e4bddc", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/init_mask/tests.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/86792086646b61342c9417b78b8a535392f1045f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86792086646b61342c9417b78b8a535392f1045f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask%2Ftests.rs?ref=86792086646b61342c9417b78b8a535392f1045f", "patch": "@@ -0,0 +1,195 @@\n+use super::*;\n+use crate::mir::interpret::alloc_range;\n+\n+#[test]\n+fn uninit_mask() {\n+    let mut mask = InitMask::new(Size::from_bytes(500), false);\n+    assert!(!mask.get(Size::from_bytes(499)));\n+    mask.set_range(alloc_range(Size::from_bytes(499), Size::from_bytes(1)), true);\n+    assert!(mask.get(Size::from_bytes(499)));\n+    mask.set_range((100..256).into(), true);\n+    for i in 0..100 {\n+        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n+    }\n+    for i in 100..256 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+    for i in 256..499 {\n+        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n+    }\n+}\n+\n+/// Returns the number of materialized blocks for this mask.\n+fn materialized_block_count(mask: &InitMask) -> usize {\n+    match mask.blocks {\n+        InitMaskBlocks::Lazy { .. } => 0,\n+        InitMaskBlocks::Materialized(ref blocks) => blocks.blocks.len(),\n+    }\n+}\n+\n+#[test]\n+fn materialize_mask_within_range() {\n+    // To have spare bits, we use a mask size smaller than its block size of 64.\n+    let mut mask = InitMask::new(Size::from_bytes(16), false);\n+    assert_eq!(materialized_block_count(&mask), 0);\n+\n+    // Forces materialization, but doesn't require growth. This is case #1 documented in the\n+    // `set_range` method.\n+    mask.set_range((8..16).into(), true);\n+    assert_eq!(materialized_block_count(&mask), 1);\n+\n+    for i in 0..8 {\n+        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n+    }\n+    for i in 8..16 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+}\n+\n+#[test]\n+fn grow_within_unused_bits_with_full_overwrite() {\n+    // To have spare bits, we use a mask size smaller than its block size of 64.\n+    let mut mask = InitMask::new(Size::from_bytes(16), true);\n+    for i in 0..16 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+\n+    // Grow without requiring an additional block. Full overwrite.\n+    // This can be fully handled without materialization.\n+    let range = (0..32).into();\n+    mask.set_range(range, true);\n+\n+    for i in 0..32 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+\n+    assert_eq!(materialized_block_count(&mask), 0);\n+}\n+\n+// This test checks that an initmask's spare capacity is correctly used when growing within block\n+// capacity. This can be fully handled without materialization.\n+#[test]\n+fn grow_same_state_within_unused_bits() {\n+    // To have spare bits, we use a mask size smaller than its block size of 64.\n+    let mut mask = InitMask::new(Size::from_bytes(16), true);\n+    for i in 0..16 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+\n+    // Grow without requiring an additional block. The gap between the current length and the\n+    // range's beginning should be set to the same value as the range.\n+    let range = (24..32).into();\n+    mask.set_range(range, true);\n+\n+    // We want to make sure the unused bits in the first block are correct\n+    for i in 16..24 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+\n+    for i in 24..32 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+\n+    assert_eq!(1, mask.range_as_init_chunks((0..32).into()).count());\n+    assert_eq!(materialized_block_count(&mask), 0);\n+}\n+\n+// This is the same test as `grow_same_state_within_unused_bits` but with both init and uninit\n+// states: this forces materialization; otherwise the mask could stay lazy even when needing to\n+// grow.\n+#[test]\n+fn grow_mixed_state_within_unused_bits() {\n+    // To have spare bits, we use a mask size smaller than its block size of 64.\n+    let mut mask = InitMask::new(Size::from_bytes(16), true);\n+    for i in 0..16 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+\n+    // Grow without requiring an additional block. The gap between the current length and the\n+    // range's beginning should be set to the same value as the range. Note: since this is fully\n+    // out-of-bounds of the current mask, this is case #3 described in the `set_range` method.\n+    let range = (24..32).into();\n+    mask.set_range(range, false);\n+\n+    // We want to make sure the unused bits in the first block are correct\n+    for i in 16..24 {\n+        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n+    }\n+\n+    for i in 24..32 {\n+        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n+    }\n+\n+    assert_eq!(1, mask.range_as_init_chunks((0..16).into()).count());\n+    assert_eq!(2, mask.range_as_init_chunks((0..32).into()).count());\n+    assert_eq!(materialized_block_count(&mask), 1);\n+}\n+\n+// This is similar to `grow_mixed_state_within_unused_bits` to force materialization, but the range\n+// to set partially overlaps the mask, so this requires a different growth + write pattern in the\n+// mask.\n+#[test]\n+fn grow_within_unused_bits_with_overlap() {\n+    // To have spare bits, we use a mask size smaller than its block size of 64.\n+    let mut mask = InitMask::new(Size::from_bytes(16), true);\n+    for i in 0..16 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+\n+    // Grow without requiring an additional block, but leave no gap after the current len. Note:\n+    // since this is partially out-of-bounds of the current mask, this is case #2 described in the\n+    // `set_range` method.\n+    let range = (8..24).into();\n+    mask.set_range(range, false);\n+\n+    // We want to make sure the unused bits in the first block are correct\n+    for i in 8..24 {\n+        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n+    }\n+\n+    assert_eq!(1, mask.range_as_init_chunks((0..8).into()).count());\n+    assert_eq!(2, mask.range_as_init_chunks((0..24).into()).count());\n+    assert_eq!(materialized_block_count(&mask), 1);\n+}\n+\n+// Force materialization before a full overwrite: the mask can now become lazy.\n+#[test]\n+fn grow_mixed_state_within_unused_bits_and_full_overwrite() {\n+    // To have spare bits, we use a mask size smaller than its block size of 64.\n+    let mut mask = InitMask::new(Size::from_bytes(16), true);\n+    let range = (0..16).into();\n+    assert!(mask.is_range_initialized(range).is_ok());\n+\n+    // Force materialization.\n+    let range = (8..24).into();\n+    mask.set_range(range, false);\n+    assert!(mask.is_range_initialized(range).is_err());\n+    assert_eq!(materialized_block_count(&mask), 1);\n+\n+    // Full overwrite, lazy blocks would be enough from now on.\n+    let range = (0..32).into();\n+    mask.set_range(range, true);\n+    assert!(mask.is_range_initialized(range).is_ok());\n+\n+    assert_eq!(1, mask.range_as_init_chunks((0..32).into()).count());\n+    assert_eq!(materialized_block_count(&mask), 0);\n+}\n+\n+// Check that growth outside the current capacity can still be lazy: if the init state doesn't\n+// change, we don't need materialized blocks.\n+#[test]\n+fn grow_same_state_outside_capacity() {\n+    // To have spare bits, we use a mask size smaller than its block size of 64.\n+    let mut mask = InitMask::new(Size::from_bytes(16), true);\n+    for i in 0..16 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+    assert_eq!(materialized_block_count(&mask), 0);\n+\n+    // Grow to 10 blocks with the same init state.\n+    let range = (24..640).into();\n+    mask.set_range(range, true);\n+\n+    assert_eq!(1, mask.range_as_init_chunks((0..640).into()).count());\n+    assert_eq!(materialized_block_count(&mask), 0);\n+}"}, {"sha": "c9c3c50c5371e92be300050e09a213dc2defca4b", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/tests.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Ftests.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -1,19 +0,0 @@\n-use super::*;\n-\n-#[test]\n-fn uninit_mask() {\n-    let mut mask = InitMask::new(Size::from_bytes(500), false);\n-    assert!(!mask.get(Size::from_bytes(499)));\n-    mask.set_range(alloc_range(Size::from_bytes(499), Size::from_bytes(1)), true);\n-    assert!(mask.get(Size::from_bytes(499)));\n-    mask.set_range((100..256).into(), true);\n-    for i in 0..100 {\n-        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n-    }\n-    for i in 100..256 {\n-        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n-    }\n-    for i in 256..499 {\n-        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n-    }\n-}"}, {"sha": "8a135039c0665e35ed9a7305f806950f0e1fd13f", "filename": "tests/codegen/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86792086646b61342c9417b78b8a535392f1045f/tests%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86792086646b61342c9417b78b8a535392f1045f/tests%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fconsts.rs?ref=86792086646b61342c9417b78b8a535392f1045f", "patch": "@@ -9,7 +9,7 @@\n // CHECK: @STATIC = {{.*}}, align 4\n \n // This checks the constants from inline_enum_const\n-// CHECK: @alloc_76bfe2f13a3e3b01074971d122eac57e = {{.*}}, align 2\n+// CHECK: @alloc_701ed935fbda2002838d0a2cbbc171e5 = {{.*}}, align 2\n \n // This checks the constants from {low,high}_align_const, they share the same\n // constant, but the alignment differs, so the higher one should be used"}, {"sha": "85523d053b59d7c8f7d31e4919abc6e6eda456b8", "filename": "tests/codegen/remap_path_prefix/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86792086646b61342c9417b78b8a535392f1045f/tests%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86792086646b61342c9417b78b8a535392f1045f/tests%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fremap_path_prefix%2Fmain.rs?ref=86792086646b61342c9417b78b8a535392f1045f", "patch": "@@ -12,7 +12,7 @@ mod aux_mod;\n include!(\"aux_mod.rs\");\n \n // Here we check that the expansion of the file!() macro is mapped.\n-// CHECK: @alloc_92a59126a55aa3c0019b6c8a007fe001 = private unnamed_addr constant <{ [34 x i8] }> <{ [34 x i8] c\"/the/src/remap_path_prefix/main.rs\" }>\n+// CHECK: @alloc_af9d0c7bc6ca3c31bb051d2862714536 = private unnamed_addr constant <{ [34 x i8] }> <{ [34 x i8] c\"/the/src/remap_path_prefix/main.rs\" }>\n pub static FILE_PATH: &'static str = file!();\n \n fn main() {"}]}