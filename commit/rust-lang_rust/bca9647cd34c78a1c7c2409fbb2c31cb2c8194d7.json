{"sha": "bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYTk2NDdjZDM0Yzc4YTFjN2MyNDA5ZmJiMmMzMWNiMmM4MTk0ZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-03T16:31:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-03T16:31:49Z"}, "message": "auto merge of #13904 : pcwalton/rust/box, r=alexcrichton\n\nr? @alexcrichton\r\n\r\nRFC#14 \r\n\r\nIssue #13885.", "tree": {"sha": "005a81de24ffe6144a32a02ca47314d676fd3f14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/005a81de24ffe6144a32a02ca47314d676fd3f14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7", "html_url": "https://github.com/rust-lang/rust/commit/bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "757f106bcc771e10073bfcfa5331ad2bd5f1fe21", "url": "https://api.github.com/repos/rust-lang/rust/commits/757f106bcc771e10073bfcfa5331ad2bd5f1fe21", "html_url": "https://github.com/rust-lang/rust/commit/757f106bcc771e10073bfcfa5331ad2bd5f1fe21"}, {"sha": "7c64f0360774c05dfc819270f8f53266b23b1ced", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c64f0360774c05dfc819270f8f53266b23b1ced", "html_url": "https://github.com/rust-lang/rust/commit/7c64f0360774c05dfc819270f8f53266b23b1ced"}], "stats": {"total": 292, "additions": 211, "deletions": 81}, "files": [{"sha": "48465309f1ed5dd47ad50e34b5cd23a40bba3b64", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7", "patch": "@@ -262,6 +262,7 @@ lets_do_this! {\n     ManagedHeapLangItem,             \"managed_heap\",            managed_heap;\n     ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;\n     GcLangItem,                      \"gc\",                      gc;\n+    OwnedBoxLangItem,                \"owned_box\",               owned_box;\n \n     CovariantTypeItem,               \"covariant_type\",          covariant_type;\n     ContravariantTypeItem,           \"contravariant_type\",      contravariant_type;"}, {"sha": "bd26e2e0c4d4d370f93c902d6ced843088bbbe72", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 161, "deletions": 81, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7", "patch": "@@ -317,7 +317,7 @@ pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n     match ast_ty.node {\n         ast::TyPath(ref path, _, id) => {\n             let a_def = match tcx.def_map.borrow().find(&id) {\n-                None => tcx.sess.span_fatal(\n+                None => tcx.sess.span_bug(\n                     ast_ty.span, format!(\"unbound path {}\", path_to_str(path))),\n                 Some(&d) => d\n             };\n@@ -366,95 +366,173 @@ pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n     }\n }\n \n-// Parses the programmer's textual representation of a type into our\n-// internal notion of a type.\n-pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n-    this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t {\n-\n-    enum PointerTy {\n-        Box,\n-        RPtr(ty::Region),\n-        Uniq\n+/// Converts the given AST type to a built-in type. A \"built-in type\" is, at\n+/// present, either a core numeric type, a string, or `Box`.\n+pub fn ast_ty_to_builtin_ty<AC:AstConv,\n+                            RS:RegionScope>(\n+                            this: &AC,\n+                            rscope: &RS,\n+                            ast_ty: &ast::Ty)\n+                            -> Option<ty::t> {\n+    match ast_ty_to_prim_ty(this.tcx(), ast_ty) {\n+        Some(typ) => return Some(typ),\n+        None => {}\n     }\n \n-    fn ast_ty_to_mt<AC:AstConv, RS:RegionScope>(this: &AC,\n-                                                rscope: &RS,\n-                                                ty: &ast::Ty) -> ty::mt {\n-        ty::mt {ty: ast_ty_to_ty(this, rscope, ty), mutbl: ast::MutImmutable}\n-    }\n+    match ast_ty.node {\n+        ast::TyPath(ref path, _, id) => {\n+            let a_def = match this.tcx().def_map.borrow().find(&id) {\n+                None => this.tcx().sess.span_bug(\n+                    ast_ty.span, format!(\"unbound path {}\", path_to_str(path))),\n+                Some(&d) => d\n+            };\n \n-    // Handle ~, and & being able to mean strs and vecs.\n-    // If a_seq_ty is a str or a vec, make it a str/vec.\n-    // Also handle first-class trait types.\n-    fn mk_pointer<AC:AstConv,\n-                  RS:RegionScope>(\n-                  this: &AC,\n-                  rscope: &RS,\n-                  a_seq_ty: &ast::MutTy,\n-                  ptr_ty: PointerTy,\n-                  constr: |ty::t| -> ty::t)\n-                  -> ty::t {\n-        let tcx = this.tcx();\n-        debug!(\"mk_pointer(ptr_ty={:?})\", ptr_ty);\n-\n-        match a_seq_ty.ty.node {\n-            ast::TyVec(ty) => {\n-                let mut mt = ast_ty_to_mt(this, rscope, ty);\n-                if a_seq_ty.mutbl == ast::MutMutable {\n-                    mt.mutbl = ast::MutMutable;\n-                }\n-                return constr(ty::mk_vec(tcx, mt, None));\n-            }\n-            ast::TyPath(ref path, ref bounds, id) => {\n-                // Note that the \"bounds must be empty if path is not a trait\"\n-                // restriction is enforced in the below case for ty_path, which\n-                // will run after this as long as the path isn't a trait.\n-                match tcx.def_map.borrow().find(&id) {\n-                    Some(&ast::DefPrimTy(ast::TyStr)) => {\n-                        check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                        match ptr_ty {\n-                            Uniq => {\n-                                return ty::mk_uniq(tcx, ty::mk_str(tcx));\n-                            }\n-                            RPtr(r) => {\n-                                return ty::mk_str_slice(tcx, r, ast::MutImmutable);\n-                            }\n-                            _ => tcx.sess.span_err(path.span,\n-                                                   format!(\"managed strings are not supported\")),\n-                        }\n+            // FIXME(#12938): This is a hack until we have full support for\n+            // DST.\n+            match a_def {\n+                ast::DefTy(did) | ast::DefStruct(did)\n+                        if Some(did) == this.tcx().lang_items.owned_box() => {\n+                    if path.segments\n+                           .iter()\n+                           .flat_map(|s| s.types.iter())\n+                           .len() > 1 {\n+                        this.tcx()\n+                            .sess\n+                            .span_err(path.span,\n+                                      \"`Box` has only one type parameter\")\n                     }\n-                    Some(&ast::DefTrait(trait_def_id)) => {\n-                        let result = ast_path_to_trait_ref(\n-                            this, rscope, trait_def_id, None, path);\n-                        let trait_store = match ptr_ty {\n-                            Uniq => ty::UniqTraitStore,\n-                            RPtr(r) => {\n-                                ty::RegionTraitStore(r, a_seq_ty.mutbl)\n-                            }\n-                            _ => {\n-                                tcx.sess.span_err(\n-                                    path.span,\n-                                    \"~trait or &trait are the only supported \\\n-                                     forms of casting-to-trait\");\n-                                return ty::mk_err();\n-                            }\n+\n+                    for inner_ast_type in path.segments\n+                                              .iter()\n+                                              .flat_map(|s| s.types.iter()) {\n+                        let mt = ast::MutTy {\n+                            ty: *inner_ast_type,\n+                            mutbl: ast::MutImmutable,\n                         };\n-                        let bounds = conv_builtin_bounds(this.tcx(), bounds, trait_store);\n-                        return ty::mk_trait(tcx,\n-                                            result.def_id,\n-                                            result.substs.clone(),\n-                                            trait_store,\n-                                            bounds);\n+                        return Some(mk_pointer(this,\n+                                               rscope,\n+                                               &mt,\n+                                               Uniq,\n+                                               |typ| {\n+                            match ty::get(typ).sty {\n+                                ty::ty_str => {\n+                                    this.tcx()\n+                                        .sess\n+                                        .span_err(path.span,\n+                                                  \"`Box<str>` is not a type\");\n+                                    ty::mk_err()\n+                                }\n+                                ty::ty_vec(_, None) => {\n+                                    this.tcx()\n+                                        .sess\n+                                        .span_err(path.span,\n+                                                  \"`Box<[T]>` is not a type\");\n+                                    ty::mk_err()\n+                                }\n+                                _ => ty::mk_uniq(this.tcx(), typ),\n+                            }\n+                        }))\n                     }\n-                    _ => {}\n+                    this.tcx().sess.span_bug(path.span,\n+                                             \"not enough type parameters \\\n+                                              supplied to `Box<T>`\")\n                 }\n+                _ => None\n             }\n-            _ => {}\n         }\n+        _ => None\n+    }\n+}\n+\n+enum PointerTy {\n+    Box,\n+    RPtr(ty::Region),\n+    Uniq\n+}\n+\n+fn ast_ty_to_mt<AC:AstConv, RS:RegionScope>(this: &AC,\n+                                            rscope: &RS,\n+                                            ty: &ast::Ty) -> ty::mt {\n+    ty::mt {ty: ast_ty_to_ty(this, rscope, ty), mutbl: ast::MutImmutable}\n+}\n+\n+// Handle `~`, `Box`, and `&` being able to mean strs and vecs.\n+// If a_seq_ty is a str or a vec, make it a str/vec.\n+// Also handle first-class trait types.\n+fn mk_pointer<AC:AstConv,\n+              RS:RegionScope>(\n+              this: &AC,\n+              rscope: &RS,\n+              a_seq_ty: &ast::MutTy,\n+              ptr_ty: PointerTy,\n+              constr: |ty::t| -> ty::t)\n+              -> ty::t {\n+    let tcx = this.tcx();\n+    debug!(\"mk_pointer(ptr_ty={:?})\", ptr_ty);\n \n-        constr(ast_ty_to_ty(this, rscope, a_seq_ty.ty))\n+    match a_seq_ty.ty.node {\n+        ast::TyVec(ty) => {\n+            let mut mt = ast_ty_to_mt(this, rscope, ty);\n+            if a_seq_ty.mutbl == ast::MutMutable {\n+                mt.mutbl = ast::MutMutable;\n+            }\n+            return constr(ty::mk_vec(tcx, mt, None));\n+        }\n+        ast::TyPath(ref path, ref bounds, id) => {\n+            // Note that the \"bounds must be empty if path is not a trait\"\n+            // restriction is enforced in the below case for ty_path, which\n+            // will run after this as long as the path isn't a trait.\n+            match tcx.def_map.borrow().find(&id) {\n+                Some(&ast::DefPrimTy(ast::TyStr)) => {\n+                    check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                    match ptr_ty {\n+                        Uniq => {\n+                            return constr(ty::mk_str(tcx));\n+                        }\n+                        RPtr(r) => {\n+                            return ty::mk_str_slice(tcx, r, ast::MutImmutable);\n+                        }\n+                        _ => tcx.sess.span_err(path.span,\n+                                               format!(\"managed strings are not supported\")),\n+                    }\n+                }\n+                Some(&ast::DefTrait(trait_def_id)) => {\n+                    let result = ast_path_to_trait_ref(\n+                        this, rscope, trait_def_id, None, path);\n+                    let trait_store = match ptr_ty {\n+                        Uniq => ty::UniqTraitStore,\n+                        RPtr(r) => {\n+                            ty::RegionTraitStore(r, a_seq_ty.mutbl)\n+                        }\n+                        _ => {\n+                            tcx.sess.span_err(\n+                                path.span,\n+                                \"~trait or &trait are the only supported \\\n+                                 forms of casting-to-trait\");\n+                            return ty::mk_err();\n+                        }\n+                    };\n+                    let bounds = conv_builtin_bounds(this.tcx(), bounds, trait_store);\n+                    return ty::mk_trait(tcx,\n+                                        result.def_id,\n+                                        result.substs.clone(),\n+                                        trait_store,\n+                                        bounds);\n+                }\n+                _ => {}\n+            }\n+        }\n+        _ => {}\n     }\n \n+    constr(ast_ty_to_ty(this, rscope, a_seq_ty.ty))\n+}\n+\n+// Parses the programmer's textual representation of a type into our\n+// internal notion of a type.\n+pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n+    this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t {\n+\n     let tcx = this.tcx();\n \n     let mut ast_ty_to_ty_cache = tcx.ast_ty_to_ty_cache.borrow_mut();\n@@ -471,7 +549,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n     ast_ty_to_ty_cache.insert(ast_ty.id, ty::atttce_unresolved);\n     drop(ast_ty_to_ty_cache);\n \n-    let typ = ast_ty_to_prim_ty(tcx, ast_ty).unwrap_or_else(|| match ast_ty.node {\n+    let typ = ast_ty_to_builtin_ty(this, rscope, ast_ty).unwrap_or_else(|| {\n+        match ast_ty.node {\n             ast::TyNil => ty::mk_nil(),\n             ast::TyBot => ty::mk_bot(),\n             ast::TyBox(ty) => {\n@@ -555,7 +634,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             }\n             ast::TyPath(ref path, ref bounds, id) => {\n                 let a_def = match tcx.def_map.borrow().find(&id) {\n-                    None => tcx.sess.span_fatal(\n+                    None => tcx.sess.span_bug(\n                         ast_ty.span, format!(\"unbound path {}\", path_to_str(path))),\n                     Some(&d) => d\n                 };\n@@ -639,7 +718,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 // and will not descend into this routine.\n                 this.ty_infer(ast_ty.span)\n             }\n-        });\n+        }\n+    });\n \n     tcx.ast_ty_to_ty_cache.borrow_mut().insert(ast_ty.id, ty::atttce_resolved(typ));\n     return typ;"}, {"sha": "826ada8f2521f1756fd8d55e85bd9c743ee9f4f1", "filename": "src/libstd/owned.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7/src%2Flibstd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7/src%2Flibstd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fowned.rs?ref=bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7", "patch": "@@ -26,6 +26,14 @@ pub static HEAP: () = ();\n #[cfg(test)]\n pub static HEAP: () = ();\n \n+/// A type that represents a uniquely-owned value.\n+#[lang=\"owned_box\"]\n+#[cfg(not(test))]\n+pub struct Box<T>(*T);\n+\n+#[cfg(test)]\n+pub struct Box<T>(*T);\n+\n #[cfg(not(test))]\n impl<T:Eq> Eq for ~T {\n     #[inline]"}, {"sha": "0202695841e1ab82f0893062edab0af34c977d75", "filename": "src/test/run-pass/new-box.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7/src%2Ftest%2Frun-pass%2Fnew-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7/src%2Ftest%2Frun-pass%2Fnew-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-box.rs?ref=bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::owned::Box;\n+\n+fn f(x: Box<int>) {\n+    let y: &int = x;\n+    println!(\"{}\", *x);\n+    println!(\"{}\", *y);\n+}\n+\n+trait Trait {\n+    fn printme(&self);\n+}\n+\n+struct Struct;\n+\n+impl Trait for Struct {\n+    fn printme(&self) {\n+        println!(\"hello world!\");\n+    }\n+}\n+\n+fn g(x: Box<Trait>) {\n+    x.printme();\n+    let y: &Trait = x;\n+    y.printme();\n+}\n+\n+fn main() {\n+    f(box 1234);\n+    g(box Struct as Box<Trait>);\n+}\n+"}]}