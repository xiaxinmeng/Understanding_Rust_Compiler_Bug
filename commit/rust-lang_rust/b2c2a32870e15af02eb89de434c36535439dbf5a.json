{"sha": "b2c2a32870e15af02eb89de434c36535439dbf5a", "node_id": "C_kwDOAAsO6NoAKGIyYzJhMzI4NzBlMTVhZjAyZWI4OWRlNDM0YzM2NTM1NDM5ZGJmNWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-28T13:18:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-28T13:18:22Z"}, "message": "Auto merge of #95976 - b-naber:valtree-constval-conversion, r=oli-obk\n\nImplement Valtree to ConstValue conversion\n\nOnce we start to use `ValTree`s in the type system we will need to be able to convert them into `ConstValue` instances, which we want to continue to use after MIR construction.\n\nr? `@oli-obk`\n\ncc `@RalfJung`", "tree": {"sha": "ba0c7a3ceade56983d473ea859a3adb3af4bd973", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba0c7a3ceade56983d473ea859a3adb3af4bd973"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2c2a32870e15af02eb89de434c36535439dbf5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2c2a32870e15af02eb89de434c36535439dbf5a", "html_url": "https://github.com/rust-lang/rust/commit/b2c2a32870e15af02eb89de434c36535439dbf5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2c2a32870e15af02eb89de434c36535439dbf5a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bfeffd55bbc7d653d2df7ad265746bafe595a96", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bfeffd55bbc7d653d2df7ad265746bafe595a96", "html_url": "https://github.com/rust-lang/rust/commit/3bfeffd55bbc7d653d2df7ad265746bafe595a96"}, {"sha": "ef5f07256cfa4e1f43a18acb45e0d8108f8471a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef5f07256cfa4e1f43a18acb45e0d8108f8471a4", "html_url": "https://github.com/rust-lang/rust/commit/ef5f07256cfa4e1f43a18acb45e0d8108f8471a4"}], "stats": {"total": 829, "additions": 667, "deletions": 162}, "files": [{"sha": "38fecf7232ebc704436755d752b000401df2afbb", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=b2c2a32870e15af02eb89de434c36535439dbf5a", "patch": "@@ -106,6 +106,7 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n \n /// This function converts an interpreter value into a constant that is meant for use in the\n /// type system.\n+#[instrument(skip(ecx), level = \"debug\")]\n pub(super) fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, 'tcx>,\n     op: &OpTy<'tcx>,\n@@ -140,21 +141,26 @@ pub(super) fn op_to_const<'tcx>(\n         op.try_as_mplace()\n     };\n \n+    debug!(?immediate);\n+\n     // We know `offset` is relative to the allocation, so we can use `into_parts`.\n-    let to_const_value = |mplace: &MPlaceTy<'_>| match mplace.ptr.into_parts() {\n-        (Some(alloc_id), offset) => {\n-            let alloc = ecx.tcx.global_alloc(alloc_id).unwrap_memory();\n-            ConstValue::ByRef { alloc, offset }\n-        }\n-        (None, offset) => {\n-            assert!(mplace.layout.is_zst());\n-            assert_eq!(\n-                offset.bytes() % mplace.layout.align.abi.bytes(),\n-                0,\n-                \"this MPlaceTy must come from a validated constant, thus we can assume the \\\n+    let to_const_value = |mplace: &MPlaceTy<'_>| {\n+        debug!(\"to_const_value(mplace: {:?})\", mplace);\n+        match mplace.ptr.into_parts() {\n+            (Some(alloc_id), offset) => {\n+                let alloc = ecx.tcx.global_alloc(alloc_id).unwrap_memory();\n+                ConstValue::ByRef { alloc, offset }\n+            }\n+            (None, offset) => {\n+                assert!(mplace.layout.is_zst());\n+                assert_eq!(\n+                    offset.bytes() % mplace.layout.align.abi.bytes(),\n+                    0,\n+                    \"this MPlaceTy must come from a validated constant, thus we can assume the \\\n                 alignment is correct\",\n-            );\n-            ConstValue::Scalar(Scalar::ZST)\n+                );\n+                ConstValue::Scalar(Scalar::ZST)\n+            }\n         }\n     };\n     match immediate {\n@@ -166,6 +172,7 @@ pub(super) fn op_to_const<'tcx>(\n                 ScalarMaybeUninit::Uninit => to_const_value(&op.assert_mem_place()),\n             },\n             Immediate::ScalarPair(a, b) => {\n+                debug!(\"ScalarPair(a: {:?}, b: {:?})\", a, b);\n                 // We know `offset` is relative to the allocation, so we can use `into_parts`.\n                 let (data, start) =\n                     match ecx.scalar_to_ptr(a.check_init().unwrap()).unwrap().into_parts() {\n@@ -209,7 +216,10 @@ fn turn_into_const_value<'tcx>(\n     );\n \n     // Turn this into a proper constant.\n-    op_to_const(&ecx, &mplace.into())\n+    let const_val = op_to_const(&ecx, &mplace.into());\n+    debug!(?const_val);\n+\n+    const_val\n }\n \n pub fn eval_to_const_value_raw_provider<'tcx>("}, {"sha": "96c18d488ee8c1e38aa6186cdad0be6f64d6190d", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 6, "deletions": 130, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=b2c2a32870e15af02eb89de434c36535439dbf5a", "patch": "@@ -3,29 +3,26 @@\n use std::convert::TryFrom;\n \n use rustc_hir::Mutability;\n-use rustc_middle::ty::layout::HasTyCtxt;\n+use rustc_middle::mir;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_middle::{\n-    mir::{self, interpret::ConstAlloc},\n-    ty::ScalarInt,\n-};\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n-use rustc_target::abi::VariantIdx;\n \n use crate::interpret::{\n-    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MPlaceTy,\n-    MemPlaceMeta, Scalar,\n+    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MemPlaceMeta,\n+    Scalar,\n };\n \n mod error;\n mod eval_queries;\n mod fn_queries;\n mod machine;\n+mod valtrees;\n \n pub use error::*;\n pub use eval_queries::*;\n pub use fn_queries::*;\n pub use machine::*;\n+pub(crate) use valtrees::{const_to_valtree, valtree_to_const_value};\n \n pub(crate) fn const_caller_location(\n     tcx: TyCtxt<'_>,\n@@ -41,128 +38,6 @@ pub(crate) fn const_caller_location(\n     ConstValue::Scalar(Scalar::from_maybe_pointer(loc_place.ptr, &tcx))\n }\n \n-/// Convert an evaluated constant to a type level constant\n-pub(crate) fn const_to_valtree<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    raw: ConstAlloc<'tcx>,\n-) -> Option<ty::ValTree<'tcx>> {\n-    let ecx = mk_eval_cx(\n-        tcx, DUMMY_SP, param_env,\n-        // It is absolutely crucial for soundness that\n-        // we do not read from static items or other mutable memory.\n-        false,\n-    );\n-    let place = ecx.raw_const_to_mplace(raw).unwrap();\n-    const_to_valtree_inner(&ecx, &place)\n-}\n-\n-#[instrument(skip(ecx), level = \"debug\")]\n-fn branches<'tcx>(\n-    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n-    place: &MPlaceTy<'tcx>,\n-    n: usize,\n-    variant: Option<VariantIdx>,\n-) -> Option<ty::ValTree<'tcx>> {\n-    let place = match variant {\n-        Some(variant) => ecx.mplace_downcast(&place, variant).unwrap(),\n-        None => *place,\n-    };\n-    let variant = variant.map(|variant| Some(ty::ValTree::Leaf(ScalarInt::from(variant.as_u32()))));\n-    debug!(?place, ?variant);\n-\n-    let fields = (0..n).map(|i| {\n-        let field = ecx.mplace_field(&place, i).unwrap();\n-        const_to_valtree_inner(ecx, &field)\n-    });\n-    // For enums, we prepend their variant index before the variant's fields so we can figure out\n-    // the variant again when just seeing a valtree.\n-    let branches = variant.into_iter().chain(fields);\n-    Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n-}\n-\n-fn slice_branches<'tcx>(\n-    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n-    place: &MPlaceTy<'tcx>,\n-) -> Option<ty::ValTree<'tcx>> {\n-    let n = place.len(&ecx.tcx()).expect(&format!(\"expected to use len of place {:?}\", place));\n-    let branches = (0..n).map(|i| {\n-        let place_elem = ecx.mplace_index(place, i).unwrap();\n-        const_to_valtree_inner(ecx, &place_elem)\n-    });\n-\n-    Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n-}\n-\n-#[instrument(skip(ecx), level = \"debug\")]\n-fn const_to_valtree_inner<'tcx>(\n-    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n-    place: &MPlaceTy<'tcx>,\n-) -> Option<ty::ValTree<'tcx>> {\n-    match place.layout.ty.kind() {\n-        ty::FnDef(..) => Some(ty::ValTree::zst()),\n-        ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n-            let val = ecx.read_immediate(&place.into()).unwrap();\n-            let val = val.to_scalar().unwrap();\n-            Some(ty::ValTree::Leaf(val.assert_int()))\n-        }\n-\n-        // Raw pointers are not allowed in type level constants, as we cannot properly test them for\n-        // equality at compile-time (see `ptr_guaranteed_eq`/`_ne`).\n-        // Technically we could allow function pointers (represented as `ty::Instance`), but this is not guaranteed to\n-        // agree with runtime equality tests.\n-        ty::FnPtr(_) | ty::RawPtr(_) => None,\n-\n-        ty::Ref(_, _, _)  => {\n-            let derefd_place = ecx.deref_operand(&place.into()).unwrap_or_else(|e| bug!(\"couldn't deref {:?}, error: {:?}\", place, e));\n-            debug!(?derefd_place);\n-\n-            const_to_valtree_inner(ecx, &derefd_place)\n-        }\n-\n-        ty::Str | ty::Slice(_) | ty::Array(_, _) => {\n-            let valtree = slice_branches(ecx, place);\n-            debug!(?valtree);\n-\n-            valtree\n-        }\n-        // Trait objects are not allowed in type level constants, as we have no concept for\n-        // resolving their backing type, even if we can do that at const eval time. We may\n-        // hypothetically be able to allow `dyn StructuralEq` trait objects in the future,\n-        // but it is unclear if this is useful.\n-        ty::Dynamic(..) => None,\n-\n-        ty::Tuple(substs) => branches(ecx, place, substs.len(), None),\n-\n-        ty::Adt(def, _) => {\n-            if def.variants().is_empty() {\n-                bug!(\"uninhabited types should have errored and never gotten converted to valtree\")\n-            }\n-\n-            let variant = ecx.read_discriminant(&place.into()).unwrap().1;\n-\n-            branches(ecx, place, def.variant(variant).fields.len(), def.is_enum().then_some(variant))\n-        }\n-\n-        ty::Never\n-        | ty::Error(_)\n-        | ty::Foreign(..)\n-        | ty::Infer(ty::FreshIntTy(_))\n-        | ty::Infer(ty::FreshFloatTy(_))\n-        | ty::Projection(..)\n-        | ty::Param(_)\n-        | ty::Bound(..)\n-        | ty::Placeholder(..)\n-        // FIXME(oli-obk): we could look behind opaque types\n-        | ty::Opaque(..)\n-        | ty::Infer(_)\n-        // FIXME(oli-obk): we can probably encode closures just like structs\n-        | ty::Closure(..)\n-        | ty::Generator(..)\n-        | ty::GeneratorWitness(..) => None,\n-    }\n-}\n-\n /// This function should never fail for validated constants. However, it is also invoked from the\n /// pretty printer which might attempt to format invalid constants and in that case it might fail.\n pub(crate) fn try_destructure_const<'tcx>(\n@@ -202,6 +77,7 @@ pub(crate) fn try_destructure_const<'tcx>(\n     Ok(mir::DestructuredConst { variant, fields })\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n pub(crate) fn deref_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,"}, {"sha": "374179d0cc24da0f7f230518ade0909d178674e4", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "added", "additions": 459, "deletions": 0, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=b2c2a32870e15af02eb89de434c36535439dbf5a", "patch": "@@ -0,0 +1,459 @@\n+use super::eval_queries::{mk_eval_cx, op_to_const};\n+use super::machine::CompileTimeEvalContext;\n+use crate::interpret::{\n+    intern_const_alloc_recursive, ConstValue, ImmTy, Immediate, InternKind, MemPlaceMeta,\n+    MemoryKind, PlaceTy, Scalar, ScalarMaybeUninit,\n+};\n+use rustc_middle::mir::interpret::ConstAlloc;\n+use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n+use rustc_span::source_map::DUMMY_SP;\n+use rustc_target::abi::{Align, VariantIdx};\n+\n+use crate::interpret::MPlaceTy;\n+use crate::interpret::Value;\n+\n+/// Convert an evaluated constant to a type level constant\n+#[instrument(skip(tcx), level = \"debug\")]\n+pub(crate) fn const_to_valtree<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    raw: ConstAlloc<'tcx>,\n+) -> Option<ty::ValTree<'tcx>> {\n+    let ecx = mk_eval_cx(\n+        tcx, DUMMY_SP, param_env,\n+        // It is absolutely crucial for soundness that\n+        // we do not read from static items or other mutable memory.\n+        false,\n+    );\n+    let place = ecx.raw_const_to_mplace(raw).unwrap();\n+    const_to_valtree_inner(&ecx, &place)\n+}\n+\n+#[instrument(skip(ecx), level = \"debug\")]\n+fn branches<'tcx>(\n+    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n+    place: &MPlaceTy<'tcx>,\n+    n: usize,\n+    variant: Option<VariantIdx>,\n+) -> Option<ty::ValTree<'tcx>> {\n+    let place = match variant {\n+        Some(variant) => ecx.mplace_downcast(&place, variant).unwrap(),\n+        None => *place,\n+    };\n+    let variant = variant.map(|variant| Some(ty::ValTree::Leaf(ScalarInt::from(variant.as_u32()))));\n+    debug!(?place, ?variant);\n+\n+    let fields = (0..n).map(|i| {\n+        let field = ecx.mplace_field(&place, i).unwrap();\n+        const_to_valtree_inner(ecx, &field)\n+    });\n+    // For enums, we preped their variant index before the variant's fields so we can figure out\n+    // the variant again when just seeing a valtree.\n+    let branches = variant.into_iter().chain(fields);\n+    Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n+}\n+\n+#[instrument(skip(ecx), level = \"debug\")]\n+fn slice_branches<'tcx>(\n+    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n+    place: &MPlaceTy<'tcx>,\n+) -> Option<ty::ValTree<'tcx>> {\n+    let n = place.len(&ecx.tcx.tcx).expect(&format!(\"expected to use len of place {:?}\", place));\n+    let branches = (0..n).map(|i| {\n+        let place_elem = ecx.mplace_index(place, i).unwrap();\n+        const_to_valtree_inner(ecx, &place_elem)\n+    });\n+\n+    Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n+}\n+\n+#[instrument(skip(ecx), level = \"debug\")]\n+fn const_to_valtree_inner<'tcx>(\n+    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n+    place: &MPlaceTy<'tcx>,\n+) -> Option<ty::ValTree<'tcx>> {\n+    match place.layout.ty.kind() {\n+        ty::FnDef(..) => Some(ty::ValTree::zst()),\n+        ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n+            let val = ecx.read_immediate(&place.into()).unwrap();\n+            let val = val.to_scalar().unwrap();\n+            Some(ty::ValTree::Leaf(val.assert_int()))\n+        }\n+\n+        // Raw pointers are not allowed in type level constants, as we cannot properly test them for\n+        // equality at compile-time (see `ptr_guaranteed_eq`/`_ne`).\n+        // Technically we could allow function pointers (represented as `ty::Instance`), but this is not guaranteed to\n+        // agree with runtime equality tests.\n+        ty::FnPtr(_) | ty::RawPtr(_) => None,\n+\n+        ty::Ref(_, _, _)  => {\n+            let derefd_place = ecx.deref_operand(&place.into()).unwrap_or_else(|e| bug!(\"couldn't deref {:?}, error: {:?}\", place, e));\n+            debug!(?derefd_place);\n+\n+            const_to_valtree_inner(ecx, &derefd_place)\n+        }\n+\n+        ty::Str | ty::Slice(_) | ty::Array(_, _) => {\n+            let valtree = slice_branches(ecx, place);\n+            debug!(?valtree);\n+\n+            valtree\n+        }\n+        // Trait objects are not allowed in type level constants, as we have no concept for\n+        // resolving their backing type, even if we can do that at const eval time. We may\n+        // hypothetically be able to allow `dyn StructuralEq` trait objects in the future,\n+        // but it is unclear if this is useful.\n+        ty::Dynamic(..) => None,\n+\n+        ty::Tuple(substs) => branches(ecx, place, substs.len(), None),\n+\n+        ty::Adt(def, _) => {\n+            if def.is_union() {\n+                return None\n+            } else if def.variants().is_empty() {\n+                bug!(\"uninhabited types should have errored and never gotten converted to valtree\")\n+            }\n+\n+            let variant = ecx.read_discriminant(&place.into()).unwrap().1;\n+\n+            branches(ecx, place, def.variant(variant).fields.len(), def.is_enum().then_some(variant))\n+        }\n+\n+        ty::Never\n+        | ty::Error(_)\n+        | ty::Foreign(..)\n+        | ty::Infer(ty::FreshIntTy(_))\n+        | ty::Infer(ty::FreshFloatTy(_))\n+        | ty::Projection(..)\n+        | ty::Param(_)\n+        | ty::Bound(..)\n+        | ty::Placeholder(..)\n+        // FIXME(oli-obk): we could look behind opaque types\n+        | ty::Opaque(..)\n+        | ty::Infer(_)\n+        // FIXME(oli-obk): we can probably encode closures just like structs\n+        | ty::Closure(..)\n+        | ty::Generator(..)\n+        | ty::GeneratorWitness(..) => None,\n+    }\n+}\n+\n+#[instrument(skip(ecx), level = \"debug\")]\n+fn create_mplace_from_layout<'tcx>(\n+    ecx: &mut CompileTimeEvalContext<'tcx, 'tcx>,\n+    ty: Ty<'tcx>,\n+) -> MPlaceTy<'tcx> {\n+    let tcx = ecx.tcx;\n+    let param_env = ecx.param_env;\n+    let layout = tcx.layout_of(param_env.and(ty)).unwrap();\n+    debug!(?layout);\n+\n+    ecx.allocate(layout, MemoryKind::Stack).unwrap()\n+}\n+\n+// Walks custom DSTs and gets the type of the unsized field and the number of elements\n+// in the unsized field.\n+fn get_info_on_unsized_field<'tcx>(\n+    ty: Ty<'tcx>,\n+    valtree: ty::ValTree<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+) -> (Ty<'tcx>, usize) {\n+    let mut last_valtree = valtree;\n+    let tail = tcx.struct_tail_with_normalize(\n+        ty,\n+        |ty| ty,\n+        || {\n+            let branches = last_valtree.unwrap_branch();\n+            last_valtree = branches[branches.len() - 1];\n+            debug!(?branches, ?last_valtree);\n+        },\n+    );\n+    let unsized_inner_ty = match tail.kind() {\n+        ty::Slice(t) => *t,\n+        ty::Str => tail,\n+        _ => bug!(\"expected Slice or Str\"),\n+    };\n+\n+    // Have to adjust type for ty::Str\n+    let unsized_inner_ty = match unsized_inner_ty.kind() {\n+        ty::Str => tcx.mk_ty(ty::Uint(ty::UintTy::U8)),\n+        _ => unsized_inner_ty,\n+    };\n+\n+    // Get the number of elements in the unsized field\n+    let num_elems = last_valtree.unwrap_branch().len();\n+\n+    (unsized_inner_ty, num_elems)\n+}\n+\n+#[instrument(skip(ecx), level = \"debug\")]\n+fn create_pointee_place<'tcx>(\n+    ecx: &mut CompileTimeEvalContext<'tcx, 'tcx>,\n+    ty: Ty<'tcx>,\n+    valtree: ty::ValTree<'tcx>,\n+) -> MPlaceTy<'tcx> {\n+    let tcx = ecx.tcx.tcx;\n+\n+    if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty()) {\n+        // We need to create `Allocation`s for custom DSTs\n+\n+        let (unsized_inner_ty, num_elems) = get_info_on_unsized_field(ty, valtree, tcx);\n+        let unsized_inner_ty = match unsized_inner_ty.kind() {\n+            ty::Str => tcx.mk_ty(ty::Uint(ty::UintTy::U8)),\n+            _ => unsized_inner_ty,\n+        };\n+        let unsized_inner_ty_size =\n+            tcx.layout_of(ty::ParamEnv::empty().and(unsized_inner_ty)).unwrap().layout.size();\n+        debug!(?unsized_inner_ty, ?unsized_inner_ty_size, ?num_elems);\n+\n+        // for custom DSTs only the last field/element is unsized, but we need to also allocate\n+        // space for the other fields/elements\n+        let layout = tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap();\n+        let size_of_sized_part = layout.layout.size();\n+\n+        // Get the size of the memory behind the DST\n+        let dst_size = unsized_inner_ty_size.checked_mul(num_elems as u64, &tcx).unwrap();\n+\n+        let ptr = ecx\n+            .allocate_ptr(\n+                size_of_sized_part.checked_add(dst_size, &tcx).unwrap(),\n+                Align::from_bytes(1).unwrap(),\n+                MemoryKind::Stack,\n+            )\n+            .unwrap();\n+        debug!(?ptr);\n+\n+        let mut place = MPlaceTy::from_aligned_ptr(ptr.into(), layout);\n+        place.meta = MemPlaceMeta::Meta(Scalar::from_u64(num_elems as u64));\n+        debug!(?place);\n+\n+        place\n+    } else {\n+        create_mplace_from_layout(ecx, ty)\n+    }\n+}\n+\n+/// Converts a `ValTree` to a `ConstValue`, which is needed after mir\n+/// construction has finished.\n+// FIXME Merge `valtree_to_const_value` and `fill_place_recursively` into one function\n+#[instrument(skip(tcx), level = \"debug\")]\n+pub fn valtree_to_const_value<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    valtree: ty::ValTree<'tcx>,\n+) -> ConstValue<'tcx> {\n+    // Basic idea: We directly construct `Scalar` values from trivial `ValTree`s\n+    // (those for constants with type bool, int, uint, float or char).\n+    // For all other types we create an `MPlace` and fill that by walking\n+    // the `ValTree` and using `place_projection` and `place_field` to\n+    // create inner `MPlace`s which are filled recursively.\n+    // FIXME Does this need an example?\n+\n+    let (param_env, ty) = param_env_ty.into_parts();\n+    let mut ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n+\n+    match ty.kind() {\n+        ty::FnDef(..) => {\n+            assert!(valtree.unwrap_branch().is_empty());\n+            ConstValue::Scalar(Scalar::ZST)\n+        }\n+        ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => match valtree {\n+            ty::ValTree::Leaf(scalar_int) => ConstValue::Scalar(Scalar::Int(scalar_int)),\n+            ty::ValTree::Branch(_) => bug!(\n+                \"ValTrees for Bool, Int, Uint, Float or Char should have the form ValTree::Leaf\"\n+            ),\n+        },\n+        ty::Ref(_, _, _) | ty::Tuple(_) | ty::Array(_, _) | ty::Adt(..) => {\n+            let mut place = match ty.kind() {\n+                ty::Ref(_, inner_ty, _) => {\n+                    // Need to create a place for the pointee to fill for Refs\n+                    create_pointee_place(&mut ecx, *inner_ty, valtree)\n+                }\n+                _ => create_mplace_from_layout(&mut ecx, ty),\n+            };\n+            debug!(?place);\n+\n+            fill_place_recursively(&mut ecx, &mut place, valtree);\n+            dump_place(&ecx, place.into());\n+            intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &place).unwrap();\n+\n+            let const_val = match ty.kind() {\n+                ty::Ref(_, _, _) => {\n+                    let ref_place = place.to_ref(&tcx);\n+                    let imm =\n+                        ImmTy::from_immediate(ref_place, tcx.layout_of(param_env_ty).unwrap());\n+\n+                    op_to_const(&ecx, &imm.into())\n+                }\n+                _ => op_to_const(&ecx, &place.into()),\n+            };\n+            debug!(?const_val);\n+\n+            const_val\n+        }\n+        ty::Never\n+        | ty::Error(_)\n+        | ty::Foreign(..)\n+        | ty::Infer(ty::FreshIntTy(_))\n+        | ty::Infer(ty::FreshFloatTy(_))\n+        | ty::Projection(..)\n+        | ty::Param(_)\n+        | ty::Bound(..)\n+        | ty::Placeholder(..)\n+        | ty::Opaque(..)\n+        | ty::Infer(_)\n+        | ty::Closure(..)\n+        | ty::Generator(..)\n+        | ty::GeneratorWitness(..)\n+        | ty::FnPtr(_)\n+        | ty::RawPtr(_)\n+        | ty::Str\n+        | ty::Slice(_)\n+        | ty::Dynamic(..) => bug!(\"no ValTree should have been created for type {:?}\", ty.kind()),\n+    }\n+}\n+\n+// FIXME Needs a better/correct name\n+#[instrument(skip(ecx), level = \"debug\")]\n+fn fill_place_recursively<'tcx>(\n+    ecx: &mut CompileTimeEvalContext<'tcx, 'tcx>,\n+    place: &mut MPlaceTy<'tcx>,\n+    valtree: ty::ValTree<'tcx>,\n+) {\n+    // This will match on valtree and write the value(s) corresponding to the ValTree\n+    // inside the place recursively.\n+\n+    let tcx = ecx.tcx.tcx;\n+    let ty = place.layout.ty;\n+\n+    match ty.kind() {\n+        ty::FnDef(_, _) => {\n+            ecx.write_immediate(\n+                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::ZST)),\n+                &(*place).into(),\n+            )\n+            .unwrap();\n+        }\n+        ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n+            let scalar_int = valtree.unwrap_leaf();\n+            debug!(\"writing trivial valtree {:?} to place {:?}\", scalar_int, place);\n+            ecx.write_immediate(\n+                Immediate::Scalar(ScalarMaybeUninit::Scalar(scalar_int.into())),\n+                &(*place).into(),\n+            )\n+            .unwrap();\n+        }\n+        ty::Ref(_, inner_ty, _) => {\n+            let mut pointee_place = create_pointee_place(ecx, *inner_ty, valtree);\n+            debug!(?pointee_place);\n+\n+            fill_place_recursively(ecx, &mut pointee_place, valtree);\n+            dump_place(ecx, pointee_place.into());\n+            intern_const_alloc_recursive(ecx, InternKind::Constant, &pointee_place).unwrap();\n+\n+            let imm = match inner_ty.kind() {\n+                ty::Slice(_) | ty::Str => {\n+                    let len = valtree.unwrap_branch().len();\n+                    let len_scalar = ScalarMaybeUninit::Scalar(Scalar::from_u64(len as u64));\n+\n+                    Immediate::ScalarPair(\n+                        ScalarMaybeUninit::from_maybe_pointer((*pointee_place).ptr, &tcx),\n+                        len_scalar,\n+                    )\n+                }\n+                _ => pointee_place.to_ref(&tcx),\n+            };\n+            debug!(?imm);\n+\n+            ecx.write_immediate(imm, &(*place).into()).unwrap();\n+        }\n+        ty::Adt(_, _) | ty::Tuple(_) | ty::Array(_, _) | ty::Str | ty::Slice(_) => {\n+            let branches = valtree.unwrap_branch();\n+\n+            // Need to downcast place for enums\n+            let (place_adjusted, branches, variant_idx) = match ty.kind() {\n+                ty::Adt(def, _) if def.is_enum() => {\n+                    // First element of valtree corresponds to variant\n+                    let scalar_int = branches[0].unwrap_leaf();\n+                    let variant_idx = VariantIdx::from_u32(scalar_int.try_to_u32().unwrap());\n+                    let variant = def.variant(variant_idx);\n+                    debug!(?variant);\n+\n+                    (\n+                        place.project_downcast(ecx, variant_idx).unwrap(),\n+                        &branches[1..],\n+                        Some(variant_idx),\n+                    )\n+                }\n+                _ => (*place, branches, None),\n+            };\n+            debug!(?place_adjusted, ?branches);\n+\n+            // Create the places (by indexing into `place`) for the fields and fill\n+            // them recursively\n+            for (i, inner_valtree) in branches.iter().enumerate() {\n+                debug!(?i, ?inner_valtree);\n+\n+                let mut place_inner = match ty.kind() {\n+                    ty::Str | ty::Slice(_) => ecx.mplace_index(&place, i as u64).unwrap(),\n+                    _ if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty())\n+                        && i == branches.len() - 1 =>\n+                    {\n+                        // Note: For custom DSTs we need to manually process the last unsized field.\n+                        // We created a `Pointer` for the `Allocation` of the complete sized version of\n+                        // the Adt in `create_pointee_place` and now we fill that `Allocation` with the\n+                        // values in the ValTree. For the unsized field we have to additionally add the meta\n+                        // data.\n+\n+                        let (unsized_inner_ty, num_elems) =\n+                            get_info_on_unsized_field(ty, valtree, tcx);\n+                        debug!(?unsized_inner_ty);\n+\n+                        let inner_ty = match ty.kind() {\n+                            ty::Adt(def, substs) => {\n+                                def.variant(VariantIdx::from_u32(0)).fields[i].ty(tcx, substs)\n+                            }\n+                            ty::Tuple(inner_tys) => inner_tys[i],\n+                            _ => bug!(\"unexpected unsized type {:?}\", ty),\n+                        };\n+\n+                        let inner_layout =\n+                            tcx.layout_of(ty::ParamEnv::empty().and(inner_ty)).unwrap();\n+                        debug!(?inner_layout);\n+\n+                        let offset = place_adjusted.layout.fields.offset(i);\n+                        place\n+                            .offset(\n+                                offset,\n+                                MemPlaceMeta::Meta(Scalar::from_u64(num_elems as u64)),\n+                                inner_layout,\n+                                &tcx,\n+                            )\n+                            .unwrap()\n+                    }\n+                    _ => ecx.mplace_field(&place_adjusted, i).unwrap(),\n+                };\n+\n+                debug!(?place_inner);\n+                fill_place_recursively(ecx, &mut place_inner, *inner_valtree);\n+                dump_place(&ecx, place_inner.into());\n+            }\n+\n+            debug!(\"dump of place_adjusted:\");\n+            dump_place(ecx, place_adjusted.into());\n+\n+            if let Some(variant_idx) = variant_idx {\n+                // don't forget filling the place with the discriminant of the enum\n+                ecx.write_discriminant(variant_idx, &(*place).into()).unwrap();\n+            }\n+\n+            debug!(\"dump of place after writing discriminant:\");\n+            dump_place(ecx, (*place).into());\n+        }\n+        _ => bug!(\"shouldn't have created a ValTree for {:?}\", ty),\n+    }\n+}\n+\n+fn dump_place<'tcx>(ecx: &CompileTimeEvalContext<'tcx, 'tcx>, place: PlaceTy<'tcx>) {\n+    trace!(\"{:?}\", ecx.dump_place(*place));\n+}"}, {"sha": "69d6c8470a2737233cef08d2ec5e517b725adf93", "filename": "compiler/rustc_const_eval/src/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs?ref=b2c2a32870e15af02eb89de434c36535439dbf5a", "patch": "@@ -27,7 +27,7 @@ pub use self::memory::{AllocCheck, AllocRef, AllocRefMut, FnVal, Memory, MemoryK\n pub use self::operand::{ImmTy, Immediate, OpTy, Operand};\n pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n pub use self::validity::{CtfeValidationMode, RefTracking};\n-pub use self::visitor::{MutValueVisitor, ValueVisitor};\n+pub use self::visitor::{MutValueVisitor, Value, ValueVisitor};\n \n crate use self::intrinsics::eval_nullary_intrinsic;\n use eval_context::{from_known_layout, mir_assign_valid_types};"}, {"sha": "f2d833b320249f735487bf915794e94a4d661bee", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=b2c2a32870e15af02eb89de434c36535439dbf5a", "patch": "@@ -424,6 +424,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         })\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn operand_projection(\n         &self,\n         base: &OpTy<'tcx, M::PointerTag>,"}, {"sha": "380eb5263618b5f26b6bba3681e4d44c770d5704", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=b2c2a32870e15af02eb89de434c36535439dbf5a", "patch": "@@ -115,6 +115,12 @@ impl<'tcx, Tag: Provenance> std::ops::Deref for MPlaceTy<'tcx, Tag> {\n     }\n }\n \n+impl<'tcx, Tag: Provenance> std::ops::DerefMut for MPlaceTy<'tcx, Tag> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.mplace\n+    }\n+}\n+\n impl<'tcx, Tag: Provenance> From<MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: MPlaceTy<'tcx, Tag>) -> Self {\n@@ -294,6 +300,7 @@ where\n \n     /// Take an operand, representing a pointer, and dereference it to a place -- that\n     /// will always be a MemPlace.  Lives in `place.rs` because it creates a place.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn deref_operand(\n         &self,\n         src: &OpTy<'tcx, M::PointerTag>,\n@@ -487,7 +494,8 @@ where\n     }\n \n     /// Project into an mplace\n-    pub(super) fn mplace_projection(\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub(crate) fn mplace_projection(\n         &self,\n         base: &MPlaceTy<'tcx, M::PointerTag>,\n         proj_elem: mir::PlaceElem<'tcx>,\n@@ -548,6 +556,7 @@ where\n     /// Just a convenience function, but used quite a bit.\n     /// This is the only projection that might have a side-effect: We cannot project\n     /// into the field of a local `ScalarPair`, we have to first allocate it.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn place_field(\n         &mut self,\n         base: &PlaceTy<'tcx, M::PointerTag>,\n@@ -617,6 +626,7 @@ where\n \n     /// Computes a place. You should only use this if you intend to write into this\n     /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn eval_place(\n         &mut self,\n         place: mir::Place<'tcx>,\n@@ -646,6 +656,7 @@ where\n \n     /// Write an immediate to a place\n     #[inline(always)]\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn write_immediate(\n         &mut self,\n         src: Immediate<M::PointerTag>,\n@@ -830,6 +841,7 @@ where\n     /// Copies the data from an operand to a place. This does not support transmuting!\n     /// Use `copy_op_transmute` if the layouts could disagree.\n     #[inline(always)]\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn copy_op(\n         &mut self,\n         src: &OpTy<'tcx, M::PointerTag>,\n@@ -849,6 +861,7 @@ where\n     /// Use `copy_op_transmute` if the layouts could disagree.\n     /// Also, if you use this you are responsible for validating that things get copied at the\n     /// right type.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn copy_op_no_validate(\n         &mut self,\n         src: &OpTy<'tcx, M::PointerTag>,\n@@ -955,6 +968,7 @@ where\n     /// This supports unsized types and returns the computed size to avoid some\n     /// redundant computation when copying; use `force_allocation` for a simpler, sized-only\n     /// version.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn force_allocation_maybe_sized(\n         &mut self,\n         place: &PlaceTy<'tcx, M::PointerTag>,\n@@ -1037,6 +1051,7 @@ where\n     }\n \n     /// Writes the discriminant of the given variant.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn write_discriminant(\n         &mut self,\n         variant_index: VariantIdx,"}, {"sha": "34a004525196dd38f94df676398abf66c4d9ac6a", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=b2c2a32870e15af02eb89de434c36535439dbf5a", "patch": "@@ -35,6 +35,7 @@ pub mod transform;\n pub mod util;\n \n use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::ParamEnv;\n \n pub fn provide(providers: &mut Providers) {\n     const_eval::provide(providers);\n@@ -49,6 +50,9 @@ pub fn provide(providers: &mut Providers) {\n         let (param_env, raw) = param_env_and_value.into_parts();\n         const_eval::const_to_valtree(tcx, param_env, raw)\n     };\n+    providers.valtree_to_const_val = |tcx, (ty, valtree)| {\n+        const_eval::valtree_to_const_value(tcx, ParamEnv::empty().and(ty), valtree)\n+    };\n     providers.deref_const = |tcx, param_env_and_value| {\n         let (param_env, value) = param_env_and_value.into_parts();\n         const_eval::deref_const(tcx, param_env, value)"}, {"sha": "8cfc5ed0a95d06147ceab0adbbb5a6bf0670bad2", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=b2c2a32870e15af02eb89de434c36535439dbf5a", "patch": "@@ -418,6 +418,7 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     /// Most likely, you want to call `InterpCx::write_scalar` instead of this method.\n+    #[instrument(skip(self, cx), level = \"debug\")]\n     pub fn write_scalar(\n         &mut self,\n         cx: &impl HasDataLayout,"}, {"sha": "cc80ab8f16e9c9f7ff007f930c349948eca3a50e", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=b2c2a32870e15af02eb89de434c36535439dbf5a", "patch": "@@ -936,6 +936,11 @@ rustc_queries! {\n         remap_env_constness\n     }\n \n+    /// Converts a type level constant value into `ConstValue`\n+    query valtree_to_const_val(key: (Ty<'tcx>, ty::ValTree<'tcx>)) -> ConstValue<'tcx> {\n+        desc { \"convert type-level constant value to mir constant value\"}\n+    }\n+\n     /// Destructure a constant ADT or array into its variant index and its\n     /// field values or return `None` if constant is invalid.\n     ///"}, {"sha": "a3ce674c115241614060f95d118b14f6b313362e", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=b2c2a32870e15af02eb89de434c36535439dbf5a", "patch": "@@ -237,6 +237,98 @@ impl ScalarInt {\n     pub fn try_to_machine_usize<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Result<u64, Size> {\n         Ok(self.to_bits(tcx.data_layout.pointer_size)? as u64)\n     }\n+\n+    /// Tries to convert the `ScalarInt` to an unsigned integer of the given size.\n+    /// Fails if the size of the `ScalarInt` is unequal to `size` and returns the\n+    /// `ScalarInt`s size in that case.\n+    #[inline]\n+    pub fn try_to_uint(self, size: Size) -> Result<u128, Size> {\n+        self.to_bits(size)\n+    }\n+\n+    // Tries to convert the `ScalarInt` to `u8`. Fails if the `size` of the `ScalarInt`\n+    // in not equal to `Size { raw: 1 }` and returns the `size` value of the `ScalarInt` in\n+    // that case.\n+    #[inline]\n+    pub fn try_to_u8(self) -> Result<u8, Size> {\n+        self.to_bits(Size::from_bits(8)).map(|v| u8::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to `u16`. Fails if the size of the `ScalarInt`\n+    /// in not equal to `Size { raw: 2 }` and returns the `size` value of the `ScalarInt` in\n+    /// that case.\n+    #[inline]\n+    pub fn try_to_u16(self) -> Result<u16, Size> {\n+        self.to_bits(Size::from_bits(16)).map(|v| u16::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to `u32`. Fails if the `size` of the `ScalarInt`\n+    /// in not equal to `Size { raw: 4 }` and returns the `size` value of the `ScalarInt` in\n+    /// that case.\n+    #[inline]\n+    pub fn try_to_u32(self) -> Result<u32, Size> {\n+        self.to_bits(Size::from_bits(32)).map(|v| u32::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to `u64`. Fails if the `size` of the `ScalarInt`\n+    /// in not equal to `Size { raw: 8 }` and returns the `size` value of the `ScalarInt` in\n+    /// that case.\n+    #[inline]\n+    pub fn try_to_u64(self) -> Result<u64, Size> {\n+        self.to_bits(Size::from_bits(64)).map(|v| u64::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to `u128`. Fails if the `size` of the `ScalarInt`\n+    /// in not equal to `Size { raw: 16 }` and returns the `size` value of the `ScalarInt` in\n+    /// that case.\n+    #[inline]\n+    pub fn try_to_u128(self) -> Result<u128, Size> {\n+        self.to_bits(Size::from_bits(128))\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to a signed integer of the given size.\n+    /// Fails if the size of the `ScalarInt` is unequal to `size` and returns the\n+    /// `ScalarInt`s size in that case.\n+    #[inline]\n+    pub fn try_to_int(self, size: Size) -> Result<i128, Size> {\n+        let b = self.to_bits(size)?;\n+        Ok(size.sign_extend(b) as i128)\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to i8.\n+    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 1 }`\n+    /// and returns the `ScalarInt`s size in that case.\n+    pub fn try_to_i8(self) -> Result<i8, Size> {\n+        self.try_to_int(Size::from_bits(8)).map(|v| i8::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to i16.\n+    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 2 }`\n+    /// and returns the `ScalarInt`s size in that case.\n+    pub fn try_to_i16(self) -> Result<i16, Size> {\n+        self.try_to_int(Size::from_bits(16)).map(|v| i16::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to i32.\n+    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 4 }`\n+    /// and returns the `ScalarInt`s size in that case.\n+    pub fn try_to_i32(self) -> Result<i32, Size> {\n+        self.try_to_int(Size::from_bits(32)).map(|v| i32::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to i64.\n+    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 8 }`\n+    /// and returns the `ScalarInt`s size in that case.\n+    pub fn try_to_i64(self) -> Result<i64, Size> {\n+        self.try_to_int(Size::from_bits(64)).map(|v| i64::try_from(v).unwrap())\n+    }\n+\n+    /// Tries to convert the `ScalarInt` to i128.\n+    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 16 }`\n+    /// and returns the `ScalarInt`s size in that case.\n+    pub fn try_to_i128(self) -> Result<i128, Size> {\n+        self.try_to_int(Size::from_bits(128)).map(|v| i128::try_from(v).unwrap())\n+    }\n }\n \n macro_rules! from {"}, {"sha": "418848f69d726bc731fe1cfc56c917fc29353206", "filename": "compiler/rustc_middle/src/ty/consts/valtree.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs?ref=b2c2a32870e15af02eb89de434c36535439dbf5a", "patch": "@@ -20,6 +20,9 @@ pub enum ValTree<'tcx> {\n     /// See the `ScalarInt` documentation for how `ScalarInt` guarantees that equal values\n     /// of these types have the same representation.\n     Leaf(ScalarInt),\n+\n+    //SliceOrStr(ValSlice<'tcx>),\n+    // dont use SliceOrStr for now\n     /// The fields of any kind of aggregate. Structs, tuples and arrays are represented by\n     /// listing their fields' values in order.\n     /// Enums are represented by storing their discriminant as a field, followed by all\n@@ -31,4 +34,20 @@ impl<'tcx> ValTree<'tcx> {\n     pub fn zst() -> Self {\n         Self::Branch(&[])\n     }\n+\n+    #[inline]\n+    pub fn unwrap_leaf(self) -> ScalarInt {\n+        match self {\n+            Self::Leaf(s) => s,\n+            _ => bug!(\"expected leaf, got {:?}\", self),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn unwrap_branch(self) -> &'tcx [Self] {\n+        match self {\n+            Self::Branch(branch) => branch,\n+            _ => bug!(\"expected branch, got {:?}\", self),\n+        }\n+    }\n }"}, {"sha": "1509de0e93070aa44ce92a9e13bbe6e64bb845d8", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=b2c2a32870e15af02eb89de434c36535439dbf5a", "patch": "@@ -2273,7 +2273,7 @@ impl<'tcx> Ty<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         normalize: impl FnMut(Ty<'tcx>) -> Ty<'tcx>,\n     ) -> (Ty<'tcx>, bool) {\n-        let tail = tcx.struct_tail_with_normalize(self, normalize);\n+        let tail = tcx.struct_tail_with_normalize(self, normalize, || {});\n         match tail.kind() {\n             // Sized types\n             ty::Infer(ty::IntVar(_) | ty::FloatVar(_))"}, {"sha": "918fe49e8e3fc6dad1b3d0ed645cfc531477d6b9", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=b2c2a32870e15af02eb89de434c36535439dbf5a", "patch": "@@ -187,7 +187,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// if input `ty` is not a structure at all.\n     pub fn struct_tail_without_normalization(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let tcx = self;\n-        tcx.struct_tail_with_normalize(ty, |ty| ty)\n+        tcx.struct_tail_with_normalize(ty, |ty| ty, || {})\n     }\n \n     /// Returns the deeply last field of nested structures, or the same type if\n@@ -203,7 +203,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self;\n-        tcx.struct_tail_with_normalize(ty, |ty| tcx.normalize_erasing_regions(param_env, ty))\n+        tcx.struct_tail_with_normalize(ty, |ty| tcx.normalize_erasing_regions(param_env, ty), || {})\n     }\n \n     /// Returns the deeply last field of nested structures, or the same type if\n@@ -220,6 +220,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         mut ty: Ty<'tcx>,\n         mut normalize: impl FnMut(Ty<'tcx>) -> Ty<'tcx>,\n+        // This is currently used to allow us to walk a ValTree\n+        // in lockstep with the type in order to get the ValTree branch that\n+        // corresponds to an unsized field.\n+        mut f: impl FnMut() -> (),\n     ) -> Ty<'tcx> {\n         let recursion_limit = self.recursion_limit();\n         for iteration in 0.. {\n@@ -235,12 +239,16 @@ impl<'tcx> TyCtxt<'tcx> {\n                         break;\n                     }\n                     match def.non_enum_variant().fields.last() {\n-                        Some(f) => ty = f.ty(self, substs),\n+                        Some(field) => {\n+                            f();\n+                            ty = field.ty(self, substs);\n+                        }\n                         None => break,\n                     }\n                 }\n \n                 ty::Tuple(tys) if let Some((&last_ty, _)) = tys.split_last() => {\n+                    f();\n                     ty = last_ty;\n                 }\n "}, {"sha": "3f0f856b5dd7c16f2dca8f2075625ce49c13a5ba", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=b2c2a32870e15af02eb89de434c36535439dbf5a", "patch": "@@ -502,3 +502,14 @@ impl<'tcx> Key for (ty::Instance<'tcx>, &'tcx ty::List<Ty<'tcx>>) {\n         self.0.default_span(tcx)\n     }\n }\n+\n+impl<'tcx> Key for (Ty<'tcx>, ty::ValTree<'tcx>) {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}"}, {"sha": "c7a61cbe25a1aed118e1a7441ab08b2bace4d540", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c2a32870e15af02eb89de434c36535439dbf5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=b2c2a32870e15af02eb89de434c36535439dbf5a", "patch": "@@ -1519,18 +1519,22 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // Any type with multiple potential metadata types is therefore not eligible.\n                 let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n \n-                let tail = selcx.tcx().struct_tail_with_normalize(self_ty, |ty| {\n-                    // We throw away any obligations we get from this, since we normalize\n-                    // and confirm these obligations once again during confirmation\n-                    normalize_with_depth(\n-                        selcx,\n-                        obligation.param_env,\n-                        obligation.cause.clone(),\n-                        obligation.recursion_depth + 1,\n-                        ty,\n-                    )\n-                    .value\n-                });\n+                let tail = selcx.tcx().struct_tail_with_normalize(\n+                    self_ty,\n+                    |ty| {\n+                        // We throw away any obligations we get from this, since we normalize\n+                        // and confirm these obligations once again during confirmation\n+                        normalize_with_depth(\n+                            selcx,\n+                            obligation.param_env,\n+                            obligation.cause.clone(),\n+                            obligation.recursion_depth + 1,\n+                            ty,\n+                        )\n+                        .value\n+                    },\n+                    || {},\n+                );\n \n                 match tail.kind() {\n                     ty::Bool"}]}