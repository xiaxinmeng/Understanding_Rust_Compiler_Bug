{"sha": "8ffbf6f94d9cc77ade0596ee104f3549b8db452d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZmJmNmY5NGQ5Y2M3N2FkZTA1OTZlZTEwNGYzNTQ5YjhkYjQ1MmQ=", "commit": {"author": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-03-13T22:54:32Z"}, "committer": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-06-08T20:00:33Z"}, "message": "use hashset not map for keeping track of seen macro refs\n\nremove stdout, fix clippy warnings, fmtcar", "tree": {"sha": "9e72b262e0286dc8550e3507670844021afebf5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e72b262e0286dc8550e3507670844021afebf5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ffbf6f94d9cc77ade0596ee104f3549b8db452d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ffbf6f94d9cc77ade0596ee104f3549b8db452d", "html_url": "https://github.com/rust-lang/rust/commit/8ffbf6f94d9cc77ade0596ee104f3549b8db452d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ffbf6f94d9cc77ade0596ee104f3549b8db452d/comments", "author": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ede366be637657280ca506c5bad0f41f96c47340", "url": "https://api.github.com/repos/rust-lang/rust/commits/ede366be637657280ca506c5bad0f41f96c47340", "html_url": "https://github.com/rust-lang/rust/commit/ede366be637657280ca506c5bad0f41f96c47340"}], "stats": {"total": 197, "additions": 97, "deletions": 100}, "files": [{"sha": "9519fa6093bdc8230fa6fc9756ac4705e0acf062", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 48, "deletions": 83, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/8ffbf6f94d9cc77ade0596ee104f3549b8db452d/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ffbf6f94d9cc77ade0596ee104f3549b8db452d/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=8ffbf6f94d9cc77ade0596ee104f3549b8db452d", "patch": "@@ -2,7 +2,7 @@ use crate::utils::{in_macro, snippet, span_lint_and_sugg};\n use hir::def::{DefKind, Res};\n use if_chain::if_chain;\n use rustc_ast::ast;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -29,7 +29,7 @@ declare_clippy_lint! {\n \n const BRACKETS: &[char] = &['<', '>'];\n \n-/// MacroRefData includes the name of the macro\n+/// `MacroRefData` includes the name of the macro\n /// and the path from `SourceMap::span_to_filename`.\n #[derive(Debug, Clone)]\n pub struct MacroRefData {\n@@ -38,11 +38,11 @@ pub struct MacroRefData {\n }\n \n impl MacroRefData {\n-    pub fn new(name: String, span: Span, ecx: &LateContext<'_, '_>) -> Self {\n+    pub fn new(name: &str, span: Span, ecx: &LateContext<'_, '_>) -> Self {\n         let mut path = ecx.sess().source_map().span_to_filename(span).to_string();\n \n         // std lib paths are <::std::module::file type>\n-        // so remove brackets and space\n+        // so remove brackets, space and type.\n         if path.contains('<') {\n             path = path.replace(BRACKETS, \"\");\n         }\n@@ -57,13 +57,12 @@ impl MacroRefData {\n }\n \n #[derive(Default)]\n+#[allow(clippy::module_name_repetitions)]\n pub struct MacroUseImports {\n     /// the actual import path used and the span of the attribute above it.\n     imports: Vec<(String, Span)>,\n-    /// the span of the macro reference and the `MacroRefData`\n-    /// for the use of the macro.\n-    /// TODO make this FxHashSet<Span> to guard against inserting already found macros\n-    collected: FxHashMap<Span, MacroRefData>,\n+    /// the span of the macro reference, kept to ensure only one reference is used per macro call.\n+    collected: FxHashSet<Span>,\n     mac_refs: Vec<(Span, MacroRefData)>,\n }\n \n@@ -72,34 +71,28 @@ impl_lint_pass!(MacroUseImports => [MACRO_USE_IMPORTS]);\n impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n     fn check_item(&mut self, lcx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n         if_chain! {\n-            if lcx.sess().opts.edition == Edition::Edition2018;\n-            if let hir::ItemKind::Use(path, _kind) = &item.kind;\n-            if let Some(mac_attr) = item\n-                .attrs\n-                .iter()\n-                .find(|attr| attr.ident().map(|s| s.to_string()) == Some(\"macro_use\".to_string()));\n-            if let Res::Def(DefKind::Mod, id) = path.res;\n-            then {\n-                // println!(\"{:#?}\", lcx.tcx.def_path_str(id));\n-                for kid in lcx.tcx.item_children(id).iter() {\n-                    // println!(\"{:#?}\", kid);\n-                    if let Res::Def(DefKind::Macro(_mac_type), mac_id) = kid.res {\n-                        let span = mac_attr.span.clone();\n-\n-                        // println!(\"{:#?}\", lcx.tcx.def_path_str(mac_id));\n-\n-                        self.imports.push((lcx.tcx.def_path_str(mac_id), span));\n+                if lcx.sess().opts.edition == Edition::Edition2018;\n+                if let hir::ItemKind::Use(path, _kind) = &item.kind;\n+                if let Some(mac_attr) = item\n+                    .attrs\n+                    .iter()\n+                    .find(|attr| attr.ident().map(|s| s.to_string()) == Some(\"macro_use\".to_string()));\n+                if let Res::Def(DefKind::Mod, id) = path.res;\n+                then {\n+                    for kid in lcx.tcx.item_children(id).iter() {\n+                        if let Res::Def(DefKind::Macro(_mac_type), mac_id) = kid.res {\n+                            let span = mac_attr.span;\n+                            self.imports.push((lcx.tcx.def_path_str(mac_id), span));\n+                        }\n                     }\n-                }\n-            } else {\n+                } else {\n                 if in_macro(item.span) {\n                     let call_site = item.span.source_callsite();\n                     let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n                     if let Some(callee) = item.span.source_callee() {\n-                        if !self.collected.contains_key(&call_site) {\n-                            let mac = MacroRefData::new(name.to_string(), callee.def_site, lcx);\n-                            self.mac_refs.push((call_site, mac.clone()));\n-                            self.collected.insert(call_site, mac);\n+                        if !self.collected.contains(&call_site) {\n+                            self.mac_refs.push((call_site, MacroRefData::new(&name, callee.def_site, lcx)));\n+                            self.collected.insert(call_site);\n                         }\n                     }\n                 }\n@@ -111,18 +104,16 @@ impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n             let call_site = attr.span.source_callsite();\n             let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n             if let Some(callee) = attr.span.source_callee() {\n-                if !self.collected.contains_key(&call_site) {\n-                    println!(\"{:?}\\n{:#?}\", call_site, attr);\n-\n+                if !self.collected.contains(&call_site) {\n                     let name = if name.contains(\"::\") {\n                         name.split(\"::\").last().unwrap().to_string()\n                     } else {\n                         name.to_string()\n                     };\n \n-                    let mac = MacroRefData::new(name, callee.def_site, lcx);\n-                    self.mac_refs.push((call_site, mac.clone()));\n-                    self.collected.insert(call_site, mac);\n+                    self.mac_refs\n+                        .push((call_site, MacroRefData::new(&name, callee.def_site, lcx)));\n+                    self.collected.insert(call_site);\n                 }\n             }\n         }\n@@ -132,16 +123,16 @@ impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n             let call_site = expr.span.source_callsite();\n             let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n             if let Some(callee) = expr.span.source_callee() {\n-                if !self.collected.contains_key(&call_site) {\n+                if !self.collected.contains(&call_site) {\n                     let name = if name.contains(\"::\") {\n                         name.split(\"::\").last().unwrap().to_string()\n                     } else {\n                         name.to_string()\n                     };\n \n-                    let mac = MacroRefData::new(name, callee.def_site, lcx);\n-                    self.mac_refs.push((call_site, mac.clone()));\n-                    self.collected.insert(call_site, mac);\n+                    self.mac_refs\n+                        .push((call_site, MacroRefData::new(&name, callee.def_site, lcx)));\n+                    self.collected.insert(call_site);\n                 }\n             }\n         }\n@@ -151,16 +142,16 @@ impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n             let call_site = stmt.span.source_callsite();\n             let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n             if let Some(callee) = stmt.span.source_callee() {\n-                if !self.collected.contains_key(&call_site) {\n+                if !self.collected.contains(&call_site) {\n                     let name = if name.contains(\"::\") {\n                         name.split(\"::\").last().unwrap().to_string()\n                     } else {\n                         name.to_string()\n                     };\n \n-                    let mac = MacroRefData::new(name, callee.def_site, lcx);\n-                    self.mac_refs.push((call_site, mac.clone()));\n-                    self.collected.insert(call_site, mac);\n+                    self.mac_refs\n+                        .push((call_site, MacroRefData::new(&name, callee.def_site, lcx)));\n+                    self.collected.insert(call_site);\n                 }\n             }\n         }\n@@ -170,10 +161,10 @@ impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n             let call_site = pat.span.source_callsite();\n             let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n             if let Some(callee) = pat.span.source_callee() {\n-                if !self.collected.contains_key(&call_site) {\n-                    let mac = MacroRefData::new(name.to_string(), callee.def_site, lcx);\n-                    self.mac_refs.push((call_site, mac.clone()));\n-                    self.collected.insert(call_site, mac);\n+                if !self.collected.contains(&call_site) {\n+                    self.mac_refs\n+                        .push((call_site, MacroRefData::new(&name, callee.def_site, lcx)));\n+                    self.collected.insert(call_site);\n                 }\n             }\n         }\n@@ -183,22 +174,18 @@ impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n             let call_site = ty.span.source_callsite();\n             let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n             if let Some(callee) = ty.span.source_callee() {\n-                if !self.collected.contains_key(&call_site) {\n-                    let mac = MacroRefData::new(name.to_string(), callee.def_site, lcx);\n-                    self.mac_refs.push((call_site, mac.clone()));\n-                    self.collected.insert(call_site, mac);\n+                if !self.collected.contains(&call_site) {\n+                    self.mac_refs\n+                        .push((call_site, MacroRefData::new(&name, callee.def_site, lcx)));\n+                    self.collected.insert(call_site);\n                 }\n             }\n         }\n     }\n \n     fn check_crate_post(&mut self, lcx: &LateContext<'_, '_>, _krate: &hir::Crate<'_>) {\n-        for (import, span) in self.imports.iter() {\n-            let matched = self\n-                .mac_refs\n-                .iter()\n-                .find(|(_span, mac)| import.ends_with(&mac.name))\n-                .is_some();\n+        for (import, span) in &self.imports {\n+            let matched = self.mac_refs.iter().any(|(_span, mac)| import.ends_with(&mac.name));\n \n             if matched {\n                 self.mac_refs.retain(|(_span, mac)| !import.ends_with(&mac.name));\n@@ -218,30 +205,8 @@ impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n         if !self.mac_refs.is_empty() {\n             // TODO if not empty we found one we could not make a suggestion for\n             // such as std::prelude::v1 or something else I haven't thought of.\n-            // println!(\"{:#?}\", self.mac_refs);\n+            // If we defer the calling of span_lint_and_sugg we can make a decision about its\n+            // applicability?\n         }\n     }\n }\n-\n-const PRELUDE: &[&str] = &[\n-    \"marker\", \"ops\", \"convert\", \"iter\", \"option\", \"result\", \"borrow\", \"boxed\", \"string\", \"vec\", \"macros\",\n-];\n-\n-/// This is somewhat of a fallback for imports from `std::prelude` because they\n-/// are not recognized by `LateLintPass::check_item` `lcx.tcx.item_children(id)`\n-fn make_path(mac: &MacroRefData, use_path: &str) -> String {\n-    let segs = mac.path.split(\"::\").filter(|s| *s != \"\").collect::<Vec<_>>();\n-\n-    if segs.starts_with(&[\"std\"]) && PRELUDE.iter().any(|m| segs.contains(m)) {\n-        return format!(\n-            \"std::prelude::{} is imported by default, remove `use` statement\",\n-            mac.name\n-        );\n-    }\n-\n-    if use_path.split(\"::\").count() == 1 {\n-        return format!(\"{}::{}\", use_path, mac.name);\n-    }\n-\n-    mac.path.clone()\n-}"}, {"sha": "7cc4e1d736a3d3312ecaaec769792229c370c49e", "filename": "tests/ui/auxiliary/macro_use_helper.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ffbf6f94d9cc77ade0596ee104f3549b8db452d/tests%2Fui%2Fauxiliary%2Fmacro_use_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ffbf6f94d9cc77ade0596ee104f3549b8db452d/tests%2Fui%2Fauxiliary%2Fmacro_use_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fmacro_use_helper.rs?ref=8ffbf6f94d9cc77ade0596ee104f3549b8db452d", "patch": "@@ -17,7 +17,7 @@ pub mod inner {\n \n     // ITEM\n     #[macro_export]\n-    macro_rules! inner_mod {\n+    macro_rules! inner_mod_macro {\n         () => {\n             #[allow(dead_code)]\n             pub struct Tardis;\n@@ -27,7 +27,7 @@ pub mod inner {\n \n // EXPR\n #[macro_export]\n-macro_rules! function {\n+macro_rules! function_macro {\n     () => {\n         if true {\n         } else {\n@@ -37,7 +37,7 @@ macro_rules! function {\n \n // TYPE\n #[macro_export]\n-macro_rules! ty_mac {\n+macro_rules! ty_macro {\n     () => {\n         Vec<u8>\n     };\n@@ -46,7 +46,7 @@ macro_rules! ty_mac {\n mod extern_exports {\n     pub(super) mod private_inner {\n         #[macro_export]\n-        macro_rules! pub_in_private {\n+        macro_rules! pub_in_private_macro {\n             ($name:ident) => {\n                 let $name = String::from(\"secrets and lies\");\n             };"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/ui/macro_use_import.stdout", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ede366be637657280ca506c5bad0f41f96c47340/tests%2Fui%2Fmacro_use_import.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ede366be637657280ca506c5bad0f41f96c47340/tests%2Fui%2Fmacro_use_import.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_import.stdout?ref=ede366be637657280ca506c5bad0f41f96c47340"}, {"sha": "bc8762df593b64d59f97abbce31f73b449c50573", "filename": "tests/ui/macro_use_imports.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ffbf6f94d9cc77ade0596ee104f3549b8db452d/tests%2Fui%2Fmacro_use_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ffbf6f94d9cc77ade0596ee104f3549b8db452d/tests%2Fui%2Fmacro_use_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.rs?ref=8ffbf6f94d9cc77ade0596ee104f3549b8db452d", "patch": "@@ -12,8 +12,6 @@ extern crate macro_use_helper as mac;\n extern crate clippy_mini_macro_test as mini_mac;\n \n mod a {\n-    #[macro_use]\n-    use std::prelude;\n     #[macro_use]\n     use mac;\n     #[macro_use]\n@@ -26,15 +24,13 @@ mod a {\n \n     fn main() {\n         pub_macro!();\n-        inner_mod!();\n-        pub_in_private!(_var);\n-        function!();\n-        let v: ty_mac!() = Vec::default();\n+        inner_mod_macro!();\n+        pub_in_private_macro!(_var);\n+        function_macro!();\n+        let v: ty_macro!() = Vec::default();\n \n         inner::try_err!();\n     }\n }\n \n-fn main() {\n-    println!();\n-}\n+fn main() {}"}, {"sha": "6bcacd0be19213aceb8c89e283bfd6e443694130", "filename": "tests/ui/macro_use_imports.stderr", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8ffbf6f94d9cc77ade0596ee104f3549b8db452d/tests%2Fui%2Fmacro_use_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ffbf6f94d9cc77ade0596ee104f3549b8db452d/tests%2Fui%2Fmacro_use_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.stderr?ref=8ffbf6f94d9cc77ade0596ee104f3549b8db452d", "patch": "@@ -1,10 +1,46 @@\n error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:5:1\n+  --> $DIR/macro_use_imports.rs:15:5\n    |\n-LL | #[macro_use]\n-   | ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use std::prelude::<macro name>`\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::pub_macro`\n    |\n    = note: `-D clippy::macro-use-imports` implied by `-D warnings`\n \n-error: aborting due to previous error\n+error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n+  --> $DIR/macro_use_imports.rs:15:5\n+   |\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::inner_mod_macro`\n+\n+error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n+  --> $DIR/macro_use_imports.rs:15:5\n+   |\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::function_macro`\n+\n+error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n+  --> $DIR/macro_use_imports.rs:15:5\n+   |\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::ty_macro`\n+\n+error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n+  --> $DIR/macro_use_imports.rs:15:5\n+   |\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::pub_in_private_macro`\n+\n+error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n+  --> $DIR/macro_use_imports.rs:17:5\n+   |\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mini_mac::ClippyMiniMacroTest`\n+\n+error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n+  --> $DIR/macro_use_imports.rs:19:5\n+   |\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::inner::try_err`\n+\n+error: aborting due to 7 previous errors\n "}]}