{"sha": "ee8a99a1140880e10677fa0b03167cd364fece3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlOGE5OWExMTQwODgwZTEwNjc3ZmEwYjAzMTY3Y2QzNjRmZWNlM2Y=", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-02-20T12:50:09Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-05-05T16:35:33Z"}, "message": "Metadata collection: Collecting Applicability assign values", "tree": {"sha": "3ad62201e77316e719ced5086d158ec080b7d868", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ad62201e77316e719ced5086d158ec080b7d868"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee8a99a1140880e10677fa0b03167cd364fece3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee8a99a1140880e10677fa0b03167cd364fece3f", "html_url": "https://github.com/rust-lang/rust/commit/ee8a99a1140880e10677fa0b03167cd364fece3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee8a99a1140880e10677fa0b03167cd364fece3f/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a39912cfbbd682270b5f3d534bc69eedfaa73a7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a39912cfbbd682270b5f3d534bc69eedfaa73a7b", "html_url": "https://github.com/rust-lang/rust/commit/a39912cfbbd682270b5f3d534bc69eedfaa73a7b"}], "stats": {"total": 372, "additions": 73, "deletions": 299}, "files": [{"sha": "42218c2c00ac5e6eaa3165914aa97f782c70da5c", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee8a99a1140880e10677fa0b03167cd364fece3f/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ee8a99a1140880e10677fa0b03167cd364fece3f/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=ee8a99a1140880e10677fa0b03167cd364fece3f", "patch": "@@ -33,7 +33,7 @@ url = { version = \"2.1.0\", features = [\"serde\"] }\n deny-warnings = []\n # build clippy with internal lints enabled, off by default\n internal-lints = [\"clippy_utils/internal-lints\"]\n-metadata-collector-lint = [\"serde_json\"]\n+metadata-collector-lint = [\"serde_json\", \"clippy_utils/metadata-collector-lint\"]\n \n [package.metadata.rust-analyzer]\n # This crate uses #[feature(rustc_private)]"}, {"sha": "a16f7c2ea5e12cac3eecc6cfa981d5923a7827b3", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 64, "deletions": 297, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/ee8a99a1140880e10677fa0b03167cd364fece3f/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8a99a1140880e10677fa0b03167cd364fece3f/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=ee8a99a1140880e10677fa0b03167cd364fece3f", "patch": "@@ -21,24 +21,19 @@\n // - TODO xFrednet 2021-02-13: Collect depreciations and maybe renames\n \n use if_chain::if_chain;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{self as hir, ExprKind, Item, ItemKind, Mutability};\n use rustc_lint::{CheckLintNameResult, LateContext, LateLintPass, LintContext, LintId};\n-use rustc_middle::ty::{BorrowKind, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, Loc, Span, Symbol};\n-use rustc_trait_selection::infer::TyCtxtInferExt;\n-use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceWithHirId};\n-use rustc_typeck::hir_ty_to_ty;\n use serde::Serialize;\n use std::fs::{self, OpenOptions};\n use std::io::prelude::*;\n use std::path::Path;\n \n use crate::utils::internal_lints::is_lint_ref_type;\n use crate::utils::{\n-    get_enclosing_body, get_parent_expr, get_parent_expr_for_hir, last_path_segment, match_function_call, match_qpath,\n-    match_type, path_to_local_id, paths, span_lint, walk_ptrs_ty_depth,\n+    last_path_segment, match_function_call, match_type, paths, span_lint, walk_ptrs_ty_depth, match_path,\n };\n \n /// This is the output file of the lint collector.\n@@ -50,11 +45,11 @@ const BLACK_LISTED_LINTS: [&str; 2] = [\"lint_author\", \"deep_code_inspection\"];\n // handling\n #[rustfmt::skip]\n const LINT_EMISSION_FUNCTIONS: [&[&str]; 5] = [\n-    &[\"clippy_lints\", \"utils\", \"diagnostics\", \"span_lint\"],\n-    &[\"clippy_lints\", \"utils\", \"diagnostics\", \"span_lint_and_help\"],\n-    &[\"clippy_lints\", \"utils\", \"diagnostics\", \"span_lint_and_note\"],\n-    &[\"clippy_lints\", \"utils\", \"diagnostics\", \"span_lint_hir\"],\n-    &[\"clippy_lints\", \"utils\", \"diagnostics\", \"span_lint_and_sugg\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_help\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_note\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_hir\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_sugg\"],\n ];\n \n declare_clippy_lint! {\n@@ -175,10 +170,10 @@ struct ApplicabilityInfo {\n     /// [rustfix#141](https://github.com/rust-lang/rustfix/issues/141) as such suggestions can\n     /// currently not be applied automatically.\n     has_multi_suggestion: bool,\n-    /// These are all the available applicability values for the lint suggestions\n-    applicabilities: FxHashSet<String>,\n+    applicability: Option<String>,\n }\n \n+#[allow(dead_code)]\n fn log_to_file(msg: &str) {\n     let mut file = OpenOptions::new()\n         .write(true)\n@@ -190,7 +185,7 @@ fn log_to_file(msg: &str) {\n     write!(file, \"{}\", msg).unwrap();\n }\n \n-impl<'tcx> LateLintPass<'tcx> for MetadataCollector {\n+impl<'hir> LateLintPass<'hir> for MetadataCollector {\n     /// Collecting lint declarations like:\n     /// ```rust, ignore\n     /// declare_clippy_lint! {\n@@ -200,7 +195,7 @@ impl<'tcx> LateLintPass<'tcx> for MetadataCollector {\n     ///     \"Who am I?\"\n     /// }\n     /// ```\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+    fn check_item(&mut self, cx: &LateContext<'hir>, item: &'hir Item<'_>) {\n         if_chain! {\n             // item validation\n             if let ItemKind::Static(ref ty, Mutability::Not, body_id) = item.kind;\n@@ -239,87 +234,16 @@ impl<'tcx> LateLintPass<'tcx> for MetadataCollector {\n     ///     Applicability::MachineApplicable, // <-- Extracts this constant value\n     /// );\n     /// ```\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'hir>, expr: &'hir hir::Expr<'_>) {\n         if let Some(args) = match_simple_lint_emission(cx, expr) {\n-            if let Some((lint_name, mut applicability)) = extract_emission_info(cx, args) {\n+            if let Some((lint_name, applicability)) = extract_emission_info(cx, args) {\n                 let app_info = self.applicability_into.entry(lint_name).or_default();\n-                applicability.drain(..).for_each(|x| {\n-                    app_info.applicabilities.insert(x);\n-                });\n+                app_info.applicability = applicability;\n             } else {\n                 lint_collection_error_span(cx, expr.span, \"I found this but I can't get the lint or applicability\");\n             }\n         }\n     }\n-\n-    /// Tracking and hopefully collecting dynamic applicability values\n-    ///\n-    /// Example:\n-    /// ```rust, ignore\n-    /// // vvv Applicability value to track\n-    /// let mut applicability = Applicability::MachineApplicable;\n-    /// // vvv Value Mutation\n-    /// let suggestion = snippet_with_applicability(cx, expr.span, \"_\", &mut applicability);\n-    /// // vvv Emission to link the value to the lint\n-    /// span_lint_and_sugg(\n-    ///     cx,\n-    ///     SOME_LINT,\n-    ///     expr.span,\n-    ///     \"This can be improved\",\n-    ///     \"try\",\n-    ///     suggestion,\n-    ///     applicability,\n-    /// );\n-    /// ```\n-    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx hir::Local<'tcx>) {\n-        if_chain! {\n-            if let Some(local_ty) = get_local_type(cx, local);\n-            if match_type(cx, local_ty, &paths::APPLICABILITY);\n-            if let Some(body) = get_enclosing_body(cx, local.hir_id);\n-            then {\n-                // TODO xFrednet: 2021-02-19: Remove debug code\n-                let span = SerializableSpan::from_span(cx, local.span);\n-                let local_str = crate::utils::snippet(cx, local.span, \"_\");\n-                log_to_file(&format!(\"{} -- {}\\n\", local_str, span));\n-\n-                let value_hir_id = local.pat.hir_id;\n-                let mut tracker = ValueTracker::new(cx, value_hir_id);\n-                if let Some(init_expr) = local.init {\n-                    tracker.process_assign_expr(init_expr)\n-                }\n-\n-                // TODO xFrednet 2021-02-18: Support nested bodies\n-                // Note: The `ExprUseVisitor` only searches though one body, this means that values\n-                // references in nested bodies like closures are not found by this simple visitor.\n-                cx.tcx.infer_ctxt().enter(|infcx| {\n-                    let body_owner_id = cx.tcx.hir().body_owner_def_id(body.id());\n-                    ExprUseVisitor::new(\n-                        &mut tracker,\n-                        &infcx,\n-                        body_owner_id,\n-                        cx.param_env,\n-                        cx.typeck_results()\n-                    )\n-                    .consume_body(body);\n-                });\n-\n-                log_to_file(&format!(\"{:?}\\n\", tracker.value_mutations));\n-            }\n-        }\n-    }\n-}\n-\n-fn get_local_type<'a>(cx: &'a LateContext<'_>, local: &'a hir::Local<'_>) -> Option<Ty<'a>> {\n-    // TODO xFrednet 2021-02-14: support nested applicability (only in tuples)\n-    if let Some(tc) = cx.maybe_typeck_results() {\n-        if let Some(ty) = local.ty {\n-            return Some(hir_ty_to_ty(cx.tcx, ty));\n-        } else if let Some(init) = local.init {\n-            return Some(tc.expr_ty(init));\n-        }\n-    }\n-\n-    None\n }\n \n // ==================================================================\n@@ -358,7 +282,7 @@ fn extract_attr_docs(item: &Item<'_>) -> Option<String> {\n         })\n }\n \n-fn get_lint_group_or_lint(cx: &LateContext<'_>, lint_name: &str, item: &'tcx Item<'_>) -> Option<String> {\n+fn get_lint_group_or_lint(cx: &LateContext<'_>, lint_name: &str, item: &'hir Item<'_>) -> Option<String> {\n     let result = cx.lint_store.check_lint_name(lint_name, Some(sym::clippy));\n     if let CheckLintNameResult::Tool(Ok(lint_lst)) = result {\n         get_lint_group(cx, lint_lst[0]).or_else(|| {\n@@ -405,17 +329,19 @@ fn lint_collection_error_span(cx: &LateContext<'_>, span: Span, message: &str) {\n // ==================================================================\n // Applicability\n // ==================================================================\n-fn match_simple_lint_emission<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx hir::Expr<'_>,\n-) -> Option<&'tcx [hir::Expr<'tcx>]> {\n+/// This function checks if a given expression is equal to a simple lint emission function call.\n+/// It will return the function arguments if the emission matched any function.\n+fn match_simple_lint_emission<'hir>(\n+    cx: &LateContext<'hir>,\n+    expr: &'hir hir::Expr<'_>,\n+) -> Option<&'hir [hir::Expr<'hir>]> {\n     LINT_EMISSION_FUNCTIONS\n         .iter()\n         .find_map(|emission_fn| match_function_call(cx, expr, emission_fn))\n }\n \n /// This returns the lint name and the possible applicability of this emission\n-fn extract_emission_info<'tcx>(cx: &LateContext<'tcx>, args: &[hir::Expr<'_>]) -> Option<(String, Vec<String>)> {\n+fn extract_emission_info<'hir>(cx: &LateContext<'hir>, args: &[hir::Expr<'_>]) -> Option<(String, Option<String>)> {\n     let mut lint_name = None;\n     let mut applicability = None;\n \n@@ -425,228 +351,69 @@ fn extract_emission_info<'tcx>(cx: &LateContext<'tcx>, args: &[hir::Expr<'_>]) -\n         if match_type(cx, arg_ty, &paths::LINT) {\n             // If we found the lint arg, extract the lint name\n             if let ExprKind::Path(ref lint_path) = arg.kind {\n-                lint_name = Some(last_path_segment(lint_path).ident.name)\n+                lint_name = Some(last_path_segment(lint_path).ident.name);\n             }\n         } else if match_type(cx, arg_ty, &paths::APPLICABILITY) {\n-            if let ExprKind::Path(ref path) = arg.kind {\n-                applicability = Some(last_path_segment(path).ident.name)\n-            }\n+            applicability = resolve_applicability(cx, arg);\n         }\n     }\n \n     lint_name.map(|lint_name| {\n         (\n             sym_to_string(lint_name).to_ascii_lowercase(),\n-            applicability.map(sym_to_string).map_or_else(Vec::new, |x| vec![x]),\n+            applicability,\n         )\n     })\n }\n \n-#[allow(dead_code)]\n-struct ValueTracker<'a, 'hir> {\n-    cx: &'a LateContext<'hir>,\n-    value_hir_id: hir::HirId,\n-    value_mutations: Vec<ApplicabilityModifier<'hir>>,\n-}\n-\n-impl<'a, 'hir> ValueTracker<'a, 'hir> {\n-    fn new(cx: &'a LateContext<'hir>, value_hir_id: hir::HirId) -> Self {\n-        Self {\n-            cx,\n-            value_hir_id,\n-            value_mutations: Vec::new(),\n-        }\n-    }\n-\n-    fn is_value_expr(&self, expr_id: hir::HirId) -> bool {\n-        match self.cx.tcx.hir().find(expr_id) {\n-            Some(hir::Node::Expr(expr)) => path_to_local_id(expr, self.value_hir_id),\n-            _ => false,\n-        }\n-    }\n-\n-    /// This function extracts possible `ApplicabilityModifier` from an assign statement like this:\n-    ///\n-    /// ```rust, ignore\n-    /// //          vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv The expression to process\n-    /// let value = Applicability::MachineApplicable;\n-    /// ```\n-    fn process_assign_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n-        // This is a bit more complicated. I'll therefor settle on the simple solution of\n-        // simplifying the cases we support.\n-        match &expr.kind {\n-            hir::ExprKind::Call(func_expr, ..) => {\n-                // We only deal with resolved paths as this is the usual case. Other expression kinds like closures\n-                // etc. are hard to track but might be a worthy improvement in the future\n-                if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = func_expr.kind {\n-                    self.value_mutations.push(ApplicabilityModifier::Producer(path));\n-                } else {\n-                    let msg = format!(\n-                        \"Unsupported assign Call expression at: {}\",\n-                        SerializableSpan::from_span(self.cx, func_expr.span)\n-                    );\n-                    self.value_mutations.push(ApplicabilityModifier::Unknown(msg));\n-                }\n-            },\n-            hir::ExprKind::MethodCall(..) => {\n-                let msg = format!(\n-                    \"Unsupported assign MethodCall expression at: {}\",\n-                    SerializableSpan::from_span(self.cx, expr.span)\n-                );\n-                self.value_mutations.push(ApplicabilityModifier::Unknown(msg));\n-            },\n-            // We can ignore ifs without an else block because those can't be used as an assignment\n-            hir::ExprKind::If(_con, if_block, Some(else_block)) => {\n-                self.process_assign_expr(if_block);\n-                self.process_assign_expr(else_block);\n-            },\n-            hir::ExprKind::Match(_expr, arms, _) => {\n-                for arm in *arms {\n-                    self.process_assign_expr(arm.body);\n-                }\n-            },\n-            hir::ExprKind::Loop(block, ..) | hir::ExprKind::Block(block, ..) => {\n-                if let Some(block_expr) = block.expr {\n-                    self.process_assign_expr(block_expr);\n+fn resolve_applicability(cx: &LateContext<'hir>, expr: &hir::Expr<'_>) -> Option<String> {\n+    match expr.kind {\n+        // We can ignore ifs without an else block because those can't be used as an assignment\n+        hir::ExprKind::If(_con, _if_block, Some(_else_block)) => {\n+            // self.process_assign_expr(if_block);\n+            // self.process_assign_expr(else_block);\n+            return Some(\"TODO IF EXPR\".to_string());\n+        },\n+        hir::ExprKind::Match(_expr, _arms, _) => {\n+            // for arm in *arms {\n+            //     self.process_assign_expr(arm.body);\n+            // }\n+            return Some(\"TODO MATCH EXPR\".to_string());\n+        },\n+        hir::ExprKind::Loop(block, ..) | hir::ExprKind::Block(block, ..) => {\n+            if let Some(block_expr) = block.expr {\n+                return resolve_applicability(cx, block_expr);\n+            }\n+        },\n+        ExprKind::Path(hir::QPath::Resolved(_, path)) => {\n+            // direct applicabilities are simple:\n+            for enum_value in &paths::APPLICABILITY_VALUES {\n+                if match_path(path, enum_value) {\n+                    return Some(enum_value[2].to_string());\n                 }\n-            },\n-            hir::ExprKind::Path(path) => {\n-                for enum_value in &paths::APPLICABILITY_VALUES {\n-                    if match_qpath(path, enum_value) {\n-                        self.value_mutations\n-                            .push(ApplicabilityModifier::ConstValue(enum_value[2].to_string()));\n+            }\n+    \n+            // Values yay\n+            if let hir::def::Res::Local(local_hir) = path.res {\n+                if let Some(local) = get_parent_local(cx, local_hir) {\n+                    if let Some(local_init) = local.init {\n+                        return resolve_applicability(cx, local_init);\n                     }\n                 }\n-            },\n-            // hir::ExprKind::Field(expr, ident) => not supported\n-            // hir::ExprKind::Index(expr, expr) => not supported\n-            _ => {\n-                let msg = format!(\n-                    \"Unexpected assign expression at: {}\",\n-                    SerializableSpan::from_span(self.cx, expr.span)\n-                );\n-                self.value_mutations.push(ApplicabilityModifier::Unknown(msg));\n-            },\n-        }\n-    }\n-\n-    fn process_borrow_expr(&mut self, borrower_expr: &'hir rustc_hir::Expr<'hir>) {\n-        match &borrower_expr.kind {\n-            hir::ExprKind::Call(func_expr, ..) => {\n-                // We only deal with resolved paths as this is the usual case. Other expression kinds like closures\n-                // etc. are hard to track but might be a worthy improvement in the future\n-                if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = func_expr.kind {\n-                    self.value_mutations.push(ApplicabilityModifier::Modifier(path));\n-                } else {\n-                    let msg = format!(\n-                        \"Unsupported borrow in Call at: {}\",\n-                        SerializableSpan::from_span(self.cx, func_expr.span)\n-                    );\n-                    self.value_mutations.push(ApplicabilityModifier::Unknown(msg));\n-                }\n-            },\n-            hir::ExprKind::MethodCall(..) => {\n-                let msg = format!(\n-                    \"Unsupported borrow in MethodCall at: {}\",\n-                    SerializableSpan::from_span(self.cx, borrower_expr.span)\n-                );\n-                self.value_mutations.push(ApplicabilityModifier::Unknown(msg));\n-            },\n-            _ => {\n-                let msg = format!(\n-                    \"Unexpected borrow at: {}\",\n-                    SerializableSpan::from_span(self.cx, borrower_expr.span)\n-                );\n-                self.value_mutations.push(ApplicabilityModifier::Unknown(msg));\n-            },\n-        }\n-    }\n-\n-    fn process_consume_expr(&mut self, consume_expr: &'hir rustc_hir::Expr<'hir>) {\n-        // We are only interested in lint emissions. Other types like assignments might be\n-        // interesting for further use or improvement but are to complex for now.\n-        if let hir::ExprKind::Call(func_expr, ..) = &consume_expr.kind {}\n-    }\n-}\n-\n-impl<'a, 'hir> Delegate<'hir> for ValueTracker<'a, 'hir> {\n-    fn consume(&mut self, _place_with_id: &PlaceWithHirId<'hir>, expr_id: hir::HirId, _: ConsumeMode) {\n-        if self.is_value_expr(expr_id) {\n-            // TODO xFrednet 2021-02-17: Check if lint emission and extract lint ID\n-            if let Some(expr) = get_parent_expr_for_hir(self.cx, expr_id) {\n-                log_to_file(&format!(\"- consume {:?}\\n\", expr));\n             }\n         }\n+        _ => {}\n     }\n \n-    fn borrow(&mut self, _place_with_id: &PlaceWithHirId<'hir>, expr_id: hir::HirId, bk: BorrowKind) {\n-        if_chain! {\n-            if self.is_value_expr(expr_id);\n-            if let BorrowKind::MutBorrow = bk;\n-            if let Some(addr_of_expr) = get_parent_expr_for_hir(self.cx, expr_id);\n-            if let Some(borrower_expr) = get_parent_expr(self.cx, addr_of_expr);\n-            then {\n-                self.process_borrow_expr(borrower_expr);\n-            }\n-        }\n-    }\n \n-    fn mutate(&mut self, _assignee_place: &PlaceWithHirId<'hir>, expr_id: hir::HirId) {\n-        if_chain! {\n-            if self.is_value_expr(expr_id);\n-            if let Some(expr) = get_parent_expr_for_hir(self.cx, expr_id);\n-            if let hir::ExprKind::Assign(_value_expr, assign_expr, ..) = expr.kind;\n-            then {\n-                self.process_assign_expr(assign_expr);\n-            }\n-        }\n-    }\n+    Some(\"TODO\".to_string())\n }\n \n-/// The life of a value in Rust is a true adventure. These are the corner stones of such a\n-/// fairy tale. Let me introduce you to the possible stepping stones a value might have in\n-/// in our crazy word:\n-#[derive(Debug)]\n-#[allow(dead_code)]\n-enum ApplicabilityModifier<'hir> {\n-    Unknown(String),\n-    /// A simple constant value.\n-    ///\n-    /// This is the actual character of a value. It's baseline. This only defines where the value\n-    /// started. As in real life it can still change and fully decide who it wants to be.\n-    ConstValue(String),\n-    /// A producer is a function that returns an applicability value.\n-    ///\n-    /// This is the heritage of this value. This value comes from a long family tree and is not\n-    /// just a black piece of paper. The evaluation of this stepping stone needs additional\n-    /// context. We therefore only add a reference. This reference will later be used to ask\n-    /// the librarian about the possible initial character that this value might have.\n-    Producer(&'hir hir::Path<'hir>),\n-    /// A modifier that takes the given applicability and might modify it\n-    ///\n-    /// What would an RPG be without it's NPCs. The special thing about modifiers is that they can\n-    /// be actively interested in the story of the value and might make decisions based on the\n-    /// character of this hero. This means that a modifier doesn't just force its way into the life\n-    /// of our hero but it actually asks him how he's been. The possible modification is a result\n-    /// of the situation.\n-    ///\n-    /// Take this part of our heroes life very seriously!\n-    Modifier(&'hir hir::Path<'hir>),\n-    /// The actual emission of a lint\n-    ///\n-    /// All good things must come to an end. Even the life of your awesome applicability hero. He\n-    /// was the bravest soul that has ever wondered this earth. Songs will be written about his\n-    /// heroic deeds. Castles will be named after him and the world how we know it will never be\n-    /// the same!\n-    ///\n-    /// Is this a happy ending? Did he archive what he wanted in his life? Yes, YES, he has lived a\n-    /// life and he will continue to live in all the lint suggestions that can be applied or just\n-    /// displayed by Clippy. He might be no more, but his legacy will serve generations to come.\n-    LintEmit(LintEmission),\n-}\n+fn get_parent_local(cx: &LateContext<'hir>, hir_id: hir::HirId) -> Option<&'hir hir::Local<'hir>> {\n+    let map = cx.tcx.hir();\n+    if let Some(hir::Node::Local(local)) = map.find(map.get_parent_node(hir_id)) {\n+        return Some(local);\n+    }\n \n-#[derive(Debug)]\n-struct LintEmission {\n-    lint: String,\n-    is_multi_line_sugg: bool,\n+    None\n }"}, {"sha": "6e158c8ce72397ec5e9801114adf80635f3e64f9", "filename": "clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee8a99a1140880e10677fa0b03167cd364fece3f/clippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ee8a99a1140880e10677fa0b03167cd364fece3f/clippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2FCargo.toml?ref=ee8a99a1140880e10677fa0b03167cd364fece3f", "patch": "@@ -15,6 +15,7 @@ rustc-semver=\"1.1.0\"\n \n [features]\n internal-lints = []\n+metadata-collector-lint = []\n \n [package.metadata.rust-analyzer]\n # This crate uses #[feature(rustc_private)]"}, {"sha": "d4bc42657f48eae059a658f64c0f1174b020d6c8", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee8a99a1140880e10677fa0b03167cd364fece3f/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8a99a1140880e10677fa0b03167cd364fece3f/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=ee8a99a1140880e10677fa0b03167cd364fece3f", "patch": "@@ -821,7 +821,13 @@ pub fn get_parent_node(tcx: TyCtxt<'_>, id: HirId) -> Option<Node<'_>> {\n \n /// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n pub fn get_parent_expr<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    match get_parent_node(cx.tcx, e.hir_id) {\n+    get_parent_expr_for_hir(cx, e.hir_id)\n+}\n+\n+/// This retrieves the parent for the given `HirId` if it's an expression. This is useful for\n+/// constraint lints\n+pub fn get_parent_expr_for_hir<'tcx>(cx: &LateContext<'tcx>, hir_id: hir::HirId) -> Option<&'tcx Expr<'tcx>> {\n+    match get_parent_node(cx.tcx, hir_id) {\n         Some(Node::Expr(parent)) => Some(parent),\n         _ => None,\n     }"}]}