{"sha": "28cb03d4e1fe230496ff097798881f06c326ba67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4Y2IwM2Q0ZTFmZTIzMDQ5NmZmMDk3Nzk4ODgxZjA2YzMyNmJhNjc=", "commit": {"author": {"name": "Matthew Hammer", "email": "matthew.hammer@colorado.edu", "date": "2017-07-21T18:32:38Z"}, "committer": {"name": "Matthew Hammer", "email": "matthew.hammer@colorado.edu", "date": "2017-08-23T15:26:48Z"}, "message": "profiling with -Z profile-queries recognizes -Z time-passes", "tree": {"sha": "345ddf7411593ac9a9d17fe3ed46324cedafb332", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/345ddf7411593ac9a9d17fe3ed46324cedafb332"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28cb03d4e1fe230496ff097798881f06c326ba67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28cb03d4e1fe230496ff097798881f06c326ba67", "html_url": "https://github.com/rust-lang/rust/commit/28cb03d4e1fe230496ff097798881f06c326ba67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28cb03d4e1fe230496ff097798881f06c326ba67/comments", "author": null, "committer": null, "parents": [{"sha": "d7ec3e1a7d50eed94b25ffc5019617be13d6f94b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b", "html_url": "https://github.com/rust-lang/rust/commit/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b"}], "stats": {"total": 165, "additions": 139, "deletions": 26}, "files": [{"sha": "bce2a66a308a5501875f64398033c6edefb23b2a", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28cb03d4e1fe230496ff097798881f06c326ba67/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28cb03d4e1fe230496ff097798881f06c326ba67/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=28cb03d4e1fe230496ff097798881f06c326ba67", "patch": "@@ -51,8 +51,12 @@ pub struct ProfQDumpParams {\n /// FIXME(matthewhammer): Determine whether we should include cycle detection here or not.\n #[derive(Clone,Debug)]\n pub enum ProfileQueriesMsg {\n+    /// begin a timed pass\n+    TimeBegin(String),\n+    // end a timed pass\n+    TimeEnd,\n     /// begin a new query\n-    QueryBegin(Span,QueryMsg),\n+    QueryBegin(Span, QueryMsg),\n     /// query is satisfied by using an already-known value for the given key\n     CacheHit,\n     /// query requires running a provider; providers may nest, permitting queries to nest.\n@@ -110,9 +114,15 @@ pub fn time<T, F>(do_it: bool, what: &str, f: F) -> T where\n         r\n     });\n \n+    if cfg!(debug_assertions) {\n+        profq_msg(ProfileQueriesMsg::TimeBegin(what.to_string()))\n+    };\n     let start = Instant::now();\n     let rv = f();\n     let dur = start.elapsed();\n+    if cfg!(debug_assertions) {\n+        profq_msg(ProfileQueriesMsg::TimeEnd)\n+    };\n \n     print_time_passes_entry_internal(what, dur);\n "}, {"sha": "785efa78ddcd0da1710372121da3ee8777cc85b0", "filename": "src/librustc_driver/profile/mod.rs", "status": "modified", "additions": 89, "deletions": 15, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/28cb03d4e1fe230496ff097798881f06c326ba67/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28cb03d4e1fe230496ff097798881f06c326ba67/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Fmod.rs?ref=28cb03d4e1fe230496ff097798881f06c326ba67", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::time::{Instant};\n use rustc::util::common::{ProfQDumpParams, ProfileQueriesMsg, profq_msg, profq_set_chan};\n use std::sync::mpsc::{Receiver};\n use std::io::{Write};\n@@ -41,14 +42,30 @@ pub fn dump(path:String) {\n     let _ = rx.recv().unwrap();\n }\n \n+// State for parsing recursive trace structure in separate thread, via messages\n+#[derive(Clone, Eq, PartialEq)]\n+enum ParseState {\n+    // No (local) parse state; may be parsing a tree, focused on a\n+    // sub-tree that could be anything.\n+    Clear,\n+    // Have Query information from the last message\n+    HaveQuery(trace::Query, Instant),\n+    // Have \"time-begin\" information from the last message (doit flag, and message)\n+    HaveTimeBegin(String, Instant),\n+}\n+struct StackFrame {\n+    pub parse_st: ParseState,\n+    pub traces:   Vec<trace::Rec>,\n+}\n+\n // profiling thread; retains state (in local variables) and dump traces, upon request.\n fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n     use self::trace::*;\n     use std::fs::File;\n     use std::time::{Instant};\n \n     let mut profq_msgs : Vec<ProfileQueriesMsg> = vec![];\n-    let mut frame : StackFrame = StackFrame{ parse_st:ParseState::NoQuery, traces:vec![] };\n+    let mut frame : StackFrame = StackFrame{ parse_st:ParseState::Clear, traces:vec![] };\n     let mut stack : Vec<StackFrame> = vec![];\n     loop {\n         let msg = r.recv();\n@@ -64,7 +81,7 @@ fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n             ProfileQueriesMsg::Halt => return,\n             ProfileQueriesMsg::Dump(params) => {\n                 assert!(stack.len() == 0);\n-                assert!(frame.parse_st == trace::ParseState::NoQuery);\n+                assert!(frame.parse_st == ParseState::Clear);\n                 {\n                     // write log of all messages\n                     if params.dump_profq_msg_log {\n@@ -94,6 +111,10 @@ fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n                     trace::write_traces(&mut html_file, &mut counts_file, &frame.traces);\n                     write!(html_file, \"</body>\\n</html>\\n\").unwrap();\n \n+                    let ack_path = format!(\"{}.ack\", params.path);\n+                    let ack_file = File::create(&ack_path).unwrap();\n+                    drop(ack_file);\n+\n                     // Tell main thread that we are done, e.g., so it can exit\n                     params.ack.send(()).unwrap();\n                 }\n@@ -108,35 +129,33 @@ fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n                     (_,ProfileQueriesMsg::Halt) => unreachable!(),\n                     (_,ProfileQueriesMsg::Dump(_)) => unreachable!(),\n \n-                    // Parse State: NoQuery\n-                    (ParseState::NoQuery,\n+                    // Parse State: Clear\n+                    (ParseState::Clear,\n                      ProfileQueriesMsg::QueryBegin(span,querymsg)) => {\n                         let start = Instant::now();\n                         frame.parse_st = ParseState::HaveQuery\n                             (Query{span:span, msg:querymsg}, start)\n                     },\n-                    (ParseState::NoQuery,\n+                    (ParseState::Clear,\n                      ProfileQueriesMsg::CacheHit) => {\n                         panic!(\"parse error: unexpected CacheHit; expected QueryBegin\")\n                     },\n-                    (ParseState::NoQuery,\n+                    (ParseState::Clear,\n                      ProfileQueriesMsg::ProviderBegin) => {\n                         panic!(\"parse error: expected QueryBegin before beginning a provider\")\n                     },\n-                    (ParseState::NoQuery,\n+                    (ParseState::Clear,\n                      ProfileQueriesMsg::ProviderEnd) => {\n                         let provider_extent = frame.traces;\n                         match stack.pop() {\n                             None =>\n                                 panic!(\"parse error: expected a stack frame; found an empty stack\"),\n                             Some(old_frame) => {\n                                 match old_frame.parse_st {\n-                                    ParseState::NoQuery =>\n-                                        panic!(\"parse error: expected a stack frame for a query\"),\n-                                    ParseState::HaveQuery(q,start) => {\n+                                    ParseState::HaveQuery(q, start) => {\n                                         let duration = start.elapsed();\n                                         frame = StackFrame{\n-                                            parse_st:ParseState::NoQuery,\n+                                            parse_st:ParseState::Clear,\n                                             traces:old_frame.traces\n                                         };\n                                         let trace = Rec {\n@@ -146,11 +165,66 @@ fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n                                             duration: duration,\n                                         };\n                                         frame.traces.push( trace );\n-                                    }\n+                                    },\n+                                    _ => panic!(\"internal parse error: malformed parse stack\")\n                                 }\n                             }\n                         }\n-                    }\n+                   },\n+\n+\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::TimeBegin(msg)) => {\n+                        let start = Instant::now();\n+                        frame.parse_st = ParseState::HaveTimeBegin(msg, start);\n+                        stack.push(frame);\n+                        frame = StackFrame{parse_st:ParseState::Clear, traces:vec![]};\n+                    },\n+                    (_, ProfileQueriesMsg::TimeBegin(_)) =>\n+                        panic!(\"parse error; did not expect time begin here\"),\n+\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::TimeEnd) => {\n+                        let provider_extent = frame.traces;\n+                        match stack.pop() {\n+                            None =>\n+                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n+                            Some(old_frame) => {\n+                                match old_frame.parse_st {\n+                                    ParseState::HaveTimeBegin(msg, start) => {\n+                                        let duration = start.elapsed();\n+                                        frame = StackFrame{\n+                                            parse_st:ParseState::Clear,\n+                                            traces:old_frame.traces\n+                                        };\n+                                        let trace = Rec {\n+                                            effect: Effect::TimeBegin(msg),\n+                                            extent: Box::new(provider_extent),\n+                                            start: start,\n+                                            duration: duration,\n+                                        };\n+                                        frame.traces.push( trace );\n+                                    },\n+                                    _ => panic!(\"internal parse error: malformed parse stack\")\n+                                }\n+                            }\n+                        }\n+                    },\n+                    (_, ProfileQueriesMsg::TimeEnd) => { panic!(\"parse error\") }\n+\n+\n+                    // Parse State: HaveTimeBegin -- for timing old\n+                    // passes in driver (outside of query model, but\n+                    // still in use)\n+                    (ParseState::HaveTimeBegin(_, _),\n+                     ProfileQueriesMsg::ProviderBegin) => {\n+                    },\n+                    (ParseState::HaveTimeBegin(_, _),\n+                     ProfileQueriesMsg::CacheHit) => { unreachable!() },\n+                    (ParseState::HaveTimeBegin(_, _),\n+                     ProfileQueriesMsg::QueryBegin(_, _)) => { unreachable!() },\n+                    (ParseState::HaveTimeBegin(_, _),\n+                     ProfileQueriesMsg::ProviderEnd) => { unreachable!() },\n \n                     // Parse State: HaveQuery\n                     (ParseState::HaveQuery(q,start),\n@@ -163,12 +237,12 @@ fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n                             duration: duration,\n                         };\n                         frame.traces.push( trace );\n-                        frame.parse_st = ParseState::NoQuery;\n+                        frame.parse_st = ParseState::Clear;\n                     },\n                     (ParseState::HaveQuery(_,_),\n                      ProfileQueriesMsg::ProviderBegin) => {\n                         stack.push(frame);\n-                        frame = StackFrame{parse_st:ParseState::NoQuery, traces:vec![]};\n+                        frame = StackFrame{parse_st:ParseState::Clear, traces:vec![]};\n                     },\n                     (ParseState::HaveQuery(q,_),\n                      ProfileQueriesMsg::ProviderEnd) => {"}, {"sha": "8db3a3e2dfa80c156dbadb59c8f15e3975364943", "filename": "src/librustc_driver/profile/trace.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/28cb03d4e1fe230496ff097798881f06c326ba67/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28cb03d4e1fe230496ff097798881f06c326ba67/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs?ref=28cb03d4e1fe230496ff097798881f06c326ba67", "patch": "@@ -22,6 +22,7 @@ pub struct Query {\n }\n pub enum Effect {\n     QueryBegin(Query, CacheCase),\n+    TimeBegin(String),\n }\n pub enum CacheCase {\n     Hit, Miss\n@@ -33,16 +34,6 @@ pub struct Rec {\n     pub duration: Duration,\n     pub extent: Box<Vec<Rec>>,\n }\n-/// State for parsing recursive trace structure\n-#[derive(Clone, Eq, PartialEq)]\n-pub enum ParseState {\n-    NoQuery,\n-    HaveQuery(Query, Instant),\n-}\n-pub struct StackFrame {\n-    pub parse_st: ParseState,\n-    pub traces:   Vec<Rec>,\n-}\n pub struct QueryMetric {\n     pub count: usize,\n     pub duration: Duration,\n@@ -58,6 +49,10 @@ pub fn cons_of_query_msg(q: &trace::Query) -> String {\n // First return value is text; second return value is a CSS class\n pub fn html_of_effect(eff: &Effect) -> (String, String) {\n     match *eff {\n+        Effect::TimeBegin(ref msg) => {\n+            (msg.clone(),\n+             format!(\"time-begin\"))\n+        },\n         Effect::QueryBegin(ref qmsg, ref cc) => {\n             let cons = cons_of_query_msg(qmsg);\n             (cons.clone(),\n@@ -142,6 +137,9 @@ fn write_traces_rec(file: &mut File, traces: &Vec<Rec>, total: Duration, depth:\n fn compute_counts_rec(counts: &mut HashMap<String,QueryMetric>, traces: &Vec<Rec>) {\n     for t in traces.iter() {\n         match t.effect {\n+            Effect::TimeBegin(ref _msg) => {\n+                // dont count time-begin effects\n+            }\n             Effect::QueryBegin(ref qmsg, ref _cc) => {\n                 let qcons = cons_of_query_msg(qmsg);\n                 let qm = match counts.get(&qcons) {\n@@ -212,6 +210,12 @@ body {\n .extent-0 {\n     padding: 2px;\n }\n+.time-begin {\n+    border-width: 4px;\n+    font-size: 12px;\n+    color: white;\n+    border-color: #afa;\n+}\n .important {\n     border-width: 3px;\n     font-size: 12px;\n@@ -234,5 +238,30 @@ body {\n .dur {\n   display: none\n }\n+.frac-50 {\n+  padding: 4px;\n+  border-width: 10px;\n+  font-size: 16px;\n+}\n+.frac-40 {\n+  padding: 4px;\n+  border-width: 8px;\n+  font-size: 16px;\n+}\n+.frac-30 {\n+  padding: 3px;\n+  border-width: 6px;\n+  font-size: 16px;\n+}\n+.frac-20 {\n+  padding: 3px;\n+  border-width: 6px;\n+  font-size: 16px;\n+}\n+.frac-10 {\n+  padding: 3px;\n+  border-width: 6px;\n+  font-size: 16px;\n+}\n \").unwrap();\n }"}]}