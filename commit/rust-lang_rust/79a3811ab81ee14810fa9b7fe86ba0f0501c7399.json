{"sha": "79a3811ab81ee14810fa9b7fe86ba0f0501c7399", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5YTM4MTFhYjgxZWUxNDgxMGZhOWI3ZmU4NmJhMGYwNTAxYzczOTk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-21T07:00:52Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-21T07:00:52Z"}, "message": "Typecheck binary, unary and name expressions. Re-enable 3 more tests.", "tree": {"sha": "1a4fa2067dc2a9534c88c37f2ed5d5fd5e6f3c65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a4fa2067dc2a9534c88c37f2ed5d5fd5e6f3c65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79a3811ab81ee14810fa9b7fe86ba0f0501c7399", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79a3811ab81ee14810fa9b7fe86ba0f0501c7399", "html_url": "https://github.com/rust-lang/rust/commit/79a3811ab81ee14810fa9b7fe86ba0f0501c7399", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79a3811ab81ee14810fa9b7fe86ba0f0501c7399/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77670e84de5edec73883218f5da3005952b53ea8", "url": "https://api.github.com/repos/rust-lang/rust/commits/77670e84de5edec73883218f5da3005952b53ea8", "html_url": "https://github.com/rust-lang/rust/commit/77670e84de5edec73883218f5da3005952b53ea8"}], "stats": {"total": 60, "additions": 55, "deletions": 5}, "files": [{"sha": "8afe0d45d42f1270bdc0aba0230f53a08fdcd2a3", "filename": "src/Makefile", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/79a3811ab81ee14810fa9b7fe86ba0f0501c7399/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/79a3811ab81ee14810fa9b7fe86ba0f0501c7399/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=79a3811ab81ee14810fa9b7fe86ba0f0501c7399", "patch": "@@ -517,7 +517,10 @@ TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n \n TEST_XFAILS_SELF := $(filter-out \\\n                       $(addprefix test/run-pass/, \\\n+                        arith-0.rs \\\n+                        arith-2.rs \\\n                         bool-not.rs \\\n+                        char.rs \\\n                         dead-code-one-arm-if.rs \\\n                         hello.rs \\\n                         int.rs \\"}, {"sha": "73f6fa85834614b009f77664ea9080ddc27213af", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 52, "deletions": 5, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/79a3811ab81ee14810fa9b7fe86ba0f0501c7399/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79a3811ab81ee14810fa9b7fe86ba0f0501c7399/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=79a3811ab81ee14810fa9b7fe86ba0f0501c7399", "patch": "@@ -189,9 +189,7 @@ fn ty_to_str(@ty typ) -> str {\n         }\n \n         case (ty_var(?v)) {\n-            // FIXME: wrap around in the case of many variables\n-            auto ch = ('T' as u8) + (v as u8);\n-            s = _str.from_bytes(vec(ch));\n+            s = \"<T\" + util.common.istr(v) + \">\";\n         }\n     }\n \n@@ -392,7 +390,7 @@ fn ann_to_type(&ast.ann ann) -> @ty {\n     alt (ann) {\n         case (ast.ann_none) {\n             // shouldn't happen, but can until the typechecker is complete\n-            ret plain_ty(ty_var(0));    // FIXME: broken, broken, broken\n+            ret plain_ty(ty_var(-1));    // FIXME: broken, broken, broken\n         }\n         case (ast.ann_type(?ty)) {\n             ret ty;\n@@ -463,7 +461,7 @@ fn unify(@ty expected, @ty actual) -> unify_result {\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n                                 ret ures_ok(plain_ty(ty_box(result_sub)));\n-                            } \n+                            }\n                             case (_) {\n                                 ret result;\n                             }\n@@ -720,6 +718,55 @@ fn check_expr(&@env e, &@ty_table locals, @ast.expr expr) -> @ast.expr {\n                                         ast.expr_lit(lit, ast.ann_type(ty)));\n         }\n \n+\n+        case (ast.expr_binary(?binop, ?lhs, ?rhs, _)) {\n+            auto lhs_1 = check_expr(e, locals, lhs);\n+            auto rhs_1 = check_expr(e, locals, rhs);\n+            auto lhs_t = type_of(lhs_1);\n+            auto rhs_t = type_of(rhs_1);\n+            // FIXME: Binops have a bit more subtlety than this.\n+            demand(e, expr.span, lhs_t, rhs_t);\n+            auto t = lhs_t;\n+            alt (binop) {\n+                case (ast.eq) { t = plain_ty(ty_bool); }\n+                case (ast.lt) { t = plain_ty(ty_bool); }\n+                case (ast.le) { t = plain_ty(ty_bool); }\n+                case (ast.ne) { t = plain_ty(ty_bool); }\n+                case (ast.ge) { t = plain_ty(ty_bool); }\n+                case (ast.gt) { t = plain_ty(ty_bool); }\n+            }\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_binary(binop, lhs_1, rhs_1,\n+                                                        ast.ann_type(t)));\n+        }\n+\n+\n+        case (ast.expr_unary(?unop, ?oper, _)) {\n+            auto oper_1 = check_expr(e, locals, oper);\n+            auto oper_t = type_of(oper_1);\n+            // FIXME: Unops have a bit more subtlety than this.\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_unary(unop, oper_1,\n+                                                       ast.ann_type(oper_t)));\n+        }\n+\n+        case (ast.expr_name(?name, ?defopt, _)) {\n+            auto ty = @rec(struct=ty_nil, cname=none[str]);\n+            alt (option.get[ast.def](defopt)) {\n+                case (ast.def_arg(?id)) { ty = locals.get(id); }\n+                case (ast.def_local(?id)) { ty = locals.get(id); }\n+                case (_) {\n+                    // FIXME: handle other names.\n+                    e.sess.unimpl(\"definition variant for: \"\n+                                  + name.node.ident);\n+                    fail;\n+                }\n+            }\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_name(name, defopt,\n+                                                      ast.ann_type(ty)));\n+        }\n+\n         case (_) {\n             // TODO\n             ret expr;"}]}