{"sha": "123406cac7168fa2e169b404b852d1d265f34c99", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMzQwNmNhYzcxNjhmYTJlMTY5YjQwNGI4NTJkMWQyNjVmMzRjOTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-30T15:56:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-30T15:56:47Z"}, "message": "Rollup merge of #66705 - pitdicker:atomic_mut_ptr, r=KodrAus\n\nAtomic as_mut_ptr\n\nI encountered the following pattern a few times: In Rust we use some atomic type like `AtomicI32`, and an FFI interface exposes this as `*mut i32` (or some similar `libc` type).\n\nIt was not obvious to me if a just transmuting a pointer to the atomic was acceptable, or if this should use a cast that goes through an `UnsafeCell`. See https://github.com/rust-lang/rust/issues/66136#issuecomment-557802477\n\nTransmuting the pointer directly:\n```rust\nlet atomic = AtomicI32::new(1);\nlet ptr = &atomic as *const AtomicI32 as *mut i32;\nunsafe {\n    ffi(ptr);\n}\n```\n\nA dance with `UnsafeCell`:\n```rust\nlet atomic = AtomicI32::new(1);\nunsafe {\n    let ptr = (&*(&atomic as *const AtomicI32 as *const UnsafeCell<i32>)).get();\n    ffi(ptr);\n}\n```\n\nMaybe in the end both ways could be valid. But why not expose a direct method to get a pointer from the standard library?\n\nAn `as_mut_ptr` method on atomics can be safe, because only the use of the resulting pointer is where things can get unsafe. I documented its use for FFI, and \"Doing non-atomic reads and writes on the resulting integer can be a data race.\"\n\nThe standard library could make use this method in a few places in the WASM module.\n\ncc @RalfJung as you answered my original question.", "tree": {"sha": "75fad4fe46779d6222deca4884499ba8cd7cb4ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75fad4fe46779d6222deca4884499ba8cd7cb4ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/123406cac7168fa2e169b404b852d1d265f34c99", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd4pFACRBK7hj4Ov3rIwAAdHIIAKoL0HFpD8k+Qcpxz3ZcG5PX\nAt/sbvkBmkZD7NCVKNQgHc/v1KQVtbdUafD+Ad39x/RMSMe4xfGgZYF5mSIzTLPv\nrZ/V1vsmBvOOoMCWCWyOJUk+2Ish6ppSmCOYQgmP18e/UHqbBr2Xb27/+4eqS1BY\nmrfxRY3kyFm1IeOUntXtNNJeEYVI02zbHfvStzXysj/Ww5NR3n+GUXkMyZUGJC6z\nsfmc9FnCqWopDgPr+UQ6pXwcz0MS8eVAJq82wWl/WFsSOF+Z/rW0lwZO8ebPcjHW\nJkcxE2vkCj0t2cPWBl8gr5vc2Z9UeYj3KV0Sy7I/0DemllspLma+L0ZOe+KFzHI=\n=dBrc\n-----END PGP SIGNATURE-----\n", "payload": "tree 75fad4fe46779d6222deca4884499ba8cd7cb4ee\nparent 3af14f994d7d5f0cef7d1f15bcfe6cab40685244\nparent d34090a10a6517f3e3ea8528936175953ce8bc3d\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1575129407 +0100\ncommitter GitHub <noreply@github.com> 1575129407 +0100\n\nRollup merge of #66705 - pitdicker:atomic_mut_ptr, r=KodrAus\n\nAtomic as_mut_ptr\n\nI encountered the following pattern a few times: In Rust we use some atomic type like `AtomicI32`, and an FFI interface exposes this as `*mut i32` (or some similar `libc` type).\n\nIt was not obvious to me if a just transmuting a pointer to the atomic was acceptable, or if this should use a cast that goes through an `UnsafeCell`. See https://github.com/rust-lang/rust/issues/66136#issuecomment-557802477\n\nTransmuting the pointer directly:\n```rust\nlet atomic = AtomicI32::new(1);\nlet ptr = &atomic as *const AtomicI32 as *mut i32;\nunsafe {\n    ffi(ptr);\n}\n```\n\nA dance with `UnsafeCell`:\n```rust\nlet atomic = AtomicI32::new(1);\nunsafe {\n    let ptr = (&*(&atomic as *const AtomicI32 as *const UnsafeCell<i32>)).get();\n    ffi(ptr);\n}\n```\n\nMaybe in the end both ways could be valid. But why not expose a direct method to get a pointer from the standard library?\n\nAn `as_mut_ptr` method on atomics can be safe, because only the use of the resulting pointer is where things can get unsafe. I documented its use for FFI, and \"Doing non-atomic reads and writes on the resulting integer can be a data race.\"\n\nThe standard library could make use this method in a few places in the WASM module.\n\ncc @RalfJung as you answered my original question.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/123406cac7168fa2e169b404b852d1d265f34c99", "html_url": "https://github.com/rust-lang/rust/commit/123406cac7168fa2e169b404b852d1d265f34c99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/123406cac7168fa2e169b404b852d1d265f34c99/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3af14f994d7d5f0cef7d1f15bcfe6cab40685244", "url": "https://api.github.com/repos/rust-lang/rust/commits/3af14f994d7d5f0cef7d1f15bcfe6cab40685244", "html_url": "https://github.com/rust-lang/rust/commit/3af14f994d7d5f0cef7d1f15bcfe6cab40685244"}, {"sha": "d34090a10a6517f3e3ea8528936175953ce8bc3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d34090a10a6517f3e3ea8528936175953ce8bc3d", "html_url": "https://github.com/rust-lang/rust/commit/d34090a10a6517f3e3ea8528936175953ce8bc3d"}], "stats": {"total": 85, "additions": 80, "deletions": 5}, "files": [{"sha": "251d49db0625389baf9260ad076b9c8a8cba2a7d", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/123406cac7168fa2e169b404b852d1d265f34c99/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123406cac7168fa2e169b404b852d1d265f34c99/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=123406cac7168fa2e169b404b852d1d265f34c99", "patch": "@@ -802,6 +802,43 @@ impl AtomicBool {\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n     }\n+\n+    /// Returns a mutable pointer to the underlying [`bool`].\n+    ///\n+    /// Doing non-atomic reads and writes on the resulting integer can be a data race.\n+    /// This method is mostly useful for FFI, where the function signature may use\n+    /// `*mut bool` instead of `&AtomicBool`.\n+    ///\n+    /// Returning an `*mut` pointer from a shared reference to this atomic is safe because the\n+    /// atomic types work with interior mutability. All modifications of an atomic change the value\n+    /// through a shared reference, and can do so safely as long as they use atomic operations. Any\n+    /// use of the returned raw pointer requires an `unsafe` block and still has to uphold the same\n+    /// restriction: operations on it must be atomic.\n+    ///\n+    /// [`bool`]: ../../../std/primitive.bool.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore (extern-declaration)\n+    /// # fn main() {\n+    /// use std::sync::atomic::AtomicBool;\n+    /// extern {\n+    ///     fn my_atomic_op(arg: *mut bool);\n+    /// }\n+    ///\n+    /// let mut atomic = AtomicBool::new(true);\n+    /// unsafe {\n+    ///     my_atomic_op(atomic.as_mut_ptr());\n+    /// }\n+    /// # }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"atomic_mut_ptr\",\n+           reason = \"recently added\",\n+           issue = \"66893\")]\n+    pub fn as_mut_ptr(&self) -> *mut bool {\n+        self.v.get() as *mut bool\n+    }\n }\n \n #[cfg(target_has_atomic_load_store = \"ptr\")]\n@@ -1891,6 +1928,43 @@ assert_eq!(min_foo, 12);\n                 }\n             }\n \n+            doc_comment! {\n+                concat!(\"Returns a mutable pointer to the underlying integer.\n+\n+Doing non-atomic reads and writes on the resulting integer can be a data race.\n+This method is mostly useful for FFI, where the function signature may use\n+`*mut \", stringify!($int_type), \"` instead of `&\", stringify!($atomic_type), \"`.\n+\n+Returning an `*mut` pointer from a shared reference to this atomic is safe because the\n+atomic types work with interior mutability. All modifications of an atomic change the value\n+through a shared reference, and can do so safely as long as they use atomic operations. Any\n+use of the returned raw pointer requires an `unsafe` block and still has to uphold the same\n+restriction: operations on it must be atomic.\n+\n+# Examples\n+\n+```ignore (extern-declaration)\n+# fn main() {\n+\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n+\n+extern {\n+    fn my_atomic_op(arg: *mut \", stringify!($int_type), \");\n+}\n+\n+let mut atomic = \", stringify!($atomic_type), \"::new(1);\n+unsafe {\n+    my_atomic_op(atomic.as_mut_ptr());\n+}\n+# }\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"atomic_mut_ptr\",\n+                       reason = \"recently added\",\n+                       issue = \"66893\")]\n+                pub fn as_mut_ptr(&self) -> *mut $int_type {\n+                    self.v.get()\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "1dbb0c6ec8310b3b9084246ada779710f5ed2278", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/123406cac7168fa2e169b404b852d1d265f34c99/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123406cac7168fa2e169b404b852d1d265f34c99/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=123406cac7168fa2e169b404b852d1d265f34c99", "patch": "@@ -234,6 +234,7 @@\n #![feature(allocator_internals)]\n #![feature(allow_internal_unsafe)]\n #![feature(allow_internal_unstable)]\n+#![feature(atomic_mut_ptr)]\n #![feature(arbitrary_self_types)]\n #![feature(array_error_internals)]\n #![feature(asm)]"}, {"sha": "05e55334ac008a3164d532bd1d4e52e2efc75625", "filename": "src/libstd/sys/wasm/alloc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123406cac7168fa2e169b404b852d1d265f34c99/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123406cac7168fa2e169b404b852d1d265f34c99/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs?ref=123406cac7168fa2e169b404b852d1d265f34c99", "patch": "@@ -67,7 +67,7 @@ mod lock {\n             //\n             //     unsafe {\n             //         let r = core::arch::wasm32::i32_atomic_wait(\n-            //             &LOCKED as *const AtomicI32 as *mut i32,\n+            //             LOCKED.as_mut_ptr(),\n             //             1,  //     expected value\n             //             -1, //     timeout\n             //         );\n@@ -143,7 +143,7 @@ mod lock {\n             //\n             //     unsafe {\n             //         core::arch::wasm32::atomic_notify(\n-            //             &LOCKED as *const AtomicI32 as *mut i32,\n+            //             LOCKED.as_mut_ptr(),\n             //             1, //     only one thread\n             //         );\n             //     }"}, {"sha": "f452bbd3487872206ca34d57cfc84fb4c4aef3bf", "filename": "src/libstd/sys/wasm/condvar_atomics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123406cac7168fa2e169b404b852d1d265f34c99/src%2Flibstd%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123406cac7168fa2e169b404b852d1d265f34c99/src%2Flibstd%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fcondvar_atomics.rs?ref=123406cac7168fa2e169b404b852d1d265f34c99", "patch": "@@ -89,6 +89,6 @@ impl Condvar {\n     #[inline]\n     fn ptr(&self) -> *mut i32 {\n         assert_eq!(mem::size_of::<usize>(), mem::size_of::<i32>());\n-        &self.cnt as *const AtomicUsize as *mut i32\n+        self.cnt.as_mut_ptr() as *mut i32\n     }\n }"}, {"sha": "cddd584dd2207354373d10f9b11a08326f573492", "filename": "src/libstd/sys/wasm/mutex_atomics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123406cac7168fa2e169b404b852d1d265f34c99/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123406cac7168fa2e169b404b852d1d265f34c99/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs?ref=123406cac7168fa2e169b404b852d1d265f34c99", "patch": "@@ -56,7 +56,7 @@ impl Mutex {\n     #[inline]\n     fn ptr(&self) -> *mut i32 {\n         assert_eq!(mem::size_of::<usize>(), mem::size_of::<i32>());\n-        &self.locked as *const AtomicUsize as *mut isize as *mut i32\n+        self.locked.as_mut_ptr() as *mut i32\n     }\n }\n \n@@ -145,6 +145,6 @@ impl ReentrantMutex {\n \n     #[inline]\n     fn ptr(&self) -> *mut i32 {\n-        &self.owner as *const AtomicU32 as *mut i32\n+        self.owner.as_mut_ptr() as *mut i32\n     }\n }"}]}