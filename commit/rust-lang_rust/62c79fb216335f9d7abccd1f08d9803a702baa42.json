{"sha": "62c79fb216335f9d7abccd1f08d9803a702baa42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyYzc5ZmIyMTYzMzVmOWQ3YWJjY2QxZjA4ZDk4MDNhNzAyYmFhNDI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-06T02:57:28Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-06T02:57:28Z"}, "message": "Sketch closure-forming logic for nontrivial bindings.", "tree": {"sha": "d94c974bd316a1ad8034b19a341a435d820fc609", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d94c974bd316a1ad8034b19a341a435d820fc609"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62c79fb216335f9d7abccd1f08d9803a702baa42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62c79fb216335f9d7abccd1f08d9803a702baa42", "html_url": "https://github.com/rust-lang/rust/commit/62c79fb216335f9d7abccd1f08d9803a702baa42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62c79fb216335f9d7abccd1f08d9803a702baa42/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3f63da7c8ac7c89b95a85f1e7c1d4ec300dea0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3f63da7c8ac7c89b95a85f1e7c1d4ec300dea0d", "html_url": "https://github.com/rust-lang/rust/commit/f3f63da7c8ac7c89b95a85f1e7c1d4ec300dea0d"}], "stats": {"total": 83, "additions": 79, "deletions": 4}, "files": [{"sha": "8cef343984c597da7f65a8929ab9fe83093f838a", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62c79fb216335f9d7abccd1f08d9803a702baa42/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c79fb216335f9d7abccd1f08d9803a702baa42/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=62c79fb216335f9d7abccd1f08d9803a702baa42", "patch": "@@ -49,6 +49,12 @@ const int obj_body_elt_fields = 1;\n const int fn_field_code = 0;\n const int fn_field_box = 1;\n \n+const int closure_elt_tydesc = 0;\n+const int closure_elt_target = 1;\n+const int closure_elt_bindings = 2;\n+const int closure_elt_ty_params = 3;\n+\n+\n const int worst_case_glue_call_args = 7;\n \n const int n_upcall_glues = 7;"}, {"sha": "a241eddb98dab6bee9b497d630e7d5099d8b590e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 73, "deletions": 4, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/62c79fb216335f9d7abccd1f08d9803a702baa42/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c79fb216335f9d7abccd1f08d9803a702baa42/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=62c79fb216335f9d7abccd1f08d9803a702baa42", "patch": "@@ -1955,24 +1955,93 @@ impure fn trans_bind(@block_ctxt cx, @ast.expr f,\n     if (f_res.is_mem) {\n         cx.fcx.ccx.sess.unimpl(\"re-binding existing function\");\n     } else {\n-        let vec[@ty.t] bound = vec();\n+        let vec[@ast.expr] bound = vec();\n+\n         for (option.t[@ast.expr] argopt in args) {\n             alt (argopt) {\n                 case (none[@ast.expr]) {\n                 }\n                 case (some[@ast.expr](?e)) {\n-                    append[@ty.t](bound, ty.expr_ty(e));\n+                    append[@ast.expr](bound, e);\n                 }\n             }\n         }\n-        if (_vec.len[@ty.t](bound) == 0u) {\n+        if (_vec.len[@ast.expr](bound) == 0u) {\n             // Trivial 'binding': just return the static pair-ptr.\n             ret f_res.res;\n         } else {\n             auto bcx = f_res.res.bcx;\n             auto pair_t = node_type(cx.fcx.ccx, ann);\n             auto pair_v = bcx.build.Alloca(pair_t);\n-            cx.fcx.ccx.sess.unimpl(\"nontrivial binding\");\n+\n+            auto pair_box = bcx.build.GEP(pair_v,\n+                                          vec(C_int(0),\n+                                              C_int(abi.fn_field_box)));\n+\n+            // Translate the bound expressions.\n+            let vec[@ty.t] bound_tys = vec();\n+            let vec[ValueRef] bound_vals = vec();\n+            for (@ast.expr e in bound) {\n+                auto arg = trans_expr(bcx, e);\n+                bcx = arg.bcx;\n+                append[ValueRef](bound_vals, arg.val);\n+                append[@ty.t](bound_tys, ty.expr_ty(e));\n+            }\n+\n+            // Synthesize a closure type.\n+            let @ty.t bindings_ty = ty.plain_ty(ty.ty_tup(bound_tys));\n+            let TypeRef llbindings_ty = type_of(bcx.fcx.ccx,\n+                                                bindings_ty);\n+            let TypeRef llclosure_ty =\n+                T_ptr(T_box(T_struct(vec(T_ptr(T_tydesc()),\n+                                         type_of(bcx.fcx.ccx,\n+                                                 ty.expr_ty(f)),\n+                                         llbindings_ty)\n+                                     // FIXME: add captured typarams.\n+                                     )));\n+\n+            // Malloc a box for the body.\n+            auto r = trans_malloc_inner(bcx, llclosure_ty);\n+            auto box = r.val;\n+            bcx = r.bcx;\n+            auto rc = bcx.build.GEP(box,\n+                                    vec(C_int(0),\n+                                        C_int(abi.box_rc_field_refcnt)));\n+            auto closure =\n+                bcx.build.GEP(box,\n+                              vec(C_int(0),\n+                                  C_int(abi.box_rc_field_body)));\n+            bcx.build.Store(C_int(1), rc);\n+\n+\n+            // Store bindings tydesc.\n+            auto bound_tydesc =\n+                bcx.build.GEP(closure,\n+                              vec(C_int(0),\n+                                  C_int(abi.closure_elt_tydesc)));\n+\n+            auto bindings_tydesc = get_tydesc(bcx, bindings_ty);\n+            bcx.build.Store(bindings_tydesc, bound_tydesc);\n+\n+            // Copy args into body fields.\n+            auto bindings =\n+                bcx.build.GEP(closure,\n+                              vec(C_int(0),\n+                                  C_int(abi.closure_elt_bindings)));\n+\n+            let int i = 0;\n+            for (ValueRef v in bound_vals) {\n+                auto bound = bcx.build.GEP(bindings,\n+                                           vec(C_int(0),C_int(i)));\n+                bcx = copy_ty(r.bcx, true, bound, v, bound_tys.(i)).bcx;\n+                i += 1;\n+            }\n+\n+            // Store box ptr in outer pair.\n+            let TypeRef llbox_ty = T_ptr(T_box(T_nil()));\n+            auto p = r.bcx.build.PointerCast(box, llbox_ty);\n+            bcx.build.Store(p, pair_box);\n+\n             ret res(bcx, pair_v);\n         }\n     }"}]}