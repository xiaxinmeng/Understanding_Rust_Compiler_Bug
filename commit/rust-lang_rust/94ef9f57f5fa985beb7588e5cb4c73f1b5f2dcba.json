{"sha": "94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0ZWY5ZjU3ZjVmYTk4NWJlYjc1ODhlNWNiNGM3M2YxYjVmMmRjYmE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-30T16:53:46Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-07-08T13:17:37Z"}, "message": "hygiene: Decouple transparencies from expansion IDs", "tree": {"sha": "6fd06514639327df46c5a78a93f2a01008e3d6d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fd06514639327df46c5a78a93f2a01008e3d6d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba", "html_url": "https://github.com/rust-lang/rust/commit/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01b6d7cc6f1b1513b717bdc1bbc48f7407d4964c", "url": "https://api.github.com/repos/rust-lang/rust/commits/01b6d7cc6f1b1513b717bdc1bbc48f7407d4964c", "html_url": "https://github.com/rust-lang/rust/commit/01b6d7cc6f1b1513b717bdc1bbc48f7407d4964c"}], "stats": {"total": 190, "additions": 122, "deletions": 68}, "files": [{"sha": "876cf295acc1ba984c3037f2b630191a097dc3e6", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba", "patch": "@@ -1351,7 +1351,7 @@ pub mod __internal {\n     use syntax::parse::token::{self, Token};\n     use syntax::tokenstream;\n     use syntax_pos::{BytePos, Loc, DUMMY_SP};\n-    use syntax_pos::hygiene::{Mark, SyntaxContext, Transparency};\n+    use syntax_pos::hygiene::{SyntaxContext, Transparency};\n \n     use super::{TokenStream, LexError, Span};\n \n@@ -1436,20 +1436,15 @@ pub mod __internal {\n \n             // No way to determine def location for a proc macro right now, so use call location.\n             let location = cx.current_expansion.mark.expn_info().unwrap().call_site;\n-            // Opaque mark was already created by expansion, now create its transparent twin.\n-            // We can't use the call-site span literally here, even if it appears to provide\n-            // correct name resolution, because it has all the `ExpnInfo` wrong, so the edition\n-            // checks, lint macro checks, macro backtraces will all break.\n-            let opaque_mark = cx.current_expansion.mark;\n-            let transparent_mark = Mark::fresh_cloned(opaque_mark);\n-            transparent_mark.set_transparency(Transparency::Transparent);\n-\n-            let to_span = |mark| Span(location.with_ctxt(SyntaxContext::empty().apply_mark(mark)));\n+            let to_span = |transparency| Span(location.with_ctxt(\n+                SyntaxContext::empty().apply_mark_with_transparency(cx.current_expansion.mark,\n+                                                                    transparency))\n+            );\n             p.set(ProcMacroSess {\n                 parse_sess: cx.parse_sess,\n                 data: ProcMacroData {\n-                    def_site: to_span(opaque_mark),\n-                    call_site: to_span(transparent_mark),\n+                    def_site: to_span(Transparency::Opaque),\n+                    call_site: to_span(Transparency::Transparent),\n                 },\n             });\n             f()"}, {"sha": "e8dcfc027ef8b2b3b76daea28743398e48c7e536", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba", "patch": "@@ -1996,17 +1996,17 @@ impl<'a> Resolver<'a> {\n             let mut iter = ctxt.marks().into_iter().rev().peekable();\n             let mut result = None;\n             // Find the last modern mark from the end if it exists.\n-            while let Some(&mark) = iter.peek() {\n-                if mark.transparency() == Transparency::Opaque {\n+            while let Some(&(mark, transparency)) = iter.peek() {\n+                if transparency == Transparency::Opaque {\n                     result = Some(mark);\n                     iter.next();\n                 } else {\n                     break;\n                 }\n             }\n             // Then find the last legacy mark from the end if it exists.\n-            for mark in iter {\n-                if mark.transparency() == Transparency::SemiTransparent {\n+            for (mark, transparency) in iter {\n+                if transparency == Transparency::SemiTransparent {\n                     result = Some(mark);\n                 } else {\n                     break;"}, {"sha": "9ce1e21d0d03ebfef3fb899ed2a8db6f5820d63d", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba", "patch": "@@ -24,7 +24,7 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Annotatable, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n use syntax::ext::expand::{self, AstFragment, AstFragmentKind, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{self, Mark, Transparency};\n+use syntax::ext::hygiene::{self, Mark};\n use syntax::ext::placeholders::placeholder;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{self, emit_feature_err, GateIssue};\n@@ -331,13 +331,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         self.unused_macros.remove(&def_id);\n         let ext = self.get_macro(def);\n-        if ext.is_modern() {\n-            let transparency =\n-                if ext.is_transparent() { Transparency::Transparent } else { Transparency::Opaque };\n-            invoc.expansion_data.mark.set_transparency(transparency);\n-        } else if def_id.krate == BUILTIN_MACROS_CRATE {\n-            invoc.expansion_data.mark.set_is_builtin(true);\n-        }\n+        invoc.expansion_data.mark.set_default_transparency(ext.default_transparency());\n+        invoc.expansion_data.mark.set_is_builtin(def_id.krate == BUILTIN_MACROS_CRATE);\n         Ok(Some(ext))\n     }\n "}, {"sha": "2e9c7d6f96c454db7897db7868d530192ef5baa0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba", "patch": "@@ -17,7 +17,7 @@ use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n use edition::Edition;\n use errors::{DiagnosticBuilder, DiagnosticId};\n use ext::expand::{self, AstFragment, Invocation};\n-use ext::hygiene::{self, Mark, SyntaxContext};\n+use ext::hygiene::{self, Mark, SyntaxContext, Transparency};\n use fold::{self, Folder};\n use parse::{self, parser, DirectoryOwnership};\n use parse::token;\n@@ -673,20 +673,14 @@ impl SyntaxExtension {\n         }\n     }\n \n-    pub fn is_modern(&self) -> bool {\n+    pub fn default_transparency(&self) -> Transparency {\n         match *self {\n-            SyntaxExtension::DeclMacro { .. } |\n             SyntaxExtension::ProcMacro { .. } |\n             SyntaxExtension::AttrProcMacro(..) |\n-            SyntaxExtension::ProcMacroDerive(..) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_transparent(&self) -> bool {\n-        match *self {\n-            SyntaxExtension::DeclMacro { is_transparent, .. } => is_transparent,\n-            _ => false,\n+            SyntaxExtension::ProcMacroDerive(..) |\n+            SyntaxExtension::DeclMacro { is_transparent: false, .. } => Transparency::Opaque,\n+            SyntaxExtension::DeclMacro { is_transparent: true, .. } => Transparency::Transparent,\n+            _ => Transparency::SemiTransparent,\n         }\n     }\n "}, {"sha": "385174ea7fea73bea503f98cfd501dc4f4aa59f0", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 44, "deletions": 32, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba", "patch": "@@ -32,6 +32,7 @@ pub struct SyntaxContext(u32);\n #[derive(Copy, Clone, Debug)]\n struct SyntaxContextData {\n     outer_mark: Mark,\n+    transparency: Transparency,\n     prev_ctxt: SyntaxContext,\n     // This context, but with all transparent and semi-transparent marks filtered away.\n     opaque: SyntaxContext,\n@@ -46,14 +47,14 @@ pub struct Mark(u32);\n #[derive(Clone, Debug)]\n struct MarkData {\n     parent: Mark,\n-    transparency: Transparency,\n+    default_transparency: Transparency,\n     is_builtin: bool,\n     expn_info: Option<ExpnInfo>,\n }\n \n /// A property of a macro expansion that determines how identifiers\n /// produced by that expansion are resolved.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug)]\n pub enum Transparency {\n     /// Identifier produced by a transparent expansion is always resolved at call-site.\n     /// Call-site spans in procedural macros, hygiene opt-out in `macro` should use this.\n@@ -81,7 +82,7 @@ impl Mark {\n             Mark::fresh_with_data(MarkData {\n                 parent,\n                 // By default expansions behave like `macro_rules`.\n-                transparency: Transparency::SemiTransparent,\n+                default_transparency: Transparency::SemiTransparent,\n                 is_builtin: false,\n                 expn_info: None,\n             }, data)\n@@ -127,34 +128,32 @@ impl Mark {\n         })\n     }\n \n+    // FIXME: This operation doesn't really make sense when single macro expansion\n+    // can produce tokens with different transparencies. Figure out how to avoid it.\n     pub fn modern(mut self) -> Mark {\n         HygieneData::with(|data| {\n-            while data.marks[self.0 as usize].transparency != Transparency::Opaque {\n+            while data.marks[self.0 as usize].default_transparency != Transparency::Opaque {\n                 self = data.marks[self.0 as usize].parent;\n             }\n             self\n         })\n     }\n \n     #[inline]\n-    pub fn transparency(self) -> Transparency {\n-        assert_ne!(self, Mark::root());\n-        HygieneData::with(|data| data.marks[self.0 as usize].transparency)\n-    }\n-\n-    #[inline]\n-    pub fn set_transparency(self, transparency: Transparency) {\n+    pub fn set_default_transparency(self, transparency: Transparency) {\n         assert_ne!(self, Mark::root());\n-        HygieneData::with(|data| data.marks[self.0 as usize].transparency = transparency)\n+        HygieneData::with(|data| data.marks[self.0 as usize].default_transparency = transparency)\n     }\n \n     #[inline]\n     pub fn is_builtin(self) -> bool {\n+        assert_ne!(self, Mark::root());\n         HygieneData::with(|data| data.marks[self.0 as usize].is_builtin)\n     }\n \n     #[inline]\n     pub fn set_is_builtin(self, is_builtin: bool) {\n+        assert_ne!(self, Mark::root());\n         HygieneData::with(|data| data.marks[self.0 as usize].is_builtin = is_builtin)\n     }\n \n@@ -201,7 +200,7 @@ impl Mark {\n crate struct HygieneData {\n     marks: Vec<MarkData>,\n     syntax_contexts: Vec<SyntaxContextData>,\n-    markings: HashMap<(SyntaxContext, Mark), SyntaxContext>,\n+    markings: HashMap<(SyntaxContext, Mark, Transparency), SyntaxContext>,\n     default_edition: Edition,\n }\n \n@@ -212,12 +211,13 @@ impl HygieneData {\n                 parent: Mark::root(),\n                 // If the root is opaque, then loops searching for an opaque mark\n                 // will automatically stop after reaching it.\n-                transparency: Transparency::Opaque,\n+                default_transparency: Transparency::Opaque,\n                 is_builtin: true,\n                 expn_info: None,\n             }],\n             syntax_contexts: vec![SyntaxContextData {\n                 outer_mark: Mark::root(),\n+                transparency: Transparency::Opaque,\n                 prev_ctxt: SyntaxContext(0),\n                 opaque: SyntaxContext(0),\n                 opaque_and_semitransparent: SyntaxContext(0),\n@@ -267,7 +267,7 @@ impl SyntaxContext {\n         HygieneData::with(|data| {\n             data.marks.push(MarkData {\n                 parent: Mark::root(),\n-                transparency: Transparency::SemiTransparent,\n+                default_transparency: Transparency::SemiTransparent,\n                 is_builtin: false,\n                 expn_info: Some(expansion_info),\n             });\n@@ -276,6 +276,7 @@ impl SyntaxContext {\n \n             data.syntax_contexts.push(SyntaxContextData {\n                 outer_mark: mark,\n+                transparency: Transparency::SemiTransparent,\n                 prev_ctxt: SyntaxContext::empty(),\n                 opaque: SyntaxContext::empty(),\n                 opaque_and_semitransparent: SyntaxContext::empty(),\n@@ -284,22 +285,31 @@ impl SyntaxContext {\n         })\n     }\n \n-    /// Extend a syntax context with a given mark\n     pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n-        if mark.transparency() == Transparency::Opaque {\n-            return self.apply_mark_internal(mark);\n+        assert_ne!(mark, Mark::root());\n+        self.apply_mark_with_transparency(\n+            mark, HygieneData::with(|data| data.marks[mark.0 as usize].default_transparency)\n+        )\n+    }\n+\n+    /// Extend a syntax context with a given mark and transparency\n+    pub fn apply_mark_with_transparency(self, mark: Mark, transparency: Transparency)\n+                                        -> SyntaxContext {\n+        assert_ne!(mark, Mark::root());\n+        if transparency == Transparency::Opaque {\n+            return self.apply_mark_internal(mark, transparency);\n         }\n \n         let call_site_ctxt =\n             mark.expn_info().map_or(SyntaxContext::empty(), |info| info.call_site.ctxt());\n-        let call_site_ctxt = if mark.transparency() == Transparency::SemiTransparent {\n+        let call_site_ctxt = if transparency == Transparency::SemiTransparent {\n             call_site_ctxt.modern()\n         } else {\n             call_site_ctxt.modern_and_legacy()\n         };\n \n         if call_site_ctxt == SyntaxContext::empty() {\n-            return self.apply_mark_internal(mark);\n+            return self.apply_mark_internal(mark, transparency);\n         }\n \n         // Otherwise, `mark` is a macros 1.0 definition and the call site is in a\n@@ -312,27 +322,26 @@ impl SyntaxContext {\n         //\n         // See the example at `test/run-pass/hygiene/legacy_interaction.rs`.\n         let mut ctxt = call_site_ctxt;\n-        for mark in self.marks() {\n-            ctxt = ctxt.apply_mark_internal(mark);\n+        for (mark, transparency) in self.marks() {\n+            ctxt = ctxt.apply_mark_internal(mark, transparency);\n         }\n-        ctxt.apply_mark_internal(mark)\n+        ctxt.apply_mark_internal(mark, transparency)\n     }\n \n-    fn apply_mark_internal(self, mark: Mark) -> SyntaxContext {\n+    fn apply_mark_internal(self, mark: Mark, transparency: Transparency) -> SyntaxContext {\n         HygieneData::with(|data| {\n             let syntax_contexts = &mut data.syntax_contexts;\n-            let transparency = data.marks[mark.0 as usize].transparency;\n-\n             let mut opaque = syntax_contexts[self.0 as usize].opaque;\n             let mut opaque_and_semitransparent =\n                 syntax_contexts[self.0 as usize].opaque_and_semitransparent;\n \n             if transparency >= Transparency::Opaque {\n                 let prev_ctxt = opaque;\n-                opaque = *data.markings.entry((prev_ctxt, mark)).or_insert_with(|| {\n+                opaque = *data.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n                     let new_opaque = SyntaxContext(syntax_contexts.len() as u32);\n                     syntax_contexts.push(SyntaxContextData {\n                         outer_mark: mark,\n+                        transparency,\n                         prev_ctxt,\n                         opaque: new_opaque,\n                         opaque_and_semitransparent: new_opaque,\n@@ -344,11 +353,12 @@ impl SyntaxContext {\n             if transparency >= Transparency::SemiTransparent {\n                 let prev_ctxt = opaque_and_semitransparent;\n                 opaque_and_semitransparent =\n-                        *data.markings.entry((prev_ctxt, mark)).or_insert_with(|| {\n+                        *data.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n                     let new_opaque_and_semitransparent =\n                         SyntaxContext(syntax_contexts.len() as u32);\n                     syntax_contexts.push(SyntaxContextData {\n                         outer_mark: mark,\n+                        transparency,\n                         prev_ctxt,\n                         opaque,\n                         opaque_and_semitransparent: new_opaque_and_semitransparent,\n@@ -358,11 +368,12 @@ impl SyntaxContext {\n             }\n \n             let prev_ctxt = self;\n-            *data.markings.entry((prev_ctxt, mark)).or_insert_with(|| {\n+            *data.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n                 let new_opaque_and_semitransparent_and_transparent =\n                     SyntaxContext(syntax_contexts.len() as u32);\n                 syntax_contexts.push(SyntaxContextData {\n                     outer_mark: mark,\n+                    transparency,\n                     prev_ctxt,\n                     opaque,\n                     opaque_and_semitransparent,\n@@ -396,12 +407,13 @@ impl SyntaxContext {\n         })\n     }\n \n-    pub fn marks(mut self) -> Vec<Mark> {\n+    pub fn marks(mut self) -> Vec<(Mark, Transparency)> {\n         HygieneData::with(|data| {\n             let mut marks = Vec::new();\n             while self != SyntaxContext::empty() {\n-                marks.push(data.syntax_contexts[self.0 as usize].outer_mark);\n-                self = data.syntax_contexts[self.0 as usize].prev_ctxt;\n+                let ctxt_data = &data.syntax_contexts[self.0 as usize];\n+                marks.push((ctxt_data.outer_mark, ctxt_data.transparency));\n+                self = ctxt_data.prev_ctxt;\n             }\n             marks.reverse();\n             marks"}, {"sha": "1741b0eed8927b35efc5248575ba1b7858ab8a38", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/generate-mod.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fgenerate-mod.rs?ref=94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-pass\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro]\n+pub fn check(_: TokenStream) -> TokenStream {\n+    \"\n+    struct Outer;\n+    mod inner {\n+        type Inner = Outer; // `Outer` shouldn't be available from here\n+    }\n+    \".parse().unwrap()\n+}"}, {"sha": "509cd33d93d34c148b18ea829a7ad6708b7f3d66", "filename": "src/test/ui-fulldeps/proc-macro/generate-mod.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs?ref=94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Modules generated by transparent proc macros still acts as barriers for names (issue #50504).\n+\n+// aux-build:generate-mod.rs\n+\n+#![feature(proc_macro, proc_macro_gen)]\n+\n+extern crate generate_mod;\n+\n+generate_mod::check!(); //~ ERROR cannot find type `Outer` in this scope\n+\n+fn main() {}"}, {"sha": "80213b04dceb05842e4fe7a340428aeddf31e6bd", "filename": "src/test/ui-fulldeps/proc-macro/generate-mod.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.stderr?ref=94ef9f57f5fa985beb7588e5cb4c73f1b5f2dcba", "patch": "@@ -0,0 +1,9 @@\n+error[E0412]: cannot find type `Outer` in this scope\n+  --> $DIR/generate-mod.rs:19:1\n+   |\n+LL | generate_mod::check!(); //~ ERROR cannot find type `Outer` in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}]}