{"sha": "b997de529a80fc5e17b9ef37ed053f6913969790", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5OTdkZTUyOWE4MGZjNWUxN2I5ZWYzN2VkMDUzZjY5MTM5Njk3OTA=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2014-05-15T11:23:46Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2014-05-25T20:30:50Z"}, "message": "Change regex! macro to expand to a constexpr, allowing to put it in a static", "tree": {"sha": "c0c1ebf7b820c4c1e75bfb351a6e7dfd985bb428", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0c1ebf7b820c4c1e75bfb351a6e7dfd985bb428"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b997de529a80fc5e17b9ef37ed053f6913969790", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b997de529a80fc5e17b9ef37ed053f6913969790", "html_url": "https://github.com/rust-lang/rust/commit/b997de529a80fc5e17b9ef37ed053f6913969790", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b997de529a80fc5e17b9ef37ed053f6913969790/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "759517c180857e1b494486d810c882755a1e2e26", "url": "https://api.github.com/repos/rust-lang/rust/commits/759517c180857e1b494486d810c882755a1e2e26", "html_url": "https://github.com/rust-lang/rust/commit/759517c180857e1b494486d810c882755a1e2e26"}], "stats": {"total": 169, "additions": 125, "deletions": 44}, "files": [{"sha": "3e100b7889cd1750bd8523e89520a97414f5bee2", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b997de529a80fc5e17b9ef37ed053f6913969790/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b997de529a80fc5e17b9ef37ed053f6913969790/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=b997de529a80fc5e17b9ef37ed053f6913969790", "patch": "@@ -401,7 +401,7 @@ pub mod native {\n     // undesirable consequences (such as requiring a dependency on\n     // `libsyntax`).\n     //\n-    // Secondly, the code generated generated by `regex!` must *also* be able\n+    // Secondly, the code generated by `regex!` must *also* be able\n     // to access various functions in this crate to reduce code duplication\n     // and to provide a value with precisely the same `Regex` type in this\n     // crate. This, AFAIK, is impossible to mitigate."}, {"sha": "91b24888c24fa1cfa1ae2d7a704db52225473b45", "filename": "src/libregex/re.rs", "status": "modified", "additions": 83, "deletions": 34, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/b997de529a80fc5e17b9ef37ed053f6913969790/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b997de529a80fc5e17b9ef37ed053f6913969790/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=b997de529a80fc5e17b9ef37ed053f6913969790", "patch": "@@ -100,38 +100,45 @@ pub fn is_match(regex: &str, text: &str) -> Result<bool, parse::Error> {\n /// documentation.\n #[deriving(Clone)]\n #[allow(visible_private_types)]\n-pub struct Regex {\n-    /// The representation of `Regex` is exported to support the `regex!`\n-    /// syntax extension. Do not rely on it.\n-    ///\n-    /// See the comments for the `program` module in `lib.rs` for a more\n-    /// detailed explanation for what `regex!` requires.\n+pub enum Regex {\n+    // The representation of `Regex` is exported to support the `regex!`\n+    // syntax extension. Do not rely on it.\n+    //\n+    // See the comments for the `program` module in `lib.rs` for a more\n+    // detailed explanation for what `regex!` requires.\n     #[doc(hidden)]\n-    pub original: String,\n+    Dynamic(Dynamic),\n     #[doc(hidden)]\n-    pub names: Vec<Option<String>>,\n+    Native(Native),\n+}\n+\n+#[deriving(Clone)]\n+#[doc(hidden)]\n+pub struct Dynamic {\n+    original: String,\n+    names: Vec<Option<String>>,\n     #[doc(hidden)]\n-    pub p: MaybeNative,\n+    pub prog: Program\n }\n \n-impl fmt::Show for Regex {\n-    /// Shows the original regular expression.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.original)\n-    }\n+#[doc(hidden)]\n+pub struct Native {\n+    #[doc(hidden)]\n+    pub original: &'static str,\n+    #[doc(hidden)]\n+    pub names: &'static [Option<&'static str>],\n+    #[doc(hidden)]\n+    pub prog: fn(MatchKind, &str, uint, uint) -> Vec<Option<uint>>\n }\n \n-pub enum MaybeNative {\n-    Dynamic(Program),\n-    Native(fn(MatchKind, &str, uint, uint) -> Vec<Option<uint>>),\n+impl Clone for Native {\n+    fn clone(&self) -> Native { *self }\n }\n \n-impl Clone for MaybeNative {\n-    fn clone(&self) -> MaybeNative {\n-        match *self {\n-            Dynamic(ref p) => Dynamic(p.clone()),\n-            Native(fp) => Native(fp),\n-        }\n+impl fmt::Show for Regex {\n+    /// Shows the original regular expression.\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.as_str())\n     }\n }\n \n@@ -146,10 +153,11 @@ impl Regex {\n     pub fn new(re: &str) -> Result<Regex, parse::Error> {\n         let ast = try!(parse::parse(re));\n         let (prog, names) = Program::new(ast);\n-        Ok(Regex {\n+        Ok(Dynamic(Dynamic {\n             original: re.to_strbuf(),\n-            names: names, p: Dynamic(prog),\n-        })\n+            names: names,\n+            prog: prog,\n+        }))\n     }\n \n     /// Returns true if and only if the regex matches the string given.\n@@ -495,6 +503,46 @@ impl Regex {\n         }\n         new.append(text.slice(last_match, text.len()))\n     }\n+\n+    /// Returns the original string of this regex.\n+    pub fn as_str<'a>(&'a self) -> &'a str {\n+        match *self {\n+            Dynamic(Dynamic { ref original, .. }) => original.as_slice(),\n+            Native(Native { ref original, .. }) => original.as_slice(),\n+        }\n+    }\n+\n+    #[doc(hidden)]\n+    #[allow(visible_private_types)]\n+    #[experimental]\n+    pub fn names_iter<'a>(&'a self) -> NamesIter<'a> {\n+        match *self {\n+            Native(ref n) => NamesIterNative(n.names.iter()),\n+            Dynamic(ref d) => NamesIterDynamic(d.names.iter())\n+        }\n+    }\n+\n+    fn names_len(&self) -> uint {\n+        match *self {\n+            Native(ref n) => n.names.len(),\n+            Dynamic(ref d) => d.names.len()\n+        }\n+    }\n+\n+}\n+\n+enum NamesIter<'a> {\n+    NamesIterNative(::std::slice::Items<'a, Option<&'static str>>),\n+    NamesIterDynamic(::std::slice::Items<'a, Option<String>>)\n+}\n+\n+impl<'a> Iterator<Option<String>> for NamesIter<'a> {\n+    fn next(&mut self) -> Option<Option<String>> {\n+        match *self {\n+            NamesIterNative(ref mut i) => i.next().map(|x| x.map(|s| s.to_strbuf())),\n+            NamesIterDynamic(ref mut i) => i.next().map(|x| x.as_ref().map(|s| s.to_strbuf())),\n+        }\n+    }\n }\n \n /// NoExpand indicates literal string replacement.\n@@ -612,22 +660,23 @@ pub struct Captures<'t> {\n }\n \n impl<'t> Captures<'t> {\n+    #[allow(experimental)]\n     fn new(re: &Regex, search: &'t str, locs: CaptureLocs)\n           -> Option<Captures<'t>> {\n         if !has_match(&locs) {\n             return None\n         }\n \n         let named =\n-            if re.names.len() == 0 {\n+            if re.names_len() == 0 {\n                 None\n             } else {\n                 let mut named = HashMap::new();\n-                for (i, name) in re.names.iter().enumerate() {\n+                for (i, name) in re.names_iter().enumerate() {\n                     match name {\n-                        &None => {},\n-                        &Some(ref name) => {\n-                            named.insert(name.to_strbuf(), i);\n+                        None => {},\n+                        Some(name) => {\n+                            named.insert(name, i);\n                         }\n                     }\n                 }\n@@ -862,9 +911,9 @@ fn exec(re: &Regex, which: MatchKind, input: &str) -> CaptureLocs {\n \n fn exec_slice(re: &Regex, which: MatchKind,\n               input: &str, s: uint, e: uint) -> CaptureLocs {\n-    match re.p {\n-        Dynamic(ref prog) => vm::run(which, prog, input, s, e),\n-        Native(exec) => exec(which, input, s, e),\n+    match *re {\n+        Dynamic(Dynamic { ref prog, .. }) => vm::run(which, prog, input, s, e),\n+        Native(Native { prog, .. }) => prog(which, input, s, e),\n     }\n }\n "}, {"sha": "c563c84fc34ed351971353ffadb6336f77efcc31", "filename": "src/libregex/test/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b997de529a80fc5e17b9ef37ed053f6913969790/src%2Flibregex%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b997de529a80fc5e17b9ef37ed053f6913969790/src%2Flibregex%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fmod.rs?ref=b997de529a80fc5e17b9ef37ed053f6913969790", "patch": "@@ -20,6 +20,9 @@ mod native_bench;\n #[path = \"tests.rs\"]\n mod native_tests;\n \n+#[cfg(not(stage1))]\n+mod native_static;\n+\n // Due to macro scoping rules, this definition only applies for the modules\n // defined below. Effectively, it allows us to use the same tests for both\n // native and dynamic regexes."}, {"sha": "62e14731c207bb3e99685bfd51d143a287f59494", "filename": "src/libregex/test/native_static.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b997de529a80fc5e17b9ef37ed053f6913969790/src%2Flibregex%2Ftest%2Fnative_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b997de529a80fc5e17b9ef37ed053f6913969790/src%2Flibregex%2Ftest%2Fnative_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fnative_static.rs?ref=b997de529a80fc5e17b9ef37ed053f6913969790", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use regex::Regex;\n+static RE: Regex = regex!(r\"\\d+\");\n+\n+#[test]\n+fn static_splitn() {\n+    let text = \"cauchy123plato456tyler789binx\";\n+    let subs: Vec<&str> = RE.splitn(text, 2).collect();\n+    assert_eq!(subs, vec!(\"cauchy\", \"plato456tyler789binx\"));\n+}\n+\n+#[test]\n+fn static_split() {\n+    let text = \"cauchy123plato456tyler789binx\";\n+    let subs: Vec<&str> = RE.split(text).collect();\n+    assert_eq!(subs, vec!(\"cauchy\", \"plato\", \"tyler\", \"binx\"));\n+}"}, {"sha": "971b727a165a3e4351abe8b1afbf2affa5851e05", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b997de529a80fc5e17b9ef37ed053f6913969790/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b997de529a80fc5e17b9ef37ed053f6913969790/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=b997de529a80fc5e17b9ef37ed053f6913969790", "patch": "@@ -75,6 +75,7 @@ pub fn macro_registrar(register: |ast::Name, SyntaxExtension|) {\n /// It is strongly recommended to read the dynamic implementation in vm.rs\n /// first before trying to understand the code generator. The implementation\n /// strategy is identical and vm.rs has comments and will be easier to follow.\n+#[allow(experimental)]\n fn native(cx: &mut ExtCtxt, sp: codemap::Span, tts: &[ast::TokenTree])\n           -> Box<MacResult> {\n     let regex = match parse(cx, tts) {\n@@ -89,14 +90,14 @@ fn native(cx: &mut ExtCtxt, sp: codemap::Span, tts: &[ast::TokenTree])\n             return DummyResult::any(sp)\n         }\n     };\n-    let prog = match re.p {\n-        Dynamic(ref prog) => prog.clone(),\n+    let prog = match re {\n+        Dynamic(Dynamic { ref prog, .. }) => prog.clone(),\n         Native(_) => unreachable!(),\n     };\n \n     let mut gen = NfaGen {\n         cx: &*cx, sp: sp, prog: prog,\n-        names: re.names.clone(), original: re.original.clone(),\n+        names: re.names_iter().collect(), original: re.as_str().to_strbuf(),\n     };\n     MacExpr::new(gen.code())\n }\n@@ -119,7 +120,7 @@ impl<'a> NfaGen<'a> {\n             |cx, name| match *name {\n                 Some(ref name) => {\n                     let name = name.as_slice();\n-                    quote_expr!(cx, Some($name.to_strbuf()))\n+                    quote_expr!(cx, Some($name))\n                 }\n                 None => cx.expr_none(self.sp),\n             }\n@@ -141,9 +142,11 @@ impl<'a> NfaGen<'a> {\n         let regex = self.original.as_slice();\n \n         quote_expr!(self.cx, {\n+static CAP_NAMES: &'static [Option<&'static str>] = &$cap_names;\n fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n             start: uint, end: uint) -> Vec<Option<uint>> {\n     #![allow(unused_imports)]\n+    #![allow(unused_mut)]\n     use regex::native::{\n         MatchKind, Exists, Location, Submatches,\n         StepState, StepMatchEarlyReturn, StepMatch, StepContinue,\n@@ -310,11 +313,11 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     }\n }\n \n-::regex::Regex {\n-    original: $regex.to_strbuf(),\n-    names: vec!$cap_names,\n-    p: ::regex::native::Native(exec),\n-}\n+::regex::native::Native(::regex::native::Native {\n+    original: $regex,\n+    names: CAP_NAMES,\n+    prog: exec,\n+})\n         })\n     }\n "}]}