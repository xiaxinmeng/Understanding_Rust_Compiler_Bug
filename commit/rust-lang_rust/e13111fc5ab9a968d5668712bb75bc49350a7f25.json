{"sha": "e13111fc5ab9a968d5668712bb75bc49350a7f25", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMzExMWZjNWFiOWE5NjhkNTY2ODcxMmJiNzViYzQ5MzUwYTdmMjU=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-02T22:03:41Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-07T04:41:58Z"}, "message": "Even more comments for ADT-related interfaces", "tree": {"sha": "31b2805839c009bbc602f324296e88e874800533", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31b2805839c009bbc602f324296e88e874800533"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e13111fc5ab9a968d5668712bb75bc49350a7f25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e13111fc5ab9a968d5668712bb75bc49350a7f25", "html_url": "https://github.com/rust-lang/rust/commit/e13111fc5ab9a968d5668712bb75bc49350a7f25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e13111fc5ab9a968d5668712bb75bc49350a7f25/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6840b48074ddb97d3a77f87c833fa8b9f10c1ccc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6840b48074ddb97d3a77f87c833fa8b9f10c1ccc", "html_url": "https://github.com/rust-lang/rust/commit/6840b48074ddb97d3a77f87c833fa8b9f10c1ccc"}], "stats": {"total": 52, "additions": 46, "deletions": 6}, "files": [{"sha": "e61925395f2a7608fa47681a97ee8a57df3cba88", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e13111fc5ab9a968d5668712bb75bc49350a7f25/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e13111fc5ab9a968d5668712bb75bc49350a7f25/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=e13111fc5ab9a968d5668712bb75bc49350a7f25", "patch": "@@ -394,9 +394,20 @@ pub fn trans_drop_flag_ptr(bcx: block, r: &Repr, val: ValueRef) -> ValueRef {\n  * alignment!) from the representation's `type_of`, so it needs a\n  * pointer cast before use.\n  *\n- * Currently it has the same size as the type, but this may be changed\n- * in the future to avoid allocating unnecessary space after values of\n- * shorter-than-maximum cases.\n+ * The LLVM type system does not directly support unions, and only\n+ * pointers can be bitcast, so a constant (and, by extension, the\n+ * GlobalVariable initialized by it) will have a type that can vary\n+ * depending on which case of an enum it is.\n+ *\n+ * To understand the alignment situation, consider `enum E { V64(u64),\n+ * V32(u32, u32) }` on win32.  The type should have 8-byte alignment\n+ * to accommodate the u64 (currently it doesn't; this is a known bug),\n+ * but `V32(x, y)` would have LLVM type `{i32, i32, i32}`, which is\n+ * 4-byte aligned.\n+ *\n+ * Currently the returned value has the same size as the type, but\n+ * this may be changed in the future to avoid allocating unnecessary\n+ * space after values of shorter-than-maximum cases.\n  */\n pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n                    vals: &[ValueRef]) -> ValueRef {\n@@ -424,6 +435,9 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n             let max_sz = cases.map(|s| s.size).max();\n             let body = build_const_struct(ccx, case, vals);\n \n+            // The unary packed struct has alignment 1 regardless of\n+            // its contents, so it will always be located at the\n+            // expected offset at runtime.\n             C_struct([C_int(ccx, discr),\n                       C_packed_struct([C_struct(body)]),\n                       padding(max_sz - case.size)])\n@@ -434,6 +448,12 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n /**\n  * Building structs is a little complicated, because we might need to\n  * insert padding if a field's value is less aligned than its type.\n+ *\n+ * Continuing the example from `trans_const`, a value of type `(u32,\n+ * E)` should have the `E` at offset 8, but if that field's\n+ * initializer is 4-byte aligned then simply translating the tuple as\n+ * a two-element struct will locate it at offset 4, and accesses to it\n+ * will read the wrong memory.\n  */\n fn build_const_struct(ccx: @CrateContext, st: &Struct, vals: &[ValueRef])\n     -> ~[ValueRef] {"}, {"sha": "699f73e7d777d51b5eac64abf03addd10558a08c", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e13111fc5ab9a968d5668712bb75bc49350a7f25/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e13111fc5ab9a968d5668712bb75bc49350a7f25/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e13111fc5ab9a968d5668712bb75bc49350a7f25", "patch": "@@ -1158,9 +1158,9 @@ fn trans_rec_or_struct(bcx: block,\n         let mut need_base = vec::from_elem(field_tys.len(), true);\n \n         let numbered_fields = do fields.map |field| {\n-            match do vec::position(field_tys) |field_ty| {\n-                field_ty.ident == field.node.ident\n-            } {\n+            let opt_pos = vec::position(field_tys, |field_ty|\n+                                        field_ty.ident == field.node.ident);\n+            match opt_pos {\n                 Some(i) => {\n                     need_base[i] = false;\n                     (i, field.node.expr)\n@@ -1196,11 +1196,31 @@ fn trans_rec_or_struct(bcx: block,\n     }\n }\n \n+/**\n+ * Information that `trans_adt` needs in order to fill in the fields\n+ * of a struct copied from a base struct (e.g., from an expression\n+ * like `Foo { a: b, ..base }`.\n+ *\n+ * Note that `fields` may be empty; the base expression must always be\n+ * evaluated for side-effects.\n+ */\n struct StructBaseInfo {\n+    /// The base expression; will be evaluated after all explicit fields.\n     expr: @ast::expr,\n+    /// The indices of fields to copy paired with their types.\n     fields: ~[(uint, ty::t)]\n }\n \n+/**\n+ * Constructs an ADT instance:\n+ *\n+ * - `fields` should be a list of field indices paired with the\n+ * expression to store into that field.  The initializers will be\n+ * evaluated in the order specified by `fields`.\n+ *\n+ * - `optbase` contains information on the base struct (if any) from\n+ * which remaining fields are copied; see comments on `StructBaseInfo`.\n+ */\n fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n              fields: &[(uint, @ast::expr)],\n              optbase: Option<StructBaseInfo>,"}]}