{"sha": "ad7fdb6859df49da179bfb4402380717aa424b0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkN2ZkYjY4NTlkZjQ5ZGExNzliZmI0NDAyMzgwNzE3YWE0MjRiMGY=", "commit": {"author": {"name": "Aaron Kutch", "email": "aaronkutch@att.net", "date": "2019-08-06T15:42:48Z"}, "committer": {"name": "Aaron Kutch", "email": "aaronkutch@att.net", "date": "2019-08-06T15:42:48Z"}, "message": "Improve `ptr_rotate` performance, tests, and benchmarks", "tree": {"sha": "c67bd730abe460bb45a802463f7858cfa0236079", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c67bd730abe460bb45a802463f7858cfa0236079"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad7fdb6859df49da179bfb4402380717aa424b0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad7fdb6859df49da179bfb4402380717aa424b0f", "html_url": "https://github.com/rust-lang/rust/commit/ad7fdb6859df49da179bfb4402380717aa424b0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad7fdb6859df49da179bfb4402380717aa424b0f/comments", "author": {"login": "AaronKutch", "id": 32419308, "node_id": "MDQ6VXNlcjMyNDE5MzA4", "avatar_url": "https://avatars.githubusercontent.com/u/32419308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AaronKutch", "html_url": "https://github.com/AaronKutch", "followers_url": "https://api.github.com/users/AaronKutch/followers", "following_url": "https://api.github.com/users/AaronKutch/following{/other_user}", "gists_url": "https://api.github.com/users/AaronKutch/gists{/gist_id}", "starred_url": "https://api.github.com/users/AaronKutch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AaronKutch/subscriptions", "organizations_url": "https://api.github.com/users/AaronKutch/orgs", "repos_url": "https://api.github.com/users/AaronKutch/repos", "events_url": "https://api.github.com/users/AaronKutch/events{/privacy}", "received_events_url": "https://api.github.com/users/AaronKutch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "AaronKutch", "id": 32419308, "node_id": "MDQ6VXNlcjMyNDE5MzA4", "avatar_url": "https://avatars.githubusercontent.com/u/32419308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AaronKutch", "html_url": "https://github.com/AaronKutch", "followers_url": "https://api.github.com/users/AaronKutch/followers", "following_url": "https://api.github.com/users/AaronKutch/following{/other_user}", "gists_url": "https://api.github.com/users/AaronKutch/gists{/gist_id}", "starred_url": "https://api.github.com/users/AaronKutch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AaronKutch/subscriptions", "organizations_url": "https://api.github.com/users/AaronKutch/orgs", "repos_url": "https://api.github.com/users/AaronKutch/repos", "events_url": "https://api.github.com/users/AaronKutch/events{/privacy}", "received_events_url": "https://api.github.com/users/AaronKutch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "890881f8f4c77e8670d4b32104c0325fcfefc90f", "url": "https://api.github.com/repos/rust-lang/rust/commits/890881f8f4c77e8670d4b32104c0325fcfefc90f", "html_url": "https://github.com/rust-lang/rust/commit/890881f8f4c77e8670d4b32104c0325fcfefc90f"}], "stats": {"total": 285, "additions": 216, "deletions": 69}, "files": [{"sha": "711a8dff2c0b51551fe23fd0cbd9db844521ec7e", "filename": "src/libcore/benches/slice.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad7fdb6859df49da179bfb4402380717aa424b0f/src%2Flibcore%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7fdb6859df49da179bfb4402380717aa424b0f/src%2Flibcore%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fslice.rs?ref=ad7fdb6859df49da179bfb4402380717aa424b0f", "patch": "@@ -55,3 +55,29 @@ fn binary_search_l2_with_dups(b: &mut Bencher) {\n fn binary_search_l3_with_dups(b: &mut Bencher) {\n     binary_search(b, Cache::L3, |i| i / 16 * 16);\n }\n+\n+macro_rules! rotate {\n+    ($fn:ident, $n:expr, $mapper:expr) => {\n+        #[bench]\n+        fn $fn(b: &mut Bencher) {\n+            let mut x = (0usize..$n).map(&$mapper).collect::<Vec<_>>();\n+            b.iter(|| {\n+                for s in 0..x.len() {\n+                    x[..].rotate_right(s);\n+                }\n+                black_box(x[0].clone())\n+            })\n+        }\n+    };\n+}\n+\n+#[derive(Clone)]\n+struct Rgb(u8, u8, u8);\n+\n+rotate!(rotate_u8, 32, |i| i as u8);\n+rotate!(rotate_rgb, 32, |i| Rgb(i as u8, (i as u8).wrapping_add(7), (i as u8).wrapping_add(42)));\n+rotate!(rotate_usize, 32, |i| i);\n+rotate!(rotate_16_usize_4, 16, |i| [i; 4]);\n+rotate!(rotate_16_usize_5, 16, |i| [i; 5]);\n+rotate!(rotate_64_usize_4, 64, |i| [i; 4]);\n+rotate!(rotate_64_usize_5, 64, |i| [i; 5]);"}, {"sha": "f73e14f27e092bda780b76cece052b8a4e703e35", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 152, "deletions": 69, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/ad7fdb6859df49da179bfb4402380717aa424b0f/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7fdb6859df49da179bfb4402380717aa424b0f/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=ad7fdb6859df49da179bfb4402380717aa424b0f", "patch": "@@ -2,88 +2,171 @@ use crate::cmp;\n use crate::mem::{self, MaybeUninit};\n use crate::ptr;\n \n-/// Rotation is much faster if it has access to a little bit of memory. This\n-/// union provides a RawVec-like interface, but to a fixed-size stack buffer.\n-#[allow(unions_with_drop_fields)]\n-union RawArray<T> {\n-    /// Ensure this is appropriately aligned for T, and is big\n-    /// enough for two elements even if T is enormous.\n-    typed: [T; 2],\n-    /// For normally-sized types, especially things like u8, having more\n-    /// than 2 in the buffer is necessary for usefulness, so pad it out\n-    /// enough to be helpful, but not so big as to risk overflow.\n-    _extra: [usize; 32],\n-}\n-\n-impl<T> RawArray<T> {\n-    fn capacity() -> usize {\n-        if mem::size_of::<T>() == 0 {\n-            usize::max_value()\n-        } else {\n-            mem::size_of::<Self>() / mem::size_of::<T>()\n-        }\n-    }\n-}\n-\n-/// Rotates the range `[mid-left, mid+right)` such that the element at `mid`\n-/// becomes the first element. Equivalently, rotates the range `left`\n-/// elements to the left or `right` elements to the right.\n+/// Rotates the range `[mid-left, mid+right)` such that the element at `mid` becomes the first\n+/// element. Equivalently, rotates the range `left` elements to the left or `right` elements to the\n+/// right.\n ///\n /// # Safety\n ///\n /// The specified range must be valid for reading and writing.\n ///\n /// # Algorithm\n ///\n-/// For longer rotations, swap the left-most `delta = min(left, right)`\n-/// elements with the right-most `delta` elements. LLVM vectorizes this,\n-/// which is profitable as we only reach this step for a \"large enough\"\n-/// rotation. Doing this puts `delta` elements on the larger side into the\n-/// correct position, leaving a smaller rotate problem. Demonstration:\n-///\n+/// Algorithm 1 is used for small values of `left + right` or for large `T`. The elements are moved\n+/// into their final positions one at a time starting at `mid - left` and advancing by `right` steps\n+/// modulo `left + right`, such that only one temporary is needed. Eventually, we arrive back at\n+/// `mid - left`. However, if `gcd(left + right, right)` is not 1, the above steps skipped over\n+/// elements. For example:\n /// ```text\n-/// [ 6 7 8 9 10 11 12 13 . 1 2 3 4 5 ]\n-/// 1 2 3 4 5 [ 11 12 13 . 6 7 8 9 10 ]\n-/// 1 2 3 4 5 [ 8 9 10 . 6 7 ] 11 12 13\n-/// 1 2 3 4 5 6 7 [ 10 . 8 9 ] 11 12 13\n-/// 1 2 3 4 5 6 7 [ 9 . 8 ] 10 11 12 13\n-/// 1 2 3 4 5 6 7 8 [ . ] 9 10 11 12 13\n+/// left = 10, right = 6\n+/// the `^` indicates an element in its final place\n+/// 6 7 8 9 10 11 12 13 14 15 . 0 1 2 3 4 5\n+/// after using one step of the above algorithm (The X will be overwritten at the end of the round,\n+/// and 12 is stored in a temporary):\n+/// X 7 8 9 10 11 6 13 14 15 . 0 1 2 3 4 5\n+///               ^\n+/// after using another step (now 2 is in the temporary):\n+/// X 7 8 9 10 11 6 13 14 15 . 0 1 12 3 4 5\n+///               ^                 ^\n+/// after the third step (the steps wrap around, and 8 is in the temporary):\n+/// X 7 2 9 10 11 6 13 14 15 . 0 1 12 3 4 5\n+///     ^         ^                 ^\n+/// after 7 more steps, the round ends with the temporary 0 getting put in the X:\n+/// 0 7 2 9 4 11 6 13 8 15 . 10 1 12 3 14 5\n+/// ^   ^   ^    ^    ^       ^    ^    ^\n /// ```\n+/// Fortunately, the number of skipped over elements between finalized elements is always equal, so\n+/// we can just offset our starting position and do more rounds (the total number of rounds is the\n+/// `gcd(left + right, right)` value). The end result is that all elements are finalized once and\n+/// only once.\n+///\n+/// Algorithm 2 is used if `left + right` is large but `min(left, right)` is small enough to\n+/// fit onto a stack buffer. The `min(left, right)` elements are copied onto the buffer, `memmove`\n+/// is applied to the others, and the ones on the buffer are moved back into the hole on the\n+/// opposite side of where they originated.\n+///\n+/// Algorithms that can be vectorized outperform the above once `left + right` becomes large enough.\n+/// Algorithm 1 can be vectorized by chunking and performing many rounds at once, but there are too\n+/// few rounds on average until `left + right` is enormous, and the worst case of a single\n+/// round is always there. Instead, algorithm 3 utilizes repeated swapping of\n+/// `min(left, right)` elements until a smaller rotate problem is left.\n ///\n-/// Once the rotation is small enough, copy some elements into a stack\n-/// buffer, `memmove` the others, and move the ones back from the buffer.\n-pub unsafe fn ptr_rotate<T>(mut left: usize, mid: *mut T, mut right: usize) {\n+/// ```text\n+/// left = 11, right = 4\n+/// [4 5 6 7 8 9 10 11 12 13 14 . 0 1 2 3]\n+///                  ^  ^  ^  ^   ^ ^ ^ ^ swapping the right most elements with elements to the left\n+/// [4 5 6 7 8 9 10 . 0 1 2 3] 11 12 13 14\n+///        ^ ^ ^  ^   ^ ^ ^ ^ swapping these\n+/// [4 5 6 . 0 1 2 3] 7 8 9 10 11 12 13 14\n+/// we cannot swap any more, but a smaller rotation problem is left to solve\n+/// ```\n+/// when `left < right` the swapping happens from the left instead.\n+pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize) {\n+    type BufType = [usize; 32];\n+    if mem::size_of::<T>() == 0 {\n+        return;\n+    }\n     loop {\n-        let delta = cmp::min(left, right);\n-        if delta <= RawArray::<T>::capacity() {\n-            // We will always hit this immediately for ZST.\n-            break;\n+        // N.B. the below algorithms can fail if these cases are not checked\n+        if (right == 0) || (left == 0) {\n+            return;\n         }\n-\n-        ptr::swap_nonoverlapping(\n-            mid.sub(left),\n-            mid.add(right - delta),\n-            delta);\n-\n-        if left <= right {\n-            right -= delta;\n+        if (left + right < 24) || (mem::size_of::<T>() > mem::size_of::<[usize; 4]>()) {\n+            // Algorithm 1\n+            // Microbenchmarks indicate that the average performance for random shifts is better all\n+            // the way until about `left + right == 32`, but the worst case performance breaks even\n+            // around 16. 24 was chosen as middle ground. If the size of `T` is larger than 4\n+            // `usize`s, this algorithm also outperforms other algorithms.\n+            let x = mid.sub(left);\n+            // beginning of first round\n+            let mut tmp: T = x.read();\n+            let mut i = right;\n+            // `gcd` can be found before hand by calculating `gcd(left + right, right)`,\n+            // but it is faster to do one loop which calculates the gcd as a side effect, then\n+            // doing the rest of the chunk\n+            let mut gcd = right;\n+            // benchmarks reveal that it is faster to swap temporaries all the way through instead\n+            // of reading one temporary once, copying backwards, and then writing that temporary at\n+            // the very end. This is possibly due to the fact that swapping or replacing temporaries\n+            // uses only one memory address in the loop instead of needing to manage two.\n+            loop {\n+                tmp = x.add(i).replace(tmp);\n+                // instead of incrementing `i` and then checking if it is outside the bounds, we\n+                // check if `i` will go outside the bounds on the next increment. This prevents\n+                // any wrapping of pointers or `usize`.\n+                if i >= left {\n+                    i -= left;\n+                    if i == 0 {\n+                        // end of first round\n+                        x.write(tmp);\n+                        break;\n+                    }\n+                    // this conditional must be here if `left + right >= 15`\n+                    if i < gcd {\n+                        gcd = i;\n+                    }\n+                } else {\n+                    i += right;\n+                }\n+            }\n+            // finish the chunk with more rounds\n+            for start in 1..gcd {\n+                tmp = x.add(start).read();\n+                i = start + right;\n+                loop {\n+                    tmp = x.add(i).replace(tmp);\n+                    if i >= left {\n+                        i -= left;\n+                        if i == start {\n+                            x.add(start).write(tmp);\n+                            break;\n+                        }\n+                    } else {\n+                        i += right;\n+                    }\n+                }\n+            }\n+            return;\n+        // `T` is not a zero-sized type, so it's okay to divide by its size.\n+        } else if cmp::min(left, right) <= mem::size_of::<BufType>() / mem::size_of::<T>() {\n+            // Algorithm 2\n+            // The `[T; 0]` here is to ensure this is appropriately aligned for T\n+            let mut rawarray = MaybeUninit::<(BufType, [T; 0])>::uninit();\n+            let buf = rawarray.as_mut_ptr() as *mut T;\n+            let dim = mid.sub(left).add(right);\n+            if left <= right {\n+                ptr::copy_nonoverlapping(mid.sub(left), buf, left);\n+                ptr::copy(mid, mid.sub(left), right);\n+                ptr::copy_nonoverlapping(buf, dim, left);\n+            } else {\n+                ptr::copy_nonoverlapping(mid, buf, right);\n+                ptr::copy(mid.sub(left), dim, left);\n+                ptr::copy_nonoverlapping(buf, mid.sub(left), right);\n+            }\n+            return;\n+        } else if left >= right {\n+            // Algorithm 3\n+            // There is an alternate way of swapping that involves finding where the last swap\n+            // of this algorithm would be, and swapping using that last chunk instead of swapping\n+            // adjacent chunks like this algorithm is doing, but this way is still faster.\n+            loop {\n+                ptr::swap_nonoverlapping(mid.sub(right), mid, right);\n+                mid = mid.sub(right);\n+                left -= right;\n+                if left < right {\n+                    break;\n+                }\n+            }\n         } else {\n-            left -= delta;\n+            // Algorithm 3, `left < right`\n+            loop {\n+                ptr::swap_nonoverlapping(mid.sub(left), mid, left);\n+                mid = mid.add(left);\n+                right -= left;\n+                if right < left {\n+                    break;\n+                }\n+            }\n         }\n     }\n-\n-    let mut rawarray = MaybeUninit::<RawArray<T>>::uninit();\n-    let buf = &mut (*rawarray.as_mut_ptr()).typed as *mut [T; 2] as *mut T;\n-\n-    let dim = mid.sub(left).add(right);\n-    if left <= right {\n-        ptr::copy_nonoverlapping(mid.sub(left), buf, left);\n-        ptr::copy(mid, mid.sub(left), right);\n-        ptr::copy_nonoverlapping(buf, dim, left);\n-    }\n-    else {\n-        ptr::copy_nonoverlapping(mid, buf, right);\n-        ptr::copy(mid.sub(left), dim, left);\n-        ptr::copy_nonoverlapping(buf, mid.sub(left), right);\n-    }\n }"}, {"sha": "712109110fdc263912be5a543000edf047ff7613", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ad7fdb6859df49da179bfb4402380717aa424b0f/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7fdb6859df49da179bfb4402380717aa424b0f/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=ad7fdb6859df49da179bfb4402380717aa424b0f", "patch": "@@ -1130,6 +1130,44 @@ fn test_rotate_right() {\n     }\n }\n \n+#[test]\n+#[cfg(not(miri))]\n+fn brute_force_rotate_test_0() {\n+    // In case of edge cases involving multiple algorithms\n+    let n = 300;\n+    for len in 0..n {\n+        for s in 0..len {\n+            let mut v = Vec::with_capacity(len);\n+            for i in 0..len {\n+                v.push(i);\n+            }\n+            v[..].rotate_right(s);\n+            for i in 0..v.len() {\n+                assert_eq!(v[i], v.len().wrapping_add(i.wrapping_sub(s)) % v.len());\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn brute_force_rotate_test_1() {\n+    // `ptr_rotate` covers so many kinds of pointer usage, that this is just a good test for\n+    // pointers in general. This uses a `[usize; 4]` to hit all algorithms without overwhelming miri\n+    let n = 30;\n+    for len in 0..n {\n+        for s in 0..len {\n+            let mut v: Vec<[usize; 4]> = Vec::with_capacity(len);\n+            for i in 0..len {\n+                v.push([i, 0, 0, 0]);\n+            }\n+            v[..].rotate_right(s);\n+            for i in 0..v.len() {\n+                assert_eq!(v[i][0], v.len().wrapping_add(i.wrapping_sub(s)) % v.len());\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n #[cfg(not(target_arch = \"wasm32\"))]\n fn sort_unstable() {"}]}