{"sha": "faee8e1756dbdfbe0752a8006e952395c0cd7a67", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZWU4ZTE3NTZkYmRmYmUwNzUyYTgwMDZlOTUyMzk1YzBjZDdhNjc=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-09-26T00:05:30Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-09-27T16:34:03Z"}, "message": "Turn `walk_parent_nodes` method into an iterator", "tree": {"sha": "07b1955abcc09083b7c4726595210425fdf3b979", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07b1955abcc09083b7c4726595210425fdf3b979"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/faee8e1756dbdfbe0752a8006e952395c0cd7a67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/faee8e1756dbdfbe0752a8006e952395c0cd7a67", "html_url": "https://github.com/rust-lang/rust/commit/faee8e1756dbdfbe0752a8006e952395c0cd7a67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/faee8e1756dbdfbe0752a8006e952395c0cd7a67/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "url": "https://api.github.com/repos/rust-lang/rust/commits/590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "html_url": "https://github.com/rust-lang/rust/commit/590ae0ec4d0c782f7cf97cff7474dc4012c1b615"}], "stats": {"total": 206, "additions": 101, "deletions": 105}, "files": [{"sha": "ca854395d7bbb5e42d60bc2256c6af74c3dee57b", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 101, "deletions": 105, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/faee8e1756dbdfbe0752a8006e952395c0cd7a67/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faee8e1756dbdfbe0752a8006e952395c0cd7a67/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=faee8e1756dbdfbe0752a8006e952395c0cd7a67", "patch": "@@ -23,8 +23,6 @@ use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n \n-use std::result::Result::Err;\n-\n pub mod blocks;\n mod collector;\n mod def_collector;\n@@ -183,6 +181,44 @@ pub struct Map<'hir> {\n     hir_to_node_id: FxHashMap<HirId, NodeId>,\n }\n \n+struct ParentHirIterator<'map> {\n+    current_id: HirId,\n+    map: &'map Map<'map>,\n+}\n+\n+impl<'map> ParentHirIterator<'map> {\n+    fn new(current_id: HirId, map: &'map Map<'map>) -> ParentHirIterator<'map> {\n+        ParentHirIterator {\n+            current_id,\n+            map,\n+        }\n+    }\n+}\n+\n+impl<'map> Iterator for ParentHirIterator<'map> {\n+    type Item = (HirId, Node<'map>);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.current_id == CRATE_HIR_ID {\n+            return None;\n+        }\n+        loop { // There are nodes that do not have entries, so we need to skip them.\n+            let parent_id = self.map.get_parent_node(self.current_id);\n+\n+            if parent_id == self.current_id {\n+                self.current_id = CRATE_HIR_ID;\n+                return None;\n+            }\n+\n+            self.current_id = parent_id;\n+            if let Some(entry) = self.map.find_entry(parent_id) {\n+                return Some((parent_id, entry.node));\n+            }\n+            // If this `HirId` doesn't have an `Entry`, skip it and look for its `parent_id`.\n+        }\n+    }\n+}\n+\n impl<'hir> Map<'hir> {\n     #[inline]\n     fn lookup(&self, id: HirId) -> Option<&Entry<'hir>> {\n@@ -682,45 +718,6 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-\n-    /// If there is some error when walking the parents (e.g., a node does not\n-    /// have a parent in the map or a node can't be found), then we return the\n-    /// last good `HirId` we found. Note that reaching the crate root (`id == 0`),\n-    /// is not an error, since items in the crate module have the crate root as\n-    /// parent.\n-    fn walk_parent_nodes<F, F2>(&self,\n-                                start_id: HirId,\n-                                found: F,\n-                                bail_early: F2)\n-        -> Result<HirId, HirId>\n-        where F: Fn(&Node<'hir>) -> bool, F2: Fn(&Node<'hir>) -> bool\n-    {\n-        let mut id = start_id;\n-        loop {\n-            let parent_id = self.get_parent_node(id);\n-            if parent_id == CRATE_HIR_ID {\n-                return Ok(CRATE_HIR_ID);\n-            }\n-            if parent_id == id {\n-                return Err(id);\n-            }\n-\n-            if let Some(entry) = self.find_entry(parent_id) {\n-                if let Node::Crate = entry.node {\n-                    return Err(id);\n-                }\n-                if found(&entry.node) {\n-                    return Ok(parent_id);\n-                } else if bail_early(&entry.node) {\n-                    return Err(parent_id);\n-                }\n-                id = parent_id;\n-            } else {\n-                return Err(id);\n-            }\n-        }\n-    }\n-\n     /// Retrieves the `HirId` for `id`'s enclosing method, unless there's a\n     /// `while` or `loop` before reaching it, as block tail returns are not\n     /// available in them.\n@@ -744,46 +741,41 @@ impl<'hir> Map<'hir> {\n     /// }\n     /// ```\n     pub fn get_return_block(&self, id: HirId) -> Option<HirId> {\n-        let match_fn = |node: &Node<'_>| {\n-            match *node {\n+        for (hir_id, node) in ParentHirIterator::new(id, &self) {\n+            match node {\n                 Node::Item(_) |\n                 Node::ForeignItem(_) |\n                 Node::TraitItem(_) |\n                 Node::Expr(Expr { kind: ExprKind::Closure(..), ..}) |\n-                Node::ImplItem(_) => true,\n-                _ => false,\n-            }\n-        };\n-        let match_non_returning_block = |node: &Node<'_>| {\n-            match *node {\n+                Node::ImplItem(_) => return Some(hir_id),\n                 Node::Expr(ref expr) => {\n                     match expr.kind {\n-                        ExprKind::Loop(..) | ExprKind::Ret(..) => true,\n-                        _ => false,\n+                        ExprKind::Loop(..) | ExprKind::Ret(..) => return None,\n+                        _ => {}\n                     }\n                 }\n-                _ => false,\n+                _ => {}\n             }\n-        };\n-\n-        self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n+        }\n+        None\n     }\n \n     /// Retrieves the `HirId` for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n     pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n-        match self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(_) |\n-            Node::ForeignItem(_) |\n-            Node::TraitItem(_) |\n-            Node::ImplItem(_) => true,\n-            _ => false,\n-        }, |_| false) {\n-            Ok(id) => id,\n-            Err(id) => id,\n+        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+            match node {\n+                Node::Crate |\n+                Node::Item(_) |\n+                Node::ForeignItem(_) |\n+                Node::TraitItem(_) |\n+                Node::ImplItem(_) => return hir_id,\n+                _ => {}\n+            }\n         }\n+        hir_id\n     }\n \n     /// Returns the `DefId` of `id`'s nearest module parent, or `id` itself if no\n@@ -795,58 +787,62 @@ impl<'hir> Map<'hir> {\n     /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent_node(&self, hir_id: HirId) -> HirId {\n-        match self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(&Item { kind: ItemKind::Mod(_), .. }) => true,\n-            _ => false,\n-        }, |_| false) {\n-            Ok(id) => id,\n-            Err(id) => id,\n+        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+            if let Node::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n+                return hir_id;\n+            }\n         }\n+        CRATE_HIR_ID\n     }\n \n     /// Returns the nearest enclosing scope. A scope is roughly an item or block.\n     pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n-        self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(i) => {\n-                match i.kind {\n-                    ItemKind::Fn(..)\n-                    | ItemKind::Mod(..)\n-                    | ItemKind::Enum(..)\n-                    | ItemKind::Struct(..)\n-                    | ItemKind::Union(..)\n-                    | ItemKind::Trait(..)\n-                    | ItemKind::Impl(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::ForeignItem(fi) => {\n-                match fi.kind {\n-                    ForeignItemKind::Fn(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::TraitItem(ti) => {\n-                match ti.kind {\n-                    TraitItemKind::Method(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::ImplItem(ii) => {\n-                match ii.kind {\n-                    ImplItemKind::Method(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::Block(_) => true,\n-            _ => false,\n-        }, |_| false).ok()\n+        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+            if match node {\n+                Node::Item(i) => {\n+                    match i.kind {\n+                        ItemKind::Fn(..)\n+                        | ItemKind::Mod(..)\n+                        | ItemKind::Enum(..)\n+                        | ItemKind::Struct(..)\n+                        | ItemKind::Union(..)\n+                        | ItemKind::Trait(..)\n+                        | ItemKind::Impl(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::ForeignItem(fi) => {\n+                    match fi.kind {\n+                        ForeignItemKind::Fn(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::TraitItem(ti) => {\n+                    match ti.kind {\n+                        TraitItemKind::Method(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::ImplItem(ii) => {\n+                    match ii.kind {\n+                        ImplItemKind::Method(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::Block(_) => true,\n+                _ => false,\n+            } {\n+                return Some(hir_id);\n+            }\n+        }\n+        None\n     }\n \n     /// Returns the defining scope for an opaque type definition.\n     pub fn get_defining_scope(&self, id: HirId) -> Option<HirId> {\n         let mut scope = id;\n         loop {\n-            scope = self.get_enclosing_scope(scope)?;\n+            scope = self.get_enclosing_scope(scope).unwrap_or(CRATE_HIR_ID);\n             if scope == CRATE_HIR_ID {\n                 return Some(CRATE_HIR_ID);\n             }"}]}