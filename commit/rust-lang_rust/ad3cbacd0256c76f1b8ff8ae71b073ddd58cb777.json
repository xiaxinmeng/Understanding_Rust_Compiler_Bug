{"sha": "ad3cbacd0256c76f1b8ff8ae71b073ddd58cb777", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkM2NiYWNkMDI1NmM3NmYxYjhmZjhhZTcxYjA3M2RkZDU4Y2I3Nzc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-15T13:13:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-17T14:05:33Z"}, "message": "Rewrite constrained type params code to operate generically over\nmultiple kinds of parameters (regions and types, specifically)", "tree": {"sha": "7d1366f0849c86ba7220f432415a500134eb0138", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d1366f0849c86ba7220f432415a500134eb0138"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad3cbacd0256c76f1b8ff8ae71b073ddd58cb777", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad3cbacd0256c76f1b8ff8ae71b073ddd58cb777", "html_url": "https://github.com/rust-lang/rust/commit/ad3cbacd0256c76f1b8ff8ae71b073ddd58cb777", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad3cbacd0256c76f1b8ff8ae71b073ddd58cb777/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a1f556999b25e0d62402a8edda8839c2940fb74", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a1f556999b25e0d62402a8edda8839c2940fb74", "html_url": "https://github.com/rust-lang/rust/commit/4a1f556999b25e0d62402a8edda8839c2940fb74"}], "stats": {"total": 129, "additions": 90, "deletions": 39}, "files": [{"sha": "83e0c398590f539ed80c2db58049878a8a2284df", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad3cbacd0256c76f1b8ff8ae71b073ddd58cb777/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad3cbacd0256c76f1b8ff8ae71b073ddd58cb777/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=ad3cbacd0256c76f1b8ff8ae71b073ddd58cb777", "patch": "@@ -10,7 +10,7 @@\n \n use astconv::AstConv;\n use check::{FnCtxt, Inherited, blank_fn_ctxt, vtable, regionck};\n-use constrained_type_params::identify_constrained_type_params;\n+use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n use middle::region;\n use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n@@ -287,10 +287,11 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n         let mut constrained_parameters: HashSet<_> =\n             variances.types\n-            .iter_enumerated()\n-            .filter(|&(_, _, &variance)| variance != ty::Bivariant)\n-            .map(|(space, index, _)| self.param_ty(ast_generics, space, index))\n-            .collect();\n+                     .iter_enumerated()\n+                     .filter(|&(_, _, &variance)| variance != ty::Bivariant)\n+                     .map(|(space, index, _)| self.param_ty(ast_generics, space, index))\n+                     .map(|p| Parameter::Type(p))\n+                     .collect();\n \n         identify_constrained_type_params(self.tcx(),\n                                          ty_predicates.predicates.as_slice(),\n@@ -299,7 +300,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n         for (space, index, _) in variances.types.iter_enumerated() {\n             let param_ty = self.param_ty(ast_generics, space, index);\n-            if constrained_parameters.contains(&param_ty) {\n+            if constrained_parameters.contains(&Parameter::Type(param_ty)) {\n                 continue;\n             }\n             let span = self.ty_param_span(ast_generics, item, space, index);"}, {"sha": "dfcf375bdbc5f2bb4ed76295c689d715c16759c7", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad3cbacd0256c76f1b8ff8ae71b073ddd58cb777/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad3cbacd0256c76f1b8ff8ae71b073ddd58cb777/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ad3cbacd0256c76f1b8ff8ae71b073ddd58cb777", "patch": "@@ -66,7 +66,7 @@ There are some shortcomings in this design:\n \n use astconv::{self, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n use middle::def;\n-use constrained_type_params::identify_constrained_type_params;\n+use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n use middle::region;\n use middle::resolve_lifetime;\n@@ -2200,23 +2200,21 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // reachable from there, to start (if this is an inherent impl,\n     // then just examine the self type).\n     let mut input_parameters: HashSet<_> =\n-        impl_trait_ref.iter()\n-                      .flat_map(|t| t.input_types().iter()) // Types in trait ref, if any\n-                      .chain(Some(impl_scheme.ty).iter())   // Self type, always\n-                      .flat_map(|t| t.walk())\n-                      .filter_map(|t| t.as_opt_param_ty())\n-                      .collect();\n-\n-    identify_constrained_type_params(tcx,\n-                                     impl_predicates.predicates.as_slice(),\n-                                     impl_trait_ref,\n-                                     &mut input_parameters);\n+        ctp::parameters_for_type(impl_scheme.ty).into_iter().collect();\n+    if let Some(ref trait_ref) = impl_trait_ref {\n+        input_parameters.extend(ctp::parameters_for_trait_ref(trait_ref));\n+    }\n+\n+    ctp::identify_constrained_type_params(tcx,\n+                                          impl_predicates.predicates.as_slice(),\n+                                          impl_trait_ref,\n+                                          &mut input_parameters);\n \n     for (index, ty_param) in ast_generics.ty_params.iter().enumerate() {\n         let param_ty = ty::ParamTy { space: TypeSpace,\n                                      idx: index as u32,\n                                      name: ty_param.ident.name };\n-        if !input_parameters.contains(&param_ty) {\n+        if !input_parameters.contains(&ctp::Parameter::Type(param_ty)) {\n             span_err!(tcx.sess, ty_param.span, E0207,\n                 \"the type parameter `{}` is not constrained by the \\\n                          impl trait, self type, or predicates\","}, {"sha": "fad8fbef2a4d40ce8a1425b112be0d980cac8306", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 72, "deletions": 20, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ad3cbacd0256c76f1b8ff8ae71b073ddd58cb777/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad3cbacd0256c76f1b8ff8ae71b073ddd58cb777/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=ad3cbacd0256c76f1b8ff8ae71b073ddd58cb777", "patch": "@@ -8,49 +8,101 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::ty::{self};\n+use middle::subst;\n+use middle::ty::{self, Ty};\n \n use std::collections::HashSet;\n use std::rc::Rc;\n \n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum Parameter {\n+    Type(ty::ParamTy),\n+    Region(ty::EarlyBoundRegion),\n+}\n+\n+pub fn parameters_for_type<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n+    ty.walk()\n+      .flat_map(|ty| parameters_for_type_shallow(ty).into_iter())\n+      .collect()\n+}\n+\n+pub fn parameters_for_trait_ref<'tcx>(trait_ref: &Rc<ty::TraitRef<'tcx>>) -> Vec<Parameter> {\n+    let mut region_parameters =\n+        parameters_for_regions_in_substs(&trait_ref.substs);\n+\n+    let type_parameters =\n+        trait_ref.substs.types.iter()\n+                              .flat_map(|ty| parameters_for_type(ty).into_iter());\n+\n+    region_parameters.extend(type_parameters);\n+\n+    region_parameters\n+}\n+\n+fn parameters_for_type_shallow<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n+    match ty.sty {\n+        ty::ty_param(ref d) =>\n+            vec![Parameter::Type(d.clone())],\n+        ty::ty_rptr(region, _) =>\n+            parameters_for_region(region).into_iter().collect(),\n+        ty::ty_struct(_, substs) |\n+        ty::ty_enum(_, substs) =>\n+            parameters_for_regions_in_substs(substs),\n+        ty::ty_trait(ref data) =>\n+            parameters_for_regions_in_substs(&data.principal.skip_binder().substs),\n+        _ =>\n+            vec![],\n+    }\n+}\n+\n+fn parameters_for_regions_in_substs(substs: &subst::Substs) -> Vec<Parameter> {\n+    substs.regions()\n+          .iter()\n+          .filter_map(|r| parameters_for_region(r))\n+          .collect()\n+}\n+\n+fn parameters_for_region(region: &ty::Region) -> Option<Parameter> {\n+    match *region {\n+        ty::ReEarlyBound(data) => Some(Parameter::Region(data)),\n+        _ => None,\n+    }\n+}\n+\n pub fn identify_constrained_type_params<'tcx>(_tcx: &ty::ctxt<'tcx>,\n                                               predicates: &[ty::Predicate<'tcx>],\n                                               impl_trait_ref: Option<Rc<ty::TraitRef<'tcx>>>,\n-                                              input_parameters: &mut HashSet<ty::ParamTy>)\n+                                              input_parameters: &mut HashSet<Parameter>)\n {\n     loop {\n         let num_inputs = input_parameters.len();\n \n-        let projection_predicates =\n+        let poly_projection_predicates = // : iterator over PolyProjectionPredicate\n             predicates.iter()\n                       .filter_map(|predicate| {\n                           match *predicate {\n-                              // Ignore higher-ranked binders. For the purposes\n-                              // of this check, they don't matter because they\n-                              // only affect named regions, and we're just\n-                              // concerned about type parameters here.\n-                              ty::Predicate::Projection(ref data) => Some(data.0.clone()),\n+                              ty::Predicate::Projection(ref data) => Some(data.clone()),\n                               _ => None,\n                           }\n                       });\n \n-        for projection in projection_predicates {\n+        for poly_projection in poly_projection_predicates {\n+            // Note that we can skip binder here because the impl\n+            // trait ref never contains any late-bound regions.\n+            let projection = poly_projection.skip_binder();\n+\n             // Special case: watch out for some kind of sneaky attempt\n-            // to project out an associated type defined by this very trait.\n-            if Some(projection.projection_ty.trait_ref.clone()) == impl_trait_ref {\n+            // to project out an associated type defined by this very\n+            // trait.\n+            let unbound_trait_ref = &projection.projection_ty.trait_ref;\n+            if Some(unbound_trait_ref.clone()) == impl_trait_ref {\n                 continue;\n             }\n \n-            let relies_only_on_inputs =\n-                projection.projection_ty.trait_ref.input_types()\n-                                                  .iter()\n-                                                  .flat_map(|t| t.walk())\n-                                                  .filter_map(|t| t.as_opt_param_ty())\n-                                                  .all(|t| input_parameters.contains(&t));\n-\n+            let inputs = parameters_for_trait_ref(&projection.projection_ty.trait_ref);\n+            let relies_only_on_inputs = inputs.iter().all(|p| input_parameters.contains(&p));\n             if relies_only_on_inputs {\n-                input_parameters.extend(\n-                    projection.ty.walk().filter_map(|t| t.as_opt_param_ty()));\n+                input_parameters.extend(parameters_for_type(projection.ty));\n             }\n         }\n "}]}