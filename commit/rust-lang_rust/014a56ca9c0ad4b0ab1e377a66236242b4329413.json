{"sha": "014a56ca9c0ad4b0ab1e377a66236242b4329413", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNGE1NmNhOWMwYWQ0YjBhYjFlMzc3YTY2MjM2MjQyYjQzMjk0MTM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-09-09T21:55:46Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-09-09T21:55:46Z"}, "message": "Don't compute padding of braces unless they are unmatched", "tree": {"sha": "b224123d356c17d13179ee7f8ab9537f4a8568b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b224123d356c17d13179ee7f8ab9537f4a8568b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/014a56ca9c0ad4b0ab1e377a66236242b4329413", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/014a56ca9c0ad4b0ab1e377a66236242b4329413", "html_url": "https://github.com/rust-lang/rust/commit/014a56ca9c0ad4b0ab1e377a66236242b4329413", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/014a56ca9c0ad4b0ab1e377a66236242b4329413/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f50b7758f4dc85dc1c5e38258adaa94213ac6ed1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f50b7758f4dc85dc1c5e38258adaa94213ac6ed1", "html_url": "https://github.com/rust-lang/rust/commit/f50b7758f4dc85dc1c5e38258adaa94213ac6ed1"}], "stats": {"total": 49, "additions": 23, "deletions": 26}, "files": [{"sha": "aa47d5bf669bc0eb9f6015c78739094d9cb78951", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/014a56ca9c0ad4b0ab1e377a66236242b4329413/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/014a56ca9c0ad4b0ab1e377a66236242b4329413/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=014a56ca9c0ad4b0ab1e377a66236242b4329413", "patch": "@@ -66,10 +66,10 @@ pub struct StringReader<'a> {\n     /// The raw source span which *does not* take `override_span` into account\n     span_src_raw: Span,\n     open_braces: Vec<(token::DelimToken, Span)>,\n-    /// The type and spans for all braces that have different indentation.\n+    /// The type and spans for all braces\n     ///\n     /// Used only for error recovery when arriving to EOF with mismatched braces.\n-    suspicious_open_spans: Vec<(token::DelimToken, Span, Span)>,\n+    matching_delim_spans: Vec<(token::DelimToken, Span, Span)>,\n     crate override_span: Option<Span>,\n     last_unclosed_found_span: Option<Span>,\n }\n@@ -220,7 +220,7 @@ impl<'a> StringReader<'a> {\n             span: syntax_pos::DUMMY_SP,\n             span_src_raw: syntax_pos::DUMMY_SP,\n             open_braces: Vec::new(),\n-            suspicious_open_spans: Vec::new(),\n+            matching_delim_spans: Vec::new(),\n             override_span,\n             last_unclosed_found_span: None,\n         }"}, {"sha": "8047ab014651474d0a5b1bfafc1d3c03001c9768", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/014a56ca9c0ad4b0ab1e377a66236242b4329413/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/014a56ca9c0ad4b0ab1e377a66236242b4329413/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=014a56ca9c0ad4b0ab1e377a66236242b4329413", "patch": "@@ -44,6 +44,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     fn parse_token_tree(&mut self) -> PResult<'a, TokenStream> {\n+        let sm = self.sess.source_map();\n         match self.token {\n             token::Eof => {\n                 let msg = \"this file contains an un-closed delimiter\";\n@@ -53,20 +54,25 @@ impl<'a> StringReader<'a> {\n                 }\n \n                 if let Some((delim, _)) = self.open_braces.last() {\n-                    if let Some((d, open_sp, close_sp)) = self.suspicious_open_spans.iter()\n-                        .filter(|(d, _, _)| delim == d)\n-                        .next()  // these are in reverse order as they get inserted on close, but\n-                    {            // we want the last open/first close\n-                        if d == delim {\n-                            err.span_label(\n-                                *open_sp,\n-                                \"this delimiter might not be properly closed...\",\n-                            );\n-                            err.span_label(\n-                                *close_sp,\n-                                \"...as it matches this but it has different indentation\",\n-                            );\n+                    if let Some((_, open_sp, close_sp)) = self.matching_delim_spans.iter()\n+                        .filter(|(d, open_sp, close_sp)| {\n+\n+                        if let Some(close_padding) = sm.span_to_margin(*close_sp) {\n+                            if let Some(open_padding) = sm.span_to_margin(*open_sp) {\n+                                return delim == d && close_padding != open_padding;\n+                            }\n                         }\n+                        false\n+                        }).next()  // these are in reverse order as they get inserted on close, but\n+                    {              // we want the last open/first close\n+                        err.span_label(\n+                            *open_sp,\n+                            \"this delimiter might not be properly closed...\",\n+                        );\n+                        err.span_label(\n+                            *close_sp,\n+                            \"...as it matches this but it has different indentation\",\n+                        );\n                     }\n                 }\n                 Err(err)\n@@ -87,20 +93,11 @@ impl<'a> StringReader<'a> {\n                 // Expand to cover the entire delimited token tree\n                 let delim_span = DelimSpan::from_pair(pre_span, self.span);\n \n-                let sm = self.sess.source_map();\n                 match self.token {\n                     // Correct delimiter.\n                     token::CloseDelim(d) if d == delim => {\n                         let (open_brace, open_brace_span) = self.open_braces.pop().unwrap();\n-                        if let Some(current_padding) = sm.span_to_margin(self.span) {\n-                            if let Some(padding) = sm.span_to_margin(open_brace_span) {\n-                                if current_padding != padding {\n-                                    self.suspicious_open_spans.push(\n-                                        (open_brace, open_brace_span, self.span),\n-                                    );\n-                                }\n-                            }\n-                        }\n+                        self.matching_delim_spans.push((open_brace, open_brace_span, self.span));\n                         // Parse the close delimiter.\n                         self.real_token();\n                     }"}]}