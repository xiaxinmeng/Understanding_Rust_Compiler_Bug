{"sha": "78fc5107430d73557df489b795d93b6ec7149cc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ZmM1MTA3NDMwZDczNTU3ZGY0ODliNzk1ZDkzYjZlYzcxNDljYzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-19T06:19:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-19T06:19:27Z"}, "message": "Auto merge of #49890 - varkor:xpy-check-rustc_trans, r=alexcrichton\n\nAdd rustc_trans to x.py check\n\nr? @Mark-Simulacrum\n\nI looked at `bootstrap/compile.rs` and `bootstrap/check.rs` to try to work out which steps were appropriate, but I'm sure I've overlooked some details here, so it's worth checking carefully I've got all the steps right (e.g. I wasn't sure whether we want to build LLVM if necessary with `x.py check`, though I thought it was probably better to than to not).\n\nFrom a quick test, it seems to be working, though.", "tree": {"sha": "6545fc0522f33e5ce5c557c97bf4d18901443b4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6545fc0522f33e5ce5c557c97bf4d18901443b4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78fc5107430d73557df489b795d93b6ec7149cc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78fc5107430d73557df489b795d93b6ec7149cc3", "html_url": "https://github.com/rust-lang/rust/commit/78fc5107430d73557df489b795d93b6ec7149cc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78fc5107430d73557df489b795d93b6ec7149cc3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "883bf4ba2ed8c63ed2c3201576bca1ec10488624", "url": "https://api.github.com/repos/rust-lang/rust/commits/883bf4ba2ed8c63ed2c3201576bca1ec10488624", "html_url": "https://github.com/rust-lang/rust/commit/883bf4ba2ed8c63ed2c3201576bca1ec10488624"}, {"sha": "86acb09273275a0a045f48bd43cb60eb0a512ff1", "url": "https://api.github.com/repos/rust-lang/rust/commits/86acb09273275a0a045f48bd43cb60eb0a512ff1", "html_url": "https://github.com/rust-lang/rust/commit/86acb09273275a0a045f48bd43cb60eb0a512ff1"}], "stats": {"total": 193, "additions": 138, "deletions": 55}, "files": [{"sha": "7ac9b146fe57e0c99b25d953499accdc3f9da53c", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78fc5107430d73557df489b795d93b6ec7149cc3/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78fc5107430d73557df489b795d93b6ec7149cc3/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=78fc5107430d73557df489b795d93b6ec7149cc3", "patch": "@@ -310,7 +310,7 @@ impl<'a> Builder<'a> {\n                 tool::Compiletest, tool::RemoteTestServer, tool::RemoteTestClient,\n                 tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc, tool::Clippy,\n                 native::Llvm, tool::Rustfmt, tool::Miri, native::Lld),\n-            Kind::Check => describe!(check::Std, check::Test, check::Rustc),\n+            Kind::Check => describe!(check::Std, check::Test, check::Rustc, check::CodegenBackend),\n             Kind::Test => describe!(test::Tidy, test::Bootstrap, test::Ui, test::RunPass,\n                 test::CompileFail, test::ParseFail, test::RunFail, test::RunPassValgrind,\n                 test::MirOpt, test::Codegen, test::CodegenUnits, test::Incremental, test::Debuginfo,\n@@ -552,6 +552,12 @@ impl<'a> Builder<'a> {\n              .arg(\"--target\")\n              .arg(target);\n \n+        // Set a flag for `check` so that certain build scripts can do less work\n+        // (e.g. not building/requiring LLVM).\n+        if cmd == \"check\" {\n+            cargo.env(\"RUST_CHECK\", \"1\");\n+        }\n+\n         // If we were invoked from `make` then that's already got a jobserver\n         // set up for us so no need to tell Cargo about jobs all over again.\n         if env::var_os(\"MAKEFLAGS\").is_none() && env::var_os(\"MFLAGS\").is_none() {\n@@ -836,7 +842,7 @@ impl<'a> Builder<'a> {\n         cargo\n     }\n \n-    /// Ensure that a given step is built, returning it's output. This will\n+    /// Ensure that a given step is built, returning its output. This will\n     /// cache the step, so it is safe (and good!) to call this as often as\n     /// needed to ensure that all dependencies are built.\n     pub fn ensure<S: Step>(&'a self, step: S) -> S::Output {"}, {"sha": "e7c6ec888dfb1fa59905cab5e64e99a6561bb097", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/78fc5107430d73557df489b795d93b6ec7149cc3/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78fc5107430d73557df489b795d93b6ec7149cc3/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=78fc5107430d73557df489b795d93b6ec7149cc3", "patch": "@@ -10,10 +10,10 @@\n \n //! Implementation of compiling the compiler and standard library, in \"check\" mode.\n \n-use compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, add_to_sysroot};\n+use compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, rustc_cargo_env, add_to_sysroot};\n use builder::{RunConfig, Builder, ShouldRun, Step};\n use {Compiler, Mode};\n-use cache::Interned;\n+use cache::{INTERNER, Interned};\n use std::path::PathBuf;\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -104,6 +104,52 @@ impl Step for Rustc {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct CodegenBackend {\n+    pub target: Interned<String>,\n+    pub backend: Interned<String>,\n+}\n+\n+impl Step for CodegenBackend {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.all_krates(\"rustc_trans\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let backend = run.builder.config.rust_codegen_backends.get(0);\n+        let backend = backend.cloned().unwrap_or_else(|| {\n+            INTERNER.intern_str(\"llvm\")\n+        });\n+        run.builder.ensure(CodegenBackend {\n+            target: run.target,\n+            backend,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        let compiler = builder.compiler(0, builder.config.build);\n+        let target = self.target;\n+        let backend = self.backend;\n+\n+        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"check\");\n+        let features = builder.rustc_features().to_string();\n+        cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/librustc_trans/Cargo.toml\"));\n+        rustc_cargo_env(builder, &mut cargo);\n+\n+        // We won't build LLVM if it's not available, as it shouldn't affect `check`.\n+\n+        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n+        run_cargo(builder,\n+                  cargo.arg(\"--features\").arg(features),\n+                  &codegen_backend_stamp(builder, compiler, target, backend),\n+                  true);\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Test {\n     pub target: Interned<String>,\n@@ -161,3 +207,13 @@ pub fn libtest_stamp(builder: &Builder, compiler: Compiler, target: Interned<Str\n pub fn librustc_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Librustc, target).join(\".librustc-check.stamp\")\n }\n+\n+/// Cargo's output path for librustc_trans in a given stage, compiled by a particular\n+/// compiler for the specified target and backend.\n+fn codegen_backend_stamp(builder: &Builder,\n+                         compiler: Compiler,\n+                         target: Interned<String>,\n+                         backend: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Librustc, target)\n+         .join(format!(\".librustc_trans-{}-check.stamp\", backend))\n+}"}, {"sha": "1248c2b50be5e8700b4fa672ced5981db5db41b8", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 66, "deletions": 51, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/78fc5107430d73557df489b795d93b6ec7149cc3/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78fc5107430d73557df489b795d93b6ec7149cc3/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=78fc5107430d73557df489b795d93b6ec7149cc3", "patch": "@@ -519,7 +519,7 @@ pub fn rustc_cargo(builder: &Builder, cargo: &mut Command) {\n     rustc_cargo_env(builder, cargo);\n }\n \n-fn rustc_cargo_env(builder: &Builder, cargo: &mut Command) {\n+pub fn rustc_cargo_env(builder: &Builder, cargo: &mut Command) {\n     // Set some configuration variables picked up by build scripts and\n     // the compiler alike\n     cargo.env(\"CFG_RELEASE\", builder.rust_release())\n@@ -614,21 +614,22 @@ impl Step for CodegenBackend {\n         run.builder.ensure(CodegenBackend {\n             compiler: run.builder.compiler(run.builder.top_stage, run.host),\n             target: run.target,\n-            backend\n+            backend,\n         });\n     }\n \n     fn run(self, builder: &Builder) {\n         let compiler = self.compiler;\n         let target = self.target;\n+        let backend = self.backend;\n \n         builder.ensure(Rustc { compiler, target });\n \n         if builder.force_use_stage1(compiler, target) {\n             builder.ensure(CodegenBackend {\n                 compiler: builder.compiler(1, builder.config.build),\n                 target,\n-                backend: self.backend,\n+                backend,\n             });\n             return;\n         }\n@@ -639,52 +640,7 @@ impl Step for CodegenBackend {\n             .arg(builder.src.join(\"src/librustc_trans/Cargo.toml\"));\n         rustc_cargo_env(builder, &mut cargo);\n \n-        match &*self.backend {\n-            \"llvm\" | \"emscripten\" => {\n-                // Build LLVM for our target. This will implicitly build the\n-                // host LLVM if necessary.\n-                let llvm_config = builder.ensure(native::Llvm {\n-                    target,\n-                    emscripten: self.backend == \"emscripten\",\n-                });\n-\n-                if self.backend == \"emscripten\" {\n-                    features.push_str(\" emscripten\");\n-                }\n-\n-                builder.info(&format!(\"Building stage{} codegen artifacts ({} -> {}, {})\",\n-                         compiler.stage, &compiler.host, target, self.backend));\n-\n-                // Pass down configuration from the LLVM build into the build of\n-                // librustc_llvm and librustc_trans.\n-                if builder.is_rust_llvm(target) {\n-                    cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n-                }\n-                cargo.env(\"LLVM_CONFIG\", &llvm_config);\n-                if self.backend != \"emscripten\" {\n-                    let target_config = builder.config.target_config.get(&target);\n-                    if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n-                        cargo.env(\"CFG_LLVM_ROOT\", s);\n-                    }\n-                }\n-                // Building with a static libstdc++ is only supported on linux right now,\n-                // not for MSVC or macOS\n-                if builder.config.llvm_static_stdcpp &&\n-                   !target.contains(\"freebsd\") &&\n-                   !target.contains(\"windows\") &&\n-                   !target.contains(\"apple\") {\n-                    let file = compiler_file(builder,\n-                                             builder.cxx(target).unwrap(),\n-                                             target,\n-                                             \"libstdc++.a\");\n-                    cargo.env(\"LLVM_STATIC_STDCPP\", file);\n-                }\n-                if builder.config.llvm_link_shared {\n-                    cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n-                }\n-            }\n-            _ => panic!(\"unknown backend: {}\", self.backend),\n-        }\n+        features += &build_codegen_backend(&builder, &mut cargo, &compiler, target, backend);\n \n         let tmp_stamp = builder.cargo_out(compiler, Mode::Librustc, target)\n             .join(\".tmp.stamp\");\n@@ -711,12 +667,69 @@ impl Step for CodegenBackend {\n                    codegen_backend.display(),\n                    f.display());\n         }\n-        let stamp = codegen_backend_stamp(builder, compiler, target, self.backend);\n+        let stamp = codegen_backend_stamp(builder, compiler, target, backend);\n         let codegen_backend = codegen_backend.to_str().unwrap();\n         t!(t!(File::create(&stamp)).write_all(codegen_backend.as_bytes()));\n     }\n }\n \n+pub fn build_codegen_backend(builder: &Builder,\n+                             cargo: &mut Command,\n+                             compiler: &Compiler,\n+                             target: Interned<String>,\n+                             backend: Interned<String>) -> String {\n+    let mut features = String::new();\n+\n+    match &*backend {\n+        \"llvm\" | \"emscripten\" => {\n+            // Build LLVM for our target. This will implicitly build the\n+            // host LLVM if necessary.\n+            let llvm_config = builder.ensure(native::Llvm {\n+                target,\n+                emscripten: backend == \"emscripten\",\n+            });\n+\n+            if backend == \"emscripten\" {\n+                features.push_str(\" emscripten\");\n+            }\n+\n+            builder.info(&format!(\"Building stage{} codegen artifacts ({} -> {}, {})\",\n+                     compiler.stage, &compiler.host, target, backend));\n+\n+            // Pass down configuration from the LLVM build into the build of\n+            // librustc_llvm and librustc_trans.\n+            if builder.is_rust_llvm(target) {\n+                cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n+            }\n+            cargo.env(\"LLVM_CONFIG\", &llvm_config);\n+            if backend != \"emscripten\" {\n+                let target_config = builder.config.target_config.get(&target);\n+                if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n+                    cargo.env(\"CFG_LLVM_ROOT\", s);\n+                }\n+            }\n+            // Building with a static libstdc++ is only supported on linux right now,\n+            // not for MSVC or macOS\n+            if builder.config.llvm_static_stdcpp &&\n+               !target.contains(\"freebsd\") &&\n+               !target.contains(\"windows\") &&\n+               !target.contains(\"apple\") {\n+                let file = compiler_file(builder,\n+                                         builder.cxx(target).unwrap(),\n+                                         target,\n+                                         \"libstdc++.a\");\n+                cargo.env(\"LLVM_STATIC_STDCPP\", file);\n+            }\n+            if builder.config.llvm_link_shared {\n+                cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n+            }\n+        }\n+        _ => panic!(\"unknown backend: {}\", backend),\n+    }\n+\n+    features\n+}\n+\n /// Creates the `codegen-backends` folder for a compiler that's about to be\n /// assembled as a complete compiler.\n ///\n@@ -795,6 +808,8 @@ pub fn librustc_stamp(builder: &Builder, compiler: Compiler, target: Interned<St\n     builder.cargo_out(compiler, Mode::Librustc, target).join(\".librustc.stamp\")\n }\n \n+/// Cargo's output path for librustc_trans in a given stage, compiled by a particular\n+/// compiler for the specified target and backend.\n fn codegen_backend_stamp(builder: &Builder,\n                          compiler: Compiler,\n                          target: Interned<String>,\n@@ -803,7 +818,7 @@ fn codegen_backend_stamp(builder: &Builder,\n         .join(format!(\".librustc_trans-{}.stamp\", backend))\n }\n \n-fn compiler_file(builder: &Builder,\n+pub fn compiler_file(builder: &Builder,\n                  compiler: &Path,\n                  target: Interned<String>,\n                  file: &str) -> PathBuf {"}, {"sha": "1619637b827dfe99a1bad79271fa3a6f6c318fa2", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78fc5107430d73557df489b795d93b6ec7149cc3/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78fc5107430d73557df489b795d93b6ec7149cc3/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=78fc5107430d73557df489b795d93b6ec7149cc3", "patch": "@@ -28,6 +28,12 @@ fn detect_llvm_link() -> (&'static str, &'static str) {\n }\n \n fn main() {\n+    if env::var_os(\"RUST_CHECK\").is_some() {\n+        // If we're just running `check`, there's no need for LLVM to be built.\n+        println!(\"cargo:rerun-if-env-changed=RUST_CHECK\");\n+        return;\n+    }\n+\n     let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n     let llvm_config = env::var_os(\"LLVM_CONFIG\")\n         .map(PathBuf::from)"}]}