{"sha": "f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "node_id": "C_kwDOAAsO6NoAKGY1MTkzYTlmY2M3M2RjMDllNDFhOTBjNWEyYzk3ZmM5YWNjMTYwMzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-25T19:15:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-25T19:15:26Z"}, "message": "Auto merge of #95474 - oli-obk:tait_ub, r=jackh726\n\nNeither require nor imply lifetime bounds on opaque type for well formedness\n\nThe actual hidden type can live arbitrarily longer than any individual lifetime and arbitrarily shorter than all but one of the lifetimes.\n\nfixes #86218\nfixes #84305\n\nThis is a **breaking change** but it is a necessary soundness fix", "tree": {"sha": "94bef252534bbe09eca9d1fc2253656c54a47136", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94bef252534bbe09eca9d1fc2253656c54a47136"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "html_url": "https://github.com/rust-lang/rust/commit/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3fafbb006ee98635874f73e480655912b465e65", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3fafbb006ee98635874f73e480655912b465e65", "html_url": "https://github.com/rust-lang/rust/commit/f3fafbb006ee98635874f73e480655912b465e65"}, {"sha": "59e285ff34796585a61a711e11a056c2999368ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/59e285ff34796585a61a711e11a056c2999368ea", "html_url": "https://github.com/rust-lang/rust/commit/59e285ff34796585a61a711e11a056c2999368ea"}], "stats": {"total": 851, "additions": 697, "deletions": 154}, "files": [{"sha": "e0140e281ee736cc07e072955fcaf5c8c87f7895", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -362,6 +362,11 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                     self.region_bound_pairs\n                         .insert(ty::OutlivesPredicate(GenericKind::Projection(projection_b), r_a));\n                 }\n+\n+                OutlivesBound::RegionSubOpaque(r_a, def_id, substs) => {\n+                    self.region_bound_pairs\n+                        .insert(ty::OutlivesPredicate(GenericKind::Opaque(def_id, substs), r_a));\n+                }\n             }\n         }\n     }"}, {"sha": "99469d1e1e7db9f189b587c7515be69e6c91130d", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -2481,6 +2481,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n             GenericKind::Projection(ref p) => format!(\"the associated type `{}`\", p),\n+            GenericKind::Opaque(def_id, substs) => {\n+                format!(\"the opaque type `{}`\", self.tcx.def_path_str_with_substs(def_id, substs))\n+            }\n         };\n \n         if let Some(SubregionOrigin::CompareImplItemObligation {"}, {"sha": "14ee9f05190102b8f7067bf28a1f56a7b332b9b5", "filename": "compiler/rustc_infer/src/infer/outlives/components.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -3,8 +3,9 @@\n // RFC for reference.\n \n use rustc_data_structures::sso::SsoHashSet;\n+use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, SubstsRef, Ty, TyCtxt, TypeVisitable};\n use smallvec::{smallvec, SmallVec};\n \n #[derive(Debug)]\n@@ -45,6 +46,8 @@ pub enum Component<'tcx> {\n     // them. This gives us room to improve the regionck reasoning in\n     // the future without breaking backwards compat.\n     EscapingProjection(Vec<Component<'tcx>>),\n+\n+    Opaque(DefId, SubstsRef<'tcx>),\n }\n \n /// Push onto `out` all the things that must outlive `'a` for the condition\n@@ -120,6 +123,17 @@ fn compute_components<'tcx>(\n                 out.push(Component::Param(p));\n             }\n \n+            // Ignore lifetimes found in opaque types. Opaque types can\n+            // have lifetimes in their substs which their hidden type doesn't\n+            // actually use. If we inferred that an opaque type is outlived by\n+            // its parameter lifetimes, then we could prove that any lifetime\n+            // outlives any other lifetime, which is unsound.\n+            // See https://github.com/rust-lang/rust/issues/84305 for\n+            // more details.\n+            ty::Opaque(def_id, substs) => {\n+                out.push(Component::Opaque(def_id, substs));\n+            },\n+\n             // For projections, we prefer to generate an obligation like\n             // `<P0 as Trait<P1...Pn>>::Foo: 'a`, because this gives the\n             // regionck more ways to prove that it holds. However,\n@@ -168,7 +182,6 @@ fn compute_components<'tcx>(\n             ty::Float(..) |       // OutlivesScalar\n             ty::Never |           // ...\n             ty::Adt(..) |         // OutlivesNominalType\n-            ty::Opaque(..) |      // OutlivesNominalType (ish)\n             ty::Foreign(..) |     // OutlivesNominalType\n             ty::Str |             // OutlivesScalar (ish)\n             ty::Slice(..) |       // ..."}, {"sha": "113d4f0906673d0ecef6f43f8b37c958dbeb10f4", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -142,6 +142,10 @@ impl<'a, 'tcx> OutlivesEnvironmentBuilder<'tcx> {\n                     self.region_bound_pairs\n                         .insert(ty::OutlivesPredicate(GenericKind::Projection(projection_b), r_a));\n                 }\n+                OutlivesBound::RegionSubOpaque(r_a, def_id, substs) => {\n+                    self.region_bound_pairs\n+                        .insert(ty::OutlivesPredicate(GenericKind::Opaque(def_id, substs), r_a));\n+                }\n                 OutlivesBound::RegionSubRegion(r_a, r_b) => {\n                     if let (ReEarlyBound(_) | ReFree(_), ReVar(vid_b)) = (r_a.kind(), r_b.kind()) {\n                         infcx"}, {"sha": "229b69b92e68e31f3b48f5190319c16885a6300d", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 103, "deletions": 41, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -68,10 +68,11 @@ use crate::infer::{\n };\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::undo_log::UndoLogs;\n+use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, Region, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, Region, SubstsRef, Ty, TyCtxt, TypeVisitable};\n use smallvec::smallvec;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n@@ -283,6 +284,9 @@ where\n                 Component::Param(param_ty) => {\n                     self.param_ty_must_outlive(origin, region, *param_ty);\n                 }\n+                Component::Opaque(def_id, substs) => {\n+                    self.opaque_must_outlive(*def_id, substs, origin, region)\n+                }\n                 Component::Projection(projection_ty) => {\n                     self.projection_must_outlive(origin, region, *projection_ty);\n                 }\n@@ -314,17 +318,69 @@ where\n         );\n \n         let generic = GenericKind::Param(param_ty);\n-        let verify_bound = self.verify_bound.generic_bound(generic);\n+        let verify_bound = self.verify_bound.param_bound(param_ty);\n         self.delegate.push_verify(origin, generic, region, verify_bound);\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n+    fn opaque_must_outlive(\n+        &mut self,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        region: ty::Region<'tcx>,\n+    ) {\n+        self.generic_must_outlive(\n+            origin,\n+            region,\n+            GenericKind::Opaque(def_id, substs),\n+            def_id,\n+            substs,\n+            true,\n+            |ty| match *ty.kind() {\n+                ty::Opaque(def_id, substs) => (def_id, substs),\n+                _ => bug!(\"expected only projection types from env, not {:?}\", ty),\n+            },\n+        );\n+    }\n+\n     #[instrument(level = \"debug\", skip(self))]\n     fn projection_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n         projection_ty: ty::ProjectionTy<'tcx>,\n     ) {\n+        self.generic_must_outlive(\n+            origin,\n+            region,\n+            GenericKind::Projection(projection_ty),\n+            projection_ty.item_def_id,\n+            projection_ty.substs,\n+            false,\n+            |ty| match ty.kind() {\n+                ty::Projection(projection_ty) => (projection_ty.item_def_id, projection_ty.substs),\n+                _ => bug!(\"expected only projection types from env, not {:?}\", ty),\n+            },\n+        );\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self, filter))]\n+    fn generic_must_outlive(\n+        &mut self,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        region: ty::Region<'tcx>,\n+        generic: GenericKind<'tcx>,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+        is_opaque: bool,\n+        filter: impl Fn(Ty<'tcx>) -> (DefId, SubstsRef<'tcx>),\n+    ) {\n+        // An optimization for a common case with opaque types.\n+        if substs.is_empty() {\n+            return;\n+        }\n+\n         // This case is thorny for inference. The fundamental problem is\n         // that there are many cases where we have choice, and inference\n         // doesn't like choice (the current region inference in\n@@ -343,16 +399,15 @@ where\n         // These are guaranteed to apply, no matter the inference\n         // results.\n         let trait_bounds: Vec<_> =\n-            self.verify_bound.projection_declared_bounds_from_trait(projection_ty).collect();\n+            self.verify_bound.declared_region_bounds(def_id, substs).collect();\n \n         debug!(?trait_bounds);\n \n         // Compute the bounds we can derive from the environment. This\n         // is an \"approximate\" match -- in some cases, these bounds\n         // may not apply.\n-        let mut approx_env_bounds =\n-            self.verify_bound.projection_approx_declared_bounds_from_env(projection_ty);\n-        debug!(\"projection_must_outlive: approx_env_bounds={:?}\", approx_env_bounds);\n+        let mut approx_env_bounds = self.verify_bound.approx_declared_bounds_from_env(generic);\n+        debug!(?approx_env_bounds);\n \n         // Remove outlives bounds that we get from the environment but\n         // which are also deducible from the trait. This arises (cc\n@@ -366,14 +421,8 @@ where\n             // If the declaration is `trait Trait<'b> { type Item: 'b; }`, then `projection_declared_bounds_from_trait`\n             // will be invoked with `['b => ^1]` and so we will get `^1` returned.\n             let bound = bound_outlives.skip_binder();\n-            match *bound.0.kind() {\n-                ty::Projection(projection_ty) => self\n-                    .verify_bound\n-                    .projection_declared_bounds_from_trait(projection_ty)\n-                    .all(|r| r != bound.1),\n-\n-                _ => panic!(\"expected only projection types from env, not {:?}\", bound.0),\n-            }\n+            let (def_id, substs) = filter(bound.0);\n+            self.verify_bound.declared_region_bounds(def_id, substs).all(|r| r != bound.1)\n         });\n \n         // If declared bounds list is empty, the only applicable rule is\n@@ -390,29 +439,11 @@ where\n         // the problem is to add `T: 'r`, which isn't true. So, if there are no\n         // inference variables, we use a verify constraint instead of adding\n         // edges, which winds up enforcing the same condition.\n-        let needs_infer = projection_ty.needs_infer();\n-        if approx_env_bounds.is_empty() && trait_bounds.is_empty() && needs_infer {\n-            debug!(\"projection_must_outlive: no declared bounds\");\n-\n-            let constraint = origin.to_constraint_category();\n-            for k in projection_ty.substs {\n-                match k.unpack() {\n-                    GenericArgKind::Lifetime(lt) => {\n-                        self.delegate.push_sub_region_constraint(\n-                            origin.clone(),\n-                            region,\n-                            lt,\n-                            constraint,\n-                        );\n-                    }\n-                    GenericArgKind::Type(ty) => {\n-                        self.type_must_outlive(origin.clone(), ty, region, constraint);\n-                    }\n-                    GenericArgKind::Const(_) => {\n-                        // Const parameters don't impose constraints.\n-                    }\n-                }\n-            }\n+        let needs_infer = substs.needs_infer();\n+        if approx_env_bounds.is_empty() && trait_bounds.is_empty() && (needs_infer || is_opaque) {\n+            debug!(\"no declared bounds\");\n+\n+            self.substs_must_outlive(substs, origin, region);\n \n             return;\n         }\n@@ -442,8 +473,8 @@ where\n                 .all(|b| b == Some(trait_bounds[0]))\n         {\n             let unique_bound = trait_bounds[0];\n-            debug!(\"projection_must_outlive: unique trait bound = {:?}\", unique_bound);\n-            debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n+            debug!(?unique_bound);\n+            debug!(\"unique declared bound appears in trait ref\");\n             let category = origin.to_constraint_category();\n             self.delegate.push_sub_region_constraint(origin, region, unique_bound, category);\n             return;\n@@ -454,11 +485,42 @@ where\n         // projection outlive; in some cases, this may add insufficient\n         // edges into the inference graph, leading to inference failures\n         // even though a satisfactory solution exists.\n-        let generic = GenericKind::Projection(projection_ty);\n-        let verify_bound = self.verify_bound.generic_bound(generic);\n+        let verify_bound = self.verify_bound.projection_opaque_bounds(\n+            generic,\n+            def_id,\n+            substs,\n+            &mut Default::default(),\n+        );\n         debug!(\"projection_must_outlive: pushing {:?}\", verify_bound);\n         self.delegate.push_verify(origin, generic, region, verify_bound);\n     }\n+\n+    fn substs_must_outlive(\n+        &mut self,\n+        substs: SubstsRef<'tcx>,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        region: ty::Region<'tcx>,\n+    ) {\n+        let constraint = origin.to_constraint_category();\n+        for k in substs {\n+            match k.unpack() {\n+                GenericArgKind::Lifetime(lt) => {\n+                    self.delegate.push_sub_region_constraint(\n+                        origin.clone(),\n+                        region,\n+                        lt,\n+                        constraint,\n+                    );\n+                }\n+                GenericArgKind::Type(ty) => {\n+                    self.type_must_outlive(origin.clone(), ty, region, constraint);\n+                }\n+                GenericArgKind::Const(_) => {\n+                    // Const parameters don't impose constraints.\n+                }\n+            }\n+        }\n+    }\n }\n \n impl<'cx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'cx, 'tcx> {"}, {"sha": "f470b2eb8c1939a4acef1abd6f12e7b4c6a35b97", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 37, "deletions": 72, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -2,11 +2,10 @@ use crate::infer::outlives::components::{compute_components_recursive, Component\n use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::region_constraints::VerifyIfEq;\n use crate::infer::{GenericKind, VerifyBound};\n-use rustc_data_structures::captures::Captures;\n use rustc_data_structures::sso::SsoHashSet;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::GenericArg;\n-use rustc_middle::ty::{self, EarlyBinder, OutlivesPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, EarlyBinder, OutlivesPredicate, SubstsRef, Ty, TyCtxt};\n \n use smallvec::smallvec;\n \n@@ -38,20 +37,8 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         Self { tcx, region_bound_pairs, implicit_region_bound, param_env }\n     }\n \n-    /// Returns a \"verify bound\" that encodes what we know about\n-    /// `generic` and the regions it outlives.\n-    pub fn generic_bound(&self, generic: GenericKind<'tcx>) -> VerifyBound<'tcx> {\n-        let mut visited = SsoHashSet::new();\n-        match generic {\n-            GenericKind::Param(param_ty) => self.param_bound(param_ty),\n-            GenericKind::Projection(projection_ty) => {\n-                self.projection_bound(projection_ty, &mut visited)\n-            }\n-        }\n-    }\n-\n     #[instrument(level = \"debug\", skip(self))]\n-    fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n+    pub fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n         // Start with anything like `T: 'a` we can scrape from the\n         // environment. If the environment contains something like\n         // `for<'a> T: 'a`, then we know that `T` outlives everything.\n@@ -105,41 +92,31 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     /// the clause from the environment only applies if `'0 = 'a`,\n     /// which we don't know yet. But we would still include `'b` in\n     /// this list.\n-    pub fn projection_approx_declared_bounds_from_env(\n+    pub fn approx_declared_bounds_from_env(\n         &self,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n+        generic: GenericKind<'tcx>,\n     ) -> Vec<ty::Binder<'tcx, ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>> {\n-        let projection_ty = GenericKind::Projection(projection_ty).to_ty(self.tcx);\n+        let projection_ty = generic.to_ty(self.tcx);\n         let erased_projection_ty = self.tcx.erase_regions(projection_ty);\n         self.declared_generic_bounds_from_env_for_erased_ty(erased_projection_ty)\n     }\n \n-    /// Searches the where-clauses in scope for regions that\n-    /// `projection_ty` is known to outlive. Currently requires an\n-    /// exact match.\n-    pub fn projection_declared_bounds_from_trait(\n+    #[instrument(level = \"debug\", skip(self, visited))]\n+    pub fn projection_opaque_bounds(\n         &self,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'tcx> {\n-        self.declared_projection_bounds_from_trait(projection_ty)\n-    }\n-\n-    pub fn projection_bound(\n-        &self,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n+        generic: GenericKind<'tcx>,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n         visited: &mut SsoHashSet<GenericArg<'tcx>>,\n     ) -> VerifyBound<'tcx> {\n-        debug!(\"projection_bound(projection_ty={:?})\", projection_ty);\n-\n-        let projection_ty_as_ty =\n-            self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n+        let generic_ty = generic.to_ty(self.tcx);\n \n         // Search the env for where clauses like `P: 'a`.\n-        let env_bounds = self\n-            .projection_approx_declared_bounds_from_env(projection_ty)\n+        let projection_opaque_bounds = self\n+            .approx_declared_bounds_from_env(generic)\n             .into_iter()\n             .map(|binder| {\n-                if let Some(ty::OutlivesPredicate(ty, r)) = binder.no_bound_vars() && ty == projection_ty_as_ty {\n+                if let Some(ty::OutlivesPredicate(ty, r)) = binder.no_bound_vars() && ty == generic_ty {\n                     // Micro-optimize if this is an exact match (this\n                     // occurs often when there are no region variables\n                     // involved).\n@@ -149,21 +126,19 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n                     VerifyBound::IfEq(verify_if_eq_b)\n                 }\n             });\n-\n         // Extend with bounds that we can find from the trait.\n-        let trait_bounds = self\n-            .projection_declared_bounds_from_trait(projection_ty)\n-            .map(|r| VerifyBound::OutlivedBy(r));\n+        let trait_bounds =\n+            self.declared_region_bounds(def_id, substs).map(|r| VerifyBound::OutlivedBy(r));\n \n         // see the extensive comment in projection_must_outlive\n         let recursive_bound = {\n             let mut components = smallvec![];\n-            let ty = self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n-            compute_components_recursive(self.tcx, ty.into(), &mut components, visited);\n+            compute_components_recursive(self.tcx, generic_ty.into(), &mut components, visited);\n             self.bound_from_components(&components, visited)\n         };\n \n-        VerifyBound::AnyBound(env_bounds.chain(trait_bounds).collect()).or(recursive_bound)\n+        VerifyBound::AnyBound(projection_opaque_bounds.chain(trait_bounds).collect())\n+            .or(recursive_bound)\n     }\n \n     fn bound_from_components(\n@@ -195,7 +170,18 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         match *component {\n             Component::Region(lt) => VerifyBound::OutlivedBy(lt),\n             Component::Param(param_ty) => self.param_bound(param_ty),\n-            Component::Projection(projection_ty) => self.projection_bound(projection_ty, visited),\n+            Component::Opaque(did, substs) => self.projection_opaque_bounds(\n+                GenericKind::Opaque(did, substs),\n+                did,\n+                substs,\n+                visited,\n+            ),\n+            Component::Projection(projection_ty) => self.projection_opaque_bounds(\n+                GenericKind::Projection(projection_ty),\n+                projection_ty.item_def_id,\n+                projection_ty.substs,\n+                visited,\n+            ),\n             Component::EscapingProjection(ref components) => {\n                 self.bound_from_components(components, visited)\n             }\n@@ -293,30 +279,6 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     /// }\n     /// ```\n     ///\n-    /// then this function would return `'x`. This is subject to the\n-    /// limitations around higher-ranked bounds described in\n-    /// `region_bounds_declared_on_associated_item`.\n-    fn declared_projection_bounds_from_trait(\n-        &self,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'tcx> {\n-        debug!(\"projection_bounds(projection_ty={:?})\", projection_ty);\n-        let tcx = self.tcx;\n-        self.region_bounds_declared_on_associated_item(projection_ty.item_def_id)\n-            .map(move |r| EarlyBinder(r).subst(tcx, projection_ty.substs))\n-    }\n-\n-    /// Given the `DefId` of an associated item, returns any region\n-    /// bounds attached to that associated item from the trait definition.\n-    ///\n-    /// For example:\n-    ///\n-    /// ```rust\n-    /// trait Foo<'a> {\n-    ///     type Bar: 'a;\n-    /// }\n-    /// ```\n-    ///\n     /// If we were given the `DefId` of `Foo::Bar`, we would return\n     /// `'a`. You could then apply the substitutions from the\n     /// projection to convert this into your namespace. This also\n@@ -336,17 +298,20 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     ///\n     /// This is for simplicity, and because we are not really smart\n     /// enough to cope with such bounds anywhere.\n-    fn region_bounds_declared_on_associated_item(\n+    pub fn declared_region_bounds(\n         &self,\n-        assoc_item_def_id: DefId,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n     ) -> impl Iterator<Item = ty::Region<'tcx>> {\n         let tcx = self.tcx;\n-        let bounds = tcx.item_bounds(assoc_item_def_id);\n+        let bounds = tcx.item_bounds(def_id);\n+        trace!(\"{:#?}\", bounds);\n         bounds\n             .into_iter()\n             .filter_map(|p| p.to_opt_type_outlives())\n             .filter_map(|p| p.no_bound_vars())\n             .map(|b| b.1)\n+            .map(move |r| EarlyBinder(r).subst(tcx, substs))\n     }\n \n     /// Searches through a predicate list for a predicate `T: 'a`."}, {"sha": "67b3da687200e9538aff976cbf4db4af520c482e", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -12,8 +12,10 @@ use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::UndoLogs;\n use rustc_data_structures::unify as ut;\n+use rustc_hir::def_id::DefId;\n use rustc_index::vec::IndexVec;\n use rustc_middle::infer::unify_key::{RegionVidKey, UnifiedRegion};\n+use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::ReStatic;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{ReLateBound, ReVar};\n@@ -168,6 +170,7 @@ pub struct Verify<'tcx> {\n pub enum GenericKind<'tcx> {\n     Param(ty::ParamTy),\n     Projection(ty::ProjectionTy<'tcx>),\n+    Opaque(DefId, SubstsRef<'tcx>),\n }\n \n /// Describes the things that some `GenericKind` value `G` is known to\n@@ -747,6 +750,9 @@ impl<'tcx> fmt::Debug for GenericKind<'tcx> {\n         match *self {\n             GenericKind::Param(ref p) => write!(f, \"{:?}\", p),\n             GenericKind::Projection(ref p) => write!(f, \"{:?}\", p),\n+            GenericKind::Opaque(def_id, substs) => ty::tls::with(|tcx| {\n+                write!(f, \"{}\", tcx.def_path_str_with_substs(def_id, tcx.lift(substs).unwrap()))\n+            }),\n         }\n     }\n }\n@@ -756,6 +762,9 @@ impl<'tcx> fmt::Display for GenericKind<'tcx> {\n         match *self {\n             GenericKind::Param(ref p) => write!(f, \"{}\", p),\n             GenericKind::Projection(ref p) => write!(f, \"{}\", p),\n+            GenericKind::Opaque(def_id, substs) => ty::tls::with(|tcx| {\n+                write!(f, \"{}\", tcx.def_path_str_with_substs(def_id, tcx.lift(substs).unwrap()))\n+            }),\n         }\n     }\n }\n@@ -765,6 +774,7 @@ impl<'tcx> GenericKind<'tcx> {\n         match *self {\n             GenericKind::Param(ref p) => p.to_ty(tcx),\n             GenericKind::Projection(ref p) => tcx.mk_projection(p.item_def_id, p.substs),\n+            GenericKind::Opaque(def_id, substs) => tcx.mk_opaque(def_id, substs),\n         }\n     }\n }"}, {"sha": "e12c069dcc1d980de0587cc5368b863574767ca0", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -246,6 +246,13 @@ impl<'tcx> Elaborator<'tcx> {\n \n                             Component::UnresolvedInferenceVariable(_) => None,\n \n+                            Component::Opaque(def_id, substs) => {\n+                                let ty = tcx.mk_opaque(def_id, substs);\n+                                Some(ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n+                                    ty, r_min,\n+                                )))\n+                            }\n+\n                             Component::Projection(projection) => {\n                                 // We might end up here if we have `Foo<<Bar as Baz>::Assoc>: 'a`.\n                                 // With this, we can deduce that `<Bar as Baz>::Assoc: 'a`.\n@@ -262,8 +269,9 @@ impl<'tcx> Elaborator<'tcx> {\n                                 None\n                             }\n                         })\n-                        .map(ty::Binder::dummy)\n-                        .map(|predicate_kind| predicate_kind.to_predicate(tcx))\n+                        .map(|predicate_kind| {\n+                            bound_predicate.rebind(predicate_kind).to_predicate(tcx)\n+                        })\n                         .filter(|&predicate| visited.insert(predicate))\n                         .map(|predicate| {\n                             predicate_obligation("}, {"sha": "fb152b63f63448675059b251cbd6191681df48fa", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -8,8 +8,9 @@\n use crate::error::DropCheckOverflow;\n use crate::infer::canonical::{Canonical, QueryResponse};\n use crate::ty::error::TypeError;\n-use crate::ty::subst::GenericArg;\n+use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt};\n+use rustc_hir::def_id::DefId;\n use rustc_span::source_map::Span;\n use std::iter::FromIterator;\n \n@@ -219,4 +220,5 @@ pub enum OutlivesBound<'tcx> {\n     RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n     RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n     RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n+    RegionSubOpaque(ty::Region<'tcx>, DefId, SubstsRef<'tcx>),\n }"}, {"sha": "32aca4a8a3f9108ad16eb62787468a35a81790dd", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -156,6 +156,9 @@ fn implied_bounds_from_components<'tcx>(\n                 Component::Region(r) => Some(OutlivesBound::RegionSubRegion(sub_region, r)),\n                 Component::Param(p) => Some(OutlivesBound::RegionSubParam(sub_region, p)),\n                 Component::Projection(p) => Some(OutlivesBound::RegionSubProjection(sub_region, p)),\n+                Component::Opaque(def_id, substs) => {\n+                    Some(OutlivesBound::RegionSubOpaque(sub_region, def_id, substs))\n+                }\n                 Component::EscapingProjection(_) =>\n                 // If the projection has escaping regions, don't\n                 // try to infer any implied bounds even for its"}, {"sha": "39610e3ae38057228ec2d97c6690806261aeabfe", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -265,6 +265,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         self.cat_expr_adjusted_with(expr, || Ok(previous), adjustment)\n     }\n \n+    #[instrument(level = \"debug\", skip(self, previous))]\n     fn cat_expr_adjusted_with<F>(\n         &self,\n         expr: &hir::Expr<'_>,\n@@ -274,7 +275,6 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     where\n         F: FnOnce() -> McResult<PlaceWithHirId<'tcx>>,\n     {\n-        debug!(\"cat_expr_adjusted_with({:?}): {:?}\", adjustment, expr);\n         let target = self.resolve_vars_if_possible(adjustment.target);\n         match adjustment.kind {\n             adjustment::Adjust::Deref(overloaded) => {\n@@ -299,6 +299,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn cat_expr_unadjusted(\n         &self,\n         expr: &hir::Expr<'_>,\n@@ -387,15 +388,14 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self, span))]\n     pub(crate) fn cat_res(\n         &self,\n         hir_id: hir::HirId,\n         span: Span,\n         expr_ty: Ty<'tcx>,\n         res: Res,\n     ) -> McResult<PlaceWithHirId<'tcx>> {\n-        debug!(\"cat_res: id={:?} expr={:?} def={:?}\", hir_id, expr_ty, res);\n-\n         match res {\n             Res::Def(\n                 DefKind::Ctor(..)\n@@ -475,13 +475,12 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         ret\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn cat_overloaded_place(\n         &self,\n         expr: &hir::Expr<'_>,\n         base: &hir::Expr<'_>,\n     ) -> McResult<PlaceWithHirId<'tcx>> {\n-        debug!(\"cat_overloaded_place(expr={:?}, base={:?})\", expr, base);\n-\n         // Reconstruct the output assuming it's a reference with the\n         // same region and mutability as the receiver. This holds for\n         // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n@@ -497,13 +496,12 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         self.cat_deref(expr, base)\n     }\n \n+    #[instrument(level = \"debug\", skip(self, node))]\n     fn cat_deref(\n         &self,\n         node: &impl HirNode,\n         base_place: PlaceWithHirId<'tcx>,\n     ) -> McResult<PlaceWithHirId<'tcx>> {\n-        debug!(\"cat_deref: base_place={:?}\", base_place);\n-\n         let base_curr_ty = base_place.place.ty();\n         let deref_ty = match base_curr_ty.builtin_deref(true) {\n             Some(mt) => mt.ty,"}, {"sha": "0409c7081dc4f5cde6e626905b82b9255e83f6f2", "filename": "compiler/rustc_typeck/src/outlives/utils.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Futils.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -96,6 +96,23 @@ pub(crate) fn insert_outlives_predicate<'tcx>(\n                             .or_insert(span);\n                     }\n \n+                    Component::Opaque(def_id, substs) => {\n+                        // This would arise from something like:\n+                        //\n+                        // ```rust\n+                        // type Opaque<T> = impl Sized;\n+                        // fn defining<T>() -> Opaque<T> {}\n+                        // struct Ss<'a, T>(&'a Opaque<T>);\n+                        // ```\n+                        //\n+                        // Here we want to have an implied bound `Opaque<T>: 'a`\n+\n+                        let ty = tcx.mk_opaque(def_id, substs);\n+                        required_predicates\n+                            .entry(ty::OutlivesPredicate(ty.into(), outlived_region))\n+                            .or_insert(span);\n+                    }\n+\n                     Component::EscapingProjection(_) => {\n                         // As above, but the projection involves\n                         // late-bound regions.  Therefore, the WF"}, {"sha": "de1b464a41dbe81ebe20d175f37ebbfc74eba1be", "filename": "src/test/ui/generic-associated-types/bugs/issue-86218.stderr", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f3fafbb006ee98635874f73e480655912b465e65/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-86218.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3fafbb006ee98635874f73e480655912b465e65/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-86218.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-86218.stderr?ref=f3fafbb006ee98635874f73e480655912b465e65", "patch": "@@ -1,23 +0,0 @@\n-error[E0477]: the type `<() as Yay<&'a ()>>::InnerStream<'s>` does not fulfill the required lifetime\n-  --> $DIR/issue-86218.rs:22:28\n-   |\n-LL |     type InnerStream<'s> = impl Stream<Item = i32> + 's;\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: type must outlive the lifetime `'s` as defined here as required by this binding\n-  --> $DIR/issue-86218.rs:22:22\n-   |\n-LL |     type InnerStream<'s> = impl Stream<Item = i32> + 's;\n-   |                      ^^\n-\n-error: unconstrained opaque type\n-  --> $DIR/issue-86218.rs:22:28\n-   |\n-LL |     type InnerStream<'s> = impl Stream<Item = i32> + 's;\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `InnerStream` must be used in combination with a concrete type within the same module\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0477`."}, {"sha": "63c839ea8712d798e0c82fa66ae41fbb13cfa866", "filename": "src/test/ui/generic-associated-types/issue-86218-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86218-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86218-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86218-2.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+pub trait Stream {\n+    type Item;\n+}\n+\n+impl Stream for () {\n+    type Item = i32;\n+}\n+\n+trait Yay<AdditionalValue> {\n+    type InnerStream<'s>: Stream<Item = i32> + 's;\n+    fn foo<'s>() -> Self::InnerStream<'s>;\n+}\n+\n+impl<T> Yay<T> for () {\n+    type InnerStream<'s> = impl Stream<Item = i32> + 's;\n+    fn foo<'s>() -> Self::InnerStream<'s> { () }\n+}\n+\n+fn main() {}"}, {"sha": "b2c3071f06b100cc8b804bf0ac0b6a40e71b2518", "filename": "src/test/ui/generic-associated-types/issue-86218.rs", "status": "renamed", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86218.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86218.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86218.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -1,7 +1,4 @@\n-// check-fail\n-// known-bug: #86218\n-\n-// This should pass, but seems to run into a TAIT issue.\n+// check-pass\n \n #![feature(type_alias_impl_trait)]\n \n@@ -20,7 +17,8 @@ trait Yay<AdditionalValue> {\n \n impl<'a> Yay<&'a ()> for () {\n     type InnerStream<'s> = impl Stream<Item = i32> + 's;\n-    fn foo<'s>() -> Self::InnerStream<'s> { todo!() }\n+    //^ ERROR does not fulfill the required lifetime\n+    fn foo<'s>() -> Self::InnerStream<'s> { () }\n }\n \n fn main() {}", "previous_filename": "src/test/ui/generic-associated-types/bugs/issue-86218.rs"}, {"sha": "6c2505177fef83b2bd96501dccd51a7f99c75d80", "filename": "src/test/ui/impl-trait/unactionable_diagnostic.fixed", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Fimpl-trait%2Funactionable_diagnostic.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Fimpl-trait%2Funactionable_diagnostic.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funactionable_diagnostic.fixed?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,25 @@\n+// run-rustfix\n+\n+pub trait Trait {}\n+\n+pub struct Foo;\n+\n+impl Trait for Foo {}\n+\n+fn foo<'x, P>(\n+    _post: P,\n+    x: &'x Foo,\n+) -> &'x impl Trait {\n+    x\n+}\n+\n+pub fn bar<'t, T: 't>(\n+    //~^ HELP: consider adding an explicit lifetime bound...\n+    post: T,\n+    x: &'t Foo,\n+) -> &'t impl Trait {\n+    foo(post, x)\n+    //~^ ERROR: the parameter type `T` may not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "bce35cbdd0d385b80bf6e1275f37acfc50f1eb26", "filename": "src/test/ui/impl-trait/unactionable_diagnostic.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Fimpl-trait%2Funactionable_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Fimpl-trait%2Funactionable_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funactionable_diagnostic.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,25 @@\n+// run-rustfix\n+\n+pub trait Trait {}\n+\n+pub struct Foo;\n+\n+impl Trait for Foo {}\n+\n+fn foo<'x, P>(\n+    _post: P,\n+    x: &'x Foo,\n+) -> &'x impl Trait {\n+    x\n+}\n+\n+pub fn bar<'t, T>(\n+    //~^ HELP: consider adding an explicit lifetime bound...\n+    post: T,\n+    x: &'t Foo,\n+) -> &'t impl Trait {\n+    foo(post, x)\n+    //~^ ERROR: the parameter type `T` may not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "a32004cda1a6f00c976720d04f27c4aa8c12e2b0", "filename": "src/test/ui/impl-trait/unactionable_diagnostic.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Fimpl-trait%2Funactionable_diagnostic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Fimpl-trait%2Funactionable_diagnostic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funactionable_diagnostic.stderr?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,14 @@\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/unactionable_diagnostic.rs:21:5\n+   |\n+LL |     foo(post, x)\n+   |     ^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | pub fn bar<'t, T: 't>(\n+   |                 ++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "53cbf8d229006ecdb2cfbcdf9c168733a4f68e15", "filename": "src/test/ui/type-alias-impl-trait/implied_bounds.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,51 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type WithLifetime<'a> = impl Equals<SelfType = ()>;\n+fn _defining_use<'a>() -> WithLifetime<'a> {}\n+\n+trait Convert<'a> {\n+    type Witness;\n+    fn convert<'b, T: ?Sized>(_proof: &'b Self::Witness, x: &'a T) -> &'b T;\n+}\n+\n+impl<'a> Convert<'a> for () {\n+    type Witness = WithLifetime<'a>;\n+\n+    fn convert<'b, T: ?Sized>(_proof: &'b WithLifetime<'a>, x: &'a T) -> &'b T {\n+        // compiler used to think it gets to assume 'a: 'b here because\n+        // of the `&'b WithLifetime<'a>` argument\n+        x\n+        //~^ ERROR lifetime may not live long enough\n+    }\n+}\n+\n+fn extend_lifetime<'a, 'b, T: ?Sized>(x: &'a T) -> &'b T {\n+    WithLifetime::<'a>::convert_helper::<(), T>(&(), x)\n+}\n+\n+trait Equals {\n+    type SelfType;\n+    fn convert_helper<'a, 'b, W: Convert<'a, Witness = Self>, T: ?Sized>(\n+        proof: &'b Self::SelfType,\n+        x: &'a T,\n+    ) -> &'b T;\n+}\n+\n+impl<S> Equals for S {\n+    type SelfType = Self;\n+    fn convert_helper<'a, 'b, W: Convert<'a, Witness = Self>, T: ?Sized>(\n+        proof: &'b Self,\n+        x: &'a T,\n+    ) -> &'b T {\n+        W::convert(proof, x)\n+    }\n+}\n+\n+fn main() {\n+    let r;\n+    {\n+        let x = String::from(\"Hello World?\");\n+        r = extend_lifetime(&x);\n+    }\n+    println!(\"{}\", r);\n+}"}, {"sha": "6f11b66634b293aa8331e8fd22a71f9f3e50a2e3", "filename": "src/test/ui/type-alias-impl-trait/implied_bounds.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds.stderr?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,16 @@\n+error: lifetime may not live long enough\n+  --> $DIR/implied_bounds.rs:17:9\n+   |\n+LL | impl<'a> Convert<'a> for () {\n+   |      -- lifetime `'a` defined here\n+...\n+LL |     fn convert<'b, T: ?Sized>(_proof: &'b WithLifetime<'a>, x: &'a T) -> &'b T {\n+   |                -- lifetime `'b` defined here\n+...\n+LL |         x\n+   |         ^ associated function was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a`\n+   |\n+   = help: consider adding the following bound: `'a: 'b`\n+\n+error: aborting due to previous error\n+"}, {"sha": "b4c4c013cd25112c28567d3a7488733c0a32de58", "filename": "src/test/ui/type-alias-impl-trait/implied_bounds2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds2.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type Ty<'a, A> = impl Sized + 'a;\n+fn defining<'a, A>() -> Ty<'a, A> {}\n+fn assert_static<T: 'static>() {}\n+fn test<'a, A>() where Ty<'a, A>: 'static, { assert_static::<Ty<'a, A>>() }\n+\n+fn main() {}"}, {"sha": "e39c613281dc72b77ba8211da4af8b734ca4ac79", "filename": "src/test/ui/type-alias-impl-trait/implied_bounds3.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds3.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+fn foo<F>(_: F)\n+where\n+    F: 'static,\n+{\n+}\n+\n+fn from<F: Send>(f: F) -> impl Send {\n+    f\n+}\n+\n+fn bar<T>() {\n+    foo(from(|| ()))\n+}\n+\n+fn main() {\n+}"}, {"sha": "4cf35f951904a93c10981fd9ae05a0b3301686b7", "filename": "src/test/ui/type-alias-impl-trait/implied_bounds_closure.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds_closure.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,31 @@\n+trait StaticDefaultRef: 'static {\n+    fn default_ref() -> &'static Self;\n+}\n+\n+impl StaticDefaultRef for str {\n+    fn default_ref() -> &'static str {\n+        \"\"\n+    }\n+}\n+\n+fn into_impl(x: &str) -> &(impl ?Sized + AsRef<str> + StaticDefaultRef + '_) {\n+    x\n+}\n+\n+fn extend_lifetime<'a>(x: &'a str) -> &'static str {\n+    let t = into_impl(x);\n+    helper(|_| t) //~ ERROR lifetime may not live long enough\n+}\n+\n+fn helper<T: ?Sized + AsRef<str> + StaticDefaultRef>(f: impl FnOnce(&T) -> &T) -> &'static str {\n+    f(T::default_ref()).as_ref()\n+}\n+\n+fn main() {\n+    let r;\n+    {\n+        let x = String::from(\"Hello World?\");\n+        r = extend_lifetime(&x);\n+    }\n+    println!(\"{}\", r);\n+}"}, {"sha": "151564c3b45a169a5e4f23425a0c932227b20a5a", "filename": "src/test/ui/type-alias-impl-trait/implied_bounds_closure.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds_closure.stderr?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,11 @@\n+error: lifetime may not live long enough\n+  --> $DIR/implied_bounds_closure.rs:17:16\n+   |\n+LL | fn extend_lifetime<'a>(x: &'a str) -> &'static str {\n+   |                    -- lifetime `'a` defined here\n+LL |     let t = into_impl(x);\n+LL |     helper(|_| t)\n+   |                ^ returning this value requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "8023cd24f0bf621d86e16fd6ea02d25d6b9efe52", "filename": "src/test/ui/type-alias-impl-trait/implied_bounds_from_types.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds_from_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds_from_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds_from_types.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,51 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type WithLifetime<T> = impl Equals<SelfType = ()>;\n+fn _defining_use<T>() -> WithLifetime<T> {}\n+\n+trait Convert<'a> {\n+    type Witness;\n+    fn convert<'b, T: ?Sized>(_proof: &'b Self::Witness, x: &'a T) -> &'b T;\n+}\n+\n+impl<'a> Convert<'a> for () {\n+    type Witness = WithLifetime<&'a ()>;\n+\n+    fn convert<'b, T: ?Sized>(_proof: &'b WithLifetime<&'a ()>, x: &'a T) -> &'b T {\n+        // compiler used to think it gets to assume 'a: 'b here because\n+        // of the `&'b WithLifetime<&'a ()>` argument\n+        x\n+        //~^ ERROR lifetime may not live long enough\n+    }\n+}\n+\n+fn extend_lifetime<'a, 'b, T: ?Sized>(x: &'a T) -> &'b T {\n+    WithLifetime::<&'a ()>::convert_helper::<(), T>(&(), x)\n+}\n+\n+trait Equals {\n+    type SelfType;\n+    fn convert_helper<'a, 'b, W: Convert<'a, Witness = Self>, T: ?Sized>(\n+        proof: &'b Self::SelfType,\n+        x: &'a T,\n+    ) -> &'b T;\n+}\n+\n+impl<S> Equals for S {\n+    type SelfType = Self;\n+    fn convert_helper<'a, 'b, W: Convert<'a, Witness = Self>, T: ?Sized>(\n+        proof: &'b Self,\n+        x: &'a T,\n+    ) -> &'b T {\n+        W::convert(proof, x)\n+    }\n+}\n+\n+fn main() {\n+    let r;\n+    {\n+        let x = String::from(\"Hello World?\");\n+        r = extend_lifetime(&x);\n+    }\n+    println!(\"{}\", r);\n+}"}, {"sha": "cbc5e6073181582e7c9f1dc8492c40a5aa2e5b36", "filename": "src/test/ui/type-alias-impl-trait/implied_bounds_from_types.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds_from_types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds_from_types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_bounds_from_types.stderr?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,16 @@\n+error: lifetime may not live long enough\n+  --> $DIR/implied_bounds_from_types.rs:17:9\n+   |\n+LL | impl<'a> Convert<'a> for () {\n+   |      -- lifetime `'a` defined here\n+...\n+LL |     fn convert<'b, T: ?Sized>(_proof: &'b WithLifetime<&'a ()>, x: &'a T) -> &'b T {\n+   |                -- lifetime `'b` defined here\n+...\n+LL |         x\n+   |         ^ associated function was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a`\n+   |\n+   = help: consider adding the following bound: `'a: 'b`\n+\n+error: aborting due to previous error\n+"}, {"sha": "b6a7264a529fd5a0c6a26bb8a1cbe55e1865626d", "filename": "src/test/ui/type-alias-impl-trait/implied_lifetime_wf_check.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,27 @@\n+#![feature(type_alias_impl_trait)]\n+\n+// known-bug: #99840\n+// this should not compile\n+// check-pass\n+\n+type Alias = impl Sized;\n+\n+fn constrain() -> Alias {\n+    1i32\n+}\n+\n+trait HideIt {\n+    type Assoc;\n+}\n+\n+impl HideIt for () {\n+    type Assoc = Alias;\n+}\n+\n+pub trait Yay {}\n+\n+impl Yay for <() as HideIt>::Assoc {}\n+// impl Yay for i32 {} // this already errors\n+// impl Yay for u32 {} // this also already errors\n+\n+fn main() {}"}, {"sha": "6e5b8f491eab5ef9b878d84657bc87cf3a3cf71a", "filename": "src/test/ui/type-alias-impl-trait/implied_lifetime_wf_check3.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check3.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,43 @@\n+#![feature(type_alias_impl_trait)]\n+\n+mod test_lifetime_param {\n+    type Ty<'a> = impl Sized;\n+    fn defining(a: &str) -> Ty<'_> { a }\n+    fn assert_static<'a: 'static>() {}\n+    //~^ WARN: unnecessary lifetime parameter `'a`\n+    fn test<'a>() where Ty<'a>: 'static { assert_static::<'a>() }\n+    //~^ ERROR: lifetime may not live long enough\n+}\n+\n+mod test_higher_kinded_lifetime_param {\n+    type Ty<'a> = impl Sized;\n+    fn defining(a: &str) -> Ty<'_> { a }\n+    fn assert_static<'a: 'static>() {}\n+    //~^ WARN: unnecessary lifetime parameter `'a`\n+    fn test<'a>() where for<'b> Ty<'b>: 'a { assert_static::<'a>() }\n+    //~^ ERROR: lifetime may not live long enough\n+}\n+\n+mod test_higher_kinded_lifetime_param2 {\n+    fn assert_static<'a: 'static>() {}\n+    //~^ WARN: unnecessary lifetime parameter `'a`\n+    fn test<'a>() { assert_static::<'a>() }\n+    //~^ ERROR: lifetime may not live long enough\n+}\n+\n+mod test_type_param {\n+    type Ty<A> = impl Sized;\n+    fn defining<A>(s: A) -> Ty<A> { s }\n+    fn assert_static<A: 'static>() {}\n+    fn test<A>() where Ty<A>: 'static { assert_static::<A>() }\n+    //~^ ERROR: parameter type `A` may not live long enough\n+}\n+\n+mod test_implied_from_fn_sig {\n+    type Opaque<T: 'static> = impl Sized;\n+    fn defining<T: 'static>() -> Opaque<T> {}\n+    fn assert_static<T: 'static>() {}\n+    fn test<T>(_: Opaque<T>) { assert_static::<T>(); }\n+}\n+\n+fn main() {}"}, {"sha": "887620a4d50eca3aa32496ebb24f564767820320", "filename": "src/test/ui/type-alias-impl-trait/implied_lifetime_wf_check3.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check3.stderr?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,58 @@\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/implied_lifetime_wf_check3.rs:6:22\n+   |\n+LL |     fn assert_static<'a: 'static>() {}\n+   |                      ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/implied_lifetime_wf_check3.rs:15:22\n+   |\n+LL |     fn assert_static<'a: 'static>() {}\n+   |                      ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/implied_lifetime_wf_check3.rs:22:22\n+   |\n+LL |     fn assert_static<'a: 'static>() {}\n+   |                      ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/implied_lifetime_wf_check3.rs:8:43\n+   |\n+LL |     fn test<'a>() where Ty<'a>: 'static { assert_static::<'a>() }\n+   |             -- lifetime `'a` defined here ^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/implied_lifetime_wf_check3.rs:17:46\n+   |\n+LL |     fn test<'a>() where for<'b> Ty<'b>: 'a { assert_static::<'a>() }\n+   |             -- lifetime `'a` defined here    ^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/implied_lifetime_wf_check3.rs:24:21\n+   |\n+LL |     fn test<'a>() { assert_static::<'a>() }\n+   |             --      ^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+   |             |\n+   |             lifetime `'a` defined here\n+\n+error[E0310]: the parameter type `A` may not live long enough\n+  --> $DIR/implied_lifetime_wf_check3.rs:32:41\n+   |\n+LL |     fn test<A>() where Ty<A>: 'static { assert_static::<A>() }\n+   |                                         ^^^^^^^^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     fn test<A: 'static>() where Ty<A>: 'static { assert_static::<A>() }\n+   |              +++++++++\n+\n+error: aborting due to 4 previous errors; 3 warnings emitted\n+\n+For more information about this error, try `rustc --explain E0310`."}, {"sha": "ac32dbde04b1c8e3fe8d05b032912a3a943c395b", "filename": "src/test/ui/type-alias-impl-trait/implied_lifetime_wf_check4_static.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check4_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check4_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check4_static.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,11 @@\n+#![feature(type_alias_impl_trait)]\n+\n+mod test_type_param_static {\n+    type Ty<A> = impl Sized + 'static;\n+    //~^ ERROR: the parameter type `A` may not live long enough\n+    fn defining<A: 'static>(s: A) -> Ty<A> { s }\n+    fn assert_static<A: 'static>() {}\n+    fn test<A>() where Ty<A>: 'static { assert_static::<A>() }\n+}\n+\n+fn main() {}"}, {"sha": "47bc31e78c34f8c42c775f95f841d67d86749cc9", "filename": "src/test/ui/type-alias-impl-trait/implied_lifetime_wf_check4_static.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check4_static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check4_static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimplied_lifetime_wf_check4_static.stderr?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,14 @@\n+error[E0310]: the parameter type `A` may not live long enough\n+  --> $DIR/implied_lifetime_wf_check4_static.rs:4:18\n+   |\n+LL |     type Ty<A> = impl Sized + 'static;\n+   |                  ^^^^^^^^^^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     type Ty<A: 'static> = impl Sized + 'static;\n+   |              +++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0310`."}, {"sha": "477b61390ed46d44a6ebe734180e7c6b19ec787a", "filename": "src/test/ui/type-alias-impl-trait/issue-58662-generator-with-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58662-generator-with-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58662-generator-with-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58662-generator-with-lifetime.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -16,7 +16,7 @@ fn rand_generator<'a>(rng: &'a ()) -> RandGenerator<'a> {\n     }\n }\n \n-pub type RandGeneratorWithIndirection<'a> = impl Generator<Return = (), Yield = u64> + 'a;\n+pub type RandGeneratorWithIndirection<'c> = impl Generator<Return = (), Yield = u64> + 'c;\n pub fn rand_generator_with_indirection<'a>(rng: &'a ()) -> RandGeneratorWithIndirection<'a> {\n     fn helper<'b>(rng: &'b ()) -> impl 'b + Generator<Return = (), Yield = u64> {\n         move || {"}, {"sha": "27ca7d0fdc9fa4fd76a7da1e1a95e8a3debcbefa", "filename": "src/test/ui/type-alias-impl-trait/issue-58662-simplified.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58662-simplified.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58662-simplified.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58662-simplified.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+\n+#![feature(generators, generator_trait)]\n+#![feature(type_alias_impl_trait)]\n+\n+trait Trait {}\n+\n+impl<T> Trait for T {}\n+\n+type Foo<'c> = impl Trait + 'c;\n+fn foo<'a>(rng: &'a ()) -> Foo<'a> {\n+    fn helper<'b>(rng: &'b ()) -> impl 'b + Trait {\n+        rng\n+    }\n+\n+    helper(rng)\n+}\n+\n+fn main() {\n+}"}, {"sha": "f43ad7dce1d4072603699ddf85e21f3b3abbae4c", "filename": "src/test/ui/type-alias-impl-trait/unbounded_opaque_type.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Funbounded_opaque_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5193a9fcc73dc09e41a90c5a2c97fc9acc16032/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Funbounded_opaque_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Funbounded_opaque_type.rs?ref=f5193a9fcc73dc09e41a90c5a2c97fc9acc16032", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+type Opaque<T> = impl Sized;\n+fn defining<T>() -> Opaque<T> {}\n+struct Ss<'a, T>(&'a Opaque<T>);\n+\n+\n+fn test<'a, T>(_: Ss<'a, T>) {\n+    // test that we have an implied bound `Opaque<T>: 'a` from fn signature\n+    None::<&'a Opaque<T>>;\n+}\n+\n+fn main() {}"}]}