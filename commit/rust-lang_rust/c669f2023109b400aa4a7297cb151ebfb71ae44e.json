{"sha": "c669f2023109b400aa4a7297cb151ebfb71ae44e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NjlmMjAyMzEwOWI0MDBhYTRhNzI5N2NiMTUxZWJmYjcxYWU0NGU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-23T22:43:18Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-23T22:44:17Z"}, "message": "rustc: Write out crate metadata", "tree": {"sha": "3606f0720f12c35f68c9957c13a3b78c6dd6ef5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3606f0720f12c35f68c9957c13a3b78c6dd6ef5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c669f2023109b400aa4a7297cb151ebfb71ae44e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c669f2023109b400aa4a7297cb151ebfb71ae44e", "html_url": "https://github.com/rust-lang/rust/commit/c669f2023109b400aa4a7297cb151ebfb71ae44e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c669f2023109b400aa4a7297cb151ebfb71ae44e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a42d5ae62771cbcdc4589ea9a019d8dbecb0ae7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a42d5ae62771cbcdc4589ea9a019d8dbecb0ae7", "html_url": "https://github.com/rust-lang/rust/commit/0a42d5ae62771cbcdc4589ea9a019d8dbecb0ae7"}], "stats": {"total": 299, "additions": 293, "deletions": 6}, "files": [{"sha": "ce33658f44c3e74cdd9ed258547f0b7e16b5f280", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 282, "deletions": 5, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/c669f2023109b400aa4a7297cb151ebfb71ae44e/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c669f2023109b400aa4a7297cb151ebfb71ae44e/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=c669f2023109b400aa4a7297cb151ebfb71ae44e", "patch": "@@ -1,8 +1,11 @@\n import std._str;\n import std._vec;\n+import std.ebml;\n+import std.io;\n import std.option;\n \n import front.ast;\n+import middle.fold;\n import middle.trans;\n import middle.ty;\n import back.x86;\n@@ -12,6 +15,22 @@ import lib.llvm.llvm;\n import lib.llvm.llvm.ValueRef;\n import lib.llvm.False;\n \n+const uint tag_paths = 0x01u;\n+const uint tag_items = 0x02u;\n+\n+const uint tag_paths_name = 0x03u;\n+const uint tag_paths_item = 0x04u;\n+const uint tag_paths_mod = 0x05u;\n+\n+const uint tag_items_item = 0x06u;\n+const uint tag_items_def_id = 0x07u;\n+const uint tag_items_kind = 0x08u;\n+const uint tag_items_ty_param = 0x09u;\n+const uint tag_items_type = 0x0au;\n+const uint tag_items_symbol = 0x0bu;\n+const uint tag_items_variant = 0x0cu;\n+const uint tag_items_tag_id = 0x0du;\n+\n // Type encoding\n \n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n@@ -102,7 +121,8 @@ fn sty_str(ty.sty st, def_str ds) -> str {\n         }\n         case (ty.ty_var(?id)) {ret \"X\" + common.istr(id);}\n         case (ty.ty_native) {ret \"E\";}\n-        // TODO (maybe?)   ty_param(ast.def_id), ty_type;\n+        case (ty.ty_param(?def)) {ret \"p\" + ds(def);}\n+        // TODO (maybe?)   ty_type;\n     }\n }\n \n@@ -128,13 +148,270 @@ fn C_postr(str s) -> ValueRef {\n     ret llvm.LLVMConstString(_str.buf(s), _str.byte_len(s), False);\n }\n \n-fn collect_meta_directives(@trans.crate_ctxt cx, @ast.crate crate)\n-        -> ValueRef {\n-    ret C_postr(\"Hello world!\");    // TODO\n+\n+// Path table encoding\n+\n+fn encode_name(&ebml.writer ebml_w, str name) {\n+    ebml.start_tag(ebml_w, tag_paths_name);\n+    ebml_w.writer.write(_str.bytes(name));\n+    ebml.end_tag(ebml_w);\n+}\n+\n+fn encode_def_id(&ebml.writer ebml_w, &ast.def_id id) {\n+    ebml.start_tag(ebml_w, tag_items_def_id);\n+    ebml_w.writer.write(_str.bytes(def_to_str(id)));\n+    ebml.end_tag(ebml_w);\n+}\n+\n+fn encode_tag_variant_paths(&ebml.writer ebml_w, vec[ast.variant] variants) {\n+    for (ast.variant variant in variants) {\n+        ebml.start_tag(ebml_w, tag_paths_item);\n+        encode_name(ebml_w, variant.name);\n+        encode_def_id(ebml_w, variant.id);\n+        ebml.end_tag(ebml_w);\n+    }\n+}\n+\n+fn encode_native_module_item_paths(&ebml.writer ebml_w,\n+                                   &ast.native_mod nmod) {\n+    for (@ast.native_item nitem in nmod.items) {\n+        alt (nitem.node) {\n+            case (ast.native_item_ty(?id, ?did)) {\n+                ebml.start_tag(ebml_w, tag_paths_item);\n+                encode_name(ebml_w, id);\n+                encode_def_id(ebml_w, did);\n+                ebml.end_tag(ebml_w);\n+            }\n+            case (ast.native_item_fn(?id, _, _, _, ?did, _)) {\n+                ebml.start_tag(ebml_w, tag_paths_item);\n+                encode_name(ebml_w, id);\n+                encode_def_id(ebml_w, did);\n+                ebml.end_tag(ebml_w);\n+            }\n+        }\n+    }\n+}\n+\n+fn encode_module_item_paths(&ebml.writer ebml_w, &ast._mod module) {\n+    // TODO: only encode exported items\n+    for (@ast.item it in module.items) {\n+        alt (it.node) {\n+            case (ast.item_const(?id, _, ?tps, ?did, ?ann)) {\n+                ebml.start_tag(ebml_w, tag_paths_item);\n+                encode_name(ebml_w, id);\n+                encode_def_id(ebml_w, did);\n+                ebml.end_tag(ebml_w);\n+            }\n+            case (ast.item_fn(?id, _, ?tps, ?did, ?ann)) {\n+                ebml.start_tag(ebml_w, tag_paths_item);\n+                encode_name(ebml_w, id);\n+                encode_def_id(ebml_w, did);\n+                ebml.end_tag(ebml_w);\n+            }\n+            case (ast.item_mod(?id, ?_mod, _)) {\n+                ebml.start_tag(ebml_w, tag_paths_mod);\n+                encode_name(ebml_w, id);\n+                encode_module_item_paths(ebml_w, _mod);\n+                ebml.end_tag(ebml_w);\n+            }\n+            case (ast.item_native_mod(?id, ?nmod, _)) {\n+                ebml.start_tag(ebml_w, tag_paths_mod);\n+                encode_name(ebml_w, id);\n+                encode_native_module_item_paths(ebml_w, nmod);\n+                ebml.end_tag(ebml_w);\n+            }\n+            case (ast.item_ty(?id, _, ?tps, ?did, ?ann)) {\n+                ebml.start_tag(ebml_w, tag_paths_item);\n+                encode_name(ebml_w, id);\n+                encode_def_id(ebml_w, did);\n+                ebml.end_tag(ebml_w);\n+            }\n+            case (ast.item_tag(?id, ?variants, ?tps, ?did)) {\n+                ebml.start_tag(ebml_w, tag_paths_item);\n+                encode_name(ebml_w, id);\n+                encode_tag_variant_paths(ebml_w, variants);\n+                encode_def_id(ebml_w, did);\n+                ebml.end_tag(ebml_w);\n+            }\n+            case (ast.item_obj(?id, _, ?tps, ?did, ?ann)) {\n+                ebml.start_tag(ebml_w, tag_paths_item);\n+                encode_name(ebml_w, id);\n+                encode_def_id(ebml_w, did);\n+                ebml.end_tag(ebml_w);\n+            }\n+        }\n+    }\n+}\n+\n+fn encode_item_paths(&ebml.writer ebml_w, @ast.crate crate) {\n+    ebml.start_tag(ebml_w, tag_paths);\n+    encode_module_item_paths(ebml_w, crate.node.module);\n+    ebml.end_tag(ebml_w);\n+}\n+\n+\n+// Item info table encoding\n+\n+fn encode_kind(&ebml.writer ebml_w, u8 c) {\n+    ebml.start_tag(ebml_w, tag_items_kind);\n+    ebml_w.writer.write(vec(c));\n+    ebml.end_tag(ebml_w);\n+}\n+\n+fn def_to_str(ast.def_id did) -> str {\n+    ret #fmt(\"%d:%d\", did._0, did._1);\n+}\n+\n+// TODO: We need to encode the \"crate numbers\" somewhere for diamond imports.\n+fn encode_type_params(&ebml.writer ebml_w, vec[ast.ty_param] tps) {\n+    for (ast.ty_param tp in tps) {\n+        ebml.start_tag(ebml_w, tag_items_ty_param);\n+        ebml_w.writer.write(_str.bytes(def_to_str(tp.id)));\n+        ebml.end_tag(ebml_w);\n+    }\n+}\n+\n+fn encode_type(&ebml.writer ebml_w, @ty.t typ) {\n+    ebml.start_tag(ebml_w, tag_items_type);\n+    auto f = def_to_str;\n+    ebml_w.writer.write(_str.bytes(ty_str(typ, f)));\n+    ebml.end_tag(ebml_w);\n+}\n+\n+fn encode_symbol(@trans.crate_ctxt cx, &ebml.writer ebml_w, ast.def_id did) {\n+    ebml.start_tag(ebml_w, tag_items_symbol);\n+    ebml_w.writer.write(_str.bytes(cx.item_symbols.get(did)));\n+    ebml.end_tag(ebml_w);\n+}\n+\n+fn encode_discriminant(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n+                       ast.def_id did) {\n+    ebml.start_tag(ebml_w, tag_items_symbol);\n+    ebml_w.writer.write(_str.bytes(cx.discrim_symbols.get(did)));\n+    ebml.end_tag(ebml_w);\n+}\n+\n+fn encode_tag_id(&ebml.writer ebml_w, &ast.def_id id) {\n+    ebml.start_tag(ebml_w, tag_items_tag_id);\n+    ebml_w.writer.write(_str.bytes(def_to_str(id)));\n+    ebml.end_tag(ebml_w);\n+}\n+\n+\n+fn encode_tag_variant_info(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n+                           ast.def_id did, vec[ast.variant] variants) {\n+    for (ast.variant variant in variants) {\n+        ebml.start_tag(ebml_w, tag_items_variant);\n+        encode_def_id(ebml_w, variant.id);\n+        encode_tag_id(ebml_w, did);\n+        encode_type(ebml_w, trans.node_ann_type(cx, variant.ann));\n+        if (_vec.len[ast.variant_arg](variant.args) > 0u) {\n+            encode_symbol(cx, ebml_w, variant.id);\n+        }\n+        encode_discriminant(cx, ebml_w, variant.id);\n+        ebml.end_tag(ebml_w);\n+    }\n+}\n+\n+fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n+                        @ast.item item) {\n+    alt (item.node) {\n+        case (ast.item_const(_, _, _, ?did, ?ann)) {\n+            ebml.start_tag(ebml_w, tag_items_item);\n+            encode_def_id(ebml_w, did);\n+            encode_kind(ebml_w, 'c' as u8);\n+            encode_type(ebml_w, trans.node_ann_type(cx, ann));\n+            encode_symbol(cx, ebml_w, did);\n+            ebml.end_tag(ebml_w);\n+        }\n+        case (ast.item_fn(_, _, ?tps, ?did, ?ann)) {\n+            ebml.start_tag(ebml_w, tag_items_item);\n+            encode_def_id(ebml_w, did);\n+            encode_kind(ebml_w, 'f' as u8);\n+            encode_type_params(ebml_w, tps);\n+            encode_type(ebml_w, trans.node_ann_type(cx, ann));\n+            encode_symbol(cx, ebml_w, did);\n+            ebml.end_tag(ebml_w);\n+        }\n+        case (ast.item_mod(_, _, _)) {\n+            // nothing to do\n+        }\n+        case (ast.item_native_mod(_, _, _)) {\n+            // nothing to do\n+        }\n+        case (ast.item_ty(?id, _, ?tps, ?did, ?ann)) {\n+            ebml.start_tag(ebml_w, tag_items_item);\n+            encode_def_id(ebml_w, did);\n+            encode_kind(ebml_w, 'y' as u8);\n+            encode_type_params(ebml_w, tps);\n+            encode_type(ebml_w, trans.node_ann_type(cx, ann));\n+            ebml.end_tag(ebml_w);\n+        }\n+        case (ast.item_tag(?id, ?variants, ?tps, ?did)) {\n+            ebml.start_tag(ebml_w, tag_items_item);\n+            encode_def_id(ebml_w, did);\n+            encode_kind(ebml_w, 't' as u8);\n+            encode_type_params(ebml_w, tps);\n+            ebml.end_tag(ebml_w);\n+\n+            encode_tag_variant_info(cx, ebml_w, did, variants);\n+        }\n+        case (ast.item_obj(?id, _, ?tps, ?did, ?ann)) {\n+            ebml.start_tag(ebml_w, tag_items_item);\n+            encode_def_id(ebml_w, did);\n+            encode_kind(ebml_w, 'o' as u8);\n+            encode_type_params(ebml_w, tps);\n+            encode_type(ebml_w, trans.node_ann_type(cx, ann));\n+            encode_symbol(cx, ebml_w, did);\n+            ebml.end_tag(ebml_w);\n+        }\n+    }\n+}\n+\n+fn encode_info_for_native_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n+                               @ast.native_item nitem) {\n+    ebml.start_tag(ebml_w, tag_items_item);\n+    alt (nitem.node) {\n+        case (ast.native_item_ty(_, ?did)) {\n+            encode_def_id(ebml_w, did);\n+            encode_kind(ebml_w, 'T' as u8);\n+        }\n+        case (ast.native_item_fn(_, _, _, ?tps, ?did, ?ann)) {\n+            encode_def_id(ebml_w, did);\n+            encode_kind(ebml_w, 'F' as u8);\n+            encode_type_params(ebml_w, tps);\n+            encode_type(ebml_w, trans.node_ann_type(cx, ann));\n+        }\n+    }\n+    ebml.end_tag(ebml_w);\n+}\n+\n+fn encode_info_for_items(@trans.crate_ctxt cx, &ebml.writer ebml_w) {\n+    ebml.start_tag(ebml_w, tag_items);\n+    for each (@tup(ast.def_id, @ast.item) kvp in cx.items.items()) {\n+        encode_info_for_item(cx, ebml_w, kvp._1);\n+    }\n+    for each (@tup(ast.def_id, @ast.native_item) kvp in\n+            cx.native_items.items()) {\n+        encode_info_for_native_item(cx, ebml_w, kvp._1);\n+    }\n+    ebml.end_tag(ebml_w);\n+}\n+\n+\n+fn encode_metadata(@trans.crate_ctxt cx, @ast.crate crate) -> ValueRef {\n+    auto string_w = io.string_writer();\n+    auto buf_w = string_w.get_writer().get_buf_writer();\n+    auto ebml_w = ebml.create_writer(buf_w);\n+\n+    encode_item_paths(ebml_w, crate);\n+    encode_info_for_items(cx, ebml_w);\n+\n+    ret C_postr(string_w.get_str());\n }\n \n fn write_metadata(@trans.crate_ctxt cx, @ast.crate crate) {\n-    auto llmeta = collect_meta_directives(cx, crate);\n+    auto llmeta = encode_metadata(cx, crate);\n \n     auto llconst = trans.C_struct(vec(llmeta));\n     auto llglobal = llvm.LLVMAddGlobal(cx.llmod, trans.val_ty(llconst),"}, {"sha": "945394239f1fb83c08b15b21087de165e3fe7b7f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c669f2023109b400aa4a7297cb151ebfb71ae44e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c669f2023109b400aa4a7297cb151ebfb71ae44e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c669f2023109b400aa4a7297cb151ebfb71ae44e", "patch": "@@ -76,9 +76,11 @@ state type crate_ctxt = rec(session.session sess,\n                             hashmap[ast.def_id, @ast.item] items,\n                             hashmap[ast.def_id,\n                                     @ast.native_item] native_items,\n+                            hashmap[ast.def_id, str] item_symbols,\n                             // TODO: hashmap[tup(tag_id,subtys), @tag_info]\n                             hashmap[@ty.t, uint] tag_sizes,\n                             hashmap[ast.def_id, ValueRef] discrims,\n+                            hashmap[ast.def_id, str] discrim_symbols,\n                             hashmap[ast.def_id, ValueRef] fn_pairs,\n                             hashmap[ast.def_id, ValueRef] consts,\n                             hashmap[ast.def_id,()] obj_methods,\n@@ -5332,6 +5334,7 @@ fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n         let str s = cx.names.next(\"_rust_method\") + sep() + mcx.path;\n         let ValueRef llfn = decl_fastcall_fn(cx.llmod, s, llfnty);\n         cx.item_ids.insert(m.node.id, llfn);\n+        cx.item_symbols.insert(m.node.id, s);\n \n         trans_fn(mcx, m.node.meth, m.node.id, some[TypeRef](self_ty),\n                  ty_params, m.node.ann);\n@@ -5663,6 +5666,7 @@ fn register_fn_pair(@crate_ctxt cx, str ps, TypeRef llpairty, ValueRef llfn,\n                         as llvm.Linkage);\n \n     cx.item_ids.insert(id, llfn);\n+    cx.item_symbols.insert(id, ps);\n     cx.fn_pairs.insert(id, gvar);\n }\n \n@@ -5884,8 +5888,9 @@ fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n                 auto discrim_val = C_int(i as int);\n \n                 // FIXME: better name.\n+                auto s = cx.names.next(\"_rust_tag_discrim\");\n                 auto discrim_gvar = llvm.LLVMAddGlobal(cx.llmod, T_int(),\n-                    _str.buf(\"tag_discrim\"));\n+                                                       _str.buf(s));\n \n                 // FIXME: Eventually we do want to export these, but we need\n                 // to figure out what name they get first!\n@@ -5895,6 +5900,7 @@ fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n                                     as llvm.Linkage);\n \n                 cx.discrims.insert(variant.id, discrim_gvar);\n+                cx.discrim_symbols.insert(variant.id, s);\n \n                 i += 1u;\n             }\n@@ -5905,6 +5911,8 @@ fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n             // with consts.\n             auto v = C_int(1);\n             cx.item_ids.insert(cid, v);\n+            auto s = cx.names.next(\"_rust_const\") + sep() + name;\n+            cx.item_symbols.insert(cid, s);\n         }\n \n         case (_) {\n@@ -6485,8 +6493,10 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n                    item_ids = new_def_hash[ValueRef](),\n                    items = new_def_hash[@ast.item](),\n                    native_items = new_def_hash[@ast.native_item](),\n+                   item_symbols = new_def_hash[str](),\n                    tag_sizes = tag_sizes,\n                    discrims = new_def_hash[ValueRef](),\n+                   discrim_symbols = new_def_hash[str](),\n                    fn_pairs = new_def_hash[ValueRef](),\n                    consts = new_def_hash[ValueRef](),\n                    obj_methods = new_def_hash[()](),"}]}