{"sha": "2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMWRlYzc4ZTdmZDJmYTBhNTY5Zjc5N2QxNDdkNTk0MGU4MWYzZDA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-31T16:45:37Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-01T14:32:38Z"}, "message": "Move mutability checking into its own pass.\n\nHaving it in the alias pass was slightly more efficient (finding\nexpression roots has to be done in both passes), but further muddled\nup the already complex alias checker.\n\nAlso factors out some duplication in the mutability-checking code.", "tree": {"sha": "fe35c14dcd9c29ed3bee30fe2c11453eacd0e36f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe35c14dcd9c29ed3bee30fe2c11453eacd0e36f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "html_url": "https://github.com/rust-lang/rust/commit/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34ae491ca9f7ad7549fa0d767f7452055df875d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/34ae491ca9f7ad7549fa0d767f7452055df875d8", "html_url": "https://github.com/rust-lang/rust/commit/34ae491ca9f7ad7549fa0d767f7452055df875d8"}], "stats": {"total": 582, "additions": 292, "deletions": 290}, "files": [{"sha": "c281fc6a9b66f5785c6f44e5703a29550e837886", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "patch": "@@ -165,8 +165,10 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: &istr,\n         time(time_passes, ~\"typestate checking\",\n              bind middle::tstate::ck::check_crate(ty_cx, crate));\n     }\n-    let mut_map = time(time_passes, ~\"alias checking\",\n-                       bind middle::alias::check_crate(ty_cx, crate));\n+    let mut_map = time(time_passes, ~\"mutability checking\",\n+                       bind middle::mut::check_crate(ty_cx, crate));\n+    time(time_passes, ~\"alias checking\",\n+         bind middle::alias::check_crate(ty_cx, crate));\n     time(time_passes, ~\"kind checking\",\n          bind kind::check_crate(ty_cx, crate));\n     if sess.get_opts().no_trans { ret; }"}, {"sha": "dd30cb8839c9693d6202154b659740b175165d16", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 16, "deletions": 275, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "patch": "@@ -5,6 +5,7 @@ import ast::ident;\n import ast::fn_ident;\n import ast::node_id;\n import ast::def_id;\n+import mut::{expr_root, mut_field, inner_mut};\n import syntax::codemap::span;\n import syntax::visit;\n import visit::vt;\n@@ -37,40 +38,30 @@ type restrict =\n type scope = @[restrict];\n \n tag local_info {\n-    arg(ast::mode);\n-    objfield(ast::mutability);\n     local(uint);\n }\n \n-type mut_map = std::map::hashmap<node_id, ()>;\n type ctx = {tcx: ty::ctxt,\n             local_map: std::map::hashmap<node_id, local_info>,\n-            mutable next_local: uint,\n-            mut_map: mut_map};\n+            mutable next_local: uint};\n \n-fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) -> mut_map {\n+fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) {\n     // Stores information about object fields and function\n     // arguments that's otherwise not easily available.\n     let cx = @{tcx: tcx,\n                local_map: std::map::new_int_hash(),\n-               mutable next_local: 0u,\n-               mut_map: std::map::new_int_hash()};\n+               mutable next_local: 0u};\n     let v = @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _),\n-              visit_item: bind visit_item(cx, _, _, _),\n               visit_expr: bind visit_expr(cx, _, _, _),\n               visit_decl: bind visit_decl(cx, _, _, _)\n               with *visit::default_visitor::<scope>()};\n     visit::visit_crate(*crate, @[], visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n-    ret cx.mut_map;\n }\n \n fn visit_fn(cx: &@ctx, f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span,\n             _name: &fn_ident, id: ast::node_id, sc: &scope, v: &vt<scope>) {\n     visit::visit_fn_decl(f.decl, sc, v);\n-    for arg_: ast::arg in f.decl.inputs {\n-        cx.local_map.insert(arg_.id, arg(arg_.mode));\n-    }\n     let scope =\n         alt f.proto {\n \n@@ -104,34 +95,18 @@ fn visit_fn(cx: &@ctx, f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span,\n     v.visit_block(f.body, scope, v);\n }\n \n-fn visit_item(cx: &@ctx, i: &@ast::item, sc: &scope, v: &vt<scope>) {\n-    alt i.node {\n-      ast::item_obj(o, _, _) {\n-        for f: ast::obj_field in o.fields {\n-            cx.local_map.insert(f.id, objfield(f.mut));\n-        }\n-      }\n-      _ { }\n-    }\n-    visit::visit_item(i, sc, v);\n-}\n-\n fn visit_expr(cx: &@ctx, ex: &@ast::expr, sc: &scope, v: &vt<scope>) {\n     let handled = true;\n     alt ex.node {\n       ast::expr_call(f, args) {\n         check_call(*cx, f, args, sc);\n         handled = false;\n       }\n-      ast::expr_be(cl) {\n-        check_tail_call(*cx, cl);\n-        visit::visit_expr(cl, sc, v);\n-      }\n       ast::expr_alt(input, arms) { check_alt(*cx, input, arms, sc, v); }\n       ast::expr_put(val) {\n         alt val {\n           some(ex) {\n-            let root = expr_root(*cx, ex, false);\n+            let root = expr_root(cx.tcx, ex, false);\n             if mut_field(root.ds) {\n                 cx.tcx.sess.span_err(ex.span,\n                                      ~\"result of put must be\" +\n@@ -157,7 +132,7 @@ fn visit_expr(cx: &@ctx, ex: &@ast::expr, sc: &scope, v: &vt<scope>) {\n       }\n       ast::expr_move(dest, src) {\n         check_assign(cx, dest, src, sc, v);\n-        check_move_rhs(cx, src, sc, v);\n+        check_lval(cx, src, sc, v);\n       }\n       ast::expr_assign(dest, src) | ast::expr_assign_op(_, dest, src) {\n         check_assign(cx, dest, src, sc, v);\n@@ -182,7 +157,7 @@ fn visit_decl(cx: &@ctx, d: &@ast::decl, sc: &scope, v: &vt<scope>) {\n             alt loc.node.init {\n               some(init) {\n                 if init.op == ast::init_move {\n-                    check_move_rhs(cx, init.expr, sc, v);\n+                    check_lval(cx, init.expr, sc, v);\n                 }\n               }\n               none. { }\n@@ -196,47 +171,22 @@ fn visit_decl(cx: &@ctx, d: &@ast::decl, sc: &scope, v: &vt<scope>) {\n \n fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n     -> [restrict] {\n-    let fty = ty::expr_ty(cx.tcx, f);\n-    let arg_ts = fty_args(cx, fty);\n+    let fty = ty::type_autoderef(cx.tcx, ty::expr_ty(cx.tcx, f));\n+    let arg_ts = ty::ty_fn_args(cx.tcx, fty);\n     let mut_roots: [{arg: uint, node: node_id}] = [];\n     let restricts = [];\n     let i = 0u;\n     for arg_t: ty::arg in arg_ts {\n         if arg_t.mode != ty::mo_val {\n             let arg = args[i];\n-            let root = expr_root(cx, arg, false);\n+            let root = expr_root(cx.tcx, arg, false);\n             if arg_t.mode == ty::mo_alias(true) {\n                 alt path_def(cx, arg) {\n                   some(def) {\n                     let dnum = ast_util::def_id_of_def(def).node;\n-                    if def_is_local(def, true) {\n-                        if is_immutable_alias(cx, sc, dnum) {\n-                            cx.tcx.sess.span_err(\n-                                arg.span,\n-                                ~\"passing an immutable alias \\\n-                                 by mutable alias\");\n-                        } else if is_immutable_objfield(cx, dnum) {\n-                            cx.tcx.sess.span_err(\n-                                arg.span,\n-                                ~\"passing an immutable object \\\n-                                 field by mutable alias\");\n-                        }\n-                        cx.mut_map.insert(dnum, ());\n-                    } else {\n-                        cx.tcx.sess.span_err(\n-                            arg.span,\n-                            ~\"passing a static item by mutable alias\");\n-                    }\n                     mut_roots += [{arg: i, node: dnum}];\n                   }\n-                  _ {\n-                    if !mut_field(root.ds) {\n-                        let m =\n-                            ~\"passing a temporary value or \\\n-                                 immutable field by mutable alias\";\n-                        cx.tcx.sess.span_err(arg.span, m);\n-                    }\n-                  }\n+                  _ {}\n                 }\n             }\n             let root_var = path_def_id(cx, root.ex);\n@@ -318,45 +268,10 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n     ret restricts;\n }\n \n-fn check_tail_call(cx: &ctx, call: &@ast::expr) {\n-    let args;\n-    let f = alt call.node { ast::expr_call(f, args_) { args = args_; f } };\n-    let i = 0u;\n-    for arg_t: ty::arg in fty_args(cx, ty::expr_ty(cx.tcx, f)) {\n-        if arg_t.mode != ty::mo_val {\n-            let mut_a = arg_t.mode == ty::mo_alias(true);\n-            let ok = true;\n-            alt args[i].node {\n-              ast::expr_path(_) {\n-                let def = cx.tcx.def_map.get(args[i].id);\n-                let dnum = ast_util::def_id_of_def(def).node;\n-                alt cx.local_map.find(dnum) {\n-                  some(arg(ast::alias(mut))) {\n-                    if mut_a && !mut {\n-                        cx.tcx.sess.span_err(args[i].span,\n-                                             ~\"passing an immutable \\\n-                                     alias by mutable alias\");\n-                    }\n-                  }\n-                  _ { ok = !def_is_local(def, false); }\n-                }\n-              }\n-              _ { ok = false; }\n-            }\n-            if !ok {\n-                cx.tcx.sess.span_err(args[i].span,\n-                                     ~\"can not pass a local value by \\\n-                                     alias to a tail call\");\n-            }\n-        }\n-        i += 1u;\n-    }\n-}\n-\n fn check_alt(cx: &ctx, input: &@ast::expr, arms: &[ast::arm], sc: &scope,\n              v: &vt<scope>) {\n     v.visit_expr(input, sc, v);\n-    let root = expr_root(cx, input, true);\n+    let root = expr_root(cx.tcx, input, true);\n     for a: ast::arm in arms {\n         let dnums = ast_util::pat_binding_ids(a.pats[0]);\n         let new_sc = sc;\n@@ -389,7 +304,7 @@ fn check_for_each(cx: &ctx, local: &@ast::local, call: &@ast::expr,\n fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n              sc: &scope, v: &vt<scope>) {\n     v.visit_expr(seq, sc, v);\n-    let root = expr_root(cx, seq, false);\n+    let root = expr_root(cx.tcx, seq, false);\n     let unsafe = inner_mut(root.ds);\n \n     // If this is a mutable vector, don't allow it to be touched.\n@@ -444,59 +359,15 @@ fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt<scope>) {\n     alt dest.node {\n       ast::expr_path(p) {\n-        let dnum = ast_util::def_id_of_def(cx.tcx.def_map.get(dest.id)).node;\n-        cx.mut_map.insert(dnum, ());\n-        if is_immutable_alias(*cx, sc, dnum) {\n-            cx.tcx.sess.span_err(dest.span, ~\"assigning to immutable alias\");\n-        } else if is_immutable_objfield(*cx, dnum) {\n-            cx.tcx.sess.span_err(dest.span,\n-                                 ~\"assigning to immutable obj field\");\n-        }\n+        let def = cx.tcx.def_map.get(dest.id);\n+        let dnum = ast_util::def_id_of_def(def).node;\n         for r: restrict in *sc {\n             if r.root_var == some(dnum) {\n                 r.ok = overwritten(dest.span, p);\n             }\n         }\n       }\n-      _ {\n-        let root = expr_root(*cx, dest, false);\n-        if vec::len(*root.ds) == 0u {\n-            cx.tcx.sess.span_err(dest.span, ~\"assignment to non-lvalue\");\n-        } else if !root.ds[0].mut {\n-            let name =\n-                alt root.ds[0].kind {\n-                  unbox. { ~\"box\" }\n-                  field. { ~\"field\" }\n-                  index. { ~\"vec content\" }\n-                };\n-            cx.tcx.sess.span_err(dest.span,\n-                                 ~\"assignment to immutable \" + name);\n-        }\n-        visit_expr(cx, dest, sc, v);\n-      }\n-    }\n-}\n-\n-fn check_move_rhs(cx: &@ctx, src: &@ast::expr, sc: &scope, v: &vt<scope>) {\n-    alt src.node {\n-      ast::expr_path(p) {\n-        alt cx.tcx.def_map.get(src.id) {\n-          ast::def_obj_field(_, _) {\n-            cx.tcx.sess.span_err(src.span,\n-                                 ~\"may not move out of an obj field\");\n-          }\n-          _ { }\n-        }\n-        check_lval(cx, src, sc, v);\n-      }\n-      _ {\n-        let root = expr_root(*cx, src, false);\n-\n-        // Not a path and no-derefs means this is a temporary.\n-        if vec::len(*root.ds) != 0u {\n-            cx.tcx.sess.span_err(src.span, ~\"moving out of a data structure\");\n-        }\n-      }\n+      _ { visit_expr(cx, dest, sc, v); }\n     }\n }\n \n@@ -506,20 +377,6 @@ fn check_assign(cx: &@ctx, dest: &@ast::expr, src: &@ast::expr, sc: &scope,\n     check_lval(cx, dest, sc, v);\n }\n \n-\n-fn is_immutable_alias(cx: &ctx, sc: &scope, dnum: node_id) -> bool {\n-    alt cx.local_map.find(dnum) {\n-      some(arg(ast::alias(false))) { ret true; }\n-      _ { }\n-    }\n-    for r: restrict in *sc { if vec::member(dnum, r.bindings) { ret true; } }\n-    ret false;\n-}\n-\n-fn is_immutable_objfield(cx: &ctx, dnum: node_id) -> bool {\n-    ret cx.local_map.find(dnum) == some(objfield(ast::imm));\n-}\n-\n fn test_scope(cx: &ctx, sc: &scope, r: &restrict, p: &ast::path) {\n     let prob = r.ok;\n     for dep: uint in r.depends_on {\n@@ -561,117 +418,6 @@ fn deps(sc: &scope, root: &option::t<node_id>) -> [uint] {\n     ret result;\n }\n \n-tag deref_t { unbox; field; index; }\n-\n-type deref = @{mut: bool, kind: deref_t, outer_t: ty::t};\n-\n-\n-// Finds the root (the thing that is dereferenced) for the given expr, and a\n-// vec of dereferences that were used on this root. Note that, in this vec,\n-// the inner derefs come in front, so foo.bar.baz becomes rec(ex=foo,\n-// ds=[field(baz),field(bar)])\n-fn expr_root(cx: &ctx, ex: @ast::expr, autoderef: bool) ->\n-   {ex: @ast::expr, ds: @[deref]} {\n-    fn maybe_auto_unbox(cx: &ctx, t: ty::t) -> {t: ty::t, ds: [deref]} {\n-        let ds = [];\n-        while true {\n-            alt ty::struct(cx.tcx, t) {\n-              ty::ty_box(mt) {\n-                ds += [@{mut: mt.mut != ast::imm, kind: unbox, outer_t: t}];\n-                t = mt.ty;\n-              }\n-              ty::ty_uniq(mt) {\n-                ds += [@{mut: false, kind: unbox, outer_t: t}];\n-              }\n-              ty::ty_res(_, inner, tps) {\n-                ds += [@{mut: false, kind: unbox, outer_t: t}];\n-                t = ty::substitute_type_params(cx.tcx, tps, inner);\n-              }\n-              ty::ty_tag(did, tps) {\n-                let variants = ty::tag_variants(cx.tcx, did);\n-                if vec::len(variants) != 1u ||\n-                       vec::len(variants[0].args) != 1u {\n-                    break;\n-                }\n-                ds += [@{mut: false, kind: unbox, outer_t: t}];\n-                t =\n-                    ty::substitute_type_params(cx.tcx, tps,\n-                                               variants[0].args[0]);\n-              }\n-              _ { break; }\n-            }\n-        }\n-        ret {t: t, ds: ds};\n-    }\n-    let ds: [deref] = [];\n-    while true {\n-        alt { ex.node } {\n-          ast::expr_field(base, ident) {\n-            let auto_unbox = maybe_auto_unbox(cx, ty::expr_ty(cx.tcx, base));\n-            let mut = false;\n-            alt ty::struct(cx.tcx, auto_unbox.t) {\n-              ty::ty_rec(fields) {\n-                for fld: ty::field in fields {\n-                    if istr::eq(ident, fld.ident) {\n-                        mut = fld.mt.mut != ast::imm;\n-                        break;\n-                    }\n-                }\n-              }\n-              ty::ty_obj(_) { }\n-            }\n-            ds += [@{mut: mut, kind: field, outer_t: auto_unbox.t}];\n-            ds += auto_unbox.ds;\n-            ex = base;\n-          }\n-          ast::expr_index(base, _) {\n-            let auto_unbox = maybe_auto_unbox(cx, ty::expr_ty(cx.tcx, base));\n-            alt ty::struct(cx.tcx, auto_unbox.t) {\n-              ty::ty_vec(mt) {\n-                ds +=\n-                    [@{mut: mt.mut != ast::imm,\n-                       kind: index,\n-                       outer_t: auto_unbox.t}];\n-              }\n-            }\n-            ds += auto_unbox.ds;\n-            ex = base;\n-          }\n-          ast::expr_unary(op, base) {\n-            if op == ast::deref {\n-                let base_t = ty::expr_ty(cx.tcx, base);\n-                let mut = false;\n-                alt ty::struct(cx.tcx, base_t) {\n-                  ty::ty_box(mt) { mut = mt.mut != ast::imm; }\n-                  ty::ty_uniq(_) { }\n-                  ty::ty_res(_, _, _) { }\n-                  ty::ty_tag(_, _) { }\n-                  ty::ty_ptr(mt) { mut = mt.mut != ast::imm; }\n-                }\n-                ds += [@{mut: mut, kind: unbox, outer_t: base_t}];\n-                ex = base;\n-            } else { break; }\n-          }\n-          _ { break; }\n-        }\n-    }\n-    if autoderef {\n-        let auto_unbox = maybe_auto_unbox(cx, ty::expr_ty(cx.tcx, ex));\n-        ds += auto_unbox.ds;\n-    }\n-    ret {ex: ex, ds: @ds};\n-}\n-\n-fn mut_field(ds: &@[deref]) -> bool {\n-    for d: deref in *ds { if d.mut { ret true; } }\n-    ret false;\n-}\n-\n-fn inner_mut(ds: &@[deref]) -> option::t<ty::t> {\n-    for d: deref in *ds { if d.mut { ret some(d.outer_t); } }\n-    ret none;\n-}\n-\n fn path_def(cx: &ctx, ex: &@ast::expr) -> option::t<ast::def> {\n     ret alt ex.node {\n           ast::expr_path(_) { some(cx.tcx.def_map.get(ex.id)) }\n@@ -749,11 +495,6 @@ fn def_is_local(d: &ast::def, objfields_count: bool) -> bool {\n     };\n }\n \n-fn fty_args(cx: &ctx, fty: ty::t) -> [ty::arg] {\n-    ret alt ty::struct(cx.tcx, ty::type_autoderef(cx.tcx, fty)) {\n-          ty::ty_fn(_, args, _, _, _) | ty::ty_native_fn(_, args, _) { args }\n-        };\n-}\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "cb7a85639ecc8a40444fc4715eb8b9bdd40647fc", "filename": "src/comp/middle/mut.rs", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "patch": "@@ -0,0 +1,258 @@\n+import std::{vec, istr, option};\n+import option::{some, none};\n+import syntax::ast::*;\n+import syntax::visit;\n+import syntax::ast_util;\n+\n+tag deref_t { unbox; field; index; }\n+\n+type deref = @{mut: bool, kind: deref_t, outer_t: ty::t};\n+\n+// Finds the root (the thing that is dereferenced) for the given expr, and a\n+// vec of dereferences that were used on this root. Note that, in this vec,\n+// the inner derefs come in front, so foo.bar[1] becomes rec(ex=foo,\n+// ds=[index,field])\n+fn expr_root(tcx: &ty::ctxt, ex: @expr, autoderef: bool)\n+    -> {ex: @expr, ds: @[deref]} {\n+    fn maybe_auto_unbox(tcx: &ty::ctxt, t: ty::t) -> {t: ty::t, ds: [deref]} {\n+        let ds = [];\n+        while true {\n+            alt ty::struct(tcx, t) {\n+              ty::ty_box(mt) {\n+                ds += [@{mut: mt.mut != imm, kind: unbox, outer_t: t}];\n+                t = mt.ty;\n+              }\n+              ty::ty_uniq(mt) {\n+                ds += [@{mut: false, kind: unbox, outer_t: t}];\n+              }\n+              ty::ty_res(_, inner, tps) {\n+                ds += [@{mut: false, kind: unbox, outer_t: t}];\n+                t = ty::substitute_type_params(tcx, tps, inner);\n+              }\n+              ty::ty_tag(did, tps) {\n+                let variants = ty::tag_variants(tcx, did);\n+                if vec::len(variants) != 1u ||\n+                   vec::len(variants[0].args) != 1u {\n+                    break;\n+                }\n+                ds += [@{mut: false, kind: unbox, outer_t: t}];\n+                t =\n+                    ty::substitute_type_params(tcx, tps,\n+                                               variants[0].args[0]);\n+              }\n+              _ { break; }\n+            }\n+        }\n+        ret {t: t, ds: ds};\n+    }\n+    let ds: [deref] = [];\n+    while true {\n+        alt { ex.node } {\n+          expr_field(base, ident) {\n+            let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n+            let mut = false;\n+            alt ty::struct(tcx, auto_unbox.t) {\n+              ty::ty_rec(fields) {\n+                for fld: ty::field in fields {\n+                    if istr::eq(ident, fld.ident) {\n+                        mut = fld.mt.mut != imm;\n+                        break;\n+                    }\n+                }\n+              }\n+              ty::ty_obj(_) { }\n+            }\n+            ds += [@{mut: mut, kind: field, outer_t: auto_unbox.t}];\n+            ds += auto_unbox.ds;\n+            ex = base;\n+          }\n+          expr_index(base, _) {\n+            let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n+            alt ty::struct(tcx, auto_unbox.t) {\n+              ty::ty_vec(mt) {\n+                ds +=\n+                    [@{mut: mt.mut != imm,\n+                       kind: index,\n+                       outer_t: auto_unbox.t}];\n+              }\n+            }\n+            ds += auto_unbox.ds;\n+            ex = base;\n+          }\n+          expr_unary(op, base) {\n+            if op == deref {\n+                let base_t = ty::expr_ty(tcx, base);\n+                let mut = false;\n+                alt ty::struct(tcx, base_t) {\n+                  ty::ty_box(mt) { mut = mt.mut != imm; }\n+                  ty::ty_uniq(_) { }\n+                  ty::ty_res(_, _, _) { }\n+                  ty::ty_tag(_, _) { }\n+                  ty::ty_ptr(mt) { mut = mt.mut != imm; }\n+                }\n+                ds += [@{mut: mut, kind: unbox, outer_t: base_t}];\n+                ex = base;\n+            } else { break; }\n+          }\n+          _ { break; }\n+        }\n+    }\n+    if autoderef {\n+        let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, ex));\n+        ds += auto_unbox.ds;\n+    }\n+    ret {ex: ex, ds: @ds};\n+}\n+\n+fn mut_field(ds: &@[deref]) -> bool {\n+    for d: deref in *ds { if d.mut { ret true; } }\n+    ret false;\n+}\n+\n+fn inner_mut(ds: &@[deref]) -> option::t<ty::t> {\n+    for d: deref in *ds { if d.mut { ret some(d.outer_t); } }\n+    ret none;\n+}\n+\n+// Actual mut-checking pass\n+\n+type mut_map = std::map::hashmap<node_id, ()>;\n+type ctx = {tcx: ty::ctxt, mut_map: mut_map};\n+\n+fn check_crate(tcx: ty::ctxt, crate: &@crate) -> mut_map {\n+    let cx = @{tcx: tcx, mut_map: std::map::new_int_hash()};\n+    let v = @{visit_expr: bind visit_expr(cx, _, _, _),\n+              visit_decl: bind visit_decl(cx, _, _, _)\n+              with *visit::default_visitor::<()>()};\n+    visit::visit_crate(*crate, (), visit::mk_vt(v));\n+    ret cx.mut_map;\n+}\n+\n+tag msg { msg_assign; msg_move_out; msg_mut_alias; }\n+\n+fn mk_err(cx: &@ctx, span: &syntax::codemap::span, msg: msg, name: &istr) {\n+    cx.tcx.sess.span_err(span, alt msg {\n+      msg_assign. { ~\"assigning to \" + name }\n+      msg_move_out. { ~\"moving out of \" + name }\n+      msg_mut_alias. { ~\"passing \" + name + ~\" by mutable alias\" }\n+    });\n+}\n+\n+fn visit_decl(cx: &@ctx, d: &@decl, e: &(), v: &visit::vt<()>) {\n+    visit::visit_decl(d, e, v);\n+    alt d.node {\n+      decl_local(locs) {\n+        for loc: @local in locs {\n+            alt loc.node.init {\n+              some(init) {\n+                if init.op == init_move {\n+                    check_move_rhs(cx, init.expr);\n+                }\n+              }\n+              none. { }\n+            }\n+        }\n+      }\n+      _ { }\n+    }\n+}\n+\n+fn visit_expr(cx: &@ctx, ex: &@expr, e: &(), v: &visit::vt<()>) {\n+    alt ex.node {\n+      expr_call(f, args) {\n+        check_call(cx, f, args);\n+      }\n+      expr_swap(lhs, rhs) {\n+        check_lval(cx, lhs, msg_assign);\n+        check_lval(cx, rhs, msg_assign);\n+      }\n+      expr_move(dest, src) {\n+        check_lval(cx, dest, msg_assign);\n+        check_move_rhs(cx, src);\n+      }\n+      expr_assign(dest, src) | expr_assign_op(_, dest, src) {\n+        check_lval(cx, dest, msg_assign);\n+      }\n+      _ {}\n+    }\n+    visit::visit_expr(ex, e, v);\n+}\n+\n+fn check_lval(cx: &@ctx, dest: &@expr, msg: msg) {\n+    alt dest.node {\n+      expr_path(p) {\n+        let def = cx.tcx.def_map.get(dest.id);\n+        alt is_immutable_def(def) {\n+          some(name) { mk_err(cx, dest.span, msg, name); }\n+          _ {}\n+        }\n+        cx.mut_map.insert(ast_util::def_id_of_def(def).node, ());\n+      }\n+      _ {\n+        let root = expr_root(cx.tcx, dest, false);\n+        if vec::len(*root.ds) == 0u {\n+            mk_err(cx, dest.span, msg, ~\"non-lvalue\");\n+        } else if !root.ds[0].mut {\n+            let name = alt root.ds[0].kind {\n+              mut::unbox. { ~\"immutable box\" }\n+              mut::field. { ~\"immutable field\" }\n+              mut::index. { ~\"immutable vec content\" }\n+            };\n+            mk_err(cx, dest.span, msg, name);\n+        }\n+      }\n+    }\n+}\n+\n+fn check_move_rhs(cx: &@ctx, src: &@expr) {\n+    alt src.node {\n+      expr_path(p) {\n+        alt cx.tcx.def_map.get(src.id) {\n+          def_obj_field(_, _) {\n+            mk_err(cx, src.span, msg_move_out, ~\"object field\");\n+          }\n+          _ { }\n+        }\n+        check_lval(cx, src, msg_move_out);\n+      }\n+      _ {\n+        let root = expr_root(cx.tcx, src, false);\n+        // Not a path and no-derefs means this is a temporary.\n+        if vec::len(*root.ds) != 0u {\n+            cx.tcx.sess.span_err(src.span, ~\"moving out of a data structure\");\n+        }\n+      }\n+    }\n+}\n+\n+fn check_call(cx: &@ctx, f: &@expr, args: &[@expr]) {\n+    let arg_ts = ty::ty_fn_args(cx.tcx, ty::type_autoderef\n+                                (cx.tcx, ty::expr_ty(cx.tcx, f)));\n+    let i = 0u;\n+    for arg_t: ty::arg in arg_ts {\n+        if arg_t.mode == ty::mo_alias(true) {\n+            check_lval(cx, args[i], msg_mut_alias);\n+        }\n+        i += 1u;\n+    }\n+}\n+\n+fn is_immutable_def(def: &def) -> option::t<istr> {\n+    ret alt def {\n+      def_fn(_, _) | def_mod(_) | def_native_mod(_) | def_const(_) |\n+      def_use(_) { some(~\"static item\") }\n+      def_obj_field(_, imm.) { some(~\"immutable object field\") }\n+      def_arg(_, alias(false)) { some(~\"immutable alias\") }\n+      def_binding(_) { some(~\"binding\") }\n+      _ { none }\n+    };\n+}\n+\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "61bddcf4b945e93942744cbe378a666c324d5b1c", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "patch": "@@ -678,7 +678,7 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n           scope_loop(local) {\n             if ns == ns_value {\n                 alt lookup_in_pat(name, local.node.pat) {\n-                  some(did) { ret some(ast::def_local(did)); }\n+                  some(did) { ret some(ast::def_binding(did)); }\n                   _ { }\n                 }\n             }"}, {"sha": "8b0cfe195019ed53adba3d4319ef208ab79107bf", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "patch": "@@ -6241,7 +6241,7 @@ fn write_abi_version(ccx: &@crate_ctxt) {\n }\n \n fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n-               output: &istr, amap: &ast_map::map, mut_map: alias::mut_map)\n+               output: &istr, amap: &ast_map::map, mut_map: mut::mut_map)\n     -> ModuleRef {\n     let llmod = istr::as_buf(~\"rust_out\", { |buf|\n         llvm::LLVMModuleCreateWithNameInContext(buf,"}, {"sha": "39a6b25f6ccc4c81ff1d1793e3021d03ed58faad", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "patch": "@@ -149,7 +149,7 @@ type crate_ctxt =\n      type_sha1s: hashmap<ty::t, istr>,\n      type_short_names: hashmap<ty::t, istr>,\n      tcx: ty::ctxt,\n-     mut_map: alias::mut_map,\n+     mut_map: mut::mut_map,\n      stats: stats,\n      upcalls: @upcall::upcalls,\n      rust_object_type: TypeRef,"}, {"sha": "fe02cac179e9b5a3396234ef34899c38e8d1b2ca", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "patch": "@@ -25,6 +25,7 @@ mod middle {\n     mod resolve;\n     mod typeck;\n     mod check_alt;\n+    mod mut;\n     mod alias;\n     mod kind;\n     mod freevars;"}, {"sha": "2bad0d1c403f581332951dce950f7391e3810fee", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "patch": "@@ -46,7 +46,7 @@ fn def_id_of_def(d: def) -> def_id {\n     }\n }\n \n-type pat_id_map = std::map::hashmap<istr, ast::node_id>;\n+type pat_id_map = std::map::hashmap<istr, node_id>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the node_id of their namesake in the first pattern.\n@@ -142,7 +142,7 @@ fn ty_mach_to_str(tm: ty_mach) -> istr {\n \n fn is_exported(i: ident, m: _mod) -> bool {\n     let nonlocal = true;\n-    for it: @ast::item in m.items {\n+    for it: @item in m.items {\n         if it.ident == i { nonlocal = false; }\n         alt it.node {\n           item_tag(variants, _) {\n@@ -155,9 +155,9 @@ fn is_exported(i: ident, m: _mod) -> bool {\n         if !nonlocal { break; }\n     }\n     let count = 0u;\n-    for vi: @ast::view_item in m.view_items {\n+    for vi: @view_item in m.view_items {\n         alt vi.node {\n-          ast::view_item_export(ids, _) {\n+          view_item_export(ids, _) {\n             for id in ids { if istr::eq(i, id) { ret true; } }\n             count += 1u;\n           }\n@@ -202,7 +202,7 @@ fn obj_field_from_anon_obj_field(f: &anon_obj_field) -> obj_field {\n \n // This is a convenience function to transfor ternary expressions to if\n // expressions so that they can be treated the same\n-fn ternary_to_if(e: &@expr) -> @ast::expr {\n+fn ternary_to_if(e: &@expr) -> @expr {\n     alt e.node {\n       expr_ternary(cond, then, els) {\n         let then_blk = block_from_expr(then);"}, {"sha": "27629596ebf98bbfddf2b984a7e7eaee3934f1c1", "filename": "src/test/compile-fail/swap-no-lval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs?ref=2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "patch": "@@ -1,3 +1,3 @@\n-// error-pattern: assignment to non-lvalue\n+// error-pattern: assigning to non-lvalue\n \n fn main() { 5 <-> 3; }"}, {"sha": "9de010eca93dc9b5116971247cd9534e47caf04e", "filename": "src/test/compile-fail/writing-through-read-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Ftest%2Fcompile-fail%2Fwriting-through-read-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Ftest%2Fcompile-fail%2Fwriting-through-read-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-through-read-alias.rs?ref=2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "patch": "@@ -1,6 +1,6 @@\n // -*- rust -*-\n \n-// error-pattern:assignment to immutable field\n+// error-pattern:assigning to immutable field\n \n type point = {x: int, y: int, z: int};\n "}, {"sha": "559e69275c7d20b05968f7b6b0c537e4d08ea942", "filename": "src/test/compile-fail/writing-to-immutable-obj.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-obj.rs?ref=2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:assigning to immutable obj field\n+// error-pattern:assigning to immutable object field\n obj objy(x: int) {\n     fn foo() { x = 5; }\n }"}, {"sha": "cdac3706c8130fc1d717dfe1d5e3779736ce6fdc", "filename": "src/test/compile-fail/writing-to-immutable-rec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-rec.rs?ref=2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "patch": "@@ -1,2 +1,2 @@\n-// error-pattern: assignment to immutable field\n+// error-pattern: assigning to immutable field\n fn main() { let r: {x: int} = {x: 1}; r.x = 6; }"}, {"sha": "8b740218815d4a3517fc0ece4bb0184f739dc89f", "filename": "src/test/compile-fail/writing-to-immutable-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs?ref=2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "patch": "@@ -1,2 +1,2 @@\n-// error-pattern:assignment to immutable vec content\n+// error-pattern:assigning to immutable vec content\n fn main() { let v: [int] = [1, 2, 3]; v[1] = 4; }"}]}