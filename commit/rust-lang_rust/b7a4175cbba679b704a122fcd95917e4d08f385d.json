{"sha": "b7a4175cbba679b704a122fcd95917e4d08f385d", "node_id": "C_kwDOAAsO6NoAKGI3YTQxNzVjYmJhNjc5YjcwNGExMjJmY2Q5NTkxN2U0ZDA4ZjM4NWQ", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-05-31T13:15:01Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-05-31T16:28:12Z"}, "message": "Implement type inference for assignee expressions", "tree": {"sha": "34802404559287f03eb9ed81e220130df1540f48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34802404559287f03eb9ed81e220130df1540f48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7a4175cbba679b704a122fcd95917e4d08f385d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmKWQhwACgkQ4laYqTBY\nYXHvNA/9GO3UlLEmWwniq4Y4nQzJ3lhpo0i0eEyJ5XGvEhWrFN7gWfqR2qzm9Vwt\n4iTOaOAxlTvgh8JdP53qGBpZS1MtJkI+crKb/+YsRFLJGceVwnVVRv13wTjMRFph\ntPTClS+NtfkW9mbSKHUNSQhOSRXdEUbLcjuB+m93TcTKutHD/tIPWqygl4so3ng5\nrRsw7thPDJ5h1hJfankfAYrA+bce/94cx968e6IyQzr8d8KU4MwhHP9SHG0ODQ4W\nu3NdxgUbEMrAr5H1hngyASGrztXCkJwkmMYy6vdoBA3AumdQElsfqXFvoQfRu+Nw\nAJ7Ww2M2xXF1gxpoJjX9827JDIuGYdn7VwtyM9pcTvK3LkKgQFV7fwCA6LWGYaKM\n8seCAGw4e/l8GDMcqoY/jobzxd8xQ2Fik5ubS8auVrwcCl2HmGQnSo2abziLgvDV\n17iELHN9J0WgnpRT7+PZN4efMbZ41kqtVE5TcpmZvCp0IBxWdToLjvEQQgt2O4oZ\nUJutxB8FL9NKbL5T7eaHpctYL+8VtYtKi0NR7T30FhZREZM7a3h1J7Pl++N/eYac\nHU+vwbU3fBYQuWsfsbsPfrscDZWIrJiSnEnQRUbgo1zmYS1EqY1v2Sx/5LBzQGTI\nhCPGvg/pVmSJw9PuTAHAN3o1/JNwByp1OXZbSSYWHuWiTueeNYI=\n=6DGj\n-----END PGP SIGNATURE-----", "payload": "tree 34802404559287f03eb9ed81e220130df1540f48\nparent 62d6b5a594c4b8fa53eec25e4b2d2fd2580a31f3\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1654002901 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1654014492 +0900\n\nImplement type inference for assignee expressions\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7a4175cbba679b704a122fcd95917e4d08f385d", "html_url": "https://github.com/rust-lang/rust/commit/b7a4175cbba679b704a122fcd95917e4d08f385d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7a4175cbba679b704a122fcd95917e4d08f385d/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62d6b5a594c4b8fa53eec25e4b2d2fd2580a31f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/62d6b5a594c4b8fa53eec25e4b2d2fd2580a31f3", "html_url": "https://github.com/rust-lang/rust/commit/62d6b5a594c4b8fa53eec25e4b2d2fd2580a31f3"}], "stats": {"total": 419, "additions": 416, "deletions": 3}, "files": [{"sha": "ecadfb6ce4eb3749b00e49efa28e5c731293233a", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7a4175cbba679b704a122fcd95917e4d08f385d/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7a4175cbba679b704a122fcd95917e4d08f385d/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=b7a4175cbba679b704a122fcd95917e4d08f385d", "patch": "@@ -137,6 +137,14 @@ trait PatLike: Into<ExprOrPatId> + Copy {\n     ) -> Ty;\n }\n \n+impl PatLike for ExprId {\n+    type BindingMode = ();\n+\n+    fn infer(this: &mut InferenceContext, id: Self, expected_ty: &Ty, _: Self::BindingMode) -> Ty {\n+        this.infer_assignee_expr(id, expected_ty)\n+    }\n+}\n+\n impl PatLike for PatId {\n     type BindingMode = BindingMode;\n "}, {"sha": "620d889bd5d1f8e1ed6c1b7a1bf3f4c838996bc2", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 91, "deletions": 2, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b7a4175cbba679b704a122fcd95917e4d08f385d/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7a4175cbba679b704a122fcd95917e4d08f385d/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=b7a4175cbba679b704a122fcd95917e4d08f385d", "patch": "@@ -593,8 +593,8 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::BinaryOp { lhs, rhs, op } => match op {\n                 Some(BinaryOp::Assignment { op: None }) => {\n-                    let lhs_ty = self.infer_expr(*lhs, &Expectation::none());\n-                    self.infer_expr_coerce(*rhs, &Expectation::has_type(lhs_ty));\n+                    let rhs_ty = self.infer_expr(*rhs, &Expectation::none());\n+                    self.infer_assignee_expr(*lhs, &rhs_ty);\n                     self.result.standard_types.unit.clone()\n                 }\n                 Some(BinaryOp::LogicOp(_)) => {\n@@ -817,6 +817,95 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n+    pub(super) fn infer_assignee_expr(&mut self, lhs: ExprId, rhs_ty: &Ty) -> Ty {\n+        let is_rest_expr = |expr| {\n+            matches!(\n+                &self.body[expr],\n+                Expr::Range { lhs: None, rhs: None, range_type: RangeOp::Exclusive },\n+            )\n+        };\n+\n+        let rhs_ty = self.resolve_ty_shallow(rhs_ty);\n+\n+        let ty = match &self.body[lhs] {\n+            Expr::Tuple { exprs } => {\n+                // We don't consider multiple ellipses. This is analogous to\n+                // `hir_def::body::lower::ExprCollector::collect_tuple_pat()`.\n+                let ellipsis = exprs.iter().position(|e| is_rest_expr(*e));\n+                let exprs: Vec<_> = exprs.iter().filter(|e| !is_rest_expr(**e)).copied().collect();\n+\n+                self.infer_tuple_pat_like(&rhs_ty, (), ellipsis, &exprs)\n+            }\n+            Expr::Call { callee, args } => {\n+                // Tuple structs\n+                let path = match &self.body[*callee] {\n+                    Expr::Path(path) => Some(path),\n+                    _ => None,\n+                };\n+\n+                // We don't consider multiple ellipses. This is analogous to\n+                // `hir_def::body::lower::ExprCollector::collect_tuple_pat()`.\n+                let ellipsis = args.iter().position(|e| is_rest_expr(*e));\n+                let args: Vec<_> = args.iter().filter(|e| !is_rest_expr(**e)).copied().collect();\n+\n+                self.infer_tuple_struct_pat_like(path, &rhs_ty, (), lhs, ellipsis, &args)\n+            }\n+            Expr::Array(Array::ElementList(elements)) => {\n+                let elem_ty = match rhs_ty.kind(Interner) {\n+                    TyKind::Array(st, _) => st.clone(),\n+                    _ => self.err_ty(),\n+                };\n+\n+                // There's no need to handle `..` as it cannot be bound.\n+                let sub_exprs = elements.iter().filter(|e| !is_rest_expr(**e));\n+\n+                for e in sub_exprs {\n+                    self.infer_assignee_expr(*e, &elem_ty);\n+                }\n+\n+                match rhs_ty.kind(Interner) {\n+                    TyKind::Array(_, _) => rhs_ty.clone(),\n+                    // Even when `rhs_ty` is not an array type, this assignee\n+                    // expression is infered to be an array (of unknown element\n+                    // type and length). This should not be just an error type,\n+                    // because we are to compute the unifiability of this type and\n+                    // `rhs_ty` in the end of this function to issue type mismatches.\n+                    _ => TyKind::Array(self.err_ty(), crate::consteval::usize_const(None))\n+                        .intern(Interner),\n+                }\n+            }\n+            Expr::RecordLit { path, fields, .. } => {\n+                let subs = fields.iter().map(|f| (f.name.clone(), f.expr));\n+\n+                self.infer_record_pat_like(path.as_deref(), &rhs_ty, (), lhs.into(), subs)\n+            }\n+            Expr::Underscore => rhs_ty.clone(),\n+            _ => {\n+                // `lhs` is a place expression, a unit struct, or an enum variant.\n+                let lhs_ty = self.infer_expr(lhs, &Expectation::none());\n+\n+                // This is the only branch where this function may coerce any type.\n+                // We are returning early to avoid the unifiability check below.\n+                let lhs_ty = self.insert_type_vars_shallow(lhs_ty);\n+                let ty = match self.coerce(None, &rhs_ty, &lhs_ty) {\n+                    Ok(ty) => ty,\n+                    Err(_) => self.err_ty(),\n+                };\n+                self.write_expr_ty(lhs, ty.clone());\n+                return ty;\n+            }\n+        };\n+\n+        let ty = self.insert_type_vars_shallow(ty);\n+        if !self.unify(&ty, &rhs_ty) {\n+            self.result\n+                .type_mismatches\n+                .insert(lhs.into(), TypeMismatch { expected: rhs_ty.clone(), actual: ty.clone() });\n+        }\n+        self.write_expr_ty(lhs, ty.clone());\n+        ty\n+    }\n+\n     fn infer_overloadable_binop(\n         &mut self,\n         lhs: ExprId,"}, {"sha": "0e512ef5ec9ec55a106bb3f569c8335ce9970adb", "filename": "crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b7a4175cbba679b704a122fcd95917e4d08f385d/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7a4175cbba679b704a122fcd95917e4d08f385d/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=b7a4175cbba679b704a122fcd95917e4d08f385d", "patch": "@@ -312,6 +312,24 @@ fn f(text: &str) {\n     );\n }\n \n+#[test]\n+fn destructuring_assign_coerce() {\n+    check_no_mismatches(\n+        r\"\n+//- minicore: deref\n+struct String;\n+impl core::ops::Deref for String { type Target = str; }\n+fn g(_text: &str) {}\n+fn f(text: &str) {\n+    let mut text = text;\n+    let tmp = String;\n+    [text, _] = [&tmp, &tmp];\n+    g(text);\n+}\n+\",\n+    );\n+}\n+\n #[test]\n fn coerce_fn_item_to_fn_ptr() {\n     check_no_mismatches("}, {"sha": "535b948371c756d26dc77abfda96fd5b68b2610f", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 299, "deletions": 1, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/b7a4175cbba679b704a122fcd95917e4d08f385d/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7a4175cbba679b704a122fcd95917e4d08f385d/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=b7a4175cbba679b704a122fcd95917e4d08f385d", "patch": "@@ -1,6 +1,6 @@\n use expect_test::expect;\n \n-use super::{check_infer, check_no_mismatches, check_types};\n+use super::{check, check_infer, check_no_mismatches, check_types};\n \n #[test]\n fn infer_box() {\n@@ -2745,3 +2745,301 @@ fn f() {\n     \"#,\n     );\n }\n+\n+#[test]\n+fn destructuring_assignment_slice() {\n+    check_types(\n+        r#\"\n+fn main() {\n+    let a;\n+      //^usize\n+    [a,] = [0usize];\n+\n+    let a;\n+      //^usize\n+    [a, ..] = [0usize; 5];\n+\n+    let a;\n+      //^usize\n+    [.., a] = [0usize; 5];\n+\n+    let a;\n+      //^usize\n+    [.., a, _] = [0usize; 5];\n+\n+    let a;\n+      //^usize\n+    [_, a, ..] = [0usize; 5];\n+\n+    let a: &mut i64 = &mut 0;\n+    [*a, ..] = [1, 2, 3];\n+\n+    let a: usize;\n+    let b;\n+      //^usize\n+    [a, _, b] = [3, 4, 5];\n+      //^usize\n+\n+    let a;\n+      //^i64\n+    let b;\n+      //^i64\n+    [[a, ..], .., [.., b]] = [[1, 2], [3i64, 4], [5, 6], [7, 8]];\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn destructuring_assignment_tuple() {\n+    check_types(\n+        r#\"\n+fn main() {\n+    let a;\n+      //^char\n+    let b;\n+      //^i64\n+    (a, b) = ('c', 0i64);\n+\n+    let a;\n+      //^char\n+    (a, ..) = ('c', 0i64);\n+\n+    let a;\n+      //^i64\n+    (.., a) = ('c', 0i64);\n+\n+    let a;\n+      //^char\n+    let b;\n+      //^i64\n+    (a, .., b) = ('c', 0i64);\n+\n+    let a;\n+      //^char\n+    let b;\n+      //^bool\n+    (a, .., b) = ('c', 0i64, true);\n+\n+    let a;\n+      //^i64\n+    let b;\n+      //^bool\n+    (_, a, .., b) = ('c', 0i64, true);\n+\n+    let a;\n+      //^i64\n+    let b;\n+      //^usize\n+    (_, a, .., b) = ('c', 0i64, true, 0usize);\n+\n+    let mut a = 1;\n+      //^^^^^i64\n+    let mut b: i64 = 0;\n+    (a, b) = (b, a);\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn destructuring_assignment_tuple_struct() {\n+    check_types(\n+        r#\"\n+struct S2(char, i64);\n+struct S3(char, i64, bool);\n+struct S4(char, i64, bool usize);\n+fn main() {\n+    let a;\n+      //^char\n+    let b;\n+      //^i64\n+    S2(a, b) = S2('c', 0i64);\n+\n+    let a;\n+      //^char\n+    let b;\n+      //^i64\n+    S2(a, .., b) = S2('c', 0i64);\n+\n+    let a;\n+      //^char\n+    let b;\n+      //^bool\n+    S3(a, .., b) = S3('c', 0i64, true);\n+\n+    let a;\n+      //^i64\n+    let b;\n+      //^bool\n+    S3(_, a, .., b) = S3('c', 0i64, true);\n+\n+    let a;\n+      //^i64\n+    let b;\n+      //^usize\n+    S4(_, a, .., b) = S4('c', 0i64, true, 0usize);\n+\n+    struct Swap(i64, i64);\n+\n+    let mut a = 1;\n+      //^^^^^i64\n+    let mut b = 0;\n+      //^^^^^i64\n+    Swap(a, b) = Swap(b, a);\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn destructuring_assignment_struct() {\n+    check_types(\n+        r#\"\n+struct S {\n+    a: usize,\n+    b: char,\n+}\n+struct T {\n+    s: S,\n+    t: i64,\n+}\n+\n+fn main() {\n+    let a;\n+      //^usize\n+    let c;\n+      //^char\n+    S { a, b: c } = S { a: 3, b: 'b' };\n+\n+    let a;\n+      //^char\n+    S { b: a, .. } = S { a: 3, b: 'b' };\n+\n+    let a;\n+      //^char\n+    S { b: a, _ } = S { a: 3, b: 'b' };\n+\n+    let a;\n+      //^usize\n+    let c;\n+      //^char\n+    let t;\n+      //^i64\n+    T { s: S { a, b: c }, t } = T { s: S { a: 3, b: 'b' }, t: 0 };\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn destructuring_assignment_nested() {\n+    check_types(\n+        r#\"\n+struct S {\n+    a: TS,\n+    b: [char; 3],\n+}\n+struct TS(usize, i64);\n+\n+fn main() {\n+    let a;\n+      //^i32\n+    let b;\n+      //^bool\n+    ([.., a], .., b, _) = ([0, 1, 2], true, 'c');\n+\n+    let a;\n+      //^i32\n+    let b;\n+      //^i32\n+    [(.., a, _), .., (b, ..)] = [(1, 2); 5];\n+\n+    let a;\n+      //^usize\n+    let b;\n+      //^char\n+    S { a: TS(a, ..), b: [_, b, ..] } = S { a: TS(0, 0), b: ['a'; 3] };\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn destructuring_assignment_unit_struct() {\n+    // taken from rustc; see https://github.com/rust-lang/rust/pull/95380\n+    check_no_mismatches(\n+        r#\"\n+struct S;\n+enum E { V, }\n+type A = E;\n+\n+fn main() {\n+    let mut a;\n+\n+    (S, a) = (S, ());\n+\n+    (E::V, a) = (E::V, ());\n+\n+    (<E>::V, a) = (E::V, ());\n+    (A::V, a) = (E::V, ());\n+}\n+\n+impl S {\n+    fn check() {\n+        let a;\n+        (Self, a) = (S, ());\n+    }\n+}\n+\n+impl E {\n+    fn check() {\n+        let a;\n+        (Self::V, a) = (E::V, ());\n+    }\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn destructuring_assignment_no_default_binding_mode() {\n+    check(\n+        r#\"\n+struct S { a: usize }\n+struct TS(usize);\n+fn main() {\n+    let x;\n+    [x,] = &[1,];\n+  //^^^^expected &[i32; 1], got [{unknown}; _]\n+\n+    // FIXME we only want the outermost error, but this matches the current\n+    // behavior of slice patterns\n+    let x;\n+    [(x,),] = &[(1,),];\n+  // ^^^^expected {unknown}, got ({unknown},)\n+  //^^^^^^^expected &[(i32,); 1], got [{unknown}; _]\n+\n+    let x;\n+    ((x,),) = &((1,),);\n+  //^^^^^^^expected &((i32,),), got (({unknown},),)\n+\n+    let x;\n+    (x,) = &(1,);\n+  //^^^^expected &(i32,), got ({unknown},)\n+\n+    let x;\n+    (S { a: x },) = &(S { a: 42 },);\n+  //^^^^^^^^^^^^^expected &(S,), got (S,)\n+\n+    let x;\n+    S { a: x } = &S { a: 42 };\n+  //^^^^^^^^^^expected &S, got S\n+\n+    let x;\n+    TS(x) = &TS(42);\n+  //^^^^^expected &TS, got TS\n+}\n+        \"#,\n+    );\n+}"}]}