{"sha": "74c74571311431924285032588e9a3b99a048a9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0Yzc0NTcxMzExNDMxOTI0Mjg1MDMyNTg4ZTlhM2I5OWEwNDhhOWI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-04-26T15:46:54Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-04-26T18:30:44Z"}, "message": "Add GetOpts module to std", "tree": {"sha": "4f7b4d8546f9aaa731669ef7969f2521356a1d63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f7b4d8546f9aaa731669ef7969f2521356a1d63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74c74571311431924285032588e9a3b99a048a9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74c74571311431924285032588e9a3b99a048a9b", "html_url": "https://github.com/rust-lang/rust/commit/74c74571311431924285032588e9a3b99a048a9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74c74571311431924285032588e9a3b99a048a9b/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0ed2e384a3b90394ca0f160e21a4948a1dbccb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0ed2e384a3b90394ca0f160e21a4948a1dbccb0", "html_url": "https://github.com/rust-lang/rust/commit/d0ed2e384a3b90394ca0f160e21a4948a1dbccb0"}], "stats": {"total": 250, "additions": 250, "deletions": 0}, "files": [{"sha": "f85ce85c136fd2222fae2a1ec1dd35a667762237", "filename": "src/lib/GetOpts.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/74c74571311431924285032588e9a3b99a048a9b/src%2Flib%2FGetOpts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c74571311431924285032588e9a3b99a048a9b/src%2Flib%2FGetOpts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FGetOpts.rs?ref=74c74571311431924285032588e9a3b99a048a9b", "patch": "@@ -0,0 +1,249 @@\n+/* Simple getopt alternative. Construct a vector of options, either by using\n+ * reqopt, optopt, and optflag or by building them from components yourself,\n+ * and pass them to getopts, along with a vector of actual arguments (not\n+ * including argv[0]). You'll either get a failure code back, or a match.\n+ * You'll have to verify whether the amount of 'free' arguments in the match\n+ * is what you expect. Use opt_* accessors (bottom of the file) to get\n+ * argument values out of the match object.\n+ */ \n+\n+import option.some;\n+import option.none;\n+\n+tag name { long(str); short(char); }\n+tag hasarg { yes; no; maybe; }\n+tag occur { req; optional; multi; }\n+\n+type opt = rec(name name, hasarg hasarg, occur occur);\n+\n+fn mkname(str nm) -> name {\n+    if (_str.char_len(nm) == 1u) { ret short(_str.char_at(nm, 0u)); }\n+    else { ret long(nm); }\n+}\n+fn reqopt(str name) -> opt {\n+    ret rec(name=mkname(name), hasarg=yes, occur=req);\n+}\n+fn optopt(str name) -> opt {\n+    ret rec(name=mkname(name), hasarg=yes, occur=optional);\n+}\n+fn optflag(str name) -> opt {\n+    ret rec(name=mkname(name), hasarg=no, occur=optional);\n+}\n+fn optmulti(str name) -> opt {\n+    ret rec(name=mkname(name), hasarg=yes, occur=multi);\n+}\n+\n+tag optval {\n+    val(str);\n+    given;\n+}\n+\n+type match = rec(vec[opt] opts, vec[mutable vec[optval]] vals, vec[str] free);\n+\n+fn is_arg(str arg) -> bool {\n+    ret _str.byte_len(arg) > 1u && arg.(0) == '-' as u8;\n+}\n+fn name_str(name nm) -> str {\n+    alt (nm) {\n+        case (short(?ch)) {ret _str.from_char(ch);}\n+        case (long(?s)) {ret s;}\n+    }\n+}\n+\n+// FIXME rustboot workaround\n+fn name_eq(name a, name b) -> bool {\n+    alt (a) {\n+        case (long(?a)) {\n+            alt (b) {\n+                case (long(?b)) { ret _str.eq(a, b); }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (_) { if (a == b) { ret true; } else {ret false; } }\n+    }\n+}\n+fn find_opt(vec[opt] opts, name nm) -> option.t[uint] {\n+    auto i = 0u;\n+    auto l = _vec.len[opt](opts);\n+    while (i < l) {\n+        if (name_eq(opts.(i).name, nm)) { ret some[uint](i); }\n+        i += 1u;\n+    }\n+    ret none[uint];\n+}\n+\n+tag fail_ {\n+    argument_missing(str);\n+    unrecognized_option(str);\n+    option_missing(str);\n+    option_duplicated(str);\n+}\n+\n+fn fail_str(fail_ f) -> str {\n+    alt (f) {\n+        case (argument_missing(?nm)) {\n+            ret \"Argument to option '\" + nm + \"' missing.\";\n+        }\n+        case (unrecognized_option(?nm)) {\n+            ret \"Unrecognized option: '\" + nm + \"'.\";\n+        }\n+        case (option_missing(?nm)) {\n+            ret \"Required option '\" + nm + \"' missing.\";\n+        }\n+        case (option_duplicated(?nm)) {\n+            ret \"Option '\" + nm + \"' given more than once.\";\n+        }\n+    }\n+}\n+\n+tag result {\n+    success(match);\n+    failure(fail_);\n+}\n+\n+fn getopts(vec[str] args, vec[opt] opts) -> result {\n+    auto n_opts = _vec.len[opt](opts);\n+    fn empty_(uint x) -> vec[optval]{ret _vec.empty[optval]();}\n+    auto f = empty_;\n+    auto vals = _vec.init_fn_mut[vec[optval]](f, n_opts);\n+    let vec[str] free = vec();\n+\n+    auto l = _vec.len[str](args);\n+    auto i = 0u;\n+    while (i < l) {\n+        auto cur = args.(i);\n+        auto curlen = _str.byte_len(cur);\n+        if (!is_arg(cur)) {\n+            _vec.push[str](free, cur);\n+        } else if (_str.eq(cur, \"--\")) {\n+            free += _vec.slice[str](args, i + 1u, l);\n+            break;\n+        } else {\n+            auto names;\n+            auto i_arg = option.none[str];\n+            if (cur.(1) == '-' as u8) {\n+                auto tail = _str.slice(cur, 2u, curlen);\n+                auto eq = _str.index(tail, '=' as u8);\n+                if (eq == -1) {\n+                    names = vec(long(tail));\n+                } else {\n+                    names = vec(long(_str.slice(tail, 0u, eq as uint)));\n+                    i_arg = option.some[str]\n+                        (_str.slice(tail, (eq as uint) + 1u, curlen - 2u));\n+                }\n+            } else {\n+                auto j = 1u;\n+                names = vec();\n+                while (j < curlen) {\n+                    auto range = _str.char_range_at(cur, j);\n+                    _vec.push[name](names, short(range._0));\n+                    j = range._1;\n+                }\n+            }\n+            auto name_pos = 0u;\n+            for (name nm in names) {\n+                name_pos += 1u;\n+                auto optid;\n+                alt (find_opt(opts, nm)) {\n+                    case (some[uint](?id)) {optid = id;}\n+                    case (none[uint]) {\n+                        ret failure(unrecognized_option(name_str(nm)));\n+                    }\n+                }\n+                alt (opts.(optid).hasarg) {\n+                    case (no) {\n+                        _vec.push[optval](vals.(optid), given);\n+                    }\n+                    case (maybe) {\n+                        if (!option.is_none[str](i_arg)) {\n+                            _vec.push[optval](vals.(optid),\n+                                              val(option.get[str](i_arg)));\n+                        } else if (name_pos < _vec.len[name](names) ||\n+                                   i + 1u == l || is_arg(args.(i + 1u))) {\n+                            _vec.push[optval](vals.(optid), given);\n+                        } else {\n+                            i += 1u;\n+                            _vec.push[optval](vals.(optid), val(args.(i)));\n+                        }\n+                    }\n+                    case (yes) {\n+                        if (!option.is_none[str](i_arg)) {\n+                            _vec.push[optval](vals.(optid),\n+                                              val(option.get[str](i_arg)));\n+                        } else if (i + 1u == l) {\n+                            ret failure(argument_missing(name_str(nm)));\n+                        } else {\n+                            i += 1u;\n+                            _vec.push[optval](vals.(optid), val(args.(i)));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        i += 1u;\n+    }\n+\n+    i = 0u;\n+    while (i < n_opts) {\n+        auto n = _vec.len[optval](vals.(i));\n+        auto occ = opts.(i).occur;\n+        if (occ == req) {if (n == 0u) {\n+            ret failure(option_missing(name_str(opts.(i).name)));\n+        }}\n+        if (occ != multi) {if (n > 1u) {\n+            ret failure(option_duplicated(name_str(opts.(i).name)));\n+        }}\n+        i += 1u;\n+    }\n+\n+    ret success(rec(opts=opts, vals=vals, free=free));\n+}\n+\n+fn opt_vals(match m, str nm) -> vec[optval] {\n+    alt (find_opt(m.opts, mkname(nm))) {\n+        case (some[uint](?id)) { ret m.vals.(id); }\n+        case (none[uint]) {\n+            log_err \"No option '\" + nm + \"' defined.\";\n+            fail;\n+        }\n+    }\n+}\n+fn opt_val(match m, str nm) -> optval {\n+    ret opt_vals(m, nm).(0);\n+}\n+fn opt_present(match m, str nm) -> bool {\n+    ret _vec.len[optval](opt_vals(m, nm)) > 0u;\n+}\n+fn opt_str(match m, str nm) -> str {\n+    alt (opt_val(m, nm)) {\n+        case (val(?s)) { ret s; }\n+        case (_) { fail; }\n+    }\n+}\n+fn opt_strs(match m, str nm) -> vec[str] {\n+    let vec[str] acc = vec();\n+    for (optval v in opt_vals(m, nm)) {\n+        alt (v) {\n+            case (val(?s)) { _vec.push[str](acc, s); }\n+            case (_) {}\n+        }\n+    }\n+    ret acc;\n+}\n+fn opt_maybe_str(match m, str nm) -> option.t[str] {\n+    auto vals = opt_vals(m, nm);\n+    if (_vec.len[optval](vals) == 0u) { ret none[str]; }\n+    alt (vals.(0)) {\n+        case (val(?s)) { ret some[str](s); }\n+        case (_) { ret none[str]; }\n+    }\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "9fc1b7b8cbfea17f8cb4969e9f8cdff0be976196", "filename": "src/lib/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74c74571311431924285032588e9a3b99a048a9b/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/74c74571311431924285032588e9a3b99a048a9b/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=74c74571311431924285032588e9a3b99a048a9b", "patch": "@@ -70,6 +70,7 @@ mod ebml;\n mod UFind;\n mod ExtFmt;\n mod Box;\n+mod GetOpts;\n \n // Local Variables:\n // mode: rust;"}]}