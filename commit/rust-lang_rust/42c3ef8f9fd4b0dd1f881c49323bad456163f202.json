{"sha": "42c3ef8f9fd4b0dd1f881c49323bad456163f202", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYzNlZjhmOWZkNGIwZGQxZjg4MWM0OTMyM2JhZDQ1NjE2M2YyMDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-22T09:15:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-22T09:15:29Z"}, "message": "Auto merge of #30417 - alexcrichton:better-detect-elf-tls, r=alexcrichton\n\nCurrently a compiler can be built with the `--disable-elf-tls` option for compatibility with OSX 10.6 which doesn't have ELF TLS. This is unfortunate, however, as a whole new compiler must be generated which can take some time. These commits add a new (feature gated) `cfg(target_thread_local)` annotation set by the compiler which indicates whether `#[thread_local]` is available for use. The compiler now interprets `MACOSX_DEPLOYMENT_TARGET` (a standard environment variable) to set this flag on OSX. With this we may want to start compiling our OSX nightlies with `MACOSX_DEPLOYMENT_TARGET` set to 10.6 which would allow the compiler out-of-the-box to generate 10.6-compatible binaries.\n\nFor now the compiler still by default targets OSX 10.7 by allowing ELF TLS by default (e.g. if `MACOSX_DEPLOYMENT_TARGET` isn't set).", "tree": {"sha": "7cccae3a631cf5706b45a3b9c6b13fdd3c6b7a08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cccae3a631cf5706b45a3b9c6b13fdd3c6b7a08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42c3ef8f9fd4b0dd1f881c49323bad456163f202", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42c3ef8f9fd4b0dd1f881c49323bad456163f202", "html_url": "https://github.com/rust-lang/rust/commit/42c3ef8f9fd4b0dd1f881c49323bad456163f202", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42c3ef8f9fd4b0dd1f881c49323bad456163f202/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5178449f1c40b8b3a69f71e4db4e745c87b2ba67", "url": "https://api.github.com/repos/rust-lang/rust/commits/5178449f1c40b8b3a69f71e4db4e745c87b2ba67", "html_url": "https://github.com/rust-lang/rust/commit/5178449f1c40b8b3a69f71e4db4e745c87b2ba67"}, {"sha": "cd74364e5ddd3e81fa27ea149194966a3a172d9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd74364e5ddd3e81fa27ea149194966a3a172d9b", "html_url": "https://github.com/rust-lang/rust/commit/cd74364e5ddd3e81fa27ea149194966a3a172d9b"}], "stats": {"total": 187, "additions": 103, "deletions": 84}, "files": [{"sha": "b275480a6fc68347113837514bdd6ee58374f7f8", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=42c3ef8f9fd4b0dd1f881c49323bad456163f202", "patch": "@@ -660,6 +660,9 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n         \"windows\" | \"unix\" => ret.push(attr::mk_word_item(fam)),\n         _ => (),\n     }\n+    if sess.target.target.options.has_elf_tls {\n+        ret.push(attr::mk_word_item(InternedString::new(\"target_thread_local\")));\n+    }\n     if sess.opts.debug_assertions {\n         ret.push(attr::mk_word_item(InternedString::new(\"debug_assertions\")));\n     }"}, {"sha": "21bfd87e412dd5d899ed8ad226d5b0b852d3fa2c", "filename": "src/librustc_back/target/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs?ref=42c3ef8f9fd4b0dd1f881c49323bad456163f202", "patch": "@@ -11,7 +11,8 @@\n use target::Target;\n \n pub fn target() -> Target {\n-    let base = super::linux_base::opts();\n+    let mut base = super::linux_base::opts();\n+    base.has_elf_tls = false;\n     Target {\n         llvm_target: \"aarch64-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "ffcb6f971ae25ce793273f21e7a714414e777f1e", "filename": "src/librustc_back/target/apple_base.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs?ref=42c3ef8f9fd4b0dd1f881c49323bad456163f202", "patch": "@@ -8,10 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::env;\n+\n use target::TargetOptions;\n-use std::default::Default;\n \n pub fn opts() -> TargetOptions {\n+    // ELF TLS is only available in OSX 10.7+. If you try to compile for 10.6\n+    // either the linker will complain if it is used or the binary will end up\n+    // segfaulting at runtime when run on 10.6. Rust by default supports OSX\n+    // 10.7+, but there is a standard environment variable,\n+    // MACOSX_DEPLOYMENT_TARGET, which is used to signal targeting older\n+    // versions of OSX. For example compiling on 10.10 with\n+    // MACOSX_DEPLOYMENT_TARGET set to 10.6 will cause the linker to generate\n+    // warnings about the usage of ELF TLS.\n+    //\n+    // Here we detect what version is being requested, defaulting to 10.7. ELF\n+    // TLS is flagged as enabled if it looks to be supported.\n+    let deployment_target = env::var(\"MACOSX_DEPLOYMENT_TARGET\").ok();\n+    let version = deployment_target.as_ref().and_then(|s| {\n+        let mut i = s.splitn(2, \".\");\n+        i.next().and_then(|a| i.next().map(|b| (a, b)))\n+    }).and_then(|(a, b)| {\n+        a.parse::<u32>().and_then(|a| b.parse::<u32>().map(|b| (a, b))).ok()\n+    }).unwrap_or((10, 7));\n+\n     TargetOptions {\n         // OSX has -dead_strip, which doesn't rely on ffunction_sections\n         function_sections: false,\n@@ -25,6 +45,7 @@ pub fn opts() -> TargetOptions {\n         archive_format: \"bsd\".to_string(),\n         pre_link_args: Vec::new(),\n         exe_allocation_crate: super::maybe_jemalloc(),\n+        has_elf_tls: version >= (10, 7),\n         .. Default::default()\n     }\n }"}, {"sha": "d182fd9605640677322f9d1d425a6732d6bdb488", "filename": "src/librustc_back/target/apple_ios_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs?ref=42c3ef8f9fd4b0dd1f881c49323bad456163f202", "patch": "@@ -88,6 +88,7 @@ pub fn opts(arch: Arch) -> TargetOptions {\n         dynamic_linking: false,\n         executables: true,\n         pre_link_args: pre_link_args(arch),\n+        has_elf_tls: false,\n         .. super::apple_base::opts()\n     }\n }"}, {"sha": "7776aaacd00b1b8f2f2506265a79674658be9917", "filename": "src/librustc_back/target/arm_linux_androideabi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs?ref=42c3ef8f9fd4b0dd1f881c49323bad456163f202", "patch": "@@ -13,6 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::android_base::opts();\n     base.features = \"+v7\".to_string();\n+    base.has_elf_tls = false;\n \n     Target {\n         llvm_target: \"arm-linux-androideabi\".to_string(),"}, {"sha": "0efcf73ee86808ecff5243e64d199410ffc996a1", "filename": "src/librustc_back/target/linux_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs?ref=42c3ef8f9fd4b0dd1f881c49323bad456163f202", "patch": "@@ -30,6 +30,7 @@ pub fn opts() -> TargetOptions {\n         position_independent_executables: true,\n         archive_format: \"gnu\".to_string(),\n         exe_allocation_crate: super::maybe_jemalloc(),\n+        has_elf_tls: true,\n         .. Default::default()\n     }\n }"}, {"sha": "666903b4eed42a881dc1422cce04075b16d85f64", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=42c3ef8f9fd4b0dd1f881c49323bad456163f202", "patch": "@@ -195,6 +195,10 @@ pub struct TargetOptions {\n     /// Default crate for allocation symbols to link against\n     pub lib_allocation_crate: String,\n     pub exe_allocation_crate: String,\n+\n+    /// Flag indicating whether ELF TLS (e.g. #[thread_local]) is available for\n+    /// this target.\n+    pub has_elf_tls: bool,\n }\n \n impl Default for TargetOptions {\n@@ -240,6 +244,7 @@ impl Default for TargetOptions {\n             lib_allocation_crate: \"alloc_system\".to_string(),\n             exe_allocation_crate: \"alloc_system\".to_string(),\n             allow_asm: true,\n+            has_elf_tls: false,\n         }\n     }\n }"}, {"sha": "89299c01199756ca5e7c6578f1806e6ee7b5d56e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=42c3ef8f9fd4b0dd1f881c49323bad456163f202", "patch": "@@ -606,7 +606,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         feature_gated_cfgs.sort();\n         feature_gated_cfgs.dedup();\n         for cfg in &feature_gated_cfgs {\n-            cfg.check_and_emit(sess.diagnostic(), &features);\n+            cfg.check_and_emit(sess.diagnostic(), &features, sess.codemap());\n         }\n     });\n "}, {"sha": "e66cc49290adf86cc0a28bd08e0092b6bdc215bf", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=42c3ef8f9fd4b0dd1f881c49323bad456163f202", "patch": "@@ -218,6 +218,7 @@\n #![feature(borrow_state)]\n #![feature(box_syntax)]\n #![feature(cfg_target_vendor)]\n+#![feature(cfg_target_thread_local)]\n #![feature(char_internals)]\n #![feature(clone_from_slice)]\n #![feature(collections)]"}, {"sha": "ca0f10315625304313699bbf75ca67268cf68965", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 44, "deletions": 76, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=42c3ef8f9fd4b0dd1f881c49323bad456163f202", "patch": "@@ -15,10 +15,6 @@\n use cell::UnsafeCell;\n use mem;\n \n-// Sure wish we had macro hygiene, no?\n-#[doc(hidden)]\n-pub use self::imp::Key as __KeyInner;\n-\n /// A thread local storage key which owns its contents.\n ///\n /// This key uses the fastest possible implementation available to it for the\n@@ -61,78 +57,42 @@ pub use self::imp::Key as __KeyInner;\n /// });\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct LocalKey<T:'static> {\n-    // The key itself may be tagged with #[thread_local], and this `Key` is\n-    // stored as a `static`, and it's not valid for a static to reference the\n-    // address of another thread_local static. For this reason we kinda wonkily\n-    // work around this by generating a shim function which will give us the\n-    // address of the inner TLS key at runtime.\n+pub struct LocalKey<T: 'static> {\n+    // This outer `LocalKey<T>` type is what's going to be stored in statics,\n+    // but actual data inside will sometimes be tagged with #[thread_local].\n+    // It's not valid for a true static to reference a #[thread_local] static,\n+    // so we get around that by exposing an accessor through a layer of function\n+    // indirection (this thunk).\n+    //\n+    // Note that the thunk is itself unsafe because the returned lifetime of the\n+    // slot where data lives, `'static`, is not actually valid. The lifetime\n+    // here is actually `'thread`!\n     //\n-    // This is trivially devirtualizable by LLVM because we never store anything\n-    // to this field and rustc can declare the `static` as constant as well.\n-    inner: fn() -> &'static __KeyInner<T>,\n+    // Although this is an extra layer of indirection, it should in theory be\n+    // trivially devirtualizable by LLVM because the value of `inner` never\n+    // changes and the constant should be readonly within a crate. This mainly\n+    // only runs into problems when TLS statics are exported across crates.\n+    inner: unsafe fn() -> Option<&'static UnsafeCell<Option<T>>>,\n \n     // initialization routine to invoke to create a value\n     init: fn() -> T,\n }\n \n-// Macro pain #4586:\n-//\n-// When cross compiling, rustc will load plugins and macros from the *host*\n-// platform before search for macros from the target platform. This is primarily\n-// done to detect, for example, plugins. Ideally the macro below would be\n-// defined once per module below, but unfortunately this means we have the\n-// following situation:\n-//\n-// 1. We compile libstd for x86_64-unknown-linux-gnu, this thread_local!() macro\n-//    will inject #[thread_local] statics.\n-// 2. We then try to compile a program for arm-linux-androideabi\n-// 3. The compiler has a host of linux and a target of android, so it loads\n-//    macros from the *linux* libstd.\n-// 4. The macro generates a #[thread_local] field, but the android libstd does\n-//    not use #[thread_local]\n-// 5. Compile error about structs with wrong fields.\n-//\n-// To get around this, we're forced to inject the #[cfg] logic into the macro\n-// itself. Woohoo.\n-\n /// Declare a new thread local storage key of type `std::thread::LocalKey`.\n ///\n /// See [LocalKey documentation](thread/struct.LocalKey.html) for more\n /// information.\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable]\n-#[cfg(not(no_elf_tls))]\n-macro_rules! thread_local {\n-    (static $name:ident: $t:ty = $init:expr) => (\n-        static $name: $crate::thread::LocalKey<$t> =\n-            __thread_local_inner!($t, $init,\n-                #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n-                               not(target_arch = \"aarch64\")),\n-                           thread_local)]);\n-    );\n-    (pub static $name:ident: $t:ty = $init:expr) => (\n-        pub static $name: $crate::thread::LocalKey<$t> =\n-            __thread_local_inner!($t, $init,\n-                #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n-                               not(target_arch = \"aarch64\")),\n-                           thread_local)]);\n-    );\n-}\n-\n-#[macro_export]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n-#[cfg(no_elf_tls)]\n macro_rules! thread_local {\n     (static $name:ident: $t:ty = $init:expr) => (\n         static $name: $crate::thread::LocalKey<$t> =\n-            __thread_local_inner!($t, $init, #[]);\n+            __thread_local_inner!($t, $init);\n     );\n     (pub static $name:ident: $t:ty = $init:expr) => (\n         pub static $name: $crate::thread::LocalKey<$t> =\n-            __thread_local_inner!($t, $init, #[]);\n+            __thread_local_inner!($t, $init);\n     );\n }\n \n@@ -143,12 +103,25 @@ macro_rules! thread_local {\n #[macro_export]\n #[allow_internal_unstable]\n macro_rules! __thread_local_inner {\n-    ($t:ty, $init:expr, #[$($attr:meta),*]) => {{\n-        $(#[$attr])*\n-        static __KEY: $crate::thread::__LocalKeyInner<$t> =\n-            $crate::thread::__LocalKeyInner::new();\n+    ($t:ty, $init:expr) => {{\n         fn __init() -> $t { $init }\n-        fn __getit() -> &'static $crate::thread::__LocalKeyInner<$t> { &__KEY }\n+\n+        unsafe fn __getit() -> $crate::option::Option<\n+            &'static $crate::cell::UnsafeCell<\n+                $crate::option::Option<$t>>>\n+        {\n+            #[thread_local]\n+            #[cfg(target_thread_local)]\n+            static __KEY: $crate::thread::__ElfLocalKeyInner<$t> =\n+                $crate::thread::__ElfLocalKeyInner::new();\n+\n+            #[cfg(not(target_thread_local))]\n+            static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n+                $crate::thread::__OsLocalKeyInner::new();\n+\n+            __KEY.get()\n+        }\n+\n         $crate::thread::LocalKey::new(__getit, __init)\n     }}\n }\n@@ -190,11 +163,11 @@ impl<T: 'static> LocalKey<T> {\n     #[unstable(feature = \"thread_local_internals\",\n                reason = \"recently added to create a key\",\n                issue = \"0\")]\n-    pub const fn new(inner: fn() -> &'static __KeyInner<T>,\n+    pub const fn new(inner: unsafe fn() -> Option<&'static UnsafeCell<Option<T>>>,\n                      init: fn() -> T) -> LocalKey<T> {\n         LocalKey {\n             inner: inner,\n-            init: init\n+            init: init,\n         }\n     }\n \n@@ -211,10 +184,10 @@ impl<T: 'static> LocalKey<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with<F, R>(&'static self, f: F) -> R\n                       where F: FnOnce(&T) -> R {\n-        let slot = (self.inner)();\n         unsafe {\n-            let slot = slot.get().expect(\"cannot access a TLS value during or \\\n-                                          after it is destroyed\");\n+            let slot = (self.inner)();\n+            let slot = slot.expect(\"cannot access a TLS value during or \\\n+                                    after it is destroyed\");\n             f(match *slot.get() {\n                 Some(ref inner) => inner,\n                 None => self.init(slot),\n@@ -270,7 +243,7 @@ impl<T: 'static> LocalKey<T> {\n                issue = \"27716\")]\n     pub fn state(&'static self) -> LocalKeyState {\n         unsafe {\n-            match (self.inner)().get() {\n+            match (self.inner)() {\n                 Some(cell) => {\n                     match *cell.get() {\n                         Some(..) => LocalKeyState::Valid,\n@@ -283,11 +256,9 @@ impl<T: 'static> LocalKey<T> {\n     }\n }\n \n-#[cfg(all(any(target_os = \"macos\", target_os = \"linux\"),\n-          not(target_arch = \"aarch64\"),\n-          not(no_elf_tls)))]\n+#[cfg(target_thread_local)]\n #[doc(hidden)]\n-mod imp {\n+pub mod elf {\n     use cell::{Cell, UnsafeCell};\n     use intrinsics;\n     use ptr;\n@@ -431,11 +402,8 @@ mod imp {\n     }\n }\n \n-#[cfg(any(not(any(target_os = \"macos\", target_os = \"linux\")),\n-          target_arch = \"aarch64\",\n-          no_elf_tls))]\n #[doc(hidden)]\n-mod imp {\n+pub mod os {\n     use prelude::v1::*;\n \n     use cell::{Cell, UnsafeCell};"}, {"sha": "0e525f394216c9bdadef5d415f8e40e54fd16a9b", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=42c3ef8f9fd4b0dd1f881c49323bad456163f202", "patch": "@@ -191,7 +191,10 @@ pub use self::local::{LocalKey, LocalKeyState};\n pub use self::scoped_tls::ScopedKey;\n \n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n-#[doc(hidden)] pub use self::local::__KeyInner as __LocalKeyInner;\n+#[cfg(target_thread_local)]\n+#[doc(hidden)] pub use self::local::elf::Key as __ElfLocalKeyInner;\n+#[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n+#[doc(hidden)] pub use self::local::os::Key as __OsLocalKeyInner;\n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n #[doc(hidden)] pub use self::scoped_tls::__KeyInner as __ScopedKeyInner;\n "}, {"sha": "4ea0fd76fea4a6c38868651b0a34eb188f4aa4ae", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c3ef8f9fd4b0dd1f881c49323bad456163f202/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=42c3ef8f9fd4b0dd1f881c49323bad456163f202", "patch": "@@ -236,6 +236,9 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n \n     // allow using type ascription in expressions\n     (\"type_ascription\", \"1.6.0\", Some(23416), Active),\n+\n+    // Allows cfg(target_thread_local)\n+    (\"cfg_target_thread_local\", \"1.7.0\", Some(29594), Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -414,6 +417,8 @@ const GATED_CFGS: &'static [(&'static str, &'static str, fn(&Features) -> bool)]\n     // (name in cfg, feature, function to check if the feature is enabled)\n     (\"target_feature\", \"cfg_target_feature\", cfg_fn!(|x| x.cfg_target_feature)),\n     (\"target_vendor\", \"cfg_target_vendor\", cfg_fn!(|x| x.cfg_target_vendor)),\n+    (\"target_thread_local\", \"cfg_target_thread_local\",\n+     cfg_fn!(|x| x.cfg_target_thread_local)),\n ];\n \n #[derive(Debug, Eq, PartialEq)]\n@@ -449,10 +454,13 @@ impl PartialOrd for GatedCfgAttr {\n }\n \n impl GatedCfgAttr {\n-    pub fn check_and_emit(&self, diagnostic: &Handler, features: &Features) {\n+    pub fn check_and_emit(&self,\n+                          diagnostic: &Handler,\n+                          features: &Features,\n+                          codemap: &CodeMap) {\n         match *self {\n             GatedCfgAttr::GatedCfg(ref cfg) => {\n-                cfg.check_and_emit(diagnostic, features);\n+                cfg.check_and_emit(diagnostic, features, codemap);\n             }\n             GatedCfgAttr::GatedAttr(span) => {\n                 if !features.stmt_expr_attributes {\n@@ -479,9 +487,12 @@ impl GatedCfg {\n                       }\n                   })\n     }\n-    fn check_and_emit(&self, diagnostic: &Handler, features: &Features) {\n+    fn check_and_emit(&self,\n+                      diagnostic: &Handler,\n+                      features: &Features,\n+                      codemap: &CodeMap) {\n         let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n-        if !has_feature(features) {\n+        if !has_feature(features) && !codemap.span_allows_unstable(self.span) {\n             let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n             emit_feature_err(diagnostic, feature, self.span, GateIssue::Language, &explain);\n         }\n@@ -541,6 +552,7 @@ pub struct Features {\n     pub type_macros: bool,\n     pub cfg_target_feature: bool,\n     pub cfg_target_vendor: bool,\n+    pub cfg_target_thread_local: bool,\n     pub augmented_assignments: bool,\n     pub braced_empty_structs: bool,\n     pub staged_api: bool,\n@@ -575,6 +587,7 @@ impl Features {\n             type_macros: false,\n             cfg_target_feature: false,\n             cfg_target_vendor: false,\n+            cfg_target_thread_local: false,\n             augmented_assignments: false,\n             braced_empty_structs: false,\n             staged_api: false,\n@@ -1157,6 +1170,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n         type_macros: cx.has_feature(\"type_macros\"),\n         cfg_target_feature: cx.has_feature(\"cfg_target_feature\"),\n         cfg_target_vendor: cx.has_feature(\"cfg_target_vendor\"),\n+        cfg_target_thread_local: cx.has_feature(\"cfg_target_thread_local\"),\n         augmented_assignments: cx.has_feature(\"augmented_assignments\"),\n         braced_empty_structs: cx.has_feature(\"braced_empty_structs\"),\n         staged_api: cx.has_feature(\"staged_api\"),"}]}