{"sha": "f466a2fa8f7594d6895bb4263a662adc7ed26326", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NjZhMmZhOGY3NTk0ZDY4OTViYjQyNjNhNjYyYWRjN2VkMjYzMjY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-14T04:38:15Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-16T19:33:21Z"}, "message": "rustc: -L also indicates the location of native libraries\n\n-L currently specifies paths to search for Rust crates\n\nBuilding crates that use native libraries is difficult. When the\nlibrary is located somewhere unexpected there is no way\nto tell rustc additional paths to look in.\n\nIf libclang is located at `.` then rustc is not going to\nknow that and linking will fail.\n\nTo get around that I often end up inserting\n\n    #[link_args = \"-L.\"] native mod m { }\n\ninto other crates to get them to build.\n\nNow you just `rustc -L .` and it builds.\n\nThis doesn't do any rpathing so it's still up to somebody else\nto put the library somewhere it will be found or use LD_LIBRARY_PATH\n\nThis feature comes with a single, XFAILed test, because I could\nnot think of a way to test it. Odd.", "tree": {"sha": "89ae6b80fa20d1fda0afa8b108969aa52f0eda51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89ae6b80fa20d1fda0afa8b108969aa52f0eda51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f466a2fa8f7594d6895bb4263a662adc7ed26326", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f466a2fa8f7594d6895bb4263a662adc7ed26326", "html_url": "https://github.com/rust-lang/rust/commit/f466a2fa8f7594d6895bb4263a662adc7ed26326", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f466a2fa8f7594d6895bb4263a662adc7ed26326/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37", "url": "https://api.github.com/repos/rust-lang/rust/commits/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37", "html_url": "https://github.com/rust-lang/rust/commit/903cb0e3a5273f68c5c27dbfbfbe2e4c6721bd37"}], "stats": {"total": 30, "additions": 30, "deletions": 0}, "files": [{"sha": "8bf6c585557b6e092da733a9899d4c224e4f95f2", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f466a2fa8f7594d6895bb4263a662adc7ed26326/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f466a2fa8f7594d6895bb4263a662adc7ed26326/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=f466a2fa8f7594d6895bb4263a662adc7ed26326", "patch": "@@ -580,6 +580,8 @@ fn link_binary(sess: session,\n         lib_cmd = \"-dynamiclib\";\n     } else { lib_cmd = \"-shared\"; }\n \n+    // # Crate linking\n+\n     let cstore = sess.cstore;\n     for cstore::get_used_crate_files(cstore).each {|cratepath|\n         if str::ends_with(cratepath, \".rlib\") {\n@@ -596,6 +598,18 @@ fn link_binary(sess: session,\n     let ula = cstore::get_used_link_args(cstore);\n     for ula.each {|arg| cc_args += [arg]; }\n \n+    // # Native library linking\n+\n+    // User-supplied library search paths (-L on the cammand line) These are\n+    // the same paths used to find Rust crates, so some of them may have been\n+    // added already by the previous crate linking code. This only allows them\n+    // to be found at compile time so it is still entirely up to outside\n+    // forces to make sure that library can be found at runtime.\n+\n+    let addl_paths = sess.opts.addl_lib_search_paths;\n+    for addl_paths.each {|path| cc_args += [\"-L\" + path]; }\n+\n+    // The names of the native libraries\n     let used_libs = cstore::get_used_libraries(cstore);\n     for used_libs.each {|l| cc_args += [\"-l\" + l]; }\n \n@@ -639,6 +653,8 @@ fn link_binary(sess: session,\n     // Stack growth requires statically linking a __morestack function\n     cc_args += [\"-lmorestack\"];\n \n+    // FIXME: At some point we want to rpath our guesses as to where\n+    // native libraries might live, based on the addl_lib_search_paths\n     cc_args += rpath::get_rpath_flags(sess, output);\n \n     #debug(\"%s link args: %s\", cc_prog, str::connect(cc_args, \" \"));"}, {"sha": "2f9d416a223001e02cac34e4880e9a7fce9efd29", "filename": "src/test/run-pass/native-lib-path.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f466a2fa8f7594d6895bb4263a662adc7ed26326/src%2Ftest%2Frun-pass%2Fnative-lib-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f466a2fa8f7594d6895bb4263a662adc7ed26326/src%2Ftest%2Frun-pass%2Fnative-lib-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-lib-path.rs?ref=f466a2fa8f7594d6895bb4263a662adc7ed26326", "patch": "@@ -0,0 +1,14 @@\n+// xfail-test FIXME I don't know how to test this\n+// compile-flags:-L.\n+// The -L flag is also used for linking native libraries\n+\n+// FIXME: I want to name a mod that would not link successfully\n+// wouthout providing a -L argument to the compiler, and that\n+// will also be found successfully at runtime.\n+native mod WHATGOESHERE {\n+    fn IDONTKNOW() -> u32;\n+}\n+\n+fn main() {\n+    assert IDONTKNOW() == 0x_BAD_DOOD_u32;\n+}\n\\ No newline at end of file"}]}