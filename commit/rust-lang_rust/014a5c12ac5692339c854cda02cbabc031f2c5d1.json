{"sha": "014a5c12ac5692339c854cda02cbabc031f2c5d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNGE1YzEyYWM1NjkyMzM5Yzg1NGNkYTAyY2JhYmMwMzFmMmM1ZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-16T22:20:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-16T22:20:15Z"}, "message": "Auto merge of #26280 - Marwes:deriving_discriminant, r=pcwalton\n\nPR for #26128.\r\n\r\nImproves codegen in deriving by utilizing the discriminant_value intrinsic.\r\n\r\nI have a more detailed comment on the changes in a comment on the issue [here](https://github.com/rust-lang/rust/issues/26128#issuecomment-111509863)\r\n\r\n### Old\r\n```\r\nrunning 7 tests\r\ntest large_c_like       ... bench:   2,694,129 ns/iter (+/- 5,170)\r\ntest large_c_like_ord   ... bench:   2,723,521 ns/iter (+/- 9,098)\r\ntest test1_partial_eq   ... bench:   2,439,317 ns/iter (+/- 2,135)\r\ntest test1_partial_ord  ... bench:   2,499,114 ns/iter (+/- 55,766)\r\ntest test2_partial_eq   ... bench:   3,562,815 ns/iter (+/- 45,590)\r\ntest test2_partial_ord  ... bench:   3,398,306 ns/iter (+/- 22,180)\r\ntest test_match_success ... bench:   1,509,267 ns/iter (+/- 1,982)\r\n```\r\n\r\n### New\r\n```\r\nrunning 7 tests\r\ntest large_c_like       ... bench:     286,509 ns/iter (+/- 474)\r\ntest large_c_like_ord   ... bench:     286,666 ns/iter (+/- 8,756)\r\ntest test1_partial_eq   ... bench:     286,584 ns/iter (+/- 2,789)\r\ntest test1_partial_ord  ... bench:     286,470 ns/iter (+/- 516)\r\ntest test2_partial_eq   ... bench:   2,228,997 ns/iter (+/- 34,191)\r\ntest test2_partial_ord  ... bench:   1,731,699 ns/iter (+/- 21,756)\r\ntest test_match_success ... bench:   1,509,630 ns/iter (+[- 3,765)\r\n```\r\n\r\n[Benchmark](https://gist.github.com/Marwes/7c0b3468d0cae972a2b4)", "tree": {"sha": "d6c03d7aab1e7b606ca7015da61b91ff2cbdc697", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6c03d7aab1e7b606ca7015da61b91ff2cbdc697"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/014a5c12ac5692339c854cda02cbabc031f2c5d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/014a5c12ac5692339c854cda02cbabc031f2c5d1", "html_url": "https://github.com/rust-lang/rust/commit/014a5c12ac5692339c854cda02cbabc031f2c5d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/014a5c12ac5692339c854cda02cbabc031f2c5d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "467e4a6681f8ac3b29fa28406ece66418e1b703d", "url": "https://api.github.com/repos/rust-lang/rust/commits/467e4a6681f8ac3b29fa28406ece66418e1b703d", "html_url": "https://github.com/rust-lang/rust/commit/467e4a6681f8ac3b29fa28406ece66418e1b703d"}, {"sha": "34d5b5450cf8728321a77f3e32393197fd66a325", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d5b5450cf8728321a77f3e32393197fd66a325", "html_url": "https://github.com/rust-lang/rust/commit/34d5b5450cf8728321a77f3e32393197fd66a325"}], "stats": {"total": 132, "additions": 90, "deletions": 42}, "files": [{"sha": "e7d242ab70364300b8a08f4b29ba1023d795d3c6", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 90, "deletions": 42, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/014a5c12ac5692339c854cda02cbabc031f2c5d1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/014a5c12ac5692339c854cda02cbabc031f2c5d1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=014a5c12ac5692339c854cda02cbabc031f2c5d1", "patch": "@@ -1042,21 +1042,31 @@ impl<'a> MethodDef<'a> {\n     /// variants where all of the variants match, and one catch-all for\n     /// when one does not match.\n \n+    /// As an optimization we generate code which checks whether all variants\n+    /// match first which makes llvm see that C-like enums can be compiled into\n+    /// a simple equality check (for PartialEq).\n+\n     /// The catch-all handler is provided access the variant index values\n-    /// for each of the self-args, carried in precomputed variables. (Nota\n-    /// bene: the variant index values are not necessarily the\n-    /// discriminant values.  See issue #15523.)\n+    /// for each of the self-args, carried in precomputed variables.\n \n     /// ```{.text}\n-    /// match (this, that, ...) {\n-    ///   (Variant1, Variant1, Variant1) => ... // delegate Matching on Variant1\n-    ///   (Variant2, Variant2, Variant2) => ... // delegate Matching on Variant2\n-    ///   ...\n-    ///   _ => {\n-    ///     let __this_vi = match this { Variant1 => 0, Variant2 => 1, ... };\n-    ///     let __that_vi = match that { Variant1 => 0, Variant2 => 1, ... };\n+    /// let __self0_vi = unsafe {\n+    ///     std::intrinsics::discriminant_value(&self) } as i32;\n+    /// let __self1_vi = unsafe {\n+    ///     std::intrinsics::discriminant_value(&__arg1) } as i32;\n+    /// let __self2_vi = unsafe {\n+    ///     std::intrinsics::discriminant_value(&__arg2) } as i32;\n+    ///\n+    /// if __self0_vi == __self1_vi && __self0_vi == __self2_vi && ... {\n+    ///     match (...) {\n+    ///         (Variant1, Variant1, ...) => Body1\n+    ///         (Variant2, Variant2, ...) => Body2,\n+    ///         ...\n+    ///         _ => ::core::intrinsics::unreachable()\n+    ///     }\n+    /// }\n+    /// else {\n     ///     ... // catch-all remainder can inspect above variant index values.\n-    ///   }\n     /// }\n     /// ```\n     fn build_enum_match_tuple<'b>(\n@@ -1187,7 +1197,6 @@ impl<'a> MethodDef<'a> {\n \n                 cx.arm(sp, vec![single_pat], arm_expr)\n             }).collect();\n-\n         // We will usually need the catch-all after matching the\n         // tuples `(VariantK, VariantK, ...)` for each VariantK of the\n         // enum.  But:\n@@ -1223,9 +1232,14 @@ impl<'a> MethodDef<'a> {\n             // ```\n             let mut index_let_stmts: Vec<P<ast::Stmt>> = Vec::new();\n \n+            //We also build an expression which checks whether all discriminants are equal\n+            // discriminant_test = __self0_vi == __self1_vi && __self0_vi == __self2_vi && ...\n+            let mut discriminant_test = cx.expr_bool(sp, true);\n+\n             let target_type_name =\n                 find_repr_type_name(&cx.parse_sess.span_diagnostic, type_attrs);\n \n+            let mut first_ident = None;\n             for (&ident, self_arg) in vi_idents.iter().zip(&self_args) {\n                 let path = vec![cx.ident_of_std(\"core\"),\n                                 cx.ident_of(\"intrinsics\"),\n@@ -1243,32 +1257,64 @@ impl<'a> MethodDef<'a> {\n                 let variant_disr = cx.expr_cast(sp, variant_value, target_ty);\n                 let let_stmt = cx.stmt_let(sp, false, ident, variant_disr);\n                 index_let_stmts.push(let_stmt);\n+\n+                match first_ident {\n+                    Some(first) => {\n+                        let first_expr = cx.expr_ident(sp, first);\n+                        let id = cx.expr_ident(sp, ident);\n+                        let test = cx.expr_binary(sp, ast::BiEq, first_expr, id);\n+                        discriminant_test = cx.expr_binary(sp, ast::BiAnd, discriminant_test, test)\n+                    }\n+                    None => {\n+                        first_ident = Some(ident);\n+                    }\n+                }\n             }\n \n             let arm_expr = self.call_substructure_method(\n                 cx, trait_, type_ident, &self_args[..], nonself_args,\n                 &catch_all_substructure);\n \n-            // Builds the expression:\n-            // {\n-            //   let __self0_vi = ...;\n-            //   let __self1_vi = ...;\n-            //   ...\n-            //   <delegated expression referring to __self0_vi, et al.>\n-            // }\n-            let arm_expr = cx.expr_block(\n-                cx.block_all(sp, index_let_stmts, Some(arm_expr)));\n-\n-            // Builds arm:\n-            // _ => { let __self0_vi = ...;\n-            //        let __self1_vi = ...;\n-            //        ...\n-            //        <delegated expression as above> }\n-            let catch_all_match_arm =\n-                cx.arm(sp, vec![cx.pat_wild(sp)], arm_expr);\n-\n-            match_arms.push(catch_all_match_arm);\n-\n+            //Since we know that all the arguments will match if we reach the match expression we\n+            //add the unreachable intrinsics as the result of the catch all which should help llvm\n+            //in optimizing it\n+            let path = vec![cx.ident_of_std(\"core\"),\n+                            cx.ident_of(\"intrinsics\"),\n+                            cx.ident_of(\"unreachable\")];\n+            let call = cx.expr_call_global(\n+                sp, path, vec![]);\n+            let unreachable = cx.expr_block(P(ast::Block {\n+                stmts: vec![],\n+                expr: Some(call),\n+                id: ast::DUMMY_NODE_ID,\n+                rules: ast::UnsafeBlock(ast::CompilerGenerated),\n+                span: sp }));\n+            match_arms.push(cx.arm(sp, vec![cx.pat_wild(sp)], unreachable));\n+\n+            // Final wrinkle: the self_args are expressions that deref\n+            // down to desired l-values, but we cannot actually deref\n+            // them when they are fed as r-values into a tuple\n+            // expression; here add a layer of borrowing, turning\n+            // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n+            let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n+            let match_arg = cx.expr(sp, ast::ExprTup(borrowed_self_args));\n+\n+            //Lastly we create an expression which branches on all discriminants being equal\n+            //  if discriminant_test {\n+            //      match (...) {\n+            //          (Variant1, Variant1, ...) => Body1\n+            //          (Variant2, Variant2, ...) => Body2,\n+            //          ...\n+            //          _ => ::core::intrinsics::unreachable()\n+            //      }\n+            //  }\n+            //  else {\n+            //      <delegated expression referring to __self0_vi, et al.>\n+            //  }\n+            let all_match = cx.expr_match(sp, match_arg, match_arms);\n+            let arm_expr = cx.expr_if(sp, discriminant_test, all_match, Some(arm_expr));\n+            cx.expr_block(\n+                cx.block_all(sp, index_let_stmts, Some(arm_expr)))\n         } else if variants.is_empty() {\n             // As an additional wrinkle, For a zero-variant enum A,\n             // currently the compiler\n@@ -1319,17 +1365,19 @@ impl<'a> MethodDef<'a> {\n             // derive Debug on such a type could here generate code\n             // that needs the feature gate enabled.)\n \n-            return cx.expr_unreachable(sp);\n+            cx.expr_unreachable(sp)\n+        }\n+        else {\n+\n+            // Final wrinkle: the self_args are expressions that deref\n+            // down to desired l-values, but we cannot actually deref\n+            // them when they are fed as r-values into a tuple\n+            // expression; here add a layer of borrowing, turning\n+            // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n+            let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n+            let match_arg = cx.expr(sp, ast::ExprTup(borrowed_self_args));\n+            cx.expr_match(sp, match_arg, match_arms)\n         }\n-\n-        // Final wrinkle: the self_args are expressions that deref\n-        // down to desired l-values, but we cannot actually deref\n-        // them when they are fed as r-values into a tuple\n-        // expression; here add a layer of borrowing, turning\n-        // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-        let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n-        let match_arg = cx.expr(sp, ast::ExprTup(borrowed_self_args));\n-        cx.expr_match(sp, match_arg, match_arms)\n     }\n \n     fn expand_static_enum_method_body(&self,"}]}