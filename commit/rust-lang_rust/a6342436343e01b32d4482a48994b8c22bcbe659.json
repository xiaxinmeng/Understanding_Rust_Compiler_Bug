{"sha": "a6342436343e01b32d4482a48994b8c22bcbe659", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MzQyNDM2MzQzZTAxYjMyZDQ0ODJhNDg5OTRiOGMyMmJjYmU2NTk=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-12-02T15:52:14Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-12-03T14:48:29Z"}, "message": "Propagate eager expansion errors", "tree": {"sha": "1fd4c71c6b203417c64b9ffb31221242d6f1a270", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fd4c71c6b203417c64b9ffb31221242d6f1a270"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6342436343e01b32d4482a48994b8c22bcbe659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6342436343e01b32d4482a48994b8c22bcbe659", "html_url": "https://github.com/rust-lang/rust/commit/a6342436343e01b32d4482a48994b8c22bcbe659", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6342436343e01b32d4482a48994b8c22bcbe659/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a1306a43652d914035b2cf0b703f4bfd3451a33", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a1306a43652d914035b2cf0b703f4bfd3451a33", "html_url": "https://github.com/rust-lang/rust/commit/5a1306a43652d914035b2cf0b703f4bfd3451a33"}], "stats": {"total": 186, "additions": 153, "deletions": 33}, "files": [{"sha": "92bcc17053d82d2e8c0157e4e1f246025442b565", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a6342436343e01b32d4482a48994b8c22bcbe659/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6342436343e01b32d4482a48994b8c22bcbe659/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=a6342436343e01b32d4482a48994b8c22bcbe659", "patch": "@@ -120,18 +120,24 @@ impl Expander {\n             self.resolve_path_as_macro(db, &path)\n         };\n \n-        let call_id = match macro_call.as_call_id(db, self.crate_def_map.krate, resolver) {\n+        let mut err = None;\n+        let call_id =\n+            macro_call.as_call_id_with_errors(db, self.crate_def_map.krate, resolver, &mut |e| {\n+                err.get_or_insert(e);\n+            });\n+        let call_id = match call_id {\n             Some(it) => it,\n             None => {\n-                // FIXME: this can mean other things too, but `as_call_id` doesn't provide enough\n-                // info.\n-                return ExpandResult::only_err(mbe::ExpandError::Other(\n-                    \"failed to parse or resolve macro invocation\".into(),\n-                ));\n+                if err.is_none() {\n+                    eprintln!(\"no error despite `as_call_id_with_errors` returning `None`\");\n+                }\n+                return ExpandResult { value: None, err };\n             }\n         };\n \n-        let err = db.macro_expand_error(call_id);\n+        if err.is_none() {\n+            err = db.macro_expand_error(call_id);\n+        }\n \n         let file_id = call_id.as_file();\n "}, {"sha": "ce2be8e2b9bf41337eab83e5b1b410add07c2464", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a6342436343e01b32d4482a48994b8c22bcbe659/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6342436343e01b32d4482a48994b8c22bcbe659/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=a6342436343e01b32d4482a48994b8c22bcbe659", "patch": "@@ -465,21 +465,37 @@ pub trait AsMacroCall {\n         db: &dyn db::DefDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+    ) -> Option<MacroCallId> {\n+        self.as_call_id_with_errors(db, krate, resolver, &mut |_| ())\n+    }\n+\n+    fn as_call_id_with_errors(\n+        &self,\n+        db: &dyn db::DefDatabase,\n+        krate: CrateId,\n+        resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+        error_sink: &mut dyn FnMut(mbe::ExpandError),\n     ) -> Option<MacroCallId>;\n }\n \n impl AsMacroCall for InFile<&ast::MacroCall> {\n-    fn as_call_id(\n+    fn as_call_id_with_errors(\n         &self,\n         db: &dyn db::DefDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+        error_sink: &mut dyn FnMut(mbe::ExpandError),\n     ) -> Option<MacroCallId> {\n         let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(self.value));\n         let h = Hygiene::new(db.upcast(), self.file_id);\n-        let path = path::ModPath::from_src(self.value.path()?, &h)?;\n+        let path = self.value.path().and_then(|path| path::ModPath::from_src(path, &h));\n+\n+        if path.is_none() {\n+            error_sink(mbe::ExpandError::Other(\"malformed macro invocation\".into()));\n+        }\n \n-        AstIdWithPath::new(ast_id.file_id, ast_id.value, path).as_call_id(db, krate, resolver)\n+        AstIdWithPath::new(ast_id.file_id, ast_id.value, path?)\n+            .as_call_id_with_errors(db, krate, resolver, error_sink)\n     }\n }\n \n@@ -497,22 +513,32 @@ impl<T: ast::AstNode> AstIdWithPath<T> {\n }\n \n impl AsMacroCall for AstIdWithPath<ast::MacroCall> {\n-    fn as_call_id(\n+    fn as_call_id_with_errors(\n         &self,\n         db: &dyn db::DefDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+        error_sink: &mut dyn FnMut(mbe::ExpandError),\n     ) -> Option<MacroCallId> {\n-        let def: MacroDefId = resolver(self.path.clone())?;\n+        let def: MacroDefId = resolver(self.path.clone()).or_else(|| {\n+            error_sink(mbe::ExpandError::Other(\"could not resolve macro\".into()));\n+            None\n+        })?;\n \n         if let MacroDefKind::BuiltInEager(_) = def.kind {\n             let macro_call = InFile::new(self.ast_id.file_id, self.ast_id.to_node(db.upcast()));\n             let hygiene = Hygiene::new(db.upcast(), self.ast_id.file_id);\n \n             Some(\n-                expand_eager_macro(db.upcast(), krate, macro_call, def, &|path: ast::Path| {\n-                    resolver(path::ModPath::from_src(path, &hygiene)?)\n-                })?\n+                expand_eager_macro(\n+                    db.upcast(),\n+                    krate,\n+                    macro_call,\n+                    def,\n+                    &|path: ast::Path| resolver(path::ModPath::from_src(path, &hygiene)?),\n+                    error_sink,\n+                )\n+                .ok()?\n                 .into(),\n             )\n         } else {\n@@ -522,13 +548,18 @@ impl AsMacroCall for AstIdWithPath<ast::MacroCall> {\n }\n \n impl AsMacroCall for AstIdWithPath<ast::Item> {\n-    fn as_call_id(\n+    fn as_call_id_with_errors(\n         &self,\n         db: &dyn db::DefDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+        error_sink: &mut dyn FnMut(mbe::ExpandError),\n     ) -> Option<MacroCallId> {\n-        let def = resolver(self.path.clone())?;\n+        let def: MacroDefId = resolver(self.path.clone()).or_else(|| {\n+            error_sink(mbe::ExpandError::Other(\"could not resolve macro\".into()));\n+            None\n+        })?;\n+\n         Some(\n             def.as_lazy_macro(\n                 db.upcast(),"}, {"sha": "a48d08f3b745a87e1c8c6dd7ffb4efc6a3390d57", "filename": "crates/hir_expand/src/eager.rs", "status": "modified", "additions": 99, "deletions": 16, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/a6342436343e01b32d4482a48994b8c22bcbe659/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6342436343e01b32d4482a48994b8c22bcbe659/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=a6342436343e01b32d4482a48994b8c22bcbe659", "patch": "@@ -26,19 +26,89 @@ use crate::{\n };\n \n use base_db::CrateId;\n+use mbe::ExpandResult;\n use parser::FragmentKind;\n use std::sync::Arc;\n use syntax::{algo::SyntaxRewriter, SyntaxNode};\n \n+pub struct ErrorEmitted {\n+    _private: (),\n+}\n+\n+trait ErrorSink {\n+    fn emit(&mut self, err: mbe::ExpandError);\n+\n+    fn option<T>(\n+        &mut self,\n+        opt: Option<T>,\n+        error: impl FnOnce() -> mbe::ExpandError,\n+    ) -> Result<T, ErrorEmitted> {\n+        match opt {\n+            Some(it) => Ok(it),\n+            None => {\n+                self.emit(error());\n+                Err(ErrorEmitted { _private: () })\n+            }\n+        }\n+    }\n+\n+    fn option_with<T>(\n+        &mut self,\n+        opt: impl FnOnce() -> Option<T>,\n+        error: impl FnOnce() -> mbe::ExpandError,\n+    ) -> Result<T, ErrorEmitted> {\n+        self.option(opt(), error)\n+    }\n+\n+    fn result<T>(&mut self, res: Result<T, mbe::ExpandError>) -> Result<T, ErrorEmitted> {\n+        match res {\n+            Ok(it) => Ok(it),\n+            Err(e) => {\n+                self.emit(e);\n+                Err(ErrorEmitted { _private: () })\n+            }\n+        }\n+    }\n+\n+    fn expand_result_option<T>(&mut self, res: ExpandResult<Option<T>>) -> Result<T, ErrorEmitted> {\n+        match (res.value, res.err) {\n+            (None, Some(err)) => {\n+                self.emit(err);\n+                Err(ErrorEmitted { _private: () })\n+            }\n+            (Some(value), opt_err) => {\n+                if let Some(err) = opt_err {\n+                    self.emit(err);\n+                }\n+                Ok(value)\n+            }\n+            (None, None) => unreachable!(\"`ExpandResult` without value or error\"),\n+        }\n+    }\n+}\n+\n+impl ErrorSink for &'_ mut dyn FnMut(mbe::ExpandError) {\n+    fn emit(&mut self, err: mbe::ExpandError) {\n+        self(err);\n+    }\n+}\n+\n+fn err(msg: impl Into<String>) -> mbe::ExpandError {\n+    mbe::ExpandError::Other(msg.into())\n+}\n+\n pub fn expand_eager_macro(\n     db: &dyn AstDatabase,\n     krate: CrateId,\n     macro_call: InFile<ast::MacroCall>,\n     def: MacroDefId,\n     resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n-) -> Option<EagerMacroId> {\n-    let args = macro_call.value.token_tree()?;\n-    let parsed_args = mbe::ast_to_token_tree(&args)?.0;\n+    mut error_sink: &mut dyn FnMut(mbe::ExpandError),\n+) -> Result<EagerMacroId, ErrorEmitted> {\n+    let parsed_args = error_sink.option_with(\n+        || Some(mbe::ast_to_token_tree(&macro_call.value.token_tree()?)?.0),\n+        || err(\"malformed macro invocation\"),\n+    )?;\n \n     // Note:\n     // When `lazy_expand` is called, its *parent* file must be already exists.\n@@ -55,17 +125,21 @@ pub fn expand_eager_macro(\n     });\n     let arg_file_id: MacroCallId = arg_id.into();\n \n-    let parsed_args = mbe::token_tree_to_syntax_node(&parsed_args, FragmentKind::Expr).ok()?.0;\n+    let parsed_args =\n+        error_sink.result(mbe::token_tree_to_syntax_node(&parsed_args, FragmentKind::Expr))?.0;\n     let result = eager_macro_recur(\n         db,\n         InFile::new(arg_file_id.as_file(), parsed_args.syntax_node()),\n         krate,\n         resolver,\n+        error_sink,\n     )?;\n-    let subtree = to_subtree(&result)?;\n+    let subtree = error_sink.option(to_subtree(&result), || err(\"failed to parse macro result\"))?;\n \n     if let MacroDefKind::BuiltInEager(eager) = def.kind {\n-        let (subtree, fragment) = eager.expand(db, arg_id, &subtree).value?;\n+        let res = eager.expand(db, arg_id, &subtree);\n+\n+        let (subtree, fragment) = error_sink.expand_result_option(res)?;\n         let eager = EagerCallLoc {\n             def,\n             fragment,\n@@ -74,9 +148,9 @@ pub fn expand_eager_macro(\n             file_id: macro_call.file_id,\n         };\n \n-        Some(db.intern_eager_expansion(eager))\n+        Ok(db.intern_eager_expansion(eager))\n     } else {\n-        None\n+        panic!(\"called `expand_eager_macro` on non-eager macro def {:?}\", def);\n     }\n }\n \n@@ -91,29 +165,34 @@ fn lazy_expand(\n     def: &MacroDefId,\n     macro_call: InFile<ast::MacroCall>,\n     krate: CrateId,\n-) -> Option<InFile<SyntaxNode>> {\n+) -> ExpandResult<Option<InFile<SyntaxNode>>> {\n     let ast_id = db.ast_id_map(macro_call.file_id).ast_id(&macro_call.value);\n \n     let id: MacroCallId =\n         def.as_lazy_macro(db, krate, MacroCallKind::FnLike(macro_call.with_value(ast_id))).into();\n \n-    db.parse_or_expand(id.as_file()).map(|node| InFile::new(id.as_file(), node))\n+    let err = db.macro_expand_error(id);\n+    let value = db.parse_or_expand(id.as_file()).map(|node| InFile::new(id.as_file(), node));\n+\n+    ExpandResult { value, err }\n }\n \n fn eager_macro_recur(\n     db: &dyn AstDatabase,\n     curr: InFile<SyntaxNode>,\n     krate: CrateId,\n     macro_resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n-) -> Option<SyntaxNode> {\n+    mut error_sink: &mut dyn FnMut(mbe::ExpandError),\n+) -> Result<SyntaxNode, ErrorEmitted> {\n     let original = curr.value.clone();\n \n     let children = curr.value.descendants().filter_map(ast::MacroCall::cast);\n     let mut rewriter = SyntaxRewriter::default();\n \n     // Collect replacement\n     for child in children {\n-        let def: MacroDefId = macro_resolver(child.path()?)?;\n+        let def = error_sink\n+            .option_with(|| macro_resolver(child.path()?), || err(\"failed to resolve macro\"))?;\n         let insert = match def.kind {\n             MacroDefKind::BuiltInEager(_) => {\n                 let id: MacroCallId = expand_eager_macro(\n@@ -122,23 +201,27 @@ fn eager_macro_recur(\n                     curr.with_value(child.clone()),\n                     def,\n                     macro_resolver,\n+                    error_sink,\n                 )?\n                 .into();\n-                db.parse_or_expand(id.as_file())?\n+                db.parse_or_expand(id.as_file())\n+                    .expect(\"successful macro expansion should be parseable\")\n             }\n             MacroDefKind::Declarative\n             | MacroDefKind::BuiltIn(_)\n             | MacroDefKind::BuiltInDerive(_)\n             | MacroDefKind::ProcMacro(_) => {\n-                let expanded = lazy_expand(db, &def, curr.with_value(child.clone()), krate)?;\n+                let res = lazy_expand(db, &def, curr.with_value(child.clone()), krate);\n+                let val = error_sink.expand_result_option(res)?;\n+\n                 // replace macro inside\n-                eager_macro_recur(db, expanded, krate, macro_resolver)?\n+                eager_macro_recur(db, val, krate, macro_resolver, error_sink)?\n             }\n         };\n \n         rewriter.replace(child.syntax(), &insert);\n     }\n \n     let res = rewriter.rewrite(&original);\n-    Some(res)\n+    Ok(res)\n }"}]}