{"sha": "a8e04a702827c454f5336c82262b0963df7fe484", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ZTA0YTcwMjgyN2M0NTRmNTMzNmM4MjI2MmIwOTYzZGY3ZmU0ODQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-21T22:01:40Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-21T22:01:40Z"}, "message": "docs", "tree": {"sha": "24d94c4361b5ac3c009a2832006cdd4b8475af66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24d94c4361b5ac3c009a2832006cdd4b8475af66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8e04a702827c454f5336c82262b0963df7fe484", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8e04a702827c454f5336c82262b0963df7fe484", "html_url": "https://github.com/rust-lang/rust/commit/a8e04a702827c454f5336c82262b0963df7fe484", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8e04a702827c454f5336c82262b0963df7fe484/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "200cc0a1e355cbe63dfea844a31b90ea13d42ad5", "url": "https://api.github.com/repos/rust-lang/rust/commits/200cc0a1e355cbe63dfea844a31b90ea13d42ad5", "html_url": "https://github.com/rust-lang/rust/commit/200cc0a1e355cbe63dfea844a31b90ea13d42ad5"}], "stats": {"total": 348, "additions": 181, "deletions": 167}, "files": [{"sha": "2d61a3aef53e9abe91300f5059c434779644ac1e", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 14, "deletions": 156, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/a8e04a702827c454f5336c82262b0963df7fe484/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e04a702827c454f5336c82262b0963df7fe484/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=a8e04a702827c454f5336c82262b0963df7fe484", "patch": "@@ -1,39 +1,39 @@\n mod completion_item;\n+mod completion_context;\n \n mod complete_fn_param;\n mod complete_keyword;\n mod complete_snippet;\n mod complete_path;\n mod complete_scope;\n \n-use ra_editor::find_node_at_offset;\n-use ra_text_edit::AtomTextEdit;\n-use ra_syntax::{\n-    algo::find_leaf_at_offset,\n-    ast,\n-    AstNode,\n-    SyntaxNodeRef,\n-    SourceFileNode,\n-    TextUnit,\n-    SyntaxKind::*,\n-};\n use ra_db::SyntaxDatabase;\n-use hir::source_binder;\n \n use crate::{\n     db,\n     Cancelable, FilePosition,\n-    completion::completion_item::{Completions, CompletionKind},\n+    completion::{\n+        completion_item::{Completions, CompletionKind},\n+        completion_context::CompletionContext,\n+    },\n };\n \n pub use crate::completion::completion_item::{CompletionItem, InsertText};\n \n+/// Main entry point for copmletion. We run comletion as a two-phase process.\n+///\n+/// First, we look at the position and collect a so-called `CompletionContext.\n+/// This is a somewhat messy process, because, during completion, syntax tree is\n+/// incomplete and can look readlly weired.\n+///\n+/// Once the context is collected, we run a series of completion routines whihc\n+/// look at the context and produce completion items.\n pub(crate) fn completions(\n     db: &db::RootDatabase,\n     position: FilePosition,\n ) -> Cancelable<Option<Completions>> {\n     let original_file = db.source_file(position.file_id);\n-    let ctx = ctry!(SyntaxContext::new(db, &original_file, position)?);\n+    let ctx = ctry!(CompletionContext::new(db, &original_file, position)?);\n \n     let mut acc = Completions::default();\n \n@@ -47,148 +47,6 @@ pub(crate) fn completions(\n     Ok(Some(acc))\n }\n \n-/// `SyntaxContext` is created early during completion to figure out, where\n-/// exactly is the cursor, syntax-wise.\n-#[derive(Debug)]\n-pub(super) struct SyntaxContext<'a> {\n-    db: &'a db::RootDatabase,\n-    offset: TextUnit,\n-    leaf: SyntaxNodeRef<'a>,\n-    module: Option<hir::Module>,\n-    enclosing_fn: Option<ast::FnDef<'a>>,\n-    is_param: bool,\n-    /// A single-indent path, like `foo`.\n-    is_trivial_path: bool,\n-    /// If not a trivial, path, the prefix (qualifier).\n-    path_prefix: Option<hir::Path>,\n-    after_if: bool,\n-    is_stmt: bool,\n-    /// Something is typed at the \"top\" level, in module or impl/trait.\n-    is_new_item: bool,\n-}\n-\n-impl<'a> SyntaxContext<'a> {\n-    pub(super) fn new(\n-        db: &'a db::RootDatabase,\n-        original_file: &'a SourceFileNode,\n-        position: FilePosition,\n-    ) -> Cancelable<Option<SyntaxContext<'a>>> {\n-        let module = source_binder::module_from_position(db, position)?;\n-        let leaf =\n-            ctry!(find_leaf_at_offset(original_file.syntax(), position.offset).left_biased());\n-        let mut ctx = SyntaxContext {\n-            db,\n-            leaf,\n-            offset: position.offset,\n-            module,\n-            enclosing_fn: None,\n-            is_param: false,\n-            is_trivial_path: false,\n-            path_prefix: None,\n-            after_if: false,\n-            is_stmt: false,\n-            is_new_item: false,\n-        };\n-        ctx.fill(original_file, position.offset);\n-        Ok(Some(ctx))\n-    }\n-\n-    fn fill(&mut self, original_file: &SourceFileNode, offset: TextUnit) {\n-        // Insert a fake ident to get a valid parse tree. We will use this file\n-        // to determine context, though the original_file will be used for\n-        // actual completion.\n-        let file = {\n-            let edit = AtomTextEdit::insert(offset, \"intellijRulezz\".to_string());\n-            original_file.reparse(&edit)\n-        };\n-\n-        // First, let's try to complete a reference to some declaration.\n-        if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), offset) {\n-            // Special case, `trait T { fn foo(i_am_a_name_ref) {} }`.\n-            // See RFC#1685.\n-            if is_node::<ast::Param>(name_ref.syntax()) {\n-                self.is_param = true;\n-                return;\n-            }\n-            self.classify_name_ref(&file, name_ref);\n-        }\n-\n-        // Otherwise, see if this is a declaration. We can use heuristics to\n-        // suggest declaration names, see `CompletionKind::Magic`.\n-        if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), offset) {\n-            if is_node::<ast::Param>(name.syntax()) {\n-                self.is_param = true;\n-                return;\n-            }\n-        }\n-    }\n-    fn classify_name_ref(&mut self, file: &SourceFileNode, name_ref: ast::NameRef) {\n-        let name_range = name_ref.syntax().range();\n-        let top_node = name_ref\n-            .syntax()\n-            .ancestors()\n-            .take_while(|it| it.range() == name_range)\n-            .last()\n-            .unwrap();\n-\n-        match top_node.parent().map(|it| it.kind()) {\n-            Some(SOURCE_FILE) | Some(ITEM_LIST) => {\n-                self.is_new_item = true;\n-                return;\n-            }\n-            _ => (),\n-        }\n-\n-        let parent = match name_ref.syntax().parent() {\n-            Some(it) => it,\n-            None => return,\n-        };\n-        if let Some(segment) = ast::PathSegment::cast(parent) {\n-            let path = segment.parent_path();\n-            if let Some(mut path) = hir::Path::from_ast(path) {\n-                if !path.is_ident() {\n-                    path.segments.pop().unwrap();\n-                    self.path_prefix = Some(path);\n-                    return;\n-                }\n-            }\n-            if path.qualifier().is_none() {\n-                self.is_trivial_path = true;\n-                self.enclosing_fn = self\n-                    .leaf\n-                    .ancestors()\n-                    .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n-                    .find_map(ast::FnDef::cast);\n-\n-                self.is_stmt = match name_ref\n-                    .syntax()\n-                    .ancestors()\n-                    .filter_map(ast::ExprStmt::cast)\n-                    .next()\n-                {\n-                    None => false,\n-                    Some(expr_stmt) => expr_stmt.syntax().range() == name_ref.syntax().range(),\n-                };\n-\n-                if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n-                    if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n-                        if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n-                            self.after_if = true;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn is_node<'a, N: AstNode<'a>>(node: SyntaxNodeRef<'a>) -> bool {\n-    match node.ancestors().filter_map(N::cast).next() {\n-        None => false,\n-        Some(n) => n.syntax().range() == node.range(),\n-    }\n-}\n-\n #[cfg(test)]\n fn check_completion(code: &str, expected_completions: &str, kind: CompletionKind) {\n     use crate::mock_analysis::{single_file_with_position, analysis_and_position};"}, {"sha": "3ec507fdf54488bae474440967940a4715dc6975", "filename": "crates/ra_analysis/src/completion/complete_fn_param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8e04a702827c454f5336c82262b0963df7fe484/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e04a702827c454f5336c82262b0963df7fe484/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs?ref=a8e04a702827c454f5336c82262b0963df7fe484", "patch": "@@ -8,14 +8,14 @@ use ra_syntax::{\n use rustc_hash::{FxHashMap};\n \n use crate::{\n-    completion::{SyntaxContext, Completions, CompletionKind, CompletionItem},\n+    completion::{CompletionContext, Completions, CompletionKind, CompletionItem},\n };\n \n /// Complete repeated parametes, both name and type. For example, if all\n /// functions in a file have a `spam: &mut Spam` parameter, a completion with\n /// `spam: &mut Spam` insert text/label and `spam` lookup string will be\n /// suggested.\n-pub(super) fn complete_fn_param(acc: &mut Completions, ctx: &SyntaxContext) {\n+pub(super) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.is_param {\n         return;\n     }"}, {"sha": "2ee36430ec6842520cc00cb3065a3243554c5c32", "filename": "crates/ra_analysis/src/completion/complete_keyword.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8e04a702827c454f5336c82262b0963df7fe484/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e04a702827c454f5336c82262b0963df7fe484/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=a8e04a702827c454f5336c82262b0963df7fe484", "patch": "@@ -6,10 +6,10 @@ use ra_syntax::{\n };\n \n use crate::{\n-    completion::{SyntaxContext, CompletionItem, Completions, CompletionKind::*},\n+    completion::{CompletionContext, CompletionItem, Completions, CompletionKind::*},\n };\n \n-pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &SyntaxContext) {\n+pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.is_trivial_path {\n         return;\n     }"}, {"sha": "41e439b1bab93e5d4b1eeb305d010118567c1de6", "filename": "crates/ra_analysis/src/completion/complete_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8e04a702827c454f5336c82262b0963df7fe484/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e04a702827c454f5336c82262b0963df7fe484/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=a8e04a702827c454f5336c82262b0963df7fe484", "patch": "@@ -1,9 +1,9 @@\n use crate::{\n-    completion::{CompletionItem, Completions, CompletionKind::*, SyntaxContext},\n+    completion::{CompletionItem, Completions, CompletionKind::*, CompletionContext},\n     Cancelable,\n };\n \n-pub(super) fn complete_path(acc: &mut Completions, ctx: &SyntaxContext) -> Cancelable<()> {\n+pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) -> Cancelable<()> {\n     let (path, module) = match (&ctx.path_prefix, &ctx.module) {\n         (Some(path), Some(module)) => (path.clone(), module),\n         _ => return Ok(()),"}, {"sha": "c1ab19d5bcef6392ca15077af84a385ddaefedff", "filename": "crates/ra_analysis/src/completion/complete_scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8e04a702827c454f5336c82262b0963df7fe484/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e04a702827c454f5336c82262b0963df7fe484/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=a8e04a702827c454f5336c82262b0963df7fe484", "patch": "@@ -2,11 +2,11 @@ use rustc_hash::FxHashSet;\n use ra_syntax::TextUnit;\n \n use crate::{\n-    completion::{CompletionItem, Completions, CompletionKind::*, SyntaxContext},\n+    completion::{CompletionItem, Completions, CompletionKind::*, CompletionContext},\n     Cancelable\n };\n \n-pub(super) fn complete_scope(acc: &mut Completions, ctx: &SyntaxContext) -> Cancelable<()> {\n+pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) -> Cancelable<()> {\n     if !ctx.is_trivial_path {\n         return Ok(());\n     }"}, {"sha": "6816ae6959d646971e0fc9688b8d93019c9c5607", "filename": "crates/ra_analysis/src/completion/complete_snippet.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8e04a702827c454f5336c82262b0963df7fe484/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e04a702827c454f5336c82262b0963df7fe484/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs?ref=a8e04a702827c454f5336c82262b0963df7fe484", "patch": "@@ -1,8 +1,8 @@\n use crate::{\n-    completion::{CompletionItem, Completions, CompletionKind::*, SyntaxContext},\n+    completion::{CompletionItem, Completions, CompletionKind::*, CompletionContext},\n };\n \n-pub(super) fn complete_expr_snippet(acc: &mut Completions, ctx: &SyntaxContext) {\n+pub(super) fn complete_expr_snippet(acc: &mut Completions, ctx: &CompletionContext) {\n     if !(ctx.is_trivial_path && ctx.enclosing_fn.is_some()) {\n         return;\n     }\n@@ -16,7 +16,7 @@ pub(super) fn complete_expr_snippet(acc: &mut Completions, ctx: &SyntaxContext)\n         .add_to(acc);\n }\n \n-pub(super) fn complete_item_snippet(acc: &mut Completions, ctx: &SyntaxContext) {\n+pub(super) fn complete_item_snippet(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.is_new_item {\n         return;\n     }"}, {"sha": "064fbc6f7be89751ea910863e9b784e3224691b3", "filename": "crates/ra_analysis/src/completion/completion_context.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/a8e04a702827c454f5336c82262b0963df7fe484/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e04a702827c454f5336c82262b0963df7fe484/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=a8e04a702827c454f5336c82262b0963df7fe484", "patch": "@@ -0,0 +1,156 @@\n+use ra_editor::find_node_at_offset;\n+use ra_text_edit::AtomTextEdit;\n+use ra_syntax::{\n+    algo::find_leaf_at_offset,\n+    ast,\n+    AstNode,\n+    SyntaxNodeRef,\n+    SourceFileNode,\n+    TextUnit,\n+    SyntaxKind::*,\n+};\n+use hir::source_binder;\n+\n+use crate::{db, FilePosition, Cancelable};\n+\n+/// `CompletionContext` is created early during completion to figure out, where\n+/// exactly is the cursor, syntax-wise.\n+#[derive(Debug)]\n+pub(super) struct CompletionContext<'a> {\n+    pub(super) db: &'a db::RootDatabase,\n+    pub(super) offset: TextUnit,\n+    pub(super) leaf: SyntaxNodeRef<'a>,\n+    pub(super) module: Option<hir::Module>,\n+    pub(super) enclosing_fn: Option<ast::FnDef<'a>>,\n+    pub(super) is_param: bool,\n+    /// A single-indent path, like `foo`.\n+    pub(super) is_trivial_path: bool,\n+    /// If not a trivial, path, the prefix (qualifier).\n+    pub(super) path_prefix: Option<hir::Path>,\n+    pub(super) after_if: bool,\n+    pub(super) is_stmt: bool,\n+    /// Something is typed at the \"top\" level, in module or impl/trait.\n+    pub(super) is_new_item: bool,\n+}\n+\n+impl<'a> CompletionContext<'a> {\n+    pub(super) fn new(\n+        db: &'a db::RootDatabase,\n+        original_file: &'a SourceFileNode,\n+        position: FilePosition,\n+    ) -> Cancelable<Option<CompletionContext<'a>>> {\n+        let module = source_binder::module_from_position(db, position)?;\n+        let leaf =\n+            ctry!(find_leaf_at_offset(original_file.syntax(), position.offset).left_biased());\n+        let mut ctx = CompletionContext {\n+            db,\n+            leaf,\n+            offset: position.offset,\n+            module,\n+            enclosing_fn: None,\n+            is_param: false,\n+            is_trivial_path: false,\n+            path_prefix: None,\n+            after_if: false,\n+            is_stmt: false,\n+            is_new_item: false,\n+        };\n+        ctx.fill(original_file, position.offset);\n+        Ok(Some(ctx))\n+    }\n+\n+    fn fill(&mut self, original_file: &SourceFileNode, offset: TextUnit) {\n+        // Insert a fake ident to get a valid parse tree. We will use this file\n+        // to determine context, though the original_file will be used for\n+        // actual completion.\n+        let file = {\n+            let edit = AtomTextEdit::insert(offset, \"intellijRulezz\".to_string());\n+            original_file.reparse(&edit)\n+        };\n+\n+        // First, let's try to complete a reference to some declaration.\n+        if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), offset) {\n+            // Special case, `trait T { fn foo(i_am_a_name_ref) {} }`.\n+            // See RFC#1685.\n+            if is_node::<ast::Param>(name_ref.syntax()) {\n+                self.is_param = true;\n+                return;\n+            }\n+            self.classify_name_ref(&file, name_ref);\n+        }\n+\n+        // Otherwise, see if this is a declaration. We can use heuristics to\n+        // suggest declaration names, see `CompletionKind::Magic`.\n+        if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), offset) {\n+            if is_node::<ast::Param>(name.syntax()) {\n+                self.is_param = true;\n+                return;\n+            }\n+        }\n+    }\n+    fn classify_name_ref(&mut self, file: &SourceFileNode, name_ref: ast::NameRef) {\n+        let name_range = name_ref.syntax().range();\n+        let top_node = name_ref\n+            .syntax()\n+            .ancestors()\n+            .take_while(|it| it.range() == name_range)\n+            .last()\n+            .unwrap();\n+\n+        match top_node.parent().map(|it| it.kind()) {\n+            Some(SOURCE_FILE) | Some(ITEM_LIST) => {\n+                self.is_new_item = true;\n+                return;\n+            }\n+            _ => (),\n+        }\n+\n+        let parent = match name_ref.syntax().parent() {\n+            Some(it) => it,\n+            None => return,\n+        };\n+        if let Some(segment) = ast::PathSegment::cast(parent) {\n+            let path = segment.parent_path();\n+            if let Some(mut path) = hir::Path::from_ast(path) {\n+                if !path.is_ident() {\n+                    path.segments.pop().unwrap();\n+                    self.path_prefix = Some(path);\n+                    return;\n+                }\n+            }\n+            if path.qualifier().is_none() {\n+                self.is_trivial_path = true;\n+                self.enclosing_fn = self\n+                    .leaf\n+                    .ancestors()\n+                    .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n+                    .find_map(ast::FnDef::cast);\n+\n+                self.is_stmt = match name_ref\n+                    .syntax()\n+                    .ancestors()\n+                    .filter_map(ast::ExprStmt::cast)\n+                    .next()\n+                {\n+                    None => false,\n+                    Some(expr_stmt) => expr_stmt.syntax().range() == name_ref.syntax().range(),\n+                };\n+\n+                if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n+                    if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n+                        if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n+                            self.after_if = true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn is_node<'a, N: AstNode<'a>>(node: SyntaxNodeRef<'a>) -> bool {\n+    match node.ancestors().filter_map(N::cast).next() {\n+        None => false,\n+        Some(n) => n.syntax().range() == node.range(),\n+    }\n+}"}]}