{"sha": "9a00fd049bbc051ce1cbacb04c0db5a7bfc8d723", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMDBmZDA0OWJiYzA1MWNlMWNiYWNiMDRjMGRiNWE3YmZjOGQ3MjM=", "commit": {"author": {"name": "Taylor Yu", "email": "tlyu@mit.edu", "date": "2021-06-19T20:09:27Z"}, "committer": {"name": "Taylor Yu", "email": "tlyu@mit.edu", "date": "2021-06-20T22:22:03Z"}, "message": "add more to result overview", "tree": {"sha": "9ab8187eb476c4f730c5249ade7616eb6db28f02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ab8187eb476c4f730c5249ade7616eb6db28f02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a00fd049bbc051ce1cbacb04c0db5a7bfc8d723", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a00fd049bbc051ce1cbacb04c0db5a7bfc8d723", "html_url": "https://github.com/rust-lang/rust/commit/9a00fd049bbc051ce1cbacb04c0db5a7bfc8d723", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a00fd049bbc051ce1cbacb04c0db5a7bfc8d723/comments", "author": {"login": "tlyu", "id": 431873, "node_id": "MDQ6VXNlcjQzMTg3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tlyu", "html_url": "https://github.com/tlyu", "followers_url": "https://api.github.com/users/tlyu/followers", "following_url": "https://api.github.com/users/tlyu/following{/other_user}", "gists_url": "https://api.github.com/users/tlyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/tlyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tlyu/subscriptions", "organizations_url": "https://api.github.com/users/tlyu/orgs", "repos_url": "https://api.github.com/users/tlyu/repos", "events_url": "https://api.github.com/users/tlyu/events{/privacy}", "received_events_url": "https://api.github.com/users/tlyu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tlyu", "id": 431873, "node_id": "MDQ6VXNlcjQzMTg3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tlyu", "html_url": "https://github.com/tlyu", "followers_url": "https://api.github.com/users/tlyu/followers", "following_url": "https://api.github.com/users/tlyu/following{/other_user}", "gists_url": "https://api.github.com/users/tlyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/tlyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tlyu/subscriptions", "organizations_url": "https://api.github.com/users/tlyu/orgs", "repos_url": "https://api.github.com/users/tlyu/repos", "events_url": "https://api.github.com/users/tlyu/events{/privacy}", "received_events_url": "https://api.github.com/users/tlyu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b58d93bb20fcf8529bfe994d0c85344db5da3b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b58d93bb20fcf8529bfe994d0c85344db5da3b8", "html_url": "https://github.com/rust-lang/rust/commit/1b58d93bb20fcf8529bfe994d0c85344db5da3b8"}], "stats": {"total": 181, "additions": 181, "deletions": 0}, "files": [{"sha": "75ba70dea1fb0b4e2a3b3d8ea3b38e4f356c43d7", "filename": "library/core/src/result.rs", "status": "modified", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/9a00fd049bbc051ce1cbacb04c0db5a7bfc8d723/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a00fd049bbc051ce1cbacb04c0db5a7bfc8d723/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=9a00fd049bbc051ce1cbacb04c0db5a7bfc8d723", "patch": "@@ -227,6 +227,103 @@\n //!\n //! # Method overview\n //!\n+//! In addition to working with pattern matching, [`Result`] provides a\n+//! wide variety of different methods.\n+//!\n+//! ## Querying the variant\n+//!\n+//! The [`is_ok`] and [`is_err`] methods return [`true`] if the [`Result`]\n+//! is [`Ok`] or [`Err`], respectively.\n+//!\n+//! [`is_err`]: Result::is_err\n+//! [`is_ok`]: Result::is_ok\n+//!\n+//! ## Adapters for working with references\n+//!\n+//! * [`as_ref`] converts from `&Result<T, E>` to `Result<&T, &E>`\n+//! * [`as_mut`] converts from `&mut Result<T, E>` to `Result<&mut T, &mut E>`\n+//! * [`as_deref`] converts from `&Result<T>` to `Result<&T::Target, &E>`\n+//! * [`as_deref_mut`] converts from `&mut Result<T>` to `Result<&mut T::Target, &mut E>`\n+//!\n+//! [`as_deref`]: Result::as_deref\n+//! [`as_deref_mut`]: Result::as_deref_mut\n+//! [`as_mut`]: Result::as_mut\n+//! [`as_ref`]: Result::as_ref\n+//!\n+//! ## Extracting contained values\n+//!\n+//! These methods extract the contained value in a [`Result`] when it is\n+//! the [`Ok`] variant. If the [`Result`] is [`Err`]:\n+//!\n+//! * [`expect`] panics with a provided custom message\n+//! * [`unwrap`] panics with a generic message\n+//! * [`unwrap_or`] returns the provided default value\n+//! * [`unwrap_or_default`] returns the default value of the type `T`\n+//!   (which must implement the [`Default`] trait)\n+//! * [`unwrap_or_else`] returns the result of evaluating the provided\n+//!   function\n+//!\n+//! The panicking methods [`expect`] and [`unwrap`] require `E` to\n+//! implement the [`Debug`] trait.\n+//!\n+//! These methods extract the contained value in a [`Result`] when it is\n+//! the [`Err`] variant. They require `T` to implement the [`Debug`] trait.\n+//! If the [`Result`] is [`Ok`]:\n+//!\n+//! * [`expect_err`] panics with a provided custom message\n+//! * [`unwrap_err`] panics with a generic message\n+//!\n+//! [`Debug`]: crate::fmt::Debug\n+//! [`Default`]: crate::default::Default\n+//! [`expect`]: Result::expect\n+//! [`expect_err`]: Result::expect_err\n+//! [`unwrap`]: Result::unwrap\n+//! [`unwrap_err`]: Result::unwrap_err\n+//! [`unwrap_or`]: Result::unwrap_or\n+//! [`unwrap_or_default`]: Result::unwrap_or_default\n+//! [`unwrap_or_else`]: Result::unwrap_or_else\n+//!\n+//! ## Transforming contained values\n+//!\n+//! These transformations are from [`Result`] to [`Option`]:\n+//!\n+//! * [`err`][Result::err] transforms [`Result<T, E>`] into [`Option<E>`],\n+//!   mapping [`Err(e)`] to [`Some(e)`] and [`Ok(v)`] to [`None`]\n+//! * [`ok`][Result::ok] transforms [`Result<T, E>`] into [`Option<T>`],\n+//!   mapping [`Ok(v)`] to [`Some(v)`] and [`Err(e)`] to [`None`]\n+//! * [`transpose`] transposes a [`Result`] of an [`Option`] into an\n+//!   [`Option`] of a [`Result`]\n+//!\n+//! These transformations are on [`Ok`] values:\n+//!\n+//! * [`map`] transforms [`Result<T, E>`] into [`Result<U, E>`] by applying\n+//!   the provided function to the contained value of [`Ok`] and leaving\n+//!   [`Err`] values unchanged\n+//! * [`map_or`] transforms [`Result<T, E>`] into a value of `U` by\n+//!   applying the provided function to the contained value of [`Ok`], or\n+//!   returns the provided default value of `U` if the [`Result`] is\n+//!   [`Err`]\n+//! * [`map_or_else`] transforms [`Result<T, E>`] into a value of `U` by\n+//!   applying the provided function to the contained value of [`Ok`], or\n+//!   applies the provided fallback function to the contained value of\n+//!   [`Err`]\n+//!\n+//! This transformation is on [`Err`] values:\n+//!\n+//! * [`map_err`] transforms [`Result<T, E>`] into [`Result<T, F>`] by\n+//!   applying the provided function to the contained value of [`Err`] and\n+//!   leaving [`Ok`] values unchanged\n+//!\n+//! [`Err(e)`]: Err\n+//! [`Ok(v)`]: Ok\n+//! [`Some(e)`]: Option::Some\n+//! [`Some(v)`]: Option::Some\n+//! [`map`]: Result::map\n+//! [`map_err`]: Result::map_err\n+//! [`map_or`]: Result::map_or\n+//! [`map_or_else`]: Result::map_or_else\n+//! [`transpose`]: Result::transpose\n+//!\n //! ## Boolean operators\n //!\n //! These methods treat the [`Result`] as a boolean value, where [`Ok`]\n@@ -269,6 +366,90 @@\n //! [`and_then`]: Result::and_then\n //! [`or`]: Result::or\n //! [`or_else`]: Result::or_else\n+//!\n+//! ## Iterating over `Result`\n+//!\n+//! A [`Result`] can be iterated over. This can be helpful if you need an\n+//! iterator that is conditionally empty. The iterator will either produce\n+//! a single value (when the [`Result`] is [`Ok`]), or produce no values\n+//! (when the [`Result`] is [`Err`]). For example, [`into_iter`] acts like\n+//! [`once(v)`] if the [`Result`] is [`Ok(v)`], and like [`empty()`] if\n+//! the [`Result`] is [`Err(err)`].\n+//!\n+//! Iterators over [`Result`] come in three types:\n+//!\n+//! * [`into_iter`] consumes the [`Result`] and produces the contained\n+//!   value\n+//! * [`iter`] produces an immutable reference of type `&T` to the\n+//!   contained value\n+//! * [`iter_mut`] produces a mutable reference of type `&mut T` to the\n+//!   contained value\n+//!\n+//! See [Iterating over `Option`] for examples of how this can be useful.\n+//!\n+//! [`Err(err)`]: Err\n+//! [Iterating over `Option`]: crate::option#iterating-over-option\n+//! [`Ok(v)`]: Ok\n+//! [`empty()`]: crate::iter::empty\n+//! [`into_iter`]: Result::into_iter\n+//! [`iter`]: Result::iter\n+//! [`iter_mut`]: Result::iter_mut\n+//! [`once(v)`]: crate::iter::once\n+//!\n+//! You might want to use an iterator chain to do multiple instances of an\n+//! operation that can fail, but would like to ignore failures while\n+//! continuing to process the successful results. In this example, we take\n+//! advantage of the iterable nature of [`Result`] to select only the\n+//! [`Ok`] values using [`flatten`].\n+//!\n+//! [`flatten`]: crate::iter::Iterator::flatten\n+//!\n+//! ```\n+//! # use std::str::FromStr;\n+//! let mut results = vec![];\n+//! let mut errs = vec![];\n+//! let nums: Vec<_> = vec![\"17\", \"not a number\", \"99\", \"-27\", \"768\"]\n+//!    .into_iter()\n+//!    .map(u8::from_str)\n+//!    // Save clones of the raw `Result` values to inspect\n+//!    .inspect(|x| results.push(x.clone()))\n+//!    // Challenge: explain how this captures only the `Err` values\n+//!    .inspect(|x| errs.extend(x.clone().err()))\n+//!    .flatten()\n+//!    .collect();\n+//! assert_eq!(errs.len(), 3);\n+//! assert_eq!(nums, [17, 99]);\n+//! println!(\"results {:?}\", results);\n+//! println!(\"errs {:?}\", errs);\n+//! println!(\"nums {:?}\", nums);\n+//! ```\n+//!\n+//! ## Collecting into `Result`\n+//!\n+//! [`Result`] implements the [`FromIterator`] trait, which allows an\n+//! iterator over [`Result`] values to be collected into a [`Result`] of a\n+//! collection of each contained value of the original [`Result`] values,\n+//! or [`Err`] if any of the elements was [`Err`].\n+//!\n+//! [`FromIterator`]: Result#impl-FromIterator%3CResult%3CA%2C%20E%3E%3E\n+//!\n+//! ```\n+//! let v = vec![Ok(2), Ok(4), Err(\"err!\"), Ok(8)];\n+//! let res: Result<Vec<_>, &str> = v.into_iter().collect();\n+//! assert_eq!(res, Err(\"err!\"));\n+//! let v = vec![Ok(2), Ok(4), Ok(8)];\n+//! let res: Result<Vec<_>, &str> = v.into_iter().collect();\n+//! assert_eq!(res, Ok(vec![2, 4, 8]));\n+//! ```\n+//!\n+//! [`Result`] also implements the [`Product`] and [`Sum`] traits, allowing\n+//! an iterator over [`Result`] values to provide the\n+//! [`product`][m.product] and [`sum`][m.sum] methods.\n+//!\n+//! [`Product`]: Result#impl-Product%3CResult%3CU%2C%20E%3E%3E\n+//! [`Sum`]: Result#impl-Sum%3CResult%3CU%2C%20E%3E%3E\n+//! [m.product]: crate::iter::Iterator::product\n+//! [m.sum]: crate::iter::Iterator::sum\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}