{"sha": "1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlOGY1MDEzNDMyOTllNDFjYzI3ZmIyZWIxNGVjOTBiNjI1ZmQ2ZjY=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-05T00:26:17Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-05T02:16:47Z"}, "message": "Machine types are different from int/uint, etc (Issue #2187)", "tree": {"sha": "176cb8f61c1e0be4ea7e2e3989846b67333179cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/176cb8f61c1e0be4ea7e2e3989846b67333179cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "html_url": "https://github.com/rust-lang/rust/commit/1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f904d278fa3cc8993bd961dea93d99a34e2f3c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f904d278fa3cc8993bd961dea93d99a34e2f3c2", "html_url": "https://github.com/rust-lang/rust/commit/5f904d278fa3cc8993bd961dea93d99a34e2f3c2"}], "stats": {"total": 331, "additions": 200, "deletions": 131}, "files": [{"sha": "4f29e7d982addad8d8a2c29b35483f9e3fcae521", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -25,6 +25,7 @@ io::println(comm::recv(p));\n \"];\n \n import either::either;\n+import libc::size_t;\n \n export port::{};\n export chan::{};\n@@ -66,7 +67,7 @@ enum chan<T: send> {\n \n #[doc = \"Constructs a port\"]\n fn port<T: send>() -> port<T> {\n-    port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>())))\n+    port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>() as size_t)))\n }\n \n impl methods<T: send> for port<T> {\n@@ -109,7 +110,7 @@ resource port_ptr<T: send>(po: *rust_port) unsafe {\n         rustrt::rust_port_end_detach(po);\n \n         // Drain the port so that all the still-enqueued items get dropped\n-        while rustrt::rust_port_size(po) > 0u {\n+        while rustrt::rust_port_size(po) > 0u as size_t {\n             recv_::<T>(po);\n         }\n         rustrt::del_port(po);"}, {"sha": "e0a10bc78899496c24c8f9dff3295a09ac5642af", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -76,6 +76,10 @@ pure fn ge(x: f64, y: f64) -> bool { ret x >= y; }\n \n pure fn gt(x: f64, y: f64) -> bool { ret x > y; }\n \n+pure fn sqrt(x: f64) -> f64 {\n+    cmath::c_double::sqrt(x as libc::c_double) as f64\n+}\n+\n #[doc = \"\n Returns true if `x` is a positive number, including +0.0f640 and +Infinity.\n \"]"}, {"sha": "e922737a8159035b526afc041f3818c1fe4e8d46", "filename": "src/libcore/float.rs", "status": "modified", "additions": 86, "deletions": 20, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -27,6 +27,57 @@ export j0, j1, jn, y0, y1, yn;\n import m_float = f64;\n import f64::*;\n \n+const NaN: float = 0.0/0.0;\n+\n+const infinity: float = 1.0/0.0;\n+\n+const neg_infinity: float = -1.0/0.0;\n+\n+/* Module: consts */\n+mod consts {\n+\n+    // FIXME replace with mathematical constants from cmath\n+    // (requires Issue #1433 to fix)\n+    #[doc = \"Archimedes' constant\"]\n+    const pi: float = 3.14159265358979323846264338327950288;\n+\n+    #[doc = \"pi/2.0\"]\n+    const frac_pi_2: float = 1.57079632679489661923132169163975144;\n+\n+    #[doc = \"pi/4.0\"]\n+    const frac_pi_4: float = 0.785398163397448309615660845819875721;\n+\n+    #[doc = \"1.0/pi\"]\n+    const frac_1_pi: float = 0.318309886183790671537767526745028724;\n+\n+    #[doc = \"2.0/pi\"]\n+    const frac_2_pi: float = 0.636619772367581343075535053490057448;\n+\n+    #[doc = \"2.0/sqrt(pi)\"]\n+    const frac_2_sqrtpi: float = 1.12837916709551257389615890312154517;\n+\n+    #[doc = \"sqrt(2.0)\"]\n+    const sqrt2: float = 1.41421356237309504880168872420969808;\n+\n+    #[doc = \"1.0/sqrt(2.0)\"]\n+    const frac_1_sqrt2: float = 0.707106781186547524400844362104849039;\n+\n+    #[doc = \"Euler's number\"]\n+    const e: float = 2.71828182845904523536028747135266250;\n+\n+    #[doc = \"log2(e)\"]\n+    const log2_e: float = 1.44269504088896340735992468100189214;\n+\n+    #[doc = \"log10(e)\"]\n+    const log10_e: float = 0.434294481903251827651128918916605082;\n+\n+    #[doc = \"ln(2.0)\"]\n+    const ln_2: float = 0.693147180559945309417232121458176568;\n+\n+    #[doc = \"ln(10.0)\"]\n+    const ln_10: float = 2.30258509299404568401799145468436421;\n+}\n+\n /**\n  * Section: String Conversions\n  */\n@@ -178,11 +229,11 @@ where `n` is the floating-point number represented by `[num]`.\n \"]\n fn from_str(num: str) -> option<float> {\n    if num == \"inf\" {\n-       ret some(infinity);\n+       ret some(infinity as float);\n    } else if num == \"-inf\" {\n-       ret some(neg_infinity);\n+       ret some(neg_infinity as float);\n    } else if num == \"NaN\" {\n-       ret some(NaN);\n+       ret some(NaN as float);\n    }\n \n    let mut pos = 0u;               //Current byte position in the string.\n@@ -322,25 +373,40 @@ Compute the exponentiation of an integer by another integer as a float\n `NaN` if both `x` and `pow` are `0u`, otherwise `x^pow`\n \"]\n fn pow_with_uint(base: uint, pow: uint) -> float {\n-   if base == 0u {\n-      if pow == 0u {\n-        ret NaN;\n-      }\n-       ret 0.;\n-   }\n-   let mut my_pow     = pow;\n-   let mut total      = 1f;\n-   let mut multiplier = base as float;\n-   while (my_pow > 0u) {\n-     if my_pow % 2u == 1u {\n-       total = total * multiplier;\n-     }\n-     my_pow     /= 2u;\n-     multiplier *= multiplier;\n-   }\n-   ret total;\n+    if base == 0u {\n+        if pow == 0u {\n+            ret NaN as float;\n+        }\n+        ret 0.;\n+    }\n+    let mut my_pow     = pow;\n+    let mut total      = 1f;\n+    let mut multiplier = base as float;\n+    while (my_pow > 0u) {\n+        if my_pow % 2u == 1u {\n+            total = total * multiplier;\n+        }\n+        my_pow     /= 2u;\n+        multiplier *= multiplier;\n+    }\n+    ret total;\n }\n \n+fn is_positive(x: float) -> bool { f64::is_positive(x as f64) }\n+fn is_negative(x: float) -> bool { f64::is_negative(x as f64) }\n+fn is_nonpositive(x: float) -> bool { f64::is_nonpositive(x as f64) }\n+fn is_nonnegative(x: float) -> bool { f64::is_nonnegative(x as f64) }\n+fn is_zero(x: float) -> bool { f64::is_zero(x as f64) }\n+fn is_infinite(x: float) -> bool { f64::is_infinite(x as f64) }\n+fn is_finite(x: float) -> bool { f64::is_finite(x as f64) }\n+fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n+\n+fn abs(x: float) -> float { f64::abs(x as f64) as float }\n+fn sqrt(x: float) -> float { f64::sqrt(x as f64) as float }\n+fn atan(x: float) -> float { f64::atan(x as f64) as float }\n+fn sin(x: float) -> float { f64::sin(x as f64) as float }\n+fn cos(x: float) -> float { f64::cos(x as f64) as float }\n+fn tan(x: float) -> float { f64::tan(x as f64) as float }\n \n #[test]\n fn test_from_str() {"}, {"sha": "02371ea7625d3f4b903de8d5f2e3301ba182ef0b", "filename": "src/libcore/io.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -7,7 +7,7 @@ Basic input/output\n import result::result;\n \n import dvec::{dvec, extensions};\n-import libc::{c_int, c_uint, c_void, size_t, ssize_t};\n+import libc::{c_int, c_long, c_uint, c_void, size_t, ssize_t};\n import libc::consts::os::posix88::*;\n import libc::consts::os::extra::*;\n \n@@ -196,17 +196,17 @@ impl of reader for *libc::FILE {\n         let mut buf : [mut u8] = [mut];\n         vec::reserve(buf, len);\n         vec::as_mut_buf(buf) {|b|\n-            let read = libc::fread(b as *mut c_void, 1u,\n-                                   len, self);\n-            vec::unsafe::set_len(buf, read);\n+            let read = libc::fread(b as *mut c_void, 1u as size_t,\n+                                   len as size_t, self);\n+            vec::unsafe::set_len(buf, read as uint);\n         }\n         ret vec::from_mut(buf);\n     }\n     fn read_byte() -> int { ret libc::fgetc(self) as int; }\n     fn unread_byte(byte: int) { libc::ungetc(byte as c_int, self); }\n     fn eof() -> bool { ret libc::feof(self) != 0 as c_int; }\n     fn seek(offset: int, whence: seek_style) {\n-        assert libc::fseek(self, offset, convert_whence(whence))\n+        assert libc::fseek(self, offset as c_long, convert_whence(whence))\n             == 0 as c_int;\n     }\n     fn tell() -> uint { ret libc::ftell(self) as uint; }\n@@ -332,7 +332,8 @@ impl <T: writer, C> of writer for {base: T, cleanup: C} {\n impl of writer for *libc::FILE {\n     fn write(v: [const u8]/&) unsafe {\n         vec::unpack_const_slice(v) {|vbuf, len|\n-            let nout = libc::fwrite(vbuf as *c_void, len, 1u, self);\n+            let nout = libc::fwrite(vbuf as *c_void, len as size_t,\n+                                    1u as size_t, self);\n             if nout < 1 as size_t {\n                 #error(\"error writing buffer\");\n                 log(error, os::last_os_error());\n@@ -341,7 +342,7 @@ impl of writer for *libc::FILE {\n         }\n     }\n     fn seek(offset: int, whence: seek_style) {\n-        assert libc::fseek(self, offset, convert_whence(whence))\n+        assert libc::fseek(self, offset as c_long, convert_whence(whence))\n             == 0 as c_int;\n     }\n     fn tell() -> uint { libc::ftell(self) as uint }\n@@ -362,7 +363,7 @@ impl of writer for fd_t {\n         vec::unpack_const_slice(v) {|vbuf, len|\n             while count < len {\n                 let vb = ptr::const_offset(vbuf, count) as *c_void;\n-                let nout = libc::write(self, vb, len);\n+                let nout = libc::write(self, vb, len as size_t);\n                 if nout < 0 as ssize_t {\n                     #error(\"error writing buffer\");\n                     log(error, os::last_os_error());"}, {"sha": "b6861b42eb7bdd0754059fd3bf0a754d170c778b", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -185,8 +185,8 @@ mod types {\n             mod c99 {\n                 type c_longlong = i64;\n                 type c_ulonglong = u64;\n-                type intptr_t = i32;\n-                type uintptr_t = u32;\n+                type intptr_t = int;\n+                type uintptr_t = uint;\n             }\n             mod posix88 {\n                 type off_t = i32;\n@@ -229,8 +229,8 @@ mod types {\n             mod c99 {\n                 type c_longlong = i64;\n                 type c_ulonglong = u64;\n-                type intptr_t = i64;\n-                type uintptr_t = u64;\n+                type intptr_t = int;\n+                type uintptr_t = uint;\n             }\n             mod posix88 {\n                 type off_t = i64;\n@@ -276,8 +276,8 @@ mod types {\n             mod c99 {\n                 type c_longlong = i64;\n                 type c_ulonglong = u64;\n-                type intptr_t = i64;\n-                type uintptr_t = u64;\n+                type intptr_t = int;\n+                type uintptr_t = uint;\n             }\n             mod posix88 {\n                 type off_t = i64;\n@@ -323,8 +323,8 @@ mod types {\n             mod c99 {\n                 type c_longlong = i64;\n                 type c_ulonglong = u64;\n-                type intptr_t = i32;\n-                type uintptr_t = u32;\n+                type intptr_t = int;\n+                type uintptr_t = uint;\n             }\n             mod posix88 {\n                 type off_t = i32;\n@@ -397,8 +397,8 @@ mod types {\n             mod c99 {\n                 type c_longlong = i64;\n                 type c_ulonglong = u64;\n-                type intptr_t = i32;\n-                type uintptr_t = u32;\n+                type intptr_t = int;\n+                type uintptr_t = uint;\n             }\n             mod posix88 {\n                 type off_t = i64;\n@@ -441,8 +441,8 @@ mod types {\n             mod c99 {\n                 type c_longlong = i64;\n                 type c_ulonglong = u64;\n-                type intptr_t = i64;\n-                type uintptr_t = u64;\n+                type intptr_t = int;\n+                type uintptr_t = uint;\n             }\n             mod posix88 {\n                 type off_t = i64;"}, {"sha": "e14b731da868fffa2c4dc351649351e84ac64219", "filename": "src/libcore/os.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -90,11 +90,11 @@ mod win32 {\n         import libc::funcs::extra::kernel32::*;\n         import libc::consts::os::extra::*;\n \n-        let mut n = tmpbuf_sz;\n+        let mut n = tmpbuf_sz as dword;\n         let mut res = none;\n         let mut done = false;\n         while !done {\n-            let buf = vec::to_mut(vec::from_elem(n, 0u16));\n+            let buf = vec::to_mut(vec::from_elem(n as uint, 0u16));\n             vec::as_mut_buf(buf) {|b|\n                 let k : dword = f(b, tmpbuf_sz as dword);\n                 if k == (0 as dword) {\n@@ -412,7 +412,7 @@ fn self_exe_path() -> option<path> {\n         import libc::funcs::extra::kernel32::*;\n         import win32::*;\n         fill_utf16_buf_and_decode() {|buf, sz|\n-            GetModuleFileNameW(0u, buf, sz)\n+            GetModuleFileNameW(0u as dword, buf, sz)\n         }\n     }\n \n@@ -692,16 +692,19 @@ fn copy_file(from: path, to: path) -> bool {\n         let mut ok = true;\n         while !done {\n           vec::as_mut_buf(buf) {|b|\n-            let nread = libc::fread(b as *mut c_void, 1u, bufsize, istream);\n+              let nread = libc::fread(b as *mut c_void, 1u as size_t,\n+                                      bufsize as size_t,\n+                                      istream);\n               if nread > 0 as size_t {\n-                 if libc::fwrite(b as *c_void, 1u, nread, ostream) != nread {\n-                    ok = false;\n-                    done = true;\n-                 }\n+                  if libc::fwrite(b as *c_void, 1u as size_t, nread,\n+                                  ostream) != nread {\n+                      ok = false;\n+                      done = true;\n+                  }\n               } else {\n-                    done = true;\n+                  done = true;\n               }\n-           }\n+          }\n         }\n         fclose(istream);\n         fclose(ostream);\n@@ -988,8 +991,9 @@ mod tests {\n       let s = \"hello\";\n       let mut buf = vec::to_mut(str::bytes(s) + [0 as u8]);\n       vec::as_mut_buf(buf) {|b|\n-         assert (libc::fwrite(b as *c_void, 1u, str::len(s) + 1u, ostream) ==\n-                 buf.len())};\n+          assert (libc::fwrite(b as *c_void, 1u as size_t,\n+                               (str::len(s) + 1u) as size_t, ostream)\n+                  == buf.len() as size_t)};\n       assert (libc::fclose(ostream) == (0u as c_int));\n       let rs = os::copy_file(in, out);\n       if (!os::path_exists(in)) {"}, {"sha": "b90928727b1689eb2c7c1f8a86d66722148b76c5", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -14,7 +14,7 @@ export buf_len;\n export position;\n export extensions;\n \n-import libc::c_void;\n+import libc::{c_void, size_t};\n \n #[nolink]\n #[abi = \"cdecl\"]\n@@ -93,7 +93,7 @@ and destination may not overlap.\n #[inline(always)]\n unsafe fn memcpy<T>(dst: *T, src: *T, count: uint) {\n     let n = count * sys::size_of::<T>();\n-    libc_::memcpy(dst as *c_void, src as *c_void, n);\n+    libc_::memcpy(dst as *c_void, src as *c_void, n as size_t);\n }\n \n #[doc = \"\n@@ -105,7 +105,7 @@ and destination may overlap.\n #[inline(always)]\n unsafe fn memmove<T>(dst: *T, src: *T, count: uint)  {\n     let n = count * sys::size_of::<T>();\n-    libc_::memmove(dst as *c_void, src as *c_void, n);\n+    libc_::memmove(dst as *c_void, src as *c_void, n as size_t);\n }\n \n #[doc = \"Extension methods for pointers\"]"}, {"sha": "7f967ae373d74f1bc7d8aef15704de84e42a42ab", "filename": "src/libcore/str.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -7,6 +7,8 @@ for efficiency, but UTF-8 unsafe operations should be avoided.  For\n some heavy-duty uses, try std::rope.\n \"];\n \n+import libc::size_t;\n+\n export\n    // Creating a string\n    from_bytes,\n@@ -1596,7 +1598,7 @@ capacity, then no action is taken.\n \"]\n fn reserve(&s: str, n: uint) {\n     if capacity(s) < n {\n-        rustrt::str_reserve_shared(s, n);\n+        rustrt::str_reserve_shared(s, n as size_t);\n     }\n }\n "}, {"sha": "3af4dec9b6d0e5860914779991d89310b6f54914", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -1,5 +1,8 @@\n iface to_str { fn to_str() -> str; }\n \n+impl of to_str for int {\n+    fn to_str() -> str { int::str(self) }\n+}\n impl of to_str for i8 {\n     fn to_str() -> str { i8::str(self) }\n }\n@@ -12,6 +15,9 @@ impl of to_str for i32 {\n impl of to_str for i64 {\n     fn to_str() -> str { i64::str(self) }\n }\n+impl of to_str for uint {\n+    fn to_str() -> str { uint::str(self) }\n+}\n impl of to_str for u8 {\n     fn to_str() -> str { u8::str(self) }\n }"}, {"sha": "cce654f0e24bee19e3a1d2a95e54494291d9c256", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -2,6 +2,7 @@\n \n import option::{some, none};\n import ptr::addr_of;\n+import libc::size_t;\n \n export init_op;\n export is_empty;\n@@ -123,7 +124,8 @@ fn reserve<T>(&v: [const T], n: uint) {\n     // Only make the (slow) call into the runtime if we have to\n     if capacity(v) < n {\n         let ptr = ptr::addr_of(v) as **unsafe::vec_repr;\n-        rustrt::vec_reserve_shared(sys::get_type_desc::<T>(), ptr, n);\n+        rustrt::vec_reserve_shared(sys::get_type_desc::<T>(),\n+                                   ptr, n as size_t);\n     }\n }\n \n@@ -1213,7 +1215,7 @@ mod unsafe {\n         ret ::unsafe::reinterpret_cast(\n             rustrt::vec_from_buf_shared(sys::get_type_desc::<T>(),\n                                         ptr as *(),\n-                                        elts));\n+                                        elts as size_t));\n     }\n \n     #[doc = \""}, {"sha": "5133c02b3eab31ee9c78c644169d817318c0b7b2", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -135,13 +135,13 @@ mod tests {\n \n         assert mem as int != 0;\n \n-        ret unsafe { c_vec_with_dtor(mem as *mut u8, n,\n+        ret unsafe { c_vec_with_dtor(mem as *mut u8, n as uint,\n                                      bind free(mem)) };\n     }\n \n     #[test]\n     fn test_basic() {\n-        let cv = malloc(16u);\n+        let cv = malloc(16u as size_t);\n \n         set(cv, 3u, 8u8);\n         set(cv, 4u, 9u8);\n@@ -154,7 +154,7 @@ mod tests {\n     #[should_fail]\n     #[ignore(cfg(target_os = \"win32\"))]\n     fn test_overrun_get() {\n-        let cv = malloc(16u);\n+        let cv = malloc(16u as size_t);\n \n         get(cv, 17u);\n     }\n@@ -163,14 +163,14 @@ mod tests {\n     #[should_fail]\n     #[ignore(cfg(target_os = \"win32\"))]\n     fn test_overrun_set() {\n-        let cv = malloc(16u);\n+        let cv = malloc(16u as size_t);\n \n         set(cv, 17u, 0u8);\n     }\n \n     #[test]\n     fn test_and_I_mean_it() {\n-        let cv = malloc(16u);\n+        let cv = malloc(16u as size_t);\n         let p = unsafe { ptr(cv) };\n \n         set(cv, 0u, 32u8);"}, {"sha": "0b06dd67f762c5d2d698d1ae4bc6c157b479a1c0", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -10,6 +10,7 @@ import comm::*;\n import result::*;\n import str::*;\n import future::*;\n+import libc::size_t;\n \n // data\n export tcp_socket, tcp_conn_port, tcp_err_data;\n@@ -1136,7 +1137,7 @@ crust fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n     let loop_ptr = uv::ll::get_loop_for_uv_handle(stream);\n     let socket_data_ptr = uv::ll::get_data_for_uv_handle(stream)\n         as *tcp_socket_data;\n-    alt nread {\n+    alt nread as int {\n       // incoming err.. probably eof\n       -1 {\n         let err_data = uv::ll::get_last_err_data(loop_ptr).to_tcp_err();\n@@ -1150,11 +1151,11 @@ crust fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n       // have data\n       _ {\n         // we have data\n-        log(debug, #fmt(\"tcp on_read_cb nread: %d\", nread));\n+        log(debug, #fmt(\"tcp on_read_cb nread: %d\", nread as int));\n         let reader_ch = (*socket_data_ptr).reader_ch;\n         let buf_base = uv::ll::get_base_from_buf(buf);\n         let buf_len = uv::ll::get_len_from_buf(buf);\n-        let new_bytes = vec::unsafe::from_buf(buf_base, buf_len);\n+        let new_bytes = vec::unsafe::from_buf(buf_base, buf_len as uint);\n         comm::send(reader_ch, result::ok(new_bytes));\n       }\n     }\n@@ -1171,7 +1172,7 @@ crust fn on_alloc_cb(handle: *libc::c_void,\n                      handle,\n                      char_ptr as uint,\n                      suggested_size as uint));\n-    uv::ll::buf_init(char_ptr, suggested_size)\n+    uv::ll::buf_init(char_ptr, suggested_size as uint)\n }\n \n type tcp_socket_close_data = {"}, {"sha": "18aaebb3fdb0eb1fc53ca2ea08fe90268fc01dc4", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -8,6 +8,7 @@\n import either::either;\n import result::{ok, err};\n import io::writer_util;\n+import libc::size_t;\n \n export test_name;\n export test_fn;\n@@ -322,7 +323,7 @@ const sched_overcommit : uint = 1u;\n const sched_overcommit : uint = 4u;\n \n fn get_concurrency() -> uint {\n-    let threads = rustrt::sched_threads();\n+    let threads = rustrt::sched_threads() as uint;\n     if threads == 1u { 1u }\n     else { threads * sched_overcommit }\n }"}, {"sha": "f6a99f8aa06544f6e6d2f6fee4b3a308b4a3d973", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -20,6 +20,8 @@ This module's implementation will hopefully be, eventually, replaced\n with per-platform, generated source files from rust-bindgen.\n \"];\n \n+import libc::size_t;\n+\n // libuv struct mappings\n type uv_ip4_addr = {\n     ip: [u8],\n@@ -695,8 +697,8 @@ unsafe fn buf_init(++input: *u8, len: uint) -> uv_buf_t {\n                      len as uint,\n                      out_buf_ptr as uint));\n     // yuck :/\n-    rustrt::rust_uv_buf_init(out_buf_ptr, input, len);\n-    //let result = rustrt::rust_uv_buf_init_2(input, len);\n+    rustrt::rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n+    //let result = rustrt::rust_uv_buf_init_2(input, len as size_t);\n     log(debug, \"after rust_uv_buf_init\");\n     let res_base = get_base_from_buf(out_buf);\n     let res_len = get_len_from_buf(out_buf);\n@@ -851,13 +853,15 @@ mod test {\n                          handle,\n                          char_ptr as uint,\n                          suggested_size as uint));\n-        ret buf_init(char_ptr, suggested_size);\n+        ret buf_init(char_ptr, suggested_size as uint);\n     }\n \n     crust fn on_read_cb(stream: *uv_stream_t,\n                         nread: libc::ssize_t,\n                         ++buf: uv_buf_t) unsafe {\n-        log(debug, #fmt(\"CLIENT entering on_read_cb nred: %d\", nread));\n+        let nread = nread as int;\n+        log(debug, #fmt(\"CLIENT entering on_read_cb nred: %d\",\n+                        nread));\n         if (nread > 0) {\n             // we have data\n             log(debug, #fmt(\"CLIENT read: data! nread: %d\", nread));\n@@ -867,7 +871,7 @@ mod test {\n                   as *request_wrapper;\n             let buf_base = get_base_from_buf(buf);\n             let buf_len = get_len_from_buf(buf);\n-            let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n+            let bytes = vec::unsafe::from_buf(buf_base, buf_len as uint);\n             let read_chan = *((*client_data).read_chan);\n             let msg_from_server = str::from_bytes(bytes);\n             comm::send(read_chan, msg_from_server);\n@@ -1029,17 +1033,18 @@ mod test {\n     crust fn on_server_read_cb(client_stream_ptr: *uv_stream_t,\n                                nread: libc::ssize_t,\n                                ++buf: uv_buf_t) unsafe {\n+        let nread = nread as int;\n         if (nread > 0) {\n             // we have data\n             log(debug, #fmt(\"SERVER read: data! nread: %d\", nread));\n \n             // pull out the contents of the write from the client\n             let buf_base = get_base_from_buf(buf);\n-            let buf_len = get_len_from_buf(buf);\n+            let buf_len = get_len_from_buf(buf) as uint;\n             log(debug, #fmt(\"SERVER buf base: %u, len: %u, nread: %d\",\n-                             buf_base as uint,\n-                             buf_len as uint,\n-                             nread));\n+                            buf_base as uint,\n+                            buf_len as uint,\n+                            nread));\n             let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n             let request_str = str::from_bytes(bytes);\n "}, {"sha": "5942cc34c782116acd5d667abf18e1dee750ac64", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -3,7 +3,7 @@ import syntax::ast::*;\n // FIXME this doesn't handle big integer/float literals correctly (nor does\n // the rest of our literal handling)\n enum const_val {\n-    const_float(float),\n+    const_float(f64),\n     const_int(i64),\n     const_uint(u64),\n     const_str(str),\n@@ -111,7 +111,7 @@ fn lit_to_const(lit: @lit) -> const_val {\n       lit_str(s) { const_str(s) }\n       lit_int(n, _) { const_int(n) }\n       lit_uint(n, _) { const_uint(n) }\n-      lit_float(n, _) { const_float(option::get(float::from_str(n))) }\n+      lit_float(n, _) { const_float(option::get(float::from_str(n)) as f64) }\n       lit_nil { const_int(0i64) }\n       lit_bool(b) { const_int(b as i64) }\n     }"}, {"sha": "c83a28a410b7bb5bf6f2df46e80bf6bbd6135bc1", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -1406,11 +1406,20 @@ fn super_tys<C:combine>(\n                  b.to_str(self.infcx())]);\n       }\n \n-      (ty::ty_nil, _) |\n-      (ty::ty_bool, _) |\n       (ty::ty_int(_), _) |\n       (ty::ty_uint(_), _) |\n-      (ty::ty_float(_), _) |\n+      (ty::ty_float(_), _) {\n+        let as = ty::get(a).struct;\n+        let bs = ty::get(b).struct;\n+        if as == bs {\n+            ok(a)\n+        } else {\n+            err(ty::terr_sorts(b, a))\n+        }\n+      }\n+\n+      (ty::ty_nil, _) |\n+      (ty::ty_bool, _) |\n       (ty::ty_str, _) {\n         let cfg = tcx.sess.targ_cfg;\n         if ty::mach_sty(cfg, a) == ty::mach_sty(cfg, b) {"}, {"sha": "91b263f997bde26994ad00c4c7ce041b698b5423", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -36,12 +36,12 @@ pure fn cabs(x: cmplx) -> f64\n \n fn mb(x: cmplx) -> bool\n {\n-    let mut z = {re: 0., im: 0.};\n+    let mut z = {re: 0f64, im: 0f64};\n     let mut i = 0;\n     let mut in = true;\n     while i < 50 {\n         z = z*z + x;\n-        if cabs(z) >= 4. {\n+        if cabs(z) >= 4f64 {\n             in = false;\n             break;\n         }\n@@ -66,12 +66,12 @@ fn fillbyte(x: cmplx, incr: f64) -> u8 {\n fn chanmb(i: uint, size: uint, ch: comm::chan<line>) -> ()\n {\n     let mut crv = [];\n-    let incr = 2./(size as f64);\n-    let y = incr*(i as f64) - 1.;\n-    let xincr = 8.*incr;\n+    let incr = 2f64/(size as f64);\n+    let y = incr*(i as f64) - 1f64;\n+    let xincr = 8f64*incr;\n     for uint::range(0_u, size/8_u) {\n         |j|\n-        let x = {re: xincr*(j as f64) - 1.5, im: y};\n+        let x = {re: xincr*(j as f64) - 1.5f64, im: y};\n         crv += [fillbyte(x, incr)];\n     };\n     comm::send(ch, {i:i, b:crv});"}, {"sha": "93e54db6aa27c7ceab86fb53b8f35f53a638bc16", "filename": "src/test/run-pass/bind-native-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -13,7 +13,7 @@ native mod libc {\n fn main() {\n     let s = \"hello world\\n\";\n     let b = str::bytes(s);\n-    let l = str::len(s);\n+    let l = str::len(s) as core::libc::size_t;\n     let b8 = unsafe { vec::unsafe::to_ptr(b) };\n     libc::write(0i32, b8, l);\n     let a = bind libc::write(0i32, _, _);"}, {"sha": "29d7fab9b9a908a4f8aa3db4100939d968a2ced2", "filename": "src/test/run-pass/core-export-f64-sqrt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Ftest%2Frun-pass%2Fcore-export-f64-sqrt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Ftest%2Frun-pass%2Fcore-export-f64-sqrt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-export-f64-sqrt.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -6,5 +6,5 @@ fn main() {\n \n     let digits: uint = 10 as uint;\n \n-    println( float::to_str( f64::sqrt(42.0), digits) );\n+    println(float::to_str(f64::sqrt(42.0f64) as float, digits));\n }\n\\ No newline at end of file"}, {"sha": "44c1a5d16d7438e949d2d595d85fa2d6c75cffba", "filename": "src/test/run-pass/enum-mach-type-compat.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5f904d278fa3cc8993bd961dea93d99a34e2f3c2/src%2Ftest%2Frun-pass%2Fenum-mach-type-compat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f904d278fa3cc8993bd961dea93d99a34e2f3c2/src%2Ftest%2Frun-pass%2Fenum-mach-type-compat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-mach-type-compat.rs?ref=5f904d278fa3cc8993bd961dea93d99a34e2f3c2", "patch": "@@ -1,34 +0,0 @@\n-// The two functions returning `result` should by type compatibile\n-// even though they use different int types. This will probably\n-// not be true after #2187\n-\n-#[no_core];\n-\n-enum result<T, U> {\n-    ok(T),\n-    err(U)\n-}\n-\n-type error = int;\n-\n-#[cfg(target_arch = \"x86_64\")]\n-fn get_fd() -> result<int, error> {\n-    getsockopt_i64()\n-}\n-\n-#[cfg(target_arch = \"x86_64\")]\n-fn getsockopt_i64() -> result<i64, error> {\n-    fail\n-}\n-\n-#[cfg(target_arch = \"x86\")]\n-fn get_fd() -> result<int, error> {\n-    getsockopt_i32()\n-}\n-\n-#[cfg(target_arch = \"x86\")]\n-fn getsockopt_i32() -> result<i32, error> {\n-    fail\n-}\n-\n-fn main() { }\n\\ No newline at end of file"}, {"sha": "d33e9311a2913d6cfd979342a3628a82ec534e52", "filename": "src/test/run-pass/placement-new-leaky.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Ftest%2Frun-pass%2Fplacement-new-leaky.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Ftest%2Frun-pass%2Fplacement-new-leaky.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fplacement-new-leaky.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -5,7 +5,7 @@ enum malloc_pool = ();\n impl methods for malloc_pool {\n     fn alloc(sz: uint, align: uint) -> *() {\n         unsafe {\n-            unsafe::reinterpret_cast(libc::malloc(sz))\n+            unsafe::reinterpret_cast(libc::malloc(sz as libc::size_t))\n         }\n     }\n }"}, {"sha": "077ca3d51ed3019b8136388cd7378f1faa539165", "filename": "src/test/run-pass/regions-mock-trans-impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -17,7 +17,7 @@ type ccx = {\n \n impl arena for arena {\n     fn alloc(sz: uint, _align: uint) -> *() unsafe {\n-        ret unsafe::reinterpret_cast(libc::malloc(sz));\n+        ret unsafe::reinterpret_cast(libc::malloc(sz as libc::size_t));\n     }\n }\n "}, {"sha": "646456301d588229300df5b7c245cd89ae3fe502", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -16,7 +16,8 @@ type ccx = {\n };\n \n fn alloc(_bcx : &a.arena) -> &a.bcx unsafe {\n-    ret unsafe::reinterpret_cast(libc::malloc(sys::size_of::<bcx/&blk>()));\n+    ret unsafe::reinterpret_cast(\n+        libc::malloc(sys::size_of::<bcx/&blk>() as libc::size_t));\n }\n \n fn h(bcx : &a.bcx) -> &a.bcx {"}, {"sha": "63385b8e4d51a615c9503f1dcb0ea53e975c31e9", "filename": "src/test/run-pass/struct-return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e8f501343299e41cc27fb2eb14ec90b625fd6f6/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-return.rs?ref=1e8f501343299e41cc27fb2eb14ec90b625fd6f6", "patch": "@@ -32,9 +32,9 @@ fn test2() {\n     #error(\"a: %f\", ff.a as float);\n     #error(\"b: %u\", ff.b as uint);\n     #error(\"c: %f\", ff.c as float);\n-    assert ff.a == f.c + 1.0;\n+    assert ff.a == f.c + 1.0f64;\n     assert ff.b == 0xff_u8;\n-    assert ff.c == f.a - 1.0;\n+    assert ff.c == f.a - 1.0f64;\n }\n \n #[cfg(target_arch = \"x86\")]"}]}