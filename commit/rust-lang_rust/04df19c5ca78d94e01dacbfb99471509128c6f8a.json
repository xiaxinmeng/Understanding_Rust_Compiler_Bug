{"sha": "04df19c5ca78d94e01dacbfb99471509128c6f8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0ZGYxOWM1Y2E3OGQ5NGUwMWRhY2JmYjk5NDcxNTA5MTI4YzZmOGE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-02T18:47:23Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-19T18:53:33Z"}, "message": "librustc: Take primitive types out of the type hash table.", "tree": {"sha": "751a1c3d348969509c5484c87437e89250006c28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/751a1c3d348969509c5484c87437e89250006c28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04df19c5ca78d94e01dacbfb99471509128c6f8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04df19c5ca78d94e01dacbfb99471509128c6f8a", "html_url": "https://github.com/rust-lang/rust/commit/04df19c5ca78d94e01dacbfb99471509128c6f8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04df19c5ca78d94e01dacbfb99471509128c6f8a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ffaaab9e9e3a2437fd9ed5b04cf3ba3695cc2d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ffaaab9e9e3a2437fd9ed5b04cf3ba3695cc2d2", "html_url": "https://github.com/rust-lang/rust/commit/3ffaaab9e9e3a2437fd9ed5b04cf3ba3695cc2d2"}], "stats": {"total": 158, "additions": 133, "deletions": 25}, "files": [{"sha": "72c2cfedd986edcb7c5836461eeda70e9a25f4b1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 133, "deletions": 25, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/04df19c5ca78d94e01dacbfb99471509128c6f8a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04df19c5ca78d94e01dacbfb99471509128c6f8a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=04df19c5ca78d94e01dacbfb99471509128c6f8a", "patch": "@@ -307,7 +307,7 @@ struct ctxt_ {\n     used_unsafe: @mut HashSet<ast::node_id>,\n }\n \n-enum tbox_flag {\n+pub enum tbox_flag {\n     has_params = 1,\n     has_self = 2,\n     needs_infer = 4,\n@@ -320,9 +320,9 @@ enum tbox_flag {\n     needs_subst = 1 | 2 | 8\n }\n \n-type t_box = &'static t_box_;\n+pub type t_box = &'static t_box_;\n \n-struct t_box_ {\n+pub struct t_box_ {\n     sty: sty,\n     id: uint,\n     flags: uint,\n@@ -513,6 +513,57 @@ pub struct substs {\n     tps: ~[t]\n }\n \n+mod primitives {\n+    use super::{sty, t_box_};\n+\n+    use core::option::None;\n+    use syntax::ast;\n+\n+    macro_rules! def_prim_ty(\n+        ($name:ident, $sty:expr, $id:expr) => (\n+            pub static $name: t_box_ = t_box_ {\n+                sty: $sty,\n+                id: $id,\n+                flags: 0,\n+                o_def_id: None,\n+            };\n+        )\n+    )\n+\n+    def_prim_ty!(TY_NIL,    super::ty_nil,                  0)\n+    def_prim_ty!(TY_BOOL,   super::ty_bool,                 1)\n+    def_prim_ty!(TY_INT,    super::ty_int(ast::ty_i),       2)\n+    def_prim_ty!(TY_CHAR,   super::ty_int(ast::ty_char),    3)\n+    def_prim_ty!(TY_I8,     super::ty_int(ast::ty_i8),      4)\n+    def_prim_ty!(TY_I16,    super::ty_int(ast::ty_i16),     5)\n+    def_prim_ty!(TY_I32,    super::ty_int(ast::ty_i32),     6)\n+    def_prim_ty!(TY_I64,    super::ty_int(ast::ty_i64),     7)\n+    def_prim_ty!(TY_UINT,   super::ty_uint(ast::ty_u),      8)\n+    def_prim_ty!(TY_U8,     super::ty_uint(ast::ty_u8),     9)\n+    def_prim_ty!(TY_U16,    super::ty_uint(ast::ty_u16),    10)\n+    def_prim_ty!(TY_U32,    super::ty_uint(ast::ty_u32),    11)\n+    def_prim_ty!(TY_U64,    super::ty_uint(ast::ty_u64),    12)\n+    def_prim_ty!(TY_FLOAT,  super::ty_float(ast::ty_f),     13)\n+    def_prim_ty!(TY_F32,    super::ty_float(ast::ty_f32),   14)\n+    def_prim_ty!(TY_F64,    super::ty_float(ast::ty_f64),   15)\n+\n+    pub static TY_BOT: t_box_ = t_box_ {\n+        sty: super::ty_bot,\n+        id: 16,\n+        flags: super::has_ty_bot as uint,\n+        o_def_id: None,\n+    };\n+\n+    pub static TY_ERR: t_box_ = t_box_ {\n+        sty: super::ty_err,\n+        id: 17,\n+        flags: super::has_ty_err as uint,\n+        o_def_id: None,\n+    };\n+\n+    pub static LAST_PRIMITIVE_ID: uint = 18;\n+}\n+\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n #[deriving(Eq)]\n@@ -852,7 +903,7 @@ pub fn mk_ctxt(s: session::Session,\n     @ctxt_ {\n         diag: s.diagnostic(),\n         interner: @mut HashMap::new(),\n-        next_id: @mut 0,\n+        next_id: @mut primitives::LAST_PRIMITIVE_ID,\n         vecs_implicitly_copyable: vecs_implicitly_copyable,\n         legacy_modes: legacy_modes,\n         cstore: s.cstore,\n@@ -901,6 +952,17 @@ fn mk_t(cx: ctxt, +st: sty) -> t { mk_t_with_id(cx, st, None) }\n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n+    // Check for primitive types.\n+    match st {\n+        ty_nil => return mk_nil(cx),\n+        ty_err => return mk_err(cx),\n+        ty_bool => return mk_bool(cx),\n+        ty_int(i) => return mk_mach_int(cx, i),\n+        ty_uint(u) => return mk_mach_uint(cx, u),\n+        ty_float(f) => return mk_mach_float(cx, f),\n+        _ => {}\n+    };\n+\n     let key = intern_key { sty: to_unsafe_ptr(&st), o_def_id: o_def_id };\n     match cx.interner.find(&key) {\n       Some(t) => unsafe { return cast::transmute(&t.sty); },\n@@ -996,49 +1058,95 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n     }\n }\n \n-pub fn mk_nil(cx: ctxt) -> t { mk_t(cx, ty_nil) }\n+#[inline(always)]\n+pub fn mk_prim_t(cx: ctxt, primitive: &'static t_box_) -> t {\n+    unsafe {\n+        cast::transmute::<&'static t_box_, t>(primitive)\n+    }\n+}\n+\n+#[inline(always)]\n+pub fn mk_nil(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_NIL) }\n \n-pub fn mk_err(cx: ctxt) -> t { mk_t(cx, ty_err) }\n+#[inline(always)]\n+pub fn mk_err(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_ERR) }\n \n-pub fn mk_bot(cx: ctxt) -> t { mk_t(cx, ty_bot) }\n+#[inline(always)]\n+pub fn mk_bot(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_BOT) }\n \n-pub fn mk_bool(cx: ctxt) -> t { mk_t(cx, ty_bool) }\n+#[inline(always)]\n+pub fn mk_bool(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_BOOL) }\n \n-pub fn mk_int(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i)) }\n+#[inline(always)]\n+pub fn mk_int(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_INT) }\n \n-pub fn mk_i8(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i8)) }\n+#[inline(always)]\n+pub fn mk_i8(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_I8) }\n \n-pub fn mk_i16(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i16)) }\n+#[inline(always)]\n+pub fn mk_i16(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_I16) }\n \n-pub fn mk_i32(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i32)) }\n+#[inline(always)]\n+pub fn mk_i32(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_I32) }\n \n-pub fn mk_i64(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i64)) }\n+#[inline(always)]\n+pub fn mk_i64(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_I64) }\n \n-pub fn mk_float(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f)) }\n+#[inline(always)]\n+pub fn mk_float(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_FLOAT) }\n \n-pub fn mk_uint(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u)) }\n+#[inline(always)]\n+pub fn mk_f32(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_F32) }\n \n-pub fn mk_u8(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u8)) }\n+#[inline(always)]\n+pub fn mk_f64(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_F64) }\n \n-pub fn mk_u16(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u16)) }\n+#[inline(always)]\n+pub fn mk_uint(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_UINT) }\n \n-pub fn mk_u32(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u32)) }\n+#[inline(always)]\n+pub fn mk_u8(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_U8) }\n \n-pub fn mk_u64(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u64)) }\n+#[inline(always)]\n+pub fn mk_u16(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_U16) }\n \n-pub fn mk_f32(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f32)) }\n+#[inline(always)]\n+pub fn mk_u32(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_U32) }\n \n-pub fn mk_f64(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f64)) }\n+#[inline(always)]\n+pub fn mk_u64(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_U64) }\n \n-pub fn mk_mach_int(cx: ctxt, tm: ast::int_ty) -> t { mk_t(cx, ty_int(tm)) }\n+pub fn mk_mach_int(cx: ctxt, tm: ast::int_ty) -> t {\n+    match tm {\n+        ast::ty_i    => mk_int(cx),\n+        ast::ty_char => mk_char(cx),\n+        ast::ty_i8   => mk_i8(cx),\n+        ast::ty_i16  => mk_i16(cx),\n+        ast::ty_i32  => mk_i32(cx),\n+        ast::ty_i64  => mk_i64(cx),\n+    }\n+}\n \n-pub fn mk_mach_uint(cx: ctxt, tm: ast::uint_ty) -> t { mk_t(cx, ty_uint(tm)) }\n+pub fn mk_mach_uint(cx: ctxt, tm: ast::uint_ty) -> t {\n+    match tm {\n+        ast::ty_u    => mk_uint(cx),\n+        ast::ty_u8   => mk_u8(cx),\n+        ast::ty_u16  => mk_u16(cx),\n+        ast::ty_u32  => mk_u32(cx),\n+        ast::ty_u64  => mk_u64(cx),\n+    }\n+}\n \n pub fn mk_mach_float(cx: ctxt, tm: ast::float_ty) -> t {\n-    mk_t(cx, ty_float(tm))\n+    match tm {\n+        ast::ty_f    => mk_float(cx),\n+        ast::ty_f32  => mk_f32(cx),\n+        ast::ty_f64  => mk_f64(cx),\n+    }\n }\n \n-pub fn mk_char(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_char)) }\n+#[inline(always)]\n+pub fn mk_char(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_CHAR) }\n \n pub fn mk_estr(cx: ctxt, t: vstore) -> t {\n     mk_t(cx, ty_estr(t))"}]}