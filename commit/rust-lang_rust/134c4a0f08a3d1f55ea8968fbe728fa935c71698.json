{"sha": "134c4a0f08a3d1f55ea8968fbe728fa935c71698", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNGM0YTBmMDhhM2QxZjU1ZWE4OTY4ZmJlNzI4ZmE5MzVjNzE2OTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-20T15:58:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-20T15:58:10Z"}, "message": "Auto merge of #39628 - arielb1:shimmir, r=eddyb\n\nTranslate shims using MIR\n\nThis removes one large remaining part of old trans.", "tree": {"sha": "f965ee88718069e91c5398a6084d33c64f4c03dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f965ee88718069e91c5398a6084d33c64f4c03dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/134c4a0f08a3d1f55ea8968fbe728fa935c71698", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/134c4a0f08a3d1f55ea8968fbe728fa935c71698", "html_url": "https://github.com/rust-lang/rust/commit/134c4a0f08a3d1f55ea8968fbe728fa935c71698", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/134c4a0f08a3d1f55ea8968fbe728fa935c71698/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "244f893ed704a60841d4615445d540a21a8d7722", "url": "https://api.github.com/repos/rust-lang/rust/commits/244f893ed704a60841d4615445d540a21a8d7722", "html_url": "https://github.com/rust-lang/rust/commit/244f893ed704a60841d4615445d540a21a8d7722"}, {"sha": "5dc8548050514b0781af7b21a4706552da18dd50", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dc8548050514b0781af7b21a4706552da18dd50", "html_url": "https://github.com/rust-lang/rust/commit/5dc8548050514b0781af7b21a4706552da18dd50"}], "stats": {"total": 5966, "additions": 2797, "deletions": 3169}, "files": [{"sha": "1ae8b6bb45113b45a491d5868a059de76d799691", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -46,8 +46,13 @@\n             issue = \"0\")]\n #![allow(missing_docs)]\n \n-extern \"rust-intrinsic\" {\n+#[cfg(not(stage0))]\n+#[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n+#[rustc_deprecated(reason = \"no longer an intrinsic - use `ptr::drop_in_place` directly\",\n+                   since = \"1.18.0\")]\n+pub use ptr::drop_in_place;\n \n+extern \"rust-intrinsic\" {\n     // NB: These intrinsics take raw pointers because they mutate aliased\n     // memory, which is not valid for either `&` or `&mut`.\n \n@@ -622,6 +627,7 @@ extern \"rust-intrinsic\" {\n     pub fn size_of_val<T: ?Sized>(_: &T) -> usize;\n     pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;\n \n+    #[cfg(stage0)]\n     /// Executes the destructor (if any) of the pointed-to value.\n     ///\n     /// This has two use cases:"}, {"sha": "f4eb141385040629d9008c60330808836a8ad08d", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -37,9 +37,38 @@ pub use intrinsics::copy;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::write_bytes;\n \n+#[cfg(stage0)]\n #[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n pub use intrinsics::drop_in_place;\n \n+#[cfg(not(stage0))]\n+/// Executes the destructor (if any) of the pointed-to value.\n+///\n+/// This has two use cases:\n+///\n+/// * It is *required* to use `drop_in_place` to drop unsized types like\n+///   trait objects, because they can't be read out onto the stack and\n+///   dropped normally.\n+///\n+/// * It is friendlier to the optimizer to do this over `ptr::read` when\n+///   dropping manually allocated memory (e.g. when writing Box/Rc/Vec),\n+///   as the compiler doesn't need to prove that it's sound to elide the\n+///   copy.\n+///\n+/// # Undefined Behavior\n+///\n+/// This has all the same safety problems as `ptr::read` with respect to\n+/// invalid pointers, types, and double drops.\n+#[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n+#[lang=\"drop_in_place\"]\n+#[inline]\n+#[allow(unconditional_recursion)]\n+pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+    // Code here does not matter - this is replaced by the\n+    // real drop glue by the compiler.\n+    drop_in_place(to_drop);\n+}\n+\n /// Creates a null raw pointer.\n ///\n /// # Examples"}, {"sha": "399af258e925167767be1ea6f3417141bfee6ae4", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -89,6 +89,7 @@ pub enum DepNode<D: Clone + Debug> {\n     // things read/modify that MIR.\n     MirKrate,\n     Mir(D),\n+    MirShim(Vec<D>),\n \n     BorrowCheckKrate,\n     BorrowCheck(D),\n@@ -258,6 +259,10 @@ impl<D: Clone + Debug> DepNode<D> {\n             IntrinsicCheck(ref d) => op(d).map(IntrinsicCheck),\n             MatchCheck(ref d) => op(d).map(MatchCheck),\n             Mir(ref d) => op(d).map(Mir),\n+            MirShim(ref def_ids) => {\n+                let def_ids: Option<Vec<E>> = def_ids.iter().map(op).collect();\n+                def_ids.map(MirShim)\n+            }\n             BorrowCheck(ref d) => op(d).map(BorrowCheck),\n             RvalueCheck(ref d) => op(d).map(RvalueCheck),\n             StabilityCheck(ref d) => op(d).map(StabilityCheck),"}, {"sha": "81a415a2f530964427287920165122471f528701", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -335,7 +335,7 @@ language_item_table! {\n \n     ExchangeMallocFnLangItem,        \"exchange_malloc\",         exchange_malloc_fn;\n     BoxFreeFnLangItem,               \"box_free\",                box_free_fn;\n-    StrDupUniqFnLangItem,            \"strdup_uniq\",             strdup_uniq_fn;\n+    DropInPlaceFnLangItem,             \"drop_in_place\",           drop_in_place_fn;\n \n     StartFnLangItem,                 \"start\",                   start_fn;\n \n@@ -355,8 +355,6 @@ language_item_table! {\n     ContravariantLifetimeItem,       \"contravariant_lifetime\",  contravariant_lifetime;\n     InvariantLifetimeItem,           \"invariant_lifetime\",      invariant_lifetime;\n \n-    NoCopyItem,                      \"no_copy_bound\",           no_copy_bound;\n-\n     NonZeroItem,                     \"non_zero\",                non_zero;\n \n     DebugTraitLangItem,              \"debug_trait\",             debug_trait;"}, {"sha": "33df648f172d625c248406fed56c259461af1171", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -17,7 +17,7 @@ use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccesso\n use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n-use ty::subst::Substs;\n+use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, ClosureSubsts, Region, Ty};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use util::ppaux;\n@@ -982,6 +982,22 @@ impl<'tcx> Debug for Operand<'tcx> {\n     }\n }\n \n+impl<'tcx> Operand<'tcx> {\n+    pub fn item<'a>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+                    def_id: DefId,\n+                    substs: &'tcx Substs<'tcx>,\n+                    span: Span)\n+                    -> Self\n+    {\n+        Operand::Constant(Constant {\n+            span: span,\n+            ty: tcx.item_type(def_id).subst(tcx, substs),\n+            literal: Literal::Item { def_id, substs }\n+        })\n+    }\n+\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n /// Rvalues\n "}, {"sha": "c71fc28b4d6b3a71776fae56652048f8d484078b", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -40,7 +40,7 @@ pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n pub use self::specialize::{OverlapError, specialization_graph, specializes, translate_substs};\n-pub use self::specialize::{SpecializesCache, find_method};\n+pub use self::specialize::{SpecializesCache, find_associated_item};\n pub use self::util::elaborate_predicates;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;"}, {"sha": "50a4d982832ace739c8c78b7afac69938d07f6c7", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -29,8 +29,6 @@ use traits::{self, Reveal, ObligationCause};\n use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n \n-use syntax::ast;\n-\n pub mod specialization_graph;\n \n /// Information pertinent to an overlapping impl error.\n@@ -106,22 +104,23 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n /// Given a selected impl described by `impl_data`, returns the\n-/// definition and substitions for the method with the name `name`,\n-/// and trait method substitutions `substs`, in that impl, a less\n-/// specialized impl, or the trait default, whichever applies.\n-pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             name: ast::Name,\n-                             substs: &'tcx Substs<'tcx>,\n-                             impl_data: &super::VtableImplData<'tcx, ()>)\n-                             -> (DefId, &'tcx Substs<'tcx>)\n-{\n+/// definition and substitions for the method with the name `name`\n+/// the kind `kind`, and trait method substitutions `substs`, in\n+/// that impl, a less specialized impl, or the trait default,\n+/// whichever applies.\n+pub fn find_associated_item<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    item: &ty::AssociatedItem,\n+    substs: &'tcx Substs<'tcx>,\n+    impl_data: &super::VtableImplData<'tcx, ()>,\n+) -> (DefId, &'tcx Substs<'tcx>) {\n     assert!(!substs.needs_infer());\n \n     let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n     let trait_def = tcx.lookup_trait_def(trait_def_id);\n \n     let ancestors = trait_def.ancestors(impl_data.impl_def_id);\n-    match ancestors.defs(tcx, name, ty::AssociatedKind::Method).next() {\n+    match ancestors.defs(tcx, item.name, item.kind).next() {\n         Some(node_item) => {\n             let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n@@ -137,7 +136,7 @@ pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             (node_item.item.def_id, substs)\n         }\n         None => {\n-            bug!(\"method {:?} not found in {:?}\", name, impl_data.impl_def_id)\n+            bug!(\"{:?} not found in {:?}\", item, impl_data.impl_def_id)\n         }\n     }\n }"}, {"sha": "5543223105b444c37f5d8e512588661627c094a1", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -1469,6 +1469,15 @@ impl<T, R> InternIteratorElement<T, R> for T {\n     }\n }\n \n+impl<'a, T, R> InternIteratorElement<T, R> for &'a T\n+    where T: Clone + 'a\n+{\n+    type Output = R;\n+    fn intern_with<I: Iterator<Item=Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n+        f(&iter.cloned().collect::<AccumulateVec<[_; 8]>>())\n+    }\n+}\n+\n impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n     type Output = Result<R, E>;\n     fn intern_with<I: Iterator<Item=Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {"}, {"sha": "67287f1b4ff72bf0ae9618f4c0deb014e1a26b05", "filename": "src/librustc/ty/instance.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use dep_graph::DepNode;\n+use hir::def_id::DefId;\n+use ty::{self, Ty, TypeFoldable, Substs};\n+use util::ppaux;\n+\n+use std::borrow::Cow;\n+use std::fmt;\n+use syntax::ast;\n+\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct Instance<'tcx> {\n+    pub def: InstanceDef<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum InstanceDef<'tcx> {\n+    Item(DefId),\n+    Intrinsic(DefId),\n+    // <fn() as FnTrait>::call_*\n+    // def-id is FnTrait::call_*\n+    FnPtrShim(DefId, Ty<'tcx>),\n+    // <Trait as Trait>::fn\n+    Virtual(DefId, usize),\n+    // <[mut closure] as FnOnce>::call_once\n+    ClosureOnceShim { call_once: DefId },\n+    // drop_in_place::<T>; None for empty drop glue.\n+    DropGlue(DefId, Option<Ty<'tcx>>),\n+}\n+\n+impl<'tcx> InstanceDef<'tcx> {\n+    #[inline]\n+    pub fn def_id(&self) -> DefId {\n+        match *self {\n+            InstanceDef::Item(def_id) |\n+            InstanceDef::FnPtrShim(def_id, _) |\n+            InstanceDef::Virtual(def_id, _) |\n+            InstanceDef::Intrinsic(def_id, ) |\n+            InstanceDef::ClosureOnceShim { call_once: def_id }\n+                => def_id,\n+            InstanceDef::DropGlue(def_id, _) => def_id\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn def_ty<'a>(&self, tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+        tcx.item_type(self.def_id())\n+    }\n+\n+    #[inline]\n+    pub fn attrs<'a>(&self, tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> Cow<'tcx, [ast::Attribute]> {\n+        tcx.get_attrs(self.def_id())\n+    }\n+\n+    pub(crate) fn dep_node(&self) -> DepNode<DefId> {\n+        // HACK: def-id binning, project-style; someone replace this with\n+        // real on-demand.\n+        let ty = match self {\n+            &InstanceDef::FnPtrShim(_, ty) => Some(ty),\n+            &InstanceDef::DropGlue(_, ty) => ty,\n+            _ => None\n+        }.into_iter();\n+\n+        DepNode::MirShim(\n+            Some(self.def_id()).into_iter().chain(\n+                ty.flat_map(|t| t.walk()).flat_map(|t| match t.sty {\n+                   ty::TyAdt(adt_def, _) => Some(adt_def.did),\n+                   ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n+                   _ => None,\n+               })\n+            ).collect()\n+        )\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for Instance<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ppaux::parameterized(f, self.substs, self.def_id(), &[])?;\n+        match self.def {\n+            InstanceDef::Item(_) => Ok(()),\n+            InstanceDef::Intrinsic(_) => {\n+                write!(f, \" - intrinsic\")\n+            }\n+            InstanceDef::Virtual(_, num) => {\n+                write!(f, \" - shim(#{})\", num)\n+            }\n+            InstanceDef::FnPtrShim(_, ty) => {\n+                write!(f, \" - shim({:?})\", ty)\n+            }\n+            InstanceDef::ClosureOnceShim { .. } => {\n+                write!(f, \" - shim\")\n+            }\n+            InstanceDef::DropGlue(_, ty) => {\n+                write!(f, \" - shim({:?})\", ty)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> Instance<'tcx> {\n+    pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>)\n+               -> Instance<'tcx> {\n+        assert!(substs.is_normalized_for_trans() && !substs.has_escaping_regions(),\n+                \"substs of instance {:?} not normalized for trans: {:?}\",\n+                def_id, substs);\n+        Instance { def: InstanceDef::Item(def_id), substs: substs }\n+    }\n+\n+    pub fn mono(tcx: ty::TyCtxt<'a, 'tcx, 'b>, def_id: DefId) -> Instance<'tcx> {\n+        Instance::new(def_id, tcx.global_tcx().empty_substs_for_def_id(def_id))\n+    }\n+\n+    #[inline]\n+    pub fn def_id(&self) -> DefId {\n+        self.def.def_id()\n+    }\n+}"}, {"sha": "ac8c38c7d585664d05d58efd4832d59e7a61e38e", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n-use hir::def_id::{CrateNum, DefId};\n+use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use middle::const_val::ConstVal;\n use mir;\n use ty::{self, Ty, TyCtxt};\n@@ -24,6 +24,16 @@ trait Key {\n     fn default_span(&self, tcx: TyCtxt) -> Span;\n }\n \n+impl<'tcx> Key for ty::InstanceDef<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(self.def_id())\n+    }\n+}\n+\n impl Key for CrateNum {\n     fn map_crate(&self) -> CrateNum {\n         *self\n@@ -83,9 +93,9 @@ impl<'tcx> Value<'tcx> for Ty<'tcx> {\n     }\n }\n \n-pub struct CycleError<'a> {\n+pub struct CycleError<'a, 'tcx: 'a> {\n     span: Span,\n-    cycle: RefMut<'a, [(Span, Query)]>,\n+    cycle: RefMut<'a, [(Span, Query<'tcx>)]>,\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -110,8 +120,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n-    fn cycle_check<F, R>(self, span: Span, query: Query, compute: F)\n-                         -> Result<R, CycleError<'a>>\n+    fn cycle_check<F, R>(self, span: Span, query: Query<'gcx>, compute: F)\n+                         -> Result<R, CycleError<'a, 'gcx>>\n         where F: FnOnce() -> R\n     {\n         {\n@@ -172,13 +182,20 @@ impl<'tcx> QueryDescription for queries::coherent_inherent_impls<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::mir_shims<'tcx> {\n+    fn describe(tcx: TyCtxt, def: ty::InstanceDef<'tcx>) -> String {\n+        format!(\"generating MIR shim for `{}`\",\n+                tcx.item_path_str(def.def_id()))\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n        pub $name:ident: $node:ident($K:ty) -> $V:ty),*) => {\n         pub struct Maps<$tcx> {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n-            query_stack: RefCell<Vec<(Span, Query)>>,\n+            query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n             $($(#[$attr])* pub $name: RefCell<DepTrackingMap<queries::$name<$tcx>>>),*\n         }\n \n@@ -196,11 +213,11 @@ macro_rules! define_maps {\n \n         #[allow(bad_style)]\n         #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-        pub enum Query {\n+        pub enum Query<$tcx> {\n             $($(#[$attr])* $name($K)),*\n         }\n \n-        impl Query {\n+        impl<$tcx> Query<$tcx> {\n             pub fn describe(&self, tcx: TyCtxt) -> String {\n                 match *self {\n                     $(Query::$name(key) => queries::$name::describe(tcx, key)),*\n@@ -233,7 +250,7 @@ macro_rules! define_maps {\n                                   mut span: Span,\n                                   key: $K,\n                                   f: F)\n-                                  -> Result<R, CycleError<'a>>\n+                                  -> Result<R, CycleError<'a, $tcx>>\n                 where F: FnOnce(&$V) -> R\n             {\n                 if let Some(result) = tcx.maps.$name.borrow().get(&key) {\n@@ -256,7 +273,7 @@ macro_rules! define_maps {\n             }\n \n             pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n-                           -> Result<$V, CycleError<'a>> {\n+                           -> Result<$V, CycleError<'a, $tcx>> {\n                 Self::try_get_with(tcx, span, key, Clone::clone)\n             }\n \n@@ -387,7 +404,9 @@ define_maps! { <'tcx>\n \n     /// Results of evaluating monomorphic constants embedded in\n     /// other items, such as enum variant explicit discriminants.\n-    pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> Result<ConstVal<'tcx>, ()>\n+    pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> Result<ConstVal<'tcx>, ()>,\n+\n+    pub mir_shims: mir_shim(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -397,3 +416,7 @@ fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n fn coherent_inherent_impls_dep_node(_: CrateNum) -> DepNode<DefId> {\n     DepNode::Coherence\n }\n+\n+fn mir_shim(instance: ty::InstanceDef) -> DepNode<DefId> {\n+    instance.dep_node()\n+}"}, {"sha": "c4192ffc697cecefaad97bae83db8aaddf5b5be1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -73,6 +73,8 @@ pub use self::contents::TypeContents;\n pub use self::context::{TyCtxt, GlobalArenas, tls};\n pub use self::context::{Lift, TypeckTables};\n \n+pub use self::instance::{Instance, InstanceDef};\n+\n pub use self::trait_def::{TraitDef, TraitFlags};\n \n pub use self::maps::queries;\n@@ -98,6 +100,7 @@ pub mod util;\n mod contents;\n mod context;\n mod flags;\n+mod instance;\n mod structural_impls;\n mod sty;\n \n@@ -1264,10 +1267,17 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                                                     def_id,\n                                                     ROOT_CODE_EXTENT)\n             }\n-            _ => {\n+            Some(hir_map::NodeStructCtor(..)) |\n+            Some(hir_map::NodeVariant(..)) => {\n+                let def_id = tcx.hir.local_def_id(id);\n+                tcx.construct_parameter_environment(tcx.hir.span(id),\n+                                                    def_id,\n+                                                    ROOT_CODE_EXTENT)\n+            }\n+            it => {\n                 bug!(\"ParameterEnvironment::from_item(): \\\n-                      `{}` is not an item\",\n-                     tcx.hir.node_to_string(id))\n+                      `{}` = {:?} is unsupported\",\n+                     tcx.hir.node_to_string(id), it)\n             }\n         }\n     }\n@@ -2302,6 +2312,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         queries::mir::get(self, DUMMY_SP, did).borrow()\n     }\n \n+    /// Return the possibly-auto-generated MIR of a (DefId, Subst) pair.\n+    pub fn instance_mir(self, instance: ty::InstanceDef<'gcx>)\n+                        -> Ref<'gcx, Mir<'gcx>>\n+    {\n+        match instance {\n+            ty::InstanceDef::Item(did) if true => self.item_mir(did),\n+            _ => queries::mir_shims::get(self, DUMMY_SP, instance).borrow(),\n+        }\n+    }\n+\n     /// Given the DefId of an item, returns its MIR, borrowed immutably.\n     /// Returns None if there is no MIR for the DefId\n     pub fn maybe_item_mir(self, did: DefId) -> Option<Ref<'gcx, Mir<'gcx>>> {"}, {"sha": "1d816d342c4fd3f3b53f7c9046bf0c431d3af3e8", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -398,6 +398,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n         def_id\n     }\n+\n+    /// Given the def-id of some item that has no type parameters, make\n+    /// a suitable \"empty substs\" for it.\n+    pub fn empty_substs_for_def_id(self, item_def_id: DefId) -> &'tcx ty::Substs<'tcx> {\n+        ty::Substs::for_item(self, item_def_id,\n+                             |_, _| self.mk_region(ty::ReErased),\n+                             |_, _| {\n+            bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n+        })\n+    }\n }\n \n pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, W> {"}, {"sha": "7f95f07f48d4ab3d6f062abb33a4aff6046ba779", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/graphviz.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -15,6 +15,7 @@ use rustc::mir::{BasicBlock, Mir};\n use rustc_data_structures::bitslice::bits_to_string;\n use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_mir::util as mir_util;\n \n use dot;\n use dot::IntoCow;\n@@ -219,7 +220,7 @@ impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n             }\n             Ok(())\n         }\n-        ::rustc_mir::graphviz::write_node_label(\n+        mir_util::write_graphviz_node_label(\n             *n, self.mbcx.mir(), &mut v, 4,\n             |w| {\n                 let flow = self.mbcx.flow_state();"}, {"sha": "da8aa231ccf157219d590059189e279d4e3605a8", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -14,10 +14,10 @@ use rustc_data_structures::bitslice::BitSlice; // adds set_bit/get_bit to &[usiz\n use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_mir::util::elaborate_drops::DropFlagState;\n \n use super::super::gather_moves::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex};\n use super::super::MoveDataParamEnv;\n-use super::super::DropFlagState;\n use super::super::drop_flag_effects_for_function_entry;\n use super::super::drop_flag_effects_for_location;\n use super::super::on_lookup_result_bits;"}, {"sha": "88ec86cc95d614dfe461a30620d73dc6c5c9a064", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 135, "deletions": 592, "changes": 727, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -13,22 +13,20 @@ use super::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use super::dataflow::{DataflowResults};\n use super::{drop_flag_effects_for_location, on_all_children_bits};\n use super::on_lookup_result_bits;\n-use super::{DropFlagState, MoveDataParamEnv};\n-use super::patch::MirPatch;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::subst::{Kind, Subst, Substs};\n-use rustc::ty::util::IntTypeExt;\n+use super::MoveDataParamEnv;\n+use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n-use rustc::middle::lang_items;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_mir::util::patch::MirPatch;\n+use rustc_mir::util::elaborate_drops::{DropFlagState, elaborate_drop};\n+use rustc_mir::util::elaborate_drops::{DropElaborator, DropStyle, DropFlagMode};\n use syntax_pos::Span;\n \n use std::fmt;\n-use std::iter;\n use std::u32;\n \n pub struct ElaborateDrops;\n@@ -109,12 +107,116 @@ impl InitializationData {\n     }\n }\n \n-impl fmt::Debug for InitializationData {\n+struct Elaborator<'a, 'b: 'a, 'tcx: 'b> {\n+    init_data: &'a InitializationData,\n+    ctxt: &'a mut ElaborateDropsCtxt<'b, 'tcx>,\n+}\n+\n+impl<'a, 'b, 'tcx> fmt::Debug for Elaborator<'a, 'b, 'tcx> {\n     fn fmt(&self, _f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         Ok(())\n     }\n }\n \n+impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n+    type Path = MovePathIndex;\n+\n+    fn patch(&mut self) -> &mut MirPatch<'tcx> {\n+        &mut self.ctxt.patch\n+    }\n+\n+    fn mir(&self) -> &'a Mir<'tcx> {\n+        self.ctxt.mir\n+    }\n+\n+    fn tcx(&self) -> ty::TyCtxt<'a, 'tcx, 'tcx> {\n+        self.ctxt.tcx\n+    }\n+\n+    fn param_env(&self) -> &'a ty::ParameterEnvironment<'tcx> {\n+        self.ctxt.param_env()\n+    }\n+\n+    fn drop_style(&self, path: Self::Path, mode: DropFlagMode) -> DropStyle {\n+        let ((maybe_live, maybe_dead), multipart) = match mode {\n+            DropFlagMode::Shallow => (self.init_data.state(path), false),\n+            DropFlagMode::Deep => {\n+                let mut some_live = false;\n+                let mut some_dead = false;\n+                let mut children_count = 0;\n+                on_all_children_bits(\n+                    self.tcx(), self.mir(), self.ctxt.move_data(),\n+                    path, |child| {\n+                        if self.ctxt.path_needs_drop(child) {\n+                            let (live, dead) = self.init_data.state(child);\n+                            debug!(\"elaborate_drop: state({:?}) = {:?}\",\n+                                   child, (live, dead));\n+                            some_live |= live;\n+                            some_dead |= dead;\n+                            children_count += 1;\n+                        }\n+                    });\n+                ((some_live, some_dead), children_count != 1)\n+            }\n+        };\n+        match (maybe_live, maybe_dead, multipart) {\n+            (false, _, _) => DropStyle::Dead,\n+            (true, false, _) => DropStyle::Static,\n+            (true, true, false) => DropStyle::Conditional,\n+            (true, true, true) => DropStyle::Open,\n+        }\n+    }\n+\n+    fn clear_drop_flag(&mut self, loc: Location, path: Self::Path, mode: DropFlagMode) {\n+        match mode {\n+            DropFlagMode::Shallow => {\n+                self.ctxt.set_drop_flag(loc, path, DropFlagState::Absent);\n+            }\n+            DropFlagMode::Deep => {\n+                on_all_children_bits(\n+                    self.tcx(), self.mir(), self.ctxt.move_data(), path,\n+                    |child| self.ctxt.set_drop_flag(loc, child, DropFlagState::Absent)\n+                 );\n+            }\n+        }\n+    }\n+\n+    fn field_subpath(&self, path: Self::Path, field: Field) -> Option<Self::Path> {\n+        super::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n+            match p {\n+                &Projection {\n+                    elem: ProjectionElem::Field(idx, _), ..\n+                } => idx == field,\n+                _ => false\n+            }\n+        })\n+    }\n+\n+    fn deref_subpath(&self, path: Self::Path) -> Option<Self::Path> {\n+        super::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n+            match p {\n+                &Projection { elem: ProjectionElem::Deref, .. } => true,\n+                _ => false\n+            }\n+        })\n+    }\n+\n+    fn downcast_subpath(&self, path: Self::Path, variant: usize) -> Option<Self::Path> {\n+        super::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n+            match p {\n+                &Projection {\n+                    elem: ProjectionElem::Downcast(_, idx), ..\n+                } => idx == variant,\n+                _ => false\n+            }\n+        })\n+    }\n+\n+    fn get_drop_flag(&mut self, path: Self::Path) -> Option<Operand<'tcx>> {\n+        self.ctxt.drop_flag(path).map(Operand::Consume)\n+    }\n+}\n+\n struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n@@ -125,19 +227,6 @@ struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     patch: MirPatch<'tcx>,\n }\n \n-#[derive(Copy, Clone, Debug)]\n-struct DropCtxt<'a, 'tcx: 'a> {\n-    source_info: SourceInfo,\n-    is_cleanup: bool,\n-\n-    init_data: &'a InitializationData,\n-\n-    lvalue: &'a Lvalue<'tcx>,\n-    path: MovePathIndex,\n-    succ: BasicBlock,\n-    unwind: Option<BasicBlock>\n-}\n-\n impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn move_data(&self) -> &'b MoveData<'tcx> { &self.env.move_data }\n     fn param_env(&self) -> &'b ty::ParameterEnvironment<'tcx> {\n@@ -254,19 +343,22 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                     let init_data = self.initialization_data_at(loc);\n                     match self.move_data().rev_lookup.find(location) {\n                         LookupResult::Exact(path) => {\n-                            self.elaborate_drop(&DropCtxt {\n-                                source_info: terminator.source_info,\n-                                is_cleanup: data.is_cleanup,\n-                                init_data: &init_data,\n-                                lvalue: location,\n-                                path: path,\n-                                succ: target,\n-                                unwind: if data.is_cleanup {\n+                            elaborate_drop(\n+                                &mut Elaborator {\n+                                    init_data: &init_data,\n+                                    ctxt: self\n+                                },\n+                                terminator.source_info,\n+                                data.is_cleanup,\n+                                location,\n+                                path,\n+                                target,\n+                                if data.is_cleanup {\n                                     None\n                                 } else {\n                                     Some(Option::unwrap_or(unwind, resume_block))\n-                                }\n-                            }, bb);\n+                                },\n+                                bb)\n                         }\n                         LookupResult::Parent(..) => {\n                             span_bug!(terminator.source_info.span,\n@@ -343,15 +435,18 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 debug!(\"elaborate_drop_and_replace({:?}) - tracked {:?}\", terminator, path);\n                 let init_data = self.initialization_data_at(loc);\n \n-                self.elaborate_drop(&DropCtxt {\n-                    source_info: terminator.source_info,\n-                    is_cleanup: data.is_cleanup,\n-                    init_data: &init_data,\n-                    lvalue: location,\n-                    path: path,\n-                    succ: target,\n-                    unwind: Some(unwind)\n-                }, bb);\n+                elaborate_drop(\n+                    &mut Elaborator {\n+                        init_data: &init_data,\n+                        ctxt: self\n+                    },\n+                    terminator.source_info,\n+                    data.is_cleanup,\n+                    location,\n+                    path,\n+                    target,\n+                    Some(unwind),\n+                    bb);\n                 on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n                     self.set_drop_flag(Location { block: target, statement_index: 0 },\n                                        child, DropFlagState::Present);\n@@ -372,547 +467,6 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         }\n     }\n \n-    /// This elaborates a single drop instruction, located at `bb`, and\n-    /// patches over it.\n-    ///\n-    /// The elaborated drop checks the drop flags to only drop what\n-    /// is initialized.\n-    ///\n-    /// In addition, the relevant drop flags also need to be cleared\n-    /// to avoid double-drops. However, in the middle of a complex\n-    /// drop, one must avoid clearing some of the flags before they\n-    /// are read, as that would cause a memory leak.\n-    ///\n-    /// In particular, when dropping an ADT, multiple fields may be\n-    /// joined together under the `rest` subpath. They are all controlled\n-    /// by the primary drop flag, but only the last rest-field dropped\n-    /// should clear it (and it must also not clear anything else).\n-    ///\n-    /// FIXME: I think we should just control the flags externally\n-    /// and then we do not need this machinery.\n-    fn elaborate_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>, bb: BasicBlock) {\n-        debug!(\"elaborate_drop({:?})\", c);\n-\n-        let mut some_live = false;\n-        let mut some_dead = false;\n-        let mut children_count = 0;\n-        on_all_children_bits(\n-            self.tcx, self.mir, self.move_data(),\n-            c.path, |child| {\n-                if self.path_needs_drop(child) {\n-                    let (live, dead) = c.init_data.state(child);\n-                    debug!(\"elaborate_drop: state({:?}) = {:?}\",\n-                           child, (live, dead));\n-                    some_live |= live;\n-                    some_dead |= dead;\n-                    children_count += 1;\n-                }\n-            });\n-\n-        debug!(\"elaborate_drop({:?}): live - {:?}\", c,\n-               (some_live, some_dead));\n-        match (some_live, some_dead) {\n-            (false, false) | (false, true) => {\n-                // dead drop - patch it out\n-                self.patch.patch_terminator(bb, TerminatorKind::Goto {\n-                    target: c.succ\n-                });\n-            }\n-            (true, false) => {\n-                // static drop - just set the flag\n-                self.patch.patch_terminator(bb, TerminatorKind::Drop {\n-                    location: c.lvalue.clone(),\n-                    target: c.succ,\n-                    unwind: c.unwind\n-                });\n-                self.drop_flags_for_drop(c, bb);\n-            }\n-            (true, true) => {\n-                // dynamic drop\n-                let drop_bb = if children_count == 1 || self.must_complete_drop(c) {\n-                    self.conditional_drop(c)\n-                } else {\n-                    self.open_drop(c)\n-                };\n-                self.patch.patch_terminator(bb, TerminatorKind::Goto {\n-                    target: drop_bb\n-                });\n-            }\n-        }\n-    }\n-\n-    /// Return the lvalue and move path for each field of `variant`,\n-    /// (the move path is `None` if the field is a rest field).\n-    fn move_paths_for_fields(&self,\n-                             base_lv: &Lvalue<'tcx>,\n-                             variant_path: MovePathIndex,\n-                             variant: &'tcx ty::VariantDef,\n-                             substs: &'tcx Substs<'tcx>)\n-                             -> Vec<(Lvalue<'tcx>, Option<MovePathIndex>)>\n-    {\n-        variant.fields.iter().enumerate().map(|(i, f)| {\n-            let subpath =\n-                super::move_path_children_matching(self.move_data(), variant_path, |p| {\n-                    match p {\n-                        &Projection {\n-                            elem: ProjectionElem::Field(idx, _), ..\n-                        } => idx.index() == i,\n-                        _ => false\n-                    }\n-                });\n-\n-            let field_ty =\n-                self.tcx.normalize_associated_type_in_env(\n-                    &f.ty(self.tcx, substs),\n-                    self.param_env()\n-                );\n-            (base_lv.clone().field(Field::new(i), field_ty), subpath)\n-        }).collect()\n-    }\n-\n-    /// Create one-half of the drop ladder for a list of fields, and return\n-    /// the list of steps in it in reverse order.\n-    ///\n-    /// `unwind_ladder` is such a list of steps in reverse order,\n-    /// which is called instead of the next step if the drop unwinds\n-    /// (the first field is never reached). If it is `None`, all\n-    /// unwind targets are left blank.\n-    fn drop_halfladder<'a>(&mut self,\n-                           c: &DropCtxt<'a, 'tcx>,\n-                           unwind_ladder: Option<Vec<BasicBlock>>,\n-                           succ: BasicBlock,\n-                           fields: &[(Lvalue<'tcx>, Option<MovePathIndex>)],\n-                           is_cleanup: bool)\n-                           -> Vec<BasicBlock>\n-    {\n-        let mut unwind_succ = if is_cleanup {\n-            None\n-        } else {\n-            c.unwind\n-        };\n-\n-        let mut succ = self.new_block(\n-            c, c.is_cleanup, TerminatorKind::Goto { target: succ }\n-        );\n-\n-        // Always clear the \"master\" drop flag at the bottom of the\n-        // ladder. This is needed because the \"master\" drop flag\n-        // protects the ADT's discriminant, which is invalidated\n-        // after the ADT is dropped.\n-        self.set_drop_flag(\n-            Location { block: succ, statement_index: 0 },\n-            c.path,\n-            DropFlagState::Absent\n-        );\n-\n-        fields.iter().rev().enumerate().map(|(i, &(ref lv, path))| {\n-            succ = if let Some(path) = path {\n-                debug!(\"drop_ladder: for std field {} ({:?})\", i, lv);\n-\n-                self.elaborated_drop_block(&DropCtxt {\n-                    source_info: c.source_info,\n-                    is_cleanup: is_cleanup,\n-                    init_data: c.init_data,\n-                    lvalue: lv,\n-                    path: path,\n-                    succ: succ,\n-                    unwind: unwind_succ,\n-                })\n-            } else {\n-                debug!(\"drop_ladder: for rest field {} ({:?})\", i, lv);\n-\n-                self.complete_drop(&DropCtxt {\n-                    source_info: c.source_info,\n-                    is_cleanup: is_cleanup,\n-                    init_data: c.init_data,\n-                    lvalue: lv,\n-                    path: c.path,\n-                    succ: succ,\n-                    unwind: unwind_succ,\n-                }, false)\n-            };\n-\n-            unwind_succ = unwind_ladder.as_ref().map(|p| p[i]);\n-            succ\n-        }).collect()\n-    }\n-\n-    /// Create a full drop ladder, consisting of 2 connected half-drop-ladders\n-    ///\n-    /// For example, with 3 fields, the drop ladder is\n-    ///\n-    /// .d0:\n-    ///     ELAB(drop location.0 [target=.d1, unwind=.c1])\n-    /// .d1:\n-    ///     ELAB(drop location.1 [target=.d2, unwind=.c2])\n-    /// .d2:\n-    ///     ELAB(drop location.2 [target=`c.succ`, unwind=`c.unwind`])\n-    /// .c1:\n-    ///     ELAB(drop location.1 [target=.c2])\n-    /// .c2:\n-    ///     ELAB(drop location.2 [target=`c.unwind])\n-    fn drop_ladder<'a>(&mut self,\n-                       c: &DropCtxt<'a, 'tcx>,\n-                       fields: Vec<(Lvalue<'tcx>, Option<MovePathIndex>)>)\n-                       -> BasicBlock\n-    {\n-        debug!(\"drop_ladder({:?}, {:?})\", c, fields);\n-\n-        let mut fields = fields;\n-        fields.retain(|&(ref lvalue, _)| {\n-            let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n-            self.tcx.type_needs_drop_given_env(ty, self.param_env())\n-        });\n-\n-        debug!(\"drop_ladder - fields needing drop: {:?}\", fields);\n-\n-        let unwind_ladder = if c.is_cleanup {\n-            None\n-        } else {\n-            Some(self.drop_halfladder(c, None, c.unwind.unwrap(), &fields, true))\n-        };\n-\n-        self.drop_halfladder(c, unwind_ladder, c.succ, &fields, c.is_cleanup)\n-            .last().cloned().unwrap_or(c.succ)\n-    }\n-\n-    fn open_drop_for_tuple<'a>(&mut self, c: &DropCtxt<'a, 'tcx>, tys: &[Ty<'tcx>])\n-                               -> BasicBlock\n-    {\n-        debug!(\"open_drop_for_tuple({:?}, {:?})\", c, tys);\n-\n-        let fields = tys.iter().enumerate().map(|(i, &ty)| {\n-            (c.lvalue.clone().field(Field::new(i), ty),\n-             super::move_path_children_matching(\n-                 self.move_data(), c.path, |proj| match proj {\n-                     &Projection {\n-                         elem: ProjectionElem::Field(f, _), ..\n-                     } => f.index() == i,\n-                     _ => false\n-                 }\n-            ))\n-        }).collect();\n-\n-        self.drop_ladder(c, fields)\n-    }\n-\n-    fn open_drop_for_box<'a>(&mut self, c: &DropCtxt<'a, 'tcx>, ty: Ty<'tcx>)\n-                             -> BasicBlock\n-    {\n-        debug!(\"open_drop_for_box({:?}, {:?})\", c, ty);\n-\n-        let interior_path = super::move_path_children_matching(\n-            self.move_data(), c.path, |proj| match proj {\n-                &Projection { elem: ProjectionElem::Deref, .. } => true,\n-                _ => false\n-            }).unwrap();\n-\n-        let interior = c.lvalue.clone().deref();\n-        let inner_c = DropCtxt {\n-            lvalue: &interior,\n-            unwind: c.unwind.map(|u| {\n-                self.box_free_block(c, ty, u, true)\n-            }),\n-            succ: self.box_free_block(c, ty, c.succ, c.is_cleanup),\n-            path: interior_path,\n-            ..*c\n-        };\n-\n-        self.elaborated_drop_block(&inner_c)\n-    }\n-\n-    fn open_drop_for_adt<'a>(&mut self, c: &DropCtxt<'a, 'tcx>,\n-                             adt: &'tcx ty::AdtDef, substs: &'tcx Substs<'tcx>)\n-                             -> BasicBlock {\n-        debug!(\"open_drop_for_adt({:?}, {:?}, {:?})\", c, adt, substs);\n-\n-        match adt.variants.len() {\n-            1 => {\n-                let fields = self.move_paths_for_fields(\n-                    c.lvalue,\n-                    c.path,\n-                    &adt.variants[0],\n-                    substs\n-                );\n-                self.drop_ladder(c, fields)\n-            }\n-            _ => {\n-                let mut values = Vec::with_capacity(adt.variants.len());\n-                let mut blocks = Vec::with_capacity(adt.variants.len());\n-                let mut otherwise = None;\n-                for (variant_index, discr) in adt.discriminants(self.tcx).enumerate() {\n-                    let subpath = super::move_path_children_matching(\n-                        self.move_data(), c.path, |proj| match proj {\n-                            &Projection {\n-                                elem: ProjectionElem::Downcast(_, idx), ..\n-                            } => idx == variant_index,\n-                            _ => false\n-                        });\n-                    if let Some(variant_path) = subpath {\n-                        let base_lv = c.lvalue.clone().elem(\n-                            ProjectionElem::Downcast(adt, variant_index)\n-                        );\n-                        let fields = self.move_paths_for_fields(\n-                            &base_lv,\n-                            variant_path,\n-                            &adt.variants[variant_index],\n-                            substs);\n-                        values.push(discr);\n-                        blocks.push(self.drop_ladder(c, fields));\n-                    } else {\n-                        // variant not found - drop the entire enum\n-                        if let None = otherwise {\n-                            otherwise = Some(self.complete_drop(c, true));\n-                        }\n-                    }\n-                }\n-                if let Some(block) = otherwise {\n-                    blocks.push(block);\n-                } else {\n-                    values.pop();\n-                }\n-                // If there are multiple variants, then if something\n-                // is present within the enum the discriminant, tracked\n-                // by the rest path, must be initialized.\n-                //\n-                // Additionally, we do not want to switch on the\n-                // discriminant after it is free-ed, because that\n-                // way lies only trouble.\n-                let discr_ty = adt.repr.discr_type().to_ty(self.tcx);\n-                let discr = Lvalue::Local(self.patch.new_temp(discr_ty));\n-                let switch_block = self.patch.new_block(BasicBlockData {\n-                    statements: vec![\n-                        Statement {\n-                            source_info: c.source_info,\n-                            kind: StatementKind::Assign(discr.clone(),\n-                                                        Rvalue::Discriminant(c.lvalue.clone()))\n-                        }\n-                    ],\n-                    terminator: Some(Terminator {\n-                        source_info: c.source_info,\n-                        kind: TerminatorKind::SwitchInt {\n-                            discr: Operand::Consume(discr),\n-                            switch_ty: discr_ty,\n-                            values: From::from(values),\n-                            targets: blocks,\n-                        }\n-                    }),\n-                    is_cleanup: c.is_cleanup,\n-                });\n-                self.drop_flag_test_block(c, switch_block)\n-            }\n-        }\n-    }\n-\n-    /// The slow-path - create an \"open\", elaborated drop for a type\n-    /// which is moved-out-of only partially, and patch `bb` to a jump\n-    /// to it. This must not be called on ADTs with a destructor,\n-    /// as these can't be moved-out-of, except for `Box<T>`, which is\n-    /// special-cased.\n-    ///\n-    /// This creates a \"drop ladder\" that drops the needed fields of the\n-    /// ADT, both in the success case or if one of the destructors fail.\n-    fn open_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n-        let ty = c.lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n-        match ty.sty {\n-            ty::TyClosure(def_id, substs) => {\n-                let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx).collect();\n-                self.open_drop_for_tuple(c, &tys)\n-            }\n-            ty::TyTuple(tys, _) => {\n-                self.open_drop_for_tuple(c, tys)\n-            }\n-            ty::TyAdt(def, _) if def.is_box() => {\n-                self.open_drop_for_box(c, ty.boxed_ty())\n-            }\n-            ty::TyAdt(def, substs) => {\n-                self.open_drop_for_adt(c, def, substs)\n-            }\n-            _ => bug!(\"open drop from non-ADT `{:?}`\", ty)\n-        }\n-    }\n-\n-    /// Return a basic block that drop an lvalue using the context\n-    /// and path in `c`. If `update_drop_flag` is true, also\n-    /// clear `c`.\n-    ///\n-    /// if FLAG(c.path)\n-    ///     if(update_drop_flag) FLAG(c.path) = false\n-    ///     drop(c.lv)\n-    fn complete_drop<'a>(\n-        &mut self,\n-        c: &DropCtxt<'a, 'tcx>,\n-        update_drop_flag: bool)\n-        -> BasicBlock\n-    {\n-        debug!(\"complete_drop({:?},{:?})\", c, update_drop_flag);\n-\n-        let drop_block = self.drop_block(c);\n-        if update_drop_flag {\n-            self.set_drop_flag(\n-                Location { block: drop_block, statement_index: 0 },\n-                c.path,\n-                DropFlagState::Absent\n-            );\n-        }\n-\n-        self.drop_flag_test_block(c, drop_block)\n-    }\n-\n-    /// Create a simple conditional drop.\n-    ///\n-    /// if FLAG(c.lv)\n-    ///     FLAGS(c.lv) = false\n-    ///     drop(c.lv)\n-    fn conditional_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>)\n-                            -> BasicBlock\n-    {\n-        debug!(\"conditional_drop({:?})\", c);\n-        let drop_bb = self.drop_block(c);\n-        self.drop_flags_for_drop(c, drop_bb);\n-\n-        self.drop_flag_test_block(c, drop_bb)\n-    }\n-\n-    fn new_block<'a>(&mut self,\n-                     c: &DropCtxt<'a, 'tcx>,\n-                     is_cleanup: bool,\n-                     k: TerminatorKind<'tcx>)\n-                     -> BasicBlock\n-    {\n-        self.patch.new_block(BasicBlockData {\n-            statements: vec![],\n-            terminator: Some(Terminator {\n-                source_info: c.source_info, kind: k\n-            }),\n-            is_cleanup: is_cleanup\n-        })\n-    }\n-\n-    fn elaborated_drop_block<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n-        debug!(\"elaborated_drop_block({:?})\", c);\n-        let blk = self.drop_block(c);\n-        self.elaborate_drop(c, blk);\n-        blk\n-    }\n-\n-    fn drop_flag_test_block<'a>(&mut self,\n-                                c: &DropCtxt<'a, 'tcx>,\n-                                on_set: BasicBlock)\n-                                -> BasicBlock {\n-        self.drop_flag_test_block_with_succ(c, c.is_cleanup, on_set, c.succ)\n-    }\n-\n-    fn drop_flag_test_block_with_succ<'a>(&mut self,\n-                                          c: &DropCtxt<'a, 'tcx>,\n-                                          is_cleanup: bool,\n-                                          on_set: BasicBlock,\n-                                          on_unset: BasicBlock)\n-                                          -> BasicBlock\n-    {\n-        let (maybe_live, maybe_dead) = c.init_data.state(c.path);\n-        debug!(\"drop_flag_test_block({:?},{:?},{:?}) - {:?}\",\n-               c, is_cleanup, on_set, (maybe_live, maybe_dead));\n-\n-        match (maybe_live, maybe_dead) {\n-            (false, _) => on_unset,\n-            (true, false) => on_set,\n-            (true, true) => {\n-                let flag = self.drop_flag(c.path).unwrap();\n-                let term = TerminatorKind::if_(self.tcx, Operand::Consume(flag), on_set, on_unset);\n-                self.new_block(c, is_cleanup, term)\n-            }\n-        }\n-    }\n-\n-    fn drop_block<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n-        self.new_block(c, c.is_cleanup, TerminatorKind::Drop {\n-            location: c.lvalue.clone(),\n-            target: c.succ,\n-            unwind: c.unwind\n-        })\n-    }\n-\n-    fn box_free_block<'a>(\n-        &mut self,\n-        c: &DropCtxt<'a, 'tcx>,\n-        ty: Ty<'tcx>,\n-        target: BasicBlock,\n-        is_cleanup: bool\n-    ) -> BasicBlock {\n-        let block = self.unelaborated_free_block(c, ty, target, is_cleanup);\n-        self.drop_flag_test_block_with_succ(c, is_cleanup, block, target)\n-    }\n-\n-    fn unelaborated_free_block<'a>(\n-        &mut self,\n-        c: &DropCtxt<'a, 'tcx>,\n-        ty: Ty<'tcx>,\n-        target: BasicBlock,\n-        is_cleanup: bool\n-    ) -> BasicBlock {\n-        let mut statements = vec![];\n-        if let Some(&flag) = self.drop_flags.get(&c.path) {\n-            statements.push(Statement {\n-                source_info: c.source_info,\n-                kind: StatementKind::Assign(\n-                    Lvalue::Local(flag),\n-                    self.constant_bool(c.source_info.span, false)\n-                )\n-            });\n-        }\n-\n-        let tcx = self.tcx;\n-        let unit_temp = Lvalue::Local(self.patch.new_temp(tcx.mk_nil()));\n-        let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n-        let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n-        let fty = tcx.item_type(free_func).subst(tcx, substs);\n-\n-        self.patch.new_block(BasicBlockData {\n-            statements: statements,\n-            terminator: Some(Terminator {\n-                source_info: c.source_info, kind: TerminatorKind::Call {\n-                    func: Operand::Constant(Constant {\n-                        span: c.source_info.span,\n-                        ty: fty,\n-                        literal: Literal::Item {\n-                            def_id: free_func,\n-                            substs: substs\n-                        }\n-                    }),\n-                    args: vec![Operand::Consume(c.lvalue.clone())],\n-                    destination: Some((unit_temp, target)),\n-                    cleanup: None\n-                }\n-            }),\n-            is_cleanup: is_cleanup\n-        })\n-    }\n-\n-    fn must_complete_drop<'a>(&self, c: &DropCtxt<'a, 'tcx>) -> bool {\n-        // if we have a destuctor, we must *not* split the drop.\n-\n-        // dataflow can create unneeded children in some cases\n-        // - be sure to ignore them.\n-\n-        let ty = c.lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n-\n-        match ty.sty {\n-            ty::TyAdt(def, _) => {\n-                if def.has_dtor(self.tcx) && !def.is_box() {\n-                    self.tcx.sess.span_warn(\n-                        c.source_info.span,\n-                        &format!(\"dataflow bug??? moving out of type with dtor {:?}\",\n-                                 c));\n-                    true\n-                } else {\n-                    false\n-                }\n-            }\n-            _ => false\n-        }\n-    }\n-\n     fn constant_bool(&self, span: Span, val: bool) -> Rvalue<'tcx> {\n         Rvalue::Use(Operand::Constant(Constant {\n             span: span,\n@@ -1023,15 +577,4 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             }\n         }\n     }\n-\n-    fn drop_flags_for_drop<'a>(&mut self,\n-                               c: &DropCtxt<'a, 'tcx>,\n-                               bb: BasicBlock)\n-    {\n-        let loc = self.patch.terminator_loc(self.mir, bb);\n-        on_all_children_bits(\n-            self.tcx, self.mir, self.move_data(), c.path,\n-            |child| self.set_drop_flag(loc, child, DropFlagState::Absent)\n-        );\n-    }\n }"}, {"sha": "81037fe40d9dab07ecdfd904a5a492c5a72b15a1", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -437,7 +437,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             }\n             Rvalue::Ref(..) |\n             Rvalue::Discriminant(..) |\n-            Rvalue::Len(..) => {}\n+            Rvalue::Len(..) |\n             Rvalue::Box(..) => {\n                 // This returns an rvalue with uninitialized contents. We can't\n                 // move out of it here because it is an rvalue - assignments always"}, {"sha": "9237bb31f6bd7f62c267550d29723c46d69bcf13", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -16,12 +16,12 @@ use syntax_pos::DUMMY_SP;\n use rustc::mir::{self, BasicBlock, BasicBlockData, Mir, Statement, Terminator, Location};\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n+use rustc_mir::util::elaborate_drops::DropFlagState;\n \n mod abs_domain;\n pub mod elaborate_drops;\n mod dataflow;\n mod gather_moves;\n-mod patch;\n // mod graphviz;\n \n use self::dataflow::{BitDenotation};\n@@ -183,21 +183,6 @@ impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n-enum DropFlagState {\n-    Present, // i.e. initialized\n-    Absent, // i.e. deinitialized or \"moved\"\n-}\n-\n-impl DropFlagState {\n-    fn value(self) -> bool {\n-        match self {\n-            DropFlagState::Present => true,\n-            DropFlagState::Absent => false\n-        }\n-    }\n-}\n-\n fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n                                         path: MovePathIndex,\n                                         mut cond: F)"}, {"sha": "6cd97e9559885048ac4f6905ecc257b5bf45e545", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -26,8 +26,7 @@ use rustc::session::config::Input;\n use rustc_borrowck as borrowck;\n use rustc_borrowck::graphviz as borrowck_dot;\n \n-use rustc_mir::pretty::write_mir_pretty;\n-use rustc_mir::graphviz::write_mir_graphviz;\n+use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n \n use syntax::ast::{self, BlockCheckMode};\n use syntax::fold::{self, Folder};"}, {"sha": "044ed529ef74cfa50c96f36683172d5a04999174", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: None,\n+            mir: self.encode_mir(def_id),\n         }\n     }\n \n@@ -426,7 +426,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: None,\n+            mir: self.encode_mir(def_id),\n         }\n     }\n "}, {"sha": "590c6a430b98a2862970c58db9c28c8282bc50d5", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -22,6 +22,8 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n #![feature(associated_consts)]\n #![feature(box_patterns)]\n+#![feature(box_syntax)]\n+#![cfg_attr(stage0, feature(field_init_shorthand))]\n #![feature(i128_type)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -47,16 +49,16 @@ pub mod diagnostics;\n \n pub mod build;\n pub mod callgraph;\n-pub mod def_use;\n-pub mod graphviz;\n mod hair;\n+mod shim;\n pub mod mir_map;\n-pub mod pretty;\n pub mod transform;\n+pub mod util;\n \n use rustc::ty::maps::Providers;\n \n pub fn provide(providers: &mut Providers) {\n     mir_map::provide(providers);\n+    shim::provide(providers);\n     transform::qualify_consts::provide(providers);\n }\n\\ No newline at end of file"}, {"sha": "8c138d779c10687f274897e635476808e1227de5", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 66, "deletions": 6, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -22,14 +22,16 @@ use rustc::dep_graph::DepNode;\n use rustc::mir::Mir;\n use rustc::mir::transform::MirSource;\n use rustc::mir::visit::MutVisitor;\n-use pretty;\n+use shim;\n use hair::cx::Cx;\n+use util as mir_util;\n \n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::ty::subst::Substs;\n use rustc::hir;\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -44,6 +46,31 @@ pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n             tcx.item_mir(body_owner_def_id);\n         });\n+\n+        // Tuple struct/variant constructors don't have a BodyId, so we need\n+        // to build them separately.\n+        struct GatherCtors<'a, 'tcx: 'a> {\n+            tcx: TyCtxt<'a, 'tcx, 'tcx>\n+        }\n+        impl<'a, 'tcx> Visitor<'tcx> for GatherCtors<'a, 'tcx> {\n+            fn visit_variant_data(&mut self,\n+                                  v: &'tcx hir::VariantData,\n+                                  _: ast::Name,\n+                                  _: &'tcx hir::Generics,\n+                                  _: ast::NodeId,\n+                                  _: Span) {\n+                if let hir::VariantData::Tuple(_, node_id) = *v {\n+                    self.tcx.item_mir(self.tcx.hir.local_def_id(node_id));\n+                }\n+                intravisit::walk_struct_def(self, v)\n+            }\n+            fn nested_visit_map<'b>(&'b mut self) -> NestedVisitorMap<'b, 'tcx> {\n+                NestedVisitorMap::None\n+            }\n+        }\n+        tcx.visit_all_item_likes_in_krate(DepNode::Mir, &mut GatherCtors {\n+            tcx: tcx\n+        }.as_deep_visitor());\n     }\n }\n \n@@ -95,6 +122,10 @@ fn build_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                 _ => hir::BodyId { node_id: expr.id }\n             }\n         }\n+        hir::map::NodeVariant(variant) =>\n+            return create_constructor_shim(tcx, id, &variant.node.data),\n+        hir::map::NodeStructCtor(ctor) =>\n+            return create_constructor_shim(tcx, id, ctor),\n         _ => unsupported()\n     };\n \n@@ -144,7 +175,7 @@ fn build_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             mem::transmute::<Mir, Mir<'tcx>>(mir)\n         };\n \n-        pretty::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n+        mir_util::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n \n         tcx.alloc_mir(mir)\n     })\n@@ -180,6 +211,38 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n     }\n }\n \n+fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     ctor_id: ast::NodeId,\n+                                     v: &'tcx hir::VariantData)\n+                                     -> &'tcx RefCell<Mir<'tcx>>\n+{\n+    let span = tcx.hir.span(ctor_id);\n+    if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n+        let pe = ty::ParameterEnvironment::for_item(tcx, ctor_id);\n+        tcx.infer_ctxt(pe, Reveal::UserFacing).enter(|infcx| {\n+            let (mut mir, src) =\n+                shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n+\n+            // Convert the Mir to global types.\n+            let tcx = infcx.tcx.global_tcx();\n+            let mut globalizer = GlobalizeMir {\n+                tcx: tcx,\n+                span: mir.span\n+            };\n+            globalizer.visit_mir(&mut mir);\n+            let mir = unsafe {\n+                mem::transmute::<Mir, Mir<'tcx>>(mir)\n+            };\n+\n+            mir_util::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n+\n+            tcx.alloc_mir(mir)\n+        })\n+    } else {\n+        span_bug!(span, \"attempting to create MIR for non-tuple variant {:?}\", v);\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n@@ -189,12 +252,9 @@ fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> Ty<'tcx> {\n     let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n \n-    // We're just hard-coding the idea that the signature will be\n-    // &self or &mut self and hence will have a bound region with\n-    // number 0, hokey.\n     let region = ty::Region::ReFree(ty::FreeRegion {\n         scope: tcx.region_maps.item_extent(body_id.node_id),\n-        bound_region: ty::BoundRegion::BrAnon(0),\n+        bound_region: ty::BoundRegion::BrEnv,\n     });\n     let region = tcx.mk_region(region);\n "}, {"sha": "26d5b7fd38ab080b09552e520bb5764ea154d7f1", "filename": "src/librustc_mir/shim.rs", "status": "added", "additions": 489, "deletions": 0, "changes": 489, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -0,0 +1,489 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::infer;\n+use rustc::middle::region::ROOT_CODE_EXTENT;\n+use rustc::mir::*;\n+use rustc::mir::transform::MirSource;\n+use rustc::ty::{self, Ty};\n+use rustc::ty::subst::{Kind, Subst};\n+use rustc::ty::maps::Providers;\n+\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+\n+use syntax::abi::Abi;\n+use syntax::ast;\n+use syntax_pos::Span;\n+\n+use std::cell::RefCell;\n+use std::fmt;\n+use std::iter;\n+use std::mem;\n+\n+use transform::{add_call_guards, no_landing_pads, simplify};\n+use util::elaborate_drops::{self, DropElaborator, DropStyle, DropFlagMode};\n+use util::patch::MirPatch;\n+\n+pub fn provide(providers: &mut Providers) {\n+    providers.mir_shims = make_shim;\n+}\n+\n+fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+                       instance: ty::InstanceDef<'tcx>)\n+                       -> &'tcx RefCell<Mir<'tcx>>\n+{\n+    debug!(\"make_shim({:?})\", instance);\n+    let did = instance.def_id();\n+    let span = tcx.def_span(did);\n+    let param_env =\n+        tcx.construct_parameter_environment(span, did, ROOT_CODE_EXTENT);\n+\n+    let mut result = match instance {\n+        ty::InstanceDef::Item(..) =>\n+            bug!(\"item {:?} passed to make_shim\", instance),\n+        ty::InstanceDef::FnPtrShim(def_id, ty) => {\n+            let trait_ = tcx.trait_of_item(def_id).unwrap();\n+            let adjustment = match tcx.lang_items.fn_trait_kind(trait_) {\n+                Some(ty::ClosureKind::FnOnce) => Adjustment::Identity,\n+                Some(ty::ClosureKind::FnMut) |\n+                Some(ty::ClosureKind::Fn) => Adjustment::Deref,\n+                None => bug!(\"fn pointer {:?} is not an fn\", ty)\n+            };\n+            // HACK: we need the \"real\" argument types for the MIR,\n+            // but because our substs are (Self, Args), where Args\n+            // is a tuple, we must include the *concrete* argument\n+            // types in the MIR. They will be substituted again with\n+            // the param-substs, but because they are concrete, this\n+            // will not do any harm.\n+            let sig = tcx.erase_late_bound_regions(&ty.fn_sig());\n+            let arg_tys = sig.inputs();\n+\n+            build_call_shim(\n+                tcx,\n+                &param_env,\n+                def_id,\n+                adjustment,\n+                CallKind::Indirect,\n+                Some(arg_tys)\n+            )\n+        }\n+        ty::InstanceDef::Virtual(def_id, _) => {\n+            // We are translating a call back to our def-id, which\n+            // trans::mir knows to turn to an actual virtual call.\n+            build_call_shim(\n+                tcx,\n+                &param_env,\n+                def_id,\n+                Adjustment::Identity,\n+                CallKind::Direct(def_id),\n+                None\n+            )\n+        }\n+        ty::InstanceDef::ClosureOnceShim { call_once } => {\n+            let fn_mut = tcx.lang_items.fn_mut_trait().unwrap();\n+            let call_mut = tcx.global_tcx()\n+                .associated_items(fn_mut)\n+                .find(|it| it.kind == ty::AssociatedKind::Method)\n+                .unwrap().def_id;\n+\n+            build_call_shim(\n+                tcx,\n+                &param_env,\n+                call_once,\n+                Adjustment::RefMut,\n+                CallKind::Direct(call_mut),\n+                None\n+            )\n+        }\n+        ty::InstanceDef::DropGlue(def_id, ty) => {\n+            build_drop_shim(tcx, &param_env, def_id, ty)\n+        }\n+        ty::InstanceDef::Intrinsic(_) => {\n+            bug!(\"creating shims from intrinsics ({:?}) is unsupported\", instance)\n+        }\n+    };\n+        debug!(\"make_shim({:?}) = untransformed {:?}\", instance, result);\n+        no_landing_pads::no_landing_pads(tcx, &mut result);\n+        simplify::simplify_cfg(&mut result);\n+        add_call_guards::add_call_guards(&mut result);\n+    debug!(\"make_shim({:?}) = {:?}\", instance, result);\n+\n+    let result = tcx.alloc_mir(result);\n+    // Perma-borrow MIR from shims to prevent mutation.\n+    mem::forget(result.borrow());\n+    result\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+enum Adjustment {\n+    Identity,\n+    Deref,\n+    RefMut,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+enum CallKind {\n+    Indirect,\n+    Direct(DefId),\n+}\n+\n+fn temp_decl(mutability: Mutability, ty: Ty) -> LocalDecl {\n+    LocalDecl { mutability, ty, name: None, source_info: None }\n+}\n+\n+fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>)\n+    -> IndexVec<Local, LocalDecl<'tcx>>\n+{\n+    iter::once(temp_decl(Mutability::Mut, sig.output()))\n+        .chain(sig.inputs().iter().map(\n+            |ity| temp_decl(Mutability::Not, ity)))\n+        .collect()\n+}\n+\n+fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+                             param_env: &ty::ParameterEnvironment<'tcx>,\n+                             def_id: DefId,\n+                             ty: Option<Ty<'tcx>>)\n+                             -> Mir<'tcx>\n+{\n+    debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n+\n+    let substs = if let Some(ty) = ty {\n+        tcx.mk_substs(iter::once(Kind::from(ty)))\n+    } else {\n+        param_env.free_substs\n+    };\n+    let fn_ty = tcx.item_type(def_id).subst(tcx, substs);\n+    let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n+    let span = tcx.def_span(def_id);\n+\n+    let source_info = SourceInfo { span, scope: ARGUMENT_VISIBILITY_SCOPE };\n+\n+    let return_block = BasicBlock::new(1);\n+    let mut blocks = IndexVec::new();\n+    let block = |blocks: &mut IndexVec<_, _>, kind| {\n+        blocks.push(BasicBlockData {\n+            statements: vec![],\n+            terminator: Some(Terminator { source_info, kind }),\n+            is_cleanup: false\n+        })\n+    };\n+    block(&mut blocks, TerminatorKind::Goto { target: return_block });\n+    block(&mut blocks, TerminatorKind::Return);\n+\n+    let mut mir = Mir::new(\n+        blocks,\n+        IndexVec::from_elem_n(\n+            VisibilityScopeData { span: span, parent_scope: None }, 1\n+        ),\n+        IndexVec::new(),\n+        sig.output(),\n+        local_decls_for_sig(&sig),\n+        sig.inputs().len(),\n+        vec![],\n+        span\n+    );\n+\n+    if let Some(..) = ty {\n+        let patch = {\n+            let mut elaborator = DropShimElaborator {\n+                mir: &mir,\n+                patch: MirPatch::new(&mir),\n+                tcx, param_env\n+            };\n+            let dropee = Lvalue::Projection(\n+                box Projection {\n+                    base: Lvalue::Local(Local::new(1+0)),\n+                    elem: ProjectionElem::Deref\n+                }\n+                );\n+            let resume_block = elaborator.patch.resume_block();\n+            elaborate_drops::elaborate_drop(\n+                &mut elaborator,\n+                source_info,\n+                false,\n+                &dropee,\n+                (),\n+                return_block,\n+                Some(resume_block),\n+                START_BLOCK\n+            );\n+            elaborator.patch\n+        };\n+        patch.apply(&mut mir);\n+    }\n+\n+    mir\n+}\n+\n+pub struct DropShimElaborator<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    patch: MirPatch<'tcx>,\n+    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: &'a ty::ParameterEnvironment<'tcx>,\n+}\n+\n+impl<'a, 'tcx> fmt::Debug for DropShimElaborator<'a, 'tcx> {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n+    type Path = ();\n+\n+    fn patch(&mut self) -> &mut MirPatch<'tcx> { &mut self.patch }\n+    fn mir(&self) -> &'a Mir<'tcx> { self.mir }\n+    fn tcx(&self) -> ty::TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+    fn param_env(&self) -> &'a ty::ParameterEnvironment<'tcx> { self.param_env }\n+\n+    fn drop_style(&self, _path: Self::Path, mode: DropFlagMode) -> DropStyle {\n+        if let DropFlagMode::Shallow = mode {\n+            DropStyle::Static\n+        } else {\n+            DropStyle::Open\n+        }\n+    }\n+\n+    fn get_drop_flag(&mut self, _path: Self::Path) -> Option<Operand<'tcx>> {\n+        None\n+    }\n+\n+    fn clear_drop_flag(&mut self, _location: Location, _path: Self::Path, _mode: DropFlagMode) {\n+    }\n+\n+    fn field_subpath(&self, _path: Self::Path, _field: Field) -> Option<Self::Path> {\n+        None\n+    }\n+    fn deref_subpath(&self, _path: Self::Path) -> Option<Self::Path> {\n+        None\n+    }\n+    fn downcast_subpath(&self, _path: Self::Path, _variant: usize) -> Option<Self::Path> {\n+        Some(())\n+    }\n+}\n+\n+/// Build a \"call\" shim for `def_id`. The shim calls the\n+/// function specified by `call_kind`, first adjusting its first\n+/// argument according to `rcvr_adjustment`.\n+///\n+/// If `untuple_args` is a vec of types, the second argument of the\n+/// function will be untupled as these types.\n+fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+                             param_env: &ty::ParameterEnvironment<'tcx>,\n+                             def_id: DefId,\n+                             rcvr_adjustment: Adjustment,\n+                             call_kind: CallKind,\n+                             untuple_args: Option<&[Ty<'tcx>]>)\n+                             -> Mir<'tcx>\n+{\n+    debug!(\"build_call_shim(def_id={:?}, rcvr_adjustment={:?}, \\\n+            call_kind={:?}, untuple_args={:?})\",\n+           def_id, rcvr_adjustment, call_kind, untuple_args);\n+\n+    let fn_ty = tcx.item_type(def_id).subst(tcx, param_env.free_substs);\n+    let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n+    let span = tcx.def_span(def_id);\n+\n+    debug!(\"build_call_shim: sig={:?}\", sig);\n+\n+    let mut local_decls = local_decls_for_sig(&sig);\n+    let source_info = SourceInfo { span, scope: ARGUMENT_VISIBILITY_SCOPE };\n+\n+    let rcvr_arg = Local::new(1+0);\n+    let rcvr_l = Lvalue::Local(rcvr_arg);\n+    let mut statements = vec![];\n+\n+    let rcvr = match rcvr_adjustment {\n+        Adjustment::Identity => Operand::Consume(rcvr_l),\n+        Adjustment::Deref => Operand::Consume(Lvalue::Projection(\n+            box Projection { base: rcvr_l, elem: ProjectionElem::Deref }\n+        )),\n+        Adjustment::RefMut => {\n+            // let rcvr = &mut rcvr;\n+            let re_erased = tcx.mk_region(ty::ReErased);\n+            let ref_rcvr = local_decls.push(temp_decl(\n+                Mutability::Not,\n+                tcx.mk_ref(re_erased, ty::TypeAndMut {\n+                    ty: sig.inputs()[0],\n+                    mutbl: hir::Mutability::MutMutable\n+                })\n+            ));\n+            statements.push(Statement {\n+                source_info: source_info,\n+                kind: StatementKind::Assign(\n+                    Lvalue::Local(ref_rcvr),\n+                    Rvalue::Ref(re_erased, BorrowKind::Mut, rcvr_l)\n+                )\n+            });\n+            Operand::Consume(Lvalue::Local(ref_rcvr))\n+        }\n+    };\n+\n+    let (callee, mut args) = match call_kind {\n+        CallKind::Indirect => (rcvr, vec![]),\n+        CallKind::Direct(def_id) => (\n+            Operand::Constant(Constant {\n+                span: span,\n+                ty: tcx.item_type(def_id).subst(tcx, param_env.free_substs),\n+                literal: Literal::Item { def_id, substs: param_env.free_substs },\n+            }),\n+            vec![rcvr]\n+        )\n+    };\n+\n+    if let Some(untuple_args) = untuple_args {\n+        args.extend(untuple_args.iter().enumerate().map(|(i, ity)| {\n+            let arg_lv = Lvalue::Local(Local::new(1+1));\n+            Operand::Consume(Lvalue::Projection(box Projection {\n+                base: arg_lv,\n+                elem: ProjectionElem::Field(Field::new(i), *ity)\n+            }))\n+        }));\n+    } else {\n+        args.extend((1..sig.inputs().len()).map(|i| {\n+            Operand::Consume(Lvalue::Local(Local::new(1+i)))\n+        }));\n+    }\n+\n+    let mut blocks = IndexVec::new();\n+    let block = |blocks: &mut IndexVec<_, _>, statements, kind, is_cleanup| {\n+        blocks.push(BasicBlockData {\n+            statements,\n+            terminator: Some(Terminator { source_info, kind }),\n+            is_cleanup\n+        })\n+    };\n+\n+    // BB #0\n+    block(&mut blocks, statements, TerminatorKind::Call {\n+        func: callee,\n+        args: args,\n+        destination: Some((Lvalue::Local(RETURN_POINTER),\n+                           BasicBlock::new(1))),\n+        cleanup: if let Adjustment::RefMut = rcvr_adjustment {\n+            Some(BasicBlock::new(3))\n+        } else {\n+            None\n+        }\n+    }, false);\n+\n+    if let Adjustment::RefMut = rcvr_adjustment {\n+        // BB #1 - drop for Self\n+        block(&mut blocks, vec![], TerminatorKind::Drop {\n+            location: Lvalue::Local(rcvr_arg),\n+            target: BasicBlock::new(2),\n+            unwind: None\n+        }, false);\n+    }\n+    // BB #1/#2 - return\n+    block(&mut blocks, vec![], TerminatorKind::Return, false);\n+    if let Adjustment::RefMut = rcvr_adjustment {\n+        // BB #3 - drop if closure panics\n+        block(&mut blocks, vec![], TerminatorKind::Drop {\n+            location: Lvalue::Local(rcvr_arg),\n+            target: BasicBlock::new(4),\n+            unwind: None\n+        }, true);\n+\n+        // BB #4 - resume\n+        block(&mut blocks, vec![], TerminatorKind::Resume, true);\n+    }\n+\n+    let mut mir = Mir::new(\n+        blocks,\n+        IndexVec::from_elem_n(\n+            VisibilityScopeData { span: span, parent_scope: None }, 1\n+        ),\n+        IndexVec::new(),\n+        sig.output(),\n+        local_decls,\n+        sig.inputs().len(),\n+        vec![],\n+        span\n+    );\n+    if let Abi::RustCall = sig.abi {\n+        mir.spread_arg = Some(Local::new(sig.inputs().len()));\n+    }\n+    mir\n+}\n+\n+pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n+                                      ctor_id: ast::NodeId,\n+                                      fields: &[hir::StructField],\n+                                      span: Span)\n+                                      -> (Mir<'tcx>, MirSource)\n+{\n+    let tcx = infcx.tcx;\n+    let def_id = tcx.hir.local_def_id(ctor_id);\n+    let sig = match tcx.item_type(def_id).sty {\n+        ty::TyFnDef(_, _, fty) => tcx.no_late_bound_regions(&fty)\n+            .expect(\"LBR in ADT constructor signature\"),\n+        _ => bug!(\"unexpected type for ctor {:?}\", def_id)\n+    };\n+    let sig = tcx.erase_regions(&sig);\n+\n+    let (adt_def, substs) = match sig.output().sty {\n+        ty::TyAdt(adt_def, substs) => (adt_def, substs),\n+        _ => bug!(\"unexpected type for ADT ctor {:?}\", sig.output())\n+    };\n+\n+    debug!(\"build_ctor: def_id={:?} sig={:?} fields={:?}\", def_id, sig, fields);\n+\n+    let local_decls = local_decls_for_sig(&sig);\n+\n+    let source_info = SourceInfo {\n+        span: span,\n+        scope: ARGUMENT_VISIBILITY_SCOPE\n+    };\n+\n+    let variant_no = if adt_def.is_enum() {\n+        adt_def.variant_index_with_id(def_id)\n+    } else {\n+        0\n+    };\n+\n+    // return = ADT(arg0, arg1, ...); return\n+    let start_block = BasicBlockData {\n+        statements: vec![Statement {\n+            source_info: source_info,\n+            kind: StatementKind::Assign(\n+                Lvalue::Local(RETURN_POINTER),\n+                Rvalue::Aggregate(\n+                    AggregateKind::Adt(adt_def, variant_no, substs, None),\n+                    (1..sig.inputs().len()+1).map(|i| {\n+                        Operand::Consume(Lvalue::Local(Local::new(i)))\n+                    }).collect()\n+                )\n+            )\n+        }],\n+        terminator: Some(Terminator {\n+            source_info: source_info,\n+            kind: TerminatorKind::Return,\n+        }),\n+        is_cleanup: false\n+    };\n+\n+    let mir = Mir::new(\n+        IndexVec::from_elem_n(start_block, 1),\n+        IndexVec::from_elem_n(\n+            VisibilityScopeData { span: span, parent_scope: None }, 1\n+        ),\n+        IndexVec::new(),\n+        sig.output(),\n+        local_decls,\n+        sig.inputs().len(),\n+        vec![],\n+        span\n+    );\n+    (mir, MirSource::Fn(ctor_id))\n+}"}, {"sha": "80b17c6a008f5902334915c89c4677e99d6c0f82", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -37,46 +37,50 @@ pub struct AddCallGuards;\n \n impl<'tcx> MirPass<'tcx> for AddCallGuards {\n     fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, _src: MirSource, mir: &mut Mir<'tcx>) {\n-        let pred_count: IndexVec<_, _> =\n-            mir.predecessors().iter().map(|ps| ps.len()).collect();\n+        add_call_guards(mir);\n+    }\n+}\n+\n+pub fn add_call_guards(mir: &mut Mir) {\n+    let pred_count: IndexVec<_, _> =\n+        mir.predecessors().iter().map(|ps| ps.len()).collect();\n \n-        // We need a place to store the new blocks generated\n-        let mut new_blocks = Vec::new();\n+    // We need a place to store the new blocks generated\n+    let mut new_blocks = Vec::new();\n \n-        let cur_len = mir.basic_blocks().len();\n+    let cur_len = mir.basic_blocks().len();\n \n-        for block in mir.basic_blocks_mut() {\n-            match block.terminator {\n-                Some(Terminator {\n-                    kind: TerminatorKind::Call {\n-                        destination: Some((_, ref mut destination)),\n-                        cleanup: Some(_),\n-                        ..\n-                    }, source_info\n-                }) if pred_count[*destination] > 1 => {\n-                    // It's a critical edge, break it\n-                    let call_guard = BasicBlockData {\n-                        statements: vec![],\n-                        is_cleanup: block.is_cleanup,\n-                        terminator: Some(Terminator {\n-                            source_info: source_info,\n-                            kind: TerminatorKind::Goto { target: *destination }\n-                        })\n-                    };\n+    for block in mir.basic_blocks_mut() {\n+        match block.terminator {\n+            Some(Terminator {\n+                kind: TerminatorKind::Call {\n+                    destination: Some((_, ref mut destination)),\n+                    cleanup: Some(_),\n+                    ..\n+                }, source_info\n+            }) if pred_count[*destination] > 1 => {\n+                // It's a critical edge, break it\n+                let call_guard = BasicBlockData {\n+                    statements: vec![],\n+                    is_cleanup: block.is_cleanup,\n+                    terminator: Some(Terminator {\n+                        source_info: source_info,\n+                        kind: TerminatorKind::Goto { target: *destination }\n+                    })\n+                };\n \n-                    // Get the index it will be when inserted into the MIR\n-                    let idx = cur_len + new_blocks.len();\n-                    new_blocks.push(call_guard);\n-                    *destination = BasicBlock::new(idx);\n-                }\n-                _ => {}\n+                // Get the index it will be when inserted into the MIR\n+                let idx = cur_len + new_blocks.len();\n+                new_blocks.push(call_guard);\n+                *destination = BasicBlock::new(idx);\n             }\n+            _ => {}\n         }\n+    }\n \n-        debug!(\"Broke {} N edges\", new_blocks.len());\n+    debug!(\"Broke {} N edges\", new_blocks.len());\n \n-        mir.basic_blocks_mut().extend(new_blocks);\n-    }\n+    mir.basic_blocks_mut().extend(new_blocks);\n }\n \n impl Pass for AddCallGuards {}"}, {"sha": "5d127a5aed4618d0c5c76e8380f2eb744e346120", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -29,11 +29,11 @@\n //! (non-mutating) use of `SRC`. These restrictions are conservative and may be relaxed in the\n //! future.\n \n-use def_use::DefUseAnalysis;\n use rustc::mir::{Constant, Local, LocalKind, Location, Lvalue, Mir, Operand, Rvalue, StatementKind};\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n+use util::def_use::DefUseAnalysis;\n use transform::qualify_consts;\n \n pub struct CopyPropagation;"}, {"sha": "f22a71636a98e883028c090f294e964be3dea271", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -15,7 +15,7 @@ use std::fmt;\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n use rustc::mir::transform::{Pass, MirPass, MirPassHook, MirSource};\n-use pretty;\n+use util as mir_util;\n \n pub struct Marker<'a>(pub &'a str);\n \n@@ -56,7 +56,7 @@ impl<'tcx> MirPassHook<'tcx> for DumpMir {\n         pass: &Pass,\n         is_after: bool)\n     {\n-        pretty::dump_mir(\n+        mir_util::dump_mir(\n             tcx,\n             &*pass.name(),\n             &Disambiguator {"}, {"sha": "3654ae6940c5257b11cf9ae37ed81d8f430b159a", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -42,12 +42,16 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n     }\n }\n \n+pub fn no_landing_pads<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &mut Mir<'tcx>) {\n+    if tcx.sess.no_landing_pads() {\n+        NoLandingPads.visit_mir(mir);\n+    }\n+}\n+\n impl<'tcx> MirPass<'tcx> for NoLandingPads {\n     fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     _: MirSource, mir: &mut Mir<'tcx>) {\n-        if tcx.sess.no_landing_pads() {\n-            self.visit_mir(mir);\n-        }\n+        no_landing_pads(tcx, mir)\n     }\n }\n "}, {"sha": "0a8f147b2141055ac0cec37a56a0e5659bbd421d", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -53,14 +53,18 @@ impl<'a> SimplifyCfg<'a> {\n     }\n }\n \n+pub fn simplify_cfg(mir: &mut Mir) {\n+    CfgSimplifier::new(mir).simplify();\n+    remove_dead_blocks(mir);\n+\n+    // FIXME: Should probably be moved into some kind of pass manager\n+    mir.basic_blocks_mut().raw.shrink_to_fit();\n+}\n+\n impl<'l, 'tcx> MirPass<'tcx> for SimplifyCfg<'l> {\n     fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, _src: MirSource, mir: &mut Mir<'tcx>) {\n         debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, mir);\n-        CfgSimplifier::new(mir).simplify();\n-        remove_dead_blocks(mir);\n-\n-        // FIXME: Should probably be moved into some kind of pass manager\n-        mir.basic_blocks_mut().raw.shrink_to_fit();\n+        simplify_cfg(mir);\n     }\n }\n "}, {"sha": "d20d50c561140a3f6cf526c13a554c7737f5e48c", "filename": "src/librustc_mir/util/def_use.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "previous_filename": "src/librustc_mir/def_use.rs"}, {"sha": "d0f142ad7d7a87b7a81fb7fc905cc957426bee77", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "added", "additions": 696, "deletions": 0, "changes": 696, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -0,0 +1,696 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+use rustc::hir;\n+use rustc::mir::*;\n+use rustc::middle::const_val::ConstInt;\n+use rustc::middle::lang_items;\n+use rustc::ty::{self, Ty};\n+use rustc::ty::subst::{Kind, Substs};\n+use rustc::ty::util::IntTypeExt;\n+use rustc_data_structures::indexed_vec::Idx;\n+use util::patch::MirPatch;\n+\n+use std::iter;\n+\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+pub enum DropFlagState {\n+    Present, // i.e. initialized\n+    Absent, // i.e. deinitialized or \"moved\"\n+}\n+\n+impl DropFlagState {\n+    pub fn value(self) -> bool {\n+        match self {\n+            DropFlagState::Present => true,\n+            DropFlagState::Absent => false\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum DropStyle {\n+    Dead,\n+    Static,\n+    Conditional,\n+    Open,\n+}\n+\n+#[derive(Debug)]\n+pub enum DropFlagMode {\n+    Shallow,\n+    Deep\n+}\n+\n+pub trait DropElaborator<'a, 'tcx: 'a> : fmt::Debug {\n+    type Path : Copy + fmt::Debug;\n+\n+    fn patch(&mut self) -> &mut MirPatch<'tcx>;\n+    fn mir(&self) -> &'a Mir<'tcx>;\n+    fn tcx(&self) -> ty::TyCtxt<'a, 'tcx, 'tcx>;\n+    fn param_env(&self) -> &'a ty::ParameterEnvironment<'tcx>;\n+\n+    fn drop_style(&self, path: Self::Path, mode: DropFlagMode) -> DropStyle;\n+    fn get_drop_flag(&mut self, path: Self::Path) -> Option<Operand<'tcx>>;\n+    fn clear_drop_flag(&mut self, location: Location, path: Self::Path, mode: DropFlagMode);\n+\n+\n+    fn field_subpath(&self, path: Self::Path, field: Field) -> Option<Self::Path>;\n+    fn deref_subpath(&self, path: Self::Path) -> Option<Self::Path>;\n+    fn downcast_subpath(&self, path: Self::Path, variant: usize) -> Option<Self::Path>;\n+}\n+\n+#[derive(Debug)]\n+struct DropCtxt<'l, 'b: 'l, 'tcx: 'b, D>\n+    where D : DropElaborator<'b, 'tcx> + 'l\n+{\n+    elaborator: &'l mut D,\n+\n+    source_info: SourceInfo,\n+    is_cleanup: bool,\n+\n+    lvalue: &'l Lvalue<'tcx>,\n+    path: D::Path,\n+    succ: BasicBlock,\n+    unwind: Option<BasicBlock>,\n+}\n+\n+pub fn elaborate_drop<'b, 'tcx, D>(\n+    elaborator: &mut D,\n+    source_info: SourceInfo,\n+    is_cleanup: bool,\n+    lvalue: &Lvalue<'tcx>,\n+    path: D::Path,\n+    succ: BasicBlock,\n+    unwind: Option<BasicBlock>,\n+    bb: BasicBlock)\n+    where D: DropElaborator<'b, 'tcx>\n+{\n+    assert_eq!(unwind.is_none(), is_cleanup);\n+    DropCtxt {\n+        elaborator, source_info, is_cleanup, lvalue, path, succ, unwind\n+    }.elaborate_drop(bb)\n+}\n+\n+impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n+    where D: DropElaborator<'b, 'tcx>\n+{\n+    fn lvalue_ty(&self, lvalue: &Lvalue<'tcx>) -> Ty<'tcx> {\n+        lvalue.ty(self.elaborator.mir(), self.tcx()).to_ty(self.tcx())\n+    }\n+\n+    fn tcx(&self) -> ty::TyCtxt<'b, 'tcx, 'tcx> {\n+        self.elaborator.tcx()\n+    }\n+\n+    /// This elaborates a single drop instruction, located at `bb`, and\n+    /// patches over it.\n+    ///\n+    /// The elaborated drop checks the drop flags to only drop what\n+    /// is initialized.\n+    ///\n+    /// In addition, the relevant drop flags also need to be cleared\n+    /// to avoid double-drops. However, in the middle of a complex\n+    /// drop, one must avoid clearing some of the flags before they\n+    /// are read, as that would cause a memory leak.\n+    ///\n+    /// In particular, when dropping an ADT, multiple fields may be\n+    /// joined together under the `rest` subpath. They are all controlled\n+    /// by the primary drop flag, but only the last rest-field dropped\n+    /// should clear it (and it must also not clear anything else).\n+    ///\n+    /// FIXME: I think we should just control the flags externally\n+    /// and then we do not need this machinery.\n+    pub fn elaborate_drop<'a>(&mut self, bb: BasicBlock) {\n+        debug!(\"elaborate_drop({:?})\", self);\n+        let style = self.elaborator.drop_style(self.path, DropFlagMode::Deep);\n+        debug!(\"elaborate_drop({:?}): live - {:?}\", self, style);\n+        match style {\n+            DropStyle::Dead => {\n+                self.elaborator.patch().patch_terminator(bb, TerminatorKind::Goto {\n+                    target: self.succ\n+                });\n+            }\n+            DropStyle::Static => {\n+                let loc = self.terminator_loc(bb);\n+                self.elaborator.clear_drop_flag(loc, self.path, DropFlagMode::Deep);\n+                self.elaborator.patch().patch_terminator(bb, TerminatorKind::Drop {\n+                    location: self.lvalue.clone(),\n+                    target: self.succ,\n+                    unwind: self.unwind\n+                });\n+            }\n+            DropStyle::Conditional => {\n+                let is_cleanup = self.is_cleanup; // FIXME(#6393)\n+                let succ = self.succ;\n+                let drop_bb = self.complete_drop(\n+                    is_cleanup, Some(DropFlagMode::Deep), succ);\n+                self.elaborator.patch().patch_terminator(bb, TerminatorKind::Goto {\n+                    target: drop_bb\n+                });\n+            }\n+            DropStyle::Open => {\n+                let drop_bb = self.open_drop();\n+                self.elaborator.patch().patch_terminator(bb, TerminatorKind::Goto {\n+                    target: drop_bb\n+                });\n+            }\n+        }\n+    }\n+\n+    /// Return the lvalue and move path for each field of `variant`,\n+    /// (the move path is `None` if the field is a rest field).\n+    fn move_paths_for_fields(&self,\n+                             base_lv: &Lvalue<'tcx>,\n+                             variant_path: D::Path,\n+                             variant: &'tcx ty::VariantDef,\n+                             substs: &'tcx Substs<'tcx>)\n+                             -> Vec<(Lvalue<'tcx>, Option<D::Path>)>\n+    {\n+        variant.fields.iter().enumerate().map(|(i, f)| {\n+            let field = Field::new(i);\n+            let subpath = self.elaborator.field_subpath(variant_path, field);\n+\n+            let field_ty =\n+                self.tcx().normalize_associated_type_in_env(\n+                    &f.ty(self.tcx(), substs),\n+                    self.elaborator.param_env()\n+                );\n+            (base_lv.clone().field(field, field_ty), subpath)\n+        }).collect()\n+    }\n+\n+    fn drop_subpath(&mut self,\n+                    is_cleanup: bool,\n+                    lvalue: &Lvalue<'tcx>,\n+                    path: Option<D::Path>,\n+                    succ: BasicBlock,\n+                    unwind: Option<BasicBlock>)\n+                    -> BasicBlock\n+    {\n+        if let Some(path) = path {\n+            debug!(\"drop_subpath: for std field {:?}\", lvalue);\n+\n+            DropCtxt {\n+                elaborator: self.elaborator,\n+                source_info: self.source_info,\n+                path, lvalue, succ, unwind, is_cleanup\n+            }.elaborated_drop_block()\n+        } else {\n+            debug!(\"drop_subpath: for rest field {:?}\", lvalue);\n+\n+            DropCtxt {\n+                elaborator: self.elaborator,\n+                source_info: self.source_info,\n+                lvalue, succ, unwind, is_cleanup,\n+                // Using `self.path` here to condition the drop on\n+                // our own drop flag.\n+                path: self.path\n+            }.complete_drop(is_cleanup, None, succ)\n+        }\n+    }\n+\n+    /// Create one-half of the drop ladder for a list of fields, and return\n+    /// the list of steps in it in reverse order.\n+    ///\n+    /// `unwind_ladder` is such a list of steps in reverse order,\n+    /// which is called instead of the next step if the drop unwinds\n+    /// (the first field is never reached). If it is `None`, all\n+    /// unwind targets are left blank.\n+    fn drop_halfladder<'a>(&mut self,\n+                           unwind_ladder: Option<&[BasicBlock]>,\n+                           succ: BasicBlock,\n+                           fields: &[(Lvalue<'tcx>, Option<D::Path>)],\n+                           is_cleanup: bool)\n+                           -> Vec<BasicBlock>\n+    {\n+        let mut unwind_succ = if is_cleanup {\n+            None\n+        } else {\n+            self.unwind\n+        };\n+\n+        let goto = TerminatorKind::Goto { target: succ };\n+        let mut succ = self.new_block(is_cleanup, goto);\n+\n+        // Always clear the \"master\" drop flag at the bottom of the\n+        // ladder. This is needed because the \"master\" drop flag\n+        // protects the ADT's discriminant, which is invalidated\n+        // after the ADT is dropped.\n+        let succ_loc = Location { block: succ, statement_index: 0 };\n+        self.elaborator.clear_drop_flag(succ_loc, self.path, DropFlagMode::Shallow);\n+\n+        fields.iter().rev().enumerate().map(|(i, &(ref lv, path))| {\n+            succ = self.drop_subpath(is_cleanup, lv, path, succ, unwind_succ);\n+            unwind_succ = unwind_ladder.as_ref().map(|p| p[i]);\n+            succ\n+        }).collect()\n+    }\n+\n+    /// Create a full drop ladder, consisting of 2 connected half-drop-ladders\n+    ///\n+    /// For example, with 3 fields, the drop ladder is\n+    ///\n+    /// .d0:\n+    ///     ELAB(drop location.0 [target=.d1, unwind=.c1])\n+    /// .d1:\n+    ///     ELAB(drop location.1 [target=.d2, unwind=.c2])\n+    /// .d2:\n+    ///     ELAB(drop location.2 [target=`self.succ`, unwind=`self.unwind`])\n+    /// .c1:\n+    ///     ELAB(drop location.1 [target=.c2])\n+    /// .c2:\n+    ///     ELAB(drop location.2 [target=`self.unwind`])\n+    fn drop_ladder<'a>(&mut self,\n+                       fields: Vec<(Lvalue<'tcx>, Option<D::Path>)>)\n+                       -> (BasicBlock, Option<BasicBlock>)\n+    {\n+        debug!(\"drop_ladder({:?}, {:?})\", self, fields);\n+\n+        let mut fields = fields;\n+        fields.retain(|&(ref lvalue, _)| {\n+            self.tcx().type_needs_drop_given_env(\n+                self.lvalue_ty(lvalue), self.elaborator.param_env())\n+        });\n+\n+        debug!(\"drop_ladder - fields needing drop: {:?}\", fields);\n+\n+        let unwind_ladder = if self.is_cleanup {\n+            None\n+        } else {\n+            let unwind = self.unwind.unwrap(); // FIXME(#6393)\n+            Some(self.drop_halfladder(None, unwind, &fields, true))\n+        };\n+\n+        let succ = self.succ; // FIXME(#6393)\n+        let is_cleanup = self.is_cleanup;\n+        let normal_ladder =\n+            self.drop_halfladder(unwind_ladder.as_ref().map(|x| &**x),\n+                                 succ, &fields, is_cleanup);\n+\n+        (normal_ladder.last().cloned().unwrap_or(succ),\n+         unwind_ladder.and_then(|l| l.last().cloned()).or(self.unwind))\n+    }\n+\n+    fn open_drop_for_tuple<'a>(&mut self, tys: &[Ty<'tcx>])\n+                               -> BasicBlock\n+    {\n+        debug!(\"open_drop_for_tuple({:?}, {:?})\", self, tys);\n+\n+        let fields = tys.iter().enumerate().map(|(i, &ty)| {\n+            (self.lvalue.clone().field(Field::new(i), ty),\n+             self.elaborator.field_subpath(self.path, Field::new(i)))\n+        }).collect();\n+\n+        self.drop_ladder(fields).0\n+    }\n+\n+    fn open_drop_for_box<'a>(&mut self, ty: Ty<'tcx>) -> BasicBlock\n+    {\n+        debug!(\"open_drop_for_box({:?}, {:?})\", self, ty);\n+\n+        let interior = self.lvalue.clone().deref();\n+        let interior_path = self.elaborator.deref_subpath(self.path);\n+\n+        let succ = self.succ; // FIXME(#6393)\n+        let is_cleanup = self.is_cleanup;\n+        let succ = self.box_free_block(ty, succ, is_cleanup);\n+        let unwind_succ = self.unwind.map(|u| {\n+            self.box_free_block(ty, u, true)\n+        });\n+\n+        self.drop_subpath(is_cleanup, &interior, interior_path, succ, unwind_succ)\n+    }\n+\n+    fn open_drop_for_adt<'a>(&mut self, adt: &'tcx ty::AdtDef, substs: &'tcx Substs<'tcx>)\n+                             -> BasicBlock {\n+        debug!(\"open_drop_for_adt({:?}, {:?}, {:?})\", self, adt, substs);\n+        if adt.variants.len() == 0 {\n+            return self.elaborator.patch().new_block(BasicBlockData {\n+                statements: vec![],\n+                terminator: Some(Terminator {\n+                    source_info: self.source_info,\n+                    kind: TerminatorKind::Unreachable\n+                }),\n+                is_cleanup: self.is_cleanup\n+            });\n+        }\n+\n+        let contents_drop = if adt.is_union() {\n+            (self.succ, self.unwind)\n+        } else {\n+            self.open_drop_for_adt_contents(adt, substs)\n+        };\n+\n+        if adt.has_dtor(self.tcx()) {\n+            self.destructor_call_block(contents_drop)\n+        } else {\n+            contents_drop.0\n+        }\n+    }\n+\n+    fn open_drop_for_adt_contents<'a>(&mut self, adt: &'tcx ty::AdtDef,\n+                                      substs: &'tcx Substs<'tcx>)\n+                                      -> (BasicBlock, Option<BasicBlock>) {\n+        match adt.variants.len() {\n+            1 => {\n+                let fields = self.move_paths_for_fields(\n+                    self.lvalue,\n+                    self.path,\n+                    &adt.variants[0],\n+                    substs\n+                );\n+                self.drop_ladder(fields)\n+            }\n+            _ => {\n+                let is_cleanup = self.is_cleanup;\n+                let succ = self.succ;\n+                let unwind = self.unwind; // FIXME(#6393)\n+\n+                let mut values = Vec::with_capacity(adt.variants.len());\n+                let mut normal_blocks = Vec::with_capacity(adt.variants.len());\n+                let mut unwind_blocks = if is_cleanup {\n+                    None\n+                } else {\n+                    Some(Vec::with_capacity(adt.variants.len()))\n+                };\n+                let mut otherwise = None;\n+                let mut unwind_otherwise = None;\n+                for (variant_index, discr) in adt.discriminants(self.tcx()).enumerate() {\n+                    let subpath = self.elaborator.downcast_subpath(\n+                        self.path, variant_index);\n+                    if let Some(variant_path) = subpath {\n+                        let base_lv = self.lvalue.clone().elem(\n+                            ProjectionElem::Downcast(adt, variant_index)\n+                        );\n+                        let fields = self.move_paths_for_fields(\n+                            &base_lv,\n+                            variant_path,\n+                            &adt.variants[variant_index],\n+                            substs);\n+                        values.push(discr);\n+                        if let Some(ref mut unwind_blocks) = unwind_blocks {\n+                            // We can't use the half-ladder from the original\n+                            // drop ladder, because this breaks the\n+                            // \"funclet can't have 2 successor funclets\"\n+                            // requirement from MSVC:\n+                            //\n+                            //           switch       unwind-switch\n+                            //          /      \\         /        \\\n+                            //         v1.0    v2.0  v2.0-unwind  v1.0-unwind\n+                            //         |        |      /             |\n+                            //    v1.1-unwind  v2.1-unwind           |\n+                            //      ^                                |\n+                            //       \\-------------------------------/\n+                            //\n+                            // Create a duplicate half-ladder to avoid that. We\n+                            // could technically only do this on MSVC, but I\n+                            // I want to minimize the divergence between MSVC\n+                            // and non-MSVC.\n+\n+                            let unwind = unwind.unwrap();\n+                            let halfladder = self.drop_halfladder(\n+                                None, unwind, &fields, true);\n+                            unwind_blocks.push(\n+                                halfladder.last().cloned().unwrap_or(unwind)\n+                            );\n+                        }\n+                        let (normal, _) = self.drop_ladder(fields);\n+                        normal_blocks.push(normal);\n+                    } else {\n+                        // variant not found - drop the entire enum\n+                        if let None = otherwise {\n+                            otherwise = Some(self.complete_drop(\n+                                is_cleanup,\n+                                Some(DropFlagMode::Shallow),\n+                                succ));\n+                            unwind_otherwise = unwind.map(|unwind| self.complete_drop(\n+                                true,\n+                                Some(DropFlagMode::Shallow),\n+                                unwind\n+                            ));\n+                        }\n+                    }\n+                }\n+                if let Some(block) = otherwise {\n+                    normal_blocks.push(block);\n+                    if let Some(ref mut unwind_blocks) = unwind_blocks {\n+                        unwind_blocks.push(unwind_otherwise.unwrap());\n+                    }\n+                } else {\n+                    values.pop();\n+                }\n+\n+                (self.adt_switch_block(is_cleanup, adt, normal_blocks, &values, succ),\n+                 unwind_blocks.map(|unwind_blocks| {\n+                     self.adt_switch_block(\n+                         is_cleanup, adt, unwind_blocks, &values, unwind.unwrap()\n+                     )\n+                 }))\n+            }\n+        }\n+    }\n+\n+    fn adt_switch_block(&mut self,\n+                        is_cleanup: bool,\n+                        adt: &'tcx ty::AdtDef,\n+                        blocks: Vec<BasicBlock>,\n+                        values: &[ConstInt],\n+                        succ: BasicBlock)\n+                        -> BasicBlock {\n+        // If there are multiple variants, then if something\n+        // is present within the enum the discriminant, tracked\n+        // by the rest path, must be initialized.\n+        //\n+        // Additionally, we do not want to switch on the\n+        // discriminant after it is free-ed, because that\n+        // way lies only trouble.\n+        let discr_ty = adt.repr.discr_type().to_ty(self.tcx());\n+        let discr = Lvalue::Local(self.new_temp(discr_ty));\n+        let discr_rv = Rvalue::Discriminant(self.lvalue.clone());\n+        let switch_block = self.elaborator.patch().new_block(BasicBlockData {\n+            statements: vec![\n+                Statement {\n+                    source_info: self.source_info,\n+                    kind: StatementKind::Assign(discr.clone(), discr_rv),\n+                }\n+                ],\n+            terminator: Some(Terminator {\n+                source_info: self.source_info,\n+                kind: TerminatorKind::SwitchInt {\n+                    discr: Operand::Consume(discr),\n+                    switch_ty: discr_ty,\n+                    values: From::from(values.to_owned()),\n+                    targets: blocks,\n+                }\n+            }),\n+            is_cleanup: is_cleanup,\n+        });\n+        self.drop_flag_test_block(is_cleanup, switch_block, succ)\n+    }\n+\n+    fn destructor_call_block<'a>(&mut self, (succ, unwind): (BasicBlock, Option<BasicBlock>))\n+                                 -> BasicBlock\n+    {\n+        debug!(\"destructor_call_block({:?}, {:?})\", self, succ);\n+        let tcx = self.tcx();\n+        let drop_trait = tcx.lang_items.drop_trait().unwrap();\n+        let drop_fn = tcx.associated_items(drop_trait).next().unwrap();\n+        let ty = self.lvalue_ty(self.lvalue);\n+        let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n+\n+        let re_erased = tcx.mk_region(ty::ReErased);\n+        let ref_ty = tcx.mk_ref(re_erased, ty::TypeAndMut {\n+            ty: ty,\n+            mutbl: hir::Mutability::MutMutable\n+        });\n+        let ref_lvalue = self.new_temp(ref_ty);\n+        let unit_temp = Lvalue::Local(self.new_temp(tcx.mk_nil()));\n+\n+        self.elaborator.patch().new_block(BasicBlockData {\n+            statements: vec![Statement {\n+                source_info: self.source_info,\n+                kind: StatementKind::Assign(\n+                    Lvalue::Local(ref_lvalue),\n+                    Rvalue::Ref(re_erased, BorrowKind::Mut, self.lvalue.clone())\n+                )\n+            }],\n+            terminator: Some(Terminator {\n+                kind: TerminatorKind::Call {\n+                    func: Operand::item(tcx, drop_fn.def_id, substs,\n+                                        self.source_info.span),\n+                    args: vec![Operand::Consume(Lvalue::Local(ref_lvalue))],\n+                    destination: Some((unit_temp, succ)),\n+                    cleanup: unwind,\n+                },\n+                source_info: self.source_info\n+            }),\n+            is_cleanup: self.is_cleanup,\n+        })\n+    }\n+\n+    /// The slow-path - create an \"open\", elaborated drop for a type\n+    /// which is moved-out-of only partially, and patch `bb` to a jump\n+    /// to it. This must not be called on ADTs with a destructor,\n+    /// as these can't be moved-out-of, except for `Box<T>`, which is\n+    /// special-cased.\n+    ///\n+    /// This creates a \"drop ladder\" that drops the needed fields of the\n+    /// ADT, both in the success case or if one of the destructors fail.\n+    fn open_drop<'a>(&mut self) -> BasicBlock {\n+        let ty = self.lvalue_ty(self.lvalue);\n+        let is_cleanup = self.is_cleanup; // FIXME(#6393)\n+        let succ = self.succ;\n+        match ty.sty {\n+            ty::TyClosure(def_id, substs) => {\n+                let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n+                self.open_drop_for_tuple(&tys)\n+            }\n+            ty::TyTuple(tys, _) => {\n+                self.open_drop_for_tuple(tys)\n+            }\n+            ty::TyAdt(def, _) if def.is_box() => {\n+                self.open_drop_for_box(ty.boxed_ty())\n+            }\n+            ty::TyAdt(def, substs) => {\n+                self.open_drop_for_adt(def, substs)\n+            }\n+            ty::TyDynamic(..) => {\n+                self.complete_drop(is_cleanup, Some(DropFlagMode::Deep), succ)\n+            }\n+            ty::TyArray(..) | ty::TySlice(..) => {\n+                // FIXME(#34708): handle partially-dropped\n+                // array/slice elements.\n+                self.complete_drop(is_cleanup, Some(DropFlagMode::Deep), succ)\n+            }\n+            _ => bug!(\"open drop from non-ADT `{:?}`\", ty)\n+        }\n+    }\n+\n+    /// Return a basic block that drop an lvalue using the context\n+    /// and path in `c`. If `mode` is something, also clear `c`\n+    /// according to it.\n+    ///\n+    /// if FLAG(self.path)\n+    ///     if let Some(mode) = mode: FLAG(self.path)[mode] = false\n+    ///     drop(self.lv)\n+    fn complete_drop<'a>(&mut self,\n+                         is_cleanup: bool,\n+                         drop_mode: Option<DropFlagMode>,\n+                         succ: BasicBlock) -> BasicBlock\n+    {\n+        debug!(\"complete_drop({:?},{:?})\", self, drop_mode);\n+\n+        let drop_block = self.drop_block(is_cleanup, succ);\n+        if let Some(mode) = drop_mode {\n+            let block_start = Location { block: drop_block, statement_index: 0 };\n+            self.elaborator.clear_drop_flag(block_start, self.path, mode);\n+        }\n+\n+        self.drop_flag_test_block(is_cleanup, drop_block, succ)\n+    }\n+\n+    fn elaborated_drop_block<'a>(&mut self) -> BasicBlock {\n+        debug!(\"elaborated_drop_block({:?})\", self);\n+        let is_cleanup = self.is_cleanup; // FIXME(#6393)\n+        let succ = self.succ;\n+        let blk = self.drop_block(is_cleanup, succ);\n+        self.elaborate_drop(blk);\n+        blk\n+    }\n+\n+    fn box_free_block<'a>(\n+        &mut self,\n+        ty: Ty<'tcx>,\n+        target: BasicBlock,\n+        is_cleanup: bool\n+    ) -> BasicBlock {\n+        let block = self.unelaborated_free_block(ty, target, is_cleanup);\n+        self.drop_flag_test_block(is_cleanup, block, target)\n+    }\n+\n+    fn unelaborated_free_block<'a>(\n+        &mut self,\n+        ty: Ty<'tcx>,\n+        target: BasicBlock,\n+        is_cleanup: bool\n+    ) -> BasicBlock {\n+        let tcx = self.tcx();\n+        let unit_temp = Lvalue::Local(self.new_temp(tcx.mk_nil()));\n+        let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n+        let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n+\n+        let call = TerminatorKind::Call {\n+            func: Operand::item(tcx, free_func, substs, self.source_info.span),\n+            args: vec![Operand::Consume(self.lvalue.clone())],\n+            destination: Some((unit_temp, target)),\n+            cleanup: None\n+        }; // FIXME(#6393)\n+        let free_block = self.new_block(is_cleanup, call);\n+\n+        let block_start = Location { block: free_block, statement_index: 0 };\n+        self.elaborator.clear_drop_flag(block_start, self.path, DropFlagMode::Shallow);\n+        free_block\n+    }\n+\n+    fn drop_block<'a>(&mut self, is_cleanup: bool, succ: BasicBlock) -> BasicBlock {\n+        let block = TerminatorKind::Drop {\n+            location: self.lvalue.clone(),\n+            target: succ,\n+            unwind: if is_cleanup { None } else { self.unwind }\n+        };\n+        self.new_block(is_cleanup, block)\n+    }\n+\n+    fn drop_flag_test_block(&mut self,\n+                            is_cleanup: bool,\n+                            on_set: BasicBlock,\n+                            on_unset: BasicBlock)\n+                            -> BasicBlock\n+    {\n+        let style = self.elaborator.drop_style(self.path, DropFlagMode::Shallow);\n+        debug!(\"drop_flag_test_block({:?},{:?},{:?}) - {:?}\",\n+               self, is_cleanup, on_set, style);\n+\n+        match style {\n+            DropStyle::Dead => on_unset,\n+            DropStyle::Static => on_set,\n+            DropStyle::Conditional | DropStyle::Open => {\n+                let flag = self.elaborator.get_drop_flag(self.path).unwrap();\n+                let term = TerminatorKind::if_(self.tcx(), flag, on_set, on_unset);\n+                self.new_block(is_cleanup, term)\n+            }\n+        }\n+    }\n+\n+    fn new_block<'a>(&mut self,\n+                     is_cleanup: bool,\n+                     k: TerminatorKind<'tcx>)\n+                     -> BasicBlock\n+    {\n+        self.elaborator.patch().new_block(BasicBlockData {\n+            statements: vec![],\n+            terminator: Some(Terminator {\n+                source_info: self.source_info, kind: k\n+            }),\n+            is_cleanup: is_cleanup\n+        })\n+    }\n+\n+    fn new_temp(&mut self, ty: Ty<'tcx>) -> Local {\n+        self.elaborator.patch().new_temp(ty)\n+    }\n+\n+    fn terminator_loc(&mut self, bb: BasicBlock) -> Location {\n+        let mir = self.elaborator.mir();\n+        self.elaborator.patch().terminator_loc(mir, bb)\n+    }\n+}"}, {"sha": "91600b947c6106b96fce3887c8a99cee6f96371b", "filename": "src/librustc_mir/util/graphviz.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "previous_filename": "src/librustc_mir/graphviz.rs"}, {"sha": "cafc5bca76acd8eeb2e638eee83cfef33fc35f90", "filename": "src/librustc_mir/util/mod.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod elaborate_drops;\n+pub mod def_use;\n+pub mod patch;\n+\n+mod graphviz;\n+mod pretty;\n+\n+pub use self::pretty::{dump_mir, write_mir_pretty};\n+pub use self::graphviz::{write_mir_graphviz};\n+pub use self::graphviz::write_node_label as write_graphviz_node_label;"}, {"sha": "19f240da73059d498b543a087c967581cc98b695", "filename": "src/librustc_mir/util/patch.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "previous_filename": "src/librustc_borrowck/borrowck/mir/patch.rs"}, {"sha": "35734dcce2beb631c2dd58cc319dffd7c7a7a816", "filename": "src/librustc_mir/util/pretty.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "previous_filename": "src/librustc_mir/pretty.rs"}, {"sha": "27a19d211c2908ef4f5910aa1f4915859d28cede", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -59,6 +59,7 @@ enum ArgKind {\n pub use self::attr_impl::ArgAttribute;\n \n #[allow(non_upper_case_globals)]\n+#[allow(unused)]\n mod attr_impl {\n     // The subset of llvm::Attribute needed for arguments, packed into a bitfield.\n     bitflags! {\n@@ -223,16 +224,6 @@ impl ArgType {\n         self.kind == ArgKind::Ignore\n     }\n \n-    /// Get the LLVM type for an lvalue of the original Rust type of\n-    /// this argument/return, i.e. the result of `type_of::type_of`.\n-    pub fn memory_ty(&self, ccx: &CrateContext) -> Type {\n-        if self.original_ty == Type::i1(ccx) {\n-            Type::i8(ccx)\n-        } else {\n-            self.original_ty\n-        }\n-    }\n-\n     /// Store a direct/indirect value described by this ArgType into a\n     /// lvalue for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n@@ -334,9 +325,19 @@ impl FnType {\n         fn_ty\n     }\n \n-    pub fn unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+    pub fn new_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 sig: ty::FnSig<'tcx>,\n                                 extra_args: &[Ty<'tcx>]) -> FnType {\n+        let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n+        // Don't pass the vtable, it's not an argument of the virtual fn.\n+        fn_ty.args[1].ignore();\n+        fn_ty.adjust_for_abi(ccx, sig);\n+        fn_ty\n+    }\n+\n+    fn unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                            sig: ty::FnSig<'tcx>,\n+                            extra_args: &[Ty<'tcx>]) -> FnType {\n         use self::Abi::*;\n         let cconv = match ccx.sess().target.target.adjust_abi(sig.abi) {\n             RustIntrinsic | PlatformIntrinsic |\n@@ -532,9 +533,9 @@ impl FnType {\n         }\n     }\n \n-    pub fn adjust_for_abi<'a, 'tcx>(&mut self,\n-                                    ccx: &CrateContext<'a, 'tcx>,\n-                                    sig: ty::FnSig<'tcx>) {\n+    fn adjust_for_abi<'a, 'tcx>(&mut self,\n+                                ccx: &CrateContext<'a, 'tcx>,\n+                                sig: ty::FnSig<'tcx>) {\n         let abi = sig.abi;\n         if abi == Abi::Unadjusted { return }\n "}, {"sha": "058f37f62dd82b70f87814f6ce567b2236d05c99", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -363,28 +363,6 @@ fn load_discr(bcx: &Builder, ity: layout::Integer, ptr: ValueRef,\n     }\n }\n \n-/// Yield information about how to dispatch a case of the\n-/// discriminant-like value returned by `trans_switch`.\n-///\n-/// This should ideally be less tightly tied to `_match`.\n-pub fn trans_case<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, value: Disr) -> ValueRef {\n-    let l = bcx.ccx.layout_of(t);\n-    match *l {\n-        layout::CEnum { discr, .. }\n-        | layout::General { discr, .. }=> {\n-            C_integral(Type::from_integer(bcx.ccx, discr), value.0, true)\n-        }\n-        layout::RawNullablePointer { .. } |\n-        layout::StructWrappedNullablePointer { .. } => {\n-            assert!(value == Disr(0) || value == Disr(1));\n-            C_bool(bcx.ccx, value != Disr(0))\n-        }\n-        _ => {\n-            bug!(\"{} does not have a discriminant. Represented as {:#?}\", t, l);\n-        }\n-    }\n-}\n-\n /// Set the discriminant for a new value of the given case of the given\n /// representation.\n pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: Disr) {"}, {"sha": "6bef31ccf64a423999d4f9bf664837eca1670da6", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -17,6 +17,7 @@ pub use syntax::attr::InlineAttr;\n use syntax::ast;\n use context::CrateContext;\n \n+\n /// Mark LLVM function to use provided inline heuristic.\n #[inline]\n pub fn inline(val: ValueRef, inline: InlineAttr) {"}, {"sha": "005fb3533ab0b793510bdec9fde95630c2a46744", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -11,6 +11,7 @@\n use context::SharedCrateContext;\n use monomorphize::Instance;\n use symbol_map::SymbolMap;\n+use back::symbol_names::symbol_name;\n use util::nodemap::FxHashMap;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::session::config;\n@@ -106,7 +107,7 @@ impl ExportedSymbols {\n                 .exported_symbols(cnum)\n                 .iter()\n                 .map(|&def_id| {\n-                    let name = Instance::mono(scx, def_id).symbol_name(scx);\n+                    let name = symbol_name(Instance::mono(scx.tcx(), def_id), scx);\n                     let export_level = if special_runtime_crate {\n                         // We can probably do better here by just ensuring that\n                         // it has hidden visibility rather than public\n@@ -218,9 +219,9 @@ fn symbol_for_def_id<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n     }\n \n-    let instance = Instance::mono(scx, def_id);\n+    let instance = Instance::mono(scx.tcx(), def_id);\n \n     symbol_map.get(TransItem::Fn(instance))\n               .map(str::to_owned)\n-              .unwrap_or_else(|| instance.symbol_name(scx))\n+              .unwrap_or_else(|| symbol_name(instance, scx))\n }"}, {"sha": "518995dfedcc282fac84b41ada9f0ebb288837be", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -168,105 +168,105 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     format!(\"h{:016x}\", hasher.finish())\n }\n \n-impl<'a, 'tcx> Instance<'tcx> {\n-    pub fn symbol_name(self, scx: &SharedCrateContext<'a, 'tcx>) -> String {\n-        let Instance { def: def_id, substs } = self;\n+pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n+                             scx: &SharedCrateContext<'a, 'tcx>) -> String {\n+    let def_id = instance.def_id();\n+    let substs = instance.substs;\n \n-        debug!(\"symbol_name(def_id={:?}, substs={:?})\",\n-               def_id, substs);\n+    debug!(\"symbol_name(def_id={:?}, substs={:?})\",\n+           def_id, substs);\n \n-        let node_id = scx.tcx().hir.as_local_node_id(def_id);\n+    let node_id = scx.tcx().hir.as_local_node_id(def_id);\n \n-        if let Some(id) = node_id {\n-            if scx.sess().plugin_registrar_fn.get() == Some(id) {\n-                let svh = &scx.link_meta().crate_hash;\n-                let idx = def_id.index;\n-                return scx.sess().generate_plugin_registrar_symbol(svh, idx);\n-            }\n-            if scx.sess().derive_registrar_fn.get() == Some(id) {\n-                let svh = &scx.link_meta().crate_hash;\n-                let idx = def_id.index;\n-                return scx.sess().generate_derive_registrar_symbol(svh, idx);\n-            }\n+    if let Some(id) = node_id {\n+        if scx.sess().plugin_registrar_fn.get() == Some(id) {\n+            let svh = &scx.link_meta().crate_hash;\n+            let idx = def_id.index;\n+            return scx.sess().generate_plugin_registrar_symbol(svh, idx);\n         }\n-\n-        // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n-        let attrs = scx.tcx().get_attrs(def_id);\n-        let is_foreign = if let Some(id) = node_id {\n-            match scx.tcx().hir.get(id) {\n-                hir_map::NodeForeignItem(_) => true,\n-                _ => false\n-            }\n-        } else {\n-            scx.sess().cstore.is_foreign_item(def_id)\n-        };\n-\n-        if let Some(name) = weak_lang_items::link_name(&attrs) {\n-            return name.to_string();\n+        if scx.sess().derive_registrar_fn.get() == Some(id) {\n+            let svh = &scx.link_meta().crate_hash;\n+            let idx = def_id.index;\n+            return scx.sess().generate_derive_registrar_symbol(svh, idx);\n         }\n+    }\n \n-        if is_foreign {\n-            if let Some(name) = attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n-                return name.to_string();\n-            }\n-            // Don't mangle foreign items.\n-            return scx.tcx().item_name(def_id).as_str().to_string();\n+    // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n+    let attrs = scx.tcx().get_attrs(def_id);\n+    let is_foreign = if let Some(id) = node_id {\n+        match scx.tcx().hir.get(id) {\n+            hir_map::NodeForeignItem(_) => true,\n+            _ => false\n         }\n+    } else {\n+        scx.sess().cstore.is_foreign_item(def_id)\n+    };\n \n-        if let Some(name) = attr::find_export_name_attr(scx.sess().diagnostic(), &attrs) {\n-            // Use provided name\n+    if let Some(name) = weak_lang_items::link_name(&attrs) {\n+        return name.to_string();\n+    }\n+\n+    if is_foreign {\n+        if let Some(name) = attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n             return name.to_string();\n         }\n+        // Don't mangle foreign items.\n+        return scx.tcx().item_name(def_id).as_str().to_string();\n+    }\n \n-        if attr::contains_name(&attrs, \"no_mangle\") {\n-            // Don't mangle\n-            return scx.tcx().item_name(def_id).as_str().to_string();\n-        }\n+    if let Some(name) = attr::find_export_name_attr(scx.sess().diagnostic(), &attrs) {\n+        // Use provided name\n+        return name.to_string();\n+    }\n \n-        let def_path = scx.tcx().def_path(def_id);\n-\n-        // We want to compute the \"type\" of this item. Unfortunately, some\n-        // kinds of items (e.g., closures) don't have an entry in the\n-        // item-type array. So walk back up the find the closest parent\n-        // that DOES have an entry.\n-        let mut ty_def_id = def_id;\n-        let instance_ty;\n-        loop {\n-            let key = scx.tcx().def_key(ty_def_id);\n-            match key.disambiguated_data.data {\n-                DefPathData::TypeNs(_) |\n-                DefPathData::ValueNs(_) => {\n-                    instance_ty = scx.tcx().item_type(ty_def_id);\n-                    break;\n-                }\n-                _ => {\n-                    // if we're making a symbol for something, there ought\n-                    // to be a value or type-def or something in there\n-                    // *somewhere*\n-                    ty_def_id.index = key.parent.unwrap_or_else(|| {\n-                        bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                             parent\", def_id, ty_def_id);\n-                    });\n-                }\n+    if attr::contains_name(&attrs, \"no_mangle\") {\n+        // Don't mangle\n+        return scx.tcx().item_name(def_id).as_str().to_string();\n+    }\n+\n+    let def_path = scx.tcx().def_path(def_id);\n+\n+    // We want to compute the \"type\" of this item. Unfortunately, some\n+    // kinds of items (e.g., closures) don't have an entry in the\n+    // item-type array. So walk back up the find the closest parent\n+    // that DOES have an entry.\n+    let mut ty_def_id = def_id;\n+    let instance_ty;\n+    loop {\n+        let key = scx.tcx().def_key(ty_def_id);\n+        match key.disambiguated_data.data {\n+            DefPathData::TypeNs(_) |\n+            DefPathData::ValueNs(_) => {\n+                instance_ty = scx.tcx().item_type(ty_def_id);\n+                break;\n+            }\n+            _ => {\n+                // if we're making a symbol for something, there ought\n+                // to be a value or type-def or something in there\n+                // *somewhere*\n+                ty_def_id.index = key.parent.unwrap_or_else(|| {\n+                    bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n+                          parent\", def_id, ty_def_id);\n+                });\n             }\n         }\n+    }\n \n-        // Erase regions because they may not be deterministic when hashed\n-        // and should not matter anyhow.\n-        let instance_ty = scx.tcx().erase_regions(&instance_ty);\n+    // Erase regions because they may not be deterministic when hashed\n+    // and should not matter anyhow.\n+    let instance_ty = scx.tcx().erase_regions(&instance_ty);\n \n-        let hash = get_symbol_hash(scx, &def_path, instance_ty, Some(substs));\n+    let hash = get_symbol_hash(scx, &def_path, instance_ty, Some(substs));\n \n-        let mut buffer = SymbolPathBuffer {\n-            names: Vec::with_capacity(def_path.data.len())\n-        };\n+    let mut buffer = SymbolPathBuffer {\n+        names: Vec::with_capacity(def_path.data.len())\n+    };\n \n-        item_path::with_forced_absolute_paths(|| {\n-            scx.tcx().push_item_path(&mut buffer, def_id);\n-        });\n+    item_path::with_forced_absolute_paths(|| {\n+        scx.tcx().push_item_path(&mut buffer, def_id);\n+    });\n \n-        mangle(buffer.names.into_iter(), &hash)\n-    }\n+    mangle(buffer.names.into_iter(), &hash)\n }\n \n struct SymbolPathBuffer {"}, {"sha": "6593b8e68d425fbd21a818bd87cb58b5c0348ce8", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 21, "deletions": 111, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -34,38 +34,32 @@ use back::linker::LinkerInfo;\n use back::symbol_export::{self, ExportedSymbols};\n use llvm::{Linkage, ValueRef, Vector, get_param};\n use llvm;\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::LOCAL_CRATE;\n use middle::lang_items::StartFnLangItem;\n-use rustc::ty::subst::Substs;\n-use rustc::mir::tcx::LvalueTy;\n-use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::dep_graph::{AssertDepGraphSafe, DepNode, WorkProduct};\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n use session::config::{self, NoDebugInfo};\n use rustc_incremental::IncrementalHashesMap;\n use session::{self, DataTypeKind, Session};\n-use abi::{self, FnType};\n+use abi;\n use mir::lvalue::LvalueRef;\n-use adt;\n use attributes;\n use builder::Builder;\n-use callee::{Callee};\n+use callee;\n use common::{C_bool, C_bytes_in_context, C_i32, C_uint};\n use collector::{self, TransItemCollectionMode};\n use common::{C_struct_in_context, C_u64, C_undef};\n use common::CrateContext;\n-use common::{fulfill_obligation};\n use common::{type_is_zero_size, val_ty};\n use common;\n use consts;\n use context::{SharedCrateContext, CrateContextList};\n use debuginfo;\n use declare;\n use machine;\n-use machine::{llalign_of_min, llsize_of};\n+use machine::llsize_of;\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n@@ -76,15 +70,14 @@ use trans_item::{TransItem, DefPathBasedNames};\n use type_::Type;\n use type_of;\n use value::Value;\n-use Disr;\n use util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n \n use libc::c_uint;\n use std::ffi::{CStr, CString};\n use std::rc::Rc;\n use std::str;\n use std::i32;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n use syntax::attr;\n use rustc::hir;\n use rustc::ty::layout::{self, Layout};\n@@ -317,25 +310,6 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     }\n }\n \n-pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx>,\n-                                             source_ty: Ty<'tcx>,\n-                                             target_ty: Ty<'tcx>)\n-                                             -> CustomCoerceUnsized {\n-    let trait_ref = ty::Binder(ty::TraitRef {\n-        def_id: scx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n-        substs: scx.tcx().mk_substs_trait(source_ty, &[target_ty])\n-    });\n-\n-    match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n-        traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n-            scx.tcx().custom_coerce_unsized_kind(impl_def_id)\n-        }\n-        vtable => {\n-            bug!(\"invalid CoerceUnsized vtable: {:?}\", vtable);\n-        }\n-    }\n-}\n-\n pub fn cast_shift_expr_rhs(\n     cx: &Builder, op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef\n ) -> ValueRef {\n@@ -429,7 +403,9 @@ pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef,\n         // a char is a Unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n         b.load_range_assert(ptr, 0, 0x10FFFF + 1, llvm::False, alignment.to_align())\n-    } else if (t.is_region_ptr() || t.is_box()) && !common::type_is_fat_ptr(ccx, t) {\n+    } else if (t.is_region_ptr() || t.is_box() || t.is_fn())\n+        && !common::type_is_fat_ptr(ccx, t)\n+    {\n         b.load_nonnull(ptr, alignment.to_align())\n     } else {\n         b.load(ptr, alignment.to_align())\n@@ -569,11 +545,11 @@ pub fn memcpy_ty<'a, 'tcx>(\n }\n \n pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n-                               ptr: ValueRef,\n-                               fill_byte: ValueRef,\n-                               size: ValueRef,\n-                               align: ValueRef,\n-                               volatile: bool) -> ValueRef {\n+                             ptr: ValueRef,\n+                             fill_byte: ValueRef,\n+                             size: ValueRef,\n+                             align: ValueRef,\n+                             volatile: bool) -> ValueRef {\n     let ptr_width = &b.ccx.sess().target.target.target_pointer_width[..];\n     let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n     let llintrinsicfn = b.ccx.get_intrinsic(&intrinsic_key);\n@@ -585,7 +561,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     let _s = if ccx.sess().trans_stats() {\n         let mut instance_name = String::new();\n         DefPathBasedNames::new(ccx.tcx(), true, true)\n-            .push_def_path(instance.def, &mut instance_name);\n+            .push_def_path(instance.def_id(), &mut instance_name);\n         Some(StatRecorder::new(ccx, instance_name))\n     } else {\n         None\n@@ -596,7 +572,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     // release builds.\n     info!(\"trans_instance({})\", instance);\n \n-    let fn_ty = common::def_ty(ccx.shared(), instance.def, instance.substs);\n+    let fn_ty = common::instance_ty(ccx.shared(), &instance);\n     let sig = common::ty_fn_sig(ccx, fn_ty);\n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n \n@@ -611,76 +587,10 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n         attributes::emit_uwtable(lldecl, true);\n     }\n \n-    let mir = ccx.tcx().item_mir(instance.def);\n+    let mir = ccx.tcx().instance_mir(instance.def);\n     mir::trans_mir(ccx, lldecl, &mir, instance, sig);\n }\n \n-pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                 def_id: DefId,\n-                                 substs: &'tcx Substs<'tcx>,\n-                                 disr: Disr,\n-                                 llfn: ValueRef) {\n-    attributes::inline(llfn, attributes::InlineAttr::Hint);\n-    attributes::set_frame_pointer_elimination(ccx, llfn);\n-\n-    let ctor_ty = common::def_ty(ccx.shared(), def_id, substs);\n-    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&ctor_ty.fn_sig());\n-    let fn_ty = FnType::new(ccx, sig, &[]);\n-\n-    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n-    if !fn_ty.ret.is_ignore() {\n-        // But if there are no nested returns, we skip the indirection\n-        // and have a single retslot\n-        let dest = if fn_ty.ret.is_indirect() {\n-            get_param(llfn, 0)\n-        } else {\n-            // We create an alloca to hold a pointer of type `ret.original_ty`\n-            // which will hold the pointer to the right alloca which has the\n-            // final ret value\n-            bcx.alloca(fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n-        };\n-        // Can return unsized value\n-        let mut dest_val = LvalueRef::new_sized_ty(dest, sig.output(), Alignment::AbiAligned);\n-        dest_val.ty = LvalueTy::Downcast {\n-            adt_def: sig.output().ty_adt_def().unwrap(),\n-            substs: substs,\n-            variant_index: disr.0 as usize,\n-        };\n-        let mut llarg_idx = fn_ty.ret.is_indirect() as usize;\n-        let mut arg_idx = 0;\n-        for (i, arg_ty) in sig.inputs().iter().enumerate() {\n-            let (lldestptr, _) = dest_val.trans_field_ptr(&bcx, i);\n-            let arg = &fn_ty.args[arg_idx];\n-            arg_idx += 1;\n-            if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n-                let meta = &fn_ty.args[arg_idx];\n-                arg_idx += 1;\n-                arg.store_fn_arg(&bcx, &mut llarg_idx, get_dataptr(&bcx, lldestptr));\n-                meta.store_fn_arg(&bcx, &mut llarg_idx, get_meta(&bcx, lldestptr));\n-            } else {\n-                arg.store_fn_arg(&bcx, &mut llarg_idx, lldestptr);\n-            }\n-        }\n-        adt::trans_set_discr(&bcx, sig.output(), dest, disr);\n-\n-        if fn_ty.ret.is_indirect() {\n-            bcx.ret_void();\n-            return;\n-        }\n-\n-        if let Some(cast_ty) = fn_ty.ret.cast {\n-            bcx.ret(bcx.load(\n-                bcx.pointercast(dest, cast_ty.ptr_to()),\n-                Some(llalign_of_min(ccx, fn_ty.ret.ty))\n-            ));\n-        } else {\n-            bcx.ret(bcx.load(dest, None))\n-        }\n-    } else {\n-        bcx.ret_void();\n-    }\n-}\n-\n pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n     // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n     // applicable to variable declarations and may not really make sense for\n@@ -721,7 +631,7 @@ pub fn set_link_section(ccx: &CrateContext,\n }\n \n /// Create the `main` function which will initialise the rust runtime and call\n-/// users\u2019 main function.\n+/// users main function.\n pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n     let (main_def_id, span) = match *ccx.sess().entry_fn.borrow() {\n         Some((id, span)) => {\n@@ -738,15 +648,15 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n         ccx.tcx().sess.span_fatal(span, \"compilation successful\");\n     }\n \n-    let instance = Instance::mono(ccx.shared(), main_def_id);\n+    let instance = Instance::mono(ccx.tcx(), main_def_id);\n \n     if !ccx.codegen_unit().contains_item(&TransItem::Fn(instance)) {\n         // We want to create the wrapper in the same codegen unit as Rust's main\n         // function.\n         return;\n     }\n \n-    let main_llfn = Callee::def(ccx, main_def_id, instance.substs).reify(ccx);\n+    let main_llfn = callee::get_fn(ccx, instance);\n \n     let et = ccx.sess().entry_type.get().unwrap();\n     match et {\n@@ -780,8 +690,8 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n \n         let (start_fn, args) = if use_start_lang_item {\n             let start_def_id = ccx.tcx().require_lang_item(StartFnLangItem);\n-            let empty_substs = ccx.tcx().intern_substs(&[]);\n-            let start_fn = Callee::def(ccx, start_def_id, empty_substs).reify(ccx);\n+            let start_instance = Instance::mono(ccx.tcx(), start_def_id);\n+            let start_fn = callee::get_fn(ccx, start_instance);\n             (start_fn, vec![bld.pointercast(rust_main, Type::i8p(ccx).ptr_to()), get_param(llfn, 0),\n                 get_param(llfn, 1)])\n         } else {"}, {"sha": "aefee51191ac4e3804efe66880ab7d32ee1ce5ac", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 31, "deletions": 508, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -14,531 +14,41 @@\n //! and methods are represented as just a fn ptr and not a full\n //! closure.\n \n-pub use self::CalleeData::*;\n-\n-use llvm::{self, ValueRef, get_params};\n+use llvm::{self, ValueRef};\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::{Substs, Subst};\n-use rustc::traits;\n-use abi::{Abi, FnType};\n+use rustc::ty::subst::Substs;\n use attributes;\n-use base;\n-use builder::Builder;\n use common::{self, CrateContext};\n-use cleanup::CleanupScope;\n-use mir::lvalue::LvalueRef;\n+use monomorphize;\n use consts;\n-use common::def_ty;\n use declare;\n-use value::Value;\n-use meth;\n use monomorphize::Instance;\n use trans_item::TransItem;\n use type_of;\n-use Disr;\n-use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::hir;\n-use std::iter;\n-\n-use syntax_pos::DUMMY_SP;\n-\n-use mir::lvalue::Alignment;\n-\n-#[derive(Debug)]\n-pub enum CalleeData {\n-    /// Constructor for enum variant/tuple-like-struct.\n-    NamedTupleConstructor(Disr),\n-\n-    /// Function pointer.\n-    Fn(ValueRef),\n-\n-    Intrinsic,\n-\n-    /// Trait object found in the vtable at that index.\n-    Virtual(usize)\n-}\n-\n-#[derive(Debug)]\n-pub struct Callee<'tcx> {\n-    pub data: CalleeData,\n-    pub ty: Ty<'tcx>\n-}\n-\n-impl<'tcx> Callee<'tcx> {\n-    /// Function pointer.\n-    pub fn ptr(llfn: ValueRef, ty: Ty<'tcx>) -> Callee<'tcx> {\n-        Callee {\n-            data: Fn(llfn),\n-            ty: ty\n-        }\n-    }\n-\n-    /// Function or method definition.\n-    pub fn def<'a>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>)\n-                   -> Callee<'tcx> {\n-        let tcx = ccx.tcx();\n-\n-        if let Some(trait_id) = tcx.trait_of_item(def_id) {\n-            return Callee::trait_method(ccx, trait_id, def_id, substs);\n-        }\n-\n-        let fn_ty = def_ty(ccx.shared(), def_id, substs);\n-        if let ty::TyFnDef(.., f) = fn_ty.sty {\n-            if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n-                return Callee {\n-                    data: Intrinsic,\n-                    ty: fn_ty\n-                };\n-            }\n-        }\n-\n-        // FIXME(eddyb) Detect ADT constructors more efficiently.\n-        if let Some(adt_def) = fn_ty.fn_ret().skip_binder().ty_adt_def() {\n-            if let Some(i) = adt_def.variants.iter().position(|v| def_id == v.did) {\n-                return Callee {\n-                    data: NamedTupleConstructor(Disr::for_variant(tcx, adt_def, i)),\n-                    ty: fn_ty\n-                };\n-            }\n-        }\n-\n-        let (llfn, ty) = get_fn(ccx, def_id, substs);\n-        Callee::ptr(llfn, ty)\n-    }\n-\n-    /// Trait method, which has to be resolved to an impl method.\n-    pub fn trait_method<'a>(ccx: &CrateContext<'a, 'tcx>,\n-                            trait_id: DefId,\n-                            def_id: DefId,\n-                            substs: &'tcx Substs<'tcx>)\n-                            -> Callee<'tcx> {\n-        let tcx = ccx.tcx();\n-\n-        let trait_ref = ty::TraitRef::from_method(tcx, trait_id, substs);\n-        let trait_ref = tcx.normalize_associated_type(&ty::Binder(trait_ref));\n-        match common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref) {\n-            traits::VtableImpl(vtable_impl) => {\n-                let name = tcx.item_name(def_id);\n-                let (def_id, substs) = traits::find_method(tcx, name, substs, &vtable_impl);\n-\n-                // Translate the function, bypassing Callee::def.\n-                // That is because default methods have the same ID as the\n-                // trait method used to look up the impl method that ended\n-                // up here, so calling Callee::def would infinitely recurse.\n-                let (llfn, ty) = get_fn(ccx, def_id, substs);\n-                Callee::ptr(llfn, ty)\n-            }\n-            traits::VtableClosure(vtable_closure) => {\n-                // The substitutions should have no type parameters remaining\n-                // after passing through fulfill_obligation\n-                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-                let instance = Instance::new(def_id, substs);\n-                let llfn = trans_closure_method(\n-                    ccx,\n-                    vtable_closure.closure_def_id,\n-                    vtable_closure.substs,\n-                    instance,\n-                    trait_closure_kind);\n-\n-                let method_ty = def_ty(ccx.shared(), def_id, substs);\n-                Callee::ptr(llfn, method_ty)\n-            }\n-            traits::VtableFnPointer(vtable_fn_pointer) => {\n-                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-                let instance = Instance::new(def_id, substs);\n-                let llfn = trans_fn_pointer_shim(ccx, instance,\n-                                                 trait_closure_kind,\n-                                                 vtable_fn_pointer.fn_ty);\n-\n-                let method_ty = def_ty(ccx.shared(), def_id, substs);\n-                Callee::ptr(llfn, method_ty)\n-            }\n-            traits::VtableObject(ref data) => {\n-                Callee {\n-                    data: Virtual(tcx.get_vtable_index_of_object_method(data, def_id)),\n-                    ty: def_ty(ccx.shared(), def_id, substs)\n-                }\n-            }\n-            vtable => {\n-                bug!(\"resolved vtable bad vtable {:?} in trans\", vtable);\n-            }\n-        }\n-    }\n-\n-    /// Get the abi::FnType for a direct call. Mainly deals with the fact\n-    /// that a Virtual call doesn't take the vtable, like its shim does.\n-    /// The extra argument types are for variadic (extern \"C\") functions.\n-    pub fn direct_fn_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n-                              extra_args: &[Ty<'tcx>]) -> FnType {\n-        let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&self.ty.fn_sig());\n-        let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n-        if let Virtual(_) = self.data {\n-            // Don't pass the vtable, it's not an argument of the virtual fn.\n-            fn_ty.args[1].ignore();\n-        }\n-        fn_ty.adjust_for_abi(ccx, sig);\n-        fn_ty\n-    }\n-\n-    /// Turn the callee into a function pointer.\n-    pub fn reify<'a>(self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n-        match self.data {\n-            Fn(llfn) => llfn,\n-            Virtual(_) => meth::trans_object_shim(ccx, self),\n-            NamedTupleConstructor(disr) => match self.ty.sty {\n-                ty::TyFnDef(def_id, substs, _) => {\n-                    let instance = Instance::new(def_id, substs);\n-                    if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n-                        return llfn;\n-                    }\n-\n-                    let sym = ccx.symbol_map().get_or_compute(ccx.shared(),\n-                                                              TransItem::Fn(instance));\n-                    assert!(!ccx.codegen_unit().contains_item(&TransItem::Fn(instance)));\n-                    let lldecl = declare::define_internal_fn(ccx, &sym, self.ty);\n-                    base::trans_ctor_shim(ccx, def_id, substs, disr, lldecl);\n-                    ccx.instances().borrow_mut().insert(instance, lldecl);\n-\n-                    lldecl\n-                }\n-                _ => bug!(\"expected fn item type, found {}\", self.ty)\n-            },\n-            Intrinsic => bug!(\"intrinsic {} getting reified\", self.ty)\n-        }\n-    }\n-}\n-\n-fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n-                                  def_id: DefId,\n-                                  substs: ty::ClosureSubsts<'tcx>,\n-                                  method_instance: Instance<'tcx>,\n-                                  trait_closure_kind: ty::ClosureKind)\n-                                  -> ValueRef\n-{\n-    // If this is a closure, redirect to it.\n-    let (llfn, _) = get_fn(ccx, def_id, substs.substs);\n-\n-    // If the closure is a Fn closure, but a FnOnce is needed (etc),\n-    // then adapt the self type\n-    let llfn_closure_kind = ccx.tcx().closure_kind(def_id);\n-\n-    debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n-           trait_closure_kind={:?}, llfn={:?})\",\n-           llfn_closure_kind, trait_closure_kind, Value(llfn));\n-\n-    match needs_fn_once_adapter_shim(llfn_closure_kind, trait_closure_kind) {\n-        Ok(true) => trans_fn_once_adapter_shim(ccx,\n-                                               def_id,\n-                                               substs,\n-                                               method_instance,\n-                                               llfn),\n-        Ok(false) => llfn,\n-        Err(()) => {\n-            bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n-                 llfn_closure_kind,\n-                 trait_closure_kind);\n-        }\n-    }\n-}\n-\n-pub fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n-                                  trait_closure_kind: ty::ClosureKind)\n-                                  -> Result<bool, ()>\n-{\n-    match (actual_closure_kind, trait_closure_kind) {\n-        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n-        (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n-        (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n-            // No adapter needed.\n-           Ok(false)\n-        }\n-        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n-            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n-            // `fn(&mut self, ...)`. In fact, at trans time, these are\n-            // basically the same thing, so we can just return llfn.\n-            Ok(false)\n-        }\n-        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n-        (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n-            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n-            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n-            // this by doing something like:\n-            //\n-            //     fn call_once(self, ...) { call_mut(&self, ...) }\n-            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n-            //\n-            // These are both the same at trans time.\n-            Ok(true)\n-        }\n-        _ => Err(()),\n-    }\n-}\n-\n-fn trans_fn_once_adapter_shim<'a, 'tcx>(\n-    ccx: &'a CrateContext<'a, 'tcx>,\n-    def_id: DefId,\n-    substs: ty::ClosureSubsts<'tcx>,\n-    method_instance: Instance<'tcx>,\n-    llreffn: ValueRef)\n-    -> ValueRef\n-{\n-    if let Some(&llfn) = ccx.instances().borrow().get(&method_instance) {\n-        return llfn;\n-    }\n-\n-    debug!(\"trans_fn_once_adapter_shim(def_id={:?}, substs={:?}, llreffn={:?})\",\n-           def_id, substs, Value(llreffn));\n-\n-    let tcx = ccx.tcx();\n-\n-    // Find a version of the closure type. Substitute static for the\n-    // region since it doesn't really matter.\n-    let closure_ty = tcx.mk_closure_from_closure_substs(def_id, substs);\n-    let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReErased), closure_ty);\n-\n-    // Make a version with the type of by-ref closure.\n-    let sig = tcx.closure_type(def_id).subst(tcx, substs.substs);\n-    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n-    assert_eq!(sig.abi, Abi::RustCall);\n-    let llref_fn_ty = tcx.mk_fn_ptr(ty::Binder(tcx.mk_fn_sig(\n-        iter::once(ref_closure_ty).chain(sig.inputs().iter().cloned()),\n-        sig.output(),\n-        sig.variadic,\n-        sig.unsafety,\n-        Abi::RustCall\n-    )));\n-    debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n-           llref_fn_ty);\n-\n-\n-    // Make a version of the closure type with the same arguments, but\n-    // with argument #0 being by value.\n-    let sig = tcx.mk_fn_sig(\n-        iter::once(closure_ty).chain(sig.inputs().iter().cloned()),\n-        sig.output(),\n-        sig.variadic,\n-        sig.unsafety,\n-        Abi::RustCall\n-    );\n-\n-    let fn_ty = FnType::new(ccx, sig, &[]);\n-    let llonce_fn_ty = tcx.mk_fn_ptr(ty::Binder(sig));\n-\n-    // Create the by-value helper.\n-    let function_name = method_instance.symbol_name(ccx.shared());\n-    let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n-    attributes::set_frame_pointer_elimination(ccx, lloncefn);\n-\n-    let orig_fn_ty = fn_ty;\n-    let mut bcx = Builder::new_block(ccx, lloncefn, \"entry-block\");\n-\n-    let callee = Callee {\n-        data: Fn(llreffn),\n-        ty: llref_fn_ty\n-    };\n-\n-    // the first argument (`self`) will be the (by value) closure env.\n-\n-    let mut llargs = get_params(lloncefn);\n-    let fn_ret = callee.ty.fn_ret();\n-    let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n-    let self_idx = fn_ty.ret.is_indirect() as usize;\n-    let env_arg = &orig_fn_ty.args[0];\n-    let env = if env_arg.is_indirect() {\n-        LvalueRef::new_sized_ty(llargs[self_idx], closure_ty, Alignment::AbiAligned)\n-    } else {\n-        let scratch = LvalueRef::alloca(&bcx, closure_ty, \"self\");\n-        let mut llarg_idx = self_idx;\n-        env_arg.store_fn_arg(&bcx, &mut llarg_idx, scratch.llval);\n-        scratch\n-    };\n-\n-    debug!(\"trans_fn_once_adapter_shim: env={:?}\", env);\n-    // Adjust llargs such that llargs[self_idx..] has the call arguments.\n-    // For zero-sized closures that means sneaking in a new argument.\n-    if env_arg.is_ignore() {\n-        llargs.insert(self_idx, env.llval);\n-    } else {\n-        llargs[self_idx] = env.llval;\n-    }\n-\n-    // Call the by-ref closure body with `self` in a cleanup scope,\n-    // to drop `self` when the body returns, or in case it unwinds.\n-    let self_scope = CleanupScope::schedule_drop_mem(&bcx, env);\n-\n-    let llfn = callee.reify(bcx.ccx);\n-    let llret;\n-    if let Some(landing_pad) = self_scope.landing_pad {\n-        let normal_bcx = bcx.build_sibling_block(\"normal-return\");\n-        llret = bcx.invoke(llfn, &llargs[..], normal_bcx.llbb(), landing_pad, None);\n-        bcx = normal_bcx;\n-    } else {\n-        llret = bcx.call(llfn, &llargs[..], None);\n-    }\n-    fn_ty.apply_attrs_callsite(llret);\n-\n-    if fn_ret.0.is_never() {\n-        bcx.unreachable();\n-    } else {\n-        self_scope.trans(&bcx);\n-\n-        if fn_ty.ret.is_indirect() || fn_ty.ret.is_ignore() {\n-            bcx.ret_void();\n-        } else {\n-            bcx.ret(llret);\n-        }\n-    }\n-\n-    ccx.instances().borrow_mut().insert(method_instance, lloncefn);\n-\n-    lloncefn\n-}\n-\n-/// Translates an adapter that implements the `Fn` trait for a fn\n-/// pointer. This is basically the equivalent of something like:\n-///\n-/// ```\n-/// impl<'a> Fn(&'a int) -> &'a int for fn(&int) -> &int {\n-///     extern \"rust-abi\" fn call(&self, args: (&'a int,)) -> &'a int {\n-///         (*self)(args.0)\n-///     }\n-/// }\n-/// ```\n-///\n-/// but for the bare function type given.\n-fn trans_fn_pointer_shim<'a, 'tcx>(\n-    ccx: &'a CrateContext<'a, 'tcx>,\n-    method_instance: Instance<'tcx>,\n-    closure_kind: ty::ClosureKind,\n-    bare_fn_ty: Ty<'tcx>)\n-    -> ValueRef\n-{\n-    let tcx = ccx.tcx();\n-\n-    // Normalize the type for better caching.\n-    let bare_fn_ty = tcx.normalize_associated_type(&bare_fn_ty);\n-\n-    // If this is an impl of `Fn` or `FnMut` trait, the receiver is `&self`.\n-    let is_by_ref = match closure_kind {\n-        ty::ClosureKind::Fn | ty::ClosureKind::FnMut => true,\n-        ty::ClosureKind::FnOnce => false,\n-    };\n-\n-    let llfnpointer = match bare_fn_ty.sty {\n-        ty::TyFnDef(def_id, substs, _) => {\n-            // Function definitions have to be turned into a pointer.\n-            let llfn = Callee::def(ccx, def_id, substs).reify(ccx);\n-            if !is_by_ref {\n-                // A by-value fn item is ignored, so the shim has\n-                // the same signature as the original function.\n-                return llfn;\n-            }\n-            Some(llfn)\n-        }\n-        _ => None\n-    };\n-\n-    let bare_fn_ty_maybe_ref = if is_by_ref {\n-        tcx.mk_imm_ref(tcx.mk_region(ty::ReErased), bare_fn_ty)\n-    } else {\n-        bare_fn_ty\n-    };\n-\n-    // Check if we already trans'd this shim.\n-    if let Some(&llval) = ccx.fn_pointer_shims().borrow().get(&bare_fn_ty_maybe_ref) {\n-        return llval;\n-    }\n-\n-    debug!(\"trans_fn_pointer_shim(bare_fn_ty={:?})\",\n-           bare_fn_ty);\n-\n-    // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n-    // which is the fn pointer, and `args`, which is the arguments tuple.\n-    let sig = bare_fn_ty.fn_sig();\n-    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n-    assert_eq!(sig.unsafety, hir::Unsafety::Normal);\n-    assert_eq!(sig.abi, Abi::Rust);\n-    let tuple_input_ty = tcx.intern_tup(sig.inputs(), false);\n-    let sig = tcx.mk_fn_sig(\n-        [bare_fn_ty_maybe_ref, tuple_input_ty].iter().cloned(),\n-        sig.output(),\n-        false,\n-        hir::Unsafety::Normal,\n-        Abi::RustCall\n-    );\n-    let fn_ty = FnType::new(ccx, sig, &[]);\n-    let tuple_fn_ty = tcx.mk_fn_ptr(ty::Binder(sig));\n-    debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n-\n-    //\n-    let function_name = method_instance.symbol_name(ccx.shared());\n-    let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n-    attributes::set_frame_pointer_elimination(ccx, llfn);\n-    //\n-    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n-\n-    let mut llargs = get_params(llfn);\n-\n-    let self_arg = llargs.remove(fn_ty.ret.is_indirect() as usize);\n-    let llfnpointer = llfnpointer.unwrap_or_else(|| {\n-        // the first argument (`self`) will be ptr to the fn pointer\n-        if is_by_ref {\n-            bcx.load(self_arg, None)\n-        } else {\n-            self_arg\n-        }\n-    });\n-\n-    let callee = Callee {\n-        data: Fn(llfnpointer),\n-        ty: bare_fn_ty\n-    };\n-    let fn_ret = callee.ty.fn_ret();\n-    let fn_ty = callee.direct_fn_type(ccx, &[]);\n-    let llret = bcx.call(llfnpointer, &llargs, None);\n-    fn_ty.apply_attrs_callsite(llret);\n-\n-    if fn_ret.0.is_never() {\n-        bcx.unreachable();\n-    } else {\n-        if fn_ty.ret.is_indirect() || fn_ty.ret.is_ignore() {\n-            bcx.ret_void();\n-        } else {\n-            bcx.ret(llret);\n-        }\n-    }\n-\n-    ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty_maybe_ref, llfn);\n-\n-    llfn\n-}\n+use rustc::ty::TypeFoldable;\n \n /// Translates a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n ///\n /// # Parameters\n ///\n /// - `ccx`: the crate context\n-/// - `def_id`: def id of the fn or method item being referenced\n-/// - `substs`: values for each of the fn/method's parameters\n-fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                    def_id: DefId,\n-                    substs: &'tcx Substs<'tcx>)\n-                    -> (ValueRef, Ty<'tcx>) {\n+/// - `instance`: the instance to be instantiated\n+pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                        instance: Instance<'tcx>)\n+                        -> ValueRef\n+{\n     let tcx = ccx.tcx();\n \n-    debug!(\"get_fn(def_id={:?}, substs={:?})\", def_id, substs);\n-\n-    assert!(!substs.needs_infer());\n-    assert!(!substs.has_escaping_regions());\n-    assert!(!substs.has_param_types());\n+    debug!(\"get_fn(instance={:?})\", instance);\n \n-    let substs = tcx.normalize_associated_type(&substs);\n-    let instance = Instance::new(def_id, substs);\n-    let fn_ty = common::def_ty(ccx.shared(), def_id, substs);\n+    assert!(!instance.substs.needs_infer());\n+    assert!(!instance.substs.has_escaping_regions());\n+    assert!(!instance.substs.has_param_types());\n \n+    let fn_ty = common::instance_ty(ccx.shared(), &instance);\n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n-        return (llfn, fn_ty);\n+        return llfn;\n     }\n \n     let sym = ccx.symbol_map().get_or_compute(ccx.shared(),\n@@ -586,7 +96,10 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         assert_eq!(common::val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n \n-        let attrs = ccx.tcx().get_attrs(def_id);\n+        if common::is_inline_instance(tcx, &instance) {\n+            attributes::inline(llfn, attributes::InlineAttr::Hint);\n+        }\n+        let attrs = instance.def.attrs(ccx.tcx());\n         attributes::from_fn_attrs(ccx, &attrs, llfn);\n \n         let is_local_def = ccx.shared().translation_items().borrow()\n@@ -598,7 +111,9 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n             }\n         }\n-        if ccx.use_dll_storage_attrs() && ccx.sess().cstore.is_dllimport_foreign_item(def_id) {\n+        if ccx.use_dll_storage_attrs() &&\n+            ccx.sess().cstore.is_dllimport_foreign_item(instance.def_id())\n+        {\n             unsafe {\n                 llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);\n             }\n@@ -608,5 +123,13 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     ccx.instances().borrow_mut().insert(instance, llfn);\n \n-    (llfn, fn_ty)\n+    llfn\n+}\n+\n+pub fn resolve_and_get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                    def_id: DefId,\n+                                    substs: &'tcx Substs<'tcx>)\n+                                    -> ValueRef\n+{\n+    get_fn(ccx, monomorphize::resolve(ccx.shared(), def_id, substs))\n }"}, {"sha": "5d89a67d3fd80890029273f3c6b01bfc64c406ac", "filename": "src/librustc_trans/cleanup.rs", "status": "removed", "additions": 0, "deletions": 162, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -1,162 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! ## The Cleanup module\n-//!\n-//! The cleanup module tracks what values need to be cleaned up as scopes\n-//! are exited, either via panic or just normal control flow.\n-//!\n-//! Cleanup items can be scheduled into any of the scopes on the stack.\n-//! Typically, when a scope is finished, we generate the cleanup code. This\n-//! corresponds to a normal exit from a block (for example, an expression\n-//! completing evaluation successfully without panic).\n-\n-use llvm::BasicBlockRef;\n-use base;\n-use mir::lvalue::LvalueRef;\n-use rustc::mir::tcx::LvalueTy;\n-use builder::Builder;\n-use common::Funclet;\n-use glue;\n-use type_::Type;\n-\n-pub struct CleanupScope<'tcx> {\n-    // Cleanup to run upon scope exit.\n-    cleanup: Option<DropValue<'tcx>>,\n-\n-    // Computed on creation if compiling with landing pads (!sess.no_landing_pads)\n-    pub landing_pad: Option<BasicBlockRef>,\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct DropValue<'tcx> {\n-    val: LvalueRef<'tcx>,\n-    skip_dtor: bool,\n-}\n-\n-impl<'tcx> DropValue<'tcx> {\n-    fn trans<'a>(&self, funclet: Option<&'a Funclet>, bcx: &Builder<'a, 'tcx>) {\n-        glue::call_drop_glue(bcx, self.val, self.skip_dtor, funclet)\n-    }\n-\n-    /// Creates a landing pad for the top scope. The landing pad will perform all cleanups necessary\n-    /// for an unwind and then `resume` to continue error propagation:\n-    ///\n-    ///     landing_pad -> ... cleanups ... -> [resume]\n-    ///\n-    /// This should only be called once per function, as it creates an alloca for the landingpad.\n-    fn get_landing_pad<'a>(&self, bcx: &Builder<'a, 'tcx>) -> BasicBlockRef {\n-        debug!(\"get_landing_pad\");\n-        let bcx = bcx.build_sibling_block(\"cleanup_unwind\");\n-        let llpersonality = bcx.ccx.eh_personality();\n-        bcx.set_personality_fn(llpersonality);\n-\n-        if base::wants_msvc_seh(bcx.sess()) {\n-            let pad = bcx.cleanup_pad(None, &[]);\n-            let funclet = Some(Funclet::new(pad));\n-            self.trans(funclet.as_ref(), &bcx);\n-\n-            bcx.cleanup_ret(pad, None);\n-        } else {\n-            // The landing pad return type (the type being propagated). Not sure\n-            // what this represents but it's determined by the personality\n-            // function and this is what the EH proposal example uses.\n-            let llretty = Type::struct_(bcx.ccx, &[Type::i8p(bcx.ccx), Type::i32(bcx.ccx)], false);\n-\n-            // The only landing pad clause will be 'cleanup'\n-            let llretval = bcx.landing_pad(llretty, llpersonality, 1, bcx.llfn());\n-\n-            // The landing pad block is a cleanup\n-            bcx.set_cleanup(llretval);\n-\n-            // Insert cleanup instructions into the cleanup block\n-            self.trans(None, &bcx);\n-\n-            if !bcx.sess().target.target.options.custom_unwind_resume {\n-                bcx.resume(llretval);\n-            } else {\n-                let exc_ptr = bcx.extract_value(llretval, 0);\n-                bcx.call(bcx.ccx.eh_unwind_resume(), &[exc_ptr], None);\n-                bcx.unreachable();\n-            }\n-        }\n-\n-        bcx.llbb()\n-    }\n-}\n-\n-impl<'a, 'tcx> CleanupScope<'tcx> {\n-    /// Schedules a (deep) drop of `val`, which is a pointer to an instance of `ty`\n-    pub fn schedule_drop_mem(\n-        bcx: &Builder<'a, 'tcx>, val: LvalueRef<'tcx>\n-    ) -> CleanupScope<'tcx> {\n-        if let LvalueTy::Downcast { .. } = val.ty {\n-            bug!(\"Cannot drop downcast ty yet\");\n-        }\n-        if !bcx.ccx.shared().type_needs_drop(val.ty.to_ty(bcx.tcx())) {\n-            return CleanupScope::noop();\n-        }\n-        let drop = DropValue {\n-            val: val,\n-            skip_dtor: false,\n-        };\n-\n-        CleanupScope::new(bcx, drop)\n-    }\n-\n-    /// Issue #23611: Schedules a (deep) drop of the contents of\n-    /// `val`, which is a pointer to an instance of struct/enum type\n-    /// `ty`. The scheduled code handles extracting the discriminant\n-    /// and dropping the contents associated with that variant\n-    /// *without* executing any associated drop implementation.\n-    pub fn schedule_drop_adt_contents(\n-        bcx: &Builder<'a, 'tcx>, val: LvalueRef<'tcx>\n-    ) -> CleanupScope<'tcx> {\n-        if let LvalueTy::Downcast { .. } = val.ty {\n-            bug!(\"Cannot drop downcast ty yet\");\n-        }\n-        // `if` below could be \"!contents_needs_drop\"; skipping drop\n-        // is just an optimization, so sound to be conservative.\n-        if !bcx.ccx.shared().type_needs_drop(val.ty.to_ty(bcx.tcx())) {\n-            return CleanupScope::noop();\n-        }\n-\n-        let drop = DropValue {\n-            val: val,\n-            skip_dtor: true,\n-        };\n-\n-        CleanupScope::new(bcx, drop)\n-    }\n-\n-    fn new(bcx: &Builder<'a, 'tcx>, drop_val: DropValue<'tcx>) -> CleanupScope<'tcx> {\n-        CleanupScope {\n-            cleanup: Some(drop_val),\n-            landing_pad: if !bcx.sess().no_landing_pads() {\n-                Some(drop_val.get_landing_pad(bcx))\n-            } else {\n-                None\n-            },\n-        }\n-    }\n-\n-    pub fn noop() -> CleanupScope<'tcx> {\n-        CleanupScope {\n-            cleanup: None,\n-            landing_pad: None,\n-        }\n-    }\n-\n-    pub fn trans(self, bcx: &'a Builder<'a, 'tcx>) {\n-        if let Some(cleanup) = self.cleanup {\n-            cleanup.trans(None, &bcx);\n-        }\n-    }\n-}"}, {"sha": "500802a4135d009894d5a6beec787122e910c211", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 174, "deletions": 546, "changes": 720, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -193,29 +193,21 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n-use rustc::middle::lang_items::{BoxFreeFnLangItem, ExchangeMallocFnLangItem};\n+use rustc::middle::lang_items::{ExchangeMallocFnLangItem};\n use rustc::traits;\n-use rustc::ty::subst::{Kind, Substs, Subst};\n+use rustc::ty::subst::{Substs, Subst};\n use rustc::ty::{self, TypeFoldable, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::mir::{self, Location};\n-use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n \n-use syntax::abi::Abi;\n-use syntax_pos::DUMMY_SP;\n-use base::custom_coerce_unsize_info;\n-use callee::needs_fn_once_adapter_shim;\n use context::SharedCrateContext;\n-use common::{def_ty, fulfill_obligation};\n-use glue::{self, DropGlueKind};\n+use common::{def_ty, instance_ty};\n use monomorphize::{self, Instance};\n use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n use trans_item::{TransItem, DefPathBasedNames, InstantiationMode};\n \n-use std::iter;\n-\n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum TransItemCollectionMode {\n     Eager,\n@@ -331,27 +323,23 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n     let recursion_depth_reset;\n \n     match starting_point {\n-        TransItem::DropGlue(t) => {\n-            find_drop_glue_neighbors(scx, t, &mut neighbors);\n-            recursion_depth_reset = None;\n-        }\n         TransItem::Static(node_id) => {\n             let def_id = scx.tcx().hir.local_def_id(node_id);\n+            let instance = Instance::mono(scx.tcx(), def_id);\n \n             // Sanity check whether this ended up being collected accidentally\n-            debug_assert!(should_trans_locally(scx.tcx(), def_id));\n+            debug_assert!(should_trans_locally(scx.tcx(), &instance));\n \n-            let ty = def_ty(scx, def_id, Substs::empty());\n-            let ty = glue::get_drop_glue_type(scx, ty);\n-            neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n+            let ty = instance_ty(scx, &instance);\n+            visit_drop_use(scx, ty, true, &mut neighbors);\n \n             recursion_depth_reset = None;\n \n-            collect_neighbours(scx, Instance::mono(scx, def_id), &mut neighbors);\n+            collect_neighbours(scx, instance, &mut neighbors);\n         }\n         TransItem::Fn(instance) => {\n             // Sanity check whether this ended up being collected accidentally\n-            debug_assert!(should_trans_locally(scx.tcx(), instance.def));\n+            debug_assert!(should_trans_locally(scx.tcx(), &instance));\n \n             // Keep track of the monomorphization recursion depth\n             recursion_depth_reset = Some(check_recursion_limit(scx.tcx(),\n@@ -395,27 +383,34 @@ fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    instance: Instance<'tcx>,\n                                    recursion_depths: &mut DefIdMap<usize>)\n                                    -> (DefId, usize) {\n-    let recursion_depth = recursion_depths.get(&instance.def)\n-                                          .map(|x| *x)\n-                                          .unwrap_or(0);\n+    let def_id = instance.def_id();\n+    let recursion_depth = recursion_depths.get(&def_id).cloned().unwrap_or(0);\n     debug!(\" => recursion depth={}\", recursion_depth);\n \n+    let recursion_depth = if Some(def_id) == tcx.lang_items.drop_in_place_fn() {\n+        // HACK: drop_in_place creates tight monomorphization loops. Give\n+        // it more margin.\n+        recursion_depth / 4\n+    } else {\n+        recursion_depth\n+    };\n+\n     // Code that needs to instantiate the same function recursively\n     // more than the recursion limit is assumed to be causing an\n     // infinite expansion.\n     if recursion_depth > tcx.sess.recursion_limit.get() {\n         let error = format!(\"reached the recursion limit while instantiating `{}`\",\n                             instance);\n-        if let Some(node_id) = tcx.hir.as_local_node_id(instance.def) {\n+        if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n             tcx.sess.span_fatal(tcx.hir.span(node_id), &error);\n         } else {\n             tcx.sess.fatal(&error);\n         }\n     }\n \n-    recursion_depths.insert(instance.def, recursion_depth + 1);\n+    recursion_depths.insert(def_id, recursion_depth + 1);\n \n-    (instance.def, recursion_depth)\n+    (def_id, recursion_depth)\n }\n \n fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -438,7 +433,7 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let instance_name = instance.to_string();\n         let msg = format!(\"reached the type-length limit while instantiating `{:.64}...`\",\n                           instance_name);\n-        let mut diag = if let Some(node_id) = tcx.hir.as_local_node_id(instance.def) {\n+        let mut diag = if let Some(node_id) = tcx.hir.as_local_node_id(instance.def_id()) {\n             tcx.sess.struct_span_fatal(tcx.hir.span(node_id), &msg)\n         } else {\n             tcx.sess.struct_fatal(&msg)\n@@ -489,37 +484,34 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                                           self.output);\n                 }\n             }\n+            mir::Rvalue::Cast(mir::CastKind::ReifyFnPointer, ref operand, _) => {\n+                let fn_ty = operand.ty(self.mir, self.scx.tcx());\n+                let fn_ty = monomorphize::apply_param_substs(\n+                    self.scx,\n+                    self.param_substs,\n+                    &fn_ty);\n+                visit_fn_use(self.scx, fn_ty, false, &mut self.output);\n+            }\n             mir::Rvalue::Cast(mir::CastKind::ClosureFnPointer, ref operand, _) => {\n                 let source_ty = operand.ty(self.mir, self.scx.tcx());\n                 match source_ty.sty {\n                     ty::TyClosure(def_id, substs) => {\n-                        let closure_trans_item =\n-                            create_fn_trans_item(self.scx,\n-                                                 def_id,\n-                                                 substs.substs,\n-                                                 self.param_substs);\n-                        self.output.push(closure_trans_item);\n+                        let instance = monomorphize::resolve_closure(\n+                            self.scx, def_id, substs, ty::ClosureKind::FnOnce);\n+                        self.output.push(create_fn_trans_item(instance));\n                     }\n                     _ => bug!(),\n                 }\n             }\n             mir::Rvalue::Box(..) => {\n-                let exchange_malloc_fn_def_id =\n-                    self.scx\n-                        .tcx()\n-                        .lang_items\n-                        .require(ExchangeMallocFnLangItem)\n-                        .unwrap_or_else(|e| self.scx.sess().fatal(&e));\n-\n-                if should_trans_locally(self.scx.tcx(), exchange_malloc_fn_def_id) {\n-                    let empty_substs = self.scx.empty_substs_for_def_id(exchange_malloc_fn_def_id);\n-                    let exchange_malloc_fn_trans_item =\n-                        create_fn_trans_item(self.scx,\n-                                             exchange_malloc_fn_def_id,\n-                                             empty_substs,\n-                                             self.param_substs);\n-\n-                    self.output.push(exchange_malloc_fn_trans_item);\n+                let tcx = self.scx.tcx();\n+                let exchange_malloc_fn_def_id = tcx\n+                    .lang_items\n+                    .require(ExchangeMallocFnLangItem)\n+                    .unwrap_or_else(|e| self.scx.sess().fatal(&e));\n+                let instance = Instance::mono(tcx, exchange_malloc_fn_def_id);\n+                if should_trans_locally(tcx, &instance) {\n+                    self.output.push(create_fn_trans_item(instance));\n                 }\n             }\n             _ => { /* not interesting */ }\n@@ -528,461 +520,156 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.super_rvalue(rvalue, location);\n     }\n \n-    fn visit_lvalue(&mut self,\n-                    lvalue: &mir::Lvalue<'tcx>,\n-                    context: mir_visit::LvalueContext<'tcx>,\n-                    location: Location) {\n-        debug!(\"visiting lvalue {:?}\", *lvalue);\n-\n-        if let mir_visit::LvalueContext::Drop = context {\n-            let ty = lvalue.ty(self.mir, self.scx.tcx())\n-                           .to_ty(self.scx.tcx());\n-\n-            let ty = monomorphize::apply_param_substs(self.scx,\n-                                                      self.param_substs,\n-                                                      &ty);\n-            assert!(ty.is_normalized_for_trans());\n-            let ty = glue::get_drop_glue_type(self.scx, ty);\n-            self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n-        }\n-\n-        self.super_lvalue(lvalue, context, location);\n-    }\n-\n-    fn visit_operand(&mut self, operand: &mir::Operand<'tcx>, location: Location) {\n-        debug!(\"visiting operand {:?}\", *operand);\n-\n-        let callee = match *operand {\n-            mir::Operand::Constant(ref constant) => {\n-                if let ty::TyFnDef(def_id, substs, _) = constant.ty.sty {\n-                    // This is something that can act as a callee, proceed\n-                    Some((def_id, substs))\n-                } else {\n-                    // This is not a callee, but we still have to look for\n-                    // references to `const` items\n-                    if let mir::Literal::Item { def_id, substs } = constant.literal {\n-                        let substs = monomorphize::apply_param_substs(self.scx,\n-                                                                      self.param_substs,\n-                                                                      &substs);\n-\n-                        let instance = Instance::new(def_id, substs).resolve_const(self.scx);\n-                        collect_neighbours(self.scx, instance, self.output);\n-                    }\n-\n-                    None\n-                }\n-            }\n-            _ => None\n-        };\n+    fn visit_constant(&mut self, constant: &mir::Constant<'tcx>, location: Location) {\n+        debug!(\"visiting constant {:?} @ {:?}\", *constant, location);\n \n-        if let Some((callee_def_id, callee_substs)) = callee {\n-            debug!(\" => operand is callable\");\n-\n-            // `callee_def_id` might refer to a trait method instead of a\n-            // concrete implementation, so we have to find the actual\n-            // implementation. For example, the call might look like\n-            //\n-            // std::cmp::partial_cmp(0i32, 1i32)\n-            //\n-            // Calling do_static_dispatch() here will map the def_id of\n-            // `std::cmp::partial_cmp` to the def_id of `i32::partial_cmp<i32>`\n-            let dispatched = do_static_dispatch(self.scx,\n-                                                callee_def_id,\n-                                                callee_substs,\n-                                                self.param_substs);\n-\n-            if let StaticDispatchResult::Dispatched {\n-                    def_id: callee_def_id,\n-                    substs: callee_substs,\n-                    fn_once_adjustment,\n-                } = dispatched {\n-                // if we have a concrete impl (which we might not have\n-                // in the case of something compiler generated like an\n-                // object shim or a closure that is handled differently),\n-                // we check if the callee is something that will actually\n-                // result in a translation item ...\n-                if can_result_in_trans_item(self.scx.tcx(), callee_def_id) {\n-                    // ... and create one if it does.\n-                    let trans_item = create_fn_trans_item(self.scx,\n-                                                          callee_def_id,\n-                                                          callee_substs,\n-                                                          self.param_substs);\n-                    self.output.push(trans_item);\n-\n-                    // This call will instantiate an FnOnce adapter, which drops\n-                    // the closure environment. Therefore we need to make sure\n-                    // that we collect the drop-glue for the environment type.\n-                    if let Some(env_ty) = fn_once_adjustment {\n-                        let env_ty = glue::get_drop_glue_type(self.scx, env_ty);\n-                        if self.scx.type_needs_drop(env_ty) {\n-                            let dg = DropGlueKind::Ty(env_ty);\n-                            self.output.push(TransItem::DropGlue(dg));\n-                        }\n-                    }\n-                }\n-            }\n+        if let ty::TyFnDef(..) = constant.ty.sty {\n+            // function definitions are zero-sized, and only generate\n+            // IR when they are called/reified.\n+            self.super_constant(constant, location);\n+            return\n         }\n \n-        self.super_operand(operand, location);\n-\n-        fn can_result_in_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                              def_id: DefId)\n-                                              -> bool {\n-            match tcx.item_type(def_id).sty {\n-                ty::TyFnDef(def_id, _, _) => {\n-                    // Some constructors also have type TyFnDef but they are\n-                    // always instantiated inline and don't result in a\n-                    // translation item. Same for FFI functions.\n-                    if let Some(hir_map::NodeForeignItem(_)) = tcx.hir.get_if_local(def_id) {\n-                        return false;\n-                    }\n-                }\n-                ty::TyClosure(..) => {}\n-                _ => return false\n-            }\n-\n-            should_trans_locally(tcx, def_id)\n+        if let mir::Literal::Item { def_id, substs } = constant.literal {\n+            let substs = monomorphize::apply_param_substs(self.scx,\n+                                                          self.param_substs,\n+                                                          &substs);\n+            let instance = monomorphize::resolve(self.scx, def_id, substs);\n+            collect_neighbours(self.scx, instance, self.output);\n         }\n+\n+        self.super_constant(constant, location);\n     }\n \n-    // This takes care of the \"drop_in_place\" intrinsic for which we otherwise\n-    // we would not register drop-glues.\n     fn visit_terminator_kind(&mut self,\n                              block: mir::BasicBlock,\n                              kind: &mir::TerminatorKind<'tcx>,\n                              location: Location) {\n         let tcx = self.scx.tcx();\n         match *kind {\n-            mir::TerminatorKind::Call {\n-                func: mir::Operand::Constant(ref constant),\n-                ref args,\n-                ..\n-            } => {\n-                match constant.ty.sty {\n-                    ty::TyFnDef(def_id, _, bare_fn_ty)\n-                        if is_drop_in_place_intrinsic(tcx, def_id, bare_fn_ty) => {\n-                        let operand_ty = args[0].ty(self.mir, tcx);\n-                        if let ty::TyRawPtr(mt) = operand_ty.sty {\n-                            let operand_ty = monomorphize::apply_param_substs(self.scx,\n-                                                                              self.param_substs,\n-                                                                              &mt.ty);\n-                            let ty = glue::get_drop_glue_type(self.scx, operand_ty);\n-                            self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n-                        } else {\n-                            bug!(\"Has the drop_in_place() intrinsic's signature changed?\")\n-                        }\n-                    }\n-                    _ => { /* Nothing to do. */ }\n-                }\n+            mir::TerminatorKind::Call { ref func, .. } => {\n+                let callee_ty = func.ty(self.mir, tcx);\n+                let callee_ty = monomorphize::apply_param_substs(\n+                    self.scx, self.param_substs, &callee_ty);\n+                visit_fn_use(self.scx, callee_ty, true, &mut self.output);\n+            }\n+            mir::TerminatorKind::Drop { ref location, .. } |\n+            mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n+                let ty = location.ty(self.mir, self.scx.tcx())\n+                    .to_ty(self.scx.tcx());\n+                let ty = monomorphize::apply_param_substs(self.scx,\n+                                                          self.param_substs,\n+                                                          &ty);\n+                visit_drop_use(self.scx, ty, true, self.output);\n             }\n-            _ => { /* Nothing to do. */ }\n+            mir::TerminatorKind::Goto { .. } |\n+            mir::TerminatorKind::SwitchInt { .. } |\n+            mir::TerminatorKind::Resume |\n+            mir::TerminatorKind::Return |\n+            mir::TerminatorKind::Unreachable |\n+            mir::TerminatorKind::Assert { .. } => {}\n         }\n \n         self.super_terminator_kind(block, kind, location);\n-\n-        fn is_drop_in_place_intrinsic<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                def_id: DefId,\n-                                                bare_fn_ty: ty::PolyFnSig<'tcx>)\n-                                                -> bool {\n-            (bare_fn_ty.abi() == Abi::RustIntrinsic ||\n-             bare_fn_ty.abi() == Abi::PlatformIntrinsic) &&\n-            tcx.item_name(def_id) == \"drop_in_place\"\n-        }\n     }\n }\n \n-// Returns true if we should translate an instance in the local crate.\n-// Returns false if we can just link to the upstream crate and therefore don't\n-// need a translation item.\n-fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  def_id: DefId)\n-                                  -> bool {\n-    if let ty::TyFnDef(_, _, sig) = tcx.item_type(def_id).sty {\n-        if let Some(adt_def) = sig.output().skip_binder().ty_adt_def() {\n-            if adt_def.variants.iter().any(|v| def_id == v.did) {\n-                // HACK: ADT constructors are translated in-place and\n-                // do not have a trans-item.\n-                return false;\n-            }\n-        }\n-    }\n-\n-    if def_id.is_local() {\n-        true\n-    } else {\n-        if tcx.sess.cstore.is_exported_symbol(def_id) ||\n-           tcx.sess.cstore.is_foreign_item(def_id) {\n-            // We can link to the item in question, no instance needed in this\n-            // crate\n-            false\n-        } else {\n-            if !tcx.sess.cstore.is_item_mir_available(def_id) {\n-                bug!(\"Cannot create local trans-item for {:?}\", def_id)\n-            }\n-            true\n-        }\n-    }\n+fn visit_drop_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                            ty: ty::Ty<'tcx>,\n+                            is_direct_call: bool,\n+                            output: &mut Vec<TransItem<'tcx>>)\n+{\n+    let instance = monomorphize::resolve_drop_in_place(scx, ty);\n+    visit_instance_use(scx, instance, is_direct_call, output);\n }\n \n-fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                      dg: DropGlueKind<'tcx>,\n-                                      output: &mut Vec<TransItem<'tcx>>) {\n-    let ty = match dg {\n-        DropGlueKind::Ty(ty) => ty,\n-        DropGlueKind::TyContents(_) => {\n-            // We already collected the neighbors of this item via the\n-            // DropGlueKind::Ty variant.\n-            return\n-        }\n-    };\n-\n-    debug!(\"find_drop_glue_neighbors: {}\", type_to_string(scx.tcx(), ty));\n-\n-    // Make sure the BoxFreeFn lang-item gets translated if there is a boxed value.\n-    if ty.is_box() {\n-        let def_id = scx.tcx().require_lang_item(BoxFreeFnLangItem);\n-        if should_trans_locally(scx.tcx(), def_id) {\n-            let box_free_fn_trans_item =\n-                create_fn_trans_item(scx,\n-                                     def_id,\n-                                     scx.tcx().mk_substs(iter::once(Kind::from(ty.boxed_ty()))),\n-                                     scx.tcx().intern_substs(&[]));\n-            output.push(box_free_fn_trans_item);\n-        }\n+fn visit_fn_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                          ty: ty::Ty<'tcx>,\n+                          is_direct_call: bool,\n+                          output: &mut Vec<TransItem<'tcx>>)\n+{\n+    if let ty::TyFnDef(def_id, substs, _) = ty.sty {\n+        let instance = monomorphize::resolve(scx, def_id, substs);\n+        visit_instance_use(scx, instance, is_direct_call, output);\n     }\n+}\n \n-    // If the type implements Drop, also add a translation item for the\n-    // monomorphized Drop::drop() implementation.\n-    let destructor = match ty.sty {\n-        ty::TyAdt(def, _) => def.destructor(scx.tcx()),\n-        _ => None\n-    };\n-\n-    if let (Some(destructor), false) = (destructor, ty.is_box()) {\n-        use rustc::ty::ToPolyTraitRef;\n-\n-        let drop_trait_def_id = scx.tcx()\n-                                   .lang_items\n-                                   .drop_trait()\n-                                   .unwrap();\n-\n-        let self_type_substs = scx.tcx().mk_substs_trait(ty, &[]);\n-\n-        let trait_ref = ty::TraitRef {\n-            def_id: drop_trait_def_id,\n-            substs: self_type_substs,\n-        }.to_poly_trait_ref();\n-\n-        let substs = match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n-            traits::VtableImpl(data) => data.substs,\n-            _ => bug!()\n-        };\n-\n-        if should_trans_locally(scx.tcx(), destructor.did) {\n-            let trans_item = create_fn_trans_item(scx,\n-                                                  destructor.did,\n-                                                  substs,\n-                                                  scx.tcx().intern_substs(&[]));\n-            output.push(trans_item);\n-        }\n-\n-        // This type has a Drop implementation, we'll need the contents-only\n-        // version of the glue too.\n-        output.push(TransItem::DropGlue(DropGlueKind::TyContents(ty)));\n+fn visit_instance_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                instance: ty::Instance<'tcx>,\n+                                is_direct_call: bool,\n+                                output: &mut Vec<TransItem<'tcx>>)\n+{\n+    debug!(\"visit_item_use({:?}, is_direct_call={:?})\", instance, is_direct_call);\n+    if !should_trans_locally(scx.tcx(), &instance) {\n+        return\n     }\n \n-    // Finally add the types of nested values\n-    match ty.sty {\n-        ty::TyBool      |\n-        ty::TyChar      |\n-        ty::TyInt(_)    |\n-        ty::TyUint(_)   |\n-        ty::TyStr       |\n-        ty::TyFloat(_)  |\n-        ty::TyRawPtr(_) |\n-        ty::TyRef(..)   |\n-        ty::TyFnDef(..) |\n-        ty::TyFnPtr(_)  |\n-        ty::TyNever     |\n-        ty::TyDynamic(..)  => {\n-            /* nothing to do */\n-        }\n-        ty::TyAdt(def, _) if def.is_box() => {\n-            let inner_type = glue::get_drop_glue_type(scx, ty.boxed_ty());\n-            if scx.type_needs_drop(inner_type) {\n-                output.push(TransItem::DropGlue(DropGlueKind::Ty(inner_type)));\n-            }\n-        }\n-        ty::TyAdt(def, substs) => {\n-            for field in def.all_fields() {\n-                let field_type = def_ty(scx, field.did, substs);\n-                let field_type = glue::get_drop_glue_type(scx, field_type);\n-\n-                if scx.type_needs_drop(field_type) {\n-                    output.push(TransItem::DropGlue(DropGlueKind::Ty(field_type)));\n-                }\n+    match instance.def {\n+        ty::InstanceDef::Intrinsic(def_id) => {\n+            if !is_direct_call {\n+                bug!(\"intrinsic {:?} being reified\", def_id);\n             }\n         }\n-        ty::TyClosure(def_id, substs) => {\n-            for upvar_ty in substs.upvar_tys(def_id, scx.tcx()) {\n-                let upvar_ty = glue::get_drop_glue_type(scx, upvar_ty);\n-                if scx.type_needs_drop(upvar_ty) {\n-                    output.push(TransItem::DropGlue(DropGlueKind::Ty(upvar_ty)));\n-                }\n-            }\n-        }\n-        ty::TySlice(inner_type)    |\n-        ty::TyArray(inner_type, _) => {\n-            let inner_type = glue::get_drop_glue_type(scx, inner_type);\n-            if scx.type_needs_drop(inner_type) {\n-                output.push(TransItem::DropGlue(DropGlueKind::Ty(inner_type)));\n+        ty::InstanceDef::Virtual(..) |\n+        ty::InstanceDef::DropGlue(_, None) => {\n+            // don't need to emit shim if we are calling directly.\n+            if !is_direct_call {\n+                output.push(create_fn_trans_item(instance));\n             }\n         }\n-        ty::TyTuple(args, _) => {\n-            for arg in args {\n-                let arg = glue::get_drop_glue_type(scx, arg);\n-                if scx.type_needs_drop(arg) {\n-                    output.push(TransItem::DropGlue(DropGlueKind::Ty(arg)));\n+        ty::InstanceDef::DropGlue(_, Some(ty)) => {\n+            match ty.sty {\n+                ty::TyArray(ety, _) |\n+                ty::TySlice(ety)\n+                    if is_direct_call =>\n+                {\n+                    // drop of arrays/slices is translated in-line.\n+                    visit_drop_use(scx, ety, false, output);\n                 }\n-            }\n-        }\n-        ty::TyProjection(_) |\n-        ty::TyParam(_)      |\n-        ty::TyInfer(_)      |\n-        ty::TyAnon(..)      |\n-        ty::TyError         => {\n-            bug!(\"encountered unexpected type\");\n+                _ => {}\n+            };\n+            output.push(create_fn_trans_item(instance));\n         }\n-    }\n-}\n-\n-fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                fn_def_id: DefId,\n-                                fn_substs: &'tcx Substs<'tcx>,\n-                                param_substs: &'tcx Substs<'tcx>)\n-                                -> StaticDispatchResult<'tcx> {\n-    debug!(\"do_static_dispatch(fn_def_id={}, fn_substs={:?}, param_substs={:?})\",\n-           def_id_to_string(scx.tcx(), fn_def_id),\n-           fn_substs,\n-           param_substs);\n-\n-    if let Some(trait_def_id) = scx.tcx().trait_of_item(fn_def_id) {\n-        debug!(\" => trait method, attempting to find impl\");\n-        do_static_trait_method_dispatch(scx,\n-                                        &scx.tcx().associated_item(fn_def_id),\n-                                        trait_def_id,\n-                                        fn_substs,\n-                                        param_substs)\n-    } else {\n-        debug!(\" => regular function\");\n-        // The function is not part of an impl or trait, no dispatching\n-        // to be done\n-        StaticDispatchResult::Dispatched {\n-            def_id: fn_def_id,\n-            substs: fn_substs,\n-            fn_once_adjustment: None,\n+        ty::InstanceDef::ClosureOnceShim { .. } |\n+        ty::InstanceDef::Item(..) |\n+        ty::InstanceDef::FnPtrShim(..) => {\n+            output.push(create_fn_trans_item(instance));\n         }\n     }\n }\n \n-enum StaticDispatchResult<'tcx> {\n-    // The call could be resolved statically as going to the method with\n-    // `def_id` and `substs`.\n-    Dispatched {\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n-\n-        // If this is a call to a closure that needs an FnOnce adjustment,\n-        // this contains the new self type of the call (= type of the closure\n-        // environment)\n-        fn_once_adjustment: Option<ty::Ty<'tcx>>,\n-    },\n-    // This goes to somewhere that we don't know at compile-time\n-    Unknown\n-}\n-\n-// Given a trait-method and substitution information, find out the actual\n-// implementation of the trait method.\n-fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                             trait_method: &ty::AssociatedItem,\n-                                             trait_id: DefId,\n-                                             callee_substs: &'tcx Substs<'tcx>,\n-                                             param_substs: &'tcx Substs<'tcx>)\n-                                             -> StaticDispatchResult<'tcx> {\n-    let tcx = scx.tcx();\n-    debug!(\"do_static_trait_method_dispatch(trait_method={}, \\\n-                                            trait_id={}, \\\n-                                            callee_substs={:?}, \\\n-                                            param_substs={:?}\",\n-           def_id_to_string(scx.tcx(), trait_method.def_id),\n-           def_id_to_string(scx.tcx(), trait_id),\n-           callee_substs,\n-           param_substs);\n-\n-    let rcvr_substs = monomorphize::apply_param_substs(scx,\n-                                                       param_substs,\n-                                                       &callee_substs);\n-    let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = fulfill_obligation(scx, DUMMY_SP, ty::Binder(trait_ref));\n-\n-    // Now that we know which impl is being used, we can dispatch to\n-    // the actual function:\n-    match vtbl {\n-        traits::VtableImpl(impl_data) => {\n-            let (def_id, substs) = traits::find_method(tcx,\n-                                                       trait_method.name,\n-                                                       rcvr_substs,\n-                                                       &impl_data);\n-            StaticDispatchResult::Dispatched {\n-                def_id: def_id,\n-                substs: substs,\n-                fn_once_adjustment: None,\n-            }\n-        }\n-        traits::VtableClosure(closure_data) => {\n-            let closure_def_id = closure_data.closure_def_id;\n-            let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-            let actual_closure_kind = tcx.closure_kind(closure_def_id);\n-\n-            let needs_fn_once_adapter_shim =\n-                match needs_fn_once_adapter_shim(actual_closure_kind,\n-                                                 trait_closure_kind) {\n-                Ok(true) => true,\n-                _ => false,\n-            };\n-\n-            let fn_once_adjustment = if needs_fn_once_adapter_shim {\n-                Some(tcx.mk_closure_from_closure_substs(closure_def_id,\n-                                                        closure_data.substs))\n-            } else {\n-                None\n-            };\n-\n-            StaticDispatchResult::Dispatched {\n-                def_id: closure_def_id,\n-                substs: closure_data.substs.substs,\n-                fn_once_adjustment: fn_once_adjustment,\n-            }\n-        }\n-        traits::VtableFnPointer(ref data) => {\n-            // If we know the destination of this fn-pointer, we'll have to make\n-            // sure that this destination actually gets instantiated.\n-            if let ty::TyFnDef(def_id, substs, _) = data.fn_ty.sty {\n-                // The destination of the pointer might be something that needs\n-                // further dispatching, such as a trait method, so we do that.\n-                do_static_dispatch(scx, def_id, substs, param_substs)\n+// Returns true if we should translate an instance in the local crate.\n+// Returns false if we can just link to the upstream crate and therefore don't\n+// need a translation item.\n+fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instance<'tcx>)\n+                                  -> bool {\n+    let def_id = match instance.def {\n+        ty::InstanceDef::Item(def_id) => def_id,\n+        ty::InstanceDef::ClosureOnceShim { .. } |\n+        ty::InstanceDef::Virtual(..) |\n+        ty::InstanceDef::FnPtrShim(..) |\n+        ty::InstanceDef::DropGlue(..) |\n+        ty::InstanceDef::Intrinsic(_) => return true\n+    };\n+    match tcx.hir.get_if_local(def_id) {\n+        Some(hir_map::NodeForeignItem(..)) => {\n+            false // foreign items are linked against, not translated.\n+        }\n+        Some(_) => true,\n+        None => {\n+            if tcx.sess.cstore.is_exported_symbol(def_id) ||\n+                tcx.sess.cstore.is_foreign_item(def_id)\n+            {\n+                // We can link to the item in question, no instance needed\n+                // in this crate\n+                false\n             } else {\n-                StaticDispatchResult::Unknown\n+                if !tcx.sess.cstore.is_item_mir_available(def_id) {\n+                    bug!(\"Cannot create local trans-item for {:?}\", def_id)\n+                }\n+                true\n             }\n         }\n-        // Trait object shims are always instantiated in-place, and as they are\n-        // just an ABI-adjusting indirect call they do not have any dependencies.\n-        traits::VtableObject(..) => {\n-            StaticDispatchResult::Unknown\n-        }\n-        _ => {\n-            bug!(\"static call to invalid vtable: {:?}\", vtbl)\n-        }\n     }\n }\n \n@@ -1051,7 +738,8 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n          &ty::TyAdt(target_adt_def, target_substs)) => {\n             assert_eq!(source_adt_def, target_adt_def);\n \n-            let kind = custom_coerce_unsize_info(scx, source_ty, target_ty);\n+            let kind =\n+                monomorphize::custom_coerce_unsize_info(scx, source_ty, target_ty);\n \n             let coerce_index = match kind {\n                 CustomCoerceUnsized::Struct(i) => i\n@@ -1075,28 +763,9 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     }\n }\n \n-fn create_fn_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                  def_id: DefId,\n-                                  fn_substs: &'tcx Substs<'tcx>,\n-                                  param_substs: &'tcx Substs<'tcx>)\n-                                  -> TransItem<'tcx> {\n-    let tcx = scx.tcx();\n-\n-    debug!(\"create_fn_trans_item(def_id={}, fn_substs={:?}, param_substs={:?})\",\n-            def_id_to_string(tcx, def_id),\n-            fn_substs,\n-            param_substs);\n-\n-    // We only get here, if fn_def_id either designates a local item or\n-    // an inlineable external item. Non-inlineable external items are\n-    // ignored because we don't want to generate any code for them.\n-    let concrete_substs = monomorphize::apply_param_substs(scx,\n-                                                           param_substs,\n-                                                           &fn_substs);\n-    assert!(concrete_substs.is_normalized_for_trans(),\n-            \"concrete_substs not normalized for trans: {:?}\",\n-            concrete_substs);\n-    TransItem::Fn(Instance::new(def_id, concrete_substs))\n+fn create_fn_trans_item<'a, 'tcx>(instance: Instance<'tcx>) -> TransItem<'tcx> {\n+    debug!(\"create_fn_trans_item(instance={})\", instance);\n+    TransItem::Fn(instance)\n }\n \n /// Creates a `TransItem` for each method that is referenced by the vtable for\n@@ -1111,33 +780,18 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n     if let ty::TyDynamic(ref trait_ty, ..) = trait_ty.sty {\n         if let Some(principal) = trait_ty.principal() {\n             let poly_trait_ref = principal.with_self_ty(scx.tcx(), impl_ty);\n-            let param_substs = scx.tcx().intern_substs(&[]);\n-\n             assert!(!poly_trait_ref.has_escaping_regions());\n \n             // Walk all methods of the trait, including those of its supertraits\n             let methods = traits::get_vtable_methods(scx.tcx(), poly_trait_ref);\n             let methods = methods.filter_map(|method| method)\n-                .filter_map(|(def_id, substs)| {\n-                    if let StaticDispatchResult::Dispatched {\n-                        def_id,\n-                        substs,\n-                        // We already add the drop-glue for the closure env\n-                        // unconditionally below.\n-                        fn_once_adjustment: _ ,\n-                    } = do_static_dispatch(scx, def_id, substs, param_substs) {\n-                        Some((def_id, substs))\n-                    } else {\n-                        None\n-                    }\n-                })\n-                .filter(|&(def_id, _)| should_trans_locally(scx.tcx(), def_id))\n-                .map(|(def_id, substs)| create_fn_trans_item(scx, def_id, substs, param_substs));\n+                .map(|(def_id, substs)| monomorphize::resolve(scx, def_id, substs))\n+                .filter(|&instance| should_trans_locally(scx.tcx(), &instance))\n+                .map(|instance| create_fn_trans_item(instance));\n             output.extend(methods);\n         }\n         // Also add the destructor\n-        let dg_type = glue::get_drop_glue_type(scx, impl_ty);\n-        output.push(TransItem::DropGlue(DropGlueKind::Ty(dg_type)));\n+        visit_drop_use(scx, impl_ty, false, output);\n     }\n }\n \n@@ -1182,8 +836,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                                def_id_to_string(self.scx.tcx(), def_id));\n \n                         let ty = def_ty(self.scx, def_id, Substs::empty());\n-                        let ty = glue::get_drop_glue_type(self.scx, ty);\n-                        self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n+                        visit_drop_use(self.scx, ty, true, self.output);\n                     }\n                 }\n             }\n@@ -1204,7 +857,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                     debug!(\"RootCollector: ItemFn({})\",\n                            def_id_to_string(self.scx.tcx(), def_id));\n \n-                    let instance = Instance::mono(self.scx, def_id);\n+                    let instance = Instance::mono(self.scx.tcx(), def_id);\n                     self.output.push(TransItem::Fn(instance));\n                 }\n             }\n@@ -1242,7 +895,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                     debug!(\"RootCollector: MethodImplItem({})\",\n                            def_id_to_string(self.scx.tcx(), def_id));\n \n-                    let instance = Instance::mono(self.scx, def_id);\n+                    let instance = Instance::mono(self.scx.tcx(), def_id);\n                     self.output.push(TransItem::Fn(instance));\n                 }\n             }\n@@ -1285,33 +938,17 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                         continue;\n                     }\n \n-                    // The substitutions we have are on the impl, so we grab\n-                    // the method type from the impl to substitute into.\n-                    let impl_substs = Substs::for_item(tcx, impl_def_id,\n-                                                       |_, _| tcx.mk_region(ty::ReErased),\n-                                                       |_, _| tcx.types.err);\n-                    let impl_data = traits::VtableImplData {\n-                        impl_def_id: impl_def_id,\n-                        substs: impl_substs,\n-                        nested: vec![]\n-                    };\n-                    let (def_id, substs) = traits::find_method(tcx,\n-                                                               method.name,\n-                                                               callee_substs,\n-                                                               &impl_data);\n-\n-                    let predicates = tcx.item_predicates(def_id).predicates\n-                                        .subst(tcx, substs);\n+                    let instance =\n+                        monomorphize::resolve(scx, method.def_id, callee_substs);\n+\n+                    let predicates = tcx.item_predicates(instance.def_id()).predicates\n+                        .subst(tcx, instance.substs);\n                     if !traits::normalize_and_test_predicates(tcx, predicates) {\n                         continue;\n                     }\n \n-                    if should_trans_locally(tcx, method.def_id) {\n-                        let item = create_fn_trans_item(scx,\n-                                                        method.def_id,\n-                                                        callee_substs,\n-                                                        tcx.erase_regions(&substs));\n-                        output.push(item);\n+                    if should_trans_locally(tcx, &instance) {\n+                        output.push(create_fn_trans_item(instance));\n                     }\n                 }\n             }\n@@ -1327,7 +964,7 @@ fn collect_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                 instance: Instance<'tcx>,\n                                 output: &mut Vec<TransItem<'tcx>>)\n {\n-    let mir = scx.tcx().item_mir(instance.def);\n+    let mir = scx.tcx().instance_mir(instance.def);\n \n     let mut visitor = MirNeighborCollector {\n         scx: scx,\n@@ -1351,12 +988,3 @@ fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     printer.push_def_path(def_id, &mut output);\n     output\n }\n-\n-fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            ty: ty::Ty<'tcx>)\n-                            -> String {\n-    let mut output = String::new();\n-    let printer = DefPathBasedNames::new(tcx, false, false);\n-    printer.push_type_name(ty, &mut output);\n-    output\n-}"}, {"sha": "a0906bb02f5a32893db8c4fff5f754e6ec3b33c3", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 35, "deletions": 72, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -17,7 +17,6 @@ use llvm::{ValueRef, ContextRef, TypeKind};\n use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n-use rustc::util::common::MemoizationMap;\n use middle::lang_items::LangItem;\n use base;\n use builder::Builder;\n@@ -30,13 +29,12 @@ use value::Value;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::Layout;\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::traits::{self, SelectionContext, Reveal};\n use rustc::hir;\n \n use libc::{c_uint, c_char};\n use std::iter;\n \n-use syntax::ast;\n+use syntax::attr;\n use syntax::symbol::InternedString;\n use syntax_pos::Span;\n \n@@ -426,73 +424,6 @@ pub fn is_null(val: ValueRef) -> bool {\n     }\n }\n \n-/// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n-/// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n-/// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n-pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                    span: Span,\n-                                    trait_ref: ty::PolyTraitRef<'tcx>)\n-                                    -> traits::Vtable<'tcx, ()>\n-{\n-    let tcx = scx.tcx();\n-\n-    // Remove any references to regions; this helps improve caching.\n-    let trait_ref = tcx.erase_regions(&trait_ref);\n-\n-    scx.trait_cache().memoize(trait_ref, || {\n-        debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n-               trait_ref, trait_ref.def_id());\n-\n-        // Do the initial selection for the obligation. This yields the\n-        // shallow result we are looking for -- that is, what specific impl.\n-        tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-            let mut selcx = SelectionContext::new(&infcx);\n-\n-            let obligation_cause = traits::ObligationCause::misc(span,\n-                                                             ast::DUMMY_NODE_ID);\n-            let obligation = traits::Obligation::new(obligation_cause,\n-                                                     trait_ref.to_poly_trait_predicate());\n-\n-            let selection = match selcx.select(&obligation) {\n-                Ok(Some(selection)) => selection,\n-                Ok(None) => {\n-                    // Ambiguity can happen when monomorphizing during trans\n-                    // expands to some humongo type that never occurred\n-                    // statically -- this humongo type can then overflow,\n-                    // leading to an ambiguous result. So report this as an\n-                    // overflow bug, since I believe this is the only case\n-                    // where ambiguity can result.\n-                    debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n-                            presuming due to overflow\",\n-                           trait_ref);\n-                    tcx.sess.span_fatal(span,\n-                        \"reached the recursion limit during monomorphization \\\n-                         (selection ambiguity)\");\n-                }\n-                Err(e) => {\n-                    span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                              e, trait_ref)\n-                }\n-            };\n-\n-            debug!(\"fulfill_obligation: selection={:?}\", selection);\n-\n-            // Currently, we use a fulfillment context to completely resolve\n-            // all nested obligations. This is because they can inform the\n-            // inference of the impl's type parameters.\n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n-            let vtable = selection.map(|predicate| {\n-                debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n-                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-            });\n-            let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n-\n-            info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n-            vtable\n-        })\n-    })\n-}\n-\n pub fn langcall(tcx: TyCtxt,\n                 span: Option<Span>,\n                 msg: &str,\n@@ -601,8 +532,31 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn is_closure(tcx: TyCtxt, def_id: DefId) -> bool {\n-    tcx.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr\n+pub fn requests_inline<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    instance: &ty::Instance<'tcx>\n+) -> bool {\n+    if is_inline_instance(tcx, instance) {\n+        return true\n+    }\n+    attr::requests_inline(&instance.def.attrs(tcx)[..])\n+}\n+\n+pub fn is_inline_instance<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    instance: &ty::Instance<'tcx>\n+) -> bool {\n+    let def_id = match instance.def {\n+        ty::InstanceDef::Item(def_id) => def_id,\n+        ty::InstanceDef::DropGlue(_, Some(_)) => return false,\n+        _ => return true\n+    };\n+    match tcx.def_key(def_id).disambiguated_data.data {\n+        DefPathData::StructCtor |\n+        DefPathData::EnumVariant(..) |\n+        DefPathData::ClosureExpr => true,\n+        _ => false\n+    }\n }\n \n /// Given a DefId and some Substs, produces the monomorphic item type.\n@@ -614,3 +568,12 @@ pub fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n     let ty = shared.tcx().item_type(def_id);\n     monomorphize::apply_param_substs(shared, substs, &ty)\n }\n+\n+/// Return the substituted type of an instance.\n+pub fn instance_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n+                             instance: &ty::Instance<'tcx>)\n+                             -> Ty<'tcx>\n+{\n+    let ty = instance.def.def_ty(shared.tcx());\n+    monomorphize::apply_param_substs(shared, instance.substs, &ty)\n+}"}, {"sha": "0c3d211912add2498885a63f8b2cda61c15ba02e", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n \n+use back::symbol_names;\n use llvm;\n use llvm::{SetUnnamedAddr};\n use llvm::{ValueRef, True};\n@@ -24,7 +25,6 @@ use monomorphize::Instance;\n use type_::Type;\n use type_of;\n use rustc::ty;\n-use rustc::ty::subst::Substs;\n \n use rustc::hir;\n \n@@ -80,12 +80,12 @@ pub fn addr_of(ccx: &CrateContext,\n }\n \n pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n-    let instance = Instance::mono(ccx.shared(), def_id);\n+    let instance = Instance::mono(ccx.tcx(), def_id);\n     if let Some(&g) = ccx.instances().borrow().get(&instance) {\n         return g;\n     }\n \n-    let ty = common::def_ty(ccx.shared(), def_id, Substs::empty());\n+    let ty = common::instance_ty(ccx.shared(), &instance);\n     let g = if let Some(id) = ccx.tcx().hir.as_local_node_id(def_id) {\n \n         let llty = type_of::type_of(ccx, ty);\n@@ -114,7 +114,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-                let sym = instance.symbol_name(ccx.shared());\n+                let sym = symbol_names::symbol_name(instance, ccx.shared());\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -174,7 +174,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n         g\n     } else {\n-        let sym = instance.symbol_name(ccx.shared());\n+        let sym = symbol_names::symbol_name(instance, ccx.shared());\n \n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n@@ -235,7 +235,8 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             v\n         };\n \n-        let ty = common::def_ty(ccx.shared(), def_id, Substs::empty());\n+        let instance = Instance::mono(ccx.tcx(), def_id);\n+        let ty = common::instance_ty(ccx.shared(), &instance);\n         let llty = type_of::type_of(ccx, ty);\n         let g = if val_llty == llty {\n             g"}, {"sha": "1c1395f1b7762604309616c59b07979824036bf8", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -18,10 +18,9 @@ use rustc::hir::def::ExportMap;\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n use debuginfo;\n-use callee::Callee;\n+use callee;\n use base;\n use declare;\n-use glue::DropGlueKind;\n use monomorphize::Instance;\n \n use partitioning::CodegenUnit;\n@@ -46,7 +45,7 @@ use std::str;\n use syntax::ast;\n use syntax::symbol::InternedString;\n use syntax_pos::DUMMY_SP;\n-use abi::{Abi, FnType};\n+use abi::Abi;\n \n pub struct Stats {\n     pub n_glues_created: Cell<usize>,\n@@ -94,8 +93,6 @@ pub struct LocalCrateContext<'tcx> {\n     previous_work_product: Option<WorkProduct>,\n     codegen_unit: CodegenUnit<'tcx>,\n     needs_unwind_cleanup_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n-    fn_pointer_shims: RefCell<FxHashMap<Ty<'tcx>, ValueRef>>,\n-    drop_glues: RefCell<FxHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>>,\n     /// Cache instances of monomorphic and polymorphic items\n     instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n     /// Cache generated vtables\n@@ -546,16 +543,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.translation_items\n     }\n \n-    /// Given the def-id of some item that has no type parameters, make\n-    /// a suitable \"empty substs\" for it.\n-    pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n-        Substs::for_item(self.tcx(), item_def_id,\n-                         |_, _| self.tcx().mk_region(ty::ReErased),\n-                         |_, _| {\n-            bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n-        })\n-    }\n-\n     pub fn metadata_symbol_name(&self) -> String {\n         format!(\"rust_metadata_{}_{}\",\n                 self.link_meta().crate_name,\n@@ -597,8 +584,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 previous_work_product: previous_work_product,\n                 codegen_unit: codegen_unit,\n                 needs_unwind_cleanup_cache: RefCell::new(FxHashMap()),\n-                fn_pointer_shims: RefCell::new(FxHashMap()),\n-                drop_glues: RefCell::new(FxHashMap()),\n                 instances: RefCell::new(FxHashMap()),\n                 vtables: RefCell::new(FxHashMap()),\n                 const_cstr_cache: RefCell::new(FxHashMap()),\n@@ -733,15 +718,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().needs_unwind_cleanup_cache\n     }\n \n-    pub fn fn_pointer_shims(&self) -> &RefCell<FxHashMap<Ty<'tcx>, ValueRef>> {\n-        &self.local().fn_pointer_shims\n-    }\n-\n-    pub fn drop_glues<'a>(&'a self)\n-                          -> &'a RefCell<FxHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>> {\n-        &self.local().drop_glues\n-    }\n-\n     pub fn instances<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n         &self.local().instances\n     }\n@@ -886,7 +862,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     /// Given the def-id of some item that has no type parameters, make\n     /// a suitable \"empty substs\" for it.\n     pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n-        self.shared().empty_substs_for_def_id(item_def_id)\n+        self.tcx().empty_substs_for_def_id(item_def_id)\n     }\n \n     /// Generate a new symbol name with the given prefix. This symbol name must\n@@ -930,7 +906,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         let tcx = self.tcx();\n         let llfn = match tcx.lang_items.eh_personality() {\n             Some(def_id) if !base::wants_msvc_seh(self.sess()) => {\n-                Callee::def(self, def_id, tcx.intern_substs(&[])).reify(self)\n+                callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]))\n             }\n             _ => {\n                 let name = if base::wants_msvc_seh(self.sess()) {\n@@ -958,7 +934,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         let tcx = self.tcx();\n         assert!(self.sess().target.target.options.custom_unwind_resume);\n         if let Some(def_id) = tcx.lang_items.eh_unwind_resume() {\n-            let llfn = Callee::def(self, def_id, tcx.intern_substs(&[])).reify(self);\n+            let llfn = callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]));\n             unwresume.set(Some(llfn));\n             return llfn;\n         }"}, {"sha": "8e86b50b3f7dd7c39e6c23a9df91ed679c64cfaf", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -205,7 +205,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return FunctionDebugContext::DebugInfoDisabled;\n     }\n \n-    for attr in cx.tcx().get_attrs(instance.def).iter() {\n+    for attr in instance.def.attrs(cx.tcx()).iter() {\n         if attr.check_name(\"no_debug\") {\n             return FunctionDebugContext::FunctionWithoutDebugInfo;\n         }\n@@ -229,11 +229,11 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     };\n \n     // Find the enclosing function, in case this is a closure.\n-    let def_key = cx.tcx().def_key(instance.def);\n+    let def_key = cx.tcx().def_key(instance.def_id());\n     let mut name = def_key.disambiguated_data.data.to_string();\n     let name_len = name.len();\n \n-    let fn_def_id = cx.tcx().closure_base_def_id(instance.def);\n+    let fn_def_id = cx.tcx().closure_base_def_id(instance.def_id());\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n@@ -246,11 +246,11 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                       &mut name);\n \n     // Build the linkage_name out of the item path and \"template\" parameters.\n-    let linkage_name = mangled_name_of_item(cx, instance.def, &name[name_len..]);\n+    let linkage_name = mangled_name_of_item(cx, instance.def_id(), &name[name_len..]);\n \n     let scope_line = span_start(cx, span).line;\n \n-    let local_id = cx.tcx().hir.as_local_node_id(instance.def);\n+    let local_id = cx.tcx().hir.as_local_node_id(instance.def_id());\n     let is_local_to_unit = local_id.map_or(false, |id| is_node_local_to_unit(cx, id));\n \n     let function_name = CString::new(name).unwrap();\n@@ -394,7 +394,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         // First, let's see if this is a method within an inherent impl. Because\n         // if yes, we want to make the result subroutine DIE a child of the\n         // subroutine's self-type.\n-        let self_type = cx.tcx().impl_of_method(instance.def).and_then(|impl_def_id| {\n+        let self_type = cx.tcx().impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n             // If the method does *not* belong to a trait, proceed\n             if cx.tcx().trait_id_of_impl(impl_def_id).is_none() {\n                 let impl_self_ty =\n@@ -417,9 +417,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         self_type.unwrap_or_else(|| {\n             namespace::item_namespace(cx, DefId {\n-                krate: instance.def.krate,\n+                krate: instance.def_id().krate,\n                 index: cx.tcx()\n-                         .def_key(instance.def)\n+                         .def_key(instance.def_id())\n                          .parent\n                          .expect(\"get_containing_scope: missing parent?\")\n             })"}, {"sha": "41a9ab2842dcd3e85694b6d25b73f43821fb8c58", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 14, "deletions": 395, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -13,70 +13,35 @@\n // Code relating to drop glue.\n \n use std;\n-use std::iter;\n \n use llvm;\n-use llvm::{ValueRef, get_param};\n-use middle::lang_items::BoxFreeFnLangItem;\n-use rustc::ty::subst::{Substs};\n+use llvm::{ValueRef};\n use rustc::traits;\n-use rustc::ty::{self, layout, AdtDef, AdtKind, Ty, TypeFoldable};\n-use rustc::ty::subst::Kind;\n-use rustc::mir::tcx::LvalueTy;\n-use mir::lvalue::LvalueRef;\n-use adt;\n-use base::*;\n-use callee::Callee;\n-use cleanup::CleanupScope;\n+use rustc::ty::{self, Ty, TypeFoldable};\n use common::*;\n use machine::*;\n+use meth;\n use monomorphize;\n-use trans_item::TransItem;\n-use tvec;\n-use type_of::{type_of, sizing_type_of, align_of};\n-use type_::Type;\n+use type_of::{sizing_type_of, align_of};\n use value::Value;\n-use Disr;\n use builder::Builder;\n \n-use syntax_pos::DUMMY_SP;\n-use mir::lvalue::Alignment;\n-\n-pub fn trans_exchange_free_ty<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) {\n-    let content_ty = ptr.ty.to_ty(bcx.tcx());\n-    let def_id = langcall(bcx.tcx(), None, \"\", BoxFreeFnLangItem);\n-    let substs = bcx.tcx().mk_substs(iter::once(Kind::from(content_ty)));\n-    let callee = Callee::def(bcx.ccx, def_id, substs);\n-\n-    let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n-\n-    let llret = bcx.call(callee.reify(bcx.ccx),\n-        &[ptr.llval, ptr.llextra][..1 + ptr.has_extra() as usize], None);\n-    fn_ty.apply_attrs_callsite(llret);\n-}\n-\n-pub fn get_drop_glue_type<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n+pub fn needs_drop_glue<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'tcx>) -> bool {\n     assert!(t.is_normalized_for_trans());\n \n     let t = scx.tcx().erase_regions(&t);\n \n-    // Even if there is no dtor for t, there might be one deeper down and we\n-    // might need to pass in the vtable ptr.\n-    if !scx.type_is_sized(t) {\n-        return t;\n-    }\n-\n     // FIXME (#22815): note that type_needs_drop conservatively\n     // approximates in some cases and may say a type expression\n     // requires drop glue when it actually does not.\n     //\n     // (In this case it is not clear whether any harm is done, i.e.\n-    // erroneously returning `t` in some cases where we could have\n-    // returned `tcx.types.i8` does not appear unsound. The impact on\n+    // erroneously returning `true` in some cases where we could have\n+    // returned `false` does not appear unsound. The impact on\n     // code quality is unknown at this time.)\n \n     if !scx.type_needs_drop(t) {\n-        return scx.tcx().types.i8;\n+        return false;\n     }\n     match t.sty {\n         ty::TyAdt(def, _) if def.is_box() => {\n@@ -86,215 +51,19 @@ pub fn get_drop_glue_type<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'t\n                     let layout = t.layout(&infcx).unwrap();\n                     if layout.size(&scx.tcx().data_layout).bytes() == 0 {\n                         // `Box<ZeroSizeType>` does not allocate.\n-                        scx.tcx().types.i8\n+                        false\n                     } else {\n-                        t\n+                        true\n                     }\n                 })\n             } else {\n-                t\n+                true\n             }\n         }\n-        _ => t\n+        _ => true\n     }\n }\n \n-fn drop_ty<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, args: LvalueRef<'tcx>) {\n-    call_drop_glue(bcx, args, false, None)\n-}\n-\n-pub fn call_drop_glue<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n-    mut args: LvalueRef<'tcx>,\n-    skip_dtor: bool,\n-    funclet: Option<&'a Funclet>,\n-) {\n-    let t = args.ty.to_ty(bcx.tcx());\n-    // NB: v is an *alias* of type t here, not a direct value.\n-    debug!(\"call_drop_glue(t={:?}, skip_dtor={})\", t, skip_dtor);\n-    if bcx.ccx.shared().type_needs_drop(t) {\n-        let ccx = bcx.ccx;\n-        let g = if skip_dtor {\n-            DropGlueKind::TyContents(t)\n-        } else {\n-            DropGlueKind::Ty(t)\n-        };\n-        let glue = get_drop_glue_core(ccx, g);\n-        let glue_type = get_drop_glue_type(ccx.shared(), t);\n-        if glue_type != t {\n-            args.llval = bcx.pointercast(args.llval, type_of(ccx, glue_type).ptr_to());\n-        }\n-\n-        // No drop-hint ==> call standard drop glue\n-        bcx.call(glue, &[args.llval, args.llextra][..1 + args.has_extra() as usize],\n-            funclet.map(|b| b.bundle()));\n-    }\n-}\n-\n-pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> ValueRef {\n-    get_drop_glue_core(ccx, DropGlueKind::Ty(t))\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum DropGlueKind<'tcx> {\n-    /// The normal path; runs the dtor, and then recurs on the contents\n-    Ty(Ty<'tcx>),\n-    /// Skips the dtor, if any, for ty; drops the contents directly.\n-    /// Note that the dtor is only skipped at the most *shallow*\n-    /// level, namely, an `impl Drop for Ty` itself. So, for example,\n-    /// if Ty is Newtype(S) then only the Drop impl for Newtype itself\n-    /// will be skipped, while the Drop impl for S, if any, will be\n-    /// invoked.\n-    TyContents(Ty<'tcx>),\n-}\n-\n-impl<'tcx> DropGlueKind<'tcx> {\n-    pub fn ty(&self) -> Ty<'tcx> {\n-        match *self { DropGlueKind::Ty(t) | DropGlueKind::TyContents(t) => t }\n-    }\n-\n-    pub fn map_ty<F>(&self, mut f: F) -> DropGlueKind<'tcx> where F: FnMut(Ty<'tcx>) -> Ty<'tcx>\n-    {\n-        match *self {\n-            DropGlueKind::Ty(t) => DropGlueKind::Ty(f(t)),\n-            DropGlueKind::TyContents(t) => DropGlueKind::TyContents(f(t)),\n-        }\n-    }\n-}\n-\n-fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKind<'tcx>) -> ValueRef {\n-    let g = g.map_ty(|t| get_drop_glue_type(ccx.shared(), t));\n-    match ccx.drop_glues().borrow().get(&g) {\n-        Some(&(glue, _)) => glue,\n-        None => {\n-            bug!(\"Could not find drop glue for {:?} -- {} -- {}.\",\n-                    g,\n-                    TransItem::DropGlue(g).to_raw_string(),\n-                    ccx.codegen_unit().name());\n-        }\n-    }\n-}\n-\n-pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKind<'tcx>) {\n-    assert_eq!(g.ty(), get_drop_glue_type(ccx.shared(), g.ty()));\n-    let (llfn, _) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n-\n-    let mut bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n-\n-    ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n-    // All glue functions take values passed *by alias*; this is a\n-    // requirement since in many contexts glue is invoked indirectly and\n-    // the caller has no idea if it's dealing with something that can be\n-    // passed by value.\n-    //\n-    // llfn is expected be declared to take a parameter of the appropriate\n-    // type, so we don't need to explicitly cast the function parameter.\n-\n-    // NB: v0 is an *alias* of type t here, not a direct value.\n-    // Only drop the value when it ... well, we used to check for\n-    // non-null, (and maybe we need to continue doing so), but we now\n-    // must definitely check for special bit-patterns corresponding to\n-    // the special dtor markings.\n-    let t = g.ty();\n-\n-    let value = get_param(llfn, 0);\n-    let ptr = if ccx.shared().type_is_sized(t) {\n-        LvalueRef::new_sized_ty(value, t, Alignment::AbiAligned)\n-    } else {\n-        LvalueRef::new_unsized_ty(value, get_param(llfn, 1), t, Alignment::AbiAligned)\n-    };\n-\n-    let skip_dtor = match g {\n-        DropGlueKind::Ty(_) => false,\n-        DropGlueKind::TyContents(_) => true\n-    };\n-\n-    let bcx = match t.sty {\n-        ty::TyAdt(def, _) if def.is_box() => {\n-            // Support for Box is built-in as yet and its drop glue is special\n-            // despite having a dummy Drop impl in the library.\n-            assert!(!skip_dtor);\n-            let content_ty = t.boxed_ty();\n-            let ptr = if !bcx.ccx.shared().type_is_sized(content_ty) {\n-                let llbox = bcx.load(get_dataptr(&bcx, ptr.llval), None);\n-                let info = bcx.load(get_meta(&bcx, ptr.llval), None);\n-                LvalueRef::new_unsized_ty(llbox, info, content_ty, Alignment::AbiAligned)\n-            } else {\n-                LvalueRef::new_sized_ty(\n-                    bcx.load(ptr.llval, None),\n-                    content_ty, Alignment::AbiAligned)\n-            };\n-            drop_ty(&bcx, ptr);\n-            trans_exchange_free_ty(&bcx, ptr);\n-            bcx\n-        }\n-        ty::TyDynamic(..) => {\n-            // No support in vtable for distinguishing destroying with\n-            // versus without calling Drop::drop. Assert caller is\n-            // okay with always calling the Drop impl, if any.\n-            assert!(!skip_dtor);\n-            let dtor = bcx.load(ptr.llextra, None);\n-            bcx.call(dtor, &[ptr.llval], None);\n-            bcx\n-        }\n-        ty::TyAdt(def, ..) if def.has_dtor(bcx.tcx()) && !skip_dtor => {\n-            let shallow_drop = def.is_union();\n-            let tcx = bcx.tcx();\n-\n-            let def = t.ty_adt_def().unwrap();\n-\n-            // Be sure to put the contents into a scope so we can use an invoke\n-            // instruction to call the user destructor but still call the field\n-            // destructors if the user destructor panics.\n-            //\n-            // FIXME (#14875) panic-in-drop semantics might be unsupported; we\n-            // might well consider changing below to more direct code.\n-            // Issue #23611: schedule cleanup of contents, re-inspecting the\n-            // discriminant (if any) in case of variant swap in drop code.\n-            let contents_scope = if !shallow_drop {\n-                CleanupScope::schedule_drop_adt_contents(&bcx, ptr)\n-            } else {\n-                CleanupScope::noop()\n-            };\n-\n-            let trait_ref = ty::Binder(ty::TraitRef {\n-                def_id: tcx.lang_items.drop_trait().unwrap(),\n-                substs: tcx.mk_substs_trait(t, &[])\n-            });\n-            let vtbl = match fulfill_obligation(bcx.ccx.shared(), DUMMY_SP, trait_ref) {\n-                traits::VtableImpl(data) => data,\n-                _ => bug!(\"dtor for {:?} is not an impl???\", t)\n-            };\n-            let dtor_did = def.destructor(tcx).unwrap().did;\n-            let callee = Callee::def(bcx.ccx, dtor_did, vtbl.substs);\n-            let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n-            let llret;\n-            let args = &[ptr.llval, ptr.llextra][..1 + ptr.has_extra() as usize];\n-            if let Some(landing_pad) = contents_scope.landing_pad {\n-                let normal_bcx = bcx.build_sibling_block(\"normal-return\");\n-                llret = bcx.invoke(callee.reify(ccx), args, normal_bcx.llbb(), landing_pad, None);\n-                bcx = normal_bcx;\n-            } else {\n-                llret = bcx.call(callee.reify(bcx.ccx), args, None);\n-            }\n-            fn_ty.apply_attrs_callsite(llret);\n-            contents_scope.trans(&bcx);\n-            bcx\n-        }\n-        ty::TyAdt(def, ..) if def.is_union() => {\n-            bcx\n-        }\n-        _ => {\n-            if bcx.ccx.shared().type_needs_drop(t) {\n-                drop_structural_ty(bcx, ptr)\n-            } else {\n-                bcx\n-            }\n-        }\n-    };\n-    bcx.ret_void();\n-}\n-\n pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n                                        -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n@@ -381,20 +150,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             (size, align)\n         }\n         ty::TyDynamic(..) => {\n-            // info points to the vtable and the second entry in the vtable is the\n-            // dynamic size of the object.\n-            let info = bcx.pointercast(info, Type::int(bcx.ccx).ptr_to());\n-            let size_ptr = bcx.gepi(info, &[1]);\n-            let align_ptr = bcx.gepi(info, &[2]);\n-\n-            let size = bcx.load(size_ptr, None);\n-            let align = bcx.load(align_ptr, None);\n-\n-            // Vtable loads are invariant\n-            bcx.set_invariant_load(size);\n-            bcx.set_invariant_load(align);\n-\n-            (size, align)\n+            // load size/align from vtable\n+            (meth::SIZE.get_usize(bcx, info), meth::ALIGN.get_usize(bcx, info))\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit_ty = t.sequence_element_type(bcx.tcx());\n@@ -409,141 +166,3 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n         _ => bug!(\"Unexpected unsized type, found {}\", t)\n     }\n }\n-\n-// Iterates through the elements of a structural type, dropping them.\n-fn drop_structural_ty<'a, 'tcx>(\n-    cx: Builder<'a, 'tcx>,\n-    mut ptr: LvalueRef<'tcx>\n-) -> Builder<'a, 'tcx> {\n-    fn iter_variant_fields<'a, 'tcx>(\n-        cx: &'a Builder<'a, 'tcx>,\n-        av: LvalueRef<'tcx>,\n-        adt_def: &'tcx AdtDef,\n-        variant_index: usize,\n-        substs: &'tcx Substs<'tcx>\n-    ) {\n-        let variant = &adt_def.variants[variant_index];\n-        let tcx = cx.tcx();\n-        for (i, field) in variant.fields.iter().enumerate() {\n-            let arg = monomorphize::field_ty(tcx, substs, field);\n-            let (field_ptr, align) = av.trans_field_ptr(&cx, i);\n-            drop_ty(&cx, LvalueRef::new_sized_ty(field_ptr, arg, align));\n-        }\n-    }\n-\n-    let mut cx = cx;\n-    let t = ptr.ty.to_ty(cx.tcx());\n-    match t.sty {\n-        ty::TyClosure(def_id, substs) => {\n-            for (i, upvar_ty) in substs.upvar_tys(def_id, cx.tcx()).enumerate() {\n-                let (llupvar, align) = ptr.trans_field_ptr(&cx, i);\n-                drop_ty(&cx, LvalueRef::new_sized_ty(llupvar, upvar_ty, align));\n-            }\n-        }\n-        ty::TyArray(_, n) => {\n-            let base = get_dataptr(&cx, ptr.llval);\n-            let len = C_uint(cx.ccx, n);\n-            let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::slice_for_each(&cx, base, unit_ty, len,\n-                |bb, vv| drop_ty(bb, LvalueRef::new_sized_ty(vv, unit_ty, ptr.alignment)));\n-        }\n-        ty::TySlice(_) | ty::TyStr => {\n-            let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::slice_for_each(&cx, ptr.llval, unit_ty, ptr.llextra,\n-                |bb, vv| drop_ty(bb, LvalueRef::new_sized_ty(vv, unit_ty, ptr.alignment)));\n-        }\n-        ty::TyTuple(ref args, _) => {\n-            for (i, arg) in args.iter().enumerate() {\n-                let (llfld_a, align) = ptr.trans_field_ptr(&cx, i);\n-                drop_ty(&cx, LvalueRef::new_sized_ty(llfld_a, *arg, align));\n-            }\n-        }\n-        ty::TyAdt(adt, substs) => match adt.adt_kind() {\n-            AdtKind::Struct => {\n-                for (i, field) in adt.variants[0].fields.iter().enumerate() {\n-                    let field_ty = monomorphize::field_ty(cx.tcx(), substs, field);\n-                    let (llval, align) = ptr.trans_field_ptr(&cx, i);\n-                    let field_ptr = if cx.ccx.shared().type_is_sized(field_ty) {\n-                        LvalueRef::new_sized_ty(llval, field_ty, align)\n-                    } else {\n-                        LvalueRef::new_unsized_ty(llval, ptr.llextra, field_ty, align)\n-                    };\n-                    drop_ty(&cx, field_ptr);\n-                }\n-            }\n-            AdtKind::Union => {\n-                bug!(\"Union in `glue::drop_structural_ty`\");\n-            }\n-            AdtKind::Enum => {\n-                let n_variants = adt.variants.len();\n-\n-                // NB: we must hit the discriminant first so that structural\n-                // comparison know not to proceed when the discriminants differ.\n-\n-                // Obtain a representation of the discriminant sufficient to translate\n-                // destructuring; this may or may not involve the actual discriminant.\n-                let l = cx.ccx.layout_of(t);\n-                match *l {\n-                    layout::Univariant { .. } |\n-                    layout::UntaggedUnion { .. } => {\n-                        if n_variants != 0 {\n-                            assert!(n_variants == 1);\n-                            ptr.ty = LvalueTy::Downcast {\n-                                adt_def: adt,\n-                                substs: substs,\n-                                variant_index: 0,\n-                            };\n-                            iter_variant_fields(&cx, ptr, &adt, 0, substs);\n-                        }\n-                    }\n-                    layout::CEnum { .. } |\n-                    layout::General { .. } |\n-                    layout::RawNullablePointer { .. } |\n-                    layout::StructWrappedNullablePointer { .. } => {\n-                        let lldiscrim_a = adt::trans_get_discr(\n-                            &cx, t, ptr.llval, ptr.alignment, None, false);\n-\n-                        // Create a fall-through basic block for the \"else\" case of\n-                        // the switch instruction we're about to generate. Note that\n-                        // we do **not** use an Unreachable instruction here, even\n-                        // though most of the time this basic block will never be hit.\n-                        //\n-                        // When an enum is dropped it's contents are currently\n-                        // overwritten to DTOR_DONE, which means the discriminant\n-                        // could have changed value to something not within the actual\n-                        // range of the discriminant. Currently this function is only\n-                        // used for drop glue so in this case we just return quickly\n-                        // from the outer function, and any other use case will only\n-                        // call this for an already-valid enum in which case the `ret\n-                        // void` will never be hit.\n-                        let ret_void_cx = cx.build_sibling_block(\"enum-iter-ret-void\");\n-                        ret_void_cx.ret_void();\n-                        let llswitch = cx.switch(lldiscrim_a, ret_void_cx.llbb(), n_variants);\n-                        let next_cx = cx.build_sibling_block(\"enum-iter-next\");\n-\n-                        for (i, discr) in adt.discriminants(cx.tcx()).enumerate() {\n-                            let variant_cx_name = format!(\"enum-iter-variant-{}\", i);\n-                            let variant_cx = cx.build_sibling_block(&variant_cx_name);\n-                            let case_val = adt::trans_case(&cx, t, Disr::from(discr));\n-                            variant_cx.add_case(llswitch, case_val, variant_cx.llbb());\n-                            ptr.ty = LvalueTy::Downcast {\n-                                adt_def: adt,\n-                                substs: substs,\n-                                variant_index: i,\n-                            };\n-                            iter_variant_fields(&variant_cx, ptr, &adt, i, substs);\n-                            variant_cx.br(next_cx.llbb());\n-                        }\n-                        cx = next_cx;\n-                    }\n-                    _ => bug!(\"{} is not an enum.\", t),\n-                }\n-            }\n-        },\n-\n-        _ => {\n-            cx.sess().unimpl(&format!(\"type in drop_structural_ty: {}\", t))\n-        }\n-    }\n-    return cx;\n-}"}, {"sha": "f3e30ed4839ae488fe1aeb86cce9d89bfa3e58c0", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -28,6 +28,7 @@\n #![feature(box_syntax)]\n #![feature(const_fn)]\n #![feature(custom_attribute)]\n+#![cfg_attr(stage0, feature(field_init_shorthand))]\n #![allow(unused_attributes)]\n #![feature(i128_type)]\n #![feature(libc)]\n@@ -112,7 +113,6 @@ mod cabi_x86;\n mod cabi_x86_64;\n mod cabi_x86_win64;\n mod callee;\n-mod cleanup;\n mod collector;\n mod common;\n mod consts;"}, {"sha": "75ab407614050eab3e187c868b020627569245cf", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 34, "deletions": 89, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -8,105 +8,51 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use attributes;\n-use llvm::{ValueRef, get_params};\n+use llvm::ValueRef;\n use rustc::traits;\n-use callee::{Callee, CalleeData};\n+use callee;\n use common::*;\n use builder::Builder;\n use consts;\n-use declare;\n-use glue;\n use machine;\n-use monomorphize::Instance;\n+use monomorphize;\n use type_::Type;\n use type_of::*;\n use value::Value;\n use rustc::ty;\n \n-// drop_glue pointer, size, align.\n-const VTABLE_OFFSET: usize = 3;\n-\n-/// Extracts a method from a trait object's vtable, at the specified index.\n-pub fn get_virtual_method<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                                    llvtable: ValueRef,\n-                                    vtable_index: usize) -> ValueRef {\n-    // Load the data pointer from the object.\n-    debug!(\"get_virtual_method(vtable_index={}, llvtable={:?})\",\n-           vtable_index, Value(llvtable));\n-\n-    let ptr = bcx.load_nonnull(bcx.gepi(llvtable, &[vtable_index + VTABLE_OFFSET]), None);\n-    // Vtable loads are invariant\n-    bcx.set_invariant_load(ptr);\n-    ptr\n-}\n+#[derive(Copy, Clone, Debug)]\n+pub struct VirtualIndex(usize);\n \n-/// Generate a shim function that allows an object type like `SomeTrait` to\n-/// implement the type `SomeTrait`. Imagine a trait definition:\n-///\n-///    trait SomeTrait { fn get(&self) -> i32; ... }\n-///\n-/// And a generic bit of code:\n-///\n-///    fn foo<T:SomeTrait>(t: &T) {\n-///        let x = SomeTrait::get;\n-///        x(t)\n-///    }\n-///\n-/// What is the value of `x` when `foo` is invoked with `T=SomeTrait`?\n-/// The answer is that it is a shim function generated by this routine:\n-///\n-///    fn shim(t: &SomeTrait) -> i32 {\n-///        // ... call t.get() virtually ...\n-///    }\n-///\n-/// In fact, all virtual calls can be thought of as normal trait calls\n-/// that go through this shim function.\n-pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n-                                   callee: Callee<'tcx>)\n-                                   -> ValueRef {\n-    debug!(\"trans_object_shim({:?})\", callee);\n-\n-    let function_name = match callee.ty.sty {\n-        ty::TyFnDef(def_id, substs, _) => {\n-            let instance = Instance::new(def_id, substs);\n-            instance.symbol_name(ccx.shared())\n-        }\n-        _ => bug!()\n-    };\n-\n-    let llfn = declare::define_internal_fn(ccx, &function_name, callee.ty);\n-    attributes::set_frame_pointer_elimination(ccx, llfn);\n-\n-    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n-\n-    let mut llargs = get_params(llfn);\n-    let fn_ret = callee.ty.fn_ret();\n-    let fn_ty = callee.direct_fn_type(ccx, &[]);\n-\n-    let fn_ptr = match callee.data {\n-        CalleeData::Virtual(idx) => {\n-            let fn_ptr = get_virtual_method(&bcx,\n-                llargs.remove(fn_ty.ret.is_indirect() as usize + 1), idx);\n-            let llty = fn_ty.llvm_type(bcx.ccx).ptr_to();\n-            bcx.pointercast(fn_ptr, llty)\n-        },\n-        _ => bug!(\"trans_object_shim called with non-virtual callee\"),\n-    };\n-    let llret = bcx.call(fn_ptr, &llargs, None);\n-    fn_ty.apply_attrs_callsite(llret);\n-\n-    if fn_ret.0.is_never() {\n-        bcx.unreachable();\n-    } else {\n-        if fn_ty.ret.is_indirect() || fn_ty.ret.is_ignore() {\n-            bcx.ret_void();\n-        } else {\n-            bcx.ret(llret);\n-        }\n+pub const DESTRUCTOR: VirtualIndex = VirtualIndex(0);\n+pub const SIZE: VirtualIndex = VirtualIndex(1);\n+pub const ALIGN: VirtualIndex = VirtualIndex(2);\n+\n+impl<'a, 'tcx> VirtualIndex {\n+    pub fn from_index(index: usize) -> Self {\n+        VirtualIndex(index + 3)\n+    }\n+\n+    pub fn get_fn(self, bcx: &Builder<'a, 'tcx>, llvtable: ValueRef) -> ValueRef {\n+        // Load the data pointer from the object.\n+        debug!(\"get_fn({:?}, {:?})\", Value(llvtable), self);\n+\n+        let ptr = bcx.load_nonnull(bcx.gepi(llvtable, &[self.0]), None);\n+        // Vtable loads are invariant\n+        bcx.set_invariant_load(ptr);\n+        ptr\n     }\n \n-    llfn\n+    pub fn get_usize(self, bcx: &Builder<'a, 'tcx>, llvtable: ValueRef) -> ValueRef {\n+        // Load the data pointer from the object.\n+        debug!(\"get_int({:?}, {:?})\", Value(llvtable), self);\n+\n+        let llvtable = bcx.pointercast(llvtable, Type::int(bcx.ccx).ptr_to());\n+        let ptr = bcx.load(bcx.gepi(llvtable, &[self.0]), None);\n+        // Vtable loads are invariant\n+        bcx.set_invariant_load(ptr);\n+        ptr\n+    }\n }\n \n /// Creates a dynamic vtable for the given type and vtable origin.\n@@ -139,8 +85,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let align = align_of(ccx, ty);\n \n     let mut components: Vec<_> = [\n-        // Generate a destructor for the vtable.\n-        glue::get_drop_glue(ccx, ty),\n+        callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.shared(), ty)),\n         C_uint(ccx, size),\n         C_uint(ccx, align)\n     ].iter().cloned().collect();\n@@ -149,7 +94,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let trait_ref = trait_ref.with_self_ty(tcx, ty);\n         let methods = traits::get_vtable_methods(tcx, trait_ref).map(|opt_mth| {\n             opt_mth.map_or(nullptr, |(def_id, substs)| {\n-                Callee::def(ccx, def_id, substs).reify(ccx)\n+                callee::resolve_and_get_fn(ccx, def_id, substs)\n             })\n         });\n         components.extend(methods);"}, {"sha": "226d40948c4dc41096e482f3571954aec8319f0a", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 130, "deletions": 107, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -16,15 +16,16 @@ use rustc::ty::{self, layout, TypeFoldable};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n use base::{self, Lifetime};\n-use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n+use callee;\n use builder::Builder;\n use common::{self, Funclet};\n-use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n+use common::{C_bool, C_str_slice, C_struct, C_u32, C_uint, C_undef};\n use consts;\n use machine::llalign_of_min;\n use meth;\n+use monomorphize;\n+use tvec;\n use type_of::{self, align_of};\n-use glue;\n use type_::Type;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -208,21 +209,49 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n                 let ty = location.ty(&self.mir, bcx.tcx()).to_ty(bcx.tcx());\n                 let ty = self.monomorphize(&ty);\n+                let drop_fn = monomorphize::resolve_drop_in_place(bcx.ccx.shared(), ty);\n \n-                // Double check for necessity to drop\n-                if !bcx.ccx.shared().type_needs_drop(ty) {\n+                if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n+                    // we don't actually need to drop anything.\n                     funclet_br(self, bcx, target);\n-                    return;\n+                    return\n                 }\n \n-                let mut lvalue = self.trans_lvalue(&bcx, location);\n-                let drop_fn = glue::get_drop_glue(bcx.ccx, ty);\n-                let drop_ty = glue::get_drop_glue_type(bcx.ccx.shared(), ty);\n-                if bcx.ccx.shared().type_is_sized(ty) && drop_ty != ty {\n-                    lvalue.llval = bcx.pointercast(\n-                        lvalue.llval, type_of::type_of(bcx.ccx, drop_ty).ptr_to());\n-                }\n-                let args = &[lvalue.llval, lvalue.llextra][..1 + lvalue.has_extra() as usize];\n+                let lvalue = self.trans_lvalue(&bcx, location);\n+                let (drop_fn, need_extra) = match ty.sty {\n+                    ty::TyDynamic(..) => (meth::DESTRUCTOR.get_fn(&bcx, lvalue.llextra),\n+                                          false),\n+                    ty::TyArray(ety, _) | ty::TySlice(ety) => {\n+                        // FIXME: handle panics\n+                        let drop_fn = monomorphize::resolve_drop_in_place(\n+                            bcx.ccx.shared(), ety);\n+                        let drop_fn = callee::get_fn(bcx.ccx, drop_fn);\n+                        let bcx = tvec::slice_for_each(\n+                            &bcx,\n+                            lvalue.project_index(&bcx, C_uint(bcx.ccx, 0u64)),\n+                            ety,\n+                            lvalue.len(bcx.ccx),\n+                            |bcx, llval, loop_bb| {\n+                                self.set_debug_loc(&bcx, terminator.source_info);\n+                                if let Some(unwind) = unwind {\n+                                    bcx.invoke(\n+                                        drop_fn,\n+                                        &[llval],\n+                                        loop_bb,\n+                                        llblock(self, unwind),\n+                                        cleanup_bundle\n+                                    );\n+                                } else {\n+                                    bcx.call(drop_fn, &[llval], cleanup_bundle);\n+                                    bcx.br(loop_bb);\n+                                }\n+                            });\n+                        funclet_br(self, bcx, target);\n+                        return\n+                    }\n+                    _ => (callee::get_fn(bcx.ccx, drop_fn), lvalue.has_extra())\n+                };\n+                let args = &[lvalue.llval, lvalue.llextra][..1 + need_extra as usize];\n                 if let Some(unwind) = unwind {\n                     bcx.invoke(\n                         drop_fn,\n@@ -340,9 +369,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 // Obtain the panic entry point.\n                 let def_id = common::langcall(bcx.tcx(), Some(span), \"\", lang_item);\n-                let callee = Callee::def(bcx.ccx, def_id,\n-                    bcx.ccx.empty_substs_for_def_id(def_id));\n-                let llfn = callee.reify(bcx.ccx);\n+                let instance = ty::Instance::mono(bcx.tcx(), def_id);\n+                let llfn = callee::get_fn(bcx.ccx, instance);\n \n                 // Translate the actual panic invoke/call.\n                 if let Some(unwind) = cleanup {\n@@ -365,30 +393,30 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n \n-                let (mut callee, sig) = match callee.ty.sty {\n+                let (instance, mut llfn, sig) = match callee.ty.sty {\n                     ty::TyFnDef(def_id, substs, sig) => {\n-                        (Callee::def(bcx.ccx, def_id, substs), sig)\n+                        (Some(monomorphize::resolve(bcx.ccx.shared(), def_id, substs)),\n+                         None,\n+                         sig)\n                     }\n                     ty::TyFnPtr(sig) => {\n-                        (Callee {\n-                            data: Fn(callee.immediate()),\n-                            ty: callee.ty\n-                        }, sig)\n+                        (None,\n+                         Some(callee.immediate()),\n+                         sig)\n                     }\n                     _ => bug!(\"{} is not callable\", callee.ty)\n                 };\n-\n+                let def = instance.map(|i| i.def);\n                 let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n                 let abi = sig.abi;\n \n                 // Handle intrinsics old trans wants Expr's for, ourselves.\n-                let intrinsic = match (&callee.ty.sty, &callee.data) {\n-                    (&ty::TyFnDef(def_id, ..), &Intrinsic) => {\n-                        Some(bcx.tcx().item_name(def_id).as_str())\n-                    }\n+                let intrinsic = match def {\n+                    Some(ty::InstanceDef::Intrinsic(def_id))\n+                        => Some(bcx.tcx().item_name(def_id).as_str()),\n                     _ => None\n                 };\n-                let mut intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n+                let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n \n                 if intrinsic == Some(\"move_val_init\") {\n                     let &(_, target) = destination.as_ref().unwrap();\n@@ -412,40 +440,29 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     let op_ty = op_arg.ty(&self.mir, bcx.tcx());\n                     self.monomorphize(&op_ty)\n                 }).collect::<Vec<_>>();\n-                let fn_ty = callee.direct_fn_type(bcx.ccx, &extra_args);\n-\n-                if intrinsic == Some(\"drop_in_place\") {\n-                    let &(_, target) = destination.as_ref().unwrap();\n-                    let ty = if let ty::TyFnDef(_, substs, _) = callee.ty.sty {\n-                        substs.type_at(0)\n-                    } else {\n-                        bug!(\"Unexpected ty: {}\", callee.ty);\n-                    };\n \n-                    // Double check for necessity to drop\n-                    if !bcx.ccx.shared().type_needs_drop(ty) {\n+                let fn_ty = match def {\n+                    Some(ty::InstanceDef::Virtual(..)) => {\n+                        FnType::new_vtable(bcx.ccx, sig, &extra_args)\n+                    }\n+                    Some(ty::InstanceDef::DropGlue(_, None)) => {\n+                        // empty drop glue - a nop.\n+                        let &(_, target) = destination.as_ref().unwrap();\n                         funclet_br(self, bcx, target);\n                         return;\n                     }\n-\n-                    let drop_fn = glue::get_drop_glue(bcx.ccx, ty);\n-                    let llty = fn_ty.llvm_type(bcx.ccx).ptr_to();\n-                    callee.data = Fn(bcx.pointercast(drop_fn, llty));\n-                    intrinsic = None;\n-                }\n+                    _ => FnType::new(bcx.ccx, sig, &extra_args)\n+                };\n \n                 // The arguments we'll be passing. Plus one to account for outptr, if used.\n                 let arg_count = fn_ty.args.len() + fn_ty.ret.is_indirect() as usize;\n                 let mut llargs = Vec::with_capacity(arg_count);\n \n                 // Prepare the return value destination\n                 let ret_dest = if let Some((ref dest, _)) = *destination {\n-                    let is_intrinsic = if let Intrinsic = callee.data {\n-                        true\n-                    } else {\n-                        false\n-                    };\n-                    self.make_return_dest(&bcx, dest, &fn_ty.ret, &mut llargs, is_intrinsic)\n+                    let is_intrinsic = intrinsic.is_some();\n+                    self.make_return_dest(&bcx, dest, &fn_ty.ret, &mut llargs,\n+                                          is_intrinsic)\n                 } else {\n                     ReturnDest::Nothing\n                 };\n@@ -483,56 +500,56 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                     let op = self.trans_operand(&bcx, arg);\n                     self.trans_argument(&bcx, op, &mut llargs, &fn_ty,\n-                                        &mut idx, &mut callee.data);\n+                                        &mut idx, &mut llfn, &def);\n                 }\n                 if let Some(tup) = untuple {\n                     self.trans_arguments_untupled(&bcx, tup, &mut llargs, &fn_ty,\n-                                                  &mut idx, &mut callee.data)\n+                                                  &mut idx, &mut llfn, &def)\n                 }\n \n-                let fn_ptr = match callee.data {\n-                    NamedTupleConstructor(_) => {\n-                        // FIXME translate this like mir::Rvalue::Aggregate.\n-                        callee.reify(bcx.ccx)\n-                    }\n-                    Intrinsic => {\n-                        use intrinsic::trans_intrinsic_call;\n-\n-                        let (dest, llargs) = match ret_dest {\n-                            _ if fn_ty.ret.is_indirect() => {\n-                                (llargs[0], &llargs[1..])\n-                            }\n-                            ReturnDest::Nothing => {\n-                                (C_undef(fn_ty.ret.original_ty.ptr_to()), &llargs[..])\n-                            }\n-                            ReturnDest::IndirectOperand(dst, _) |\n-                            ReturnDest::Store(dst) => (dst, &llargs[..]),\n-                            ReturnDest::DirectOperand(_) =>\n-                                bug!(\"Cannot use direct operand with an intrinsic call\")\n-                        };\n-\n-                        trans_intrinsic_call(&bcx, callee.ty, &fn_ty, &llargs, dest,\n-                            terminator.source_info.span);\n+                if intrinsic.is_some() && intrinsic != Some(\"drop_in_place\") {\n+                    use intrinsic::trans_intrinsic_call;\n \n-                        if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n-                            // Make a fake operand for store_return\n-                            let op = OperandRef {\n-                                val: Ref(dst, Alignment::AbiAligned),\n-                                ty: sig.output(),\n-                            };\n-                            self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n+                    let (dest, llargs) = match ret_dest {\n+                        _ if fn_ty.ret.is_indirect() => {\n+                            (llargs[0], &llargs[1..])\n                         }\n-\n-                        if let Some((_, target)) = *destination {\n-                            funclet_br(self, bcx, target);\n-                        } else {\n-                            bcx.unreachable();\n+                        ReturnDest::Nothing => {\n+                            (C_undef(fn_ty.ret.original_ty.ptr_to()), &llargs[..])\n                         }\n+                        ReturnDest::IndirectOperand(dst, _) |\n+                        ReturnDest::Store(dst) => (dst, &llargs[..]),\n+                        ReturnDest::DirectOperand(_) =>\n+                            bug!(\"Cannot use direct operand with an intrinsic call\")\n+                    };\n \n-                        return;\n+                    let callee_ty = common::instance_ty(\n+                        bcx.ccx.shared(), instance.as_ref().unwrap());\n+                    trans_intrinsic_call(&bcx, callee_ty, &fn_ty, &llargs, dest,\n+                                         terminator.source_info.span);\n+\n+                    if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n+                        // Make a fake operand for store_return\n+                        let op = OperandRef {\n+                            val: Ref(dst, Alignment::AbiAligned),\n+                            ty: sig.output(),\n+                        };\n+                        self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n+                    }\n+\n+                    if let Some((_, target)) = *destination {\n+                        funclet_br(self, bcx, target);\n+                    } else {\n+                        bcx.unreachable();\n                     }\n-                    Fn(f) => f,\n-                    Virtual(_) => bug!(\"Virtual fn ptr not extracted\")\n+\n+                    return;\n+                }\n+\n+                let fn_ptr = match (llfn, instance) {\n+                    (Some(llfn), _) => llfn,\n+                    (None, Some(instance)) => callee::get_fn(bcx.ccx, instance),\n+                    _ => span_bug!(span, \"no llfn for call\"),\n                 };\n \n                 // Many different ways to call a function handled here\n@@ -582,16 +599,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                       llargs: &mut Vec<ValueRef>,\n                       fn_ty: &FnType,\n                       next_idx: &mut usize,\n-                      callee: &mut CalleeData) {\n+                      llfn: &mut Option<ValueRef>,\n+                      def: &Option<ty::InstanceDef<'tcx>>) {\n         if let Pair(a, b) = op.val {\n             // Treat the values in a fat pointer separately.\n             if common::type_is_fat_ptr(bcx.ccx, op.ty) {\n                 let (ptr, meta) = (a, b);\n                 if *next_idx == 0 {\n-                    if let Virtual(idx) = *callee {\n-                        let llfn = meth::get_virtual_method(bcx, meta, idx);\n+                    if let Some(ty::InstanceDef::Virtual(_, idx)) = *def {\n+                        let llmeth = meth::VirtualIndex::from_index(idx).get_fn(bcx, meta);\n                         let llty = fn_ty.llvm_type(bcx.ccx).ptr_to();\n-                        *callee = Fn(bcx.pointercast(llfn, llty));\n+                        *llfn = Some(bcx.pointercast(llmeth, llty));\n                     }\n                 }\n \n@@ -600,8 +618,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // We won't be checking the type again.\n                     ty: bcx.tcx().types.err\n                 };\n-                self.trans_argument(bcx, imm_op(ptr), llargs, fn_ty, next_idx, callee);\n-                self.trans_argument(bcx, imm_op(meta), llargs, fn_ty, next_idx, callee);\n+                self.trans_argument(bcx, imm_op(ptr), llargs, fn_ty, next_idx, llfn, def);\n+                self.trans_argument(bcx, imm_op(meta), llargs, fn_ty, next_idx, llfn, def);\n                 return;\n             }\n         }\n@@ -664,7 +682,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 llargs: &mut Vec<ValueRef>,\n                                 fn_ty: &FnType,\n                                 next_idx: &mut usize,\n-                                callee: &mut CalleeData) {\n+                                llfn: &mut Option<ValueRef>,\n+                                def: &Option<ty::InstanceDef<'tcx>>) {\n         let tuple = self.trans_operand(bcx, operand);\n \n         let arg_types = match tuple.ty.sty {\n@@ -690,7 +709,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         val: val,\n                         ty: ty\n                     };\n-                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, callee);\n+                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, llfn, def);\n                 }\n \n             }\n@@ -712,7 +731,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         val: Immediate(elem),\n                         ty: ty\n                     };\n-                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, callee);\n+                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, llfn, def);\n                 }\n             }\n             Pair(a, b) => {\n@@ -728,7 +747,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         val: Immediate(elem),\n                         ty: ty\n                     };\n-                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, callee);\n+                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, llfn, def);\n                 }\n             }\n         }\n@@ -756,14 +775,18 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             return block;\n         }\n \n+        let block = self.blocks[target_bb];\n+        let landing_pad = self.landing_pad_uncached(block);\n+        self.landing_pads[target_bb] = Some(landing_pad);\n+        landing_pad\n+    }\n+\n+    fn landing_pad_uncached(&mut self, target_bb: BasicBlockRef) -> BasicBlockRef {\n         if base::wants_msvc_seh(self.ccx.sess()) {\n-            return self.blocks[target_bb];\n+            return target_bb;\n         }\n \n-        let target = self.get_builder(target_bb);\n-\n         let bcx = self.new_block(\"cleanup\");\n-        self.landing_pads[target_bb] = Some(bcx.llbb());\n \n         let ccx = bcx.ccx;\n         let llpersonality = self.ccx.eh_personality();\n@@ -772,7 +795,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         bcx.set_cleanup(llretval);\n         let slot = self.get_personality_slot(&bcx);\n         bcx.store(llretval, slot, None);\n-        bcx.br(target.llbb());\n+        bcx.br(target_bb);\n         bcx.llbb()\n     }\n "}, {"sha": "107b0982af982b9d606927696c18677d568db207", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -23,14 +23,14 @@ use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::{Kind, Substs, Subst};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {abi, adt, base, Disr, machine};\n-use callee::Callee;\n+use callee;\n use builder::Builder;\n use common::{self, CrateContext, const_get_elt, val_ty};\n use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral, C_big_integral};\n use common::{C_null, C_struct, C_str_slice, C_undef, C_uint, C_vector, is_undef};\n use common::const_to_opt_u128;\n use consts;\n-use monomorphize::{self, Instance};\n+use monomorphize;\n use type_of;\n use type_::Type;\n use value::Value;\n@@ -245,11 +245,12 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n-                 instance: Instance<'tcx>,\n+                 def_id: DefId,\n+                 substs: &'tcx Substs<'tcx>,\n                  args: IndexVec<mir::Local, Const<'tcx>>)\n                  -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let instance = instance.resolve_const(ccx.shared());\n-        let mir = ccx.tcx().item_mir(instance.def);\n+        let instance = monomorphize::resolve(ccx.shared(), def_id, substs);\n+        let mir = ccx.tcx().instance_mir(instance.def);\n         MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n     }\n \n@@ -332,10 +333,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 mir::TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n                     let fn_ty = func.ty(self.mir, tcx);\n                     let fn_ty = self.monomorphize(&fn_ty);\n-                    let instance = match fn_ty.sty {\n-                        ty::TyFnDef(def_id, substs, _) => {\n-                            Instance::new(def_id, substs)\n-                        }\n+                    let (def_id, substs) = match fn_ty.sty {\n+                        ty::TyFnDef(def_id, substs, _) => (def_id, substs),\n                         _ => span_bug!(span, \"calling {:?} (of type {}) in constant\",\n                                        func, fn_ty)\n                     };\n@@ -348,7 +347,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n                     }\n                     if let Some((ref dest, target)) = *destination {\n-                        match MirConstContext::trans_def(self.ccx, instance, const_args) {\n+                        match MirConstContext::trans_def(self.ccx, def_id, substs, const_args) {\n                             Ok(value) => self.store(dest, value, span),\n                             Err(err) => if failure.is_ok() { failure = Err(err); }\n                         }\n@@ -485,8 +484,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n \n                         let substs = self.monomorphize(&substs);\n-                        let instance = Instance::new(def_id, substs);\n-                        MirConstContext::trans_def(self.ccx, instance, IndexVec::new())\n+                        MirConstContext::trans_def(self.ccx, def_id, substs, IndexVec::new())\n                     }\n                     mir::Literal::Promoted { index } => {\n                         let mir = &self.mir.promoted[index];\n@@ -567,8 +565,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.ty.sty {\n                             ty::TyFnDef(def_id, substs, _) => {\n-                                Callee::def(self.ccx, def_id, substs)\n-                                    .reify(self.ccx)\n+                                callee::resolve_and_get_fn(self.ccx, def_id, substs)\n                             }\n                             _ => {\n                                 span_bug!(span, \"{} cannot be reified to a fn ptr\",\n@@ -588,10 +585,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 // Now create its substs [Closure, Tuple]\n                                 let input = tcx.closure_type(def_id)\n                                     .subst(tcx, substs.substs).input(0);\n-                                let substs = tcx.mk_substs([operand.ty, input.skip_binder()]\n+                                let input = tcx.erase_late_bound_regions_and_normalize(&input);\n+                                let substs = tcx.mk_substs([operand.ty, input]\n                                     .iter().cloned().map(Kind::from));\n-                                Callee::def(self.ccx, call_once, substs)\n-                                    .reify(self.ccx)\n+                                callee::resolve_and_get_fn(self.ccx, call_once, substs)\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be cast to a fn ptr\", operand.ty)\n@@ -935,8 +932,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n \n                 let substs = self.monomorphize(&substs);\n-                let instance = Instance::new(def_id, substs);\n-                MirConstContext::trans_def(bcx.ccx, instance, IndexVec::new())\n+                MirConstContext::trans_def(bcx.ccx, def_id, substs, IndexVec::new())\n             }\n             mir::Literal::Promoted { index } => {\n                 let mir = &self.mir.promoted[index];\n@@ -964,8 +960,8 @@ pub fn trans_static_initializer<'a, 'tcx>(\n     def_id: DefId)\n     -> Result<ValueRef, ConstEvalErr<'tcx>>\n {\n-    let instance = Instance::mono(ccx.shared(), def_id);\n-    MirConstContext::trans_def(ccx, instance, IndexVec::new()).map(|c| c.llval)\n+    MirConstContext::trans_def(ccx, def_id, Substs::empty(), IndexVec::new())\n+        .map(|c| c.llval)\n }\n \n /// Construct a constant value, suitable for initializing a"}, {"sha": "dd8c1d0e1f0310d5b49d15b2593c03f0b454aacd", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 16, "deletions": 42, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -27,7 +27,6 @@ use std::ptr;\n use std::ops;\n \n use super::{MirContext, LocalRef};\n-use super::operand::OperandValue;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum Alignment {\n@@ -95,16 +94,6 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         LvalueRef::new_sized(llval, LvalueTy::from_ty(ty), alignment)\n     }\n \n-    pub fn new_unsized_ty(llval: ValueRef, llextra: ValueRef, ty: Ty<'tcx>, alignment: Alignment)\n-                          -> LvalueRef<'tcx> {\n-        LvalueRef {\n-            llval: llval,\n-            llextra: llextra,\n-            ty: LvalueTy::from_ty(ty),\n-            alignment: alignment,\n-        }\n-    }\n-\n     pub fn alloca(bcx: &Builder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> LvalueRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, ty);\n         let tmp = bcx.alloca(type_of::type_of(bcx.ccx, ty), name);\n@@ -279,6 +268,16 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             _ => bug!(\"element access in type without elements: {} represented as {:#?}\", t, l)\n         }\n     }\n+\n+    pub fn project_index(&self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef) -> ValueRef {\n+        if let ty::TySlice(_) = self.ty.to_ty(bcx.tcx()).sty {\n+            // Slices already point to the array element type.\n+            bcx.inbounds_gep(self.llval, &[llindex])\n+        } else {\n+            let zero = common::C_uint(bcx.ccx, 0u64);\n+            bcx.inbounds_gep(self.llval, &[zero, llindex])\n+        }\n+    }\n }\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n@@ -314,39 +313,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 elem: mir::ProjectionElem::Deref\n             }) => {\n                 // Load the pointer from its location.\n-                let ptr = self.trans_consume(bcx, base);\n-                let projected_ty = LvalueTy::from_ty(ptr.ty)\n-                    .projection_ty(tcx, &mir::ProjectionElem::Deref);\n-                let projected_ty = self.monomorphize(&projected_ty);\n-                let (llptr, llextra) = match ptr.val {\n-                    OperandValue::Immediate(llptr) => (llptr, ptr::null_mut()),\n-                    OperandValue::Pair(llptr, llextra) => (llptr, llextra),\n-                    OperandValue::Ref(..) => bug!(\"Deref of by-Ref type {:?}\", ptr.ty)\n-                };\n-                LvalueRef {\n-                    llval: llptr,\n-                    llextra: llextra,\n-                    ty: projected_ty,\n-                    alignment: Alignment::AbiAligned,\n-                }\n+                self.trans_consume(bcx, base).deref()\n             }\n             mir::Lvalue::Projection(ref projection) => {\n                 let tr_base = self.trans_lvalue(bcx, &projection.base);\n                 let projected_ty = tr_base.ty.projection_ty(tcx, &projection.elem);\n                 let projected_ty = self.monomorphize(&projected_ty);\n                 let align = tr_base.alignment;\n \n-                let project_index = |llindex| {\n-                    let element = if let ty::TySlice(_) = tr_base.ty.to_ty(tcx).sty {\n-                        // Slices already point to the array element type.\n-                        bcx.inbounds_gep(tr_base.llval, &[llindex])\n-                    } else {\n-                        let zero = common::C_uint(bcx.ccx, 0u64);\n-                        bcx.inbounds_gep(tr_base.llval, &[zero, llindex])\n-                    };\n-                    (element, align)\n-                };\n-\n                 let ((llprojected, align), llextra) = match projection.elem {\n                     mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n@@ -359,25 +333,25 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     }\n                     mir::ProjectionElem::Index(ref index) => {\n                         let index = self.trans_operand(bcx, index);\n-                        (project_index(self.prepare_index(bcx, index.immediate())), ptr::null_mut())\n+                        let llindex = self.prepare_index(bcx, index.immediate());\n+                        ((tr_base.project_index(bcx, llindex), align), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n                         let lloffset = C_uint(bcx.ccx, offset);\n-                        (project_index(lloffset), ptr::null_mut())\n+                        ((tr_base.project_index(bcx, lloffset), align), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n                         let lloffset = C_uint(bcx.ccx, offset);\n                         let lllen = tr_base.len(bcx.ccx);\n                         let llindex = bcx.sub(lllen, lloffset);\n-                        (project_index(llindex), ptr::null_mut())\n+                        ((tr_base.project_index(bcx, llindex), align), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n-                        let llindex = C_uint(bcx.ccx, from);\n-                        let (llbase, align) = project_index(llindex);\n+                        let llbase = tr_base.project_index(bcx, C_uint(bcx.ccx, from));\n \n                         let base_ty = tr_base.ty.to_ty(bcx.tcx());\n                         match base_ty.sty {"}, {"sha": "da24c03fdc2a01bebb03ba1f35b10afe7ca23c23", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -9,9 +9,10 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::ty::Ty;\n+use rustc::ty::{self, Ty};\n use rustc::ty::layout::Layout;\n use rustc::mir;\n+use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n@@ -22,9 +23,10 @@ use type_of;\n use type_::Type;\n \n use std::fmt;\n+use std::ptr;\n \n use super::{MirContext, LocalRef};\n-use super::lvalue::Alignment;\n+use super::lvalue::{Alignment, LvalueRef};\n \n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n@@ -86,6 +88,22 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         }\n     }\n \n+    pub fn deref(self) -> LvalueRef<'tcx> {\n+        let projected_ty = self.ty.builtin_deref(true, ty::NoPreference)\n+            .unwrap().ty;\n+        let (llptr, llextra) = match self.val {\n+            OperandValue::Immediate(llptr) => (llptr, ptr::null_mut()),\n+            OperandValue::Pair(llptr, llextra) => (llptr, llextra),\n+            OperandValue::Ref(..) => bug!(\"Deref of by-Ref operand {:?}\", self)\n+        };\n+        LvalueRef {\n+            llval: llptr,\n+            llextra: llextra,\n+            ty: LvalueTy::from_ty(projected_ty),\n+            alignment: Alignment::AbiAligned,\n+        }\n+    }\n+\n     /// If this operand is a Pair, we return an\n     /// Immediate aggregate with the two values.\n     pub fn pack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n@@ -236,7 +254,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n \n             mir::Operand::Constant(ref constant) => {\n-                let val = self.trans_constant(bcx, constant);\n+                let val = self.trans_constant(&bcx, constant);\n                 let operand = val.to_operand(bcx.ccx);\n                 if let OperandValue::Ref(ptr, align) = operand.val {\n                     // If this is a OperandValue::Ref to an immediate constant, load it."}, {"sha": "d487aa6cd5be6f7d5e00dab89cc4683b80b2df9b", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -12,18 +12,18 @@ use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::Layout;\n-use rustc::ty::subst::{Kind, Subst};\n use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n use middle::lang_items::ExchangeMallocFnLangItem;\n \n use base;\n use builder::Builder;\n-use callee::Callee;\n+use callee;\n use common::{self, val_ty, C_bool, C_null, C_uint};\n use common::{C_integral};\n use adt;\n use machine;\n+use monomorphize;\n use type_::Type;\n use type_of;\n use tvec;\n@@ -98,8 +98,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let size = count.as_u64(bcx.tcx().sess.target.uint_type);\n                 let size = C_uint(bcx.ccx, size);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n-                tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot| {\n+                tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot, loop_bb| {\n                     self.store_operand(bcx, llslot, dest.alignment.to_align(), tr_elem);\n+                    bcx.br(loop_bb);\n                 })\n             }\n \n@@ -183,8 +184,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         match operand.ty.sty {\n                             ty::TyFnDef(def_id, substs, _) => {\n                                 OperandValue::Immediate(\n-                                    Callee::def(bcx.ccx, def_id, substs)\n-                                        .reify(bcx.ccx))\n+                                    callee::resolve_and_get_fn(bcx.ccx, def_id, substs))\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be reified to a fn ptr\", operand.ty)\n@@ -194,20 +194,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::CastKind::ClosureFnPointer => {\n                         match operand.ty.sty {\n                             ty::TyClosure(def_id, substs) => {\n-                                // Get the def_id for FnOnce::call_once\n-                                let fn_once = bcx.tcx().lang_items.fn_once_trait().unwrap();\n-                                let call_once = bcx.tcx()\n-                                    .global_tcx().associated_items(fn_once)\n-                                    .find(|it| it.kind == ty::AssociatedKind::Method)\n-                                    .unwrap().def_id;\n-                                // Now create its substs [Closure, Tuple]\n-                                let input = bcx.tcx().closure_type(def_id)\n-                                    .subst(bcx.tcx(), substs.substs).input(0);\n-                                let substs = bcx.tcx().mk_substs([operand.ty, input.skip_binder()]\n-                                    .iter().cloned().map(Kind::from));\n-                                OperandValue::Immediate(\n-                                    Callee::def(bcx.ccx, call_once, substs)\n-                                        .reify(bcx.ccx))\n+                                let instance = monomorphize::resolve_closure(\n+                                    bcx.ccx.shared(), def_id, substs, ty::ClosureKind::FnOnce);\n+                                OperandValue::Immediate(callee::get_fn(bcx.ccx, instance))\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be cast to a fn ptr\", operand.ty)\n@@ -461,8 +450,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         bcx.sess().fatal(&format!(\"allocation of `{}` {}\", box_ty, s));\n                     }\n                 };\n-                let r = Callee::def(bcx.ccx, def_id, bcx.tcx().intern_substs(&[]))\n-                    .reify(bcx.ccx);\n+                let instance = ty::Instance::mono(bcx.tcx(), def_id);\n+                let r = callee::get_fn(bcx.ccx, instance);\n                 let val = bcx.pointercast(bcx.call(r, &[llsize, llalign], None), llty_ptr);\n \n                 let operand = OperandRef {\n@@ -471,7 +460,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 };\n                 (bcx, operand)\n             }\n-\n             mir::Rvalue::Use(ref operand) => {\n                 let operand = self.trans_operand(&bcx, operand);\n                 (bcx, operand)\n@@ -674,7 +662,7 @@ pub fn rvalue_creates_operand(rvalue: &mir::Rvalue) -> bool {\n         mir::Rvalue::UnaryOp(..) |\n         mir::Rvalue::Discriminant(..) |\n         mir::Rvalue::Box(..) |\n-        mir::Rvalue::Use(..) =>\n+        mir::Rvalue::Use(..) => // (*)\n             true,\n         mir::Rvalue::Repeat(..) |\n         mir::Rvalue::Aggregate(..) =>"}, {"sha": "fcf6937d4b6d58670681f042e9bc6deedc71076b", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 263, "deletions": 34, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -8,60 +8,290 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use abi::Abi;\n use common::*;\n+use glue;\n+\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n-use rustc::traits;\n+use rustc::middle::lang_items::DropInPlaceFnLangItem;\n+use rustc::traits::{self, SelectionContext, Reveal};\n+use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::ty::fold::{TypeFolder, TypeFoldable};\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::util::ppaux;\n use rustc::util::common::MemoizationMap;\n \n-use syntax::codemap::DUMMY_SP;\n+use syntax::ast;\n+use syntax::codemap::{Span, DUMMY_SP};\n+\n+pub use rustc::ty::Instance;\n+\n+fn fn_once_adapter_instance<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    closure_did: DefId,\n+    substs: ty::ClosureSubsts<'tcx>,\n+    ) -> Instance<'tcx> {\n+    debug!(\"fn_once_adapter_shim({:?}, {:?})\",\n+           closure_did,\n+           substs);\n+    let fn_once = tcx.lang_items.fn_once_trait().unwrap();\n+    let call_once = tcx.associated_items(fn_once)\n+        .find(|it| it.kind == ty::AssociatedKind::Method)\n+        .unwrap().def_id;\n+    let def = ty::InstanceDef::ClosureOnceShim { call_once };\n \n-use std::fmt;\n+    let self_ty = tcx.mk_closure_from_closure_substs(\n+        closure_did, substs);\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct Instance<'tcx> {\n-    pub def: DefId,\n-    pub substs: &'tcx Substs<'tcx>,\n+    let sig = tcx.closure_type(closure_did).subst(tcx, substs.substs);\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n+    assert_eq!(sig.inputs().len(), 1);\n+    let substs = tcx.mk_substs([\n+        Kind::from(self_ty),\n+        Kind::from(sig.inputs()[0]),\n+    ].iter().cloned());\n+\n+    debug!(\"fn_once_adapter_shim: self_ty={:?} sig={:?}\", self_ty, sig);\n+    Instance { def, substs }\n }\n \n-impl<'tcx> fmt::Display for Instance<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ppaux::parameterized(f, &self.substs, self.def, &[])\n+fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n+                              trait_closure_kind: ty::ClosureKind)\n+                              -> Result<bool, ()>\n+{\n+    match (actual_closure_kind, trait_closure_kind) {\n+        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n+        (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n+            // No adapter needed.\n+           Ok(false)\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n+            // `fn(&mut self, ...)`. In fact, at trans time, these are\n+            // basically the same thing, so we can just return llfn.\n+            Ok(false)\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n+            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n+            // this by doing something like:\n+            //\n+            //     fn call_once(self, ...) { call_mut(&self, ...) }\n+            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n+            //\n+            // These are both the same at trans time.\n+            Ok(true)\n+        }\n+        _ => Err(()),\n     }\n }\n \n-impl<'a, 'tcx> Instance<'tcx> {\n-    pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>)\n-               -> Instance<'tcx> {\n-        assert!(substs.regions().all(|&r| r == ty::ReErased));\n-        Instance { def: def_id, substs: substs }\n-    }\n+pub fn resolve_closure<'a, 'tcx> (\n+    scx: &SharedCrateContext<'a, 'tcx>,\n+    def_id: DefId,\n+    substs: ty::ClosureSubsts<'tcx>,\n+    requested_kind: ty::ClosureKind)\n+    -> Instance<'tcx>\n+{\n+    let actual_kind = scx.tcx().closure_kind(def_id);\n \n-    pub fn mono(scx: &SharedCrateContext<'a, 'tcx>, def_id: DefId) -> Instance<'tcx> {\n-        Instance::new(def_id, scx.empty_substs_for_def_id(def_id))\n+    match needs_fn_once_adapter_shim(actual_kind, requested_kind) {\n+        Ok(true) => fn_once_adapter_instance(scx.tcx(), def_id, substs),\n+        _ => Instance::new(def_id, substs.substs)\n     }\n+}\n \n-    /// For associated constants from traits, return the impl definition.\n-    pub fn resolve_const(&self, scx: &SharedCrateContext<'a, 'tcx>) -> Self {\n-        if let Some(trait_id) = scx.tcx().trait_of_item(self.def) {\n-            let trait_ref = ty::TraitRef::new(trait_id, self.substs);\n-            let trait_ref = ty::Binder(trait_ref);\n-            let vtable = fulfill_obligation(scx, DUMMY_SP, trait_ref);\n-            if let traits::VtableImpl(vtable_impl) = vtable {\n-                let name = scx.tcx().item_name(self.def);\n-                let ac = scx.tcx().associated_items(vtable_impl.impl_def_id)\n-                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n-                if let Some(ac) = ac {\n-                    return Instance::new(ac.def_id, vtable_impl.substs);\n+/// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n+/// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n+/// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n+fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                span: Span,\n+                                trait_ref: ty::PolyTraitRef<'tcx>)\n+                                -> traits::Vtable<'tcx, ()>\n+{\n+    let tcx = scx.tcx();\n+\n+    // Remove any references to regions; this helps improve caching.\n+    let trait_ref = tcx.erase_regions(&trait_ref);\n+\n+    scx.trait_cache().memoize(trait_ref, || {\n+        debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n+               trait_ref, trait_ref.def_id());\n+\n+        // Do the initial selection for the obligation. This yields the\n+        // shallow result we are looking for -- that is, what specific impl.\n+        tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n+            let mut selcx = SelectionContext::new(&infcx);\n+\n+            let obligation_cause = traits::ObligationCause::misc(span,\n+                                                             ast::DUMMY_NODE_ID);\n+            let obligation = traits::Obligation::new(obligation_cause,\n+                                                     trait_ref.to_poly_trait_predicate());\n+\n+            let selection = match selcx.select(&obligation) {\n+                Ok(Some(selection)) => selection,\n+                Ok(None) => {\n+                    // Ambiguity can happen when monomorphizing during trans\n+                    // expands to some humongo type that never occurred\n+                    // statically -- this humongo type can then overflow,\n+                    // leading to an ambiguous result. So report this as an\n+                    // overflow bug, since I believe this is the only case\n+                    // where ambiguity can result.\n+                    debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n+                            presuming due to overflow\",\n+                           trait_ref);\n+                    tcx.sess.span_fatal(span,\n+                        \"reached the recursion limit during monomorphization \\\n+                         (selection ambiguity)\");\n                 }\n+                Err(e) => {\n+                    span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                              e, trait_ref)\n+                }\n+            };\n+\n+            debug!(\"fulfill_obligation: selection={:?}\", selection);\n+\n+            // Currently, we use a fulfillment context to completely resolve\n+            // all nested obligations. This is because they can inform the\n+            // inference of the impl's type parameters.\n+            let mut fulfill_cx = traits::FulfillmentContext::new();\n+            let vtable = selection.map(|predicate| {\n+                debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n+                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+            });\n+            let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n+\n+            info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n+            vtable\n+        })\n+    })\n+}\n+\n+fn resolve_associated_item<'a, 'tcx>(\n+    scx: &SharedCrateContext<'a, 'tcx>,\n+    trait_item: &ty::AssociatedItem,\n+    trait_id: DefId,\n+    rcvr_substs: &'tcx Substs<'tcx>\n+) -> Instance<'tcx> {\n+    let tcx = scx.tcx();\n+    let def_id = trait_item.def_id;\n+    debug!(\"resolve_associated_item(trait_item={:?}, \\\n+                                    trait_id={:?}, \\\n+                                    rcvr_substs={:?})\",\n+           def_id, trait_id, rcvr_substs);\n+\n+    let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n+    let vtbl = fulfill_obligation(scx, DUMMY_SP, ty::Binder(trait_ref));\n+\n+    // Now that we know which impl is being used, we can dispatch to\n+    // the actual function:\n+    match vtbl {\n+        traits::VtableImpl(impl_data) => {\n+            let (def_id, substs) = traits::find_associated_item(\n+                tcx, trait_item, rcvr_substs, &impl_data);\n+            let substs = tcx.erase_regions(&substs);\n+            ty::Instance::new(def_id, substs)\n+        }\n+        traits::VtableClosure(closure_data) => {\n+            let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+            resolve_closure(scx, closure_data.closure_def_id, closure_data.substs,\n+                            trait_closure_kind)\n+        }\n+        traits::VtableFnPointer(ref data) => {\n+            Instance {\n+                def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n+                substs: rcvr_substs\n             }\n         }\n+        traits::VtableObject(ref data) => {\n+            let index = tcx.get_vtable_index_of_object_method(data, def_id);\n+            Instance {\n+                def: ty::InstanceDef::Virtual(def_id, index),\n+                substs: rcvr_substs\n+            }\n+        }\n+        _ => {\n+            bug!(\"static call to invalid vtable: {:?}\", vtbl)\n+        }\n+    }\n+}\n \n-        *self\n+/// The point where linking happens. Resolve a (def_id, substs)\n+/// pair to an instance.\n+pub fn resolve<'a, 'tcx>(\n+    scx: &SharedCrateContext<'a, 'tcx>,\n+    def_id: DefId,\n+    substs: &'tcx Substs<'tcx>\n+) -> Instance<'tcx> {\n+    debug!(\"resolve(def_id={:?}, substs={:?})\",\n+           def_id, substs);\n+    let result = if let Some(trait_def_id) = scx.tcx().trait_of_item(def_id) {\n+        debug!(\" => associated item, attempting to find impl\");\n+        let item = scx.tcx().associated_item(def_id);\n+        resolve_associated_item(scx, &item, trait_def_id, substs)\n+    } else {\n+        let item_type = def_ty(scx, def_id, substs);\n+        let def = match item_type.sty {\n+            ty::TyFnDef(_, _, f) if\n+                f.abi() == Abi::RustIntrinsic ||\n+                f.abi() == Abi::PlatformIntrinsic =>\n+            {\n+                debug!(\" => intrinsic\");\n+                ty::InstanceDef::Intrinsic(def_id)\n+            }\n+            _ => {\n+                if Some(def_id) == scx.tcx().lang_items.drop_in_place_fn() {\n+                    let ty = substs.type_at(0);\n+                    if glue::needs_drop_glue(scx, ty) {\n+                        debug!(\" => nontrivial drop glue\");\n+                        ty::InstanceDef::DropGlue(def_id, Some(ty))\n+                    } else {\n+                        debug!(\" => trivial drop glue\");\n+                        ty::InstanceDef::DropGlue(def_id, None)\n+                    }\n+                } else {\n+                    debug!(\" => free item\");\n+                    ty::InstanceDef::Item(def_id)\n+                }\n+            }\n+        };\n+        Instance { def, substs }\n+    };\n+    debug!(\"resolve(def_id={:?}, substs={:?}) = {}\",\n+           def_id, substs, result);\n+    result\n+}\n+\n+pub fn resolve_drop_in_place<'a, 'tcx>(\n+    scx: &SharedCrateContext<'a, 'tcx>,\n+    ty: Ty<'tcx>)\n+    -> ty::Instance<'tcx>\n+{\n+    let def_id = scx.tcx().require_lang_item(DropInPlaceFnLangItem);\n+    let substs = scx.tcx().intern_substs(&[Kind::from(ty)]);\n+    resolve(scx, def_id, substs)\n+}\n+\n+pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx>,\n+                                             source_ty: Ty<'tcx>,\n+                                             target_ty: Ty<'tcx>)\n+                                             -> CustomCoerceUnsized {\n+    let trait_ref = ty::Binder(ty::TraitRef {\n+        def_id: scx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n+        substs: scx.tcx().mk_substs_trait(source_ty, &[target_ty])\n+    });\n+\n+    match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n+        traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n+            scx.tcx().custom_coerce_unsized_kind(impl_def_id)\n+        }\n+        vtable => {\n+            bug!(\"invalid CoerceUnsized vtable: {:?}\", vtable);\n+        }\n     }\n }\n \n@@ -80,7 +310,6 @@ pub fn apply_param_substs<'a, 'tcx, T>(scx: &SharedCrateContext<'a, 'tcx>,\n     AssociatedTypeNormalizer::new(scx).fold(&substituted)\n }\n \n-\n /// Returns the normalized type of a struct field\n pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           param_substs: &Substs<'tcx>,"}, {"sha": "90ce40cfbcf8fa3f27f3f33cbeb781baca05ab39", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -110,7 +110,7 @@ use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{self, TyCtxt};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use rustc_incremental::IchHasher;\n use std::cmp::Ordering;\n@@ -186,14 +186,14 @@ impl<'tcx> CodegenUnit<'tcx> {\n             symbol_name.hash(&mut state);\n             let exported = match item {\n                TransItem::Fn(ref instance) => {\n-                    let node_id = scx.tcx().hir.as_local_node_id(instance.def);\n+                   let node_id =\n+                       scx.tcx().hir.as_local_node_id(instance.def_id());\n                     node_id.map(|node_id| exported_symbols.contains(&node_id))\n                            .unwrap_or(false)\n                }\n                TransItem::Static(node_id) => {\n                     exported_symbols.contains(&node_id)\n                }\n-               TransItem::DropGlue(..) => false,\n             };\n             exported.hash(&mut state);\n         }\n@@ -241,10 +241,9 @@ impl<'tcx> CodegenUnit<'tcx> {\n         fn local_node_id(tcx: TyCtxt, trans_item: TransItem) -> Option<NodeId> {\n             match trans_item {\n                 TransItem::Fn(instance) => {\n-                    tcx.hir.as_local_node_id(instance.def)\n+                    tcx.hir.as_local_node_id(instance.def_id())\n                 }\n                 TransItem::Static(node_id) => Some(node_id),\n-                TransItem::DropGlue(_) => None,\n             }\n         }\n     }\n@@ -340,7 +339,6 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                     match trans_item {\n                         TransItem::Fn(..) |\n                         TransItem::Static(..) => llvm::ExternalLinkage,\n-                        TransItem::DropGlue(..) => unreachable!(),\n                     }\n                 }\n             };\n@@ -455,17 +453,26 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n     let tcx = scx.tcx();\n     match trans_item {\n         TransItem::Fn(instance) => {\n+            let def_id = match instance.def {\n+                ty::InstanceDef::Item(def_id) => def_id,\n+                ty::InstanceDef::FnPtrShim(..) |\n+                ty::InstanceDef::ClosureOnceShim { .. } |\n+                ty::InstanceDef::Intrinsic(..) |\n+                ty::InstanceDef::DropGlue(..) |\n+                ty::InstanceDef::Virtual(..) => return None\n+            };\n+\n             // If this is a method, we want to put it into the same module as\n             // its self-type. If the self-type does not provide a characteristic\n             // DefId, we use the location of the impl after all.\n \n-            if tcx.trait_of_item(instance.def).is_some() {\n+            if tcx.trait_of_item(def_id).is_some() {\n                 let self_ty = instance.substs.type_at(0);\n                 // This is an implementation of a trait method.\n-                return characteristic_def_id_of_type(self_ty).or(Some(instance.def));\n+                return characteristic_def_id_of_type(self_ty).or(Some(def_id));\n             }\n \n-            if let Some(impl_def_id) = tcx.impl_of_method(instance.def) {\n+            if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n                 // This is a method within an inherent impl, find out what the\n                 // self-type is:\n                 let impl_self_ty = common::def_ty(scx, impl_def_id, instance.substs);\n@@ -474,9 +481,8 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n                 }\n             }\n \n-            Some(instance.def)\n+            Some(def_id)\n         }\n-        TransItem::DropGlue(dg) => characteristic_def_id_of_type(dg.ty()),\n         TransItem::Static(node_id) => Some(tcx.hir.local_def_id(node_id)),\n     }\n }"}, {"sha": "1b48e131b720a2c5e5a3b01c5e7597cbd524c235", "filename": "src/librustc_trans/symbol_map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fsymbol_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fsymbol_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_map.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -97,10 +97,9 @@ impl<'tcx> SymbolMap<'tcx> {\n                               trans_item: TransItem<'tcx>) -> Option<Span> {\n             match trans_item {\n                 TransItem::Fn(Instance { def, .. }) => {\n-                    tcx.hir.as_local_node_id(def)\n+                    tcx.hir.as_local_node_id(def.def_id())\n                 }\n                 TransItem::Static(node_id) => Some(node_id),\n-                TransItem::DropGlue(_) => None,\n             }.map(|node_id| {\n                 tcx.hir.span(node_id)\n             })"}, {"sha": "fe551b06b3d95cff1b7e774139d7fbd99f5a19d9", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -14,6 +14,7 @@\n //! item-path. This is used for unit testing the code that generates\n //! paths etc in all kinds of annoying scenarios.\n \n+use back::symbol_names;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use syntax::ast;\n@@ -51,8 +52,8 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n         for attr in tcx.get_attrs(def_id).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n-                let instance = Instance::mono(self.scx, def_id);\n-                let name = instance.symbol_name(self.scx);\n+                let instance = Instance::mono(tcx, def_id);\n+                let name = symbol_names::symbol_name(instance, self.scx);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n             } else if attr.check_name(ITEM_PATH) {\n                 let path = tcx.item_path_str(def_id);\n@@ -86,4 +87,3 @@ impl<'a, 'tcx> Visitor<'tcx> for SymbolNamesTest<'a, 'tcx> {\n         intravisit::walk_impl_item(self, ii)\n     }\n }\n-"}, {"sha": "410e3f30be731eb0622e0a659030f04215094612", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 13, "deletions": 91, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -20,7 +20,6 @@ use consts;\n use context::{CrateContext, SharedCrateContext};\n use common;\n use declare;\n-use glue::DropGlueKind;\n use llvm;\n use monomorphize::Instance;\n use rustc::dep_graph::DepNode;\n@@ -32,15 +31,12 @@ use rustc_const_eval::fatal_const_eval_err;\n use syntax::ast::{self, NodeId};\n use syntax::attr;\n use type_of;\n-use glue;\n-use abi::{Abi, FnType};\n use back::symbol_names;\n use std::fmt::Write;\n use std::iter;\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n pub enum TransItem<'tcx> {\n-    DropGlue(DropGlueKind<'tcx>),\n     Fn(Instance<'tcx>),\n     Static(NodeId)\n }\n@@ -95,13 +91,10 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             }\n             TransItem::Fn(instance) => {\n                 let _task = ccx.tcx().dep_graph.in_task(\n-                    DepNode::TransCrateItem(instance.def)); // (*)\n+                    DepNode::TransCrateItem(instance.def_id())); // (*)\n \n                 base::trans_instance(&ccx, instance);\n             }\n-            TransItem::DropGlue(dg) => {\n-                glue::implement_drop_glue(&ccx, dg);\n-            }\n         }\n \n         debug!(\"END IMPLEMENTING '{} ({})' in cgu {}\",\n@@ -130,9 +123,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             TransItem::Fn(instance) => {\n                 TransItem::predefine_fn(ccx, instance, linkage, &symbol_name);\n             }\n-            TransItem::DropGlue(dg) => {\n-                TransItem::predefine_drop_glue(ccx, dg, linkage, &symbol_name);\n-            }\n         }\n \n         debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n@@ -146,7 +136,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                         linkage: llvm::Linkage,\n                         symbol_name: &str) {\n         let def_id = ccx.tcx().hir.local_def_id(node_id);\n-        let ty = common::def_ty(ccx.shared(), def_id, Substs::empty());\n+        let instance = Instance::mono(ccx.tcx(), def_id);\n+        let ty = common::instance_ty(ccx.shared(), &instance);\n         let llty = type_of::type_of(ccx, ty);\n \n         let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n@@ -156,7 +147,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n         unsafe { llvm::LLVMRustSetLinkage(g, linkage) };\n \n-        let instance = Instance::mono(ccx.shared(), def_id);\n         ccx.instances().borrow_mut().insert(instance, g);\n         ccx.statics().borrow_mut().insert(g, def_id);\n     }\n@@ -168,8 +158,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         assert!(!instance.substs.needs_infer() &&\n                 !instance.substs.has_param_types());\n \n-        let mono_ty = common::def_ty(ccx.shared(), instance.def, instance.substs);\n-        let attrs = ccx.tcx().get_attrs(instance.def);\n+        let mono_ty = common::instance_ty(ccx.shared(), &instance);\n+        let attrs = instance.def.attrs(ccx.tcx());\n         let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n         unsafe { llvm::LLVMRustSetLinkage(lldecl, linkage) };\n         base::set_link_section(ccx, lldecl, &attrs);\n@@ -178,88 +168,39 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             llvm::SetUniqueComdat(ccx.llmod(), lldecl);\n         }\n \n-        if let ty::TyClosure(..) = mono_ty.sty {\n-            // set an inline hint for all closures\n+        debug!(\"predefine_fn: mono_ty = {:?} instance = {:?}\", mono_ty, instance);\n+        if common::is_inline_instance(ccx.tcx(), &instance) {\n             attributes::inline(lldecl, attributes::InlineAttr::Hint);\n         }\n-\n         attributes::from_fn_attrs(ccx, &attrs, lldecl);\n \n         ccx.instances().borrow_mut().insert(instance, lldecl);\n     }\n \n-    fn predefine_drop_glue(ccx: &CrateContext<'a, 'tcx>,\n-                           dg: glue::DropGlueKind<'tcx>,\n-                           linkage: llvm::Linkage,\n-                           symbol_name: &str) {\n-        let tcx = ccx.tcx();\n-        assert_eq!(dg.ty(), glue::get_drop_glue_type(ccx.shared(), dg.ty()));\n-        let t = dg.ty();\n-\n-        let sig = tcx.mk_fn_sig(\n-            iter::once(tcx.mk_mut_ptr(t)),\n-            tcx.mk_nil(),\n-            false,\n-            hir::Unsafety::Normal,\n-            Abi::Rust\n-        );\n-\n-        debug!(\"predefine_drop_glue: sig={}\", sig);\n-\n-        let fn_ty = FnType::new(ccx, sig, &[]);\n-        let llfnty = fn_ty.llvm_type(ccx);\n-\n-        assert!(declare::get_defined_value(ccx, symbol_name).is_none());\n-        let llfn = declare::declare_cfn(ccx, symbol_name, llfnty);\n-        unsafe { llvm::LLVMRustSetLinkage(llfn, linkage) };\n-        if linkage == llvm::Linkage::LinkOnceODRLinkage ||\n-           linkage == llvm::Linkage::WeakODRLinkage {\n-            llvm::SetUniqueComdat(ccx.llmod(), llfn);\n-        }\n-        attributes::set_frame_pointer_elimination(ccx, llfn);\n-        ccx.drop_glues().borrow_mut().insert(dg, (llfn, fn_ty));\n-    }\n-\n     pub fn compute_symbol_name(&self,\n                                scx: &SharedCrateContext<'a, 'tcx>) -> String {\n         match *self {\n-            TransItem::Fn(instance) => instance.symbol_name(scx),\n+            TransItem::Fn(instance) => symbol_names::symbol_name(instance, scx),\n             TransItem::Static(node_id) => {\n                 let def_id = scx.tcx().hir.local_def_id(node_id);\n-                Instance::mono(scx, def_id).symbol_name(scx)\n-            }\n-            TransItem::DropGlue(dg) => {\n-                let prefix = match dg {\n-                    DropGlueKind::Ty(_) => \"drop\",\n-                    DropGlueKind::TyContents(_) => \"drop_contents\",\n-                };\n-                symbol_names::exported_name_from_type_and_prefix(scx, dg.ty(), prefix)\n+                symbol_names::symbol_name(Instance::mono(scx.tcx(), def_id), scx)\n             }\n         }\n     }\n \n-    pub fn is_from_extern_crate(&self) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => !instance.def.is_local(),\n-            TransItem::DropGlue(..) |\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n     pub fn instantiation_mode(&self,\n                               tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                               -> InstantiationMode {\n         match *self {\n             TransItem::Fn(ref instance) => {\n                 if self.explicit_linkage(tcx).is_none() &&\n-                   (common::is_closure(tcx, instance.def) ||\n-                    attr::requests_inline(&tcx.get_attrs(instance.def)[..])) {\n+                    common::requests_inline(tcx, instance)\n+                {\n                     InstantiationMode::LocalCopy\n                 } else {\n                     InstantiationMode::GloballyShared\n                 }\n             }\n-            TransItem::DropGlue(..) => InstantiationMode::LocalCopy,\n             TransItem::Static(..) => InstantiationMode::GloballyShared,\n         }\n     }\n@@ -269,16 +210,14 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             TransItem::Fn(ref instance) => {\n                 instance.substs.types().next().is_some()\n             }\n-            TransItem::DropGlue(..) |\n             TransItem::Static(..)   => false,\n         }\n     }\n \n     pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n         let def_id = match *self {\n-            TransItem::Fn(ref instance) => instance.def,\n+            TransItem::Fn(ref instance) => instance.def_id(),\n             TransItem::Static(node_id) => tcx.hir.local_def_id(node_id),\n-            TransItem::DropGlue(..) => return None,\n         };\n \n         let attributes = tcx.get_attrs(def_id);\n@@ -302,16 +241,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         let hir_map = &tcx.hir;\n \n         return match *self {\n-            TransItem::DropGlue(dg) => {\n-                let mut s = String::with_capacity(32);\n-                match dg {\n-                    DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n-                    DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n-                };\n-                let printer = DefPathBasedNames::new(tcx, false, false);\n-                printer.push_type_name(dg.ty(), &mut s);\n-                s\n-            }\n             TransItem::Fn(instance) => {\n                 to_string_internal(tcx, \"fn \", instance)\n             },\n@@ -336,13 +265,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n     pub fn to_raw_string(&self) -> String {\n         match *self {\n-            TransItem::DropGlue(dg) => {\n-                let prefix = match dg {\n-                    DropGlueKind::Ty(_) => \"Ty\",\n-                    DropGlueKind::TyContents(_) => \"TyContents\",\n-                };\n-                format!(\"DropGlue({}: {})\", prefix, dg.ty() as *const _ as usize)\n-            }\n             TransItem::Fn(instance) => {\n                 format!(\"Fn({:?}, {})\",\n                          instance.def,\n@@ -581,7 +503,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n     pub fn push_instance_as_string(&self,\n                                    instance: Instance<'tcx>,\n                                    output: &mut String) {\n-        self.push_def_path(instance.def, output);\n+        self.push_def_path(instance.def_id(), output);\n         self.push_type_params(instance.substs, iter::empty(), output);\n     }\n }"}, {"sha": "4216a73a8dd85b1ea2deae5865ec160a2235c279", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -10,7 +10,7 @@\n \n use llvm;\n use builder::Builder;\n-use llvm::ValueRef;\n+use llvm::{BasicBlockRef, ValueRef};\n use common::*;\n use rustc::ty::Ty;\n \n@@ -20,7 +20,7 @@ pub fn slice_for_each<'a, 'tcx, F>(\n     unit_ty: Ty<'tcx>,\n     len: ValueRef,\n     f: F\n-) -> Builder<'a, 'tcx> where F: FnOnce(&Builder<'a, 'tcx>, ValueRef) {\n+) -> Builder<'a, 'tcx> where F: FnOnce(&Builder<'a, 'tcx>, ValueRef, BasicBlockRef) {\n     // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n     let zst = type_is_zero_size(bcx.ccx, unit_ty);\n     let add = |bcx: &Builder, a, b| if zst {\n@@ -46,9 +46,8 @@ pub fn slice_for_each<'a, 'tcx, F>(\n     let keep_going = header_bcx.icmp(llvm::IntNE, current, end);\n     header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n \n-    f(&body_bcx, if zst { data_ptr } else { current });\n     let next = add(&body_bcx, current, C_uint(bcx.ccx, 1usize));\n+    f(&body_bcx, if zst { data_ptr } else { current }, header_bcx.llbb());\n     header_bcx.add_incoming_to_phi(current, next, body_bcx.llbb());\n-    body_bcx.br(header_bcx.llbb());\n     next_bcx\n }"}, {"sha": "d5ef27a79661d4f0d57d7b7d2cdbe9204f790a4a", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -1 +1 @@\n-Subproject commit 859fb269364623b17e092efaba3f94e70ce97c5e\n+Subproject commit d5ef27a79661d4f0d57d7b7d2cdbe9204f790a4a"}, {"sha": "be6d535dc732b63c606312aeb14fddaeefd5bed7", "filename": "src/rustllvm/llvm-rebuild-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Frustllvm%2Fllvm-rebuild-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Frustllvm%2Fllvm-rebuild-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-rebuild-trigger?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be (optionally) cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2017-03-04\n+2017-03-19"}, {"sha": "eb4f9e8e28e2d6a0a4c4e10224d2c29b3f298f5f", "filename": "src/test/codegen-units/item-collection/cross-crate-generic-functions.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-generic-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-generic-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-generic-functions.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -30,5 +30,3 @@ fn main()\n     // This should not introduce a codegen item\n     let _ = cgu_generic_function::exported_but_not_generic(3);\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "d8e6028b799fbbf18be03e11ad791e98eb20befb", "filename": "src/test/codegen-units/item-collection/drop_in_place_intrinsic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -11,8 +11,7 @@\n // ignore-tidy-linelength\n // compile-flags:-Zprint-trans-items=eager\n \n-//~ TRANS_ITEM drop-glue drop_in_place_intrinsic::StructWithDtor[0]\n-//~ TRANS_ITEM drop-glue-contents drop_in_place_intrinsic::StructWithDtor[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<drop_in_place_intrinsic::StructWithDtor[0]> @@ drop_in_place_intrinsic.cgu-0[Internal]\n struct StructWithDtor(u32);\n \n impl Drop for StructWithDtor {\n@@ -23,7 +22,7 @@ impl Drop for StructWithDtor {\n //~ TRANS_ITEM fn drop_in_place_intrinsic::main[0]\n fn main() {\n \n-    //~ TRANS_ITEM drop-glue [drop_in_place_intrinsic::StructWithDtor[0]; 2]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]; 2]> @@ drop_in_place_intrinsic.cgu-0[Internal]\n     let x = [StructWithDtor(0), StructWithDtor(1)];\n \n     drop_slice_in_place(&x);\n@@ -35,7 +34,7 @@ fn drop_slice_in_place(x: &[StructWithDtor]) {\n         // This is the interesting thing in this test case: Normally we would\n         // not have drop-glue for the unsized [StructWithDtor]. This has to be\n         // generated though when the drop_in_place() intrinsic is used.\n-        //~ TRANS_ITEM drop-glue [drop_in_place_intrinsic::StructWithDtor[0]]\n+        //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]]> @@ drop_in_place_intrinsic.cgu-0[Internal]\n         ::std::ptr::drop_in_place(x as *const _ as *mut [StructWithDtor]);\n     }\n }"}, {"sha": "c4aed7465bcb080e699fba3180ad7692486a33dd", "filename": "src/test/codegen-units/item-collection/function-as-argument.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ffunction-as-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ffunction-as-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ffunction-as-argument.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -28,10 +28,12 @@ fn main() {\n \n     //~ TRANS_ITEM fn function_as_argument::take_fn_once[0]<u32, &str, fn(u32, &str)>\n     //~ TRANS_ITEM fn function_as_argument::function[0]<u32, &str>\n+    //~ TRANS_ITEM fn core::ops[0]::FnOnce[0]::call_once[0]<fn(u32, &str), (u32, &str)>\n     take_fn_once(function, 0u32, \"abc\");\n \n     //~ TRANS_ITEM fn function_as_argument::take_fn_once[0]<char, f64, fn(char, f64)>\n     //~ TRANS_ITEM fn function_as_argument::function[0]<char, f64>\n+    //~ TRANS_ITEM fn core::ops[0]::FnOnce[0]::call_once[0]<fn(char, f64), (char, f64)>\n     take_fn_once(function, 'c', 0f64);\n \n     //~ TRANS_ITEM fn function_as_argument::take_fn_pointer[0]<i32, ()>\n@@ -42,5 +44,3 @@ fn main() {\n     //~ TRANS_ITEM fn function_as_argument::function[0]<f32, i64>\n     take_fn_pointer(function, 0f32, 0i64);\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "06e02b100152e3bce98a2944f4b275a6e950ed3b", "filename": "src/test/codegen-units/item-collection/generic-drop-glue.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -45,8 +45,7 @@ enum EnumNoDrop<T1, T2> {\n struct NonGenericNoDrop(i32);\n \n struct NonGenericWithDrop(i32);\n-//~ TRANS_ITEM drop-glue generic_drop_glue::NonGenericWithDrop[0]\n-//~ TRANS_ITEM drop-glue-contents generic_drop_glue::NonGenericWithDrop[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::NonGenericWithDrop[0]> @@ generic_drop_glue.cgu-0[Internal]\n \n impl Drop for NonGenericWithDrop {\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[2]::drop[0]\n@@ -55,13 +54,11 @@ impl Drop for NonGenericWithDrop {\n \n //~ TRANS_ITEM fn generic_drop_glue::main[0]\n fn main() {\n-    //~ TRANS_ITEM drop-glue generic_drop_glue::StructWithDrop[0]<i8, char>\n-    //~ TRANS_ITEM drop-glue-contents generic_drop_glue::StructWithDrop[0]<i8, char>\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<i8, char>> @@ generic_drop_glue.cgu-0[Internal]\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<i8, char>\n     let _ = StructWithDrop { x: 0i8, y: 'a' }.x;\n \n-    //~ TRANS_ITEM drop-glue generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n-    //~ TRANS_ITEM drop-glue-contents generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>> @@ generic_drop_glue.cgu-0[Internal]\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n     let _ = StructWithDrop { x: \"&str\", y: NonGenericNoDrop(0) }.y;\n \n@@ -70,19 +67,17 @@ fn main() {\n \n     // This is supposed to generate drop-glue because it contains a field that\n     // needs to be dropped.\n-    //~ TRANS_ITEM drop-glue generic_drop_glue::StructNoDrop[0]<generic_drop_glue::NonGenericWithDrop[0], f64>\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructNoDrop[0]<generic_drop_glue::NonGenericWithDrop[0], f64>> @@ generic_drop_glue.cgu-0[Internal]\n     let _ = StructNoDrop { x: NonGenericWithDrop(0), y: 0f64 }.y;\n \n-    //~ TRANS_ITEM drop-glue generic_drop_glue::EnumWithDrop[0]<i32, i64>\n-    //~ TRANS_ITEM drop-glue-contents generic_drop_glue::EnumWithDrop[0]<i32, i64>\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<i32, i64>> @@ generic_drop_glue.cgu-0[Internal]\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<i32, i64>\n     let _ = match EnumWithDrop::A::<i32, i64>(0) {\n         EnumWithDrop::A(x) => x,\n         EnumWithDrop::B(x) => x as i32\n     };\n \n-    //~ TRANS_ITEM drop-glue generic_drop_glue::EnumWithDrop[0]<f64, f32>\n-    //~ TRANS_ITEM drop-glue-contents generic_drop_glue::EnumWithDrop[0]<f64, f32>\n+    //~TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<f64, f32>> @@ generic_drop_glue.cgu-0[Internal]\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<f64, f32>\n     let _ = match EnumWithDrop::B::<f64, f32>(1.0) {\n         EnumWithDrop::A(x) => x,\n@@ -99,5 +94,3 @@ fn main() {\n         EnumNoDrop::B(x) => x as f64\n     };\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "9c6bdb6624eaecf63c5208969f8a0a0cb007cf86", "filename": "src/test/codegen-units/item-collection/instantiation-through-vtable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -31,12 +31,13 @@ impl<T> Trait for Struct<T> {\n fn main() {\n     let s1 = Struct { _a: 0u32 };\n \n-    //~ TRANS_ITEM drop-glue i8\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u32>> @@ instantiation_through_vtable.cgu-0[Internal]\n     //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::foo[0]<u32>\n     //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::bar[0]<u32>\n     let _ = &s1 as &Trait;\n \n     let s1 = Struct { _a: 0u64 };\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u64>> @@ instantiation_through_vtable.cgu-0[Internal]\n     //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::foo[0]<u64>\n     //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::bar[0]<u64>\n     let _ = &s1 as &Trait;"}, {"sha": "75d842d3c0bfce21cd432b49e79e83457a1558a1", "filename": "src/test/codegen-units/item-collection/items-within-generic-items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fitems-within-generic-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fitems-within-generic-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fitems-within-generic-items.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -40,5 +40,3 @@ fn main() {\n     //~ TRANS_ITEM fn items_within_generic_items::generic_fn[0]<i8>\n     let _ = generic_fn(0i8);\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "5f70ff396ddd5f78e76220a227c81dca7d873b59", "filename": "src/test/codegen-units/item-collection/non-generic-drop-glue.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -13,8 +13,7 @@\n \n #![deny(dead_code)]\n \n-//~ TRANS_ITEM drop-glue non_generic_drop_glue::StructWithDrop[0]\n-//~ TRANS_ITEM drop-glue-contents non_generic_drop_glue::StructWithDrop[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::StructWithDrop[0]> @@ non_generic_drop_glue.cgu-0[Internal]\n struct StructWithDrop {\n     x: i32\n }\n@@ -28,8 +27,7 @@ struct StructNoDrop {\n     x: i32\n }\n \n-//~ TRANS_ITEM drop-glue non_generic_drop_glue::EnumWithDrop[0]\n-//~ TRANS_ITEM drop-glue-contents non_generic_drop_glue::EnumWithDrop[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::EnumWithDrop[0]> @@ non_generic_drop_glue.cgu-0[Internal]\n enum EnumWithDrop {\n     A(i32)\n }\n@@ -54,5 +52,3 @@ fn main() {\n         EnumNoDrop::A(x) => x\n     };\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "26f9eb11876cbe07a2d1757bbec58026a16c48c4", "filename": "src/test/codegen-units/item-collection/non-generic-functions.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-functions.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -77,5 +77,3 @@ fn main() {\n     let x = Struct { _x: 0 };\n     x.bar();\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "05848a727e95101c160840d9e37c7adf3c01a548", "filename": "src/test/codegen-units/item-collection/overloaded-operators.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Foverloaded-operators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Foverloaded-operators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Foverloaded-operators.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -68,5 +68,3 @@ impl Deref for Equatable {\n         &self.0\n     }\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "3c9dcf32e0c7806e07058b912de9950f8d1c897d", "filename": "src/test/codegen-units/item-collection/static-init.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatic-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatic-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatic-init.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -20,4 +20,3 @@ pub fn foo<T>() { }\n fn main() { }\n \n //~ TRANS_ITEM fn static_init::main[0]\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "89bc620b7c552933226c9ad28a060329aaa23fed", "filename": "src/test/codegen-units/item-collection/statics-and-consts.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatics-and-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatics-and-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatics-and-consts.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -60,5 +60,3 @@ fn main() {\n //~ TRANS_ITEM static statics_and_consts::foo[0]::STATIC2[2]\n \n //~ TRANS_ITEM fn statics_and_consts::main[0]\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "e8a7d8f25b22ca9b89113f23242177102bebbacb", "filename": "src/test/codegen-units/item-collection/trait-implementations.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-implementations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-implementations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-implementations.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -78,5 +78,3 @@ fn main() {\n    //~ TRANS_ITEM fn trait_implementations::{{impl}}[3]::bar[0]<&str, &str>\n    0f32.bar(\"&str\", \"&str\");\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "f095b637a84e47df7a727fe67f64267920c4e079", "filename": "src/test/codegen-units/item-collection/trait-method-as-argument.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-as-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-as-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-as-argument.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -40,23 +40,27 @@ fn take_foo_mut<T, F: FnMut(T) -> T>(mut f: F, arg: T) -> T {\n fn main() {\n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo_once[0]<u32, fn(u32) -> u32>\n     //~ TRANS_ITEM fn trait_method_as_argument::{{impl}}[0]::foo[0]\n+    //~ TRANS_ITEM fn core::ops[0]::FnOnce[0]::call_once[0]<fn(u32) -> u32, (u32)>\n     take_foo_once(Trait::foo, 0u32);\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo_once[0]<char, fn(char) -> char>\n     //~ TRANS_ITEM fn trait_method_as_argument::Trait[0]::foo[0]<char>\n+    //~ TRANS_ITEM fn core::ops[0]::FnOnce[0]::call_once[0]<fn(char) -> char, (char)>\n     take_foo_once(Trait::foo, 'c');\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo[0]<u32, fn(u32) -> u32>\n+    //~ TRANS_ITEM fn core::ops[0]::Fn[0]::call[0]<fn(u32) -> u32, (u32)>\n     take_foo(Trait::foo, 0u32);\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo[0]<char, fn(char) -> char>\n+    //~ TRANS_ITEM fn core::ops[0]::Fn[0]::call[0]<fn(char) -> char, (char)>\n     take_foo(Trait::foo, 'c');\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo_mut[0]<u32, fn(u32) -> u32>\n+    //~ TRANS_ITEM fn core::ops[0]::FnMut[0]::call_mut[0]<fn(char) -> char, (char)>\n     take_foo_mut(Trait::foo, 0u32);\n \n     //~ TRANS_ITEM fn trait_method_as_argument::take_foo_mut[0]<char, fn(char) -> char>\n+    //~ TRANS_ITEM fn core::ops[0]::FnMut[0]::call_mut[0]<fn(u32) -> u32, (u32)>\n     take_foo_mut(Trait::foo, 'c');\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "5b24a219f354bb140d62777f80143d726deedbfb", "filename": "src/test/codegen-units/item-collection/trait-method-default-impl.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-default-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-default-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-default-impl.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -66,5 +66,3 @@ fn main() {\n     //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<u32, i16, ()>\n     0u32.bar(0i16, ());\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "e41cb34eec6abfd8dcfaff686d2c0474bfa094db", "filename": "src/test/codegen-units/item-collection/transitive-drop-glue.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -13,12 +13,11 @@\n \n #![deny(dead_code)]\n \n-//~ TRANS_ITEM drop-glue transitive_drop_glue::Root[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Root[0]> @@ transitive_drop_glue.cgu-0[Internal]\n struct Root(Intermediate);\n-//~ TRANS_ITEM drop-glue transitive_drop_glue::Intermediate[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Intermediate[0]> @@ transitive_drop_glue.cgu-0[Internal]\n struct Intermediate(Leaf);\n-//~ TRANS_ITEM drop-glue transitive_drop_glue::Leaf[0]\n-//~ TRANS_ITEM drop-glue-contents transitive_drop_glue::Leaf[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Leaf[0]> @@ transitive_drop_glue.cgu-0[Internal]\n struct Leaf;\n \n impl Drop for Leaf {\n@@ -39,17 +38,15 @@ fn main() {\n \n     let _ = Root(Intermediate(Leaf));\n \n-    //~ TRANS_ITEM drop-glue transitive_drop_glue::RootGen[0]<u32>\n-    //~ TRANS_ITEM drop-glue transitive_drop_glue::IntermediateGen[0]<u32>\n-    //~ TRANS_ITEM drop-glue transitive_drop_glue::LeafGen[0]<u32>\n-    //~ TRANS_ITEM drop-glue-contents transitive_drop_glue::LeafGen[0]<u32>\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<u32>> @@ transitive_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<u32>> @@ transitive_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<u32>> @@ transitive_drop_glue.cgu-0[Internal]\n     //~ TRANS_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<u32>\n     let _ = RootGen(IntermediateGen(LeafGen(0u32)));\n \n-    //~ TRANS_ITEM drop-glue transitive_drop_glue::RootGen[0]<i16>\n-    //~ TRANS_ITEM drop-glue transitive_drop_glue::IntermediateGen[0]<i16>\n-    //~ TRANS_ITEM drop-glue transitive_drop_glue::LeafGen[0]<i16>\n-    //~ TRANS_ITEM drop-glue-contents transitive_drop_glue::LeafGen[0]<i16>\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<i16>> @@ transitive_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<i16>> @@ transitive_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<i16>> @@ transitive_drop_glue.cgu-0[Internal]\n     //~ TRANS_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<i16>\n     let _ = RootGen(IntermediateGen(LeafGen(0i16)));\n }"}, {"sha": "39043cf87cbecd7bd838ba8e71df4e0e785f8acf", "filename": "src/test/codegen-units/item-collection/tuple-drop-glue.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -13,8 +13,7 @@\n \n #![deny(dead_code)]\n \n-//~ TRANS_ITEM drop-glue tuple_drop_glue::Dropped[0]\n-//~ TRANS_ITEM drop-glue-contents tuple_drop_glue::Dropped[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<tuple_drop_glue::Dropped[0]> @@ tuple_drop_glue.cgu-0[Internal]\n struct Dropped;\n \n impl Drop for Dropped {\n@@ -24,10 +23,10 @@ impl Drop for Dropped {\n \n //~ TRANS_ITEM fn tuple_drop_glue::main[0]\n fn main() {\n-    //~ TRANS_ITEM drop-glue (u32, tuple_drop_glue::Dropped[0])\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(u32, tuple_drop_glue::Dropped[0])> @@ tuple_drop_glue.cgu-0[Internal]\n     let x = (0u32, Dropped);\n \n-    //~ TRANS_ITEM drop-glue (i16, (tuple_drop_glue::Dropped[0], bool))\n-    //~ TRANS_ITEM drop-glue (tuple_drop_glue::Dropped[0], bool)\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(i16, (tuple_drop_glue::Dropped[0], bool))> @@ tuple_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(tuple_drop_glue::Dropped[0], bool)> @@ tuple_drop_glue.cgu-0[Internal]\n     let x = (0i16, (Dropped, true));\n }"}, {"sha": "de7613741b27bfd2610dbe87184d29195f47d3f4", "filename": "src/test/codegen-units/item-collection/unsizing.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -57,11 +57,13 @@ fn main()\n {\n     // simple case\n     let bool_sized = &true;\n-    //~ TRANS_ITEM drop-glue i8\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<bool> @@ unsizing.cgu-0[Internal]\n     //~ TRANS_ITEM fn unsizing::{{impl}}[0]::foo[0]\n     let _bool_unsized = bool_sized as &Trait;\n \n-    let char_sized = &true;\n+    let char_sized = &'a';\n+\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<char> @@ unsizing.cgu-0[Internal]\n     //~ TRANS_ITEM fn unsizing::{{impl}}[1]::foo[0]\n     let _char_unsized = char_sized as &Trait;\n \n@@ -71,11 +73,13 @@ fn main()\n         _b: 2,\n         _c: 3.0f64\n     };\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<f64> @@ unsizing.cgu-0[Internal]\n     //~ TRANS_ITEM fn unsizing::{{impl}}[2]::foo[0]\n     let _struct_unsized = struct_sized as &Struct<Trait>;\n \n     // custom coercion\n     let wrapper_sized = Wrapper(&0u32);\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<u32> @@ unsizing.cgu-0[Internal]\n     //~ TRANS_ITEM fn unsizing::{{impl}}[3]::foo[0]\n     let _wrapper_sized = wrapper_sized as Wrapper<Trait>;\n }"}, {"sha": "ce85c4fc13ce2a753b38961b6a2dd22eedc9e430", "filename": "src/test/codegen-units/item-collection/unused-traits-and-generics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funused-traits-and-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funused-traits-and-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funused-traits-and-generics.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -86,4 +86,3 @@ impl NonGeneric {\n \n // Only the non-generic methods should be instantiated:\n //~ TRANS_ITEM fn unused_traits_and_generics::{{impl}}[3]::foo[0]\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "f28c4872111c990c3e89684c599b8d5d46f4ec09", "filename": "src/test/codegen-units/partitioning/extern-drop-glue.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -20,15 +20,14 @@\n // aux-build:cgu_extern_drop_glue.rs\n extern crate cgu_extern_drop_glue;\n \n-//~ TRANS_ITEM drop-glue cgu_extern_drop_glue::Struct[0] @@ extern_drop_glue[Internal] extern_drop_glue-mod1[Internal]\n-//~ TRANS_ITEM drop-glue-contents cgu_extern_drop_glue::Struct[0] @@ extern_drop_glue[Internal] extern_drop_glue-mod1[Internal]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<cgu_extern_drop_glue::Struct[0]> @@ extern_drop_glue[Internal] extern_drop_glue-mod1[Internal]\n \n struct LocalStruct(cgu_extern_drop_glue::Struct);\n \n //~ TRANS_ITEM fn extern_drop_glue::user[0] @@ extern_drop_glue[External]\n fn user()\n {\n-    //~ TRANS_ITEM drop-glue extern_drop_glue::LocalStruct[0] @@ extern_drop_glue[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<extern_drop_glue::LocalStruct[0]> @@ extern_drop_glue[Internal]\n     let _ = LocalStruct(cgu_extern_drop_glue::Struct(0));\n }\n \n@@ -40,7 +39,7 @@ mod mod1 {\n     //~ TRANS_ITEM fn extern_drop_glue::mod1[0]::user[0] @@ extern_drop_glue-mod1[External]\n     fn user()\n     {\n-        //~ TRANS_ITEM drop-glue extern_drop_glue::mod1[0]::LocalStruct[0] @@ extern_drop_glue-mod1[Internal]\n+        //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<extern_drop_glue::mod1[0]::LocalStruct[0]> @@ extern_drop_glue-mod1[Internal]\n         let _ = LocalStruct(cgu_extern_drop_glue::Struct(0));\n     }\n }"}, {"sha": "e32c946f8554f4ca5c6ac5c9d1b86235fd027267", "filename": "src/test/codegen-units/partitioning/extern-generic.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -60,5 +60,3 @@ mod mod3 {\n // once for the current crate\n //~ TRANS_ITEM fn cgu_generic_function::foo[0]<&str> @@ cgu_generic_function.volatile[External]\n //~ TRANS_ITEM fn cgu_generic_function::bar[0]<&str> @@ cgu_generic_function.volatile[External]\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "64f4f854c2d7ffe00db0d576dd9495c6b8e2191e", "filename": "src/test/codegen-units/partitioning/local-drop-glue.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -16,8 +16,7 @@\n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n-//~ TRANS_ITEM drop-glue local_drop_glue::Struct[0] @@ local_drop_glue[Internal] local_drop_glue-mod1[Internal]\n-//~ TRANS_ITEM drop-glue-contents local_drop_glue::Struct[0] @@ local_drop_glue[Internal] local_drop_glue-mod1[Internal]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<local_drop_glue::Struct[0]> @@ local_drop_glue[Internal] local_drop_glue-mod1[Internal]\n struct Struct {\n     _a: u32\n }\n@@ -27,7 +26,7 @@ impl Drop for Struct {\n     fn drop(&mut self) {}\n }\n \n-//~ TRANS_ITEM drop-glue local_drop_glue::Outer[0] @@ local_drop_glue[Internal]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<local_drop_glue::Outer[0]> @@ local_drop_glue[Internal]\n struct Outer {\n     _a: Struct\n }\n@@ -46,10 +45,10 @@ mod mod1\n {\n     use super::Struct;\n \n-    //~ TRANS_ITEM drop-glue local_drop_glue::mod1[0]::Struct2[0] @@ local_drop_glue-mod1[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<local_drop_glue::mod1[0]::Struct2[0]> @@ local_drop_glue-mod1[Internal]\n     struct Struct2 {\n         _a: Struct,\n-        //~ TRANS_ITEM drop-glue (u32, local_drop_glue::Struct[0]) @@ local_drop_glue-mod1[Internal]\n+        //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(u32, local_drop_glue::Struct[0])> @@ local_drop_glue-mod1[Internal]\n         _b: (u32, Struct),\n     }\n "}, {"sha": "07c341203f9e206a0ef17098be4cd0abffcdbcde", "filename": "src/test/codegen-units/partitioning/regular-modules.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -80,5 +80,3 @@ mod mod2 {\n         static BAZ: u64 = 0;\n     }\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "d06b3ac407a7f4d2898d2d97cc006f0ced6bcb61", "filename": "src/test/codegen-units/partitioning/statics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -46,5 +46,3 @@ mod mod1 {\n         static BAR: u32 = 0;\n     }\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "c4594bb547ef54ba303b4777e85c1b80a4a0f430", "filename": "src/test/codegen-units/partitioning/vtable-through-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -69,7 +69,7 @@ mod mod1 {\n \n //~ TRANS_ITEM fn vtable_through_const::main[0] @@ vtable_through_const[External]\n fn main() {\n-    //~ TRANS_ITEM drop-glue i8 @@ vtable_through_const[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<u32> @@ vtable_through_const[Internal]\n \n     // Since Trait1::do_something() is instantiated via its default implementation,\n     // it is considered a generic and is instantiated here only because it is"}, {"sha": "281dde15bd336e4d45a2022e6c158e1db3e71aa1", "filename": "src/test/run-pass/issue-29948.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Frun-pass%2Fissue-29948.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Frun-pass%2Fissue-29948.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29948.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::panic;\n+\n+impl<'a> panic::UnwindSafe for Foo<'a> {}\n+impl<'a> panic::RefUnwindSafe for Foo<'a> {}\n+\n struct Foo<'a>(&'a mut bool);\n \n impl<'a> Drop for Foo<'a> {\n@@ -28,5 +33,15 @@ fn main() {\n         f(x);\n     }\n     assert!(ran_drop);\n-}\n \n+    let mut ran_drop = false;\n+    {\n+        let x = Foo(&mut ran_drop);\n+        let result = panic::catch_unwind(move || {\n+            let x = move || { let _ = x; panic!() };\n+            f(x);\n+        });\n+        assert!(result.is_err());\n+    }\n+    assert!(ran_drop);\n+}"}, {"sha": "7300a322ec4b73868623c005aaf7c5780d3d88c8", "filename": "src/test/run-pass/mir_calls_to_shims.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Frun-pass%2Fmir_calls_to_shims.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134c4a0f08a3d1f55ea8968fbe728fa935c71698/src%2Ftest%2Frun-pass%2Fmir_calls_to_shims.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_calls_to_shims.rs?ref=134c4a0f08a3d1f55ea8968fbe728fa935c71698", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(fn_traits)]\n+#![feature(never_type)]\n+\n+use std::panic;\n+\n+fn foo(x: u32, y: u32) -> u32 { x/y }\n+fn foo_diverges() -> ! { panic!() }\n+\n+fn test_fn_ptr<T>(mut t: T)\n+    where T: Fn(u32, u32) -> u32,\n+{\n+    let as_fn = <T as Fn<(u32, u32)>>::call;\n+    assert_eq!(as_fn(&t, (9, 3)), 3);\n+    let as_fn_mut = <T as FnMut<(u32, u32)>>::call_mut;\n+    assert_eq!(as_fn_mut(&mut t, (18, 3)), 6);\n+    let as_fn_once = <T as FnOnce<(u32, u32)>>::call_once;\n+    assert_eq!(as_fn_once(t, (24, 3)), 8);\n+}\n+\n+fn assert_panics<F>(f: F) where F: FnOnce() {\n+    let f = panic::AssertUnwindSafe(f);\n+    let result = panic::catch_unwind(move || {\n+        f.0()\n+    });\n+    if let Ok(..) = result {\n+        panic!(\"diverging function returned\");\n+    }\n+}\n+\n+fn test_fn_ptr_panic<T>(mut t: T)\n+    where T: Fn() -> !\n+{\n+    let as_fn = <T as Fn<()>>::call;\n+    assert_panics(|| as_fn(&t, ()));\n+    let as_fn_mut = <T as FnMut<()>>::call_mut;\n+    assert_panics(|| as_fn_mut(&mut t, ()));\n+    let as_fn_once = <T as FnOnce<()>>::call_once;\n+    assert_panics(|| as_fn_once(t, ()));\n+}\n+\n+fn main() {\n+    test_fn_ptr(foo);\n+    test_fn_ptr(foo as fn(u32, u32) -> u32);\n+    test_fn_ptr_panic(foo_diverges);\n+    test_fn_ptr_panic(foo_diverges as fn() -> !);\n+}"}]}