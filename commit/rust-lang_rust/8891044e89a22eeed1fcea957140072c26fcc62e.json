{"sha": "8891044e89a22eeed1fcea957140072c26fcc62e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4OTEwNDRlODlhMjJlZWVkMWZjZWE5NTcxNDAwNzJjMjZmY2M2MmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-03T12:18:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-03T12:18:13Z"}, "message": "Auto merge of #44896 - qmx:move-resolve-to-librustc, r=arielb1\n\nMove monomorphize::resolve() to librustc\n\nthis moves `monomorphize::resolve(..)` to librustc, and re-enables inlining for some trait methods, fixing #44389\n\n@nikomatsakis I've kept the calls to the new `ty::Instance::resolve(....)` always `.unwrap()`-ing for the moment, how/do you want to add more debugging info via `.unwrap_or()` or something like this?\n\nwe still have some related `resolve_*` functions on monomorphize, but I wasn't sure moving them was into the scope for this PR too.\n\n@eddyb mind to take a look too?", "tree": {"sha": "a4ebadb887f4acce00ded573c1270e5604c3c7ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4ebadb887f4acce00ded573c1270e5604c3c7ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8891044e89a22eeed1fcea957140072c26fcc62e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8891044e89a22eeed1fcea957140072c26fcc62e", "html_url": "https://github.com/rust-lang/rust/commit/8891044e89a22eeed1fcea957140072c26fcc62e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8891044e89a22eeed1fcea957140072c26fcc62e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61bad301f136fb6f4cb543014ed02034007e4bd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/61bad301f136fb6f4cb543014ed02034007e4bd2", "html_url": "https://github.com/rust-lang/rust/commit/61bad301f136fb6f4cb543014ed02034007e4bd2"}, {"sha": "11e141eba3d21fc8d7f9c406c85b44fe114e5a01", "url": "https://api.github.com/repos/rust-lang/rust/commits/11e141eba3d21fc8d7f9c406c85b44fe114e5a01", "html_url": "https://github.com/rust-lang/rust/commit/11e141eba3d21fc8d7f9c406c85b44fe114e5a01"}], "stats": {"total": 409, "additions": 273, "deletions": 136}, "files": [{"sha": "35ab1cec4cf9ebe459406021de9df6007d1c8e92", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/8891044e89a22eeed1fcea957140072c26fcc62e/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8891044e89a22eeed1fcea957140072c26fcc62e/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=8891044e89a22eeed1fcea957140072c26fcc62e", "patch": "@@ -10,6 +10,10 @@\n \n use hir::def_id::DefId;\n use ty::{self, Ty, TypeFoldable, Substs, TyCtxt};\n+use ty::subst::{Kind, Subst};\n+use traits;\n+use syntax::abi::Abi;\n+use syntax::codemap::DUMMY_SP;\n use util::ppaux;\n \n use std::fmt;\n@@ -111,4 +115,211 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n     pub fn def_id(&self) -> DefId {\n         self.def.def_id()\n     }\n+\n+    /// Resolve a (def_id, substs) pair to an (optional) instance -- most commonly,\n+    /// this is used to find the precise code that will run for a trait method invocation,\n+    /// if known.\n+    ///\n+    /// Returns `None` if we cannot resolve `Instance` to a specific instance.\n+    /// For example, in a context like this,\n+    ///\n+    /// ```\n+    /// fn foo<T: Debug>(t: T) { ... }\n+    /// ```\n+    ///\n+    /// trying to resolve `Debug::fmt` applied to `T` will yield `None`, because we do not\n+    /// know what code ought to run. (Note that this setting is also affected by the\n+    /// `RevealMode` in the parameter environment.)\n+    ///\n+    /// Presuming that coherence and type-check have succeeded, if this method is invoked\n+    /// in a monomorphic context (i.e., like during trans), then it is guaranteed to return\n+    /// `Some`.\n+    pub fn resolve(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                   param_env: ty::ParamEnv<'tcx>,\n+                   def_id: DefId,\n+                   substs: &'tcx Substs<'tcx>) -> Option<Instance<'tcx>> {\n+        debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n+        let result = if let Some(trait_def_id) = tcx.trait_of_item(def_id) {\n+            debug!(\" => associated item, attempting to find impl\");\n+            let item = tcx.associated_item(def_id);\n+            resolve_associated_item(tcx, &item, param_env, trait_def_id, substs)\n+        } else {\n+            let ty = tcx.type_of(def_id);\n+            let item_type = tcx.trans_apply_param_substs(substs, &ty);\n+\n+            let def = match item_type.sty {\n+                ty::TyFnDef(..) if {\n+                    let f = item_type.fn_sig(tcx);\n+                    f.abi() == Abi::RustIntrinsic ||\n+                        f.abi() == Abi::PlatformIntrinsic\n+                } =>\n+                {\n+                    debug!(\" => intrinsic\");\n+                    ty::InstanceDef::Intrinsic(def_id)\n+                }\n+                _ => {\n+                    if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n+                        let ty = substs.type_at(0);\n+                        if ty.needs_drop(tcx, ty::ParamEnv::empty(traits::Reveal::All)) {\n+                            debug!(\" => nontrivial drop glue\");\n+                            ty::InstanceDef::DropGlue(def_id, Some(ty))\n+                        } else {\n+                            debug!(\" => trivial drop glue\");\n+                            ty::InstanceDef::DropGlue(def_id, None)\n+                        }\n+                    } else {\n+                        debug!(\" => free item\");\n+                        ty::InstanceDef::Item(def_id)\n+                    }\n+                }\n+            };\n+            Some(Instance {\n+                def: def,\n+                substs: substs\n+            })\n+        };\n+        debug!(\"resolve(def_id={:?}, substs={:?}) = {:?}\", def_id, substs, result);\n+        result\n+    }\n+}\n+\n+fn resolve_closure<'a, 'tcx>(\n+                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                   def_id: DefId,\n+                   substs: ty::ClosureSubsts<'tcx>,\n+                   requested_kind: ty::ClosureKind)\n+-> Instance<'tcx>\n+{\n+    let actual_kind = tcx.closure_kind(def_id);\n+\n+    match needs_fn_once_adapter_shim(actual_kind, requested_kind) {\n+        Ok(true) => fn_once_adapter_instance(tcx, def_id, substs),\n+        _ => Instance::new(def_id, substs.substs)\n+    }\n+}\n+\n+fn resolve_associated_item<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    trait_item: &ty::AssociatedItem,\n+    param_env: ty::ParamEnv<'tcx>,\n+    trait_id: DefId,\n+    rcvr_substs: &'tcx Substs<'tcx>\n+    ) -> Option<Instance<'tcx>> {\n+    let def_id = trait_item.def_id;\n+    debug!(\"resolve_associated_item(trait_item={:?}, \\\n+                                    trait_id={:?}, \\\n+           rcvr_substs={:?})\",\n+           def_id, trait_id, rcvr_substs);\n+\n+    let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n+    let vtbl = tcx.trans_fulfill_obligation(DUMMY_SP, param_env, ty::Binder(trait_ref));\n+\n+    // Now that we know which impl is being used, we can dispatch to\n+    // the actual function:\n+    match vtbl {\n+        traits::VtableImpl(impl_data) => {\n+            let (def_id, substs) = traits::find_associated_item(\n+                tcx, trait_item, rcvr_substs, &impl_data);\n+            let substs = tcx.erase_regions(&substs);\n+            Some(ty::Instance::new(def_id, substs))\n+        }\n+        traits::VtableGenerator(closure_data) => {\n+            Some(Instance {\n+                def: ty::InstanceDef::Item(closure_data.closure_def_id),\n+                substs: closure_data.substs.substs\n+            })\n+        }\n+        traits::VtableClosure(closure_data) => {\n+            let trait_closure_kind = tcx.lang_items().fn_trait_kind(trait_id).unwrap();\n+            Some(resolve_closure(tcx, closure_data.closure_def_id, closure_data.substs,\n+                                 trait_closure_kind))\n+        }\n+        traits::VtableFnPointer(ref data) => {\n+            Some(Instance {\n+                def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n+                substs: rcvr_substs\n+            })\n+        }\n+        traits::VtableObject(ref data) => {\n+            let index = tcx.get_vtable_index_of_object_method(data, def_id);\n+            Some(Instance {\n+                def: ty::InstanceDef::Virtual(def_id, index),\n+                substs: rcvr_substs\n+            })\n+        }\n+        traits::VtableBuiltin(..) => {\n+            if let Some(_) = tcx.lang_items().clone_trait() {\n+                Some(Instance {\n+                    def: ty::InstanceDef::CloneShim(def_id, trait_ref.self_ty()),\n+                    substs: rcvr_substs\n+                })\n+            } else {\n+                None\n+            }\n+        }\n+        traits::VtableDefaultImpl(..) | traits::VtableParam(..) => None\n+    }\n+}\n+\n+fn needs_fn_once_adapter_shim<'a, 'tcx>(actual_closure_kind: ty::ClosureKind,\n+                              trait_closure_kind: ty::ClosureKind)\n+    -> Result<bool, ()>\n+{\n+    match (actual_closure_kind, trait_closure_kind) {\n+        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n+            (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n+            (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n+                // No adapter needed.\n+                Ok(false)\n+            }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n+            // `fn(&mut self, ...)`. In fact, at trans time, these are\n+            // basically the same thing, so we can just return llfn.\n+            Ok(false)\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n+            (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+                // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n+                // self, ...)`.  We want a `fn(self, ...)`. We can produce\n+                // this by doing something like:\n+                //\n+                //     fn call_once(self, ...) { call_mut(&self, ...) }\n+                //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n+                //\n+                // These are both the same at trans time.\n+                Ok(true)\n+        }\n+        (ty::ClosureKind::FnMut, _) |\n+        (ty::ClosureKind::FnOnce, _) => Err(())\n+    }\n+}\n+\n+fn fn_once_adapter_instance<'a, 'tcx>(\n+                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            closure_did: DefId,\n+                            substs: ty::ClosureSubsts<'tcx>,\n+                            ) -> Instance<'tcx> {\n+    debug!(\"fn_once_adapter_shim({:?}, {:?})\",\n+    closure_did,\n+    substs);\n+    let fn_once = tcx.lang_items().fn_once_trait().unwrap();\n+    let call_once = tcx.associated_items(fn_once)\n+        .find(|it| it.kind == ty::AssociatedKind::Method)\n+        .unwrap().def_id;\n+    let def = ty::InstanceDef::ClosureOnceShim { call_once };\n+\n+    let self_ty = tcx.mk_closure_from_closure_substs(\n+        closure_did, substs);\n+\n+    let sig = tcx.fn_sig(closure_did).subst(tcx, substs.substs);\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n+    assert_eq!(sig.inputs().len(), 1);\n+    let substs = tcx.mk_substs([\n+                               Kind::from(self_ty),\n+                               Kind::from(sig.inputs()[0]),\n+    ].iter().cloned());\n+\n+    debug!(\"fn_once_adapter_shim: self_ty={:?} sig={:?}\", self_ty, sig);\n+    Instance { def, substs }\n }"}, {"sha": "9d32861aedade2e9609c67f08a7c0ec34023897e", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8891044e89a22eeed1fcea957140072c26fcc62e/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8891044e89a22eeed1fcea957140072c26fcc62e/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=8891044e89a22eeed1fcea957140072c26fcc62e", "patch": "@@ -18,7 +18,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::mir::*;\n use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::*;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, Instance};\n use rustc::ty::subst::{Subst,Substs};\n \n use std::collections::VecDeque;\n@@ -78,7 +78,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         let mut callsites = VecDeque::new();\n \n         // Only do inlining into fn bodies.\n-        if let MirSource::Fn(_) = self.source {\n+        if let MirSource::Fn(caller_id) = self.source {\n             for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated() {\n                 // Don't inline calls that are in cleanup blocks.\n                 if bb_data.is_cleanup { continue; }\n@@ -87,17 +87,23 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 let terminator = bb_data.terminator();\n                 if let TerminatorKind::Call {\n                     func: Operand::Constant(ref f), .. } = terminator.kind {\n-                    if let ty::TyFnDef(callee_def_id, substs) = f.ty.sty {\n-                        if self.tcx.trait_of_item(callee_def_id).is_none() {\n-                            callsites.push_back(CallSite {\n-                                callee: callee_def_id,\n-                                substs,\n-                                bb,\n-                                location: terminator.source_info\n-                            });\n+                        if let ty::TyFnDef(callee_def_id, substs) = f.ty.sty {\n+                            let caller_def_id = self.tcx.hir.local_def_id(caller_id);\n+                            let param_env = self.tcx.param_env(caller_def_id);\n+\n+                            if let Some(instance) = Instance::resolve(self.tcx,\n+                                                                      param_env,\n+                                                                      callee_def_id,\n+                                                                      substs) {\n+                                callsites.push_back(CallSite {\n+                                    callee: instance.def_id(),\n+                                    substs: instance.substs,\n+                                    bb,\n+                                    location: terminator.source_info\n+                                });\n+                            }\n                         }\n                     }\n-                }\n             }\n         }\n "}, {"sha": "f5a90fc2e4a19c5739e8f5a293532ea090c966ad", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8891044e89a22eeed1fcea957140072c26fcc62e/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8891044e89a22eeed1fcea957140072c26fcc62e/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=8891044e89a22eeed1fcea957140072c26fcc62e", "patch": "@@ -19,9 +19,10 @@ use common::{self, CrateContext};\n use consts;\n use declare;\n use llvm::{self, ValueRef};\n-use monomorphize::{self, Instance};\n+use monomorphize::Instance;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::TypeFoldable;\n+use rustc::ty::{self, TypeFoldable};\n+use rustc::traits;\n use rustc::ty::subst::Substs;\n use type_of;\n \n@@ -179,5 +180,13 @@ pub fn resolve_and_get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     substs: &'tcx Substs<'tcx>)\n                                     -> ValueRef\n {\n-    get_fn(ccx, monomorphize::resolve(ccx.tcx(), def_id, substs))\n+    get_fn(\n+        ccx,\n+        ty::Instance::resolve(\n+            ccx.tcx(),\n+            ty::ParamEnv::empty(traits::Reveal::All),\n+            def_id,\n+            substs\n+        ).unwrap()\n+    )\n }"}, {"sha": "285a1fb7c7365f77032fc946cff72365b7c5d247", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8891044e89a22eeed1fcea957140072c26fcc62e/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8891044e89a22eeed1fcea957140072c26fcc62e/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=8891044e89a22eeed1fcea957140072c26fcc62e", "patch": "@@ -566,7 +566,10 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         if let ConstVal::Unevaluated(def_id, substs) = constant.val {\n             let substs = self.tcx.trans_apply_param_substs(self.param_substs,\n                                                            &substs);\n-            let instance = monomorphize::resolve(self.tcx, def_id, substs);\n+            let instance = ty::Instance::resolve(self.tcx,\n+                                                 ty::ParamEnv::empty(traits::Reveal::All),\n+                                                 def_id,\n+                                                 substs).unwrap();\n             collect_neighbours(self.tcx, instance, true, self.output);\n         }\n \n@@ -587,7 +590,11 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n                 let constness = match (self.const_context, &callee_ty.sty) {\n                     (true, &ty::TyFnDef(def_id, substs)) if self.tcx.is_const_fn(def_id) => {\n-                        let instance = monomorphize::resolve(self.tcx, def_id, substs);\n+                        let instance =\n+                            ty::Instance::resolve(self.tcx,\n+                                                  ty::ParamEnv::empty(traits::Reveal::All),\n+                                                  def_id,\n+                                                  substs).unwrap();\n                         Some(instance)\n                     }\n                     _ => None\n@@ -657,7 +664,10 @@ fn visit_fn_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           output: &mut Vec<TransItem<'tcx>>)\n {\n     if let ty::TyFnDef(def_id, substs) = ty.sty {\n-        let instance = monomorphize::resolve(tcx, def_id, substs);\n+        let instance = ty::Instance::resolve(tcx,\n+                                             ty::ParamEnv::empty(traits::Reveal::All),\n+                                             def_id,\n+                                             substs).unwrap();\n         visit_instance_use(tcx, instance, is_direct_call, output);\n     }\n }\n@@ -845,7 +855,11 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // Walk all methods of the trait, including those of its supertraits\n             let methods = traits::get_vtable_methods(tcx, poly_trait_ref);\n             let methods = methods.filter_map(|method| method)\n-                .map(|(def_id, substs)| monomorphize::resolve(tcx, def_id, substs))\n+                .map(|(def_id, substs)| ty::Instance::resolve(\n+                        tcx,\n+                        ty::ParamEnv::empty(traits::Reveal::All),\n+                        def_id,\n+                        substs).unwrap())\n                 .filter(|&instance| should_trans_locally(tcx, &instance))\n                 .map(|instance| create_fn_trans_item(instance));\n             output.extend(methods);\n@@ -1000,8 +1014,10 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         continue;\n                     }\n \n-                    let instance =\n-                        monomorphize::resolve(tcx, method.def_id, callee_substs);\n+                    let instance = ty::Instance::resolve(tcx,\n+                                                         ty::ParamEnv::empty(traits::Reveal::All),\n+                                                         method.def_id,\n+                                                         callee_substs).unwrap();\n \n                     let trans_item = create_fn_trans_item(instance);\n                     if trans_item.is_instantiable(tcx) && should_trans_locally(tcx, &instance) {"}, {"sha": "591aa974666cce89dbff36feafed0bebb0424d6f", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8891044e89a22eeed1fcea957140072c26fcc62e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8891044e89a22eeed1fcea957140072c26fcc62e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=8891044e89a22eeed1fcea957140072c26fcc62e", "patch": "@@ -13,6 +13,7 @@ use rustc::middle::lang_items;\n use rustc::middle::const_val::{ConstEvalErr, ConstInt, ErrKind};\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutTyper};\n+use rustc::traits;\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n use adt;\n@@ -429,7 +430,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 let (instance, mut llfn) = match callee.ty.sty {\n                     ty::TyFnDef(def_id, substs) => {\n-                        (Some(monomorphize::resolve(bcx.ccx.tcx(), def_id, substs)),\n+                        (Some(ty::Instance::resolve(bcx.ccx.tcx(),\n+                                                    ty::ParamEnv::empty(traits::Reveal::All),\n+                                                    def_id,\n+                                                    substs).unwrap()),\n                          None)\n                     }\n                     ty::TyFnPtr(_) => {"}, {"sha": "1b8e68f691ae66c4b3c228f8f0f86d5c6423f808", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8891044e89a22eeed1fcea957140072c26fcc62e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8891044e89a22eeed1fcea957140072c26fcc62e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=8891044e89a22eeed1fcea957140072c26fcc62e", "patch": "@@ -14,6 +14,7 @@ use rustc_const_math::ConstInt::*;\n use rustc_const_math::{ConstInt, ConstMathErr};\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n+use rustc::traits;\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -30,7 +31,6 @@ use common::{C_array, C_bool, C_bytes, C_int, C_uint, C_big_integral, C_u32, C_u\n use common::{C_null, C_struct, C_str_slice, C_undef, C_usize, C_vector, is_undef};\n use common::const_to_opt_u128;\n use consts;\n-use monomorphize;\n use type_of;\n use type_::Type;\n use value::Value;\n@@ -261,7 +261,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                  substs: &'tcx Substs<'tcx>,\n                  args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n                  -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let instance = monomorphize::resolve(ccx.tcx(), def_id, substs);\n+        let instance = ty::Instance::resolve(ccx.tcx(),\n+                                             ty::ParamEnv::empty(traits::Reveal::All),\n+                                             def_id,\n+                                             substs).unwrap();\n         let mir = ccx.tcx().instance_mir(instance.def);\n         MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n     }"}, {"sha": "cd2a881451cd35625282ba5db9f24aae4da85882", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 113, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/8891044e89a22eeed1fcea957140072c26fcc62e/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8891044e89a22eeed1fcea957140072c26fcc62e/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=8891044e89a22eeed1fcea957140072c26fcc62e", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::Abi;\n-use common::*;\n-\n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::DropInPlaceFnLangItem;\n use rustc::traits;\n@@ -99,123 +96,14 @@ pub fn resolve_closure<'a, 'tcx> (\n     }\n }\n \n-fn resolve_associated_item<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    trait_item: &ty::AssociatedItem,\n-    trait_id: DefId,\n-    rcvr_substs: &'tcx Substs<'tcx>\n-) -> Instance<'tcx> {\n-    let def_id = trait_item.def_id;\n-    debug!(\"resolve_associated_item(trait_item={:?}, \\\n-                                    trait_id={:?}, \\\n-                                    rcvr_substs={:?})\",\n-           def_id, trait_id, rcvr_substs);\n-\n-    let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = tcx.trans_fulfill_obligation(\n-        DUMMY_SP, ty::ParamEnv::empty(traits::Reveal::All), ty::Binder(trait_ref));\n-\n-    // Now that we know which impl is being used, we can dispatch to\n-    // the actual function:\n-    match vtbl {\n-        traits::VtableImpl(impl_data) => {\n-            let (def_id, substs) = traits::find_associated_item(\n-                tcx, trait_item, rcvr_substs, &impl_data);\n-            let substs = tcx.erase_regions(&substs);\n-            ty::Instance::new(def_id, substs)\n-        }\n-        traits::VtableGenerator(closure_data) => {\n-            Instance {\n-                def: ty::InstanceDef::Item(closure_data.closure_def_id),\n-                substs: closure_data.substs.substs\n-            }\n-        }\n-        traits::VtableClosure(closure_data) => {\n-            let trait_closure_kind = tcx.lang_items().fn_trait_kind(trait_id).unwrap();\n-            resolve_closure(tcx, closure_data.closure_def_id, closure_data.substs,\n-                            trait_closure_kind)\n-        }\n-        traits::VtableFnPointer(ref data) => {\n-            Instance {\n-                def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n-                substs: rcvr_substs\n-            }\n-        }\n-        traits::VtableObject(ref data) => {\n-            let index = tcx.get_vtable_index_of_object_method(data, def_id);\n-            Instance {\n-                def: ty::InstanceDef::Virtual(def_id, index),\n-                substs: rcvr_substs\n-            }\n-        }\n-        traits::VtableBuiltin(..) if Some(trait_id) == tcx.lang_items().clone_trait() => {\n-            Instance {\n-                def: ty::InstanceDef::CloneShim(def_id, trait_ref.self_ty()),\n-                substs: rcvr_substs\n-            }\n-        }\n-        _ => {\n-            bug!(\"static call to invalid vtable: {:?}\", vtbl)\n-        }\n-    }\n-}\n-\n-/// The point where linking happens. Resolve a (def_id, substs)\n-/// pair to an instance.\n-pub fn resolve<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId,\n-    substs: &'tcx Substs<'tcx>\n-) -> Instance<'tcx> {\n-    debug!(\"resolve(def_id={:?}, substs={:?})\",\n-           def_id, substs);\n-    let result = if let Some(trait_def_id) = tcx.trait_of_item(def_id) {\n-        debug!(\" => associated item, attempting to find impl\");\n-        let item = tcx.associated_item(def_id);\n-        resolve_associated_item(tcx, &item, trait_def_id, substs)\n-    } else {\n-        let item_type = def_ty(tcx, def_id, substs);\n-        let def = match item_type.sty {\n-            ty::TyFnDef(..) if {\n-                    let f = item_type.fn_sig(tcx);\n-                    f.abi() == Abi::RustIntrinsic ||\n-                    f.abi() == Abi::PlatformIntrinsic\n-                } =>\n-            {\n-                debug!(\" => intrinsic\");\n-                ty::InstanceDef::Intrinsic(def_id)\n-            }\n-            _ => {\n-                if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n-                    let ty = substs.type_at(0);\n-                    if type_needs_drop(tcx, ty) {\n-                        debug!(\" => nontrivial drop glue\");\n-                        ty::InstanceDef::DropGlue(def_id, Some(ty))\n-                    } else {\n-                        debug!(\" => trivial drop glue\");\n-                        ty::InstanceDef::DropGlue(def_id, None)\n-                    }\n-                } else {\n-                    debug!(\" => free item\");\n-                    ty::InstanceDef::Item(def_id)\n-                }\n-            }\n-        };\n-        Instance { def, substs }\n-    };\n-    debug!(\"resolve(def_id={:?}, substs={:?}) = {}\",\n-           def_id, substs, result);\n-    result\n-}\n-\n pub fn resolve_drop_in_place<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: Ty<'tcx>)\n     -> ty::Instance<'tcx>\n {\n     let def_id = tcx.require_lang_item(DropInPlaceFnLangItem);\n     let substs = tcx.intern_substs(&[Kind::from(ty)]);\n-    resolve(tcx, def_id, substs)\n+    Instance::resolve(tcx, ty::ParamEnv::empty(traits::Reveal::All), def_id, substs).unwrap()\n }\n \n pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}]}