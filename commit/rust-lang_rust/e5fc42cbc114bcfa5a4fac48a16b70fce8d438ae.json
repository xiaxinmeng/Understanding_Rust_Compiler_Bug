{"sha": "e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ZmM0MmNiYzExNGJjZmE1YTRmYWM0OGExNmI3MGZjZThkNDM4YWU=", "commit": {"author": {"name": "Timo Freiberg", "email": "timo.freiberg@gmail.com", "date": "2020-03-26T19:59:35Z"}, "committer": {"name": "Timo Freiberg", "email": "timo.freiberg@gmail.com", "date": "2020-04-01T21:06:14Z"}, "message": "Add create_function assist", "tree": {"sha": "1fac06039cf04636a259fe21d98a8a8875e2c096", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fac06039cf04636a259fe21d98a8a8875e2c096"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae", "html_url": "https://github.com/rust-lang/rust/commit/e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae/comments", "author": {"login": "TimoFreiberg", "id": 5281645, "node_id": "MDQ6VXNlcjUyODE2NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5281645?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimoFreiberg", "html_url": "https://github.com/TimoFreiberg", "followers_url": "https://api.github.com/users/TimoFreiberg/followers", "following_url": "https://api.github.com/users/TimoFreiberg/following{/other_user}", "gists_url": "https://api.github.com/users/TimoFreiberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimoFreiberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimoFreiberg/subscriptions", "organizations_url": "https://api.github.com/users/TimoFreiberg/orgs", "repos_url": "https://api.github.com/users/TimoFreiberg/repos", "events_url": "https://api.github.com/users/TimoFreiberg/events{/privacy}", "received_events_url": "https://api.github.com/users/TimoFreiberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimoFreiberg", "id": 5281645, "node_id": "MDQ6VXNlcjUyODE2NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5281645?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimoFreiberg", "html_url": "https://github.com/TimoFreiberg", "followers_url": "https://api.github.com/users/TimoFreiberg/followers", "following_url": "https://api.github.com/users/TimoFreiberg/following{/other_user}", "gists_url": "https://api.github.com/users/TimoFreiberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimoFreiberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimoFreiberg/subscriptions", "organizations_url": "https://api.github.com/users/TimoFreiberg/orgs", "repos_url": "https://api.github.com/users/TimoFreiberg/repos", "events_url": "https://api.github.com/users/TimoFreiberg/events{/privacy}", "received_events_url": "https://api.github.com/users/TimoFreiberg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f696df379a5dd450b3d89a8c690de5f8d78f6be2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f696df379a5dd450b3d89a8c690de5f8d78f6be2", "html_url": "https://github.com/rust-lang/rust/commit/f696df379a5dd450b3d89a8c690de5f8d78f6be2"}], "stats": {"total": 862, "additions": 862, "deletions": 0}, "files": [{"sha": "64444ee3aa58e29097039c5f56d4d8c4c44eeb14", "filename": "crates/ra_assists/src/doc_tests/generated.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs?ref=e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae", "patch": "@@ -58,6 +58,33 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_add_function() {\n+    check(\n+        \"add_function\",\n+        r#####\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+     bar<|>(\"\", baz());\n+}\n+\n+\"#####,\n+        r#####\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+     bar(\"\", baz());\n+}\n+\n+fn bar(arg: &str, baz: Baz) {\n+    unimplemented!()\n+}\n+\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_add_hash() {\n     check("}, {"sha": "f6721d9dffb8dbb50f922243800e44977762b0ee", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "added", "additions": 807, "deletions": 0, "changes": 807, "blob_url": "https://github.com/rust-lang/rust/blob/e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae", "patch": "@@ -0,0 +1,807 @@\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    SmolStr, SyntaxKind, SyntaxNode, TextUnit,\n+};\n+\n+use crate::{Assist, AssistCtx, AssistId};\n+use ast::{ArgListOwner, CallExpr, Expr};\n+use hir::HirDisplay;\n+use ra_fmt::leading_indent;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+\n+// Assist: add_function\n+//\n+// Adds a stub function with a signature matching the function under the cursor.\n+//\n+// ```\n+// struct Baz;\n+// fn baz() -> Baz { Baz }\n+// fn foo() {\n+//      bar<|>(\"\", baz());\n+// }\n+//\n+// ```\n+// ->\n+// ```\n+// struct Baz;\n+// fn baz() -> Baz { Baz }\n+// fn foo() {\n+//      bar(\"\", baz());\n+// }\n+//\n+// fn bar(arg: &str, baz: Baz) {\n+//     unimplemented!()\n+// }\n+//\n+// ```\n+pub(crate) fn add_function(ctx: AssistCtx) -> Option<Assist> {\n+    let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n+    let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n+    let path = path_expr.path()?;\n+\n+    if path.qualifier().is_some() {\n+        return None;\n+    }\n+\n+    if ctx.sema.resolve_path(&path).is_some() {\n+        // The function call already resolves, no need to add a function\n+        return None;\n+    }\n+\n+    let function_builder = FunctionBuilder::from_call(&ctx, &call)?;\n+\n+    ctx.add_assist(AssistId(\"add_function\"), \"Add function\", |edit| {\n+        edit.target(call.syntax().text_range());\n+\n+        let function_template = function_builder.render();\n+        edit.set_cursor(function_template.cursor_offset);\n+        edit.insert(function_template.insert_offset, function_template.fn_text);\n+    })\n+}\n+\n+struct FunctionTemplate {\n+    insert_offset: TextUnit,\n+    cursor_offset: TextUnit,\n+    fn_text: String,\n+}\n+\n+struct FunctionBuilder {\n+    start_offset: TextUnit,\n+    fn_name: String,\n+    fn_generics: String,\n+    fn_args: String,\n+    indent: String,\n+}\n+\n+impl FunctionBuilder {\n+    fn from_call(ctx: &AssistCtx, call: &ast::CallExpr) -> Option<Self> {\n+        let (start, indent) = next_space_for_fn(&call)?;\n+        let fn_name = fn_name(&call)?;\n+        let fn_generics = fn_generics(&call)?;\n+        let fn_args = fn_args(ctx, &call)?;\n+        let indent = if let Some(i) = &indent { i.to_string() } else { String::new() };\n+        Some(Self { start_offset: start, fn_name, fn_generics, fn_args, indent })\n+    }\n+    fn render(&self) -> FunctionTemplate {\n+        let mut fn_buf = String::with_capacity(128);\n+        fn_buf.push_str(\"\\n\\n\");\n+        fn_buf.push_str(&self.indent);\n+        fn_buf.push_str(\"fn \");\n+        fn_buf.push_str(&self.fn_name);\n+        fn_buf.push_str(&self.fn_generics);\n+        fn_buf.push_str(&self.fn_args);\n+        fn_buf.push_str(\" {\\n\");\n+        fn_buf.push_str(&self.indent);\n+        fn_buf.push_str(\"    \");\n+\n+        // We take the offset here to put the cursor in front of the `unimplemented!()` body\n+        let offset = TextUnit::of_str(&fn_buf);\n+\n+        fn_buf.push_str(\"unimplemented!()\\n\");\n+        fn_buf.push_str(&self.indent);\n+        fn_buf.push_str(\"}\");\n+\n+        let cursor_pos = self.start_offset + offset;\n+        FunctionTemplate {\n+            fn_text: fn_buf,\n+            cursor_offset: cursor_pos,\n+            insert_offset: self.start_offset,\n+        }\n+    }\n+}\n+\n+fn fn_name(call: &CallExpr) -> Option<String> {\n+    Some(call.expr()?.syntax().to_string())\n+}\n+\n+fn fn_generics(_call: &CallExpr) -> Option<String> {\n+    // TODO\n+    Some(\"\".into())\n+}\n+\n+fn fn_args(ctx: &AssistCtx, call: &CallExpr) -> Option<String> {\n+    let mut arg_names = Vec::new();\n+    let mut arg_types = Vec::new();\n+    for arg in call.arg_list()?.args() {\n+        let arg_name = match fn_arg_name(&arg) {\n+            Some(name) => name,\n+            None => String::from(\"arg\"),\n+        };\n+        arg_names.push(arg_name);\n+        arg_types.push(match fn_arg_type(ctx, &arg) {\n+            Some(ty) => ty,\n+            None => String::from(\"()\"),\n+        });\n+    }\n+    deduplicate_arg_names(&mut arg_names);\n+    Some(format!(\n+        \"({})\",\n+        arg_names\n+            .into_iter()\n+            .zip(arg_types)\n+            .map(|(name, ty)| format!(\"{}: {}\", name, ty))\n+            .collect::<Vec<_>>()\n+            .join(\", \")\n+    ))\n+}\n+\n+/// Makes duplicate argument names unique by appending incrementing numbers.\n+///\n+/// ```\n+/// let mut names: Vec<String> =\n+///     vec![\"foo\".into(), \"foo\".into(), \"bar\".into(), \"baz\".into(), \"bar\".into()];\n+/// deduplicate_arg_names(&mut names);\n+/// let expected: Vec<String> =\n+///     vec![\"foo_1\".into(), \"foo_2\".into(), \"bar_1\".into(), \"baz\".into(), \"bar_2\".into()];\n+/// assert_eq!(names, expected);\n+/// ```\n+fn deduplicate_arg_names(arg_names: &mut Vec<String>) {\n+    let arg_name_counts = arg_names.iter().fold(FxHashMap::default(), |mut m, name| {\n+        *m.entry(name).or_insert(0) += 1;\n+        m\n+    });\n+    let duplicate_arg_names: FxHashSet<String> = arg_name_counts\n+        .into_iter()\n+        .filter(|(_, count)| *count >= 2)\n+        .map(|(name, _)| name.clone())\n+        .collect();\n+\n+    let mut counter_per_name = FxHashMap::default();\n+    for arg_name in arg_names.iter_mut() {\n+        if duplicate_arg_names.contains(arg_name) {\n+            let counter = counter_per_name.entry(arg_name.clone()).or_insert(1);\n+            arg_name.push('_');\n+            arg_name.push_str(&counter.to_string());\n+            *counter += 1;\n+        }\n+    }\n+}\n+\n+fn fn_arg_name(fn_arg: &Expr) -> Option<String> {\n+    match fn_arg {\n+        Expr::CastExpr(cast_expr) => fn_arg_name(&cast_expr.expr()?),\n+        _ => Some(\n+            fn_arg\n+                .syntax()\n+                .descendants()\n+                .filter(|d| ast::NameRef::can_cast(d.kind()))\n+                .last()?\n+                .to_string(),\n+        ),\n+    }\n+}\n+\n+fn fn_arg_type(ctx: &AssistCtx, fn_arg: &Expr) -> Option<String> {\n+    let ty = ctx.sema.type_of_expr(fn_arg)?;\n+    if ty.is_unknown() {\n+        return None;\n+    }\n+    Some(ty.display(ctx.sema.db).to_string())\n+}\n+\n+/// Returns the position inside the current mod or file\n+/// directly after the current block\n+/// We want to write the generated function directly after\n+/// fns, impls or macro calls, but inside mods\n+fn next_space_for_fn(expr: &CallExpr) -> Option<(TextUnit, Option<SmolStr>)> {\n+    let mut ancestors = expr.syntax().ancestors().peekable();\n+    let mut last_ancestor: Option<SyntaxNode> = None;\n+    while let Some(next_ancestor) = ancestors.next() {\n+        match next_ancestor.kind() {\n+            SyntaxKind::SOURCE_FILE => {\n+                break;\n+            }\n+            SyntaxKind::ITEM_LIST => {\n+                if ancestors.peek().map(|a| a.kind()) == Some(SyntaxKind::MODULE) {\n+                    break;\n+                }\n+            }\n+            _ => {}\n+        }\n+        last_ancestor = Some(next_ancestor);\n+    }\n+    last_ancestor.map(|a| (a.text_range().end(), leading_indent(&a)))\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::helpers::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn add_function_with_no_args() {\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo() {\n+    bar<|>();\n+}\n+\",\n+            r\"\n+fn foo() {\n+    bar();\n+}\n+\n+fn bar() {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_from_method() {\n+        // This ensures that the function is correctly generated\n+        // in the next outer mod or file\n+        check_assist(\n+            add_function,\n+            r\"\n+impl Foo {\n+    fn foo() {\n+        bar<|>();\n+    }\n+}\n+\",\n+            r\"\n+impl Foo {\n+    fn foo() {\n+        bar();\n+    }\n+}\n+\n+fn bar() {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_directly_after_current_block() {\n+        // The new fn should not be created at the end of the file or module\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo1() {\n+    bar<|>();\n+}\n+\n+fn foo2() {}\n+\",\n+            r\"\n+fn foo1() {\n+    bar();\n+}\n+\n+fn bar() {\n+    <|>unimplemented!()\n+}\n+\n+fn foo2() {}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_no_args_in_same_module() {\n+        check_assist(\n+            add_function,\n+            r\"\n+mod baz {\n+    fn foo() {\n+        bar<|>();\n+    }\n+}\n+\",\n+            r\"\n+mod baz {\n+    fn foo() {\n+        bar();\n+    }\n+\n+    fn bar() {\n+        <|>unimplemented!()\n+    }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_function_call_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { unimplemented!() }\n+fn foo() {\n+    bar<|>(baz());\n+}\n+\",\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { unimplemented!() }\n+fn foo() {\n+    bar(baz());\n+}\n+\n+fn bar(baz: Baz) {\n+    <|>unimplemented!()\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn add_function_with_method_call_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+struct Baz;\n+impl Baz {\n+    fn foo(&self) -> Baz {\n+        ba<|>r(self.baz())\n+    }\n+    fn baz(&self) -> Baz {\n+        Baz\n+    }\n+}\n+\",\n+            r\"\n+struct Baz;\n+impl Baz {\n+    fn foo(&self) -> Baz {\n+        bar(self.baz())\n+    }\n+    fn baz(&self) -> Baz {\n+        Baz\n+    }\n+}\n+\n+fn bar(baz: Baz) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_string_literal_arg() {\n+        check_assist(\n+            add_function,\n+            r#\"\n+fn foo() {\n+    <|>bar(\"bar\")\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    bar(\"bar\")\n+}\n+\n+fn bar(arg: &str) {\n+    <|>unimplemented!()\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_char_literal_arg() {\n+        check_assist(\n+            add_function,\n+            r#\"\n+fn foo() {\n+    <|>bar('x')\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    bar('x')\n+}\n+\n+fn bar(arg: char) {\n+    <|>unimplemented!()\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_int_literal_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo() {\n+    <|>bar(42)\n+}\n+\",\n+            r\"\n+fn foo() {\n+    bar(42)\n+}\n+\n+fn bar(arg: i32) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_cast_int_literal_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo() {\n+    <|>bar(42 as u8)\n+}\n+\",\n+            r\"\n+fn foo() {\n+    bar(42 as u8)\n+}\n+\n+fn bar(arg: u8) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn name_of_cast_variable_is_used() {\n+        // Ensures that the name of the cast type isn't used\n+        // in the generated function signature.\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo() {\n+    let x = 42;\n+    bar<|>(x as u8)\n+}\n+\",\n+            r\"\n+fn foo() {\n+    let x = 42;\n+    bar(x as u8)\n+}\n+\n+fn bar(x: u8) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_variable_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo() {\n+    let worble = ();\n+    <|>bar(worble)\n+}\n+\",\n+            r\"\n+fn foo() {\n+    let worble = ();\n+    bar(worble)\n+}\n+\n+fn bar(worble: ()) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_with_impl_trait_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+trait Foo {}\n+fn foo() -> impl Foo {\n+    unimplemented!()\n+}\n+fn baz() {\n+    <|>bar(foo())\n+}\n+\",\n+            r\"\n+trait Foo {}\n+fn foo() -> impl Foo {\n+    unimplemented!()\n+}\n+fn baz() {\n+    bar(foo())\n+}\n+\n+fn bar(foo: impl Foo) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME print paths properly to make this test pass\n+    fn add_function_with_qualified_path_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+mod Baz {\n+    pub struct Bof;\n+    pub fn baz() -> Bof { Bof }\n+}\n+mod Foo {\n+    fn foo() {\n+        <|>bar(super::Baz::baz())\n+    }\n+}\n+\",\n+            r\"\n+mod Baz {\n+    pub struct Bof;\n+    pub fn baz() -> Bof { Bof }\n+}\n+mod Foo {\n+    fn foo() {\n+        bar(super::Baz::baz())\n+    }\n+\n+    fn bar(baz: super::Baz::Bof) {\n+        <|>unimplemented!()\n+    }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME fix printing the generics of a `Ty` to make this test pass\n+    fn add_function_with_generic_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo<T>(t: T) {\n+    <|>bar(t)\n+}\n+\",\n+            r\"\n+fn foo<T>(t: T) {\n+    bar(t)\n+}\n+\n+fn bar<T>(t: T) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME Fix function type printing to make this test pass\n+    fn add_function_with_fn_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+struct Baz;\n+impl Baz {\n+    fn new() -> Self { Baz }\n+}\n+fn foo() {\n+    <|>bar(Baz::new);\n+}\n+\",\n+            r\"\n+struct Baz;\n+impl Baz {\n+    fn new() -> Self { Baz }\n+}\n+fn foo() {\n+    bar(Baz::new);\n+}\n+\n+fn bar(arg: fn() -> Baz) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME Fix closure type printing to make this test pass\n+    fn add_function_with_closure_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo() {\n+    let closure = |x: i64| x - 1;\n+    <|>bar(closure)\n+}\n+\",\n+            r\"\n+fn foo() {\n+    let closure = |x: i64| x - 1;\n+    bar(closure)\n+}\n+\n+fn bar(closure: impl Fn(i64) -> i64) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn unresolveable_types_default_to_unit() {\n+        check_assist(\n+            add_function,\n+            r\"\n+fn foo() {\n+    <|>bar(baz)\n+}\n+\",\n+            r\"\n+fn foo() {\n+    bar(baz)\n+}\n+\n+fn bar(baz: ()) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn arg_names_dont_overlap() {\n+        check_assist(\n+            add_function,\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+    <|>bar(baz(), baz())\n+}\n+\",\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+    bar(baz(), baz())\n+}\n+\n+fn bar(baz_1: Baz, baz_2: Baz) {\n+    <|>unimplemented!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn arg_name_counters_start_at_1_per_name() {\n+        check_assist(\n+            add_function,\n+            r#\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+    <|>bar(baz(), baz(), \"foo\", \"bar\")\n+}\n+\"#,\n+            r#\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+    bar(baz(), baz(), \"foo\", \"bar\")\n+}\n+\n+fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) {\n+    <|>unimplemented!()\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_not_applicable_if_function_already_exists() {\n+        check_assist_not_applicable(\n+            add_function,\n+            r\"\n+fn foo() {\n+    bar<|>();\n+}\n+\n+fn bar() {}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_not_applicable_if_unresolved_variable_in_call_is_selected() {\n+        check_assist_not_applicable(\n+            // bar is resolved, but baz isn't.\n+            // The assist is only active if the cursor is on an unresolved path,\n+            // but the assist should only be offered if the path is a function call.\n+            add_function,\n+            r\"\n+fn foo() {\n+    bar(b<|>az);\n+}\n+\n+fn bar(baz: ()) {}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_not_applicable_if_function_path_not_singleton() {\n+        // In the future this assist could be extended to generate functions\n+        // if the path is in the same crate (or even the same workspace).\n+        // For the beginning, I think this is fine.\n+        check_assist_not_applicable(\n+            add_function,\n+            r\"\n+fn foo() {\n+    other_crate::bar<|>();\n+}\n+        \",\n+        )\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    fn create_method_with_no_args() {\n+        check_assist(\n+            add_function,\n+            r\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self) {\n+        self.bar()<|>;\n+    }\n+}\n+        \",\n+            r\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self) {\n+        self.bar();\n+    }\n+    fn bar(&self) {\n+        unimplemented!();\n+    }\n+}\n+        \",\n+        )\n+    }\n+}"}, {"sha": "66854cb5a40159519b210ebe4b84ed4559c4c422", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae", "patch": "@@ -96,6 +96,7 @@ mod handlers {\n     mod add_custom_impl;\n     mod add_derive;\n     mod add_explicit_type;\n+    mod add_function;\n     mod add_impl;\n     mod add_missing_impl_members;\n     mod add_new;\n@@ -128,6 +129,7 @@ mod handlers {\n             add_custom_impl::add_custom_impl,\n             add_derive::add_derive,\n             add_explicit_type::add_explicit_type,\n+            add_function::add_function,\n             add_impl::add_impl,\n             add_missing_impl_members::add_missing_default_members,\n             add_missing_impl_members::add_missing_impl_members,"}, {"sha": "754131f6fec11973c2a1970fc8148eaf37031c92", "filename": "docs/user/assists.md", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=e5fc42cbc114bcfa5a4fac48a16b70fce8d438ae", "patch": "@@ -56,6 +56,32 @@ fn main() {\n }\n ```\n \n+## `add_function`\n+\n+Adds a stub function with a signature matching the function under the cursor.\n+\n+```rust\n+// BEFORE\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+     bar\u2503(\"\", baz());\n+}\n+\n+\n+// AFTER\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+     bar(\"\", baz());\n+}\n+\n+fn bar(arg: &str, baz: Baz) {\n+    unimplemented!()\n+}\n+\n+```\n+\n ## `add_hash`\n \n Adds a hash to a raw string literal."}]}