{"sha": "750d48b0ad1854b389ce1c209484f9146dc7aba0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MGQ0OGIwYWQxODU0YjM4OWNlMWMyMDk0ODRmOTE0NmRjN2FiYTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-22T08:51:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-22T08:51:20Z"}, "message": "auto merge of #11711 : alexcrichton/rust/issue-11683, r=brson\n\nThere's lots of fun rationale in the comments of the diff.\r\n\r\nCloses #11683", "tree": {"sha": "3fd87b6b16120d4e29b758fb6033ee2e8a1aa3c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fd87b6b16120d4e29b758fb6033ee2e8a1aa3c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/750d48b0ad1854b389ce1c209484f9146dc7aba0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/750d48b0ad1854b389ce1c209484f9146dc7aba0", "html_url": "https://github.com/rust-lang/rust/commit/750d48b0ad1854b389ce1c209484f9146dc7aba0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/750d48b0ad1854b389ce1c209484f9146dc7aba0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47660f74fcbacb9405fed9a1a023a0bb0443c10d", "url": "https://api.github.com/repos/rust-lang/rust/commits/47660f74fcbacb9405fed9a1a023a0bb0443c10d", "html_url": "https://github.com/rust-lang/rust/commit/47660f74fcbacb9405fed9a1a023a0bb0443c10d"}, {"sha": "12c5fc5877f708e8e4df05bf834261f5237ac437", "url": "https://api.github.com/repos/rust-lang/rust/commits/12c5fc5877f708e8e4df05bf834261f5237ac437", "html_url": "https://github.com/rust-lang/rust/commit/12c5fc5877f708e8e4df05bf834261f5237ac437"}], "stats": {"total": 62, "additions": 58, "deletions": 4}, "files": [{"sha": "b89c06edda35b2d72695f0123403d5d92eb086e8", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 58, "deletions": 4, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/750d48b0ad1854b389ce1c209484f9146dc7aba0/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/750d48b0ad1854b389ce1c209484f9146dc7aba0/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=750d48b0ad1854b389ce1c209484f9146dc7aba0", "patch": "@@ -94,12 +94,63 @@ pub mod compiled {\n \n     pub unsafe fn cleanup() {}\n \n+    // Rationale for all of these functions being inline(never)\n+    //\n+    // The #[thread_local] annotation gets propagated all the way through to\n+    // LLVM, meaning the global is specially treated by LLVM to lower it to an\n+    // efficient sequence of instructions. This also involves dealing with fun\n+    // stuff in object files and whatnot. Regardless, it turns out this causes\n+    // trouble with green threads and lots of optimizations turned on. The\n+    // following case study was done on linux x86_64, but I would imagine that\n+    // other platforms are similar.\n+    //\n+    // On linux, the instruction sequence for loading the tls pointer global\n+    // looks like:\n+    //\n+    //      mov %fs:0x0, %rax\n+    //      mov -0x8(%rax), %rbx\n+    //\n+    // This code leads me to believe that (%fs:0x0) is a table, and then the\n+    // table contains the TLS values for the process. Hence, the slot at offset\n+    // -0x8 is the task TLS pointer. This leads us to the conclusion that this\n+    // table is the actual thread local part of each thread. The kernel sets up\n+    // the fs segment selector to point at the right region of memory for each\n+    // thread.\n+    //\n+    // Optimizations lead me to believe that this code is lowered to these\n+    // instructions in the LLVM codegen passes, because you'll see code like\n+    // this when everything is optimized:\n+    //\n+    //      mov %fs:0x0, %r14\n+    //      mov -0x8(%r14), %rbx\n+    //      // do something with %rbx, the rust Task pointer\n+    //\n+    //      ... // <- do more things\n+    //\n+    //      mov -0x8(%r14), %rbx\n+    //      // do something else with %rbx\n+    //\n+    // Note that the optimization done here is that the first load is not\n+    // duplicated during the lower instructions. This means that the %fs:0x0\n+    // memory location is only dereferenced once.\n+    //\n+    // Normally, this is actually a good thing! With green threads, however,\n+    // it's very possible for the code labeled \"do more things\" to context\n+    // switch to another thread. If this happens, then we *must* re-load %fs:0x0\n+    // because it's changed (we're on a different thread). If we don't re-load\n+    // the table location, then we'll be reading the original thread's TLS\n+    // values, not our thread's TLS values.\n+    //\n+    // Hence, we never inline these functions. By never inlining, we're\n+    // guaranteed that loading the table is a local decision which is forced to\n+    // *always* happen.\n+\n     /// Give a pointer to thread-local storage.\n     ///\n     /// # Safety note\n     ///\n     /// Does not validate the pointer type.\n-    #[inline]\n+    #[inline(never)] // see comments above\n     pub unsafe fn put<T>(sched: ~T) {\n         RT_TLS_PTR = cast::transmute(sched)\n     }\n@@ -109,7 +160,7 @@ pub mod compiled {\n     /// # Safety note\n     ///\n     /// Does not validate the pointer type.\n-    #[inline]\n+    #[inline(never)] // see comments above\n     pub unsafe fn take<T>() -> ~T {\n         let ptr = RT_TLS_PTR;\n         rtassert!(!ptr.is_null());\n@@ -124,7 +175,7 @@ pub mod compiled {\n     /// # Safety note\n     ///\n     /// Does not validate the pointer type.\n-    #[inline]\n+    #[inline(never)] // see comments above\n     pub unsafe fn try_take<T>() -> Option<~T> {\n         let ptr = RT_TLS_PTR;\n         if ptr.is_null() {\n@@ -143,25 +194,28 @@ pub mod compiled {\n     ///\n     /// Does not validate the pointer type.\n     /// Leaves the old pointer in TLS for speed.\n-    #[inline]\n+    #[inline(never)] // see comments above\n     pub unsafe fn unsafe_take<T>() -> ~T {\n         cast::transmute(RT_TLS_PTR)\n     }\n \n     /// Check whether there is a thread-local pointer installed.\n+    #[inline(never)] // see comments above\n     pub fn exists() -> bool {\n         unsafe {\n             RT_TLS_PTR.is_not_null()\n         }\n     }\n \n+    #[inline(never)] // see comments above\n     pub unsafe fn unsafe_borrow<T>() -> *mut T {\n         if RT_TLS_PTR.is_null() {\n             rtabort!(\"thread-local pointer is null. bogus!\");\n         }\n         RT_TLS_PTR as *mut T\n     }\n \n+    #[inline(never)] // see comments above\n     pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {\n         if RT_TLS_PTR.is_null() {\n             None"}]}