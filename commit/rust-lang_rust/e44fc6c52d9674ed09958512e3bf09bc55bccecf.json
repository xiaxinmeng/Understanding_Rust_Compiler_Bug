{"sha": "e44fc6c52d9674ed09958512e3bf09bc55bccecf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NGZjNmM1MmQ5Njc0ZWQwOTk1ODUxMmUzYmYwOWJjNTViY2NlY2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-15T23:03:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-15T23:03:04Z"}, "message": "Auto merge of #48523 - varkor:generics-ty-generalisations, r=nikomatsakis\n\nThe Great Generics Generalisation: Ty Edition\n\nPart of the generic parameter refactoring effort, split off from https://github.com/rust-lang/rust/pull/48149. Contains the `ty`-relative refactoring.\n\nr? @eddyb", "tree": {"sha": "a1b658a3c3b7f6748baf794ddb7c1ab6b35c4714", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1b658a3c3b7f6748baf794ddb7c1ab6b35c4714"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e44fc6c52d9674ed09958512e3bf09bc55bccecf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e44fc6c52d9674ed09958512e3bf09bc55bccecf", "html_url": "https://github.com/rust-lang/rust/commit/e44fc6c52d9674ed09958512e3bf09bc55bccecf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e44fc6c52d9674ed09958512e3bf09bc55bccecf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0fdaba04ea7474cd1f66264ef4edb3485a95864", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0fdaba04ea7474cd1f66264ef4edb3485a95864", "html_url": "https://github.com/rust-lang/rust/commit/f0fdaba04ea7474cd1f66264ef4edb3485a95864"}, {"sha": "5be2bdb498249d71a4a5671f73224727784a1203", "url": "https://api.github.com/repos/rust-lang/rust/commits/5be2bdb498249d71a4a5671f73224727784a1203", "html_url": "https://github.com/rust-lang/rust/commit/5be2bdb498249d71a4a5671f73224727784a1203"}], "stats": {"total": 1772, "additions": 966, "deletions": 806}, "files": [{"sha": "be9c5d2d334ae442d6bb78f8913316ef63f924bb", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -1459,10 +1459,9 @@ impl<'a> LoweringContext<'a> {\n                             return n;\n                         }\n                         assert!(!def_id.is_local());\n-                        let n = self.cstore\n-                            .item_generics_cloned_untracked(def_id, self.sess)\n-                            .regions\n-                            .len();\n+                        let item_generics =\n+                            self.cstore.item_generics_cloned_untracked(def_id, self.sess);\n+                        let n = item_generics.own_counts().lifetimes;\n                         self.type_def_lifetime_params.insert(def_id, n);\n                         n\n                     });"}, {"sha": "31dce2a14c2b783869720488634fb89ed4a7ac5a", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -735,54 +735,40 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::Generics {\n                                           hasher: &mut StableHasher<W>) {\n         let ty::Generics {\n             parent,\n-            parent_regions,\n-            parent_types,\n-            ref regions,\n-            ref types,\n+            ref parent_count,\n+            ref params,\n \n-            // Reverse map to each `TypeParameterDef`'s `index` field, from\n+            // Reverse map to each `TypeParamDef`'s `index` field, from\n             // `def_id.index` (`def_id.krate` is the same as the item's).\n-            type_param_to_index: _, // Don't hash this\n+            param_def_id_to_index: _, // Don't hash this\n             has_self,\n             has_late_bound_regions,\n         } = *self;\n \n         parent.hash_stable(hcx, hasher);\n-        parent_regions.hash_stable(hcx, hasher);\n-        parent_types.hash_stable(hcx, hasher);\n-        regions.hash_stable(hcx, hasher);\n-        types.hash_stable(hcx, hasher);\n+        parent_count.hash_stable(hcx, hasher);\n+        params.hash_stable(hcx, hasher);\n         has_self.hash_stable(hcx, hasher);\n         has_late_bound_regions.hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for ty::RegionParameterDef {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::RegionParameterDef {\n-            name,\n-            def_id,\n-            index,\n-            pure_wrt_drop\n-        } = *self;\n-\n-        name.hash_stable(hcx, hasher);\n-        def_id.hash_stable(hcx, hasher);\n-        index.hash_stable(hcx, hasher);\n-        pure_wrt_drop.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(enum ty::GenericParamDefKind {\n+    Lifetime,\n+    Type(ty)\n+});\n \n-impl_stable_hash_for!(struct ty::TypeParameterDef {\n+impl_stable_hash_for!(struct ty::GenericParamDef {\n     name,\n     def_id,\n     index,\n+    pure_wrt_drop,\n+    kind\n+});\n+\n+impl_stable_hash_for!(struct ty::TypeParamDef {\n     has_default,\n     object_lifetime_default,\n-    pure_wrt_drop,\n     synthetic\n });\n "}, {"sha": "d681e2e3d34b9b735c634a70c2c420749ff5dbc6", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -14,7 +14,7 @@ use infer::outlives::free_region_map::FreeRegionRelations;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast;\n use traits::{self, PredicateObligation};\n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, Ty, TyCtxt, GenericParamDefKind};\n use ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n use ty::outlives::Component;\n use ty::subst::{Kind, Substs, UnpackedKind};\n@@ -313,12 +313,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // `['a]` for the first impl trait and `'b` for the\n         // second.\n         let mut least_region = None;\n-        for region_def in &abstract_type_generics.regions {\n-            // Find the index of this region in the list of substitutions.\n-            let index = region_def.index as usize;\n-\n+        for param in &abstract_type_generics.params {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {}\n+                _ => continue\n+            }\n             // Get the value supplied for this region from the substs.\n-            let subst_arg = anon_defn.substs.region_at(index);\n+            let subst_arg = anon_defn.substs.region_at(param.index as usize);\n \n             // Compute the least upper bound of it with the other regions.\n             debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n@@ -616,10 +617,9 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx>\n                 // during trans.\n \n                 let generics = self.tcx.generics_of(def_id);\n-                let parent_len = generics.parent_count();\n                 let substs = self.tcx.mk_substs(substs.substs.iter().enumerate().map(\n                     |(index, &kind)| {\n-                        if index < parent_len {\n+                        if index < generics.parent_count {\n                             // Accommodate missing regions in the parent kinds...\n                             self.fold_kind_mapping_missing_regions_to_empty(kind)\n                         } else {"}, {"sha": "1cc65dcfd1027003ae9258d07fe993d21e0c32e8", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -21,9 +21,9 @@ use hir::def_id::DefId;\n use middle::free_region::RegionRelations;\n use middle::region;\n use middle::lang_items;\n-use ty::subst::Substs;\n+use ty::subst::{Kind, Substs};\n use ty::{TyVid, IntVid, FloatVid};\n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, Ty, TyCtxt, GenericParamDefKind};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::TypeFoldable;\n use ty::relate::RelateResult;\n@@ -905,34 +905,35 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.next_region_var(RegionVariableOrigin::NLL(origin))\n     }\n \n-    /// Create a region inference variable for the given\n-    /// region parameter definition.\n-    pub fn region_var_for_def(&self,\n-                              span: Span,\n-                              def: &ty::RegionParameterDef)\n-                              -> ty::Region<'tcx> {\n-        self.next_region_var(EarlyBoundRegion(span, def.name))\n-    }\n-\n-    /// Create a type inference variable for the given\n-    /// type parameter definition. The substitutions are\n-    /// for actual parameters that may be referred to by\n-    /// the default of this type parameter, if it exists.\n-    /// E.g. `struct Foo<A, B, C = (A, B)>(...);` when\n-    /// used in a path such as `Foo::<T, U>::new()` will\n-    /// use an inference variable for `C` with `[T, U]`\n-    /// as the substitutions for the default, `(T, U)`.\n-    pub fn type_var_for_def(&self,\n-                            span: Span,\n-                            def: &ty::TypeParameterDef)\n-                            -> Ty<'tcx> {\n-        let ty_var_id = self.type_variables\n-                            .borrow_mut()\n-                            .new_var(self.universe(),\n-                                     false,\n-                                     TypeVariableOrigin::TypeParameterDefinition(span, def.name));\n-\n-        self.tcx.mk_var(ty_var_id)\n+    pub fn var_for_def(&self,\n+                       span: Span,\n+                       param: &ty::GenericParamDef)\n+                       -> Kind<'tcx> {\n+        match param.kind {\n+            GenericParamDefKind::Lifetime => {\n+                // Create a region inference variable for the given\n+                // region parameter definition.\n+                self.next_region_var(EarlyBoundRegion(span, param.name)).into()\n+            }\n+            GenericParamDefKind::Type(_) => {\n+                // Create a type inference variable for the given\n+                // type parameter definition. The substitutions are\n+                // for actual parameters that may be referred to by\n+                // the default of this type parameter, if it exists.\n+                // E.g. `struct Foo<A, B, C = (A, B)>(...);` when\n+                // used in a path such as `Foo::<T, U>::new()` will\n+                // use an inference variable for `C` with `[T, U]`\n+                // as the substitutions for the default, `(T, U)`.\n+                let ty_var_id =\n+                    self.type_variables\n+                        .borrow_mut()\n+                        .new_var(self.universe(),\n+                                    false,\n+                                    TypeVariableOrigin::TypeParameterDefinition(span, param.name));\n+\n+                self.tcx.mk_var(ty_var_id).into()\n+            }\n+        }\n     }\n \n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n@@ -941,10 +942,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                  span: Span,\n                                  def_id: DefId)\n                                  -> &'tcx Substs<'tcx> {\n-        Substs::for_item(self.tcx, def_id, |def, _| {\n-            self.region_var_for_def(span, def)\n-        }, |def, _| {\n-            self.type_var_for_def(span, def)\n+        Substs::for_item(self.tcx, def_id, |param, _| {\n+            self.var_for_def(span, param)\n         })\n     }\n "}, {"sha": "26ac9d6ee9ea6798f8cd99d63c62250f018ec84a", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -49,6 +49,7 @@\n #![cfg_attr(stage0, feature(dyn_trait))]\n #![feature(from_ref)]\n #![feature(fs_read_write)]\n+#![feature(iterator_find_map)]\n #![cfg_attr(windows, feature(libc))]\n #![cfg_attr(stage0, feature(macro_lifetime_matcher))]\n #![feature(macro_vis_matcher)]"}, {"sha": "900fbdfdeadb3c58af9193f68128f55125d475d6", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -20,7 +20,7 @@ use hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use hir::map::Map;\n use hir::ItemLocalId;\n use hir::LifetimeName;\n-use ty::{self, TyCtxt};\n+use ty::{self, TyCtxt, GenericParamDefKind};\n \n use errors::DiagnosticBuilder;\n use rustc::lint;\n@@ -667,8 +667,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 for lt_def in generics.lifetimes() {\n                     let (lt_name, region) = Region::early(&self.tcx.hir, &mut index, &lt_def);\n                     if let hir::LifetimeName::Underscore = lt_name {\n-                        // Pick the elided lifetime \"definition\" if one exists and use it to make an\n-                        // elision scope.\n+                        // Pick the elided lifetime \"definition\" if one exists and use it to make\n+                        // an elision scope.\n                         elision = Some(region);\n                     } else {\n                         lifetimes.insert(lt_name, region);\n@@ -1659,9 +1659,16 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     .entry(def_id)\n                     .or_insert_with(|| {\n                         tcx.generics_of(def_id)\n-                            .types\n+                            .params\n                             .iter()\n-                            .map(|def| def.object_lifetime_default)\n+                            .filter_map(|param| {\n+                                match param.kind {\n+                                    GenericParamDefKind::Type(ty) => {\n+                                        Some(ty.object_lifetime_default)\n+                                    }\n+                                    GenericParamDefKind::Lifetime => None,\n+                                }\n+                            })\n                             .collect()\n                     })\n             };"}, {"sha": "227cba40d146388a016431509201bd3a522f3c94", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -222,9 +222,14 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             });\n \n             let names_map: FxHashSet<String> = generics\n-                .regions\n+                .params\n                 .iter()\n-                .map(|l| l.name.to_string())\n+                .filter_map(|param| {\n+                    match param.kind {\n+                        ty::GenericParamDefKind::Lifetime => Some(param.name.to_string()),\n+                        _ => None\n+                    }\n+                })\n                 .collect();\n \n             let body_ids: FxHashSet<_> = infcx"}, {"sha": "3e7f3af0358535c93abfee6a180a8f589b211580", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -36,6 +36,7 @@ use std::fmt;\n use syntax::ast;\n use session::DiagnosticMessageId;\n use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use ty::GenericParamDefKind;\n use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n@@ -378,12 +379,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             flags.push((\"_Self\".to_string(), Some(self.tcx.type_of(def.did).to_string())));\n         }\n \n-        for param in generics.types.iter() {\n+        for param in generics.params.iter() {\n+            let value = match param.kind {\n+                GenericParamDefKind::Type(_) => {\n+                    trait_ref.substs[param.index as usize].to_string()\n+                },\n+                GenericParamDefKind::Lifetime => continue,\n+            };\n             let name = param.name.to_string();\n-            let ty = trait_ref.substs.type_for_def(param);\n-            let ty_str = ty.to_string();\n-            flags.push((name.clone(),\n-                        Some(ty_str.clone())));\n+            flags.push((name, Some(value)));\n         }\n \n         if let Some(true) = self_ty.ty_to_def_id().map(|def_id| def_id.is_local()) {"}, {"sha": "154c6815bb666174d3d7e67dcda7c939c3b5bf35", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -23,7 +23,7 @@ use infer::outlives::env::OutlivesEnvironment;\n use middle::region;\n use middle::const_val::ConstEvalErr;\n use ty::subst::Substs;\n-use ty::{self, AdtKind, Slice, Ty, TyCtxt, TypeFoldable, ToPredicate};\n+use ty::{self, AdtKind, Slice, Ty, TyCtxt, GenericParamDefKind, TypeFoldable, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};\n use infer::{InferCtxt};\n \n@@ -841,10 +841,14 @@ fn vtable_methods<'a, 'tcx>(\n                 // the method may have some early-bound lifetimes, add\n                 // regions for those\n                 let substs = trait_ref.map_bound(|trait_ref| {\n-                    Substs::for_item(\n-                        tcx, def_id,\n-                        |_, _| tcx.types.re_erased,\n-                        |def, _| trait_ref.substs.type_for_def(def))\n+                    Substs::for_item(tcx, def_id, |param, _| {\n+                        match param.kind {\n+                            GenericParamDefKind::Lifetime => tcx.types.re_erased.into(),\n+                            GenericParamDefKind::Type(_) => {\n+                                trait_ref.substs[param.index as usize]\n+                            }\n+                        }\n+                    })\n                 });\n \n                 // the trait type may have higher-ranked lifetimes in it;"}, {"sha": "6c67c10dc69cf490dd3120bb064e5cc90ea5def4", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -284,7 +284,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // We can't monomorphize things like `fn foo<A>(...)`.\n-        if !self.generics_of(method.def_id).types.is_empty() {\n+        if self.generics_of(method.def_id).own_counts().types != 0 {\n             return Some(MethodViolationCode::Generic);\n         }\n \n@@ -387,7 +387,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n pub(super) fn is_object_safe_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                         trait_def_id: DefId)\n-                                         -> bool {\n+                                                trait_def_id: DefId) -> bool {\n     tcx.object_safety_violations(trait_def_id).is_empty()\n }"}, {"sha": "539f40cf3efb5a061440bfc4c419a0837bffd5ab", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -11,7 +11,7 @@\n use fmt_macros::{Parser, Piece, Position};\n \n use hir::def_id::DefId;\n-use ty::{self, TyCtxt};\n+use ty::{self, TyCtxt, GenericParamDefKind};\n use util::common::ErrorReported;\n use util::nodemap::FxHashMap;\n \n@@ -243,7 +243,6 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         let name = tcx.item_name(trait_def_id);\n         let generics = tcx.generics_of(trait_def_id);\n         let parser = Parser::new(&self.0);\n-        let types = &generics.types;\n         let mut result = Ok(());\n         for token in parser {\n             match token {\n@@ -254,13 +253,13 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                     // `{ThisTraitsName}` is allowed\n                     Position::ArgumentNamed(s) if s == name => (),\n                     // So is `{A}` if A is a type parameter\n-                    Position::ArgumentNamed(s) => match types.iter().find(|t| {\n-                        t.name == s\n+                    Position::ArgumentNamed(s) => match generics.params.iter().find(|param| {\n+                        param.name == s\n                     }) {\n                         Some(_) => (),\n                         None => {\n                             span_err!(tcx.sess, span, E0230,\n-                                      \"there is no type parameter \\\n+                                      \"there is no parameter \\\n                                        {} on trait {}\",\n                                       s, name);\n                             result = Err(ErrorReported);\n@@ -288,9 +287,15 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         let name = tcx.item_name(trait_ref.def_id);\n         let trait_str = tcx.item_path_str(trait_ref.def_id);\n         let generics = tcx.generics_of(trait_ref.def_id);\n-        let generic_map = generics.types.iter().map(|param| {\n-            (param.name.to_string(),\n-             trait_ref.substs.type_for_def(param).to_string())\n+        let generic_map = generics.params.iter().filter_map(|param| {\n+            let value = match param.kind {\n+                GenericParamDefKind::Type(_) => {\n+                    trait_ref.substs[param.index as usize].to_string()\n+                },\n+                GenericParamDefKind::Lifetime => return None\n+            };\n+            let name = param.name.to_string();\n+            Some((name, value))\n         }).collect::<FxHashMap<String, String>>();\n \n         let parser = Parser::new(&self.0);"}, {"sha": "f5a9d2a7f00145f5d510f358a8a1d7ceda1de3eb", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -213,7 +213,7 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                            },\n \n                            Component::Param(p) => {\n-                               let ty = tcx.mk_param(p.idx, p.name);\n+                               let ty = tcx.mk_ty_param(p.idx, p.name);\n                                Some(ty::Predicate::TypeOutlives(\n                                    ty::Binder::dummy(ty::OutlivesPredicate(ty, r_min))))\n                            },"}, {"sha": "3c345fcd9ee61f15cb01f60abf90ee23cef87cf2", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -44,6 +44,7 @@ use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predic\n use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n+use ty::GenericParamDefKind;\n use ty::layout::{LayoutDetails, TargetDataLayout};\n use ty::maps;\n use ty::steal::Steal;\n@@ -2325,15 +2326,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let def_id = self.require_lang_item(lang_items::OwnedBoxLangItem);\n         let adt_def = self.adt_def(def_id);\n-        let generics = self.generics_of(def_id);\n-        let mut substs = vec![Kind::from(ty)];\n-        // Add defaults for other generic params if there are some.\n-        for def in generics.types.iter().skip(1) {\n-            assert!(def.has_default);\n-            let ty = self.type_of(def.def_id).subst(self, &substs);\n-            substs.push(ty.into());\n-        }\n-        let substs = self.mk_substs(substs.into_iter());\n+        let substs = Substs::for_item(self, def_id, |param, substs| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => bug!(),\n+                GenericParamDefKind::Type(ty_param) => {\n+                    if param.index == 0 {\n+                        ty.into()\n+                    } else {\n+                        assert!(ty_param.has_default);\n+                        self.type_of(param.def_id).subst(self, substs).into()\n+                    }\n+                }\n+            }\n+        });\n         self.mk_ty(TyAdt(adt_def, substs))\n     }\n \n@@ -2457,18 +2462,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyInfer(it))\n     }\n \n-    pub fn mk_param(self,\n+    pub fn mk_ty_param(self,\n                     index: u32,\n                     name: InternedString) -> Ty<'tcx> {\n         self.mk_ty(TyParam(ParamTy { idx: index, name: name }))\n     }\n \n     pub fn mk_self_type(self) -> Ty<'tcx> {\n-        self.mk_param(0, keywords::SelfType.name().as_interned_str())\n+        self.mk_ty_param(0, keywords::SelfType.name().as_interned_str())\n     }\n \n-    pub fn mk_param_from_def(self, def: &ty::TypeParameterDef) -> Ty<'tcx> {\n-        self.mk_param(def.index, def.name)\n+    pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> Kind<'tcx> {\n+        match param.kind {\n+            GenericParamDefKind::Lifetime => {\n+                self.mk_region(ty::ReEarlyBound(param.to_early_bound_region_data())).into()\n+            }\n+            GenericParamDefKind::Type(_) => self.mk_ty_param(param.index, param.name).into(),\n+        }\n     }\n \n     pub fn mk_anon(self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {"}, {"sha": "ad48519e136c8eae12f77fc758adcbd38f49a31a", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -543,7 +543,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::named_region_map<'tcx> {\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_late_bound_map<'tcx> {\n     fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n-        format!(\"testing if a region is late boudn\")\n+        format!(\"testing if a region is late bound\")\n     }\n }\n "}, {"sha": "6861683ed1298160aa5f6eb2b8bf3e0e72bf18ec", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 90, "deletions": 86, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -709,148 +709,152 @@ pub enum IntVarValue {\n #[derive(Clone, Copy, PartialEq, Eq)]\n pub struct FloatVarValue(pub ast::FloatTy);\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub struct TypeParameterDef {\n-    pub name: InternedString,\n-    pub def_id: DefId,\n-    pub index: u32,\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct TypeParamDef {\n     pub has_default: bool,\n     pub object_lifetime_default: ObjectLifetimeDefault,\n+    pub synthetic: Option<hir::SyntheticTyParamKind>,\n+}\n \n-    /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n-    /// on generic parameter `T`, asserts data behind the parameter\n-    /// `T` won't be accessed during the parent type's `Drop` impl.\n-    pub pure_wrt_drop: bool,\n+impl ty::EarlyBoundRegion {\n+    pub fn to_bound_region(&self) -> ty::BoundRegion {\n+        ty::BoundRegion::BrNamed(self.def_id, self.name)\n+    }\n+}\n \n-    pub synthetic: Option<hir::SyntheticTyParamKind>,\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum GenericParamDefKind {\n+    Lifetime,\n+    Type(TypeParamDef),\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub struct RegionParameterDef {\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n+pub struct GenericParamDef {\n     pub name: InternedString,\n     pub def_id: DefId,\n     pub index: u32,\n \n     /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n-    /// on generic parameter `'a`, asserts data of lifetime `'a`\n-    /// won't be accessed during the parent type's `Drop` impl.\n+    /// on generic parameter `'a`/`T`, asserts data behind the parameter\n+    /// `'a`/`T` won't be accessed during the parent type's `Drop` impl.\n     pub pure_wrt_drop: bool,\n+\n+    pub kind: GenericParamDefKind,\n }\n \n-impl RegionParameterDef {\n+impl GenericParamDef {\n     pub fn to_early_bound_region_data(&self) -> ty::EarlyBoundRegion {\n-        ty::EarlyBoundRegion {\n-            def_id: self.def_id,\n-            index: self.index,\n-            name: self.name,\n+        match self.kind {\n+            GenericParamDefKind::Lifetime => {\n+                ty::EarlyBoundRegion {\n+                    def_id: self.def_id,\n+                    index: self.index,\n+                    name: self.name,\n+                }\n+            }\n+            _ => bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n         }\n     }\n \n     pub fn to_bound_region(&self) -> ty::BoundRegion {\n-        self.to_early_bound_region_data().to_bound_region()\n+        match self.kind {\n+            GenericParamDefKind::Lifetime => {\n+                self.to_early_bound_region_data().to_bound_region()\n+            }\n+            _ => bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n+        }\n     }\n }\n \n-impl ty::EarlyBoundRegion {\n-    pub fn to_bound_region(&self) -> ty::BoundRegion {\n-        ty::BoundRegion::BrNamed(self.def_id, self.name)\n-    }\n+pub struct GenericParamCount {\n+    pub lifetimes: usize,\n+    pub types: usize,\n }\n \n /// Information about the formal type/lifetime parameters associated\n /// with an item or method. Analogous to hir::Generics.\n ///\n-/// Note that in the presence of a `Self` parameter, the ordering here\n-/// is different from the ordering in a Substs. Substs are ordered as\n-///     Self, *Regions, *Other Type Params, (...child generics)\n-/// while this struct is ordered as\n-///     regions = Regions\n-///     types = [Self, *Other Type Params]\n+/// The ordering of parameters is the same as in Subst (excluding child generics):\n+/// Self (optionally), Lifetime params..., Type params...\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Generics {\n     pub parent: Option<DefId>,\n-    pub parent_regions: u32,\n-    pub parent_types: u32,\n-    pub regions: Vec<RegionParameterDef>,\n-    pub types: Vec<TypeParameterDef>,\n+    pub parent_count: usize,\n+    pub params: Vec<GenericParamDef>,\n \n-    /// Reverse map to each `TypeParameterDef`'s `index` field\n-    pub type_param_to_index: FxHashMap<DefId, u32>,\n+    /// Reverse map to the `index` field of each `GenericParamDef`\n+    pub param_def_id_to_index: FxHashMap<DefId, u32>,\n \n     pub has_self: bool,\n     pub has_late_bound_regions: Option<Span>,\n }\n \n impl<'a, 'gcx, 'tcx> Generics {\n-    pub fn parent_count(&self) -> usize {\n-        self.parent_regions as usize + self.parent_types as usize\n+    pub fn count(&self) -> usize {\n+        self.parent_count + self.params.len()\n     }\n \n-    pub fn own_count(&self) -> usize {\n-        self.regions.len() + self.types.len()\n+    pub fn own_counts(&self) -> GenericParamCount {\n+        // We could cache this as a property of `GenericParamCount`, but\n+        // the aim is to refactor this away entirely eventually and the\n+        // presence of this method will be a constant reminder.\n+        let mut own_counts = GenericParamCount {\n+            lifetimes: 0,\n+            types: 0,\n+        };\n+\n+        for param in &self.params {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => own_counts.lifetimes += 1,\n+                GenericParamDefKind::Type(_) => own_counts.types += 1,\n+            };\n+        }\n+\n+        own_counts\n     }\n \n-    pub fn count(&self) -> usize {\n-        self.parent_count() + self.own_count()\n+    pub fn requires_monomorphization(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+        for param in &self.params {\n+            match param.kind {\n+                GenericParamDefKind::Type(_) => return true,\n+                GenericParamDefKind::Lifetime => {}\n+            }\n+        }\n+        if let Some(parent_def_id) = self.parent {\n+            let parent = tcx.generics_of(parent_def_id);\n+            parent.requires_monomorphization(tcx)\n+        } else {\n+            false\n+        }\n     }\n \n     pub fn region_param(&'tcx self,\n                         param: &EarlyBoundRegion,\n                         tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                        -> &'tcx RegionParameterDef\n+                        -> &'tcx GenericParamDef\n     {\n-        if let Some(index) = param.index.checked_sub(self.parent_count() as u32) {\n-            &self.regions[index as usize - self.has_self as usize]\n+        if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n+            let param = &self.params[index as usize];\n+            match param.kind {\n+                ty::GenericParamDefKind::Lifetime => param,\n+                _ => bug!(\"expected lifetime parameter, but found another generic parameter\")\n+            }\n         } else {\n             tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n                 .region_param(param, tcx)\n         }\n     }\n \n-    /// Returns the `TypeParameterDef` associated with this `ParamTy`.\n+    /// Returns the `TypeParamDef` associated with this `ParamTy`.\n     pub fn type_param(&'tcx self,\n                       param: &ParamTy,\n                       tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                      -> &TypeParameterDef {\n-        if let Some(idx) = param.idx.checked_sub(self.parent_count() as u32) {\n-            // non-Self type parameters are always offset by exactly\n-            // `self.regions.len()`. In the absence of a Self, this is obvious,\n-            // but even in the presence of a `Self` we just have to \"compensate\"\n-            // for the regions:\n-            //\n-            // Without a `Self` (or in a nested generics that doesn't have\n-            // a `Self` in itself, even through it parent does), for example\n-            // for `fn foo<'a, T1, T2>()`, the situation is:\n-            //     Substs:\n-            //         0  1  2\n-            //         'a T1 T2\n-            //     generics.types:\n-            //         0  1\n-            //         T1 T2\n-            //\n-            // And with a `Self`, for example for `trait Foo<'a, 'b, T1, T2>`, the\n-            // situation is:\n-            //     Substs:\n-            //         0   1  2  3  4\n-            //       Self 'a 'b  T1 T2\n-            //     generics.types:\n-            //         0  1  2\n-            //       Self T1 T2\n-            //\n-            // And it can be seen that in both cases, to move from a substs\n-            // offset to a generics offset you just have to offset by the\n-            // number of regions.\n-            let type_param_offset = self.regions.len();\n-\n-            let has_self = self.has_self && self.parent.is_none();\n-            let is_separated_self = type_param_offset != 0 && idx == 0 && has_self;\n-\n-            if let Some(idx) = (idx as usize).checked_sub(type_param_offset) {\n-                assert!(!is_separated_self, \"found a Self after type_param_offset\");\n-                &self.types[idx]\n-            } else {\n-                assert!(is_separated_self, \"non-Self param before type_param_offset\");\n-                &self.types[0]\n+                      -> &'tcx GenericParamDef {\n+        if let Some(index) = param.idx.checked_sub(self.parent_count as u32) {\n+            let param = &self.params[index as usize];\n+            match param.kind {\n+                ty::GenericParamDefKind::Type(_) => param,\n+                _ => bug!(\"expected type parameter, but found another generic parameter\")\n             }\n         } else {\n             tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))"}, {"sha": "acc225ddf568031fc4dec07df802afb8e154da74", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -292,7 +292,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// ordering.\n     fn split(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> SplitClosureSubsts<'tcx> {\n         let generics = tcx.generics_of(def_id);\n-        let parent_len = generics.parent_count();\n+        let parent_len = generics.parent_count;\n         SplitClosureSubsts {\n             closure_kind_ty: self.substs.type_at(parent_len),\n             closure_sig_ty: self.substs.type_at(parent_len + 1),\n@@ -366,7 +366,7 @@ struct SplitGeneratorSubsts<'tcx> {\n impl<'tcx> GeneratorSubsts<'tcx> {\n     fn split(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> SplitGeneratorSubsts<'tcx> {\n         let generics = tcx.generics_of(def_id);\n-        let parent_len = generics.parent_count();\n+        let parent_len = generics.parent_count;\n         SplitGeneratorSubsts {\n             yield_ty: self.substs.type_at(parent_len),\n             return_ty: self.substs.type_at(parent_len + 1),\n@@ -928,12 +928,12 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n         ParamTy::new(0, keywords::SelfType.name().as_interned_str())\n     }\n \n-    pub fn for_def(def: &ty::TypeParameterDef) -> ParamTy {\n+    pub fn for_def(def: &ty::GenericParamDef) -> ParamTy {\n         ParamTy::new(def.index, def.name)\n     }\n \n     pub fn to_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        tcx.mk_param(self.idx, self.name)\n+        tcx.mk_ty_param(self.idx, self.name)\n     }\n \n     pub fn is_self(&self) -> bool {"}, {"sha": "b94b3e17f862fb29f2edcc4aad42c4e7ddbe4c19", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 38, "deletions": 63, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -174,92 +174,72 @@ impl<'tcx> Decodable for Kind<'tcx> {\n     }\n }\n \n-/// A substitution mapping type/region parameters to new values.\n+/// A substitution mapping generic parameters to new values.\n pub type Substs<'tcx> = Slice<Kind<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     /// Creates a Substs that maps each generic parameter to itself.\n     pub fn identity_for_item(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId)\n                              -> &'tcx Substs<'tcx> {\n-        Substs::for_item(tcx, def_id, |def, _| {\n-            tcx.mk_region(ty::ReEarlyBound(def.to_early_bound_region_data()))\n-        }, |def, _| tcx.mk_param_from_def(def))\n+        Substs::for_item(tcx, def_id, |param, _| {\n+            tcx.mk_param_from_def(param)\n+        })\n     }\n \n     /// Creates a Substs for generic parameter definitions,\n-    /// by calling closures to obtain each region and type.\n+    /// by calling closures to obtain each kind.\n     /// The closures get to observe the Substs as they're\n     /// being built, which can be used to correctly\n-    /// substitute defaults of type parameters.\n-    pub fn for_item<FR, FT>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                            def_id: DefId,\n-                            mut mk_region: FR,\n-                            mut mk_type: FT)\n-                            -> &'tcx Substs<'tcx>\n-    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n-          FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n+    /// substitute defaults of generic parameters.\n+    pub fn for_item<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                       def_id: DefId,\n+                       mut mk_kind: F)\n+                       -> &'tcx Substs<'tcx>\n+    where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n+    {\n         let defs = tcx.generics_of(def_id);\n         let mut substs = Vec::with_capacity(defs.count());\n-        Substs::fill_item(&mut substs, tcx, defs, &mut mk_region, &mut mk_type);\n+        Substs::fill_item(&mut substs, tcx, defs, &mut mk_kind);\n         tcx.intern_substs(&substs)\n     }\n \n-    pub fn extend_to<FR, FT>(&self,\n-                             tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                             def_id: DefId,\n-                             mut mk_region: FR,\n-                             mut mk_type: FT)\n-                             -> &'tcx Substs<'tcx>\n-    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n-          FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx>\n+    pub fn extend_to<F>(&self,\n+                        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                        def_id: DefId,\n+                        mut mk_kind: F)\n+                        -> &'tcx Substs<'tcx>\n+    where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n     {\n         let defs = tcx.generics_of(def_id);\n         let mut result = Vec::with_capacity(defs.count());\n         result.extend(self[..].iter().cloned());\n-        Substs::fill_single(&mut result, defs, &mut mk_region, &mut mk_type);\n+        Substs::fill_single(&mut result, defs, &mut mk_kind);\n         tcx.intern_substs(&result)\n     }\n \n-    pub fn fill_item<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n+    pub fn fill_item<F>(substs: &mut Vec<Kind<'tcx>>,\n                              tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                              defs: &ty::Generics,\n-                             mk_region: &mut FR,\n-                             mk_type: &mut FT)\n-    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n-          FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n+                             mk_kind: &mut F)\n+    where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n+    {\n \n         if let Some(def_id) = defs.parent {\n             let parent_defs = tcx.generics_of(def_id);\n-            Substs::fill_item(substs, tcx, parent_defs, mk_region, mk_type);\n+            Substs::fill_item(substs, tcx, parent_defs, mk_kind);\n         }\n-        Substs::fill_single(substs, defs, mk_region, mk_type)\n+        Substs::fill_single(substs, defs, mk_kind)\n     }\n \n-    fn fill_single<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n+    fn fill_single<F>(substs: &mut Vec<Kind<'tcx>>,\n                            defs: &ty::Generics,\n-                           mk_region: &mut FR,\n-                           mk_type: &mut FT)\n-    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n-          FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n-        // Handle Self first, before all regions.\n-        let mut types = defs.types.iter();\n-        if defs.parent.is_none() && defs.has_self {\n-            let def = types.next().unwrap();\n-            let ty = mk_type(def, substs);\n-            assert_eq!(def.index as usize, substs.len());\n-            substs.push(ty.into());\n-        }\n-\n-        for def in &defs.regions {\n-            let region = mk_region(def, substs);\n-            assert_eq!(def.index as usize, substs.len());\n-            substs.push(Kind::from(region));\n-        }\n-\n-        for def in types {\n-            let ty = mk_type(def, substs);\n-            assert_eq!(def.index as usize, substs.len());\n-            substs.push(Kind::from(ty));\n+                           mk_kind: &mut F)\n+    where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n+    {\n+        for param in &defs.params {\n+            let kind = mk_kind(param, substs);\n+            assert_eq!(param.index as usize, substs.len());\n+            substs.push(kind);\n         }\n     }\n \n@@ -308,13 +288,8 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn type_for_def(&self, ty_param_def: &ty::TypeParameterDef) -> Ty<'tcx> {\n-        self.type_at(ty_param_def.index as usize)\n-    }\n-\n-    #[inline]\n-    pub fn region_for_def(&self, def: &ty::RegionParameterDef) -> ty::Region<'tcx> {\n-        self.region_at(def.index as usize)\n+    pub fn type_for_def(&self, def: &ty::GenericParamDef) -> Kind<'tcx> {\n+        self.type_at(def.index as usize).into()\n     }\n \n     /// Transform from substitutions for a child of `source_ancestor`\n@@ -327,7 +302,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                        target_substs: &Substs<'tcx>)\n                        -> &'tcx Substs<'tcx> {\n         let defs = tcx.generics_of(source_ancestor);\n-        tcx.mk_substs(target_substs.iter().chain(&self[defs.own_count()..]).cloned())\n+        tcx.mk_substs(target_substs.iter().chain(&self[defs.params.len()..]).cloned())\n     }\n \n     pub fn truncate_to(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, generics: &ty::Generics)\n@@ -580,7 +555,7 @@ impl<'a, 'gcx, 'tcx> ty::TraitRef<'tcx> {\n \n         ty::TraitRef {\n             def_id: trait_id,\n-            substs: tcx.intern_substs(&substs[..defs.own_count()])\n+            substs: tcx.intern_substs(&substs[..defs.params.len()])\n         }\n     }\n }"}, {"sha": "d5532f8f8355a3167ea79d8c40cb5db9a6f37255", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -17,9 +17,9 @@ use hir;\n use ich::NodeIdHashingMode;\n use middle::const_val::ConstVal;\n use traits::{self, ObligationCause};\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, GenericParamDefKind, TypeFoldable};\n use ty::fold::TypeVisitor;\n-use ty::subst::UnpackedKind;\n+use ty::subst::{Substs, UnpackedKind};\n use ty::maps::TyCtxtAt;\n use ty::TypeVariants::*;\n use ty::layout::{Integer, IntegerExt};\n@@ -573,11 +573,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Given the def-id of some item that has no type parameters, make\n     /// a suitable \"empty substs\" for it.\n-    pub fn empty_substs_for_def_id(self, item_def_id: DefId) -> &'tcx ty::Substs<'tcx> {\n-        ty::Substs::for_item(self, item_def_id,\n-                             |_, _| self.types.re_erased,\n-                             |_, _| {\n-            bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n+    pub fn empty_substs_for_def_id(self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n+        Substs::for_item(self, item_def_id, |param, _| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => self.types.re_erased.into(),\n+                GenericParamDefKind::Type(_) => {\n+                    bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n+                }\n+            }\n         })\n     }\n "}, {"sha": "eaae874635f62772a1795aa4571a60445b62abad", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -19,7 +19,7 @@ use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n use ty::{TyClosure, TyGenerator, TyGeneratorWitness, TyForeign, TyProjection, TyAnon};\n use ty::{TyDynamic, TyInt, TyUint, TyInfer};\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind};\n use util::nodemap::FxHashSet;\n \n use std::cell::Cell;\n@@ -256,8 +256,10 @@ impl PrintContext {\n         let verbose = self.is_verbose;\n         let mut num_supplied_defaults = 0;\n         let mut has_self = false;\n-        let mut num_regions = 0;\n-        let mut num_types = 0;\n+        let mut own_counts = GenericParamCount {\n+            lifetimes: 0,\n+            types: 0,\n+        };\n         let mut is_value_path = false;\n         let fn_trait_kind = ty::tls::with(|tcx| {\n             // Unfortunately, some kinds of items (e.g., closures) don't have\n@@ -303,17 +305,17 @@ impl PrintContext {\n                 }\n             }\n             let mut generics = tcx.generics_of(item_def_id);\n+            let child_own_counts = generics.own_counts();\n             let mut path_def_id = did;\n             has_self = generics.has_self;\n \n             let mut child_types = 0;\n             if let Some(def_id) = generics.parent {\n                 // Methods.\n                 assert!(is_value_path);\n-                child_types = generics.types.len();\n+                child_types = child_own_counts.types;\n                 generics = tcx.generics_of(def_id);\n-                num_regions = generics.regions.len();\n-                num_types = generics.types.len();\n+                own_counts = generics.own_counts();\n \n                 if has_self {\n                     print!(f, self, write(\"<\"), print_display(substs.type_at(0)), write(\" as \"))?;\n@@ -328,20 +330,30 @@ impl PrintContext {\n                     assert_eq!(has_self, false);\n                 } else {\n                     // Types and traits.\n-                    num_regions = generics.regions.len();\n-                    num_types = generics.types.len();\n+                    own_counts = child_own_counts;\n                 }\n             }\n \n             if !verbose {\n-                if generics.types.last().map_or(false, |def| def.has_default) {\n+                let mut type_params =\n+                    generics.params.iter().rev().filter_map(|param| {\n+                        match param.kind {\n+                            GenericParamDefKind::Type(ty) => Some((param.def_id, ty.has_default)),\n+                            GenericParamDefKind::Lifetime => None,\n+                        }\n+                    }).peekable();\n+                let has_default = {\n+                    let has_default = type_params.peek().map(|(_, has_default)| has_default);\n+                    *has_default.unwrap_or(&false)\n+                };\n+                if has_default {\n                     if let Some(substs) = tcx.lift(&substs) {\n-                        let tps = substs.types().rev().skip(child_types);\n-                        for (def, actual) in generics.types.iter().rev().zip(tps) {\n-                            if !def.has_default {\n+                        let mut types = substs.types().rev().skip(child_types);\n+                        for ((def_id, has_default), actual) in type_params.zip(types) {\n+                            if !has_default {\n                                 break;\n                             }\n-                            if tcx.type_of(def.def_id).subst(tcx, substs) != actual {\n+                            if tcx.type_of(def_id).subst(tcx, substs) != actual {\n                                 break;\n                             }\n                             num_supplied_defaults += 1;\n@@ -401,10 +413,11 @@ impl PrintContext {\n             Ok(())\n         };\n \n-        print_regions(f, \"<\", 0, num_regions)?;\n+        print_regions(f, \"<\", 0, own_counts.lifetimes)?;\n \n-        let tps = substs.types().take(num_types - num_supplied_defaults)\n-                                .skip(has_self as usize);\n+        let tps = substs.types()\n+                        .take(own_counts.types - num_supplied_defaults)\n+                        .skip(has_self as usize);\n \n         for ty in tps {\n             start_or_continue(f, \"<\", \", \")?;\n@@ -435,10 +448,10 @@ impl PrintContext {\n                 write!(f, \"::{}\", item_name)?;\n             }\n \n-            print_regions(f, \"::<\", num_regions, usize::MAX)?;\n+            print_regions(f, \"::<\", own_counts.lifetimes, usize::MAX)?;\n \n             // FIXME: consider being smart with defaults here too\n-            for ty in substs.types().skip(num_types) {\n+            for ty in substs.types().skip(own_counts.types) {\n                 start_or_continue(f, \"::<\", \", \")?;\n                 ty.print_display(f, self)?;\n             }\n@@ -588,18 +601,14 @@ define_print! {\n     }\n }\n \n-impl fmt::Debug for ty::TypeParameterDef {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TypeParameterDef({}, {:?}, {})\",\n-               self.name,\n-               self.def_id,\n-               self.index)\n-    }\n-}\n-\n-impl fmt::Debug for ty::RegionParameterDef {\n+impl fmt::Debug for ty::GenericParamDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionParameterDef({}, {:?}, {})\",\n+        let type_name = match self.kind {\n+            ty::GenericParamDefKind::Lifetime => \"Lifetime\",\n+            ty::GenericParamDefKind::Type(_) => \"Type\",\n+        };\n+        write!(f, \"{}({}, {:?}, {})\",\n+               type_name,\n                self.name,\n                self.def_id,\n                self.index)"}, {"sha": "78c95a5ce0504e1a60a19433bdc4db3395fe9c60", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -308,7 +308,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n     pub fn t_param(&self, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        self.infcx.tcx.mk_param(index, Symbol::intern(&name).as_interned_str())\n+        self.infcx.tcx.mk_ty_param(index, Symbol::intern(&name).as_interned_str())\n     }\n \n     pub fn re_early_bound(&self, index: u32, name: &'static str) -> ty::Region<'tcx> {"}, {"sha": "3de90abd9663f84213e90addb6ccd7292e228a9b", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -929,10 +929,9 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ImplItemKind::Const(..) => true,\n                 hir::ImplItemKind::Method(ref sig, _) => {\n                     let generics = self.tcx.generics_of(def_id);\n-                    let types = generics.parent_types as usize + generics.types.len();\n-                    let needs_inline =\n-                        (types > 0 || tcx.trans_fn_attrs(def_id).requests_inline())\n-                            && !self.metadata_output_only();\n+                    let needs_inline = (generics.requires_monomorphization(self.tcx) ||\n+                                        tcx.trans_fn_attrs(def_id).requests_inline()) &&\n+                                        !self.metadata_output_only();\n                     let is_const_fn = sig.constness == hir::Constness::Const;\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                     needs_inline || is_const_fn || always_encode_mir"}, {"sha": "dc2009a02600309b79e35db58b221611e97411de", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -197,7 +197,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir::interpret::{AllocId, ConstValue};\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n use rustc::ty::subst::{Substs, Kind};\n-use rustc::ty::{self, TypeFoldable, Ty, TyCtxt};\n+use rustc::ty::{self, TypeFoldable, Ty, TyCtxt, GenericParamDefKind};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::session::config;\n use rustc::mir::{self, Location, Promoted};\n@@ -1076,7 +1076,7 @@ impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n \n fn item_has_type_parameters<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n     let generics = tcx.generics_of(def_id);\n-    generics.parent_types as usize + generics.types.len() > 0\n+    generics.requires_monomorphization(tcx)\n }\n \n fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1108,14 +1108,18 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         continue;\n                     }\n \n-                    if !tcx.generics_of(method.def_id).types.is_empty() {\n+                    if tcx.generics_of(method.def_id).own_counts().types != 0 {\n                         continue;\n                     }\n \n-                    let substs = Substs::for_item(tcx,\n-                                                  method.def_id,\n-                                                  |_, _| tcx.types.re_erased,\n-                                                  |def, _| trait_ref.substs.type_for_def(def));\n+                    let substs = Substs::for_item(tcx, method.def_id, |param, _| {\n+                        match param.kind {\n+                            GenericParamDefKind::Lifetime => tcx.types.re_erased.into(),\n+                            GenericParamDefKind::Type(_) => {\n+                                trait_ref.substs[param.index as usize]\n+                            }\n+                        }\n+                    });\n \n                     let instance = ty::Instance::resolve(tcx,\n                                                          ty::ParamEnv::reveal_all(),"}, {"sha": "c79298d8dd2cfa8a2dcbaf2432b33f32ab5fd53d", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -12,7 +12,7 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer;\n use rustc::mir::*;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, GenericParamDefKind};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::maps::Providers;\n \n@@ -427,12 +427,12 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n     ) {\n         let tcx = self.tcx;\n \n-        let substs = Substs::for_item(\n-            tcx,\n-            self.def_id,\n-            |_, _| tcx.types.re_erased,\n-            |_, _| ty\n-        );\n+        let substs = Substs::for_item(tcx, self.def_id, |param, _| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => tcx.types.re_erased.into(),\n+                GenericParamDefKind::Type(_) => ty.into(),\n+            }\n+        });\n \n         // `func == Clone::clone(&ty) -> ty`\n         let func_ty = tcx.mk_fn_def(self.def_id, substs);"}, {"sha": "fc3764e4f49a5bbb8391ab4604b655c93340f9a5", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -357,7 +357,7 @@ fn unsafe_derive_on_repr_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: D\n \n     // FIXME: when we make this a hard error, this should have its\n     // own error code.\n-    let message = if !tcx.generics_of(def_id).types.is_empty() {\n+    let message = if tcx.generics_of(def_id).own_counts().types != 0 {\n         format!(\"#[derive] can't be used on a #[repr(packed)] struct with \\\n                  type parameters (error E0133)\")\n     } else {"}, {"sha": "80603959ec202fdd0542d64941bedd7c2ff94a0b", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -184,7 +184,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n             // evaluate the promoted and replace the constant with the evaluated result\n             Literal::Promoted { index } => {\n                 let generics = self.tcx.generics_of(self.source.def_id);\n-                if generics.parent_types as usize + generics.types.len() > 0 {\n+                if generics.requires_monomorphization(self.tcx) {\n                     // FIXME: can't handle code with generics\n                     return None;\n                 }\n@@ -295,7 +295,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     self.source.def_id\n                 };\n                 let generics = self.tcx.generics_of(def_id);\n-                if generics.parent_types as usize + generics.types.len() > 0 {\n+                if generics.requires_monomorphization(self.tcx) {\n                     // FIXME: can't handle code with generics\n                     return None;\n                 }\n@@ -317,8 +317,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     self.source.def_id\n                 };\n                 let generics = self.tcx.generics_of(def_id);\n-                let has_generics = generics.parent_types as usize + generics.types.len() > 0;\n-                if has_generics {\n+                if generics.requires_monomorphization(self.tcx) {\n                     // FIXME: can't handle code with generics\n                     return None;\n                 }"}, {"sha": "6e9b03cd2a9c6cedb35d803f4c1fa0d421f6c6d2", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -27,7 +27,7 @@ use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::DeepVisitor;\n use rustc::lint;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n-use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n+use rustc::ty::{self, TyCtxt, Ty, TypeFoldable, GenericParamDefKind};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::maps::Providers;\n use rustc::ty::subst::UnpackedKind;\n@@ -399,9 +399,14 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n \n impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     fn generics(&mut self) -> &mut Self {\n-        for def in &self.ev.tcx.generics_of(self.item_def_id).types {\n-            if def.has_default {\n-                self.ev.tcx.type_of(def.def_id).visit_with(self);\n+        for param in &self.ev.tcx.generics_of(self.item_def_id).params {\n+            match param.kind {\n+                GenericParamDefKind::Type(ty) => {\n+                    if ty.has_default {\n+                        self.ev.tcx.type_of(param.def_id).visit_with(self);\n+                    }\n+                }\n+                GenericParamDefKind::Lifetime => {}\n             }\n         }\n         self\n@@ -1335,9 +1340,14 @@ struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn generics(&mut self) -> &mut Self {\n-        for def in &self.tcx.generics_of(self.item_def_id).types {\n-            if def.has_default {\n-                self.tcx.type_of(def.def_id).visit_with(self);\n+        for param in &self.tcx.generics_of(self.item_def_id).params {\n+            match param.kind {\n+                GenericParamDefKind::Type(ty) => {\n+                    if ty.has_default {\n+                        self.tcx.type_of(param.def_id).visit_with(self);\n+                    }\n+                }\n+                GenericParamDefKind::Lifetime => {}\n             }\n         }\n         self"}, {"sha": "219c6b9aefba51f72be5cacf674fcfd98413d0b6", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -14,7 +14,7 @@ use rustc::traits::{FulfillmentContext, Normalized, ObligationCause};\n use rustc::traits::query::{CanonicalTyGoal, NoSolution};\n use rustc::traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n-use rustc::ty::subst::Subst;\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::util::nodemap::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -278,9 +278,13 @@ crate fn adt_dtorck_constraint<'a, 'tcx>(\n     debug!(\"dtorck_constraint: {:?}\", def);\n \n     if def.is_phantom_data() {\n+        // The first generic parameter here is guaranteed to be a type because it's\n+        // `PhantomData`.\n+        let substs = Substs::identity_for_item(tcx, def_id);\n+        assert_eq!(substs.len(), 1);\n         let result = DtorckConstraint {\n             outlives: vec![],\n-            dtorck_types: vec![tcx.mk_param_from_def(&tcx.generics_of(def_id).types[0])],\n+            dtorck_types: vec![substs.type_at(0)],\n             overflows: vec![],\n         };\n         debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);"}, {"sha": "f2627f65702411d3e53a0539551c273755c23c39", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -12,6 +12,7 @@\n //! the guts are broken up into modules; see the comments in those modules.\n \n #![feature(crate_visibility_modifier)]\n+#![feature(iterator_find_map)]\n \n #[macro_use]\n extern crate log;"}, {"sha": "d77855220691d31113a8ef018b636552baf1e02e", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -117,7 +117,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }) => {\n                     let def_id = tcx.hir.local_def_id(node_id);\n                     let generics = tcx.generics_of(def_id);\n-                    if (generics.parent_types == 0 && generics.types.is_empty()) &&\n+                    if !generics.requires_monomorphization(tcx) &&\n                         // Functions marked with #[inline] are only ever translated\n                         // with \"internal\" linkage and are never exported.\n                         !Instance::mono(tcx, def_id).def.requires_local(tcx) {"}, {"sha": "2039a90a043bf4c5fd9a5240ddad9505fbe35c65", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -25,7 +25,7 @@ use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray, DIFlags};\n use rustc::hir::TransFnAttrFlags;\n use rustc::hir::def_id::{DefId, CrateNum};\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::{Substs, UnpackedKind};\n \n use abi::Abi;\n use common::CodegenCx;\n@@ -390,20 +390,25 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n         // Again, only create type information if full debuginfo is enabled\n         let template_params: Vec<_> = if cx.sess().opts.debuginfo == FullDebugInfo {\n-            let names = get_type_parameter_names(cx, generics);\n-            substs.types().zip(names).map(|(ty, name)| {\n-                let actual_type = cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n-                let actual_type_metadata = type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n-                let name = CString::new(name.as_str().as_bytes()).unwrap();\n-                unsafe {\n-                    llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n-                        DIB(cx),\n-                        ptr::null_mut(),\n-                        name.as_ptr(),\n-                        actual_type_metadata,\n-                        file_metadata,\n-                        0,\n-                        0)\n+            let names = get_parameter_names(cx, generics);\n+            substs.iter().zip(names).filter_map(|(kind, name)| {\n+                if let UnpackedKind::Type(ty) = kind.unpack() {\n+                    let actual_type = cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n+                    let actual_type_metadata =\n+                        type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n+                    let name = CString::new(name.as_str().as_bytes()).unwrap();\n+                    Some(unsafe {\n+                        llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n+                            DIB(cx),\n+                            ptr::null_mut(),\n+                            name.as_ptr(),\n+                            actual_type_metadata,\n+                            file_metadata,\n+                            0,\n+                            0)\n+                    })\n+                } else {\n+                    None\n                 }\n             }).collect()\n         } else {\n@@ -413,11 +418,13 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         return create_DIArray(DIB(cx), &template_params[..]);\n     }\n \n-    fn get_type_parameter_names(cx: &CodegenCx, generics: &ty::Generics) -> Vec<InternedString> {\n+    fn get_parameter_names(cx: &CodegenCx,\n+                           generics: &ty::Generics)\n+                           -> Vec<InternedString> {\n         let mut names = generics.parent.map_or(vec![], |def_id| {\n-            get_type_parameter_names(cx, cx.tcx.generics_of(def_id))\n+            get_parameter_names(cx, cx.tcx.generics_of(def_id))\n         });\n-        names.extend(generics.types.iter().map(|param| param.name));\n+        names.extend(generics.params.iter().map(|param| param.name));\n         names\n     }\n "}, {"sha": "c1868467503f823d0d17fed9d202de43c73d0873", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 117, "deletions": 85, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -21,6 +21,7 @@ use namespace::Namespace;\n use rustc::ty::subst::{Kind, UnpackedKind, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, RegionKind, Ty, TyCtxt, ToPredicate, TypeFoldable};\n+use rustc::ty::GenericParamDefKind;\n use rustc::ty::wf::object_region_bounds;\n use rustc_target::spec::abi;\n use std::slice;\n@@ -43,15 +44,15 @@ pub trait AstConv<'gcx, 'tcx> {\n                                  -> ty::GenericPredicates<'tcx>;\n \n     /// What lifetime should we use when a lifetime is omitted (and not elided)?\n-    fn re_infer(&self, span: Span, _def: Option<&ty::RegionParameterDef>)\n+    fn re_infer(&self, span: Span, _def: Option<&ty::GenericParamDef>)\n                 -> Option<ty::Region<'tcx>>;\n \n     /// What type should we use when a type is omitted?\n     fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n \n     /// Same as ty_infer, but with a known type parameter definition.\n     fn ty_infer_for_def(&self,\n-                        _def: &ty::TypeParameterDef,\n+                        _def: &ty::GenericParamDef,\n                         span: Span) -> Ty<'tcx> {\n         self.ty_infer(span)\n     }\n@@ -87,6 +88,11 @@ struct ConvertedBinding<'tcx> {\n     span: Span,\n }\n \n+struct ParamRange {\n+    required: usize,\n+    accepted: usize\n+}\n+\n /// Dummy type used for the `Self` of a `TraitRef` created for converting\n /// a trait object, and which gets removed in `ExistentialTraitRef`.\n /// This type must not appear anywhere in other converted types.\n@@ -95,7 +101,7 @@ const TRAIT_OBJECT_DUMMY_SELF: ty::TypeVariants<'static> = ty::TyInfer(ty::Fresh\n impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn ast_region_to_region(&self,\n         lifetime: &hir::Lifetime,\n-        def: Option<&ty::RegionParameterDef>)\n+        def: Option<&ty::GenericParamDef>)\n         -> ty::Region<'tcx>\n     {\n         let tcx = self.tcx();\n@@ -208,92 +214,119 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n         let decl_generics = tcx.generics_of(def_id);\n-        let num_types_provided = parameters.types.len();\n-        let expected_num_region_params = decl_generics.regions.len();\n-        let supplied_num_region_params = parameters.lifetimes.len();\n-        if expected_num_region_params != supplied_num_region_params {\n-            report_lifetime_number_error(tcx, span,\n-                                         supplied_num_region_params,\n-                                         expected_num_region_params);\n+        let ty_provided = parameters.types.len();\n+        let lt_provided = parameters.lifetimes.len();\n+\n+        let mut lt_accepted = 0;\n+        let mut ty_params = ParamRange { required: 0, accepted: 0 };\n+        for param in &decl_generics.params {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {\n+                    lt_accepted += 1;\n+                }\n+                GenericParamDefKind::Type(ty) => {\n+                    ty_params.accepted += 1;\n+                    if !ty.has_default {\n+                        ty_params.required += 1;\n+                    }\n+                }\n+            };\n+        }\n+        if self_ty.is_some() {\n+            ty_params.required -= 1;\n+            ty_params.accepted -= 1;\n+        }\n+\n+        if lt_accepted != lt_provided {\n+            report_lifetime_number_error(tcx, span, lt_provided, lt_accepted);\n         }\n \n         // If a self-type was declared, one should be provided.\n         assert_eq!(decl_generics.has_self, self_ty.is_some());\n \n         // Check the number of type parameters supplied by the user.\n-        let ty_param_defs = &decl_generics.types[self_ty.is_some() as usize..];\n-        if !infer_types || num_types_provided > ty_param_defs.len() {\n-            check_type_argument_count(tcx, span, num_types_provided, ty_param_defs);\n+        if !infer_types || ty_provided > ty_params.required {\n+            check_type_argument_count(tcx, span, ty_provided, ty_params);\n         }\n \n         let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n-        let default_needs_object_self = |p: &ty::TypeParameterDef| {\n-            if is_object && p.has_default {\n-                if tcx.at(span).type_of(p.def_id).has_self_ty() {\n-                    // There is no suitable inference default for a type parameter\n-                    // that references self, in an object type.\n-                    return true;\n+        let default_needs_object_self = |param: &ty::GenericParamDef| {\n+            if let GenericParamDefKind::Type(ty) = param.kind {\n+                if is_object && ty.has_default {\n+                    if tcx.at(span).type_of(param.def_id).has_self_ty() {\n+                        // There is no suitable inference default for a type parameter\n+                        // that references self, in an object type.\n+                        return true;\n+                    }\n                 }\n             }\n \n             false\n         };\n \n-        let substs = Substs::for_item(tcx, def_id, |def, _| {\n-            let i = def.index as usize - self_ty.is_some() as usize;\n-            if let Some(lifetime) = parameters.lifetimes.get(i) {\n-                self.ast_region_to_region(lifetime, Some(def))\n-            } else {\n-                tcx.types.re_static\n-            }\n-        }, |def, substs| {\n-            let i = def.index as usize;\n+        let own_self = self_ty.is_some() as usize;\n+        let substs = Substs::for_item(tcx, def_id, |param, substs| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {\n+                    let i = param.index as usize - own_self;\n+                    if let Some(lifetime) = parameters.lifetimes.get(i) {\n+                        self.ast_region_to_region(lifetime, Some(param)).into()\n+                    } else {\n+                        tcx.types.re_static.into()\n+                    }\n+                }\n+                GenericParamDefKind::Type(ty) => {\n+                    let i = param.index as usize;\n \n-            // Handle Self first, so we can adjust the index to match the AST.\n-            if let (0, Some(ty)) = (i, self_ty) {\n-                return ty;\n-            }\n+                    // Handle Self first, so we can adjust the index to match the AST.\n+                    if let (0, Some(ty)) = (i, self_ty) {\n+                        return ty.into();\n+                    }\n \n-            let i = i - self_ty.is_some() as usize - decl_generics.regions.len();\n-            if i < num_types_provided {\n-                // A provided type parameter.\n-                self.ast_ty_to_ty(&parameters.types[i])\n-            } else if infer_types {\n-                // No type parameters were provided, we can infer all.\n-                let ty_var = if !default_needs_object_self(def) {\n-                    self.ty_infer_for_def(def, span)\n-                } else {\n-                    self.ty_infer(span)\n-                };\n-                ty_var\n-            } else if def.has_default {\n-                // No type parameter provided, but a default exists.\n-\n-                // If we are converting an object type, then the\n-                // `Self` parameter is unknown. However, some of the\n-                // other type parameters may reference `Self` in their\n-                // defaults. This will lead to an ICE if we are not\n-                // careful!\n-                if default_needs_object_self(def) {\n-                    struct_span_err!(tcx.sess, span, E0393,\n-                                     \"the type parameter `{}` must be explicitly specified\",\n-                                     def.name)\n-                        .span_label(span, format!(\"missing reference to `{}`\", def.name))\n-                        .note(&format!(\"because of the default `Self` reference, \\\n-                                        type parameters must be specified on object types\"))\n-                        .emit();\n-                    tcx.types.err\n-                } else {\n-                    // This is a default type parameter.\n-                    self.normalize_ty(\n-                        span,\n-                        tcx.at(span).type_of(def.def_id)\n-                            .subst_spanned(tcx, substs, Some(span))\n-                    )\n+                    let i = i - (lt_accepted + own_self);\n+                    if i < ty_provided {\n+                        // A provided type parameter.\n+                        self.ast_ty_to_ty(&parameters.types[i]).into()\n+                    } else if infer_types {\n+                        // No type parameters were provided, we can infer all.\n+                        if !default_needs_object_self(param) {\n+                            self.ty_infer_for_def(param, span).into()\n+                        } else {\n+                            self.ty_infer(span).into()\n+                        }\n+                    } else if ty.has_default {\n+                        // No type parameter provided, but a default exists.\n+\n+                        // If we are converting an object type, then the\n+                        // `Self` parameter is unknown. However, some of the\n+                        // other type parameters may reference `Self` in their\n+                        // defaults. This will lead to an ICE if we are not\n+                        // careful!\n+                        if default_needs_object_self(param) {\n+                            struct_span_err!(tcx.sess, span, E0393,\n+                                             \"the type parameter `{}` must be explicitly \\\n+                                             specified\",\n+                                             param.name)\n+                                .span_label(span,\n+                                            format!(\"missing reference to `{}`\", param.name))\n+                                .note(&format!(\"because of the default `Self` reference, \\\n+                                                type parameters must be specified on object \\\n+                                                types\"))\n+                                .emit();\n+                            tcx.types.err.into()\n+                        } else {\n+                            // This is a default type parameter.\n+                            self.normalize_ty(\n+                                span,\n+                                tcx.at(span).type_of(param.def_id)\n+                                    .subst_spanned(tcx, substs, Some(span))\n+                            ).into()\n+                        }\n+                    } else {\n+                        // We've already errored above about the mismatch.\n+                        tcx.types.err.into()\n+                    }\n                 }\n-            } else {\n-                // We've already errored above about the mismatch.\n-                tcx.types.err\n             }\n         });\n \n@@ -979,8 +1012,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let item_id = tcx.hir.get_parent_node(node_id);\n                 let item_def_id = tcx.hir.local_def_id(item_id);\n                 let generics = tcx.generics_of(item_def_id);\n-                let index = generics.type_param_to_index[&tcx.hir.local_def_id(node_id)];\n-                tcx.mk_param(index, tcx.hir.name(node_id).as_interned_str())\n+                let index = generics.param_def_id_to_index[&tcx.hir.local_def_id(node_id)];\n+                tcx.mk_ty_param(index, tcx.hir.name(node_id).as_interned_str())\n             }\n             Def::SelfTy(_, Some(def_id)) => {\n                 // Self in impl (we know the concrete type).\n@@ -1124,12 +1157,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let mut substs = Vec::with_capacity(generics.count());\n         if let Some(parent_id) = generics.parent {\n             let parent_generics = tcx.generics_of(parent_id);\n-            Substs::fill_item(\n-                &mut substs, tcx, parent_generics,\n-                &mut |def, _| tcx.mk_region(\n-                    ty::ReEarlyBound(def.to_early_bound_region_data())),\n-                &mut |def, _| tcx.mk_param_from_def(def)\n-            );\n+            Substs::fill_item(&mut substs, tcx, parent_generics, &mut |param, _| {\n+                tcx.mk_param_from_def(param)\n+            });\n \n             // Replace all lifetimes with 'static\n             for subst in &mut substs {\n@@ -1139,10 +1169,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             debug!(\"impl_trait_ty_to_ty: substs from parent = {:?}\", substs);\n         }\n-        assert_eq!(substs.len(), generics.parent_count());\n+        assert_eq!(substs.len(), generics.parent_count);\n \n         // Fill in our own generics with the resolved lifetimes\n-        assert_eq!(lifetimes.len(), generics.own_count());\n+        assert_eq!(lifetimes.len(), generics.params.len());\n         substs.extend(lifetimes.iter().map(|lt| Kind::from(self.ast_region_to_region(lt, None))));\n \n         debug!(\"impl_trait_ty_to_ty: final substs = {:?}\", substs);\n@@ -1299,10 +1329,12 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     (auto_traits, trait_bounds)\n }\n \n-fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n-                             ty_param_defs: &[ty::TypeParameterDef]) {\n-    let accepted = ty_param_defs.len();\n-    let required = ty_param_defs.iter().take_while(|x| !x.has_default).count();\n+fn check_type_argument_count(tcx: TyCtxt,\n+                             span: Span,\n+                             supplied: usize,\n+                             ty_params: ParamRange)\n+{\n+    let (required, accepted) = (ty_params.required, ty_params.accepted);\n     if supplied < required {\n         let expected = if required < accepted {\n             \"expected at least\""}, {"sha": "c2ec6475b9c6596bb97cd9227c90f9f8ff89d254", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -18,7 +18,7 @@ use rustc::infer::{InferOk, InferResult};\n use rustc::infer::LateBoundRegionConversionTime;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::error_reporting::ArgKind;\n-use rustc::ty::{self, ToPolyTraitRef, Ty};\n+use rustc::ty::{self, ToPolyTraitRef, Ty, GenericParamDefKind};\n use rustc::ty::subst::Substs;\n use rustc::ty::TypeFoldable;\n use std::cmp;\n@@ -104,15 +104,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // inference phase (`upvar.rs`).\n         let base_substs =\n             Substs::identity_for_item(self.tcx, self.tcx.closure_base_def_id(expr_def_id));\n-        let substs = base_substs.extend_to(\n-            self.tcx,\n-            expr_def_id,\n-            |_, _| span_bug!(expr.span, \"closure has region param\"),\n-            |_, _| {\n-                self.infcx\n-                    .next_ty_var(TypeVariableOrigin::ClosureSynthetic(expr.span))\n-            },\n-        );\n+        let substs = base_substs.extend_to(self.tcx,expr_def_id, |param, _| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {\n+                    span_bug!(expr.span, \"closure has region param\")\n+                }\n+                GenericParamDefKind::Type(_) => {\n+                    self.infcx\n+                        .next_ty_var(TypeVariableOrigin::ClosureSynthetic(expr.span)).into()\n+                }\n+            }\n+        });\n         if let Some(GeneratorTypes { yield_ty, interior, movability }) = generator_types {\n             let substs = ty::GeneratorSubsts { substs };\n             self.demand_eqtype("}, {"sha": "ba950f90d0a02db5fa5bef9c87761ed0a139c673", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::hir::{self, ImplItemKind, TraitItemKind};\n use rustc::infer::{self, InferOk};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, GenericParamDefKind};\n use rustc::ty::util::ExplicitSelf;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n@@ -357,8 +357,8 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 trait_to_skol_substs: &Substs<'tcx>)\n                                                 -> Result<(), ErrorReported> {\n     let span = tcx.sess.codemap().def_span(span);\n-    let trait_params = &trait_generics.regions[..];\n-    let impl_params = &impl_generics.regions[..];\n+    let trait_params = trait_generics.own_counts().lifetimes;\n+    let impl_params = impl_generics.own_counts().lifetimes;\n \n     debug!(\"check_region_bounds_on_impl_method: \\\n             trait_generics={:?} \\\n@@ -377,7 +377,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // but found 0\" it's confusing, because it looks like there\n     // are zero. Since I don't quite know how to phrase things at\n     // the moment, give a kind of vague error message.\n-    if trait_params.len() != impl_params.len() {\n+    if trait_params != impl_params {\n         let mut err = struct_span_err!(tcx.sess,\n                                        span,\n                                        E0195,\n@@ -574,8 +574,8 @@ fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         -> Result<(), ErrorReported> {\n     let impl_m_generics = tcx.generics_of(impl_m.def_id);\n     let trait_m_generics = tcx.generics_of(trait_m.def_id);\n-    let num_impl_m_type_params = impl_m_generics.types.len();\n-    let num_trait_m_type_params = trait_m_generics.types.len();\n+    let num_impl_m_type_params = impl_m_generics.own_counts().types;\n+    let num_trait_m_type_params = trait_m_generics.own_counts().types;\n     if num_impl_m_type_params != num_trait_m_type_params {\n         let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n         let impl_m_item = tcx.hir.expect_impl_item(impl_m_node_id);\n@@ -728,11 +728,24 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut error_found = false;\n     let impl_m_generics = tcx.generics_of(impl_m.def_id);\n     let trait_m_generics = tcx.generics_of(trait_m.def_id);\n-    for (impl_ty, trait_ty) in impl_m_generics.types.iter().zip(trait_m_generics.types.iter()) {\n-        if impl_ty.synthetic != trait_ty.synthetic {\n-            let impl_node_id = tcx.hir.as_local_node_id(impl_ty.def_id).unwrap();\n+    let impl_m_type_params = impl_m_generics.params.iter().filter_map(|param| {\n+        match param.kind {\n+            GenericParamDefKind::Type(ty) => Some((param.def_id, ty.synthetic)),\n+            GenericParamDefKind::Lifetime => None,\n+        }\n+    });\n+    let trait_m_type_params = trait_m_generics.params.iter().filter_map(|param| {\n+        match param.kind {\n+            GenericParamDefKind::Type(ty) => Some((param.def_id, ty.synthetic)),\n+            GenericParamDefKind::Lifetime => None,\n+        }\n+    });\n+    for ((impl_def_id, impl_synthetic),\n+         (trait_def_id, trait_synthetic)) in impl_m_type_params.zip(trait_m_type_params) {\n+        if impl_synthetic != trait_synthetic {\n+            let impl_node_id = tcx.hir.as_local_node_id(impl_def_id).unwrap();\n             let impl_span = tcx.hir.span(impl_node_id);\n-            let trait_span = tcx.def_span(trait_ty.def_id);\n+            let trait_span = tcx.def_span(trait_def_id);\n             let mut err = struct_span_err!(tcx.sess,\n                                            impl_span,\n                                            E0643,"}, {"sha": "97e4a35ea4762a449220ad77c9fbd8521d53031b", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -45,7 +45,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let i_n_tps = tcx.generics_of(def_id).types.len();\n+    let i_n_tps = tcx.generics_of(def_id).own_counts().types;\n     if i_n_tps != n_tps {\n         let span = match it.node {\n             hir::ForeignItemFn(_, _, ref generics) => generics.span,\n@@ -76,7 +76,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// and in libcore/intrinsics.rs\n pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       it: &hir::ForeignItem) {\n-    let param = |n| tcx.mk_param(n, Symbol::intern(&format!(\"P{}\", n)).as_interned_str());\n+    let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)).as_interned_str());\n     let name = it.name.as_str();\n     let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n         let split : Vec<&str> = name.split('_').collect();\n@@ -342,11 +342,11 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                it: &hir::ForeignItem) {\n     let param = |n| {\n         let name = Symbol::intern(&format!(\"P{}\", n)).as_interned_str();\n-        tcx.mk_param(n, name)\n+        tcx.mk_ty_param(n, name)\n     };\n \n     let def_id = tcx.hir.local_def_id(it.id);\n-    let i_n_tps = tcx.generics_of(def_id).types.len();\n+    let i_n_tps = tcx.generics_of(def_id).own_counts().types;\n     let name = it.name.as_str();\n \n     let (n_tps, inputs, output) = match &*name {"}, {"sha": "aa3a166d0656fd71136c0cafe013bb5a7a845da3", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -15,7 +15,7 @@ use check::{FnCtxt, PlaceOp, callee, Needs};\n use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Ty, GenericParamDefKind};\n use rustc::ty::subst::Subst;\n use rustc::ty::adjustment::{Adjustment, Adjust, OverloadedDeref};\n use rustc::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n@@ -314,30 +314,32 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         // Create subst for early-bound lifetime parameters, combining\n         // parameters from the type and those from the method.\n-        assert_eq!(method_generics.parent_count(), parent_substs.len());\n+        assert_eq!(method_generics.parent_count, parent_substs.len());\n         let provided = &segment.parameters;\n-        Substs::for_item(self.tcx, pick.item.def_id, |def, _| {\n-            let i = def.index as usize;\n+        let own_counts = method_generics.own_counts();\n+        Substs::for_item(self.tcx, pick.item.def_id, |param, _| {\n+            let i = param.index as usize;\n             if i < parent_substs.len() {\n-                parent_substs.region_at(i)\n-            } else if let Some(lifetime)\n-                    = provided.as_ref().and_then(|p| p.lifetimes.get(i - parent_substs.len())) {\n-                AstConv::ast_region_to_region(self.fcx, lifetime, Some(def))\n+                parent_substs[i]\n             } else {\n-                self.region_var_for_def(self.span, def)\n-            }\n-        }, |def, _cur_substs| {\n-            let i = def.index as usize;\n-            if i < parent_substs.len() {\n-                parent_substs.type_at(i)\n-            } else if let Some(ast_ty)\n-                = provided.as_ref().and_then(|p| {\n-                    p.types.get(i - parent_substs.len() - method_generics.regions.len())\n-                })\n-            {\n-                self.to_ty(ast_ty)\n-            } else {\n-                self.type_var_for_def(self.span, def)\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => {\n+                        if let Some(lifetime) = provided.as_ref().and_then(|p| {\n+                            p.lifetimes.get(i - parent_substs.len())\n+                        }) {\n+                            return AstConv::ast_region_to_region(\n+                                self.fcx, lifetime, Some(param)).into();\n+                        }\n+                    }\n+                    GenericParamDefKind::Type(_) => {\n+                        if let Some(ast_ty) = provided.as_ref().and_then(|p| {\n+                            p.types.get(i - parent_substs.len() - own_counts.lifetimes)\n+                        }) {\n+                            return self.to_ty(ast_ty).into();\n+                        }\n+                    }\n+                }\n+                self.var_for_def(self.span, param)\n             }\n         })\n     }"}, {"sha": "15a8efd5885d77755c2ca725f822e64c5471b913", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -19,6 +19,7 @@ use namespace::Namespace;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n+use rustc::ty::GenericParamDefKind;\n use rustc::ty::subst::Subst;\n use rustc::infer::{self, InferOk};\n \n@@ -253,17 +254,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                trait_def_id);\n \n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n-        let substs = Substs::for_item(self.tcx,\n-                                      trait_def_id,\n-                                      |def, _| self.region_var_for_def(span, def),\n-                                      |def, _substs| {\n-            if def.index == 0 {\n-                self_ty\n-            } else if let Some(ref input_types) = opt_input_types {\n-                input_types[def.index as usize - 1]\n-            } else {\n-                self.type_var_for_def(span, def)\n+        let substs = Substs::for_item(self.tcx, trait_def_id, |param, _| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {}\n+                GenericParamDefKind::Type(_) => {\n+                    if param.index == 0 {\n+                        return self_ty.into();\n+                    } else if let Some(ref input_types) = opt_input_types {\n+                        return input_types[param.index as usize - 1].into();\n+                    }\n+                }\n             }\n+            self.var_for_def(span, param)\n         });\n \n         let trait_ref = ty::TraitRef::new(trait_def_id, substs);\n@@ -288,8 +290,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let method_item = self.associated_item(trait_def_id, m_name, Namespace::Value).unwrap();\n         let def_id = method_item.def_id;\n         let generics = tcx.generics_of(def_id);\n-        assert_eq!(generics.types.len(), 0);\n-        assert_eq!(generics.regions.len(), 0);\n+        assert_eq!(generics.params.len(), 0);\n \n         debug!(\"lookup_in_trait_adjusted: method_item={:?}\", method_item);\n         let mut obligations = vec![];"}, {"sha": "6b860dbe8febbfee9a756afe14eb848d3f613fb0", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -20,6 +20,7 @@ use namespace::Namespace;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, ObligationCause};\n use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TraitRef, TypeFoldable};\n+use rustc::ty::GenericParamDefKind;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::util::nodemap::FxHashSet;\n use rustc::infer::{self, InferOk};\n@@ -1378,31 +1379,28 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // method yet. So create fresh variables here for those too,\n         // if there are any.\n         let generics = self.tcx.generics_of(method);\n-        assert_eq!(substs.types().count(), generics.parent_types as usize);\n-        assert_eq!(substs.regions().count(), generics.parent_regions as usize);\n+        assert_eq!(substs.len(), generics.parent_count as usize);\n \n         // Erase any late-bound regions from the method and substitute\n         // in the values from the substitution.\n         let xform_fn_sig = self.erase_late_bound_regions(&fn_sig);\n \n-        if generics.types.is_empty() && generics.regions.is_empty() {\n+        if generics.params.is_empty() {\n             xform_fn_sig.subst(self.tcx, substs)\n         } else {\n-            let substs = Substs::for_item(self.tcx, method, |def, _| {\n-                let i = def.index as usize;\n+            let substs = Substs::for_item(self.tcx, method, |param, _| {\n+                let i = param.index as usize;\n                 if i < substs.len() {\n-                    substs.region_at(i)\n+                    substs[i]\n                 } else {\n-                    // In general, during probe we erase regions. See\n-                    // `impl_self_ty()` for an explanation.\n-                    self.tcx.types.re_erased\n-                }\n-            }, |def, _cur_substs| {\n-                let i = def.index as usize;\n-                if i < substs.len() {\n-                    substs.type_at(i)\n-                } else {\n-                    self.type_var_for_def(self.span, def)\n+                    match param.kind {\n+                        GenericParamDefKind::Lifetime => {\n+                            // In general, during probe we erase regions. See\n+                            // `impl_self_ty()` for an explanation.\n+                            self.tcx.types.re_erased.into()\n+                        }\n+                        GenericParamDefKind::Type(_) => self.var_for_def(self.span, param),\n+                    }\n                 }\n             });\n             xform_fn_sig.subst(self.tcx, substs)\n@@ -1415,12 +1413,15 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn fresh_item_substs(&self, def_id: DefId) -> &'tcx Substs<'tcx> {\n-        Substs::for_item(self.tcx,\n-                         def_id,\n-                         |_, _| self.tcx.types.re_erased,\n-                         |_, _| self.next_ty_var(\n-                             TypeVariableOrigin::SubstitutionPlaceholder(\n-                                 self.tcx.def_span(def_id))))\n+        Substs::for_item(self.tcx, def_id, |param, _| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => self.tcx.types.re_erased.into(),\n+                GenericParamDefKind::Type(_) => {\n+                    self.next_ty_var(TypeVariableOrigin::SubstitutionPlaceholder(\n+                        self.tcx.def_span(def_id))).into()\n+                }\n+            }\n+        })\n     }\n \n     /// Replace late-bound-regions bound by `value` with `'static` using"}, {"sha": "955dc6f5aac3bea7dbec8d65941f229226bfc04e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 114, "deletions": 90, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -94,9 +94,9 @@ use rustc::infer::anon_types::AnonTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::mir::interpret::{GlobalId};\n-use rustc::ty::subst::{Kind, Subst, Substs};\n+use rustc::ty::subst::{Kind, UnpackedKind, Subst, Substs};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n-use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPredicate};\n+use rustc::ty::{self, Ty, TyCtxt, GenericParamDefKind, Visibility, ToPredicate};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::maps::Providers;\n@@ -1239,7 +1239,7 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n         } else {\n             for item in &m.items {\n                 let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n-                if !generics.types.is_empty() {\n+                if generics.params.len() - generics.own_counts().lifetimes != 0 {\n                     let mut err = struct_span_err!(tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n                     err.span_label(item.span, \"can't have type parameters\");\n@@ -1716,7 +1716,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         let item_id = tcx.hir.ty_param_owner(node_id);\n         let item_def_id = tcx.hir.local_def_id(item_id);\n         let generics = tcx.generics_of(item_def_id);\n-        let index = generics.type_param_to_index[&def_id];\n+        let index = generics.param_def_id_to_index[&def_id];\n         ty::GenericPredicates {\n             parent: None,\n             predicates: self.param_env.caller_bounds.iter().filter(|predicate| {\n@@ -1730,7 +1730,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn re_infer(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n+    fn re_infer(&self, span: Span, def: Option<&ty::GenericParamDef>)\n                 -> Option<ty::Region<'tcx>> {\n         let v = match def {\n             Some(def) => infer::EarlyBoundRegion(span, def.name),\n@@ -1744,9 +1744,12 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn ty_infer_for_def(&self,\n-                        ty_param_def: &ty::TypeParameterDef,\n+                        ty_param_def: &ty::GenericParamDef,\n                         span: Span) -> Ty<'tcx> {\n-        self.type_var_for_def(span, ty_param_def)\n+        if let UnpackedKind::Type(ty) = self.var_for_def(span, ty_param_def).unpack() {\n+            return ty;\n+        }\n+        unreachable!()\n     }\n \n     fn projected_ty_from_poly_trait_ref(&self,\n@@ -4751,73 +4754,77 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let (fn_start, has_self) = match (type_segment, fn_segment) {\n             (_, Some((_, generics))) => {\n-                (generics.parent_count(), generics.has_self)\n+                (generics.parent_count, generics.has_self)\n             }\n             (Some((_, generics)), None) => {\n-                (generics.own_count(), generics.has_self)\n+                (generics.params.len(), generics.has_self)\n             }\n             (None, None) => (0, false)\n         };\n-        let substs = Substs::for_item(self.tcx, def.def_id(), |def, _| {\n-            let mut i = def.index as usize;\n+        let substs = Substs::for_item(self.tcx, def.def_id(), |param, substs| {\n+            let mut i = param.index as usize;\n \n             let segment = if i < fn_start {\n+                if let GenericParamDefKind::Type(_) = param.kind {\n+                    // Handle Self first, so we can adjust the index to match the AST.\n+                    if has_self && i == 0 {\n+                        return opt_self_ty.map(|ty| Kind::from(ty)).unwrap_or_else(|| {\n+                            self.var_for_def(span, param)\n+                        });\n+                    }\n+                }\n                 i -= has_self as usize;\n                 type_segment\n             } else {\n                 i -= fn_start;\n                 fn_segment\n             };\n-            let lifetimes = segment.map_or(&[][..], |(s, _)| {\n-                s.parameters.as_ref().map_or(&[][..], |p| &p.lifetimes[..])\n-            });\n \n-            if let Some(lifetime) = lifetimes.get(i) {\n-                AstConv::ast_region_to_region(self, lifetime, Some(def))\n-            } else {\n-                self.re_infer(span, Some(def)).unwrap()\n-            }\n-        }, |def, substs| {\n-            let mut i = def.index as usize;\n-\n-            let segment = if i < fn_start {\n-                // Handle Self first, so we can adjust the index to match the AST.\n-                if has_self && i == 0 {\n-                    return opt_self_ty.unwrap_or_else(|| {\n-                        self.type_var_for_def(span, def)\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {\n+                    let lifetimes = segment.map_or(&[][..], |(s, _)| {\n+                        s.parameters.as_ref().map_or(&[][..], |p| &p.lifetimes[..])\n                     });\n+\n+                    if let Some(lifetime) = lifetimes.get(i) {\n+                        AstConv::ast_region_to_region(self, lifetime, Some(param)).into()\n+                    } else {\n+                        self.re_infer(span, Some(param)).unwrap().into()\n+                    }\n                 }\n-                i -= has_self as usize;\n-                type_segment\n-            } else {\n-                i -= fn_start;\n-                fn_segment\n-            };\n-            let (types, infer_types) = segment.map_or((&[][..], true), |(s, _)| {\n-                (s.parameters.as_ref().map_or(&[][..], |p| &p.types[..]), s.infer_types)\n-            });\n+                GenericParamDefKind::Type(_) => {\n+                    let (types, infer_types) = segment.map_or((&[][..], true), |(s, _)| {\n+                        (s.parameters.as_ref().map_or(&[][..], |p| &p.types[..]), s.infer_types)\n+                    });\n \n-            // Skip over the lifetimes in the same segment.\n-            if let Some((_, generics)) = segment {\n-                i -= generics.regions.len();\n-            }\n+                    // Skip over the lifetimes in the same segment.\n+                    if let Some((_, generics)) = segment {\n+                        i -= generics.own_counts().lifetimes;\n+                    }\n \n-            if let Some(ast_ty) = types.get(i) {\n-                // A provided type parameter.\n-                self.to_ty(ast_ty)\n-            } else if !infer_types && def.has_default {\n-                // No type parameter provided, but a default exists.\n-                let default = self.tcx.type_of(def.def_id);\n-                self.normalize_ty(\n-                    span,\n-                    default.subst_spanned(self.tcx, substs, Some(span))\n-                )\n-            } else {\n-                // No type parameters were provided, we can infer all.\n-                // This can also be reached in some error cases:\n-                // We prefer to use inference variables instead of\n-                // TyError to let type inference recover somewhat.\n-                self.type_var_for_def(span, def)\n+                    let has_default = match param.kind {\n+                        GenericParamDefKind::Type(ty) => ty.has_default,\n+                        _ => unreachable!()\n+                    };\n+\n+                    if let Some(ast_ty) = types.get(i) {\n+                        // A provided type parameter.\n+                        self.to_ty(ast_ty).into()\n+                    } else if !infer_types && has_default {\n+                        // No type parameter provided, but a default exists.\n+                        let default = self.tcx.type_of(param.def_id);\n+                        self.normalize_ty(\n+                            span,\n+                            default.subst_spanned(self.tcx, substs, Some(span))\n+                        ).into()\n+                    } else {\n+                        // No type parameters were provided, we can infer all.\n+                        // This can also be reached in some error cases:\n+                        // We prefer to use inference variables instead of\n+                        // TyError to let type inference recover somewhat.\n+                        self.var_for_def(span, param)\n+                    }\n+                }\n             }\n         });\n \n@@ -4917,18 +4924,40 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             format!(\"{} type parameter{}\", n, if n == 1 { \"\" } else { \"s\" })\n         };\n \n-        // Check provided type parameters.\n-        let type_defs = segment.map_or(&[][..], |(_, generics)| {\n-            if generics.parent.is_none() {\n-                &generics.types[generics.has_self as usize..]\n-            } else {\n-                &generics.types\n-            }\n-        });\n-        let required_len = type_defs.iter().take_while(|d| !d.has_default).count();\n-        if types.len() > type_defs.len() {\n-            let span = types[type_defs.len()].span;\n-            let expected_text = count_type_params(type_defs.len());\n+        // Check provided parameters.\n+        let ((ty_required, ty_accepted), lt_accepted) =\n+            segment.map_or(((0, 0), 0), |(_, generics)| {\n+                struct ParamRange {\n+                    required: usize,\n+                    accepted: usize\n+                };\n+\n+                let mut lt_accepted = 0;\n+                let mut ty_params = ParamRange { required: 0, accepted: 0 };\n+                for param in &generics.params {\n+                    match param.kind {\n+                        GenericParamDefKind::Lifetime => {\n+                            lt_accepted += 1;\n+                        }\n+                        GenericParamDefKind::Type(ty) => {\n+                            ty_params.accepted += 1;\n+                            if !ty.has_default {\n+                                ty_params.required += 1;\n+                            }\n+                        }\n+                    };\n+                }\n+                if generics.parent.is_none() && generics.has_self {\n+                    ty_params.required -= 1;\n+                    ty_params.accepted -= 1;\n+                }\n+\n+                ((ty_params.required, ty_params.accepted), lt_accepted)\n+            });\n+\n+        if types.len() > ty_accepted {\n+            let span = types[ty_accepted].span;\n+            let expected_text = count_type_params(ty_accepted);\n             let actual_text = count_type_params(types.len());\n             struct_span_err!(self.tcx.sess, span, E0087,\n                              \"too many type parameters provided: \\\n@@ -4941,8 +4970,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // type parameters, we force instantiate_value_path to\n             // use inference variables instead of the provided types.\n             *segment = None;\n-        } else if types.len() < required_len && !infer_types && !supress_mismatch_error {\n-            let expected_text = count_type_params(required_len);\n+        } else if types.len() < ty_required && !infer_types && !supress_mismatch_error {\n+            let expected_text = count_type_params(ty_required);\n             let actual_text = count_type_params(types.len());\n             struct_span_err!(self.tcx.sess, span, E0089,\n                              \"too few type parameters provided: \\\n@@ -4956,10 +4985,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             AstConv::prohibit_projection(self, bindings[0].span);\n         }\n \n-        // Check provided lifetime parameters.\n-        let lifetime_defs = segment.map_or(&[][..], |(_, generics)| &generics.regions);\n-        let required_len = lifetime_defs.len();\n-\n         // Prohibit explicit lifetime arguments if late bound lifetime parameters are present.\n         let has_late_bound_lifetime_defs =\n             segment.map_or(None, |(_, generics)| generics.has_late_bound_regions);\n@@ -4968,8 +4993,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let primary_msg = \"cannot specify lifetime arguments explicitly \\\n                                if late bound lifetime parameters are present\";\n             let note_msg = \"the late bound lifetime parameter is introduced here\";\n-            if !is_method_call && (lifetimes.len() > lifetime_defs.len() ||\n-                                   lifetimes.len() < required_len && !infer_lifetimes) {\n+            if !is_method_call && (lifetimes.len() > lt_accepted ||\n+                                   lifetimes.len() < lt_accepted && !infer_lifetimes) {\n                 let mut err = self.tcx.sess.struct_span_err(lifetimes[0].span, primary_msg);\n                 err.span_note(span_late, note_msg);\n                 err.emit();\n@@ -4983,18 +5008,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return;\n         }\n \n-        if lifetimes.len() > lifetime_defs.len() {\n-            let span = lifetimes[lifetime_defs.len()].span;\n-            let expected_text = count_lifetime_params(lifetime_defs.len());\n+        if lifetimes.len() > lt_accepted {\n+            let span = lifetimes[lt_accepted].span;\n+            let expected_text = count_lifetime_params(lt_accepted);\n             let actual_text = count_lifetime_params(lifetimes.len());\n             struct_span_err!(self.tcx.sess, span, E0088,\n                              \"too many lifetime parameters provided: \\\n                               expected at most {}, found {}\",\n                              expected_text, actual_text)\n                 .span_label(span, format!(\"expected {}\", expected_text))\n                 .emit();\n-        } else if lifetimes.len() < required_len && !infer_lifetimes {\n-            let expected_text = count_lifetime_params(lifetime_defs.len());\n+        } else if lifetimes.len() < lt_accepted && !infer_lifetimes {\n+            let expected_text = count_lifetime_params(lt_accepted);\n             let actual_text = count_lifetime_params(lifetimes.len());\n             struct_span_err!(self.tcx.sess, span, E0090,\n                              \"too few lifetime parameters provided: \\\n@@ -5010,17 +5035,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         span: Span,\n                         segment: &mut Option<(&hir::PathSegment, &ty::Generics)>)\n                         -> bool {\n-        use hir::SyntheticTyParamKind::*;\n-\n         let segment = segment.map(|(path_segment, generics)| {\n             let explicit = !path_segment.infer_types;\n-            let impl_trait = generics.types.iter()\n-                                           .any(|ty_param| {\n-                                               match ty_param.synthetic {\n-                                                   Some(ImplTrait) => true,\n-                                                   _ => false,\n-                                               }\n-                                           });\n+            let impl_trait = generics.params.iter().any(|param| {\n+                if let ty::GenericParamDefKind::Type(ty) = param.kind {\n+                    if let Some(hir::SyntheticTyParamKind::ImplTrait) = ty.synthetic {\n+                        return true;\n+                    }\n+                }\n+                false\n+            });\n \n             if explicit && impl_trait {\n                 let mut err = struct_span_err! {"}, {"sha": "6b873c093c02f616b11e9c58b247ba4b78f668a2", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -13,7 +13,8 @@ use constrained_type_params::{identify_constrained_type_params, Parameter};\n \n use hir::def_id::DefId;\n use rustc::traits::{self, ObligationCauseCode};\n-use rustc::ty::{self, Lift, Ty, TyCtxt};\n+use rustc::ty::{self, Lift, Ty, TyCtxt, GenericParamDefKind};\n+use rustc::ty::subst::Substs;\n use rustc::ty::util::ExplicitSelf;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc::middle::lang_items;\n@@ -187,7 +188,7 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 fcx.register_wf_obligation(ty, span, code.clone());\n             }\n             ty::AssociatedKind::Method => {\n-                reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n+                reject_shadowing_parameters(fcx.tcx, item.def_id);\n                 let sig = fcx.tcx.fn_sig(item.def_id);\n                 let sig = fcx.normalize_associated_types_in(span, &sig);\n                 check_fn_or_method(tcx, fcx, span, sig,\n@@ -368,21 +369,31 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     let mut substituted_predicates = Vec::new();\n \n     let generics = tcx.generics_of(def_id);\n-    let is_our_default = |def: &ty::TypeParameterDef|\n-                            def.has_default && def.index >= generics.parent_count() as u32;\n+    let is_our_default = |def: &ty::GenericParamDef| {\n+        match def.kind {\n+            GenericParamDefKind::Type(ty) => {\n+                ty.has_default && def.index >= generics.parent_count as u32\n+            }\n+            _ => unreachable!()\n+        }\n+    };\n \n     // Check that concrete defaults are well-formed. See test `type-check-defaults.rs`.\n     // For example this forbids the declaration:\n     // struct Foo<T = Vec<[u32]>> { .. }\n     // Here the default `Vec<[u32]>` is not WF because `[u32]: Sized` does not hold.\n-    for d in generics.types.iter().cloned().filter(is_our_default).map(|p| p.def_id) {\n-        let ty = fcx.tcx.type_of(d);\n-        // ignore dependent defaults -- that is, where the default of one type\n-        // parameter includes another (e.g., <T, U = T>). In those cases, we can't\n-        // be sure if it will error or not as user might always specify the other.\n-        if !ty.needs_subst() {\n-            fcx.register_wf_obligation(ty, fcx.tcx.def_span(d),\n-                ObligationCauseCode::MiscObligation);\n+    for param in &generics.params {\n+        if let GenericParamDefKind::Type(_) = param.kind {\n+            if is_our_default(&param) {\n+                let ty = fcx.tcx.type_of(param.def_id);\n+                // ignore dependent defaults -- that is, where the default of one type\n+                // parameter includes another (e.g., <T, U = T>). In those cases, we can't\n+                // be sure if it will error or not as user might always specify the other.\n+                if !ty.needs_subst() {\n+                    fcx.register_wf_obligation(ty, fcx.tcx.def_span(param.def_id),\n+                        ObligationCauseCode::MiscObligation);\n+                }\n+            }\n         }\n     }\n \n@@ -394,22 +405,27 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     // For more examples see tests `defaults-well-formedness.rs` and `type-check-defaults.rs`.\n     //\n     // First we build the defaulted substitution.\n-    let substs = ty::subst::Substs::for_item(fcx.tcx, def_id, |def, _| {\n-            // All regions are identity.\n-            fcx.tcx.mk_region(ty::ReEarlyBound(def.to_early_bound_region_data()))\n-        }, |def, _| {\n-            // If the param has a default,\n-            if is_our_default(def) {\n-                let default_ty = fcx.tcx.type_of(def.def_id);\n-                // and it's not a dependent default\n-                if !default_ty.needs_subst() {\n-                    // then substitute with the default.\n-                    return default_ty;\n+    let substs = Substs::for_item(fcx.tcx, def_id, |param, _| {\n+        match param.kind {\n+            GenericParamDefKind::Lifetime => {\n+                // All regions are identity.\n+                fcx.tcx.mk_param_from_def(param)\n+            }\n+            GenericParamDefKind::Type(_) => {\n+                // If the param has a default,\n+                if is_our_default(param) {\n+                    let default_ty = fcx.tcx.type_of(param.def_id);\n+                    // and it's not a dependent default\n+                    if !default_ty.needs_subst() {\n+                        // then substitute with the default.\n+                        return default_ty.into();\n+                    }\n                 }\n+                // Mark unwanted params as err.\n+                fcx.tcx.types.err.into()\n             }\n-            // Mark unwanted params as err.\n-            fcx.tcx.types.err\n-        });\n+        }\n+    });\n     // Now we build the substituted predicates.\n     for &pred in predicates.predicates.iter() {\n         struct CountParams { params: FxHashSet<u32> }\n@@ -638,15 +654,25 @@ fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     err.emit();\n }\n \n-fn reject_shadowing_type_parameters(tcx: TyCtxt, def_id: DefId) {\n+fn reject_shadowing_parameters(tcx: TyCtxt, def_id: DefId) {\n     let generics = tcx.generics_of(def_id);\n     let parent = tcx.generics_of(generics.parent.unwrap());\n-    let impl_params: FxHashMap<_, _> = parent.types\n-                                       .iter()\n-                                       .map(|tp| (tp.name, tp.def_id))\n-                                       .collect();\n-\n-    for method_param in &generics.types {\n+    let impl_params: FxHashMap<_, _> =\n+        parent.params.iter()\n+                     .flat_map(|param| {\n+                         match param.kind {\n+                             GenericParamDefKind::Lifetime => None,\n+                             GenericParamDefKind::Type(_) => Some((param.name, param.def_id)),\n+                         }\n+                     })\n+                     .collect();\n+\n+    for method_param in generics.params.iter() {\n+        match method_param.kind {\n+            // Shadowing is checked in resolve_lifetime.\n+            GenericParamDefKind::Lifetime => continue,\n+            _ => {},\n+        };\n         if impl_params.contains_key(&method_param.name) {\n             // Tighten up the span to focus on only the shadowing type\n             let type_span = tcx.def_span(method_param.def_id);"}, {"sha": "c2dde2d2e014b1f7fb403adb82c5cc43e71055d5", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 48, "deletions": 50, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -181,7 +181,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         self.tcx.at(span).type_param_predicates((self.item_def_id, def_id))\n     }\n \n-    fn re_infer(&self, _span: Span, _def: Option<&ty::RegionParameterDef>)\n+    fn re_infer(&self, _span: Span, _def: Option<&ty::GenericParamDef>)\n                 -> Option<ty::Region<'tcx>> {\n         None\n     }\n@@ -243,8 +243,8 @@ fn type_param_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let param_owner = tcx.hir.ty_param_owner(param_id);\n     let param_owner_def_id = tcx.hir.local_def_id(param_owner);\n     let generics = tcx.generics_of(param_owner_def_id);\n-    let index = generics.type_param_to_index[&def_id];\n-    let ty = tcx.mk_param(index, tcx.hir.ty_param_name(param_id).as_interned_str());\n+    let index = generics.param_def_id_to_index[&def_id];\n+    let ty = tcx.mk_ty_param(index, tcx.hir.ty_param_name(param_id).as_interned_str());\n \n     // Don't look for bounds where the type parameter isn't in scope.\n     let parent = if item_def_id == param_owner_def_id {\n@@ -840,14 +840,16 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     // the node id for the Self type parameter.\n                     let param_id = item.id;\n \n-                    opt_self = Some(ty::TypeParameterDef {\n+                    opt_self = Some(ty::GenericParamDef {\n                         index: 0,\n                         name: keywords::SelfType.name().as_interned_str(),\n                         def_id: tcx.hir.local_def_id(param_id),\n-                        has_default: false,\n-                        object_lifetime_default: rl::Set1::Empty,\n                         pure_wrt_drop: false,\n-                        synthetic: None,\n+                        kind: ty::GenericParamDefKind::Type(ty::TypeParamDef {\n+                            has_default: false,\n+                            object_lifetime_default: rl::Set1::Empty,\n+                            synthetic: None,\n+                        }),\n                     });\n \n                     allow_defaults = true;\n@@ -876,31 +878,33 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let has_self = opt_self.is_some();\n     let mut parent_has_self = false;\n     let mut own_start = has_self as u32;\n-    let (parent_regions, parent_types) = parent_def_id.map_or((0, 0), |def_id| {\n+    let parent_count = parent_def_id.map_or(0, |def_id| {\n         let generics = tcx.generics_of(def_id);\n         assert_eq!(has_self, false);\n         parent_has_self = generics.has_self;\n         own_start = generics.count() as u32;\n-        (generics.parent_regions + generics.regions.len() as u32,\n-            generics.parent_types + generics.types.len() as u32)\n+        generics.parent_count + generics.params.len()\n     });\n \n+    let mut params: Vec<_> = opt_self.into_iter().collect();\n+\n     let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n-    let regions = early_lifetimes.enumerate().map(|(i, l)| {\n-        ty::RegionParameterDef {\n+    params.extend(early_lifetimes.enumerate().map(|(i, l)| {\n+        ty::GenericParamDef {\n             name: l.lifetime.name.name().as_interned_str(),\n             index: own_start + i as u32,\n             def_id: tcx.hir.local_def_id(l.lifetime.id),\n             pure_wrt_drop: l.pure_wrt_drop,\n+            kind: ty::GenericParamDefKind::Lifetime,\n         }\n-    }).collect::<Vec<_>>();\n+    }));\n \n     let hir_id = tcx.hir.node_to_hir_id(node_id);\n     let object_lifetime_defaults = tcx.object_lifetime_defaults(hir_id);\n \n     // Now create the real type parameters.\n-    let type_start = own_start + regions.len() as u32;\n-    let types = ast_generics.ty_params().enumerate().map(|(i, p)| {\n+    let type_start = own_start - has_self as u32 + params.len() as u32;\n+    params.extend(ast_generics.ty_params().enumerate().map(|(i, p)| {\n         if p.name == keywords::SelfType.name() {\n             span_bug!(p.span, \"`Self` should not be the name of a regular parameter\");\n         }\n@@ -916,19 +920,19 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         }\n \n-        ty::TypeParameterDef {\n+        ty::GenericParamDef {\n             index: type_start + i as u32,\n             name: p.name.as_interned_str(),\n             def_id: tcx.hir.local_def_id(p.id),\n-            has_default: p.default.is_some(),\n-            object_lifetime_default:\n-                object_lifetime_defaults.as_ref().map_or(rl::Set1::Empty, |o| o[i]),\n             pure_wrt_drop: p.pure_wrt_drop,\n-            synthetic: p.synthetic,\n+            kind: ty::GenericParamDefKind::Type(ty::TypeParamDef {\n+                has_default: p.default.is_some(),\n+                object_lifetime_default:\n+                    object_lifetime_defaults.as_ref().map_or(rl::Set1::Empty, |o| o[i]),\n+                synthetic: p.synthetic,\n+            }),\n         }\n-    });\n-\n-    let mut types: Vec<_> = opt_self.into_iter().chain(types).collect();\n+    }));\n \n     // provide junk type parameter defs - the only place that\n     // cares about anything but the length is instantiation,\n@@ -941,43 +945,45 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n \n         for (i, &arg) in dummy_args.iter().enumerate() {\n-            types.push(ty::TypeParameterDef {\n+            params.push(ty::GenericParamDef {\n                 index: type_start + i as u32,\n                 name: Symbol::intern(arg).as_interned_str(),\n                 def_id,\n-                has_default: false,\n-                object_lifetime_default: rl::Set1::Empty,\n                 pure_wrt_drop: false,\n-                synthetic: None,\n+                kind: ty::GenericParamDefKind::Type(ty::TypeParamDef {\n+                    has_default: false,\n+                    object_lifetime_default: rl::Set1::Empty,\n+                    synthetic: None,\n+                }),\n             });\n         }\n \n         tcx.with_freevars(node_id, |fv| {\n-            types.extend(fv.iter().zip((dummy_args.len() as u32)..).map(|(_, i)| {\n-                ty::TypeParameterDef {\n+            params.extend(fv.iter().zip((dummy_args.len() as u32)..).map(|(_, i)| {\n+                ty::GenericParamDef {\n                     index: type_start + i,\n                     name: Symbol::intern(\"<upvar>\").as_interned_str(),\n                     def_id,\n-                    has_default: false,\n-                    object_lifetime_default: rl::Set1::Empty,\n                     pure_wrt_drop: false,\n-                    synthetic: None,\n+                    kind: ty::GenericParamDefKind::Type(ty::TypeParamDef {\n+                        has_default: false,\n+                        object_lifetime_default: rl::Set1::Empty,\n+                        synthetic: None,\n+                    }),\n                 }\n             }));\n         });\n     }\n \n-    let type_param_to_index = types.iter()\n-                                   .map(|param| (param.def_id, param.index))\n-                                   .collect();\n+    let param_def_id_to_index = params.iter()\n+                                      .map(|param| (param.def_id, param.index))\n+                                      .collect();\n \n     tcx.alloc_generics(ty::Generics {\n         parent: parent_def_id,\n-        parent_regions,\n-        parent_types,\n-        regions,\n-        types,\n-        type_param_to_index,\n+        parent_count,\n+        params,\n+        param_def_id_to_index,\n         has_self: has_self || parent_has_self,\n         has_late_bound_regions: has_late_bound_regions(tcx, node),\n     })\n@@ -1090,15 +1096,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             let substs = ty::ClosureSubsts {\n-                substs: Substs::for_item(\n-                    tcx,\n-                    def_id,\n-                    |def, _| {\n-                        let region = def.to_early_bound_region_data();\n-                        tcx.mk_region(ty::ReEarlyBound(region))\n-                    },\n-                    |def, _| tcx.mk_param_from_def(def)\n-                )\n+                substs: Substs::identity_for_item(tcx, def_id),\n             };\n \n             tcx.mk_closure(def_id, substs)\n@@ -1390,7 +1388,7 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     let generics = tcx.generics_of(def_id);\n-    let parent_count = generics.parent_count() as u32;\n+    let parent_count = generics.parent_count as u32;\n     let has_own_self = generics.has_self && parent_count == 0;\n \n     let mut predicates = vec![];"}, {"sha": "80dde814c6638a529eee689fc4b0e552150f37cd", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -72,10 +72,9 @@ struct ImplWfCheck<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n-            hir::ItemImpl(.., ref generics, _, _, ref impl_item_refs) => {\n+            hir::ItemImpl(.., ref impl_item_refs) => {\n                 let impl_def_id = self.tcx.hir.local_def_id(item.id);\n                 enforce_impl_params_are_constrained(self.tcx,\n-                                                    generics,\n                                                     impl_def_id,\n                                                     impl_item_refs);\n                 enforce_impl_items_are_distinct(self.tcx, impl_item_refs);\n@@ -90,7 +89,6 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n }\n \n fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 impl_hir_generics: &hir::Generics,\n                                                  impl_def_id: DefId,\n                                                  impl_item_refs: &[hir::ImplItemRef])\n {\n@@ -104,35 +102,39 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ctp::identify_constrained_type_params(\n         tcx, &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n \n-    // Disallow ANY unconstrained type parameters.\n-    for (ty_param, param) in impl_generics.types.iter().zip(impl_hir_generics.ty_params()) {\n-        let param_ty = ty::ParamTy::for_def(ty_param);\n-        if !input_parameters.contains(&ctp::Parameter::from(param_ty)) {\n-            report_unused_parameter(tcx, param.span, \"type\", &param_ty.to_string());\n-        }\n-    }\n-\n     // Disallow unconstrained lifetimes, but only if they appear in assoc types.\n     let lifetimes_in_associated_types: FxHashSet<_> = impl_item_refs.iter()\n-        .map(|item_ref|  tcx.hir.local_def_id(item_ref.id.node_id))\n+        .map(|item_ref| tcx.hir.local_def_id(item_ref.id.node_id))\n         .filter(|&def_id| {\n             let item = tcx.associated_item(def_id);\n             item.kind == ty::AssociatedKind::Type && item.defaultness.has_value()\n         })\n         .flat_map(|def_id| {\n             ctp::parameters_for(&tcx.type_of(def_id), true)\n         }).collect();\n-    for (ty_lifetime, lifetime) in impl_generics.regions.iter()\n-        .zip(impl_hir_generics.lifetimes())\n-    {\n-        let param = ctp::Parameter::from(ty_lifetime.to_early_bound_region_data());\n \n-        if\n-            lifetimes_in_associated_types.contains(&param) && // (*)\n-            !input_parameters.contains(&param)\n-        {\n-            report_unused_parameter(tcx, lifetime.lifetime.span,\n-                                    \"lifetime\", &lifetime.lifetime.name.name().to_string());\n+    for param in &impl_generics.params {\n+        match param.kind {\n+            // Disallow ANY unconstrained type parameters.\n+            ty::GenericParamDefKind::Type(_) => {\n+                let param_ty = ty::ParamTy::for_def(param);\n+                if !input_parameters.contains(&ctp::Parameter::from(param_ty)) {\n+                    report_unused_parameter(tcx,\n+                                            tcx.def_span(param.def_id),\n+                                            \"type\",\n+                                            &param_ty.to_string());\n+                }\n+            }\n+            ty::GenericParamDefKind::Lifetime => {\n+                let param_lt = ctp::Parameter::from(param.to_early_bound_region_data());\n+                if lifetimes_in_associated_types.contains(&param_lt) && // (*)\n+                    !input_parameters.contains(&param_lt) {\n+                    report_unused_parameter(tcx,\n+                                            tcx.def_span(param.def_id),\n+                                            \"lifetime\",\n+                                            &param.name.to_string());\n+                }\n+            }\n         }\n     }\n "}, {"sha": "e711598c944c12ba0031efe79c08b8e8f656ac47", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -353,7 +353,7 @@ fn insert_outlives_predicate<'tcx>(\n                         // Vec<U>`.  Decomposing `Vec<U>` into\n                         // components would yield `U`, and we add the\n                         // where clause that `U: 'a`.\n-                        let ty: Ty<'tcx> = tcx.mk_param(param_ty.idx, param_ty.name);\n+                        let ty: Ty<'tcx> = tcx.mk_ty_param(param_ty.idx, param_ty.name);\n                         required_predicates\n                             .insert(ty::OutlivesPredicate(ty.into(), outlived_region));\n                     }"}, {"sha": "d7646ce7bfc5ca4fb24dded85c7ca43bfb765438", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -224,42 +224,39 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n     }\n \n     fn generics_to_path_params(&self, generics: ty::Generics) -> hir::PathParameters {\n-        let lifetimes = HirVec::from_vec(\n-            generics\n-                .regions\n-                .iter()\n-                .map(|p| {\n-                    let name = if p.name == \"\" {\n+        let mut lifetimes = vec![];\n+        let mut types = vec![];\n+\n+        for param in generics.params.iter() {\n+            match param.kind {\n+                ty::GenericParamDefKind::Lifetime => {\n+                    let name = if param.name == \"\" {\n                         hir::LifetimeName::Static\n                     } else {\n-                        hir::LifetimeName::Name(p.name.as_symbol())\n+                        hir::LifetimeName::Name(param.name.as_symbol())\n                     };\n \n-                    hir::Lifetime {\n+                    lifetimes.push(hir::Lifetime {\n                         id: ast::DUMMY_NODE_ID,\n                         span: DUMMY_SP,\n                         name,\n-                    }\n-                })\n-                .collect(),\n-        );\n-        let types = HirVec::from_vec(\n-            generics\n-                .types\n-                .iter()\n-                .map(|p| P(self.ty_param_to_ty(p.clone())))\n-                .collect(),\n-        );\n+                    });\n+                }\n+                ty::GenericParamDefKind::Type(_) => {\n+                    types.push(P(self.ty_param_to_ty(param.clone())));\n+                }\n+            }\n+        }\n \n         hir::PathParameters {\n-            lifetimes: lifetimes,\n-            types: types,\n+            lifetimes: HirVec::from_vec(lifetimes),\n+            types: HirVec::from_vec(types),\n             bindings: HirVec::new(),\n             parenthesized: false,\n         }\n     }\n \n-    fn ty_param_to_ty(&self, param: ty::TypeParameterDef) -> hir::Ty {\n+    fn ty_param_to_ty(&self, param: ty::GenericParamDef) -> hir::Ty {\n         debug!(\"ty_param_to_ty({:?}) {:?}\", param, param.def_id);\n         hir::Ty {\n             id: ast::DUMMY_NODE_ID,\n@@ -494,7 +491,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         &self,\n         tcx: TyCtxt<'b, 'c, 'd>,\n         pred: ty::Predicate<'d>,\n-    ) -> FxHashSet<GenericParam> {\n+    ) -> FxHashSet<GenericParamDef> {\n         pred.walk_tys()\n             .flat_map(|t| {\n                 let mut regions = FxHashSet();\n@@ -505,7 +502,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                         // We only care about late bound regions, as we need to add them\n                         // to the 'for<>' section\n                         &ty::ReLateBound(_, ty::BoundRegion::BrNamed(_, name)) => {\n-                            Some(GenericParam::Lifetime(Lifetime(name.to_string())))\n+                            Some(GenericParamDef::Lifetime(Lifetime(name.to_string())))\n                         }\n                         &ty::ReVar(_) | &ty::ReEarlyBound(_) => None,\n                         _ => panic!(\"Unexpected region type {:?}\", r),\n@@ -853,7 +850,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n \n         for p in generic_params.iter_mut() {\n             match p {\n-                &mut GenericParam::Type(ref mut ty) => {\n+                &mut GenericParamDef::Type(ref mut ty) => {\n                     // We never want something like 'impl<T=Foo>'\n                     ty.default.take();\n \n@@ -863,7 +860,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                         ty.bounds.insert(0, TyParamBound::maybe_sized(self.cx));\n                     }\n                 }\n-                _ => {}\n+                GenericParamDef::Lifetime(_) => {}\n             }\n         }\n "}, {"sha": "a1d77f4145b83f19f77a2c2bcf707035fce13bb0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 77, "deletions": 52, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -41,7 +41,7 @@ use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::def_id::DefIndexAddressSpace;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n+use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind, GenericParamCount};\n use rustc::middle::stability;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_typeck::hir_ty_to_ty;\n@@ -1336,14 +1336,18 @@ impl Clean<TyParam> for hir::TyParam {\n     }\n }\n \n-impl<'tcx> Clean<TyParam> for ty::TypeParameterDef {\n+impl<'tcx> Clean<TyParam> for ty::GenericParamDef {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n         cx.renderinfo.borrow_mut().external_typarams.insert(self.def_id, self.name.clean(cx));\n+        let has_default = match self.kind {\n+            ty::GenericParamDefKind::Type(ty) => ty.has_default,\n+            _ => panic!(\"tried to convert a non-type GenericParamDef as a type\")\n+        };\n         TyParam {\n             name: self.name.clean(cx),\n             did: self.def_id,\n             bounds: vec![], // these are filled in from the where-clauses\n-            default: if self.has_default {\n+            default: if has_default {\n                 Some(cx.tcx.type_of(self.def_id).clean(cx))\n             } else {\n                 None\n@@ -1484,7 +1488,7 @@ impl<'a, 'tcx> Clean<TyParamBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>\n                         if let &ty::RegionKind::ReLateBound(..) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n                             if let Some(lt) = reg.clean(cx) {\n-                                late_bounds.push(GenericParam::Lifetime(lt));\n+                                late_bounds.push(GenericParamDef::Lifetime(lt));\n                             }\n                         }\n                     }\n@@ -1577,8 +1581,8 @@ impl Clean<Lifetime> for hir::LifetimeDef {\n     }\n }\n \n-impl Clean<Lifetime> for ty::RegionParameterDef {\n-    fn clean(&self, _: &DocContext) -> Lifetime {\n+impl<'tcx> Clean<Lifetime> for ty::GenericParamDef {\n+    fn clean(&self, _cx: &DocContext) -> Lifetime {\n         Lifetime(self.name.to_string())\n     }\n }\n@@ -1718,34 +1722,33 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericParam {\n+pub enum GenericParamDef {\n     Lifetime(Lifetime),\n     Type(TyParam),\n }\n \n-impl GenericParam {\n+impl GenericParamDef {\n     pub fn is_synthetic_type_param(&self) -> bool {\n-        if let GenericParam::Type(ref t) = *self {\n-            t.synthetic.is_some()\n-        } else {\n-            false\n+        match self {\n+            GenericParamDef::Type(ty) => ty.synthetic.is_some(),\n+            GenericParamDef::Lifetime(_) => false,\n         }\n     }\n }\n \n-impl Clean<GenericParam> for hir::GenericParam {\n-    fn clean(&self, cx: &DocContext) -> GenericParam {\n+impl Clean<GenericParamDef> for hir::GenericParam {\n+    fn clean(&self, cx: &DocContext) -> GenericParamDef {\n         match *self {\n-            hir::GenericParam::Lifetime(ref l) => GenericParam::Lifetime(l.clean(cx)),\n-            hir::GenericParam::Type(ref t) => GenericParam::Type(t.clean(cx)),\n+            hir::GenericParam::Lifetime(ref l) => GenericParamDef::Lifetime(l.clean(cx)),\n+            hir::GenericParam::Type(ref t) => GenericParamDef::Type(t.clean(cx)),\n         }\n     }\n }\n \n // maybe use a Generic enum and use Vec<Generic>?\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Default, Hash)]\n pub struct Generics {\n-    pub params: Vec<GenericParam>,\n+    pub params: Vec<GenericParamDef>,\n     pub where_predicates: Vec<WherePredicate>,\n }\n \n@@ -1754,7 +1757,7 @@ impl Clean<Generics> for hir::Generics {\n         let mut params = Vec::with_capacity(self.params.len());\n         for p in &self.params {\n             let p = p.clean(cx);\n-            if let GenericParam::Type(ref tp) = p {\n+            if let GenericParamDef::Type(ref tp) = p {\n                 if tp.synthetic == Some(hir::SyntheticTyParamKind::ImplTrait) {\n                     cx.impl_trait_bounds.borrow_mut().insert(tp.did, tp.bounds.clone());\n                 }\n@@ -1774,7 +1777,7 @@ impl Clean<Generics> for hir::Generics {\n                 WherePredicate::BoundPredicate { ty: Generic(ref name), ref mut bounds } => {\n                     if bounds.is_empty() {\n                         for param in &mut g.params {\n-                            if let GenericParam::Type(ref mut type_param) = *param {\n+                            if let GenericParamDef::Type(ref mut type_param) = *param {\n                                 if &type_param.name == name {\n                                     mem::swap(bounds, &mut type_param.bounds);\n                                     break\n@@ -1800,14 +1803,18 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         // Bounds in the type_params and lifetimes fields are repeated in the\n         // predicates field (see rustc_typeck::collect::ty_generics), so remove\n         // them.\n-        let stripped_typarams = gens.types.iter().filter_map(|tp| {\n-            if tp.name == keywords::SelfType.name().as_str() {\n-                assert_eq!(tp.index, 0);\n-                None\n+        let stripped_typarams = gens.params.iter().filter_map(|param| {\n+            if let ty::GenericParamDefKind::Type(_) = param.kind {\n+                if param.name == keywords::SelfType.name().as_str() {\n+                    assert_eq!(param.index, 0);\n+                    None\n+                } else {\n+                    Some(param.clean(cx))\n+                }\n             } else {\n-                Some(tp.clean(cx))\n+                None\n             }\n-        }).collect::<Vec<_>>();\n+        }).collect::<Vec<TyParam>>();\n \n         let mut where_predicates = preds.predicates.to_vec().clean(cx);\n \n@@ -1849,16 +1856,20 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         // and instead see `where T: Foo + Bar + Sized + 'a`\n \n         Generics {\n-            params: gens.regions\n-                .clean(cx)\n-                .into_iter()\n-                .map(|lp| GenericParam::Lifetime(lp))\n-                .chain(\n-                    simplify::ty_params(stripped_typarams)\n-                        .into_iter()\n-                        .map(|tp| GenericParam::Type(tp))\n-                )\n-                .collect(),\n+            params: gens.params\n+                        .iter()\n+                        .flat_map(|param| {\n+                            if let ty::GenericParamDefKind::Lifetime = param.kind {\n+                                Some(GenericParamDef::Lifetime(param.clean(cx)))\n+                            } else {\n+                                None\n+                            }\n+                        }).chain(\n+                            simplify::ty_params(stripped_typarams)\n+                                .into_iter()\n+                                .map(|tp| GenericParamDef::Type(tp))\n+                        )\n+                        .collect(),\n             where_predicates: simplify::where_clauses(cx, where_predicates),\n         }\n     }\n@@ -2349,7 +2360,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct PolyTrait {\n     pub trait_: Type,\n-    pub generic_params: Vec<GenericParam>,\n+    pub generic_params: Vec<GenericParamDef>,\n }\n \n /// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n@@ -2676,20 +2687,34 @@ impl Clean<Type> for hir::Ty {\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n                     provided_params.with_parameters(|provided_params| {\n-                        for (i, ty_param) in generics.ty_params().enumerate() {\n-                            let ty_param_def = Def::TyParam(cx.tcx.hir.local_def_id(ty_param.id));\n-                            if let Some(ty) = provided_params.types.get(i).cloned() {\n-                                ty_substs.insert(ty_param_def, ty.into_inner().clean(cx));\n-                            } else if let Some(default) = ty_param.default.clone() {\n-                                ty_substs.insert(ty_param_def, default.into_inner().clean(cx));\n-                            }\n-                        }\n-\n-                        for (i, lt_param) in generics.lifetimes().enumerate() {\n-                            if let Some(lt) = provided_params.lifetimes.get(i).cloned() {\n-                                if !lt.is_elided() {\n-                                    let lt_def_id = cx.tcx.hir.local_def_id(lt_param.lifetime.id);\n-                                    lt_substs.insert(lt_def_id, lt.clean(cx));\n+                        let mut indices = GenericParamCount {\n+                            lifetimes: 0,\n+                            types: 0\n+                        };\n+                        for param in generics.params.iter() {\n+                            match param {\n+                                hir::GenericParam::Lifetime(lt_param) => {\n+                                    if let Some(lt) = provided_params.lifetimes\n+                                        .get(indices.lifetimes).cloned() {\n+                                        if !lt.is_elided() {\n+                                            let lt_def_id =\n+                                                cx.tcx.hir.local_def_id(lt_param.lifetime.id);\n+                                            lt_substs.insert(lt_def_id, lt.clean(cx));\n+                                        }\n+                                    }\n+                                    indices.lifetimes += 1;\n+                                }\n+                                hir::GenericParam::Type(ty_param) => {\n+                                    let ty_param_def =\n+                                        Def::TyParam(cx.tcx.hir.local_def_id(ty_param.id));\n+                                    if let Some(ty) = provided_params.types\n+                                        .get(indices.types).cloned() {\n+                                        ty_substs.insert(ty_param_def, ty.into_inner().clean(cx));\n+                                    } else if let Some(default) = ty_param.default.clone() {\n+                                        ty_substs.insert(ty_param_def,\n+                                                         default.into_inner().clean(cx));\n+                                    }\n+                                    indices.types += 1;\n                                 }\n                             }\n                         }\n@@ -3425,7 +3450,7 @@ impl Clean<Item> for doctree::Typedef {\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct BareFunctionDecl {\n     pub unsafety: hir::Unsafety,\n-    pub generic_params: Vec<GenericParam>,\n+    pub generic_params: Vec<GenericParamDef>,\n     pub decl: FnDecl,\n     pub abi: Abi,\n }\n@@ -4184,7 +4209,7 @@ struct RegionDeps<'tcx> {\n #[derive(Eq, PartialEq, Hash, Debug)]\n enum SimpleBound {\n     RegionBound(Lifetime),\n-    TraitBound(Vec<PathSegment>, Vec<SimpleBound>, Vec<GenericParam>, hir::TraitBoundModifier)\n+    TraitBound(Vec<PathSegment>, Vec<SimpleBound>, Vec<GenericParamDef>, hir::TraitBoundModifier)\n }\n \n enum AutoTraitResult {"}, {"sha": "40dcd6e891fe8cfba1161c4335c4fd7c33c2b580", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -117,11 +117,11 @@ impl<'a> fmt::Display for TyParamBounds<'a> {\n     }\n }\n \n-impl fmt::Display for clean::GenericParam {\n+impl fmt::Display for clean::GenericParamDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            clean::GenericParam::Lifetime(ref lp) => write!(f, \"{}\", lp),\n-            clean::GenericParam::Type(ref tp) => {\n+            clean::GenericParamDef::Lifetime(ref lp) => write!(f, \"{}\", lp),\n+            clean::GenericParamDef::Type(ref tp) => {\n                 f.write_str(&tp.name)?;\n \n                 if !tp.bounds.is_empty() {"}, {"sha": "109765b6711979899ac0513fe7a0990609101249", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -1453,8 +1453,11 @@ impl DocFolder for Cache {\n impl<'a> Cache {\n     fn generics(&mut self, generics: &clean::Generics) {\n         for param in &generics.params {\n-            if let clean::GenericParam::Type(ref typ) = *param {\n-                self.typarams.insert(typ.did, typ.name.clone());\n+            match *param {\n+                clean::GenericParamDef::Type(ref typ) => {\n+                    self.typarams.insert(typ.did, typ.name.clone());\n+                }\n+                clean::GenericParamDef::Lifetime(_) => {}\n             }\n         }\n     }"}, {"sha": "7ef155e5f2ebece26ddc962389863f4f1bc7d023", "filename": "src/test/ui/on-unimplemented/bad-annotation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.rs?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -28,7 +28,7 @@ trait BadAnnotation1\n {}\n \n #[rustc_on_unimplemented = \"Unimplemented trait error on `{Self}` with params `<{A},{B},{C}>`\"]\n-//~^ ERROR there is no type parameter C on trait BadAnnotation2\n+//~^ ERROR there is no parameter C on trait BadAnnotation2\n trait BadAnnotation2<A,B>\n {}\n "}, {"sha": "1c5d4d603afc662d6cae88914ec8a29104a74eb9", "filename": "src/test/ui/on-unimplemented/bad-annotation.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e44fc6c52d9674ed09958512e3bf09bc55bccecf/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.stderr?ref=e44fc6c52d9674ed09958512e3bf09bc55bccecf", "patch": "@@ -6,7 +6,7 @@ LL | #[rustc_on_unimplemented] //~ ERROR `#[rustc_on_unimplemented]` requires a\n    |\n    = note: eg `#[rustc_on_unimplemented = \"foo\"]`\n \n-error[E0230]: there is no type parameter C on trait BadAnnotation2\n+error[E0230]: there is no parameter C on trait BadAnnotation2\n   --> $DIR/bad-annotation.rs:30:1\n    |\n LL | #[rustc_on_unimplemented = \"Unimplemented trait error on `{Self}` with params `<{A},{B},{C}>`\"]"}]}