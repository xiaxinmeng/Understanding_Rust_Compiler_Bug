{"sha": "9907fa4acc2af5b2b07d1362b3ceb29171954c58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5MDdmYTRhY2MyYWY1YjJiMDdkMTM2MmIzY2ViMjkxNzE5NTRjNTg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-08-04T20:56:56Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-08-14T18:40:22Z"}, "message": "librustc: Stop assuming that implementations and traits only contain\nmethods.\n\nThis paves the way to associated items by introducing an extra level of\nabstraction (\"impl-or-trait item\") between traits/implementations and\nmethods. This new abstraction is encoded in the metadata and used\nthroughout the compiler where appropriate.\n\nThere are no functional changes; this is purely a refactoring.", "tree": {"sha": "6acf4c541c9321d8a304eb16f486b09755983c52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6acf4c541c9321d8a304eb16f486b09755983c52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9907fa4acc2af5b2b07d1362b3ceb29171954c58", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9907fa4acc2af5b2b07d1362b3ceb29171954c58", "html_url": "https://github.com/rust-lang/rust/commit/9907fa4acc2af5b2b07d1362b3ceb29171954c58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9907fa4acc2af5b2b07d1362b3ceb29171954c58/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "404978ea722c0257cc763540c93243e8a21f82ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/404978ea722c0257cc763540c93243e8a21f82ed", "html_url": "https://github.com/rust-lang/rust/commit/404978ea722c0257cc763540c93243e8a21f82ed"}], "stats": {"total": 3046, "additions": 1926, "deletions": 1120}, "files": [{"sha": "93320caf5f2819c8f4c115942cb9dc3f899be10d", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -109,10 +109,14 @@ fn fold_foreign_mod(cx: &mut Context, nm: &ast::ForeignMod) -> ast::ForeignMod {\n \n fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n     let item = match *item {\n-        ast::ItemImpl(ref a, ref b, c, ref methods) => {\n-            let methods = methods.iter().filter(|m| method_in_cfg(cx, &***m))\n-                .map(|x| *x).collect();\n-            ast::ItemImpl((*a).clone(), (*b).clone(), c, methods)\n+        ast::ItemImpl(ref a, ref b, c, ref impl_items) => {\n+            let impl_items = impl_items.iter()\n+                                       .filter(|ii| {\n+                                           impl_item_in_cfg(cx, &**ii)\n+                                       })\n+                                       .map(|x| *x)\n+                                       .collect();\n+            ast::ItemImpl((*a).clone(), (*b).clone(), c, impl_items)\n         }\n         ast::ItemTrait(ref a, ref b, ref c, ref methods) => {\n             let methods = methods.iter()\n@@ -230,14 +234,16 @@ fn view_item_in_cfg(cx: &mut Context, item: &ast::ViewItem) -> bool {\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn method_in_cfg(cx: &mut Context, meth: &ast::Method) -> bool {\n-    return (cx.in_cfg)(meth.attrs.as_slice());\n+fn trait_method_in_cfg(cx: &mut Context, meth: &ast::TraitItem) -> bool {\n+    match *meth {\n+        ast::RequiredMethod(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n+        ast::ProvidedMethod(meth) => (cx.in_cfg)(meth.attrs.as_slice())\n+    }\n }\n \n-fn trait_method_in_cfg(cx: &mut Context, meth: &ast::TraitMethod) -> bool {\n-    match *meth {\n-        ast::Required(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n-        ast::Provided(meth) => (cx.in_cfg)(meth.attrs.as_slice())\n+fn impl_item_in_cfg(cx: &mut Context, impl_item: &ast::ImplItem) -> bool {\n+    match *impl_item {\n+        ast::MethodImplItem(meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n     }\n }\n "}, {"sha": "d08e2ce527f1f60dd73ce03a28c1ee3bcb2f264c", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -801,15 +801,19 @@ fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n         node: m.id\n     };\n \n-    match cx.tcx.methods.borrow().find_copy(&did) {\n+    match cx.tcx.impl_or_trait_items.borrow().find_copy(&did) {\n         None => cx.sess().span_bug(m.span, \"missing method descriptor?!\"),\n         Some(md) => {\n-            match md.container {\n-                ty::TraitContainer(..) => TraitDefaultImpl,\n-                ty::ImplContainer(cid) => {\n-                    match ty::impl_trait_ref(cx.tcx, cid) {\n-                        Some(..) => TraitImpl,\n-                        None => PlainImpl\n+            match md {\n+                ty::MethodTraitItem(md) => {\n+                    match md.container {\n+                        ty::TraitContainer(..) => TraitDefaultImpl,\n+                        ty::ImplContainer(cid) => {\n+                            match ty::impl_trait_ref(cx.tcx, cid) {\n+                                Some(..) => TraitImpl,\n+                                None => PlainImpl\n+                            }\n+                        }\n                     }\n                 }\n             }\n@@ -1470,7 +1474,15 @@ impl LintPass for Stability {\n                                 trait_id: trait_id,\n                                 method_num: index,\n                                 ..\n-                            }) => ty::trait_method(cx.tcx, trait_id, index).def_id\n+                            }) => {\n+                                match ty::trait_item(cx.tcx,\n+                                                     trait_id,\n+                                                     index) {\n+                                    ty::MethodTraitItem(method) => {\n+                                        method.def_id\n+                                    }\n+                                }\n+                            }\n                         }\n                     }\n                     None => return"}, {"sha": "cf018927f70b460aae25795e75bf91e22387d1a9", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -563,9 +563,9 @@ impl<'a> Visitor<()> for Context<'a> {\n         visit::walk_generics(self, g, ());\n     }\n \n-    fn visit_trait_method(&mut self, m: &ast::TraitMethod, _: ()) {\n+    fn visit_trait_item(&mut self, m: &ast::TraitItem, _: ()) {\n         run_lints!(self, check_trait_method, m);\n-        visit::walk_trait_method(self, m, ());\n+        visit::walk_trait_item(self, m, ());\n     }\n \n     fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<ast::Lifetime>, _: ()) {"}, {"sha": "dbdda96dcb84fb7f9e1c785309d8f96a01363f35", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -141,7 +141,7 @@ pub trait LintPass {\n     fn check_fn(&mut self, _: &Context,\n         _: &FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) { }\n     fn check_ty_method(&mut self, _: &Context, _: &ast::TypeMethod) { }\n-    fn check_trait_method(&mut self, _: &Context, _: &ast::TraitMethod) { }\n+    fn check_trait_method(&mut self, _: &Context, _: &ast::TraitItem) { }\n     fn check_struct_def(&mut self, _: &Context,\n         _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n     fn check_struct_def_post(&mut self, _: &Context,"}, {"sha": "6a1c7c6c951c99a507194bbeac344014f98f0815", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -77,7 +77,7 @@ pub static tag_crate_dep_hash: uint = 0x1e;\n \n pub static tag_mod_impl: uint = 0x1f;\n \n-pub static tag_item_trait_method: uint = 0x20;\n+pub static tag_item_trait_item: uint = 0x20;\n \n pub static tag_item_trait_ref: uint = 0x21;\n pub static tag_item_super_trait_ref: uint = 0x22;\n@@ -95,14 +95,14 @@ pub static tag_item_field_origin: uint = 0x29;\n \n pub static tag_item_variances: uint = 0x2a;\n /*\n-  trait items contain tag_item_trait_method elements,\n-  impl items contain tag_item_impl_method elements, and classes\n+  trait items contain tag_item_trait_item elements,\n+  impl items contain tag_item_impl_item elements, and classes\n   have both. That's because some code treats classes like traits,\n   and other code treats them like impls. Because classes can contain\n-  both, tag_item_trait_method and tag_item_impl_method have to be two\n+  both, tag_item_trait_item and tag_item_impl_item have to be two\n   different tags.\n  */\n-pub static tag_item_impl_method: uint = 0x30;\n+pub static tag_item_impl_item: uint = 0x30;\n pub static tag_item_trait_method_explicit_self: uint = 0x31;\n \n \n@@ -154,9 +154,11 @@ impl astencode_tag {\n     }\n }\n \n-pub static tag_item_trait_method_sort: uint = 0x60;\n+pub static tag_item_trait_item_sort: uint = 0x60;\n \n-pub static tag_item_impl_type_basename: uint = 0x61;\n+pub static tag_item_trait_parent_sort: uint = 0x61;\n+\n+pub static tag_item_impl_type_basename: uint = 0x62;\n \n pub static tag_crate_triple: uint = 0x66;\n "}, {"sha": "ac161ef8bdefefde46dd9cf72e41ad12d7582459", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -16,6 +16,7 @@ use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use middle::lang_items;\n+use middle::resolve;\n use middle::ty;\n use middle::typeck;\n use middle::subst::VecPerParamSpace;\n@@ -121,30 +122,33 @@ pub fn get_enum_variants(tcx: &ty::ctxt, def: ast::DefId)\n }\n \n /// Returns information about the given implementation.\n-pub fn get_impl_methods(cstore: &cstore::CStore, impl_def_id: ast::DefId)\n-                        -> Vec<ast::DefId> {\n+pub fn get_impl_items(cstore: &cstore::CStore, impl_def_id: ast::DefId)\n+                      -> Vec<ty::ImplOrTraitItemId> {\n     let cdata = cstore.get_crate_data(impl_def_id.krate);\n-    decoder::get_impl_methods(&*cdata, impl_def_id.node)\n+    decoder::get_impl_items(&*cdata, impl_def_id.node)\n }\n \n-pub fn get_method(tcx: &ty::ctxt, def: ast::DefId) -> ty::Method {\n+pub fn get_impl_or_trait_item(tcx: &ty::ctxt, def: ast::DefId)\n+                              -> ty::ImplOrTraitItem {\n     let cdata = tcx.sess.cstore.get_crate_data(def.krate);\n-    decoder::get_method(tcx.sess.cstore.intr.clone(), &*cdata, def.node, tcx)\n+    decoder::get_impl_or_trait_item(tcx.sess.cstore.intr.clone(),\n+                                    &*cdata,\n+                                    def.node,\n+                                    tcx)\n }\n \n-pub fn get_method_name_and_explicit_self(cstore: &cstore::CStore,\n-                                         def: ast::DefId)\n-                                         -> (ast::Ident,\n-                                             ty::ExplicitSelfCategory)\n-{\n+pub fn get_trait_item_name_and_kind(cstore: &cstore::CStore, def: ast::DefId)\n+                                    -> (ast::Ident, resolve::TraitItemKind) {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_method_name_and_explicit_self(cstore.intr.clone(), &*cdata, def.node)\n+    decoder::get_trait_item_name_and_kind(cstore.intr.clone(),\n+                                          &*cdata,\n+                                          def.node)\n }\n \n-pub fn get_trait_method_def_ids(cstore: &cstore::CStore,\n-                                def: ast::DefId) -> Vec<ast::DefId> {\n+pub fn get_trait_item_def_ids(cstore: &cstore::CStore, def: ast::DefId)\n+                              -> Vec<ty::ImplOrTraitItemId> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_trait_method_def_ids(&*cdata, def.node)\n+    decoder::get_trait_item_def_ids(&*cdata, def.node)\n }\n \n pub fn get_item_variances(cstore: &cstore::CStore,\n@@ -286,15 +290,15 @@ pub fn each_implementation_for_trait(cstore: &cstore::CStore,\n     decoder::each_implementation_for_trait(&*cdata, def_id.node, callback)\n }\n \n-/// If the given def ID describes a method belonging to a trait (either a\n+/// If the given def ID describes an item belonging to a trait (either a\n /// default method or an implementation of a trait method), returns the ID of\n /// the trait that the method belongs to. Otherwise, returns `None`.\n-pub fn get_trait_of_method(cstore: &cstore::CStore,\n-                           def_id: ast::DefId,\n-                           tcx: &ty::ctxt)\n-                           -> Option<ast::DefId> {\n+pub fn get_trait_of_item(cstore: &cstore::CStore,\n+                         def_id: ast::DefId,\n+                         tcx: &ty::ctxt)\n+                         -> Option<ast::DefId> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_trait_of_method(&*cdata, def_id.node, tcx)\n+    decoder::get_trait_of_item(&*cdata, def_id.node, tcx)\n }\n \n pub fn get_tuple_struct_definition_if_ctor(cstore: &cstore::CStore,"}, {"sha": "74810261d4a750de1bada065dba5e80ec2404376", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 107, "deletions": 74, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -18,11 +18,12 @@ use metadata::common::*;\n use metadata::csearch::StaticMethodInfo;\n use metadata::csearch;\n use metadata::cstore;\n-use metadata::tydecode::{parse_ty_data, parse_def_id,\n-                         parse_type_param_def_data,\n-                         parse_bare_fn_ty_data, parse_trait_ref_data};\n-use middle::lang_items;\n+use metadata::tydecode::{parse_ty_data, parse_def_id};\n+use metadata::tydecode::{parse_type_param_def_data, parse_bare_fn_ty_data};\n+use metadata::tydecode::{parse_trait_ref_data};\n use middle::def;\n+use middle::lang_items;\n+use middle::resolve::TraitItemKind;\n use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty;\n@@ -165,9 +166,9 @@ fn item_visibility(item: rbml::Doc) -> ast::Visibility {\n     }\n }\n \n-fn item_method_sort(item: rbml::Doc) -> char {\n+fn item_sort(item: rbml::Doc) -> char {\n     let mut ret = 'r';\n-    reader::tagged_docs(item, tag_item_trait_method_sort, |doc| {\n+    reader::tagged_docs(item, tag_item_trait_item_sort, |doc| {\n         ret = doc.as_str_slice().as_bytes()[0] as char;\n         false\n     });\n@@ -338,15 +339,18 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n         UnsafeFn  => DlDef(def::DefFn(did, ast::UnsafeFn)),\n         Fn        => DlDef(def::DefFn(did, ast::NormalFn)),\n         StaticMethod | UnsafeStaticMethod => {\n-            let fn_style = if fam == UnsafeStaticMethod { ast::UnsafeFn } else\n-                { ast::NormalFn };\n+            let fn_style = if fam == UnsafeStaticMethod {\n+                ast::UnsafeFn\n+            } else {\n+                ast::NormalFn\n+            };\n             // def_static_method carries an optional field of its enclosing\n             // trait or enclosing impl (if this is an inherent static method).\n             // So we need to detect whether this is in a trait or not, which\n             // we do through the mildly hacky way of checking whether there is\n-            // a trait_method_sort.\n+            // a trait_parent_sort.\n             let provenance = if reader::maybe_get_doc(\n-                  item, tag_item_trait_method_sort).is_some() {\n+                  item, tag_item_trait_parent_sort).is_some() {\n                 def::FromTrait(item_reqd_and_translated_parent_item(cnum,\n                                                                     item))\n             } else {\n@@ -536,14 +540,11 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n             None => {}\n             Some(inherent_impl_doc) => {\n                 let _ = reader::tagged_docs(inherent_impl_doc,\n-                                            tag_item_impl_method,\n-                                            |impl_method_def_id_doc| {\n-                    let impl_method_def_id =\n-                        reader::with_doc_data(impl_method_def_id_doc,\n-                                              parse_def_id);\n-                    let impl_method_def_id =\n-                        translate_def_id(cdata, impl_method_def_id);\n-                    match maybe_find_item(impl_method_def_id.node, items) {\n+                                            tag_item_impl_item,\n+                                            |impl_item_def_id_doc| {\n+                    let impl_item_def_id = item_def_id(impl_item_def_id_doc,\n+                                                       cdata);\n+                    match maybe_find_item(impl_item_def_id.node, items) {\n                         None => {}\n                         Some(impl_method_doc) => {\n                             match item_family(impl_method_doc) {\n@@ -554,7 +555,7 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n                                         item_name(&*intr, impl_method_doc);\n                                     let static_method_def_like =\n                                         item_to_def_like(impl_method_doc,\n-                                                         impl_method_def_id,\n+                                                         impl_item_def_id,\n                                                          cdata.cnum);\n                                     callback(static_method_def_like,\n                                              static_method_name,\n@@ -752,33 +753,46 @@ fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n     }\n }\n \n-/// Returns information about the given implementation.\n-pub fn get_impl_methods(cdata: Cmd, impl_id: ast::NodeId) -> Vec<ast::DefId> {\n-    let mut methods = Vec::new();\n+/// Returns the def IDs of all the items in the given implementation.\n+pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n+                      -> Vec<ty::ImplOrTraitItemId> {\n+    let mut impl_items = Vec::new();\n     reader::tagged_docs(lookup_item(impl_id, cdata.data()),\n-                        tag_item_impl_method, |doc| {\n-        let m_did = reader::with_doc_data(doc, parse_def_id);\n-        methods.push(translate_def_id(cdata, m_did));\n+                        tag_item_impl_item, |doc| {\n+        let def_id = item_def_id(doc, cdata);\n+        match item_sort(doc) {\n+            'r' | 'p' => impl_items.push(ty::MethodTraitItemId(def_id)),\n+            _ => fail!(\"unknown impl item sort\"),\n+        }\n         true\n     });\n \n-    methods\n+    impl_items\n }\n \n-pub fn get_method_name_and_explicit_self(intr: Rc<IdentInterner>,\n-                                         cdata: Cmd,\n-                                         id: ast::NodeId)\n-                                         -> (ast::Ident,\n-                                             ty::ExplicitSelfCategory) {\n-    let method_doc = lookup_item(id, cdata.data());\n-    let name = item_name(&*intr, method_doc);\n-    let explicit_self = get_explicit_self(method_doc);\n-    (name, explicit_self)\n+pub fn get_trait_item_name_and_kind(intr: Rc<IdentInterner>,\n+                                    cdata: Cmd,\n+                                    id: ast::NodeId)\n+                                    -> (ast::Ident, TraitItemKind) {\n+    let doc = lookup_item(id, cdata.data());\n+    let name = item_name(&*intr, doc);\n+    match item_sort(doc) {\n+        'r' | 'p' => {\n+            let explicit_self = get_explicit_self(doc);\n+            (name, TraitItemKind::from_explicit_self_category(explicit_self))\n+        }\n+        c => {\n+            fail!(\"get_trait_item_name_and_kind(): unknown trait item kind \\\n+                   in metadata: `{}`\", c)\n+        }\n+    }\n }\n \n-pub fn get_method(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n-                  tcx: &ty::ctxt) -> ty::Method\n-{\n+pub fn get_impl_or_trait_item(intr: Rc<IdentInterner>,\n+                              cdata: Cmd,\n+                              id: ast::NodeId,\n+                              tcx: &ty::ctxt)\n+                              -> ty::ImplOrTraitItem {\n     let method_doc = lookup_item(id, cdata.data());\n     let def_id = item_def_id(method_doc, cdata);\n \n@@ -791,36 +805,45 @@ pub fn get_method(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n     };\n \n     let name = item_name(&*intr, method_doc);\n-    let type_param_defs = item_ty_param_defs(method_doc, tcx, cdata,\n-                                             tag_item_method_tps);\n-    let rp_defs = item_region_param_defs(method_doc, cdata);\n-    let fty = doc_method_fty(method_doc, tcx, cdata);\n-    let vis = item_visibility(method_doc);\n-    let explicit_self = get_explicit_self(method_doc);\n-    let provided_source = get_provided_source(method_doc, cdata);\n-\n-    ty::Method::new(\n-        name,\n-        ty::Generics {\n-            types: type_param_defs,\n-            regions: rp_defs,\n-        },\n-        fty,\n-        explicit_self,\n-        vis,\n-        def_id,\n-        container,\n-        provided_source\n-    )\n-}\n-\n-pub fn get_trait_method_def_ids(cdata: Cmd,\n-                                id: ast::NodeId) -> Vec<ast::DefId> {\n+\n+    match item_sort(method_doc) {\n+        'r' | 'p' => {\n+            let type_param_defs = item_ty_param_defs(method_doc, tcx, cdata,\n+                                                     tag_item_method_tps);\n+            let rp_defs = item_region_param_defs(method_doc, cdata);\n+            let fty = doc_method_fty(method_doc, tcx, cdata);\n+            let vis = item_visibility(method_doc);\n+            let explicit_self = get_explicit_self(method_doc);\n+            let provided_source = get_provided_source(method_doc, cdata);\n+\n+            let generics = ty::Generics {\n+                types: type_param_defs,\n+                regions: rp_defs,\n+            };\n+            ty::MethodTraitItem(Rc::new(ty::Method::new(name,\n+                                                        generics,\n+                                                        fty,\n+                                                        explicit_self,\n+                                                        vis,\n+                                                        def_id,\n+                                                        container,\n+                                                        provided_source)))\n+        }\n+        _ => fail!(\"unknown impl/trait item sort\"),\n+    }\n+}\n+\n+pub fn get_trait_item_def_ids(cdata: Cmd, id: ast::NodeId)\n+                              -> Vec<ty::ImplOrTraitItemId> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n     let mut result = Vec::new();\n-    reader::tagged_docs(item, tag_item_trait_method, |mth| {\n-        result.push(item_def_id(mth, cdata));\n+    reader::tagged_docs(item, tag_item_trait_item, |mth| {\n+        let def_id = item_def_id(mth, cdata);\n+        match item_sort(mth) {\n+            'r' | 'p' => result.push(ty::MethodTraitItemId(def_id)),\n+            _ => fail!(\"unknown trait item sort\"),\n+        }\n         true\n     });\n     result\n@@ -834,19 +857,29 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n     Decodable::decode(&mut decoder).unwrap()\n }\n \n-pub fn get_provided_trait_methods(intr: Rc<IdentInterner>, cdata: Cmd,\n-                                  id: ast::NodeId, tcx: &ty::ctxt)\n+pub fn get_provided_trait_methods(intr: Rc<IdentInterner>,\n+                                  cdata: Cmd,\n+                                  id: ast::NodeId,\n+                                  tcx: &ty::ctxt)\n                                   -> Vec<Rc<ty::Method>> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n     let mut result = Vec::new();\n \n-    reader::tagged_docs(item, tag_item_trait_method, |mth_id| {\n+    reader::tagged_docs(item, tag_item_trait_item, |mth_id| {\n         let did = item_def_id(mth_id, cdata);\n         let mth = lookup_item(did.node, data);\n \n-        if item_method_sort(mth) == 'p' {\n-            result.push(Rc::new(get_method(intr.clone(), cdata, did.node, tcx)));\n+        if item_sort(mth) == 'p' {\n+            let trait_item = get_impl_or_trait_item(intr.clone(),\n+                                                    cdata,\n+                                                    did.node,\n+                                                    tcx);\n+            match trait_item {\n+                ty::MethodTraitItem(ref method) => {\n+                    result.push((*method).clone())\n+                }\n+            }\n         }\n         true\n     });\n@@ -905,8 +938,8 @@ pub fn get_static_methods_if_impl(intr: Rc<IdentInterner>,\n     if !ret { return None }\n \n     let mut impl_method_ids = Vec::new();\n-    reader::tagged_docs(item, tag_item_impl_method, |impl_method_doc| {\n-        impl_method_ids.push(reader::with_doc_data(impl_method_doc, parse_def_id));\n+    reader::tagged_docs(item, tag_item_impl_item, |impl_method_doc| {\n+        impl_method_ids.push(item_def_id(impl_method_doc, cdata));\n         true\n     });\n \n@@ -1230,8 +1263,8 @@ pub fn each_implementation_for_trait(cdata: Cmd,\n     });\n }\n \n-pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n-                           -> Option<ast::DefId> {\n+pub fn get_trait_of_item(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n+                         -> Option<ast::DefId> {\n     let item_doc = lookup_item(id, cdata.data());\n     let parent_item_id = match item_parent_item(item_doc) {\n         None => return None,"}, {"sha": "1d426aaaf5c91fdb7c57d2659248c11b3ac2721d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 171, "deletions": 94, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -54,13 +54,19 @@ use syntax;\n use rbml::writer;\n use rbml::io::SeekableMemWriter;\n \n-/// A borrowed version of ast::InlinedItem.\n+/// A borrowed version of `ast::InlinedItem`.\n pub enum InlinedItemRef<'a> {\n     IIItemRef(&'a ast::Item),\n-    IIMethodRef(ast::DefId, bool, &'a ast::Method),\n+    IITraitItemRef(ast::DefId, InlinedTraitItemRef<'a>),\n     IIForeignRef(&'a ast::ForeignItem)\n }\n \n+/// A borrowed version of `ast::InlinedTraitItem`.\n+pub enum InlinedTraitItemRef<'a> {\n+    ProvidedInlinedTraitItemRef(&'a Method),\n+    RequiredInlinedTraitItemRef(&'a Method),\n+}\n+\n pub type Encoder<'a> = writer::Encoder<'a, SeekableMemWriter>;\n \n pub type EncodeInlinedItem<'a> = |ecx: &EncodeContext,\n@@ -403,14 +409,24 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                          rbml_w: &mut Encoder,\n                                          exp: &middle::resolve::Export2)\n                                          -> bool {\n-    let impl_methods = ecx.tcx.impl_methods.borrow();\n+    let impl_items = ecx.tcx.impl_items.borrow();\n     match ecx.tcx.inherent_impls.borrow().find(&exp.def_id) {\n         Some(implementations) => {\n             for base_impl_did in implementations.borrow().iter() {\n-                for &method_did in impl_methods.get(base_impl_did).iter() {\n-                    let m = ty::method(ecx.tcx, method_did);\n-                    if m.explicit_self == ty::StaticExplicitSelfCategory {\n-                        encode_reexported_static_method(rbml_w, exp, m.def_id, m.ident);\n+                for &method_did in impl_items.get(base_impl_did).iter() {\n+                    let impl_item = ty::impl_or_trait_item(\n+                        ecx.tcx,\n+                        method_did.def_id());\n+                    match impl_item {\n+                        ty::MethodTraitItem(ref m) => {\n+                            if m.explicit_self ==\n+                                    ty::StaticExplicitSelfCategory {\n+                                encode_reexported_static_method(rbml_w,\n+                                                                exp,\n+                                                                m.def_id,\n+                                                                m.ident);\n+                            }\n+                        }\n                     }\n                 }\n             }\n@@ -425,11 +441,18 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                                           rbml_w: &mut Encoder,\n                                           exp: &middle::resolve::Export2)\n                                           -> bool {\n-    match ecx.tcx.trait_methods_cache.borrow().find(&exp.def_id) {\n-        Some(methods) => {\n-            for m in methods.iter() {\n-                if m.explicit_self == ty::StaticExplicitSelfCategory {\n-                    encode_reexported_static_method(rbml_w, exp, m.def_id, m.ident);\n+    match ecx.tcx.trait_items_cache.borrow().find(&exp.def_id) {\n+        Some(trait_items) => {\n+            for trait_item in trait_items.iter() {\n+                match *trait_item {\n+                    ty::MethodTraitItem(ref m) if m.explicit_self ==\n+                            ty::StaticExplicitSelfCategory => {\n+                        encode_reexported_static_method(rbml_w,\n+                                                        exp,\n+                                                        m.def_id,\n+                                                        m.ident);\n+                    }\n+                    _ => {}\n                 }\n             }\n \n@@ -675,8 +698,14 @@ fn encode_explicit_self(rbml_w: &mut Encoder,\n     }\n }\n \n-fn encode_method_sort(rbml_w: &mut Encoder, sort: char) {\n-    rbml_w.start_tag(tag_item_trait_method_sort);\n+fn encode_item_sort(rbml_w: &mut Encoder, sort: char) {\n+    rbml_w.start_tag(tag_item_trait_item_sort);\n+    rbml_w.writer.write(&[ sort as u8 ]);\n+    rbml_w.end_tag();\n+}\n+\n+fn encode_parent_sort(rbml_w: &mut Encoder, sort: char) {\n+    rbml_w.start_tag(tag_item_trait_parent_sort);\n     rbml_w.writer.write(&[ sort as u8 ]);\n     rbml_w.end_tag();\n }\n@@ -799,6 +828,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n \n     encode_method_ty_fields(ecx, rbml_w, m);\n     encode_parent_item(rbml_w, local_def(parent_id));\n+    encode_item_sort(rbml_w, 'r');\n \n     let stab = stability::lookup(ecx.tcx, m.def_id);\n     encode_stability(rbml_w, stab);\n@@ -819,9 +849,11 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     for &ast_method in ast_method_opt.iter() {\n         let any_types = !pty.generics.types.is_empty();\n         if any_types || is_default_impl || should_inline(ast_method.attrs.as_slice()) {\n-            encode_inlined_item(ecx, rbml_w,\n-                                IIMethodRef(local_def(parent_id), false,\n-                                            &*ast_method));\n+            encode_inlined_item(ecx,\n+                                rbml_w,\n+                                IITraitItemRef(local_def(parent_id),\n+                                               RequiredInlinedTraitItemRef(\n+                                                   &*ast_method)));\n         } else {\n             encode_symbol(ecx, rbml_w, m.def_id.node);\n         }\n@@ -1106,11 +1138,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             None => {}\n         }\n       }\n-      ItemImpl(_, ref opt_trait, ty, ref ast_methods) => {\n+      ItemImpl(_, ref opt_trait, ty, ref ast_items) => {\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n-        let impl_methods = tcx.impl_methods.borrow();\n-        let methods = impl_methods.get(&def_id);\n+        let impl_items = tcx.impl_items.borrow();\n+        let items = impl_items.get(&def_id);\n \n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n@@ -1128,10 +1160,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             _ => {}\n         }\n-        for &method_def_id in methods.iter() {\n-            rbml_w.start_tag(tag_item_impl_method);\n-            let s = def_to_string(method_def_id);\n-            rbml_w.writer.write(s.as_bytes());\n+        for &item_def_id in items.iter() {\n+            rbml_w.start_tag(tag_item_impl_item);\n+            match item_def_id {\n+                ty::MethodTraitItemId(item_def_id) => {\n+                    encode_def_id(rbml_w, item_def_id);\n+                    encode_item_sort(rbml_w, 'r');\n+                }\n+            }\n             rbml_w.end_tag();\n         }\n         for ast_trait_ref in opt_trait.iter() {\n@@ -1145,27 +1181,46 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n \n-        // Iterate down the methods, emitting them. We rely on the\n-        // assumption that all of the actually implemented methods\n+        // Iterate down the trait items, emitting them. We rely on the\n+        // assumption that all of the actually implemented trait items\n         // appear first in the impl structure, in the same order they do\n         // in the ast. This is a little sketchy.\n-        let num_implemented_methods = ast_methods.len();\n-        for (i, &method_def_id) in methods.iter().enumerate() {\n-            let ast_method = if i < num_implemented_methods {\n-                Some(*ast_methods.get(i))\n-            } else { None };\n+        let num_implemented_methods = ast_items.len();\n+        for (i, &trait_item_def_id) in items.iter().enumerate() {\n+            let ast_item = if i < num_implemented_methods {\n+                Some(*ast_items.get(i))\n+            } else {\n+                None\n+            };\n \n             index.push(entry {\n-                val: method_def_id.node as i64,\n+                val: trait_item_def_id.def_id().node as i64,\n                 pos: rbml_w.writer.tell().unwrap(),\n             });\n-            encode_info_for_method(ecx,\n-                                   rbml_w,\n-                                   &*ty::method(tcx, method_def_id),\n-                                   path.clone(),\n-                                   false,\n-                                   item.id,\n-                                   ast_method)\n+\n+            let trait_item_type =\n+                ty::impl_or_trait_item(tcx, trait_item_def_id.def_id());\n+            match (trait_item_type, ast_item) {\n+                (ty::MethodTraitItem(method_type),\n+                 Some(ast::MethodImplItem(ast_method))) => {\n+                    encode_info_for_method(ecx,\n+                                           rbml_w,\n+                                           &*method_type,\n+                                           path.clone(),\n+                                           false,\n+                                           item.id,\n+                                           Some(ast_method))\n+                }\n+                (ty::MethodTraitItem(method_type), None) => {\n+                    encode_info_for_method(ecx,\n+                                           rbml_w,\n+                                           &*method_type,\n+                                           path.clone(),\n+                                           false,\n+                                           item.id,\n+                                           None)\n+                }\n+            }\n         }\n       }\n       ItemTrait(_, _, ref super_traits, ref ms) => {\n@@ -1184,13 +1239,18 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(rbml_w, item.attrs.as_slice());\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n-        for &method_def_id in ty::trait_method_def_ids(tcx, def_id).iter() {\n-            rbml_w.start_tag(tag_item_trait_method);\n-            encode_def_id(rbml_w, method_def_id);\n+        for &method_def_id in ty::trait_item_def_ids(tcx, def_id).iter() {\n+            rbml_w.start_tag(tag_item_trait_item);\n+            match method_def_id {\n+                ty::MethodTraitItemId(method_def_id) => {\n+                    encode_def_id(rbml_w, method_def_id);\n+                    encode_item_sort(rbml_w, 'r');\n+                }\n+            }\n             rbml_w.end_tag();\n \n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(method_def_id).as_slice());\n+            rbml_w.wr_str(def_to_string(method_def_id.def_id()).as_slice());\n             rbml_w.end_tag();\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1207,66 +1267,83 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         rbml_w.end_tag();\n \n-        // Now output the method info for each method.\n-        let r = ty::trait_method_def_ids(tcx, def_id);\n-        for (i, &method_def_id) in r.iter().enumerate() {\n-            assert_eq!(method_def_id.krate, ast::LOCAL_CRATE);\n-\n-            let method_ty = ty::method(tcx, method_def_id);\n+        // Now output the trait item info for each trait item.\n+        let r = ty::trait_item_def_ids(tcx, def_id);\n+        for (i, &item_def_id) in r.iter().enumerate() {\n+            assert_eq!(item_def_id.def_id().krate, ast::LOCAL_CRATE);\n \n             index.push(entry {\n-                val: method_def_id.node as i64,\n+                val: item_def_id.def_id().node as i64,\n                 pos: rbml_w.writer.tell().unwrap(),\n             });\n \n             rbml_w.start_tag(tag_items_data_item);\n \n-            encode_method_ty_fields(ecx, rbml_w, &*method_ty);\n-            encode_parent_item(rbml_w, def_id);\n-\n-            let stab = stability::lookup(tcx, method_def_id);\n-            encode_stability(rbml_w, stab);\n-\n-            let elem = ast_map::PathName(method_ty.ident.name);\n-            encode_path(rbml_w, path.clone().chain(Some(elem).move_iter()));\n-\n-            match method_ty.explicit_self {\n-                ty::StaticExplicitSelfCategory => {\n-                    encode_family(rbml_w,\n-                                  fn_style_static_method_family(\n-                                      method_ty.fty.fn_style));\n-\n-                    let pty = ty::lookup_item_type(tcx, method_def_id);\n-                    encode_bounds_and_type(rbml_w, ecx, &pty);\n-                }\n-\n-                _ => {\n-                    encode_family(rbml_w,\n-                                  style_fn_family(\n-                                      method_ty.fty.fn_style));\n-                }\n-            }\n-\n-            match ms.get(i) {\n-                &Required(ref tm) => {\n-                    encode_attributes(rbml_w, tm.attrs.as_slice());\n-                    encode_method_sort(rbml_w, 'r');\n-                    encode_method_argument_names(rbml_w, &*tm.decl);\n-                }\n+            let trait_item_type =\n+                ty::impl_or_trait_item(tcx, item_def_id.def_id());\n+            match trait_item_type {\n+                 ty::MethodTraitItem(method_ty) => {\n+                    let method_def_id = item_def_id.def_id();\n+\n+                    encode_method_ty_fields(ecx, rbml_w, &*method_ty);\n+                    encode_parent_item(rbml_w, def_id);\n+\n+                    let stab = stability::lookup(tcx, method_def_id);\n+                    encode_stability(rbml_w, stab);\n+\n+                    let elem = ast_map::PathName(method_ty.ident.name);\n+                    encode_path(rbml_w,\n+                                path.clone().chain(Some(elem).move_iter()));\n+\n+                    match method_ty.explicit_self {\n+                        ty::StaticExplicitSelfCategory => {\n+                            encode_family(rbml_w,\n+                                          fn_style_static_method_family(\n+                                              method_ty.fty.fn_style));\n+\n+                            let pty = ty::lookup_item_type(tcx,\n+                                                           method_def_id);\n+                            encode_bounds_and_type(rbml_w, ecx, &pty);\n+                        }\n+\n+                        _ => {\n+                            encode_family(rbml_w,\n+                                          style_fn_family(\n+                                              method_ty.fty.fn_style));\n+                        }\n+                    }\n \n-                &Provided(m) => {\n-                    encode_attributes(rbml_w, m.attrs.as_slice());\n-                    // If this is a static method, we've already encoded\n-                    // this.\n-                    if method_ty.explicit_self != ty::StaticExplicitSelfCategory {\n-                        // FIXME: I feel like there is something funny going on.\n-                        let pty = ty::lookup_item_type(tcx, method_def_id);\n-                        encode_bounds_and_type(rbml_w, ecx, &pty);\n+                    match ms.get(i) {\n+                        &RequiredMethod(ref tm) => {\n+                            encode_attributes(rbml_w, tm.attrs.as_slice());\n+                            encode_item_sort(rbml_w, 'r');\n+                            encode_parent_sort(rbml_w, 't');\n+                            encode_method_argument_names(rbml_w, &*tm.decl);\n+                        }\n+\n+                        &ProvidedMethod(m) => {\n+                            encode_attributes(rbml_w, m.attrs.as_slice());\n+                            // If this is a static method, we've already\n+                            // encoded this.\n+                            if method_ty.explicit_self !=\n+                                    ty::StaticExplicitSelfCategory {\n+                                // FIXME: I feel like there is something funny\n+                                // going on.\n+                                let pty = ty::lookup_item_type(tcx, method_def_id);\n+                                encode_bounds_and_type(rbml_w, ecx, &pty);\n+                            }\n+                            encode_item_sort(rbml_w, 'p');\n+                            encode_parent_sort(rbml_w, 't');\n+                            encode_inlined_item(\n+                                ecx,\n+                                rbml_w,\n+                                IITraitItemRef(\n+                                    def_id,\n+                                    ProvidedInlinedTraitItemRef(&*m)));\n+                            encode_method_argument_names(rbml_w,\n+                                                         &*m.pe_fn_decl());\n+                        }\n                     }\n-                    encode_method_sort(rbml_w, 'p');\n-                    encode_inlined_item(ecx, rbml_w,\n-                                        IIMethodRef(def_id, true, &*m));\n-                    encode_method_argument_names(rbml_w, &*m.pe_fn_decl());\n                 }\n             }\n "}, {"sha": "26cb2f25129aa61ef02964eedda615a95fa412de", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 48, "deletions": 11, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -84,7 +84,8 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     let id = match ii {\n         e::IIItemRef(i) => i.id,\n         e::IIForeignRef(i) => i.id,\n-        e::IIMethodRef(_, _, m) => m.id,\n+        e::IITraitItemRef(_, e::ProvidedInlinedTraitItemRef(m)) => m.id,\n+        e::IITraitItemRef(_, e::RequiredInlinedTraitItemRef(m)) => m.id,\n     };\n     debug!(\"> Encoding inlined item: {} ({})\",\n            ecx.tcx.map.path_to_string(id),\n@@ -137,7 +138,12 @@ pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n         let ident = match ii {\n             ast::IIItem(i) => i.ident,\n             ast::IIForeign(i) => i.ident,\n-            ast::IIMethod(_, _, m) => m.pe_ident(),\n+            ast::IITraitItem(_, iti) => {\n+                match iti {\n+                    ast::ProvidedInlinedTraitItem(m) => m.pe_ident(),\n+                    ast::RequiredInlinedTraitItem(m) => m.pe_ident(),\n+                }\n+            }\n         };\n         debug!(\"Fn named: {}\", token::get_ident(ident));\n         debug!(\"< Decoded inlined fn: {}::{}\",\n@@ -344,12 +350,29 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n \n     match ii {\n         // HACK we're not dropping items.\n-        e::IIItemRef(i) => ast::IIItem(fold::noop_fold_item(i, &mut fld)\n-                                       .expect_one(\"expected one item\")),\n-        e::IIMethodRef(d, p, m) => ast::IIMethod(d, p, fold::noop_fold_method(m, &mut fld)\n-                                                 .expect_one(\n-                \"noop_fold_method must produce exactly one method\")),\n-        e::IIForeignRef(i) => ast::IIForeign(fold::noop_fold_foreign_item(i, &mut fld))\n+        e::IIItemRef(i) => {\n+            ast::IIItem(fold::noop_fold_item(i, &mut fld)\n+                            .expect_one(\"expected one item\"))\n+        }\n+        e::IITraitItemRef(d, iti) => {\n+            ast::IITraitItem(d, match iti {\n+                e::ProvidedInlinedTraitItemRef(m) => {\n+                    ast::ProvidedInlinedTraitItem(\n+                        fold::noop_fold_method(m, &mut fld)\n+                            .expect_one(\"noop_fold_method must produce \\\n+                                         exactly one method\"))\n+                }\n+                e::RequiredInlinedTraitItemRef(m) => {\n+                    ast::RequiredInlinedTraitItem(\n+                        fold::noop_fold_method(m, &mut fld)\n+                            .expect_one(\"noop_fold_method must produce \\\n+                                         exactly one method\"))\n+                }\n+            })\n+        }\n+        e::IIForeignRef(i) => {\n+            ast::IIForeign(fold::noop_fold_foreign_item(i, &mut fld))\n+        }\n     }\n }\n \n@@ -389,9 +412,23 @@ fn renumber_and_map_ast(xcx: &ExtendedDecodeContext,\n             ast::IIItem(i) => {\n                 ast::IIItem(fld.fold_item(i).expect_one(\"expected one item\"))\n             }\n-            ast::IIMethod(d, is_provided, m) => {\n-                ast::IIMethod(xcx.tr_def_id(d), is_provided, fld.fold_method(m)\n-                              .expect_one(\"expected one method\"))\n+            ast::IITraitItem(d, iti) => {\n+                match iti {\n+                    ast::ProvidedInlinedTraitItem(m) => {\n+                        ast::IITraitItem(\n+                            xcx.tr_def_id(d),\n+                            ast::ProvidedInlinedTraitItem(\n+                                fld.fold_method(m)\n+                                   .expect_one(\"expected one method\")))\n+                    }\n+                    ast::RequiredInlinedTraitItem(m) => {\n+                        ast::IITraitItem(\n+                            xcx.tr_def_id(d),\n+                            ast::RequiredInlinedTraitItem(\n+                                fld.fold_method(m)\n+                                   .expect_one(\"expected one method\")))\n+                    }\n+                }\n             }\n             ast::IIForeign(i) => ast::IIForeign(fld.fold_foreign_item(i))\n         }"}, {"sha": "9a7bfb0e6dca257cedfca8138e4f6599c1f05d66", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -40,9 +40,9 @@ fn should_explore(tcx: &ty::ctxt, def_id: ast::DefId) -> bool {\n \n     match tcx.map.find(def_id.node) {\n         Some(ast_map::NodeItem(..))\n-        | Some(ast_map::NodeMethod(..))\n+        | Some(ast_map::NodeImplItem(..))\n         | Some(ast_map::NodeForeignItem(..))\n-        | Some(ast_map::NodeTraitMethod(..)) => true,\n+        | Some(ast_map::NodeTraitItem(..)) => true,\n         _ => false\n     }\n }\n@@ -114,9 +114,14 @@ impl<'a> MarkSymbolVisitor<'a> {\n                         method_num: index,\n                         ..\n                     }) => {\n-                        let def_id = ty::trait_method(self.tcx,\n-                                                      trait_id, index).def_id;\n-                        self.check_def_id(def_id);\n+                        let trait_item = ty::trait_item(self.tcx,\n+                                                        trait_id,\n+                                                        index);\n+                        match trait_item {\n+                            ty::MethodTraitItem(method) => {\n+                                self.check_def_id(method.def_id);\n+                            }\n+                        }\n                     }\n                 }\n             }\n@@ -208,11 +213,15 @@ impl<'a> MarkSymbolVisitor<'a> {\n                     _ => ()\n                 }\n             }\n-            ast_map::NodeTraitMethod(trait_method) => {\n-                visit::walk_trait_method(self, &*trait_method, ctxt);\n+            ast_map::NodeTraitItem(trait_method) => {\n+                visit::walk_trait_item(self, &*trait_method, ctxt);\n             }\n-            ast_map::NodeMethod(method) => {\n-                visit::walk_block(self, &*method.pe_body(), ctxt);\n+            ast_map::NodeImplItem(impl_item) => {\n+                match *impl_item {\n+                    ast::MethodImplItem(method) => {\n+                        visit::walk_block(self, &*method.pe_body(), ctxt);\n+                    }\n+                }\n             }\n             ast_map::NodeForeignItem(foreign_item) => {\n                 visit::walk_foreign_item(self, &*foreign_item, ctxt);\n@@ -316,9 +325,13 @@ impl Visitor<()> for LifeSeeder {\n             self.worklist.push(item.id);\n         }\n         match item.node {\n-            ast::ItemImpl(_, Some(ref _trait_ref), _, ref methods) => {\n-                for method in methods.iter() {\n-                    self.worklist.push(method.id);\n+            ast::ItemImpl(_, Some(ref _trait_ref), _, ref impl_items) => {\n+                for impl_item in impl_items.iter() {\n+                    match *impl_item {\n+                        ast::MethodImplItem(method) => {\n+                            self.worklist.push(method.id);\n+                        }\n+                    }\n                 }\n             }\n             _ => ()\n@@ -443,13 +456,14 @@ impl<'a> DeadVisitor<'a> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let impl_methods = self.tcx.impl_methods.borrow();\n+        let impl_items = self.tcx.impl_items.borrow();\n         match self.tcx.inherent_impls.borrow().find(&local_def(id)) {\n             None => (),\n             Some(impl_list) => {\n                 for impl_did in impl_list.borrow().iter() {\n-                    for method_did in impl_methods.get(impl_did).iter() {\n-                        if self.live_symbols.contains(&method_did.node) {\n+                    for item_did in impl_items.get(impl_did).iter() {\n+                        if self.live_symbols.contains(&item_did.def_id()\n+                                                               .node) {\n                             return true;\n                         }\n                     }\n@@ -516,12 +530,12 @@ impl<'a> Visitor<()> for DeadVisitor<'a> {\n     }\n \n     // Overwrite so that we don't warn the trait method itself.\n-    fn visit_trait_method(&mut self, trait_method: &ast::TraitMethod, _: ()) {\n+    fn visit_trait_item(&mut self, trait_method: &ast::TraitItem, _: ()) {\n         match *trait_method {\n-            ast::Provided(ref method) => {\n+            ast::ProvidedMethod(ref method) => {\n                 visit::walk_block(self, &*method.pe_body(), ())\n             }\n-            ast::Required(_) => ()\n+            ast::RequiredMethod(_) => ()\n         }\n     }\n }"}, {"sha": "b76b85e024c447309844607cd789cf384b07c469", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -131,12 +131,14 @@ impl OverloadedCallType {\n     fn from_method_id(tcx: &ty::ctxt, method_id: ast::DefId)\n                       -> OverloadedCallType {\n         let method_descriptor =\n-            match tcx.methods.borrow_mut().find(&method_id) {\n+            match tcx.impl_or_trait_items.borrow_mut().find(&method_id) {\n+                Some(&ty::MethodTraitItem(ref method_descriptor)) => {\n+                    (*method_descriptor).clone()\n+                }\n                 None => {\n                     tcx.sess.bug(\"overloaded call method wasn't in method \\\n                                   map\")\n                 }\n-                Some(ref method_descriptor) => (*method_descriptor).clone(),\n             };\n         let impl_id = match method_descriptor.container {\n             ty::TraitContainer(_) => {"}, {"sha": "61e6debb0864714cbd8d8a41255300e59488eac7", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 92, "deletions": 44, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -83,8 +83,8 @@ impl Visitor<()> for ParentVisitor {\n             ast::ItemTrait(_, _, _, ref methods) if item.vis != ast::Public => {\n                 for m in methods.iter() {\n                     match *m {\n-                        ast::Provided(ref m) => self.parents.insert(m.id, item.id),\n-                        ast::Required(ref m) => self.parents.insert(m.id, item.id),\n+                        ast::ProvidedMethod(ref m) => self.parents.insert(m.id, item.id),\n+                        ast::RequiredMethod(ref m) => self.parents.insert(m.id, item.id),\n                     };\n                 }\n             }\n@@ -240,7 +240,7 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n             //   undefined symbols at linkage time if this case is not handled.\n             //\n             // * Private trait impls for private types can be completely ignored\n-            ast::ItemImpl(_, _, ref ty, ref methods) => {\n+            ast::ItemImpl(_, _, ref ty, ref impl_items) => {\n                 let public_ty = match ty.node {\n                     ast::TyPath(_, _, id) => {\n                         match self.tcx.def_map.borrow().get_copy(&id) {\n@@ -261,13 +261,18 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n                 });\n \n                 if public_ty || public_trait {\n-                    for method in methods.iter() {\n-                        let meth_public = match method.pe_explicit_self().node {\n-                            ast::SelfStatic => public_ty,\n-                            _ => true,\n-                        } && method.pe_vis() == ast::Public;\n-                        if meth_public || tr.is_some() {\n-                            self.exported_items.insert(method.id);\n+                    for impl_item in impl_items.iter() {\n+                        match *impl_item {\n+                            ast::MethodImplItem(method) => {\n+                                let meth_public =\n+                                    match method.pe_explicit_self().node {\n+                                        ast::SelfStatic => public_ty,\n+                                        _ => true,\n+                                    } && method.pe_vis() == ast::Public;\n+                                if meth_public || tr.is_some() {\n+                                    self.exported_items.insert(method.id);\n+                                }\n+                            }\n                         }\n                     }\n                 }\n@@ -278,11 +283,11 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n             ast::ItemTrait(_, _, _, ref methods) if public_first => {\n                 for method in methods.iter() {\n                     match *method {\n-                        ast::Provided(ref m) => {\n+                        ast::ProvidedMethod(ref m) => {\n                             debug!(\"provided {}\", m.id);\n                             self.exported_items.insert(m.id);\n                         }\n-                        ast::Required(ref m) => {\n+                        ast::RequiredMethod(ref m) => {\n                             debug!(\"required {}\", m.id);\n                             self.exported_items.insert(m.id);\n                         }\n@@ -387,9 +392,10 @@ impl<'a> PrivacyVisitor<'a> {\n             }\n             debug!(\"privacy - is {:?} a public method\", did);\n \n-            return match self.tcx.methods.borrow().find(&did) {\n-                Some(meth) => {\n-                    debug!(\"privacy - well at least it's a method: {:?}\", meth);\n+            return match self.tcx.impl_or_trait_items.borrow().find(&did) {\n+                Some(&ty::MethodTraitItem(ref meth)) => {\n+                    debug!(\"privacy - well at least it's a method: {:?}\",\n+                           *meth);\n                     match meth.container {\n                         ty::TraitContainer(id) => {\n                             debug!(\"privacy - recursing on trait {:?}\", id);\n@@ -451,15 +457,23 @@ impl<'a> PrivacyVisitor<'a> {\n                 // invocation.\n                 // FIXME(#10573) is this the right behavior? Why not consider\n                 //               where the method was defined?\n-                Some(ast_map::NodeMethod(ref m)) => {\n-                    let imp = self.tcx.map.get_parent_did(closest_private_id);\n-                    match ty::impl_trait_ref(self.tcx, imp) {\n-                        Some(..) => return Allowable,\n-                        _ if m.pe_vis() == ast::Public => return Allowable,\n-                        _ => m.pe_vis()\n+                Some(ast_map::NodeImplItem(ref ii)) => {\n+                    match **ii {\n+                        ast::MethodImplItem(m) => {\n+                            let imp = self.tcx\n+                                          .map\n+                                          .get_parent_did(closest_private_id);\n+                            match ty::impl_trait_ref(self.tcx, imp) {\n+                                Some(..) => return Allowable,\n+                                _ if m.pe_vis() == ast::Public => {\n+                                    return Allowable\n+                                }\n+                                _ => m.pe_vis()\n+                            }\n+                        }\n                     }\n                 }\n-                Some(ast_map::NodeTraitMethod(_)) => {\n+                Some(ast_map::NodeTraitItem(_)) => {\n                     return Allowable;\n                 }\n \n@@ -648,12 +662,17 @@ impl<'a> PrivacyVisitor<'a> {\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n-    fn check_static_method(&mut self, span: Span, method_id: ast::DefId,\n+    fn check_static_method(&mut self,\n+                           span: Span,\n+                           method_id: ast::DefId,\n                            name: ast::Ident) {\n         // If the method is a default method, we need to use the def_id of\n         // the default implementation.\n-        let method_id = ty::method(self.tcx, method_id).provided_source\n-                                                       .unwrap_or(method_id);\n+        let method_id = match ty::impl_or_trait_item(self.tcx, method_id) {\n+            ty::MethodTraitItem(method_type) => {\n+                method_type.provided_source.unwrap_or(method_id)\n+            }\n+        };\n \n         let string = token::get_ident(name);\n         self.report_error(self.ensure_public(span,\n@@ -1075,12 +1094,16 @@ impl<'a> SanePrivacyVisitor<'a> {\n         match item.node {\n             // implementations of traits don't need visibility qualifiers because\n             // that's controlled by having the trait in scope.\n-            ast::ItemImpl(_, Some(..), _, ref methods) => {\n+            ast::ItemImpl(_, Some(..), _, ref impl_items) => {\n                 check_inherited(item.span, item.vis,\n                                 \"visibility qualifiers have no effect on trait \\\n                                  impls\");\n-                for m in methods.iter() {\n-                    check_inherited(m.span, m.pe_vis(), \"\");\n+                for impl_item in impl_items.iter() {\n+                    match *impl_item {\n+                        ast::MethodImplItem(m) => {\n+                            check_inherited(m.span, m.pe_vis(), \"\");\n+                        }\n+                    }\n                 }\n             }\n \n@@ -1111,11 +1134,11 @@ impl<'a> SanePrivacyVisitor<'a> {\n             ast::ItemTrait(_, _, _, ref methods) => {\n                 for m in methods.iter() {\n                     match *m {\n-                        ast::Provided(ref m) => {\n+                        ast::ProvidedMethod(ref m) => {\n                             check_inherited(m.span, m.pe_vis(),\n                                             \"unnecessary visibility\");\n                         }\n-                        ast::Required(ref m) => {\n+                        ast::RequiredMethod(ref m) => {\n                             check_inherited(m.span, m.vis,\n                                             \"unnecessary visibility\");\n                         }\n@@ -1148,9 +1171,13 @@ impl<'a> SanePrivacyVisitor<'a> {\n         };\n         check_inherited(tcx, item.span, item.vis);\n         match item.node {\n-            ast::ItemImpl(_, _, _, ref methods) => {\n-                for m in methods.iter() {\n-                    check_inherited(tcx, m.span, m.pe_vis());\n+            ast::ItemImpl(_, _, _, ref impl_items) => {\n+                for impl_item in impl_items.iter() {\n+                    match *impl_item {\n+                        ast::MethodImplItem(m) => {\n+                            check_inherited(tcx, m.span, m.pe_vis());\n+                        }\n+                    }\n                 }\n             }\n             ast::ItemForeignMod(ref fm) => {\n@@ -1174,8 +1201,8 @@ impl<'a> SanePrivacyVisitor<'a> {\n             ast::ItemTrait(_, _, _, ref methods) => {\n                 for m in methods.iter() {\n                     match *m {\n-                        ast::Required(..) => {}\n-                        ast::Provided(ref m) => check_inherited(tcx, m.span,\n+                        ast::RequiredMethod(..) => {}\n+                        ast::ProvidedMethod(ref m) => check_inherited(tcx, m.span,\n                                                                 m.pe_vis()),\n                     }\n                 }\n@@ -1270,7 +1297,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n             // (i.e. we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n             // publicly visible.\n-            ast::ItemImpl(ref g, ref trait_ref, self_, ref methods) => {\n+            ast::ItemImpl(ref g, ref trait_ref, self_, ref impl_items) => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n                 // impl [... for] Public<...>, but not `impl [... for]\n@@ -1311,7 +1338,14 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n                 // are private (because `T` won't be visible externally).\n                 let trait_or_some_public_method =\n                     trait_ref.is_some() ||\n-                    methods.iter().any(|m| self.exported_items.contains(&m.id));\n+                    impl_items.iter()\n+                              .any(|impl_item| {\n+                                  match *impl_item {\n+                                      ast::MethodImplItem(m) => {\n+                                          self.exported_items.contains(&m.id)\n+                                      }\n+                                  }\n+                              });\n \n                 if !self_contains_private &&\n                         not_private_trait &&\n@@ -1321,8 +1355,14 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n \n                     match *trait_ref {\n                         None => {\n-                            for method in methods.iter() {\n-                                visit::walk_method_helper(self, &**method, ())\n+                            for impl_item in impl_items.iter() {\n+                                match *impl_item {\n+                                    ast::MethodImplItem(method) => {\n+                                        visit::walk_method_helper(self,\n+                                                                  &*method,\n+                                                                  ())\n+                                    }\n+                                }\n                             }\n                         }\n                         Some(ref tr) => {\n@@ -1345,11 +1385,19 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n                     // impl Public<Private> { ... }. Any public static\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n-                    for method in methods.iter() {\n-                        if method.pe_explicit_self().node == ast::SelfStatic &&\n-                            self.exported_items.contains(&method.id) {\n-                            found_pub_static = true;\n-                            visit::walk_method_helper(self, &**method, ());\n+                    for impl_item in impl_items.iter() {\n+                        match *impl_item {\n+                            ast::MethodImplItem(method) => {\n+                                if method.pe_explicit_self().node ==\n+                                        ast::SelfStatic &&\n+                                        self.exported_items\n+                                            .contains(&method.id) {\n+                                    found_pub_static = true;\n+                                    visit::walk_method_helper(self,\n+                                                              &*method,\n+                                                              ());\n+                                }\n+                            }\n                         }\n                     }\n                     if found_pub_static {"}, {"sha": "5dfc43daa646f763dcb0c9c835d3d007641a991c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 38, "deletions": 23, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -193,26 +193,37 @@ impl<'a> ReachableContext<'a> {\n                     _ => false,\n                 }\n             }\n-            Some(ast_map::NodeTraitMethod(trait_method)) => {\n+            Some(ast_map::NodeTraitItem(trait_method)) => {\n                 match *trait_method {\n-                    ast::Required(_) => false,\n-                    ast::Provided(_) => true,\n+                    ast::RequiredMethod(_) => false,\n+                    ast::ProvidedMethod(_) => true,\n                 }\n             }\n-            Some(ast_map::NodeMethod(method)) => {\n-                if generics_require_inlining(method.pe_generics()) ||\n-                        attributes_specify_inlining(method.attrs.as_slice()) {\n-                    true\n-                } else {\n-                    let impl_did = self.tcx.map.get_parent_did(node_id);\n-                    // Check the impl. If the generics on the self type of the\n-                    // impl require inlining, this method does too.\n-                    assert!(impl_did.krate == ast::LOCAL_CRATE);\n-                    match self.tcx.map.expect_item(impl_did.node).node {\n-                        ast::ItemImpl(ref generics, _, _, _) => {\n-                            generics_require_inlining(generics)\n+            Some(ast_map::NodeImplItem(impl_item)) => {\n+                match *impl_item {\n+                    ast::MethodImplItem(method) => {\n+                        if generics_require_inlining(method.pe_generics()) ||\n+                                attributes_specify_inlining(\n+                                    method.attrs.as_slice()) {\n+                            true\n+                        } else {\n+                            let impl_did = self.tcx\n+                                               .map\n+                                               .get_parent_did(node_id);\n+                            // Check the impl. If the generics on the self\n+                            // type of the impl require inlining, this method\n+                            // does too.\n+                            assert!(impl_did.krate == ast::LOCAL_CRATE);\n+                            match self.tcx\n+                                      .map\n+                                      .expect_item(impl_did.node)\n+                                      .node {\n+                                ast::ItemImpl(ref generics, _, _, _) => {\n+                                    generics_require_inlining(generics)\n+                                }\n+                                _ => false\n+                            }\n                         }\n-                        _ => false\n                     }\n                 }\n             }\n@@ -310,20 +321,24 @@ impl<'a> ReachableContext<'a> {\n                     }\n                 }\n             }\n-            ast_map::NodeTraitMethod(trait_method) => {\n+            ast_map::NodeTraitItem(trait_method) => {\n                 match *trait_method {\n-                    ast::Required(..) => {\n+                    ast::RequiredMethod(..) => {\n                         // Keep going, nothing to get exported\n                     }\n-                    ast::Provided(ref method) => {\n+                    ast::ProvidedMethod(ref method) => {\n                         visit::walk_block(self, &*method.pe_body(), ())\n                     }\n                 }\n             }\n-            ast_map::NodeMethod(method) => {\n-                let did = self.tcx.map.get_parent_did(search_item);\n-                if method_might_be_inlined(self.tcx, &*method, did) {\n-                    visit::walk_block(self, &*method.pe_body(), ())\n+            ast_map::NodeImplItem(impl_item) => {\n+                match *impl_item {\n+                    ast::MethodImplItem(method) => {\n+                        let did = self.tcx.map.get_parent_did(search_item);\n+                        if method_might_be_inlined(self.tcx, &*method, did) {\n+                            visit::walk_block(self, &*method.pe_body(), ())\n+                        }\n+                    }\n                 }\n             }\n             // Nothing to recurse on for these"}, {"sha": "9edf9fcbdbad62754d8aa973ee65041c3038983c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 115, "deletions": 98, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -24,7 +24,7 @@ use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n use syntax::ast::*;\n use syntax::ast;\n use syntax::ast_util::{local_def, PostExpansionMethod};\n-use syntax::ast_util::{walk_pat, trait_method_to_ty_method};\n+use syntax::ast_util::{walk_pat, trait_item_to_ty_method};\n use syntax::ext::mtwt;\n use syntax::parse::token::special_names;\n use syntax::parse::token::special_idents;\n@@ -36,7 +36,7 @@ use syntax::visit::Visitor;\n \n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n-use std::gc::{Gc, GC};\n+use std::gc::GC;\n use std::mem::replace;\n use std::rc::{Rc, Weak};\n use std::uint;\n@@ -225,7 +225,7 @@ enum FallbackSuggestion {\n     NoSuggestion,\n     Field,\n     Method,\n-    TraitMethod,\n+    TraitItem,\n     StaticMethod(String),\n     StaticTraitMethod(String),\n }\n@@ -272,10 +272,10 @@ enum RibKind {\n     ConstantItemRibKind\n }\n \n-// Methods can be required or provided. Required methods only occur in traits.\n+// Methods can be required or provided. RequiredMethod methods only occur in traits.\n enum MethodSort {\n-    Required,\n-    Provided(NodeId)\n+    RequiredMethod,\n+    ProvidedMethod(NodeId)\n }\n \n enum UseLexicalScopeFlag {\n@@ -289,19 +289,19 @@ enum ModulePrefixResult {\n }\n \n #[deriving(Clone, Eq, PartialEq)]\n-enum MethodIsStaticFlag {\n-    MethodIsNotStatic,\n-    MethodIsStatic,\n+pub enum TraitItemKind {\n+    NonstaticMethodTraitItemKind,\n+    StaticMethodTraitItemKind,\n }\n \n-impl MethodIsStaticFlag {\n-    fn from_explicit_self_category(explicit_self_category:\n-                                   ExplicitSelfCategory)\n-                                   -> MethodIsStaticFlag {\n+impl TraitItemKind {\n+    pub fn from_explicit_self_category(explicit_self_category:\n+                                       ExplicitSelfCategory)\n+                                       -> TraitItemKind {\n         if explicit_self_category == StaticExplicitSelfCategory {\n-            MethodIsStatic\n+            StaticMethodTraitItemKind\n         } else {\n-            MethodIsNotStatic\n+            NonstaticMethodTraitItemKind\n         }\n     }\n }\n@@ -824,7 +824,7 @@ struct Resolver<'a> {\n \n     graph_root: NameBindings,\n \n-    method_map: RefCell<FnvHashMap<(Name, DefId), MethodIsStaticFlag>>,\n+    trait_item_map: RefCell<FnvHashMap<(Name, DefId), TraitItemKind>>,\n \n     structs: FnvHashMap<DefId, Vec<Name>>,\n \n@@ -934,7 +934,7 @@ impl<'a> Resolver<'a> {\n \n             graph_root: graph_root,\n \n-            method_map: RefCell::new(FnvHashMap::new()),\n+            trait_item_map: RefCell::new(FnvHashMap::new()),\n             structs: FnvHashMap::new(),\n \n             unresolved_imports: 0,\n@@ -1263,7 +1263,7 @@ impl<'a> Resolver<'a> {\n                 parent\n             }\n \n-            ItemImpl(_, None, ty, ref methods) => {\n+            ItemImpl(_, None, ty, ref impl_items) => {\n                 // If this implements an anonymous trait, then add all the\n                 // methods within to a new module, if the type was defined\n                 // within this module.\n@@ -1315,35 +1315,43 @@ impl<'a> Resolver<'a> {\n                             }\n                         };\n \n-                        // For each method...\n-                        for method in methods.iter() {\n-                            // Add the method to the module.\n-                            let ident = method.pe_ident();\n-                            let method_name_bindings =\n-                                self.add_child(ident,\n-                                               new_parent.clone(),\n-                                               ForbidDuplicateValues,\n-                                               method.span);\n-                            let def = match method.pe_explicit_self().node {\n-                                SelfStatic => {\n-                                    // Static methods become\n-                                    // `def_static_method`s.\n-                                    DefStaticMethod(local_def(method.id),\n-                                                      FromImpl(local_def(\n-                                                        item.id)),\n-                                                      method.pe_fn_style())\n-                                }\n-                                _ => {\n-                                    // Non-static methods become\n-                                    // `def_method`s.\n-                                    DefMethod(local_def(method.id), None)\n-                                }\n-                            };\n+                        // For each implementation item...\n+                        for impl_item in impl_items.iter() {\n+                            match *impl_item {\n+                                MethodImplItem(method) => {\n+                                    // Add the method to the module.\n+                                    let ident = method.pe_ident();\n+                                    let method_name_bindings =\n+                                        self.add_child(ident,\n+                                                       new_parent.clone(),\n+                                                       ForbidDuplicateValues,\n+                                                       method.span);\n+                                    let def = match method.pe_explicit_self()\n+                                                          .node {\n+                                        SelfStatic => {\n+                                            // Static methods become\n+                                            // `def_static_method`s.\n+                                            DefStaticMethod(\n+                                                local_def(method.id),\n+                                                FromImpl(local_def(item.id)),\n+                                                         method.pe_fn_style())\n+                                        }\n+                                        _ => {\n+                                            // Non-static methods become\n+                                            // `def_method`s.\n+                                            DefMethod(local_def(method.id),\n+                                                      None)\n+                                        }\n+                                    };\n \n-                            let is_public = method.pe_vis() == ast::Public;\n-                            method_name_bindings.define_value(def,\n-                                                              method.span,\n-                                                              is_public);\n+                                    let is_public =\n+                                        method.pe_vis() == ast::Public;\n+                                    method_name_bindings.define_value(\n+                                        def,\n+                                        method.span,\n+                                        is_public);\n+                                }\n+                            }\n                         }\n                     }\n                     _ => {}\n@@ -1376,7 +1384,7 @@ impl<'a> Resolver<'a> {\n \n                 // Add the names of all the methods to the trait info.\n                 for method in methods.iter() {\n-                    let ty_m = trait_method_to_ty_method(method);\n+                    let ty_m = trait_item_to_ty_method(method);\n \n                     let ident = ty_m.ident;\n \n@@ -1387,13 +1395,13 @@ impl<'a> Resolver<'a> {\n                             (DefStaticMethod(local_def(ty_m.id),\n                                               FromTrait(local_def(item.id)),\n                                               ty_m.fn_style),\n-                             MethodIsStatic)\n+                             StaticMethodTraitItemKind)\n                         }\n                         _ => {\n                             // Non-static methods become `def_method`s.\n                             (DefMethod(local_def(ty_m.id),\n                                        Some(local_def(item.id))),\n-                             MethodIsNotStatic)\n+                             NonstaticMethodTraitItemKind)\n                         }\n                     };\n \n@@ -1404,7 +1412,7 @@ impl<'a> Resolver<'a> {\n                                        ty_m.span);\n                     method_name_bindings.define_value(def, ty_m.span, true);\n \n-                    self.method_map\n+                    self.trait_item_map\n                         .borrow_mut()\n                         .insert((ident.name, def_id), static_flag);\n                 }\n@@ -1714,29 +1722,29 @@ impl<'a> Resolver<'a> {\n               debug!(\"(building reduced graph for external \\\n                       crate) building type {}\", final_ident);\n \n-              // If this is a trait, add all the method names\n-              // to the trait info.\n+              // If this is a trait, add all the trait item names to the trait\n+              // info.\n \n-              let method_def_ids =\n-                csearch::get_trait_method_def_ids(&self.session.cstore, def_id);\n-              for &method_def_id in method_def_ids.iter() {\n-                  let (method_name, explicit_self) =\n-                      csearch::get_method_name_and_explicit_self(&self.session.cstore,\n-                                                                 method_def_id);\n+              let trait_item_def_ids =\n+                csearch::get_trait_item_def_ids(&self.session.cstore, def_id);\n+              for trait_item_def_id in trait_item_def_ids.iter() {\n+                  let (trait_item_name, trait_item_kind) =\n+                      csearch::get_trait_item_name_and_kind(\n+                          &self.session.cstore,\n+                          trait_item_def_id.def_id());\n \n-                  debug!(\"(building reduced graph for \\\n-                          external crate) ... adding \\\n-                          trait method '{}'\",\n-                         token::get_ident(method_name));\n+                  debug!(\"(building reduced graph for external crate) ... \\\n+                          adding trait item '{}'\",\n+                         token::get_ident(trait_item_name));\n \n-                  self.method_map\n+                  self.trait_item_map\n                       .borrow_mut()\n-                      .insert((method_name.name, def_id),\n-                              MethodIsStaticFlag::from_explicit_self_category(\n-                                  explicit_self));\n+                      .insert((trait_item_name.name, def_id),\n+                              trait_item_kind);\n \n                   if is_exported {\n-                      self.external_exports.insert(method_def_id);\n+                      self.external_exports\n+                          .insert(trait_item_def_id.def_id());\n                   }\n               }\n \n@@ -3680,12 +3688,12 @@ impl<'a> Resolver<'a> {\n             ItemImpl(ref generics,\n                      ref implemented_traits,\n                      ref self_type,\n-                     ref methods) => {\n+                     ref impl_items) => {\n                 self.resolve_implementation(item.id,\n                                             generics,\n                                             implemented_traits,\n                                             &**self_type,\n-                                            methods.as_slice());\n+                                            impl_items.as_slice());\n             }\n \n             ItemTrait(ref generics, ref unbound, ref traits, ref methods) => {\n@@ -3724,12 +3732,12 @@ impl<'a> Resolver<'a> {\n                         // FIXME #4951: Do we need a node ID here?\n \n                         match *method {\n-                          ast::Required(ref ty_m) => {\n+                          ast::RequiredMethod(ref ty_m) => {\n                             this.with_type_parameter_rib\n                                 (HasTypeParameters(&ty_m.generics,\n                                                    FnSpace,\n                                                    item.id,\n-                                        MethodRibKind(item.id, Required)),\n+                                        MethodRibKind(item.id, RequiredMethod)),\n                                  |this| {\n \n                                 // Resolve the method-specific type\n@@ -3751,9 +3759,9 @@ impl<'a> Resolver<'a> {\n                                 this.resolve_type(&*ty_m.decl.output);\n                             });\n                           }\n-                          ast::Provided(ref m) => {\n+                          ast::ProvidedMethod(ref m) => {\n                               this.resolve_method(MethodRibKind(item.id,\n-                                                                Provided(m.id)),\n+                                                                ProvidedMethod(m.id)),\n                                                   &**m)\n                           }\n                         }\n@@ -4129,7 +4137,7 @@ impl<'a> Resolver<'a> {\n                               generics: &Generics,\n                               opt_trait_reference: &Option<TraitRef>,\n                               self_type: &Ty,\n-                              methods: &[Gc<Method>]) {\n+                              impl_items: &[ImplItem]) {\n         // If applicable, create a rib for the type parameters.\n         self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                        TypeSpace,\n@@ -4145,27 +4153,36 @@ impl<'a> Resolver<'a> {\n                 this.resolve_type(self_type);\n \n                 this.with_current_self_type(self_type, |this| {\n-                    for method in methods.iter() {\n-                        // If this is a trait impl, ensure the method exists in trait\n-                        this.check_trait_method(&**method);\n-\n-                        // We also need a new scope for the method-specific type parameters.\n-                        this.resolve_method(MethodRibKind(id, Provided(method.id)),\n-                                            &**method);\n+                    for impl_item in impl_items.iter() {\n+                        match *impl_item {\n+                            MethodImplItem(method) => {\n+                                // If this is a trait impl, ensure the method\n+                                // exists in trait\n+                                this.check_trait_item(method.pe_ident(),\n+                                                      method.span);\n+\n+                                // We also need a new scope for the method-\n+                                // specific type parameters.\n+                                this.resolve_method(\n+                                    MethodRibKind(id,\n+                                                  ProvidedMethod(method.id)),\n+                                    &*method);\n+                            }\n+                        }\n                     }\n                 });\n             });\n         });\n     }\n \n-    fn check_trait_method(&self, method: &Method) {\n+    fn check_trait_item(&self, ident: Ident, span: Span) {\n         // If there is a TraitRef in scope for an impl, then the method must be in the trait.\n         for &(did, ref trait_ref) in self.current_trait_ref.iter() {\n-            let method_name = method.pe_ident().name;\n+            let method_name = ident.name;\n \n-            if self.method_map.borrow().find(&(method_name, did)).is_none() {\n+            if self.trait_item_map.borrow().find(&(method_name, did)).is_none() {\n                 let path_str = self.path_idents_to_string(&trait_ref.path);\n-                self.resolve_error(method.span,\n+                self.resolve_error(span,\n                                     format!(\"method `{}` is not a member of trait `{}`\",\n                                             token::get_name(method_name),\n                                             path_str).as_slice());\n@@ -4845,8 +4862,8 @@ impl<'a> Resolver<'a> {\n             TraitModuleKind | ImplModuleKind => {\n                 match containing_module.def_id.get() {\n                     Some(def_id) => {\n-                        match self.method_map.borrow().find(&(ident.name, def_id)) {\n-                            Some(&MethodIsStatic) => (),\n+                        match self.trait_item_map.borrow().find(&(ident.name, def_id)) {\n+                            Some(&StaticMethodTraitItemKind) => (),\n                             None => (),\n                             _ => {\n                                 debug!(\"containing module was a trait or impl \\\n@@ -5102,7 +5119,7 @@ impl<'a> Resolver<'a> {\n                             }\n                         }\n                         Some(DefMethod(_, None)) if allowed == Everything => return Method,\n-                        Some(DefMethod(_, Some(_))) => return TraitMethod,\n+                        Some(DefMethod(_, Some(_))) => return TraitItem,\n                         _ => ()\n                     }\n                 }\n@@ -5112,14 +5129,14 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Look for a method in the current trait.\n-        let method_map = self.method_map.borrow();\n+        let trait_item_map = self.trait_item_map.borrow();\n         match self.current_trait_ref {\n             Some((did, ref trait_ref)) => {\n                 let path_str = self.path_idents_to_string(&trait_ref.path);\n \n-                match method_map.find(&(name, did)) {\n-                    Some(&MethodIsStatic) => return StaticTraitMethod(path_str),\n-                    Some(_) => return TraitMethod,\n+                match trait_item_map.find(&(name, did)) {\n+                    Some(&StaticMethodTraitItemKind) => return StaticTraitMethod(path_str),\n+                    Some(_) => return TraitItem,\n                     None => {}\n                 }\n             }\n@@ -5262,7 +5279,7 @@ impl<'a> Resolver<'a> {\n                                         Field =>\n                                             format!(\"`self.{}`\", wrong_name),\n                                         Method\n-                                        | TraitMethod =>\n+                                        | TraitItem =>\n                                             format!(\"to call `self.{}`\", wrong_name),\n                                         StaticTraitMethod(path_str)\n                                         | StaticMethod(path_str) =>\n@@ -5437,9 +5454,9 @@ impl<'a> Resolver<'a> {\n             // Look for the current trait.\n             match self.current_trait_ref {\n                 Some((trait_def_id, _)) => {\n-                    let method_map = self.method_map.borrow();\n+                    let trait_item_map = self.trait_item_map.borrow();\n \n-                    if method_map.contains_key(&(name, trait_def_id)) {\n+                    if trait_item_map.contains_key(&(name, trait_def_id)) {\n                         add_trait_info(&mut found_traits, trait_def_id, name);\n                     }\n                 }\n@@ -5450,7 +5467,7 @@ impl<'a> Resolver<'a> {\n             self.populate_module_if_necessary(&search_module);\n \n             {\n-                let method_map = self.method_map.borrow();\n+                let trait_item_map = self.trait_item_map.borrow();\n                 for (_, child_names) in search_module.children.borrow().iter() {\n                     let def = match child_names.def_for_namespace(TypeNS) {\n                         Some(def) => def,\n@@ -5460,7 +5477,7 @@ impl<'a> Resolver<'a> {\n                         DefTrait(trait_def_id) => trait_def_id,\n                         _ => continue,\n                     };\n-                    if method_map.contains_key(&(name, trait_def_id)) {\n+                    if trait_item_map.contains_key(&(name, trait_def_id)) {\n                         add_trait_info(&mut found_traits, trait_def_id, name);\n                     }\n                 }\n@@ -5476,7 +5493,7 @@ impl<'a> Resolver<'a> {\n                     Some(DefTrait(trait_def_id)) => trait_def_id,\n                     Some(..) | None => continue,\n                 };\n-                if self.method_map.borrow().contains_key(&(name, did)) {\n+                if self.trait_item_map.borrow().contains_key(&(name, did)) {\n                     add_trait_info(&mut found_traits, did, name);\n                     self.used_imports.insert((import.type_id, TypeNS));\n                 }"}, {"sha": "11b16f1853379372999919fd9f45379af76bc5a8", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 110, "deletions": 43, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -283,8 +283,8 @@ impl <'l> DxrVisitor<'l> {\n                             let mut result = String::from_str(\"<\");\n                             result.push_str(ty_to_string(&*ty).as_slice());\n \n-                            match ty::trait_of_method(&self.analysis.ty_cx,\n-                                                      ast_util::local_def(method.id)) {\n+                            match ty::trait_of_item(&self.analysis.ty_cx,\n+                                                    ast_util::local_def(method.id)) {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n@@ -310,8 +310,8 @@ impl <'l> DxrVisitor<'l> {\n                                               ).as_slice());\n                 },\n             },\n-            None => match ty::trait_of_method(&self.analysis.ty_cx,\n-                                              ast_util::local_def(method.id)) {\n+            None => match ty::trait_of_item(&self.analysis.ty_cx,\n+                                            ast_util::local_def(method.id)) {\n                 Some(def_id) => {\n                     scope_id = def_id.node;\n                     match self.analysis.ty_cx.map.get(def_id.node) {\n@@ -338,9 +338,19 @@ impl <'l> DxrVisitor<'l> {\n         let qualname = qualname.as_slice();\n \n         // record the decl for this def (if it has one)\n-        let decl_id = ty::trait_method_of_method(&self.analysis.ty_cx,\n-                                                 ast_util::local_def(method.id))\n-            .filtered(|def_id| method.id != 0 && def_id.node == 0);\n+        let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n+                                             ast_util::local_def(method.id))\n+            .filtered(|def_id| {\n+                match *def_id {\n+                    ty::MethodTraitItemId(def_id) => {\n+                        method.id != 0 && def_id.node == 0\n+                    }\n+                }\n+            });\n+        let decl_id = match decl_id {\n+            None => None,\n+            Some(ty::MethodTraitItemId(def_id)) => Some(def_id),\n+        };\n \n         let sub_span = self.span.sub_span_after_keyword(method.span, keywords::Fn);\n         self.fmt.method_str(method.span,\n@@ -601,7 +611,7 @@ impl <'l> DxrVisitor<'l> {\n                     type_parameters: &ast::Generics,\n                     trait_ref: &Option<ast::TraitRef>,\n                     typ: ast::P<ast::Ty>,\n-                    methods: &Vec<Gc<ast::Method>>) {\n+                    impl_items: &Vec<ast::ImplItem>) {\n         match typ.node {\n             ast::TyPath(ref path, _, id) => {\n                 match self.lookup_type_ref(id) {\n@@ -630,8 +640,12 @@ impl <'l> DxrVisitor<'l> {\n         }\n \n         self.process_generic_params(type_parameters, item.span, \"\", item.id, e);\n-        for method in methods.iter() {\n-            visit::walk_method_helper(self, &**method, e)\n+        for impl_item in impl_items.iter() {\n+            match *impl_item {\n+                ast::MethodImplItem(method) => {\n+                    visit::walk_method_helper(self, &*method, e)\n+                }\n+            }\n         }\n     }\n \n@@ -640,7 +654,7 @@ impl <'l> DxrVisitor<'l> {\n                      e: DxrVisitorEnv,\n                      generics: &ast::Generics,\n                      trait_refs: &Vec<ast::TraitRef>,\n-                     methods: &Vec<ast::TraitMethod>) {\n+                     methods: &Vec<ast::TraitItem>) {\n         let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n \n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n@@ -672,7 +686,7 @@ impl <'l> DxrVisitor<'l> {\n         // walk generics and methods\n         self.process_generic_params(generics, item.span, qualname.as_slice(), item.id, e);\n         for method in methods.iter() {\n-            self.visit_trait_method(method, e)\n+            self.visit_trait_item(method, e)\n         }\n     }\n \n@@ -735,18 +749,44 @@ impl <'l> DxrVisitor<'l> {\n             def::DefStaticMethod(declid, provenence, _) => {\n                 let sub_span = self.span.sub_span_for_meth_name(ex.span);\n                 let defid = if declid.krate == ast::LOCAL_CRATE {\n-                    let m = ty::method(&self.analysis.ty_cx, declid);\n+                    let ti = ty::impl_or_trait_item(&self.analysis.ty_cx,\n+                                                    declid);\n                     match provenence {\n-                        def::FromTrait(def_id) =>\n-                            Some(ty::trait_methods(&self.analysis.ty_cx, def_id)\n-                                .iter().find(|mr| mr.ident.name == m.ident.name).unwrap().def_id),\n+                        def::FromTrait(def_id) => {\n+                            Some(ty::trait_items(&self.analysis.ty_cx,\n+                                                 def_id)\n+                                    .iter()\n+                                    .find(|mr| {\n+                                        match **mr {\n+                                            ty::MethodTraitItem(ref mr) => {\n+                                                mr.ident.name == ti.ident()\n+                                                                   .name\n+                                            }\n+                                        }\n+                                    })\n+                                    .unwrap()\n+                                    .def_id())\n+                        }\n                         def::FromImpl(def_id) => {\n-                            let impl_methods = self.analysis.ty_cx.impl_methods.borrow();\n-                            Some(*impl_methods.get(&def_id)\n-                                .iter().find(|mr|\n-                                    ty::method(\n-                                        &self.analysis.ty_cx, **mr).ident.name == m.ident.name)\n-                                .unwrap())\n+                            let impl_items = self.analysis\n+                                                 .ty_cx\n+                                                 .impl_items\n+                                                 .borrow();\n+                            Some(impl_items.get(&def_id)\n+                                           .iter()\n+                                           .find(|mr| {\n+                                            match **mr {\n+                                                ty::MethodTraitItemId(mr) => {\n+                                                    ty::impl_or_trait_item(\n+                                                            &self.analysis\n+                                                                 .ty_cx,\n+                                                            mr).ident()\n+                                                               .name ==\n+                                                        ti.ident().name\n+                                                    }\n+                                                }\n+                                            }).unwrap()\n+                                              .def_id())\n                         }\n                     }\n                 } else {\n@@ -845,27 +885,45 @@ impl <'l> DxrVisitor<'l> {\n             typeck::MethodStatic(def_id) |\n             typeck::MethodStaticUnboxedClosure(def_id) => {\n                 // method invoked on an object with a concrete type (not a static method)\n-                let decl_id = ty::trait_method_of_method(&self.analysis.ty_cx, def_id);\n+                let decl_id =\n+                    match ty::trait_item_of_item(&self.analysis.ty_cx,\n+                                                 def_id) {\n+                        None => None,\n+                        Some(ty::MethodTraitItemId(decl_id)) => Some(decl_id),\n+                    };\n \n-                // This incantation is required if the method referenced is a trait's\n-                // default implementation.\n-                let def_id = ty::method(&self.analysis.ty_cx, def_id).provided_source\n-                                    .unwrap_or(def_id);\n+                // This incantation is required if the method referenced is a\n+                // trait's default implementation.\n+                let def_id = match ty::impl_or_trait_item(&self.analysis\n+                                                               .ty_cx,\n+                                                          def_id) {\n+                    ty::MethodTraitItem(method) => {\n+                        method.provided_source.unwrap_or(def_id)\n+                    }\n+                };\n                 (Some(def_id), decl_id)\n             }\n             typeck::MethodParam(mp) => {\n                 // method invoked on a type parameter\n-                let method = ty::trait_method(&self.analysis.ty_cx,\n-                                              mp.trait_id,\n-                                              mp.method_num);\n-                (None, Some(method.def_id))\n+                let trait_item = ty::trait_item(&self.analysis.ty_cx,\n+                                                mp.trait_id,\n+                                                mp.method_num);\n+                match trait_item {\n+                    ty::MethodTraitItem(method) => {\n+                        (None, Some(method.def_id))\n+                    }\n+                }\n             },\n             typeck::MethodObject(mo) => {\n                 // method invoked on a trait instance\n-                let method = ty::trait_method(&self.analysis.ty_cx,\n-                                              mo.trait_id,\n-                                              mo.method_num);\n-                (None, Some(method.def_id))\n+                let trait_item = ty::trait_item(&self.analysis.ty_cx,\n+                                                mo.trait_id,\n+                                                mo.method_num);\n+                match trait_item {\n+                    ty::MethodTraitItem(method) => {\n+                        (None, Some(method.def_id))\n+                    }\n+                }\n             },\n         };\n         let sub_span = self.span.sub_span_for_meth_name(ex.span);\n@@ -968,8 +1026,17 @@ impl<'l> Visitor<DxrVisitorEnv> for DxrVisitor<'l> {\n                 self.process_static(item, e, typ, mt, &*expr),\n             ast::ItemStruct(def, ref ty_params) => self.process_struct(item, e, &*def, ty_params),\n             ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, e, def, ty_params),\n-            ast::ItemImpl(ref ty_params, ref trait_ref, typ, ref methods) =>\n-                self.process_impl(item, e, ty_params, trait_ref, typ, methods),\n+            ast::ItemImpl(ref ty_params,\n+                          ref trait_ref,\n+                          typ,\n+                          ref impl_items) => {\n+                self.process_impl(item,\n+                                  e,\n+                                  ty_params,\n+                                  trait_ref,\n+                                  typ,\n+                                  impl_items)\n+            }\n             ast::ItemTrait(ref generics, _, ref trait_refs, ref methods) =>\n                 self.process_trait(item, e, generics, trait_refs, methods),\n             ast::ItemMod(ref m) => self.process_mod(item, e, m),\n@@ -1027,16 +1094,16 @@ impl<'l> Visitor<DxrVisitorEnv> for DxrVisitor<'l> {\n         }\n     }\n \n-    fn visit_trait_method(&mut self, tm: &ast::TraitMethod, e: DxrVisitorEnv) {\n+    fn visit_trait_item(&mut self, tm: &ast::TraitItem, e: DxrVisitorEnv) {\n         match *tm {\n-            ast::Required(ref method_type) => {\n+            ast::RequiredMethod(ref method_type) => {\n                 if generated_code(method_type.span) {\n                     return;\n                 }\n \n-                let mut scope_id ;\n-                let mut qualname = match ty::trait_of_method(&self.analysis.ty_cx,\n-                                                             ast_util::local_def(method_type.id)) {\n+                let mut scope_id;\n+                let mut qualname = match ty::trait_of_item(&self.analysis.ty_cx,\n+                                                           ast_util::local_def(method_type.id)) {\n                     Some(def_id) => {\n                         scope_id = def_id.node;\n                         ty::item_path_str(&self.analysis.ty_cx, def_id).append(\"::\")\n@@ -1070,7 +1137,7 @@ impl<'l> Visitor<DxrVisitorEnv> for DxrVisitor<'l> {\n                                             method_type.id,\n                                             e);\n             }\n-            ast::Provided(method) => self.process_method(&*method, e),\n+            ast::ProvidedMethod(method) => self.process_method(&*method, e),\n         }\n     }\n "}, {"sha": "e73d81d9bf5974923a14383547eb37ea6bb37da5", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -16,7 +16,7 @@ use syntax::codemap::Span;\n use syntax::{attr, visit};\n use syntax::ast;\n use syntax::ast::{Attribute, Block, Crate, DefId, FnDecl, NodeId, Variant};\n-use syntax::ast::{Item, Required, Provided, TraitMethod, TypeMethod, Method};\n+use syntax::ast::{Item, RequiredMethod, ProvidedMethod, TraitItem, TypeMethod, Method};\n use syntax::ast::{Generics, StructDef, StructField, Ident};\n use syntax::ast_util::is_local;\n use syntax::attr::Stability;\n@@ -68,18 +68,18 @@ impl Visitor<Option<Stability>> for Annotator {\n         visit::walk_fn(self, fk, fd, b, s, stab)\n     }\n \n-    fn visit_trait_method(&mut self, t: &TraitMethod, parent: Option<Stability>) {\n+    fn visit_trait_item(&mut self, t: &TraitItem, parent: Option<Stability>) {\n         let stab = match *t {\n-            Required(TypeMethod {attrs: ref attrs, id: id, ..}) =>\n+            RequiredMethod(TypeMethod {attrs: ref attrs, id: id, ..}) =>\n                 self.annotate(id, attrs.as_slice(), parent),\n \n             // work around lack of pattern matching for @ types\n-            Provided(method) => match *method {\n+            ProvidedMethod(method) => match *method {\n                 Method {attrs: ref attrs, id: id, ..} =>\n                     self.annotate(id, attrs.as_slice(), parent)\n             }\n         };\n-        visit::walk_trait_method(self, t, stab)\n+        visit::walk_trait_item(self, t, stab)\n     }\n \n     fn visit_variant(&mut self, v: &Variant, g: &Generics, parent: Option<Stability>) {\n@@ -116,10 +116,11 @@ impl Index {\n \n /// Lookup the stability for a node, loading external crate\n /// metadata as necessary.\n-pub fn lookup(tcx: &ty::ctxt,  id: DefId) -> Option<Stability> {\n+pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n     // is this definition the implementation of a trait method?\n-    match ty::trait_method_of_method(tcx, id) {\n-        Some(trait_method_id) if trait_method_id != id => {\n+    match ty::trait_item_of_item(tcx, id) {\n+        Some(ty::MethodTraitItemId(trait_method_id))\n+                if trait_method_id != id => {\n             lookup(tcx, trait_method_id)\n         }\n         _ if is_local(id) => {"}, {"sha": "9aa4355632cfb3273bb454b05a978819fdbddf36", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -1299,9 +1299,9 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n                 _ => tcx.sess.bug(\"unexpected item variant in has_nested_returns\")\n             }\n         }\n-        Some(ast_map::NodeTraitMethod(trait_method)) => {\n+        Some(ast_map::NodeTraitItem(trait_method)) => {\n             match *trait_method {\n-                ast::Provided(m) => {\n+                ast::ProvidedMethod(m) => {\n                     match m.node {\n                         ast::MethDecl(_, _, _, _, _, _, blk, _) => {\n                             let mut explicit = CheckForNestedReturnsVisitor { found: false };\n@@ -1313,20 +1313,34 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n                         ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n                     }\n                 }\n-                ast::Required(_) => tcx.sess.bug(\"unexpected variant: required trait method in \\\n-                                                  has_nested_returns\")\n+                ast::RequiredMethod(_) => {\n+                    tcx.sess.bug(\"unexpected variant: required trait method \\\n+                                  in has_nested_returns\")\n+                }\n             }\n         }\n-        Some(ast_map::NodeMethod(m)) => {\n-            match m.node {\n-                ast::MethDecl(_, _, _, _, _, _, blk, _) => {\n-                    let mut explicit = CheckForNestedReturnsVisitor { found: false };\n-                    let mut implicit = CheckForNestedReturnsVisitor { found: false };\n-                    visit::walk_method_helper(&mut explicit, &*m, false);\n-                    visit::walk_expr_opt(&mut implicit, blk.expr, true);\n-                    explicit.found || implicit.found\n+        Some(ast_map::NodeImplItem(ref ii)) => {\n+            match **ii {\n+                ast::MethodImplItem(ref m) => {\n+                    match m.node {\n+                        ast::MethDecl(_, _, _, _, _, _, blk, _) => {\n+                            let mut explicit = CheckForNestedReturnsVisitor {\n+                                found: false,\n+                            };\n+                            let mut implicit = CheckForNestedReturnsVisitor {\n+                                found: false,\n+                            };\n+                            visit::walk_method_helper(&mut explicit,\n+                                                      &**m,\n+                                                      false);\n+                            visit::walk_expr_opt(&mut implicit,\n+                                                 blk.expr,\n+                                                 true);\n+                            explicit.found || implicit.found\n+                        }\n+                        ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n+                    }\n                 }\n-                ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n             }\n         }\n         Some(ast_map::NodeExpr(e)) => {\n@@ -2107,8 +2121,12 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n         let mut v = TransItemVisitor{ ccx: ccx };\n         v.visit_block(&**body, ());\n       }\n-      ast::ItemImpl(ref generics, _, _, ref ms) => {\n-        meth::trans_impl(ccx, item.ident, ms.as_slice(), generics, item.id);\n+      ast::ItemImpl(ref generics, _, _, ref impl_items) => {\n+        meth::trans_impl(ccx,\n+                         item.ident,\n+                         impl_items.as_slice(),\n+                         generics,\n+                         item.id);\n       }\n       ast::ItemMod(ref m) => {\n         trans_mod(ccx, m);\n@@ -2615,21 +2633,23 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             v\n         }\n \n-        ast_map::NodeTraitMethod(trait_method) => {\n-            debug!(\"get_item_val(): processing a NodeTraitMethod\");\n+        ast_map::NodeTraitItem(trait_method) => {\n+            debug!(\"get_item_val(): processing a NodeTraitItem\");\n             match *trait_method {\n-                ast::Required(_) => {\n+                ast::RequiredMethod(_) => {\n                     ccx.sess().bug(\"unexpected variant: required trait method in \\\n                                    get_item_val()\");\n                 }\n-                ast::Provided(m) => {\n+                ast::ProvidedMethod(m) => {\n                     register_method(ccx, id, &*m)\n                 }\n             }\n         }\n \n-        ast_map::NodeMethod(m) => {\n-            register_method(ccx, id, &*m)\n+        ast_map::NodeImplItem(ii) => {\n+            match *ii {\n+                ast::MethodImplItem(m) => register_method(ccx, id, &*m),\n+            }\n         }\n \n         ast_map::NodeForeignItem(ni) => {"}, {"sha": "56c1c66533133c222570fb8f173ca3fe70b88de1", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -77,7 +77,7 @@ pub enum CalleeData {\n \n     Intrinsic(ast::NodeId, subst::Substs),\n \n-    TraitMethod(MethodData)\n+    TraitItem(MethodData)\n }\n \n pub struct Callee<'a> {\n@@ -449,7 +449,7 @@ pub fn trans_fn_ref_with_vtables(\n     assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n \n     // Load the info for the appropriate trait if necessary.\n-    match ty::trait_of_method(tcx, def_id) {\n+    match ty::trait_of_item(tcx, def_id) {\n         None => {}\n         Some(trait_id) => {\n             ty::populate_implementations_for_trait_if_necessary(tcx, trait_id)\n@@ -476,35 +476,43 @@ pub fn trans_fn_ref_with_vtables(\n             // So, what we need to do is find this substitution and\n             // compose it with the one we already have.\n \n-            let impl_id = ty::method(tcx, def_id).container_id();\n-            let method = ty::method(tcx, source_id);\n-            let trait_ref = ty::impl_trait_ref(tcx, impl_id)\n-                .expect(\"could not find trait_ref for impl with \\\n-                         default methods\");\n-\n-            // Compute the first substitution\n-            let first_subst = make_substs_for_receiver_types(\n-                tcx, &*trait_ref, &*method);\n-\n-            // And compose them\n-            let new_substs = first_subst.subst(tcx, &substs);\n-\n-            debug!(\"trans_fn_with_vtables - default method: \\\n-                    substs = {}, trait_subst = {}, \\\n-                    first_subst = {}, new_subst = {}, \\\n-                    vtables = {}\",\n-                   substs.repr(tcx), trait_ref.substs.repr(tcx),\n-                   first_subst.repr(tcx), new_substs.repr(tcx),\n-                   vtables.repr(tcx));\n-\n-            let param_vtables =\n-                resolve_default_method_vtables(bcx, impl_id, &substs, vtables);\n-\n-            debug!(\"trans_fn_with_vtables - default method: \\\n-                    param_vtables = {}\",\n-                   param_vtables.repr(tcx));\n-\n-            (true, source_id, new_substs, param_vtables)\n+            let impl_id = ty::impl_or_trait_item(tcx, def_id).container()\n+                                                             .id();\n+            let impl_or_trait_item = ty::impl_or_trait_item(tcx, source_id);\n+            match impl_or_trait_item {\n+                ty::MethodTraitItem(method) => {\n+                    let trait_ref = ty::impl_trait_ref(tcx, impl_id)\n+                        .expect(\"could not find trait_ref for impl with \\\n+                                 default methods\");\n+\n+                    // Compute the first substitution\n+                    let first_subst = make_substs_for_receiver_types(\n+                        tcx, &*trait_ref, &*method);\n+\n+                    // And compose them\n+                    let new_substs = first_subst.subst(tcx, &substs);\n+\n+                    debug!(\"trans_fn_with_vtables - default method: \\\n+                            substs = {}, trait_subst = {}, \\\n+                            first_subst = {}, new_subst = {}, \\\n+                            vtables = {}\",\n+                           substs.repr(tcx), trait_ref.substs.repr(tcx),\n+                           first_subst.repr(tcx), new_substs.repr(tcx),\n+                           vtables.repr(tcx));\n+\n+                    let param_vtables =\n+                        resolve_default_method_vtables(bcx,\n+                                                       impl_id,\n+                                                       &substs,\n+                                                       vtables);\n+\n+                    debug!(\"trans_fn_with_vtables - default method: \\\n+                            param_vtables = {}\",\n+                           param_vtables.repr(tcx));\n+\n+                    (true, source_id, new_substs, param_vtables)\n+                }\n+            }\n         }\n     };\n \n@@ -742,7 +750,7 @@ pub fn trans_call_inner<'a>(\n         Fn(llfn) => {\n             (llfn, None, None)\n         }\n-        TraitMethod(d) => {\n+        TraitItem(d) => {\n             (d.llfn, None, Some(d.llself))\n         }\n         Closure(d) => {"}, {"sha": "9b78cedd4ac7f7425d5c7090aa0a73a94bf145c1", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -1140,13 +1140,17 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                 }\n             }\n         }\n-        ast_map::NodeMethod(ref method) => {\n-            (method.pe_ident(),\n-             method.pe_fn_decl(),\n-             method.pe_generics(),\n-             method.pe_body(),\n-             method.span,\n-             true)\n+        ast_map::NodeImplItem(ref item) => {\n+            match **item {\n+                ast::MethodImplItem(ref method) => {\n+                    (method.pe_ident(),\n+                     method.pe_fn_decl(),\n+                     method.pe_generics(),\n+                     method.pe_body(),\n+                     method.span,\n+                     true)\n+                }\n+            }\n         }\n         ast_map::NodeExpr(ref expr) => {\n             match expr.node {\n@@ -1168,9 +1172,9 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                         \"create_function_debug_context: expected an expr_fn_block here\")\n             }\n         }\n-        ast_map::NodeTraitMethod(ref trait_method) => {\n+        ast_map::NodeTraitItem(ref trait_method) => {\n             match **trait_method {\n-                ast::Provided(ref method) => {\n+                ast::ProvidedMethod(ref method) => {\n                     (method.pe_ident(),\n                      method.pe_fn_decl(),\n                      method.pe_generics(),"}, {"sha": "4b1f37fcdc22afaf6cc1e1c401aab01d1bf6caec", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -115,27 +115,42 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.sess().bug(\"maybe_get_item_ast returned a found_parent \\\n              with a non-item parent\");\n         }\n-        csearch::found(ast::IIMethod(impl_did, is_provided, mth)) => {\n-            ccx.external.borrow_mut().insert(fn_id, Some(mth.id));\n-            ccx.external_srcs.borrow_mut().insert(mth.id, fn_id);\n+        csearch::found(ast::IITraitItem(impl_did, impl_item)) => {\n+            match impl_item {\n+                ast::ProvidedInlinedTraitItem(mth) |\n+                ast::RequiredInlinedTraitItem(mth) => {\n+                    ccx.external.borrow_mut().insert(fn_id, Some(mth.id));\n+                    ccx.external_srcs.borrow_mut().insert(mth.id, fn_id);\n \n-            ccx.stats.n_inlines.set(ccx.stats.n_inlines.get() + 1);\n-\n-            // If this is a default method, we can't look up the\n-            // impl type. But we aren't going to translate anyways, so don't.\n-            if is_provided { return local_def(mth.id); }\n+                    ccx.stats.n_inlines.set(ccx.stats.n_inlines.get() + 1);\n+                }\n+            }\n \n-            let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n-            let unparameterized =\n-                impl_tpt.generics.types.is_empty() &&\n-                mth.pe_generics().ty_params.is_empty();\n+            match impl_item {\n+                ast::ProvidedInlinedTraitItem(mth) => {\n+                    // If this is a default method, we can't look up the\n+                    // impl type. But we aren't going to translate anyways, so\n+                    // don't.\n+                    local_def(mth.id)\n+                }\n+                ast::RequiredInlinedTraitItem(mth) => {\n+                    let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n+                    let unparameterized = impl_tpt.generics.types.is_empty() &&\n+                            mth.pe_generics().ty_params.is_empty();\n \n-          if unparameterized {\n-              let llfn = get_item_val(ccx, mth.id);\n-                trans_fn(ccx, &*mth.pe_fn_decl(), &*mth.pe_body(), llfn,\n-                       &param_substs::empty(), mth.id, []);\n-          }\n-          local_def(mth.id)\n+                    if unparameterized {\n+                        let llfn = get_item_val(ccx, mth.id);\n+                        trans_fn(ccx,\n+                                 &*mth.pe_fn_decl(),\n+                                 &*mth.pe_body(),\n+                                 llfn,\n+                                 &param_substs::empty(),\n+                                 mth.id,\n+                                 []);\n+                    }\n+                    local_def(mth.id)\n+                }\n+            }\n         }\n     };\n }"}, {"sha": "31f2a3df6620216a0f34156608fde051ca91c5d1", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 86, "deletions": 57, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -35,7 +35,6 @@ use util::common::indenter;\n use util::ppaux::Repr;\n \n use std::c_str::ToCStr;\n-use std::gc::Gc;\n use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n use syntax::{ast, ast_map, visit};\n@@ -49,7 +48,7 @@ see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n pub fn trans_impl(ccx: &CrateContext,\n                   name: ast::Ident,\n-                  methods: &[Gc<ast::Method>],\n+                  impl_items: &[ast::ImplItem],\n                   generics: &ast::Generics,\n                   id: ast::NodeId) {\n     let _icx = push_ctxt(\"meth::trans_impl\");\n@@ -61,24 +60,34 @@ pub fn trans_impl(ccx: &CrateContext,\n     // items that we need to translate.\n     if !generics.ty_params.is_empty() {\n         let mut v = TransItemVisitor{ ccx: ccx };\n-        for method in methods.iter() {\n-            visit::walk_method_helper(&mut v, &**method, ());\n+        for impl_item in impl_items.iter() {\n+            match *impl_item {\n+                ast::MethodImplItem(method) => {\n+                    visit::walk_method_helper(&mut v, &*method, ());\n+                }\n+            }\n         }\n         return;\n     }\n-    for method in methods.iter() {\n-        if method.pe_generics().ty_params.len() == 0u {\n-            let llfn = get_item_val(ccx, method.id);\n-            trans_fn(ccx,\n-                     &*method.pe_fn_decl(),\n-                     &*method.pe_body(),\n-                     llfn,\n-                     &param_substs::empty(),\n-                     method.id,\n-                     []);\n+    for impl_item in impl_items.iter() {\n+        match *impl_item {\n+            ast::MethodImplItem(method) => {\n+                if method.pe_generics().ty_params.len() == 0u {\n+                    let llfn = get_item_val(ccx, method.id);\n+                    trans_fn(ccx,\n+                             &*method.pe_fn_decl(),\n+                             &*method.pe_body(),\n+                             llfn,\n+                             &param_substs::empty(),\n+                             method.id,\n+                             []);\n+                }\n+                let mut v = TransItemVisitor {\n+                    ccx: ccx,\n+                };\n+                visit::walk_method_helper(&mut v, &*method, ());\n+            }\n         }\n-        let mut v = TransItemVisitor{ ccx: ccx };\n-        visit::walk_method_helper(&mut v, &**method, ());\n     }\n }\n \n@@ -165,10 +174,10 @@ pub fn trans_static_method_callee(bcx: &Block,\n \n     let mname = if method_id.krate == ast::LOCAL_CRATE {\n         match bcx.tcx().map.get(method_id.node) {\n-            ast_map::NodeTraitMethod(method) => {\n+            ast_map::NodeTraitItem(method) => {\n                 let ident = match *method {\n-                    ast::Required(ref m) => m.ident,\n-                    ast::Provided(ref m) => m.pe_ident()\n+                    ast::RequiredMethod(ref m) => m.ident,\n+                    ast::ProvidedMethod(ref m) => m.pe_ident()\n                 };\n                 ident.name\n             }\n@@ -213,22 +222,33 @@ pub fn trans_static_method_callee(bcx: &Block,\n     }\n }\n \n-fn method_with_name(ccx: &CrateContext,\n-                    impl_id: ast::DefId,\n-                    name: ast::Name) -> ast::DefId {\n+fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n+                    -> ast::DefId {\n     match ccx.impl_method_cache.borrow().find_copy(&(impl_id, name)) {\n         Some(m) => return m,\n         None => {}\n     }\n \n-    let methods = ccx.tcx.impl_methods.borrow();\n-    let methods = methods.find(&impl_id)\n-                         .expect(\"could not find impl while translating\");\n-    let meth_did = methods.iter().find(|&did| ty::method(&ccx.tcx, *did).ident.name == name)\n-                                 .expect(\"could not find method while translating\");\n-\n-    ccx.impl_method_cache.borrow_mut().insert((impl_id, name), *meth_did);\n-    *meth_did\n+    let impl_items = ccx.tcx.impl_items.borrow();\n+    let impl_items =\n+        impl_items.find(&impl_id)\n+                  .expect(\"could not find impl while translating\");\n+    let meth_did = impl_items.iter()\n+                             .find(|&did| {\n+                                match *did {\n+                                    ty::MethodTraitItemId(did) => {\n+                                        ty::impl_or_trait_item(&ccx.tcx,\n+                                                               did).ident()\n+                                                                   .name ==\n+                                            name\n+                                    }\n+                                }\n+                             }).expect(\"could not find method while \\\n+                                        translating\");\n+\n+    ccx.impl_method_cache.borrow_mut().insert((impl_id, name),\n+                                              meth_did.def_id());\n+    meth_did.def_id()\n }\n \n fn trans_monomorphized_callee<'a>(\n@@ -242,7 +262,9 @@ fn trans_monomorphized_callee<'a>(\n     match vtbl {\n       typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n-          let mname = ty::trait_method(ccx.tcx(), trait_id, n_method).ident;\n+          let mname = match ty::trait_item(ccx.tcx(), trait_id, n_method) {\n+              ty::MethodTraitItem(method) => method.ident,\n+          };\n           let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n \n           // create a concatenated set of substitutions which includes\n@@ -433,7 +455,7 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n \n     return Callee {\n         bcx: bcx,\n-        data: TraitMethod(MethodData {\n+        data: TraitItem(MethodData {\n             llfn: mptr,\n             llself: llself,\n         })\n@@ -552,35 +574,42 @@ fn emit_vtable_methods(bcx: &Block,\n \n     ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trt_id);\n \n-    let trait_method_def_ids = ty::trait_method_def_ids(tcx, trt_id);\n-    trait_method_def_ids.iter().map(|method_def_id| {\n-        let ident = ty::method(tcx, *method_def_id).ident;\n+    let trait_item_def_ids = ty::trait_item_def_ids(tcx, trt_id);\n+    trait_item_def_ids.iter().map(|method_def_id| {\n+        let method_def_id = method_def_id.def_id();\n+        let ident = ty::impl_or_trait_item(tcx, method_def_id).ident();\n         // The substitutions we have are on the impl, so we grab\n         // the method type from the impl to substitute into.\n         let m_id = method_with_name(ccx, impl_id, ident.name);\n-        let m = ty::method(tcx, m_id);\n-        debug!(\"(making impl vtable) emitting method {} at subst {}\",\n-               m.repr(tcx),\n-               substs.repr(tcx));\n-        if m.generics.has_type_params(subst::FnSpace) ||\n-           ty::type_has_self(ty::mk_bare_fn(tcx, m.fty.clone())) {\n-            debug!(\"(making impl vtable) method has self or type params: {}\",\n-                   token::get_ident(ident));\n-            C_null(Type::nil(ccx).ptr_to())\n-        } else {\n-            let mut fn_ref = trans_fn_ref_with_vtables(bcx,\n-                                                       m_id,\n-                                                       ExprId(0),\n-                                                       substs.clone(),\n-                                                       vtables.clone());\n-            if m.explicit_self == ty::ByValueExplicitSelfCategory {\n-                fn_ref = trans_unboxing_shim(bcx,\n-                                             fn_ref,\n-                                             &*m,\n-                                             m_id,\n-                                             substs.clone());\n+        let ti = ty::impl_or_trait_item(tcx, m_id);\n+        match ti {\n+            ty::MethodTraitItem(m) => {\n+                debug!(\"(making impl vtable) emitting method {} at subst {}\",\n+                       m.repr(tcx),\n+                       substs.repr(tcx));\n+                if m.generics.has_type_params(subst::FnSpace) ||\n+                   ty::type_has_self(ty::mk_bare_fn(tcx, m.fty.clone())) {\n+                    debug!(\"(making impl vtable) method has self or type \\\n+                            params: {}\",\n+                           token::get_ident(ident));\n+                    C_null(Type::nil(ccx).ptr_to())\n+                } else {\n+                    let mut fn_ref = trans_fn_ref_with_vtables(\n+                        bcx,\n+                        m_id,\n+                        ExprId(0),\n+                        substs.clone(),\n+                        vtables.clone());\n+                    if m.explicit_self == ty::ByValueExplicitSelfCategory {\n+                        fn_ref = trans_unboxing_shim(bcx,\n+                                                     fn_ref,\n+                                                     &*m,\n+                                                     m_id,\n+                                                     substs.clone());\n+                    }\n+                    fn_ref\n+                }\n             }\n-            fn_ref\n         }\n     }).collect()\n }"}, {"sha": "e19ee035a781e3a02169232b68c70b17caaa5783", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -197,15 +197,25 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             }\n             d\n         }\n-        ast_map::NodeMethod(mth) => {\n-            let d = mk_lldecl(abi::Rust);\n-            set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-            trans_fn(ccx, &*mth.pe_fn_decl(), &*mth.pe_body(), d, &psubsts, mth.id, []);\n-            d\n+        ast_map::NodeImplItem(ii) => {\n+            match *ii {\n+                ast::MethodImplItem(mth) => {\n+                    let d = mk_lldecl(abi::Rust);\n+                    set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n+                    trans_fn(ccx,\n+                             &*mth.pe_fn_decl(),\n+                             &*mth.pe_body(),\n+                             d,\n+                             &psubsts,\n+                             mth.id,\n+                             []);\n+                    d\n+                }\n+            }\n         }\n-        ast_map::NodeTraitMethod(method) => {\n+        ast_map::NodeTraitItem(method) => {\n             match *method {\n-                ast::Provided(mth) => {\n+                ast::ProvidedMethod(mth) => {\n                     let d = mk_lldecl(abi::Rust);\n                     set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n                     trans_fn(ccx, &*mth.pe_fn_decl(), &*mth.pe_body(), d,"}, {"sha": "2aff12c2b68c5010a262a596a21942b3697fbf92", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -25,7 +25,6 @@ use middle::trans::type_of::*;\n use middle::ty;\n use util::ppaux::ty_to_string;\n \n-use std::rc::Rc;\n use arena::TypedArena;\n use libc::c_uint;\n use syntax::ast::DefId;\n@@ -36,7 +35,7 @@ use syntax::parse::token;\n \n pub struct Reflector<'a, 'b> {\n     visitor_val: ValueRef,\n-    visitor_methods: &'a [Rc<ty::Method>],\n+    visitor_items: &'a [ty::ImplOrTraitItem],\n     final_bcx: &'b Block<'b>,\n     tydesc_ty: Type,\n     bcx: &'b Block<'b>\n@@ -87,13 +86,14 @@ impl<'a, 'b> Reflector<'a, 'b> {\n     pub fn visit(&mut self, ty_name: &str, args: &[ValueRef]) {\n         let fcx = self.bcx.fcx;\n         let tcx = self.bcx.tcx();\n-        let mth_idx = ty::method_idx(token::str_to_ident(format!(\n+        let mth_idx = ty::impl_or_trait_item_idx(token::str_to_ident(format!(\n                         \"visit_{}\", ty_name).as_slice()),\n-                                     self.visitor_methods.as_slice()).expect(\n+                                     self.visitor_items.as_slice()).expect(\n                 format!(\"couldn't find visit method for {}\", ty_name).as_slice());\n-        let mth_ty =\n-            ty::mk_bare_fn(tcx,\n-                           self.visitor_methods[mth_idx].fty.clone());\n+        let method = match self.visitor_items[mth_idx] {\n+            ty::MethodTraitItem(ref method) => (*method).clone(),\n+        };\n+        let mth_ty = ty::mk_bare_fn(tcx, method.fty.clone());\n         let v = self.visitor_val;\n         debug!(\"passing {} args:\", args.len());\n         let mut bcx = self.bcx;\n@@ -397,10 +397,10 @@ pub fn emit_calls_to_trait_visit_ty<'a>(\n     let final = fcx.new_temp_block(\"final\");\n     let tydesc_ty = ty::get_tydesc_ty(bcx.tcx()).unwrap();\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);\n-    let visitor_methods = ty::trait_methods(bcx.tcx(), visitor_trait_id);\n+    let visitor_items = ty::trait_items(bcx.tcx(), visitor_trait_id);\n     let mut r = Reflector {\n         visitor_val: visitor_val,\n-        visitor_methods: visitor_methods.as_slice(),\n+        visitor_items: visitor_items.as_slice(),\n         final_bcx: final,\n         tydesc_ty: tydesc_ty,\n         bcx: bcx"}, {"sha": "40c4d9682c4a3e8bf504bbcf63c9193e49543132", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 171, "deletions": 77, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -76,11 +76,64 @@ pub struct field {\n }\n \n #[deriving(Clone)]\n-pub enum MethodContainer {\n+pub enum ImplOrTraitItemContainer {\n     TraitContainer(ast::DefId),\n     ImplContainer(ast::DefId),\n }\n \n+impl ImplOrTraitItemContainer {\n+    pub fn id(&self) -> ast::DefId {\n+        match *self {\n+            TraitContainer(id) => id,\n+            ImplContainer(id) => id,\n+        }\n+    }\n+}\n+\n+#[deriving(Clone)]\n+pub enum ImplOrTraitItem {\n+    MethodTraitItem(Rc<Method>),\n+}\n+\n+impl ImplOrTraitItem {\n+    fn id(&self) -> ImplOrTraitItemId {\n+        match *self {\n+            MethodTraitItem(ref method) => MethodTraitItemId(method.def_id),\n+        }\n+    }\n+\n+    pub fn def_id(&self) -> ast::DefId {\n+        match *self {\n+            MethodTraitItem(ref method) => method.def_id,\n+        }\n+    }\n+\n+    pub fn ident(&self) -> ast::Ident {\n+        match *self {\n+            MethodTraitItem(ref method) => method.ident,\n+        }\n+    }\n+\n+    pub fn container(&self) -> ImplOrTraitItemContainer {\n+        match *self {\n+            MethodTraitItem(ref method) => method.container,\n+        }\n+    }\n+}\n+\n+#[deriving(Clone)]\n+pub enum ImplOrTraitItemId {\n+    MethodTraitItemId(ast::DefId),\n+}\n+\n+impl ImplOrTraitItemId {\n+    pub fn def_id(&self) -> ast::DefId {\n+        match *self {\n+            MethodTraitItemId(def_id) => def_id,\n+        }\n+    }\n+}\n+\n #[deriving(Clone)]\n pub struct Method {\n     pub ident: ast::Ident,\n@@ -89,7 +142,7 @@ pub struct Method {\n     pub explicit_self: ExplicitSelfCategory,\n     pub vis: ast::Visibility,\n     pub def_id: ast::DefId,\n-    pub container: MethodContainer,\n+    pub container: ImplOrTraitItemContainer,\n \n     // If this method is provided, we need to know where it came from\n     pub provided_source: Option<ast::DefId>\n@@ -102,7 +155,7 @@ impl Method {\n                explicit_self: ExplicitSelfCategory,\n                vis: ast::Visibility,\n                def_id: ast::DefId,\n-               container: MethodContainer,\n+               container: ImplOrTraitItemContainer,\n                provided_source: Option<ast::DefId>)\n                -> Method {\n        Method {\n@@ -274,14 +327,14 @@ pub struct ctxt {\n     /// other items.\n     pub item_substs: RefCell<NodeMap<ItemSubsts>>,\n \n-    /// Maps from a method to the method \"descriptor\"\n-    pub methods: RefCell<DefIdMap<Rc<Method>>>,\n+    /// Maps from a trait item to the trait item \"descriptor\"\n+    pub impl_or_trait_items: RefCell<DefIdMap<ImplOrTraitItem>>,\n \n-    /// Maps from a trait def-id to a list of the def-ids of its methods\n-    pub trait_method_def_ids: RefCell<DefIdMap<Rc<Vec<DefId>>>>,\n+    /// Maps from a trait def-id to a list of the def-ids of its trait items\n+    pub trait_item_def_ids: RefCell<DefIdMap<Rc<Vec<ImplOrTraitItemId>>>>,\n \n-    /// A cache for the trait_methods() routine\n-    pub trait_methods_cache: RefCell<DefIdMap<Rc<Vec<Rc<Method>>>>>,\n+    /// A cache for the trait_items() routine\n+    pub trait_items_cache: RefCell<DefIdMap<Rc<Vec<ImplOrTraitItem>>>>,\n \n     pub impl_trait_cache: RefCell<DefIdMap<Option<Rc<ty::TraitRef>>>>,\n \n@@ -332,11 +385,11 @@ pub struct ctxt {\n     /// Methods in these implementations don't need to be exported.\n     pub inherent_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n \n-    /// Maps a DefId of an impl to a list of its methods.\n+    /// Maps a DefId of an impl to a list of its items.\n     /// Note that this contains all of the impls that we know about,\n     /// including ones in other crates. It's not clear that this is the best\n     /// way to do it.\n-    pub impl_methods: RefCell<DefIdMap<Vec<ast::DefId>>>,\n+    pub impl_items: RefCell<DefIdMap<Vec<ImplOrTraitItemId>>>,\n \n     /// Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     /// present in this set can be warned about.\n@@ -1104,9 +1157,9 @@ pub fn mk_ctxt(s: Session,\n         tc_cache: RefCell::new(HashMap::new()),\n         ast_ty_to_ty_cache: RefCell::new(NodeMap::new()),\n         enum_var_cache: RefCell::new(DefIdMap::new()),\n-        methods: RefCell::new(DefIdMap::new()),\n-        trait_method_def_ids: RefCell::new(DefIdMap::new()),\n-        trait_methods_cache: RefCell::new(DefIdMap::new()),\n+        impl_or_trait_items: RefCell::new(DefIdMap::new()),\n+        trait_item_def_ids: RefCell::new(DefIdMap::new()),\n+        trait_items_cache: RefCell::new(DefIdMap::new()),\n         impl_trait_cache: RefCell::new(DefIdMap::new()),\n         ty_param_defs: RefCell::new(NodeMap::new()),\n         adjustments: RefCell::new(NodeMap::new()),\n@@ -1120,7 +1173,7 @@ pub fn mk_ctxt(s: Session,\n         destructors: RefCell::new(DefIdSet::new()),\n         trait_impls: RefCell::new(DefIdMap::new()),\n         inherent_impls: RefCell::new(DefIdMap::new()),\n-        impl_methods: RefCell::new(DefIdMap::new()),\n+        impl_items: RefCell::new(DefIdMap::new()),\n         used_unsafe: RefCell::new(NodeSet::new()),\n         used_mut_nodes: RefCell::new(NodeSet::new()),\n         impl_vtables: RefCell::new(DefIdMap::new()),\n@@ -3075,11 +3128,19 @@ pub fn method_call_type_param_defs(tcx: &ctxt, origin: typeck::MethodOrigin)\n                 Err(s) => tcx.sess.fatal(s.as_slice()),\n             }\n         }\n-        typeck::MethodParam(typeck::MethodParam{trait_id: trt_id,\n-                                                method_num: n_mth, ..}) |\n-        typeck::MethodObject(typeck::MethodObject{trait_id: trt_id,\n-                                                  method_num: n_mth, ..}) => {\n-            ty::trait_method(tcx, trt_id, n_mth).generics.types.clone()\n+        typeck::MethodParam(typeck::MethodParam{\n+            trait_id: trt_id,\n+            method_num: n_mth,\n+            ..\n+        }) |\n+        typeck::MethodObject(typeck::MethodObject{\n+                trait_id: trt_id,\n+                method_num: n_mth,\n+                ..\n+        }) => {\n+            match ty::trait_item(tcx, trt_id, n_mth) {\n+                ty::MethodTraitItem(method) => method.generics.types.clone(),\n+            }\n         }\n     }\n }\n@@ -3297,8 +3358,9 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n               .collect::<Vec<String>>()).as_slice());\n }\n \n-pub fn method_idx(id: ast::Ident, meths: &[Rc<Method>]) -> Option<uint> {\n-    meths.iter().position(|m| m.ident == id)\n+pub fn impl_or_trait_item_idx(id: ast::Ident, trait_items: &[ImplOrTraitItem])\n+                              -> Option<uint> {\n+    trait_items.iter().position(|m| m.ident() == id)\n }\n \n /// Returns a vector containing the indices of all type parameters that appear\n@@ -3540,7 +3602,15 @@ pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<Rc<Method>> {\n                 match item.node {\n                     ItemTrait(_, _, _, ref ms) => {\n                         let (_, p) = ast_util::split_trait_methods(ms.as_slice());\n-                        p.iter().map(|m| method(cx, ast_util::local_def(m.id))).collect()\n+                        p.iter()\n+                         .map(|m| {\n+                            match impl_or_trait_item(\n+                                    cx,\n+                                    ast_util::local_def(m.id)) {\n+                                MethodTraitItem(m) => m,\n+                            }\n+                         })\n+                         .collect()\n                     }\n                     _ => {\n                         cx.sess.bug(format!(\"provided_trait_methods: `{}` is \\\n@@ -3592,7 +3662,7 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     /*!\n      * Helper for looking things up in the various maps\n      * that are populated during typeck::collect (e.g.,\n-     * `cx.methods`, `cx.tcache`, etc).  All of these share\n+     * `cx.impl_or_trait_items`, `cx.tcache`, etc).  All of these share\n      * the pattern that if the id is local, it should have\n      * been loaded into the map by the `typeck::collect` phase.\n      * If the def-id is external, then we have to go consult\n@@ -3612,40 +3682,47 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     v\n }\n \n-pub fn trait_method(cx: &ctxt, trait_did: ast::DefId, idx: uint) -> Rc<Method> {\n-    let method_def_id = *ty::trait_method_def_ids(cx, trait_did).get(idx);\n-    ty::method(cx, method_def_id)\n+pub fn trait_item(cx: &ctxt, trait_did: ast::DefId, idx: uint)\n+                  -> ImplOrTraitItem {\n+    let method_def_id = ty::trait_item_def_ids(cx, trait_did).get(idx)\n+                                                             .def_id();\n+    impl_or_trait_item(cx, method_def_id)\n }\n \n-\n-pub fn trait_methods(cx: &ctxt, trait_did: ast::DefId) -> Rc<Vec<Rc<Method>>> {\n-    let mut trait_methods = cx.trait_methods_cache.borrow_mut();\n-    match trait_methods.find_copy(&trait_did) {\n-        Some(methods) => methods,\n+pub fn trait_items(cx: &ctxt, trait_did: ast::DefId)\n+                   -> Rc<Vec<ImplOrTraitItem>> {\n+    let mut trait_items = cx.trait_items_cache.borrow_mut();\n+    match trait_items.find_copy(&trait_did) {\n+        Some(trait_items) => trait_items,\n         None => {\n-            let def_ids = ty::trait_method_def_ids(cx, trait_did);\n-            let methods: Rc<Vec<Rc<Method>>> = Rc::new(def_ids.iter().map(|d| {\n-                ty::method(cx, *d)\n-            }).collect());\n-            trait_methods.insert(trait_did, methods.clone());\n-            methods\n+            let def_ids = ty::trait_item_def_ids(cx, trait_did);\n+            let items: Rc<Vec<ImplOrTraitItem>> =\n+                Rc::new(def_ids.iter()\n+                               .map(|d| impl_or_trait_item(cx, d.def_id()))\n+                               .collect());\n+            trait_items.insert(trait_did, items.clone());\n+            items\n         }\n     }\n }\n \n-pub fn method(cx: &ctxt, id: ast::DefId) -> Rc<Method> {\n-    lookup_locally_or_in_crate_store(\"methods\", id,\n-                                     &mut *cx.methods.borrow_mut(), || {\n-        Rc::new(csearch::get_method(cx, id))\n+pub fn impl_or_trait_item(cx: &ctxt, id: ast::DefId) -> ImplOrTraitItem {\n+    lookup_locally_or_in_crate_store(\"impl_or_trait_items\",\n+                                     id,\n+                                     &mut *cx.impl_or_trait_items\n+                                             .borrow_mut(),\n+                                     || {\n+        csearch::get_impl_or_trait_item(cx, id)\n     })\n }\n \n-pub fn trait_method_def_ids(cx: &ctxt, id: ast::DefId) -> Rc<Vec<DefId>> {\n-    lookup_locally_or_in_crate_store(\"trait_method_def_ids\",\n+pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n+                          -> Rc<Vec<ImplOrTraitItemId>> {\n+    lookup_locally_or_in_crate_store(\"trait_item_def_ids\",\n                                      id,\n-                                     &mut *cx.trait_method_def_ids.borrow_mut(),\n+                                     &mut *cx.trait_item_def_ids.borrow_mut(),\n                                      || {\n-        Rc::new(csearch::get_trait_method_def_ids(&cx.sess.cstore, id))\n+        Rc::new(csearch::get_trait_item_def_ids(&cx.sess.cstore, id))\n     })\n }\n \n@@ -4459,7 +4536,8 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n \n     csearch::each_implementation_for_type(&tcx.sess.cstore, type_id,\n             |impl_def_id| {\n-        let methods = csearch::get_impl_methods(&tcx.sess.cstore, impl_def_id);\n+        let impl_items = csearch::get_impl_items(&tcx.sess.cstore,\n+                                                 impl_def_id);\n \n         // Record the trait->implementation mappings, if applicable.\n         let associated_traits = csearch::get_impl_trait(tcx, impl_def_id);\n@@ -4469,14 +4547,21 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for &method_def_id in methods.iter() {\n-            for &source in ty::method(tcx, method_def_id).provided_source.iter() {\n-                tcx.provided_method_sources.borrow_mut().insert(method_def_id, source);\n+        for impl_item_def_id in impl_items.iter() {\n+            let method_def_id = impl_item_def_id.def_id();\n+            match impl_or_trait_item(tcx, method_def_id) {\n+                MethodTraitItem(method) => {\n+                    for &source in method.provided_source.iter() {\n+                        tcx.provided_method_sources\n+                           .borrow_mut()\n+                           .insert(method_def_id, source);\n+                    }\n+                }\n             }\n         }\n \n         // Store the implementation info.\n-        tcx.impl_methods.borrow_mut().insert(impl_def_id, methods);\n+        tcx.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n \n         // If this is an inherent implementation, record it.\n         if associated_traits.is_none() {\n@@ -4509,21 +4594,28 @@ pub fn populate_implementations_for_trait_if_necessary(\n \n     csearch::each_implementation_for_trait(&tcx.sess.cstore, trait_id,\n             |implementation_def_id| {\n-        let methods = csearch::get_impl_methods(&tcx.sess.cstore, implementation_def_id);\n+        let impl_items = csearch::get_impl_items(&tcx.sess.cstore, implementation_def_id);\n \n         // Record the trait->implementation mapping.\n         record_trait_implementation(tcx, trait_id, implementation_def_id);\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for &method_def_id in methods.iter() {\n-            for &source in ty::method(tcx, method_def_id).provided_source.iter() {\n-                tcx.provided_method_sources.borrow_mut().insert(method_def_id, source);\n+        for impl_item_def_id in impl_items.iter() {\n+            let method_def_id = impl_item_def_id.def_id();\n+            match impl_or_trait_item(tcx, method_def_id) {\n+                MethodTraitItem(method) => {\n+                    for &source in method.provided_source.iter() {\n+                        tcx.provided_method_sources\n+                           .borrow_mut()\n+                           .insert(method_def_id, source);\n+                    }\n+                }\n             }\n         }\n \n         // Store the implementation info.\n-        tcx.impl_methods.borrow_mut().insert(implementation_def_id, methods);\n+        tcx.impl_items.borrow_mut().insert(implementation_def_id, impl_items);\n     });\n \n     tcx.populated_external_traits.borrow_mut().insert(trait_id);\n@@ -4555,14 +4647,15 @@ pub fn trait_id_of_impl(tcx: &ctxt,\n pub fn impl_of_method(tcx: &ctxt, def_id: ast::DefId)\n                        -> Option<ast::DefId> {\n     if def_id.krate != LOCAL_CRATE {\n-        return match csearch::get_method(tcx, def_id).container {\n+        return match csearch::get_impl_or_trait_item(tcx,\n+                                                     def_id).container() {\n             TraitContainer(_) => None,\n             ImplContainer(def_id) => Some(def_id),\n         };\n     }\n-    match tcx.methods.borrow().find_copy(&def_id) {\n-        Some(method) => {\n-            match method.container {\n+    match tcx.impl_or_trait_items.borrow().find_copy(&def_id) {\n+        Some(trait_item) => {\n+            match trait_item.container() {\n                 TraitContainer(_) => None,\n                 ImplContainer(def_id) => Some(def_id),\n             }\n@@ -4571,17 +4664,16 @@ pub fn impl_of_method(tcx: &ctxt, def_id: ast::DefId)\n     }\n }\n \n-/// If the given def ID describes a method belonging to a trait (either a\n+/// If the given def ID describes an item belonging to a trait (either a\n /// default method or an implementation of a trait method), return the ID of\n /// the trait that the method belongs to. Otherwise, return `None`.\n-pub fn trait_of_method(tcx: &ctxt, def_id: ast::DefId)\n-                       -> Option<ast::DefId> {\n+pub fn trait_of_item(tcx: &ctxt, def_id: ast::DefId) -> Option<ast::DefId> {\n     if def_id.krate != LOCAL_CRATE {\n-        return csearch::get_trait_of_method(&tcx.sess.cstore, def_id, tcx);\n+        return csearch::get_trait_of_item(&tcx.sess.cstore, def_id, tcx);\n     }\n-    match tcx.methods.borrow().find_copy(&def_id) {\n-        Some(method) => {\n-            match method.container {\n+    match tcx.impl_or_trait_items.borrow().find_copy(&def_id) {\n+        Some(impl_or_trait_item) => {\n+            match impl_or_trait_item.container() {\n                 TraitContainer(def_id) => Some(def_id),\n                 ImplContainer(def_id) => trait_id_of_impl(tcx, def_id),\n             }\n@@ -4590,25 +4682,27 @@ pub fn trait_of_method(tcx: &ctxt, def_id: ast::DefId)\n     }\n }\n \n-/// If the given def ID describes a method belonging to a trait, (either a\n+/// If the given def ID describes an item belonging to a trait, (either a\n /// default method or an implementation of a trait method), return the ID of\n /// the method inside trait definition (this means that if the given def ID\n /// is already that of the original trait method, then the return value is\n /// the same).\n /// Otherwise, return `None`.\n-pub fn trait_method_of_method(tcx: &ctxt,\n-                              def_id: ast::DefId) -> Option<ast::DefId> {\n-    let method = match tcx.methods.borrow().find(&def_id) {\n+pub fn trait_item_of_item(tcx: &ctxt, def_id: ast::DefId)\n+                          -> Option<ImplOrTraitItemId> {\n+    let impl_item = match tcx.impl_or_trait_items.borrow().find(&def_id) {\n         Some(m) => m.clone(),\n         None => return None,\n     };\n-    let name = method.ident.name;\n-    match trait_of_method(tcx, def_id) {\n+    let name = match impl_item {\n+        MethodTraitItem(method) => method.ident.name,\n+    };\n+    match trait_of_item(tcx, def_id) {\n         Some(trait_did) => {\n-            let trait_methods = ty::trait_methods(tcx, trait_did);\n-            trait_methods.iter()\n-                .position(|m| m.ident.name == name)\n-                .map(|idx| ty::trait_method(tcx, trait_did, idx).def_id)\n+            let trait_items = ty::trait_items(tcx, trait_did);\n+            trait_items.iter()\n+                .position(|m| m.ident().name == name)\n+                .map(|idx| ty::trait_item(tcx, trait_did, idx).id())\n         }\n         None => None\n     }"}, {"sha": "1e3ea095704bf167057eccb365205b7c4fee6015", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 69, "deletions": 29, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -220,9 +220,15 @@ fn get_method_index(tcx: &ty::ctxt,\n     // methods from them.\n     let mut method_count = 0;\n     ty::each_bound_trait_and_supertraits(tcx, &[subtrait], |bound_ref| {\n-        if bound_ref.def_id == trait_ref.def_id { false }\n-            else {\n-            method_count += ty::trait_methods(tcx, bound_ref.def_id).len();\n+        if bound_ref.def_id == trait_ref.def_id {\n+            false\n+        } else {\n+            let trait_items = ty::trait_items(tcx, bound_ref.def_id);\n+            for trait_item in trait_items.iter() {\n+                match *trait_item {\n+                    ty::MethodTraitItem(_) => method_count += 1,\n+                }\n+            }\n             true\n         }\n     });\n@@ -488,11 +494,13 @@ impl<'a> LookupContext<'a> {\n         ty::populate_implementations_for_trait_if_necessary(self.tcx(), trait_did);\n \n         // Look for explicit implementations.\n-        let impl_methods = self.tcx().impl_methods.borrow();\n+        let impl_items = self.tcx().impl_items.borrow();\n         for impl_infos in self.tcx().trait_impls.borrow().find(&trait_did).iter() {\n             for impl_did in impl_infos.borrow().iter() {\n-                let methods = impl_methods.get(impl_did);\n-                self.push_candidates_from_impl(*impl_did, methods.as_slice(), true);\n+                let items = impl_items.get(impl_did);\n+                self.push_candidates_from_impl(*impl_did,\n+                                               items.as_slice(),\n+                                               true);\n             }\n         }\n     }\n@@ -520,8 +528,11 @@ impl<'a> LookupContext<'a> {\n             trait_did: DefId,\n             closure_did: DefId,\n             closure_function_type: &ClosureTy) {\n-        let method =\n-            ty::trait_methods(self.tcx(), trait_did).get(0).clone();\n+        let trait_item = ty::trait_items(self.tcx(), trait_did).get(0)\n+                                                               .clone();\n+        let method = match trait_item {\n+            ty::MethodTraitItem(method) => method,\n+        };\n \n         let vcx = self.fcx.vtable_context();\n         let region_params =\n@@ -701,14 +712,24 @@ impl<'a> LookupContext<'a> {\n             let this_bound_idx = next_bound_idx;\n             next_bound_idx += 1;\n \n-            let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n-            match trait_methods.iter().position(|m| {\n-                m.explicit_self != ty::StaticExplicitSelfCategory &&\n-                m.ident.name == self.m_name }) {\n+            let trait_items = ty::trait_items(tcx, bound_trait_ref.def_id);\n+            match trait_items.iter().position(|ti| {\n+                match *ti {\n+                    ty::MethodTraitItem(ref m) => {\n+                        m.explicit_self != ty::StaticExplicitSelfCategory &&\n+                        m.ident.name == self.m_name\n+                    }\n+                }\n+            }) {\n                 Some(pos) => {\n-                    let method = trait_methods.get(pos).clone();\n-\n-                    match mk_cand(bound_trait_ref, method, pos, this_bound_idx) {\n+                    let method = match *trait_items.get(pos) {\n+                        ty::MethodTraitItem(ref method) => (*method).clone(),\n+                    };\n+\n+                    match mk_cand(bound_trait_ref,\n+                                  method,\n+                                  pos,\n+                                  this_bound_idx) {\n                         Some(cand) => {\n                             debug!(\"pushing inherent candidate for param: {}\",\n                                    cand.repr(self.tcx()));\n@@ -733,18 +754,20 @@ impl<'a> LookupContext<'a> {\n         // metadata if necessary.\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), did);\n \n-        let impl_methods = self.tcx().impl_methods.borrow();\n+        let impl_items = self.tcx().impl_items.borrow();\n         for impl_infos in self.tcx().inherent_impls.borrow().find(&did).iter() {\n             for impl_did in impl_infos.borrow().iter() {\n-                let methods = impl_methods.get(impl_did);\n-                self.push_candidates_from_impl(*impl_did, methods.as_slice(), false);\n+                let items = impl_items.get(impl_did);\n+                self.push_candidates_from_impl(*impl_did,\n+                                               items.as_slice(),\n+                                               false);\n             }\n         }\n     }\n \n     fn push_candidates_from_impl(&mut self,\n                                  impl_did: DefId,\n-                                 impl_methods: &[DefId],\n+                                 impl_items: &[ImplOrTraitItemId],\n                                  is_extension: bool) {\n         let did = if self.report_statics == ReportStaticMethods {\n             // we only want to report each base trait once\n@@ -762,13 +785,23 @@ impl<'a> LookupContext<'a> {\n \n         debug!(\"push_candidates_from_impl: {} {}\",\n                token::get_name(self.m_name),\n-               impl_methods.iter().map(|&did| ty::method(self.tcx(), did).ident)\n-                                 .collect::<Vec<ast::Ident>>()\n-                                 .repr(self.tcx()));\n-\n-        let method = match impl_methods.iter().map(|&did| ty::method(self.tcx(), did))\n-                                              .find(|m| m.ident.name == self.m_name) {\n-            Some(method) => method,\n+               impl_items.iter()\n+                         .map(|&did| {\n+                             ty::impl_or_trait_item(self.tcx(),\n+                                                    did.def_id()).ident()\n+                         })\n+                         .collect::<Vec<ast::Ident>>()\n+                         .repr(self.tcx()));\n+\n+        let method = match impl_items.iter()\n+                                     .map(|&did| {\n+                                         ty::impl_or_trait_item(self.tcx(),\n+                                                                did.def_id())\n+                                     })\n+                                     .find(|m| {\n+                                         m.ident().name == self.m_name\n+                                     }) {\n+            Some(ty::MethodTraitItem(method)) => method,\n             None => { return; } // No method with the right name.\n         };\n \n@@ -1486,9 +1519,16 @@ impl<'a> LookupContext<'a> {\n                 let did = if self.report_statics == ReportStaticMethods {\n                     // If we're reporting statics, we want to report the trait\n                     // definition if possible, rather than an impl\n-                    match ty::trait_method_of_method(self.tcx(), impl_did) {\n-                        None => {debug!(\"(report candidate) No trait method found\"); impl_did},\n-                        Some(trait_did) => {debug!(\"(report candidate) Found trait ref\"); trait_did}\n+                    match ty::trait_item_of_item(self.tcx(), impl_did) {\n+                        None => {\n+                            debug!(\"(report candidate) No trait method \\\n+                                    found\");\n+                            impl_did\n+                        }\n+                        Some(MethodTraitItemId(trait_did)) => {\n+                            debug!(\"(report candidate) Found trait ref\");\n+                            trait_did\n+                        }\n                     }\n                 } else {\n                     // If it is an instantiated default method, use the original"}, {"sha": "3403a51610cff082d618de0e22d5c566e020178e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 86, "deletions": 55, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -123,7 +123,7 @@ use std::mem::replace;\n use std::rc::Rc;\n use std::gc::Gc;\n use syntax::abi;\n-use syntax::ast::{Provided, Required};\n+use syntax::ast::{ProvidedMethod, RequiredMethod};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{local_def, PostExpansionMethod};\n@@ -680,23 +680,27 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n         check_bare_fn(ccx, &**decl, &**body, it.id, fn_pty.ty, param_env);\n       }\n-      ast::ItemImpl(_, ref opt_trait_ref, _, ref ms) => {\n+      ast::ItemImpl(_, ref opt_trait_ref, _, ref impl_items) => {\n         debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n \n         let impl_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n-        for m in ms.iter() {\n-            check_method_body(ccx, &impl_pty.generics, &**m);\n+        for impl_item in impl_items.iter() {\n+            match *impl_item {\n+                ast::MethodImplItem(m) => {\n+                    check_method_body(ccx, &impl_pty.generics, &*m);\n+                }\n+            }\n         }\n \n         match *opt_trait_ref {\n             Some(ref ast_trait_ref) => {\n                 let impl_trait_ref =\n                     ty::node_id_to_trait_ref(ccx.tcx, ast_trait_ref.ref_id);\n-                check_impl_methods_against_trait(ccx,\n-                                             it.span,\n-                                             ast_trait_ref,\n-                                             &*impl_trait_ref,\n-                                             ms.as_slice());\n+                check_impl_items_against_trait(ccx,\n+                                               it.span,\n+                                               ast_trait_ref,\n+                                               &*impl_trait_ref,\n+                                               impl_items.as_slice());\n                 vtable::resolve_impl(ccx.tcx, it, &impl_pty.generics, &*impl_trait_ref);\n             }\n             None => { }\n@@ -707,11 +711,11 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n         for trait_method in (*trait_methods).iter() {\n             match *trait_method {\n-                Required(..) => {\n+                RequiredMethod(..) => {\n                     // Nothing to do, since required methods don't have\n                     // bodies to check.\n                 }\n-                Provided(m) => {\n+                ProvidedMethod(m) => {\n                     check_method_body(ccx, &trait_def.generics, &*m);\n                 }\n             }\n@@ -770,7 +774,9 @@ fn check_method_body(ccx: &CrateCtxt,\n             item_generics.repr(ccx.tcx),\n             method.id);\n     let method_def_id = local_def(method.id);\n-    let method_ty = ty::method(ccx.tcx, method_def_id);\n+    let method_ty = match ty::impl_or_trait_item(ccx.tcx, method_def_id) {\n+        ty::MethodTraitItem(ref method_ty) => (*method_ty).clone(),\n+    };\n     let method_generics = &method_ty.generics;\n \n     let param_env = ty::construct_parameter_environment(ccx.tcx,\n@@ -787,43 +793,58 @@ fn check_method_body(ccx: &CrateCtxt,\n                   param_env);\n }\n \n-fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n-                                    impl_span: Span,\n-                                    ast_trait_ref: &ast::TraitRef,\n-                                    impl_trait_ref: &ty::TraitRef,\n-                                    impl_methods: &[Gc<ast::Method>]) {\n+fn check_impl_items_against_trait(ccx: &CrateCtxt,\n+                                  impl_span: Span,\n+                                  ast_trait_ref: &ast::TraitRef,\n+                                  impl_trait_ref: &ty::TraitRef,\n+                                  impl_items: &[ast::ImplItem]) {\n     // Locate trait methods\n     let tcx = ccx.tcx;\n-    let trait_methods = ty::trait_methods(tcx, impl_trait_ref.def_id);\n+    let trait_items = ty::trait_items(tcx, impl_trait_ref.def_id);\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n-    for impl_method in impl_methods.iter() {\n-        let impl_method_def_id = local_def(impl_method.id);\n-        let impl_method_ty = ty::method(ccx.tcx, impl_method_def_id);\n-\n-        // If this is an impl of a trait method, find the corresponding\n-        // method definition in the trait.\n-        let opt_trait_method_ty =\n-            trait_methods.iter().\n-            find(|tm| tm.ident.name == impl_method_ty.ident.name);\n-        match opt_trait_method_ty {\n-            Some(trait_method_ty) => {\n-                compare_impl_method(ccx.tcx,\n-                                    &*impl_method_ty,\n-                                    impl_method.span,\n-                                    impl_method.pe_body().id,\n-                                    &**trait_method_ty,\n-                                    &impl_trait_ref.substs);\n-            }\n-            None => {\n-                // This is span_bug as it should have already been caught in resolve.\n-                tcx.sess.span_bug(\n-                    impl_method.span,\n-                    format!(\n-                        \"method `{}` is not a member of trait `{}`\",\n-                        token::get_ident(impl_method_ty.ident),\n-                        pprust::path_to_string(&ast_trait_ref.path)).as_slice());\n+    for impl_item in impl_items.iter() {\n+        match *impl_item {\n+            ast::MethodImplItem(impl_method) => {\n+                let impl_method_def_id = local_def(impl_method.id);\n+                let impl_item_ty = ty::impl_or_trait_item(ccx.tcx,\n+                                                          impl_method_def_id);\n+\n+                // If this is an impl of a trait method, find the\n+                // corresponding method definition in the trait.\n+                let opt_trait_method_ty =\n+                    trait_items.iter()\n+                               .find(|ti| {\n+                                   ti.ident().name == impl_item_ty.ident()\n+                                                                  .name\n+                               });\n+                match opt_trait_method_ty {\n+                    Some(trait_method_ty) => {\n+                        match (trait_method_ty, &impl_item_ty) {\n+                            (&ty::MethodTraitItem(ref trait_method_ty),\n+                             &ty::MethodTraitItem(ref impl_method_ty)) => {\n+                                compare_impl_method(ccx.tcx,\n+                                                    &**impl_method_ty,\n+                                                    impl_method.span,\n+                                                    impl_method.pe_body().id,\n+                                                    &**trait_method_ty,\n+                                                    &impl_trait_ref.substs);\n+                            }\n+                        }\n+                    }\n+                    None => {\n+                        // This is span_bug as it should have already been\n+                        // caught in resolve.\n+                        tcx.sess.span_bug(\n+                            impl_method.span,\n+                            format!(\n+                                \"method `{}` is not a member of trait `{}`\",\n+                                token::get_ident(impl_item_ty.ident()),\n+                                pprust::path_to_string(\n+                                    &ast_trait_ref.path)).as_slice());\n+                    }\n+                }\n             }\n         }\n     }\n@@ -832,16 +853,26 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n     let provided_methods = ty::provided_trait_methods(tcx,\n                                                       impl_trait_ref.def_id);\n     let mut missing_methods = Vec::new();\n-    for trait_method in trait_methods.iter() {\n-        let is_implemented =\n-            impl_methods.iter().any(\n-                |m| m.pe_ident().name == trait_method.ident.name);\n-        let is_provided =\n-            provided_methods.iter().any(\n-                |m| m.ident.name == trait_method.ident.name);\n-        if !is_implemented && !is_provided {\n-            missing_methods.push(\n-                format!(\"`{}`\", token::get_ident(trait_method.ident)));\n+    for trait_item in trait_items.iter() {\n+        match *trait_item {\n+            ty::MethodTraitItem(ref trait_method) => {\n+                let is_implemented =\n+                    impl_items.iter().any(|ii| {\n+                        match *ii {\n+                            ast::MethodImplItem(m) => {\n+                                m.pe_ident().name == trait_method.ident.name\n+                            }\n+                        }\n+                    });\n+                let is_provided =\n+                    provided_methods.iter().any(\n+                        |m| m.ident.name == trait_method.ident.name);\n+                if !is_implemented && !is_provided {\n+                    missing_methods.push(\n+                        format!(\"`{}`\",\n+                                token::get_ident(trait_method.ident)));\n+                }\n+            }\n         }\n     }\n \n@@ -853,7 +884,7 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n }\n \n /**\n- * Checks that a method from an impl/class conforms to the signature of\n+ * Checks that a method from an impl conforms to the signature of\n  * the same method as declared in the trait.\n  *\n  * # Parameters"}, {"sha": "3dee787b6c9064edea7f3507a25dd933427dcf7e", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -20,7 +20,8 @@ use metadata::csearch;\n use middle::subst;\n use middle::subst::{Substs};\n use middle::ty::get;\n-use middle::ty::{ImplContainer, lookup_item_type};\n+use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n+use middle::ty::{lookup_item_type};\n use middle::ty::{t, ty_bool, ty_char, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_param, Polytype, ty_ptr};\n@@ -308,7 +309,7 @@ impl<'a> CoherenceChecker<'a> {\n             }\n         }\n \n-        let impl_methods = self.create_impl_from_item(item);\n+        let impl_items = self.create_impl_from_item(item);\n \n         for associated_trait in associated_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(\n@@ -337,16 +338,17 @@ impl<'a> CoherenceChecker<'a> {\n             }\n         }\n \n-        tcx.impl_methods.borrow_mut().insert(impl_did, impl_methods);\n+        tcx.impl_items.borrow_mut().insert(impl_did, impl_items);\n     }\n \n     // Creates default method IDs and performs type substitutions for an impl\n     // and trait pair. Then, for each provided method in the trait, inserts a\n     // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n-    fn instantiate_default_methods(&self,\n-                                   impl_id: DefId,\n-                                   trait_ref: &ty::TraitRef,\n-                                   all_methods: &mut Vec<DefId>) {\n+    fn instantiate_default_methods(\n+            &self,\n+            impl_id: DefId,\n+            trait_ref: &ty::TraitRef,\n+            all_impl_items: &mut Vec<ImplOrTraitItemId>) {\n         let tcx = self.crate_context.tcx;\n         debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n                impl_id, trait_ref.repr(tcx));\n@@ -373,7 +375,7 @@ impl<'a> CoherenceChecker<'a> {\n                     Some(trait_method.def_id)));\n \n             debug!(\"new_method_ty={}\", new_method_ty.repr(tcx));\n-            all_methods.push(new_did);\n+            all_impl_items.push(MethodTraitItemId(new_did));\n \n             // construct the polytype for the method based on the\n             // method_ty.  it will have all the generics from the\n@@ -385,7 +387,9 @@ impl<'a> CoherenceChecker<'a> {\n             debug!(\"new_polytype={}\", new_polytype.repr(tcx));\n \n             tcx.tcache.borrow_mut().insert(new_did, new_polytype);\n-            tcx.methods.borrow_mut().insert(new_did, new_method_ty);\n+            tcx.impl_or_trait_items\n+               .borrow_mut()\n+               .insert(new_did, ty::MethodTraitItem(new_method_ty));\n \n             // Pair the new synthesized ID up with the\n             // ID of the method.\n@@ -576,13 +580,20 @@ impl<'a> CoherenceChecker<'a> {\n         }\n     }\n \n-    // Converts an implementation in the AST to a vector of methods.\n-    fn create_impl_from_item(&self, item: &Item) -> Vec<DefId> {\n+    // Converts an implementation in the AST to a vector of items.\n+    fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> {\n         match item.node {\n-            ItemImpl(_, ref trait_refs, _, ref ast_methods) => {\n-                let mut methods: Vec<DefId> = ast_methods.iter().map(|ast_method| {\n-                    local_def(ast_method.id)\n-                }).collect();\n+            ItemImpl(_, ref trait_refs, _, ref ast_items) => {\n+                let mut items: Vec<ImplOrTraitItemId> =\n+                        ast_items.iter()\n+                                 .map(|ast_item| {\n+                            match *ast_item {\n+                                ast::MethodImplItem(ast_method) => {\n+                                    MethodTraitItemId(\n+                                        local_def(ast_method.id))\n+                                }\n+                            }\n+                        }).collect();\n \n                 for trait_ref in trait_refs.iter() {\n                     let ty_trait_ref = ty::node_id_to_trait_ref(\n@@ -591,10 +602,10 @@ impl<'a> CoherenceChecker<'a> {\n \n                     self.instantiate_default_methods(local_def(item.id),\n                                                      &*ty_trait_ref,\n-                                                     &mut methods);\n+                                                     &mut items);\n                 }\n \n-                methods\n+                items\n             }\n             _ => {\n                 self.crate_context.tcx.sess.span_bug(item.span,\n@@ -614,7 +625,8 @@ impl<'a> CoherenceChecker<'a> {\n                          impls_seen: &mut HashSet<DefId>,\n                          impl_def_id: DefId) {\n         let tcx = self.crate_context.tcx;\n-        let methods = csearch::get_impl_methods(&tcx.sess.cstore, impl_def_id);\n+        let impl_items = csearch::get_impl_items(&tcx.sess.cstore,\n+                                                 impl_def_id);\n \n         // Make sure we don't visit the same implementation multiple times.\n         if !impls_seen.insert(impl_def_id) {\n@@ -629,20 +641,27 @@ impl<'a> CoherenceChecker<'a> {\n         // Do a sanity check.\n         assert!(associated_traits.is_some());\n \n-        // Record all the trait methods.\n+        // Record all the trait items.\n         for trait_ref in associated_traits.iter() {\n             self.add_trait_impl(trait_ref.def_id, impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n-        for &method_def_id in methods.iter() {\n-            for &source in ty::method(tcx, method_def_id).provided_source.iter() {\n-                tcx.provided_method_sources.borrow_mut().insert(method_def_id, source);\n+        for item_def_id in impl_items.iter() {\n+            let impl_item = ty::impl_or_trait_item(tcx, item_def_id.def_id());\n+            match impl_item {\n+                ty::MethodTraitItem(ref method) => {\n+                    for &source in method.provided_source.iter() {\n+                        tcx.provided_method_sources\n+                           .borrow_mut()\n+                           .insert(item_def_id.def_id(), source);\n+                    }\n+                }\n             }\n         }\n \n-        tcx.impl_methods.borrow_mut().insert(impl_def_id, methods);\n+        tcx.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n     }\n \n     // Adds implementations and traits from external crates to the coherence\n@@ -669,28 +688,31 @@ impl<'a> CoherenceChecker<'a> {\n             Some(id) => id, None => { return }\n         };\n \n-        let impl_methods = tcx.impl_methods.borrow();\n+        let impl_items = tcx.impl_items.borrow();\n         let trait_impls = match tcx.trait_impls.borrow().find_copy(&drop_trait) {\n             None => return, // No types with (new-style) dtors present.\n             Some(found_impls) => found_impls\n         };\n \n         for &impl_did in trait_impls.borrow().iter() {\n-            let methods = impl_methods.get(&impl_did);\n-            if methods.len() < 1 {\n+            let items = impl_items.get(&impl_did);\n+            if items.len() < 1 {\n                 // We'll error out later. For now, just don't ICE.\n                 continue;\n             }\n-            let method_def_id = *methods.get(0);\n+            let method_def_id = *items.get(0);\n \n             let self_type = self.get_self_type_for_implementation(impl_did);\n             match ty::get(self_type.ty).sty {\n                 ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) |\n                 ty::ty_unboxed_closure(type_def_id, _) => {\n-                    tcx.destructor_for_type.borrow_mut().insert(type_def_id,\n-                                                                method_def_id);\n-                    tcx.destructors.borrow_mut().insert(method_def_id);\n+                    tcx.destructor_for_type\n+                       .borrow_mut()\n+                       .insert(type_def_id, method_def_id.def_id());\n+                    tcx.destructors\n+                       .borrow_mut()\n+                       .insert(method_def_id.def_id());\n                 }\n                 _ => {\n                     // Destructors only work on nominal types."}, {"sha": "284330c51c86a963e7c269703644f7b1e7bc84de", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 83, "deletions": 63, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -37,7 +37,7 @@ use middle::lang_items::SizedTraitLangItem;\n use middle::resolve_lifetime;\n use middle::subst;\n use middle::subst::{Substs};\n-use middle::ty::{ImplContainer, MethodContainer, TraitContainer};\n+use middle::ty::{ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use middle::ty::{Polytype};\n use middle::ty;\n use middle::ty_fold::TypeFolder;\n@@ -200,64 +200,74 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n     match tcx.map.get(trait_id) {\n         ast_map::NodeItem(item) => {\n             match item.node {\n-                ast::ItemTrait(_, _, _, ref ms) => {\n+                ast::ItemTrait(_, _, _, ref trait_items) => {\n                     // For each method, construct a suitable ty::Method and\n-                    // store it into the `tcx.methods` table:\n-                    for m in ms.iter() {\n-                        let ty_method = Rc::new(match m {\n-                            &ast::Required(ref m) => {\n-                                ty_method_of_trait_method(\n-                                    ccx,\n-                                    trait_id,\n-                                    &trait_def.generics,\n-                                    &m.id,\n-                                    &m.ident,\n-                                    &m.explicit_self,\n-                                    m.abi,\n-                                    &m.generics,\n-                                    &m.fn_style,\n-                                    &*m.decl)\n-                            }\n+                    // store it into the `tcx.impl_or_trait_items` table:\n+                    for trait_item in trait_items.iter() {\n+                        match *trait_item {\n+                            ast::RequiredMethod(_) |\n+                            ast::ProvidedMethod(_) => {\n+                                let ty_method = Rc::new(match *trait_item {\n+                                    ast::RequiredMethod(ref m) => {\n+                                        ty_method_of_trait_method(\n+                                            ccx,\n+                                            trait_id,\n+                                            &trait_def.generics,\n+                                            &m.id,\n+                                            &m.ident,\n+                                            &m.explicit_self,\n+                                            m.abi,\n+                                            &m.generics,\n+                                            &m.fn_style,\n+                                            &*m.decl)\n+                                    }\n+                                    ast::ProvidedMethod(ref m) => {\n+                                        ty_method_of_trait_method(\n+                                            ccx,\n+                                            trait_id,\n+                                            &trait_def.generics,\n+                                            &m.id,\n+                                            &m.pe_ident(),\n+                                            m.pe_explicit_self(),\n+                                            m.pe_abi(),\n+                                            m.pe_generics(),\n+                                            &m.pe_fn_style(),\n+                                            &*m.pe_fn_decl())\n+                                    }\n+                                });\n \n-                            &ast::Provided(ref m) => {\n-                                ty_method_of_trait_method(\n-                                    ccx,\n-                                    trait_id,\n-                                    &trait_def.generics,\n-                                    &m.id,\n-                                    &m.pe_ident(),\n-                                    m.pe_explicit_self(),\n-                                    m.pe_abi(),\n-                                    m.pe_generics(),\n-                                    &m.pe_fn_style(),\n-                                    &*m.pe_fn_decl())\n-                            }\n-                        });\n+                                if ty_method.explicit_self ==\n+                                        ty::StaticExplicitSelfCategory {\n+                                    make_static_method_ty(ccx, &*ty_method);\n+                                }\n \n-                        if ty_method.explicit_self ==\n-                                ty::StaticExplicitSelfCategory {\n-                            make_static_method_ty(ccx, &*ty_method);\n+                                tcx.impl_or_trait_items\n+                                   .borrow_mut()\n+                                   .insert(ty_method.def_id,\n+                                           ty::MethodTraitItem(ty_method));\n+                            }\n                         }\n-\n-                        tcx.methods.borrow_mut().insert(ty_method.def_id,\n-                                                        ty_method);\n                     }\n \n                     // Add an entry mapping\n-                    let method_def_ids = Rc::new(ms.iter().map(|m| {\n-                        match m {\n-                            &ast::Required(ref ty_method) => {\n-                                local_def(ty_method.id)\n-                            }\n-                            &ast::Provided(ref method) => {\n-                                local_def(method.id)\n+                    let trait_item_def_ids =\n+                        Rc::new(trait_items.iter()\n+                                           .map(|ti| {\n+                            match *ti {\n+                                ast::RequiredMethod(ref ty_method) => {\n+                                    ty::MethodTraitItemId(local_def(\n+                                            ty_method.id))\n+                                }\n+                                ast::ProvidedMethod(ref method) => {\n+                                    ty::MethodTraitItemId(local_def(\n+                                            method.id))\n+                                }\n                             }\n-                        }\n-                    }).collect());\n+                        }).collect());\n \n                     let trait_def_id = local_def(trait_id);\n-                    tcx.trait_method_def_ids.borrow_mut()\n-                        .insert(trait_def_id, method_def_ids);\n+                    tcx.trait_item_def_ids.borrow_mut()\n+                        .insert(trait_def_id, trait_item_def_ids);\n                 }\n                 _ => {} // Ignore things that aren't traits.\n             }\n@@ -346,12 +356,11 @@ pub fn convert_field(ccx: &CrateCtxt,\n }\n \n fn convert_methods(ccx: &CrateCtxt,\n-                   container: MethodContainer,\n+                   container: ImplOrTraitItemContainer,\n                    ms: &[Gc<ast::Method>],\n                    untransformed_rcvr_ty: ty::t,\n                    rcvr_ty_generics: &ty::Generics,\n-                   rcvr_visibility: ast::Visibility)\n-{\n+                   rcvr_visibility: ast::Visibility) {\n     let tcx = ccx.tcx;\n     let mut seen_methods = HashSet::new();\n     for m in ms.iter() {\n@@ -379,11 +388,13 @@ fn convert_methods(ccx: &CrateCtxt,\n \n         write_ty_to_tcx(tcx, m.id, fty);\n \n-        tcx.methods.borrow_mut().insert(mty.def_id, mty);\n+        tcx.impl_or_trait_items\n+           .borrow_mut()\n+           .insert(mty.def_id, ty::MethodTraitItem(mty));\n     }\n \n     fn ty_of_method(ccx: &CrateCtxt,\n-                    container: MethodContainer,\n+                    container: ImplOrTraitItemContainer,\n                     m: &ast::Method,\n                     untransformed_rcvr_ty: ty::t,\n                     rcvr_ty_generics: &ty::Generics,\n@@ -459,7 +470,10 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                                    enum_definition.variants.as_slice(),\n                                    generics);\n         },\n-        ast::ItemImpl(ref generics, ref opt_trait_ref, selfty, ref ms) => {\n+        ast::ItemImpl(ref generics,\n+                      ref opt_trait_ref,\n+                      selfty,\n+                      ref impl_items) => {\n             let ty_generics = ty_generics_for_type(ccx, generics);\n             let selfty = ccx.to_ty(&ExplicitRscope, &*selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n@@ -480,16 +494,22 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                 it.vis\n             };\n \n-            for method in ms.iter() {\n-                check_method_self_type(ccx,\n-                                       &BindingRscope::new(method.id),\n-                                       selfty,\n-                                       method.pe_explicit_self())\n+            let mut methods = Vec::new();\n+            for impl_item in impl_items.iter() {\n+                match *impl_item {\n+                    ast::MethodImplItem(ref method) => {\n+                        check_method_self_type(ccx,\n+                                               &BindingRscope::new(method.id),\n+                                               selfty,\n+                                               method.pe_explicit_self());\n+                        methods.push(*method);\n+                    }\n+                }\n             }\n \n             convert_methods(ccx,\n                             ImplContainer(local_def(it.id)),\n-                            ms.as_slice(),\n+                            methods.as_slice(),\n                             selfty,\n                             &ty_generics,\n                             parent_visibility);\n@@ -507,14 +527,14 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                                              0,\n                                              local_def(it.id));\n                 match *trait_method {\n-                    ast::Required(ref type_method) => {\n+                    ast::RequiredMethod(ref type_method) => {\n                         let rscope = BindingRscope::new(type_method.id);\n                         check_method_self_type(ccx,\n                                                &rscope,\n                                                self_type,\n                                                &type_method.explicit_self)\n                     }\n-                    ast::Provided(ref method) => {\n+                    ast::ProvidedMethod(ref method) => {\n                         check_method_self_type(ccx,\n                                                &BindingRscope::new(method.id),\n                                                self_type,"}, {"sha": "a4e7f28b45063b7d0f4e93545c98ba3358c97b5b", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -305,7 +305,8 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                         },\n                         _ => None\n                     },\n-                    ast_map::NodeMethod(..) => {\n+                    ast_map::NodeImplItem(..) |\n+                    ast_map::NodeTraitItem(..) => {\n                         Some(FreeRegionsFromSameFn::new(fr1, fr2, scope_id))\n                     },\n                     _ => None\n@@ -699,9 +700,17 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                         _ => None\n                     }\n                 }\n-                ast_map::NodeMethod(ref m) => {\n-                    Some((m.pe_fn_decl(), m.pe_generics(), m.pe_fn_style(),\n-                          m.pe_ident(), Some(m.pe_explicit_self().node), m.span))\n+                ast_map::NodeImplItem(ref item) => {\n+                    match **item {\n+                        ast::MethodImplItem(ref m) => {\n+                            Some((m.pe_fn_decl(),\n+                                  m.pe_generics(),\n+                                  m.pe_fn_style(),\n+                                  m.pe_ident(),\n+                                  Some(m.pe_explicit_self().node),\n+                                  m.span))\n+                        }\n+                    }\n                 },\n                 _ => None\n             },\n@@ -1454,10 +1463,14 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n                 },\n                 _ => None\n             },\n-            ast_map::NodeMethod(m) => {\n-                taken.push_all(m.pe_generics().lifetimes.as_slice());\n-                Some(m.id)\n-            },\n+            ast_map::NodeImplItem(ii) => {\n+                match *ii {\n+                    ast::MethodImplItem(m) => {\n+                        taken.push_all(m.pe_generics().lifetimes.as_slice());\n+                        Some(m.id)\n+                    }\n+                }\n+            }\n             _ => None\n         },\n         None => None"}, {"sha": "e0fab95a04529435a9c039aceeba218e3bf073b5", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -515,10 +515,14 @@ impl<'a> Visitor<()> for ConstraintContext<'a> {\n             }\n \n             ast::ItemTrait(..) => {\n-                let methods = ty::trait_methods(tcx, did);\n-                for method in methods.iter() {\n-                    self.add_constraints_from_sig(\n-                        &method.fty.sig, self.covariant);\n+                let trait_items = ty::trait_items(tcx, did);\n+                for trait_item in trait_items.iter() {\n+                    match *trait_item {\n+                        ty::MethodTraitItem(ref method) => {\n+                            self.add_constraints_from_sig(&method.fty.sig,\n+                                                          self.covariant);\n+                        }\n+                    }\n                 }\n             }\n \n@@ -609,8 +613,8 @@ impl<'a> ConstraintContext<'a> {\n                         _                    => cannot_happen!(),\n                     }\n                 }\n-                ast_map::NodeTraitMethod(..) => is_inferred = false,\n-                ast_map::NodeMethod(_)       => is_inferred = false,\n+                ast_map::NodeTraitItem(..)   => is_inferred = false,\n+                ast_map::NodeImplItem(..)    => is_inferred = false,\n                 _                            => cannot_happen!(),\n             }\n "}, {"sha": "301143e5045509c941b3bfc2320a8fcc5a2a50c2", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -762,8 +762,8 @@ impl Repr for ast::DefId {\n                 match tcx.map.find(self.node) {\n                     Some(ast_map::NodeItem(..)) |\n                     Some(ast_map::NodeForeignItem(..)) |\n-                    Some(ast_map::NodeMethod(..)) |\n-                    Some(ast_map::NodeTraitMethod(..)) |\n+                    Some(ast_map::NodeImplItem(..)) |\n+                    Some(ast_map::NodeTraitItem(..)) |\n                     Some(ast_map::NodeVariant(..)) |\n                     Some(ast_map::NodeStructCtor(..)) => {\n                         return format!("}, {"sha": "29668795ed7ba429e3d30c42c60fedb976237218", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -480,8 +480,8 @@ mod svh_visitor {\n             SawTyMethod.hash(self.st); visit::walk_ty_method(self, t, e)\n         }\n \n-        fn visit_trait_method(&mut self, t: &TraitMethod, e: E) {\n-            SawTraitMethod.hash(self.st); visit::walk_trait_method(self, t, e)\n+        fn visit_trait_item(&mut self, t: &TraitItem, e: E) {\n+            SawTraitMethod.hash(self.st); visit::walk_trait_item(self, t, e)\n         }\n \n         fn visit_struct_field(&mut self, s: &StructField, e: E) {"}, {"sha": "0e87be1c241b91a1e02de8ab1a4456f042fc30cb", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -157,13 +157,13 @@ pub fn record_extern_fqn(cx: &core::DocContext,\n \n pub fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> clean::Trait {\n     let def = ty::lookup_trait_def(tcx, did);\n-    let methods = ty::trait_methods(tcx, did).clean();\n+    let trait_items = ty::trait_items(tcx, did).clean();\n     let provided = ty::provided_trait_methods(tcx, did);\n-    let mut methods = methods.move_iter().map(|meth| {\n-        if provided.iter().any(|a| a.def_id == meth.def_id) {\n-            clean::Provided(meth)\n+    let mut items = trait_items.move_iter().map(|trait_item| {\n+        if provided.iter().any(|a| a.def_id == trait_item.def_id) {\n+            clean::ProvidedMethod(trait_item)\n         } else {\n-            clean::Required(meth)\n+            clean::RequiredMethod(trait_item)\n         }\n     });\n     let supertraits = ty::trait_supertraits(tcx, did);\n@@ -176,7 +176,7 @@ pub fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> clean::Trait {\n \n     clean::Trait {\n         generics: (&def.generics, subst::TypeSpace).clean(),\n-        methods: methods.collect(),\n+        items: items.collect(),\n         parents: parents.collect()\n     }\n }\n@@ -303,27 +303,33 @@ fn build_impl(cx: &core::DocContext,\n \n     let attrs = load_attrs(tcx, did);\n     let ty = ty::lookup_item_type(tcx, did);\n-    let methods = csearch::get_impl_methods(&tcx.sess.cstore,\n-                                            did).iter().filter_map(|did| {\n-        let method = ty::method(tcx, *did);\n-        if method.vis != ast::Public && associated_trait.is_none() {\n-            return None\n-        }\n-        let mut item = ty::method(tcx, *did).clean();\n-        item.inner = match item.inner.clone() {\n-            clean::TyMethodItem(clean::TyMethod {\n-                fn_style, decl, self_, generics\n-            }) => {\n-                clean::MethodItem(clean::Method {\n-                    fn_style: fn_style,\n-                    decl: decl,\n-                    self_: self_,\n-                    generics: generics,\n-                })\n+    let trait_items = csearch::get_impl_items(&tcx.sess.cstore, did)\n+            .iter()\n+            .filter_map(|did| {\n+        let did = did.def_id();\n+        let impl_item = ty::impl_or_trait_item(tcx, did);\n+        match impl_item {\n+            ty::MethodTraitItem(method) => {\n+                if method.vis != ast::Public && associated_trait.is_none() {\n+                    return None\n+                }\n+                let mut item = method.clean();\n+                item.inner = match item.inner.clone() {\n+                    clean::TyMethodItem(clean::TyMethod {\n+                        fn_style, decl, self_, generics\n+                    }) => {\n+                        clean::MethodItem(clean::Method {\n+                            fn_style: fn_style,\n+                            decl: decl,\n+                            self_: self_,\n+                            generics: generics,\n+                        })\n+                    }\n+                    _ => fail!(\"not a tymethod\"),\n+                };\n+                Some(item)\n             }\n-            _ => fail!(\"not a tymethod\"),\n-        };\n-        Some(item)\n+        }\n     }).collect();\n     return Some(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n@@ -336,7 +342,7 @@ fn build_impl(cx: &core::DocContext,\n             }),\n             for_: ty.ty.clean(),\n             generics: (&ty.generics, subst::TypeSpace).clean(),\n-            methods: methods,\n+            items: trait_items,\n         }),\n         source: clean::Span::empty(),\n         name: None,"}, {"sha": "c5d3c73c9bcf7b5d00fdebda6386b7cab9339bca", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -907,7 +907,7 @@ impl Clean<RetStyle> for ast::RetStyle {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct Trait {\n-    pub methods: Vec<TraitMethod>,\n+    pub items: Vec<TraitItem>,\n     pub generics: Generics,\n     pub parents: Vec<Type>,\n }\n@@ -922,7 +922,7 @@ impl Clean<Item> for doctree::Trait {\n             visibility: self.vis.clean(),\n             stability: self.stab.clean(),\n             inner: TraitItem(Trait {\n-                methods: self.methods.clean(),\n+                items: self.items.clean(),\n                 generics: self.generics.clean(),\n                 parents: self.parents.clean(),\n             }),\n@@ -937,37 +937,50 @@ impl Clean<Type> for ast::TraitRef {\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n-pub enum TraitMethod {\n-    Required(Item),\n-    Provided(Item),\n+pub enum TraitItem {\n+    RequiredMethod(Item),\n+    ProvidedMethod(Item),\n }\n \n-impl TraitMethod {\n+impl TraitItem {\n     pub fn is_req(&self) -> bool {\n         match self {\n-            &Required(..) => true,\n+            &RequiredMethod(..) => true,\n             _ => false,\n         }\n     }\n     pub fn is_def(&self) -> bool {\n         match self {\n-            &Provided(..) => true,\n+            &ProvidedMethod(..) => true,\n             _ => false,\n         }\n     }\n     pub fn item<'a>(&'a self) -> &'a Item {\n         match *self {\n-            Required(ref item) => item,\n-            Provided(ref item) => item,\n+            RequiredMethod(ref item) => item,\n+            ProvidedMethod(ref item) => item,\n         }\n     }\n }\n \n-impl Clean<TraitMethod> for ast::TraitMethod {\n-    fn clean(&self) -> TraitMethod {\n+impl Clean<TraitItem> for ast::TraitItem {\n+    fn clean(&self) -> TraitItem {\n         match self {\n-            &ast::Required(ref t) => Required(t.clean()),\n-            &ast::Provided(ref t) => Provided(t.clean()),\n+            &ast::RequiredMethod(ref t) => RequiredMethod(t.clean()),\n+            &ast::ProvidedMethod(ref t) => ProvidedMethod(t.clean()),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub enum ImplItem {\n+    MethodImplItem(Item),\n+}\n+\n+impl Clean<ImplItem> for ast::ImplItem {\n+    fn clean(&self) -> ImplItem {\n+        match self {\n+            &ast::MethodImplItem(ref t) => MethodImplItem(t.clean()),\n         }\n     }\n }\n@@ -1019,6 +1032,14 @@ impl Clean<Item> for ty::Method {\n     }\n }\n \n+impl Clean<Item> for ty::ImplOrTraitItem {\n+    fn clean(&self) -> Item {\n+        match *self {\n+            ty::MethodTraitItem(ref mti) => mti.clean(),\n+        }\n+    }\n+}\n+\n /// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n /// type out of the AST/ty::ctxt given one of these, if more information is needed. Most importantly\n /// it does not preserve mutability or boxes.\n@@ -1714,7 +1735,7 @@ pub struct Impl {\n     pub generics: Generics,\n     pub trait_: Option<Type>,\n     pub for_: Type,\n-    pub methods: Vec<Item>,\n+    pub items: Vec<Item>,\n     pub derived: bool,\n }\n \n@@ -1735,7 +1756,11 @@ impl Clean<Item> for doctree::Impl {\n                 generics: self.generics.clean(),\n                 trait_: self.trait_.clean(),\n                 for_: self.for_.clean(),\n-                methods: self.methods.clean(),\n+                items: self.items.clean().move_iter().map(|ti| {\n+                        match ti {\n+                            MethodImplItem(i) => i,\n+                        }\n+                    }).collect(),\n                 derived: detect_derived(self.attrs.as_slice()),\n             }),\n         }"}, {"sha": "a5ead46384a0056dda7e0a6eb52b8be3c381042c", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -154,7 +154,7 @@ pub struct Static {\n \n pub struct Trait {\n     pub name: Ident,\n-    pub methods: Vec<ast::TraitMethod>, //should be TraitMethod\n+    pub items: Vec<ast::TraitItem>, //should be TraitItem\n     pub generics: ast::Generics,\n     pub parents: Vec<ast::TraitRef>,\n     pub attrs: Vec<ast::Attribute>,\n@@ -168,7 +168,7 @@ pub struct Impl {\n     pub generics: ast::Generics,\n     pub trait_: Option<ast::TraitRef>,\n     pub for_: ast::P<ast::Ty>,\n-    pub methods: Vec<Gc<ast::Method>>,\n+    pub items: Vec<ast::ImplItem>,\n     pub attrs: Vec<ast::Attribute>,\n     pub where: Span,\n     pub vis: ast::Visibility,"}, {"sha": "f0082f8900e6ae3414a92b802490d06786c8f33c", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -40,29 +40,31 @@ pub trait DocFolder {\n                 EnumItem(i)\n             },\n             TraitItem(mut i) => {\n-                fn vtrm<T: DocFolder>(this: &mut T, trm: TraitMethod) -> Option<TraitMethod> {\n+                fn vtrm<T: DocFolder>(this: &mut T, trm: TraitItem)\n+                        -> Option<TraitItem> {\n                     match trm {\n-                        Required(it) => {\n+                        RequiredMethod(it) => {\n                             match this.fold_item(it) {\n-                                Some(x) => return Some(Required(x)),\n+                                Some(x) => return Some(RequiredMethod(x)),\n                                 None => return None,\n                             }\n                         },\n-                        Provided(it) => {\n+                        ProvidedMethod(it) => {\n                             match this.fold_item(it) {\n-                                Some(x) => return Some(Provided(x)),\n+                                Some(x) => return Some(ProvidedMethod(x)),\n                                 None => return None,\n                             }\n                         },\n                     }\n                 }\n-                let mut foo = Vec::new(); swap(&mut foo, &mut i.methods);\n-                i.methods.extend(foo.move_iter().filter_map(|x| vtrm(self, x)));\n+                let mut foo = Vec::new(); swap(&mut foo, &mut i.items);\n+                i.items.extend(foo.move_iter().filter_map(|x| vtrm(self, x)));\n                 TraitItem(i)\n             },\n             ImplItem(mut i) => {\n-                let mut foo = Vec::new(); swap(&mut foo, &mut i.methods);\n-                i.methods.extend(foo.move_iter().filter_map(|x| self.fold_item(x)));\n+                let mut foo = Vec::new(); swap(&mut foo, &mut i.items);\n+                i.items.extend(foo.move_iter()\n+                                  .filter_map(|x| self.fold_item(x)));\n                 ImplItem(i)\n             },\n             VariantItem(i) => {"}, {"sha": "bb68c6536a00d3ab676b3c506de65b87be9ad5df", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -1624,10 +1624,24 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                   it.name.get_ref().as_slice(),\n                   t.generics,\n                   parents));\n-    let required = t.methods.iter().filter(|m| m.is_req()).collect::<Vec<&clean::TraitMethod>>();\n-    let provided = t.methods.iter().filter(|m| !m.is_req()).collect::<Vec<&clean::TraitMethod>>();\n-\n-    if t.methods.len() == 0 {\n+    let required = t.items.iter()\n+                          .filter(|m| {\n+                              match **m {\n+                                  clean::RequiredMethod(_) => true,\n+                                  _ => false,\n+                              }\n+                          })\n+                          .collect::<Vec<&clean::TraitItem>>();\n+    let provided = t.items.iter()\n+                          .filter(|m| {\n+                              match **m {\n+                                  clean::ProvidedMethod(_) => true,\n+                                  _ => false,\n+                              }\n+                          })\n+                          .collect::<Vec<&clean::TraitItem>>();\n+\n+    if t.items.len() == 0 {\n         try!(write!(w, \"{{ }}\"));\n     } else {\n         try!(write!(w, \"{{\\n\"));\n@@ -1651,7 +1665,8 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     // Trait documentation\n     try!(document(w, it));\n \n-    fn meth(w: &mut fmt::Formatter, m: &clean::TraitMethod) -> fmt::Result {\n+    fn trait_item(w: &mut fmt::Formatter, m: &clean::TraitItem)\n+                  -> fmt::Result {\n         try!(write!(w, \"<h3 id='{}.{}' class='method'>{}<code>\",\n                     shortty(m.item()),\n                     *m.item().name.get_ref(),\n@@ -1669,7 +1684,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <div class='methods'>\n         \"));\n         for m in required.iter() {\n-            try!(meth(w, *m));\n+            try!(trait_item(w, *m));\n         }\n         try!(write!(w, \"</div>\"));\n     }\n@@ -1679,7 +1694,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <div class='methods'>\n         \"));\n         for m in provided.iter() {\n-            try!(meth(w, *m));\n+            try!(trait_item(w, *m));\n         }\n         try!(write!(w, \"</div>\"));\n     }\n@@ -1991,8 +2006,8 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n         None => {}\n     }\n \n-    fn docmeth(w: &mut fmt::Formatter, item: &clean::Item,\n-               dox: bool) -> fmt::Result {\n+    fn doctraititem(w: &mut fmt::Formatter, item: &clean::Item, dox: bool)\n+                    -> fmt::Result {\n         try!(write!(w, \"<h4 id='method.{}' class='method'>{}<code>\",\n                     *item.name.get_ref(),\n                     ConciseStability(&item.stability)));\n@@ -2008,21 +2023,21 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n     }\n \n     try!(write!(w, \"<div class='impl-methods'>\"));\n-    for meth in i.impl_.methods.iter() {\n-        try!(docmeth(w, meth, true));\n+    for trait_item in i.impl_.items.iter() {\n+        try!(doctraititem(w, trait_item, true));\n     }\n \n     fn render_default_methods(w: &mut fmt::Formatter,\n                               t: &clean::Trait,\n                               i: &clean::Impl) -> fmt::Result {\n-        for method in t.methods.iter() {\n-            let n = method.item().name.clone();\n-            match i.methods.iter().find(|m| { m.name == n }) {\n+        for trait_item in t.items.iter() {\n+            let n = trait_item.item().name.clone();\n+            match i.items.iter().find(|m| { m.name == n }) {\n                 Some(..) => continue,\n                 None => {}\n             }\n \n-            try!(docmeth(w, method.item(), false));\n+            try!(doctraititem(w, trait_item.item(), false));\n         }\n         Ok(())\n     }"}, {"sha": "eeccc3303ebfec7e000f307dc9c6744e65288062", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -202,7 +202,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n                     clean::ModuleItem(ref m)\n                         if m.items.len() == 0 &&\n                            i.doc_value().is_none() => None,\n-                    clean::ImplItem(ref i) if i.methods.len() == 0 => None,\n+                    clean::ImplItem(ref i) if i.items.len() == 0 => None,\n                     _ => {\n                         self.retained.insert(i.def_id.node);\n                         Some(i)"}, {"sha": "bbcf38f4955715604cb30f0bab593c41f09d5a52", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -21,7 +21,7 @@ use syntax::attr::{Deprecated, Experimental, Unstable, Stable, Frozen, Locked};\n use syntax::ast::Public;\n \n use clean::{Crate, Item, ModuleItem, Module, StructItem, Struct, EnumItem, Enum};\n-use clean::{ImplItem, Impl, TraitItem, Trait, TraitMethod, Provided, Required};\n+use clean::{ImplItem, Impl, Trait, TraitItem, ProvidedMethod, RequiredMethod};\n use clean::{ViewItemItem, PrimitiveItem};\n \n #[deriving(Zero, Encodable, Decodable, PartialEq, Eq)]\n@@ -110,7 +110,7 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n     match item.inner {\n         // Require explicit `pub` to be visible\n         StructItem(Struct { fields: ref subitems, .. }) |\n-        ImplItem(Impl { methods: ref subitems, trait_: None, .. }) => {\n+        ImplItem(Impl { items: ref subitems, trait_: None, .. }) => {\n             let subcounts = subitems.iter().filter(|i| visible(*i))\n                                            .map(summarize_item)\n                                            .map(|s| s.val0())\n@@ -124,16 +124,21 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n                                            .sum();\n             (item_counts + subcounts, None)\n         }\n-        TraitItem(Trait { methods: ref methods, .. }) => {\n-            fn extract_item<'a>(meth: &'a TraitMethod) -> &'a Item {\n-                match *meth {\n-                    Provided(ref item) | Required(ref item) => item\n+        TraitItem(Trait {\n+            items: ref trait_items,\n+            ..\n+        }) => {\n+            fn extract_item<'a>(trait_item: &'a TraitItem) -> &'a Item {\n+                match *trait_item {\n+                    ProvidedMethod(ref item) |\n+                    RequiredMethod(ref item) => item\n                 }\n             }\n-            let subcounts = methods.iter().map(extract_item)\n-                                          .map(summarize_item)\n-                                          .map(|s| s.val0())\n-                                          .sum();\n+            let subcounts = trait_items.iter()\n+                                       .map(extract_item)\n+                                       .map(summarize_item)\n+                                       .map(|s| s.val0())\n+                                       .sum();\n             (item_counts + subcounts, None)\n         }\n         ModuleItem(Module { items: ref items, .. }) => {"}, {"sha": "f7ccad79fdacca21363733e102b0ecf8b4c5cbfe", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -317,10 +317,10 @@ impl<'a> RustdocVisitor<'a> {\n                 };\n                 om.statics.push(s);\n             },\n-            ast::ItemTrait(ref gen, _, ref tr, ref met) => {\n+            ast::ItemTrait(ref gen, _, ref tr, ref items) => {\n                 let t = Trait {\n                     name: item.ident,\n-                    methods: met.iter().map(|x| (*x).clone()).collect(),\n+                    items: items.iter().map(|x| (*x).clone()).collect(),\n                     generics: gen.clone(),\n                     parents: tr.iter().map(|x| (*x).clone()).collect(),\n                     id: item.id,\n@@ -331,12 +331,12 @@ impl<'a> RustdocVisitor<'a> {\n                 };\n                 om.traits.push(t);\n             },\n-            ast::ItemImpl(ref gen, ref tr, ty, ref meths) => {\n+            ast::ItemImpl(ref gen, ref tr, ty, ref items) => {\n                 let i = Impl {\n                     generics: gen.clone(),\n                     trait_: tr.clone(),\n                     for_: ty,\n-                    methods: meths.iter().map(|x| *x).collect(),\n+                    items: items.iter().map(|x| *x).collect(),\n                     attrs: item.attrs.iter().map(|x| *x).collect(),\n                     id: item.id,\n                     where: item.span,"}, {"sha": "1ff8ca10fffbd410dc4de965316360638454b90c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -767,9 +767,14 @@ pub struct TypeMethod {\n /// doesn't have an implementation, just a signature) or provided (meaning it\n /// has a default implementation).\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n-pub enum TraitMethod {\n-    Required(TypeMethod),\n-    Provided(Gc<Method>),\n+pub enum TraitItem {\n+    RequiredMethod(TypeMethod),\n+    ProvidedMethod(Gc<Method>),\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub enum ImplItem {\n+    MethodImplItem(Gc<Method>),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n@@ -1273,11 +1278,11 @@ pub enum Item_ {\n               Option<TyParamBound>, // (optional) default bound not required for Self.\n                                     // Currently, only Sized makes sense here.\n               Vec<TraitRef> ,\n-              Vec<TraitMethod>),\n+              Vec<TraitItem>),\n     ItemImpl(Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n-             Vec<Gc<Method>>),\n+             Vec<ImplItem>),\n     /// A macro invocation (which includes macro definition)\n     ItemMac(Mac),\n }\n@@ -1311,10 +1316,16 @@ pub enum UnboxedClosureKind {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum InlinedItem {\n     IIItem(Gc<Item>),\n-    IIMethod(DefId /* impl id */, bool /* is provided */, Gc<Method>),\n+    IITraitItem(DefId /* impl id */, InlinedTraitItem),\n     IIForeign(Gc<ForeignItem>),\n }\n \n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub enum InlinedTraitItem {\n+    ProvidedInlinedTraitItem(Gc<Method>),\n+    RequiredInlinedTraitItem(Gc<Method>),\n+}\n+\n #[cfg(test)]\n mod test {\n     use serialize::json;"}, {"sha": "b00c6ce14b5b85f58dfdc9d225b4e8b0c34e89a5", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -60,9 +60,9 @@ impl MaybeFnLike for ast::Item {\n     }\n }\n \n-impl MaybeFnLike for ast::TraitMethod {\n+impl MaybeFnLike for ast::TraitItem {\n     fn is_fn_like(&self) -> bool {\n-        match *self { ast::Provided(_) => true, _ => false, }\n+        match *self { ast::ProvidedMethod(_) => true, _ => false, }\n     }\n }\n \n@@ -97,9 +97,9 @@ impl Code {\n         match node {\n             ast_map::NodeItem(item) if item.is_fn_like() =>\n                 Some(FnLikeCode(new(node))),\n-            ast_map::NodeTraitMethod(tm) if tm.is_fn_like() =>\n+            ast_map::NodeTraitItem(tm) if tm.is_fn_like() =>\n                 Some(FnLikeCode(new(node))),\n-            ast_map::NodeMethod(_) =>\n+            ast_map::NodeImplItem(_) =>\n                 Some(FnLikeCode(new(node))),\n             ast_map::NodeExpr(e) if e.is_fn_like() =>\n                 Some(FnLikeCode(new(node))),\n@@ -200,11 +200,15 @@ impl FnLikeNode {\n                     }),\n                 _ => fail!(\"item FnLikeNode that is not fn-like\"),\n             },\n-            ast_map::NodeTraitMethod(ref t) => match **t {\n-                ast::Provided(ref m) => method(&**m),\n+            ast_map::NodeTraitItem(ref t) => match **t {\n+                ast::ProvidedMethod(ref m) => method(&**m),\n                 _ => fail!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n-            ast_map::NodeMethod(ref m) => method(&**m),\n+            ast_map::NodeImplItem(ref ii) => {\n+                match **ii {\n+                    ast::MethodImplItem(ref m) => method(&**m),\n+                }\n+            }\n             ast_map::NodeExpr(ref e) => match e.node {\n                 ast::ExprFnBlock(_, ref decl, ref block) =>\n                     closure(ClosureParts::new(*decl, *block, e.id, e.span)),"}, {"sha": "78afa8441c5f3e265cbb9268f48ac1aecf1757b9", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 97, "deletions": 55, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -99,8 +99,8 @@ pub fn path_to_string<PI: Iterator<PathElem>>(mut path: PI) -> String {\n pub enum Node {\n     NodeItem(Gc<Item>),\n     NodeForeignItem(Gc<ForeignItem>),\n-    NodeTraitMethod(Gc<TraitMethod>),\n-    NodeMethod(Gc<Method>),\n+    NodeTraitItem(Gc<TraitItem>),\n+    NodeImplItem(Gc<ImplItem>),\n     NodeVariant(P<Variant>),\n     NodeExpr(Gc<Expr>),\n     NodeStmt(Gc<Stmt>),\n@@ -125,8 +125,8 @@ enum MapEntry {\n     /// All the node types, with a parent ID.\n     EntryItem(NodeId, Gc<Item>),\n     EntryForeignItem(NodeId, Gc<ForeignItem>),\n-    EntryTraitMethod(NodeId, Gc<TraitMethod>),\n-    EntryMethod(NodeId, Gc<Method>),\n+    EntryTraitItem(NodeId, Gc<TraitItem>),\n+    EntryImplItem(NodeId, Gc<ImplItem>),\n     EntryVariant(NodeId, P<Variant>),\n     EntryExpr(NodeId, Gc<Expr>),\n     EntryStmt(NodeId, Gc<Stmt>),\n@@ -144,7 +144,7 @@ enum MapEntry {\n \n struct InlinedParent {\n     path: Vec<PathElem> ,\n-    /// Required by NodeTraitMethod and NodeMethod.\n+    /// RequiredMethod by NodeTraitItem and NodeImplItem.\n     def_id: DefId\n }\n \n@@ -153,8 +153,8 @@ impl MapEntry {\n         Some(match *self {\n             EntryItem(id, _) => id,\n             EntryForeignItem(id, _) => id,\n-            EntryTraitMethod(id, _) => id,\n-            EntryMethod(id, _) => id,\n+            EntryTraitItem(id, _) => id,\n+            EntryImplItem(id, _) => id,\n             EntryVariant(id, _) => id,\n             EntryExpr(id, _) => id,\n             EntryStmt(id, _) => id,\n@@ -172,8 +172,8 @@ impl MapEntry {\n         Some(match *self {\n             EntryItem(_, p) => NodeItem(p),\n             EntryForeignItem(_, p) => NodeForeignItem(p),\n-            EntryTraitMethod(_, p) => NodeTraitMethod(p),\n-            EntryMethod(_, p) => NodeMethod(p),\n+            EntryTraitItem(_, p) => NodeTraitItem(p),\n+            EntryImplItem(_, p) => NodeImplItem(p),\n             EntryVariant(_, p) => NodeVariant(p),\n             EntryExpr(_, p) => NodeExpr(p),\n             EntryStmt(_, p) => NodeStmt(p),\n@@ -324,13 +324,23 @@ impl Map {\n                 }\n             }\n             NodeForeignItem(i) => PathName(i.ident.name),\n-            NodeMethod(m) => match m.node {\n-                MethDecl(ident, _, _, _, _, _, _, _) => PathName(ident.name),\n-                MethMac(_) => fail!(\"no path elem for {:?}\", node)\n+            NodeImplItem(ii) => {\n+                match *ii {\n+                    MethodImplItem(ref m) => {\n+                        match m.node {\n+                            MethDecl(ident, _, _, _, _, _, _, _) => {\n+                                PathName(ident.name)\n+                            }\n+                            MethMac(_) => {\n+                                fail!(\"no path elem for {:?}\", node)\n+                            }\n+                        }\n+                    }\n+                }\n             },\n-            NodeTraitMethod(tm) => match *tm {\n-                Required(ref m) => PathName(m.ident.name),\n-                Provided(m) => match m.node {\n+            NodeTraitItem(tm) => match *tm {\n+                RequiredMethod(ref m) => PathName(m.ident.name),\n+                ProvidedMethod(m) => match m.node {\n                     MethDecl(ident, _, _, _, _, _, _, _) => {\n                         PathName(ident.name)\n                     }\n@@ -393,11 +403,15 @@ impl Map {\n         let attrs = match node {\n             NodeItem(ref i) => Some(i.attrs.as_slice()),\n             NodeForeignItem(ref fi) => Some(fi.attrs.as_slice()),\n-            NodeTraitMethod(ref tm) => match **tm {\n-                Required(ref type_m) => Some(type_m.attrs.as_slice()),\n-                Provided(ref m) => Some(m.attrs.as_slice())\n+            NodeTraitItem(ref tm) => match **tm {\n+                RequiredMethod(ref type_m) => Some(type_m.attrs.as_slice()),\n+                ProvidedMethod(ref m) => Some(m.attrs.as_slice())\n             },\n-            NodeMethod(ref m) => Some(m.attrs.as_slice()),\n+            NodeImplItem(ref ii) => {\n+                match **ii {\n+                    MethodImplItem(ref m) => Some(m.attrs.as_slice()),\n+                }\n+            }\n             NodeVariant(ref v) => Some(v.node.attrs.as_slice()),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n@@ -428,13 +442,17 @@ impl Map {\n         let sp = match self.find(id) {\n             Some(NodeItem(item)) => item.span,\n             Some(NodeForeignItem(foreign_item)) => foreign_item.span,\n-            Some(NodeTraitMethod(trait_method)) => {\n+            Some(NodeTraitItem(trait_method)) => {\n                 match *trait_method {\n-                    Required(ref type_method) => type_method.span,\n-                    Provided(ref method) => method.span,\n+                    RequiredMethod(ref type_method) => type_method.span,\n+                    ProvidedMethod(ref method) => method.span,\n+                }\n+            }\n+            Some(NodeImplItem(ref impl_item)) => {\n+                match **impl_item {\n+                    MethodImplItem(ref method) => method.span,\n                 }\n             }\n-            Some(NodeMethod(method)) => method.span,\n             Some(NodeVariant(variant)) => variant.span,\n             Some(NodeExpr(expr)) => expr.span,\n             Some(NodeStmt(stmt)) => stmt.span,\n@@ -532,8 +550,8 @@ impl<'a,S:Str> Iterator<NodeId> for NodesMatchingSuffix<'a,S> {\n             let (p, name) = match self.map.find_entry(idx) {\n                 Some(EntryItem(p, n))        => (p, n.name()),\n                 Some(EntryForeignItem(p, n)) => (p, n.name()),\n-                Some(EntryTraitMethod(p, n)) => (p, n.name()),\n-                Some(EntryMethod(p, n))      => (p, n.name()),\n+                Some(EntryTraitItem(p, n))   => (p, n.name()),\n+                Some(EntryImplItem(p, n))    => (p, n.name()),\n                 Some(EntryVariant(p, n))     => (p, n.name()),\n                 _ => continue,\n             };\n@@ -553,11 +571,18 @@ impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() }\n impl Named for Item { fn name(&self) -> Name { self.ident.name } }\n impl Named for ForeignItem { fn name(&self) -> Name { self.ident.name } }\n impl Named for Variant_ { fn name(&self) -> Name { self.name.name } }\n-impl Named for TraitMethod {\n+impl Named for TraitItem {\n+    fn name(&self) -> Name {\n+        match *self {\n+            RequiredMethod(ref tm) => tm.ident.name,\n+            ProvidedMethod(m) => m.name(),\n+        }\n+    }\n+}\n+impl Named for ImplItem {\n     fn name(&self) -> Name {\n         match *self {\n-            Required(ref tm) => tm.ident.name,\n-            Provided(m) => m.name(),\n+            MethodImplItem(ref m) => m.name(),\n         }\n     }\n }\n@@ -616,9 +641,15 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         assert_eq!(self.parent, i.id);\n \n         match i.node {\n-            ItemImpl(_, _, _, ref ms) => {\n-                for &m in ms.iter() {\n-                    self.insert(m.id, EntryMethod(self.parent, m));\n+            ItemImpl(_, _, _, ref impl_items) => {\n+                for impl_item in impl_items.iter() {\n+                    match *impl_item {\n+                        MethodImplItem(m) => {\n+                            self.insert(m.id,\n+                                        EntryImplItem(self.parent,\n+                                                      box(GC) *impl_item));\n+                        }\n+                    }\n                 }\n             }\n             ItemEnum(ref enum_definition, _) => {\n@@ -649,13 +680,13 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n \n                 for tm in methods.iter() {\n                     match *tm {\n-                        Required(ref m) => {\n-                            self.insert(m.id, EntryTraitMethod(self.parent,\n+                        RequiredMethod(ref m) => {\n+                            self.insert(m.id, EntryTraitItem(self.parent,\n                                                                box(GC) (*tm).clone()));\n                         }\n-                        Provided(m) => {\n-                            self.insert(m.id, EntryTraitMethod(self.parent,\n-                                                               box(GC) Provided(m)));\n+                        ProvidedMethod(m) => {\n+                            self.insert(m.id, EntryTraitItem(self.parent,\n+                                                               box(GC) ProvidedMethod(m)));\n                         }\n                     }\n                 }\n@@ -798,13 +829,18 @@ pub fn map_decoded_item<F: FoldOps>(map: &Map,\n     let ii = fold(&mut cx);\n     match ii {\n         IIItem(_) => {}\n-        IIMethod(impl_did, is_provided, m) => {\n-            let entry = if is_provided {\n-                EntryTraitMethod(cx.parent, box(GC) Provided(m))\n-            } else {\n-                EntryMethod(cx.parent, m)\n+        IITraitItem(impl_did, inlined_trait_item) => {\n+            let (trait_item_id, entry) = match inlined_trait_item {\n+                ProvidedInlinedTraitItem(m) => {\n+                    (m.id,\n+                     EntryTraitItem(cx.parent, box(GC) ProvidedMethod(m)))\n+                }\n+                RequiredInlinedTraitItem(m) => {\n+                    (m.id,\n+                     EntryImplItem(cx.parent, box(GC) MethodImplItem(m)))\n+                }\n             };\n-            cx.insert(m.id, entry);\n+            cx.insert(trait_item_id, entry);\n             def_id = impl_did;\n         }\n         IIForeign(i) => {\n@@ -829,8 +865,8 @@ impl<'a> NodePrinter for pprust::State<'a> {\n         match *node {\n             NodeItem(a)        => self.print_item(&*a),\n             NodeForeignItem(a) => self.print_foreign_item(&*a),\n-            NodeTraitMethod(a) => self.print_trait_method(&*a),\n-            NodeMethod(a)      => self.print_method(&*a),\n+            NodeTraitItem(a)   => self.print_trait_method(&*a),\n+            NodeImplItem(a)    => self.print_impl_item(&*a),\n             NodeVariant(a)     => self.print_variant(&*a),\n             NodeExpr(a)        => self.print_expr(&*a),\n             NodeStmt(a)        => self.print_stmt(&*a),\n@@ -870,17 +906,23 @@ fn node_id_to_string(map: &Map, id: NodeId) -> String {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n             format!(\"foreign item {} (id={})\", path_str, id)\n         }\n-        Some(NodeMethod(m)) => match m.node {\n-            MethDecl(ident, _, _, _, _, _, _, _) =>\n-                format!(\"method {} in {} (id={})\",\n-                        token::get_ident(ident),\n-                        map.path_to_string(id), id),\n-            MethMac(ref mac) =>\n-                format!(\"method macro {} (id={})\",\n-                        pprust::mac_to_string(mac), id)\n-        },\n-        Some(NodeTraitMethod(ref tm)) => {\n-            let m = ast_util::trait_method_to_ty_method(&**tm);\n+        Some(NodeImplItem(ref ii)) => {\n+            match **ii {\n+                MethodImplItem(ref m) => {\n+                    match m.node {\n+                        MethDecl(ident, _, _, _, _, _, _, _) =>\n+                            format!(\"method {} in {} (id={})\",\n+                                    token::get_ident(ident),\n+                                    map.path_to_string(id), id),\n+                        MethMac(ref mac) =>\n+                            format!(\"method macro {} (id={})\",\n+                                    pprust::mac_to_string(mac), id)\n+                    }\n+                }\n+            }\n+        }\n+        Some(NodeTraitItem(ref tm)) => {\n+            let m = ast_util::trait_item_to_ty_method(&**tm);\n             format!(\"method {} in {} (id={})\",\n                     token::get_ident(m.ident),\n                     map.path_to_string(id), id)"}, {"sha": "7689646d373c4027de875a3f901c775ea6f84f65", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -241,51 +241,52 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     token::gensym_ident(pretty.as_slice())\n }\n \n-/// extract a TypeMethod from a TraitMethod. if the TraitMethod is\n+pub fn trait_method_to_ty_method(method: &Method) -> TypeMethod {\n+    match method.node {\n+        MethDecl(ident,\n+                 ref generics,\n+                 abi,\n+                 explicit_self,\n+                 fn_style,\n+                 decl,\n+                 _,\n+                 vis) => {\n+            TypeMethod {\n+                ident: ident,\n+                attrs: method.attrs.clone(),\n+                fn_style: fn_style,\n+                decl: decl,\n+                generics: generics.clone(),\n+                explicit_self: explicit_self,\n+                id: method.id,\n+                span: method.span,\n+                vis: vis,\n+                abi: abi,\n+            }\n+        },\n+        MethMac(_) => fail!(\"expected non-macro method declaration\")\n+    }\n+}\n+\n+/// extract a TypeMethod from a TraitItem. if the TraitItem is\n /// a default, pull out the useful fields to make a TypeMethod\n //\n // NB: to be used only after expansion is complete, and macros are gone.\n-pub fn trait_method_to_ty_method(method: &TraitMethod) -> TypeMethod {\n+pub fn trait_item_to_ty_method(method: &TraitItem) -> TypeMethod {\n     match *method {\n-        Required(ref m) => (*m).clone(),\n-        Provided(m) => {\n-            match m.node {\n-                MethDecl(ident,\n-                         ref generics,\n-                         abi,\n-                         explicit_self,\n-                         fn_style,\n-                         decl,\n-                         _,\n-                         vis) => {\n-                    TypeMethod {\n-                        ident: ident,\n-                        attrs: m.attrs.clone(),\n-                        fn_style: fn_style,\n-                        decl: decl,\n-                        generics: generics.clone(),\n-                        explicit_self: explicit_self,\n-                        id: m.id,\n-                        span: m.span,\n-                        vis: vis,\n-                        abi: abi,\n-                    }\n-                },\n-                MethMac(_) => fail!(\"expected non-macro method declaration\")\n-            }\n-\n-        }\n+        RequiredMethod(ref m) => (*m).clone(),\n+        ProvidedMethod(ref m) => trait_method_to_ty_method(&**m),\n     }\n }\n \n-pub fn split_trait_methods(trait_methods: &[TraitMethod])\n+pub fn split_trait_methods(trait_methods: &[TraitItem])\n     -> (Vec<TypeMethod> , Vec<Gc<Method>> ) {\n     let mut reqd = Vec::new();\n     let mut provd = Vec::new();\n     for trt_method in trait_methods.iter() {\n         match *trt_method {\n-            Required(ref tm) => reqd.push((*tm).clone()),\n-            Provided(m) => provd.push(m)\n+            RequiredMethod(ref tm) => reqd.push((*tm).clone()),\n+            ProvidedMethod(m) => provd.push(m)\n         }\n     };\n     (reqd, provd)\n@@ -543,12 +544,12 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n         visit::walk_struct_def(self, struct_def, ());\n     }\n \n-    fn visit_trait_method(&mut self, tm: &ast::TraitMethod, _: ()) {\n+    fn visit_trait_item(&mut self, tm: &ast::TraitItem, _: ()) {\n         match *tm {\n-            ast::Required(ref m) => self.operation.visit_id(m.id),\n-            ast::Provided(ref m) => self.operation.visit_id(m.id),\n+            ast::RequiredMethod(ref m) => self.operation.visit_id(m.id),\n+            ast::ProvidedMethod(ref m) => self.operation.visit_id(m.id),\n         }\n-        visit::walk_trait_method(self, tm, ());\n+        visit::walk_trait_item(self, tm, ());\n     }\n }\n "}, {"sha": "7a8ee6d1416834b2be06f6045af0d86cb163f3a9", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -452,8 +452,13 @@ impl<'a> TraitDef<'a> {\n             self.span,\n             ident,\n             (vec!(attr)).append(self.attributes.as_slice()),\n-            ast::ItemImpl(trait_generics, opt_trait_ref,\n-                          self_type, methods))\n+            ast::ItemImpl(trait_generics,\n+                          opt_trait_ref,\n+                          self_type,\n+                          methods.move_iter()\n+                                 .map(|method| {\n+                                     ast::MethodImplItem(method)\n+                                 }).collect()))\n     }\n \n     fn expand_struct_def(&self,"}, {"sha": "4ed2a3ed4c2b0cd8304c059daabb28810a3a2e47", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -834,26 +834,37 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n             let struct_def = folder.fold_struct_def(*struct_def);\n             ItemStruct(struct_def, folder.fold_generics(generics))\n         }\n-        ItemImpl(ref generics, ref ifce, ty, ref methods) => {\n+        ItemImpl(ref generics, ref ifce, ty, ref impl_items) => {\n             ItemImpl(folder.fold_generics(generics),\n                      ifce.as_ref().map(|p| folder.fold_trait_ref(p)),\n                      folder.fold_ty(ty),\n-                     methods.iter().flat_map(|x| folder.fold_method(*x).move_iter()).collect()\n+                     impl_items.iter()\n+                               .flat_map(|impl_item| {\n+                                    match *impl_item {\n+                                        MethodImplItem(x) => {\n+                                            folder.fold_method(x)\n+                                                  .move_iter()\n+                                                  .map(|x| MethodImplItem(x))\n+                                        }\n+                                    }\n+                               }).collect()\n             )\n         }\n         ItemTrait(ref generics, ref unbound, ref traits, ref methods) => {\n             let methods = methods.iter().flat_map(|method| {\n                 let r = match *method {\n-                    Required(ref m) =>\n-                            SmallVector::one(Required(folder.fold_type_method(m))).move_iter(),\n-                    Provided(method) => {\n+                    RequiredMethod(ref m) => {\n+                            SmallVector::one(RequiredMethod(\n+                                    folder.fold_type_method(m))).move_iter()\n+                    }\n+                    ProvidedMethod(method) => {\n                             // the awkward collect/iter idiom here is because\n                             // even though an iter and a map satisfy the same trait bound,\n                             // they're not actually the same type, so the method arms\n                             // don't unify.\n-                            let methods : SmallVector<ast::TraitMethod> =\n+                            let methods : SmallVector<ast::TraitItem> =\n                                 folder.fold_method(method).move_iter()\n-                                .map(|m| Provided(m)).collect();\n+                                .map(|m| ProvidedMethod(m)).collect();\n                             methods.move_iter()\n                         }\n                 };"}, {"sha": "f272f7e18872386ff94e669e9cc65d6075397bf3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -13,7 +13,7 @@\n use abi;\n use ast::{BareFnTy, ClosureTy};\n use ast::{StaticRegionTyParamBound, OtherRegionTyParamBound, TraitTyParamBound};\n-use ast::{Provided, Public, FnStyle};\n+use ast::{ProvidedMethod, Public, FnStyle};\n use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindByRef, BindByValue};\n use ast::{BiBitAnd, BiBitOr, BiBitXor, Block};\n use ast::{BlockCheckMode, UnBox};\n@@ -33,23 +33,24 @@ use ast::{ExprVstoreUniq, Once, Many};\n use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n use ast::{FnOnceUnboxedClosureKind};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod};\n-use ast::{Ident, NormalFn, Inherited, Item, Item_, ItemStatic};\n+use ast::{Ident, NormalFn, Inherited, ImplItem, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl};\n use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy, Lit, Lit_};\n use ast::{LitBool, LitChar, LitByte, LitBinary};\n use ast::{LitNil, LitStr, LitInt, Local, LocalLet};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, Matcher, MatchNonterminal};\n use ast::{MatchSeq, MatchTok, Method, MutTy, BiMul, Mutability};\n+use ast::{MethodImplItem};\n use ast::{NamedField, UnNeg, NoReturn, UnNot, P, Pat, PatEnum};\n use ast::{PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n-use ast::{BiRem, Required};\n+use ast::{BiRem, RequiredMethod};\n use ast::{RetStyle, Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n use ast::{StructVariantKind, BiSub};\n use ast::StrStyle;\n use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n-use ast::{TokenTree, TraitMethod, TraitRef, TTDelim, TTSeq, TTTok};\n+use ast::{TokenTree, TraitItem, TraitRef, TTDelim, TTSeq, TTTok};\n use ast::{TTNonterminal, TupleVariantKind, Ty, Ty_, TyBot, TyBox};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n@@ -1238,7 +1239,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the methods in a trait declaration\n-    pub fn parse_trait_methods(&mut self) -> Vec<TraitMethod> {\n+    pub fn parse_trait_methods(&mut self) -> Vec<TraitItem> {\n         self.parse_unspanned_seq(\n             &token::LBRACE,\n             &token::RBRACE,\n@@ -1276,7 +1277,7 @@ impl<'a> Parser<'a> {\n               token::SEMI => {\n                 p.bump();\n                 debug!(\"parse_trait_methods(): parsing required method\");\n-                Required(TypeMethod {\n+                RequiredMethod(TypeMethod {\n                     ident: ident,\n                     attrs: attrs,\n                     fn_style: style,\n@@ -1294,7 +1295,7 @@ impl<'a> Parser<'a> {\n                 let (inner_attrs, body) =\n                     p.parse_inner_attrs_and_block();\n                 let attrs = attrs.append(inner_attrs.as_slice());\n-                Provided(box(GC) ast::Method {\n+                ProvidedMethod(box(GC) ast::Method {\n                     attrs: attrs,\n                     id: ast::DUMMY_NODE_ID,\n                     span: mk_sp(lo, hi),\n@@ -4243,6 +4244,18 @@ impl<'a> Parser<'a> {\n         (ident, ItemTrait(tps, sized, traits, meths), None)\n     }\n \n+    fn parse_impl_items(&mut self) -> (Vec<ImplItem>, Vec<Attribute>) {\n+        let mut impl_items = Vec::new();\n+        self.expect(&token::LBRACE);\n+        let (inner_attrs, next) = self.parse_inner_attrs_and_next();\n+        let mut method_attrs = Some(next);\n+        while !self.eat(&token::RBRACE) {\n+            impl_items.push(MethodImplItem(self.parse_method(method_attrs)));\n+            method_attrs = None;\n+        }\n+        (impl_items, inner_attrs)\n+    }\n+\n     /// Parses two variants (with the region/type params always optional):\n     ///    impl<T> Foo { ... }\n     ///    impl<T> ToString for ~[T] { ... }\n@@ -4284,18 +4297,13 @@ impl<'a> Parser<'a> {\n             None\n         };\n \n-        let mut meths = Vec::new();\n-        self.expect(&token::LBRACE);\n-        let (inner_attrs, next) = self.parse_inner_attrs_and_next();\n-        let mut method_attrs = Some(next);\n-        while !self.eat(&token::RBRACE) {\n-            meths.push(self.parse_method(method_attrs));\n-            method_attrs = None;\n-        }\n+        let (impl_items, attrs) = self.parse_impl_items();\n \n         let ident = ast_util::impl_pretty_name(&opt_trait, &*ty);\n \n-        (ident, ItemImpl(generics, opt_trait, ty, meths), Some(inner_attrs))\n+        (ident,\n+         ItemImpl(generics, opt_trait, ty, impl_items),\n+         Some(attrs))\n     }\n \n     /// Parse a::B<String,int>"}, {"sha": "c573cc0c0adec9832a7f480dc6c7fe2ce1908ba6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -10,9 +10,9 @@\n \n use abi;\n use ast::{FnMutUnboxedClosureKind, FnOnceUnboxedClosureKind};\n-use ast::{FnUnboxedClosureKind, P, OtherRegionTyParamBound};\n+use ast::{FnUnboxedClosureKind, MethodImplItem, P, OtherRegionTyParamBound};\n use ast::{StaticRegionTyParamBound, TraitTyParamBound, UnboxedClosureKind};\n-use ast::{UnboxedFnTyParamBound, Required, Provided};\n+use ast::{UnboxedFnTyParamBound, RequiredMethod, ProvidedMethod};\n use ast;\n use ast_util;\n use owned_slice::OwnedSlice;\n@@ -787,7 +787,10 @@ impl<'a> State<'a> {\n                                        item.span));\n             }\n \n-            ast::ItemImpl(ref generics, ref opt_trait, ref ty, ref methods) => {\n+            ast::ItemImpl(ref generics,\n+                          ref opt_trait,\n+                          ref ty,\n+                          ref impl_items) => {\n                 try!(self.head(visibility_qualified(item.vis,\n                                                     \"impl\").as_slice()));\n                 if generics.is_parameterized() {\n@@ -809,8 +812,12 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n                 try!(self.print_inner_attributes(item.attrs.as_slice()));\n-                for meth in methods.iter() {\n-                    try!(self.print_method(&**meth));\n+                for impl_item in impl_items.iter() {\n+                    match *impl_item {\n+                        ast::MethodImplItem(meth) => {\n+                            try!(self.print_method(&*meth));\n+                        }\n+                    }\n                 }\n                 try!(self.bclose(item.span));\n             }\n@@ -1061,10 +1068,16 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_trait_method(&mut self,\n-                              m: &ast::TraitMethod) -> IoResult<()> {\n+                              m: &ast::TraitItem) -> IoResult<()> {\n         match *m {\n-            Required(ref ty_m) => self.print_ty_method(ty_m),\n-            Provided(ref m) => self.print_method(&**m)\n+            RequiredMethod(ref ty_m) => self.print_ty_method(ty_m),\n+            ProvidedMethod(ref m) => self.print_method(&**m)\n+        }\n+    }\n+\n+    pub fn print_impl_item(&mut self, ii: &ast::ImplItem) -> IoResult<()> {\n+        match *ii {\n+            MethodImplItem(ref m) => self.print_method(&**m),\n         }\n     }\n "}, {"sha": "18cbf797d03c441f91de5e47119c43f7d5651c79", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9907fa4acc2af5b2b07d1362b3ceb29171954c58/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9907fa4acc2af5b2b07d1362b3ceb29171954c58", "patch": "@@ -99,7 +99,7 @@ pub trait Visitor<E: Clone> {\n         walk_fn(self, fk, fd, b, s, e)\n     }\n     fn visit_ty_method(&mut self, t: &TypeMethod, e: E) { walk_ty_method(self, t, e) }\n-    fn visit_trait_method(&mut self, t: &TraitMethod, e: E) { walk_trait_method(self, t, e) }\n+    fn visit_trait_item(&mut self, t: &TraitItem, e: E) { walk_trait_item(self, t, e) }\n     fn visit_struct_def(&mut self, s: &StructDef, _: Ident, _: &Generics, _: NodeId, e: E) {\n         walk_struct_def(self, s, e)\n     }\n@@ -148,7 +148,16 @@ pub fn walk_inlined_item<E: Clone, V: Visitor<E>>(visitor: &mut V,\n     match *item {\n         IIItem(i) => visitor.visit_item(&*i, env),\n         IIForeign(i) => visitor.visit_foreign_item(&*i, env),\n-        IIMethod(_, _, m) => walk_method_helper(visitor, &*m, env),\n+        IITraitItem(_, iti) => {\n+            match iti {\n+                ProvidedInlinedTraitItem(m) => {\n+                    walk_method_helper(visitor, &*m, env)\n+                }\n+                RequiredInlinedTraitItem(m) => {\n+                    walk_method_helper(visitor, &*m, env)\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -269,16 +278,20 @@ pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E)\n         ItemImpl(ref type_parameters,\n                  ref trait_reference,\n                  typ,\n-                 ref methods) => {\n+                 ref impl_items) => {\n             visitor.visit_generics(type_parameters, env.clone());\n             match *trait_reference {\n                 Some(ref trait_reference) => walk_trait_ref_helper(visitor,\n                                                                    trait_reference, env.clone()),\n                 None => ()\n             }\n             visitor.visit_ty(&*typ, env.clone());\n-            for method in methods.iter() {\n-                walk_method_helper(visitor, &**method, env.clone())\n+            for impl_item in impl_items.iter() {\n+                match *impl_item {\n+                    MethodImplItem(method) => {\n+                        walk_method_helper(visitor, &*method, env.clone())\n+                    }\n+                }\n             }\n         }\n         ItemStruct(ref struct_definition, ref generics) => {\n@@ -297,7 +310,7 @@ pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E)\n                                    env.clone())\n             }\n             for method in methods.iter() {\n-                visitor.visit_trait_method(method, env.clone())\n+                visitor.visit_trait_item(method, env.clone())\n             }\n         }\n         ItemMac(ref macro) => visitor.visit_mac(macro, env.clone()),\n@@ -626,14 +639,14 @@ pub fn walk_ty_method<E: Clone, V: Visitor<E>>(visitor: &mut V,\n     }\n }\n \n-pub fn walk_trait_method<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                                  trait_method: &TraitMethod,\n+pub fn walk_trait_item<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                                  trait_method: &TraitItem,\n                                                   env: E) {\n     match *trait_method {\n-        Required(ref method_type) => {\n+        RequiredMethod(ref method_type) => {\n             visitor.visit_ty_method(method_type, env)\n         }\n-        Provided(ref method) => walk_method_helper(visitor, &**method, env),\n+        ProvidedMethod(ref method) => walk_method_helper(visitor, &**method, env),\n     }\n }\n "}]}