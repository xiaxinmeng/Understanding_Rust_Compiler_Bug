{"sha": "3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYjc4ZTI5ZjRhZTliM2U1YmIxOWJmNWE3NDAzNzVlOTBiMDFjZWI=", "commit": {"author": {"name": "nham", "email": "hamann.nick@gmail.com", "date": "2014-08-06T06:02:50Z"}, "committer": {"name": "nham", "email": "hamann.nick@gmail.com", "date": "2014-08-06T06:02:50Z"}, "message": "Use byte literals in libstd", "tree": {"sha": "b4dcb4ce0e5f25a5f92c5a99f44d6ade5243144a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4dcb4ce0e5f25a5f92c5a99f44d6ade5243144a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "html_url": "https://github.com/rust-lang/rust/commit/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/comments", "author": {"login": "nham", "id": 546409, "node_id": "MDQ6VXNlcjU0NjQwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/546409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nham", "html_url": "https://github.com/nham", "followers_url": "https://api.github.com/users/nham/followers", "following_url": "https://api.github.com/users/nham/following{/other_user}", "gists_url": "https://api.github.com/users/nham/gists{/gist_id}", "starred_url": "https://api.github.com/users/nham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nham/subscriptions", "organizations_url": "https://api.github.com/users/nham/orgs", "repos_url": "https://api.github.com/users/nham/repos", "events_url": "https://api.github.com/users/nham/events{/privacy}", "received_events_url": "https://api.github.com/users/nham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nham", "id": 546409, "node_id": "MDQ6VXNlcjU0NjQwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/546409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nham", "html_url": "https://github.com/nham", "followers_url": "https://api.github.com/users/nham/followers", "following_url": "https://api.github.com/users/nham/following{/other_user}", "gists_url": "https://api.github.com/users/nham/gists{/gist_id}", "starred_url": "https://api.github.com/users/nham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nham/subscriptions", "organizations_url": "https://api.github.com/users/nham/orgs", "repos_url": "https://api.github.com/users/nham/repos", "events_url": "https://api.github.com/users/nham/events{/privacy}", "received_events_url": "https://api.github.com/users/nham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfdea3f116ea028b347ca5b73dc462a6d48d9940", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfdea3f116ea028b347ca5b73dc462a6d48d9940", "html_url": "https://github.com/rust-lang/rust/commit/dfdea3f116ea028b347ca5b73dc462a6d48d9940"}], "stats": {"total": 106, "additions": 52, "deletions": 54}, "files": [{"sha": "e8352dcd40cdc29fcfc9099e4706990de89c85dd", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "patch": "@@ -119,7 +119,7 @@ impl Ascii {\n     /// Check if the character is a space or horizontal tab\n     #[inline]\n     pub fn is_blank(&self) -> bool {\n-        self.chr == ' ' as u8 || self.chr == '\\t' as u8\n+        self.chr == b' ' || self.chr == b'\\t'\n     }\n \n     /// Check if the character is a control character\n@@ -150,7 +150,7 @@ impl Ascii {\n     /// Checks if the character is lowercase\n     #[inline]\n     pub fn is_lowercase(&self) -> bool {\n-        (self.chr - 'a' as u8) < 26\n+        (self.chr - b'a') < 26\n     }\n \n     #[inline]\n@@ -163,7 +163,7 @@ impl Ascii {\n     /// Checks if the character is uppercase\n     #[inline]\n     pub fn is_uppercase(&self) -> bool {\n-        (self.chr - 'A' as u8) < 26\n+        (self.chr - b'A') < 26\n     }\n \n     /// Checks if the character is punctuation\n@@ -175,7 +175,7 @@ impl Ascii {\n     /// Checks if the character is a valid hex digit\n     #[inline]\n     pub fn is_hex(&self) -> bool {\n-        self.is_digit() || ((self.chr | 32u8) - 'a' as u8) < 6\n+        self.is_digit() || ((self.chr | 32u8) - b'a') < 6\n     }\n }\n \n@@ -792,13 +792,13 @@ mod tests {\n \n     #[test]\n     fn test_to_string() {\n-        let s = Ascii{ chr: 't' as u8 }.to_string();\n+        let s = Ascii{ chr: b't' }.to_string();\n         assert_eq!(s, \"t\".to_string());\n     }\n \n     #[test]\n     fn test_show() {\n-        let c = Ascii { chr: 't' as u8 };\n+        let c = Ascii { chr: b't' };\n         assert_eq!(format!(\"{}\", c), \"t\".to_string());\n     }\n }"}, {"sha": "1ac37458e2493acd1b6f0f95b274187933d7a227", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "patch": "@@ -114,7 +114,7 @@ impl DynamicLibrary {\n     }\n \n     fn separator() -> u8 {\n-        if cfg!(windows) {';' as u8} else {':' as u8}\n+        if cfg!(windows) {b';'} else {b':'}\n     }\n \n     /// Returns the current search path for dynamic libraries being used by this"}, {"sha": "71ec524211824dcad77dc4d52f01ce1a293d5be8", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "patch": "@@ -248,7 +248,7 @@ impl<W: Writer> LineBufferedWriter<W> {\n \n impl<W: Writer> Writer for LineBufferedWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        match buf.iter().rposition(|&b| b == '\\n' as u8) {\n+        match buf.iter().rposition(|&b| b == b'\\n') {\n             Some(i) => {\n                 try!(self.inner.write(buf.slice_to(i + 1)));\n                 try!(self.inner.flush());\n@@ -524,15 +524,15 @@ mod test {\n         assert_eq!(writer.get_ref().get_ref(), &[]);\n         writer.flush().unwrap();\n         assert_eq!(writer.get_ref().get_ref(), &[0, 1]);\n-        writer.write([0, '\\n' as u8, 1, '\\n' as u8, 2]).unwrap();\n+        writer.write([0, b'\\n', 1, b'\\n', 2]).unwrap();\n         assert_eq!(writer.get_ref().get_ref(),\n-                   &[0, 1, 0, '\\n' as u8, 1, '\\n' as u8]);\n+                   &[0, 1, 0, b'\\n', 1, b'\\n']);\n         writer.flush().unwrap();\n         assert_eq!(writer.get_ref().get_ref(),\n-                   &[0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2]);\n-        writer.write([3, '\\n' as u8]).unwrap();\n+                   &[0, 1, 0, b'\\n', 1, b'\\n', 2]);\n+        writer.write([3, b'\\n']).unwrap();\n         assert_eq!(writer.get_ref().get_ref(),\n-            &[0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2, 3, '\\n' as u8]);\n+            &[0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n']);\n     }\n \n     #[test]\n@@ -579,7 +579,7 @@ mod test {\n \n     #[test]\n     fn test_chars() {\n-        let buf = [195u8, 159u8, 'a' as u8];\n+        let buf = [195u8, 159u8, b'a'];\n         let mut reader = BufferedReader::with_capacity(1, BufReader::new(buf));\n         let mut it = reader.chars();\n         assert_eq!(it.next(), Some(Ok('\u00df')));"}, {"sha": "6a4172d5c3526fd195ecafb4292bda2d15bdc39d", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "patch": "@@ -1241,8 +1241,8 @@ mod test {\n         let mut cur = [0u8, .. 2];\n         for f in files {\n             let stem = f.filestem_str().unwrap();\n-            let root = stem.as_bytes()[0] - ('0' as u8);\n-            let name = stem.as_bytes()[1] - ('0' as u8);\n+            let root = stem.as_bytes()[0] - b'0';\n+            let name = stem.as_bytes()[1] - b'0';\n             assert!(cur[root as uint] < name);\n             cur[root as uint] = name;\n         }"}, {"sha": "d098f9a6479146016bfab81ee7d1c53e82580ca2", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "patch": "@@ -1103,7 +1103,7 @@ pub trait Writer {\n     /// that the `write` method is used specifically instead.\n     #[inline]\n     fn write_line(&mut self, s: &str) -> IoResult<()> {\n-        self.write_str(s).and_then(|()| self.write(['\\n' as u8]))\n+        self.write_str(s).and_then(|()| self.write([b'\\n']))\n     }\n \n     /// Write a single char, encoded as UTF-8.\n@@ -1442,7 +1442,7 @@ pub trait Buffer: Reader {\n     /// Additionally, this function can fail if the line of input read is not a\n     /// valid UTF-8 sequence of bytes.\n     fn read_line(&mut self) -> IoResult<String> {\n-        self.read_until('\\n' as u8).and_then(|line|\n+        self.read_until(b'\\n').and_then(|line|\n             match String::from_utf8(line) {\n                 Ok(s)  => Ok(s),\n                 Err(_) => Err(standard_error(InvalidInput)),"}, {"sha": "0f864c7be5e274e5a1b754e74bea8e5b6e8d1267", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "patch": "@@ -161,12 +161,12 @@ impl<'a> Parser<'a> {\n         fn parse_digit(c: char, radix: u8) -> Option<u8> {\n             let c = c as u8;\n             // assuming radix is either 10 or 16\n-            if c >= '0' as u8 && c <= '9' as u8 {\n-                Some(c - '0' as u8)\n-            } else if radix > 10 && c >= 'a' as u8 && c < 'a' as u8 + (radix - 10) {\n-                Some(c - 'a' as u8 + 10)\n-            } else if radix > 10 && c >= 'A' as u8 && c < 'A' as u8 + (radix - 10) {\n-                Some(c - 'A' as u8 + 10)\n+            if c >= b'0' && c <= b'9' {\n+                Some(c - b'0')\n+            } else if radix > 10 && c >= b'a' && c < b'a' + (radix - 10) {\n+                Some(c - b'a' + 10)\n+            } else if radix > 10 && c >= b'A' && c < b'A' + (radix - 10) {\n+                Some(c - b'A' + 10)\n             } else {\n                 None\n             }"}, {"sha": "e0201b650716a5304a2203509d0746e67fd6d8ef", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "patch": "@@ -239,7 +239,7 @@ pub fn print(s: &str) {\n /// `\\n` character is printed to the console after the string.\n pub fn println(s: &str) {\n     with_task_stdout(|io| {\n-        io.write(s.as_bytes()).and_then(|()| io.write(['\\n' as u8]))\n+        io.write(s.as_bytes()).and_then(|()| io.write([b'\\n']))\n     })\n }\n "}, {"sha": "3184c151bd2c74e9c138344a5da481862f133d6a", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "patch": "@@ -502,7 +502,7 @@ pub mod builtin {\n     ///\n     /// ```\n     /// let rust = bytes!(\"r\", 'u', \"st\", 255);\n-    /// assert_eq!(rust[1], 'u' as u8);\n+    /// assert_eq!(rust[1], b'u');\n     /// assert_eq!(rust[4], 255);\n     /// ```\n     #[macro_export]"}, {"sha": "37378518dc8e123b98688ab042bb73734dd94462", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "patch": "@@ -138,12 +138,10 @@ impl_NumStrConv_Integer!(u64)\n \n \n // Special value strings as [u8] consts.\n-static INF_BUF:          [u8, ..3] = ['i' as u8, 'n' as u8, 'f' as u8];\n-static POS_INF_BUF: [u8, ..4] = ['+' as u8, 'i' as u8, 'n' as u8,\n-                                      'f' as u8];\n-static NEG_INF_BUF: [u8, ..4] = ['-' as u8, 'i' as u8, 'n' as u8,\n-                                      'f' as u8];\n-static NAN_BUF:          [u8, ..3] = ['N' as u8, 'a' as u8, 'N' as u8];\n+static INF_BUF:     [u8, ..3] = [b'i', b'n', b'f'];\n+static POS_INF_BUF: [u8, ..4] = [b'+', b'i', b'n', b'f'];\n+static NEG_INF_BUF: [u8, ..4] = [b'-', b'i', b'n', b'f'];\n+static NAN_BUF:     [u8, ..3] = [b'N', b'a', b'N'];\n \n /**\n  * Converts an integral number to its string representation as a byte vector.\n@@ -201,8 +199,8 @@ pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f:\n             current_digit_signed\n         };\n         buf[cur] = match current_digit.to_u8().unwrap() {\n-            i @ 0..9 => '0' as u8 + i,\n-            i        => 'a' as u8 + (i - 10),\n+            i @ 0..9 => b'0' + i,\n+            i        => b'a' + (i - 10),\n         };\n         cur += 1;\n \n@@ -213,8 +211,8 @@ pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f:\n \n     // Decide what sign to put in front\n     match sign {\n-        SignNeg | SignAll if neg => { f('-' as u8); }\n-        SignAll => { f('+' as u8); }\n+        SignNeg | SignAll if neg => { f(b'-'); }\n+        SignAll => { f(b'+'); }\n         _ => ()\n     }\n \n@@ -350,10 +348,10 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n     // Decide what sign to put in front\n     match sign {\n         SignNeg | SignAll if neg => {\n-            buf.push('-' as u8);\n+            buf.push(b'-');\n         }\n         SignAll => {\n-            buf.push('+' as u8);\n+            buf.push(b'+');\n         }\n         _ => ()\n     }\n@@ -368,7 +366,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n     // Now emit the fractional part, if any\n     deccum = num.fract();\n     if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n-        buf.push('.' as u8);\n+        buf.push(b'.');\n         let mut dig = 0u;\n \n         // calculate new digits while\n@@ -415,14 +413,14 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n                     // If reached left end of number, have to\n                     // insert additional digit:\n                     if i < 0\n-                    || *buf.get(i as uint) == '-' as u8\n-                    || *buf.get(i as uint) == '+' as u8 {\n+                    || *buf.get(i as uint) == b'-'\n+                    || *buf.get(i as uint) == b'+' {\n                         buf.insert((i + 1) as uint, value2ascii(1));\n                         break;\n                     }\n \n                     // Skip the '.'\n-                    if *buf.get(i as uint) == '.' as u8 { i -= 1; continue; }\n+                    if *buf.get(i as uint) == b'.' { i -= 1; continue; }\n \n                     // Either increment the digit,\n                     // or set to 0 if max and carry the 1.\n@@ -448,14 +446,14 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n         let mut i = buf_max_i;\n \n         // discover trailing zeros of fractional part\n-        while i > start_fractional_digits && *buf.get(i) == '0' as u8 {\n+        while i > start_fractional_digits && *buf.get(i) == b'0' {\n             i -= 1;\n         }\n \n         // Only attempt to truncate digits if buf has fractional digits\n         if i >= start_fractional_digits {\n             // If buf ends with '.', cut that too.\n-            if *buf.get(i) == '.' as u8 { i -= 1 }\n+            if *buf.get(i) == b'.' { i -= 1 }\n \n             // only resize buf if we actually remove digits\n             if i < buf_max_i {\n@@ -465,7 +463,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n     } // If exact and trailing '.', just cut that\n     else {\n         let max_i = buf.len() - 1;\n-        if *buf.get(max_i) == '.' as u8 {\n+        if *buf.get(max_i) == b'.' {\n             buf = Vec::from_slice(buf.slice(0, max_i));\n         }\n     }"}, {"sha": "a28d2ba9d5c7e43edd478ba51f28f364a991941a", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "patch": "@@ -293,7 +293,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n         fn env_convert(input: Vec<Vec<u8>>) -> Vec<(Vec<u8>, Vec<u8>)> {\n             let mut pairs = Vec::new();\n             for p in input.iter() {\n-                let mut it = p.as_slice().splitn(1, |b| *b == '=' as u8);\n+                let mut it = p.as_slice().splitn(1, |b| *b == b'=');\n                 let key = Vec::from_slice(it.next().unwrap());\n                 let val = Vec::from_slice(it.next().unwrap_or(&[]));\n                 pairs.push((key, val));"}, {"sha": "d290a5f8c63c758d12113b5ddf923e844f118838", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "patch": "@@ -351,7 +351,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         match self.filename() {\n             None => None,\n             Some(name) => Some({\n-                let dot = '.' as u8;\n+                let dot = b'.';\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => name,\n                     Some(1) if name == b\"..\" => name,\n@@ -398,7 +398,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         match self.filename() {\n             None => None,\n             Some(name) => {\n-                let dot = '.' as u8;\n+                let dot = b'.';\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => None,\n                     Some(1) if name == b\"..\" => None,\n@@ -474,7 +474,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         assert!(!contains_nul(&extension));\n \n         let val = self.filename().and_then(|name| {\n-            let dot = '.' as u8;\n+            let dot = b'.';\n             let extlen = extension.container_as_bytes().len();\n             match (name.rposition_elem(&dot), extlen) {\n                 (None, 0) | (Some(0), 0) => None,"}, {"sha": "9a4bc11f5c03a8fd78eef3204c11e497d8937561", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "patch": "@@ -237,7 +237,7 @@ impl GenericPath for Path {\n         match self.sepidx {\n             None if b\".\" == self.repr.as_slice() => false,\n             None => {\n-                self.repr = vec!['.' as u8];\n+                self.repr = vec![b'.'];\n                 self.sepidx = None;\n                 true\n             }"}, {"sha": "c3a217bf940f3a3b716b0e4cb6f89f3a4d103fb3", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=3fb78e29f4ae9b3e5bb19bf5a740375e90b01ceb", "patch": "@@ -737,12 +737,12 @@ impl Path {\n             let mut comps = comps;\n             match (comps.is_some(),prefix) {\n                 (false, Some(DiskPrefix)) => {\n-                    if s.as_bytes()[0] >= 'a' as u8 && s.as_bytes()[0] <= 'z' as u8 {\n+                    if s.as_bytes()[0] >= b'a' && s.as_bytes()[0] <= b'z' {\n                         comps = Some(vec![]);\n                     }\n                 }\n                 (false, Some(VerbatimDiskPrefix)) => {\n-                    if s.as_bytes()[4] >= 'a' as u8 && s.as_bytes()[0] <= 'z' as u8 {\n+                    if s.as_bytes()[4] >= b'a' && s.as_bytes()[0] <= b'z' {\n                         comps = Some(vec![]);\n                     }\n                 }\n@@ -1010,7 +1010,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n             } else {\n                 // \\\\?\\path\n                 let idx = path.find('\\\\');\n-                if idx == Some(2) && path.as_bytes()[1] == ':' as u8 {\n+                if idx == Some(2) && path.as_bytes()[1] == b':' {\n                     let c = path.as_bytes()[0];\n                     if c.is_ascii() && (c as char).is_alphabetic() {\n                         // \\\\?\\C:\\ path\n@@ -1033,7 +1033,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n             }\n             _ => ()\n         }\n-    } else if path.len() > 1 && path.as_bytes()[1] == ':' as u8 {\n+    } else if path.len() > 1 && path.as_bytes()[1] == b':' {\n         // C:\n         let c = path.as_bytes()[0];\n         if c.is_ascii() && (c as char).is_alphabetic() {"}]}