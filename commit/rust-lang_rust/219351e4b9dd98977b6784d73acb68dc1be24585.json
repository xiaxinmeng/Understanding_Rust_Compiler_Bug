{"sha": "219351e4b9dd98977b6784d73acb68dc1be24585", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxOTM1MWU0YjlkZDk4OTc3YjY3ODRkNzNhY2I2OGRjMWJlMjQ1ODU=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-05-20T01:36:40Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-05-20T23:51:08Z"}, "message": "A little closure towards translating spawn. We're about ready to do the upcall, except that rustc segfaults.", "tree": {"sha": "3405568fbc4c4f8d526c19b4fcb1afffafeeb3f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3405568fbc4c4f8d526c19b4fcb1afffafeeb3f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/219351e4b9dd98977b6784d73acb68dc1be24585", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/219351e4b9dd98977b6784d73acb68dc1be24585", "html_url": "https://github.com/rust-lang/rust/commit/219351e4b9dd98977b6784d73acb68dc1be24585", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/219351e4b9dd98977b6784d73acb68dc1be24585/comments", "author": null, "committer": null, "parents": [{"sha": "d6338a8c1563fe7d7a9a1ea3de0692eb0e2560ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6338a8c1563fe7d7a9a1ea3de0692eb0e2560ac", "html_url": "https://github.com/rust-lang/rust/commit/d6338a8c1563fe7d7a9a1ea3de0692eb0e2560ac"}], "stats": {"total": 51, "additions": 47, "deletions": 4}, "files": [{"sha": "054e6114a71718e3d378e1a4b1e28fac91b0ecbc", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/219351e4b9dd98977b6784d73acb68dc1be24585/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219351e4b9dd98977b6784d73acb68dc1be24585/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=219351e4b9dd98977b6784d73acb68dc1be24585", "patch": "@@ -5544,7 +5544,7 @@ fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n         }\n \n         case (ast::expr_spawn(?dom, ?name, ?func, ?args, ?ann)) {\n-            ret trans_spawn(dom, name, func, args, ann);\n+            ret trans_spawn(cx, dom, name, func, args, ann);\n         }\n \n         case (_) {\n@@ -5883,9 +5883,12 @@ fn trans_chan(&@block_ctxt cx, &@ast::expr e, &ast::ann ann) -> result {\n     ret res(bcx, chan_val);\n }\n \n-fn trans_spawn(&ast::spawn_dom dom, &option::t[str] name,\n+fn trans_spawn(&@block_ctxt cx,\n+               &ast::spawn_dom dom, &option::t[str] name,\n                &@ast::expr func, &vec[@ast::expr] args, \n                &ast::ann ann) -> result {\n+    auto bcx = cx;\n+\n     // Make the task name\n     auto tname = alt(name) {\n         case(none) {\n@@ -5913,22 +5916,62 @@ fn trans_spawn(&ast::spawn_dom dom, &option::t[str] name,\n     // 2. Alloca a tuple that holds these arguments (they must be in reverse\n     // order, so that they match the expected stack layout for the spawnee)\n     //\n-    // 3. Fill the tutple with the arguments we evaluated.\n+    // 3. Fill the tuple with the arguments we evaluated.\n     // \n     // 4. Pass a pointer to the spawnee function and the argument tuple to\n     // upcall_start_task.\n     \n+    // Translate the arguments, remembering their types and where the values\n+    // ended up.\n+    let vec[ty::t] arg_tys = [];\n+    let vec[ValueRef] arg_vals = [];\n+    for(@ast::expr e in args) {\n+        auto arg = trans_expr(bcx, e);\n+        \n+        bcx = arg.bcx;\n+\n+        vec::push[ValueRef](arg_vals, arg.val);\n+        vec::push[ty::t](arg_tys,\n+                         ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n+                                     e));\n+    }\n+\n+    // Make the tuple. We have to reverse the types first though.\n+    vec::reverse[ty::t](arg_tys);\n+    vec::reverse[ValueRef](arg_vals);\n+    auto args_ty = ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx, arg_tys);\n     \n+    // Allocate and fill the tuple.\n+    auto llargs = alloc_ty(bcx, args_ty);\n+\n+    auto i = vec::len[ValueRef](arg_vals) - 1u;\n+    for(ValueRef v in arg_vals) {\n+        // log_err #fmt(\"ty(llargs) = %s\", \n+        //              val_str(bcx.fcx.lcx.ccx.tn, llargs.val));\n+        auto target = bcx.build.GEP(llargs.val, [C_int(0), C_int(i as int)]);\n+        \n+        // log_err #fmt(\"ty(v) = %s\", val_str(bcx.fcx.lcx.ccx.tn, v));\n+        // log_err #fmt(\"ty(target) = %s\", \n+        //              val_str(bcx.fcx.lcx.ccx.tn, target));\n+\n+        bcx.build.Store(v, target);\n+\n+        i -= 1u;\n+    }\n+\n+    // Now we're ready to do the upcall.\n+\n     alt(dom) {\n         case(ast::dom_implicit) {\n             // TODO\n             log_err \"Spawning implicit domain tasks is not implemented.\";\n-            fail;\n+            //fail;\n         }\n \n         case(ast::dom_thread) {\n             // TODO\n             log_err \"Spawining new thread tasks is not implemented.\";\n+            // TODO: for now use the normal unimpl thing.\n             fail;\n         }\n     }"}]}