{"sha": "142c831861ba5a995fd9de99198e7f6074b6b400", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MmM4MzE4NjFiYTVhOTk1ZmQ5ZGU5OTE5OGU3ZjYwNzRiNmI0MDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-22T04:03:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-22T04:03:53Z"}, "message": "Auto merge of #83360 - Dylan-DPC:rollup-17xulpv, r=Dylan-DPC\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #80193 (stabilize `feature(osstring_ascii)`)\n - #80771 (Make NonNull::as_ref (and friends) return refs with unbound lifetimes)\n - #81607 (Implement TrustedLen and TrustedRandomAccess for Range<integer>, array::IntoIter, VecDequeue's iterators)\n - #82554 (Fix invalid slice access in String::retain)\n - #82686 (Move `std::sys::unix::platform` to `std::sys::unix::ext`)\n - #82771 (slice: Stabilize IterMut::as_slice.)\n - #83329 (Cleanup LLVM debuginfo module docs)\n - #83336 (Fix ICE with `use clippy::a::b;`)\n - #83350 (Download a more recent LLVM version if `src/version` is modified)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "3a43c288d544f23fb39cc4f42834bea8170ebc0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a43c288d544f23fb39cc4f42834bea8170ebc0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/142c831861ba5a995fd9de99198e7f6074b6b400", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/142c831861ba5a995fd9de99198e7f6074b6b400", "html_url": "https://github.com/rust-lang/rust/commit/142c831861ba5a995fd9de99198e7f6074b6b400", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/142c831861ba5a995fd9de99198e7f6074b6b400/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35385770ae1ea86a911cc44ac43f856831e44b26", "url": "https://api.github.com/repos/rust-lang/rust/commits/35385770ae1ea86a911cc44ac43f856831e44b26", "html_url": "https://github.com/rust-lang/rust/commit/35385770ae1ea86a911cc44ac43f856831e44b26"}, {"sha": "790c2ad46ac5d29903d75125679b7604dcc206fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/790c2ad46ac5d29903d75125679b7604dcc206fe", "html_url": "https://github.com/rust-lang/rust/commit/790c2ad46ac5d29903d75125679b7604dcc206fe"}], "stats": {"total": 709, "additions": 447, "deletions": 262}, "files": [{"sha": "f983d09203904dd1c439139230db9671f855722f", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/doc.md", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -0,0 +1,180 @@\n+# Debug Info Module\n+\n+This module serves the purpose of generating debug symbols. We use LLVM's\n+[source level debugging](https://llvm.org/docs/SourceLevelDebugging.html)\n+features for generating the debug information. The general principle is\n+this:\n+\n+Given the right metadata in the LLVM IR, the LLVM code generator is able to\n+create DWARF debug symbols for the given code. The\n+[metadata](https://llvm.org/docs/LangRef.html#metadata-type) is structured\n+much like DWARF *debugging information entries* (DIE), representing type\n+information such as datatype layout, function signatures, block layout,\n+variable location and scope information, etc. It is the purpose of this\n+module to generate correct metadata and insert it into the LLVM IR.\n+\n+As the exact format of metadata trees may change between different LLVM\n+versions, we now use LLVM\n+[DIBuilder](https://llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n+to create metadata where possible. This will hopefully ease the adaption of\n+this module to future LLVM versions.\n+\n+The public API of the module is a set of functions that will insert the\n+correct metadata into the LLVM IR when called with the right parameters.\n+The module is thus driven from an outside client with functions like\n+`debuginfo::create_local_var_metadata(bx: block, local: &ast::local)`.\n+\n+Internally the module will try to reuse already created metadata by\n+utilizing a cache. The way to get a shared metadata node when needed is\n+thus to just call the corresponding function in this module:\n+\n+    let file_metadata = file_metadata(cx, file);\n+\n+The function will take care of probing the cache for an existing node for\n+that exact file path.\n+\n+All private state used by the module is stored within either the\n+CrateDebugContext struct (owned by the CodegenCx) or the\n+FunctionDebugContext (owned by the FunctionCx).\n+\n+This file consists of three conceptual sections:\n+1. The public interface of the module\n+2. Module-internal metadata creation functions\n+3. Minor utility functions\n+\n+\n+## Recursive Types\n+\n+Some kinds of types, such as structs and enums can be recursive. That means\n+that the type definition of some type X refers to some other type which in\n+turn (transitively) refers to X. This introduces cycles into the type\n+referral graph. A naive algorithm doing an on-demand, depth-first traversal\n+of this graph when describing types, can get trapped in an endless loop\n+when it reaches such a cycle.\n+\n+For example, the following simple type for a singly-linked list...\n+\n+```\n+struct List {\n+    value: i32,\n+    tail: Option<Box<List>>,\n+}\n+```\n+\n+will generate the following callstack with a naive DFS algorithm:\n+\n+```\n+describe(t = List)\n+  describe(t = i32)\n+  describe(t = Option<Box<List>>)\n+    describe(t = Box<List>)\n+      describe(t = List) // at the beginning again...\n+      ...\n+```\n+\n+To break cycles like these, we use \"forward declarations\". That is, when\n+the algorithm encounters a possibly recursive type (any struct or enum), it\n+immediately creates a type description node and inserts it into the cache\n+*before* describing the members of the type. This type description is just\n+a stub (as type members are not described and added to it yet) but it\n+allows the algorithm to already refer to the type. After the stub is\n+inserted into the cache, the algorithm continues as before. If it now\n+encounters a recursive reference, it will hit the cache and does not try to\n+describe the type anew.\n+\n+This behavior is encapsulated in the 'RecursiveTypeDescription' enum,\n+which represents a kind of continuation, storing all state needed to\n+continue traversal at the type members after the type has been registered\n+with the cache. (This implementation approach might be a tad over-\n+engineered and may change in the future)\n+\n+\n+## Source Locations and Line Information\n+\n+In addition to data type descriptions the debugging information must also\n+allow to map machine code locations back to source code locations in order\n+to be useful. This functionality is also handled in this module. The\n+following functions allow to control source mappings:\n+\n++ `set_source_location()`\n++ `clear_source_location()`\n++ `start_emitting_source_locations()`\n+\n+`set_source_location()` allows to set the current source location. All IR\n+instructions created after a call to this function will be linked to the\n+given source location, until another location is specified with\n+`set_source_location()` or the source location is cleared with\n+`clear_source_location()`. In the later case, subsequent IR instruction\n+will not be linked to any source location. As you can see, this is a\n+stateful API (mimicking the one in LLVM), so be careful with source\n+locations set by previous calls. It's probably best to not rely on any\n+specific state being present at a given point in code.\n+\n+One topic that deserves some extra attention is *function prologues*. At\n+the beginning of a function's machine code there are typically a few\n+instructions for loading argument values into allocas and checking if\n+there's enough stack space for the function to execute. This *prologue* is\n+not visible in the source code and LLVM puts a special PROLOGUE END marker\n+into the line table at the first non-prologue instruction of the function.\n+In order to find out where the prologue ends, LLVM looks for the first\n+instruction in the function body that is linked to a source location. So,\n+when generating prologue instructions we have to make sure that we don't\n+emit source location information until the 'real' function body begins. For\n+this reason, source location emission is disabled by default for any new\n+function being codegened and is only activated after a call to the third\n+function from the list above, `start_emitting_source_locations()`. This\n+function should be called right before regularly starting to codegen the\n+top-level block of the given function.\n+\n+There is one exception to the above rule: `llvm.dbg.declare` instruction\n+must be linked to the source location of the variable being declared. For\n+function parameters these `llvm.dbg.declare` instructions typically occur\n+in the middle of the prologue, however, they are ignored by LLVM's prologue\n+detection. The `create_argument_metadata()` and related functions take care\n+of linking the `llvm.dbg.declare` instructions to the correct source\n+locations even while source location emission is still disabled, so there\n+is no need to do anything special with source location handling here.\n+\n+## Unique Type Identification\n+\n+In order for link-time optimization to work properly, LLVM needs a unique\n+type identifier that tells it across compilation units which types are the\n+same as others. This type identifier is created by\n+`TypeMap::get_unique_type_id_of_type()` using the following algorithm:\n+\n+1. Primitive types have their name as ID\n+\n+2. Structs, enums and traits have a multipart identifier\n+\n+  1. The first part is the SVH (strict version hash) of the crate they\n+     were originally defined in\n+\n+  2. The second part is the ast::NodeId of the definition in their\n+     original crate\n+\n+  3. The final part is a concatenation of the type IDs of their concrete\n+     type arguments if they are generic types.\n+\n+3. Tuple-, pointer-, and function types are structurally identified, which\n+   means that they are equivalent if their component types are equivalent\n+   (i.e., `(i32, i32)` is the same regardless in which crate it is used).\n+\n+This algorithm also provides a stable ID for types that are defined in one\n+crate but instantiated from metadata within another crate. We just have to\n+take care to always map crate and `NodeId`s back to the original crate\n+context.\n+\n+As a side-effect these unique type IDs also help to solve a problem arising\n+from lifetime parameters. Since lifetime parameters are completely omitted\n+in debuginfo, more than one `Ty` instance may map to the same debuginfo\n+type metadata, that is, some struct `Struct<'a>` may have N instantiations\n+with different concrete substitutions for `'a`, and thus there will be N\n+`Ty` instances for the type `Struct<'a>` even though it is not generic\n+otherwise. Unfortunately this means that we cannot use `ty::type_id()` as\n+cheap identifier for type metadata -- we have done this in the past, but it\n+led to unnecessary metadata duplication in the best case and LLVM\n+assertions in the worst. However, the unique type ID as described above\n+*can* be used as identifier. Since it is comparatively expensive to\n+construct, though, `ty::type_id()` is still used additionally as an\n+optimization for cases where the exact same type has been seen before\n+(which is most of the time)."}, {"sha": "10dd590652949a3e54d209ea0e23a8f1ac79a6d8", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/doc.rs", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/35385770ae1ea86a911cc44ac43f856831e44b26/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35385770ae1ea86a911cc44ac43f856831e44b26/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.rs?ref=35385770ae1ea86a911cc44ac43f856831e44b26", "patch": "@@ -1,179 +0,0 @@\n-//! # Debug Info Module\n-//!\n-//! This module serves the purpose of generating debug symbols. We use LLVM's\n-//! [source level debugging](https://llvm.org/docs/SourceLevelDebugging.html)\n-//! features for generating the debug information. The general principle is\n-//! this:\n-//!\n-//! Given the right metadata in the LLVM IR, the LLVM code generator is able to\n-//! create DWARF debug symbols for the given code. The\n-//! [metadata](https://llvm.org/docs/LangRef.html#metadata-type) is structured\n-//! much like DWARF *debugging information entries* (DIE), representing type\n-//! information such as datatype layout, function signatures, block layout,\n-//! variable location and scope information, etc. It is the purpose of this\n-//! module to generate correct metadata and insert it into the LLVM IR.\n-//!\n-//! As the exact format of metadata trees may change between different LLVM\n-//! versions, we now use LLVM\n-//! [DIBuilder](https://llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n-//! to create metadata where possible. This will hopefully ease the adaption of\n-//! this module to future LLVM versions.\n-//!\n-//! The public API of the module is a set of functions that will insert the\n-//! correct metadata into the LLVM IR when called with the right parameters.\n-//! The module is thus driven from an outside client with functions like\n-//! `debuginfo::create_local_var_metadata(bx: block, local: &ast::local)`.\n-//!\n-//! Internally the module will try to reuse already created metadata by\n-//! utilizing a cache. The way to get a shared metadata node when needed is\n-//! thus to just call the corresponding function in this module:\n-//!\n-//!     let file_metadata = file_metadata(cx, file);\n-//!\n-//! The function will take care of probing the cache for an existing node for\n-//! that exact file path.\n-//!\n-//! All private state used by the module is stored within either the\n-//! CrateDebugContext struct (owned by the CodegenCx) or the\n-//! FunctionDebugContext (owned by the FunctionCx).\n-//!\n-//! This file consists of three conceptual sections:\n-//! 1. The public interface of the module\n-//! 2. Module-internal metadata creation functions\n-//! 3. Minor utility functions\n-//!\n-//!\n-//! ## Recursive Types\n-//!\n-//! Some kinds of types, such as structs and enums can be recursive. That means\n-//! that the type definition of some type X refers to some other type which in\n-//! turn (transitively) refers to X. This introduces cycles into the type\n-//! referral graph. A naive algorithm doing an on-demand, depth-first traversal\n-//! of this graph when describing types, can get trapped in an endless loop\n-//! when it reaches such a cycle.\n-//!\n-//! For example, the following simple type for a singly-linked list...\n-//!\n-//! ```\n-//! struct List {\n-//!     value: i32,\n-//!     tail: Option<Box<List>>,\n-//! }\n-//! ```\n-//!\n-//! will generate the following callstack with a naive DFS algorithm:\n-//!\n-//! ```\n-//! describe(t = List)\n-//!   describe(t = i32)\n-//!   describe(t = Option<Box<List>>)\n-//!     describe(t = Box<List>)\n-//!       describe(t = List) // at the beginning again...\n-//!       ...\n-//! ```\n-//!\n-//! To break cycles like these, we use \"forward declarations\". That is, when\n-//! the algorithm encounters a possibly recursive type (any struct or enum), it\n-//! immediately creates a type description node and inserts it into the cache\n-//! *before* describing the members of the type. This type description is just\n-//! a stub (as type members are not described and added to it yet) but it\n-//! allows the algorithm to already refer to the type. After the stub is\n-//! inserted into the cache, the algorithm continues as before. If it now\n-//! encounters a recursive reference, it will hit the cache and does not try to\n-//! describe the type anew.\n-//!\n-//! This behavior is encapsulated in the 'RecursiveTypeDescription' enum,\n-//! which represents a kind of continuation, storing all state needed to\n-//! continue traversal at the type members after the type has been registered\n-//! with the cache. (This implementation approach might be a tad over-\n-//! engineered and may change in the future)\n-//!\n-//!\n-//! ## Source Locations and Line Information\n-//!\n-//! In addition to data type descriptions the debugging information must also\n-//! allow to map machine code locations back to source code locations in order\n-//! to be useful. This functionality is also handled in this module. The\n-//! following functions allow to control source mappings:\n-//!\n-//! + set_source_location()\n-//! + clear_source_location()\n-//! + start_emitting_source_locations()\n-//!\n-//! `set_source_location()` allows to set the current source location. All IR\n-//! instructions created after a call to this function will be linked to the\n-//! given source location, until another location is specified with\n-//! `set_source_location()` or the source location is cleared with\n-//! `clear_source_location()`. In the later case, subsequent IR instruction\n-//! will not be linked to any source location. As you can see, this is a\n-//! stateful API (mimicking the one in LLVM), so be careful with source\n-//! locations set by previous calls. It's probably best to not rely on any\n-//! specific state being present at a given point in code.\n-//!\n-//! One topic that deserves some extra attention is *function prologues*. At\n-//! the beginning of a function's machine code there are typically a few\n-//! instructions for loading argument values into allocas and checking if\n-//! there's enough stack space for the function to execute. This *prologue* is\n-//! not visible in the source code and LLVM puts a special PROLOGUE END marker\n-//! into the line table at the first non-prologue instruction of the function.\n-//! In order to find out where the prologue ends, LLVM looks for the first\n-//! instruction in the function body that is linked to a source location. So,\n-//! when generating prologue instructions we have to make sure that we don't\n-//! emit source location information until the 'real' function body begins. For\n-//! this reason, source location emission is disabled by default for any new\n-//! function being codegened and is only activated after a call to the third\n-//! function from the list above, `start_emitting_source_locations()`. This\n-//! function should be called right before regularly starting to codegen the\n-//! top-level block of the given function.\n-//!\n-//! There is one exception to the above rule: `llvm.dbg.declare` instruction\n-//! must be linked to the source location of the variable being declared. For\n-//! function parameters these `llvm.dbg.declare` instructions typically occur\n-//! in the middle of the prologue, however, they are ignored by LLVM's prologue\n-//! detection. The `create_argument_metadata()` and related functions take care\n-//! of linking the `llvm.dbg.declare` instructions to the correct source\n-//! locations even while source location emission is still disabled, so there\n-//! is no need to do anything special with source location handling here.\n-//!\n-//! ## Unique Type Identification\n-//!\n-//! In order for link-time optimization to work properly, LLVM needs a unique\n-//! type identifier that tells it across compilation units which types are the\n-//! same as others. This type identifier is created by\n-//! `TypeMap::get_unique_type_id_of_type()` using the following algorithm:\n-//!\n-//! (1) Primitive types have their name as ID\n-//! (2) Structs, enums and traits have a multipart identifier\n-//!\n-//!     (1) The first part is the SVH (strict version hash) of the crate they\n-//!          were originally defined in\n-//!\n-//!     (2) The second part is the ast::NodeId of the definition in their\n-//!          original crate\n-//!\n-//!     (3) The final part is a concatenation of the type IDs of their concrete\n-//!          type arguments if they are generic types.\n-//!\n-//! (3) Tuple-, pointer and function types are structurally identified, which\n-//!     means that they are equivalent if their component types are equivalent\n-//!     (i.e., (i32, i32) is the same regardless in which crate it is used).\n-//!\n-//! This algorithm also provides a stable ID for types that are defined in one\n-//! crate but instantiated from metadata within another crate. We just have to\n-//! take care to always map crate and `NodeId`s back to the original crate\n-//! context.\n-//!\n-//! As a side-effect these unique type IDs also help to solve a problem arising\n-//! from lifetime parameters. Since lifetime parameters are completely omitted\n-//! in debuginfo, more than one `Ty` instance may map to the same debuginfo\n-//! type metadata, that is, some struct `Struct<'a>` may have N instantiations\n-//! with different concrete substitutions for `'a`, and thus there will be N\n-//! `Ty` instances for the type `Struct<'a>` even though it is not generic\n-//! otherwise. Unfortunately this means that we cannot use `ty::type_id()` as\n-//! cheap identifier for type metadata -- we have done this in the past, but it\n-//! led to unnecessary metadata duplication in the best case and LLVM\n-//! assertions in the worst. However, the unique type ID as described above\n-//! *can* be used as identifier. Since it is comparatively expensive to\n-//! construct, though, `ty::type_id()` is still used additionally as an\n-//! optimization for cases where the exact same type has been seen before\n-//! (which is most of the time)."}, {"sha": "abb87cb36568eb01352c701ad0d82c809381a31b", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -1,5 +1,4 @@\n-// See doc.rs for documentation.\n-mod doc;\n+#![doc = include_str!(\"doc.md\")]\n \n use rustc_codegen_ssa::mir::debuginfo::VariableKind::*;\n "}, {"sha": "146c08337fc77998673ffe3843387c9c39e21171", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -8,6 +8,7 @@\n #![feature(bool_to_option)]\n #![feature(const_cstr_unchecked)]\n #![feature(crate_visibility_modifier)]\n+#![feature(extended_key_value_attributes)]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]"}, {"sha": "26858915f45a03978a409830d2eca01b6b2ac174", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -955,14 +955,14 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 }\n                 return None;\n             }\n-            PathResult::NonModule(path_res) if path_res.base_res() == Res::Err => {\n+            PathResult::NonModule(_) => {\n                 if no_ambiguity {\n                     assert!(import.imported_module.get().is_none());\n                 }\n                 // The error was already reported earlier.\n                 return None;\n             }\n-            PathResult::Indeterminate | PathResult::NonModule(..) => unreachable!(),\n+            PathResult::Indeterminate => unreachable!(),\n         };\n \n         let (ident, target, source_bindings, target_bindings, type_ns_only) = match import.kind {"}, {"sha": "1c635dd4f27fa8c001cfc5287f2ccf0ff45ad952", "filename": "library/alloc/src/collections/vec_deque/into_iter.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -1,5 +1,5 @@\n use core::fmt;\n-use core::iter::FusedIterator;\n+use core::iter::{FusedIterator, TrustedLen, TrustedRandomAccess};\n \n use super::VecDeque;\n \n@@ -36,6 +36,22 @@ impl<T> Iterator for IntoIter<T> {\n         let len = self.inner.len();\n         (len, Some(len))\n     }\n+\n+    #[inline]\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // Safety: The TrustedRandomAccess contract requires that callers only pass an index\n+        // that is in bounds.\n+        // Additionally Self: TrustedRandomAccess is only implemented for T: Copy which means even\n+        // multiple repeated reads of the same index would be safe and the\n+        // values are !Drop, thus won't suffer from double drops.\n+        unsafe {\n+            let idx = self.inner.wrap_add(self.inner.tail, idx);\n+            self.inner.buffer_read(idx)\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -55,3 +71,17 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for IntoIter<T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+// T: Copy as approximation for !Drop since get_unchecked does not update the pointers\n+// and thus we can't implement drop-handling\n+unsafe impl<T> TrustedRandomAccess for IntoIter<T>\n+where\n+    T: Copy,\n+{\n+    const MAY_HAVE_SIDE_EFFECT: bool = false;\n+}"}, {"sha": "e4cfb3acdfd5ce94c74d172a2a425720a1c8966e", "filename": "library/alloc/src/collections/vec_deque/iter.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -1,5 +1,5 @@\n use core::fmt;\n-use core::iter::FusedIterator;\n+use core::iter::{FusedIterator, TrustedLen, TrustedRandomAccess};\n use core::ops::Try;\n \n use super::{count, wrap_index, RingSlices};\n@@ -101,6 +101,19 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn last(mut self) -> Option<&'a T> {\n         self.next_back()\n     }\n+\n+    #[inline]\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // Safety: The TrustedRandomAccess contract requires that callers only  pass an index\n+        // that is in bounds.\n+        unsafe {\n+            let idx = wrap_index(self.tail.wrapping_add(idx), self.ring.len());\n+            self.ring.get_unchecked(idx)\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -157,3 +170,12 @@ impl<T> ExactSizeIterator for Iter<'_, T> {\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Iter<'_, T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for Iter<'_, T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<T> TrustedRandomAccess for Iter<'_, T> {\n+    const MAY_HAVE_SIDE_EFFECT: bool = false;\n+}"}, {"sha": "9493676e66bc8f3232e6937aea62a6a99a47a38a", "filename": "library/alloc/src/collections/vec_deque/iter_mut.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -1,5 +1,5 @@\n use core::fmt;\n-use core::iter::FusedIterator;\n+use core::iter::{FusedIterator, TrustedLen, TrustedRandomAccess};\n use core::marker::PhantomData;\n \n use super::{count, wrap_index, RingSlices};\n@@ -87,6 +87,19 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     fn last(mut self) -> Option<&'a mut T> {\n         self.next_back()\n     }\n+\n+    #[inline]\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // Safety: The TrustedRandomAccess contract requires that callers only  pass an index\n+        // that is in bounds.\n+        unsafe {\n+            let idx = wrap_index(self.tail.wrapping_add(idx), self.ring.len());\n+            &mut *self.ring.get_unchecked_mut(idx)\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -126,3 +139,12 @@ impl<T> ExactSizeIterator for IterMut<'_, T> {\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IterMut<'_, T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for IterMut<'_, T> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<T> TrustedRandomAccess for IterMut<'_, T> {\n+    const MAY_HAVE_SIDE_EFFECT: bool = false;\n+}"}, {"sha": "d3e70991ad5187bcee4500d008fe65bd3d56386a", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -58,7 +58,7 @@ mod tests;\n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n \n-const MAXIMUM_ZST_CAPACITY: usize = 1 << (core::mem::size_of::<usize>() * 8 - 1); // Largest possible power of two\n+const MAXIMUM_ZST_CAPACITY: usize = 1 << (usize::BITS - 1); // Largest possible power of two\n \n /// A double-ended queue implemented with a growable ring buffer.\n ///"}, {"sha": "f4ec4a36ffd2bac8b5e99a12481bbdff21c53a64", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -1289,37 +1289,44 @@ impl String {\n     where\n         F: FnMut(char) -> bool,\n     {\n-        let len = self.len();\n-        let mut del_bytes = 0;\n-        let mut idx = 0;\n+        struct SetLenOnDrop<'a> {\n+            s: &'a mut String,\n+            idx: usize,\n+            del_bytes: usize,\n+        }\n \n-        unsafe {\n-            self.vec.set_len(0);\n+        impl<'a> Drop for SetLenOnDrop<'a> {\n+            fn drop(&mut self) {\n+                let new_len = self.idx - self.del_bytes;\n+                debug_assert!(new_len <= self.s.len());\n+                unsafe { self.s.vec.set_len(new_len) };\n+            }\n         }\n \n-        while idx < len {\n-            let ch = unsafe { self.get_unchecked(idx..len).chars().next().unwrap() };\n+        let len = self.len();\n+        let mut guard = SetLenOnDrop { s: self, idx: 0, del_bytes: 0 };\n+\n+        while guard.idx < len {\n+            let ch = unsafe { guard.s.get_unchecked(guard.idx..len).chars().next().unwrap() };\n             let ch_len = ch.len_utf8();\n \n             if !f(ch) {\n-                del_bytes += ch_len;\n-            } else if del_bytes > 0 {\n+                guard.del_bytes += ch_len;\n+            } else if guard.del_bytes > 0 {\n                 unsafe {\n                     ptr::copy(\n-                        self.vec.as_ptr().add(idx),\n-                        self.vec.as_mut_ptr().add(idx - del_bytes),\n+                        guard.s.vec.as_ptr().add(guard.idx),\n+                        guard.s.vec.as_mut_ptr().add(guard.idx - guard.del_bytes),\n                         ch_len,\n                     );\n                 }\n             }\n \n             // Point idx to the next char\n-            idx += ch_len;\n+            guard.idx += ch_len;\n         }\n \n-        unsafe {\n-            self.vec.set_len(len - del_bytes);\n-        }\n+        drop(guard);\n     }\n \n     /// Inserts a character into this `String` at a byte position."}, {"sha": "f82454addd09af3466c6c95720af4b3f05937e3b", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -2,7 +2,7 @@\n \n use crate::{\n     fmt,\n-    iter::{ExactSizeIterator, FusedIterator, TrustedLen},\n+    iter::{ExactSizeIterator, FusedIterator, TrustedLen, TrustedRandomAccess},\n     mem::{self, MaybeUninit},\n     ops::Range,\n     ptr,\n@@ -130,6 +130,18 @@ impl<T, const N: usize> Iterator for IntoIter<T, N> {\n     fn last(mut self) -> Option<Self::Item> {\n         self.next_back()\n     }\n+\n+    #[inline]\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: Callers are only allowed to pass an index that is in bounds\n+        // Additionally Self: TrustedRandomAccess is only implemented for T: Copy which means even\n+        // multiple repeated reads of the same index would be safe and the\n+        // values aree !Drop, thus won't suffer from double drops.\n+        unsafe { self.data.get_unchecked(self.alive.start + idx).assume_init_read() }\n+    }\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n@@ -184,6 +196,17 @@ impl<T, const N: usize> FusedIterator for IntoIter<T, N> {}\n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, N> {}\n \n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+// T: Copy as approximation for !Drop since get_unchecked does not update the pointers\n+// and thus we can't implement drop-handling\n+unsafe impl<T, const N: usize> TrustedRandomAccess for IntoIter<T, N>\n+where\n+    T: Copy,\n+{\n+    const MAY_HAVE_SIDE_EFFECT: bool = false;\n+}\n+\n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n impl<T: Clone, const N: usize> Clone for IntoIter<T, N> {\n     fn clone(&self) -> Self {"}, {"sha": "4b293c596e7af6e702bacff670c27a5475e8c097", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -3,7 +3,7 @@ use crate::convert::TryFrom;\n use crate::mem;\n use crate::ops::{self, Try};\n \n-use super::{FusedIterator, TrustedLen};\n+use super::{FusedIterator, TrustedLen, TrustedRandomAccess};\n \n /// Objects that have a notion of *successor* and *predecessor* operations.\n ///\n@@ -493,6 +493,18 @@ macro_rules! range_exact_iter_impl {\n     )*)\n }\n \n+/// Safety: This macro must only be used on types that are `Copy` and result in ranges\n+/// which have an exact `size_hint()` where the upper bound must not be `None`.\n+macro_rules! unsafe_range_trusted_random_access_impl {\n+    ($($t:ty)*) => ($(\n+        #[doc(hidden)]\n+        #[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+        unsafe impl TrustedRandomAccess for ops::Range<$t> {\n+            const MAY_HAVE_SIDE_EFFECT: bool = false;\n+        }\n+    )*)\n+}\n+\n macro_rules! range_incl_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n@@ -553,6 +565,18 @@ impl<A: Step> Iterator for ops::Range<A> {\n     fn max(mut self) -> Option<A> {\n         self.next_back()\n     }\n+\n+    #[inline]\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: The TrustedRandomAccess contract requires that callers only  pass an index\n+        // that is in bounds.\n+        // Additionally Self: TrustedRandomAccess is only implemented for Copy types\n+        // which means even repeated reads of the same index would be safe.\n+        unsafe { Step::forward_unchecked(self.start.clone(), idx) }\n+    }\n }\n \n // These macros generate `ExactSizeIterator` impls for various range types.\n@@ -574,6 +598,23 @@ range_exact_iter_impl! {\n     u32\n     i32\n }\n+\n+unsafe_range_trusted_random_access_impl! {\n+    usize u8 u16\n+    isize i8 i16\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+unsafe_range_trusted_random_access_impl! {\n+    u32 i32\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+unsafe_range_trusted_random_access_impl! {\n+    u32 i32\n+    u64 i64\n+}\n+\n range_incl_exact_iter_impl! {\n     u8\n     i8"}, {"sha": "83b88ffd91694d3a4462dcc0cde08dc5ca912c67", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -110,7 +110,7 @@ impl<T: Sized> NonNull<T> {\n     /// [the module documentation]: crate::ptr#safety\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_ref(&self) -> &MaybeUninit<T> {\n+    pub unsafe fn as_uninit_ref<'a>(&self) -> &'a MaybeUninit<T> {\n         // SAFETY: the caller must guarantee that `self` meets all the\n         // requirements for a reference.\n         unsafe { &*self.cast().as_ptr() }\n@@ -142,7 +142,7 @@ impl<T: Sized> NonNull<T> {\n     /// [the module documentation]: crate::ptr#safety\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_mut(&mut self) -> &mut MaybeUninit<T> {\n+    pub unsafe fn as_uninit_mut<'a>(&mut self) -> &'a mut MaybeUninit<T> {\n         // SAFETY: the caller must guarantee that `self` meets all the\n         // requirements for a reference.\n         unsafe { &mut *self.cast().as_ptr() }\n@@ -244,7 +244,7 @@ impl<T: ?Sized> NonNull<T> {\n     /// [the module documentation]: crate::ptr#safety\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n-    pub unsafe fn as_ref(&self) -> &T {\n+    pub unsafe fn as_ref<'a>(&self) -> &'a T {\n         // SAFETY: the caller must guarantee that `self` meets all the\n         // requirements for a reference.\n         unsafe { &*self.as_ptr() }\n@@ -280,7 +280,7 @@ impl<T: ?Sized> NonNull<T> {\n     /// [the module documentation]: crate::ptr#safety\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n-    pub unsafe fn as_mut(&mut self) -> &mut T {\n+    pub unsafe fn as_mut<'a>(&mut self) -> &'a mut T {\n         // SAFETY: the caller must guarantee that `self` meets all the\n         // requirements for a mutable reference.\n         unsafe { &mut *self.as_ptr() }\n@@ -427,7 +427,7 @@ impl<T> NonNull<[T]> {\n     /// [valid]: crate::ptr#safety\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_slice(&self) -> &[MaybeUninit<T>] {\n+    pub unsafe fn as_uninit_slice<'a>(&self) -> &'a [MaybeUninit<T>] {\n         // SAFETY: the caller must uphold the safety contract for `as_uninit_slice`.\n         unsafe { slice::from_raw_parts(self.cast().as_ptr(), self.len()) }\n     }\n@@ -488,7 +488,7 @@ impl<T> NonNull<[T]> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_slice_mut(&self) -> &mut [MaybeUninit<T>] {\n+    pub unsafe fn as_uninit_slice_mut<'a>(&self) -> &'a mut [MaybeUninit<T>] {\n         // SAFETY: the caller must uphold the safety contract for `as_uninit_slice_mut`.\n         unsafe { slice::from_raw_parts_mut(self.cast().as_ptr(), self.len()) }\n     }"}, {"sha": "1ee662c6c8e3cc60938552e7bd71913abe91e833", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -286,7 +286,6 @@ impl<'a, T> IterMut<'a, T> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// # #![feature(slice_iter_mut_as_slice)]\n     /// let mut slice: &mut [usize] = &mut [1, 2, 3];\n     ///\n     /// // First, we get the iterator:\n@@ -299,12 +298,19 @@ impl<'a, T> IterMut<'a, T> {\n     /// // Now `as_slice` returns \"[2, 3]\":\n     /// assert_eq!(iter.as_slice(), &[2, 3]);\n     /// ```\n-    #[unstable(feature = \"slice_iter_mut_as_slice\", reason = \"recently added\", issue = \"58957\")]\n+    #[stable(feature = \"slice_iter_mut_as_slice\", since = \"1.53.0\")]\n     pub fn as_slice(&self) -> &[T] {\n         self.make_slice()\n     }\n }\n \n+#[stable(feature = \"slice_iter_mut_as_slice\", since = \"1.53.0\")]\n+impl<T> AsRef<[T]> for IterMut<'_, T> {\n+    fn as_ref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n iterator! {struct IterMut -> *mut T, &'a mut T, mut, {mut}, {}}\n \n /// An internal abstraction over the splitting iterators, so that"}, {"sha": "14914287cb1b14c57af949205f178564f65dabe6", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -716,7 +716,6 @@ impl OsStr {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(osstring_ascii)]\n     /// use std::ffi::OsString;\n     ///\n     /// let mut s = OsString::from(\"GR\u00dc\u00dfE, J\u00dcRGEN \u2764\");\n@@ -725,7 +724,7 @@ impl OsStr {\n     ///\n     /// assert_eq!(\"gr\u00dc\u00dfe, j\u00dcrgen \u2764\", s);\n     /// ```\n-    #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    #[stable(feature = \"osstring_ascii\", since = \"1.53.0\")]\n     #[inline]\n     pub fn make_ascii_lowercase(&mut self) {\n         self.inner.make_ascii_lowercase()\n@@ -742,7 +741,6 @@ impl OsStr {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(osstring_ascii)]\n     /// use std::ffi::OsString;\n     ///\n     /// let mut s = OsString::from(\"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\");\n@@ -751,7 +749,7 @@ impl OsStr {\n     ///\n     /// assert_eq!(\"GR\u00fc\u00dfE, J\u00fcRGEN \u2764\", s);\n     /// ```\n-    #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    #[stable(feature = \"osstring_ascii\", since = \"1.53.0\")]\n     #[inline]\n     pub fn make_ascii_uppercase(&mut self) {\n         self.inner.make_ascii_uppercase()\n@@ -768,13 +766,12 @@ impl OsStr {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(osstring_ascii)]\n     /// use std::ffi::OsString;\n     /// let s = OsString::from(\"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\");\n     ///\n     /// assert_eq!(\"gr\u00fc\u00dfe, j\u00fcrgen \u2764\", s.to_ascii_lowercase());\n     /// ```\n-    #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    #[stable(feature = \"osstring_ascii\", since = \"1.53.0\")]\n     pub fn to_ascii_lowercase(&self) -> OsString {\n         OsString::from_inner(self.inner.to_ascii_lowercase())\n     }\n@@ -790,13 +787,12 @@ impl OsStr {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(osstring_ascii)]\n     /// use std::ffi::OsString;\n     /// let s = OsString::from(\"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\");\n     ///\n     /// assert_eq!(\"GR\u00fc\u00dfE, J\u00fcRGEN \u2764\", s.to_ascii_uppercase());\n     /// ```\n-    #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    #[stable(feature = \"osstring_ascii\", since = \"1.53.0\")]\n     pub fn to_ascii_uppercase(&self) -> OsString {\n         OsString::from_inner(self.inner.to_ascii_uppercase())\n     }\n@@ -806,7 +802,6 @@ impl OsStr {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(osstring_ascii)]\n     /// use std::ffi::OsString;\n     ///\n     /// let ascii = OsString::from(\"hello!\\n\");\n@@ -815,7 +810,7 @@ impl OsStr {\n     /// assert!(ascii.is_ascii());\n     /// assert!(!non_ascii.is_ascii());\n     /// ```\n-    #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    #[stable(feature = \"osstring_ascii\", since = \"1.53.0\")]\n     #[inline]\n     pub fn is_ascii(&self) -> bool {\n         self.inner.is_ascii()\n@@ -829,14 +824,13 @@ impl OsStr {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(osstring_ascii)]\n     /// use std::ffi::OsString;\n     ///\n     /// assert!(OsString::from(\"Ferris\").eq_ignore_ascii_case(\"FERRIS\"));\n     /// assert!(OsString::from(\"Ferr\u00f6s\").eq_ignore_ascii_case(\"FERR\u00f6S\"));\n     /// assert!(!OsString::from(\"Ferr\u00f6s\").eq_ignore_ascii_case(\"FERR\u00d6S\"));\n     /// ```\n-    #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    #[stable(feature = \"osstring_ascii\", since = \"1.53.0\")]\n     pub fn eq_ignore_ascii_case<S: AsRef<OsStr>>(&self, other: S) -> bool {\n         self.inner.eq_ignore_ascii_case(&other.as_ref().inner)\n     }"}, {"sha": "9b359392cf0cde335f01e7b6f37b57b1c3c14df8", "filename": "library/std/src/sys/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -70,8 +70,6 @@ cfg_if::cfg_if! {\n         #[allow(missing_docs)]\n         pub mod unix_ext {}\n     } else {\n-        // On other platforms like Windows document the bare bones of unix\n-        use crate::os::linux as platform;\n         #[path = \"unix/ext/mod.rs\"]\n         pub mod unix_ext;\n     }"}, {"sha": "21bdfe29578bfb0b871b7ea0c935a10e7b617300", "filename": "library/std/src/sys/unix/ext/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -2,11 +2,11 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use super::platform::fs::MetadataExt as _;\n use crate::fs::{self, OpenOptions, Permissions};\n use crate::io;\n use crate::path::Path;\n use crate::sys;\n-use crate::sys::platform::fs::MetadataExt as UnixMetadataExt;\n use crate::sys_common::{AsInner, AsInnerMut, FromInner};\n // Used for `File::read` on intra-doc links\n #[allow(unused_imports)]"}, {"sha": "e5048f7e545e0722d5a33877de597d4e16064f7b", "filename": "library/std/src/sys/unix/ext/mod.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fmod.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -29,6 +29,42 @@\n #![doc(cfg(unix))]\n #![allow(missing_docs)]\n \n+cfg_if::cfg_if! {\n+    if #[cfg(doc)] {\n+        // Use linux as the default platform when documenting on other platforms like Windows\n+        use crate::os::linux as platform;\n+    } else {\n+        #[cfg(target_os = \"android\")]\n+        use crate::os::android as platform;\n+        #[cfg(target_os = \"dragonfly\")]\n+        use crate::os::dragonfly as platform;\n+        #[cfg(target_os = \"emscripten\")]\n+        use crate::os::emscripten as platform;\n+        #[cfg(target_os = \"freebsd\")]\n+        use crate::os::freebsd as platform;\n+        #[cfg(target_os = \"fuchsia\")]\n+        use crate::os::fuchsia as platform;\n+        #[cfg(target_os = \"haiku\")]\n+        use crate::os::haiku as platform;\n+        #[cfg(target_os = \"illumos\")]\n+        use crate::os::illumos as platform;\n+        #[cfg(target_os = \"ios\")]\n+        use crate::os::ios as platform;\n+        #[cfg(any(target_os = \"linux\", target_os = \"l4re\"))]\n+        use crate::os::linux as platform;\n+        #[cfg(target_os = \"macos\")]\n+        use crate::os::macos as platform;\n+        #[cfg(target_os = \"netbsd\")]\n+        use crate::os::netbsd as platform;\n+        #[cfg(target_os = \"openbsd\")]\n+        use crate::os::openbsd as platform;\n+        #[cfg(target_os = \"redox\")]\n+        use crate::os::redox as platform;\n+        #[cfg(target_os = \"solaris\")]\n+        use crate::os::solaris as platform;\n+    }\n+}\n+\n pub mod ffi;\n pub mod fs;\n pub mod io;"}, {"sha": "c292955cb4eea40213a7b6b67840c876924adc02", "filename": "library/std/src/sys/unix/ext/raw.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fraw.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -24,10 +24,10 @@ pub type pid_t = i32;\n \n #[doc(inline)]\n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n-pub use crate::sys::platform::raw::pthread_t;\n+pub use super::platform::raw::pthread_t;\n #[doc(inline)]\n #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-pub use crate::sys::platform::raw::{blkcnt_t, time_t};\n+pub use super::platform::raw::{blkcnt_t, time_t};\n #[doc(inline)]\n #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-pub use crate::sys::platform::raw::{blksize_t, dev_t, ino_t, mode_t, nlink_t, off_t};\n+pub use super::platform::raw::{blksize_t, dev_t, ino_t, mode_t, nlink_t, off_t};"}, {"sha": "44328ffc22e5b6713a91c307c9cb4abf114d3144", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -2,38 +2,6 @@\n \n use crate::io::ErrorKind;\n \n-#[cfg(any(doc, target_os = \"linux\"))]\n-pub use crate::os::linux as platform;\n-\n-#[cfg(all(not(doc), target_os = \"android\"))]\n-pub use crate::os::android as platform;\n-#[cfg(all(not(doc), target_os = \"dragonfly\"))]\n-pub use crate::os::dragonfly as platform;\n-#[cfg(all(not(doc), target_os = \"emscripten\"))]\n-pub use crate::os::emscripten as platform;\n-#[cfg(all(not(doc), target_os = \"freebsd\"))]\n-pub use crate::os::freebsd as platform;\n-#[cfg(all(not(doc), target_os = \"fuchsia\"))]\n-pub use crate::os::fuchsia as platform;\n-#[cfg(all(not(doc), target_os = \"haiku\"))]\n-pub use crate::os::haiku as platform;\n-#[cfg(all(not(doc), target_os = \"illumos\"))]\n-pub use crate::os::illumos as platform;\n-#[cfg(all(not(doc), target_os = \"ios\"))]\n-pub use crate::os::ios as platform;\n-#[cfg(all(not(doc), target_os = \"l4re\"))]\n-pub use crate::os::linux as platform;\n-#[cfg(all(not(doc), target_os = \"macos\"))]\n-pub use crate::os::macos as platform;\n-#[cfg(all(not(doc), target_os = \"netbsd\"))]\n-pub use crate::os::netbsd as platform;\n-#[cfg(all(not(doc), target_os = \"openbsd\"))]\n-pub use crate::os::openbsd as platform;\n-#[cfg(all(not(doc), target_os = \"redox\"))]\n-pub use crate::os::redox as platform;\n-#[cfg(all(not(doc), target_os = \"solaris\"))]\n-pub use crate::os::solaris as platform;\n-\n pub use self::rand::hashmap_random_keys;\n pub use libc::strlen;\n "}, {"sha": "075756b73ba820ea256a3c45e1c66fb3abf21c70", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -463,6 +463,8 @@ def download_stage0(self):\n                 \"--\",\n                 \"{}/src/llvm-project\".format(top_level),\n                 \"{}/src/bootstrap/download-ci-llvm-stamp\".format(top_level),\n+                # the LLVM shared object file is named `LLVM-12-rust-{version}-nightly`\n+                \"{}/src/version\".format(top_level)\n             ]).decode(sys.getdefaultencoding()).strip()\n             llvm_assertions = self.get_toml('assertions', 'llvm') == 'true'\n             llvm_root = self.llvm_root()"}, {"sha": "4581dc2e2ad8855cf69d74c6fc8d4b2c9aaf159a", "filename": "src/test/ui/imports/tool-mod-child.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/src%2Ftest%2Fui%2Fimports%2Ftool-mod-child.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/src%2Ftest%2Fui%2Fimports%2Ftool-mod-child.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Ftool-mod-child.rs?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -0,0 +1,7 @@\n+use clippy::a; //~ ERROR unresolved import `clippy`\n+use clippy::a::b; //~ ERROR failed to resolve: maybe a missing crate `clippy`?\n+\n+use rustdoc::a; //~ ERROR unresolved import `rustdoc`\n+use rustdoc::a::b; //~ ERROR failed to resolve: maybe a missing crate `rustdoc`?\n+\n+fn main() {}"}, {"sha": "efab4f6a74f835ee30a53680977b9ce2c8de799d", "filename": "src/test/ui/imports/tool-mod-child.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/142c831861ba5a995fd9de99198e7f6074b6b400/src%2Ftest%2Fui%2Fimports%2Ftool-mod-child.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/142c831861ba5a995fd9de99198e7f6074b6b400/src%2Ftest%2Fui%2Fimports%2Ftool-mod-child.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Ftool-mod-child.stderr?ref=142c831861ba5a995fd9de99198e7f6074b6b400", "patch": "@@ -0,0 +1,28 @@\n+error[E0433]: failed to resolve: maybe a missing crate `clippy`?\n+  --> $DIR/tool-mod-child.rs:2:5\n+   |\n+LL | use clippy::a::b;\n+   |     ^^^^^^ maybe a missing crate `clippy`?\n+\n+error[E0432]: unresolved import `clippy`\n+  --> $DIR/tool-mod-child.rs:1:5\n+   |\n+LL | use clippy::a;\n+   |     ^^^^^^ maybe a missing crate `clippy`?\n+\n+error[E0433]: failed to resolve: maybe a missing crate `rustdoc`?\n+  --> $DIR/tool-mod-child.rs:5:5\n+   |\n+LL | use rustdoc::a::b;\n+   |     ^^^^^^^ maybe a missing crate `rustdoc`?\n+\n+error[E0432]: unresolved import `rustdoc`\n+  --> $DIR/tool-mod-child.rs:4:5\n+   |\n+LL | use rustdoc::a;\n+   |     ^^^^^^^ maybe a missing crate `rustdoc`?\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0432, E0433.\n+For more information about an error, try `rustc --explain E0432`."}]}