{"sha": "8168765d43937d1def40f13bcfe9be5748a180b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNjg3NjVkNDM5MzdkMWRlZjQwZjEzYmNmZTliZTU3NDhhMTgwYjM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-01-12T16:17:50Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-01-13T13:29:50Z"}, "message": "Factored out private routine for emitting LLVM lifetime intrinsic calls.\n\n(The reason this is not factored as far as possible because a\nsubsequent commit is going to need to do construction without having\naccess to a `cx`.)", "tree": {"sha": "4c52c3027811da28161e39e3408ad451661b1af4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c52c3027811da28161e39e3408ad451661b1af4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8168765d43937d1def40f13bcfe9be5748a180b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8168765d43937d1def40f13bcfe9be5748a180b3", "html_url": "https://github.com/rust-lang/rust/commit/8168765d43937d1def40f13bcfe9be5748a180b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8168765d43937d1def40f13bcfe9be5748a180b3/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df1283cd1a6902bad5c869b124519814cd482064", "url": "https://api.github.com/repos/rust-lang/rust/commits/df1283cd1a6902bad5c869b124519814cd482064", "html_url": "https://github.com/rust-lang/rust/commit/df1283cd1a6902bad5c869b124519814cd482064"}], "stats": {"total": 75, "additions": 45, "deletions": 30}, "files": [{"sha": "636db8fecdf7f0e337bc193c876eb50e3a0026f5", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 45, "deletions": 30, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8168765d43937d1def40f13bcfe9be5748a180b3/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8168765d43937d1def40f13bcfe9be5748a180b3/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=8168765d43937d1def40f13bcfe9be5748a180b3", "patch": "@@ -1147,48 +1147,63 @@ pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>, val: ValueRef, f: F) ->\n     next_cx\n }\n \n-pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n-    if cx.sess().opts.optimize == config::No {\n+enum Lifetime { Start, End }\n+\n+// If LLVM lifetime intrinsic support is enabled (i.e. optimizations\n+// on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n+// and the intrinsic for `lt` and passes them to `emit`, which is in\n+// charge of generating code to call the passed intrinsic on whatever\n+// block of generated code is targetted for the intrinsic.\n+//\n+// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n+// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n+fn core_lifetime_emit<'blk, 'tcx, F>(ccx: &'blk CrateContext<'blk, 'tcx>,\n+                                     ptr: ValueRef,\n+                                     lt: Lifetime,\n+                                     emit: F)\n+    where F: FnOnce(&'blk CrateContext<'blk, 'tcx>, machine::llsize, ValueRef)\n+{\n+    if ccx.sess().opts.optimize == config::No {\n         return;\n     }\n \n-    let _icx = push_ctxt(\"lifetime_start\");\n-    let ccx = cx.ccx();\n+    let _icx = push_ctxt(match lt {\n+        Lifetime::Start => \"lifetime_start\",\n+        Lifetime::End => \"lifetime_end\"\n+    });\n \n     let size = machine::llsize_of_alloc(ccx, val_ty(ptr).element_type());\n     if size == 0 {\n         return;\n     }\n \n-    let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n-    let lifetime_start = ccx.get_intrinsic(&\"llvm.lifetime.start\");\n-    Call(cx,\n-         lifetime_start,\n-         &[C_u64(ccx, size), ptr],\n-         None,\n-         DebugLoc::None);\n+    let lifetime_intrinsic = ccx.get_intrinsic(match lt {\n+        Lifetime::Start => \"llvm.lifetime.start\",\n+        Lifetime::End => \"llvm.lifetime.end\"\n+    });\n+    emit(ccx, size, lifetime_intrinsic)\n }\n \n-pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n-    if cx.sess().opts.optimize == config::No {\n-        return;\n-    }\n-\n-    let _icx = push_ctxt(\"lifetime_end\");\n-    let ccx = cx.ccx();\n-\n-    let size = machine::llsize_of_alloc(ccx, val_ty(ptr).element_type());\n-    if size == 0 {\n-        return;\n-    }\n+pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n+    core_lifetime_emit(cx.ccx(), ptr, Lifetime::Start, |ccx, size, lifetime_start| {\n+        let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n+        Call(cx,\n+             lifetime_start,\n+             &[C_u64(ccx, size), ptr],\n+             None,\n+             DebugLoc::None);\n+    })\n+}\n \n-    let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n-    let lifetime_end = ccx.get_intrinsic(&\"llvm.lifetime.end\");\n-    Call(cx,\n-         lifetime_end,\n-         &[C_u64(ccx, size), ptr],\n-         None,\n-         DebugLoc::None);\n+pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n+    core_lifetime_emit(cx.ccx(), ptr, Lifetime::End, |ccx, size, lifetime_end| {\n+        let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n+        Call(cx,\n+             lifetime_end,\n+             &[C_u64(ccx, size), ptr],\n+             None,\n+             DebugLoc::None);\n+    })\n }\n \n // Generates code for resumption of unwind at the end of a landing pad."}]}