{"sha": "cc0fbdffe7db21649f45b3407ff9766636727690", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMGZiZGZmZTdkYjIxNjQ5ZjQ1YjM0MDdmZjk3NjY2MzY3Mjc2OTA=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-21T22:55:34Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-01-07T14:41:47Z"}, "message": "Automatically prefer integer addresses for zst MPlace", "tree": {"sha": "76b1abbd078f09311ad39194acac7d742d88a79b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76b1abbd078f09311ad39194acac7d742d88a79b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc0fbdffe7db21649f45b3407ff9766636727690", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc0fbdffe7db21649f45b3407ff9766636727690", "html_url": "https://github.com/rust-lang/rust/commit/cc0fbdffe7db21649f45b3407ff9766636727690", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc0fbdffe7db21649f45b3407ff9766636727690/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee84c30aee06a004b8d8f8d24000351e9d1cb4bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee84c30aee06a004b8d8f8d24000351e9d1cb4bf", "html_url": "https://github.com/rust-lang/rust/commit/ee84c30aee06a004b8d8f8d24000351e9d1cb4bf"}], "stats": {"total": 79, "additions": 26, "deletions": 53}, "files": [{"sha": "8c41f7d1e61f6fd8781eee3843d36f5b2084e1e5", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0fbdffe7db21649f45b3407ff9766636727690/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0fbdffe7db21649f45b3407ff9766636727690/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=cc0fbdffe7db21649f45b3407ff9766636727690", "patch": "@@ -115,7 +115,7 @@ pub(super) fn op_to_const<'tcx>(\n         // by-val is if we are in const_field, i.e., if this is (a field of) something that we\n         // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n         // structs containing such.\n-        op.try_as_mplace()\n+        op.try_as_mplace(ecx)\n     };\n     let val = match immediate {\n         Ok(mplace) => {\n@@ -132,7 +132,7 @@ pub(super) fn op_to_const<'tcx>(\n                 // `Immediate` is when we are called from `const_field`, and that `Immediate`\n                 // comes from a constant so it can happen have `Undef`, because the indirect\n                 // memory that was read had undefined bytes.\n-                let mplace = op.assert_mem_place();\n+                let mplace = op.assert_mem_place(ecx);\n                 let ptr = mplace.ptr.assert_ptr();\n                 let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n                 ConstValue::ByRef { alloc, offset: ptr.offset }"}, {"sha": "00aecf74c7d3ded8c9c7009e47d264dacb0f3636", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cc0fbdffe7db21649f45b3407ff9766636727690/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0fbdffe7db21649f45b3407ff9766636727690/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=cc0fbdffe7db21649f45b3407ff9766636727690", "patch": "@@ -267,7 +267,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        match op.try_as_mplace() {\n+        match op.try_as_mplace(self) {\n             Ok(mplace) => Ok(self.force_mplace_ptr(mplace)?.into()),\n             Err(imm) => Ok(imm.into()), // Nothing to cast/force\n         }\n@@ -335,7 +335,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::PointerTag>, MPlaceTy<'tcx, M::PointerTag>>> {\n-        Ok(match src.try_as_mplace() {\n+        Ok(match src.try_as_mplace(self) {\n             Ok(mplace) => {\n                 if let Some(val) = self.try_read_immediate_from_mplace(mplace)? {\n                     Ok(val)\n@@ -383,7 +383,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         op: OpTy<'tcx, M::PointerTag>,\n         field: u64,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let base = match op.try_as_mplace() {\n+        let base = match op.try_as_mplace(self) {\n             Ok(mplace) => {\n                 // The easy case\n                 let field = self.mplace_field(mplace, field)?;\n@@ -420,7 +420,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n-        Ok(match op.try_as_mplace() {\n+        Ok(match op.try_as_mplace(self) {\n             Ok(mplace) => self.mplace_downcast(mplace, variant)?.into(),\n             Err(..) => {\n                 let layout = op.layout.for_variant(self, variant);\n@@ -439,30 +439,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Field(field, _) => self.operand_field(base, field.index() as u64)?,\n             Downcast(_, variant) => self.operand_downcast(base, variant)?,\n             Deref => self.deref_operand(base)?.into(),\n-            ConstantIndex { .. } | Index(_) if base.layout.is_zst() => {\n-                OpTy {\n-                    op: Operand::Immediate(Scalar::zst().into()),\n-                    // the actual index doesn't matter, so we just pick a convenient one like 0\n-                    layout: base.layout.field(self, 0)?,\n-                }\n-            }\n-            Subslice { from, to, from_end } if base.layout.is_zst() => {\n-                let elem_ty = if let ty::Array(elem_ty, _) = base.layout.ty.kind {\n-                    elem_ty\n-                } else {\n-                    bug!(\"slices shouldn't be zero-sized\");\n-                };\n-                assert!(!from_end, \"arrays shouldn't be subsliced from the end\");\n-\n-                OpTy {\n-                    op: Operand::Immediate(Scalar::zst().into()),\n-                    layout: self.layout_of(self.tcx.mk_array(elem_ty, (to - from) as u64))?,\n-                }\n-            }\n             Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n                 // The rest should only occur as mplace, we do not use Immediates for types\n                 // allowing such operations.  This matches place_projection forcing an allocation.\n-                let mplace = base.assert_mem_place();\n+                let mplace = base.assert_mem_place(self);\n                 self.mplace_projection(mplace, proj_elem)?.into()\n             }\n         })"}, {"sha": "7fbe691f183cc36546c0e71ad6e668fba64bda50", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cc0fbdffe7db21649f45b3407ff9766636727690/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0fbdffe7db21649f45b3407ff9766636727690/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=cc0fbdffe7db21649f45b3407ff9766636727690", "patch": "@@ -200,16 +200,17 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n // These are defined here because they produce a place.\n impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n     #[inline(always)]\n-    pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n+    pub fn try_as_mplace(self, cx: &impl HasDataLayout) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n         match *self {\n             Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n+            Operand::Immediate(_) if self.layout.is_zst() => Ok(MPlaceTy::dangling(self.layout, cx)),\n             Operand::Immediate(imm) => Err(ImmTy { imm, layout: self.layout }),\n         }\n     }\n \n     #[inline(always)]\n-    pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n-        self.try_as_mplace().unwrap()\n+    pub fn assert_mem_place(self, cx: &impl HasDataLayout) -> MPlaceTy<'tcx, Tag> {\n+        self.try_as_mplace(cx).unwrap()\n     }\n }\n \n@@ -305,7 +306,7 @@ where\n     /// On success, returns `None` for zero-sized accesses (where nothing else is\n     /// left to do) and a `Pointer` to use for the actual access otherwise.\n     #[inline]\n-    pub fn check_mplace_access(\n+    pub(super) fn check_mplace_access(\n         &self,\n         place: MPlaceTy<'tcx, M::PointerTag>,\n         size: Option<Size>,\n@@ -338,7 +339,7 @@ where\n \n     /// Force `place.ptr` to a `Pointer`.\n     /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n-    pub fn force_mplace_ptr(\n+    pub(super) fn force_mplace_ptr(\n         &self,\n         mut place: MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n@@ -415,7 +416,7 @@ where\n \n     // Iterates over all fields of an array. Much more efficient than doing the\n     // same by repeatedly calling `mplace_array`.\n-    pub fn mplace_array_fields(\n+    pub(super) fn mplace_array_fields(\n         &self,\n         base: MPlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'tcx>\n@@ -430,7 +431,7 @@ where\n         Ok((0..len).map(move |i| base.offset(i * stride, None, layout, dl)))\n     }\n \n-    pub fn mplace_subslice(\n+    fn mplace_subslice(\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n         from: u64,\n@@ -471,7 +472,7 @@ where\n         base.offset(from_offset, meta, layout, self)\n     }\n \n-    pub fn mplace_downcast(\n+    pub(super) fn mplace_downcast(\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n         variant: VariantIdx,\n@@ -482,7 +483,7 @@ where\n     }\n \n     /// Project into an mplace\n-    pub fn mplace_projection(\n+    pub(super) fn mplace_projection(\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n         proj_elem: &mir::PlaceElem<'tcx>,"}, {"sha": "37dcab512b9918d65eb95f4fe02ddde69da3d72e", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0fbdffe7db21649f45b3407ff9766636727690/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0fbdffe7db21649f45b3407ff9766636727690/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=cc0fbdffe7db21649f45b3407ff9766636727690", "patch": "@@ -378,7 +378,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     None => {\n                         // Unsized self.\n-                        args[0].assert_mem_place()\n+                        args[0].assert_mem_place(self)\n                     }\n                 };\n                 // Find and consult vtable"}, {"sha": "73f479ede769d76d8f4673f392cfd6ba539271cb", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cc0fbdffe7db21649f45b3407ff9766636727690/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0fbdffe7db21649f45b3407ff9766636727690/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=cc0fbdffe7db21649f45b3407ff9766636727690", "patch": "@@ -571,12 +571,9 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     ) -> InterpResult<'tcx> {\n         match op.layout.ty.kind {\n             ty::Str => {\n-                let mplace = op.assert_mem_place(); // strings are never immediate\n-                try_validation!(\n-                    self.ecx.read_str(mplace),\n-                    \"uninitialized or non-UTF-8 data in str\",\n-                    self.path\n-                );\n+                let mplace = op.assert_mem_place(self.ecx); // strings are never immediate\n+                try_validation!(self.ecx.read_str(mplace),\n+                    \"uninitialized or non-UTF-8 data in str\", self.path);\n             }\n             ty::Array(tys, ..) | ty::Slice(tys)\n                 if {\n@@ -604,7 +601,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     return Ok(());\n                 }\n                 // non-ZST array cannot be immediate, slices are never immediate\n-                let mplace = op.assert_mem_place();\n+                let mplace = op.assert_mem_place(self.ecx);\n                 // This is the length of the array/slice.\n                 let len = mplace.len(self.ecx)?;\n                 // zero length slices have nothing to be checked"}, {"sha": "d2594e8707104cf10e94f9c3cad066d7f3831fd7", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc0fbdffe7db21649f45b3407ff9766636727690/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0fbdffe7db21649f45b3407ff9766636727690/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=cc0fbdffe7db21649f45b3407ff9766636727690", "patch": "@@ -223,7 +223,7 @@ macro_rules! make_value_visitor {\n                 match v.layout().ty.kind {\n                     ty::Dynamic(..) => {\n                         // immediate trait objects are not a thing\n-                        let dest = v.to_op(self.ecx())?.assert_mem_place();\n+                        let dest = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n                         let inner = self.ecx().unpack_dyn_trait(dest)?.1;\n                         trace!(\"walk_value: dyn object layout: {:#?}\", inner.layout);\n                         // recurse with the inner type\n@@ -292,13 +292,7 @@ macro_rules! make_value_visitor {\n                     },\n                     layout::FieldPlacement::Array { .. } => {\n                         // Let's get an mplace first.\n-                        let mplace = if v.layout().is_zst() {\n-                            // it's a ZST, the memory content cannot matter\n-                            MPlaceTy::dangling(v.layout(), self.ecx())\n-                        } else {\n-                            // non-ZST array/slice/str cannot be immediate\n-                            v.to_op(self.ecx())?.assert_mem_place()\n-                        };\n+                        let mplace = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n                         // Now we can go over all the fields.\n                         let iter = self.ecx().mplace_array_fields(mplace)?\n                             .map(|f| f.and_then(|f| {"}, {"sha": "d5d56b36cf4c3934b67d5a0ca4e082f9282ec0aa", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc0fbdffe7db21649f45b3407ff9766636727690/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0fbdffe7db21649f45b3407ff9766636727690/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=cc0fbdffe7db21649f45b3407ff9766636727690", "patch": "@@ -707,7 +707,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 ScalarMaybeUndef::Scalar(r),\n             )) => l.is_bits() && r.is_bits(),\n             interpret::Operand::Indirect(_) if mir_opt_level >= 2 => {\n-                intern_const_alloc_recursive(&mut self.ecx, None, op.assert_mem_place())\n+                let mplace = op.assert_mem_place(&self.ecx);\n+                intern_const_alloc_recursive(&mut self.ecx, None, mplace)\n                     .expect(\"failed to intern alloc\");\n                 true\n             }"}]}