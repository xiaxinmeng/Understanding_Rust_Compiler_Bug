{"sha": "580a6342ef9d435d241b74e86b99dc1131a526f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MGE2MzQyZWY5ZDQzNWQyNDFiNzRlODZiOTlkYzExMzFhNTI2Zjg=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-03-19T17:15:32Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-03-20T16:11:13Z"}, "message": "Generate tests for Unicode property data\n\nCurrently the test file takes a while to compile -- 30 seconds or so -- but\nsince it's not going to be committed, and is just for local testing, that seems\nfine.", "tree": {"sha": "f9e29689b667afffe479461965b549dd35d1094f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9e29689b667afffe479461965b549dd35d1094f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/580a6342ef9d435d241b74e86b99dc1131a526f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/580a6342ef9d435d241b74e86b99dc1131a526f8", "html_url": "https://github.com/rust-lang/rust/commit/580a6342ef9d435d241b74e86b99dc1131a526f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/580a6342ef9d435d241b74e86b99dc1131a526f8/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c4baedb3a090f2dc9e653bd7c03165be84acad3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4baedb3a090f2dc9e653bd7c03165be84acad3", "html_url": "https://github.com/rust-lang/rust/commit/7c4baedb3a090f2dc9e653bd7c03165be84acad3"}], "stats": {"total": 101, "additions": 101, "deletions": 0}, "files": [{"sha": "39c288dfc61e8f143a5cb9de1d2ab5ac4bf4903b", "filename": "src/tools/unicode-table-generator/src/main.rs", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/580a6342ef9d435d241b74e86b99dc1131a526f8/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/580a6342ef9d435d241b74e86b99dc1131a526f8/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fmain.rs?ref=580a6342ef9d435d241b74e86b99dc1131a526f8", "patch": "@@ -152,9 +152,17 @@ fn main() {\n         std::process::exit(1);\n     });\n \n+    // Optional test path, which is a Rust source file testing that the unicode\n+    // property lookups are correct.\n+    let test_path = std::env::args().nth(2);\n+\n     let unicode_data = load_data();\n     let ranges_by_property = &unicode_data.ranges;\n \n+    if let Some(path) = test_path {\n+        std::fs::write(&path, generate_tests(&write_location, &ranges_by_property)).unwrap();\n+    }\n+\n     let mut total_bytes = 0;\n     let mut modules = Vec::new();\n     for (property, ranges) in ranges_by_property {\n@@ -236,6 +244,99 @@ fn fmt_list<V: std::fmt::Debug>(values: impl IntoIterator<Item = V>) -> String {\n     out\n }\n \n+fn generate_tests(data_path: &str, ranges: &[(&str, Vec<Range<u32>>)]) -> String {\n+    let mut s = String::new();\n+    s.push_str(\"#![allow(incomplete_features, unused)]\\n\");\n+    s.push_str(\"#![feature(const_generics)]\\n\\n\");\n+    s.push_str(&format!(\"#[path = \\\"{}\\\"]\\n\", data_path));\n+    s.push_str(\"mod unicode_data;\\n\\n\");\n+\n+    s.push_str(\n+        \"\n+#[inline(always)]\n+fn range_search<const N: usize, const CHUNK_SIZE: usize, const N1: usize, const N2: usize>(\n+    needle: u32,\n+    chunk_idx_map: &[u8; N],\n+    (last_chunk_idx, last_chunk_mapping): (u16, u8),\n+    bitset_chunk_idx: &[[u8; CHUNK_SIZE]; N1],\n+    bitset: &[u64; N2],\n+) -> bool {\n+    let bucket_idx = (needle / 64) as usize;\n+    let chunk_map_idx = bucket_idx / CHUNK_SIZE;\n+    let chunk_piece = bucket_idx % CHUNK_SIZE;\n+    let chunk_idx = if chunk_map_idx >= N {\n+        if chunk_map_idx == last_chunk_idx as usize {\n+            last_chunk_mapping\n+        } else {\n+            return false;\n+        }\n+    } else {\n+        chunk_idx_map[chunk_map_idx]\n+    };\n+    let idx = bitset_chunk_idx[(chunk_idx as usize)][chunk_piece];\n+    let word = bitset[(idx as usize)];\n+    (word & (1 << (needle % 64) as u64)) != 0\n+}\n+    \",\n+    );\n+\n+    s.push_str(\"\\nfn main() {\\n\");\n+\n+    for (property, ranges) in ranges {\n+        s.push_str(&format!(r#\"    println!(\"Testing {}\");\"#, property));\n+        s.push('\\n');\n+        s.push_str(&format!(\"    {}();\\n\", property.to_lowercase()));\n+        let mut is_true = Vec::new();\n+        let mut is_false = Vec::new();\n+        for ch_num in 0..(std::char::MAX as u32) {\n+            if std::char::from_u32(ch_num).is_none() {\n+                continue;\n+            }\n+            if ranges.iter().any(|r| r.contains(&ch_num)) {\n+                is_true.push(ch_num);\n+            } else {\n+                is_false.push(ch_num);\n+            }\n+        }\n+\n+        s.push_str(&format!(\"    fn {}() {{\\n\", property.to_lowercase()));\n+        generate_asserts(&mut s, property, &is_true, true);\n+        generate_asserts(&mut s, property, &is_false, false);\n+        s.push_str(\"    }\\n\\n\");\n+    }\n+\n+    s.push_str(\"}\");\n+    s\n+}\n+\n+fn generate_asserts(s: &mut String, property: &str, points: &[u32], truthy: bool) {\n+    for range in ranges_from_set(points) {\n+        if range.end == range.start + 1 {\n+            s.push_str(&format!(\n+                \"        assert!({}unicode_data::{}::lookup(std::char::from_u32({}).unwrap()), \\\"{}\\\");\\n\",\n+                if truthy { \"\" } else { \"!\" },\n+                property.to_lowercase(),\n+                range.start,\n+                std::char::from_u32(range.start).unwrap(),\n+        ));\n+        } else {\n+            s.push_str(&format!(\"        for chn in {:?}u32 {{\\n\", range));\n+            s.push_str(&format!(\n+                \"            assert!({}unicode_data::{}::lookup(std::char::from_u32(chn).unwrap()), \\\"{{:?}}\\\", chn);\\n\",\n+                if truthy { \"\" } else { \"!\" },\n+                property.to_lowercase(),\n+        ));\n+            s.push_str(\"        }\\n\");\n+        }\n+    }\n+}\n+\n+fn ranges_from_set(set: &[u32]) -> Vec<Range<u32>> {\n+    let mut ranges = set.iter().map(|e| (*e)..(*e + 1)).collect::<Vec<Range<u32>>>();\n+    merge_ranges(&mut ranges);\n+    ranges\n+}\n+\n fn merge_ranges(ranges: &mut Vec<Range<u32>>) {\n     loop {\n         let mut new_ranges = Vec::new();"}]}