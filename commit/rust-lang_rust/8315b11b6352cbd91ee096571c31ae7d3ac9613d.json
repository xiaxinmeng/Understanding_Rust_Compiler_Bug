{"sha": "8315b11b6352cbd91ee096571c31ae7d3ac9613d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzMTViMTFiNjM1MmNiZDkxZWUwOTY1NzFjMzFhZTdkM2FjOTYxM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-07T09:14:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-07T09:14:12Z"}, "message": "Auto merge of #55549 - RalfJung:miri-visitor, r=oli-obk\n\nValue visitors for miri\n\nGeneralize the traversal part of validation to a `ValueVisitor`.\n\n~~This includes https://github.com/rust-lang/rust/pull/55316, [click here](https://github.com/RalfJung/rust/compare/retagging...RalfJung:miri-visitor) for just the new commits.~~", "tree": {"sha": "d53f27262d56e5ac6f14800ce75bccd8c14970a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d53f27262d56e5ac6f14800ce75bccd8c14970a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8315b11b6352cbd91ee096571c31ae7d3ac9613d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8315b11b6352cbd91ee096571c31ae7d3ac9613d", "html_url": "https://github.com/rust-lang/rust/commit/8315b11b6352cbd91ee096571c31ae7d3ac9613d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8315b11b6352cbd91ee096571c31ae7d3ac9613d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddd4b194a0c28065a277c1f964aa931cc021b5c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddd4b194a0c28065a277c1f964aa931cc021b5c6", "html_url": "https://github.com/rust-lang/rust/commit/ddd4b194a0c28065a277c1f964aa931cc021b5c6"}, {"sha": "7b7c6ceb7595eec801d18c62b7c45c5503452803", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7c6ceb7595eec801d18c62b7c45c5503452803", "html_url": "https://github.com/rust-lang/rust/commit/7b7c6ceb7595eec801d18c62b7c45c5503452803"}], "stats": {"total": 1225, "additions": 786, "deletions": 439}, "files": [{"sha": "f28aa41ed42221a22053b389bd9cbdc429309312", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -15,7 +15,7 @@ use ty::{Ty, layout};\n use ty::layout::{Size, Align, LayoutError};\n use rustc_target::spec::abi::Abi;\n \n-use super::Pointer;\n+use super::{Pointer, Scalar};\n \n use backtrace::Backtrace;\n \n@@ -240,7 +240,7 @@ pub enum EvalErrorKind<'tcx, O> {\n     InvalidMemoryAccess,\n     InvalidFunctionPointer,\n     InvalidBool,\n-    InvalidDiscriminant(u128),\n+    InvalidDiscriminant(Scalar),\n     PointerOutOfBounds {\n         ptr: Pointer,\n         access: bool,"}, {"sha": "e2abf7970d6d821fe9808ac3b2cf4b120fd22eb8", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -91,42 +91,43 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n     }\n \n     //// Trunace the given value to the pointer size; also return whether there was an overflow\n+    #[inline]\n     fn truncate_to_ptr(&self, val: u128) -> (u64, bool) {\n         let max_ptr_plus_1 = 1u128 << self.pointer_size().bits();\n         ((val % max_ptr_plus_1) as u64, val >= max_ptr_plus_1)\n     }\n \n-    // Overflow checking only works properly on the range from -u64 to +u64.\n-    fn overflowing_signed_offset(&self, val: u64, i: i128) -> (u64, bool) {\n-        // FIXME: is it possible to over/underflow here?\n-        if i < 0 {\n-            // trickery to ensure that i64::min_value() works fine\n-            // this formula only works for true negative values, it panics for zero!\n-            let n = u64::max_value() - (i as u64) + 1;\n-            val.overflowing_sub(n)\n-        } else {\n-            self.overflowing_offset(val, i as u64)\n-        }\n+    #[inline]\n+    fn offset<'tcx>(&self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_offset(val, i);\n+        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n \n+    #[inline]\n     fn overflowing_offset(&self, val: u64, i: u64) -> (u64, bool) {\n         let (res, over1) = val.overflowing_add(i);\n-        let (res, over2) = self.truncate_to_ptr(res as u128);\n+        let (res, over2) = self.truncate_to_ptr(u128::from(res));\n         (res, over1 || over2)\n     }\n \n+    #[inline]\n     fn signed_offset<'tcx>(&self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_signed_offset(val, i as i128);\n+        let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n         if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n \n-    fn offset<'tcx>(&self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_offset(val, i);\n-        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n-    }\n-\n-    fn wrapping_signed_offset(&self, val: u64, i: i64) -> u64 {\n-        self.overflowing_signed_offset(val, i as i128).0\n+    // Overflow checking only works properly on the range from -u64 to +u64.\n+    #[inline]\n+    fn overflowing_signed_offset(&self, val: u64, i: i128) -> (u64, bool) {\n+        // FIXME: is it possible to over/underflow here?\n+        if i < 0 {\n+            // trickery to ensure that i64::min_value() works fine\n+            // this formula only works for true negative values, it panics for zero!\n+            let n = u64::max_value() - (i as u64) + 1;\n+            val.overflowing_sub(n)\n+        } else {\n+            self.overflowing_offset(val, i as u64)\n+        }\n     }\n }\n \n@@ -176,19 +177,27 @@ impl<'tcx, Tag> Pointer<Tag> {\n         Pointer { alloc_id, offset, tag }\n     }\n \n-    pub fn wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n-        Pointer::new_with_tag(\n+    #[inline]\n+    pub fn offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+        Ok(Pointer::new_with_tag(\n             self.alloc_id,\n-            Size::from_bytes(cx.data_layout().wrapping_signed_offset(self.offset.bytes(), i)),\n-            self.tag,\n-        )\n+            Size::from_bytes(cx.data_layout().offset(self.offset.bytes(), i.bytes())?),\n+            self.tag\n+        ))\n     }\n \n-    pub fn overflowing_signed_offset(self, i: i128, cx: &impl HasDataLayout) -> (Self, bool) {\n-        let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset.bytes(), i);\n+    #[inline]\n+    pub fn overflowing_offset(self, i: Size, cx: &impl HasDataLayout) -> (Self, bool) {\n+        let (res, over) = cx.data_layout().overflowing_offset(self.offset.bytes(), i.bytes());\n         (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n     }\n \n+    #[inline(always)]\n+    pub fn wrapping_offset(self, i: Size, cx: &impl HasDataLayout) -> Self {\n+        self.overflowing_offset(i, cx).0\n+    }\n+\n+    #[inline]\n     pub fn signed_offset(self, i: i64, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         Ok(Pointer::new_with_tag(\n             self.alloc_id,\n@@ -197,20 +206,18 @@ impl<'tcx, Tag> Pointer<Tag> {\n         ))\n     }\n \n-    pub fn overflowing_offset(self, i: Size, cx: &impl HasDataLayout) -> (Self, bool) {\n-        let (res, over) = cx.data_layout().overflowing_offset(self.offset.bytes(), i.bytes());\n+    #[inline]\n+    pub fn overflowing_signed_offset(self, i: i128, cx: &impl HasDataLayout) -> (Self, bool) {\n+        let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset.bytes(), i);\n         (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n     }\n \n-    pub fn offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n-        Ok(Pointer::new_with_tag(\n-            self.alloc_id,\n-            Size::from_bytes(cx.data_layout().offset(self.offset.bytes(), i.bytes())?),\n-            self.tag\n-        ))\n+    #[inline(always)]\n+    pub fn wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n+        self.overflowing_signed_offset(i128::from(i), cx).0\n     }\n \n-    #[inline]\n+    #[inline(always)]\n     pub fn erase_tag(self) -> Pointer {\n         Pointer { alloc_id: self.alloc_id, offset: self.offset, tag: () }\n     }"}, {"sha": "3f5399396abcf837ea2f3b874427cd197ffae868", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unknown_lints)]\n+use std::fmt;\n \n use ty::layout::{HasDataLayout, Size};\n use ty::subst::Substs;\n@@ -99,6 +99,15 @@ pub enum Scalar<Tag=(), Id=AllocId> {\n     Ptr(Pointer<Tag, Id>),\n }\n \n+impl<Tag> fmt::Display for Scalar<Tag> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Scalar::Ptr(_) => write!(f, \"a pointer\"),\n+            Scalar::Bits { bits, .. } => write!(f, \"{}\", bits),\n+        }\n+    }\n+}\n+\n impl<'tcx> Scalar<()> {\n     #[inline]\n     pub fn with_default_tag<Tag>(self) -> Scalar<Tag>\n@@ -134,32 +143,47 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n \n     #[inline]\n-    pub fn ptr_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let dl = cx.data_layout();\n         match self {\n             Scalar::Bits { bits, size } => {\n                 assert_eq!(size as u64, dl.pointer_size.bytes());\n                 Ok(Scalar::Bits {\n-                    bits: dl.signed_offset(bits as u64, i)? as u128,\n+                    bits: dl.offset(bits as u64, i.bytes())? as u128,\n                     size,\n                 })\n             }\n-            Scalar::Ptr(ptr) => ptr.signed_offset(i, dl).map(Scalar::Ptr),\n+            Scalar::Ptr(ptr) => ptr.offset(i, dl).map(Scalar::Ptr),\n         }\n     }\n \n     #[inline]\n-    pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_wrapping_offset(self, i: Size, cx: &impl HasDataLayout) -> Self {\n         let dl = cx.data_layout();\n         match self {\n             Scalar::Bits { bits, size } => {\n                 assert_eq!(size as u64, dl.pointer_size.bytes());\n+                Scalar::Bits {\n+                    bits: dl.overflowing_offset(bits as u64, i.bytes()).0 as u128,\n+                    size,\n+                }\n+            }\n+            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.wrapping_offset(i, dl)),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn ptr_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+        let dl = cx.data_layout();\n+        match self {\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(size as u64, dl.pointer_size().bytes());\n                 Ok(Scalar::Bits {\n-                    bits: dl.offset(bits as u64, i.bytes())? as u128,\n+                    bits: dl.signed_offset(bits as u64, i)? as u128,\n                     size,\n                 })\n             }\n-            Scalar::Ptr(ptr) => ptr.offset(i, dl).map(Scalar::Ptr),\n+            Scalar::Ptr(ptr) => ptr.signed_offset(i, dl).map(Scalar::Ptr),\n         }\n     }\n \n@@ -170,14 +194,27 @@ impl<'tcx, Tag> Scalar<Tag> {\n             Scalar::Bits { bits, size } => {\n                 assert_eq!(size as u64, dl.pointer_size.bytes());\n                 Scalar::Bits {\n-                    bits: dl.wrapping_signed_offset(bits as u64, i) as u128,\n+                    bits: dl.overflowing_signed_offset(bits as u64, i128::from(i)).0 as u128,\n                     size,\n                 }\n             }\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.wrapping_signed_offset(i, dl)),\n         }\n     }\n \n+    /// Returns this pointers offset from the allocation base, or from NULL (for\n+    /// integer pointers).\n+    #[inline]\n+    pub fn get_ptr_offset(self, cx: &impl HasDataLayout) -> Size {\n+        match self {\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(size as u64, cx.pointer_size().bytes());\n+                Size::from_bytes(bits as u64)\n+            }\n+            Scalar::Ptr(ptr) => ptr.offset,\n+        }\n+    }\n+\n     #[inline]\n     pub fn is_null_ptr(self, cx: &impl HasDataLayout) -> bool {\n         match self {"}, {"sha": "011887090eefe8002f3ffffc9b02f2ef415b718c", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -539,10 +539,10 @@ fn validate_const<'a, 'tcx>(\n     let val = (|| {\n         let op = ecx.const_to_op(constant)?;\n         let mut ref_tracking = RefTracking::new(op);\n-        while let Some((op, mut path)) = ref_tracking.todo.pop() {\n+        while let Some((op, path)) = ref_tracking.todo.pop() {\n             ecx.validate_operand(\n                 op,\n-                &mut path,\n+                path,\n                 Some(&mut ref_tracking),\n                 /* const_mode */ true,\n             )?;"}, {"sha": "e6267012dc27587848c9b42c105f429b2cb8ded8", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -521,7 +521,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                 // return place is always a local and then this cannot happen.\n                 self.validate_operand(\n                     self.place_to_op(return_place)?,\n-                    &mut vec![],\n+                    vec![],\n                     None,\n                     /*const_mode*/false,\n                 )?;"}, {"sha": "27cf28ef41e8ac3a261d2d0a0a1d01dd3cdc97b7", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -17,11 +17,11 @@ use std::hash::Hash;\n \n use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n-use rustc::ty::{self, Ty, layout::{Size, TyLayout}, query::TyCtxtAt};\n+use rustc::ty::{self, layout::{Size, TyLayout}, query::TyCtxtAt};\n \n use super::{\n     Allocation, AllocId, EvalResult, Scalar,\n-    EvalContext, PlaceTy, OpTy, Pointer, MemPlace, MemoryKind,\n+    EvalContext, PlaceTy, MPlaceTy, OpTy, Pointer, MemoryKind,\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -217,26 +217,22 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     #[inline]\n     fn tag_reference(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        place: MemPlace<Self::PointerTag>,\n-        _ty: Ty<'tcx>,\n-        _size: Size,\n+        place: MPlaceTy<'tcx, Self::PointerTag>,\n         _mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, MemPlace<Self::PointerTag>> {\n-        Ok(place)\n+    ) -> EvalResult<'tcx, Scalar<Self::PointerTag>> {\n+        Ok(place.ptr)\n     }\n \n     /// Executed when evaluating the `*` operator: Following a reference.\n-    /// This has the change to adjust the tag.  It should not change anything else!\n+    /// This has the chance to adjust the tag.  It should not change anything else!\n     /// `mutability` can be `None` in case a raw ptr is being dereferenced.\n     #[inline]\n     fn tag_dereference(\n         _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n-        place: MemPlace<Self::PointerTag>,\n-        _ty: Ty<'tcx>,\n-        _size: Size,\n+        place: MPlaceTy<'tcx, Self::PointerTag>,\n         _mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, MemPlace<Self::PointerTag>> {\n-        Ok(place)\n+    ) -> EvalResult<'tcx, Scalar<Self::PointerTag>> {\n+        Ok(place.ptr)\n     }\n \n     /// Execute a validation operation"}, {"sha": "82fe08fa038a4ad32c9deba323f34c4214aab597", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -23,6 +23,7 @@ mod terminator;\n mod traits;\n mod validity;\n mod intrinsics;\n+mod visitor;\n \n pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n@@ -38,4 +39,6 @@ pub use self::machine::{Machine, AllocMap, MayLeak};\n \n pub use self::operand::{ScalarMaybeUndef, Immediate, ImmTy, Operand, OpTy};\n \n+pub use self::visitor::ValueVisitor;\n+\n pub use self::validity::RefTracking;"}, {"sha": "83a2d14b7ca4cdf9896d81e46758e697b6b67de0", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -12,6 +12,7 @@\n //! All high-level functions to read from memory work on operands as sources.\n \n use std::convert::TryInto;\n+use std::fmt;\n \n use rustc::{mir, ty};\n use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt};\n@@ -36,6 +37,15 @@ impl<Tag> From<Scalar<Tag>> for ScalarMaybeUndef<Tag> {\n     }\n }\n \n+impl<Tag> fmt::Display for ScalarMaybeUndef<Tag> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            ScalarMaybeUndef::Undef => write!(f, \"uninitialized bytes\"),\n+            ScalarMaybeUndef::Scalar(s) => write!(f, \"{}\", s),\n+        }\n+    }\n+}\n+\n impl<'tcx> ScalarMaybeUndef<()> {\n     #[inline]\n     pub fn with_default_tag<Tag>(self) -> ScalarMaybeUndef<Tag>\n@@ -732,8 +742,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         Ok(match rval.layout.variants {\n             layout::Variants::Single { .. } => bug!(),\n             layout::Variants::Tagged { .. } => {\n+                let bits_discr = match raw_discr.to_bits(discr_val.layout.size) {\n+                    Ok(raw_discr) => raw_discr,\n+                    Err(_) => return err!(InvalidDiscriminant(raw_discr.erase_tag())),\n+                };\n                 let real_discr = if discr_val.layout.ty.is_signed() {\n-                    let i = raw_discr.to_bits(discr_val.layout.size)? as i128;\n+                    let i = bits_discr as i128;\n                     // going from layout tag type to typeck discriminant type\n                     // requires first sign extending with the layout discriminant\n                     let shift = 128 - discr_val.layout.size.bits();\n@@ -748,15 +762,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     let truncatee = sexted as u128;\n                     (truncatee << shift) >> shift\n                 } else {\n-                    raw_discr.to_bits(discr_val.layout.size)?\n+                    bits_discr\n                 };\n                 // Make sure we catch invalid discriminants\n                 let index = rval.layout.ty\n                     .ty_adt_def()\n                     .expect(\"tagged layout for non adt\")\n                     .discriminants(self.tcx.tcx)\n                     .position(|var| var.val == real_discr)\n-                    .ok_or_else(|| EvalErrorKind::InvalidDiscriminant(real_discr))?;\n+                    .ok_or_else(|| EvalErrorKind::InvalidDiscriminant(raw_discr.erase_tag()))?;\n                 (real_discr, index)\n             },\n             layout::Variants::NicheFilling {"}, {"sha": "19430c85cf73c20877b02ab7451bcb0e19f82a2a", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -278,42 +278,34 @@ where\n         let meta = val.to_meta()?;\n         let ptr = val.to_scalar_ptr()?;\n         let mplace = MemPlace { ptr, align, meta };\n+        let mut mplace = MPlaceTy { mplace, layout };\n         // Pointer tag tracking might want to adjust the tag.\n-        let mplace = if M::ENABLE_PTR_TRACKING_HOOKS {\n-            let (size, _) = self.size_and_align_of(meta, layout)?\n-                // for extern types, just cover what we can\n-                .unwrap_or_else(|| layout.size_and_align());\n+        if M::ENABLE_PTR_TRACKING_HOOKS {\n             let mutbl = match val.layout.ty.sty {\n                 // `builtin_deref` considers boxes immutable, that's useless for our purposes\n                 ty::Ref(_, _, mutbl) => Some(mutbl),\n                 ty::Adt(def, _) if def.is_box() => Some(hir::MutMutable),\n                 ty::RawPtr(_) => None,\n                 _ => bug!(\"Unexpected pointer type {}\", val.layout.ty.sty),\n             };\n-            M::tag_dereference(self, mplace, pointee_type, size, mutbl)?\n-        } else {\n-            mplace\n-        };\n-        Ok(MPlaceTy { mplace, layout })\n+            mplace.mplace.ptr = M::tag_dereference(self, mplace, mutbl)?;\n+        }\n+        // Done\n+        Ok(mplace)\n     }\n \n     /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n     /// This is the inverse of `ref_to_mplace`.\n     /// `mutbl` indicates whether we are create a shared or mutable ref, or a raw pointer (`None`).\n     pub fn create_ref(\n         &mut self,\n-        place: MPlaceTy<'tcx, M::PointerTag>,\n+        mut place: MPlaceTy<'tcx, M::PointerTag>,\n         mutbl: Option<hir::Mutability>,\n     ) -> EvalResult<'tcx, Immediate<M::PointerTag>> {\n         // Pointer tag tracking might want to adjust the tag\n-        let place = if M::ENABLE_PTR_TRACKING_HOOKS {\n-            let (size, _) = self.size_and_align_of_mplace(place)?\n-                // for extern types, just cover what we can\n-                .unwrap_or_else(|| place.layout.size_and_align());\n-            M::tag_reference(self, *place, place.layout.ty, size, mutbl)?\n-        } else {\n-            *place\n-        };\n+        if M::ENABLE_PTR_TRACKING_HOOKS {\n+            place.mplace.ptr = M::tag_reference(self, place, mutbl)?\n+        }\n         Ok(match place.meta {\n             None => Immediate::Scalar(place.ptr.into()),\n             Some(meta) => Immediate::ScalarPair(place.ptr.into(), meta.into()),\n@@ -489,6 +481,8 @@ where\n \n     /// Get the place of a field inside the place, and also the field's type.\n     /// Just a convenience function, but used quite a bit.\n+    /// This is the only projection that might have a side-effect: We cannot project\n+    /// into the field of a local `ScalarPair`, we have to first allocate it.\n     pub fn place_field(\n         &mut self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n@@ -501,7 +495,7 @@ where\n     }\n \n     pub fn place_downcast(\n-        &mut self,\n+        &self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n         variant: usize,\n     ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n@@ -643,7 +637,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, &mut vec![], None, /*const_mode*/false)?;\n+            self.validate_operand(self.place_to_op(dest)?, vec![], None, /*const_mode*/false)?;\n         }\n \n         Ok(())\n@@ -765,7 +759,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, &mut vec![], None, /*const_mode*/false)?;\n+            self.validate_operand(self.place_to_op(dest)?, vec![], None, /*const_mode*/false)?;\n         }\n \n         Ok(())\n@@ -843,7 +837,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into(), &mut vec![], None, /*const_mode*/false)?;\n+            self.validate_operand(dest.into(), vec![], None, /*const_mode*/false)?;\n         }\n \n         Ok(())"}, {"sha": "8c8b3e2ca77c49ddea6244d1ce8318a12a25a195", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 269, "deletions": 315, "changes": 584, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -20,12 +20,12 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    ImmTy, OpTy, MPlaceTy, Machine, EvalContext, ScalarMaybeUndef\n+    OpTy, MPlaceTy, ImmTy, Machine, EvalContext, ValueVisitor\n };\n \n macro_rules! validation_failure {\n     ($what:expr, $where:expr, $details:expr) => {{\n-        let where_ = path_format($where);\n+        let where_ = path_format(&$where);\n         let where_ = if where_.is_empty() {\n             String::new()\n         } else {\n@@ -37,7 +37,7 @@ macro_rules! validation_failure {\n         )))\n     }};\n     ($what:expr, $where:expr) => {{\n-        let where_ = path_format($where);\n+        let where_ = path_format(&$where);\n         let where_ = if where_.is_empty() {\n             String::new()\n         } else {\n@@ -78,6 +78,7 @@ pub enum PathElem {\n     TupleElem(usize),\n     Deref,\n     Tag,\n+    DynDowncast,\n }\n \n /// State for tracking recursive validation of references\n@@ -97,80 +98,162 @@ impl<'tcx, Tag: Copy+Eq+Hash> RefTracking<'tcx, Tag> {\n     }\n }\n \n-// Adding a Deref and making a copy of the path to be put into the queue\n-// always go together.  This one does it with only new allocation.\n-fn path_clone_and_deref(path: &Vec<PathElem>) -> Vec<PathElem> {\n-    let mut new_path = Vec::with_capacity(path.len()+1);\n-    new_path.clone_from(path);\n-    new_path.push(PathElem::Deref);\n-    new_path\n-}\n-\n /// Format a path\n fn path_format(path: &Vec<PathElem>) -> String {\n     use self::PathElem::*;\n \n     let mut out = String::new();\n     for elem in path.iter() {\n         match elem {\n-            Field(name) => write!(out, \".{}\", name).unwrap(),\n-            ClosureVar(name) => write!(out, \".<closure-var({})>\", name).unwrap(),\n-            TupleElem(idx) => write!(out, \".{}\", idx).unwrap(),\n-            ArrayElem(idx) => write!(out, \"[{}]\", idx).unwrap(),\n+            Field(name) => write!(out, \".{}\", name),\n+            ClosureVar(name) => write!(out, \".<closure-var({})>\", name),\n+            TupleElem(idx) => write!(out, \".{}\", idx),\n+            ArrayElem(idx) => write!(out, \"[{}]\", idx),\n             Deref =>\n                 // This does not match Rust syntax, but it is more readable for long paths -- and\n                 // some of the other items here also are not Rust syntax.  Actually we can't\n                 // even use the usual syntax because we are just showing the projections,\n                 // not the root.\n-                write!(out, \".<deref>\").unwrap(),\n-            Tag => write!(out, \".<enum-tag>\").unwrap(),\n-        }\n+                write!(out, \".<deref>\"),\n+            Tag => write!(out, \".<enum-tag>\"),\n+            DynDowncast => write!(out, \".<dyn-downcast>\"),\n+        }.unwrap()\n     }\n     out\n }\n \n-fn scalar_format<Tag>(value: ScalarMaybeUndef<Tag>) -> String {\n-    match value {\n-        ScalarMaybeUndef::Undef =>\n-            \"uninitialized bytes\".to_owned(),\n-        ScalarMaybeUndef::Scalar(Scalar::Ptr(_)) =>\n-            \"a pointer\".to_owned(),\n-        ScalarMaybeUndef::Scalar(Scalar::Bits { bits, .. }) =>\n-            bits.to_string(),\n+struct ValidityVisitor<'rt, 'a: 'rt, 'mir: 'rt, 'tcx: 'a+'rt+'mir, M: Machine<'a, 'mir, 'tcx>+'rt> {\n+    /// The `path` may be pushed to, but the part that is present when a function\n+    /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n+    /// this stack discipline.\n+    path: Vec<PathElem>,\n+    ref_tracking: Option<&'rt mut RefTracking<'tcx, M::PointerTag>>,\n+    const_mode: bool,\n+    ecx: &'rt EvalContext<'a, 'mir, 'tcx, M>,\n+}\n+\n+impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, 'mir, 'tcx, M> {\n+    fn push_aggregate_field_path_elem(\n+        &mut self,\n+        layout: TyLayout<'tcx>,\n+        field: usize,\n+    ) {\n+        let elem = match layout.ty.sty {\n+            // generators and closures.\n+            ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n+                if let Some(upvar) = self.ecx.tcx.optimized_mir(def_id).upvar_decls.get(field) {\n+                    PathElem::ClosureVar(upvar.debug_name)\n+                } else {\n+                    // Sometimes the index is beyond the number of freevars (seen\n+                    // for a generator).\n+                    PathElem::ClosureVar(Symbol::intern(&field.to_string()))\n+                }\n+            }\n+\n+            // tuples\n+            ty::Tuple(_) => PathElem::TupleElem(field),\n+\n+            // enums\n+            ty::Adt(def, ..) if def.is_enum() => {\n+                // we might be projecting *to* a variant, or to a field *in*a variant.\n+                match layout.variants {\n+                    layout::Variants::Single { index } =>\n+                        // Inside a variant\n+                        PathElem::Field(def.variants[index].fields[field].ident.name),\n+                    _ =>\n+                        // To a variant\n+                        PathElem::Field(def.variants[field].name)\n+                }\n+            }\n+\n+            // other ADTs\n+            ty::Adt(def, _) => PathElem::Field(def.non_enum_variant().fields[field].ident.name),\n+\n+            // arrays/slices\n+            ty::Array(..) | ty::Slice(..) => PathElem::ArrayElem(field),\n+\n+            // dyn traits\n+            ty::Dynamic(..) => PathElem::DynDowncast,\n+\n+            // nothing else has an aggregate layout\n+            _ => bug!(\"aggregate_field_path_elem: got non-aggregate type {:?}\", layout.ty),\n+        };\n+        self.path.push(elem);\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    /// Make sure that `value` is valid for `ty`, *assuming* `ty` is a primitive type.\n-    fn validate_primitive_type(\n-        &self,\n-        value: ImmTy<'tcx, M::PointerTag>,\n-        path: &Vec<PathElem>,\n-        ref_tracking: Option<&mut RefTracking<'tcx, M::PointerTag>>,\n-        const_mode: bool,\n+impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n+    ValueVisitor<'a, 'mir, 'tcx, M> for ValidityVisitor<'rt, 'a, 'mir, 'tcx, M>\n+{\n+    type V = OpTy<'tcx, M::PointerTag>;\n+\n+    #[inline(always)]\n+    fn ecx(&self) -> &EvalContext<'a, 'mir, 'tcx, M> {\n+        &self.ecx\n+    }\n+\n+    #[inline]\n+    fn visit_field(\n+        &mut self,\n+        old_op: OpTy<'tcx, M::PointerTag>,\n+        field: usize,\n+        new_op: OpTy<'tcx, M::PointerTag>\n     ) -> EvalResult<'tcx> {\n+        // Remember the old state\n+        let path_len = self.path.len();\n+        // Perform operation\n+        self.push_aggregate_field_path_elem(old_op.layout, field);\n+        self.visit_value(new_op)?;\n+        // Undo changes\n+        self.path.truncate(path_len);\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn visit_value(&mut self, op: OpTy<'tcx, M::PointerTag>) -> EvalResult<'tcx>\n+    {\n+        trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n+        // Translate some possible errors to something nicer.\n+        match self.walk_value(op) {\n+            Ok(()) => Ok(()),\n+            Err(err) => match err.kind {\n+                EvalErrorKind::InvalidDiscriminant(val) =>\n+                    validation_failure!(\n+                        val, self.path, \"a valid enum discriminant\"\n+                    ),\n+                EvalErrorKind::ReadPointerAsBytes =>\n+                    validation_failure!(\n+                        \"a pointer\", self.path, \"plain bytes\"\n+                    ),\n+                _ => Err(err),\n+            }\n+        }\n+    }\n+\n+    fn visit_primitive(&mut self, value: ImmTy<'tcx, M::PointerTag>) -> EvalResult<'tcx>\n+    {\n         // Go over all the primitive types\n         let ty = value.layout.ty;\n         match ty.sty {\n             ty::Bool => {\n                 let value = value.to_scalar_or_undef();\n                 try_validation!(value.to_bool(),\n-                    scalar_format(value), path, \"a boolean\");\n+                    value, self.path, \"a boolean\");\n             },\n             ty::Char => {\n                 let value = value.to_scalar_or_undef();\n                 try_validation!(value.to_char(),\n-                    scalar_format(value), path, \"a valid unicode codepoint\");\n+                    value, self.path, \"a valid unicode codepoint\");\n             },\n             ty::Float(_) | ty::Int(_) | ty::Uint(_) => {\n                 // NOTE: Keep this in sync with the array optimization for int/float\n                 // types below!\n                 let size = value.layout.size;\n                 let value = value.to_scalar_or_undef();\n-                if const_mode {\n+                if self.const_mode {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n                     try_validation!(value.to_bits(size),\n-                        scalar_format(value), path, \"initialized plain bits\");\n+                        value, self.path, \"initialized plain bits\");\n                 } else {\n                     // At run-time, for now, we accept *anything* for these types, including\n                     // undef. We should fix that, but let's start low.\n@@ -180,33 +263,33 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 // No undef allowed here.  Eventually this should be consistent with\n                 // the integer types.\n                 let _ptr = try_validation!(value.to_scalar_ptr(),\n-                    \"undefined address in pointer\", path);\n+                    \"undefined address in pointer\", self.path);\n                 let _meta = try_validation!(value.to_meta(),\n-                    \"uninitialized data in fat pointer metadata\", path);\n+                    \"uninitialized data in fat pointer metadata\", self.path);\n             }\n             _ if ty.is_box() || ty.is_region_ptr() => {\n                 // Handle fat pointers.\n                 // Check metadata early, for better diagnostics\n                 let ptr = try_validation!(value.to_scalar_ptr(),\n-                    \"undefined address in pointer\", path);\n+                    \"undefined address in pointer\", self.path);\n                 let meta = try_validation!(value.to_meta(),\n-                    \"uninitialized data in fat pointer metadata\", path);\n-                let layout = self.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n+                    \"uninitialized data in fat pointer metadata\", self.path);\n+                let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n                 if layout.is_unsized() {\n-                    let tail = self.tcx.struct_tail(layout.ty);\n+                    let tail = self.ecx.tcx.struct_tail(layout.ty);\n                     match tail.sty {\n                         ty::Dynamic(..) => {\n                             let vtable = try_validation!(meta.unwrap().to_ptr(),\n-                                \"non-pointer vtable in fat pointer\", path);\n-                            try_validation!(self.read_drop_type_from_vtable(vtable),\n-                                \"invalid drop fn in vtable\", path);\n-                            try_validation!(self.read_size_and_align_from_vtable(vtable),\n-                                \"invalid size or align in vtable\", path);\n+                                \"non-pointer vtable in fat pointer\", self.path);\n+                            try_validation!(self.ecx.read_drop_type_from_vtable(vtable),\n+                                \"invalid drop fn in vtable\", self.path);\n+                            try_validation!(self.ecx.read_size_and_align_from_vtable(vtable),\n+                                \"invalid size or align in vtable\", self.path);\n                             // FIXME: More checks for the vtable.\n                         }\n                         ty::Slice(..) | ty::Str => {\n-                            try_validation!(meta.unwrap().to_usize(self),\n-                                \"non-integer slice length in fat pointer\", path);\n+                            try_validation!(meta.unwrap().to_usize(self.ecx),\n+                                \"non-integer slice length in fat pointer\", self.path);\n                         }\n                         ty::Foreign(..) => {\n                             // Unsized, but not fat.\n@@ -216,55 +299,55 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     }\n                 }\n                 // Make sure this is non-NULL and aligned\n-                let (size, align) = self.size_and_align_of(meta, layout)?\n+                let (size, align) = self.ecx.size_and_align_of(meta, layout)?\n                     // for the purpose of validity, consider foreign types to have\n                     // alignment and size determined by the layout (size will be 0,\n                     // alignment should take attributes into account).\n                     .unwrap_or_else(|| layout.size_and_align());\n-                match self.memory.check_align(ptr, align) {\n+                match self.ecx.memory.check_align(ptr, align) {\n                     Ok(_) => {},\n                     Err(err) => {\n                         error!(\"{:?} is not aligned to {:?}\", ptr, align);\n                         match err.kind {\n                             EvalErrorKind::InvalidNullPointerUsage =>\n-                                return validation_failure!(\"NULL reference\", path),\n+                                return validation_failure!(\"NULL reference\", self.path),\n                             EvalErrorKind::AlignmentCheckFailed { .. } =>\n-                                return validation_failure!(\"unaligned reference\", path),\n+                                return validation_failure!(\"unaligned reference\", self.path),\n                             _ =>\n                                 return validation_failure!(\n                                     \"dangling (out-of-bounds) reference (might be NULL at \\\n                                         run-time)\",\n-                                    path\n+                                    self.path\n                                 ),\n                         }\n                     }\n                 }\n                 // Turn ptr into place.\n                 // `ref_to_mplace` also calls the machine hook for (re)activating the tag,\n                 // which in turn will (in full miri) check if the pointer is dereferencable.\n-                let place = self.ref_to_mplace(value)?;\n+                let place = self.ecx.ref_to_mplace(value)?;\n                 // Recursive checking\n-                if let Some(ref_tracking) = ref_tracking {\n-                    assert!(const_mode, \"We should only do recursie checking in const mode\");\n+                if let Some(ref mut ref_tracking) = self.ref_tracking {\n+                    assert!(self.const_mode, \"We should only do recursie checking in const mode\");\n                     if size != Size::ZERO {\n                         // Non-ZST also have to be dereferencable\n                         let ptr = try_validation!(place.ptr.to_ptr(),\n-                            \"integer pointer in non-ZST reference\", path);\n+                            \"integer pointer in non-ZST reference\", self.path);\n                         // Skip validation entirely for some external statics\n-                        let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                        let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n                         if let Some(AllocType::Static(did)) = alloc_kind {\n                             // `extern static` cannot be validated as they have no body.\n                             // FIXME: Statics from other crates are also skipped.\n                             // They might be checked at a different type, but for now we\n                             // want to avoid recursing too deeply.  This is not sound!\n-                            if !did.is_local() || self.tcx.is_foreign_item(did) {\n+                            if !did.is_local() || self.ecx.tcx.is_foreign_item(did) {\n                                 return Ok(());\n                             }\n                         }\n                         // Maintain the invariant that the place we are checking is\n                         // already verified to be in-bounds.\n-                        try_validation!(self.memory.check_bounds(ptr, size, false),\n-                            \"dangling (not entirely in bounds) reference\", path);\n+                        try_validation!(self.ecx.memory.check_bounds(ptr, size, false),\n+                            \"dangling (not entirely in bounds) reference\", self.path);\n                     }\n                     // Check if we have encountered this pointer+layout combination\n                     // before.  Proceed recursively even for integer pointers, no\n@@ -273,35 +356,45 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     let op = place.into();\n                     if ref_tracking.seen.insert(op) {\n                         trace!(\"Recursing below ptr {:#?}\", *op);\n-                        ref_tracking.todo.push((op, path_clone_and_deref(path)));\n+                        // We need to clone the path anyway, make sure it gets created\n+                        // with enough space for the additional `Deref`.\n+                        let mut new_path = Vec::with_capacity(self.path.len()+1);\n+                        new_path.clone_from(&self.path);\n+                        new_path.push(PathElem::Deref);\n+                        // Remember to come back to this later.\n+                        ref_tracking.todo.push((op, new_path));\n                     }\n                 }\n             }\n             ty::FnPtr(_sig) => {\n                 let value = value.to_scalar_or_undef();\n                 let ptr = try_validation!(value.to_ptr(),\n-                    scalar_format(value), path, \"a pointer\");\n-                let _fn = try_validation!(self.memory.get_fn(ptr),\n-                    scalar_format(value), path, \"a function pointer\");\n+                    value, self.path, \"a pointer\");\n+                let _fn = try_validation!(self.ecx.memory.get_fn(ptr),\n+                    value, self.path, \"a function pointer\");\n                 // FIXME: Check if the signature matches\n             }\n             // This should be all the primitive types\n-            ty::Never => bug!(\"Uninhabited type should have been caught earlier\"),\n             _ => bug!(\"Unexpected primitive type {}\", value.layout.ty)\n         }\n         Ok(())\n     }\n \n-    /// Make sure that `value` matches the\n-    fn validate_scalar_layout(\n-        &self,\n-        value: ScalarMaybeUndef<M::PointerTag>,\n-        size: Size,\n-        path: &Vec<PathElem>,\n+    fn visit_uninhabited(&mut self) -> EvalResult<'tcx>\n+    {\n+        validation_failure!(\"a value of an uninhabited type\", self.path)\n+    }\n+\n+    fn visit_scalar(\n+        &mut self,\n+        op: OpTy<'tcx, M::PointerTag>,\n         layout: &layout::Scalar,\n     ) -> EvalResult<'tcx> {\n+        let value = self.ecx.read_scalar(op)?;\n+        // Determine the allowed range\n         let (lo, hi) = layout.valid_range.clone().into_inner();\n-        let max_hi = u128::max_value() >> (128 - size.bits()); // as big as the size fits\n+        // `max_hi` is as big as the size fits\n+        let max_hi = u128::max_value() >> (128 - op.layout.size.bits());\n         assert!(hi <= max_hi);\n         // We could also write `(hi + 1) % (max_hi + 1) == lo` but `max_hi + 1` overflows for `u128`\n         if (lo == 0 && hi == max_hi) || (hi + 1 == lo) {\n@@ -310,38 +403,39 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         }\n         // At least one value is excluded. Get the bits.\n         let value = try_validation!(value.not_undef(),\n-            scalar_format(value), path, format!(\"something in the range {:?}\", layout.valid_range));\n+            value, self.path,\n+            format!(\"something in the range {:?}\", layout.valid_range));\n         let bits = match value {\n             Scalar::Ptr(ptr) => {\n                 if lo == 1 && hi == max_hi {\n                     // only NULL is not allowed.\n                     // We can call `check_align` to check non-NULL-ness, but have to also look\n                     // for function pointers.\n                     let non_null =\n-                        self.memory.check_align(\n+                        self.ecx.memory.check_align(\n                             Scalar::Ptr(ptr), Align::from_bytes(1, 1).unwrap()\n                         ).is_ok() ||\n-                        self.memory.get_fn(ptr).is_ok();\n+                        self.ecx.memory.get_fn(ptr).is_ok();\n                     if !non_null {\n                         // could be NULL\n-                        return validation_failure!(\"a potentially NULL pointer\", path);\n+                        return validation_failure!(\"a potentially NULL pointer\", self.path);\n                     }\n                     return Ok(());\n                 } else {\n                     // Conservatively, we reject, because the pointer *could* have this\n                     // value.\n                     return validation_failure!(\n                         \"a pointer\",\n-                        path,\n+                        self.path,\n                         format!(\n                             \"something that cannot possibly be outside the (wrapping) range {:?}\",\n                             layout.valid_range\n                         )\n                     );\n                 }\n             }\n-            Scalar::Bits { bits, size: value_size } => {\n-                assert_eq!(value_size as u64, size.bytes());\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(size as u64, op.layout.size.bytes());\n                 bits\n             }\n         };\n@@ -355,7 +449,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             } else {\n                 validation_failure!(\n                     bits,\n-                    path,\n+                    self.path,\n                     format!(\"something in the range {:?} or {:?}\", 0..=hi, lo..=max_hi)\n                 )\n             }\n@@ -365,7 +459,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             } else {\n                 validation_failure!(\n                     bits,\n-                    path,\n+                    self.path,\n                     if hi == max_hi {\n                         format!(\"something greater or equal to {}\", lo)\n                     } else {\n@@ -376,250 +470,110 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         }\n     }\n \n-    /// This function checks the data at `op`.  `op` is assumed to cover valid memory if it\n-    /// is an indirect operand.\n-    /// It will error if the bits at the destination do not match the ones described by the layout.\n-    /// The `path` may be pushed to, but the part that is present when the function\n-    /// starts must not be changed!\n-    ///\n-    /// `ref_tracking` can be None to avoid recursive checking below references.\n-    /// This also toggles between \"run-time\" (no recursion) and \"compile-time\" (with recursion)\n-    /// validation (e.g., pointer values are fine in integers at runtime).\n-    pub fn validate_operand(\n-        &self,\n-        dest: OpTy<'tcx, M::PointerTag>,\n-        path: &mut Vec<PathElem>,\n-        mut ref_tracking: Option<&mut RefTracking<'tcx, M::PointerTag>>,\n-        const_mode: bool,\n+    fn visit_aggregate(\n+        &mut self,\n+        op: OpTy<'tcx, M::PointerTag>,\n+        fields: impl Iterator<Item=EvalResult<'tcx, Self::V>>,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"validate_operand: {:?}, {:?}\", *dest, dest.layout.ty);\n-\n-        // If this is a multi-variant layout, we have find the right one and proceed with that.\n-        // (No good reasoning to make this recursion, but it is equivalent to that.)\n-        let dest = match dest.layout.variants {\n-            layout::Variants::NicheFilling { .. } |\n-            layout::Variants::Tagged { .. } => {\n-                let variant = match self.read_discriminant(dest) {\n-                    Ok(res) => res.1,\n-                    Err(err) => match err.kind {\n-                        EvalErrorKind::InvalidDiscriminant(val) =>\n-                            return validation_failure!(\n-                                format!(\"invalid enum discriminant {}\", val), path\n-                            ),\n-                        _ =>\n-                            return validation_failure!(\n-                                String::from(\"non-integer enum discriminant\"), path\n-                            ),\n-                    }\n-                };\n-                // Put the variant projection onto the path, as a field\n-                path.push(PathElem::Field(dest.layout.ty\n-                                          .ty_adt_def()\n-                                          .unwrap()\n-                                          .variants[variant].name));\n-                // Proceed with this variant\n-                let dest = self.operand_downcast(dest, variant)?;\n-                trace!(\"variant layout: {:#?}\", dest.layout);\n-                dest\n-            },\n-            layout::Variants::Single { .. } => dest,\n-        };\n-\n-        // First thing, find the real type:\n-        // If it is a trait object, switch to the actual type that was used to create it.\n-        let dest = match dest.layout.ty.sty {\n-            ty::Dynamic(..) => {\n-                let dest = dest.to_mem_place(); // immediate trait objects are not a thing\n-                self.unpack_dyn_trait(dest)?.1.into()\n-            },\n-            _ => dest\n-        };\n-\n-        // If this is a scalar, validate the scalar layout.\n-        // Things can be aggregates and have scalar layout at the same time, and that\n-        // is very relevant for `NonNull` and similar structs: We need to validate them\n-        // at their scalar layout *before* descending into their fields.\n-        // FIXME: We could avoid some redundant checks here. For newtypes wrapping\n-        // scalars, we do the same check on every \"level\" (e.g. first we check\n-        // MyNewtype and then the scalar in there).\n-        match dest.layout.abi {\n-            layout::Abi::Uninhabited =>\n-                return validation_failure!(\"a value of an uninhabited type\", path),\n-            layout::Abi::Scalar(ref layout) => {\n-                let value = try_validation!(self.read_scalar(dest),\n-                            \"uninitialized or unrepresentable data\", path);\n-                self.validate_scalar_layout(value, dest.layout.size, &path, layout)?;\n+        match op.layout.ty.sty {\n+            ty::Str => {\n+                let mplace = op.to_mem_place(); // strings are never immediate\n+                try_validation!(self.ecx.read_str(mplace),\n+                    \"uninitialized or non-UTF-8 data in str\", self.path);\n             }\n-            // FIXME: Should we do something for ScalarPair? Vector?\n-            _ => {}\n-        }\n-\n-        // Check primitive types.  We do this after checking the scalar layout,\n-        // just to have that done as well.  Primitives can have varying layout,\n-        // so we check them separately and before aggregate handling.\n-        // It is CRITICAL that we get this check right, or we might be\n-        // validating the wrong thing!\n-        let primitive = match dest.layout.fields {\n-            // Primitives appear as Union with 0 fields -- except for fat pointers.\n-            layout::FieldPlacement::Union(0) => true,\n-            _ => dest.layout.ty.builtin_deref(true).is_some(),\n-        };\n-        if primitive {\n-            let value = try_validation!(self.read_immediate(dest),\n-                \"uninitialized or unrepresentable data\", path);\n-            return self.validate_primitive_type(\n-                value,\n-                &path,\n-                ref_tracking,\n-                const_mode,\n-            );\n-        }\n-\n-        // Validate all fields of compound data structures\n-        let path_len = path.len(); // Remember the length, in case we need to truncate\n-        match dest.layout.fields {\n-            layout::FieldPlacement::Union(fields) => {\n-                // Empty unions are not accepted by rustc. That's great, it means we can\n-                // use that as an unambiguous signal for detecting primitives.  Make sure\n-                // we did not miss any primitive.\n-                debug_assert!(fields > 0);\n-                // We can't check unions, their bits are allowed to be anything.\n-                // The fields don't need to correspond to any bit pattern of the union's fields.\n-                // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n-            },\n-            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                // Go look at all the fields\n-                for i in 0..offsets.len() {\n-                    let field = self.operand_field(dest, i as u64)?;\n-                    path.push(self.aggregate_field_path_elem(dest.layout, i));\n-                    self.validate_operand(\n-                        field,\n-                        path,\n-                        ref_tracking.as_mut().map(|r| &mut **r),\n-                        const_mode,\n-                    )?;\n-                    path.truncate(path_len);\n+            ty::Array(tys, ..) | ty::Slice(tys) if {\n+                // This optimization applies only for integer and floating point types\n+                // (i.e., types that can hold arbitrary bytes).\n+                match tys.sty {\n+                    ty::Int(..) | ty::Uint(..) | ty::Float(..) => true,\n+                    _ => false,\n                 }\n-            }\n-            layout::FieldPlacement::Array { stride, .. } => {\n-                let dest = if dest.layout.is_zst() {\n+            } => {\n+                let mplace = if op.layout.is_zst() {\n                     // it's a ZST, the memory content cannot matter\n-                    MPlaceTy::dangling(dest.layout, self)\n+                    MPlaceTy::dangling(op.layout, self.ecx)\n                 } else {\n                     // non-ZST array/slice/str cannot be immediate\n-                    dest.to_mem_place()\n+                    op.to_mem_place()\n                 };\n-                match dest.layout.ty.sty {\n-                    // Special handling for strings to verify UTF-8\n-                    ty::Str => {\n-                        try_validation!(self.read_str(dest),\n-                            \"uninitialized or non-UTF-8 data in str\", path);\n-                    }\n-                    // Special handling for arrays/slices of builtin integer types\n-                    ty::Array(tys, ..) | ty::Slice(tys) if {\n-                        // This optimization applies only for integer and floating point types\n-                        // (i.e., types that can hold arbitrary bytes).\n-                        match tys.sty {\n-                            ty::Int(..) | ty::Uint(..) | ty::Float(..) => true,\n-                            _ => false,\n-                        }\n-                    } => {\n-                        // This is the length of the array/slice.\n-                        let len = dest.len(self)?;\n-                        // Since primitive types are naturally aligned and tightly packed in arrays,\n-                        // we can use the stride to get the size of the integral type.\n-                        let ty_size = stride.bytes();\n-                        // This is the size in bytes of the whole array.\n-                        let size = Size::from_bytes(ty_size * len);\n-\n-                        // NOTE: Keep this in sync with the handling of integer and float\n-                        // types above, in `validate_primitive_type`.\n-                        // In run-time mode, we accept pointers in here.  This is actually more\n-                        // permissive than a per-element check would be, e.g. we accept\n-                        // an &[u8] that contains a pointer even though bytewise checking would\n-                        // reject it.  However, that's good: We don't inherently want\n-                        // to reject those pointers, we just do not have the machinery to\n-                        // talk about parts of a pointer.\n-                        // We also accept undef, for consistency with the type-based checks.\n-                        match self.memory.check_bytes(\n-                            dest.ptr,\n-                            size,\n-                            /*allow_ptr_and_undef*/!const_mode,\n-                        ) {\n-                            // In the happy case, we needn't check anything else.\n-                            Ok(()) => {},\n-                            // Some error happened, try to provide a more detailed description.\n-                            Err(err) => {\n-                                // For some errors we might be able to provide extra information\n-                                match err.kind {\n-                                    EvalErrorKind::ReadUndefBytes(offset) => {\n-                                        // Some byte was undefined, determine which\n-                                        // element that byte belongs to so we can\n-                                        // provide an index.\n-                                        let i = (offset.bytes() / ty_size) as usize;\n-                                        path.push(PathElem::ArrayElem(i));\n-\n-                                        return validation_failure!(\n-                                            \"undefined bytes\", path\n-                                        )\n-                                    },\n-                                    // Other errors shouldn't be possible\n-                                    _ => return Err(err),\n-                                }\n-                            }\n-                        }\n-                    },\n-                    _ => {\n-                        // This handles the unsized case correctly as well, as well as\n-                        // SIMD an all sorts of other array-like types.\n-                        for (i, field) in self.mplace_array_fields(dest)?.enumerate() {\n-                            let field = field?;\n-                            path.push(PathElem::ArrayElem(i));\n-                            self.validate_operand(\n-                                field.into(),\n-                                path,\n-                                ref_tracking.as_mut().map(|r| &mut **r),\n-                                const_mode,\n-                            )?;\n-                            path.truncate(path_len);\n+                // This is the length of the array/slice.\n+                let len = mplace.len(self.ecx)?;\n+                // This is the element type size.\n+                let ty_size = self.ecx.layout_of(tys)?.size;\n+                // This is the size in bytes of the whole array.\n+                let size = ty_size * len;\n+\n+                // NOTE: Keep this in sync with the handling of integer and float\n+                // types above, in `visit_primitive`.\n+                // In run-time mode, we accept pointers in here.  This is actually more\n+                // permissive than a per-element check would be, e.g. we accept\n+                // an &[u8] that contains a pointer even though bytewise checking would\n+                // reject it.  However, that's good: We don't inherently want\n+                // to reject those pointers, we just do not have the machinery to\n+                // talk about parts of a pointer.\n+                // We also accept undef, for consistency with the type-based checks.\n+                match self.ecx.memory.check_bytes(\n+                    mplace.ptr,\n+                    size,\n+                    /*allow_ptr_and_undef*/!self.const_mode,\n+                ) {\n+                    // In the happy case, we needn't check anything else.\n+                    Ok(()) => {},\n+                    // Some error happened, try to provide a more detailed description.\n+                    Err(err) => {\n+                        // For some errors we might be able to provide extra information\n+                        match err.kind {\n+                            EvalErrorKind::ReadUndefBytes(offset) => {\n+                                // Some byte was undefined, determine which\n+                                // element that byte belongs to so we can\n+                                // provide an index.\n+                                let i = (offset.bytes() / ty_size.bytes()) as usize;\n+                                self.path.push(PathElem::ArrayElem(i));\n+\n+                                return validation_failure!(\n+                                    \"undefined bytes\", self.path\n+                                )\n+                            },\n+                            // Other errors shouldn't be possible\n+                            _ => return Err(err),\n                         }\n                     }\n                 }\n-            },\n+            }\n+            _ => {\n+                self.walk_aggregate(op, fields)? // default handler\n+            }\n         }\n         Ok(())\n     }\n+}\n \n-    fn aggregate_field_path_elem(&self, layout: TyLayout<'tcx>, field: usize) -> PathElem {\n-        match layout.ty.sty {\n-            // generators and closures.\n-            ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n-                if let Some(upvar) = self.tcx.optimized_mir(def_id).upvar_decls.get(field) {\n-                    PathElem::ClosureVar(upvar.debug_name)\n-                } else {\n-                    // Sometimes the index is beyond the number of freevars (seen\n-                    // for a generator).\n-                    PathElem::ClosureVar(Symbol::intern(&field.to_string()))\n-                }\n-            }\n-\n-            // tuples\n-            ty::Tuple(_) => PathElem::TupleElem(field),\n-\n-            // enums\n-            ty::Adt(def, ..) if def.is_enum() => {\n-                let variant = match layout.variants {\n-                    layout::Variants::Single { index } => &def.variants[index],\n-                    _ => bug!(\"aggregate_field_path_elem: got enum but not in a specific variant\"),\n-                };\n-                PathElem::Field(variant.fields[field].ident.name)\n-            }\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+    /// This function checks the data at `op`.  `op` is assumed to cover valid memory if it\n+    /// is an indirect operand.\n+    /// It will error if the bits at the destination do not match the ones described by the layout.\n+    ///\n+    /// `ref_tracking` can be None to avoid recursive checking below references.\n+    /// This also toggles between \"run-time\" (no recursion) and \"compile-time\" (with recursion)\n+    /// validation (e.g., pointer values are fine in integers at runtime).\n+    pub fn validate_operand(\n+        &self,\n+        op: OpTy<'tcx, M::PointerTag>,\n+        path: Vec<PathElem>,\n+        ref_tracking: Option<&mut RefTracking<'tcx, M::PointerTag>>,\n+        const_mode: bool,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"validate_operand: {:?}, {:?}\", *op, op.layout.ty);\n \n-            // other ADTs\n-            ty::Adt(def, _) => PathElem::Field(def.non_enum_variant().fields[field].ident.name),\n+        // Construct a visitor\n+        let mut visitor = ValidityVisitor {\n+            path,\n+            ref_tracking,\n+            const_mode,\n+            ecx: self,\n+        };\n \n-            // nothing else has an aggregate layout\n-            _ => bug!(\"aggregate_field_path_elem: got non-aggregate type {:?}\", layout.ty),\n-        }\n+        // Run it\n+        visitor.visit_value(op)\n     }\n }"}, {"sha": "392e27918092f45ec2b4a2093b99a7de4542b51b", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -0,0 +1,320 @@\n+//! Visitor for a run-time value with a given layout: Traverse enums, structs and other compound\n+//! types until we arrive at the leaves, with custom handling for primitive types.\n+\n+use rustc::ty::layout::{self, TyLayout};\n+use rustc::ty;\n+use rustc::mir::interpret::{\n+    EvalResult,\n+};\n+\n+use super::{\n+    Machine, EvalContext, MPlaceTy, OpTy, ImmTy,\n+};\n+\n+// A thing that we can project into, and that has a layout.\n+// This wouldn't have to depend on `Machine` but with the current type inference,\n+// that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n+pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n+{\n+    /// Get this value's layout.\n+    fn layout(&self) -> TyLayout<'tcx>;\n+\n+    /// Make this into an `OpTy`.\n+    fn to_op(\n+        self,\n+        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n+\n+    /// Create this from an `MPlaceTy`.\n+    fn from_mem_place(MPlaceTy<'tcx, M::PointerTag>) -> Self;\n+\n+    /// Project to the given enum variant.\n+    fn project_downcast(\n+        self,\n+        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        variant: usize,\n+    ) -> EvalResult<'tcx, Self>;\n+\n+    /// Project to the n-th field.\n+    fn project_field(\n+        self,\n+        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        field: u64,\n+    ) -> EvalResult<'tcx, Self>;\n+}\n+\n+// Operands and memory-places are both values.\n+// Places in general are not due to `place_field` having to do `force_allocation`.\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n+    for OpTy<'tcx, M::PointerTag>\n+{\n+    #[inline(always)]\n+    fn layout(&self) -> TyLayout<'tcx> {\n+        self.layout\n+    }\n+\n+    #[inline(always)]\n+    fn to_op(\n+        self,\n+        _ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        Ok(self)\n+    }\n+\n+    #[inline(always)]\n+    fn from_mem_place(mplace: MPlaceTy<'tcx, M::PointerTag>) -> Self {\n+        mplace.into()\n+    }\n+\n+    #[inline(always)]\n+    fn project_downcast(\n+        self,\n+        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        variant: usize,\n+    ) -> EvalResult<'tcx, Self> {\n+        ecx.operand_downcast(self, variant)\n+    }\n+\n+    #[inline(always)]\n+    fn project_field(\n+        self,\n+        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        field: u64,\n+    ) -> EvalResult<'tcx, Self> {\n+        ecx.operand_field(self, field)\n+    }\n+}\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n+    for MPlaceTy<'tcx, M::PointerTag>\n+{\n+    #[inline(always)]\n+    fn layout(&self) -> TyLayout<'tcx> {\n+        self.layout\n+    }\n+\n+    #[inline(always)]\n+    fn to_op(\n+        self,\n+        _ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        Ok(self.into())\n+    }\n+\n+    #[inline(always)]\n+    fn from_mem_place(mplace: MPlaceTy<'tcx, M::PointerTag>) -> Self {\n+        mplace\n+    }\n+\n+    #[inline(always)]\n+    fn project_downcast(\n+        self,\n+        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        variant: usize,\n+    ) -> EvalResult<'tcx, Self> {\n+        ecx.mplace_downcast(self, variant)\n+    }\n+\n+    #[inline(always)]\n+    fn project_field(\n+        self,\n+        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        field: u64,\n+    ) -> EvalResult<'tcx, Self> {\n+        ecx.mplace_field(self, field)\n+    }\n+}\n+\n+macro_rules! make_value_visitor {\n+    ($visitor_trait_name:ident, $($mutability:ident)*) => {\n+        // How to traverse a value and what to do when we are at the leaves.\n+        pub trait $visitor_trait_name<'a, 'mir, 'tcx: 'mir+'a, M: Machine<'a, 'mir, 'tcx>>: Sized {\n+            type V: Value<'a, 'mir, 'tcx, M>;\n+\n+            /// The visitor must have an `EvalContext` in it.\n+            fn ecx(&$($mutability)* self)\n+                -> &$($mutability)* EvalContext<'a, 'mir, 'tcx, M>;\n+\n+            // Recursive actions, ready to be overloaded.\n+            /// Visit the given value, dispatching as appropriate to more specialized visitors.\n+            #[inline(always)]\n+            fn visit_value(&mut self, v: Self::V) -> EvalResult<'tcx>\n+            {\n+                self.walk_value(v)\n+            }\n+            /// Visit the given value as a union.  No automatic recursion can happen here.\n+            #[inline(always)]\n+            fn visit_union(&mut self, _v: Self::V) -> EvalResult<'tcx>\n+            {\n+                Ok(())\n+            }\n+            /// Visit this vale as an aggregate, you are even getting an iterator yielding\n+            /// all the fields (still in an `EvalResult`, you have to do error handling yourself).\n+            /// Recurses into the fields.\n+            #[inline(always)]\n+            fn visit_aggregate(\n+                &mut self,\n+                v: Self::V,\n+                fields: impl Iterator<Item=EvalResult<'tcx, Self::V>>,\n+            ) -> EvalResult<'tcx> {\n+                self.walk_aggregate(v, fields)\n+            }\n+            /// Called each time we recurse down to a field, passing in old and new value.\n+            /// This gives the visitor the chance to track the stack of nested fields that\n+            /// we are descending through.\n+            #[inline(always)]\n+            fn visit_field(\n+                &mut self,\n+                _old_val: Self::V,\n+                _field: usize,\n+                new_val: Self::V,\n+            ) -> EvalResult<'tcx> {\n+                self.visit_value(new_val)\n+            }\n+\n+            /// Called whenever we reach a value with uninhabited layout.\n+            /// Recursing to fields will *always* continue after this!  This is not meant to control\n+            /// whether and how we descend recursively/ into the scalar's fields if there are any,\n+            /// it is meant to provide the chance for additional checks when a value of uninhabited\n+            /// layout is detected.\n+            #[inline(always)]\n+            fn visit_uninhabited(&mut self) -> EvalResult<'tcx>\n+            { Ok(()) }\n+            /// Called whenever we reach a value with scalar layout.\n+            /// We do NOT provide a `ScalarMaybeUndef` here to avoid accessing memory if the\n+            /// visitor is not even interested in scalars.\n+            /// Recursing to fields will *always* continue after this!  This is not meant to control\n+            /// whether and how we descend recursively/ into the scalar's fields if there are any,\n+            /// it is meant to provide the chance for additional checks when a value of scalar\n+            /// layout is detected.\n+            #[inline(always)]\n+            fn visit_scalar(&mut self, _v: Self::V, _layout: &layout::Scalar) -> EvalResult<'tcx>\n+            { Ok(()) }\n+\n+            /// Called whenever we reach a value of primitive type.  There can be no recursion\n+            /// below such a value.  This is the leave function.\n+            #[inline(always)]\n+            fn visit_primitive(&mut self, _val: ImmTy<'tcx, M::PointerTag>) -> EvalResult<'tcx>\n+            { Ok(()) }\n+\n+            // Default recursors. Not meant to be overloaded.\n+            fn walk_aggregate(\n+                &mut self,\n+                v: Self::V,\n+                fields: impl Iterator<Item=EvalResult<'tcx, Self::V>>,\n+            ) -> EvalResult<'tcx> {\n+                // Now iterate over it.\n+                for (idx, field_val) in fields.enumerate() {\n+                    self.visit_field(v, idx, field_val?)?;\n+                }\n+                Ok(())\n+            }\n+            fn walk_value(&mut self, v: Self::V) -> EvalResult<'tcx>\n+            {\n+                trace!(\"walk_value: type: {}\", v.layout().ty);\n+                // If this is a multi-variant layout, we have find the right one and proceed with\n+                // that.\n+                match v.layout().variants {\n+                    layout::Variants::NicheFilling { .. } |\n+                    layout::Variants::Tagged { .. } => {\n+                        let op = v.to_op(self.ecx())?;\n+                        let idx = self.ecx().read_discriminant(op)?.1;\n+                        let inner = v.project_downcast(self.ecx(), idx)?;\n+                        trace!(\"walk_value: variant layout: {:#?}\", inner.layout());\n+                        // recurse with the inner type\n+                        return self.visit_field(v, idx, inner);\n+                    }\n+                    layout::Variants::Single { .. } => {}\n+                }\n+\n+                // Even for single variants, we might be able to get a more refined type:\n+                // If it is a trait object, switch to the actual type that was used to create it.\n+                match v.layout().ty.sty {\n+                    ty::Dynamic(..) => {\n+                        // immediate trait objects are not a thing\n+                        let dest = v.to_op(self.ecx())?.to_mem_place();\n+                        let inner = self.ecx().unpack_dyn_trait(dest)?.1;\n+                        trace!(\"walk_value: dyn object layout: {:#?}\", inner.layout);\n+                        // recurse with the inner type\n+                        return self.visit_field(v, 0, Value::from_mem_place(inner));\n+                    },\n+                    _ => {},\n+                };\n+\n+                // If this is a scalar, visit it as such.\n+                // Things can be aggregates and have scalar layout at the same time, and that\n+                // is very relevant for `NonNull` and similar structs: We need to visit them\n+                // at their scalar layout *before* descending into their fields.\n+                // FIXME: We could avoid some redundant checks here. For newtypes wrapping\n+                // scalars, we do the same check on every \"level\" (e.g. first we check\n+                // MyNewtype and then the scalar in there).\n+                match v.layout().abi {\n+                    layout::Abi::Uninhabited => {\n+                        self.visit_uninhabited()?;\n+                    }\n+                    layout::Abi::Scalar(ref layout) => {\n+                        self.visit_scalar(v, layout)?;\n+                    }\n+                    // FIXME: Should we do something for ScalarPair? Vector?\n+                    _ => {}\n+                }\n+\n+                // Check primitive types.  We do this after checking the scalar layout,\n+                // just to have that done as well.  Primitives can have varying layout,\n+                // so we check them separately and before aggregate handling.\n+                // It is CRITICAL that we get this check right, or we might be\n+                // validating the wrong thing!\n+                let primitive = match v.layout().fields {\n+                    // Primitives appear as Union with 0 fields - except for Boxes and fat pointers.\n+                    layout::FieldPlacement::Union(0) => true,\n+                    _ => v.layout().ty.builtin_deref(true).is_some(),\n+                };\n+                if primitive {\n+                    let op = v.to_op(self.ecx())?;\n+                    let val = self.ecx().read_immediate(op)?;\n+                    return self.visit_primitive(val);\n+                }\n+\n+                // Proceed into the fields.\n+                match v.layout().fields {\n+                    layout::FieldPlacement::Union(fields) => {\n+                        // Empty unions are not accepted by rustc. That's great, it means we can\n+                        // use that as an unambiguous signal for detecting primitives.  Make sure\n+                        // we did not miss any primitive.\n+                        debug_assert!(fields > 0);\n+                        self.visit_union(v)?;\n+                    },\n+                    layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n+                        // FIXME: We collect in a vec because otherwise there are lifetime errors:\n+                        // Projecting to a field needs (mutable!) access to `ecx`.\n+                        let fields: Vec<EvalResult<'tcx, Self::V>> =\n+                            (0..offsets.len()).map(|i| {\n+                                v.project_field(self.ecx(), i as u64)\n+                            })\n+                            .collect();\n+                        self.visit_aggregate(v, fields.into_iter())?;\n+                    },\n+                    layout::FieldPlacement::Array { .. } => {\n+                        // Let's get an mplace first.\n+                        let mplace = if v.layout().is_zst() {\n+                            // it's a ZST, the memory content cannot matter\n+                            MPlaceTy::dangling(v.layout(), self.ecx())\n+                        } else {\n+                            // non-ZST array/slice/str cannot be immediate\n+                            v.to_op(self.ecx())?.to_mem_place()\n+                        };\n+                        // Now we can go over all the fields.\n+                        let iter = self.ecx().mplace_array_fields(mplace)?\n+                            .map(|f| f.and_then(|f| {\n+                                Ok(Value::from_mem_place(f))\n+                            }));\n+                        self.visit_aggregate(v, iter)?;\n+                    }\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+}\n+\n+make_value_visitor!(ValueVisitor,);\n+make_value_visitor!(MutValueVisitor,mut);"}, {"sha": "7e82d4fc264f564ca81820fdffe93d4215a3898f", "filename": "src/test/ui/consts/const-eval/double_check2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -5,7 +5,7 @@ LL | / static FOO: (&Foo, &Bar) = unsafe {( //~ undefined behavior\n LL | |     Union { u8: &BAR }.foo,\n LL | |     Union { u8: &BAR }.bar,\n LL | | )};\n-   | |___^ type validation failed: encountered invalid enum discriminant 5 at .1.<deref>\n+   | |___^ type validation failed: encountered 5 at .1.<deref>, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "309627581d0512cd5a881ceb013b7f03cdb7d306", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(const_err)] // make sure we cannot allow away the errors tested here\n+\n #[repr(usize)]\n #[derive(Copy, Clone)]\n enum Enum {\n@@ -31,10 +33,15 @@ enum Enum2 {\n union TransmuteEnum2 {\n     a: usize,\n     b: Enum2,\n+    c: (),\n }\n const BAD_ENUM2 : Enum2 = unsafe { TransmuteEnum2 { a: 0 }.b };\n //~^ ERROR is undefined behavior\n \n+// Undef enum discriminant. In an arry to avoid `Scalar` layout.\n+const BAD_ENUM3 : [Enum2; 2] = [unsafe { TransmuteEnum2 { c: () }.b }; 2];\n+//~^ ERROR is undefined behavior\n+\n // Invalid enum field content (mostly to test printing of apths for enum tuple\n // variants and tuples).\n union TransmuteChar {"}, {"sha": "57c41711536d9485749b501a0f5cf85d87258306", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -1,27 +1,35 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:22:1\n+  --> $DIR/ub-enum.rs:24:1\n    |\n LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { a: &1 }.b };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:35:1\n+  --> $DIR/ub-enum.rs:38:1\n    |\n LL | const BAD_ENUM2 : Enum2 = unsafe { TransmuteEnum2 { a: 0 }.b };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid enum discriminant 0\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:45:1\n+  --> $DIR/ub-enum.rs:42:1\n+   |\n+LL | const BAD_ENUM3 : [Enum2; 2] = [unsafe { TransmuteEnum2 { c: () }.b }; 2];\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempted to read undefined bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-enum.rs:52:1\n    |\n LL | const BAD_ENUM_CHAR : Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .Some.0.1, but expected something in the range 0..=1114111\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "8b83a1747cabdebeff01800942f1cee77ca467f9", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(const_transmute)]\n+#![allow(const_err)] // make sure we cannot allow away the errors tested here\n \n use std::mem;\n use std::ptr::NonNull;"}, {"sha": "7c0ff851d8848c96da8f7caa6c516202b16ca0dc", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -1,21 +1,21 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:17:1\n+  --> $DIR/ub-nonnull.rs:18:1\n    |\n LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:20:1\n+  --> $DIR/ub-nonnull.rs:21:1\n    |\n LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:22:1\n+  --> $DIR/ub-nonnull.rs:23:1\n    |\n LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1"}, {"sha": "c0dd94a375bcbb0c69d36886fa3e582b51a63619", "filename": "src/test/ui/consts/const-eval/ub-ref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(const_transmute)]\n+#![allow(const_err)] // make sure we cannot allow away the errors tested here\n \n use std::mem;\n "}, {"sha": "c3f5f4a26f55594cbc6b2545df8774de73d588ab", "filename": "src/test/ui/consts/const-eval/ub-ref.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -1,37 +1,37 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:15:1\n+  --> $DIR/ub-ref.rs:16:1\n    |\n LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered unaligned reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:18:1\n+  --> $DIR/ub-ref.rs:19:1\n    |\n LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:21:1\n+  --> $DIR/ub-ref.rs:22:1\n    |\n LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:24:1\n+  --> $DIR/ub-ref.rs:25:1\n    |\n LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ a raw memory access tried to access part of a pointer value as raw bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<deref>, but expected plain bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:27:1\n+  --> $DIR/ub-ref.rs:28:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered integer pointer in non-ZST reference"}, {"sha": "74713af2ea033114ee9ed28e9b45338efa55f52f", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(const_transmute)]\n+#![allow(const_err)] // make sure we cannot allow away the errors tested here\n \n use std::mem;\n "}, {"sha": "c5ac72b639c05a94292c40ec0722d284d9c6633a", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -1,21 +1,21 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:18:1\n+  --> $DIR/ub-uninhabit.rs:19:1\n    |\n LL | const BAD_BAD_BAD: Bar = unsafe { mem::transmute(()) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:21:1\n+  --> $DIR/ub-uninhabit.rs:22:1\n    |\n LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:24:1\n+  --> $DIR/ub-uninhabit.rs:25:1\n    |\n LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { mem::transmute(()) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at [0]"}, {"sha": "6661de4ab2cb586bcaa737211848c2a56d51ca7b", "filename": "src/test/ui/consts/const-eval/ub-upvars.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(const_transmute,const_let)]\n+#![allow(const_err)] // make sure we cannot allow away the errors tested here\n \n use std::mem;\n "}, {"sha": "3617a53a9788da4f2fde860a1f3e0ebc480f019d", "filename": "src/test/ui/consts/const-eval/ub-upvars.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -1,12 +1,12 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-upvars.rs:15:1\n+  --> $DIR/ub-upvars.rs:16:1\n    |\n LL | / const BAD_UPVAR: &FnOnce() = &{ //~ ERROR it is undefined behavior to use this value\n LL | |     let bad_ref: &'static u16 = unsafe { mem::transmute(0usize) };\n LL | |     let another_var = 13;\n LL | |     move || { let _ = bad_ref; let _ = another_var; }\n LL | | };\n-   | |__^ type validation failed: encountered 0 at .<deref>.<closure-var(bad_ref)>, but expected something greater or equal to 1\n+   | |__^ type validation failed: encountered 0 at .<deref>.<dyn-downcast>.<closure-var(bad_ref)>, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "31540b46631c0558b181344158f8588b75131452", "filename": "src/test/ui/consts/const-eval/union-ub-fat-ptr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![allow(unused)]\n+#![allow(const_err)] // make sure we cannot allow away the errors tested here\n \n // normalize-stderr-test \"alignment \\d+\" -> \"alignment N\"\n // normalize-stderr-test \"offset \\d+\" -> \"offset N\""}, {"sha": "9a799b98cfc573e77b2f7971b3f1beccfb77d303", "filename": "src/test/ui/consts/const-eval/union-ub-fat-ptr.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -1,109 +1,109 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:87:1\n+  --> $DIR/union-ub-fat-ptr.rs:88:1\n    |\n LL | const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling (not entirely in bounds) reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:90:1\n+  --> $DIR/union-ub-fat-ptr.rs:91:1\n    |\n LL | const C: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in fat pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:93:1\n+  --> $DIR/union-ub-fat-ptr.rs:94:1\n    |\n LL | const C2: &MyStr = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in fat pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:99:1\n+  --> $DIR/union-ub-fat-ptr.rs:100:1\n    |\n LL | const B2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling (not entirely in bounds) reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:102:1\n+  --> $DIR/union-ub-fat-ptr.rs:103:1\n    |\n LL | const C3: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in fat pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:106:1\n+  --> $DIR/union-ub-fat-ptr.rs:107:1\n    |\n LL | const D: &Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop fn in vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:109:1\n+  --> $DIR/union-ub-fat-ptr.rs:110:1\n    |\n LL | const E: &Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop fn in vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:112:1\n+  --> $DIR/union-ub-fat-ptr.rs:113:1\n    |\n LL | const F: &Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-pointer vtable in fat pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:116:1\n+  --> $DIR/union-ub-fat-ptr.rs:117:1\n    |\n LL | const G: &Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>, but expected something in the range 0..=1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.<dyn-downcast>, but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:120:1\n+  --> $DIR/union-ub-fat-ptr.rs:121:1\n    |\n LL | const H: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:126:1\n+  --> $DIR/union-ub-fat-ptr.rs:127:1\n    |\n LL | const I2: &MySliceBool = &MySlice(unsafe { BoolTransmute { val: 3 }.bl }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:129:1\n+  --> $DIR/union-ub-fat-ptr.rs:130:1\n    |\n LL | const I3: &MySliceBool = &MySlice(true, [unsafe { BoolTransmute { val: 3 }.bl }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:133:1\n+  --> $DIR/union-ub-fat-ptr.rs:134:1\n    |\n LL | const J1: &str = unsafe { SliceTransmute { slice: &[0xFF] }.str };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:136:1\n+  --> $DIR/union-ub-fat-ptr.rs:137:1\n    |\n LL | const J2: &MyStr = unsafe { SliceTransmute { slice: &[0xFF] }.my_str };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>.0"}, {"sha": "712147b52e96465dda4024e8aef4f89af5963317", "filename": "src/test/ui/consts/const-eval/union-ub.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.rs?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(const_err)] // make sure we cannot allow away the errors tested here\n+\n union DummyUnion {\n     u8: u8,\n     bool: bool,"}, {"sha": "2b6f6a47cd92f67c9e31c2fad99384485820afdb", "filename": "src/test/ui/consts/const-eval/union-ub.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8315b11b6352cbd91ee096571c31ae7d3ac9613d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.stderr?ref=8315b11b6352cbd91ee096571c31ae7d3ac9613d", "patch": "@@ -1,5 +1,5 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub.rs:36:1\n+  --> $DIR/union-ub.rs:38:1\n    |\n LL | const BAD_BOOL: bool = unsafe { DummyUnion { u8: 42 }.bool};\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 42, but expected something in the range 0..=1"}]}