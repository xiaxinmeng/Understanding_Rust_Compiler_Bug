{"sha": "fd76552a4b41d132701dc0857a9fee9a3850088e", "node_id": "C_kwDOAAsO6NoAKGZkNzY1NTJhNGI0MWQxMzI3MDFkYzA4NTdhOWZlZTlhMzg1MDA4OGU", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-05-18T10:18:51Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-05-18T10:18:51Z"}, "message": "std: use an event flag based thread parker on SOLID", "tree": {"sha": "fcab07ddd9f277525a652f328443ac4ed6a5c29e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcab07ddd9f277525a652f328443ac4ed6a5c29e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd76552a4b41d132701dc0857a9fee9a3850088e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEVuz3PwcqDyifNyYbcE4BSbAZSzwFAmKEyAwACgkQcE4BSbAZ\nSzwtAA//a3y0puAt9uolMgp2NiANUNkA3Y3LCy9xkONgFODpY/EuL6fJN+fH2xT+\nSdMAH3YLIitvr9646WTaUIuBk7UhpG12C9Fbwea7qsAu8p1Dsy1FPiuAkrEb+t5X\nizvXgfSXv0Fa6AUqVXmlKm72KmdZFtGEwOujf61MPOImmaOK9XEEI5nPfYq+5COZ\na+65cVLBuud+C4ysXf3lWcFgkDeLR1kux5upmPWkUPVeNPBi/xTEluY9IlFZn28w\nQptG0vxRVxK42LgOjhZ4arZ++zfohhsdWO9u7E30leWyHO3Oo2kjerzOqy9QQUwH\njeiqs8o3D8oNmDpMLl6ksD9pjdRf9yaZhJ803O3B7o5TEELzNDimWLVshQqcWWmn\nbqVqL6ONi3xIdyC6wN0OS/QVS/nmTkYxWzIA3INv9X66Y8FMDqfCqmKcB5WkxFj6\nosEWC1Tnxr7FF5RAOq9vCslScApVYmkQnZ3BNmFFAZMllfyKLA6zWD5KsxURA/49\npgGPt5WaivXnxlfMEyY5NzcHQpu6uh4f7e1QL/PrKAuJ56tsN22W0mr9pRrhdZ+b\ncKFGHJtgwcbdBqqNT8yLszumsn/cglNY4mvRQbGGqDwPihJp20iRb+Vg8KmpjsJa\nI1A1VUMExeL5SfzbjC+cCfJBH1Rsj4P5pIUsfAp/x40yiqUCXhI=\n=6rqn\n-----END PGP SIGNATURE-----", "payload": "tree fcab07ddd9f277525a652f328443ac4ed6a5c29e\nparent 97d48bec2d2ac7e1aac807e1fe3e8341189db7da\nauthor joboet <jonasboettiger@icloud.com> 1652869131 +0200\ncommitter joboet <jonasboettiger@icloud.com> 1652869131 +0200\n\nstd: use an event flag based thread parker on SOLID\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd76552a4b41d132701dc0857a9fee9a3850088e", "html_url": "https://github.com/rust-lang/rust/commit/fd76552a4b41d132701dc0857a9fee9a3850088e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd76552a4b41d132701dc0857a9fee9a3850088e/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97d48bec2d2ac7e1aac807e1fe3e8341189db7da", "url": "https://api.github.com/repos/rust-lang/rust/commits/97d48bec2d2ac7e1aac807e1fe3e8341189db7da", "html_url": "https://github.com/rust-lang/rust/commit/97d48bec2d2ac7e1aac807e1fe3e8341189db7da"}], "stats": {"total": 220, "additions": 214, "deletions": 6}, "files": [{"sha": "5eb14bb7e534be11226565e0b243a987bec50588", "filename": "library/std/src/sys/itron/abi.rs", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fd76552a4b41d132701dc0857a9fee9a3850088e/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd76552a4b41d132701dc0857a9fee9a3850088e/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fabi.rs?ref=fd76552a4b41d132701dc0857a9fee9a3850088e", "patch": "@@ -30,15 +30,32 @@ pub type ER = int_t;\n /// Error code type, `ID` on success\n pub type ER_ID = int_t;\n \n+/// Service call operational mode\n+pub type MODE = uint_t;\n+\n+/// OR waiting condition for an eventflag\n+pub const TWF_ORW: MODE = 0x01;\n+\n+/// Object attributes\n+pub type ATR = uint_t;\n+\n+/// FIFO wait order\n+pub const TA_FIFO: ATR = 0;\n+/// Only one task is allowed to be in the waiting state for the eventflag\n+pub const TA_WSGL: ATR = 0;\n+/// The eventflag\u2019s bit pattern is cleared when a task is released from the\n+/// waiting state for that eventflag.\n+pub const TA_CLR: ATR = 0x04;\n+\n+/// Bit pattern of an eventflag\n+pub type FLGPTN = uint_t;\n+\n /// Task or interrupt priority\n pub type PRI = int_t;\n \n /// The special value of `PRI` representing the current task's priority.\n pub const TPRI_SELF: PRI = 0;\n \n-/// Object attributes\n-pub type ATR = uint_t;\n-\n /// Use the priority inheritance protocol\n #[cfg(target_os = \"solid_asp3\")]\n pub const TA_INHERIT: ATR = 0x02;\n@@ -90,6 +107,13 @@ pub struct T_CSEM {\n     pub maxsem: uint_t,\n }\n \n+#[derive(Clone, Copy)]\n+#[repr(C)]\n+pub struct T_CFLG {\n+    pub flgatr: ATR,\n+    pub iflgptn: FLGPTN,\n+}\n+\n #[derive(Clone, Copy)]\n #[repr(C)]\n pub struct T_CMTX {\n@@ -139,6 +163,24 @@ extern \"C\" {\n     pub fn sns_dsp() -> bool_t;\n     #[link_name = \"__asp3_get_tim\"]\n     pub fn get_tim(p_systim: *mut SYSTIM) -> ER;\n+    #[link_name = \"__asp3_acre_flg\"]\n+    pub fn acre_flg(pk_cflg: *const T_CFLG) -> ER_ID;\n+    #[link_name = \"__asp3_del_flg\"]\n+    pub fn del_flg(flgid: ID) -> ER;\n+    #[link_name = \"__asp3_set_flg\"]\n+    pub fn set_flg(flgid: ID, setptn: FLGPTN) -> ER;\n+    #[link_name = \"__asp3_clr_flg\"]\n+    pub fn clr_flg(flgid: ID, clrptn: FLGPTN) -> ER;\n+    #[link_name = \"__asp3_wai_flg\"]\n+    pub fn wai_flg(flgid: ID, waiptn: FLGPTN, wfmode: MODE, p_flgptn: *mut FLGPTN) -> ER;\n+    #[link_name = \"__asp3_twai_flg\"]\n+    pub fn twai_flg(\n+        flgid: ID,\n+        waiptn: FLGPTN,\n+        wfmode: MODE,\n+        p_flgptn: *mut FLGPTN,\n+        tmout: TMO,\n+    ) -> ER;\n     #[link_name = \"__asp3_acre_mtx\"]\n     pub fn acre_mtx(pk_cmtx: *const T_CMTX) -> ER_ID;\n     #[link_name = \"__asp3_del_mtx\"]"}, {"sha": "805f85a69b6c7d8e5d12af4122c4b0a8635026b9", "filename": "library/std/src/sys/itron/wait_flag.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/fd76552a4b41d132701dc0857a9fee9a3850088e/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd76552a4b41d132701dc0857a9fee9a3850088e/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs?ref=fd76552a4b41d132701dc0857a9fee9a3850088e", "patch": "@@ -0,0 +1,67 @@\n+use crate::mem::MaybeUninit;\n+use crate::time::Duration;\n+\n+use super::{\n+    abi,\n+    error::{expect_success, fail},\n+    time::with_tmos,\n+};\n+\n+const CLEAR: abi::FLGPTN = 0;\n+const RAISED: abi::FLGPTN = 1;\n+\n+/// A thread parking primitive that is not susceptible to race conditions,\n+/// but provides no atomic ordering guarantees and allows only one `raise` per wait.\n+pub struct WaitFlag {\n+    flag: abi::ID,\n+}\n+\n+impl WaitFlag {\n+    /// Creates a new wait flag.\n+    pub fn new() -> WaitFlag {\n+        let flag = expect_success(\n+            unsafe {\n+                abi::acre_flg(&abi::T_CFLG {\n+                    flgatr: abi::TA_FIFO | abi::TA_WSGL | abi::TA_CLR,\n+                    iflgptn: CLEAR,\n+                })\n+            },\n+            &\"acre_flg\",\n+        );\n+\n+        WaitFlag { flag }\n+    }\n+\n+    /// Wait for the wait flag to be raised.\n+    pub fn wait(&self) {\n+        let mut token = MaybeUninit::uninit();\n+        expect_success(\n+            unsafe { abi::wai_flg(self.flag, RAISED, abi::TWF_ORW, token.as_mut_ptr()) },\n+            &\"wai_flg\",\n+        );\n+    }\n+\n+    /// Wait for the wait flag to be raised or the timeout to occur.\n+    pub fn wait_timeout(&self, dur: Duration) {\n+        let mut token = MaybeUninit::uninit();\n+        let er = with_tmos(dur, |tmout| unsafe {\n+            abi::twai_flg(self.flag, RAISED, abi::TWF_ORW, token.as_mut_ptr(), tmout)\n+        });\n+        if er != abi::E_OK && er != abi::E_TMOUT {\n+            fail(er, &\"twai_flg\");\n+        }\n+    }\n+\n+    /// Raise the wait flag.\n+    ///\n+    /// Calls to this function should be balanced with the number of successful waits.\n+    pub fn raise(&self) {\n+        expect_success(unsafe { abi::set_flg(self.flag, RAISED) }, &\"set_flg\");\n+    }\n+}\n+\n+impl Drop for WaitFlag {\n+    fn drop(&mut self) {\n+        expect_success(unsafe { abi::del_flg(self.flag) }, &\"del_flg\");\n+    }\n+}"}, {"sha": "2d21e4764fc210a21ecb23341ab64c5ed4160811", "filename": "library/std/src/sys/solid/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd76552a4b41d132701dc0857a9fee9a3850088e/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd76552a4b41d132701dc0857a9fee9a3850088e/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs?ref=fd76552a4b41d132701dc0857a9fee9a3850088e", "patch": "@@ -15,6 +15,7 @@ mod itron {\n     pub mod thread;\n     pub(super) mod time;\n     use super::unsupported;\n+    pub mod wait_flag;\n }\n \n pub mod alloc;\n@@ -43,6 +44,7 @@ pub mod memchr;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n pub mod time;\n+pub use self::itron::wait_flag;\n \n mod rwlock;\n "}, {"sha": "79d5a498e054f39dda0786923880b4abd28f4ae0", "filename": "library/std/src/sys_common/thread_parker/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd76552a4b41d132701dc0857a9fee9a3850088e/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd76552a4b41d132701dc0857a9fee9a3850088e/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs?ref=fd76552a4b41d132701dc0857a9fee9a3850088e", "patch": "@@ -9,9 +9,10 @@ cfg_if::cfg_if! {\n     ))] {\n         mod futex;\n         pub use futex::Parker;\n-    } else if #[cfg(windows)] {\n-        pub use crate::sys::thread_parker::Parker;\n-    } else if #[cfg(target_family = \"unix\")] {\n+    } else if #[cfg(target_os = \"solid_asp3\")] {\n+        mod wait_flag;\n+        pub use wait_flag::Parker;\n+    } else if #[cfg(any(windows, target_family = \"unix\"))] {\n         pub use crate::sys::thread_parker::Parker;\n     } else {\n         mod generic;"}, {"sha": "39a0df1cd3de4f2ae3bb10f80b19340d79f196c5", "filename": "library/std/src/sys_common/thread_parker/wait_flag.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/fd76552a4b41d132701dc0857a9fee9a3850088e/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd76552a4b41d132701dc0857a9fee9a3850088e/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fwait_flag.rs?ref=fd76552a4b41d132701dc0857a9fee9a3850088e", "patch": "@@ -0,0 +1,96 @@\n+//! A wait-flag-based thread parker.\n+//!\n+//! Some operating systems provide low-level parking primitives like wait counts,\n+//! event flags or semaphores which are not susceptible to race conditions (meaning\n+//! the wakeup can occure before the wait operation). To implement the `std` thread\n+//! parker on top of these primitives, we only have to ensure that parking is fast\n+//! when the thread token is available, the atomic ordering guarantees are maintained\n+//! and spurious wakeups are minimized.\n+//!\n+//! To achieve this, this parker uses an atomic variable with three states: `EMPTY`,\n+//! `PARKED` and `NOTIFIED`:\n+//! * `EMPTY` means the token has not been made available, but the thread is not\n+//!    currently waiting on it.\n+//! * `PARKED` means the token is not available and the thread is parked.\n+//! * `NOTIFIED` means the token is available.\n+//!\n+//! `park` and `park_timeout` change the state from `EMPTY` to `PARKED` and from\n+//! `NOTIFIED` to `EMPTY`. If the state was `NOTIFIED`, the thread was unparked and\n+//! execution can continue without calling into the OS. If the state was `EMPTY`,\n+//! the token is not available and the thread waits on the primitive (here called\n+//! \"wait flag\").\n+//!\n+//! `unpark` changes the state to `NOTIFIED`. If the state was `PARKED`, the thread\n+//! is or will be sleeping on the wait flag, so we raise it. Only the first thread\n+//! to call `unpark` will raise the wait flag, so spurious wakeups are avoided\n+//! (this is especially important for semaphores).\n+\n+use crate::pin::Pin;\n+use crate::sync::atomic::AtomicI8;\n+use crate::sync::atomic::Ordering::SeqCst;\n+use crate::sys::wait_flag::WaitFlag;\n+use crate::time::Duration;\n+\n+const EMPTY: i8 = 0;\n+const PARKED: i8 = -1;\n+const NOTIFIED: i8 = 1;\n+\n+pub struct Parker {\n+    state: AtomicI8,\n+    wait_flag: WaitFlag,\n+}\n+\n+impl Parker {\n+    /// Construct a parker for the current thread. The UNIX parker\n+    /// implementation requires this to happen in-place.\n+    pub unsafe fn new(parker: *mut Parker) {\n+        parker.write(Parker { state: AtomicI8::new(EMPTY), wait_flag: WaitFlag::new() })\n+    }\n+\n+    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        // The state values are chosen so that this subtraction changes\n+        // `NOTIFIED` to `EMPTY` and `EMPTY` to `PARKED`.\n+        let state = self.state.fetch_sub(1, SeqCst);\n+        match state {\n+            EMPTY => (),\n+            NOTIFIED => return,\n+            _ => panic!(\"inconsistent park state\"),\n+        }\n+\n+        self.wait_flag.wait();\n+\n+        // We need to do a load here to use `Acquire` ordering.\n+        self.state.swap(EMPTY, SeqCst);\n+    }\n+\n+    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        let state = self.state.fetch_sub(1, SeqCst);\n+        match state {\n+            EMPTY => (),\n+            NOTIFIED => return,\n+            _ => panic!(\"inconsistent park state\"),\n+        }\n+\n+        self.wait_flag.wait_timeout(dur);\n+        let state = self.state.swap(EMPTY, SeqCst);\n+        if state == NOTIFIED {\n+            // The token was made available after the timeout occurred, but before\n+            // we reset the state, so we need to reset the wait flag to avoid\n+            // spurious wakeups. This wait has no timeout, but we know it will\n+            // return quickly, as the unparking thread will definitely raise the\n+            // flag if it has not already done so.\n+            self.wait_flag.wait();\n+        }\n+    }\n+\n+    // This implementation doesn't require `Pin`, but other implementations do.\n+    pub fn unpark(self: Pin<&Self>) {\n+        let state = self.state.swap(NOTIFIED, SeqCst);\n+\n+        if state == PARKED {\n+            self.wait_flag.raise();\n+        }\n+    }\n+}"}]}