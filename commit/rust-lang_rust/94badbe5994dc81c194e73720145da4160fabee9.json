{"sha": "94badbe5994dc81c194e73720145da4160fabee9", "node_id": "C_kwDOAAsO6NoAKDk0YmFkYmU1OTk0ZGM4MWMxOTRlNzM3MjAxNDVkYTQxNjBmYWJlZTk", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-06-09T06:12:36Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-06-12T01:57:33Z"}, "message": "rustdoc-search: fix order-independence bug", "tree": {"sha": "172c588ce4104bbfa399dc26a927fbb6022b6b9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/172c588ce4104bbfa399dc26a927fbb6022b6b9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94badbe5994dc81c194e73720145da4160fabee9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94badbe5994dc81c194e73720145da4160fabee9", "html_url": "https://github.com/rust-lang/rust/commit/94badbe5994dc81c194e73720145da4160fabee9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94badbe5994dc81c194e73720145da4160fabee9/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c897deddb8ed9471cd739fa5ea763d47dbd9a0e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c897deddb8ed9471cd739fa5ea763d47dbd9a0e3", "html_url": "https://github.com/rust-lang/rust/commit/c897deddb8ed9471cd739fa5ea763d47dbd9a0e3"}], "stats": {"total": 279, "additions": 207, "deletions": 72}, "files": [{"sha": "56edc015049a1ad70c573be41ea2550b038256a9", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 98, "deletions": 68, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/94badbe5994dc81c194e73720145da4160fabee9/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/94badbe5994dc81c194e73720145da4160fabee9/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=94badbe5994dc81c194e73720145da4160fabee9", "patch": "@@ -1208,13 +1208,62 @@ function initSearch(rawSearchIndex) {\n             if (!fnTypes || fnTypes.length === 0) {\n                 return false;\n             }\n+            /**\n+             * @type Map<integer, QueryElement[]>\n+             */\n+            const queryElemSet = new Map();\n+            const addQueryElemToQueryElemSet = function addQueryElemToQueryElemSet(queryElem) {\n+                let currentQueryElemList;\n+                if (queryElemSet.has(queryElem.id)) {\n+                    currentQueryElemList = queryElemSet.get(queryElem.id);\n+                } else {\n+                    currentQueryElemList = [];\n+                    queryElemSet.set(queryElem.id, currentQueryElemList);\n+                }\n+                currentQueryElemList.push(queryElem);\n+            };\n+            for (const queryElem of queryElems) {\n+                addQueryElemToQueryElemSet(queryElem);\n+            }\n             /**\n              * @type Map<integer, FunctionType[]>\n              */\n             const fnTypeSet = new Map();\n             const addFnTypeToFnTypeSet = function addFnTypeToFnTypeSet(fnType) {\n-                if (fnType.id === -1) {\n-                    // Pure generic, needs to check into it.\n+                // Pure generic, or an item that's not matched by any query elems.\n+                // Try [unboxing] it.\n+                //\n+                // [unboxing]:\n+                // http://ndmitchell.com/downloads/slides-hoogle_fast_type_searching-09_aug_2008.pdf\n+                const queryContainsArrayOrSliceElem = queryElemSet.has(typeNameIdOfArrayOrSlice);\n+                if (fnType.id === -1 || !(\n+                    queryElemSet.has(fnType.id) ||\n+                    (fnType.id === typeNameIdOfSlice && queryContainsArrayOrSliceElem) ||\n+                    (fnType.id === typeNameIdOfArray && queryContainsArrayOrSliceElem)\n+                )) {\n+                    for (const innerFnType of fnType.generics) {\n+                        addFnTypeToFnTypeSet(innerFnType);\n+                    }\n+                    return;\n+                }\n+                let currentQueryElemList = queryElemSet.get(fnType.id) || [];\n+                let matchIdx = currentQueryElemList.findIndex(queryElem => {\n+                    return typePassesFilter(queryElem.typeFilter, fnType.ty) &&\n+                        checkGenerics(fnType, queryElem);\n+                });\n+                if (matchIdx === -1 &&\n+                    (fnType.id === typeNameIdOfSlice || fnType.id === typeNameIdOfArray) &&\n+                    queryContainsArrayOrSliceElem\n+                ) {\n+                    currentQueryElemList = queryElemSet.get(typeNameIdOfArrayOrSlice) || [];\n+                    matchIdx = currentQueryElemList.findIndex(queryElem => {\n+                        return typePassesFilter(queryElem.typeFilter, fnType.ty) &&\n+                            checkGenerics(fnType, queryElem);\n+                    });\n+                }\n+                // None of the query elems match the function type.\n+                // Try [unboxing] it.\n+                if (matchIdx === -1) {\n                     for (const innerFnType of fnType.generics) {\n                         addFnTypeToFnTypeSet(innerFnType);\n                     }\n@@ -1232,85 +1281,66 @@ function initSearch(rawSearchIndex) {\n             for (const fnType of fnTypes) {\n                 addFnTypeToFnTypeSet(fnType);\n             }\n-            // We need to find the type that matches the most to remove it in order\n-            // to move forward.\n-            const handleQueryElem = queryElem => {\n-                if (!fnTypeSet.has(queryElem.id)) {\n-                    return false;\n+            const doHandleQueryElemList = (currentFnTypeList, queryElemList) => {\n+                if (queryElemList.length === 0) {\n+                    return true;\n                 }\n-                const currentFnTypeList = fnTypeSet.get(queryElem.id);\n-                const matchIdx = currentFnTypeList.findIndex(fnType => {\n+                // Multiple items in one list might match multiple items in another.\n+                // Since an item with fewer generics can match an item with more, we\n+                // need to check all combinations for a potential match.\n+                const queryElem = queryElemList.pop();\n+                const l = currentFnTypeList.length;\n+                for (let i = 0; i < l; i += 1) {\n+                    const fnType = currentFnTypeList[i];\n                     if (!typePassesFilter(queryElem.typeFilter, fnType.ty)) {\n-                        return false;\n+                        continue;\n+                    }\n+                    if (queryElem.generics.length === 0 || checkGenerics(fnType, queryElem)) {\n+                        currentFnTypeList.splice(i, 1);\n+                        const result = doHandleQueryElemList(currentFnTypeList, queryElemList);\n+                        if (result) {\n+                            return true;\n+                        }\n+                        currentFnTypeList.splice(i, 0, fnType);\n                     }\n-                    return queryElem.generics.length === 0 || checkGenerics(fnType, queryElem);\n-                });\n-                if (matchIdx === -1) {\n-                    return false;\n-                }\n-                currentFnTypeList.splice(matchIdx, 1);\n-                if (currentFnTypeList.length === 0) {\n-                    fnTypeSet.delete(queryElem.id);\n                 }\n-                return true;\n+                return false;\n             };\n-            // To do the right thing with type filters, we first process generics\n-            // that have them, removing matching ones from the \"bag,\" then do the\n-            // ones with no type filter, which can match any entry regardless of its\n-            // own type.\n-            const needsUnboxed = [];\n-            for (const queryElem of queryElems) {\n-                if (queryElem.typeFilter === TY_PRIMITIVE &&\n-                    queryElem.id === typeNameIdOfArrayOrSlice) {\n-                    const queryElemArray = {\n-                        id: typeNameIdOfArray,\n-                        typeFilter: TY_PRIMITIVE,\n-                        generics: queryElem.generics,\n-                    };\n-                    const queryElemSlice = {\n-                        id: typeNameIdOfSlice,\n-                        typeFilter: TY_PRIMITIVE,\n-                        generics: queryElem.generics,\n-                    };\n-                    if (!handleQueryElem(queryElemArray) && !handleQueryElem(queryElemSlice)) {\n-                        needsUnboxed.push(queryElem);\n+            const handleQueryElemList = (id, queryElemList) => {\n+                if (!fnTypeSet.has(id)) {\n+                    if (id === typeNameIdOfArrayOrSlice) {\n+                        return handleQueryElemList(typeNameIdOfSlice, queryElemList) ||\n+                            handleQueryElemList(typeNameIdOfArray, queryElemList);\n                     }\n-                } else if (queryElem.typeFilter !== -1 && !handleQueryElem(queryElem)) {\n-                    needsUnboxed.push(queryElem);\n+                    return false;\n                 }\n-            }\n-            for (const queryElem of queryElems) {\n-                if (queryElem.typeFilter === -1 && !handleQueryElem(queryElem)) {\n-                    needsUnboxed.push(queryElem);\n+                const currentFnTypeList = fnTypeSet.get(id);\n+                if (currentFnTypeList.length < queryElemList.length) {\n+                    // It's not possible for all the query elems to find a match.\n+                    return false;\n                 }\n-            }\n-            // If the current item does not match, try [unboxing] the generic.\n-            // [unboxing]:\n-            //   https://ndmitchell.com/downloads/slides-hoogle_fast_type_searching-09_aug_2008.pdf\n-            unboxing: while (needsUnboxed.length !== 0) {\n-                for (const [i, queryElem] of needsUnboxed.entries()) {\n-                    if (handleQueryElem(queryElem)) {\n-                        needsUnboxed.splice(i, 1);\n-                        continue unboxing;\n+                const result = doHandleQueryElemList(currentFnTypeList, queryElemList);\n+                if (result) {\n+                    // Found a solution.\n+                    // Any items that weren't used for it can be unboxed, and might form\n+                    // part of the solution for another item.\n+                    for (const innerFnType of currentFnTypeList) {\n+                        addFnTypeToFnTypeSet(innerFnType);\n                     }\n+                    fnTypeSet.delete(id);\n                 }\n-                for (const [id, fnTypeList] of fnTypeSet) {\n-                    for (const [i, fnType] of fnTypeList.entries()) {\n-                        if (fnType.generics.length !== 0) {\n-                            fnTypeList.splice(i, 1);\n-                            for (const innerFnType of fnType.generics) {\n-                                addFnTypeToFnTypeSet(innerFnType);\n-                            }\n-                            if (fnTypeList.length === 0) {\n-                                fnTypeSet.delete(id);\n-                            }\n-                            continue unboxing;\n-                        }\n+                return result;\n+            };\n+            let queryElemSetSize = -1;\n+            while (queryElemSetSize !== queryElemSet.size) {\n+                queryElemSetSize = queryElemSet.size;\n+                for (const [id, queryElemList] of queryElemSet) {\n+                    if (handleQueryElemList(id, queryElemList)) {\n+                        queryElemSet.delete(id);\n                     }\n                 }\n-                return false;\n             }\n-            return true;\n+            return queryElemSetSize === 0;\n         }\n \n         /**"}, {"sha": "3828cf76026eaef199e4192115541371ea0e251b", "filename": "tests/rustdoc-js-std/bufread-fill-buf.js", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94badbe5994dc81c194e73720145da4160fabee9/tests%2Frustdoc-js-std%2Fbufread-fill-buf.js", "raw_url": "https://github.com/rust-lang/rust/raw/94badbe5994dc81c194e73720145da4160fabee9/tests%2Frustdoc-js-std%2Fbufread-fill-buf.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fbufread-fill-buf.js?ref=94badbe5994dc81c194e73720145da4160fabee9", "patch": "@@ -1,11 +1,8 @@\n // ignore-order\n \n-const QUERY = [\n-    'bufread -> result<u8>',\n-];\n-\n const EXPECTED = [\n     {\n+        'query': 'bufread -> result<u8>',\n         'others': [\n             { 'path': 'std::io::Split', 'name': 'next' },\n             { 'path': 'std::boxed::Box', 'name': 'fill_buf' },"}, {"sha": "a9932a16ca38b190001ffb872c38977e6a5c428c", "filename": "tests/rustdoc-js/generics-match-ambiguity.js", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/94badbe5994dc81c194e73720145da4160fabee9/tests%2Frustdoc-js%2Fgenerics-match-ambiguity.js", "raw_url": "https://github.com/rust-lang/rust/raw/94badbe5994dc81c194e73720145da4160fabee9/tests%2Frustdoc-js%2Fgenerics-match-ambiguity.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fgenerics-match-ambiguity.js?ref=94badbe5994dc81c194e73720145da4160fabee9", "patch": "@@ -0,0 +1,91 @@\n+// ignore-order\n+// exact-check\n+\n+// Make sure that results are order-agnostic, even when there's search items that only differ\n+// by generics.\n+\n+const EXPECTED = [\n+    {\n+        'query': 'Wrap',\n+        'in_args': [\n+            { 'path': 'generics_match_ambiguity', 'name': 'bar' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'foo' },\n+        ],\n+    },\n+    {\n+        'query': 'Wrap<i32>',\n+        'in_args': [\n+            { 'path': 'generics_match_ambiguity', 'name': 'bar' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'foo' },\n+        ],\n+    },\n+    {\n+        'query': 'Wrap<i32>, Wrap<i32, u32>',\n+        'others': [\n+            { 'path': 'generics_match_ambiguity', 'name': 'bar' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'foo' },\n+        ],\n+    },\n+    {\n+        'query': 'Wrap<i32, u32>, Wrap<i32>',\n+        'others': [\n+            { 'path': 'generics_match_ambiguity', 'name': 'bar' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'foo' },\n+        ],\n+    },\n+    {\n+        'query': 'W3<i32>, W3<i32, u32>',\n+        'others': [\n+            { 'path': 'generics_match_ambiguity', 'name': 'baaa' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baab' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baac' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baad' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baae' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baaf' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baag' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baah' },\n+        ],\n+    },\n+    {\n+        'query': 'W3<i32, u32>, W3<i32>',\n+        'others': [\n+            { 'path': 'generics_match_ambiguity', 'name': 'baaa' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baab' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baac' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baad' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baae' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baaf' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baag' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baah' },\n+        ],\n+    },\n+    {\n+        'query': 'W2<i32>, W2<i32, u32>',\n+        'others': [\n+            { 'path': 'generics_match_ambiguity', 'name': 'baag' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baah' },\n+        ],\n+    },\n+    {\n+        'query': 'W2<i32, u32>, W2<i32>',\n+        'others': [\n+            { 'path': 'generics_match_ambiguity', 'name': 'baag' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baah' },\n+        ],\n+    },\n+    {\n+        'query': 'W2<i32>, W3<i32, u32>',\n+        'others': [\n+            { 'path': 'generics_match_ambiguity', 'name': 'baac' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baaf' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baag' },\n+        ],\n+    },\n+    {\n+        'query': 'W2<i32>, W2<i32>',\n+        'others': [\n+            { 'path': 'generics_match_ambiguity', 'name': 'baag' },\n+            { 'path': 'generics_match_ambiguity', 'name': 'baah' },\n+        ],\n+    },\n+];"}, {"sha": "79c493856ebc7c62eab74e3f56978f17587b289c", "filename": "tests/rustdoc-js/generics-match-ambiguity.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/94badbe5994dc81c194e73720145da4160fabee9/tests%2Frustdoc-js%2Fgenerics-match-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94badbe5994dc81c194e73720145da4160fabee9/tests%2Frustdoc-js%2Fgenerics-match-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fgenerics-match-ambiguity.rs?ref=94badbe5994dc81c194e73720145da4160fabee9", "patch": "@@ -0,0 +1,17 @@\n+pub struct Wrap<T, U = ()>(pub T, pub U);\n+\n+pub fn foo(a: Wrap<i32>, b: Wrap<i32, u32>) {}\n+pub fn bar(a: Wrap<i32, u32>, b: Wrap<i32>) {}\n+\n+pub struct W2<T>(pub T);\n+pub struct W3<T, U = ()>(pub T, pub U);\n+\n+pub fn baaa(a: W3<i32>, b: W3<i32, u32>) {}\n+pub fn baab(a: W3<i32, u32>, b: W3<i32>) {}\n+pub fn baac(a: W2<W3<i32>>, b: W3<i32, u32>) {}\n+pub fn baad(a: W2<W3<i32, u32>>, b: W3<i32>) {}\n+pub fn baae(a: W3<i32>, b: W2<W3<i32, u32>>) {}\n+pub fn baaf(a: W3<i32, u32>, b: W2<W3<i32>>) {}\n+pub fn baag(a: W2<W3<i32>>, b: W2<W3<i32, u32>>) {}\n+pub fn baah(a: W2<W3<i32, u32>>, b: W2<W3<i32>>) {}\n+//"}]}