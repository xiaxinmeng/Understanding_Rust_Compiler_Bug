{"sha": "795efb206892041e81107cc58797ea61fd1c7b16", "node_id": "C_kwDOAAsO6NoAKDc5NWVmYjIwNjg5MjA0MWU4MTEwN2NjNTg3OTdlYTYxZmQxYzdiMTY", "commit": {"author": {"name": "Yacin Tmimi", "email": "yacintmimi@gmail.com", "date": "2022-06-13T14:53:53Z"}, "committer": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2022-06-16T01:06:04Z"}, "message": "Add `Version` information to `UseSegment`\n\nThere are some proposed import sorting changes for raw identifier `r#`.\nThese changes constitute a breaking change, and need to be version\ngagted. Before version gating those changes we add the version\ninformation to the `UseSegment`.", "tree": {"sha": "0ea04341f1bdebd48c48db9861c1ab262ddba724", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ea04341f1bdebd48c48db9861c1ab262ddba724"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/795efb206892041e81107cc58797ea61fd1c7b16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/795efb206892041e81107cc58797ea61fd1c7b16", "html_url": "https://github.com/rust-lang/rust/commit/795efb206892041e81107cc58797ea61fd1c7b16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/795efb206892041e81107cc58797ea61fd1c7b16/comments", "author": {"login": "ytmimi", "id": 29028348, "node_id": "MDQ6VXNlcjI5MDI4MzQ4", "avatar_url": "https://avatars.githubusercontent.com/u/29028348?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ytmimi", "html_url": "https://github.com/ytmimi", "followers_url": "https://api.github.com/users/ytmimi/followers", "following_url": "https://api.github.com/users/ytmimi/following{/other_user}", "gists_url": "https://api.github.com/users/ytmimi/gists{/gist_id}", "starred_url": "https://api.github.com/users/ytmimi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ytmimi/subscriptions", "organizations_url": "https://api.github.com/users/ytmimi/orgs", "repos_url": "https://api.github.com/users/ytmimi/repos", "events_url": "https://api.github.com/users/ytmimi/events{/privacy}", "received_events_url": "https://api.github.com/users/ytmimi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ae94cc6b878f8004e3d354d77991146448c1f82", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ae94cc6b878f8004e3d354d77991146448c1f82", "html_url": "https://github.com/rust-lang/rust/commit/5ae94cc6b878f8004e3d354d77991146448c1f82"}], "stats": {"total": 321, "additions": 206, "deletions": 115}, "files": [{"sha": "58c5f31995ee413b99352c2de226847bd88afa16", "filename": "src/imports.rs", "status": "modified", "additions": 201, "deletions": 110, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/795efb206892041e81107cc58797ea61fd1c7b16/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/795efb206892041e81107cc58797ea61fd1c7b16/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=795efb206892041e81107cc58797ea61fd1c7b16", "patch": "@@ -15,7 +15,7 @@ use rustc_span::{\n use crate::comment::combine_strs_with_missing_comments;\n use crate::config::lists::*;\n use crate::config::ImportGranularity;\n-use crate::config::{Edition, IndentStyle};\n+use crate::config::{Edition, IndentStyle, Version};\n use crate::lists::{\n     definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator,\n };\n@@ -92,7 +92,7 @@ impl<'a> FmtVisitor<'a> {\n \n // FIXME we do a lot of allocation to make our own representation.\n #[derive(Clone, Eq, Hash, PartialEq)]\n-pub(crate) enum UseSegment {\n+pub(crate) enum UseSegmentKind {\n     Ident(String, Option<String>),\n     Slf(Option<String>),\n     Super(Option<String>),\n@@ -101,6 +101,12 @@ pub(crate) enum UseSegment {\n     List(Vec<UseTree>),\n }\n \n+#[derive(Clone, Eq, PartialEq)]\n+pub(crate) struct UseSegment {\n+    pub(crate) kind: UseSegmentKind,\n+    pub(crate) version: Version,\n+}\n+\n #[derive(Clone)]\n pub(crate) struct UseTree {\n     pub(crate) path: Vec<UseSegment>,\n@@ -134,34 +140,38 @@ impl Spanned for UseTree {\n impl UseSegment {\n     // Clone a version of self with any top-level alias removed.\n     fn remove_alias(&self) -> UseSegment {\n-        match *self {\n-            UseSegment::Ident(ref s, _) => UseSegment::Ident(s.clone(), None),\n-            UseSegment::Slf(_) => UseSegment::Slf(None),\n-            UseSegment::Super(_) => UseSegment::Super(None),\n-            UseSegment::Crate(_) => UseSegment::Crate(None),\n-            _ => self.clone(),\n+        let kind = match self.kind {\n+            UseSegmentKind::Ident(ref s, _) => UseSegmentKind::Ident(s.clone(), None),\n+            UseSegmentKind::Slf(_) => UseSegmentKind::Slf(None),\n+            UseSegmentKind::Super(_) => UseSegmentKind::Super(None),\n+            UseSegmentKind::Crate(_) => UseSegmentKind::Crate(None),\n+            _ => return self.clone(),\n+        };\n+        UseSegment {\n+            kind,\n+            version: self.version,\n         }\n     }\n \n     // Check if self == other with their aliases removed.\n     fn equal_except_alias(&self, other: &Self) -> bool {\n-        match (self, other) {\n-            (UseSegment::Ident(ref s1, _), UseSegment::Ident(ref s2, _)) => s1 == s2,\n-            (UseSegment::Slf(_), UseSegment::Slf(_))\n-            | (UseSegment::Super(_), UseSegment::Super(_))\n-            | (UseSegment::Crate(_), UseSegment::Crate(_))\n-            | (UseSegment::Glob, UseSegment::Glob) => true,\n-            (UseSegment::List(ref list1), UseSegment::List(ref list2)) => list1 == list2,\n+        match (&self.kind, &other.kind) {\n+            (UseSegmentKind::Ident(ref s1, _), UseSegmentKind::Ident(ref s2, _)) => s1 == s2,\n+            (UseSegmentKind::Slf(_), UseSegmentKind::Slf(_))\n+            | (UseSegmentKind::Super(_), UseSegmentKind::Super(_))\n+            | (UseSegmentKind::Crate(_), UseSegmentKind::Crate(_))\n+            | (UseSegmentKind::Glob, UseSegmentKind::Glob) => true,\n+            (UseSegmentKind::List(ref list1), UseSegmentKind::List(ref list2)) => list1 == list2,\n             _ => false,\n         }\n     }\n \n     fn get_alias(&self) -> Option<&str> {\n-        match self {\n-            UseSegment::Ident(_, a)\n-            | UseSegment::Slf(a)\n-            | UseSegment::Super(a)\n-            | UseSegment::Crate(a) => a.as_deref(),\n+        match &self.kind {\n+            UseSegmentKind::Ident(_, a)\n+            | UseSegmentKind::Slf(a)\n+            | UseSegmentKind::Super(a)\n+            | UseSegmentKind::Crate(a) => a.as_deref(),\n             _ => None,\n         }\n     }\n@@ -175,19 +185,24 @@ impl UseSegment {\n         if name.is_empty() || name == \"{{root}}\" {\n             return None;\n         }\n-        Some(match name {\n-            \"self\" => UseSegment::Slf(None),\n-            \"super\" => UseSegment::Super(None),\n-            \"crate\" => UseSegment::Crate(None),\n+        let kind = match name {\n+            \"self\" => UseSegmentKind::Slf(None),\n+            \"super\" => UseSegmentKind::Super(None),\n+            \"crate\" => UseSegmentKind::Crate(None),\n             _ => {\n                 let mod_sep = if modsep { \"::\" } else { \"\" };\n-                UseSegment::Ident(format!(\"{}{}\", mod_sep, name), None)\n+                UseSegmentKind::Ident(format!(\"{}{}\", mod_sep, name), None)\n             }\n+        };\n+\n+        Some(UseSegment {\n+            kind,\n+            version: context.config.version(),\n         })\n     }\n \n     fn contains_comment(&self) -> bool {\n-        if let UseSegment::List(list) = self {\n+        if let UseSegmentKind::List(list) = &self.kind {\n             list.iter().any(|subtree| subtree.contains_comment())\n         } else {\n             false\n@@ -254,20 +269,38 @@ impl fmt::Debug for UseTree {\n \n impl fmt::Debug for UseSegment {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n+        fmt::Display::fmt(&self.kind, f)\n     }\n }\n \n impl fmt::Display for UseSegment {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.kind, f)\n+    }\n+}\n+\n+impl Hash for UseSegment {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.kind.hash(state);\n+    }\n+}\n+\n+impl fmt::Debug for UseSegmentKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for UseSegmentKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            UseSegment::Glob => write!(f, \"*\"),\n-            UseSegment::Ident(ref s, Some(ref alias)) => write!(f, \"{} as {}\", s, alias),\n-            UseSegment::Ident(ref s, None) => write!(f, \"{}\", s),\n-            UseSegment::Slf(..) => write!(f, \"self\"),\n-            UseSegment::Super(..) => write!(f, \"super\"),\n-            UseSegment::Crate(..) => write!(f, \"crate\"),\n-            UseSegment::List(ref list) => {\n+            UseSegmentKind::Glob => write!(f, \"*\"),\n+            UseSegmentKind::Ident(ref s, Some(ref alias)) => write!(f, \"{} as {}\", s, alias),\n+            UseSegmentKind::Ident(ref s, None) => write!(f, \"{}\", s),\n+            UseSegmentKind::Slf(..) => write!(f, \"self\"),\n+            UseSegmentKind::Super(..) => write!(f, \"super\"),\n+            UseSegmentKind::Crate(..) => write!(f, \"crate\"),\n+            UseSegmentKind::List(ref list) => {\n                 write!(f, \"{{\")?;\n                 for (i, item) in list.iter().enumerate() {\n                     if i != 0 {\n@@ -411,13 +444,19 @@ impl UseTree {\n             }\n         }\n \n+        let version = context.config.version();\n+\n         match a.kind {\n             UseTreeKind::Glob => {\n                 // in case of a global path and the glob starts at the root, e.g., \"::*\"\n                 if a.prefix.segments.len() == 1 && leading_modsep {\n-                    result.path.push(UseSegment::Ident(\"\".to_owned(), None));\n+                    let kind = UseSegmentKind::Ident(\"\".to_owned(), None);\n+                    result.path.push(UseSegment { kind, version });\n                 }\n-                result.path.push(UseSegment::Glob);\n+                result.path.push(UseSegment {\n+                    kind: UseSegmentKind::Glob,\n+                    version,\n+                });\n             }\n             UseTreeKind::Nested(ref list) => {\n                 // Extract comments between nested use items.\n@@ -438,16 +477,18 @@ impl UseTree {\n                 // in case of a global path and the nested list starts at the root,\n                 // e.g., \"::{foo, bar}\"\n                 if a.prefix.segments.len() == 1 && leading_modsep {\n-                    result.path.push(UseSegment::Ident(\"\".to_owned(), None));\n+                    let kind = UseSegmentKind::Ident(\"\".to_owned(), None);\n+                    result.path.push(UseSegment { kind, version });\n                 }\n-                result.path.push(UseSegment::List(\n+                let kind = UseSegmentKind::List(\n                     list.iter()\n                         .zip(items)\n                         .map(|(t, list_item)| {\n                             Self::from_ast(context, &t.0, Some(list_item), None, None, None)\n                         })\n                         .collect(),\n-                ));\n+                );\n+                result.path.push(UseSegment { kind, version });\n             }\n             UseTreeKind::Simple(ref rename, ..) => {\n                 // If the path has leading double colons and is composed of only 2 segments, then we\n@@ -469,13 +510,15 @@ impl UseTree {\n                         Some(rewrite_ident(context, ident).to_owned())\n                     }\n                 });\n-                let segment = match name.as_ref() {\n-                    \"self\" => UseSegment::Slf(alias),\n-                    \"super\" => UseSegment::Super(alias),\n-                    \"crate\" => UseSegment::Crate(alias),\n-                    _ => UseSegment::Ident(name, alias),\n+                let kind = match name.as_ref() {\n+                    \"self\" => UseSegmentKind::Slf(alias),\n+                    \"super\" => UseSegmentKind::Super(alias),\n+                    \"crate\" => UseSegmentKind::Crate(alias),\n+                    _ => UseSegmentKind::Ident(name, alias),\n                 };\n \n+                let segment = UseSegment { kind, version };\n+\n                 // `name` is already in result.\n                 result.path.pop();\n                 result.path.push(segment);\n@@ -492,39 +535,46 @@ impl UseTree {\n         let mut aliased_self = false;\n \n         // Remove foo::{} or self without attributes.\n-        match last {\n+        match last.kind {\n             _ if self.attrs.is_some() => (),\n-            UseSegment::List(ref list) if list.is_empty() => {\n+            UseSegmentKind::List(ref list) if list.is_empty() => {\n                 self.path = vec![];\n                 return self;\n             }\n-            UseSegment::Slf(None) if self.path.is_empty() && self.visibility.is_some() => {\n+            UseSegmentKind::Slf(None) if self.path.is_empty() && self.visibility.is_some() => {\n                 self.path = vec![];\n                 return self;\n             }\n             _ => (),\n         }\n \n         // Normalise foo::self -> foo.\n-        if let UseSegment::Slf(None) = last {\n+        if let UseSegmentKind::Slf(None) = last.kind {\n             if !self.path.is_empty() {\n                 return self;\n             }\n         }\n \n         // Normalise foo::self as bar -> foo as bar.\n-        if let UseSegment::Slf(_) = last {\n-            if let Some(UseSegment::Ident(_, None)) = self.path.last() {\n+        if let UseSegmentKind::Slf(_) = last.kind {\n+            if let Some(UseSegment {\n+                kind: UseSegmentKind::Ident(_, None),\n+                ..\n+            }) = self.path.last()\n+            {\n                 aliased_self = true;\n             }\n         }\n \n         let mut done = false;\n         if aliased_self {\n             match self.path.last_mut() {\n-                Some(UseSegment::Ident(_, ref mut old_rename)) => {\n+                Some(UseSegment {\n+                    kind: UseSegmentKind::Ident(_, ref mut old_rename),\n+                    ..\n+                }) => {\n                     assert!(old_rename.is_none());\n-                    if let UseSegment::Slf(Some(rename)) = last.clone() {\n+                    if let UseSegmentKind::Slf(Some(rename)) = last.clone().kind {\n                         *old_rename = Some(rename);\n                         done = true;\n                     }\n@@ -538,15 +588,15 @@ impl UseTree {\n         }\n \n         // Normalise foo::{bar} -> foo::bar\n-        if let UseSegment::List(ref list) = last {\n+        if let UseSegmentKind::List(ref list) = last.kind {\n             if list.len() == 1 && list[0].to_string() != \"self\" {\n                 normalize_sole_list = true;\n             }\n         }\n \n         if normalize_sole_list {\n-            match last {\n-                UseSegment::List(list) => {\n+            match last.kind {\n+                UseSegmentKind::List(list) => {\n                     for seg in &list[0].path {\n                         self.path.push(seg.clone());\n                     }\n@@ -557,10 +607,13 @@ impl UseTree {\n         }\n \n         // Recursively normalize elements of a list use (including sorting the list).\n-        if let UseSegment::List(list) = last {\n+        if let UseSegmentKind::List(list) = last.kind {\n             let mut list = list.into_iter().map(UseTree::normalize).collect::<Vec<_>>();\n             list.sort();\n-            last = UseSegment::List(list);\n+            last = UseSegment {\n+                kind: UseSegmentKind::List(list),\n+                version: last.version,\n+            };\n         }\n \n         self.path.push(last);\n@@ -620,10 +673,10 @@ impl UseTree {\n         if self.path.is_empty() || self.contains_comment() {\n             return vec![self];\n         }\n-        match self.path.clone().last().unwrap() {\n-            UseSegment::List(list) => {\n+        match &self.path.clone().last().unwrap().kind {\n+            UseSegmentKind::List(list) => {\n                 if list.len() == 1 && list[0].path.len() == 1 {\n-                    if let UseSegment::Slf(..) = list[0].path[0] {\n+                    if let UseSegmentKind::Slf(..) = list[0].path[0].kind {\n                         return vec![self];\n                     };\n                 }\n@@ -671,12 +724,15 @@ impl UseTree {\n \n     /// If this tree ends in `::self`, rewrite it to `::{self}`.\n     fn nest_trailing_self(mut self) -> UseTree {\n-        if let Some(UseSegment::Slf(..)) = self.path.last() {\n+        if let Some(UseSegment {\n+            kind: UseSegmentKind::Slf(..),\n+            ..\n+        }) = self.path.last()\n+        {\n             let self_segment = self.path.pop().unwrap();\n-            self.path.push(UseSegment::List(vec![UseTree::from_path(\n-                vec![self_segment],\n-                DUMMY_SP,\n-            )]));\n+            let version = self_segment.version;\n+            let kind = UseSegmentKind::List(vec![UseTree::from_path(vec![self_segment], DUMMY_SP)]);\n+            self.path.push(UseSegment { kind, version });\n         }\n         self\n     }\n@@ -692,15 +748,17 @@ fn merge_rest(\n         return None;\n     }\n     if a.len() != len && b.len() != len {\n-        if let UseSegment::List(ref list) = a[len] {\n+        let version = a[len].version;\n+        if let UseSegmentKind::List(ref list) = a[len].kind {\n             let mut list = list.clone();\n             merge_use_trees_inner(\n                 &mut list,\n                 UseTree::from_path(b[len..].to_vec(), DUMMY_SP),\n                 merge_by,\n             );\n             let mut new_path = b[..len].to_vec();\n-            new_path.push(UseSegment::List(list));\n+            let kind = UseSegmentKind::List(list);\n+            new_path.push(UseSegment { kind, version });\n             return Some(new_path);\n         }\n     } else if len == 1 {\n@@ -709,15 +767,28 @@ fn merge_rest(\n         } else {\n             (&b[0], &a[1..])\n         };\n+        let kind = UseSegmentKind::Slf(common.get_alias().map(ToString::to_string));\n+        let version = a[0].version;\n         let mut list = vec![UseTree::from_path(\n-            vec![UseSegment::Slf(common.get_alias().map(ToString::to_string))],\n+            vec![UseSegment { kind, version }],\n             DUMMY_SP,\n         )];\n         match rest {\n-            [UseSegment::List(rest_list)] => list.extend(rest_list.clone()),\n+            [\n+                UseSegment {\n+                    kind: UseSegmentKind::List(rest_list),\n+                    ..\n+                },\n+            ] => list.extend(rest_list.clone()),\n             _ => list.push(UseTree::from_path(rest.to_vec(), DUMMY_SP)),\n         }\n-        return Some(vec![b[0].clone(), UseSegment::List(list)]);\n+        return Some(vec![\n+            b[0].clone(),\n+            UseSegment {\n+                kind: UseSegmentKind::List(list),\n+                version,\n+            },\n+        ]);\n     } else {\n         len -= 1;\n     }\n@@ -727,7 +798,9 @@ fn merge_rest(\n     ];\n     list.sort();\n     let mut new_path = b[..len].to_vec();\n-    new_path.push(UseSegment::List(list));\n+    let kind = UseSegmentKind::List(list);\n+    let version = a[0].version;\n+    new_path.push(UseSegment { kind, version });\n     Some(new_path)\n }\n \n@@ -805,24 +878,24 @@ impl PartialOrd for UseTree {\n }\n impl Ord for UseSegment {\n     fn cmp(&self, other: &UseSegment) -> Ordering {\n-        use self::UseSegment::*;\n+        use self::UseSegmentKind::*;\n \n         fn is_upper_snake_case(s: &str) -> bool {\n             s.chars()\n                 .all(|c| c.is_uppercase() || c == '_' || c.is_numeric())\n         }\n \n-        match (self, other) {\n-            (&Slf(ref a), &Slf(ref b))\n-            | (&Super(ref a), &Super(ref b))\n-            | (&Crate(ref a), &Crate(ref b)) => match (a, b) {\n+        match (&self.kind, &other.kind) {\n+            (Slf(ref a), Slf(ref b))\n+            | (Super(ref a), Super(ref b))\n+            | (Crate(ref a), Crate(ref b)) => match (a, b) {\n                 (Some(sa), Some(sb)) => {\n                     sa.trim_start_matches(\"r#\").cmp(sb.trim_start_matches(\"r#\"))\n                 }\n                 (_, _) => a.cmp(b),\n             },\n-            (&Glob, &Glob) => Ordering::Equal,\n-            (&Ident(ref pia, ref aa), &Ident(ref pib, ref ab)) => {\n+            (Glob, Glob) => Ordering::Equal,\n+            (Ident(ref pia, ref aa), Ident(ref pib, ref ab)) => {\n                 let ia = pia.trim_start_matches(\"r#\");\n                 let ib = pib.trim_start_matches(\"r#\");\n                 // snake_case < CamelCase < UPPER_SNAKE_CASE\n@@ -851,7 +924,7 @@ impl Ord for UseSegment {\n                     (None, None) => Ordering::Equal,\n                 }\n             }\n-            (&List(ref a), &List(ref b)) => {\n+            (List(ref a), List(ref b)) => {\n                 for (a, b) in a.iter().zip(b.iter()) {\n                     let ord = a.cmp(b);\n                     if ord != Ordering::Equal {\n@@ -861,16 +934,16 @@ impl Ord for UseSegment {\n \n                 a.len().cmp(&b.len())\n             }\n-            (&Slf(_), _) => Ordering::Less,\n-            (_, &Slf(_)) => Ordering::Greater,\n-            (&Super(_), _) => Ordering::Less,\n-            (_, &Super(_)) => Ordering::Greater,\n-            (&Crate(_), _) => Ordering::Less,\n-            (_, &Crate(_)) => Ordering::Greater,\n-            (&Ident(..), _) => Ordering::Less,\n-            (_, &Ident(..)) => Ordering::Greater,\n-            (&Glob, _) => Ordering::Less,\n-            (_, &Glob) => Ordering::Greater,\n+            (Slf(_), _) => Ordering::Less,\n+            (_, Slf(_)) => Ordering::Greater,\n+            (Super(_), _) => Ordering::Less,\n+            (_, Super(_)) => Ordering::Greater,\n+            (Crate(_), _) => Ordering::Less,\n+            (_, Crate(_)) => Ordering::Greater,\n+            (Ident(..), _) => Ordering::Less,\n+            (_, Ident(..)) => Ordering::Greater,\n+            (Glob, _) => Ordering::Less,\n+            (_, Glob) => Ordering::Greater,\n         }\n     }\n }\n@@ -914,7 +987,7 @@ fn rewrite_nested_use_tree(\n     }\n     let has_nested_list = use_tree_list.iter().any(|use_segment| {\n         use_segment.path.last().map_or(false, |last_segment| {\n-            matches!(last_segment, UseSegment::List(..))\n+            matches!(last_segment.kind, UseSegmentKind::List(..))\n         })\n     });\n \n@@ -965,17 +1038,19 @@ fn rewrite_nested_use_tree(\n \n impl Rewrite for UseSegment {\n     fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n-        Some(match self {\n-            UseSegment::Ident(ref ident, Some(ref rename)) => format!(\"{} as {}\", ident, rename),\n-            UseSegment::Ident(ref ident, None) => ident.clone(),\n-            UseSegment::Slf(Some(ref rename)) => format!(\"self as {}\", rename),\n-            UseSegment::Slf(None) => \"self\".to_owned(),\n-            UseSegment::Super(Some(ref rename)) => format!(\"super as {}\", rename),\n-            UseSegment::Super(None) => \"super\".to_owned(),\n-            UseSegment::Crate(Some(ref rename)) => format!(\"crate as {}\", rename),\n-            UseSegment::Crate(None) => \"crate\".to_owned(),\n-            UseSegment::Glob => \"*\".to_owned(),\n-            UseSegment::List(ref use_tree_list) => rewrite_nested_use_tree(\n+        Some(match self.kind {\n+            UseSegmentKind::Ident(ref ident, Some(ref rename)) => {\n+                format!(\"{} as {}\", ident, rename)\n+            }\n+            UseSegmentKind::Ident(ref ident, None) => ident.clone(),\n+            UseSegmentKind::Slf(Some(ref rename)) => format!(\"self as {}\", rename),\n+            UseSegmentKind::Slf(None) => \"self\".to_owned(),\n+            UseSegmentKind::Super(Some(ref rename)) => format!(\"super as {}\", rename),\n+            UseSegmentKind::Super(None) => \"super\".to_owned(),\n+            UseSegmentKind::Crate(Some(ref rename)) => format!(\"crate as {}\", rename),\n+            UseSegmentKind::Crate(None) => \"crate\".to_owned(),\n+            UseSegmentKind::Glob => \"*\".to_owned(),\n+            UseSegmentKind::List(ref use_tree_list) => rewrite_nested_use_tree(\n                 context,\n                 use_tree_list,\n                 // 1 = \"{\" and \"}\"\n@@ -1024,6 +1099,7 @@ mod test {\n \n         struct Parser<'a> {\n             input: Peekable<Chars<'a>>,\n+            version: Version,\n         }\n \n         impl<'a> Parser<'a> {\n@@ -1036,34 +1112,40 @@ mod test {\n             }\n \n             fn push_segment(\n+                &self,\n                 result: &mut Vec<UseSegment>,\n                 buf: &mut String,\n                 alias_buf: &mut Option<String>,\n             ) {\n+                let version = self.version;\n                 if !buf.is_empty() {\n                     let mut alias = None;\n                     swap(alias_buf, &mut alias);\n \n                     match buf.as_ref() {\n                         \"self\" => {\n-                            result.push(UseSegment::Slf(alias));\n+                            let kind = UseSegmentKind::Slf(alias);\n+                            result.push(UseSegment { kind, version });\n                             *buf = String::new();\n                             *alias_buf = None;\n                         }\n                         \"super\" => {\n-                            result.push(UseSegment::Super(alias));\n+                            let kind = UseSegmentKind::Super(alias);\n+                            result.push(UseSegment { kind, version });\n                             *buf = String::new();\n                             *alias_buf = None;\n                         }\n                         \"crate\" => {\n-                            result.push(UseSegment::Crate(alias));\n+                            let kind = UseSegmentKind::Crate(alias);\n+                            result.push(UseSegment { kind, version });\n                             *buf = String::new();\n                             *alias_buf = None;\n                         }\n                         _ => {\n                             let mut name = String::new();\n                             swap(buf, &mut name);\n-                            result.push(UseSegment::Ident(name, alias));\n+                            let kind = UseSegmentKind::Ident(name, alias);\n+                            result.push(UseSegment { kind, version });\n                         }\n                     }\n                 }\n@@ -1078,21 +1160,29 @@ mod test {\n                         '{' => {\n                             assert!(buf.is_empty());\n                             self.bump();\n-                            result.push(UseSegment::List(self.parse_list()));\n+                            let kind = UseSegmentKind::List(self.parse_list());\n+                            result.push(UseSegment {\n+                                kind,\n+                                version: self.version,\n+                            });\n                             self.eat('}');\n                         }\n                         '*' => {\n                             assert!(buf.is_empty());\n                             self.bump();\n-                            result.push(UseSegment::Glob);\n+                            let kind = UseSegmentKind::Glob;\n+                            result.push(UseSegment {\n+                                kind,\n+                                version: self.version,\n+                            });\n                         }\n                         ':' => {\n                             self.bump();\n                             self.eat(':');\n-                            Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                            self.push_segment(&mut result, &mut buf, &mut alias_buf);\n                         }\n                         '}' | ',' => {\n-                            Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                            self.push_segment(&mut result, &mut buf, &mut alias_buf);\n                             return UseTree {\n                                 path: result,\n                                 span: DUMMY_SP,\n@@ -1118,7 +1208,7 @@ mod test {\n                         }\n                     }\n                 }\n-                Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                self.push_segment(&mut result, &mut buf, &mut alias_buf);\n                 UseTree {\n                     path: result,\n                     span: DUMMY_SP,\n@@ -1144,6 +1234,7 @@ mod test {\n \n         let mut parser = Parser {\n             input: s.chars().peekable(),\n+            version: Version::One,\n         };\n         parser.parse_in_list()\n     }"}, {"sha": "9e4a668aa49301319ace07e9bb21dad53d4b3393", "filename": "src/reorder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/795efb206892041e81107cc58797ea61fd1c7b16/src%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/795efb206892041e81107cc58797ea61fd1c7b16/src%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freorder.rs?ref=795efb206892041e81107cc58797ea61fd1c7b16", "patch": "@@ -12,7 +12,7 @@ use rustc_ast::ast;\n use rustc_span::{symbol::sym, Span};\n \n use crate::config::{Config, GroupImportsTactic};\n-use crate::imports::{normalize_use_trees_with_granularity, UseSegment, UseTree};\n+use crate::imports::{normalize_use_trees_with_granularity, UseSegmentKind, UseTree};\n use crate::items::{is_mod_decl, rewrite_extern_crate, rewrite_mod};\n use crate::lists::{itemize_list, write_list, ListFormatting, ListItem};\n use crate::rewrite::RewriteContext;\n@@ -182,16 +182,16 @@ fn group_imports(uts: Vec<UseTree>) -> Vec<Vec<UseTree>> {\n             external_imports.push(ut);\n             continue;\n         }\n-        match &ut.path[0] {\n-            UseSegment::Ident(id, _) => match id.as_ref() {\n+        match &ut.path[0].kind {\n+            UseSegmentKind::Ident(id, _) => match id.as_ref() {\n                 \"std\" | \"alloc\" | \"core\" => std_imports.push(ut),\n                 _ => external_imports.push(ut),\n             },\n-            UseSegment::Slf(_) | UseSegment::Super(_) | UseSegment::Crate(_) => {\n+            UseSegmentKind::Slf(_) | UseSegmentKind::Super(_) | UseSegmentKind::Crate(_) => {\n                 local_imports.push(ut)\n             }\n             // These are probably illegal here\n-            UseSegment::Glob | UseSegment::List(_) => external_imports.push(ut),\n+            UseSegmentKind::Glob | UseSegmentKind::List(_) => external_imports.push(ut),\n         }\n     }\n "}]}