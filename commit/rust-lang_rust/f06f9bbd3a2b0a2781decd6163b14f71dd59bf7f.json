{"sha": "f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f", "node_id": "C_kwDOAAsO6NoAKGYwNmY5YmJkM2EyYjBhMjc4MWRlY2Q2MTYzYjE0ZjcxZGQ1OWJmN2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-24T15:22:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-24T15:22:26Z"}, "message": "Auto merge of #88999 - Migi:master, r=oli-obk\n\nMake `Duration` respect `width` when formatting using `Debug`\n\nWhen printing or writing a `std::time::Duration` using `Debug` formatting, it previously completely ignored any specified `width`. This is unlike types like integers and floats, which do pad to `width`, for both `Display` and `Debug`, though not all types consider `width` in their `Debug` output (see e.g. #30164). Curiously, `Duration`'s `Debug` formatting *did* consider `precision`.\n\nThis PR makes `Duration` pad to `width` just like integers and floats, so that\n```rust\nformat!(\"|{:8?}|\", Duration::from_millis(1234))\n```\nreturns\n```\n|1.234s  |\n```\n\nBefore you ask \"who formats `Debug` output?\", note that `Duration` doesn't actually implement `Display`, so `Debug` is currently the only way to format `Duration`s. I think that's wrong, and `Duration` should get a `Display` implementation, but in the meantime there's no harm in making the `Debug` formatting respect `width` rather than ignore it.\n\nI chose the default alignment to be left-aligned. The general rule Rust uses is: numeric types are right-aligned by default, non-numeric types left-aligned. It wasn't clear to me whether `Duration` is a numeric type or not. The fact that a formatted `Duration` can end with suffixes of variable length (`\"s\"`, `\"ms\"`, `\"\u00b5s\"`, etc.) made me lean towards left-alignment, but it would be trivial to change it.\n\nFixes issue #88059.", "tree": {"sha": "50ef3e4883906b47f8823622ae54516747cc5220", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50ef3e4883906b47f8823622ae54516747cc5220"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f", "html_url": "https://github.com/rust-lang/rust/commit/f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0648eab3686f100c7ab9b0d38472c740079cce4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0648eab3686f100c7ab9b0d38472c740079cce4", "html_url": "https://github.com/rust-lang/rust/commit/a0648eab3686f100c7ab9b0d38472c740079cce4"}, {"sha": "77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10", "url": "https://api.github.com/repos/rust-lang/rust/commits/77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10", "html_url": "https://github.com/rust-lang/rust/commit/77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10"}], "stats": {"total": 136, "additions": 106, "deletions": 30}, "files": [{"sha": "3a0c19d7de56f132f5776b061c85601a91e593aa", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f", "patch": "@@ -1224,7 +1224,7 @@ unsafe fn getcount(args: &[ArgumentV1<'_>], cnt: &rt::v1::Count) -> Option<usize\n \n /// Padding after the end of something. Returned by `Formatter::padding`.\n #[must_use = \"don't forget to write the post padding\"]\n-struct PostPadding {\n+pub(crate) struct PostPadding {\n     fill: char,\n     padding: usize,\n }\n@@ -1235,9 +1235,9 @@ impl PostPadding {\n     }\n \n     /// Write this post padding.\n-    fn write(self, buf: &mut dyn Write) -> Result {\n+    pub(crate) fn write(self, f: &mut Formatter<'_>) -> Result {\n         for _ in 0..self.padding {\n-            buf.write_char(self.fill)?;\n+            f.buf.write_char(self.fill)?;\n         }\n         Ok(())\n     }\n@@ -1360,7 +1360,7 @@ impl<'a> Formatter<'a> {\n                 write_prefix(self, sign, prefix)?;\n                 let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n                 self.buf.write_str(buf)?;\n-                post_padding.write(self.buf)?;\n+                post_padding.write(self)?;\n                 self.fill = old_fill;\n                 self.align = old_align;\n                 Ok(())\n@@ -1370,7 +1370,7 @@ impl<'a> Formatter<'a> {\n                 let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n                 write_prefix(self, sign, prefix)?;\n                 self.buf.write_str(buf)?;\n-                post_padding.write(self.buf)\n+                post_padding.write(self)\n             }\n         }\n     }\n@@ -1445,7 +1445,7 @@ impl<'a> Formatter<'a> {\n                     let align = rt::v1::Alignment::Left;\n                     let post_padding = self.padding(width - chars_count, align)?;\n                     self.buf.write_str(s)?;\n-                    post_padding.write(self.buf)\n+                    post_padding.write(self)\n                 }\n             }\n         }\n@@ -1454,7 +1454,7 @@ impl<'a> Formatter<'a> {\n     /// Write the pre-padding and return the unwritten post-padding. Callers are\n     /// responsible for ensuring post-padding is written after the thing that is\n     /// being padded.\n-    fn padding(\n+    pub(crate) fn padding(\n         &mut self,\n         padding: usize,\n         default: rt::v1::Alignment,\n@@ -1509,7 +1509,7 @@ impl<'a> Formatter<'a> {\n             } else {\n                 let post_padding = self.padding(width - len, align)?;\n                 self.write_formatted_parts(&formatted)?;\n-                post_padding.write(self.buf)\n+                post_padding.write(self)\n             };\n             self.fill = old_fill;\n             self.align = old_align;"}, {"sha": "d1533b8d67a6bf97e1f3360dc3661bd7fcfd96c0", "filename": "library/core/src/time.rs", "status": "modified", "additions": 70, "deletions": 22, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f", "patch": "@@ -1049,11 +1049,16 @@ impl fmt::Debug for Duration {\n         /// `divisor` must not be above 100_000_000. It also should be a power\n         /// of 10, everything else doesn't make sense. `fractional_part` has\n         /// to be less than `10 * divisor`!\n+        ///\n+        /// A prefix and postfix may be added. The whole thing is padded\n+        /// to the formatter's `width`, if specified.\n         fn fmt_decimal(\n             f: &mut fmt::Formatter<'_>,\n             mut integer_part: u64,\n             mut fractional_part: u32,\n             mut divisor: u32,\n+            prefix: &str,\n+            postfix: &str,\n         ) -> fmt::Result {\n             // Encode the fractional part into a temporary buffer. The buffer\n             // only need to hold 9 elements, because `fractional_part` has to\n@@ -1114,48 +1119,91 @@ impl fmt::Debug for Duration {\n             // set, we only use all digits up to the last non-zero one.\n             let end = f.precision().map(|p| crate::cmp::min(p, 9)).unwrap_or(pos);\n \n-            // If we haven't emitted a single fractional digit and the precision\n-            // wasn't set to a non-zero value, we don't print the decimal point.\n-            if end == 0 {\n-                write!(f, \"{}\", integer_part)\n-            } else {\n-                // SAFETY: We are only writing ASCII digits into the buffer and it was\n-                // initialized with '0's, so it contains valid UTF8.\n-                let s = unsafe { crate::str::from_utf8_unchecked(&buf[..end]) };\n+            // This closure emits the formatted duration without emitting any\n+            // padding (padding is calculated below).\n+            let emit_without_padding = |f: &mut fmt::Formatter<'_>| {\n+                write!(f, \"{}{}\", prefix, integer_part)?;\n+\n+                // Write the decimal point and the fractional part (if any).\n+                if end > 0 {\n+                    // SAFETY: We are only writing ASCII digits into the buffer and\n+                    // it was initialized with '0's, so it contains valid UTF8.\n+                    let s = unsafe { crate::str::from_utf8_unchecked(&buf[..end]) };\n+\n+                    // If the user request a precision > 9, we pad '0's at the end.\n+                    let w = f.precision().unwrap_or(pos);\n+                    write!(f, \".{:0<width$}\", s, width = w)?;\n+                }\n \n-                // If the user request a precision > 9, we pad '0's at the end.\n-                let w = f.precision().unwrap_or(pos);\n-                write!(f, \"{}.{:0<width$}\", integer_part, s, width = w)\n+                write!(f, \"{}\", postfix)\n+            };\n+\n+            match f.width() {\n+                None => {\n+                    // No `width` specified. There's no need to calculate the\n+                    // length of the output in this case, just emit it.\n+                    emit_without_padding(f)\n+                }\n+                Some(requested_w) => {\n+                    // A `width` was specified. Calculate the actual width of\n+                    // the output in order to calculate the required padding.\n+                    // It consists of 4 parts:\n+                    // 1. The prefix: is either \"+\" or \"\", so we can just use len().\n+                    // 2. The postfix: can be \"\u00b5s\" so we have to count UTF8 characters.\n+                    let mut actual_w = prefix.len() + postfix.chars().count();\n+                    // 3. The integer part:\n+                    if let Some(log) = integer_part.checked_log10() {\n+                        // integer_part is > 0, so has length log10(x)+1\n+                        actual_w += 1 + log as usize;\n+                    } else {\n+                        // integer_part is 0, so has length 1.\n+                        actual_w += 1;\n+                    }\n+                    // 4. The fractional part (if any):\n+                    if end > 0 {\n+                        let frac_part_w = f.precision().unwrap_or(pos);\n+                        actual_w += 1 + frac_part_w;\n+                    }\n+\n+                    if requested_w <= actual_w {\n+                        // Output is already longer than `width`, so don't pad.\n+                        emit_without_padding(f)\n+                    } else {\n+                        // We need to add padding. Use the `Formatter::padding` helper function.\n+                        let default_align = crate::fmt::rt::v1::Alignment::Left;\n+                        let post_padding = f.padding(requested_w - actual_w, default_align)?;\n+                        emit_without_padding(f)?;\n+                        post_padding.write(f)\n+                    }\n+                }\n             }\n         }\n \n         // Print leading '+' sign if requested\n-        if f.sign_plus() {\n-            write!(f, \"+\")?;\n-        }\n+        let prefix = if f.sign_plus() { \"+\" } else { \"\" };\n \n         if self.secs > 0 {\n-            fmt_decimal(f, self.secs, self.nanos, NANOS_PER_SEC / 10)?;\n-            f.write_str(\"s\")\n+            fmt_decimal(f, self.secs, self.nanos, NANOS_PER_SEC / 10, prefix, \"s\")\n         } else if self.nanos >= NANOS_PER_MILLI {\n             fmt_decimal(\n                 f,\n                 (self.nanos / NANOS_PER_MILLI) as u64,\n                 self.nanos % NANOS_PER_MILLI,\n                 NANOS_PER_MILLI / 10,\n-            )?;\n-            f.write_str(\"ms\")\n+                prefix,\n+                \"ms\",\n+            )\n         } else if self.nanos >= NANOS_PER_MICRO {\n             fmt_decimal(\n                 f,\n                 (self.nanos / NANOS_PER_MICRO) as u64,\n                 self.nanos % NANOS_PER_MICRO,\n                 NANOS_PER_MICRO / 10,\n-            )?;\n-            f.write_str(\"\u00b5s\")\n+                prefix,\n+                \"\u00b5s\",\n+            )\n         } else {\n-            fmt_decimal(f, self.nanos as u64, 0, 1)?;\n-            f.write_str(\"ns\")\n+            fmt_decimal(f, self.nanos as u64, 0, 1, prefix, \"ns\")\n         }\n     }\n }"}, {"sha": "fe2d2f2412daa1fe79357396d0fb712f32eba761", "filename": "library/core/tests/time.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f/library%2Fcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f/library%2Fcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ftime.rs?ref=f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f", "patch": "@@ -313,6 +313,34 @@ fn debug_formatting_precision_two() {\n     assert_eq!(format!(\"{:.2?}\", Duration::new(8, 999_999_999)), \"9.00s\");\n }\n \n+#[test]\n+fn debug_formatting_padding() {\n+    assert_eq!(\"0ns      \", format!(\"{:<9?}\", Duration::new(0, 0)));\n+    assert_eq!(\"      0ns\", format!(\"{:>9?}\", Duration::new(0, 0)));\n+    assert_eq!(\"   0ns   \", format!(\"{:^9?}\", Duration::new(0, 0)));\n+    assert_eq!(\"123ns    \", format!(\"{:<9.0?}\", Duration::new(0, 123)));\n+    assert_eq!(\"    123ns\", format!(\"{:>9.0?}\", Duration::new(0, 123)));\n+    assert_eq!(\"  123ns  \", format!(\"{:^9.0?}\", Duration::new(0, 123)));\n+    assert_eq!(\"123.0ns  \", format!(\"{:<9.1?}\", Duration::new(0, 123)));\n+    assert_eq!(\"  123.0ns\", format!(\"{:>9.1?}\", Duration::new(0, 123)));\n+    assert_eq!(\" 123.0ns \", format!(\"{:^9.1?}\", Duration::new(0, 123)));\n+    assert_eq!(\"7.1\u00b5s    \", format!(\"{:<9?}\", Duration::new(0, 7_100)));\n+    assert_eq!(\"    7.1\u00b5s\", format!(\"{:>9?}\", Duration::new(0, 7_100)));\n+    assert_eq!(\"  7.1\u00b5s  \", format!(\"{:^9?}\", Duration::new(0, 7_100)));\n+    assert_eq!(\"999.123456ms\", format!(\"{:<9?}\", Duration::new(0, 999_123_456)));\n+    assert_eq!(\"999.123456ms\", format!(\"{:>9?}\", Duration::new(0, 999_123_456)));\n+    assert_eq!(\"999.123456ms\", format!(\"{:^9?}\", Duration::new(0, 999_123_456)));\n+    assert_eq!(\"5s       \", format!(\"{:<9?}\", Duration::new(5, 0)));\n+    assert_eq!(\"       5s\", format!(\"{:>9?}\", Duration::new(5, 0)));\n+    assert_eq!(\"   5s    \", format!(\"{:^9?}\", Duration::new(5, 0)));\n+    assert_eq!(\"5.000000000000s\", format!(\"{:<9.12?}\", Duration::new(5, 0)));\n+    assert_eq!(\"5.000000000000s\", format!(\"{:>9.12?}\", Duration::new(5, 0)));\n+    assert_eq!(\"5.000000000000s\", format!(\"{:^9.12?}\", Duration::new(5, 0)));\n+\n+    // default alignment is left:\n+    assert_eq!(\"5s       \", format!(\"{:9?}\", Duration::new(5, 0)));\n+}\n+\n #[test]\n fn debug_formatting_precision_high() {\n     assert_eq!(format!(\"{:.5?}\", Duration::new(0, 23_678)), \"23.67800\u00b5s\");"}]}