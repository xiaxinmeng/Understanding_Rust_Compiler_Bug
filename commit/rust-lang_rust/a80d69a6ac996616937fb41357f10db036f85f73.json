{"sha": "a80d69a6ac996616937fb41357f10db036f85f73", "node_id": "C_kwDOAAsO6NoAKGE4MGQ2OWE2YWM5OTY2MTY5MzdmYjQxMzU3ZjEwZGIwMzZmODVmNzM", "commit": {"author": {"name": "jyn", "email": "github@jyn.dev", "date": "2023-04-22T14:53:22Z"}, "committer": {"name": "jyn", "email": "github@jyn.dev", "date": "2023-05-31T04:40:51Z"}, "message": "Fix `x test --stage 2 core` when download-rustc is enabled\n\nThis works by building std from source unconditionally instead of downloading it, for library tests only.\n\nThis was somewhat complicated because of the following requirements:\n1. Unconditionally downloading libstd breaks `x test std`, because `coretests` requires the std loaded from the sysroot to match the std that's currently being tested.\n2. Unconditionally rebuilding libstd breaks `x test ui-fulldeps librustdoc`, because anything loading `rustc_private` needs to use the same libstd that rustc was built with.\n\nBreak the knot by introducing a new `stage2-test-sysroot`, used only for testing `std` itself. This\nholds a freshly compiled std, while `stage2` and `ci-rustc-sysroot` still hold the downloaded std.\n\nThis also extends the existing `cp_filtered` in Sysroot to apply to the `rust-std` component, not just the `rustc-dev` component.", "tree": {"sha": "47e6e58bb40f4162bfb43b3a91ec8626d04bd57c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47e6e58bb40f4162bfb43b3a91ec8626d04bd57c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a80d69a6ac996616937fb41357f10db036f85f73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a80d69a6ac996616937fb41357f10db036f85f73", "html_url": "https://github.com/rust-lang/rust/commit/a80d69a6ac996616937fb41357f10db036f85f73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a80d69a6ac996616937fb41357f10db036f85f73/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f0a26607f324ad2d630c39e718e55725f8b108d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f0a26607f324ad2d630c39e718e55725f8b108d", "html_url": "https://github.com/rust-lang/rust/commit/2f0a26607f324ad2d630c39e718e55725f8b108d"}], "stats": {"total": 189, "additions": 149, "deletions": 40}, "files": [{"sha": "b69f99c5e78067b585d662149099c54f5417cae3", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a80d69a6ac996616937fb41357f10db036f85f73/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80d69a6ac996616937fb41357f10db036f85f73/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=a80d69a6ac996616937fb41357f10db036f85f73", "patch": "@@ -992,7 +992,7 @@ impl<'a> Builder<'a> {\n     }\n \n     pub fn sysroot(&self, compiler: Compiler) -> Interned<PathBuf> {\n-        self.ensure(compile::Sysroot { compiler })\n+        self.ensure(compile::Sysroot::new(compiler))\n     }\n \n     /// Returns the libdir where the standard library and other artifacts are"}, {"sha": "7c09d2043f1167777a0573cbe9060277e2fdfb1c", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 92, "deletions": 28, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/a80d69a6ac996616937fb41357f10db036f85f73/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80d69a6ac996616937fb41357f10db036f85f73/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=a80d69a6ac996616937fb41357f10db036f85f73", "patch": "@@ -40,11 +40,18 @@ pub struct Std {\n     ///\n     /// This shouldn't be used from other steps; see the comment on [`Rustc`].\n     crates: Interned<Vec<String>>,\n+    /// When using download-rustc, we need to use a new build of `std` for running unit tests of Std itself,\n+    /// but we need to use the downloaded copy of std for linking to rustdoc. Allow this to be overriden by `builder.ensure` from other steps.\n+    force_recompile: bool,\n }\n \n impl Std {\n     pub fn new(compiler: Compiler, target: TargetSelection) -> Self {\n-        Self { target, compiler, crates: Default::default() }\n+        Self { target, compiler, crates: Default::default(), force_recompile: false }\n+    }\n+\n+    pub fn force_recompile(compiler: Compiler, target: TargetSelection) -> Self {\n+        Self { target, compiler, crates: Default::default(), force_recompile: true }\n     }\n }\n \n@@ -77,6 +84,7 @@ impl Step for Std {\n             compiler: run.builder.compiler(run.builder.top_stage, run.build_triple()),\n             target: run.target,\n             crates: make_run_crates(&run, \"library\"),\n+            force_recompile: false,\n         });\n     }\n \n@@ -89,11 +97,20 @@ impl Step for Std {\n         let target = self.target;\n         let compiler = self.compiler;\n \n-        // When using `download-rustc`, we already have artifacts for the host available\n-        // (they were copied in `impl Step for Sysroot`). Don't recompile them.\n-        // NOTE: the ABI of the beta compiler is different from the ABI of the downloaded compiler,\n-        // so its artifacts can't be reused.\n-        if builder.download_rustc() && compiler.stage != 0 && target == builder.build.build {\n+        // When using `download-rustc`, we already have artifacts for the host available. Don't\n+        // recompile them.\n+        if builder.download_rustc() && target == builder.build.build\n+            // NOTE: the beta compiler may generate different artifacts than the downloaded compiler, so\n+            // its artifacts can't be reused.\n+            && compiler.stage != 0\n+            // This check is specific to testing std itself; see `test::Std` for more details.\n+            && !self.force_recompile\n+        {\n+            cp_rustc_component_to_ci_sysroot(\n+                builder,\n+                compiler,\n+                builder.config.ci_rust_std_contents(),\n+            );\n             return;\n         }\n \n@@ -428,6 +445,8 @@ struct StdLink {\n     pub target: TargetSelection,\n     /// Not actually used; only present to make sure the cache invalidation is correct.\n     crates: Interned<Vec<String>>,\n+    /// See [`Std::force_recompile`].\n+    force_recompile: bool,\n }\n \n impl StdLink {\n@@ -437,6 +456,7 @@ impl StdLink {\n             target_compiler: std.compiler,\n             target: std.target,\n             crates: std.crates,\n+            force_recompile: std.force_recompile,\n         }\n     }\n }\n@@ -460,8 +480,24 @@ impl Step for StdLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        let libdir = builder.sysroot_libdir(target_compiler, target);\n-        let hostdir = builder.sysroot_libdir(target_compiler, compiler.host);\n+\n+        // NOTE: intentionally does *not* check `target == builder.build` to avoid having to add the same check in `test::Crate`.\n+        let (libdir, hostdir) = if self.force_recompile && builder.download_rustc() {\n+            // NOTE: copies part of `sysroot_libdir` to avoid having to add a new `force_recompile` argument there too\n+            let lib = builder.sysroot_libdir_relative(self.compiler);\n+            let sysroot = builder.ensure(crate::compile::Sysroot {\n+                compiler: self.compiler,\n+                force_recompile: self.force_recompile,\n+            });\n+            let libdir = sysroot.join(lib).join(\"rustlib\").join(target.triple).join(\"lib\");\n+            let hostdir = sysroot.join(lib).join(\"rustlib\").join(compiler.host.triple).join(\"lib\");\n+            (INTERNER.intern_path(libdir), INTERNER.intern_path(hostdir))\n+        } else {\n+            let libdir = builder.sysroot_libdir(target_compiler, target);\n+            let hostdir = builder.sysroot_libdir(target_compiler, compiler.host);\n+            (libdir, hostdir)\n+        };\n+\n         add_to_sysroot(builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n     }\n }\n@@ -594,6 +630,25 @@ impl Step for StartupObjects {\n     }\n }\n \n+fn cp_rustc_component_to_ci_sysroot(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    contents: Vec<String>,\n+) {\n+    let sysroot = builder.ensure(Sysroot { compiler, force_recompile: false });\n+\n+    let ci_rustc_dir = builder.out.join(&*builder.build.build.triple).join(\"ci-rustc\");\n+    for file in contents {\n+        let src = ci_rustc_dir.join(&file);\n+        let dst = sysroot.join(file);\n+        if src.is_dir() {\n+            t!(fs::create_dir_all(dst));\n+        } else {\n+            builder.copy(&src, &dst);\n+        }\n+    }\n+}\n+\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n     pub target: TargetSelection,\n@@ -653,18 +708,11 @@ impl Step for Rustc {\n         if builder.download_rustc() && compiler.stage != 0 {\n             // Copy the existing artifacts instead of rebuilding them.\n             // NOTE: this path is only taken for tools linking to rustc-dev (including ui-fulldeps tests).\n-            let sysroot = builder.ensure(Sysroot { compiler });\n-\n-            let ci_rustc_dir = builder.out.join(&*builder.build.build.triple).join(\"ci-rustc\");\n-            for file in builder.config.rustc_dev_contents() {\n-                let src = ci_rustc_dir.join(&file);\n-                let dst = sysroot.join(file);\n-                if src.is_dir() {\n-                    t!(fs::create_dir_all(dst));\n-                } else {\n-                    builder.copy(&src, &dst);\n-                }\n-            }\n+            cp_rustc_component_to_ci_sysroot(\n+                builder,\n+                compiler,\n+                builder.config.ci_rustc_dev_contents(),\n+            );\n             return;\n         }\n \n@@ -1225,6 +1273,14 @@ pub fn compiler_file(\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Sysroot {\n     pub compiler: Compiler,\n+    /// See [`Std::force_recompile`].\n+    force_recompile: bool,\n+}\n+\n+impl Sysroot {\n+    pub(crate) fn new(compiler: Compiler) -> Self {\n+        Sysroot { compiler, force_recompile: false }\n+    }\n }\n \n impl Step for Sysroot {\n@@ -1247,6 +1303,8 @@ impl Step for Sysroot {\n         let sysroot_dir = |stage| {\n             if stage == 0 {\n                 host_dir.join(\"stage0-sysroot\")\n+            } else if self.force_recompile && stage == compiler.stage {\n+                host_dir.join(format!(\"stage{stage}-test-sysroot\"))\n             } else if builder.download_rustc() && compiler.stage != builder.top_stage {\n                 host_dir.join(\"ci-rustc-sysroot\")\n             } else {\n@@ -1286,14 +1344,19 @@ impl Step for Sysroot {\n             // 2. The sysroot is deleted and recreated between each invocation, so running `x test\n             //    ui-fulldeps && x test ui` can't cause failures.\n             let mut filtered_files = Vec::new();\n-            // Don't trim directories or files that aren't loaded per-target; they can't cause conflicts.\n-            let suffix = format!(\"lib/rustlib/{}/lib\", compiler.host);\n-            for path in builder.config.rustc_dev_contents() {\n-                let path = Path::new(&path);\n-                if path.parent().map_or(false, |parent| parent.ends_with(&suffix)) {\n-                    filtered_files.push(path.file_name().unwrap().to_owned());\n+            let mut add_filtered_files = |suffix, contents| {\n+                for path in contents {\n+                    let path = Path::new(&path);\n+                    if path.parent().map_or(false, |parent| parent.ends_with(&suffix)) {\n+                        filtered_files.push(path.file_name().unwrap().to_owned());\n+                    }\n                 }\n-            }\n+            };\n+            let suffix = format!(\"lib/rustlib/{}/lib\", compiler.host);\n+            add_filtered_files(suffix.as_str(), builder.config.ci_rustc_dev_contents());\n+            // NOTE: we can't copy std eagerly because `stage2-test-sysroot` needs to have only the\n+            // newly compiled std, not the downloaded std.\n+            add_filtered_files(\"lib\", builder.config.ci_rust_std_contents());\n \n             let filtered_extensions = [OsStr::new(\"rmeta\"), OsStr::new(\"rlib\"), OsStr::new(\"so\")];\n             let ci_rustc_dir = builder.ci_rustc_dir(builder.config.build);\n@@ -1411,7 +1474,8 @@ impl Step for Assemble {\n \n         // If we're downloading a compiler from CI, we can use the same compiler for all stages other than 0.\n         if builder.download_rustc() {\n-            let sysroot = builder.ensure(Sysroot { compiler: target_compiler });\n+            let sysroot =\n+                builder.ensure(Sysroot { compiler: target_compiler, force_recompile: false });\n             // Ensure that `libLLVM.so` ends up in the newly created target directory,\n             // so that tools using `rustc_private` can use it.\n             dist::maybe_install_llvm_target(builder, target_compiler.host, &sysroot);"}, {"sha": "c18e7ed5a56c9acb0cdfe960ece4c0ba6068e64d", "filename": "src/bootstrap/download.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a80d69a6ac996616937fb41357f10db036f85f73/src%2Fbootstrap%2Fdownload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80d69a6ac996616937fb41357f10db036f85f73/src%2Fbootstrap%2Fdownload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload.rs?ref=a80d69a6ac996616937fb41357f10db036f85f73", "patch": "@@ -270,11 +270,8 @@ impl Config {\n         // `compile::Sysroot` needs to know the contents of the `rustc-dev` tarball to avoid adding\n         // it to the sysroot unless it was explicitly requested. But parsing the 100 MB tarball is slow.\n         // Cache the entries when we extract it so we only have to read it once.\n-        let mut recorded_entries = if dst.ends_with(\"ci-rustc\") && pattern == \"rustc-dev\" {\n-            Some(BufWriter::new(t!(File::create(dst.join(\".rustc-dev-contents\")))))\n-        } else {\n-            None\n-        };\n+        let mut recorded_entries =\n+            if dst.ends_with(\"ci-rustc\") { recorded_entries(dst, pattern) } else { None };\n \n         for member in t!(tar.entries()) {\n             let mut member = t!(member);\n@@ -331,6 +328,17 @@ impl Config {\n     }\n }\n \n+fn recorded_entries(dst: &Path, pattern: &str) -> Option<BufWriter<File>> {\n+    let name = if pattern == \"rustc-dev\" {\n+        \".rustc-dev-contents\"\n+    } else if pattern.starts_with(\"rust-std\") {\n+        \".rust-std-contents\"\n+    } else {\n+        return None;\n+    };\n+    Some(BufWriter::new(t!(File::create(dst.join(name)))))\n+}\n+\n enum DownloadSource {\n     CI,\n     Dist,\n@@ -381,11 +389,20 @@ impl Config {\n         Some(rustfmt_path)\n     }\n \n-    pub(crate) fn rustc_dev_contents(&self) -> Vec<String> {\n+    pub(crate) fn ci_rust_std_contents(&self) -> Vec<String> {\n+        self.ci_component_contents(\".rust-std-contents\")\n+    }\n+\n+    pub(crate) fn ci_rustc_dev_contents(&self) -> Vec<String> {\n+        self.ci_component_contents(\".rustc-dev-contents\")\n+    }\n+\n+    fn ci_component_contents(&self, stamp_file: &str) -> Vec<String> {\n         assert!(self.download_rustc());\n         let ci_rustc_dir = self.out.join(&*self.build.triple).join(\"ci-rustc\");\n-        let rustc_dev_contents_file = t!(File::open(ci_rustc_dir.join(\".rustc-dev-contents\")));\n-        t!(BufReader::new(rustc_dev_contents_file).lines().collect())\n+        let stamp_file = ci_rustc_dir.join(stamp_file);\n+        let contents_file = t!(File::open(&stamp_file), stamp_file.display().to_string());\n+        t!(BufReader::new(contents_file).lines().collect())\n     }\n \n     pub(crate) fn download_ci_rustc(&self, commit: &str) {"}, {"sha": "ed524a2c4b1b489b5138ecd4377bb4ac34c3e1b3", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a80d69a6ac996616937fb41357f10db036f85f73/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80d69a6ac996616937fb41357f10db036f85f73/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=a80d69a6ac996616937fb41357f10db036f85f73", "patch": "@@ -1777,7 +1777,13 @@ impl Step for BookTest {\n     /// This uses the `rustdoc` that sits next to `compiler`.\n     fn run(self, builder: &Builder<'_>) {\n         let host = self.compiler.host;\n-        let _guard = builder.msg(Kind::Test, self.compiler.stage, &format!(\"book {}\", self.name), host, host);\n+        let _guard = builder.msg(\n+            Kind::Test,\n+            self.compiler.stage,\n+            &format!(\"book {}\", self.name),\n+            host,\n+            host,\n+        );\n         // External docs are different from local because:\n         // - Some books need pre-processing by mdbook before being tested.\n         // - They need to save their state to toolstate.\n@@ -2202,7 +2208,8 @@ impl Step for Crate {\n         let target = self.target;\n         let mode = self.mode;\n \n-        builder.ensure(compile::Std::new(compiler, target));\n+        // See [field@compile::Std::force_recompile].\n+        builder.ensure(compile::Std::force_recompile(compiler, target));\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n         // If we're not doing a full bootstrap but we're testing a stage2\n@@ -2216,6 +2223,16 @@ impl Step for Crate {\n         match mode {\n             Mode::Std => {\n                 compile::std_cargo(builder, target, compiler.stage, &mut cargo);\n+                // `std_cargo` actually does the wrong thing: it passes `--sysroot build/host/stage2`,\n+                // but we want to use the force-recompile std we just built in `build/host/stage2-test-sysroot`.\n+                // Override it.\n+                if builder.download_rustc() {\n+                    let sysroot = builder\n+                        .out\n+                        .join(compiler.host.triple)\n+                        .join(format!(\"stage{}-test-sysroot\", compiler.stage));\n+                    cargo.env(\"RUSTC_SYSROOT\", sysroot);\n+                }\n             }\n             Mode::Rustc => {\n                 compile::rustc_cargo(builder, &mut cargo, target, compiler.stage);\n@@ -2267,6 +2284,11 @@ impl Step for CrateRustdoc {\n             // isn't really necessary.\n             builder.compiler_for(builder.top_stage, target, target)\n         };\n+        // NOTE: normally `ensure(Rustc)` automatically runs `ensure(Std)` for us. However, when\n+        // using `download-rustc`, the rustc_private artifacts may be in a *different sysroot* from\n+        // the target rustdoc (`ci-rustc-sysroot` vs `stage2`). In that case, we need to ensure this\n+        // explicitly to make sure it ends up in the stage2 sysroot.\n+        builder.ensure(compile::Std::new(compiler, target));\n         builder.ensure(compile::Rustc::new(compiler, target));\n \n         let mut cargo = tool::prepare_tool_cargo(\n@@ -2318,7 +2340,13 @@ impl Step for CrateRustdoc {\n         dylib_path.insert(0, PathBuf::from(&*libdir));\n         cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n-        let _guard = builder.msg(builder.kind, compiler.stage, \"rustdoc\", compiler.host, target);\n+        let _guard = builder.msg_sysroot_tool(\n+            builder.kind,\n+            compiler.stage,\n+            \"rustdoc\",\n+            compiler.host,\n+            target,\n+        );\n         run_cargo_test(\n             cargo,\n             &[],"}]}