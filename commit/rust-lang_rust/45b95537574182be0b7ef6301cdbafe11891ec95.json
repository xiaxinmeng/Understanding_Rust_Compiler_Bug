{"sha": "45b95537574182be0b7ef6301cdbafe11891ec95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1Yjk1NTM3NTc0MTgyYmUwYjdlZjYzMDFjZGJhZmUxMTg5MWVjOTU=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-13T07:25:44Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-13T07:25:44Z"}, "message": "added follow flag", "tree": {"sha": "24c57792d18ea0c09ec4f92034f91674d5c41418", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24c57792d18ea0c09ec4f92034f91674d5c41418"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45b95537574182be0b7ef6301cdbafe11891ec95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45b95537574182be0b7ef6301cdbafe11891ec95", "html_url": "https://github.com/rust-lang/rust/commit/45b95537574182be0b7ef6301cdbafe11891ec95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45b95537574182be0b7ef6301cdbafe11891ec95/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38e8d2bc060607ebf9a37919752e1de15f1794fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/38e8d2bc060607ebf9a37919752e1de15f1794fa", "html_url": "https://github.com/rust-lang/rust/commit/38e8d2bc060607ebf9a37919752e1de15f1794fa"}], "stats": {"total": 154, "additions": 113, "deletions": 41}, "files": [{"sha": "38044bbea5ccab987f75d5f21cbe87fd253a802a", "filename": "src/const.rs", "status": "modified", "additions": 113, "deletions": 41, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/45b95537574182be0b7ef6301cdbafe11891ec95/src%2Fconst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45b95537574182be0b7ef6301cdbafe11891ec95/src%2Fconst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconst.rs?ref=45b95537574182be0b7ef6301cdbafe11891ec95", "patch": "@@ -3,60 +3,74 @@ use rustc::middle::const_eval::lookup_const_by_id;\n use syntax::ast::*;\n use syntax::ptr::P;\n \n+pub enum FloatWidth {\n+    Fw32,\n+    Fw64,\n+    FwAny\n+}\n+\n+impl From<FloatTy> for FloatWidth {\n+    fn from(ty: FloatTy) -> FloatWidth {\n+        match ty {\n+            TyF32 => Fw32,\n+            TyF64 => Fw64,\n+        }\n+    }\n+}\n+\n /// a Lit_-like enum to fold constant `Expr`s into\n #[derive(PartialEq, Eq, Debug, Clone)]\n pub enum Constant {\n+    /// a String \"abc\"\n     ConstantStr(&'static str, StrStyle),\n+    /// a Binary String b\"abc\"\n     ConstantBinary(Rc<Vec<u8>>),\n+    /// a single byte b'a'\n     ConstantByte(u8),\n+    /// a single char 'a'\n     ConstantChar(char),\n+    /// an integer\n     ConstantInt(u64, LitIntType),\n-    ConstantFloat(Cow<'static, str>, FloatTy),\n-    ConstantFloatUnsuffixed(Cow<'static, str>),\n+    /// a float with given type\n+    ConstantFloat(Cow<'static, str>, FloatWidth),\n+    /// true or false\n     ConstantBool(bool),\n+    /// an array of constants\n     ConstantVec(Vec<Constant>),\n+    /// also an array, but with only one constant, repeated N times\n+    ConstantRepeat(Constant, usize),\n+    /// a tuple of constants\n     ConstantTuple(Vec<Constant>),\n }\n \n /// simple constant folding\n-pub fn constant(cx: &Context, e: &Expr) -> Option<Constant> {\n+pub fn constant(cx: &Context, e: &Expr, follow: bool) -> Option<Constant> {\n     match e {\n-        &ExprParen(ref inner) => constant(cx, inner),\n-        &ExprPath(_, _) => fetch_path(cx, e),\n-        &ExprBlock(ref block) => constant_block(cx, inner),\n-        &ExprIf(ref cond, ref then, ref otherwise) => \n+        &ExprParen(ref inner) => constant(cx, inner, follow),\n+        &ExprPath(_, _) => if follow { fetch_path(cx, e) } else { None },\n+        &ExprBlock(ref block) => constant_block(cx, inner, follow),\n+        &ExprIf(ref cond, ref then, ref otherwise) =>\n             match constant(cx, cond) {\n-                Some(ConstantBool(true)) => constant(cx, then),\n-                Some(ConstantBool(false)) => constant(cx, otherwise),\n+                Some(ConstantBool(true)) => constant(cx, then, follow),\n+                Some(ConstantBool(false)) => constant(cx, otherwise, follow),\n                 _ => None,\n             },\n         &ExprLit(ref lit) => Some(lit_to_constant(lit)),\n-        &ExprVec(ref vec) => constant_vec(cx, vec),\n-        &ExprTup(ref tup) => constant_tup(cx, tup),\n-        &ExprUnary(op, ref operand) => constant(cx, operand).and_then(\n+        &ExprVec(ref vec) => constant_vec(cx, vec, follow),\n+        &ExprTup(ref tup) => constant_tup(cx, tup, follow),\n+        &ExprRepeat(ref value, ref number) =>\n+            constant_binop_apply(cx, value, number,|v, n| ConstantRepeat(v, n)),\n+        &ExprUnary(op, ref operand) => constant(cx, operand, follow).and_then(\n             |o| match op {\n                 UnNot =>\n                     if let ConstantBool(b) = o {\n                         Some(ConstantBool(!b))\n                     } else { None },\n-                UnNeg =>\n-                    match o {\n-                        &ConstantInt(value, ty) =>\n-                            Some(ConstantInt(value, match ty {\n-                                SignedIntLit(ity, sign) => \n-                                    SignedIntLit(ity, neg_sign(sign)),\n-                                UnsuffixedIntLit(sign) =>\n-                                    UnsuffixedIntLit(neg_sign(sign)),\n-                                _ => { return None; },\n-                            })),\n-                        &LitFloat(ref is, ref ty) =>\n-                            Some(ConstantFloat(neg_float_str(is), ty)),\n-                        &LitFloatUnsuffixed(ref is) => \n-                            Some(ConstantFloatUnsuffixed(neg_float_str(is))),\n-                        _ => None,\n-                    },\n+                UnNeg => constant_negate(o),\n                 UnUniq | UnDeref => o,\n             }),\n+        &ExprBinary(op, ref left, ref right) =>\n+            constant_binop(cx, op, left, right, follow),\n         //TODO: add other expressions\n         _ => None,\n     }\n@@ -69,30 +83,30 @@ fn lit_to_constant(lit: &Lit_) -> Constant {\n         &LitByte(b) => ConstantByte(b),\n         &LitChar(c) => ConstantChar(c),\n         &LitInt(value, ty) => ConstantInt(value, ty),\n-        &LitFloat(ref is, ty) => ConstantFloat(Cow::Borrowed(&*is), ty),\n-        &LitFloatUnsuffixed(InternedString) => \n-            ConstantFloatUnsuffixed(Cow::Borrowed(&*is)),\n+        &LitFloat(ref is, ty) => ConstantFloat(Cow::Borrowed(&*is), ty.into()),\n+        &LitFloatUnsuffixed(InternedString) =>\n+                ConstantFloat(Cow::Borrowed(&*is), FwAny),\n         &LitBool(b) => ConstantBool(b),\n     }\n }\n \n /// create `Some(ConstantVec(..))` of all constants, unless there is any\n /// non-constant part\n-fn constant_vec(cx: &Context, vec: &[&Expr]) -> Option<Constant> {\n-    Vec<Constant> parts = Vec::new();\n+fn constant_vec(cx: &Context, vec: &[&Expr], follow: bool) -> Option<Constant> {\n+    parts = Vec::new();\n     for opt_part in vec {\n-        match constant(cx, opt_part) {\n+        match constant(cx, opt_part, follow) {\n             Some(ref p) => parts.push(p),\n             None => { return None; },\n         }\n     }\n     Some(ConstantVec(parts))\n }\n \n-fn constant_tup(cx, &Context, tup: &[&Expr]) -> Option<Constant> {\n-    Vec<Constant> parts = Vec::new();\n+fn constant_tup(cx: &Context, tup: &[&Expr], follow: bool) -> Option<Constant> {\n+    parts = Vec::new();\n     for opt_part in vec {\n-        match constant(cx, opt_part) {\n+        match constant(cx, opt_part, follow) {\n             Some(ref p) => parts.push(p),\n             None => { return None; },\n         }\n@@ -109,23 +123,81 @@ fn fetch_path(cx: &Context, e: &Expr) -> Option<Constant> {\n }\n \n /// A block can only yield a constant if it only has one constant expression\n-fn constant_block(cx: &Context, block: &Block) -> Option<Constant> {\n+fn constant_block(cx: &Context, block: &Block, follow: bool) -> Option<Constant> {\n     if block.stmts.is_empty() {\n-        block.expr.map(|b| constant(cx, b)) \n+        block.expr.map(|b| constant(cx, b, follow))\n     } else { None }\n }\n \n+fn constant_negate(o: Constant) -> Option<Constant> {\n+    match o {\n+        &ConstantInt(value, ty) =>\n+            Some(ConstantInt(value, match ty {\n+                SignedIntLit(ity, sign) => SignedIntLit(ity, neg_sign(sign)),\n+                UnsuffixedIntLit(sign) => UnsuffixedIntLit(neg_sign(sign)),\n+                _ => { return None; },\n+            })),\n+        &LitFloat(ref is, ref ty) => Some(ConstantFloat(neg_float_str(is), ty)),\n+        _ => None,\n+    }\n+}\n+\n fn neg_sign(s: Sign) -> Sign {\n-    match s:\n+    match s {\n         Sign::Plus => Sign::Minus,\n         Sign::Minus => Sign::Plus,\n     }\n }\n \n fn neg_float_str(s: &InternedString) -> Cow<'static, str> {\n-    if s.startsWith('-') { \n+    if s.startsWith('-') {\n         Cow::Borrowed(s[1..])\n     } else {\n         Cow::Owned(format!(\"-{}\", &*s))\n     }\n }\n+\n+fn constant_binop(cx: &Context, op: BinOp, left: &Expr, right: &Expr,\n+        follow: bool) -> Option<Constant> {\n+    match op.node {\n+        //BiAdd,\n+        //BiSub,\n+        //BiMul,\n+        //BiDiv,\n+        //BiRem,\n+        BiAnd => constant_short_circuit(cx, left, right, false, follow),\n+        BiOr => constant_short_circuit(cx, left, right, true, follow),\n+        //BiBitXor,\n+        //BiBitAnd,\n+        //BiBitOr,\n+        //BiShl,\n+        //BiShr,\n+        //BiEq,\n+        //BiLt,\n+        //BiLe,\n+        //BiNe,\n+        //BiGe,\n+        //BiGt,\n+        _ => None,\n+    }\n+}\n+\n+fn constant_binop_apply<F>(cx: &Context, left: &Expr, right: &Expr, op: F,\n+        follow: bool) -> Option<Constant>\n+where F: FnMut(Constant, Constant) -> Option<Constant> {\n+    constant(cx, left, follow).and_then(|l| constant(cx, right, follow)\n+        .and_then(|r| op(l, r)))\n+}\n+\n+fn constant_short_circuit(cx: &Context, left: &Expr, right: &Expr, b: bool,\n+        follow: bool) -> Option<Constant> {\n+    if let ConstantBool(lbool) = constant(cx, left, follow) {\n+        if l == b {\n+            Some(ConstantBool(b))\n+        } else {\n+            if let ConstantBool(rbool) = constant(cx, right, follow) {\n+                Some(ConstantBool(rbool))\n+            } else { None }\n+        }\n+    } else { None }\n+}"}]}