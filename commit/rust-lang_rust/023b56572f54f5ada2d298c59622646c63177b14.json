{"sha": "023b56572f54f5ada2d298c59622646c63177b14", "node_id": "C_kwDOAAsO6NoAKDAyM2I1NjU3MmY1NGY1YWRhMmQyOThjNTk2MjI2NDZjNjMxNzdiMTQ", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-11-19T13:21:21Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-12-14T12:32:42Z"}, "message": "add some comments", "tree": {"sha": "5704c57cbba3ab000de6017f4d99804667d5008c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5704c57cbba3ab000de6017f4d99804667d5008c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/023b56572f54f5ada2d298c59622646c63177b14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/023b56572f54f5ada2d298c59622646c63177b14", "html_url": "https://github.com/rust-lang/rust/commit/023b56572f54f5ada2d298c59622646c63177b14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/023b56572f54f5ada2d298c59622646c63177b14/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "992efa68b7defb7b1ea366dfd862a5609821549c", "url": "https://api.github.com/repos/rust-lang/rust/commits/992efa68b7defb7b1ea366dfd862a5609821549c", "html_url": "https://github.com/rust-lang/rust/commit/992efa68b7defb7b1ea366dfd862a5609821549c"}], "stats": {"total": 73, "additions": 41, "deletions": 32}, "files": [{"sha": "c4043d9698cc1c4565be8f23060c20aa841ce3a5", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/023b56572f54f5ada2d298c59622646c63177b14/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/023b56572f54f5ada2d298c59622646c63177b14/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=023b56572f54f5ada2d298c59622646c63177b14", "patch": "@@ -60,15 +60,29 @@ pub enum StripReferences {\n     No,\n }\n \n-/// Tries to simplify a type by dropping type parameters, deref'ing away any reference types, etc.\n-/// The idea is to get something simple that we can use to quickly decide if two types could unify\n-/// during method lookup.\n+/// Tries to simplify a type by only returning the outermost injective\u00b9 layer, if one exists.\n ///\n-/// If `can_simplify_params` is false, then we will fail to simplify type parameters entirely. This\n-/// is useful when those type parameters would be instantiated with fresh type variables, since\n-/// then we can't say much about whether two types would unify. Put another way,\n-/// `can_simplify_params` should be true if type parameters appear free in `ty` and `false` if they\n-/// are to be considered bound.\n+/// The idea is to get something simple that we can use to quickly decide if two types could unify,\n+/// for example during method lookup.\n+///\n+/// A special case here are parameters and projections. Projections can be normalized to\n+/// a different type, meaning that `<T as Trait>::Assoc` and `u8` can be unified, even though\n+/// their outermost layer is different while parameters like `T` of impls are later replaced\n+/// with an inference variable, which then also allows unification with other types.\n+///\n+/// When using `SimplifyParams::Yes`, we still return a simplified type for params and projections\u00b2,\n+/// the reasoning for this can be seen at the places doing this.\n+///\n+/// For diagnostics we strip references with `StripReferences::Yes`. This is currently the best\n+/// way to skip some unhelpful suggestions.\n+///\n+/// \u00b9 meaning that if two outermost layers are different, then the whole types are also different.\n+/// \u00b2 FIXME(@lcnr): this seems like it can actually end up being unsound with the way it's used during\n+///   candidate selection. We do not consider non blanket impls for `<_ as Trait>::Assoc` even\n+///   though `_` can be inferred to a concrete type later at which point a concrete impl\n+///   could actually apply. After experimenting for about an hour I wasn't able to cause any issues\n+///   this way so I am not going to change this until we actually find an issue as I am really\n+///   interesting in getting an actual test for this.\n pub fn simplify_type(\n     tcx: TyCtxt<'_>,\n     ty: Ty<'_>,"}, {"sha": "cbb88def7e27dbd326a28ee891f5dbeab710cfc8", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/023b56572f54f5ada2d298c59622646c63177b14/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/023b56572f54f5ada2d298c59622646c63177b14/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=023b56572f54f5ada2d298c59622646c63177b14", "patch": "@@ -146,6 +146,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         self_ty: Ty<'tcx>,\n         mut f: F,\n     ) -> Option<T> {\n+        // FIXME: This depends on the set of all impls for the trait. That is\n+        // unfortunate wrt. incremental compilation.\n+        //\n+        // If we want to be faster, we could have separate queries for\n+        // blanket and non-blanket impls, and compare them separately.\n         let impls = self.trait_impls_of(def_id);\n \n         for &impl_def_id in impls.blanket_impls.iter() {\n@@ -154,31 +159,13 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n \n-        // simplify_type(.., false) basically replaces type parameters and\n-        // projections with infer-variables. This is, of course, done on\n-        // the impl trait-ref when it is instantiated, but not on the\n-        // predicate trait-ref which is passed here.\n-        //\n-        // for example, if we match `S: Copy` against an impl like\n-        // `impl<T:Copy> Copy for Option<T>`, we replace the type variable\n-        // in `Option<T>` with an infer variable, to `Option<_>` (this\n-        // doesn't actually change fast_reject output), but we don't\n-        // replace `S` with anything - this impl of course can't be\n-        // selected, and as there are hundreds of similar impls,\n-        // considering them would significantly harm performance.\n-\n-        // This depends on the set of all impls for the trait. That is\n-        // unfortunate. When we get red-green recompilation, we would like\n-        // to have a way of knowing whether the set of relevant impls\n-        // changed. The most naive\n-        // way would be to compute the Vec of relevant impls and see whether\n-        // it differs between compilations. That shouldn't be too slow by\n-        // itself - we do quite a bit of work for each relevant impl anyway.\n-        //\n-        // If we want to be faster, we could have separate queries for\n-        // blanket and non-blanket impls, and compare them separately.\n+        // Note that we're using `SimplifyParams::Yes` to query `non_blanket_impls` while using\n+        // `SimplifyParams::No` while actually adding them.\n         //\n-        // I think we'll cross that bridge when we get to it.\n+        // This way, when searching for some impl for `T: Trait`, we do not look at any impls\n+        // whose outer level is not a parameter or projection. Especially for things like\n+        // `T: Clone` this is incredibly useful as we would otherwise look at all the impls\n+        // of `Clone` for `Option<T>`, `Vec<T>`, `ConcreteType` and so on.\n         if let Some(simp) =\n             fast_reject::simplify_type(self, self_ty, SimplifyParams::Yes, StripReferences::No)\n         {"}, {"sha": "5893dca8dbf67f2710b0fefd81e19d281677331f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/023b56572f54f5ada2d298c59622646c63177b14/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/023b56572f54f5ada2d298c59622646c63177b14/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=023b56572f54f5ada2d298c59622646c63177b14", "patch": "@@ -1440,6 +1440,14 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Vec<ty::TraitRef<'tcx>> {\n+        // We simplify params and strip references here.\n+        //\n+        // This both removes a lot of unhelpful suggestions, e.g.\n+        // when searching for `&Foo: Trait` it doesn't suggestion `impl Trait for &Bar`,\n+        // while also suggesting impls for `&Foo` when we're looking for `Foo: Trait`.\n+        //\n+        // The second thing isn't necessarily always a good thing, but\n+        // any other simple setup results in a far worse output, so \ud83e\udd37\n         let simp = fast_reject::simplify_type(\n             self.tcx,\n             trait_ref.skip_binder().self_ty(),"}]}