{"sha": "eb4128fb4203f926370fdf17d6961940986728cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNDEyOGZiNDIwM2Y5MjYzNzBmZGYxN2Q2OTYxOTQwOTg2NzI4Y2Q=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-03T08:19:55Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-03T08:47:28Z"}, "message": "don't call Stacked Borrows hooks at all when validation is disabled", "tree": {"sha": "55d23ca9c3be8a2c373f44ebfcee86ee89d0449c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55d23ca9c3be8a2c373f44ebfcee86ee89d0449c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb4128fb4203f926370fdf17d6961940986728cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb4128fb4203f926370fdf17d6961940986728cd", "html_url": "https://github.com/rust-lang/rust/commit/eb4128fb4203f926370fdf17d6961940986728cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb4128fb4203f926370fdf17d6961940986728cd/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8450bda4fc3ed70aa019f83c58ff8ee8f9fcb09", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8450bda4fc3ed70aa019f83c58ff8ee8f9fcb09", "html_url": "https://github.com/rust-lang/rust/commit/c8450bda4fc3ed70aa019f83c58ff8ee8f9fcb09"}], "stats": {"total": 92, "additions": 62, "deletions": 30}, "files": [{"sha": "69c66db52147ed4f6d56f8610537501c4c9c97cb", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb4128fb4203f926370fdf17d6961940986728cd/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/eb4128fb4203f926370fdf17d6961940986728cd/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=eb4128fb4203f926370fdf17d6961940986728cd", "patch": "@@ -279,6 +279,8 @@ Several `-Z` flags are relevant for Miri:\n * `-Zalways-encode-mir` makes rustc dump MIR even for completely monomorphic\n   functions.  This is needed so that Miri can execute such functions, so Miri\n   sets this flag per default.\n+* `-Zmir-emit-retag` controls whether `Retag` statements are emitted. Miri\n+  enables this per default because it is needed for validation.\n \n Moreover, Miri recognizes some environment variables:\n "}, {"sha": "a1157af0e39b6d3103d5baf373a72f269167da8d", "filename": "src/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb4128fb4203f926370fdf17d6961940986728cd/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4128fb4203f926370fdf17d6961940986728cd/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=eb4128fb4203f926370fdf17d6961940986728cd", "patch": "@@ -32,11 +32,11 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     let mut ecx = InterpretCx::new(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n-        Evaluator::new(config.validate),\n+        Evaluator::new(),\n     );\n \n     // FIXME: InterpretCx::new should take an initial MemoryExtra\n-    ecx.memory_mut().extra = MemoryExtra::with_rng(config.seed.map(StdRng::seed_from_u64));\n+    ecx.memory_mut().extra = MemoryExtra::new(config.seed.map(StdRng::seed_from_u64), config.validate);\n     \n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n     let main_mir = ecx.load_mir(main_instance.def)?;"}, {"sha": "0ddb2d40b8e8575f0eabe9d9459a6fd480796983", "filename": "src/machine.rs", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/eb4128fb4203f926370fdf17d6961940986728cd/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4128fb4203f926370fdf17d6961940986728cd/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=eb4128fb4203f926370fdf17d6961940986728cd", "patch": "@@ -41,25 +41,31 @@ impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n /// Extra per-allocation data\n #[derive(Debug, Clone)]\n pub struct AllocExtra {\n-    pub stacked_borrows: stacked_borrows::AllocExtra,\n+    /// Stacked Borrows state is only added if validation is enabled.\n+    pub stacked_borrows: Option<stacked_borrows::AllocExtra>,\n }\n \n /// Extra global memory data\n #[derive(Default, Clone, Debug)]\n pub struct MemoryExtra {\n     pub stacked_borrows: stacked_borrows::MemoryExtra,\n     pub intptrcast: intptrcast::MemoryExtra,\n+\n     /// The random number generator to use if Miri is running in non-deterministic mode and to\n     /// enable intptrcast\n-    pub(crate) rng: Option<RefCell<StdRng>>\n+    pub(crate) rng: Option<RefCell<StdRng>>,\n+\n+    /// Whether to enforce the validity invariant.\n+    pub(crate) validate: bool,\n }\n \n impl MemoryExtra {\n-    pub fn with_rng(rng: Option<StdRng>) -> Self {\n+    pub fn new(rng: Option<StdRng>, validate: bool) -> Self {\n         MemoryExtra {\n             stacked_borrows: Default::default(),\n             intptrcast: Default::default(),\n             rng: rng.map(RefCell::new),\n+            validate,\n         }\n     }\n }\n@@ -82,21 +88,17 @@ pub struct Evaluator<'tcx> {\n \n     /// TLS state.\n     pub(crate) tls: TlsData<'tcx>,\n-\n-    /// Whether to enforce the validity invariant.\n-    pub(crate) validate: bool,\n }\n \n impl<'tcx> Evaluator<'tcx> {\n-    pub(crate) fn new(validate: bool) -> Self {\n+    pub(crate) fn new() -> Self {\n         Evaluator {\n             env_vars: HashMap::default(),\n             argc: None,\n             argv: None,\n             cmd_line: None,\n             last_error: 0,\n             tls: TlsData::default(),\n-            validate,\n         }\n     }\n }\n@@ -135,7 +137,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n \n     #[inline(always)]\n     fn enforce_validity(ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool {\n-        ecx.machine.validate\n+        ecx.memory().extra.validate\n     }\n \n     /// Returns `Ok()` when the function was handled; fail otherwise.\n@@ -251,12 +253,17 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag) {\n         let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n         let alloc = alloc.into_owned();\n-        let (stacks, base_tag) = Stacks::new_allocation(\n-            id,\n-            Size::from_bytes(alloc.bytes.len() as u64),\n-            Rc::clone(&memory.extra.stacked_borrows),\n-            kind,\n-        );\n+        let (stacks, base_tag) = if !memory.extra.validate {\n+            (None, Tag::Untagged)\n+        } else {\n+            let (stacks, base_tag) = Stacks::new_allocation(\n+                id,\n+                Size::from_bytes(alloc.bytes.len() as u64),\n+                Rc::clone(&memory.extra.stacked_borrows),\n+                kind,\n+            );\n+            (Some(stacks), base_tag)\n+        };\n         if kind != MiriMemoryKind::Static.into() {\n             assert!(alloc.relocations.is_empty(), \"Only statics can come initialized with inner pointers\");\n             // Now we can rely on the inner pointers being static, too.\n@@ -268,7 +275,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n                 alloc.relocations.iter()\n                     // The allocations in the relocations (pointers stored *inside* this allocation)\n                     // all get the base pointer tag.\n-                    .map(|&(offset, ((), alloc))| (offset, (memory_extra.static_base_ptr(alloc), alloc)))\n+                    .map(|&(offset, ((), alloc))| {\n+                        let tag = if !memory.extra.validate {\n+                            Tag::Untagged\n+                        } else {\n+                            memory_extra.static_base_ptr(alloc)\n+                        };\n+                        (offset, (tag, alloc))\n+                    })\n                     .collect()\n             ),\n             undef_mask: alloc.undef_mask,\n@@ -286,7 +300,11 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         id: AllocId,\n         memory: &Memory<'mir, 'tcx, Self>,\n     ) -> Self::PointerTag {\n-        memory.extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n+        if !memory.extra.validate {\n+            Tag::Untagged\n+        } else {\n+            memory.extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n+        }\n     }\n \n     #[inline(always)]\n@@ -295,12 +313,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         kind: mir::RetagKind,\n         place: PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n-        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !Self::enforce_validity(ecx) {\n-            // No tracking, or no retagging. The latter is possible because a dependency of ours\n-            // might be called with different flags than we are, so there are `Retag`\n-            // statements but we do not want to execute them.\n-            // Also, honor the whitelist in `enforce_validity` because otherwise we might retag\n-            // uninitialized data.\n+        if !Self::enforce_validity(ecx) {\n+            // No tracking.\n              Ok(())\n         } else {\n             ecx.retag(kind, place)\n@@ -354,7 +368,11 @@ impl AllocationExtra<Tag> for AllocExtra {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        alloc.extra.stacked_borrows.memory_read(ptr, size)\n+        if let Some(ref stacked_borrows) = alloc.extra.stacked_borrows {\n+            stacked_borrows.memory_read(ptr, size)\n+        } else {\n+            Ok(())\n+        }\n     }\n \n     #[inline(always)]\n@@ -363,7 +381,11 @@ impl AllocationExtra<Tag> for AllocExtra {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        alloc.extra.stacked_borrows.memory_written(ptr, size)\n+        if let Some(ref mut stacked_borrows) = alloc.extra.stacked_borrows {\n+            stacked_borrows.memory_written(ptr, size)\n+        } else {\n+            Ok(())\n+        }\n     }\n \n     #[inline(always)]\n@@ -372,7 +394,11 @@ impl AllocationExtra<Tag> for AllocExtra {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        alloc.extra.stacked_borrows.memory_deallocated(ptr, size)\n+        if let Some(ref mut stacked_borrows) = alloc.extra.stacked_borrows {\n+            stacked_borrows.memory_deallocated(ptr, size)\n+        } else {\n+            Ok(())\n+        }\n     }\n }\n "}, {"sha": "5c59066c475d225cfb101870623181508a3bbd35", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb4128fb4203f926370fdf17d6961940986728cd/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4128fb4203f926370fdf17d6961940986728cd/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=eb4128fb4203f926370fdf17d6961940986728cd", "patch": "@@ -538,6 +538,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n         let alloc = this.memory().get(ptr.alloc_id)?;\n+        let stacked_borrows = alloc.extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n@@ -553,14 +554,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n                     let perm = if frozen { Permission::SharedReadOnly } else { Permission::SharedReadWrite };\n                     let item = Item { perm, tag: new_tag, protector };\n-                    alloc.extra.stacked_borrows.for_each(cur_ptr, size, |stack, global| {\n+                    stacked_borrows.for_each(cur_ptr, size, |stack, global| {\n                         stack.grant(cur_ptr.tag, item, global)\n                     })\n                 });\n             }\n         };\n         let item = Item { perm, tag: new_tag, protector };\n-        alloc.extra.stacked_borrows.for_each(ptr, size, |stack, global| {\n+        stacked_borrows.for_each(ptr, size, |stack, global| {\n             stack.grant(ptr.tag, item, global)\n         })\n     }"}, {"sha": "27da44935b106c98cba3c37c50e79e40fb890810", "filename": "tests/run-pass/transmute_fat.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb4128fb4203f926370fdf17d6961940986728cd/tests%2Frun-pass%2Ftransmute_fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4128fb4203f926370fdf17d6961940986728cd/tests%2Frun-pass%2Ftransmute_fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftransmute_fat.rs?ref=eb4128fb4203f926370fdf17d6961940986728cd", "patch": "@@ -1,3 +1,6 @@\n+// Validation disallows this becuase the reference is never cast to a raw pointer.\n+// compile-flags: -Zmiri-disable-validation\n+\n fn main() {\n     // If we are careful, we can exploit data layout...\n     let raw = unsafe {"}]}