{"sha": "2017be4ef657d1a7d03a9dac80d868645c6673dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMTdiZTRlZjY1N2QxYTdkMDNhOWRhYzgwZDg2ODY0NWM2NjczZGQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-17T05:36:45Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-22T23:29:29Z"}, "message": "let_chains: Remove ast_validation logic in favor of lowering with recovery.", "tree": {"sha": "fcd465cace1852f7462268ab71b9c266970fe046", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcd465cace1852f7462268ab71b9c266970fe046"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2017be4ef657d1a7d03a9dac80d868645c6673dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2017be4ef657d1a7d03a9dac80d868645c6673dd", "html_url": "https://github.com/rust-lang/rust/commit/2017be4ef657d1a7d03a9dac80d868645c6673dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2017be4ef657d1a7d03a9dac80d868645c6673dd/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10234d286ac0b74a3bfe1581df91137a21f66033", "url": "https://api.github.com/repos/rust-lang/rust/commits/10234d286ac0b74a3bfe1581df91137a21f66033", "html_url": "https://github.com/rust-lang/rust/commit/10234d286ac0b74a3bfe1581df91137a21f66033"}], "stats": {"total": 116, "additions": 49, "deletions": 67}, "files": [{"sha": "36b29ae6e607643cfbbcccf1758ee1c59f80d87a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2017be4ef657d1a7d03a9dac80d868645c6673dd/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2017be4ef657d1a7d03a9dac80d868645c6673dd/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=2017be4ef657d1a7d03a9dac80d868645c6673dd", "patch": "@@ -4344,12 +4344,39 @@ impl<'a> LoweringContext<'a> {\n                 let ohs = P(self.lower_expr(ohs));\n                 hir::ExprKind::AddrOf(m, ohs)\n             }\n-            ExprKind::Let(..) => {\n-                // This should have been caught `ast_validation`!\n-                self.sess.span_err(e.span, \"`let` expressions only supported in `if`\");\n-                // ^-- FIXME(53667): Change to `delay_span_bug` when let_chains handled in lowering.\n-                self.sess.abort_if_errors();\n-                hir::ExprKind::Err\n+            ExprKind::Let(ref pats, ref scrutinee) => {\n+                // If we got here, the `let` expression is not allowed.\n+                self.sess\n+                    .struct_span_err(e.span, \"`let` expressions are not supported here\")\n+                    .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n+                    .note(\"as well as when nested within `&&` and parenthesis in those conditions\")\n+                    .emit();\n+\n+                // For better recovery, we emit:\n+                // ```\n+                // match scrutinee { pats => true, _ => false }\n+                // ```\n+                // While this doesn't fully match the user's intent, it has key advantages:\n+                // 1. We can avoid using `abort_if_errors`.\n+                // 2. We can typeck both `pats` and `scrutinee`.\n+                // 3. `pats` is allowed to be refutable.\n+                // 4. The return type of the block is `bool` which seems like what the user wanted.\n+                let scrutinee = self.lower_expr(scrutinee);\n+                let then_arm = {\n+                    let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+                    let expr = self.expr_bool(e.span, true);\n+                    self.arm(pats, P(expr))\n+                };\n+                let else_arm = {\n+                    let pats = hir_vec![self.pat_wild(e.span)];\n+                    let expr = self.expr_bool(e.span, false);\n+                    self.arm(pats, P(expr))\n+                };\n+                hir::ExprKind::Match(\n+                    P(scrutinee),\n+                    vec![then_arm, else_arm].into(),\n+                    hir::MatchSource::Normal,\n+                )\n             }\n             // FIXME(#53667): handle lowering of && and parens.\n             ExprKind::If(ref cond, ref then, ref else_opt) => {\n@@ -5431,10 +5458,15 @@ impl<'a> LoweringContext<'a> {\n         )\n     }\n \n+    /// Constructs a `true` or `false` literal expression.\n+    fn expr_bool(&mut self, span: Span, val: bool) -> hir::Expr {\n+        let lit = Spanned { span, node: LitKind::Bool(val) };\n+        self.expr(span, hir::ExprKind::Lit(lit), ThinVec::new())\n+    }\n+\n     /// Constructs a `true` or `false` literal pattern.\n     fn pat_bool(&mut self, span: Span, val: bool) -> P<hir::Pat> {\n-        let lit = Spanned { span, node: LitKind::Bool(val) };\n-        let expr = self.expr(span, hir::ExprKind::Lit(lit), ThinVec::new());\n+        let expr = self.expr_bool(span, val);\n         self.pat(span, hir::PatKind::Lit(P(expr)))\n     }\n "}, {"sha": "c6bc4f2f49e3eecde501be3a49a92d94c33bb445", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 9, "deletions": 59, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2017be4ef657d1a7d03a9dac80d868645c6673dd/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2017be4ef657d1a7d03a9dac80d868645c6673dd/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=2017be4ef657d1a7d03a9dac80d868645c6673dd", "patch": "@@ -74,9 +74,6 @@ struct AstValidator<'a> {\n     /// these booleans.\n     warning_period_57979_didnt_record_next_impl_trait: bool,\n     warning_period_57979_impl_trait_in_proj: bool,\n-\n-    /// Used to ban `let` expressions in inappropriate places.\n-    is_let_allowed: bool,\n }\n \n /// With the `new` value in `store`,\n@@ -114,12 +111,6 @@ impl<'a> AstValidator<'a> {\n         with(self, outer, |this| &mut this.outer_impl_trait, f)\n     }\n \n-    fn with_let_allowed(&mut self, v: bool, f: impl FnOnce(&mut Self, bool)) {\n-        let old = mem::replace(&mut self.is_let_allowed, v);\n-        f(self, old);\n-        self.is_let_allowed = old;\n-    }\n-\n     fn visit_assoc_ty_constraint_from_generic_args(&mut self, constraint: &'a AssocTyConstraint) {\n         match constraint.kind {\n             AssocTyConstraintKind::Equality { ref ty } => {\n@@ -335,15 +326,6 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    /// Emits an error banning the `let` expression provided.\n-    fn ban_let_expr(&self, expr: &'a Expr) {\n-        self.err_handler()\n-            .struct_span_err(expr.span, \"`let` expressions are not supported here\")\n-            .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n-            .note(\"as well as when nested within `&&` and parenthesis in those conditions\")\n-            .emit();\n-    }\n-\n     fn check_fn_decl(&self, fn_decl: &FnDecl) {\n         fn_decl\n             .inputs\n@@ -470,48 +452,17 @@ fn validate_generics_order<'a>(\n \n impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_expr(&mut self, expr: &'a Expr) {\n-        self.with_let_allowed(false, |this, let_allowed| {\n-            match &expr.node {\n-                ExprKind::Let(_, _) if !let_allowed => {\n-                    this.ban_let_expr(expr);\n-                }\n-                // Assuming the context permits, `($expr)` does not impose additional constraints.\n-                ExprKind::Paren(_) => {\n-                    this.with_let_allowed(let_allowed, |this, _| visit::walk_expr(this, expr));\n-                    return; // We've already walked into `expr`.\n-                }\n-                // Assuming the context permits,\n-                // l && r` allows decendants in `l` and `r` to be `let` expressions.\n-                ExprKind::Binary(op, ..) if op.node == BinOpKind::And => {\n-                    this.with_let_allowed(let_allowed, |this, _| visit::walk_expr(this, expr));\n-                    return; // We've already walked into `expr`.\n-                }\n-                // However, we do allow it in the condition of the `if` expression.\n-                // We do not allow `let` in `then` and `opt_else` directly.\n-                ExprKind::If(cond, then, opt_else) => {\n-                    this.visit_block(then);\n-                    walk_list!(this, visit_expr, opt_else);\n-                    this.with_let_allowed(true, |this, _| this.visit_expr(cond));\n-                    return; // We've already walked into `expr`.\n-                }\n-                // The same logic applies to `While`.\n-                ExprKind::While(cond, then, opt_label) => {\n-                    walk_list!(this, visit_label, opt_label);\n-                    this.visit_block(then);\n-                    this.with_let_allowed(true, |this, _| this.visit_expr(cond));\n-                    return; // We've already walked into `expr`.\n-                }\n-                ExprKind::Closure(_, _, _, fn_decl, _, _) => {\n-                    this.check_fn_decl(fn_decl);\n-                }\n-                ExprKind::InlineAsm(..) if !this.session.target.target.options.allow_asm => {\n-                    span_err!(this.session, expr.span, E0472, \"asm! is unsupported on this target\");\n-                }\n-                _ => {}\n+        match &expr.node {\n+            ExprKind::Closure(_, _, _, fn_decl, _, _) => {\n+                self.check_fn_decl(fn_decl);\n             }\n+            ExprKind::InlineAsm(..) if !self.session.target.target.options.allow_asm => {\n+                span_err!(self.session, expr.span, E0472, \"asm! is unsupported on this target\");\n+            }\n+            _ => {}\n+        }\n \n-            visit::walk_expr(this, expr);\n-        });\n+        visit::walk_expr(self, expr);\n     }\n \n     fn visit_ty(&mut self, ty: &'a Ty) {\n@@ -923,7 +874,6 @@ pub fn check_crate(session: &Session, krate: &Crate) -> (bool, bool) {\n         is_assoc_ty_bound_banned: false,\n         warning_period_57979_didnt_record_next_impl_trait: false,\n         warning_period_57979_impl_trait_in_proj: false,\n-        is_let_allowed: false,\n     };\n     visit::walk_crate(&mut validator, krate);\n "}]}