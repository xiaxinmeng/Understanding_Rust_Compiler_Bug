{"sha": "6266f64d09184f53fff4a6f7cea682b4dd714cf2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNjZmNjRkMDkxODRmNTNmZmY0YTZmN2NlYTY4MmI0ZGQ3MTRjZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-07T06:06:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-07T06:06:35Z"}, "message": "auto merge of #14638 : alexcrichton/rust/librustrt, r=brson\n\nAs part of the libstd facade efforts, this commit extracts the runtime interface\r\nout of the standard library into a standalone crate, librustrt. This crate will\r\nprovide the following services:\r\n\r\n* Definition of the rtio interface\r\n* Definition of the Runtime interface\r\n* Implementation of the Task structure\r\n* Implementation of task-local-data\r\n* Implementation of task failure via unwinding via libunwind\r\n* Implementation of runtime initialization and shutdown\r\n* Implementation of thread-local-storage for the local rust Task\r\n\r\nNotably, this crate avoids the following services:\r\n\r\n* Thread creation and destruction. The crate does not require the knowledge of\r\n  an OS threading system, and as a result it seemed best to leave out the\r\n  `rt::thread` module from librustrt. The librustrt module does depend on\r\n  mutexes, however.\r\n* Implementation of backtraces. There is no inherent requirement for the runtime\r\n  to be able to generate backtraces. As will be discussed later, this\r\n  functionality continues to live in libstd rather than librustrt.\r\n\r\nAs usual, a number of architectural changes were required to make this crate\r\npossible. Users of \"stable\" functionality will not be impacted by this change,\r\nbut users of the `std::rt` module will likely note the changes. A list of\r\narchitectural changes made is:\r\n\r\n* The stdout/stderr handles no longer live directly inside of the `Task`\r\n  structure. This is a consequence of librustrt not knowing about `std::io`.\r\n  These two handles are now stored inside of task-local-data.\r\n\r\n  The handles were originally stored inside of the `Task` for perf reasons, and\r\n  TLD is not currently as fast as it could be. For comparison, 100k prints goes\r\n  from 59ms to 68ms (a 15% slowdown). This appeared to me to be an acceptable\r\n  perf loss for the successful extraction of a librustrt crate.\r\n\r\n* The `rtio` module was forced to duplicate more functionality of `std::io`. As\r\n  the module no longer depends on `std::io`, `rtio` now defines structures such\r\n  as socket addresses, addrinfo fiddly bits, etc. The primary change made was\r\n  that `rtio` now defines its own `IoError` type. This type is distinct from\r\n  `std::io::IoError` in that it does not have an enum for what error occurred,\r\n  but rather a platform-specific error code.\r\n\r\n  The native and green libraries will be updated in later commits for this\r\n  change, and the bulk of this effort was put behind updating the two libraries\r\n  for this change (with `rtio`).\r\n\r\n* Printing a message on task failure (along with the backtrace) continues to\r\n  live in libstd, not in librustrt. This is a consequence of the above decision\r\n  to move the stdout/stderr handles to TLD rather than inside the `Task` itself.\r\n  The unwinding API now supports registration of global callback functions which\r\n  will be invoked when a task fails, allowing for libstd to register a function\r\n  to print a message and a backtrace.\r\n\r\n  The API for registering a callback is experimental and unsafe, as the\r\n  ramifications of running code on unwinding is pretty hairy.\r\n\r\n* The `std::unstable::mutex` module has moved to `std::rt::mutex`.\r\n\r\n* The `std::unstable::sync` module has been moved to `std::rt::exclusive` and\r\n  the type has been rewritten to not internally have an Arc and to have an RAII\r\n  guard structure when locking. Old code should stop using `Exclusive` in favor\r\n  of the primitives in `libsync`, but if necessary, old code should port to\r\n  `Arc<Exclusive<T>>`.\r\n\r\n* The local heap has been stripped down to have fewer debugging options. None of\r\n  these were tested, and none of these have been used in a very long time.", "tree": {"sha": "46fb046e002a37ba60f6e8b8ef5ee0675fbb7fd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46fb046e002a37ba60f6e8b8ef5ee0675fbb7fd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6266f64d09184f53fff4a6f7cea682b4dd714cf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6266f64d09184f53fff4a6f7cea682b4dd714cf2", "html_url": "https://github.com/rust-lang/rust/commit/6266f64d09184f53fff4a6f7cea682b4dd714cf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6266f64d09184f53fff4a6f7cea682b4dd714cf2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e87e18064ece0d7eddb269b8211fb8fdf5efaa91", "url": "https://api.github.com/repos/rust-lang/rust/commits/e87e18064ece0d7eddb269b8211fb8fdf5efaa91", "html_url": "https://github.com/rust-lang/rust/commit/e87e18064ece0d7eddb269b8211fb8fdf5efaa91"}, {"sha": "75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "html_url": "https://github.com/rust-lang/rust/commit/75014f7b1790e7ebdf13d38acc04dfdab6e450e9"}], "stats": {"total": 5261, "additions": 2643, "deletions": 2618}, "files": [{"sha": "433490f6f5dbfd4985b52b7d53c2bb0ab794c477", "filename": "mk/crates.mk", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -51,7 +51,7 @@\n \n TARGET_CRATES := libc std green rustuv native flate arena glob term semver \\\n                  uuid serialize sync getopts collections num test time rand \\\n-                 url log regex graphviz core rlibc alloc debug\n+                 url log regex graphviz core rlibc alloc debug rustrt\n HOST_CRATES := syntax rustc rustdoc fourcc hexfloat regex_macros fmt_macros\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n@@ -60,7 +60,9 @@ DEPS_core :=\n DEPS_rlibc :=\n DEPS_alloc := core libc native:jemalloc\n DEPS_debug := std\n-DEPS_std := core rand libc alloc collections native:rustrt native:backtrace\n+DEPS_rustrt := alloc core libc collections native:rustrt_native\n+DEPS_std := core libc rand alloc collections rustrt \\\n+\tnative:rust_builtin native:backtrace\n DEPS_graphviz := std\n DEPS_green := std native:context_switch\n DEPS_rustuv := std native:uv native:uv_support"}, {"sha": "a75cb8aa4deb2f3a88e8dcb38db56b71fed4614d", "filename": "mk/rt.mk", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -35,8 +35,8 @@\n # that's per-target so you're allowed to conditionally add files based on the\n # target.\n ################################################################################\n-NATIVE_LIBS := rustrt hoedown uv_support morestack miniz context_switch \\\n-\t\trust_test_helpers\n+NATIVE_LIBS := rust_builtin hoedown uv_support morestack miniz context_switch \\\n+\t\trustrt_native rust_test_helpers\n \n # $(1) is the target triple\n define NATIVE_LIBRARIES\n@@ -52,8 +52,9 @@ NATIVE_DEPS_hoedown_$(1) := hoedown/src/autolink.c \\\n \t\t\thoedown/src/version.c\n NATIVE_DEPS_uv_support_$(1) := rust_uv.c\n NATIVE_DEPS_miniz_$(1) = miniz.c\n-NATIVE_DEPS_rustrt_$(1) := rust_builtin.c \\\n-\t\t\trust_android_dummy.c \\\n+NATIVE_DEPS_rust_builtin_$(1) := rust_builtin.c \\\n+\t\t\trust_android_dummy.c\n+NATIVE_DEPS_rustrt_native_$(1) := \\\n \t\t\trust_try.ll \\\n \t\t\tarch/$$(HOST_$(1))/record_sp.S\n NATIVE_DEPS_rust_test_helpers_$(1) := rust_test_helpers.c"}, {"sha": "ca7ed6f4ba05bda7329cc0139c0138d92de67330", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -96,6 +96,21 @@ pub mod owned;\n pub mod arc;\n pub mod rc;\n \n+// FIXME(#14344): When linking liballoc with libstd, this library will be linked\n+//                as an rlib (it only exists as an rlib). It turns out that an\n+//                optimized standard library doesn't actually use *any* symbols\n+//                from this library. Everything is inlined and optimized away.\n+//                This means that linkers will actually omit the object for this\n+//                file, even though it may be needed in the future.\n+//\n+//                To get around this for now, we define a dummy symbol which\n+//                will never get inlined so the stdlib can call it. The stdlib's\n+//                reference to this symbol will cause this library's object file\n+//                to get linked in to libstd successfully (the linker won't\n+//                optimize it out).\n+#[doc(hidden)]\n+pub fn fixme_14344_be_sure_to_link_to_collections() {}\n+\n #[cfg(not(test))]\n #[doc(hidden)]\n mod std {"}, {"sha": "7e35af79eab1cf10f8d10699edff49ca73b378ba", "filename": "src/liballoc/util.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Fliballoc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Fliballoc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Futil.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -28,20 +28,3 @@ fn align_to(size: uint, align: uint) -> uint {\n     assert!(align != 0);\n     (size + align - 1) & !(align - 1)\n }\n-\n-// FIXME(#14344): When linking liballoc with libstd, this library will be linked\n-//                as an rlib (it only exists as an rlib). It turns out that an\n-//                optimized standard library doesn't actually use *any* symbols\n-//                from this library. Everything is inlined and optimized away.\n-//                This means that linkers will actually omit the object for this\n-//                file, even though it may be needed in the future.\n-//\n-//                To get around this for now, we define a dummy symbol which\n-//                will never get inlined so the stdlib can call it. The stdlib's\n-//                reference to this symbol will cause this library's object file\n-//                to get linked in to libstd successfully (the linker won't\n-//                optimize it out).\n-#[deprecated]\n-#[doc(hidden)]\n-pub fn make_stdlib_link_work() {}\n-"}, {"sha": "c46ea84a765cea9adace56d880d220a5f8c6fdb7", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -72,6 +72,10 @@ fn expect<T>(a: core::option::Option<T>, b: &str) -> T {\n     }\n }\n \n+// FIXME(#14344) this shouldn't be necessary\n+#[doc(hidden)]\n+pub fn fixme_14344_be_sure_to_link_to_collections() {}\n+\n #[cfg(not(test))]\n mod std {\n     pub use core::fmt;      // necessary for fail!()"}, {"sha": "4798218e3ff25dbc9653882f2d64c51c38799b18", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -862,7 +862,7 @@ mod tests {\n     use std::prelude::*;\n     use std::rand::{Rng, task_rng};\n     use std::rc::Rc;\n-    use std::unstable;\n+    use std::rt;\n     use slice::*;\n \n     use vec::Vec;\n@@ -1104,9 +1104,9 @@ mod tests {\n     #[test]\n     fn test_swap_remove_noncopyable() {\n         // Tests that we don't accidentally run destructors twice.\n-        let mut v = vec![unstable::sync::Exclusive::new(()),\n-                         unstable::sync::Exclusive::new(()),\n-                         unstable::sync::Exclusive::new(())];\n+        let mut v = vec![rt::exclusive::Exclusive::new(()),\n+                         rt::exclusive::Exclusive::new(()),\n+                         rt::exclusive::Exclusive::new(())];\n         let mut _e = v.swap_remove(0);\n         assert_eq!(v.len(), 2);\n         _e = v.swap_remove(1);"}, {"sha": "7942a1569ed2f491ba8d6c1197113be32920636d", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -98,6 +98,20 @@ macro_rules! try(\n     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n )\n \n+/// Writing a formatted string into a writer\n+#[macro_export]\n+macro_rules! write(\n+    ($dst:expr, $($arg:tt)*) => (format_args_method!($dst, write_fmt, $($arg)*))\n+)\n+\n+/// Writing a formatted string plus a newline into a writer\n+#[macro_export]\n+macro_rules! writeln(\n+    ($dst:expr, $fmt:expr $($arg:tt)*) => (\n+        write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n+    )\n+)\n+\n #[cfg(test)]\n macro_rules! vec( ($($e:expr),*) => ({\n     let mut _v = ::std::vec::Vec::new();"}, {"sha": "7f033a1bc6163a5d542767ee4cc11072c3a61102", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 20, "deletions": 33, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -20,7 +20,7 @@ use std::sync::atomics;\n use std::mem;\n use std::rt::rtio::{EventLoop, IoFactory, RemoteCallback};\n use std::rt::rtio::{PausableIdleCallback, Callback};\n-use std::unstable::sync::Exclusive;\n+use std::rt::exclusive::Exclusive;\n \n /// This is the only exported function from this module.\n pub fn event_loop() -> Box<EventLoop:Send> {\n@@ -31,7 +31,7 @@ struct BasicLoop {\n     work: Vec<proc():Send>,             // pending work\n     remotes: Vec<(uint, Box<Callback:Send>)>,\n     next_remote: uint,\n-    messages: Exclusive<Vec<Message>>,\n+    messages: Arc<Exclusive<Vec<Message>>>,\n     idle: Option<Box<Callback:Send>>,\n     idle_active: Option<Arc<atomics::AtomicBool>>,\n }\n@@ -46,7 +46,7 @@ impl BasicLoop {\n             idle_active: None,\n             next_remote: 0,\n             remotes: vec![],\n-            messages: Exclusive::new(vec![]),\n+            messages: Arc::new(Exclusive::new(Vec::new())),\n         }\n     }\n \n@@ -61,19 +61,10 @@ impl BasicLoop {\n \n     fn remote_work(&mut self) {\n         let messages = unsafe {\n-            self.messages.with(|messages| {\n-                if messages.len() > 0 {\n-                    Some(mem::replace(messages, vec![]))\n-                } else {\n-                    None\n-                }\n-            })\n-        };\n-        let messages = match messages {\n-            Some(m) => m, None => return\n+            mem::replace(&mut *self.messages.lock(), Vec::new())\n         };\n-        for message in messages.iter() {\n-            self.message(*message);\n+        for message in messages.move_iter() {\n+            self.message(message);\n         }\n     }\n \n@@ -125,13 +116,13 @@ impl EventLoop for BasicLoop {\n             }\n \n             unsafe {\n+                let mut messages = self.messages.lock();\n                 // We block here if we have no messages to process and we may\n                 // receive a message at a later date\n-                self.messages.hold_and_wait(|messages| {\n-                    self.remotes.len() > 0 &&\n-                        messages.len() == 0 &&\n-                        self.work.len() == 0\n-                })\n+                if self.remotes.len() > 0 && messages.len() == 0 &&\n+                   self.work.len() == 0 {\n+                    messages.wait()\n+                }\n             }\n         }\n     }\n@@ -165,33 +156,29 @@ impl EventLoop for BasicLoop {\n }\n \n struct BasicRemote {\n-    queue: Exclusive<Vec<Message>>,\n+    queue: Arc<Exclusive<Vec<Message>>>,\n     id: uint,\n }\n \n impl BasicRemote {\n-    fn new(queue: Exclusive<Vec<Message>>, id: uint) -> BasicRemote {\n+    fn new(queue: Arc<Exclusive<Vec<Message>>>, id: uint) -> BasicRemote {\n         BasicRemote { queue: queue, id: id }\n     }\n }\n \n impl RemoteCallback for BasicRemote {\n     fn fire(&mut self) {\n-        unsafe {\n-            self.queue.hold_and_signal(|queue| {\n-                queue.push(RunRemote(self.id));\n-            })\n-        }\n+        let mut queue = unsafe { self.queue.lock() };\n+        queue.push(RunRemote(self.id));\n+        queue.signal();\n     }\n }\n \n impl Drop for BasicRemote {\n     fn drop(&mut self) {\n-        unsafe {\n-            self.queue.hold_and_signal(|queue| {\n-                queue.push(RemoveRemote(self.id));\n-            })\n-        }\n+        let mut queue = unsafe { self.queue.lock() };\n+        queue.push(RemoveRemote(self.id));\n+        queue.signal();\n     }\n }\n \n@@ -216,7 +203,7 @@ impl Drop for BasicPausable {\n \n #[cfg(test)]\n mod test {\n-    use std::task::TaskOpts;\n+    use std::rt::task::TaskOpts;\n \n     use basic;\n     use PoolConfig;"}, {"sha": "333ac80907f6a9012a2ea6e5040674e0fddc4983", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -160,7 +160,7 @@\n //! # Using a scheduler pool\n //!\n //! ```rust\n-//! use std::task::TaskOpts;\n+//! use std::rt::task::TaskOpts;\n //! use green::{SchedPool, PoolConfig};\n //! use green::sched::{PinnedTask, TaskFromFriend};\n //!\n@@ -221,10 +221,10 @@ use std::mem::replace;\n use std::os;\n use std::rt::rtio;\n use std::rt::thread::Thread;\n+use std::rt::task::TaskOpts;\n use std::rt;\n use std::sync::atomics::{SeqCst, AtomicUint, INIT_ATOMIC_UINT};\n use std::sync::deque;\n-use std::task::TaskOpts;\n \n use sched::{Shutdown, Scheduler, SchedHandle, TaskFromFriend, NewNeighbor};\n use sleeper_list::SleeperList;\n@@ -319,7 +319,7 @@ pub fn run(event_loop_factory: fn() -> Box<rtio::EventLoop:Send>,\n     let mut pool = SchedPool::new(cfg);\n     let (tx, rx) = channel();\n     let mut opts = TaskOpts::new();\n-    opts.notify_chan = Some(tx);\n+    opts.on_exit = Some(proc(r) tx.send(r));\n     opts.name = Some(\"<main>\".into_maybe_owned());\n     pool.spawn(opts, main);\n "}, {"sha": "f55dc92eac610c5d58240a93bf8f0b9c43defdd1", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -10,11 +10,11 @@\n \n use std::mem;\n use std::rt::local::Local;\n+use std::rt::mutex::NativeMutex;\n use std::rt::rtio::{RemoteCallback, PausableIdleCallback, Callback, EventLoop};\n use std::rt::task::BlockedTask;\n use std::rt::task::Task;\n use std::sync::deque;\n-use std::unstable::mutex::NativeMutex;\n use std::raw;\n \n use std::rand::{XorShiftRng, Rng, Rand};\n@@ -1022,7 +1022,7 @@ fn new_sched_rng() -> XorShiftRng {\n mod test {\n     use rustuv;\n \n-    use std::task::TaskOpts;\n+    use std::rt::task::TaskOpts;\n     use std::rt::task::Task;\n     use std::rt::local::Local;\n \n@@ -1475,7 +1475,7 @@ mod test {\n \n     #[test]\n     fn test_spawn_sched_blocking() {\n-        use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+        use std::rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n         static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n         // Testing that a task in one scheduler can block in foreign code"}, {"sha": "7b738ed9c7c158d3ac10f0b107e55ef5f2671adb", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -15,10 +15,9 @@ use std::any::Any;\n use std::mem;\n use std::rt::Runtime;\n use std::rt::local::Local;\n+use std::rt::mutex::NativeMutex;\n use std::rt::rtio;\n-use std::rt::task::{Task, BlockedTask};\n-use std::task::TaskOpts;\n-use std::unstable::mutex::NativeMutex;\n+use std::rt::task::{Task, BlockedTask, TaskOpts};\n \n struct SimpleTask {\n     lock: NativeMutex,"}, {"sha": "2e385f75e1d3e21c47943bb7b15a0299f76e3f84", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rt::env::max_cached_stacks;\n+use std::sync::atomics;\n use std::os::{errno, page_size, MemoryMap, MapReadable, MapWritable,\n-              MapNonStandardFlags, MapVirtual};\n+              MapNonStandardFlags, MapVirtual, getenv};\n use libc;\n \n /// A task's stack. The name \"Stack\" is a vestige of segmented stacks.\n@@ -151,6 +151,22 @@ impl StackPool {\n     }\n }\n \n+fn max_cached_stacks() -> uint {\n+    static mut AMT: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n+    match unsafe { AMT.load(atomics::SeqCst) } {\n+        0 => {}\n+        n => return n - 1,\n+    }\n+    let amt = getenv(\"RUST_MAX_CACHED_STACKS\").and_then(|s| from_str(s.as_slice()));\n+    // This default corresponds to 20M of cache per scheduler (at the\n+    // default size).\n+    let amt = amt.unwrap_or(10);\n+    // 0 is our sentinel value, so ensure that we'll never see 0 after\n+    // initialization has run\n+    unsafe { AMT.store(amt + 1, atomics::SeqCst); }\n+    return amt;\n+}\n+\n extern {\n     fn rust_valgrind_stack_register(start: *libc::uintptr_t,\n                                     end: *libc::uintptr_t) -> libc::c_uint;"}, {"sha": "91ebad3b3f8ab0418e2cd578c037f13da2f6c77d", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -22,13 +22,12 @@ use std::any::Any;\n use std::mem;\n use std::raw;\n use std::rt::Runtime;\n-use std::rt::env;\n use std::rt::local::Local;\n+use std::rt::mutex::NativeMutex;\n use std::rt::rtio;\n use std::rt::stack;\n-use std::rt::task::{Task, BlockedTask, SendMessage};\n-use std::task::TaskOpts;\n-use std::unstable::mutex::NativeMutex;\n+use std::rt::task::{Task, BlockedTask, TaskOpts};\n+use std::rt;\n \n use context::Context;\n use coroutine::Coroutine;\n@@ -142,7 +141,7 @@ impl GreenTask {\n         let mut ops = GreenTask::new_typed(None, TypeGreen(Some(home)));\n \n         // Allocate a stack for us to run on\n-        let stack_size = stack_size.unwrap_or_else(|| env::min_stack());\n+        let stack_size = stack_size.unwrap_or_else(|| rt::min_stack());\n         let mut stack = stack_pool.take_stack(stack_size);\n         let context = Context::new(bootstrap_green_task, ops.as_uint(), start,\n                                    &mut stack);\n@@ -176,23 +175,13 @@ impl GreenTask {\n     pub fn configure(pool: &mut StackPool,\n                      opts: TaskOpts,\n                      f: proc():Send) -> Box<GreenTask> {\n-        let TaskOpts {\n-            notify_chan, name, stack_size,\n-            stderr, stdout,\n-        } = opts;\n+        let TaskOpts { name, stack_size, on_exit } = opts;\n \n         let mut green = GreenTask::new(pool, stack_size, f);\n         {\n             let task = green.task.get_mut_ref();\n             task.name = name;\n-            task.stderr = stderr;\n-            task.stdout = stdout;\n-            match notify_chan {\n-                Some(chan) => {\n-                    task.death.on_exit = Some(SendMessage(chan));\n-                }\n-                None => {}\n-            }\n+            task.death.on_exit = on_exit;\n         }\n         return green;\n     }\n@@ -490,7 +479,7 @@ mod tests {\n     use std::rt::local::Local;\n     use std::rt::task::Task;\n     use std::task;\n-    use std::task::TaskOpts;\n+    use std::rt::task::TaskOpts;\n \n     use super::super::{PoolConfig, SchedPool};\n     use super::GreenTask;\n@@ -529,7 +518,7 @@ mod tests {\n         opts.name = Some(\"test\".into_maybe_owned());\n         opts.stack_size = Some(20 * 4096);\n         let (tx, rx) = channel();\n-        opts.notify_chan = Some(tx);\n+        opts.on_exit = Some(proc(r) tx.send(r));\n         spawn_opts(opts, proc() {});\n         assert!(rx.recv().is_ok());\n     }\n@@ -538,7 +527,7 @@ mod tests {\n     fn smoke_opts_fail() {\n         let mut opts = TaskOpts::new();\n         let (tx, rx) = channel();\n-        opts.notify_chan = Some(tx);\n+        opts.on_exit = Some(proc(r) tx.send(r));\n         spawn_opts(opts, proc() { fail!() });\n         assert!(rx.recv().is_err());\n     }"}, {"sha": "b833b2a65158d90b26db3ad51b7beb9b411b7d07", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -172,6 +172,7 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(unix)] pub use consts::os::posix88::{ENOTCONN, ECONNABORTED, EADDRNOTAVAIL, EINTR};\n #[cfg(unix)] pub use consts::os::posix88::{EADDRINUSE, ENOENT, EISDIR, EAGAIN, EWOULDBLOCK};\n #[cfg(unix)] pub use consts::os::posix88::{ECANCELED, SIGINT, EINPROGRESS};\n+#[cfg(unix)] pub use consts::os::posix88::{ENOSYS, ENOTTY, ETIMEDOUT};\n #[cfg(unix)] pub use consts::os::posix88::{SIGTERM, SIGKILL, SIGPIPE, PROT_NONE};\n #[cfg(unix)] pub use consts::os::posix01::{SIG_IGN};\n #[cfg(unix)] pub use consts::os::bsd44::{AF_UNIX};\n@@ -195,7 +196,7 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(windows)] pub use consts::os::c95::{WSAECONNREFUSED, WSAECONNRESET, WSAEACCES};\n #[cfg(windows)] pub use consts::os::c95::{WSAEWOULDBLOCK, WSAENOTCONN, WSAECONNABORTED};\n #[cfg(windows)] pub use consts::os::c95::{WSAEADDRNOTAVAIL, WSAEADDRINUSE, WSAEINTR};\n-#[cfg(windows)] pub use consts::os::c95::{WSAEINPROGRESS};\n+#[cfg(windows)] pub use consts::os::c95::{WSAEINPROGRESS, WSAEINVAL};\n #[cfg(windows)] pub use consts::os::extra::{ERROR_INSUFFICIENT_BUFFER};\n #[cfg(windows)] pub use consts::os::extra::{O_BINARY, O_NOINHERIT, PAGE_NOACCESS};\n #[cfg(windows)] pub use consts::os::extra::{PAGE_READONLY, PAGE_READWRITE, PAGE_EXECUTE};\n@@ -205,6 +206,9 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(windows)] pub use consts::os::extra::{ERROR_ALREADY_EXISTS, ERROR_NO_DATA};\n #[cfg(windows)] pub use consts::os::extra::{ERROR_FILE_NOT_FOUND, ERROR_INVALID_NAME};\n #[cfg(windows)] pub use consts::os::extra::{ERROR_BROKEN_PIPE, ERROR_INVALID_FUNCTION};\n+#[cfg(windows)] pub use consts::os::extra::{ERROR_CALL_NOT_IMPLEMENTED};\n+#[cfg(windows)] pub use consts::os::extra::{ERROR_NOTHING_TO_TERMINATE};\n+#[cfg(windows)] pub use consts::os::extra::{ERROR_INVALID_HANDLE};\n #[cfg(windows)] pub use consts::os::extra::{TRUE, FALSE, INFINITE};\n #[cfg(windows)] pub use consts::os::extra::{PROCESS_TERMINATE, PROCESS_QUERY_INFORMATION};\n #[cfg(windows)] pub use consts::os::extra::{STILL_ACTIVE, DETACHED_PROCESS};\n@@ -1758,6 +1762,7 @@ pub mod consts {\n             pub static ERROR_NO_DATA: c_int = 232;\n             pub static ERROR_INVALID_ADDRESS : c_int = 487;\n             pub static ERROR_PIPE_CONNECTED: c_int = 535;\n+            pub static ERROR_NOTHING_TO_TERMINATE: c_int = 758;\n             pub static ERROR_OPERATION_ABORTED: c_int = 995;\n             pub static ERROR_IO_PENDING: c_int = 997;\n             pub static ERROR_FILE_INVALID : c_int = 1006;"}, {"sha": "255c3f4bd213dd8c510791c6f6adad4dc627bd66", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -8,21 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ai = std::io::net::addrinfo;\n use libc::{c_char, c_int};\n use libc;\n use std::c_str::CString;\n-use std::io::IoError;\n use std::mem;\n use std::ptr::{null, mut_null};\n+use std::rt::rtio;\n+use std::rt::rtio::IoError;\n \n-use super::net::sockaddr_to_addr;\n+use super::net;\n \n pub struct GetAddrInfoRequest;\n \n impl GetAddrInfoRequest {\n     pub fn run(host: Option<&str>, servname: Option<&str>,\n-               hint: Option<ai::Hint>) -> Result<Vec<ai::Info>, IoError> {\n+               hint: Option<rtio::AddrinfoHint>)\n+        -> Result<Vec<rtio::AddrinfoInfo>, IoError>\n+    {\n         assert!(host.is_some() || servname.is_some());\n \n         let c_host = host.map_or(unsafe { CString::new(null(), true) }, |x| x.to_c_str());\n@@ -61,16 +63,16 @@ impl GetAddrInfoRequest {\n         let mut rp = res;\n         while rp.is_not_null() {\n             unsafe {\n-                let addr = match sockaddr_to_addr(mem::transmute((*rp).ai_addr),\n-                                                  (*rp).ai_addrlen as uint) {\n+                let addr = match net::sockaddr_to_addr(mem::transmute((*rp).ai_addr),\n+                                                       (*rp).ai_addrlen as uint) {\n                     Ok(a) => a,\n                     Err(e) => return Err(e)\n                 };\n-                addrs.push(ai::Info {\n+                addrs.push(rtio::AddrinfoInfo {\n                     address: addr,\n                     family: (*rp).ai_family as uint,\n-                    socktype: None,\n-                    protocol: None,\n+                    socktype: 0,\n+                    protocol: 0,\n                     flags: (*rp).ai_flags as uint\n                 });\n \n@@ -90,27 +92,22 @@ extern \"system\" {\n     fn freeaddrinfo(res: *mut libc::addrinfo);\n     #[cfg(not(windows))]\n     fn gai_strerror(errcode: c_int) -> *c_char;\n-    #[cfg(windows)]\n-    fn WSAGetLastError() -> c_int;\n }\n \n #[cfg(windows)]\n fn get_error(_: c_int) -> IoError {\n-    unsafe {\n-        IoError::from_errno(WSAGetLastError() as uint, true)\n-    }\n+    net::last_error()\n }\n \n #[cfg(not(windows))]\n fn get_error(s: c_int) -> IoError {\n-    use std::io;\n \n     let err_str = unsafe {\n         CString::new(gai_strerror(s), false).as_str().unwrap().to_string()\n     };\n     IoError {\n-        kind: io::OtherIoError,\n-        desc: \"unable to resolve host\",\n+        code: s as uint,\n+        extra: 0,\n         detail: Some(err_str),\n     }\n }"}, {"sha": "fda9b7b1932b0a4b03477c4ecae18dfa2e4ae0de", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 84, "deletions": 107, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -14,12 +14,12 @@ use alloc::arc::Arc;\n use libc::{c_int, c_void};\n use libc;\n use std::c_str::CString;\n-use std::io::IoError;\n-use std::io;\n use std::mem;\n use std::rt::rtio;\n+use std::rt::rtio::IoResult;\n \n-use io::{IoResult, retry, keep_going};\n+use io::{retry, keep_going};\n+use io::util;\n \n pub type fd_t = libc::c_int;\n \n@@ -51,21 +51,21 @@ impl FileDesc {\n     // FIXME(#10465) these functions should not be public, but anything in\n     //               native::io wanting to use them is forced to have all the\n     //               rtio traits in scope\n-    pub fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    pub fn inner_read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let ret = retry(|| unsafe {\n             libc::read(self.fd(),\n                        buf.as_mut_ptr() as *mut libc::c_void,\n                        buf.len() as libc::size_t) as libc::c_int\n         });\n         if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(util::eof())\n         } else if ret < 0 {\n             Err(super::last_error())\n         } else {\n             Ok(ret as uint)\n         }\n     }\n-    pub fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    pub fn inner_write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let ret = keep_going(buf, |buf, len| {\n             unsafe {\n                 libc::write(self.fd(), buf as *libc::c_void,\n@@ -82,26 +82,14 @@ impl FileDesc {\n     pub fn fd(&self) -> fd_t { self.inner.fd }\n }\n \n-impl io::Reader for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n-        self.inner_read(buf)\n-    }\n-}\n-\n-impl io::Writer for FileDesc {\n-    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-}\n-\n impl rtio::RtioFileStream for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> {\n         self.inner_read(buf).map(|i| i as int)\n     }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner_write(buf)\n     }\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n         match retry(|| unsafe {\n             libc::pread(self.fd(), buf.as_ptr() as *libc::c_void,\n                         buf.len() as libc::size_t,\n@@ -111,17 +99,17 @@ impl rtio::RtioFileStream for FileDesc {\n             n => Ok(n as int)\n         }\n     }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()> {\n         super::mkerr_libc(retry(|| unsafe {\n             libc::pwrite(self.fd(), buf.as_ptr() as *libc::c_void,\n                          buf.len() as libc::size_t, offset as libc::off_t)\n         } as c_int))\n     }\n-    fn seek(&mut self, pos: i64, whence: io::SeekStyle) -> Result<u64, IoError> {\n+    fn seek(&mut self, pos: i64, whence: rtio::SeekStyle) -> IoResult<u64> {\n         let whence = match whence {\n-            io::SeekSet => libc::SEEK_SET,\n-            io::SeekEnd => libc::SEEK_END,\n-            io::SeekCur => libc::SEEK_CUR,\n+            rtio::SeekSet => libc::SEEK_SET,\n+            rtio::SeekEnd => libc::SEEK_END,\n+            rtio::SeekCur => libc::SEEK_CUR,\n         };\n         let n = unsafe { libc::lseek(self.fd(), pos as libc::off_t, whence) };\n         if n < 0 {\n@@ -130,18 +118,18 @@ impl rtio::RtioFileStream for FileDesc {\n             Ok(n as u64)\n         }\n     }\n-    fn tell(&self) -> Result<u64, IoError> {\n+    fn tell(&self) -> IoResult<u64> {\n         let n = unsafe { libc::lseek(self.fd(), 0, libc::SEEK_CUR) };\n         if n < 0 {\n             Err(super::last_error())\n         } else {\n             Ok(n as u64)\n         }\n     }\n-    fn fsync(&mut self) -> Result<(), IoError> {\n+    fn fsync(&mut self) -> IoResult<()> {\n         super::mkerr_libc(retry(|| unsafe { libc::fsync(self.fd()) }))\n     }\n-    fn datasync(&mut self) -> Result<(), IoError> {\n+    fn datasync(&mut self) -> IoResult<()> {\n         return super::mkerr_libc(os_datasync(self.fd()));\n \n         #[cfg(target_os = \"macos\")]\n@@ -157,13 +145,13 @@ impl rtio::RtioFileStream for FileDesc {\n             retry(|| unsafe { libc::fsync(fd) })\n         }\n     }\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+    fn truncate(&mut self, offset: i64) -> IoResult<()> {\n         super::mkerr_libc(retry(|| unsafe {\n             libc::ftruncate(self.fd(), offset as libc::off_t)\n         }))\n     }\n \n-    fn fstat(&mut self) -> IoResult<io::FileStat> {\n+    fn fstat(&mut self) -> IoResult<rtio::FileStat> {\n         let mut stat: libc::stat = unsafe { mem::zeroed() };\n         match retry(|| unsafe { libc::fstat(self.fd(), &mut stat) }) {\n             0 => Ok(mkstat(&stat)),\n@@ -173,10 +161,10 @@ impl rtio::RtioFileStream for FileDesc {\n }\n \n impl rtio::RtioPipe for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         self.inner_read(buf)\n     }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner_write(buf)\n     }\n     fn clone(&self) -> Box<rtio::RtioPipe:Send> {\n@@ -187,28 +175,28 @@ impl rtio::RtioPipe for FileDesc {\n     // impact on the std::io primitives, this is never called via\n     // std::io::PipeStream. If the functionality is exposed in the future, then\n     // these methods will need to be implemented.\n-    fn close_read(&mut self) -> Result<(), IoError> {\n-        Err(io::standard_error(io::InvalidInput))\n+    fn close_read(&mut self) -> IoResult<()> {\n+        Err(super::unimpl())\n     }\n-    fn close_write(&mut self) -> Result<(), IoError> {\n-        Err(io::standard_error(io::InvalidInput))\n+    fn close_write(&mut self) -> IoResult<()> {\n+        Err(super::unimpl())\n     }\n     fn set_timeout(&mut self, _t: Option<u64>) {}\n     fn set_read_timeout(&mut self, _t: Option<u64>) {}\n     fn set_write_timeout(&mut self, _t: Option<u64>) {}\n }\n \n impl rtio::RtioTTY for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         self.inner_read(buf)\n     }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner_write(buf)\n     }\n-    fn set_raw(&mut self, _raw: bool) -> Result<(), IoError> {\n+    fn set_raw(&mut self, _raw: bool) -> IoResult<()> {\n         Err(super::unimpl())\n     }\n-    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n+    fn get_winsize(&mut self) -> IoResult<(int, int)> {\n         Err(super::unimpl())\n     }\n     fn isatty(&self) -> bool { false }\n@@ -249,29 +237,29 @@ impl CFile {\n         }\n     }\n \n-    pub fn flush(&mut self) -> Result<(), IoError> {\n+    pub fn flush(&mut self) -> IoResult<()> {\n         super::mkerr_libc(retry(|| unsafe { libc::fflush(self.file) }))\n     }\n }\n \n impl rtio::RtioFileStream for CFile {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> {\n         let ret = keep_going(buf, |buf, len| {\n             unsafe {\n                 libc::fread(buf as *mut libc::c_void, 1, len as libc::size_t,\n                             self.file) as i64\n             }\n         });\n         if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(util::eof())\n         } else if ret < 0 {\n             Err(super::last_error())\n         } else {\n             Ok(ret as int)\n         }\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let ret = keep_going(buf, |buf, len| {\n             unsafe {\n                 libc::fwrite(buf as *libc::c_void, 1, len as libc::size_t,\n@@ -285,17 +273,17 @@ impl rtio::RtioFileStream for CFile {\n         }\n     }\n \n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n         self.flush().and_then(|()| self.fd.pread(buf, offset))\n     }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()> {\n         self.flush().and_then(|()| self.fd.pwrite(buf, offset))\n     }\n-    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n+    fn seek(&mut self, pos: i64, style: rtio::SeekStyle) -> IoResult<u64> {\n         let whence = match style {\n-            io::SeekSet => libc::SEEK_SET,\n-            io::SeekEnd => libc::SEEK_END,\n-            io::SeekCur => libc::SEEK_CUR,\n+            rtio::SeekSet => libc::SEEK_SET,\n+            rtio::SeekEnd => libc::SEEK_END,\n+            rtio::SeekCur => libc::SEEK_CUR,\n         };\n         let n = unsafe { libc::fseek(self.file, pos as libc::c_long, whence) };\n         if n < 0 {\n@@ -304,25 +292,25 @@ impl rtio::RtioFileStream for CFile {\n             Ok(n as u64)\n         }\n     }\n-    fn tell(&self) -> Result<u64, IoError> {\n+    fn tell(&self) -> IoResult<u64> {\n         let ret = unsafe { libc::ftell(self.file) };\n         if ret < 0 {\n             Err(super::last_error())\n         } else {\n             Ok(ret as u64)\n         }\n     }\n-    fn fsync(&mut self) -> Result<(), IoError> {\n+    fn fsync(&mut self) -> IoResult<()> {\n         self.flush().and_then(|()| self.fd.fsync())\n     }\n-    fn datasync(&mut self) -> Result<(), IoError> {\n+    fn datasync(&mut self) -> IoResult<()> {\n         self.flush().and_then(|()| self.fd.fsync())\n     }\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+    fn truncate(&mut self, offset: i64) -> IoResult<()> {\n         self.flush().and_then(|()| self.fd.truncate(offset))\n     }\n \n-    fn fstat(&mut self) -> IoResult<io::FileStat> {\n+    fn fstat(&mut self) -> IoResult<rtio::FileStat> {\n         self.flush().and_then(|()| self.fd.fstat())\n     }\n }\n@@ -333,20 +321,21 @@ impl Drop for CFile {\n     }\n }\n \n-pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n-        -> IoResult<FileDesc> {\n+pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n+    -> IoResult<FileDesc>\n+{\n     let flags = match fm {\n-        io::Open => 0,\n-        io::Append => libc::O_APPEND,\n-        io::Truncate => libc::O_TRUNC,\n+        rtio::Open => 0,\n+        rtio::Append => libc::O_APPEND,\n+        rtio::Truncate => libc::O_TRUNC,\n     };\n     // Opening with a write permission must silently create the file.\n     let (flags, mode) = match fa {\n-        io::Read => (flags | libc::O_RDONLY, 0),\n-        io::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n-                      libc::S_IRUSR | libc::S_IWUSR),\n-        io::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n-                          libc::S_IRUSR | libc::S_IWUSR),\n+        rtio::Read => (flags | libc::O_RDONLY, 0),\n+        rtio::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n+                        libc::S_IRUSR | libc::S_IWUSR),\n+        rtio::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n+                            libc::S_IRUSR | libc::S_IWUSR),\n     };\n \n     match retry(|| unsafe { libc::open(path.with_ref(|p| p), flags, mode) }) {\n@@ -355,23 +344,23 @@ pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n     }\n }\n \n-pub fn mkdir(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n+pub fn mkdir(p: &CString, mode: uint) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::mkdir(p.with_ref(|p| p), mode.bits() as libc::mode_t)\n+        libc::mkdir(p.with_ref(|p| p), mode as libc::mode_t)\n     }))\n }\n \n-pub fn readdir(p: &CString) -> IoResult<Vec<Path>> {\n+pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n     use libc::{dirent_t};\n     use libc::{opendir, readdir_r, closedir};\n \n-    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<Path> {\n+    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<CString> {\n         let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n         let root = Path::new(root);\n \n         dirs.move_iter().filter(|path| {\n             path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n-        }).map(|path| root.join(path)).collect()\n+        }).map(|path| root.join(path).to_c_str()).collect()\n     }\n \n     extern {\n@@ -412,9 +401,9 @@ pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n     }))\n }\n \n-pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n+pub fn chmod(p: &CString, mode: uint) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::chmod(p.with_ref(|p| p), mode.bits() as libc::mode_t)\n+        libc::chmod(p.with_ref(|p| p), mode as libc::mode_t)\n     }))\n }\n \n@@ -431,7 +420,7 @@ pub fn chown(p: &CString, uid: int, gid: int) -> IoResult<()> {\n     }))\n }\n \n-pub fn readlink(p: &CString) -> IoResult<Path> {\n+pub fn readlink(p: &CString) -> IoResult<CString> {\n     let p = p.with_ref(|p| p);\n     let mut len = unsafe { libc::pathconf(p, libc::_PC_NAME_MAX) };\n     if len == -1 {\n@@ -446,7 +435,7 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n         n => {\n             assert!(n > 0);\n             unsafe { buf.set_len(n as uint); }\n-            Ok(Path::new(buf))\n+            Ok(buf.as_slice().to_c_str())\n         }\n     }\n }\n@@ -463,19 +452,10 @@ pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n     }))\n }\n \n-fn mkstat(stat: &libc::stat) -> io::FileStat {\n+fn mkstat(stat: &libc::stat) -> rtio::FileStat {\n     // FileStat times are in milliseconds\n     fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n \n-    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n-        libc::S_IFREG => io::TypeFile,\n-        libc::S_IFDIR => io::TypeDirectory,\n-        libc::S_IFIFO => io::TypeNamedPipe,\n-        libc::S_IFBLK => io::TypeBlockSpecial,\n-        libc::S_IFLNK => io::TypeSymlink,\n-        _ => io::TypeUnknown,\n-    };\n-\n     #[cfg(not(target_os = \"linux\"), not(target_os = \"android\"))]\n     fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }\n     #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n@@ -486,37 +466,35 @@ fn mkstat(stat: &libc::stat) -> io::FileStat {\n     #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n     fn gen(_stat: &libc::stat) -> u64 { 0 }\n \n-    io::FileStat {\n+    rtio::FileStat {\n         size: stat.st_size as u64,\n-        kind: kind,\n-        perm: io::FilePermission::from_bits_truncate(stat.st_mode as u32),\n+        kind: stat.st_mode as u64,\n+        perm: stat.st_mode as u64,\n         created: mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64),\n         modified: mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64),\n         accessed: mktime(stat.st_atime as u64, stat.st_atime_nsec as u64),\n-        unstable: io::UnstableFileStat {\n-            device: stat.st_dev as u64,\n-            inode: stat.st_ino as u64,\n-            rdev: stat.st_rdev as u64,\n-            nlink: stat.st_nlink as u64,\n-            uid: stat.st_uid as u64,\n-            gid: stat.st_gid as u64,\n-            blksize: stat.st_blksize as u64,\n-            blocks: stat.st_blocks as u64,\n-            flags: flags(stat),\n-            gen: gen(stat),\n-        }\n+        device: stat.st_dev as u64,\n+        inode: stat.st_ino as u64,\n+        rdev: stat.st_rdev as u64,\n+        nlink: stat.st_nlink as u64,\n+        uid: stat.st_uid as u64,\n+        gid: stat.st_gid as u64,\n+        blksize: stat.st_blksize as u64,\n+        blocks: stat.st_blocks as u64,\n+        flags: flags(stat),\n+        gen: gen(stat),\n     }\n }\n \n-pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n+pub fn stat(p: &CString) -> IoResult<rtio::FileStat> {\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     match retry(|| unsafe { libc::stat(p.with_ref(|p| p), &mut stat) }) {\n         0 => Ok(mkstat(&stat)),\n         _ => Err(super::last_error()),\n     }\n }\n \n-pub fn lstat(p: &CString) -> IoResult<io::FileStat> {\n+pub fn lstat(p: &CString) -> IoResult<rtio::FileStat> {\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     match retry(|| unsafe { libc::lstat(p.with_ref(|p| p), &mut stat) }) {\n         0 => Ok(mkstat(&stat)),\n@@ -537,10 +515,9 @@ pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n #[cfg(test)]\n mod tests {\n     use super::{CFile, FileDesc};\n-    use std::io;\n     use libc;\n     use std::os;\n-    use std::rt::rtio::RtioFileStream;\n+    use std::rt::rtio::{RtioFileStream, SeekSet};\n \n     #[ignore(cfg(target_os = \"freebsd\"))] // hmm, maybe pipes have a tiny buffer\n     #[test]\n@@ -551,7 +528,7 @@ mod tests {\n         let mut reader = FileDesc::new(input, true);\n         let mut writer = FileDesc::new(out, true);\n \n-        writer.inner_write(bytes!(\"test\")).unwrap();\n+        writer.inner_write(bytes!(\"test\")).ok().unwrap();\n         let mut buf = [0u8, ..4];\n         match reader.inner_read(buf) {\n             Ok(4) => {\n@@ -574,9 +551,9 @@ mod tests {\n             assert!(!f.is_null());\n             let mut file = CFile::new(f);\n \n-            file.write(bytes!(\"test\")).unwrap();\n+            file.write(bytes!(\"test\")).ok().unwrap();\n             let mut buf = [0u8, ..4];\n-            let _ = file.seek(0, io::SeekSet).unwrap();\n+            let _ = file.seek(0, SeekSet).ok().unwrap();\n             match file.read(buf) {\n                 Ok(4) => {\n                     assert_eq!(buf[0], 't' as u8);"}, {"sha": "2a5b78e55067cb75e5ef369981b210157f6f2309", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 69, "deletions": 95, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -14,17 +14,14 @@ use alloc::arc::Arc;\n use libc::{c_int, c_void};\n use libc;\n use std::c_str::CString;\n-use std::io::IoError;\n-use std::io;\n use std::mem;\n use std::os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n use std::ptr;\n use std::rt::rtio;\n+use std::rt::rtio::IoResult;\n use std::str;\n use std::vec;\n \n-use io::IoResult;\n-\n pub type fd_t = libc::c_int;\n \n struct Inner {\n@@ -52,7 +49,7 @@ impl FileDesc {\n         }) }\n     }\n \n-    pub fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    pub fn inner_read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let mut read = 0;\n         let ret = unsafe {\n             libc::ReadFile(self.handle(), buf.as_ptr() as libc::LPVOID,\n@@ -65,7 +62,7 @@ impl FileDesc {\n             Err(super::last_error())\n         }\n     }\n-    pub fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    pub fn inner_write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let mut cur = buf.as_ptr();\n         let mut remaining = buf.len();\n         while remaining > 0 {\n@@ -93,11 +90,11 @@ impl FileDesc {\n \n     // A version of seek that takes &self so that tell can call it\n     //   - the private seek should of course take &mut self.\n-    fn seek_common(&self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n+    fn seek_common(&self, pos: i64, style: rtio::SeekStyle) -> IoResult<u64> {\n         let whence = match style {\n-            io::SeekSet => libc::FILE_BEGIN,\n-            io::SeekEnd => libc::FILE_END,\n-            io::SeekCur => libc::FILE_CURRENT,\n+            rtio::SeekSet => libc::FILE_BEGIN,\n+            rtio::SeekEnd => libc::FILE_END,\n+            rtio::SeekCur => libc::FILE_CURRENT,\n         };\n         unsafe {\n             let mut newpos = 0;\n@@ -111,27 +108,15 @@ impl FileDesc {\n \n }\n \n-impl io::Reader for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n-        self.inner_read(buf)\n-    }\n-}\n-\n-impl io::Writer for FileDesc {\n-    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-}\n-\n impl rtio::RtioFileStream for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> {\n         self.inner_read(buf).map(|i| i as int)\n     }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner_write(buf)\n     }\n \n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n         let mut read = 0;\n         let mut overlap: libc::OVERLAPPED = unsafe { mem::zeroed() };\n         overlap.Offset = offset as libc::DWORD;\n@@ -147,7 +132,7 @@ impl rtio::RtioFileStream for FileDesc {\n             Err(super::last_error())\n         }\n     }\n-    fn pwrite(&mut self, buf: &[u8], mut offset: u64) -> Result<(), IoError> {\n+    fn pwrite(&mut self, buf: &[u8], mut offset: u64) -> IoResult<()> {\n         let mut cur = buf.as_ptr();\n         let mut remaining = buf.len();\n         let mut overlap: libc::OVERLAPPED = unsafe { mem::zeroed() };\n@@ -171,36 +156,36 @@ impl rtio::RtioFileStream for FileDesc {\n         Ok(())\n     }\n \n-    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n+    fn seek(&mut self, pos: i64, style: rtio::SeekStyle) -> IoResult<u64> {\n         self.seek_common(pos, style)\n     }\n \n-    fn tell(&self) -> Result<u64, IoError> {\n-        self.seek_common(0, io::SeekCur)\n+    fn tell(&self) -> IoResult<u64> {\n+        self.seek_common(0, rtio::SeekCur)\n     }\n \n-    fn fsync(&mut self) -> Result<(), IoError> {\n+    fn fsync(&mut self) -> IoResult<()> {\n         super::mkerr_winbool(unsafe {\n             libc::FlushFileBuffers(self.handle())\n         })\n     }\n \n-    fn datasync(&mut self) -> Result<(), IoError> { return self.fsync(); }\n+    fn datasync(&mut self) -> IoResult<()> { return self.fsync(); }\n \n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+    fn truncate(&mut self, offset: i64) -> IoResult<()> {\n         let orig_pos = try!(self.tell());\n-        let _ = try!(self.seek(offset, io::SeekSet));\n+        let _ = try!(self.seek(offset, rtio::SeekSet));\n         let ret = unsafe {\n             match libc::SetEndOfFile(self.handle()) {\n                 0 => Err(super::last_error()),\n                 _ => Ok(())\n             }\n         };\n-        let _ = self.seek(orig_pos as i64, io::SeekSet);\n+        let _ = self.seek(orig_pos as i64, rtio::SeekSet);\n         return ret;\n     }\n \n-    fn fstat(&mut self) -> IoResult<io::FileStat> {\n+    fn fstat(&mut self) -> IoResult<rtio::FileStat> {\n         let mut stat: libc::stat = unsafe { mem::zeroed() };\n         match unsafe { libc::fstat(self.fd(), &mut stat) } {\n             0 => Ok(mkstat(&stat)),\n@@ -210,10 +195,10 @@ impl rtio::RtioFileStream for FileDesc {\n }\n \n impl rtio::RtioPipe for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         self.inner_read(buf)\n     }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner_write(buf)\n     }\n     fn clone(&self) -> Box<rtio::RtioPipe:Send> {\n@@ -225,27 +210,27 @@ impl rtio::RtioPipe for FileDesc {\n     // std::io::PipeStream. If the functionality is exposed in the future, then\n     // these methods will need to be implemented.\n     fn close_read(&mut self) -> IoResult<()> {\n-        Err(io::standard_error(io::InvalidInput))\n+        Err(super::unimpl())\n     }\n     fn close_write(&mut self) -> IoResult<()> {\n-        Err(io::standard_error(io::InvalidInput))\n+        Err(super::unimpl())\n     }\n     fn set_timeout(&mut self, _t: Option<u64>) {}\n     fn set_read_timeout(&mut self, _t: Option<u64>) {}\n     fn set_write_timeout(&mut self, _t: Option<u64>) {}\n }\n \n impl rtio::RtioTTY for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         self.inner_read(buf)\n     }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner_write(buf)\n     }\n-    fn set_raw(&mut self, _raw: bool) -> Result<(), IoError> {\n+    fn set_raw(&mut self, _raw: bool) -> IoResult<()> {\n         Err(super::unimpl())\n     }\n-    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n+    fn get_winsize(&mut self) -> IoResult<(int, int)> {\n         Err(super::unimpl())\n     }\n     fn isatty(&self) -> bool { false }\n@@ -268,24 +253,24 @@ impl Drop for Inner {\n     }\n }\n \n-pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n+pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n         -> IoResult<FileDesc> {\n     // Flags passed to open_osfhandle\n     let flags = match fm {\n-        io::Open => 0,\n-        io::Append => libc::O_APPEND,\n-        io::Truncate => libc::O_TRUNC,\n+        rtio::Open => 0,\n+        rtio::Append => libc::O_APPEND,\n+        rtio::Truncate => libc::O_TRUNC,\n     };\n     let flags = match fa {\n-        io::Read => flags | libc::O_RDONLY,\n-        io::Write => flags | libc::O_WRONLY | libc::O_CREAT,\n-        io::ReadWrite => flags | libc::O_RDWR | libc::O_CREAT,\n+        rtio::Read => flags | libc::O_RDONLY,\n+        rtio::Write => flags | libc::O_WRONLY | libc::O_CREAT,\n+        rtio::ReadWrite => flags | libc::O_RDWR | libc::O_CREAT,\n     };\n \n     let mut dwDesiredAccess = match fa {\n-        io::Read => libc::FILE_GENERIC_READ,\n-        io::Write => libc::FILE_GENERIC_WRITE,\n-        io::ReadWrite => libc::FILE_GENERIC_READ | libc::FILE_GENERIC_WRITE\n+        rtio::Read => libc::FILE_GENERIC_READ,\n+        rtio::Write => libc::FILE_GENERIC_WRITE,\n+        rtio::ReadWrite => libc::FILE_GENERIC_READ | libc::FILE_GENERIC_WRITE\n     };\n \n     // libuv has a good comment about this, but the basic idea is what we try to\n@@ -295,15 +280,15 @@ pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n                       libc::FILE_SHARE_DELETE;\n \n     let dwCreationDisposition = match (fm, fa) {\n-        (io::Truncate, io::Read) => libc::TRUNCATE_EXISTING,\n-        (io::Truncate, _) => libc::CREATE_ALWAYS,\n-        (io::Open, io::Read) => libc::OPEN_EXISTING,\n-        (io::Open, _) => libc::OPEN_ALWAYS,\n-        (io::Append, io::Read) => {\n+        (rtio::Truncate, rtio::Read) => libc::TRUNCATE_EXISTING,\n+        (rtio::Truncate, _) => libc::CREATE_ALWAYS,\n+        (rtio::Open, rtio::Read) => libc::OPEN_EXISTING,\n+        (rtio::Open, _) => libc::OPEN_ALWAYS,\n+        (rtio::Append, rtio::Read) => {\n             dwDesiredAccess |= libc::FILE_APPEND_DATA;\n             libc::OPEN_EXISTING\n         }\n-        (io::Append, _) => {\n+        (rtio::Append, _) => {\n             dwDesiredAccess &= !libc::FILE_WRITE_DATA;\n             dwDesiredAccess |= libc::FILE_APPEND_DATA;\n             libc::OPEN_ALWAYS\n@@ -338,7 +323,7 @@ pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n     }\n }\n \n-pub fn mkdir(p: &CString, _mode: io::FilePermission) -> IoResult<()> {\n+pub fn mkdir(p: &CString, _mode: uint) -> IoResult<()> {\n     super::mkerr_winbool(unsafe {\n         // FIXME: turn mode into something useful? #2623\n         as_utf16_p(p.as_str().unwrap(), |buf| {\n@@ -347,16 +332,16 @@ pub fn mkdir(p: &CString, _mode: io::FilePermission) -> IoResult<()> {\n     })\n }\n \n-pub fn readdir(p: &CString) -> IoResult<Vec<Path>> {\n+pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n     use std::rt::libc_heap::malloc_raw;\n \n-    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<Path> {\n+    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<CString> {\n         let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n         let root = Path::new(root);\n \n         dirs.move_iter().filter(|path| {\n             path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n-        }).map(|path| root.join(path)).collect()\n+        }).map(|path| root.join(path).to_c_str()).collect()\n     }\n \n     extern {\n@@ -413,9 +398,9 @@ pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n     })\n }\n \n-pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n+pub fn chmod(p: &CString, mode: uint) -> IoResult<()> {\n     super::mkerr_libc(as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n-        libc::wchmod(p, mode.bits() as libc::c_int)\n+        libc::wchmod(p, mode as libc::c_int)\n     }))\n }\n \n@@ -430,7 +415,7 @@ pub fn chown(_p: &CString, _uid: int, _gid: int) -> IoResult<()> {\n     Ok(())\n }\n \n-pub fn readlink(p: &CString) -> IoResult<Path> {\n+pub fn readlink(p: &CString) -> IoResult<CString> {\n     // FIXME: I have a feeling that this reads intermediate symlinks as well.\n     use io::c::compat::kernel32::GetFinalPathNameByHandleW;\n     let handle = unsafe {\n@@ -457,9 +442,9 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n     });\n     let ret = match ret {\n         Some(ref s) if s.as_slice().starts_with(r\"\\\\?\\\") => {\n-            Ok(Path::new(s.as_slice().slice_from(4)))\n+            Ok(Path::new(s.as_slice().slice_from(4)).to_c_str())\n         }\n-        Some(s) => Ok(Path::new(s)),\n+        Some(s) => Ok(Path::new(s).to_c_str()),\n         None => Err(super::last_error()),\n     };\n     assert!(unsafe { libc::CloseHandle(handle) } != 0);\n@@ -483,39 +468,28 @@ pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n     }))\n }\n \n-fn mkstat(stat: &libc::stat) -> io::FileStat {\n-    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n-        libc::S_IFREG => io::TypeFile,\n-        libc::S_IFDIR => io::TypeDirectory,\n-        libc::S_IFIFO => io::TypeNamedPipe,\n-        libc::S_IFBLK => io::TypeBlockSpecial,\n-        libc::S_IFLNK => io::TypeSymlink,\n-        _ => io::TypeUnknown,\n-    };\n-\n-    io::FileStat {\n+fn mkstat(stat: &libc::stat) -> rtio::FileStat {\n+    rtio::FileStat {\n         size: stat.st_size as u64,\n-        kind: kind,\n-        perm: io::FilePermission::from_bits_truncate(stat.st_mode as u32),\n+        kind: stat.st_mode as u64,\n+        perm: stat.st_mode as u64,\n         created: stat.st_ctime as u64,\n         modified: stat.st_mtime as u64,\n         accessed: stat.st_atime as u64,\n-        unstable: io::UnstableFileStat {\n-            device: stat.st_dev as u64,\n-            inode: stat.st_ino as u64,\n-            rdev: stat.st_rdev as u64,\n-            nlink: stat.st_nlink as u64,\n-            uid: stat.st_uid as u64,\n-            gid: stat.st_gid as u64,\n-            blksize: 0,\n-            blocks: 0,\n-            flags: 0,\n-            gen: 0,\n-        }\n+        device: stat.st_dev as u64,\n+        inode: stat.st_ino as u64,\n+        rdev: stat.st_rdev as u64,\n+        nlink: stat.st_nlink as u64,\n+        uid: stat.st_uid as u64,\n+        gid: stat.st_gid as u64,\n+        blksize: 0,\n+        blocks: 0,\n+        flags: 0,\n+        gen: 0,\n     }\n }\n \n-pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n+pub fn stat(p: &CString) -> IoResult<rtio::FileStat> {\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     as_utf16_p(p.as_str().unwrap(), |up| {\n         match unsafe { libc::wstat(up, &mut stat) } {\n@@ -525,7 +499,7 @@ pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n     })\n }\n \n-pub fn lstat(_p: &CString) -> IoResult<io::FileStat> {\n+pub fn lstat(_p: &CString) -> IoResult<rtio::FileStat> {\n     // FIXME: implementation is missing\n     Err(super::unimpl())\n }"}, {"sha": "443c82c6a547c53918a3ebd586783ce604268805", "filename": "src/libnative/io/helper_thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fhelper_thread.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -24,9 +24,9 @@\n \n use std::mem;\n use std::rt::bookkeeping;\n+use std::rt::mutex::StaticNativeMutex;\n use std::rt;\n use std::ty::Unsafe;\n-use std::unstable::mutex::StaticNativeMutex;\n \n use task;\n \n@@ -57,7 +57,7 @@ pub struct Helper<M> {\n \n macro_rules! helper_init( (static mut $name:ident: Helper<$m:ty>) => (\n     static mut $name: Helper<$m> = Helper {\n-        lock: ::std::unstable::mutex::NATIVE_MUTEX_INIT,\n+        lock: ::std::rt::mutex::NATIVE_MUTEX_INIT,\n         chan: ::std::ty::Unsafe {\n             value: 0 as *mut Sender<$m>,\n             marker1: ::std::kinds::marker::InvariantType,\n@@ -163,7 +163,7 @@ mod imp {\n     }\n \n     pub fn signal(fd: libc::c_int) {\n-        FileDesc::new(fd, false).inner_write([0]).unwrap();\n+        FileDesc::new(fd, false).inner_write([0]).ok().unwrap();\n     }\n \n     pub fn close(fd: libc::c_int) {"}, {"sha": "3b0dbe2d0dce978e63be79d4c53ef6cdfd302e2a", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 62, "deletions": 56, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -26,16 +26,9 @@\n use libc::c_int;\n use libc;\n use std::c_str::CString;\n-use std::io;\n-use std::io::IoError;\n-use std::io::net::ip::SocketAddr;\n-use std::io::signal::Signum;\n use std::os;\n use std::rt::rtio;\n-use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioUdpSocket};\n-use std::rt::rtio::{RtioUnixListener, RtioPipe, RtioFileStream, RtioProcess};\n-use std::rt::rtio::{RtioSignal, RtioTTY, CloseBehavior, RtioTimer, ProcessConfig};\n-use ai = std::io::net::addrinfo;\n+use std::rt::rtio::{IoResult, IoError};\n \n // Local re-exports\n pub use self::file::FileDesc;\n@@ -78,18 +71,23 @@ pub mod pipe;\n #[cfg(unix)]    #[path = \"c_unix.rs\"]  mod c;\n #[cfg(windows)] #[path = \"c_win32.rs\"] mod c;\n \n-pub type IoResult<T> = Result<T, IoError>;\n-\n fn unimpl() -> IoError {\n+    #[cfg(unix)] use ERROR = libc::ENOSYS;\n+    #[cfg(windows)] use ERROR = libc::ERROR_CALL_NOT_IMPLEMENTED;\n     IoError {\n-        kind: io::IoUnavailable,\n-        desc: \"unimplemented I/O interface\",\n+        code: ERROR as uint,\n+        extra: 0,\n         detail: None,\n     }\n }\n \n fn last_error() -> IoError {\n-    IoError::last_error()\n+    let errno = os::errno() as uint;\n+    IoError {\n+        code: os::errno() as uint,\n+        extra: 0,\n+        detail: Some(os::error_string(errno)),\n+    }\n }\n \n // unix has nonzero values as errors\n@@ -166,64 +164,70 @@ impl IoFactory {\n \n impl rtio::IoFactory for IoFactory {\n     // networking\n-    fn tcp_connect(&mut self, addr: SocketAddr,\n-                   timeout: Option<u64>) -> IoResult<Box<RtioTcpStream:Send>> {\n+    fn tcp_connect(&mut self, addr: rtio::SocketAddr,\n+                   timeout: Option<u64>)\n+        -> IoResult<Box<rtio::RtioTcpStream:Send>>\n+    {\n         net::TcpStream::connect(addr, timeout).map(|s| {\n-            box s as Box<RtioTcpStream:Send>\n+            box s as Box<rtio::RtioTcpStream:Send>\n         })\n     }\n-    fn tcp_bind(&mut self, addr: SocketAddr)\n-                -> IoResult<Box<RtioTcpListener:Send>> {\n+    fn tcp_bind(&mut self, addr: rtio::SocketAddr)\n+                -> IoResult<Box<rtio::RtioTcpListener:Send>> {\n         net::TcpListener::bind(addr).map(|s| {\n-            box s as Box<RtioTcpListener:Send>\n+            box s as Box<rtio::RtioTcpListener:Send>\n         })\n     }\n-    fn udp_bind(&mut self, addr: SocketAddr)\n-                -> IoResult<Box<RtioUdpSocket:Send>> {\n-        net::UdpSocket::bind(addr).map(|u| box u as Box<RtioUdpSocket:Send>)\n+    fn udp_bind(&mut self, addr: rtio::SocketAddr)\n+                -> IoResult<Box<rtio::RtioUdpSocket:Send>> {\n+        net::UdpSocket::bind(addr).map(|u| {\n+            box u as Box<rtio::RtioUdpSocket:Send>\n+        })\n     }\n     fn unix_bind(&mut self, path: &CString)\n-                 -> IoResult<Box<RtioUnixListener:Send>> {\n+                 -> IoResult<Box<rtio::RtioUnixListener:Send>> {\n         pipe::UnixListener::bind(path).map(|s| {\n-            box s as Box<RtioUnixListener:Send>\n+            box s as Box<rtio::RtioUnixListener:Send>\n         })\n     }\n     fn unix_connect(&mut self, path: &CString,\n-                    timeout: Option<u64>) -> IoResult<Box<RtioPipe:Send>> {\n+                    timeout: Option<u64>) -> IoResult<Box<rtio::RtioPipe:Send>> {\n         pipe::UnixStream::connect(path, timeout).map(|s| {\n-            box s as Box<RtioPipe:Send>\n+            box s as Box<rtio::RtioPipe:Send>\n         })\n     }\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<ai::Hint>) -> IoResult<Vec<ai::Info>> {\n+                          hint: Option<rtio::AddrinfoHint>)\n+        -> IoResult<Vec<rtio::AddrinfoInfo>>\n+    {\n         addrinfo::GetAddrInfoRequest::run(host, servname, hint)\n     }\n \n     // filesystem operations\n-    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior)\n-                      -> Box<RtioFileStream:Send> {\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close: rtio::CloseBehavior)\n+                      -> Box<rtio::RtioFileStream:Send> {\n         let close = match close {\n             rtio::CloseSynchronously | rtio::CloseAsynchronously => true,\n             rtio::DontClose => false\n         };\n-        box file::FileDesc::new(fd, close) as Box<RtioFileStream:Send>\n+        box file::FileDesc::new(fd, close) as Box<rtio::RtioFileStream:Send>\n     }\n-    fn fs_open(&mut self, path: &CString, fm: io::FileMode, fa: io::FileAccess)\n-        -> IoResult<Box<RtioFileStream:Send>> {\n-        file::open(path, fm, fa).map(|fd| box fd as Box<RtioFileStream:Send>)\n+    fn fs_open(&mut self, path: &CString, fm: rtio::FileMode,\n+               fa: rtio::FileAccess)\n+        -> IoResult<Box<rtio::RtioFileStream:Send>>\n+    {\n+        file::open(path, fm, fa).map(|fd| box fd as Box<rtio::RtioFileStream:Send>)\n     }\n     fn fs_unlink(&mut self, path: &CString) -> IoResult<()> {\n         file::unlink(path)\n     }\n-    fn fs_stat(&mut self, path: &CString) -> IoResult<io::FileStat> {\n+    fn fs_stat(&mut self, path: &CString) -> IoResult<rtio::FileStat> {\n         file::stat(path)\n     }\n-    fn fs_mkdir(&mut self, path: &CString,\n-                mode: io::FilePermission) -> IoResult<()> {\n+    fn fs_mkdir(&mut self, path: &CString, mode: uint) -> IoResult<()> {\n         file::mkdir(path, mode)\n     }\n-    fn fs_chmod(&mut self, path: &CString,\n-                mode: io::FilePermission) -> IoResult<()> {\n+    fn fs_chmod(&mut self, path: &CString, mode: uint) -> IoResult<()> {\n         file::chmod(path, mode)\n     }\n     fn fs_rmdir(&mut self, path: &CString) -> IoResult<()> {\n@@ -232,16 +236,16 @@ impl rtio::IoFactory for IoFactory {\n     fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()> {\n         file::rename(path, to)\n     }\n-    fn fs_readdir(&mut self, path: &CString, _flags: c_int) -> IoResult<Vec<Path>> {\n+    fn fs_readdir(&mut self, path: &CString, _flags: c_int) -> IoResult<Vec<CString>> {\n         file::readdir(path)\n     }\n-    fn fs_lstat(&mut self, path: &CString) -> IoResult<io::FileStat> {\n+    fn fs_lstat(&mut self, path: &CString) -> IoResult<rtio::FileStat> {\n         file::lstat(path)\n     }\n     fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> IoResult<()> {\n         file::chown(path, uid, gid)\n     }\n-    fn fs_readlink(&mut self, path: &CString) -> IoResult<Path> {\n+    fn fs_readlink(&mut self, path: &CString) -> IoResult<CString> {\n         file::readlink(path)\n     }\n     fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()> {\n@@ -256,39 +260,41 @@ impl rtio::IoFactory for IoFactory {\n     }\n \n     // misc\n-    fn timer_init(&mut self) -> IoResult<Box<RtioTimer:Send>> {\n-        timer::Timer::new().map(|t| box t as Box<RtioTimer:Send>)\n+    fn timer_init(&mut self) -> IoResult<Box<rtio::RtioTimer:Send>> {\n+        timer::Timer::new().map(|t| box t as Box<rtio::RtioTimer:Send>)\n     }\n-    fn spawn(&mut self, cfg: ProcessConfig)\n-            -> IoResult<(Box<RtioProcess:Send>,\n-                         Vec<Option<Box<RtioPipe:Send>>>)> {\n+    fn spawn(&mut self, cfg: rtio::ProcessConfig)\n+            -> IoResult<(Box<rtio::RtioProcess:Send>,\n+                         Vec<Option<Box<rtio::RtioPipe:Send>>>)> {\n         process::Process::spawn(cfg).map(|(p, io)| {\n-            (box p as Box<RtioProcess:Send>,\n+            (box p as Box<rtio::RtioProcess:Send>,\n              io.move_iter().map(|p| p.map(|p| {\n-                 box p as Box<RtioPipe:Send>\n+                 box p as Box<rtio::RtioPipe:Send>\n              })).collect())\n         })\n     }\n     fn kill(&mut self, pid: libc::pid_t, signum: int) -> IoResult<()> {\n         process::Process::kill(pid, signum)\n     }\n-    fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<RtioPipe:Send>> {\n-        Ok(box file::FileDesc::new(fd, true) as Box<RtioPipe:Send>)\n+    fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<rtio::RtioPipe:Send>> {\n+        Ok(box file::FileDesc::new(fd, true) as Box<rtio::RtioPipe:Send>)\n     }\n     fn tty_open(&mut self, fd: c_int, _readable: bool)\n-                -> IoResult<Box<RtioTTY:Send>> {\n+                -> IoResult<Box<rtio::RtioTTY:Send>> {\n+        #[cfg(unix)] use ERROR = libc::ENOTTY;\n+        #[cfg(windows)] use ERROR = libc::ERROR_INVALID_HANDLE;\n         if unsafe { libc::isatty(fd) } != 0 {\n-            Ok(box file::FileDesc::new(fd, true) as Box<RtioTTY:Send>)\n+            Ok(box file::FileDesc::new(fd, true) as Box<rtio::RtioTTY:Send>)\n         } else {\n             Err(IoError {\n-                kind: io::MismatchedFileTypeForOperation,\n-                desc: \"file descriptor is not a TTY\",\n+                code: ERROR as uint,\n+                extra: 0,\n                 detail: None,\n             })\n         }\n     }\n-    fn signal(&mut self, _signal: Signum, _channel: Sender<Signum>)\n-              -> IoResult<Box<RtioSignal:Send>> {\n+    fn signal(&mut self, _signal: int, _cb: Box<rtio::Callback>)\n+              -> IoResult<Box<rtio::RtioSignal:Send>> {\n         Err(unimpl())\n     }\n }"}, {"sha": "24956e514ec83e09cb85ce4234040e270ad2d03d", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 54, "deletions": 51, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -10,13 +10,12 @@\n \n use alloc::arc::Arc;\n use libc;\n-use std::io::net::ip;\n-use std::io;\n use std::mem;\n+use std::rt::mutex;\n use std::rt::rtio;\n-use std::unstable::mutex;\n+use std::rt::rtio::{IoResult, IoError};\n \n-use super::{IoResult, retry, keep_going};\n+use super::{retry, keep_going};\n use super::c;\n use super::util;\n \n@@ -39,9 +38,9 @@ enum InAddr {\n     In6Addr(libc::in6_addr),\n }\n \n-fn ip_to_inaddr(ip: ip::IpAddr) -> InAddr {\n+fn ip_to_inaddr(ip: rtio::IpAddr) -> InAddr {\n     match ip {\n-        ip::Ipv4Addr(a, b, c, d) => {\n+        rtio::Ipv4Addr(a, b, c, d) => {\n             let ip = (a as u32 << 24) |\n                      (b as u32 << 16) |\n                      (c as u32 <<  8) |\n@@ -50,7 +49,7 @@ fn ip_to_inaddr(ip: ip::IpAddr) -> InAddr {\n                 s_addr: mem::from_be32(ip)\n             })\n         }\n-        ip::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+        rtio::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n             In6Addr(libc::in6_addr {\n                 s6_addr: [\n                     htons(a),\n@@ -67,7 +66,7 @@ fn ip_to_inaddr(ip: ip::IpAddr) -> InAddr {\n     }\n }\n \n-fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n+fn addr_to_sockaddr(addr: rtio::SocketAddr) -> (libc::sockaddr_storage, uint) {\n     unsafe {\n         let storage: libc::sockaddr_storage = mem::zeroed();\n         let len = match ip_to_inaddr(addr.ip) {\n@@ -90,11 +89,11 @@ fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n     }\n }\n \n-fn socket(addr: ip::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n+fn socket(addr: rtio::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n     unsafe {\n         let fam = match addr.ip {\n-            ip::Ipv4Addr(..) => libc::AF_INET,\n-            ip::Ipv6Addr(..) => libc::AF_INET6,\n+            rtio::Ipv4Addr(..) => libc::AF_INET,\n+            rtio::Ipv6Addr(..) => libc::AF_INET6,\n         };\n         match libc::socket(fam, ty, 0) {\n             -1 => Err(super::last_error()),\n@@ -136,12 +135,18 @@ pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n }\n \n #[cfg(windows)]\n-fn last_error() -> io::IoError {\n-    io::IoError::from_errno(unsafe { c::WSAGetLastError() } as uint, true)\n+pub fn last_error() -> IoError {\n+    use std::os;\n+    let code = unsafe { c::WSAGetLastError() as uint };\n+    IoError {\n+        code: code,\n+        extra: 0,\n+        detail: Some(os::error_string(code)),\n+    }\n }\n \n #[cfg(not(windows))]\n-fn last_error() -> io::IoError {\n+fn last_error() -> IoError {\n     super::last_error()\n }\n \n@@ -151,7 +156,7 @@ fn last_error() -> io::IoError {\n fn sockname(fd: sock_t,\n             f: unsafe extern \"system\" fn(sock_t, *mut libc::sockaddr,\n                                          *mut libc::socklen_t) -> libc::c_int)\n-    -> IoResult<ip::SocketAddr>\n+    -> IoResult<rtio::SocketAddr>\n {\n     let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n     let mut len = mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n@@ -168,7 +173,7 @@ fn sockname(fd: sock_t,\n }\n \n pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n-                        len: uint) -> IoResult<ip::SocketAddr> {\n+                        len: uint) -> IoResult<rtio::SocketAddr> {\n     match storage.ss_family as libc::c_int {\n         libc::AF_INET => {\n             assert!(len as uint >= mem::size_of::<libc::sockaddr_in>());\n@@ -180,8 +185,8 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             let b = (ip >> 16) as u8;\n             let c = (ip >>  8) as u8;\n             let d = (ip >>  0) as u8;\n-            Ok(ip::SocketAddr {\n-                ip: ip::Ipv4Addr(a, b, c, d),\n+            Ok(rtio::SocketAddr {\n+                ip: rtio::Ipv4Addr(a, b, c, d),\n                 port: ntohs(storage.sin_port),\n             })\n         }\n@@ -198,13 +203,19 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             let f = ntohs(storage.sin6_addr.s6_addr[5]);\n             let g = ntohs(storage.sin6_addr.s6_addr[6]);\n             let h = ntohs(storage.sin6_addr.s6_addr[7]);\n-            Ok(ip::SocketAddr {\n-                ip: ip::Ipv6Addr(a, b, c, d, e, f, g, h),\n+            Ok(rtio::SocketAddr {\n+                ip: rtio::Ipv6Addr(a, b, c, d, e, f, g, h),\n                 port: ntohs(storage.sin6_port),\n             })\n         }\n         _ => {\n-            Err(io::standard_error(io::OtherIoError))\n+            #[cfg(unix)] use ERROR = libc::EINVAL;\n+            #[cfg(windows)] use ERROR = libc::WSAEINVAL;\n+            Err(IoError {\n+                code: ERROR as uint,\n+                extra: 0,\n+                detail: None,\n+            })\n         }\n     }\n }\n@@ -216,7 +227,7 @@ pub fn init() {}\n pub fn init() {\n \n     unsafe {\n-        use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+        use std::rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n         static mut INITIALIZED: bool = false;\n         static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n@@ -258,7 +269,7 @@ impl Inner {\n }\n \n impl TcpStream {\n-    pub fn connect(addr: ip::SocketAddr,\n+    pub fn connect(addr: rtio::SocketAddr,\n                    timeout: Option<u64>) -> IoResult<TcpStream> {\n         let fd = try!(socket(addr, libc::SOCK_STREAM));\n         let ret = TcpStream::new(Inner::new(fd));\n@@ -366,7 +377,7 @@ impl rtio::RtioTcpStream for TcpStream {\n             Err(e) => Err(e)\n         }\n     }\n-    fn peer_name(&mut self) -> IoResult<ip::SocketAddr> {\n+    fn peer_name(&mut self) -> IoResult<rtio::SocketAddr> {\n         sockname(self.fd(), libc::getpeername)\n     }\n     fn control_congestion(&mut self) -> IoResult<()> {\n@@ -411,7 +422,7 @@ impl rtio::RtioTcpStream for TcpStream {\n }\n \n impl rtio::RtioSocket for TcpStream {\n-    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n         sockname(self.fd(), libc::getsockname)\n     }\n }\n@@ -436,7 +447,7 @@ pub struct TcpListener {\n }\n \n impl TcpListener {\n-    pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> {\n+    pub fn bind(addr: rtio::SocketAddr) -> IoResult<TcpListener> {\n         let fd = try!(socket(addr, libc::SOCK_STREAM));\n         let ret = TcpListener { inner: Inner::new(fd) };\n \n@@ -477,7 +488,7 @@ impl rtio::RtioTcpListener for TcpListener {\n }\n \n impl rtio::RtioSocket for TcpListener {\n-    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n         sockname(self.fd(), libc::getsockname)\n     }\n }\n@@ -512,7 +523,7 @@ impl TcpAcceptor {\n }\n \n impl rtio::RtioSocket for TcpAcceptor {\n-    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n         sockname(self.fd(), libc::getsockname)\n     }\n }\n@@ -540,7 +551,7 @@ pub struct UdpSocket {\n }\n \n impl UdpSocket {\n-    pub fn bind(addr: ip::SocketAddr) -> IoResult<UdpSocket> {\n+    pub fn bind(addr: rtio::SocketAddr) -> IoResult<UdpSocket> {\n         let fd = try!(socket(addr, libc::SOCK_DGRAM));\n         let ret = UdpSocket {\n             inner: Arc::new(Inner::new(fd)),\n@@ -570,7 +581,7 @@ impl UdpSocket {\n                    on as libc::c_int)\n     }\n \n-    pub fn set_membership(&mut self, addr: ip::IpAddr,\n+    pub fn set_membership(&mut self, addr: rtio::IpAddr,\n                           opt: libc::c_int) -> IoResult<()> {\n         match ip_to_inaddr(addr) {\n             InAddr(addr) => {\n@@ -606,7 +617,7 @@ impl UdpSocket {\n }\n \n impl rtio::RtioSocket for UdpSocket {\n-    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n         sockname(self.fd(), libc::getsockname)\n     }\n }\n@@ -615,7 +626,7 @@ impl rtio::RtioSocket for UdpSocket {\n #[cfg(unix)]    type msglen_t = libc::size_t;\n \n impl rtio::RtioUdpSocket for UdpSocket {\n-    fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, ip::SocketAddr)> {\n+    fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, rtio::SocketAddr)> {\n         let fd = self.fd();\n         let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n         let storagep = &mut storage as *mut _ as *mut libc::sockaddr;\n@@ -638,7 +649,7 @@ impl rtio::RtioUdpSocket for UdpSocket {\n         })\n     }\n \n-    fn sendto(&mut self, buf: &[u8], dst: ip::SocketAddr) -> IoResult<()> {\n+    fn sendto(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> IoResult<()> {\n         let (dst, dstlen) = addr_to_sockaddr(dst);\n         let dstp = &dst as *_ as *libc::sockaddr;\n         let dstlen = dstlen as libc::socklen_t;\n@@ -657,32 +668,28 @@ impl rtio::RtioUdpSocket for UdpSocket {\n \n         let n = try!(write(fd, self.write_deadline, buf, false, dolock, dowrite));\n         if n != buf.len() {\n-            Err(io::IoError {\n-                kind: io::ShortWrite(n),\n-                desc: \"couldn't send entire packet at once\",\n-                detail: None,\n-            })\n+            Err(util::short_write(n, \"couldn't send entire packet at once\"))\n         } else {\n             Ok(())\n         }\n     }\n \n-    fn join_multicast(&mut self, multi: ip::IpAddr) -> IoResult<()> {\n+    fn join_multicast(&mut self, multi: rtio::IpAddr) -> IoResult<()> {\n         match multi {\n-            ip::Ipv4Addr(..) => {\n+            rtio::Ipv4Addr(..) => {\n                 self.set_membership(multi, libc::IP_ADD_MEMBERSHIP)\n             }\n-            ip::Ipv6Addr(..) => {\n+            rtio::Ipv6Addr(..) => {\n                 self.set_membership(multi, libc::IPV6_ADD_MEMBERSHIP)\n             }\n         }\n     }\n-    fn leave_multicast(&mut self, multi: ip::IpAddr) -> IoResult<()> {\n+    fn leave_multicast(&mut self, multi: rtio::IpAddr) -> IoResult<()> {\n         match multi {\n-            ip::Ipv4Addr(..) => {\n+            rtio::Ipv4Addr(..) => {\n                 self.set_membership(multi, libc::IP_DROP_MEMBERSHIP)\n             }\n-            ip::Ipv6Addr(..) => {\n+            rtio::Ipv6Addr(..) => {\n                 self.set_membership(multi, libc::IPV6_DROP_MEMBERSHIP)\n             }\n         }\n@@ -821,7 +828,7 @@ pub fn read<T>(fd: sock_t,\n     }\n \n     match ret {\n-        0 => Err(io::standard_error(io::EndOfFile)),\n+        0 => Err(util::eof()),\n         n if n < 0 => Err(last_error()),\n         n => Ok(n as uint)\n     }\n@@ -858,13 +865,9 @@ pub fn write<T>(fd: sock_t,\n             // As with read(), first wait for the socket to be ready for\n             // the I/O operation.\n             match util::await(fd, deadline, util::Writable) {\n-                Err(ref e) if e.kind == io::TimedOut && written > 0 => {\n+                Err(ref e) if e.code == libc::EOF as uint && written > 0 => {\n                     assert!(deadline.is_some());\n-                    return Err(io::IoError {\n-                        kind: io::ShortWrite(written),\n-                        desc: \"short write\",\n-                        detail: None,\n-                    })\n+                    return Err(util::short_write(written, \"short write\"))\n                 }\n                 Err(e) => return Err(e),\n                 Ok(()) => {}"}, {"sha": "7a1134fbe5956109bed023e09ad0e6997ce1b0d8", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -11,13 +11,12 @@\n use alloc::arc::Arc;\n use libc;\n use std::c_str::CString;\n-use std::intrinsics;\n-use std::io;\n use std::mem;\n+use std::rt::mutex;\n use std::rt::rtio;\n-use std::unstable::mutex;\n+use std::rt::rtio::{IoResult, IoError};\n \n-use super::{IoResult, retry};\n+use super::retry;\n use super::net;\n use super::util;\n use super::c;\n@@ -34,15 +33,17 @@ fn addr_to_sockaddr_un(addr: &CString) -> IoResult<(libc::sockaddr_storage, uint\n     // the sun_path length is limited to SUN_LEN (with null)\n     assert!(mem::size_of::<libc::sockaddr_storage>() >=\n             mem::size_of::<libc::sockaddr_un>());\n-    let mut storage: libc::sockaddr_storage = unsafe { intrinsics::init() };\n+    let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n     let s: &mut libc::sockaddr_un = unsafe { mem::transmute(&mut storage) };\n \n     let len = addr.len();\n     if len > s.sun_path.len() - 1 {\n-        return Err(io::IoError {\n-            kind: io::InvalidInput,\n-            desc: \"path must be smaller than SUN_LEN\",\n-            detail: None,\n+        #[cfg(unix)] use ERROR = libc::EINVAL;\n+        #[cfg(windows)] use ERROR = libc::WSAEINVAL;\n+        return Err(IoError {\n+            code: ERROR as uint,\n+            extra: 0,\n+            detail: Some(\"path must be smaller than SUN_LEN\".to_str()),\n         })\n     }\n     s.sun_family = libc::AF_UNIX as libc::sa_family_t;\n@@ -244,7 +245,7 @@ impl UnixAcceptor {\n         if self.deadline != 0 {\n             try!(util::await(self.fd(), Some(self.deadline), util::Readable));\n         }\n-        let mut storage: libc::sockaddr_storage = unsafe { intrinsics::init() };\n+        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n         let storagep = &mut storage as *mut libc::sockaddr_storage;\n         let size = mem::size_of::<libc::sockaddr_storage>();\n         let mut size = size as libc::socklen_t;"}, {"sha": "a5694436b97200016f91a4d4463493a7029b6531", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -87,16 +87,15 @@\n use alloc::arc::Arc;\n use libc;\n use std::c_str::CString;\n-use std::io;\n use std::mem;\n use std::os::win32::as_utf16_p;\n use std::os;\n use std::ptr;\n use std::rt::rtio;\n+use std::rt::rtio::{IoResult, IoError};\n use std::sync::atomics;\n-use std::unstable::mutex;\n+use std::rt::mutex;\n \n-use super::IoResult;\n use super::c;\n use super::util;\n \n@@ -190,6 +189,14 @@ pub fn await(handle: libc::HANDLE, deadline: u64,\n     }\n }\n \n+fn epipe() -> IoError {\n+    IoError {\n+        code: libc::ERROR_BROKEN_PIPE as uint,\n+        extra: 0,\n+        detail: None,\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Unix Streams\n ////////////////////////////////////////////////////////////////////////////////\n@@ -355,7 +362,7 @@ impl rtio::RtioPipe for UnixStream {\n         // See comments in close_read() about why this lock is necessary.\n         let guard = unsafe { self.inner.lock.lock() };\n         if self.read_closed() {\n-            return Err(io::standard_error(io::EndOfFile))\n+            return Err(util::eof())\n         }\n \n         // Issue a nonblocking requests, succeeding quickly if it happened to\n@@ -403,10 +410,10 @@ impl rtio::RtioPipe for UnixStream {\n             // If the reading half is now closed, then we're done. If we woke up\n             // because the writing half was closed, keep trying.\n             if !succeeded {\n-                return Err(io::standard_error(io::TimedOut))\n+                return Err(util::timeout(\"read timed out\"))\n             }\n             if self.read_closed() {\n-                return Err(io::standard_error(io::EndOfFile))\n+                return Err(util::eof())\n             }\n         }\n     }\n@@ -431,7 +438,7 @@ impl rtio::RtioPipe for UnixStream {\n             // See comments in close_read() about why this lock is necessary.\n             let guard = unsafe { self.inner.lock.lock() };\n             if self.write_closed() {\n-                return Err(io::standard_error(io::BrokenPipe))\n+                return Err(epipe())\n             }\n             let ret = unsafe {\n                 libc::WriteFile(self.handle(),\n@@ -445,7 +452,11 @@ impl rtio::RtioPipe for UnixStream {\n \n             if ret == 0 {\n                 if err != libc::ERROR_IO_PENDING as uint {\n-                    return Err(io::IoError::from_errno(err, true));\n+                    return Err(IoError {\n+                        code: err as uint,\n+                        extra: 0,\n+                        detail: Some(os::error_string(err as uint)),\n+                    })\n                 }\n                 // Process a timeout if one is pending\n                 let succeeded = await(self.handle(), self.write_deadline,\n@@ -466,17 +477,17 @@ impl rtio::RtioPipe for UnixStream {\n                     if !succeeded {\n                         let amt = offset + bytes_written as uint;\n                         return if amt > 0 {\n-                            Err(io::IoError {\n-                                kind: io::ShortWrite(amt),\n-                                desc: \"short write during write\",\n-                                detail: None,\n+                            Err(IoError {\n+                                code: libc::ERROR_OPERATION_ABORTED as uint,\n+                                extra: amt,\n+                                detail: Some(\"short write during write\".to_str()),\n                             })\n                         } else {\n                             Err(util::timeout(\"write timed out\"))\n                         }\n                     }\n                     if self.write_closed() {\n-                        return Err(io::standard_error(io::BrokenPipe))\n+                        return Err(epipe())\n                     }\n                     continue // retry\n                 }"}, {"sha": "2c2b7cec1dec4806a3d32835de56b458b825d85f", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 55, "deletions": 52, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -10,16 +10,13 @@\n \n use libc::{pid_t, c_void, c_int};\n use libc;\n-use std::io;\n use std::mem;\n use std::os;\n use std::ptr;\n use std::rt::rtio;\n-use std::rt::rtio::ProcessConfig;\n+use std::rt::rtio::{ProcessConfig, IoResult, IoError};\n use std::c_str::CString;\n-use p = std::io::process;\n \n-use super::IoResult;\n use super::file;\n use super::util;\n \n@@ -48,7 +45,7 @@ pub struct Process {\n     handle: *(),\n \n     /// None until finish() is called.\n-    exit_code: Option<p::ProcessExit>,\n+    exit_code: Option<rtio::ProcessExit>,\n \n     /// Manually delivered signal\n     exit_signal: Option<int>,\n@@ -59,28 +56,29 @@ pub struct Process {\n \n #[cfg(unix)]\n enum Req {\n-    NewChild(libc::pid_t, Sender<p::ProcessExit>, u64),\n+    NewChild(libc::pid_t, Sender<rtio::ProcessExit>, u64),\n }\n \n impl Process {\n     /// Creates a new process using native process-spawning abilities provided\n     /// by the OS. Operations on this process will be blocking instead of using\n     /// the runtime for sleeping just this current task.\n     pub fn spawn(cfg: ProcessConfig)\n-        -> Result<(Process, Vec<Option<file::FileDesc>>), io::IoError>\n+        -> IoResult<(Process, Vec<Option<file::FileDesc>>)>\n     {\n         // right now we only handle stdin/stdout/stderr.\n         if cfg.extra_io.len() > 0 {\n             return Err(super::unimpl());\n         }\n \n-        fn get_io(io: p::StdioContainer, ret: &mut Vec<Option<file::FileDesc>>)\n+        fn get_io(io: rtio::StdioContainer,\n+                  ret: &mut Vec<Option<file::FileDesc>>)\n             -> (Option<os::Pipe>, c_int)\n         {\n             match io {\n-                p::Ignored => { ret.push(None); (None, -1) }\n-                p::InheritFd(fd) => { ret.push(None); (None, fd) }\n-                p::CreatePipe(readable, _writable) => {\n+                rtio::Ignored => { ret.push(None); (None, -1) }\n+                rtio::InheritFd(fd) => { ret.push(None); (None, fd) }\n+                rtio::CreatePipe(readable, _writable) => {\n                     let pipe = os::pipe();\n                     let (theirs, ours) = if readable {\n                         (pipe.input, pipe.out)\n@@ -133,7 +131,7 @@ impl rtio::RtioProcess for Process {\n         self.deadline = timeout.map(|i| i + ::io::timer::now()).unwrap_or(0);\n     }\n \n-    fn wait(&mut self) -> IoResult<p::ProcessExit> {\n+    fn wait(&mut self) -> IoResult<rtio::ProcessExit> {\n         match self.exit_code {\n             Some(code) => Ok(code),\n             None => {\n@@ -143,7 +141,7 @@ impl rtio::RtioProcess for Process {\n                 // consider it as having died via a signal.\n                 let code = match self.exit_signal {\n                     None => code,\n-                    Some(signal) if cfg!(windows) => p::ExitSignal(signal),\n+                    Some(signal) if cfg!(windows) => rtio::ExitSignal(signal),\n                     Some(..) => code,\n                 };\n                 self.exit_code = Some(code);\n@@ -152,7 +150,10 @@ impl rtio::RtioProcess for Process {\n         }\n     }\n \n-    fn kill(&mut self, signum: int) -> Result<(), io::IoError> {\n+    fn kill(&mut self, signum: int) -> IoResult<()> {\n+        #[cfg(unix)] use ERROR = libc::EINVAL;\n+        #[cfg(windows)] use ERROR = libc::ERROR_NOTHING_TO_TERMINATE;\n+\n         // On linux (and possibly other unices), a process that has exited will\n         // continue to accept signals because it is \"defunct\". The delivery of\n         // signals will only fail once the child has been reaped. For this\n@@ -169,10 +170,10 @@ impl rtio::RtioProcess for Process {\n         // and we kill it, then on unix we might ending up killing a\n         // newer process that happens to have the same (re-used) id\n         match self.exit_code {\n-            Some(..) => return Err(io::IoError {\n-                kind: io::OtherIoError,\n-                desc: \"can't kill an exited process\",\n-                detail: None,\n+            Some(..) => return Err(IoError {\n+                code: ERROR as uint,\n+                extra: 0,\n+                detail: Some(\"can't kill an exited process\".to_str()),\n             }),\n             None => {}\n         }\n@@ -194,7 +195,7 @@ impl Drop for Process {\n }\n \n #[cfg(windows)]\n-unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n+unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n     let handle = libc::OpenProcess(libc::PROCESS_TERMINATE |\n                                    libc::PROCESS_QUERY_INFORMATION,\n                                    libc::FALSE, pid as libc::DWORD);\n@@ -209,31 +210,31 @@ unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n             if ret == 0 {\n                 Err(super::last_error())\n             } else if status != libc::STILL_ACTIVE {\n-                Err(io::IoError {\n-                    kind: io::OtherIoError,\n-                    desc: \"process no longer alive\",\n+                Err(IoError {\n+                    code: libc::ERROR_NOTHING_TO_TERMINATE as uint,\n+                    extra: 0,\n                     detail: None,\n                 })\n             } else {\n                 Ok(())\n             }\n         }\n-        io::process::PleaseExitSignal | io::process::MustDieSignal => {\n+        15 | 9 => { // sigterm or sigkill\n             let ret = libc::TerminateProcess(handle, 1);\n             super::mkerr_winbool(ret)\n         }\n-        _ => Err(io::IoError {\n-            kind: io::OtherIoError,\n-            desc: \"unsupported signal on windows\",\n-            detail: None,\n+        _ => Err(IoError {\n+            code: libc::ERROR_CALL_NOT_IMPLEMENTED as uint,\n+            extra: 0,\n+            detail: Some(\"unsupported signal on windows\".to_string()),\n         })\n     };\n     let _ = libc::CloseHandle(handle);\n     return ret;\n }\n \n #[cfg(not(windows))]\n-unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n+unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n     let r = libc::funcs::posix88::signal::kill(pid, signal as c_int);\n     super::mkerr_libc(r)\n }\n@@ -265,10 +266,10 @@ fn spawn_process_os(cfg: ProcessConfig,\n     use std::mem;\n \n     if cfg.gid.is_some() || cfg.uid.is_some() {\n-        return Err(io::IoError {\n-            kind: io::OtherIoError,\n-            desc: \"unsupported gid/uid requested on windows\",\n-            detail: None,\n+        return Err(IoError {\n+            code: libc::ERROR_CALL_NOT_IMPLEMENTED as uint,\n+            extra: 0,\n+            detail: Some(\"unsupported gid/uid requested on windows\".to_str()),\n         })\n     }\n \n@@ -521,12 +522,13 @@ fn spawn_process_os(cfg: ProcessConfig, in_fd: c_int, out_fd: c_int, err_fd: c_i\n                                     (bytes[1] << 16) as i32 |\n                                     (bytes[2] <<  8) as i32 |\n                                     (bytes[3] <<  0) as i32;\n-                        Err(io::IoError::from_errno(errno as uint, false))\n+                        Err(IoError {\n+                            code: errno as uint,\n+                            detail: None,\n+                            extra: 0,\n+                        })\n                     }\n-                    Err(e) => {\n-                        assert!(e.kind == io::BrokenPipe ||\n-                                e.kind == io::EndOfFile,\n-                                \"unexpected error: {}\", e);\n+                    Err(..) => {\n                         Ok(SpawnProcessResult {\n                             pid: pid,\n                             handle: ptr::null()\n@@ -757,7 +759,7 @@ fn free_handle(_handle: *()) {\n }\n \n #[cfg(unix)]\n-fn translate_status(status: c_int) -> p::ProcessExit {\n+fn translate_status(status: c_int) -> rtio::ProcessExit {\n     #![allow(non_snake_case_functions)]\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n@@ -776,9 +778,9 @@ fn translate_status(status: c_int) -> p::ProcessExit {\n     }\n \n     if imp::WIFEXITED(status) {\n-        p::ExitStatus(imp::WEXITSTATUS(status) as int)\n+        rtio::ExitStatus(imp::WEXITSTATUS(status) as int)\n     } else {\n-        p::ExitSignal(imp::WTERMSIG(status) as int)\n+        rtio::ExitSignal(imp::WTERMSIG(status) as int)\n     }\n }\n \n@@ -793,7 +795,7 @@ fn translate_status(status: c_int) -> p::ProcessExit {\n  * with the same id.\n  */\n #[cfg(windows)]\n-fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n+fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n     use libc::types::os::arch::extra::DWORD;\n     use libc::consts::os::extra::{\n         SYNCHRONIZE,\n@@ -828,7 +830,7 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n             }\n             if status != STILL_ACTIVE {\n                 assert!(CloseHandle(process) != 0);\n-                return Ok(p::ExitStatus(status as int));\n+                return Ok(rtio::ExitStatus(status as int));\n             }\n             let interval = if deadline == 0 {\n                 INFINITE\n@@ -853,7 +855,7 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n }\n \n #[cfg(unix)]\n-fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n+fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n     use std::cmp;\n     use std::comm;\n \n@@ -862,7 +864,7 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n     let mut status = 0 as c_int;\n     if deadline == 0 {\n         return match retry(|| unsafe { c::waitpid(pid, &mut status, 0) }) {\n-            -1 => fail!(\"unknown waitpid error: {}\", super::last_error()),\n+            -1 => fail!(\"unknown waitpid error: {}\", super::last_error().code),\n             _ => Ok(translate_status(status)),\n         }\n     }\n@@ -928,8 +930,8 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n         unsafe {\n             let mut pipes = [0, ..2];\n             assert_eq!(libc::pipe(pipes.as_mut_ptr()), 0);\n-            util::set_nonblocking(pipes[0], true).unwrap();\n-            util::set_nonblocking(pipes[1], true).unwrap();\n+            util::set_nonblocking(pipes[0], true).ok().unwrap();\n+            util::set_nonblocking(pipes[1], true).ok().unwrap();\n             WRITE_FD = pipes[1];\n \n             let mut old: c::sigaction = mem::zeroed();\n@@ -945,10 +947,10 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n     fn waitpid_helper(input: libc::c_int,\n                       messages: Receiver<Req>,\n                       (read_fd, old): (libc::c_int, c::sigaction)) {\n-        util::set_nonblocking(input, true).unwrap();\n+        util::set_nonblocking(input, true).ok().unwrap();\n         let mut set: c::fd_set = unsafe { mem::zeroed() };\n         let mut tv: libc::timeval;\n-        let mut active = Vec::<(libc::pid_t, Sender<p::ProcessExit>, u64)>::new();\n+        let mut active = Vec::<(libc::pid_t, Sender<rtio::ProcessExit>, u64)>::new();\n         let max = cmp::max(input, read_fd) + 1;\n \n         'outer: loop {\n@@ -1094,22 +1096,23 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n     }\n }\n \n-fn waitpid_nowait(pid: pid_t) -> Option<p::ProcessExit> {\n+fn waitpid_nowait(pid: pid_t) -> Option<rtio::ProcessExit> {\n     return waitpid_os(pid);\n \n     // This code path isn't necessary on windows\n     #[cfg(windows)]\n-    fn waitpid_os(_pid: pid_t) -> Option<p::ProcessExit> { None }\n+    fn waitpid_os(_pid: pid_t) -> Option<rtio::ProcessExit> { None }\n \n     #[cfg(unix)]\n-    fn waitpid_os(pid: pid_t) -> Option<p::ProcessExit> {\n+    fn waitpid_os(pid: pid_t) -> Option<rtio::ProcessExit> {\n         let mut status = 0 as c_int;\n         match retry(|| unsafe {\n             c::waitpid(pid, &mut status, c::WNOHANG)\n         }) {\n             n if n == pid => Some(translate_status(status)),\n             0 => None,\n-            n => fail!(\"unknown waitpid error `{}`: {}\", n, super::last_error()),\n+            n => fail!(\"unknown waitpid error `{}`: {}\", n,\n+                       super::last_error().code),\n         }\n     }\n }"}, {"sha": "11f9c4b3d8cb8cebe6ef32cdce12213125a0cbd8", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -51,10 +51,10 @@ use std::mem;\n use std::os;\n use std::ptr;\n use std::rt::rtio;\n+use std::rt::rtio::IoResult;\n use std::sync::atomics;\n use std::comm;\n \n-use io::IoResult;\n use io::c;\n use io::file::FileDesc;\n use io::helper_thread::Helper;\n@@ -67,7 +67,7 @@ pub struct Timer {\n }\n \n struct Inner {\n-    tx: Option<Sender<()>>,\n+    cb: Option<Box<rtio::Callback:Send>>,\n     interval: u64,\n     repeat: bool,\n     target: u64,\n@@ -119,13 +119,13 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n         let mut timer = match active.shift() {\n             Some(timer) => timer, None => return\n         };\n-        let tx = timer.tx.take_unwrap();\n-        if tx.send_opt(()).is_ok() && timer.repeat {\n-            timer.tx = Some(tx);\n+        let mut cb = timer.cb.take_unwrap();\n+        cb.call();\n+        if timer.repeat {\n+            timer.cb = Some(cb);\n             timer.target += timer.interval;\n             insert(timer, active);\n         } else {\n-            drop(tx);\n             dead.push((timer.id, timer));\n         }\n     }\n@@ -190,7 +190,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n \n                 // drain the file descriptor\n                 let mut buf = [0];\n-                assert_eq!(fd.inner_read(buf).unwrap(), 1);\n+                assert_eq!(fd.inner_read(buf).ok().unwrap(), 1);\n             }\n \n             -1 if os::errno() == libc::EINTR as int => {}\n@@ -209,7 +209,7 @@ impl Timer {\n         Ok(Timer {\n             id: id,\n             inner: Some(box Inner {\n-                tx: None,\n+                cb: None,\n                 interval: 0,\n                 target: 0,\n                 repeat: false,\n@@ -245,38 +245,34 @@ impl Timer {\n impl rtio::RtioTimer for Timer {\n     fn sleep(&mut self, msecs: u64) {\n         let mut inner = self.inner();\n-        inner.tx = None; // cancel any previous request\n+        inner.cb = None; // cancel any previous request\n         self.inner = Some(inner);\n \n         Timer::sleep(msecs);\n     }\n \n-    fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n+    fn oneshot(&mut self, msecs: u64, cb: Box<rtio::Callback:Send>) {\n         let now = now();\n         let mut inner = self.inner();\n \n-        let (tx, rx) = channel();\n         inner.repeat = false;\n-        inner.tx = Some(tx);\n+        inner.cb = Some(cb);\n         inner.interval = msecs;\n         inner.target = now + msecs;\n \n         unsafe { HELPER.send(NewTimer(inner)); }\n-        return rx;\n     }\n \n-    fn period(&mut self, msecs: u64) -> Receiver<()> {\n+    fn period(&mut self, msecs: u64, cb: Box<rtio::Callback:Send>) {\n         let now = now();\n         let mut inner = self.inner();\n \n-        let (tx, rx) = channel();\n         inner.repeat = true;\n-        inner.tx = Some(tx);\n+        inner.cb = Some(cb);\n         inner.interval = msecs;\n         inner.target = now + msecs;\n \n         unsafe { HELPER.send(NewTimer(inner)); }\n-        return rx;\n     }\n }\n "}, {"sha": "d175060dd98606f04502e01e96c3d240d8e86a93", "filename": "src/libnative/io/timer_win32.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Ftimer_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Ftimer_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_win32.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -23,10 +23,10 @@\n use libc;\n use std::ptr;\n use std::rt::rtio;\n+use std::rt::rtio::{IoResult, Callback};\n use std::comm;\n \n use io::helper_thread::Helper;\n-use io::IoResult;\n \n helper_init!(static mut HELPER: Helper<Req>)\n \n@@ -36,7 +36,7 @@ pub struct Timer {\n }\n \n pub enum Req {\n-    NewTimer(libc::HANDLE, Sender<()>, bool),\n+    NewTimer(libc::HANDLE, Box<Callback:Send>, bool),\n     RemoveTimer(libc::HANDLE, Sender<()>),\n }\n \n@@ -79,8 +79,8 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) {\n             }\n         } else {\n             let remove = {\n-                match chans.get(idx as uint - 1) {\n-                    &(ref c, oneshot) => c.send_opt(()).is_err() || oneshot\n+                match chans.get_mut(idx as uint - 1) {\n+                    &(ref mut c, oneshot) => { c.call(); oneshot }\n                 }\n             };\n             if remove {\n@@ -148,9 +148,8 @@ impl rtio::RtioTimer for Timer {\n         let _ = unsafe { imp::WaitForSingleObject(self.obj, libc::INFINITE) };\n     }\n \n-    fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n+    fn oneshot(&mut self, msecs: u64, cb: Box<Callback:Send>) {\n         self.remove();\n-        let (tx, rx) = channel();\n \n         // see above for the calculation\n         let due = -(msecs as i64 * 10000) as libc::LARGE_INTEGER;\n@@ -159,14 +158,12 @@ impl rtio::RtioTimer for Timer {\n                                   ptr::mut_null(), 0)\n         }, 1);\n \n-        unsafe { HELPER.send(NewTimer(self.obj, tx, true)) }\n+        unsafe { HELPER.send(NewTimer(self.obj, cb, true)) }\n         self.on_worker = true;\n-        return rx;\n     }\n \n-    fn period(&mut self, msecs: u64) -> Receiver<()> {\n+    fn period(&mut self, msecs: u64, cb: Box<Callback:Send>) {\n         self.remove();\n-        let (tx, rx) = channel();\n \n         // see above for the calculation\n         let due = -(msecs as i64 * 10000) as libc::LARGE_INTEGER;\n@@ -175,10 +172,8 @@ impl rtio::RtioTimer for Timer {\n                                   ptr::null(), ptr::mut_null(), 0)\n         }, 1);\n \n-        unsafe { HELPER.send(NewTimer(self.obj, tx, false)) }\n+        unsafe { HELPER.send(NewTimer(self.obj, cb, false)) }\n         self.on_worker = true;\n-\n-        return rx;\n     }\n }\n "}, {"sha": "a3c5349fa4582a47be58176939d9a2304b2e499d", "filename": "src/libnative/io/util.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n use libc;\n-use std::io::IoResult;\n-use std::io;\n use std::mem;\n use std::os;\n use std::ptr;\n+use std::rt::rtio::{IoResult, IoError};\n \n use super::c;\n use super::net;\n@@ -25,10 +24,30 @@ pub enum SocketStatus {\n     Writable,\n }\n \n-pub fn timeout(desc: &'static str) -> io::IoError {\n-    io::IoError {\n-        kind: io::TimedOut,\n-        desc: desc,\n+pub fn timeout(desc: &'static str) -> IoError {\n+    #[cfg(unix)] use ERROR = libc::ETIMEDOUT;\n+    #[cfg(windows)] use ERROR = libc::ERROR_OPERATION_ABORTED;\n+    IoError {\n+        code: ERROR as uint,\n+        extra: 0,\n+        detail: Some(desc.to_str()),\n+    }\n+}\n+\n+pub fn short_write(n: uint, desc: &'static str) -> IoError {\n+    #[cfg(unix)] use ERROR = libc::EAGAIN;\n+    #[cfg(windows)] use ERROR = libc::ERROR_OPERATION_ABORTED;\n+    IoError {\n+        code: ERROR as uint,\n+        extra: n,\n+        detail: Some(desc.to_str()),\n+    }\n+}\n+\n+pub fn eof() -> IoError {\n+    IoError {\n+        code: libc::EOF as uint,\n+        extra: 0,\n         detail: None,\n     }\n }\n@@ -100,7 +119,11 @@ pub fn connect_timeout(fd: net::sock_t,\n                     if err == 0 {\n                         Ok(())\n                     } else {\n-                        Err(io::IoError::from_errno(err as uint, true))\n+                        Err(IoError {\n+                            code: err as uint,\n+                            extra: 0,\n+                            detail: Some(os::error_string(err as uint)),\n+                        })\n                     }\n                 }\n             }"}, {"sha": "f16c41d4e28f7c1806cda0089d22b7b57447e7ee", "filename": "src/libnative/task.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -17,15 +17,13 @@\n use std::any::Any;\n use std::mem;\n use std::rt::bookkeeping;\n-use std::rt::env;\n use std::rt::local::Local;\n+use std::rt::mutex::NativeMutex;\n use std::rt::rtio;\n use std::rt::stack;\n-use std::rt::task::{Task, BlockedTask, SendMessage};\n+use std::rt::task::{Task, BlockedTask, TaskOpts};\n use std::rt::thread::Thread;\n use std::rt;\n-use std::task::TaskOpts;\n-use std::unstable::mutex::NativeMutex;\n \n use io;\n use task;\n@@ -51,27 +49,19 @@ fn ops() -> Box<Ops> {\n \n /// Spawns a function with the default configuration\n pub fn spawn(f: proc():Send) {\n-    spawn_opts(TaskOpts::new(), f)\n+    spawn_opts(TaskOpts { name: None, stack_size: None, on_exit: None }, f)\n }\n \n /// Spawns a new task given the configuration options and a procedure to run\n /// inside the task.\n pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n-    let TaskOpts {\n-        notify_chan, name, stack_size,\n-        stderr, stdout,\n-    } = opts;\n+    let TaskOpts { name, stack_size, on_exit } = opts;\n \n     let mut task = box Task::new();\n     task.name = name;\n-    task.stderr = stderr;\n-    task.stdout = stdout;\n-    match notify_chan {\n-        Some(chan) => { task.death.on_exit = Some(SendMessage(chan)); }\n-        None => {}\n-    }\n+    task.death.on_exit = on_exit;\n \n-    let stack = stack_size.unwrap_or(env::min_stack());\n+    let stack = stack_size.unwrap_or(rt::min_stack());\n     let task = task;\n     let ops = ops();\n \n@@ -267,9 +257,8 @@ impl rt::Runtime for Ops {\n #[cfg(test)]\n mod tests {\n     use std::rt::local::Local;\n-    use std::rt::task::Task;\n+    use std::rt::task::{Task, TaskOpts};\n     use std::task;\n-    use std::task::TaskOpts;\n     use super::{spawn, spawn_opts, Ops};\n \n     #[test]\n@@ -297,7 +286,7 @@ mod tests {\n         opts.name = Some(\"test\".into_maybe_owned());\n         opts.stack_size = Some(20 * 4096);\n         let (tx, rx) = channel();\n-        opts.notify_chan = Some(tx);\n+        opts.on_exit = Some(proc(r) tx.send(r));\n         spawn_opts(opts, proc() {});\n         assert!(rx.recv().is_ok());\n     }\n@@ -306,7 +295,7 @@ mod tests {\n     fn smoke_opts_fail() {\n         let mut opts = TaskOpts::new();\n         let (tx, rx) = channel();\n-        opts.notify_chan = Some(tx);\n+        opts.on_exit = Some(proc(r) tx.send(r));\n         spawn_opts(opts, proc() { fail!() });\n         assert!(rx.recv().is_err());\n     }"}, {"sha": "0789bf7f906f6928749e7e8522c97d760cc7f8ec", "filename": "src/librustrt/args.rs", "status": "renamed", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -18,10 +18,9 @@\n //! discover the command line arguments.\n //!\n //! FIXME #7756: Would be nice for this to not exist.\n-//! FIXME #7756: This has a lot of C glue for lack of globals.\n \n-use option::Option;\n-use vec::Vec;\n+use core::prelude::*;\n+use collections::vec::Vec;\n \n /// One-time global initialization.\n pub unsafe fn init(argc: int, argv: **u8) { imp::init(argc, argv) }\n@@ -44,14 +43,14 @@ pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"freebsd\")]\n mod imp {\n-    use clone::Clone;\n-    use iter::Iterator;\n-    use option::{Option, Some, None};\n-    use owned::Box;\n-    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    use mem;\n-    use vec::Vec;\n-    use ptr::RawPtr;\n+    use core::prelude::*;\n+\n+    use alloc::owned::Box;\n+    use collections::vec::Vec;\n+    use core::mem;\n+    use core::slice;\n+\n+    use mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n     static mut global_args_ptr: uint = 0;\n     static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n@@ -100,24 +99,23 @@ mod imp {\n         unsafe { mem::transmute(&global_args_ptr) }\n     }\n \n-    // Copied from `os`.\n     unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> Vec<Vec<u8>> {\n-        use c_str::CString;\n-        use ptr::RawPtr;\n-        use libc;\n-        use vec::Vec;\n-\n         Vec::from_fn(argc as uint, |i| {\n-            let cs = CString::new(*(argv as **libc::c_char).offset(i as int), false);\n-            Vec::from_slice(cs.as_bytes_no_nul())\n+            let base = *argv.offset(i as int);\n+            let mut len = 0;\n+            while *base.offset(len) != 0 { len += 1; }\n+            slice::raw::buf_as_slice(base, len as uint, |slice| {\n+                Vec::from_slice(slice)\n+            })\n         })\n     }\n \n     #[cfg(test)]\n     mod tests {\n-        use prelude::*;\n+        use std::prelude::*;\n+        use std::finally::Finally;\n+\n         use super::*;\n-        use finally::Finally;\n \n         #[test]\n         fn smoke_test() {\n@@ -149,8 +147,8 @@ mod imp {\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"win32\")]\n mod imp {\n-    use option::Option;\n-    use vec::Vec;\n+    use core::prelude::*;\n+    use collections::vec::Vec;\n \n     pub unsafe fn init(_argc: int, _argv: **u8) {\n     }", "previous_filename": "src/libstd/rt/args.rs"}, {"sha": "d38d06950bf8bb16dc9b92a2060e12dda5240bac", "filename": "src/librustrt/at_exit_imp.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fat_exit_imp.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of running at_exit routines\n+//!\n+//! Documentation can be found on the `rt::at_exit` function.\n+\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use collections::vec::Vec;\n+use core::atomics;\n+use core::mem;\n+\n+use exclusive::Exclusive;\n+\n+type Queue = Exclusive<Vec<proc():Send>>;\n+\n+static mut QUEUE: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n+static mut RUNNING: atomics::AtomicBool = atomics::INIT_ATOMIC_BOOL;\n+\n+pub fn init() {\n+    let state: Box<Queue> = box Exclusive::new(Vec::new());\n+    unsafe {\n+        rtassert!(!RUNNING.load(atomics::SeqCst));\n+        rtassert!(QUEUE.swap(mem::transmute(state), atomics::SeqCst) == 0);\n+    }\n+}\n+\n+pub fn push(f: proc():Send) {\n+    unsafe {\n+        // Note that the check against 0 for the queue pointer is not atomic at\n+        // all with respect to `run`, meaning that this could theoretically be a\n+        // use-after-free. There's not much we can do to protect against that,\n+        // however. Let's just assume a well-behaved runtime and go from there!\n+        rtassert!(!RUNNING.load(atomics::SeqCst));\n+        let queue = QUEUE.load(atomics::SeqCst);\n+        rtassert!(queue != 0);\n+        (*(queue as *Queue)).lock().push(f);\n+    }\n+}\n+\n+pub fn run() {\n+    let cur = unsafe {\n+        rtassert!(!RUNNING.load(atomics::SeqCst));\n+        let queue = QUEUE.swap(0, atomics::SeqCst);\n+        rtassert!(queue != 0);\n+\n+        let queue: Box<Queue> = mem::transmute(queue);\n+        mem::replace(&mut *queue.lock(), Vec::new())\n+    };\n+\n+    for to_run in cur.move_iter() {\n+        to_run();\n+    }\n+}"}, {"sha": "fd290491eaf1e1208a50782ec707ed5ba3a84572", "filename": "src/librustrt/bookkeeping.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fbookkeeping.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -18,11 +18,9 @@\n //! each respective runtime to make sure that they call increment() and\n //! decrement() manually.\n \n-#![experimental] // this is a massive code smell\n-#![doc(hidden)]\n+use core::atomics;\n \n-use sync::atomics;\n-use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+use mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n static mut TASK_COUNT: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n static mut TASK_LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;", "previous_filename": "src/libstd/rt/bookkeeping.rs"}, {"sha": "4234c085148cb575acbe2856a8ba099b220c44e2", "filename": "src/librustrt/c_str.rs", "status": "renamed", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -65,24 +65,17 @@ fn main() {\n \n */\n \n-use clone::Clone;\n-use cmp::PartialEq;\n-use container::Container;\n-use iter::{Iterator, range};\n-use kinds::marker;\n+use core::prelude::*;\n+\n+use alloc::libc_heap::malloc_raw;\n+use collections::string::String;\n+use core::kinds::marker;\n+use core::mem;\n+use core::ptr;\n+use core::raw::Slice;\n+use core::slice;\n+use core::str;\n use libc;\n-use mem;\n-use ops::Drop;\n-use option::{Option, Some, None};\n-use ptr::RawPtr;\n-use ptr;\n-use raw::Slice;\n-use rt::libc_heap::malloc_raw;\n-use slice::{ImmutableVector, MutableVector};\n-use slice;\n-use str::StrSlice;\n-use str;\n-use string::String;\n \n /// The representation of a C String.\n ///\n@@ -245,9 +238,15 @@ impl Container for CString {\n     #[inline]\n     fn len(&self) -> uint {\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n+        let mut cur = self.buf;\n+        let mut len = 0;\n         unsafe {\n-            ptr::position(self.buf, |c| *c == 0)\n+            while *cur != 0 {\n+                len += 1;\n+                cur = cur.offset(1);\n+            }\n         }\n+        return len;\n     }\n }\n \n@@ -454,11 +453,12 @@ pub unsafe fn from_c_multistring(buf: *libc::c_char,\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n-    use super::*;\n+    use std::prelude::*;\n+    use std::ptr;\n+    use std::task;\n     use libc;\n-    use ptr;\n-    use str::StrSlice;\n+\n+    use super::*;\n \n     #[test]\n     fn test_str_multistring_parsing() {\n@@ -574,7 +574,6 @@ mod tests {\n \n     #[test]\n     fn test_to_c_str_fail() {\n-        use task;\n         assert!(task::try(proc() { \"he\\x00llo\".to_c_str() }).is_err());\n     }\n \n@@ -700,10 +699,9 @@ mod tests {\n \n #[cfg(test)]\n mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n+    use test::Bencher;\n     use libc;\n-    use prelude::*;\n+    use std::prelude::*;\n \n     #[inline]\n     fn check(s: &str, c_str: *libc::c_char) {", "previous_filename": "src/libstd/c_str.rs"}, {"sha": "62313965768a6e623b545a4b83819ad1ccc579ea", "filename": "src/librustrt/exclusive.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fexclusive.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use core::ty::Unsafe;\n+use mutex;\n+\n+/// An OS mutex over some data.\n+///\n+/// This is not a safe primitive to use, it is unaware of the libgreen\n+/// scheduler, as well as being easily susceptible to misuse due to the usage of\n+/// the inner NativeMutex.\n+///\n+/// > **Note**: This type is not recommended for general use. The mutex provided\n+/// >           as part of `libsync` should almost always be favored.\n+pub struct Exclusive<T> {\n+    lock: mutex::NativeMutex,\n+    data: Unsafe<T>,\n+}\n+\n+/// An RAII guard returned via `lock`\n+pub struct ExclusiveGuard<'a, T> {\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _data: &'a mut T,\n+    _guard: mutex::LockGuard<'a>,\n+}\n+\n+impl<T: Send> Exclusive<T> {\n+    /// Creates a new `Exclusive` which will protect the data provided.\n+    pub fn new(user_data: T) -> Exclusive<T> {\n+        Exclusive {\n+            lock: unsafe { mutex::NativeMutex::new() },\n+            data: Unsafe::new(user_data),\n+        }\n+    }\n+\n+    /// Acquires this lock, returning a guard which the data is accessed through\n+    /// and from which that lock will be unlocked.\n+    ///\n+    /// This method is unsafe due to many of the same reasons that the\n+    /// NativeMutex itself is unsafe.\n+    pub unsafe fn lock<'a>(&'a self) -> ExclusiveGuard<'a, T> {\n+        let guard = self.lock.lock();\n+        let data = &mut *self.data.get();\n+\n+        ExclusiveGuard {\n+            _data: data,\n+            _guard: guard,\n+        }\n+    }\n+}\n+\n+impl<'a, T: Send> ExclusiveGuard<'a, T> {\n+    // The unsafety here should be ok because our loan guarantees that the lock\n+    // itself is not moving\n+    pub fn signal(&self) {\n+        unsafe { self._guard.signal() }\n+    }\n+    pub fn wait(&self) {\n+        unsafe { self._guard.wait() }\n+    }\n+}\n+\n+impl<'a, T: Send> Deref<T> for ExclusiveGuard<'a, T> {\n+    fn deref<'a>(&'a self) -> &'a T { &*self._data }\n+}\n+impl<'a, T: Send> DerefMut<T> for ExclusiveGuard<'a, T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self._data }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::prelude::*;\n+    use alloc::arc::Arc;\n+    use super::Exclusive;\n+    use std::task;\n+\n+    #[test]\n+    fn exclusive_new_arc() {\n+        unsafe {\n+            let mut futures = Vec::new();\n+\n+            let num_tasks = 10;\n+            let count = 10;\n+\n+            let total = Arc::new(Exclusive::new(box 0));\n+\n+            for _ in range(0u, num_tasks) {\n+                let total = total.clone();\n+                let (tx, rx) = channel();\n+                futures.push(rx);\n+\n+                task::spawn(proc() {\n+                    for _ in range(0u, count) {\n+                        **total.lock() += 1;\n+                    }\n+                    tx.send(());\n+                });\n+            };\n+\n+            for f in futures.mut_iter() { f.recv() }\n+\n+            assert_eq!(**total.lock(), num_tasks * count);\n+        }\n+    }\n+}"}, {"sha": "3158687c6ab937e04be0b278f4a2252e17eba01f", "filename": "src/librustrt/lib.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -0,0 +1,164 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_id = \"rustrt#0.11.0-pre\"]\n+#![license = \"MIT/ASL2\"]\n+#![crate_type = \"rlib\"]\n+#![crate_type = \"dylib\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+       html_root_url = \"http://doc.rust-lang.org/\")]\n+#![feature(macro_rules, phase, globs, thread_local, managed_boxes, asm)]\n+#![no_std]\n+#![experimental]\n+\n+#[phase(syntax, link)]\n+extern crate core;\n+extern crate alloc;\n+extern crate libc;\n+extern crate collections;\n+\n+#[cfg(test)] extern crate realrustrt = \"rustrt\";\n+#[cfg(test)] extern crate test;\n+#[cfg(test)] extern crate native;\n+#[cfg(test)] #[phase(syntax, link)] extern crate std;\n+\n+pub use self::util::{Stdio, Stdout, Stderr};\n+pub use self::unwind::{begin_unwind, begin_unwind_fmt};\n+\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use core::any::Any;\n+\n+use task::{Task, BlockedTask, TaskOpts};\n+\n+mod macros;\n+\n+mod at_exit_imp;\n+mod local_ptr;\n+mod thread_local_storage;\n+mod util;\n+mod libunwind;\n+\n+pub mod args;\n+pub mod bookkeeping;\n+pub mod exclusive;\n+pub mod local;\n+pub mod local_data;\n+pub mod local_heap;\n+pub mod mutex;\n+pub mod rtio;\n+pub mod stack;\n+pub mod task;\n+pub mod unwind;\n+pub mod c_str;\n+\n+/// The interface to the current runtime.\n+///\n+/// This trait is used as the abstraction between 1:1 and M:N scheduling. The\n+/// two independent crates, libnative and libgreen, both have objects which\n+/// implement this trait. The goal of this trait is to encompass all the\n+/// fundamental differences in functionality between the 1:1 and M:N runtime\n+/// modes.\n+pub trait Runtime {\n+    // Necessary scheduling functions, used for channels and blocking I/O\n+    // (sometimes).\n+    fn yield_now(~self, cur_task: Box<Task>);\n+    fn maybe_yield(~self, cur_task: Box<Task>);\n+    fn deschedule(~self, times: uint, cur_task: Box<Task>,\n+                  f: |BlockedTask| -> Result<(), BlockedTask>);\n+    fn reawaken(~self, to_wake: Box<Task>);\n+\n+    // Miscellaneous calls which are very different depending on what context\n+    // you're in.\n+    fn spawn_sibling(~self,\n+                     cur_task: Box<Task>,\n+                     opts: TaskOpts,\n+                     f: proc():Send);\n+    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;\n+    /// The (low, high) edges of the current stack.\n+    fn stack_bounds(&self) -> (uint, uint); // (lo, hi)\n+    fn can_block(&self) -> bool;\n+\n+    // FIXME: This is a serious code smell and this should not exist at all.\n+    fn wrap(~self) -> Box<Any>;\n+}\n+\n+/// The default error code of the rust runtime if the main task fails instead\n+/// of exiting cleanly.\n+pub static DEFAULT_ERROR_CODE: int = 101;\n+\n+/// One-time runtime initialization.\n+///\n+/// Initializes global state, including frobbing\n+/// the crate's logging flags, registering GC\n+/// metadata, and storing the process arguments.\n+pub fn init(argc: int, argv: **u8) {\n+    // FIXME: Derefing these pointers is not safe.\n+    // Need to propagate the unsafety to `start`.\n+    unsafe {\n+        args::init(argc, argv);\n+        local_ptr::init();\n+        at_exit_imp::init();\n+    }\n+\n+    // FIXME(#14344) this shouldn't be necessary\n+    collections::fixme_14344_be_sure_to_link_to_collections();\n+    alloc::fixme_14344_be_sure_to_link_to_collections();\n+    libc::issue_14344_workaround();\n+}\n+\n+/// Enqueues a procedure to run when the runtime is cleaned up\n+///\n+/// The procedure passed to this function will be executed as part of the\n+/// runtime cleanup phase. For normal rust programs, this means that it will run\n+/// after all other tasks have exited.\n+///\n+/// The procedure is *not* executed with a local `Task` available to it, so\n+/// primitives like logging, I/O, channels, spawning, etc, are *not* available.\n+/// This is meant for \"bare bones\" usage to clean up runtime details, this is\n+/// not meant as a general-purpose \"let's clean everything up\" function.\n+///\n+/// It is forbidden for procedures to register more `at_exit` handlers when they\n+/// are running, and doing so will lead to a process abort.\n+pub fn at_exit(f: proc():Send) {\n+    at_exit_imp::push(f);\n+}\n+\n+/// One-time runtime cleanup.\n+///\n+/// This function is unsafe because it performs no checks to ensure that the\n+/// runtime has completely ceased running. It is the responsibility of the\n+/// caller to ensure that the runtime is entirely shut down and nothing will be\n+/// poking around at the internal components.\n+///\n+/// Invoking cleanup while portions of the runtime are still in use may cause\n+/// undefined behavior.\n+pub unsafe fn cleanup() {\n+    bookkeeping::wait_for_other_tasks();\n+    at_exit_imp::run();\n+    args::cleanup();\n+    local_ptr::cleanup();\n+}\n+\n+// FIXME: these probably shouldn't be public...\n+#[doc(hidden)]\n+pub mod shouldnt_be_public {\n+    #[cfg(not(test))]\n+    pub use super::local_ptr::native::maybe_tls_key;\n+    #[cfg(not(windows), not(target_os = \"android\"))]\n+    pub use super::local_ptr::compiled::RT_TLS_PTR;\n+}\n+\n+#[cfg(not(test))]\n+mod std {\n+    pub use core::{fmt, option, cmp};\n+}"}, {"sha": "846ec248805e96d5e940f6d9d3b45f80e12a4709", "filename": "src/librustrt/libunwind.rs", "status": "renamed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -79,10 +79,6 @@ pub type _Unwind_Exception_Cleanup_Fn =\n         extern \"C\" fn(unwind_code: _Unwind_Reason_Code,\n                       exception: *_Unwind_Exception);\n \n-pub type _Unwind_Trace_Fn =\n-        extern \"C\" fn(ctx: *_Unwind_Context,\n-                      arg: *libc::c_void) -> _Unwind_Reason_Code;\n-\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"win32\")]\n@@ -97,67 +93,4 @@ extern \"C\" {\n     pub fn _Unwind_RaiseException(exception: *_Unwind_Exception)\n                 -> _Unwind_Reason_Code;\n     pub fn _Unwind_DeleteException(exception: *_Unwind_Exception);\n-    pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n-                             trace_argument: *libc::c_void)\n-                -> _Unwind_Reason_Code;\n-\n-    #[cfg(not(target_os = \"android\"),\n-          not(target_os = \"linux\", target_arch = \"arm\"))]\n-    pub fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t;\n-    #[cfg(not(target_os = \"android\"),\n-          not(target_os = \"linux\", target_arch = \"arm\"))]\n-    pub fn _Unwind_FindEnclosingFunction(pc: *libc::c_void) -> *libc::c_void;\n-}\n-\n-// On android, the function _Unwind_GetIP is a macro, and this is the expansion\n-// of the macro. This is all copy/pasted directly from the header file with the\n-// definition of _Unwind_GetIP.\n-#[cfg(target_os = \"android\")]\n-#[cfg(target_os = \"linux\", target_arch = \"arm\")]\n-pub unsafe fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t {\n-    #[repr(C)]\n-    enum _Unwind_VRS_Result {\n-        _UVRSR_OK = 0,\n-        _UVRSR_NOT_IMPLEMENTED = 1,\n-        _UVRSR_FAILED = 2,\n-    }\n-    #[repr(C)]\n-    enum _Unwind_VRS_RegClass {\n-        _UVRSC_CORE = 0,\n-        _UVRSC_VFP = 1,\n-        _UVRSC_FPA = 2,\n-        _UVRSC_WMMXD = 3,\n-        _UVRSC_WMMXC = 4,\n-    }\n-    #[repr(C)]\n-    enum _Unwind_VRS_DataRepresentation {\n-        _UVRSD_UINT32 = 0,\n-        _UVRSD_VFPX = 1,\n-        _UVRSD_FPAX = 2,\n-        _UVRSD_UINT64 = 3,\n-        _UVRSD_FLOAT = 4,\n-        _UVRSD_DOUBLE = 5,\n-    }\n-\n-    type _Unwind_Word = libc::c_uint;\n-    extern {\n-        fn _Unwind_VRS_Get(ctx: *_Unwind_Context,\n-                           klass: _Unwind_VRS_RegClass,\n-                           word: _Unwind_Word,\n-                           repr: _Unwind_VRS_DataRepresentation,\n-                           data: *mut libc::c_void) -> _Unwind_VRS_Result;\n-    }\n-\n-    let mut val: _Unwind_Word = 0;\n-    let ptr = &mut val as *mut _Unwind_Word;\n-    let _ = _Unwind_VRS_Get(ctx, _UVRSC_CORE, 15, _UVRSD_UINT32,\n-                            ptr as *mut libc::c_void);\n-    (val & !1) as libc::uintptr_t\n-}\n-\n-// This function also doesn't exist on android or arm/linux, so make it a no-op\n-#[cfg(target_os = \"android\")]\n-#[cfg(target_os = \"linux\", target_arch = \"arm\")]\n-pub unsafe fn _Unwind_FindEnclosingFunction(pc: *libc::c_void) -> *libc::c_void {\n-    pc\n }", "previous_filename": "src/libstd/rt/libunwind.rs"}, {"sha": "7fe9dbc6d4ff554d81cbe5a3e375d40ed988de38", "filename": "src/librustrt/local.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::Option;\n-use owned::Box;\n-use rt::task::Task;\n-use rt::local_ptr;\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use local_ptr;\n+use task::Task;\n \n /// Encapsulates some task-local data.\n pub trait Local<Borrowed> {\n@@ -52,11 +53,10 @@ impl Local<local_ptr::Borrowed<Task>> for Task {\n \n #[cfg(test)]\n mod test {\n-    use option::{None, Option};\n-    use rt::thread::Thread;\n+    use std::prelude::*;\n+    use std::rt::thread::Thread;\n     use super::*;\n-    use owned::Box;\n-    use rt::task::Task;\n+    use task::Task;\n \n     #[test]\n     fn thread_local_task_smoke_test() {", "previous_filename": "src/libstd/rt/local.rs"}, {"sha": "6b468bd0827c6144ba0c63eec06c10a922f7bf67", "filename": "src/librustrt/local_data.rs", "status": "renamed", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -38,18 +38,16 @@ assert_eq!(*key_vector.get().unwrap(), ~[4]);\n // Casting 'Arcane Sight' reveals an overwhelming aura of Transmutation\n // magic.\n \n-use iter::{Iterator};\n-use kinds::Send;\n-use kinds::marker;\n-use mem::replace;\n-use mem;\n-use ops::{Drop, Deref};\n-use option::{None, Option, Some};\n-use owned::Box;\n-use raw;\n-use rt::task::{Task, LocalStorage};\n-use slice::{ImmutableVector, MutableVector};\n-use vec::Vec;\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use collections::vec::Vec;\n+use core::kinds::marker;\n+use core::mem;\n+use core::raw;\n+\n+use local::Local;\n+use task::{Task, LocalStorage};\n \n /**\n  * Indexes a task-local data slot. This pointer is used for comparison to\n@@ -97,8 +95,6 @@ type TLSValue = Box<LocalData:Send>;\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n unsafe fn get_local_map() -> Option<&mut Map> {\n-    use rt::local::Local;\n-\n     if !Local::exists(None::<Task>) { return None }\n \n     let task: *mut Task = Local::unsafe_borrow();\n@@ -111,10 +107,10 @@ unsafe fn get_local_map() -> Option<&mut Map> {\n         // If this is the first time we've accessed TLS, perform similar\n         // actions to the oldsched way of doing things.\n         &LocalStorage(ref mut slot) => {\n-            *slot = Some(vec!());\n+            *slot = Some(Vec::new());\n             match *slot {\n                 Some(ref mut map_ptr) => { return Some(map_ptr) }\n-                None => unreachable!(),\n+                None => fail!(\"unreachable code\"),\n             }\n         }\n     }\n@@ -192,7 +188,7 @@ impl<T: 'static> KeyValue<T> {\n \n         match pos {\n             Some(i) => {\n-                replace(map.get_mut(i), newval).map(|(_, data, _)| {\n+                mem::replace(map.get_mut(i), newval).map(|(_, data, _)| {\n                     // Move `data` into transmute to get out the memory that it\n                     // owns, we must free it manually later.\n                     let t: raw::TraitObject = unsafe { mem::transmute(data) };\n@@ -277,10 +273,9 @@ impl<T: 'static> Drop for Ref<T> {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n+    use std::prelude::*;\n     use super::*;\n-    use owned::Box;\n-    use task;\n+    use std::task;\n \n     #[test]\n     fn test_tls_multitask() {", "previous_filename": "src/libstd/local_data.rs"}, {"sha": "52fe5c35a268fbd3a0d9844d580fceeb5b362765", "filename": "src/librustrt/local_heap.rs", "status": "renamed", "additions": 85, "deletions": 94, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_heap.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -10,55 +10,45 @@\n \n //! The local, garbage collected heap\n \n+use core::prelude::*;\n+\n+use alloc::libc_heap;\n use alloc::util;\n-use iter::Iterator;\n use libc::{c_void, free};\n-use mem;\n-use ops::Drop;\n-use option::{Option, None, Some};\n-use ptr::RawPtr;\n-use ptr;\n-use raw;\n-use rt::libc_heap;\n-use rt::local::Local;\n-use rt::task::Task;\n-use slice::{ImmutableVector, Vector};\n-use vec::Vec;\n-\n-// This has no meaning with out rtdebug also turned on.\n-#[cfg(rtdebug)]\n-static TRACK_ALLOCATIONS: int = 0;\n-#[cfg(rtdebug)]\n-static MAGIC: u32 = 0xbadc0ffe;\n+\n+use core::mem;\n+use core::ptr;\n+use core::raw;\n+use local::Local;\n+use task::Task;\n+\n+static RC_IMMORTAL : uint = 0x77777777;\n \n pub type Box = raw::Box<()>;\n \n pub struct MemoryRegion {\n-    allocations: Vec<*AllocHeader>,\n     live_allocations: uint,\n }\n \n pub struct LocalHeap {\n     memory_region: MemoryRegion,\n-\n     live_allocs: *mut raw::Box<()>,\n }\n \n impl LocalHeap {\n-    #[inline]\n     pub fn new() -> LocalHeap {\n-        let region = MemoryRegion {\n-            allocations: Vec::new(),\n-            live_allocations: 0,\n-        };\n         LocalHeap {\n-            memory_region: region,\n+            memory_region: MemoryRegion { live_allocations: 0 },\n             live_allocs: ptr::mut_null(),\n         }\n     }\n \n     #[inline]\n-    pub fn alloc(&mut self, drop_glue: fn(*mut u8), size: uint, align: uint) -> *mut Box {\n+    #[allow(deprecated)]\n+    pub fn alloc(&mut self,\n+                 drop_glue: fn(*mut u8),\n+                 size: uint,\n+                 align: uint) -> *mut Box {\n         let total_size = util::get_box_size(size, align);\n         let alloc = self.memory_region.malloc(total_size);\n         {\n@@ -119,6 +109,63 @@ impl LocalHeap {\n \n         self.memory_region.free(alloc);\n     }\n+\n+    pub unsafe fn annihilate(&mut self) {\n+        let mut n_total_boxes = 0u;\n+\n+        // Pass 1: Make all boxes immortal.\n+        //\n+        // In this pass, nothing gets freed, so it does not matter whether\n+        // we read the next field before or after the callback.\n+        self.each_live_alloc(true, |_, alloc| {\n+            n_total_boxes += 1;\n+            (*alloc).ref_count = RC_IMMORTAL;\n+        });\n+\n+        // Pass 2: Drop all boxes.\n+        //\n+        // In this pass, unique-managed boxes may get freed, but not\n+        // managed boxes, so we must read the `next` field *after* the\n+        // callback, as the original value may have been freed.\n+        self.each_live_alloc(false, |_, alloc| {\n+            let drop_glue = (*alloc).drop_glue;\n+            let data = &mut (*alloc).data as *mut ();\n+            drop_glue(data as *mut u8);\n+        });\n+\n+        // Pass 3: Free all boxes.\n+        //\n+        // In this pass, managed boxes may get freed (but not\n+        // unique-managed boxes, though I think that none of those are\n+        // left), so we must read the `next` field before, since it will\n+        // not be valid after.\n+        self.each_live_alloc(true, |me, alloc| {\n+            me.free(alloc);\n+        });\n+\n+        if debug_mem() {\n+            // We do logging here w/o allocation.\n+            rterrln!(\"total boxes annihilated: {}\", n_total_boxes);\n+        }\n+    }\n+\n+    unsafe fn each_live_alloc(&mut self, read_next_before: bool,\n+                              f: |&mut LocalHeap, alloc: *mut raw::Box<()>|) {\n+        //! Walks the internal list of allocations\n+\n+        let mut alloc = self.live_allocs;\n+        while alloc != ptr::mut_null() {\n+            let next_before = (*alloc).next;\n+\n+            f(self, alloc);\n+\n+            if read_next_before {\n+                alloc = next_before;\n+            } else {\n+                alloc = (*alloc).next;\n+            }\n+        }\n+    }\n }\n \n impl Drop for LocalHeap {\n@@ -127,43 +174,11 @@ impl Drop for LocalHeap {\n     }\n }\n \n-#[cfg(rtdebug)]\n-struct AllocHeader {\n-    magic: u32,\n-    index: i32,\n-    size: u32,\n-}\n-#[cfg(not(rtdebug))]\n struct AllocHeader;\n \n impl AllocHeader {\n-    #[cfg(rtdebug)]\n-    fn init(&mut self, size: u32) {\n-        if TRACK_ALLOCATIONS > 0 {\n-            self.magic = MAGIC;\n-            self.index = -1;\n-            self.size = size;\n-        }\n-    }\n-    #[cfg(not(rtdebug))]\n     fn init(&mut self, _size: u32) {}\n-\n-    #[cfg(rtdebug)]\n-    fn assert_sane(&self) {\n-        if TRACK_ALLOCATIONS > 0 {\n-            rtassert!(self.magic == MAGIC);\n-        }\n-    }\n-    #[cfg(not(rtdebug))]\n     fn assert_sane(&self) {}\n-\n-    #[cfg(rtdebug)]\n-    fn update_size(&mut self, size: u32) {\n-        if TRACK_ALLOCATIONS > 0 {\n-            self.size = size;\n-        }\n-    }\n-    #[cfg(not(rtdebug))]\n     fn update_size(&mut self, _size: u32) {}\n \n     fn as_box(&mut self) -> *mut Box {\n@@ -183,6 +198,17 @@ impl AllocHeader {\n     }\n }\n \n+#[cfg(unix)]\n+fn debug_mem() -> bool {\n+    // FIXME: Need to port the environment struct to newsched\n+    false\n+}\n+\n+#[cfg(windows)]\n+fn debug_mem() -> bool {\n+    false\n+}\n+\n impl MemoryRegion {\n     #[inline]\n     fn malloc(&mut self, size: uint) -> *mut Box {\n@@ -230,39 +256,10 @@ impl MemoryRegion {\n         }\n     }\n \n-    #[cfg(rtdebug)]\n-    fn claim(&mut self, alloc: &mut AllocHeader) {\n-        alloc.assert_sane();\n-        if TRACK_ALLOCATIONS > 1 {\n-            alloc.index = self.allocations.len() as i32;\n-            self.allocations.push(&*alloc as *AllocHeader);\n-        }\n-    }\n-    #[cfg(not(rtdebug))]\n     #[inline]\n     fn claim(&mut self, _alloc: &mut AllocHeader) {}\n-\n-    #[cfg(rtdebug)]\n-    fn release(&mut self, alloc: &AllocHeader) {\n-        alloc.assert_sane();\n-        if TRACK_ALLOCATIONS > 1 {\n-            rtassert!(self.allocations.as_slice()[alloc.index] == alloc as *AllocHeader);\n-            self.allocations.as_mut_slice()[alloc.index] = ptr::null();\n-        }\n-    }\n-    #[cfg(not(rtdebug))]\n     #[inline]\n     fn release(&mut self, _alloc: &AllocHeader) {}\n-\n-    #[cfg(rtdebug)]\n-    fn update(&mut self, alloc: &mut AllocHeader, orig: *AllocHeader) {\n-        alloc.assert_sane();\n-        if TRACK_ALLOCATIONS > 1 {\n-            rtassert!(self.allocations.as_slice()[alloc.index] == orig);\n-            self.allocations.as_mut_slice()[alloc.index] = &*alloc as *AllocHeader;\n-        }\n-    }\n-    #[cfg(not(rtdebug))]\n     #[inline]\n     fn update(&mut self, _alloc: &mut AllocHeader, _orig: *AllocHeader) {}\n }\n@@ -272,11 +269,9 @@ impl Drop for MemoryRegion {\n         if self.live_allocations != 0 {\n             rtabort!(\"leaked managed memory ({} objects)\", self.live_allocations);\n         }\n-        rtassert!(self.allocations.as_slice().iter().all(|s| s.is_null()));\n     }\n }\n \n-\n #[cfg(not(test))]\n #[lang=\"malloc\"]\n #[inline]\n@@ -318,10 +313,6 @@ pub unsafe fn local_free(ptr: *u8) {\n     }\n }\n \n-pub fn live_allocs() -> *mut Box {\n-    Local::borrow(None::<Task>).heap.live_allocs\n-}\n-\n #[cfg(test)]\n mod bench {\n     extern crate test;", "previous_filename": "src/libstd/rt/local_heap.rs"}, {"sha": "91e3409892ea5f3d2da7027a57409f3429948794", "filename": "src/librustrt/local_ptr.rs", "status": "renamed", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_ptr.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -17,10 +17,10 @@\n \n #![allow(dead_code)]\n \n-use mem;\n-use ops::{Drop, Deref, DerefMut};\n-use owned::Box;\n-use ptr::RawPtr;\n+use core::prelude::*;\n+\n+use core::mem;\n+use alloc::owned::Box;\n \n #[cfg(windows)]               // mingw-w32 doesn't like thread_local things\n #[cfg(target_os = \"android\")] // see #10686\n@@ -83,13 +83,13 @@ pub unsafe fn borrow<T>() -> Borrowed<T> {\n /// it wherever possible.\n #[cfg(not(windows), not(target_os = \"android\"))]\n pub mod compiled {\n-    use mem;\n-    use option::{Option, Some, None};\n-    use owned::Box;\n-    use ptr::RawPtr;\n+    use core::prelude::*;\n+\n+    use alloc::owned::Box;\n+    use core::mem;\n \n     #[cfg(test)]\n-    pub use realstd::rt::shouldnt_be_public::RT_TLS_PTR;\n+    pub use realrustrt::shouldnt_be_public::RT_TLS_PTR;\n \n     #[cfg(not(test))]\n     #[thread_local]\n@@ -234,12 +234,12 @@ pub mod compiled {\n /// implementation uses the `thread_local_storage` module to provide a\n /// thread-local value.\n pub mod native {\n-    use mem;\n-    use option::{Option, Some, None};\n-    use owned::Box;\n-    use ptr::RawPtr;\n-    use ptr;\n-    use tls = rt::thread_local_storage;\n+    use core::prelude::*;\n+\n+    use alloc::owned::Box;\n+    use core::mem;\n+    use core::ptr;\n+    use tls = thread_local_storage;\n \n     static mut RT_TLS_KEY: tls::Key = -1;\n \n@@ -396,9 +396,9 @@ pub mod native {\n \n     #[inline] #[cfg(test)]\n     pub fn maybe_tls_key() -> Option<tls::Key> {\n-        use realstd;\n+        use realrustrt;\n         unsafe {\n-            mem::transmute(realstd::rt::shouldnt_be_public::maybe_tls_key())\n+            mem::transmute(realrustrt::shouldnt_be_public::maybe_tls_key())\n         }\n     }\n }", "previous_filename": "src/libstd/rt/local_ptr.rs"}, {"sha": "d4e92736a9d4d2ec38d72a690fba240335efe390", "filename": "src/librustrt/macros.rs", "status": "renamed", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmacros.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -16,8 +16,8 @@\n #![macro_escape]\n \n macro_rules! rterrln (\n-    ($($arg:tt)*) => ( {\n-        format_args!(::rt::util::dumb_println, $($arg)*)\n+    ($fmt:expr $($arg:tt)*) => ( {\n+        format_args!(::util::dumb_print, concat!($fmt, \"\\n\") $($arg)*)\n     } )\n )\n \n@@ -32,7 +32,7 @@ macro_rules! rtdebug (\n \n macro_rules! rtassert (\n     ( $arg:expr ) => ( {\n-        if ::rt::util::ENFORCE_SANITY {\n+        if ::util::ENFORCE_SANITY {\n             if !$arg {\n                 rtabort!(\" assertion failed: {}\", stringify!($arg));\n             }\n@@ -42,8 +42,5 @@ macro_rules! rtassert (\n \n \n macro_rules! rtabort (\n-    ($($arg:tt)*) => ( {\n-        use str::Str;\n-        ::rt::util::abort(format!($($arg)*).as_slice());\n-    } )\n+    ($($arg:tt)*) => (format_args!(::util::abort, $($arg)*))\n )", "previous_filename": "src/libstd/rt/macros.rs"}, {"sha": "fccbe4a15e948144cf8f67488107da5313951692", "filename": "src/librustrt/mutex.rs", "status": "renamed", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -33,7 +33,7 @@\n //! # Example\n //!\n //! ```rust\n-//! use std::unstable::mutex::{NativeMutex, StaticNativeMutex, NATIVE_MUTEX_INIT};\n+//! use std::rt::mutex::{NativeMutex, StaticNativeMutex, NATIVE_MUTEX_INIT};\n //!\n //! // Use a statically initialized mutex\n //! static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n@@ -58,8 +58,7 @@\n \n #![allow(non_camel_case_types)]\n \n-use option::{Option, None, Some};\n-use ops::Drop;\n+use core::prelude::*;\n \n /// A native mutex suitable for storing in statics (that is, it has\n /// the `destroy` method rather than a destructor).\n@@ -109,7 +108,7 @@ impl StaticNativeMutex {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    /// use std::rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     /// static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n     /// unsafe {\n     ///     let _guard = LOCK.lock();\n@@ -183,7 +182,7 @@ impl NativeMutex {\n     ///\n     /// # Example\n     /// ```rust\n-    /// use std::unstable::mutex::NativeMutex;\n+    /// use std::rt::mutex::NativeMutex;\n     /// unsafe {\n     ///     let mut lock = NativeMutex::new();\n     ///\n@@ -264,8 +263,8 @@ mod imp {\n     use libc;\n     use self::os::{PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER,\n                    pthread_mutex_t, pthread_cond_t};\n-    use ty::Unsafe;\n-    use kinds::marker;\n+    use core::ty::Unsafe;\n+    use core::kinds::marker;\n \n     type pthread_mutexattr_t = libc::c_void;\n     type pthread_condattr_t = libc::c_void;\n@@ -432,11 +431,11 @@ mod imp {\n \n #[cfg(windows)]\n mod imp {\n-    use rt::libc_heap::malloc_raw;\n+    use alloc::libc_heap::malloc_raw;\n+    use core::atomics;\n+    use core::ptr;\n     use libc::{HANDLE, BOOL, LPSECURITY_ATTRIBUTES, c_void, DWORD, LPCSTR};\n     use libc;\n-    use ptr;\n-    use sync::atomics;\n \n     type LPCRITICAL_SECTION = *mut c_void;\n     static SPIN_COUNT: DWORD = 4000;\n@@ -563,11 +562,11 @@ mod imp {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use std::prelude::*;\n \n-    use mem::drop;\n+    use std::mem::drop;\n     use super::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    use rt::thread::Thread;\n+    use std::rt::thread::Thread;\n \n     #[test]\n     fn smoke_lock() {", "previous_filename": "src/libstd/unstable/mutex.rs"}, {"sha": "00f761bae2152e133780dea04f574ac05fe8f2a0", "filename": "src/librustrt/rtio.rs", "status": "renamed", "additions": 127, "deletions": 52, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -10,33 +10,18 @@\n \n //! The EventLoop and internal synchronous I/O interface.\n \n-use c_str::CString;\n-use comm::{Sender, Receiver};\n-use kinds::Send;\n+use core::prelude::*;\n+use alloc::owned::Box;\n+use collections::string::String;\n+use collections::vec::Vec;\n+use core::fmt;\n+use core::mem;\n use libc::c_int;\n use libc;\n-use mem;\n-use ops::Drop;\n-use option::{Option, Some, None};\n-use owned::Box;\n-use path::Path;\n-use result::Err;\n-use rt::local::Local;\n-use rt::task::Task;\n-use vec::Vec;\n-\n-use ai = io::net::addrinfo;\n-use io;\n-use io::IoResult;\n-use io::net::ip::{IpAddr, SocketAddr};\n-use io::process::{StdioContainer, ProcessExit};\n-use io::signal::Signum;\n-use io::{FileMode, FileAccess, FileStat, FilePermission};\n-use io::{SeekStyle};\n \n-pub trait Callback {\n-    fn call(&mut self);\n-}\n+use c_str::CString;\n+use local::Local;\n+use task::Task;\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -51,6 +36,10 @@ pub trait EventLoop {\n     fn has_active_io(&self) -> bool;\n }\n \n+pub trait Callback {\n+    fn call(&mut self);\n+}\n+\n pub trait RemoteCallback {\n     /// Trigger the remote callback. Note that the number of times the\n     /// callback is run is not guaranteed. All that is guaranteed is\n@@ -61,18 +50,6 @@ pub trait RemoteCallback {\n     fn fire(&mut self);\n }\n \n-/// Data needed to make a successful open(2) call\n-/// Using unix flag conventions for now, which happens to also be what's supported\n-/// libuv (it does translation to windows under the hood).\n-pub struct FileOpenConfig {\n-    /// Path to file to be opened\n-    pub path: Path,\n-    /// Flags for file access mode (as per open(2))\n-    pub flags: int,\n-    /// File creation mode, ignored unless O_CREAT is passed as part of flags\n-    pub mode: int\n-}\n-\n /// Description of what to do when a file handle is closed\n pub enum CloseBehavior {\n     /// Do not close this handle when the object is destroyed\n@@ -185,9 +162,15 @@ impl<'a> LocalIo<'a> {\n     pub fn maybe_raise<T>(f: |io: &mut IoFactory| -> IoResult<T>)\n         -> IoResult<T>\n     {\n+        #[cfg(unix)] use ERROR = libc::EINVAL;\n+        #[cfg(windows)] use ERROR = libc::ERROR_CALL_NOT_IMPLEMENTED;\n         match LocalIo::borrow() {\n-            None => Err(io::standard_error(io::IoUnavailable)),\n             Some(mut io) => f(io.get()),\n+            None => Err(IoError {\n+                code: ERROR as uint,\n+                extra: 0,\n+                detail: None,\n+            }),\n         }\n     }\n \n@@ -198,11 +181,8 @@ impl<'a> LocalIo<'a> {\n     /// Returns the underlying I/O factory as a trait reference.\n     #[inline]\n     pub fn get<'a>(&'a mut self) -> &'a mut IoFactory {\n-        // FIXME(pcwalton): I think this is actually sound? Could borrow check\n-        // allow this safely?\n-        unsafe {\n-            mem::transmute_copy(&self.factory)\n-        }\n+        let f: &'a mut IoFactory = self.factory;\n+        f\n     }\n }\n \n@@ -219,7 +199,8 @@ pub trait IoFactory {\n     fn unix_connect(&mut self, path: &CString,\n                     timeout: Option<u64>) -> IoResult<Box<RtioPipe:Send>>;\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<ai::Hint>) -> IoResult<Vec<ai::Info>>;\n+                          hint: Option<AddrinfoHint>)\n+                          -> IoResult<Vec<AddrinfoInfo>>;\n \n     // filesystem operations\n     fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior)\n@@ -228,18 +209,16 @@ pub trait IoFactory {\n                -> IoResult<Box<RtioFileStream:Send>>;\n     fn fs_unlink(&mut self, path: &CString) -> IoResult<()>;\n     fn fs_stat(&mut self, path: &CString) -> IoResult<FileStat>;\n-    fn fs_mkdir(&mut self, path: &CString,\n-                mode: FilePermission) -> IoResult<()>;\n-    fn fs_chmod(&mut self, path: &CString,\n-                mode: FilePermission) -> IoResult<()>;\n+    fn fs_mkdir(&mut self, path: &CString, mode: uint) -> IoResult<()>;\n+    fn fs_chmod(&mut self, path: &CString, mode: uint) -> IoResult<()>;\n     fn fs_rmdir(&mut self, path: &CString) -> IoResult<()>;\n     fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()>;\n     fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n-        IoResult<Vec<Path>>;\n+        IoResult<Vec<CString>>;\n     fn fs_lstat(&mut self, path: &CString) -> IoResult<FileStat>;\n     fn fs_chown(&mut self, path: &CString, uid: int, gid: int) ->\n         IoResult<()>;\n-    fn fs_readlink(&mut self, path: &CString) -> IoResult<Path>;\n+    fn fs_readlink(&mut self, path: &CString) -> IoResult<CString>;\n     fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()>;\n     fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()>;\n     fn fs_utime(&mut self, src: &CString, atime: u64, mtime: u64) ->\n@@ -254,7 +233,7 @@ pub trait IoFactory {\n     fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<RtioPipe:Send>>;\n     fn tty_open(&mut self, fd: c_int, readable: bool)\n             -> IoResult<Box<RtioTTY:Send>>;\n-    fn signal(&mut self, signal: Signum, channel: Sender<Signum>)\n+    fn signal(&mut self, signal: int, cb: Box<Callback:Send>)\n         -> IoResult<Box<RtioSignal:Send>>;\n }\n \n@@ -313,8 +292,8 @@ pub trait RtioUdpSocket : RtioSocket {\n \n pub trait RtioTimer {\n     fn sleep(&mut self, msecs: u64);\n-    fn oneshot(&mut self, msecs: u64) -> Receiver<()>;\n-    fn period(&mut self, msecs: u64) -> Receiver<()>;\n+    fn oneshot(&mut self, msecs: u64, cb: Box<Callback:Send>);\n+    fn period(&mut self, msecs: u64, cb: Box<Callback:Send>);\n }\n \n pub trait RtioFileStream {\n@@ -372,3 +351,99 @@ pub trait PausableIdleCallback {\n }\n \n pub trait RtioSignal {}\n+\n+pub struct IoError {\n+    pub code: uint,\n+    pub extra: uint,\n+    pub detail: Option<String>,\n+}\n+\n+pub type IoResult<T> = Result<T, IoError>;\n+\n+#[deriving(PartialEq, Eq)]\n+pub enum IpAddr {\n+    Ipv4Addr(u8, u8, u8, u8),\n+    Ipv6Addr(u16, u16, u16, u16, u16, u16, u16, u16),\n+}\n+\n+impl fmt::Show for IpAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Ipv4Addr(a, b, c, d) => write!(fmt, \"{}.{}.{}.{}\", a, b, c, d),\n+            Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+                write!(fmt,\n+                       \"{:04x}:{:04x}:{:04x}:{:04x}:{:04x}:{:04x}:{:04x}:{:04x}\",\n+                       a, b, c, d, e, f, g, h)\n+            }\n+        }\n+    }\n+}\n+\n+#[deriving(PartialEq, Eq)]\n+pub struct SocketAddr {\n+    pub ip: IpAddr,\n+    pub port: u16,\n+}\n+\n+pub enum StdioContainer {\n+    Ignored,\n+    InheritFd(i32),\n+    CreatePipe(bool, bool),\n+}\n+\n+pub enum ProcessExit {\n+    ExitStatus(int),\n+    ExitSignal(int),\n+}\n+\n+pub enum FileMode {\n+    Open,\n+    Append,\n+    Truncate,\n+}\n+\n+pub enum FileAccess {\n+    Read,\n+    Write,\n+    ReadWrite,\n+}\n+\n+pub struct FileStat {\n+    pub size: u64,\n+    pub kind: u64,\n+    pub perm: u64,\n+    pub created: u64,\n+    pub modified: u64,\n+    pub accessed: u64,\n+    pub device: u64,\n+    pub inode: u64,\n+    pub rdev: u64,\n+    pub nlink: u64,\n+    pub uid: u64,\n+    pub gid: u64,\n+    pub blksize: u64,\n+    pub blocks: u64,\n+    pub flags: u64,\n+    pub gen: u64,\n+}\n+\n+pub enum SeekStyle {\n+    SeekSet,\n+    SeekEnd,\n+    SeekCur,\n+}\n+\n+pub struct AddrinfoHint {\n+    pub family: uint,\n+    pub socktype: uint,\n+    pub protocol: uint,\n+    pub flags: uint,\n+}\n+\n+pub struct AddrinfoInfo {\n+    pub address: SocketAddr,\n+    pub family: uint,\n+    pub socktype: uint,\n+    pub protocol: uint,\n+    pub flags: uint,\n+}", "previous_filename": "src/libstd/rt/rtio.rs"}, {"sha": "148d93adc8485583c3a58f53bf7a4a87357e549a", "filename": "src/librustrt/stack.rs", "status": "renamed", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -33,12 +33,11 @@ pub static RED_ZONE: uint = 20 * 1024;\n #[cfg(not(test))] // in testing, use the original libstd's version\n #[lang = \"stack_exhausted\"]\n extern fn stack_exhausted() {\n-    use option::{Option, None, Some};\n-    use owned::Box;\n-    use rt::local::Local;\n-    use rt::task::Task;\n-    use str::Str;\n-    use intrinsics;\n+    use core::prelude::*;\n+    use alloc::owned::Box;\n+    use local::Local;\n+    use task::Task;\n+    use core::intrinsics;\n \n     unsafe {\n         // We're calling this function because the stack just ran out. We need", "previous_filename": "src/libstd/rt/stack.rs"}, {"sha": "0640b2b9c77aeefe06c80b52d7885000becf27e6", "filename": "src/librustrt/task.rs", "status": "renamed", "additions": 62, "deletions": 80, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -13,30 +13,24 @@\n //! local storage, and logging. Even a 'freestanding' Rust would likely want\n //! to implement this.\n \n+use core::prelude::*;\n+\n use alloc::arc::Arc;\n+use alloc::owned::{AnyOwnExt, Box};\n+use core::any::Any;\n+use core::atomics::{AtomicUint, SeqCst};\n+use core::finally::Finally;\n+use core::iter::Take;\n+use core::mem;\n+use core::raw;\n \n-use cleanup;\n-use clone::Clone;\n-use comm::Sender;\n-use io::Writer;\n-use iter::{Iterator, Take};\n-use kinds::Send;\n use local_data;\n-use mem;\n-use ops::Drop;\n-use option::{Option, Some, None};\n-use owned::{AnyOwnExt, Box};\n-use prelude::drop;\n-use result::{Result, Ok, Err};\n-use rt::Runtime;\n-use rt::local::Local;\n-use rt::local_heap::LocalHeap;\n-use rt::rtio::LocalIo;\n-use rt::unwind::Unwinder;\n-use str::SendStr;\n-use sync::atomics::{AtomicUint, SeqCst};\n-use task::{TaskResult, TaskOpts};\n-use finally::Finally;\n+use Runtime;\n+use local::Local;\n+use local_heap::LocalHeap;\n+use rtio::LocalIo;\n+use unwind::Unwinder;\n+use collections::str::SendStr;\n \n /// The Task struct represents all state associated with a rust\n /// task. There are at this point two primary \"subtypes\" of task,\n@@ -52,12 +46,26 @@ pub struct Task {\n     pub destroyed: bool,\n     pub name: Option<SendStr>,\n \n-    pub stdout: Option<Box<Writer:Send>>,\n-    pub stderr: Option<Box<Writer:Send>>,\n-\n     imp: Option<Box<Runtime:Send>>,\n }\n \n+pub struct TaskOpts {\n+    /// Invoke this procedure with the result of the task when it finishes.\n+    pub on_exit: Option<proc(Result):Send>,\n+    /// A name for the task-to-be, for identification in failure messages\n+    pub name: Option<SendStr>,\n+    /// The size of the stack for the spawned task\n+    pub stack_size: Option<uint>,\n+}\n+\n+/// Indicates the manner in which a task exited.\n+///\n+/// A task that completes without failing is considered to exit successfully.\n+///\n+/// If you wish for this result's delivery to block until all\n+/// children tasks complete, recommend using a result future.\n+pub type Result = ::core::result::Result<(), Box<Any:Send>>;\n+\n pub struct GarbageCollector;\n pub struct LocalStorage(pub Option<local_data::Map>);\n \n@@ -69,17 +77,9 @@ pub enum BlockedTask {\n     Shared(Arc<AtomicUint>),\n }\n \n-pub enum DeathAction {\n-    /// Action to be done with the exit code. If set, also makes the task wait\n-    /// until all its watched children exit before collecting the status.\n-    Execute(proc(TaskResult):Send),\n-    /// A channel to send the result of the task on when the task exits\n-    SendMessage(Sender<TaskResult>),\n-}\n-\n /// Per-task state related to task death, killing, failure, etc.\n pub struct Death {\n-    pub on_exit: Option<DeathAction>,\n+    pub on_exit: Option<proc(Result):Send>,\n }\n \n pub struct BlockedTasks {\n@@ -96,8 +96,6 @@ impl Task {\n             death: Death::new(),\n             destroyed: false,\n             name: None,\n-            stdout: None,\n-            stderr: None,\n             imp: None,\n         }\n     }\n@@ -126,20 +124,6 @@ impl Task {\n \n             // Run the task main function, then do some cleanup.\n             f.finally(|| {\n-                #[allow(unused_must_use)]\n-                fn close_outputs() {\n-                    let mut task = Local::borrow(None::<Task>);\n-                    let stderr = task.stderr.take();\n-                    let stdout = task.stdout.take();\n-                    drop(task);\n-                    match stdout { Some(mut w) => { w.flush(); }, None => {} }\n-                    match stderr { Some(mut w) => { w.flush(); }, None => {} }\n-                }\n-\n-                // First, flush/destroy the user stdout/logger because these\n-                // destructors can run arbitrary code.\n-                close_outputs();\n-\n                 // First, destroy task-local storage. This may run user dtors.\n                 //\n                 // FIXME #8302: Dear diary. I'm so tired and confused.\n@@ -159,23 +143,19 @@ impl Task {\n                 // TLS, or possibly some destructors for those objects being\n                 // annihilated invoke TLS. Sadly these two operations seemed to\n                 // be intertwined, and miraculously work for now...\n-                let mut task = Local::borrow(None::<Task>);\n-                let storage_map = {\n+                drop({\n+                    let mut task = Local::borrow(None::<Task>);\n                     let &LocalStorage(ref mut optmap) = &mut task.storage;\n                     optmap.take()\n-                };\n-                drop(task);\n-                drop(storage_map);\n+                });\n \n                 // Destroy remaining boxes. Also may run user dtors.\n-                unsafe { cleanup::annihilate(); }\n-\n-                // Finally, just in case user dtors printed/logged during TLS\n-                // cleanup and annihilation, re-destroy stdout and the logger.\n-                // Note that these will have been initialized with a\n-                // runtime-provided type which we have control over what the\n-                // destructor does.\n-                close_outputs();\n+                let mut heap = {\n+                    let mut task = Local::borrow(None::<Task>);\n+                    mem::replace(&mut task.heap, LocalHeap::new())\n+                };\n+                unsafe { heap.annihilate() }\n+                drop(heap);\n             })\n         };\n \n@@ -222,13 +202,16 @@ impl Task {\n         //      crops up.\n         unsafe {\n             let imp = self.imp.take_unwrap();\n-            let &(vtable, _): &(uint, uint) = mem::transmute(&imp);\n+            let vtable = mem::transmute::<_, &raw::TraitObject>(&imp).vtable;\n             match imp.wrap().move::<T>() {\n                 Ok(t) => Some(t),\n                 Err(t) => {\n-                    let (_, obj): (uint, uint) = mem::transmute(t);\n+                    let data = mem::transmute::<_, raw::TraitObject>(t).data;\n                     let obj: Box<Runtime:Send> =\n-                        mem::transmute((vtable, obj));\n+                        mem::transmute(raw::TraitObject {\n+                            vtable: vtable,\n+                            data: data,\n+                        });\n                     self.put_runtime(obj);\n                     None\n                 }\n@@ -247,7 +230,7 @@ impl Task {\n     /// recommended to use this function directly, but rather communication\n     /// primitives in `std::comm` should be used.\n     pub fn deschedule(mut ~self, amt: uint,\n-                      f: |BlockedTask| -> Result<(), BlockedTask>) {\n+                      f: |BlockedTask| -> ::core::result::Result<(), BlockedTask>) {\n         let ops = self.imp.take_unwrap();\n         ops.deschedule(amt, self, f)\n     }\n@@ -303,6 +286,12 @@ impl Drop for Task {\n     }\n }\n \n+impl TaskOpts {\n+    pub fn new() -> TaskOpts {\n+        TaskOpts { on_exit: None, name: None, stack_size: None }\n+    }\n+}\n+\n impl Iterator<BlockedTask> for BlockedTasks {\n     fn next(&mut self) -> Option<BlockedTask> {\n         Some(Shared(self.inner.clone()))\n@@ -389,10 +378,9 @@ impl Death {\n     }\n \n     /// Collect failure exit codes from children and propagate them to a parent.\n-    pub fn collect_failure(&mut self, result: TaskResult) {\n+    pub fn collect_failure(&mut self, result: Result) {\n         match self.on_exit.take() {\n-            Some(Execute(f)) => f(result),\n-            Some(SendMessage(ch)) => { let _ = ch.send_opt(result); }\n+            Some(f) => f(result),\n             None => {}\n         }\n     }\n@@ -407,8 +395,8 @@ impl Drop for Death {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use prelude::*;\n-    use task;\n+    use std::prelude::*;\n+    use std::task;\n \n     #[test]\n     fn local_heap() {\n@@ -440,16 +428,11 @@ mod test {\n \n     #[test]\n     fn rng() {\n-        use rand::{StdRng, Rng};\n+        use std::rand::{StdRng, Rng};\n         let mut r = StdRng::new().ok().unwrap();\n         let _ = r.next_u32();\n     }\n \n-    #[test]\n-    fn logging() {\n-        info!(\"here i am. logging in a newsched task\");\n-    }\n-\n     #[test]\n     fn comm_stream() {\n         let (tx, rx) = channel();\n@@ -466,8 +449,7 @@ mod test {\n \n     #[test]\n     fn heap_cycles() {\n-        use cell::RefCell;\n-        use option::{Option, Some, None};\n+        use std::cell::RefCell;\n \n         struct List {\n             next: Option<@RefCell<List>>,\n@@ -485,7 +467,7 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_begin_unwind() {\n-        use rt::unwind::begin_unwind;\n+        use std::rt::unwind::begin_unwind;\n         begin_unwind(\"cause\", file!(), line!())\n     }\n ", "previous_filename": "src/libstd/rt/task.rs"}, {"sha": "2cdeb21fb83dde04f3dfd25c63d2b7577863764f", "filename": "src/librustrt/thread_local_storage.rs", "status": "renamed", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread_local_storage.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -10,26 +10,21 @@\n \n #![allow(dead_code)]\n \n-#[cfg(test)]\n-use owned::Box;\n-#[cfg(unix)]\n-use libc::c_int;\n-#[cfg(unix)]\n-use ptr::null;\n-#[cfg(windows)]\n-use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n+#[cfg(unix)] use libc::c_int;\n+#[cfg(unix)] use core::ptr::null;\n+#[cfg(windows)] use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n \n #[cfg(unix)]\n pub type Key = pthread_key_t;\n \n #[cfg(unix)]\n pub unsafe fn create(key: &mut Key) {\n-    assert_eq!(0, pthread_key_create(key, null()));\n+    assert!(pthread_key_create(key, null()) == 0);\n }\n \n #[cfg(unix)]\n pub unsafe fn set(key: Key, value: *mut u8) {\n-    assert_eq!(0, pthread_setspecific(key, value));\n+    assert!(pthread_setspecific(key, value) == 0);\n }\n \n #[cfg(unix)]\n@@ -39,7 +34,7 @@ pub unsafe fn get(key: Key) -> *mut u8 {\n \n #[cfg(unix)]\n pub unsafe fn destroy(key: Key) {\n-    assert_eq!(0, pthread_key_delete(key));\n+    assert!(pthread_key_delete(key) == 0);\n }\n \n #[cfg(target_os=\"macos\")]\n@@ -94,19 +89,25 @@ extern \"system\" {\n     fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n }\n \n-#[test]\n-fn tls_smoke_test() {\n-    use mem::transmute;\n-    unsafe {\n-        let mut key = 0;\n-        let value = box 20;\n-        create(&mut key);\n-        set(key, transmute(value));\n-        let value: Box<int> = transmute(get(key));\n-        assert_eq!(value, box 20);\n-        let value = box 30;\n-        set(key, transmute(value));\n-        let value: Box<int> = transmute(get(key));\n-        assert_eq!(value, box 30);\n+#[cfg(test)]\n+mod test {\n+    use std::prelude::*;\n+    use super::*;\n+\n+    #[test]\n+    fn tls_smoke_test() {\n+        use std::mem::transmute;\n+        unsafe {\n+            let mut key = 0;\n+            let value = box 20;\n+            create(&mut key);\n+            set(key, transmute(value));\n+            let value: Box<int> = transmute(get(key));\n+            assert_eq!(value, box 20);\n+            let value = box 30;\n+            set(key, transmute(value));\n+            let value: Box<int> = transmute(get(key));\n+            assert_eq!(value, box 30);\n+        }\n     }\n }", "previous_filename": "src/libstd/rt/thread_local_storage.rs"}, {"sha": "2fd9f4ef1f18cadf9e6d8ebddcaa24efa058e96d", "filename": "src/librustrt/unwind.rs", "status": "renamed", "additions": 171, "deletions": 183, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -8,73 +8,74 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Stack unwinding\n-\n-// Implementation of Rust stack unwinding\n-//\n-// For background on exception handling and stack unwinding please see\n-// \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n-// documents linked from it.\n-// These are also good reads:\n-//     http://theofilos.cs.columbia.edu/blog/2013/09/22/base_abi/\n-//     http://monoinfinito.wordpress.com/series/exception-handling-in-c/\n-//     http://www.airs.com/blog/index.php?s=exception+frames\n-//\n-// ~~~ A brief summary ~~~\n-// Exception handling happens in two phases: a search phase and a cleanup phase.\n-//\n-// In both phases the unwinder walks stack frames from top to bottom using\n-// information from the stack frame unwind sections of the current process's\n-// modules (\"module\" here refers to an OS module, i.e. an executable or a\n-// dynamic library).\n-//\n-// For each stack frame, it invokes the associated \"personality routine\", whose\n-// address is also stored in the unwind info section.\n-//\n-// In the search phase, the job of a personality routine is to examine exception\n-// object being thrown, and to decide whether it should be caught at that stack\n-// frame.  Once the handler frame has been identified, cleanup phase begins.\n-//\n-// In the cleanup phase, personality routines invoke cleanup code associated\n-// with their stack frames (i.e. destructors).  Once stack has been unwound down\n-// to the handler frame level, unwinding stops and the last personality routine\n-// transfers control to its' catch block.\n-//\n-// ~~~ Frame unwind info registration ~~~\n-// Each module has its' own frame unwind info section (usually \".eh_frame\"), and\n-// unwinder needs to know about all of them in order for unwinding to be able to\n-// cross module boundaries.\n-//\n-// On some platforms, like Linux, this is achieved by dynamically enumerating\n-// currently loaded modules via the dl_iterate_phdr() API and finding all\n-// .eh_frame sections.\n-//\n-// Others, like Windows, require modules to actively register their unwind info\n-// sections by calling __register_frame_info() API at startup.  In the latter\n-// case it is essential that there is only one copy of the unwinder runtime in\n-// the process.  This is usually achieved by linking to the dynamic version of\n-// the unwind runtime.\n-//\n-// Currently Rust uses unwind runtime provided by libgcc.\n-\n-use any::{Any, AnyRefExt};\n-use fmt;\n-use intrinsics;\n-use kinds::Send;\n-use mem;\n-use option::{Some, None, Option};\n-use owned::Box;\n-use prelude::drop;\n-use ptr::RawPtr;\n-use result::{Err, Ok, Result};\n-use rt::backtrace;\n-use rt::local::Local;\n-use rt::task::Task;\n-use str::Str;\n-use string::String;\n-use task::TaskResult;\n-\n-use uw = rt::libunwind;\n+//! Implementation of Rust stack unwinding\n+//!\n+//! For background on exception handling and stack unwinding please see\n+//! \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n+//! documents linked from it.\n+//! These are also good reads:\n+//!     http://theofilos.cs.columbia.edu/blog/2013/09/22/base_abi/\n+//!     http://monoinfinito.wordpress.com/series/exception-handling-in-c/\n+//!     http://www.airs.com/blog/index.php?s=exception+frames\n+//!\n+//! ## A brief summary\n+//!\n+//! Exception handling happens in two phases: a search phase and a cleanup phase.\n+//!\n+//! In both phases the unwinder walks stack frames from top to bottom using\n+//! information from the stack frame unwind sections of the current process's\n+//! modules (\"module\" here refers to an OS module, i.e. an executable or a\n+//! dynamic library).\n+//!\n+//! For each stack frame, it invokes the associated \"personality routine\", whose\n+//! address is also stored in the unwind info section.\n+//!\n+//! In the search phase, the job of a personality routine is to examine exception\n+//! object being thrown, and to decide whether it should be caught at that stack\n+//! frame.  Once the handler frame has been identified, cleanup phase begins.\n+//!\n+//! In the cleanup phase, personality routines invoke cleanup code associated\n+//! with their stack frames (i.e. destructors).  Once stack has been unwound down\n+//! to the handler frame level, unwinding stops and the last personality routine\n+//! transfers control to its' catch block.\n+//!\n+//! ## Frame unwind info registration\n+//!\n+//! Each module has its' own frame unwind info section (usually \".eh_frame\"), and\n+//! unwinder needs to know about all of them in order for unwinding to be able to\n+//! cross module boundaries.\n+//!\n+//! On some platforms, like Linux, this is achieved by dynamically enumerating\n+//! currently loaded modules via the dl_iterate_phdr() API and finding all\n+//! .eh_frame sections.\n+//!\n+//! Others, like Windows, require modules to actively register their unwind info\n+//! sections by calling __register_frame_info() API at startup.  In the latter\n+//! case it is essential that there is only one copy of the unwinder runtime in\n+//! the process.  This is usually achieved by linking to the dynamic version of\n+//! the unwind runtime.\n+//!\n+//! Currently Rust uses unwind runtime provided by libgcc.\n+\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use collections::string::String;\n+use collections::vec::Vec;\n+use core::any::Any;\n+use core::atomics;\n+use core::cmp;\n+use core::fmt;\n+use core::intrinsics;\n+use core::mem;\n+use core::raw::Closure;\n+use libc::c_void;\n+\n+use local::Local;\n+use task::{Task, Result};\n+use exclusive::Exclusive;\n+\n+use uw = libunwind;\n \n pub struct Unwinder {\n     unwinding: bool,\n@@ -86,6 +87,24 @@ struct Exception {\n     cause: Option<Box<Any:Send>>,\n }\n \n+pub type Callback = fn(msg: &Any:Send, file: &'static str, line: uint);\n+type Queue = Exclusive<Vec<Callback>>;\n+\n+// Variables used for invoking callbacks when a task starts to unwind.\n+//\n+// For more information, see below.\n+static MAX_CALLBACKS: uint = 16;\n+static mut CALLBACKS: [atomics::AtomicUint, ..MAX_CALLBACKS] =\n+        [atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT,\n+         atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT,\n+         atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT,\n+         atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT,\n+         atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT,\n+         atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT,\n+         atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT,\n+         atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT];\n+static mut CALLBACK_CNT: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n+\n impl Unwinder {\n     pub fn new() -> Unwinder {\n         Unwinder {\n@@ -102,7 +121,7 @@ impl Unwinder {\n         self.cause = unsafe { try(f) }.err();\n     }\n \n-    pub fn result(&mut self) -> TaskResult {\n+    pub fn result(&mut self) -> Result {\n         if self.unwinding {\n             Err(self.cause.take().unwrap())\n         } else {\n@@ -131,10 +150,7 @@ impl Unwinder {\n ///   guaranteed that a rust task is in place when invoking this function.\n ///   Unwinding twice can lead to resource leaks where some destructors are not\n ///   run.\n-pub unsafe fn try(f: ||) -> Result<(), Box<Any:Send>> {\n-    use raw::Closure;\n-    use libc::{c_void};\n-\n+pub unsafe fn try(f: ||) -> ::core::result::Result<(), Box<Any:Send>> {\n     let closure: Closure = mem::transmute(f);\n     let ep = rust_try(try_fn, closure.code as *c_void,\n                       closure.env as *c_void);\n@@ -158,6 +174,7 @@ pub unsafe fn try(f: ||) -> Result<(), Box<Any:Send>> {\n         }\n     }\n \n+    #[link(name = \"rustrt_native\", kind = \"static\")]\n     extern {\n         // Rust's try-catch\n         // When f(...) returns normally, the return value is null.\n@@ -227,7 +244,7 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n #[doc(hidden)]\n #[allow(visible_private_types)]\n pub mod eabi {\n-    use uw = rt::libunwind;\n+    use uw = libunwind;\n     use libc::c_int;\n \n     extern \"C\" {\n@@ -280,7 +297,7 @@ pub mod eabi {\n #[cfg(target_arch = \"arm\", not(test))]\n #[allow(visible_private_types)]\n pub mod eabi {\n-    use uw = rt::libunwind;\n+    use uw = libunwind;\n     use libc::c_int;\n \n     extern \"C\" {\n@@ -338,11 +355,26 @@ pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n #[inline(never)] #[cold]\n pub fn begin_unwind_fmt(msg: &fmt::Arguments, file: &'static str,\n                         line: uint) -> ! {\n+    use core::fmt::FormatWriter;\n+\n     // We do two allocations here, unfortunately. But (a) they're\n     // required with the current scheme, and (b) we don't handle\n     // failure + OOM properly anyway (see comment in begin_unwind\n     // below).\n-    begin_unwind_inner(box fmt::format(msg), file, line)\n+\n+    struct VecWriter<'a> { v: &'a mut Vec<u8> }\n+\n+    impl<'a> fmt::FormatWriter for VecWriter<'a> {\n+        fn write(&mut self, buf: &[u8]) -> fmt::Result {\n+            self.v.push_all(buf);\n+            Ok(())\n+        }\n+    }\n+\n+    let mut v = Vec::new();\n+    let _ = write!(&mut VecWriter { v: &mut v }, \"{}\", msg);\n+\n+    begin_unwind_inner(box String::from_utf8(v).unwrap(), file, line)\n }\n \n /// This is the entry point of unwinding for fail!() and assert!().\n@@ -373,122 +405,78 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> !\n fn begin_unwind_inner(msg: Box<Any:Send>,\n                       file: &'static str,\n                       line: uint) -> ! {\n-    // First up, print the message that we're failing\n-    print_failure(msg, file, line);\n-\n-    let opt_task: Option<Box<Task>> = Local::try_take();\n-    match opt_task {\n-        Some(mut task) => {\n-            // Now that we've printed why we're failing, do a check\n-            // to make sure that we're not double failing.\n-            //\n-            // If a task fails while it's already unwinding then we\n-            // have limited options. Currently our preference is to\n-            // just abort. In the future we may consider resuming\n-            // unwinding or otherwise exiting the task cleanly.\n-            if task.unwinder.unwinding {\n-                rterrln!(\"task failed during unwinding. aborting.\");\n-\n-                // Don't print the backtrace twice (it would have already been\n-                // printed if logging was enabled).\n-                if !backtrace::log_enabled() {\n-                    let mut err = ::rt::util::Stderr;\n-                    let _err = backtrace::write(&mut err);\n-                }\n-                unsafe { intrinsics::abort() }\n+    // First, invoke call the user-defined callbacks triggered on task failure.\n+    //\n+    // By the time that we see a callback has been registered (by reading\n+    // MAX_CALLBACKS), the actuall callback itself may have not been stored yet,\n+    // so we just chalk it up to a race condition and move on to the next\n+    // callback. Additionally, CALLBACK_CNT may briefly be higher than\n+    // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n+    let callbacks = unsafe {\n+        let amt = CALLBACK_CNT.load(atomics::SeqCst);\n+        CALLBACKS.slice_to(cmp::min(amt, MAX_CALLBACKS))\n+    };\n+    for cb in callbacks.iter() {\n+        match cb.load(atomics::SeqCst) {\n+            0 => {}\n+            n => {\n+                let f: Callback = unsafe { mem::transmute(n) };\n+                f(msg, file, line);\n             }\n-\n-            // Finally, we've printed our failure and figured out we're not in a\n-            // double failure, so flag that we've started to unwind and then\n-            // actually unwind.  Be sure that the task is in TLS so destructors\n-            // can do fun things like I/O.\n-            task.unwinder.unwinding = true;\n-            Local::put(task);\n         }\n-        None => {}\n+    };\n+\n+    // Now that we've run all the necessary unwind callbacks, we actually\n+    // perform the unwinding. If we don't have a task, then it's time to die\n+    // (hopefully someone printed something about this).\n+    let mut task: Box<Task> = match Local::try_take() {\n+        Some(task) => task,\n+        None => rust_fail(msg),\n+    };\n+\n+    if task.unwinder.unwinding {\n+        // If a task fails while it's already unwinding then we\n+        // have limited options. Currently our preference is to\n+        // just abort. In the future we may consider resuming\n+        // unwinding or otherwise exiting the task cleanly.\n+        rterrln!(\"task failed during unwinding. aborting.\");\n+        unsafe { intrinsics::abort() }\n     }\n-    rust_fail(msg)\n+    task.unwinder.unwinding = true;\n+\n+    // Put the task back in TLS because the unwinding process may run code which\n+    // requires the task. We need a handle to its unwinder, however, so after\n+    // this we unsafely extract it and continue along.\n+    Local::put(task);\n+    rust_fail(msg);\n }\n \n-/// Given a failure message and the location that it occurred, prints the\n-/// message to the local task's appropriate stream.\n+/// Register a callback to be invoked when a task unwinds.\n ///\n-/// This function currently handles three cases:\n+/// This is an unsafe and experimental API which allows for an arbitrary\n+/// callback to be invoked when a task fails. This callback is invoked on both\n+/// the initial unwinding and a double unwinding if one occurs. Additionally,\n+/// the local `Task` will be in place for the duration of the callback, and\n+/// the callback must ensure that it remains in place once the callback returns.\n ///\n-///     - There is no local task available. In this case the error is printed to\n-///       stderr.\n-///     - There is a local task available, but it does not have a stderr handle.\n-///       In this case the message is also printed to stderr.\n-///     - There is a local task available, and it has a stderr handle. The\n-///       message is printed to the handle given in this case.\n-fn print_failure(msg: &Any:Send, file: &str, line: uint) {\n-    let msg = match msg.as_ref::<&'static str>() {\n-        Some(s) => *s,\n-        None => match msg.as_ref::<String>() {\n-            Some(s) => s.as_slice(),\n-            None => \"Box<Any>\",\n+/// Only a limited number of callbacks can be registered, and this function\n+/// returns whether the callback was successfully registered or not. It is not\n+/// currently possible to unregister a callback once it has been registered.\n+#[experimental]\n+pub unsafe fn register(f: Callback) -> bool {\n+    match CALLBACK_CNT.fetch_add(1, atomics::SeqCst) {\n+        // The invocation code has knowledge of this window where the count has\n+        // been incremented, but the callback has not been stored. We're\n+        // guaranteed that the slot we're storing into is 0.\n+        n if n < MAX_CALLBACKS => {\n+            let prev = CALLBACKS[n].swap(mem::transmute(f), atomics::SeqCst);\n+            rtassert!(prev == 0);\n+            true\n         }\n-    };\n-\n-    // It is assumed that all reasonable rust code will have a local task at\n-    // all times. This means that this `try_take` will succeed almost all of\n-    // the time. There are border cases, however, when the runtime has\n-    // *almost* set up the local task, but hasn't quite gotten there yet. In\n-    // order to get some better diagnostics, we print on failure and\n-    // immediately abort the whole process if there is no local task\n-    // available.\n-    let mut task: Box<Task> = match Local::try_take() {\n-        Some(t) => t,\n-        None => {\n-            rterrln!(\"failed at '{}', {}:{}\", msg, file, line);\n-            if backtrace::log_enabled() {\n-                let mut err = ::rt::util::Stderr;\n-                let _err = backtrace::write(&mut err);\n-            } else {\n-                rterrln!(\"run with `RUST_BACKTRACE=1` to see a backtrace\");\n-            }\n-            return\n-        }\n-    };\n-\n-    // See comments in io::stdio::with_task_stdout as to why we have to be\n-    // careful when using an arbitrary I/O handle from the task. We\n-    // essentially need to dance to make sure when a task is in TLS when\n-    // running user code.\n-    let name = task.name.take();\n-    {\n-        let n = name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n-\n-        match task.stderr.take() {\n-            Some(mut stderr) => {\n-                Local::put(task);\n-                // FIXME: what to do when the task printing fails?\n-                let _err = write!(stderr,\n-                                  \"task '{}' failed at '{}', {}:{}\\n\",\n-                                  n, msg, file, line);\n-                if backtrace::log_enabled() {\n-                    let _err = backtrace::write(stderr);\n-                }\n-                task = Local::take();\n-\n-                match mem::replace(&mut task.stderr, Some(stderr)) {\n-                    Some(prev) => {\n-                        Local::put(task);\n-                        drop(prev);\n-                        task = Local::take();\n-                    }\n-                    None => {}\n-                }\n-            }\n-            None => {\n-                rterrln!(\"task '{}' failed at '{}', {}:{}\", n, msg, file, line);\n-                if backtrace::log_enabled() {\n-                    let mut err = ::rt::util::Stderr;\n-                    let _err = backtrace::write(&mut err);\n-                }\n-            }\n+        // If we accidentally bumped the count too high, pull it back.\n+        _ => {\n+            CALLBACK_CNT.store(MAX_CALLBACKS, atomics::SeqCst);\n+            false\n         }\n     }\n-    task.name = name;\n-    Local::put(task);\n }", "previous_filename": "src/libstd/rt/unwind.rs"}, {"sha": "c08652cc08c792feb14864b46660875ec289adc7", "filename": "src/librustrt/util.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use core::cmp;\n+use core::fmt;\n+use core::intrinsics;\n+use core::slice;\n+use core::str;\n+use libc;\n+\n+// Indicates whether we should perform expensive sanity checks, including rtassert!\n+//\n+// FIXME: Once the runtime matures remove the `true` below to turn off rtassert,\n+//        etc.\n+pub static ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) ||\n+                                  cfg!(rtassert);\n+\n+pub struct Stdio(libc::c_int);\n+\n+pub static Stdout: Stdio = Stdio(libc::STDOUT_FILENO);\n+pub static Stderr: Stdio = Stdio(libc::STDERR_FILENO);\n+\n+impl fmt::FormatWriter for Stdio {\n+    fn write(&mut self, data: &[u8]) -> fmt::Result {\n+        #[cfg(unix)]\n+        type WriteLen = libc::size_t;\n+        #[cfg(windows)]\n+        type WriteLen = libc::c_uint;\n+        unsafe {\n+            let Stdio(fd) = *self;\n+            libc::write(fd,\n+                        data.as_ptr() as *libc::c_void,\n+                        data.len() as WriteLen);\n+        }\n+        Ok(()) // yes, we're lying\n+    }\n+}\n+\n+pub fn dumb_print(args: &fmt::Arguments) {\n+    use core::fmt::FormatWriter;\n+    let mut w = Stderr;\n+    let _ = w.write_fmt(args);\n+}\n+\n+pub fn abort(args: &fmt::Arguments) -> ! {\n+    use core::fmt::FormatWriter;\n+\n+    struct BufWriter<'a> {\n+        buf: &'a mut [u8],\n+        pos: uint,\n+    }\n+    impl<'a> FormatWriter for BufWriter<'a> {\n+        fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n+            let left = self.buf.mut_slice_from(self.pos);\n+            let to_write = bytes.slice_to(cmp::min(bytes.len(), left.len()));\n+            slice::bytes::copy_memory(left, to_write);\n+            self.pos += to_write.len();\n+            Ok(())\n+        }\n+    }\n+\n+    // Convert the arguments into a stack-allocated string\n+    let mut msg = [0u8, ..512];\n+    let mut w = BufWriter { buf: msg, pos: 0 };\n+    let _ = write!(&mut w, \"{}\", args);\n+    let msg = str::from_utf8(w.buf.slice_to(w.pos)).unwrap_or(\"aborted\");\n+    let msg = if msg.is_empty() {\"aborted\"} else {msg};\n+\n+    // Give some context to the message\n+    let hash = msg.bytes().fold(0, |accum, val| accum + (val as uint) );\n+    let quote = match hash % 10 {\n+        0 => \"\n+It was from the artists and poets that the pertinent answers came, and I\n+know that panic would have broken loose had they been able to compare notes.\n+As it was, lacking their original letters, I half suspected the compiler of\n+having asked leading questions, or of having edited the correspondence in\n+corroboration of what he had latently resolved to see.\",\n+        1 => \"\n+There are not many persons who know what wonders are opened to them in the\n+stories and visions of their youth; for when as children we listen and dream,\n+we think but half-formed thoughts, and when as men we try to remember, we are\n+dulled and prosaic with the poison of life. But some of us awake in the night\n+with strange phantasms of enchanted hills and gardens, of fountains that sing\n+in the sun, of golden cliffs overhanging murmuring seas, of plains that stretch\n+down to sleeping cities of bronze and stone, and of shadowy companies of heroes\n+that ride caparisoned white horses along the edges of thick forests; and then\n+we know that we have looked back through the ivory gates into that world of\n+wonder which was ours before we were wise and unhappy.\",\n+        2 => \"\n+Instead of the poems I had hoped for, there came only a shuddering blackness\n+and ineffable loneliness; and I saw at last a fearful truth which no one had\n+ever dared to breathe before \u2014 the unwhisperable secret of secrets \u2014 The fact\n+that this city of stone and stridor is not a sentient perpetuation of Old New\n+York as London is of Old London and Paris of Old Paris, but that it is in fact\n+quite dead, its sprawling body imperfectly embalmed and infested with queer\n+animate things which have nothing to do with it as it was in life.\",\n+        3 => \"\n+The ocean ate the last of the land and poured into the smoking gulf, thereby\n+giving up all it had ever conquered. From the new-flooded lands it flowed\n+again, uncovering death and decay; and from its ancient and immemorial bed it\n+trickled loathsomely, uncovering nighted secrets of the years when Time was\n+young and the gods unborn. Above the waves rose weedy remembered spires. The\n+moon laid pale lilies of light on dead London, and Paris stood up from its damp\n+grave to be sanctified with star-dust. Then rose spires and monoliths that were\n+weedy but not remembered; terrible spires and monoliths of lands that men never\n+knew were lands...\",\n+        4 => \"\n+There was a night when winds from unknown spaces whirled us irresistibly into\n+limitless vacuum beyond all thought and entity. Perceptions of the most\n+maddeningly untransmissible sort thronged upon us; perceptions of infinity\n+which at the time convulsed us with joy, yet which are now partly lost to my\n+memory and partly incapable of presentation to others.\",\n+        _ => \"You've met with a terrible fate, haven't you?\"\n+    };\n+    rterrln!(\"{}\", \"\");\n+    rterrln!(\"{}\", quote);\n+    rterrln!(\"{}\", \"\");\n+    rterrln!(\"fatal runtime error: {}\", msg);\n+    unsafe { intrinsics::abort(); }\n+}"}, {"sha": "daca3005f12ffcd099463bc3211988121dba6d44", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 12, "deletions": 56, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ai = std::io::net::addrinfo;\n use libc::c_int;\n use libc;\n use std::mem;\n use std::ptr::null;\n use std::rt::task::BlockedTask;\n+use std::rt::rtio;\n \n use net;\n use super::{Loop, UvError, Request, wait_until_woken_after, wakeup};\n@@ -33,7 +33,9 @@ pub struct GetAddrInfoRequest;\n \n impl GetAddrInfoRequest {\n     pub fn run(loop_: &Loop, node: Option<&str>, service: Option<&str>,\n-               hints: Option<ai::Hint>) -> Result<Vec<ai::Info>, UvError> {\n+               hints: Option<rtio::AddrinfoHint>)\n+        -> Result<Vec<rtio::AddrinfoInfo>, UvError>\n+    {\n         assert!(node.is_some() || service.is_some());\n         let (_c_node, c_node_ptr) = match node {\n             Some(n) => {\n@@ -54,20 +56,11 @@ impl GetAddrInfoRequest {\n         };\n \n         let hint = hints.map(|hint| {\n-            let mut flags = 0;\n-            each_ai_flag(|cval, aival| {\n-                if hint.flags & (aival as uint) != 0 {\n-                    flags |= cval as i32;\n-                }\n-            });\n-            let socktype = 0;\n-            let protocol = 0;\n-\n             libc::addrinfo {\n-                ai_flags: flags,\n+                ai_flags: 0,\n                 ai_family: hint.family as c_int,\n-                ai_socktype: socktype,\n-                ai_protocol: protocol,\n+                ai_socktype: 0,\n+                ai_protocol: 0,\n                 ai_addrlen: 0,\n                 ai_canonname: null(),\n                 ai_addr: null(),\n@@ -119,22 +112,8 @@ impl Drop for Addrinfo {\n     }\n }\n \n-fn each_ai_flag(_f: |c_int, ai::Flag|) {\n-    /* FIXME: do we really want to support these?\n-    unsafe {\n-        f(uvll::rust_AI_ADDRCONFIG(), ai::AddrConfig);\n-        f(uvll::rust_AI_ALL(), ai::All);\n-        f(uvll::rust_AI_CANONNAME(), ai::CanonName);\n-        f(uvll::rust_AI_NUMERICHOST(), ai::NumericHost);\n-        f(uvll::rust_AI_NUMERICSERV(), ai::NumericServ);\n-        f(uvll::rust_AI_PASSIVE(), ai::Passive);\n-        f(uvll::rust_AI_V4MAPPED(), ai::V4Mapped);\n-    }\n-    */\n-}\n-\n // Traverse the addrinfo linked list, producing a vector of Rust socket addresses\n-pub fn accum_addrinfo(addr: &Addrinfo) -> Vec<ai::Info> {\n+pub fn accum_addrinfo(addr: &Addrinfo) -> Vec<rtio::AddrinfoInfo> {\n     unsafe {\n         let mut addr = addr.handle;\n \n@@ -143,35 +122,12 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> Vec<ai::Info> {\n             let rustaddr = net::sockaddr_to_addr(mem::transmute((*addr).ai_addr),\n                                                  (*addr).ai_addrlen as uint);\n \n-            let mut flags = 0;\n-            each_ai_flag(|cval, aival| {\n-                if (*addr).ai_flags & cval != 0 {\n-                    flags |= aival as uint;\n-                }\n-            });\n-\n-            /* FIXME: do we really want to support these\n-            let protocol = match (*addr).ai_protocol {\n-                p if p == uvll::rust_IPPROTO_UDP() => Some(ai::UDP),\n-                p if p == uvll::rust_IPPROTO_TCP() => Some(ai::TCP),\n-                _ => None,\n-            };\n-            let socktype = match (*addr).ai_socktype {\n-                p if p == uvll::rust_SOCK_STREAM() => Some(ai::Stream),\n-                p if p == uvll::rust_SOCK_DGRAM() => Some(ai::Datagram),\n-                p if p == uvll::rust_SOCK_RAW() => Some(ai::Raw),\n-                _ => None,\n-            };\n-            */\n-            let protocol = None;\n-            let socktype = None;\n-\n-            addrs.push(ai::Info {\n+            addrs.push(rtio::AddrinfoInfo {\n                 address: rustaddr,\n                 family: (*addr).ai_family as uint,\n-                socktype: socktype,\n-                protocol: protocol,\n-                flags: flags,\n+                socktype: 0,\n+                protocol: 0,\n+                flags: 0,\n             });\n             if (*addr).ai_next.is_not_null() {\n                 addr = (*addr).ai_next;"}, {"sha": "5167ce5aff2d98430b9646f2f96c6ee2d9c5d333", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use alloc::arc::Arc;\n use std::mem;\n+use std::rt::exclusive::Exclusive;\n use std::rt::rtio::{Callback, RemoteCallback};\n-use std::unstable::sync::Exclusive;\n \n use uvll;\n use super::{Loop, UvHandle};\n@@ -22,12 +23,12 @@ pub struct AsyncWatcher {\n \n     // A flag to tell the callback to exit, set from the dtor. This is\n     // almost never contested - only in rare races with the dtor.\n-    exit_flag: Exclusive<bool>\n+    exit_flag: Arc<Exclusive<bool>>,\n }\n \n struct Payload {\n     callback: Box<Callback:Send>,\n-    exit_flag: Exclusive<bool>,\n+    exit_flag: Arc<Exclusive<bool>>,\n }\n \n impl AsyncWatcher {\n@@ -36,7 +37,7 @@ impl AsyncWatcher {\n         assert_eq!(unsafe {\n             uvll::uv_async_init(loop_.handle, handle, async_cb)\n         }, 0);\n-        let flag = Exclusive::new(false);\n+        let flag = Arc::new(Exclusive::new(false));\n         let payload = box Payload { callback: cb, exit_flag: flag.clone() };\n         unsafe {\n             let payload: *u8 = mem::transmute(payload);\n@@ -80,9 +81,7 @@ extern fn async_cb(handle: *uvll::uv_async_t) {\n     // could be called in the other thread, missing the final\n     // callback while still destroying the handle.\n \n-    let should_exit = unsafe {\n-        payload.exit_flag.with_imm(|&should_exit| should_exit)\n-    };\n+    let should_exit = unsafe { *payload.exit_flag.lock() };\n \n     payload.callback.call();\n \n@@ -108,16 +107,13 @@ impl RemoteCallback for AsyncWatcher {\n \n impl Drop for AsyncWatcher {\n     fn drop(&mut self) {\n-        unsafe {\n-            self.exit_flag.with(|should_exit| {\n-                // NB: These two things need to happen atomically. Otherwise\n-                // the event handler could wake up due to a *previous*\n-                // signal and see the exit flag, destroying the handle\n-                // before the final send.\n-                *should_exit = true;\n-                uvll::uv_async_send(self.handle)\n-            })\n-        }\n+        let mut should_exit = unsafe { self.exit_flag.lock() };\n+        // NB: These two things need to happen atomically. Otherwise\n+        // the event handler could wake up due to a *previous*\n+        // signal and see the exit flag, destroying the handle\n+        // before the final send.\n+        *should_exit = true;\n+        unsafe { uvll::uv_async_send(self.handle) }\n     }\n }\n "}, {"sha": "4b1343045de376219398b7137b5dc6aa689ca338", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 54, "deletions": 68, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -12,9 +12,9 @@ use libc::{c_int, c_char, c_void, ssize_t};\n use libc;\n use std::c_str::CString;\n use std::c_str;\n-use std::io::{FileStat, IoError};\n-use std::io;\n use std::mem;\n+use std::os;\n+use std::rt::rtio::{IoResult, IoError};\n use std::rt::rtio;\n use std::rt::task::BlockedTask;\n \n@@ -56,21 +56,23 @@ impl FsRequest {\n         })\n     }\n \n-    pub fn lstat(loop_: &Loop, path: &CString) -> Result<FileStat, UvError> {\n+    pub fn lstat(loop_: &Loop, path: &CString)\n+        -> Result<rtio::FileStat, UvError>\n+    {\n         execute(|req, cb| unsafe {\n             uvll::uv_fs_lstat(loop_.handle, req, path.with_ref(|p| p),\n                               cb)\n         }).map(|req| req.mkstat())\n     }\n \n-    pub fn stat(loop_: &Loop, path: &CString) -> Result<FileStat, UvError> {\n+    pub fn stat(loop_: &Loop, path: &CString) -> Result<rtio::FileStat, UvError> {\n         execute(|req, cb| unsafe {\n             uvll::uv_fs_stat(loop_.handle, req, path.with_ref(|p| p),\n                              cb)\n         }).map(|req| req.mkstat())\n     }\n \n-    pub fn fstat(loop_: &Loop, fd: c_int) -> Result<FileStat, UvError> {\n+    pub fn fstat(loop_: &Loop, fd: c_int) -> Result<rtio::FileStat, UvError> {\n         execute(|req, cb| unsafe {\n             uvll::uv_fs_fstat(loop_.handle, req, fd, cb)\n         }).map(|req| req.mkstat())\n@@ -157,7 +159,7 @@ impl FsRequest {\n     }\n \n     pub fn readdir(loop_: &Loop, path: &CString, flags: c_int)\n-        -> Result<Vec<Path>, UvError>\n+        -> Result<Vec<CString>, UvError>\n     {\n         execute(|req, cb| unsafe {\n             uvll::uv_fs_readdir(loop_.handle,\n@@ -170,20 +172,22 @@ impl FsRequest {\n                                               Some(req.get_result() as uint),\n                                               |rel| {\n                 let p = rel.as_bytes();\n-                paths.push(parent.join(p.slice_to(rel.len())));\n+                paths.push(parent.join(p.slice_to(rel.len())).to_c_str());\n             });\n             paths\n         })\n     }\n \n-    pub fn readlink(loop_: &Loop, path: &CString) -> Result<Path, UvError> {\n+    pub fn readlink(loop_: &Loop, path: &CString) -> Result<CString, UvError> {\n         execute(|req, cb| unsafe {\n             uvll::uv_fs_readlink(loop_.handle, req,\n                                  path.with_ref(|p| p), cb)\n         }).map(|req| {\n-            Path::new(unsafe {\n-                CString::new(req.get_ptr() as *libc::c_char, false)\n-            })\n+            // Be sure to clone the cstring so we get an independently owned\n+            // allocation to work with and return.\n+            unsafe {\n+                CString::new(req.get_ptr() as *libc::c_char, false).clone()\n+            }\n         })\n     }\n \n@@ -267,40 +271,30 @@ impl FsRequest {\n         unsafe { uvll::get_ptr_from_fs_req(self.req) }\n     }\n \n-    pub fn mkstat(&self) -> FileStat {\n+    pub fn mkstat(&self) -> rtio::FileStat {\n         let stat = self.get_stat();\n         fn to_msec(stat: uvll::uv_timespec_t) -> u64 {\n             // Be sure to cast to u64 first to prevent overflowing if the tv_sec\n             // field is a 32-bit integer.\n             (stat.tv_sec as u64) * 1000 + (stat.tv_nsec as u64) / 1000000\n         }\n-        let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n-            libc::S_IFREG => io::TypeFile,\n-            libc::S_IFDIR => io::TypeDirectory,\n-            libc::S_IFIFO => io::TypeNamedPipe,\n-            libc::S_IFBLK => io::TypeBlockSpecial,\n-            libc::S_IFLNK => io::TypeSymlink,\n-            _ => io::TypeUnknown,\n-        };\n-        FileStat {\n+        rtio::FileStat {\n             size: stat.st_size as u64,\n-            kind: kind,\n-            perm: io::FilePermission::from_bits_truncate(stat.st_mode as u32),\n+            kind: stat.st_mode as u64,\n+            perm: stat.st_mode as u64,\n             created: to_msec(stat.st_birthtim),\n             modified: to_msec(stat.st_mtim),\n             accessed: to_msec(stat.st_atim),\n-            unstable: io::UnstableFileStat {\n-                device: stat.st_dev as u64,\n-                inode: stat.st_ino as u64,\n-                rdev: stat.st_rdev as u64,\n-                nlink: stat.st_nlink as u64,\n-                uid: stat.st_uid as u64,\n-                gid: stat.st_gid as u64,\n-                blksize: stat.st_blksize as u64,\n-                blocks: stat.st_blocks as u64,\n-                flags: stat.st_flags as u64,\n-                gen: stat.st_gen as u64,\n-            }\n+            device: stat.st_dev as u64,\n+            inode: stat.st_ino as u64,\n+            rdev: stat.st_rdev as u64,\n+            nlink: stat.st_nlink as u64,\n+            uid: stat.st_uid as u64,\n+            gid: stat.st_gid as u64,\n+            blksize: stat.st_blksize as u64,\n+            blocks: stat.st_blocks as u64,\n+            flags: stat.st_flags as u64,\n+            gen: stat.st_gen as u64,\n         }\n     }\n }\n@@ -367,29 +361,26 @@ impl FileWatcher {\n         }\n     }\n \n-    fn base_read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError> {\n+    fn base_read(&mut self, buf: &mut [u8], offset: i64) -> IoResult<int> {\n         let _m = self.fire_homing_missile();\n         let r = FsRequest::read(&self.loop_, self.fd, buf, offset);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn base_write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n+    fn base_write(&mut self, buf: &[u8], offset: i64) -> IoResult<()> {\n         let _m = self.fire_homing_missile();\n         let r = FsRequest::write(&self.loop_, self.fd, buf, offset);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn seek_common(&self, pos: i64, whence: c_int) ->\n-        Result<u64, IoError>{\n-        unsafe {\n-            match libc::lseek(self.fd, pos as libc::off_t, whence) {\n-                -1 => {\n-                    Err(IoError {\n-                        kind: io::OtherIoError,\n-                        desc: \"Failed to lseek.\",\n-                        detail: None\n-                    })\n-                },\n-                n => Ok(n as u64)\n-            }\n+    fn seek_common(&self, pos: i64, whence: c_int) -> IoResult<u64>{\n+        match unsafe { libc::lseek(self.fd, pos as libc::off_t, whence) } {\n+            -1 => {\n+                Err(IoError {\n+                    code: os::errno() as uint,\n+                    extra: 0,\n+                    detail: None,\n+                })\n+            },\n+            n => Ok(n as u64)\n         }\n     }\n }\n@@ -423,47 +414,47 @@ impl Drop for FileWatcher {\n }\n \n impl rtio::RtioFileStream for FileWatcher {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> {\n         self.base_read(buf, -1)\n     }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.base_write(buf, -1)\n     }\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n         self.base_read(buf, offset as i64)\n     }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()> {\n         self.base_write(buf, offset as i64)\n     }\n-    fn seek(&mut self, pos: i64, whence: io::SeekStyle) -> Result<u64, IoError> {\n+    fn seek(&mut self, pos: i64, whence: rtio::SeekStyle) -> IoResult<u64> {\n         use libc::{SEEK_SET, SEEK_CUR, SEEK_END};\n         let whence = match whence {\n-            io::SeekSet => SEEK_SET,\n-            io::SeekCur => SEEK_CUR,\n-            io::SeekEnd => SEEK_END\n+            rtio::SeekSet => SEEK_SET,\n+            rtio::SeekCur => SEEK_CUR,\n+            rtio::SeekEnd => SEEK_END\n         };\n         self.seek_common(pos, whence)\n     }\n-    fn tell(&self) -> Result<u64, IoError> {\n+    fn tell(&self) -> IoResult<u64> {\n         use libc::SEEK_CUR;\n \n         self.seek_common(0, SEEK_CUR)\n     }\n-    fn fsync(&mut self) -> Result<(), IoError> {\n+    fn fsync(&mut self) -> IoResult<()> {\n         let _m = self.fire_homing_missile();\n         FsRequest::fsync(&self.loop_, self.fd).map_err(uv_error_to_io_error)\n     }\n-    fn datasync(&mut self) -> Result<(), IoError> {\n+    fn datasync(&mut self) -> IoResult<()> {\n         let _m = self.fire_homing_missile();\n         FsRequest::datasync(&self.loop_, self.fd).map_err(uv_error_to_io_error)\n     }\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+    fn truncate(&mut self, offset: i64) -> IoResult<()> {\n         let _m = self.fire_homing_missile();\n         let r = FsRequest::truncate(&self.loop_, self.fd, offset);\n         r.map_err(uv_error_to_io_error)\n     }\n \n-    fn fstat(&mut self) -> Result<FileStat, IoError> {\n+    fn fstat(&mut self) -> IoResult<rtio::FileStat> {\n         let _m = self.fire_homing_missile();\n         FsRequest::fstat(&self.loop_, self.fd).map_err(uv_error_to_io_error)\n     }\n@@ -473,7 +464,6 @@ impl rtio::RtioFileStream for FileWatcher {\n mod test {\n     use libc::c_int;\n     use libc::{O_CREAT, O_RDWR, O_RDONLY, S_IWUSR, S_IRUSR};\n-    use std::io;\n     use std::str;\n     use super::FsRequest;\n     use super::super::Loop;\n@@ -560,10 +550,6 @@ mod test {\n         let result = FsRequest::mkdir(l(), path, mode);\n         assert!(result.is_ok());\n \n-        let result = FsRequest::stat(l(), path);\n-        assert!(result.is_ok());\n-        assert!(result.unwrap().kind == io::TypeDirectory);\n-\n         let result = FsRequest::rmdir(l(), path);\n         assert!(result.is_ok());\n "}, {"sha": "644ac4e45f6569e62ee82b890fd0f23d3898e5a0", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -153,8 +153,7 @@ mod test {\n     use green::sched;\n     use green::{SchedPool, PoolConfig};\n     use std::rt::rtio::RtioUdpSocket;\n-    use std::io::test::next_test_ip4;\n-    use std::task::TaskOpts;\n+    use std::rt::task::TaskOpts;\n \n     use net::UdpWatcher;\n     use super::super::local_loop;\n@@ -172,7 +171,7 @@ mod test {\n         });\n \n         pool.spawn(TaskOpts::new(), proc() {\n-            let listener = UdpWatcher::bind(local_loop(), next_test_ip4());\n+            let listener = UdpWatcher::bind(local_loop(), ::next_test_ip4());\n             tx.send(listener.unwrap());\n         });\n \n@@ -193,18 +192,18 @@ mod test {\n         });\n \n         pool.spawn(TaskOpts::new(), proc() {\n-            let addr1 = next_test_ip4();\n-            let addr2 = next_test_ip4();\n+            let addr1 = ::next_test_ip4();\n+            let addr2 = ::next_test_ip4();\n             let listener = UdpWatcher::bind(local_loop(), addr2);\n             tx.send((listener.unwrap(), addr1));\n             let mut listener = UdpWatcher::bind(local_loop(), addr1).unwrap();\n-            listener.sendto([1, 2, 3, 4], addr2).unwrap();\n+            listener.sendto([1, 2, 3, 4], addr2).ok().unwrap();\n         });\n \n         let task = pool.task(TaskOpts::new(), proc() {\n             let (mut watcher, addr) = rx.recv();\n             let mut buf = [0, ..10];\n-            assert_eq!(watcher.recvfrom(buf).unwrap(), (4, addr));\n+            assert!(watcher.recvfrom(buf).ok().unwrap() == (4, addr));\n         });\n         pool.spawn_sched().send(sched::TaskFromFriend(task));\n "}, {"sha": "e2122aea0365ebeb2167df272a4ace6927df9aa8", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 58, "deletions": 33, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -51,16 +51,14 @@ extern crate alloc;\n \n use libc::{c_int, c_void};\n use std::fmt;\n-use std::io::IoError;\n-use std::io;\n use std::mem;\n use std::ptr::null;\n use std::ptr;\n use std::rt::local::Local;\n use std::rt::rtio;\n+use std::rt::rtio::{IoResult, IoError};\n use std::rt::task::{BlockedTask, Task};\n use std::str::raw::from_c_str;\n-use std::str;\n use std::task;\n \n pub use self::async::AsyncWatcher;\n@@ -391,40 +389,40 @@ fn error_smoke_test() {\n     assert_eq!(err.to_str(), \"EOF: end of file\".to_string());\n }\n \n+#[cfg(unix)]\n pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n-    unsafe {\n-        // Importing error constants\n-\n-        // uv error descriptions are static\n-        let UvError(errcode) = uverr;\n-        let c_desc = uvll::uv_strerror(errcode);\n-        let desc = str::raw::c_str_to_static_slice(c_desc);\n-\n-        let kind = match errcode {\n-            uvll::UNKNOWN => io::OtherIoError,\n-            uvll::OK => io::OtherIoError,\n-            uvll::EOF => io::EndOfFile,\n-            uvll::EACCES => io::PermissionDenied,\n-            uvll::ECONNREFUSED => io::ConnectionRefused,\n-            uvll::ECONNRESET => io::ConnectionReset,\n-            uvll::ENOTCONN => io::NotConnected,\n-            uvll::ENOENT => io::FileNotFound,\n-            uvll::EPIPE => io::BrokenPipe,\n-            uvll::ECONNABORTED => io::ConnectionAborted,\n-            uvll::EADDRNOTAVAIL => io::ConnectionRefused,\n-            uvll::ECANCELED => io::TimedOut,\n+    let UvError(errcode) = uverr;\n+    IoError {\n+        code: if errcode == uvll::EOF {libc::EOF as uint} else {-errcode as uint},\n+        extra: 0,\n+        detail: Some(uverr.desc()),\n+    }\n+}\n+\n+#[cfg(windows)]\n+pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n+    let UvError(errcode) = uverr;\n+    IoError {\n+        code: match errcode {\n+            uvll::EOF => libc::EOF,\n+            uvll::EACCES => libc::ERROR_ACCESS_DENIED,\n+            uvll::ECONNREFUSED => libc::WSAECONNREFUSED,\n+            uvll::ECONNRESET => libc::WSAECONNRESET,\n+            uvll::ENOTCONN => libc::WSAENOTCONN,\n+            uvll::ENOENT => libc::ERROR_FILE_NOT_FOUND,\n+            uvll::EPIPE => libc::ERROR_NO_DATA,\n+            uvll::ECONNABORTED => libc::WSAECONNABORTED,\n+            uvll::EADDRNOTAVAIL => libc::WSAEADDRNOTAVAIL,\n+            uvll::ECANCELED => libc::ERROR_OPERATION_ABORTED,\n+            uvll::EADDRINUSE => libc::WSAEADDRINUSE,\n             err => {\n                 uvdebug!(\"uverr.code {}\", err as int);\n                 // FIXME: Need to map remaining uv error types\n-                io::OtherIoError\n+                -1\n             }\n-        };\n-\n-        IoError {\n-            kind: kind,\n-            desc: desc,\n-            detail: None\n-        }\n+        } as uint,\n+        extra: 0,\n+        detail: Some(uverr.desc()),\n     }\n }\n \n@@ -437,7 +435,7 @@ pub fn status_to_maybe_uv_error(status: c_int) -> Option<UvError> {\n     }\n }\n \n-pub fn status_to_io_result(status: c_int) -> Result<(), IoError> {\n+pub fn status_to_io_result(status: c_int) -> IoResult<()> {\n     if status >= 0 {Ok(())} else {Err(uv_error_to_io_error(UvError(status)))}\n }\n \n@@ -471,6 +469,33 @@ fn local_loop() -> &'static mut uvio::UvIoFactory {\n     }\n }\n \n+#[cfg(test)]\n+fn next_test_ip4() -> std::rt::rtio::SocketAddr {\n+    use std::io;\n+    use std::rt::rtio;\n+\n+    let io::net::ip::SocketAddr { ip, port } = io::test::next_test_ip4();\n+    let ip = match ip {\n+        io::net::ip::Ipv4Addr(a, b, c, d) => rtio::Ipv4Addr(a, b, c, d),\n+        _ => unreachable!(),\n+    };\n+    rtio::SocketAddr { ip: ip, port: port }\n+}\n+\n+#[cfg(test)]\n+fn next_test_ip6() -> std::rt::rtio::SocketAddr {\n+    use std::io;\n+    use std::rt::rtio;\n+\n+    let io::net::ip::SocketAddr { ip, port } = io::test::next_test_ip6();\n+    let ip = match ip {\n+        io::net::ip::Ipv6Addr(a, b, c, d, e, f, g, h) =>\n+            rtio::Ipv6Addr(a, b, c, d, e, f, g, h),\n+        _ => unreachable!(),\n+    };\n+    rtio::SocketAddr { ip: ip, port: port }\n+}\n+\n #[cfg(test)]\n mod test {\n     use std::mem::transmute;"}, {"sha": "e7bdc25a1fd91d6bb07ea5021998f1ba52351ccd", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 74, "deletions": 77, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -10,12 +10,10 @@\n \n use libc::{size_t, ssize_t, c_int, c_void, c_uint};\n use libc;\n-use std::io;\n-use std::io::IoError;\n-use std::io::net::ip;\n use std::mem;\n use std::ptr;\n use std::rt::rtio;\n+use std::rt::rtio::IoError;\n use std::rt::task::BlockedTask;\n \n use homing::{HomingIO, HomeHandle};\n@@ -36,7 +34,7 @@ pub fn htons(u: u16) -> u16 { mem::to_be16(u) }\n pub fn ntohs(u: u16) -> u16 { mem::from_be16(u) }\n \n pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n-                        len: uint) -> ip::SocketAddr {\n+                        len: uint) -> rtio::SocketAddr {\n     match storage.ss_family as c_int {\n         libc::AF_INET => {\n             assert!(len as uint >= mem::size_of::<libc::sockaddr_in>());\n@@ -48,8 +46,8 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             let b = (ip >> 16) as u8;\n             let c = (ip >>  8) as u8;\n             let d = (ip >>  0) as u8;\n-            ip::SocketAddr {\n-                ip: ip::Ipv4Addr(a, b, c, d),\n+            rtio::SocketAddr {\n+                ip: rtio::Ipv4Addr(a, b, c, d),\n                 port: ntohs(storage.sin_port),\n             }\n         }\n@@ -66,8 +64,8 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             let f = ntohs(storage.sin6_addr.s6_addr[5]);\n             let g = ntohs(storage.sin6_addr.s6_addr[6]);\n             let h = ntohs(storage.sin6_addr.s6_addr[7]);\n-            ip::SocketAddr {\n-                ip: ip::Ipv6Addr(a, b, c, d, e, f, g, h),\n+            rtio::SocketAddr {\n+                ip: rtio::Ipv6Addr(a, b, c, d, e, f, g, h),\n                 port: ntohs(storage.sin6_port),\n             }\n         }\n@@ -77,11 +75,11 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n     }\n }\n \n-fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n+fn addr_to_sockaddr(addr: rtio::SocketAddr) -> (libc::sockaddr_storage, uint) {\n     unsafe {\n         let mut storage: libc::sockaddr_storage = mem::zeroed();\n         let len = match addr.ip {\n-            ip::Ipv4Addr(a, b, c, d) => {\n+            rtio::Ipv4Addr(a, b, c, d) => {\n                 let ip = (a as u32 << 24) |\n                          (b as u32 << 16) |\n                          (c as u32 <<  8) |\n@@ -95,7 +93,7 @@ fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n                 };\n                 mem::size_of::<libc::sockaddr_in>()\n             }\n-            ip::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+            rtio::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n                 let storage: &mut libc::sockaddr_in6 =\n                     mem::transmute(&mut storage);\n                 storage.sin6_family = libc::AF_INET6 as libc::sa_family_t;\n@@ -126,7 +124,7 @@ enum SocketNameKind {\n }\n \n fn socket_name(sk: SocketNameKind,\n-               handle: *c_void) -> Result<ip::SocketAddr, IoError> {\n+               handle: *c_void) -> Result<rtio::SocketAddr, IoError> {\n     let getsockname = match sk {\n         TcpPeer => uvll::uv_tcp_getpeername,\n         Tcp     => uvll::uv_tcp_getsockname,\n@@ -201,7 +199,7 @@ impl TcpWatcher {\n     }\n \n     pub fn connect(io: &mut UvIoFactory,\n-                   address: ip::SocketAddr,\n+                   address: rtio::SocketAddr,\n                    timeout: Option<u64>) -> Result<TcpWatcher, UvError> {\n         let tcp = TcpWatcher::new(io);\n         let cx = ConnectCtx { status: -1, task: None, timer: None };\n@@ -218,7 +216,7 @@ impl HomingIO for TcpWatcher {\n }\n \n impl rtio::RtioSocket for TcpWatcher {\n-    fn socket_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n+    fn socket_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n         socket_name(Tcp, self.handle)\n     }\n@@ -231,7 +229,7 @@ impl rtio::RtioTcpStream for TcpWatcher {\n \n         // see comments in close_read about this check\n         if guard.access.is_closed() {\n-            return Err(io::standard_error(io::EndOfFile))\n+            return Err(uv_error_to_io_error(UvError(uvll::EOF)))\n         }\n \n         self.stream.read(buf).map_err(uv_error_to_io_error)\n@@ -243,7 +241,7 @@ impl rtio::RtioTcpStream for TcpWatcher {\n         self.stream.write(buf, guard.can_timeout).map_err(uv_error_to_io_error)\n     }\n \n-    fn peer_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n+    fn peer_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n         socket_name(TcpPeer, self.handle)\n     }\n@@ -350,7 +348,7 @@ impl Drop for TcpWatcher {\n // TCP listeners (unbound servers)\n \n impl TcpListener {\n-    pub fn bind(io: &mut UvIoFactory, address: ip::SocketAddr)\n+    pub fn bind(io: &mut UvIoFactory, address: rtio::SocketAddr)\n                 -> Result<Box<TcpListener>, UvError> {\n         let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n         assert_eq!(unsafe {\n@@ -385,7 +383,7 @@ impl UvHandle<uvll::uv_tcp_t> for TcpListener {\n }\n \n impl rtio::RtioSocket for TcpListener {\n-    fn socket_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n+    fn socket_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n         socket_name(Tcp, self.handle)\n     }\n@@ -439,7 +437,7 @@ impl HomingIO for TcpAcceptor {\n }\n \n impl rtio::RtioSocket for TcpAcceptor {\n-    fn socket_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n+    fn socket_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n         socket_name(Tcp, self.listener.handle)\n     }\n@@ -492,7 +490,7 @@ pub struct UdpWatcher {\n struct UdpRecvCtx {\n     task: Option<BlockedTask>,\n     buf: Option<Buf>,\n-    result: Option<(ssize_t, Option<ip::SocketAddr>)>,\n+    result: Option<(ssize_t, Option<rtio::SocketAddr>)>,\n }\n \n struct UdpSendCtx {\n@@ -502,7 +500,7 @@ struct UdpSendCtx {\n }\n \n impl UdpWatcher {\n-    pub fn bind(io: &mut UvIoFactory, address: ip::SocketAddr)\n+    pub fn bind(io: &mut UvIoFactory, address: rtio::SocketAddr)\n                 -> Result<UdpWatcher, UvError> {\n         let udp = UdpWatcher {\n             handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n@@ -536,15 +534,15 @@ impl HomingIO for UdpWatcher {\n }\n \n impl rtio::RtioSocket for UdpWatcher {\n-    fn socket_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n+    fn socket_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n         socket_name(Udp, self.handle)\n     }\n }\n \n impl rtio::RtioUdpSocket for UdpWatcher {\n     fn recvfrom(&mut self, buf: &mut [u8])\n-        -> Result<(uint, ip::SocketAddr), IoError>\n+        -> Result<(uint, rtio::SocketAddr), IoError>\n     {\n         let loop_ = self.uv_loop();\n         let m = self.fire_homing_missile();\n@@ -609,7 +607,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         }\n     }\n \n-    fn sendto(&mut self, buf: &[u8], dst: ip::SocketAddr) -> Result<(), IoError> {\n+    fn sendto(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> Result<(), IoError> {\n         let m = self.fire_homing_missile();\n         let loop_ = self.uv_loop();\n         let guard = try!(self.write_access.grant(m));\n@@ -675,7 +673,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         }\n     }\n \n-    fn join_multicast(&mut self, multi: ip::IpAddr) -> Result<(), IoError> {\n+    fn join_multicast(&mut self, multi: rtio::IpAddr) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             multi.to_str().with_c_str(|m_addr| {\n@@ -686,7 +684,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         })\n     }\n \n-    fn leave_multicast(&mut self, multi: ip::IpAddr) -> Result<(), IoError> {\n+    fn leave_multicast(&mut self, multi: rtio::IpAddr) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             multi.to_str().with_c_str(|m_addr| {\n@@ -843,38 +841,37 @@ pub fn shutdown(handle: *uvll::uv_stream_t, loop_: &Loop) -> Result<(), IoError>\n mod test {\n     use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioTcpAcceptor,\n                         RtioUdpSocket};\n-    use std::io::test::{next_test_ip4, next_test_ip6};\n \n     use super::{UdpWatcher, TcpWatcher, TcpListener};\n     use super::super::local_loop;\n \n     #[test]\n     fn connect_close_ip4() {\n-        match TcpWatcher::connect(local_loop(), next_test_ip4(), None) {\n+        match TcpWatcher::connect(local_loop(), ::next_test_ip4(), None) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_string()),\n         }\n     }\n \n     #[test]\n     fn connect_close_ip6() {\n-        match TcpWatcher::connect(local_loop(), next_test_ip6(), None) {\n+        match TcpWatcher::connect(local_loop(), ::next_test_ip6(), None) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_string()),\n         }\n     }\n \n     #[test]\n     fn udp_bind_close_ip4() {\n-        match UdpWatcher::bind(local_loop(), next_test_ip4()) {\n+        match UdpWatcher::bind(local_loop(), ::next_test_ip4()) {\n             Ok(..) => {}\n             Err(..) => fail!()\n         }\n     }\n \n     #[test]\n     fn udp_bind_close_ip6() {\n-        match UdpWatcher::bind(local_loop(), next_test_ip6()) {\n+        match UdpWatcher::bind(local_loop(), ::next_test_ip6()) {\n             Ok(..) => {}\n             Err(..) => fail!()\n         }\n@@ -883,7 +880,7 @@ mod test {\n     #[test]\n     fn listen_ip4() {\n         let (tx, rx) = channel();\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n \n         spawn(proc() {\n             let w = match TcpListener::bind(local_loop(), addr) {\n@@ -919,7 +916,7 @@ mod test {\n     #[test]\n     fn listen_ip6() {\n         let (tx, rx) = channel();\n-        let addr = next_test_ip6();\n+        let addr = ::next_test_ip6();\n \n         spawn(proc() {\n             let w = match TcpListener::bind(local_loop(), addr) {\n@@ -955,16 +952,16 @@ mod test {\n     #[test]\n     fn udp_recv_ip4() {\n         let (tx, rx) = channel();\n-        let client = next_test_ip4();\n-        let server = next_test_ip4();\n+        let client = ::next_test_ip4();\n+        let server = ::next_test_ip4();\n \n         spawn(proc() {\n             match UdpWatcher::bind(local_loop(), server) {\n                 Ok(mut w) => {\n                     tx.send(());\n                     let mut buf = [0u8, ..10];\n                     match w.recvfrom(buf) {\n-                        Ok((10, addr)) => assert_eq!(addr, client),\n+                        Ok((10, addr)) => assert!(addr == client),\n                         e => fail!(\"{:?}\", e),\n                     }\n                     for i in range(0, 10u8) {\n@@ -987,16 +984,16 @@ mod test {\n     #[test]\n     fn udp_recv_ip6() {\n         let (tx, rx) = channel();\n-        let client = next_test_ip6();\n-        let server = next_test_ip6();\n+        let client = ::next_test_ip6();\n+        let server = ::next_test_ip6();\n \n         spawn(proc() {\n             match UdpWatcher::bind(local_loop(), server) {\n                 Ok(mut w) => {\n                     tx.send(());\n                     let mut buf = [0u8, ..10];\n                     match w.recvfrom(buf) {\n-                        Ok((10, addr)) => assert_eq!(addr, client),\n+                        Ok((10, addr)) => assert!(addr == client),\n                         e => fail!(\"{:?}\", e),\n                     }\n                     for i in range(0, 10u8) {\n@@ -1018,15 +1015,15 @@ mod test {\n \n     #[test]\n     fn test_read_read_read() {\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n         static MAX: uint = 5000;\n         let (tx, rx) = channel();\n \n         spawn(proc() {\n             let listener = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut acceptor = listener.listen().unwrap();\n+            let mut acceptor = listener.listen().ok().unwrap();\n             tx.send(());\n-            let mut stream = acceptor.accept().unwrap();\n+            let mut stream = acceptor.accept().ok().unwrap();\n             let buf = [1, .. 2048];\n             let mut total_bytes_written = 0;\n             while total_bytes_written < MAX {\n@@ -1041,7 +1038,7 @@ mod test {\n         let mut buf = [0, .. 2048];\n         let mut total_bytes_read = 0;\n         while total_bytes_read < MAX {\n-            let nread = stream.read(buf).unwrap();\n+            let nread = stream.read(buf).ok().unwrap();\n             total_bytes_read += nread;\n             for i in range(0u, nread) {\n                 assert_eq!(buf[i], 1);\n@@ -1053,8 +1050,8 @@ mod test {\n     #[test]\n     #[ignore(cfg(windows))] // FIXME(#10102) server never sees second packet\n     fn test_udp_twice() {\n-        let server_addr = next_test_ip4();\n-        let client_addr = next_test_ip4();\n+        let server_addr = ::next_test_ip4();\n+        let client_addr = ::next_test_ip4();\n         let (tx, rx) = channel();\n \n         spawn(proc() {\n@@ -1068,22 +1065,22 @@ mod test {\n         tx.send(());\n         let mut buf1 = [0];\n         let mut buf2 = [0];\n-        let (nread1, src1) = server.recvfrom(buf1).unwrap();\n-        let (nread2, src2) = server.recvfrom(buf2).unwrap();\n+        let (nread1, src1) = server.recvfrom(buf1).ok().unwrap();\n+        let (nread2, src2) = server.recvfrom(buf2).ok().unwrap();\n         assert_eq!(nread1, 1);\n         assert_eq!(nread2, 1);\n-        assert_eq!(src1, client_addr);\n-        assert_eq!(src2, client_addr);\n+        assert!(src1 == client_addr);\n+        assert!(src2 == client_addr);\n         assert_eq!(buf1[0], 1);\n         assert_eq!(buf2[0], 2);\n     }\n \n     #[test]\n     fn test_udp_many_read() {\n-        let server_out_addr = next_test_ip4();\n-        let server_in_addr = next_test_ip4();\n-        let client_out_addr = next_test_ip4();\n-        let client_in_addr = next_test_ip4();\n+        let server_out_addr = ::next_test_ip4();\n+        let server_in_addr = ::next_test_ip4();\n+        let client_out_addr = ::next_test_ip4();\n+        let client_in_addr = ::next_test_ip4();\n         static MAX: uint = 500_000;\n \n         let (tx1, rx1) = channel::<()>();\n@@ -1106,9 +1103,9 @@ mod test {\n                 // check if the client has received enough\n                 let res = server_in.recvfrom(buf);\n                 assert!(res.is_ok());\n-                let (nread, src) = res.unwrap();\n+                let (nread, src) = res.ok().unwrap();\n                 assert_eq!(nread, 1);\n-                assert_eq!(src, client_out_addr);\n+                assert!(src == client_out_addr);\n             }\n             assert!(total_bytes_sent >= MAX);\n         });\n@@ -1127,8 +1124,8 @@ mod test {\n             // wait for data\n             let res = client_in.recvfrom(buf);\n             assert!(res.is_ok());\n-            let (nread, src) = res.unwrap();\n-            assert_eq!(src, server_out_addr);\n+            let (nread, src) = res.ok().unwrap();\n+            assert!(src == server_out_addr);\n             total_bytes_recv += nread;\n             for i in range(0u, nread) {\n                 assert_eq!(buf[i], 1);\n@@ -1140,33 +1137,33 @@ mod test {\n \n     #[test]\n     fn test_read_and_block() {\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n         let (tx, rx) = channel::<Receiver<()>>();\n \n         spawn(proc() {\n             let rx = rx.recv();\n             let mut stream = TcpWatcher::connect(local_loop(), addr, None).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).ok().unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).ok().unwrap();\n             rx.recv();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).ok().unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).ok().unwrap();\n             rx.recv();\n         });\n \n         let listener = TcpListener::bind(local_loop(), addr).unwrap();\n-        let mut acceptor = listener.listen().unwrap();\n+        let mut acceptor = listener.listen().ok().unwrap();\n         let (tx2, rx2) = channel();\n         tx.send(rx2);\n-        let mut stream = acceptor.accept().unwrap();\n+        let mut stream = acceptor.accept().ok().unwrap();\n         let mut buf = [0, .. 2048];\n \n         let expected = 32;\n         let mut current = 0;\n         let mut reads = 0;\n \n         while current < expected {\n-            let nread = stream.read(buf).unwrap();\n+            let nread = stream.read(buf).ok().unwrap();\n             for i in range(0u, nread) {\n                 let val = buf[i] as uint;\n                 assert_eq!(val, current % 8);\n@@ -1183,14 +1180,14 @@ mod test {\n \n     #[test]\n     fn test_simple_tcp_server_and_client_on_diff_threads() {\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n \n         spawn(proc() {\n             let listener = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut acceptor = listener.listen().unwrap();\n-            let mut stream = acceptor.accept().unwrap();\n+            let mut acceptor = listener.listen().ok().unwrap();\n+            let mut stream = acceptor.accept().ok().unwrap();\n             let mut buf = [0, .. 2048];\n-            let nread = stream.read(buf).unwrap();\n+            let nread = stream.read(buf).ok().unwrap();\n             assert_eq!(nread, 8);\n             for i in range(0u, nread) {\n                 assert_eq!(buf[i], i as u8);\n@@ -1201,27 +1198,27 @@ mod test {\n         while stream.is_err() {\n             stream = TcpWatcher::connect(local_loop(), addr, None);\n         }\n-        stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n+        stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]).ok().unwrap();\n     }\n \n     #[should_fail] #[test]\n     fn tcp_listener_fail_cleanup() {\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n         let w = TcpListener::bind(local_loop(), addr).unwrap();\n-        let _w = w.listen().unwrap();\n+        let _w = w.listen().ok().unwrap();\n         fail!();\n     }\n \n     #[should_fail] #[test]\n     fn tcp_stream_fail_cleanup() {\n         let (tx, rx) = channel();\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n \n         spawn(proc() {\n             let w = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut w = w.listen().unwrap();\n+            let mut w = w.listen().ok().unwrap();\n             tx.send(());\n-            drop(w.accept().unwrap());\n+            drop(w.accept().ok().unwrap());\n         });\n         rx.recv();\n         let _w = TcpWatcher::connect(local_loop(), addr, None).unwrap();\n@@ -1230,14 +1227,14 @@ mod test {\n \n     #[should_fail] #[test]\n     fn udp_listener_fail_cleanup() {\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n         let _w = UdpWatcher::bind(local_loop(), addr).unwrap();\n         fail!();\n     }\n \n     #[should_fail] #[test]\n     fn udp_fail_other_task() {\n-        let addr = next_test_ip4();\n+        let addr = ::next_test_ip4();\n         let (tx, rx) = channel();\n \n         // force the handle to be created on a different scheduler, failure in"}, {"sha": "e5c134b6b92687b7285f3b88935efd9158bbe104", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -10,10 +10,9 @@\n \n use libc;\n use std::c_str::CString;\n-use std::io::IoError;\n-use std::io;\n use std::mem;\n-use std::rt::rtio::{RtioPipe, RtioUnixListener, RtioUnixAcceptor};\n+use std::rt::rtio;\n+use std::rt::rtio::IoResult;\n use std::rt::task::BlockedTask;\n \n use homing::{HomingIO, HomeHandle};\n@@ -39,8 +38,8 @@ pub struct PipeWatcher {\n pub struct PipeListener {\n     home: HomeHandle,\n     pipe: *uvll::uv_pipe_t,\n-    outgoing: Sender<Result<Box<RtioPipe:Send>, IoError>>,\n-    incoming: Receiver<Result<Box<RtioPipe:Send>, IoError>>,\n+    outgoing: Sender<IoResult<Box<rtio::RtioPipe:Send>>>,\n+    incoming: Receiver<IoResult<Box<rtio::RtioPipe:Send>>>,\n }\n \n pub struct PipeAcceptor {\n@@ -111,37 +110,37 @@ impl PipeWatcher {\n     }\n }\n \n-impl RtioPipe for PipeWatcher {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+impl rtio::RtioPipe for PipeWatcher {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let m = self.fire_homing_missile();\n         let guard = try!(self.read_access.grant(m));\n \n         // see comments in close_read about this check\n         if guard.access.is_closed() {\n-            return Err(io::standard_error(io::EndOfFile))\n+            return Err(uv_error_to_io_error(UvError(uvll::EOF)))\n         }\n \n         self.stream.read(buf).map_err(uv_error_to_io_error)\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let m = self.fire_homing_missile();\n         let guard = try!(self.write_access.grant(m));\n         self.stream.write(buf, guard.can_timeout).map_err(uv_error_to_io_error)\n     }\n \n-    fn clone(&self) -> Box<RtioPipe:Send> {\n+    fn clone(&self) -> Box<rtio::RtioPipe:Send> {\n         box PipeWatcher {\n             stream: StreamWatcher::new(self.stream.handle),\n             defused: false,\n             home: self.home.clone(),\n             refcount: self.refcount.clone(),\n             read_access: self.read_access.clone(),\n             write_access: self.write_access.clone(),\n-        } as Box<RtioPipe:Send>\n+        } as Box<rtio::RtioPipe:Send>\n     }\n \n-    fn close_read(&mut self) -> Result<(), IoError> {\n+    fn close_read(&mut self) -> IoResult<()> {\n         // The current uv_shutdown method only shuts the writing half of the\n         // connection, and no method is provided to shut down the reading half\n         // of the connection. With a lack of method, we emulate shutting down\n@@ -168,7 +167,7 @@ impl RtioPipe for PipeWatcher {\n         Ok(())\n     }\n \n-    fn close_write(&mut self) -> Result<(), IoError> {\n+    fn close_write(&mut self) -> IoResult<()> {\n         let _m = self.fire_homing_missile();\n         net::shutdown(self.stream.handle, &self.uv_loop())\n     }\n@@ -248,8 +247,8 @@ impl PipeListener {\n     }\n }\n \n-impl RtioUnixListener for PipeListener {\n-    fn listen(~self) -> Result<Box<RtioUnixAcceptor:Send>, IoError> {\n+impl rtio::RtioUnixListener for PipeListener {\n+    fn listen(~self) -> IoResult<Box<rtio::RtioUnixAcceptor:Send>> {\n         // create the acceptor object from ourselves\n         let mut acceptor = box PipeAcceptor {\n             listener: self,\n@@ -259,7 +258,7 @@ impl RtioUnixListener for PipeListener {\n         let _m = acceptor.fire_homing_missile();\n         // FIXME: the 128 backlog should be configurable\n         match unsafe { uvll::uv_listen(acceptor.listener.pipe, 128, listen_cb) } {\n-            0 => Ok(acceptor as Box<RtioUnixAcceptor:Send>),\n+            0 => Ok(acceptor as Box<rtio::RtioUnixAcceptor:Send>),\n             n => Err(uv_error_to_io_error(UvError(n))),\n         }\n     }\n@@ -284,7 +283,7 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n             });\n             let client = PipeWatcher::new_home(&loop_, pipe.home().clone(), false);\n             assert_eq!(unsafe { uvll::uv_accept(server, client.handle()) }, 0);\n-            Ok(box client as Box<RtioPipe:Send>)\n+            Ok(box client as Box<rtio::RtioPipe:Send>)\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n@@ -300,8 +299,8 @@ impl Drop for PipeListener {\n \n // PipeAcceptor implementation and traits\n \n-impl RtioUnixAcceptor for PipeAcceptor {\n-    fn accept(&mut self) -> Result<Box<RtioPipe:Send>, IoError> {\n+impl rtio::RtioUnixAcceptor for PipeAcceptor {\n+    fn accept(&mut self) -> IoResult<Box<rtio::RtioPipe:Send>> {\n         self.timeout.accept(&self.listener.incoming)\n     }\n \n@@ -366,19 +365,19 @@ mod tests {\n \n         spawn(proc() {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n-            let mut p = p.listen().unwrap();\n+            let mut p = p.listen().ok().unwrap();\n             tx.send(());\n-            let mut client = p.accept().unwrap();\n+            let mut client = p.accept().ok().unwrap();\n             let mut buf = [0];\n-            assert!(client.read(buf).unwrap() == 1);\n+            assert!(client.read(buf).ok().unwrap() == 1);\n             assert_eq!(buf[0], 1);\n             assert!(client.write([2]).is_ok());\n         });\n         rx.recv();\n         let mut c = PipeWatcher::connect(local_loop(), &path.to_c_str(), None).unwrap();\n         assert!(c.write([1]).is_ok());\n         let mut buf = [0];\n-        assert!(c.read(buf).unwrap() == 1);\n+        assert!(c.read(buf).ok().unwrap() == 1);\n         assert_eq!(buf[0], 2);\n     }\n \n@@ -390,9 +389,9 @@ mod tests {\n \n         spawn(proc() {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n-            let mut p = p.listen().unwrap();\n+            let mut p = p.listen().ok().unwrap();\n             tx.send(());\n-            drop(p.accept().unwrap());\n+            drop(p.accept().ok().unwrap());\n         });\n         rx.recv();\n         let _c = PipeWatcher::connect(local_loop(), &path.to_c_str(), None).unwrap();"}, {"sha": "aa87582da26d87bca60dd1c7f42b06f935cb06c6", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -10,11 +10,10 @@\n \n use libc::c_int;\n use libc;\n-use std::io::IoError;\n-use std::io::process;\n use std::ptr;\n use std::c_str::CString;\n-use std::rt::rtio::{ProcessConfig, RtioProcess};\n+use std::rt::rtio;\n+use std::rt::rtio::IoResult;\n use std::rt::task::BlockedTask;\n \n use homing::{HomingIO, HomeHandle};\n@@ -33,7 +32,7 @@ pub struct Process {\n     to_wake: Option<BlockedTask>,\n \n     /// Collected from the exit_cb\n-    exit_status: Option<process::ProcessExit>,\n+    exit_status: Option<rtio::ProcessExit>,\n \n     /// Lazily initialized timeout timer\n     timer: Option<Box<TimerWatcher>>,\n@@ -51,7 +50,7 @@ impl Process {\n     ///\n     /// Returns either the corresponding process object or an error which\n     /// occurred.\n-    pub fn spawn(io_loop: &mut UvIoFactory, cfg: ProcessConfig)\n+    pub fn spawn(io_loop: &mut UvIoFactory, cfg: rtio::ProcessConfig)\n                 -> Result<(Box<Process>, Vec<Option<PipeWatcher>>), UvError> {\n         let mut io = vec![cfg.stdin, cfg.stdout, cfg.stderr];\n         for slot in cfg.extra_io.iter() {\n@@ -137,28 +136,28 @@ extern fn on_exit(handle: *uvll::uv_process_t,\n \n     assert!(p.exit_status.is_none());\n     p.exit_status = Some(match term_signal {\n-        0 => process::ExitStatus(exit_status as int),\n-        n => process::ExitSignal(n as int),\n+        0 => rtio::ExitStatus(exit_status as int),\n+        n => rtio::ExitSignal(n as int),\n     });\n \n     if p.to_wake.is_none() { return }\n     wakeup(&mut p.to_wake);\n }\n \n unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n-                    io: &process::StdioContainer,\n+                    io: &rtio::StdioContainer,\n                     io_loop: &mut UvIoFactory) -> Option<PipeWatcher> {\n     match *io {\n-        process::Ignored => {\n+        rtio::Ignored => {\n             uvll::set_stdio_container_flags(dst, uvll::STDIO_IGNORE);\n             None\n         }\n-        process::InheritFd(fd) => {\n+        rtio::InheritFd(fd) => {\n             uvll::set_stdio_container_flags(dst, uvll::STDIO_INHERIT_FD);\n             uvll::set_stdio_container_fd(dst, fd);\n             None\n         }\n-        process::CreatePipe(readable, writable) => {\n+        rtio::CreatePipe(readable, writable) => {\n             let mut flags = uvll::STDIO_CREATE_PIPE as libc::c_int;\n             if readable {\n                 flags |= uvll::STDIO_READABLE_PIPE as libc::c_int;\n@@ -231,12 +230,12 @@ impl UvHandle<uvll::uv_process_t> for Process {\n     fn uv_handle(&self) -> *uvll::uv_process_t { self.handle }\n }\n \n-impl RtioProcess for Process {\n+impl rtio::RtioProcess for Process {\n     fn id(&self) -> libc::pid_t {\n         unsafe { uvll::process_pid(self.handle) as libc::pid_t }\n     }\n \n-    fn kill(&mut self, signal: int) -> Result<(), IoError> {\n+    fn kill(&mut self, signal: int) -> IoResult<()> {\n         let _m = self.fire_homing_missile();\n         match unsafe {\n             uvll::uv_process_kill(self.handle, signal as libc::c_int)\n@@ -246,7 +245,7 @@ impl RtioProcess for Process {\n         }\n     }\n \n-    fn wait(&mut self) -> Result<process::ProcessExit, IoError> {\n+    fn wait(&mut self) -> IoResult<rtio::ProcessExit> {\n         // Make sure (on the home scheduler) that we have an exit status listed\n         let _m = self.fire_homing_missile();\n         match self.exit_status {"}, {"sha": "a3694bfe9c2beed46199f5a7f825f48fa636b994", "filename": "src/librustuv/queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -23,8 +23,8 @@\n use alloc::arc::Arc;\n use libc::c_void;\n use std::mem;\n+use std::rt::mutex::NativeMutex;\n use std::rt::task::BlockedTask;\n-use std::unstable::mutex::NativeMutex;\n use mpsc = std::sync::mpsc_queue;\n \n use async::AsyncWatcher;"}, {"sha": "fd0b6acb8ae746ecef398637aeae07240f4faceb", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use libc::c_int;\n-use std::io::signal::Signum;\n-use std::rt::rtio::RtioSignal;\n+use std::rt::rtio::{RtioSignal, Callback};\n \n use homing::{HomingIO, HomeHandle};\n use super::{UvError, UvHandle};\n@@ -21,18 +20,16 @@ pub struct SignalWatcher {\n     handle: *uvll::uv_signal_t,\n     home: HomeHandle,\n \n-    channel: Sender<Signum>,\n-    signal: Signum,\n+    cb: Box<Callback:Send>,\n }\n \n impl SignalWatcher {\n-    pub fn new(io: &mut UvIoFactory, signum: Signum, channel: Sender<Signum>)\n+    pub fn new(io: &mut UvIoFactory, signum: int, cb: Box<Callback:Send>)\n                -> Result<Box<SignalWatcher>, UvError> {\n         let s = box SignalWatcher {\n             handle: UvHandle::alloc(None::<SignalWatcher>, uvll::UV_SIGNAL),\n             home: io.make_handle(),\n-            channel: channel,\n-            signal: signum,\n+            cb: cb,\n         };\n         assert_eq!(unsafe {\n             uvll::uv_signal_init(io.uv_loop(), s.handle)\n@@ -48,10 +45,9 @@ impl SignalWatcher {\n     }\n }\n \n-extern fn signal_cb(handle: *uvll::uv_signal_t, signum: c_int) {\n+extern fn signal_cb(handle: *uvll::uv_signal_t, _signum: c_int) {\n     let s: &mut SignalWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n-    assert_eq!(signum as int, s.signal as int);\n-    let _ = s.channel.send_opt(s.signal);\n+    let _ = s.cb.call();\n }\n \n impl HomingIO for SignalWatcher {\n@@ -70,25 +66,3 @@ impl Drop for SignalWatcher {\n         self.close();\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::super::local_loop;\n-    use std::io::signal;\n-    use super::SignalWatcher;\n-\n-    #[test]\n-    fn closing_channel_during_drop_doesnt_kill_everything() {\n-        // see issue #10375, relates to timers as well.\n-        let (tx, rx) = channel();\n-        let _signal = SignalWatcher::new(local_loop(), signal::Interrupt,\n-                                         tx);\n-\n-        spawn(proc() {\n-            let _ = rx.recv_opt();\n-        });\n-\n-        // when we drop the SignalWatcher we're going to destroy the channel,\n-        // which must wake up the task on the other end\n-    }\n-}"}, {"sha": "1c191d476edb9efa27750192bb823d1ea654cc89", "filename": "src/librustuv/timeout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimeout.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use libc::c_int;\n-use std::io::IoResult;\n use std::mem;\n use std::rt::task::BlockedTask;\n+use std::rt::rtio::IoResult;\n \n use access;\n use homing::{HomeHandle, HomingMissile, HomingIO};"}, {"sha": "b940774323a2a57dae027e26afaf0fa07da7cfb0", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 11, "deletions": 161, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::mem;\n-use std::rt::rtio::RtioTimer;\n+use std::rt::rtio::{RtioTimer, Callback};\n use std::rt::task::BlockedTask;\n \n use homing::{HomeHandle, HomingIO};\n@@ -27,8 +27,8 @@ pub struct TimerWatcher {\n \n pub enum NextAction {\n     WakeTask,\n-    SendOnce(Sender<()>),\n-    SendMany(Sender<()>, uint),\n+    CallOnce(Box<Callback:Send>),\n+    CallMany(Box<Callback:Send>, uint),\n }\n \n impl TimerWatcher {\n@@ -103,36 +103,28 @@ impl RtioTimer for TimerWatcher {\n         self.stop();\n     }\n \n-    fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n-        let (tx, rx) = channel();\n-\n+    fn oneshot(&mut self, msecs: u64, cb: Box<Callback:Send>) {\n         // similarly to the destructor, we must drop the previous action outside\n         // of the homing missile\n         let _prev_action = {\n             let _m = self.fire_homing_missile();\n             self.id += 1;\n             self.stop();\n             self.start(timer_cb, msecs, 0);\n-            mem::replace(&mut self.action, Some(SendOnce(tx)))\n+            mem::replace(&mut self.action, Some(CallOnce(cb)))\n         };\n-\n-        return rx;\n     }\n \n-    fn period(&mut self, msecs: u64) -> Receiver<()> {\n-        let (tx, rx) = channel();\n-\n+    fn period(&mut self, msecs: u64, cb: Box<Callback:Send>) {\n         // similarly to the destructor, we must drop the previous action outside\n         // of the homing missile\n         let _prev_action = {\n             let _m = self.fire_homing_missile();\n             self.id += 1;\n             self.stop();\n             self.start(timer_cb, msecs, msecs);\n-            mem::replace(&mut self.action, Some(SendMany(tx, self.id)))\n+            mem::replace(&mut self.action, Some(CallMany(cb, self.id)))\n         };\n-\n-        return rx;\n     }\n }\n \n@@ -145,9 +137,9 @@ extern fn timer_cb(handle: *uvll::uv_timer_t) {\n             let task = timer.blocker.take_unwrap();\n             let _ = task.wake().map(|t| t.reawaken());\n         }\n-        SendOnce(chan) => { let _ = chan.send_opt(()); }\n-        SendMany(chan, id) => {\n-            let _ = chan.send_opt(());\n+        CallOnce(mut cb) => { cb.call() }\n+        CallMany(mut cb, id) => {\n+            cb.call();\n \n             // Note that the above operation could have performed some form of\n             // scheduling. This means that the timer may have decided to insert\n@@ -158,7 +150,7 @@ extern fn timer_cb(handle: *uvll::uv_timer_t) {\n             // for you. We're guaranteed to all be running on the same thread,\n             // so there's no need for any synchronization here.\n             if timer.id == id {\n-                timer.action = Some(SendMany(chan, id));\n+                timer.action = Some(CallMany(cb, id));\n             }\n         }\n     }\n@@ -179,145 +171,3 @@ impl Drop for TimerWatcher {\n         };\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use std::rt::rtio::RtioTimer;\n-    use super::super::local_loop;\n-    use super::TimerWatcher;\n-\n-    #[test]\n-    fn oneshot() {\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let port = timer.oneshot(1);\n-        port.recv();\n-        let port = timer.oneshot(1);\n-        port.recv();\n-    }\n-\n-    #[test]\n-    fn override() {\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let oport = timer.oneshot(1);\n-        let pport = timer.period(1);\n-        timer.sleep(1);\n-        assert_eq!(oport.recv_opt(), Err(()));\n-        assert_eq!(pport.recv_opt(), Err(()));\n-        timer.oneshot(1).recv();\n-    }\n-\n-    #[test]\n-    fn period() {\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let port = timer.period(1);\n-        port.recv();\n-        port.recv();\n-        let port2 = timer.period(1);\n-        port2.recv();\n-        port2.recv();\n-    }\n-\n-    #[test]\n-    fn sleep() {\n-        let mut timer = TimerWatcher::new(local_loop());\n-        timer.sleep(1);\n-        timer.sleep(1);\n-    }\n-\n-    #[test] #[should_fail]\n-    fn oneshot_fail() {\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let _port = timer.oneshot(1);\n-        fail!();\n-    }\n-\n-    #[test] #[should_fail]\n-    fn period_fail() {\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let _port = timer.period(1);\n-        fail!();\n-    }\n-\n-    #[test] #[should_fail]\n-    fn normal_fail() {\n-        let _timer = TimerWatcher::new(local_loop());\n-        fail!();\n-    }\n-\n-    #[test]\n-    fn closing_channel_during_drop_doesnt_kill_everything() {\n-        // see issue #10375\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let timer_port = timer.period(1000);\n-\n-        spawn(proc() {\n-            let _ = timer_port.recv_opt();\n-        });\n-\n-        // when we drop the TimerWatcher we're going to destroy the channel,\n-        // which must wake up the task on the other end\n-    }\n-\n-    #[test]\n-    fn reset_doesnt_switch_tasks() {\n-        // similar test to the one above.\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let timer_port = timer.period(1000);\n-\n-        spawn(proc() {\n-            let _ = timer_port.recv_opt();\n-        });\n-\n-        drop(timer.oneshot(1));\n-    }\n-    #[test]\n-    fn reset_doesnt_switch_tasks2() {\n-        // similar test to the one above.\n-        let mut timer = TimerWatcher::new(local_loop());\n-        let timer_port = timer.period(1000);\n-\n-        spawn(proc() {\n-            let _ = timer_port.recv_opt();\n-        });\n-\n-        timer.sleep(1);\n-    }\n-\n-    #[test]\n-    fn sender_goes_away_oneshot() {\n-        let port = {\n-            let mut timer = TimerWatcher::new(local_loop());\n-            timer.oneshot(1000)\n-        };\n-        assert_eq!(port.recv_opt(), Err(()));\n-    }\n-\n-    #[test]\n-    fn sender_goes_away_period() {\n-        let port = {\n-            let mut timer = TimerWatcher::new(local_loop());\n-            timer.period(1000)\n-        };\n-        assert_eq!(port.recv_opt(), Err(()));\n-    }\n-\n-    #[test]\n-    fn receiver_goes_away_oneshot() {\n-        let mut timer1 = TimerWatcher::new(local_loop());\n-        drop(timer1.oneshot(1));\n-        let mut timer2 = TimerWatcher::new(local_loop());\n-        // while sleeping, the prevous timer should fire and not have its\n-        // callback do something terrible.\n-        timer2.sleep(2);\n-    }\n-\n-    #[test]\n-    fn receiver_goes_away_period() {\n-        let mut timer1 = TimerWatcher::new(local_loop());\n-        drop(timer1.period(1));\n-        let mut timer2 = TimerWatcher::new(local_loop());\n-        // while sleeping, the prevous timer should fire and not have its\n-        // callback do something terrible.\n-        timer2.sleep(2);\n-    }\n-}"}, {"sha": "828a3d0c63b0aaea2109647706b625e2723e9cfb", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -9,9 +9,8 @@\n // except according to those terms.\n \n use libc;\n-use std::io::IoError;\n use std::ptr;\n-use std::rt::rtio::RtioTTY;\n+use std::rt::rtio::{RtioTTY, IoResult};\n \n use homing::{HomingIO, HomeHandle};\n use stream::StreamWatcher;\n@@ -80,17 +79,17 @@ impl TtyWatcher {\n }\n \n impl RtioTTY for TtyWatcher {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let _m = self.fire_homing_missile();\n         self.stream.read(buf).map_err(uv_error_to_io_error)\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let _m = self.fire_homing_missile();\n         self.stream.write(buf, false).map_err(uv_error_to_io_error)\n     }\n \n-    fn set_raw(&mut self, raw: bool) -> Result<(), IoError> {\n+    fn set_raw(&mut self, raw: bool) -> IoResult<()> {\n         let raw = raw as libc::c_int;\n         let _m = self.fire_homing_missile();\n         match unsafe { uvll::uv_tty_set_mode(self.tty, raw) } {\n@@ -100,7 +99,7 @@ impl RtioTTY for TtyWatcher {\n     }\n \n     #[allow(unused_mut)]\n-    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n+    fn get_winsize(&mut self) -> IoResult<(int, int)> {\n         let mut width: libc::c_int = 0;\n         let mut height: libc::c_int = 0;\n         let widthptr: *libc::c_int = &width;"}, {"sha": "cf2a2d73d4d9f11e2b7e2efda60db9366a7e44c3", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 50, "deletions": 55, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -11,21 +11,13 @@\n //! The implementation of `rtio` for libuv\n \n use std::c_str::CString;\n-use std::io::IoError;\n-use std::io::net::ip::SocketAddr;\n-use std::io::signal::Signum;\n-use std::io::{FileMode, FileAccess, Open, Append, Truncate, Read, Write,\n-              ReadWrite, FileStat};\n-use std::io;\n use std::mem;\n use libc::c_int;\n use libc::{O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY, S_IRUSR,\n                 S_IWUSR};\n use libc;\n-use std::path::Path;\n use std::rt::rtio;\n-use std::rt::rtio::{ProcessConfig, IoFactory, EventLoop};\n-use ai = std::io::net::addrinfo;\n+use std::rt::rtio::{ProcessConfig, IoFactory, EventLoop, IoResult};\n \n #[cfg(test)] use std::rt::thread::Thread;\n \n@@ -148,36 +140,38 @@ impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n-    fn tcp_connect(&mut self, addr: SocketAddr, timeout: Option<u64>)\n-                   -> Result<Box<rtio::RtioTcpStream:Send>, IoError> {\n+    fn tcp_connect(&mut self, addr: rtio::SocketAddr, timeout: Option<u64>)\n+                   -> IoResult<Box<rtio::RtioTcpStream:Send>> {\n         match TcpWatcher::connect(self, addr, timeout) {\n             Ok(t) => Ok(box t as Box<rtio::RtioTcpStream:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn tcp_bind(&mut self, addr: SocketAddr)\n-                -> Result<Box<rtio::RtioTcpListener:Send>, IoError> {\n+    fn tcp_bind(&mut self, addr: rtio::SocketAddr)\n+                -> IoResult<Box<rtio::RtioTcpListener:Send>> {\n         match TcpListener::bind(self, addr) {\n             Ok(t) => Ok(t as Box<rtio::RtioTcpListener:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn udp_bind(&mut self, addr: SocketAddr)\n-                -> Result<Box<rtio::RtioUdpSocket:Send>, IoError> {\n+    fn udp_bind(&mut self, addr: rtio::SocketAddr)\n+                -> IoResult<Box<rtio::RtioUdpSocket:Send>> {\n         match UdpWatcher::bind(self, addr) {\n             Ok(u) => Ok(box u as Box<rtio::RtioUdpSocket:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn timer_init(&mut self) -> Result<Box<rtio::RtioTimer:Send>, IoError> {\n+    fn timer_init(&mut self) -> IoResult<Box<rtio::RtioTimer:Send>> {\n         Ok(TimerWatcher::new(self) as Box<rtio::RtioTimer:Send>)\n     }\n \n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<ai::Hint>) -> Result<Vec<ai::Info>, IoError> {\n+                          hint: Option<rtio::AddrinfoHint>)\n+        -> IoResult<Vec<rtio::AddrinfoInfo>>\n+    {\n         let r = GetAddrInfoRequest::run(&self.loop_, host, servname, hint);\n         r.map_err(uv_error_to_io_error)\n     }\n@@ -188,20 +182,22 @@ impl IoFactory for UvIoFactory {\n             Box<rtio::RtioFileStream:Send>\n     }\n \n-    fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n-               -> Result<Box<rtio::RtioFileStream:Send>, IoError> {\n+    fn fs_open(&mut self, path: &CString, fm: rtio::FileMode,\n+               fa: rtio::FileAccess)\n+        -> IoResult<Box<rtio::RtioFileStream:Send>>\n+    {\n         let flags = match fm {\n-            io::Open => 0,\n-            io::Append => libc::O_APPEND,\n-            io::Truncate => libc::O_TRUNC,\n+            rtio::Open => 0,\n+            rtio::Append => libc::O_APPEND,\n+            rtio::Truncate => libc::O_TRUNC,\n         };\n         // Opening with a write permission must silently create the file.\n         let (flags, mode) = match fa {\n-            io::Read => (flags | libc::O_RDONLY, 0),\n-            io::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n-                          libc::S_IRUSR | libc::S_IWUSR),\n-            io::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n-                              libc::S_IRUSR | libc::S_IWUSR),\n+            rtio::Read => (flags | libc::O_RDONLY, 0),\n+            rtio::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n+                            libc::S_IRUSR | libc::S_IWUSR),\n+            rtio::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n+                                libc::S_IRUSR | libc::S_IWUSR),\n         };\n \n         match FsRequest::open(self, path, flags as int, mode as int) {\n@@ -210,69 +206,66 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n-    fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError> {\n+    fn fs_unlink(&mut self, path: &CString) -> IoResult<()> {\n         let r = FsRequest::unlink(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_lstat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n+    fn fs_lstat(&mut self, path: &CString) -> IoResult<rtio::FileStat> {\n         let r = FsRequest::lstat(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n+    fn fs_stat(&mut self, path: &CString) -> IoResult<rtio::FileStat> {\n         let r = FsRequest::stat(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_mkdir(&mut self, path: &CString,\n-                perm: io::FilePermission) -> Result<(), IoError> {\n-        let r = FsRequest::mkdir(&self.loop_, path, perm.bits() as c_int);\n+    fn fs_mkdir(&mut self, path: &CString, perm: uint) -> IoResult<()> {\n+        let r = FsRequest::mkdir(&self.loop_, path, perm as c_int);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError> {\n+    fn fs_rmdir(&mut self, path: &CString) -> IoResult<()> {\n         let r = FsRequest::rmdir(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_rename(&mut self, path: &CString, to: &CString) -> Result<(), IoError> {\n+    fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()> {\n         let r = FsRequest::rename(&self.loop_, path, to);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_chmod(&mut self, path: &CString,\n-                perm: io::FilePermission) -> Result<(), IoError> {\n-        let r = FsRequest::chmod(&self.loop_, path, perm.bits() as c_int);\n+    fn fs_chmod(&mut self, path: &CString, perm: uint) -> IoResult<()> {\n+        let r = FsRequest::chmod(&self.loop_, path, perm as c_int);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_readdir(&mut self, path: &CString, flags: c_int)\n-        -> Result<Vec<Path>, IoError>\n+        -> IoResult<Vec<CString>>\n     {\n         let r = FsRequest::readdir(&self.loop_, path, flags);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_link(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> {\n+    fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()> {\n         let r = FsRequest::link(&self.loop_, src, dst);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> {\n+    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()> {\n         let r = FsRequest::symlink(&self.loop_, src, dst);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> Result<(), IoError> {\n+    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> IoResult<()> {\n         let r = FsRequest::chown(&self.loop_, path, uid, gid);\n         r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_readlink(&mut self, path: &CString) -> Result<Path, IoError> {\n+    fn fs_readlink(&mut self, path: &CString) -> IoResult<CString> {\n         let r = FsRequest::readlink(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_utime(&mut self, path: &CString, atime: u64, mtime: u64)\n-        -> Result<(), IoError>\n+        -> IoResult<()>\n     {\n         let r = FsRequest::utime(&self.loop_, path, atime, mtime);\n         r.map_err(uv_error_to_io_error)\n     }\n \n     fn spawn(&mut self, cfg: ProcessConfig)\n-            -> Result<(Box<rtio::RtioProcess:Send>,\n-                       Vec<Option<Box<rtio::RtioPipe:Send>>>),\n-                      IoError>\n+            -> IoResult<(Box<rtio::RtioProcess:Send>,\n+                         Vec<Option<Box<rtio::RtioPipe:Send>>>)>\n     {\n         match Process::spawn(self, cfg) {\n             Ok((p, io)) => {\n@@ -285,45 +278,47 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n-    fn kill(&mut self, pid: libc::pid_t, signum: int) -> Result<(), IoError> {\n+    fn kill(&mut self, pid: libc::pid_t, signum: int) -> IoResult<()> {\n         Process::kill(pid, signum).map_err(uv_error_to_io_error)\n     }\n \n     fn unix_bind(&mut self, path: &CString)\n-                 -> Result<Box<rtio::RtioUnixListener:Send>, IoError> {\n+                 -> IoResult<Box<rtio::RtioUnixListener:Send>> {\n         match PipeListener::bind(self, path) {\n             Ok(p) => Ok(p as Box<rtio::RtioUnixListener:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n     fn unix_connect(&mut self, path: &CString, timeout: Option<u64>)\n-                    -> Result<Box<rtio::RtioPipe:Send>, IoError> {\n+                    -> IoResult<Box<rtio::RtioPipe:Send>> {\n         match PipeWatcher::connect(self, path, timeout) {\n             Ok(p) => Ok(box p as Box<rtio::RtioPipe:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n     fn tty_open(&mut self, fd: c_int, readable: bool)\n-            -> Result<Box<rtio::RtioTTY:Send>, IoError> {\n+            -> IoResult<Box<rtio::RtioTTY:Send>> {\n         match TtyWatcher::new(self, fd, readable) {\n             Ok(tty) => Ok(box tty as Box<rtio::RtioTTY:Send>),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n     fn pipe_open(&mut self, fd: c_int)\n-                 -> Result<Box<rtio::RtioPipe:Send>, IoError> {\n+        -> IoResult<Box<rtio::RtioPipe:Send>>\n+    {\n         match PipeWatcher::open(self, fd) {\n             Ok(s) => Ok(box s as Box<rtio::RtioPipe:Send>),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n-    fn signal(&mut self, signum: Signum, channel: Sender<Signum>)\n-        -> Result<Box<rtio::RtioSignal:Send>, IoError> {\n-        match SignalWatcher::new(self, signum, channel) {\n+    fn signal(&mut self, signum: int, cb: Box<rtio::Callback:Send>)\n+        -> IoResult<Box<rtio::RtioSignal:Send>>\n+    {\n+        match SignalWatcher::new(self, signum, cb) {\n             Ok(s) => Ok(s as Box<rtio::RtioSignal:Send>),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }"}, {"sha": "f6c6d6c9068e0cbbfc46a43811f50d22dd183382", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -38,7 +38,8 @@ use std::rt::libc_heap::malloc_raw;\n use libc::uintptr_t;\n \n pub use self::errors::{EACCES, ECONNREFUSED, ECONNRESET, EPIPE, ECONNABORTED,\n-                       ECANCELED, EBADF, ENOTCONN, ENOENT, EADDRNOTAVAIL};\n+                       ECANCELED, EBADF, ENOTCONN, ENOENT, EADDRNOTAVAIL,\n+                       EADDRINUSE};\n \n pub static OK: c_int = 0;\n pub static EOF: c_int = -4095;\n@@ -61,6 +62,7 @@ pub mod errors {\n     pub static ECANCELED: c_int = -4081;\n     pub static EBADF: c_int = -4083;\n     pub static EADDRNOTAVAIL: c_int = -4090;\n+    pub static EADDRINUSE: c_int = -4091;\n }\n #[cfg(not(windows))]\n pub mod errors {\n@@ -77,6 +79,7 @@ pub mod errors {\n     pub static ECANCELED : c_int = -libc::ECANCELED;\n     pub static EBADF : c_int = -libc::EBADF;\n     pub static EADDRNOTAVAIL : c_int = -libc::EADDRNOTAVAIL;\n+    pub static EADDRINUSE : c_int = -libc::EADDRINUSE;\n }\n \n pub static PROCESS_SETUID: c_int = 1 << 0;"}, {"sha": "2e51931f15a1336a046bf3a4dee3e5f978f1f05c", "filename": "src/libstd/cleanup.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/e87e18064ece0d7eddb269b8211fb8fdf5efaa91/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87e18064ece0d7eddb269b8211fb8fdf5efaa91/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=e87e18064ece0d7eddb269b8211fb8fdf5efaa91", "patch": "@@ -1,102 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![doc(hidden)]\n-\n-use ptr;\n-use raw;\n-\n-static RC_IMMORTAL : uint = 0x77777777;\n-\n-/*\n- * Box annihilation\n- *\n- * This runs at task death to free all boxes.\n- */\n-\n-unsafe fn each_live_alloc(read_next_before: bool,\n-                          f: |alloc: *mut raw::Box<()>| -> bool)\n-                          -> bool {\n-    //! Walks the internal list of allocations\n-\n-    use rt::local_heap;\n-\n-    let mut alloc = local_heap::live_allocs();\n-    while alloc != ptr::mut_null() {\n-        let next_before = (*alloc).next;\n-\n-        if !f(alloc) {\n-            return false;\n-        }\n-\n-        if read_next_before {\n-            alloc = next_before;\n-        } else {\n-            alloc = (*alloc).next;\n-        }\n-    }\n-    return true;\n-}\n-\n-#[cfg(unix)]\n-fn debug_mem() -> bool {\n-    // FIXME: Need to port the environment struct to newsched\n-    false\n-}\n-\n-#[cfg(windows)]\n-fn debug_mem() -> bool {\n-    false\n-}\n-\n-/// Destroys all managed memory (i.e. @ boxes) held by the current task.\n-pub unsafe fn annihilate() {\n-    use rt::local_heap::local_free;\n-\n-    let mut n_total_boxes = 0u;\n-\n-    // Pass 1: Make all boxes immortal.\n-    //\n-    // In this pass, nothing gets freed, so it does not matter whether\n-    // we read the next field before or after the callback.\n-    each_live_alloc(true, |alloc| {\n-        n_total_boxes += 1;\n-        (*alloc).ref_count = RC_IMMORTAL;\n-        true\n-    });\n-\n-    // Pass 2: Drop all boxes.\n-    //\n-    // In this pass, unique-managed boxes may get freed, but not\n-    // managed boxes, so we must read the `next` field *after* the\n-    // callback, as the original value may have been freed.\n-    each_live_alloc(false, |alloc| {\n-        let drop_glue = (*alloc).drop_glue;\n-        let data = &mut (*alloc).data as *mut ();\n-        drop_glue(data as *mut u8);\n-        true\n-    });\n-\n-    // Pass 3: Free all boxes.\n-    //\n-    // In this pass, managed boxes may get freed (but not\n-    // unique-managed boxes, though I think that none of those are\n-    // left), so we must read the `next` field before, since it will\n-    // not be valid after.\n-    each_live_alloc(true, |alloc| {\n-        local_free(alloc as *u8);\n-        true\n-    });\n-\n-    if debug_mem() {\n-        // We do logging here w/o allocation.\n-        println!(\"total boxes annihilated: {}\", n_total_boxes);\n-    }\n-}"}, {"sha": "f4eeebeeea06fe6f903da27ec7cf325a164d2f06", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -27,10 +27,10 @@ use option::{Some, None, Option};\n use owned::Box;\n use result::{Ok, Err, Result};\n use rt::local::Local;\n+use rt::mutex::NativeMutex;\n use rt::task::{Task, BlockedTask};\n use rt::thread::Thread;\n use sync::atomics;\n-use unstable::mutex::NativeMutex;\n \n use mpsc = sync::mpsc_queue;\n "}, {"sha": "7fe505573b799bb12257a682a043fe6fde04df5d", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -43,10 +43,10 @@ use owned::Box;\n use ptr::RawPtr;\n use result::{Result, Ok, Err};\n use rt::local::Local;\n+use rt::mutex::{NativeMutex, LockGuard};\n use rt::task::{Task, BlockedTask};\n use sync::atomics;\n use ty::Unsafe;\n-use unstable::mutex::{NativeMutex, LockGuard};\n use vec::Vec;\n \n pub struct Packet<T> {"}, {"sha": "903f39c7b06a3ef717f9acf304a7117b8a0c5f41", "filename": "src/libstd/failure.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use alloc::owned::Box;\n+use any::{Any, AnyRefExt};\n+use fmt;\n+use io::{Writer, IoResult};\n+use kinds::Send;\n+use option::{Some, None};\n+use result::Ok;\n+use rt::backtrace;\n+use rt::{Stderr, Stdio};\n+use rustrt::local::Local;\n+use rustrt::task::Task;\n+use str::Str;\n+use string::String;\n+\n+// Defined in this module instead of io::stdio so that the unwinding\n+local_data_key!(pub local_stderr: Box<Writer:Send>)\n+\n+impl Writer for Stdio {\n+    fn write(&mut self, bytes: &[u8]) -> IoResult<()> {\n+        fn fmt_write<F: fmt::FormatWriter>(f: &mut F, bytes: &[u8]) {\n+            let _ = f.write(bytes);\n+        }\n+        fmt_write(self, bytes);\n+        Ok(())\n+    }\n+}\n+\n+pub fn on_fail(obj: &Any:Send, file: &'static str, line: uint) {\n+    let msg = match obj.as_ref::<&'static str>() {\n+        Some(s) => *s,\n+        None => match obj.as_ref::<String>() {\n+            Some(s) => s.as_slice(),\n+            None => \"Box<Any>\",\n+        }\n+    };\n+    let mut err = Stderr;\n+\n+    // It is assumed that all reasonable rust code will have a local task at\n+    // all times. This means that this `exists` will return true almost all of\n+    // the time. There are border cases, however, when the runtime has\n+    // *almost* set up the local task, but hasn't quite gotten there yet. In\n+    // order to get some better diagnostics, we print on failure and\n+    // immediately abort the whole process if there is no local task\n+    // available.\n+    if !Local::exists(None::<Task>) {\n+        let _ = writeln!(&mut err, \"failed at '{}', {}:{}\", msg, file, line);\n+        if backtrace::log_enabled() {\n+            let _ = backtrace::write(&mut err);\n+        } else {\n+            let _ = writeln!(&mut err, \"run with `RUST_BACKTRACE=1` to \\\n+                                        see a backtrace\");\n+        }\n+        return\n+    }\n+\n+    // Peel the name out of local task so we can print it. We've got to be sure\n+    // that the local task is in TLS while we're printing as I/O may occur.\n+    let (name, unwinding) = {\n+        let mut t = Local::borrow(None::<Task>);\n+        (t.name.take(), t.unwinder.unwinding())\n+    };\n+    {\n+        let n = name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n+\n+        match local_stderr.replace(None) {\n+            Some(mut stderr) => {\n+                // FIXME: what to do when the task printing fails?\n+                let _ = writeln!(stderr,\n+                                 \"task '{}' failed at '{}', {}:{}\\n\",\n+                                 n, msg, file, line);\n+                if backtrace::log_enabled() {\n+                    let _ = backtrace::write(stderr);\n+                }\n+                local_stderr.replace(Some(stderr));\n+            }\n+            None => {\n+                let _ = writeln!(&mut err, \"task '{}' failed at '{}', {}:{}\",\n+                                 n, msg, file, line);\n+                if backtrace::log_enabled() {\n+                    let _ = backtrace::write(&mut err);\n+                }\n+            }\n+        }\n+\n+        // If this is a double failure, make sure that we printed a backtrace\n+        // for this failure.\n+        if unwinding && !backtrace::log_enabled() {\n+            let _ = backtrace::write(&mut err);\n+        }\n+    }\n+    Local::borrow(None::<Task>).name = name;\n+}"}, {"sha": "49e8d37923661bf2c614768af0ebbb8d139e4a81", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 117, "deletions": 34, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -52,19 +52,22 @@ fs::unlink(&path);\n use c_str::ToCStr;\n use clone::Clone;\n use container::Container;\n+use io;\n use iter::Iterator;\n use kinds::Send;\n-use super::{Reader, Writer, Seek};\n-use super::{SeekStyle, Read, Write, Open, IoError, Truncate};\n-use super::{FileMode, FileAccess, FileStat, IoResult, FilePermission};\n-use rt::rtio::{RtioFileStream, IoFactory, LocalIo};\n-use io;\n+use libc;\n use option::{Some, None, Option};\n use owned::Box;\n-use result::{Ok, Err};\n-use path;\n use path::{Path, GenericPath};\n+use path;\n+use result::{Ok, Err};\n+use rt::rtio::{RtioFileStream, IoFactory, LocalIo};\n+use rt::rtio;\n use slice::{OwnedVector, ImmutableVector};\n+use super::UnstableFileStat;\n+use super::{FileMode, FileAccess, FileStat, IoResult, FilePermission};\n+use super::{Reader, Writer, Seek, Append, SeekCur, SeekEnd, SeekSet};\n+use super::{SeekStyle, Read, Write, ReadWrite, Open, IoError, Truncate};\n use vec::Vec;\n \n /// Unconstrained file access type that exposes read and write operations\n@@ -126,6 +129,16 @@ impl File {\n     pub fn open_mode(path: &Path,\n                      mode: FileMode,\n                      access: FileAccess) -> IoResult<File> {\n+        let mode = match mode {\n+            Open => rtio::Open,\n+            Append => rtio::Append,\n+            Truncate => rtio::Truncate,\n+        };\n+        let access = match access {\n+            Read => rtio::Read,\n+            Write => rtio::Write,\n+            ReadWrite => rtio::ReadWrite,\n+        };\n         LocalIo::maybe_raise(|io| {\n             io.fs_open(&path.to_c_str(), mode, access).map(|fd| {\n                 File {\n@@ -134,7 +147,7 @@ impl File {\n                     last_nread: -1\n                 }\n             })\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Attempts to open a file in read-only mode. This function is equivalent to\n@@ -184,15 +197,15 @@ impl File {\n     /// device. This will flush any internal buffers necessary to perform this\n     /// operation.\n     pub fn fsync(&mut self) -> IoResult<()> {\n-        self.fd.fsync()\n+        self.fd.fsync().map_err(IoError::from_rtio_error)\n     }\n \n     /// This function is similar to `fsync`, except that it may not synchronize\n     /// file metadata to the filesystem. This is intended for use case which\n     /// must synchronize content, but don't need the metadata on disk. The goal\n     /// of this method is to reduce disk operations.\n     pub fn datasync(&mut self) -> IoResult<()> {\n-        self.fd.datasync()\n+        self.fd.datasync().map_err(IoError::from_rtio_error)\n     }\n \n     /// Either truncates or extends the underlying file, updating the size of\n@@ -204,7 +217,7 @@ impl File {\n     /// will be extended to `size` and have all of the intermediate data filled\n     /// in with 0s.\n     pub fn truncate(&mut self, size: i64) -> IoResult<()> {\n-        self.fd.truncate(size)\n+        self.fd.truncate(size).map_err(IoError::from_rtio_error)\n     }\n \n     /// Tests whether this stream has reached EOF.\n@@ -217,7 +230,10 @@ impl File {\n \n     /// Queries information about the underlying file.\n     pub fn stat(&mut self) -> IoResult<FileStat> {\n-        self.fd.fstat()\n+        match self.fd.fstat() {\n+            Ok(s) => Ok(from_rtio(s)),\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n }\n \n@@ -243,7 +259,9 @@ impl File {\n /// user lacks permissions to remove the file, or if some other filesystem-level\n /// error occurs.\n pub fn unlink(path: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_unlink(&path.to_c_str()))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_unlink(&path.to_c_str())\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -268,9 +286,10 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n /// to perform a `stat` call on the given path or if there is no entry in the\n /// filesystem at the provided path.\n pub fn stat(path: &Path) -> IoResult<FileStat> {\n-    LocalIo::maybe_raise(|io| {\n-        io.fs_stat(&path.to_c_str())\n-    })\n+    match LocalIo::maybe_raise(|io| io.fs_stat(&path.to_c_str())) {\n+        Ok(s) => Ok(from_rtio(s)),\n+        Err(e) => Err(IoError::from_rtio_error(e)),\n+    }\n }\n \n /// Perform the same operation as the `stat` function, except that this\n@@ -282,9 +301,46 @@ pub fn stat(path: &Path) -> IoResult<FileStat> {\n ///\n /// See `stat`\n pub fn lstat(path: &Path) -> IoResult<FileStat> {\n-    LocalIo::maybe_raise(|io| {\n-        io.fs_lstat(&path.to_c_str())\n-    })\n+    match LocalIo::maybe_raise(|io| io.fs_lstat(&path.to_c_str())) {\n+        Ok(s) => Ok(from_rtio(s)),\n+        Err(e) => Err(IoError::from_rtio_error(e)),\n+    }\n+}\n+\n+fn from_rtio(s: rtio::FileStat) -> FileStat {\n+    let rtio::FileStat {\n+        size, kind, perm, created, modified,\n+        accessed, device, inode, rdev,\n+        nlink, uid, gid, blksize, blocks, flags, gen\n+    } = s;\n+\n+    FileStat {\n+        size: size,\n+        kind: match (kind as libc::c_int) & libc::S_IFMT {\n+            libc::S_IFREG => io::TypeFile,\n+            libc::S_IFDIR => io::TypeDirectory,\n+            libc::S_IFIFO => io::TypeNamedPipe,\n+            libc::S_IFBLK => io::TypeBlockSpecial,\n+            libc::S_IFLNK => io::TypeSymlink,\n+            _ => io::TypeUnknown,\n+        },\n+        perm: FilePermission::from_bits_truncate(perm as u32),\n+        created: created,\n+        modified: modified,\n+        accessed: accessed,\n+        unstable: UnstableFileStat {\n+            device: device,\n+            inode: inode,\n+            rdev: rdev,\n+            nlink: nlink,\n+            uid: uid,\n+            gid: gid,\n+            blksize: blksize,\n+            blocks: blocks,\n+            flags: flags,\n+            gen: gen,\n+        },\n+    }\n }\n \n /// Rename a file or directory to a new name.\n@@ -304,7 +360,9 @@ pub fn lstat(path: &Path) -> IoResult<FileStat> {\n /// permissions to view the contents, or if some other intermittent I/O error\n /// occurs.\n pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_rename(&from.to_c_str(), &to.to_c_str()))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_rename(&from.to_c_str(), &to.to_c_str())\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Copies the contents of one file to another. This function will also\n@@ -382,25 +440,33 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n /// Some possible error situations are not having the permission to\n /// change the attributes of a file or the file not existing.\n pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_chmod(&path.to_c_str(), mode))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_chmod(&path.to_c_str(), mode.bits() as uint)\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Change the user and group owners of a file at the specified path.\n pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_chown(&path.to_c_str(), uid, gid))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_chown(&path.to_c_str(), uid, gid)\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Creates a new hard link on the filesystem. The `dst` path will be a\n /// link pointing to the `src` path. Note that systems often require these\n /// two paths to both be located on the same filesystem.\n pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_link(&src.to_c_str(), &dst.to_c_str()))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_link(&src.to_c_str(), &dst.to_c_str())\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n /// symlink pointing to the `src` path.\n pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_symlink(&src.to_c_str(), &dst.to_c_str()))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_symlink(&src.to_c_str(), &dst.to_c_str())\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Reads a symlink, returning the file that the symlink points to.\n@@ -410,7 +476,9 @@ pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n /// This function will return an error on failure. Failure conditions include\n /// reading a file that does not exist or reading a file which is not a symlink.\n pub fn readlink(path: &Path) -> IoResult<Path> {\n-    LocalIo::maybe_raise(|io| io.fs_readlink(&path.to_c_str()))\n+    LocalIo::maybe_raise(|io| {\n+        Ok(Path::new(try!(io.fs_readlink(&path.to_c_str()))))\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Create a new, empty directory at the provided path\n@@ -431,7 +499,9 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n /// This call will return an error if the user lacks permissions to make a new\n /// directory at the provided path, or if the directory already exists.\n pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_mkdir(&path.to_c_str(), mode))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_mkdir(&path.to_c_str(), mode.bits() as uint)\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Remove an existing, empty directory\n@@ -451,7 +521,9 @@ pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n /// This call will return an error if the user lacks permissions to remove the\n /// directory at the provided path, or if the directory isn't empty.\n pub fn rmdir(path: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_rmdir(&path.to_c_str()))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_rmdir(&path.to_c_str())\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Retrieve a vector containing all entries within a provided directory\n@@ -487,8 +559,10 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n /// file\n pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n     LocalIo::maybe_raise(|io| {\n-        io.fs_readdir(&path.to_c_str(), 0)\n-    })\n+        Ok(try!(io.fs_readdir(&path.to_c_str(), 0)).move_iter().map(|a| {\n+            Path::new(a)\n+        }).collect())\n+    }).map_err(IoError::from_rtio_error)\n }\n \n /// Returns an iterator which will recursively walk the directory structure\n@@ -612,7 +686,9 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n /// be in milliseconds.\n // FIXME(#10301) these arguments should not be u64\n pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| io.fs_utime(&path.to_c_str(), atime, mtime))\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_utime(&path.to_c_str(), atime, mtime)\n+    }).map_err(IoError::from_rtio_error)\n }\n \n impl Reader for File {\n@@ -625,28 +701,35 @@ impl Reader for File {\n                     _ => Ok(read as uint)\n                 }\n             },\n-            Err(e) => Err(e),\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n         }\n     }\n }\n \n impl Writer for File {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.fd.write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.fd.write(buf).map_err(IoError::from_rtio_error)\n+    }\n }\n \n impl Seek for File {\n     fn tell(&self) -> IoResult<u64> {\n-        self.fd.tell()\n+        self.fd.tell().map_err(IoError::from_rtio_error)\n     }\n \n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n+        let style = match style {\n+            SeekSet => rtio::SeekSet,\n+            SeekCur => rtio::SeekCur,\n+            SeekEnd => rtio::SeekEnd,\n+        };\n         match self.fd.seek(pos, style) {\n             Ok(_) => {\n                 // successful seek resets EOF indicator\n                 self.last_nread = -1;\n                 Ok(())\n             }\n-            Err(e) => Err(e),\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n         }\n     }\n }"}, {"sha": "c72cc0ded9bc3ca7c5f0210de3de15f75c394302", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -225,6 +225,7 @@ use option::{Option, Some, None};\n use os;\n use owned::Box;\n use result::{Ok, Err, Result};\n+use rt::rtio;\n use slice::{Vector, MutableVector, ImmutableVector};\n use str::{StrSlice, StrAllocating};\n use str;\n@@ -312,7 +313,8 @@ impl IoError {\n                 libc::ERROR_INVALID_NAME => (InvalidInput, \"invalid file name\"),\n                 libc::WSAECONNREFUSED => (ConnectionRefused, \"connection refused\"),\n                 libc::WSAECONNRESET => (ConnectionReset, \"connection reset\"),\n-                libc::WSAEACCES => (PermissionDenied, \"permission denied\"),\n+                libc::ERROR_ACCESS_DENIED | libc::WSAEACCES =>\n+                    (PermissionDenied, \"permission denied\"),\n                 libc::WSAEWOULDBLOCK => {\n                     (ResourceUnavailable, \"resource temporarily unavailable\")\n                 }\n@@ -323,6 +325,14 @@ impl IoError {\n                 libc::ERROR_BROKEN_PIPE => (EndOfFile, \"the pipe has ended\"),\n                 libc::ERROR_OPERATION_ABORTED =>\n                     (TimedOut, \"operation timed out\"),\n+                libc::WSAEINVAL => (InvalidInput, \"invalid argument\"),\n+                libc::ERROR_CALL_NOT_IMPLEMENTED =>\n+                    (IoUnavailable, \"function not implemented\"),\n+                libc::ERROR_INVALID_HANDLE =>\n+                    (MismatchedFileTypeForOperation,\n+                     \"invalid handle provided to function\"),\n+                libc::ERROR_NOTHING_TO_TERMINATE =>\n+                    (InvalidInput, \"no process to kill\"),\n \n                 // libuv maps this error code to EISDIR. we do too. if it is found\n                 // to be incorrect, we can add in some more machinery to only\n@@ -351,9 +361,17 @@ impl IoError {\n                 libc::EADDRINUSE => (ConnectionRefused, \"address in use\"),\n                 libc::ENOENT => (FileNotFound, \"no such file or directory\"),\n                 libc::EISDIR => (InvalidInput, \"illegal operation on a directory\"),\n-\n-                // These two constants can have the same value on some systems, but\n-                // different values on others, so we can't use a match clause\n+                libc::ENOSYS => (IoUnavailable, \"function not implemented\"),\n+                libc::EINVAL => (InvalidInput, \"invalid argument\"),\n+                libc::ENOTTY =>\n+                    (MismatchedFileTypeForOperation,\n+                     \"file descriptor is not a TTY\"),\n+                libc::ETIMEDOUT => (TimedOut, \"operation timed out\"),\n+                libc::ECANCELED => (TimedOut, \"operation aborted\"),\n+\n+                // These two constants can have the same value on some systems,\n+                // but different values on others, so we can't use a match\n+                // clause\n                 x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n                     (ResourceUnavailable, \"resource temporarily unavailable\"),\n \n@@ -382,6 +400,17 @@ impl IoError {\n     pub fn last_error() -> IoError {\n         IoError::from_errno(os::errno() as uint, true)\n     }\n+\n+    fn from_rtio_error(err: rtio::IoError) -> IoError {\n+        let rtio::IoError { code, extra, detail } = err;\n+        let mut ioerr = IoError::from_errno(code, false);\n+        ioerr.detail = detail;\n+        ioerr.kind = match ioerr.kind {\n+            TimedOut if extra > 0 => ShortWrite(extra),\n+            k => k,\n+        };\n+        return ioerr;\n+    }\n }\n \n impl fmt::Show for IoError {"}, {"sha": "8d5fd2b99fd7b6e2fdff9997ffe3bb8f0a27a722", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -20,10 +20,12 @@ getaddrinfo()\n #![allow(missing_doc)]\n \n use iter::Iterator;\n-use io::IoResult;\n+use io::{IoResult, IoError};\n use io::net::ip::{SocketAddr, IpAddr};\n use option::{Option, Some, None};\n+use result::{Ok, Err};\n use rt::rtio::{IoFactory, LocalIo};\n+use rt::rtio;\n use vec::Vec;\n \n /// Hints to the types of sockets that are desired when looking up hosts\n@@ -89,9 +91,34 @@ pub fn get_host_addresses(host: &str) -> IoResult<Vec<IpAddr>> {\n ///\n /// FIXME: this is not public because the `Hint` structure is not ready for public\n ///      consumption just yet.\n+#[allow(unused_variable)]\n fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n           -> IoResult<Vec<Info>> {\n-    LocalIo::maybe_raise(|io| io.get_host_addresses(hostname, servname, hint))\n+    let hint = hint.map(|Hint { family, socktype, protocol, flags }| {\n+        rtio::AddrinfoHint {\n+            family: family,\n+            socktype: 0, // FIXME: this should use the above variable\n+            protocol: 0, // FIXME: this should use the above variable\n+            flags: flags,\n+        }\n+    });\n+    match LocalIo::maybe_raise(|io| {\n+        io.get_host_addresses(hostname, servname, hint)\n+    }) {\n+        Ok(v) => Ok(v.move_iter().map(|info| {\n+            Info {\n+                address: SocketAddr {\n+                    ip: super::from_rtio(info.address.ip),\n+                    port: info.address.port,\n+                },\n+                family: info.family,\n+                socktype: None, // FIXME: this should use the above variable\n+                protocol: None, // FIXME: this should use the above variable\n+                flags: info.flags,\n+            }\n+        }).collect()),\n+        Err(e) => Err(IoError::from_rtio_error(e)),\n+    }\n }\n \n // Ignored on android since we cannot give tcp/ip"}, {"sha": "54af83462eed6dd35a3c8272f42ed0b41164e625", "filename": "src/libstd/io/net/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fmod.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -10,6 +10,9 @@\n \n //! Networking I/O\n \n+use rt::rtio;\n+use self::ip::{Ipv4Addr, Ipv6Addr, IpAddr};\n+\n pub use self::addrinfo::get_host_addresses;\n \n pub mod addrinfo;\n@@ -18,3 +21,21 @@ pub mod udp;\n pub mod ip;\n // FIXME(#12093) - this should not be called unix\n pub mod unix;\n+\n+fn to_rtio(ip: IpAddr) -> rtio::IpAddr {\n+    match ip {\n+        Ipv4Addr(a, b, c, d) => rtio::Ipv4Addr(a, b, c, d),\n+        Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+            rtio::Ipv6Addr(a, b, c, d, e, f, g, h)\n+        }\n+    }\n+}\n+\n+fn from_rtio(ip: rtio::IpAddr) -> IpAddr {\n+    match ip {\n+        rtio::Ipv4Addr(a, b, c, d) => Ipv4Addr(a, b, c, d),\n+        rtio::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+            Ipv6Addr(a, b, c, d, e, f, g, h)\n+        }\n+    }\n+}"}, {"sha": "6c773467553d2f055d46a744cc3a251521bd1413", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 57, "deletions": 21, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -32,6 +32,7 @@ use option::{None, Some, Option};\n use owned::Box;\n use rt::rtio::{IoFactory, LocalIo, RtioSocket, RtioTcpListener};\n use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n+use rt::rtio;\n \n /// A structure which represents a TCP stream between a local socket and a\n /// remote socket.\n@@ -67,22 +68,22 @@ impl TcpStream {\n             Some(addr) => vec!(addr),\n             None => try!(get_host_addresses(host))\n         };\n-        let mut err = IoError{\n+        let mut err = IoError {\n             kind: ConnectionFailed,\n             desc: \"no addresses found for hostname\",\n             detail: None\n         };\n-        for address in addresses.iter() {\n-            let socket_addr = SocketAddr{ip: *address, port: port};\n+        for addr in addresses.iter() {\n+            let addr = rtio::SocketAddr{ ip: super::to_rtio(*addr), port: port };\n             let result = LocalIo::maybe_raise(|io| {\n-                io.tcp_connect(socket_addr, None).map(TcpStream::new)\n+                io.tcp_connect(addr, None).map(TcpStream::new)\n             });\n             match result {\n                 Ok(stream) => {\n                     return Ok(stream)\n                 }\n                 Err(connect_err) => {\n-                    err = connect_err\n+                    err = IoError::from_rtio_error(connect_err)\n                 }\n             }\n         }\n@@ -101,19 +102,31 @@ impl TcpStream {\n     #[experimental = \"the timeout argument may eventually change types\"]\n     pub fn connect_timeout(addr: SocketAddr,\n                            timeout_ms: u64) -> IoResult<TcpStream> {\n+        let SocketAddr { ip, port } = addr;\n+        let addr = rtio::SocketAddr { ip: super::to_rtio(ip), port: port };\n         LocalIo::maybe_raise(|io| {\n             io.tcp_connect(addr, Some(timeout_ms)).map(TcpStream::new)\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Returns the socket address of the remote peer of this TCP connection.\n     pub fn peer_name(&mut self) -> IoResult<SocketAddr> {\n-        self.obj.peer_name()\n+        match self.obj.peer_name() {\n+            Ok(rtio::SocketAddr { ip, port }) => {\n+                Ok(SocketAddr { ip: super::from_rtio(ip), port: port })\n+            }\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n \n     /// Returns the socket address of the local half of this TCP connection.\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        self.obj.socket_name()\n+        match self.obj.socket_name() {\n+            Ok(rtio::SocketAddr { ip, port }) => {\n+                Ok(SocketAddr { ip: super::from_rtio(ip), port: port })\n+            }\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n \n     /// Sets the nodelay flag on this connection to the boolean specified\n@@ -123,7 +136,7 @@ impl TcpStream {\n             self.obj.nodelay()\n         } else {\n             self.obj.control_congestion()\n-        }\n+        }.map_err(IoError::from_rtio_error)\n     }\n \n     /// Sets the keepalive timeout to the timeout specified.\n@@ -136,7 +149,7 @@ impl TcpStream {\n         match delay_in_seconds {\n             Some(i) => self.obj.keepalive(i),\n             None => self.obj.letdie(),\n-        }\n+        }.map_err(IoError::from_rtio_error)\n     }\n \n     /// Closes the reading half of this connection.\n@@ -168,7 +181,9 @@ impl TcpStream {\n     ///\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n-    pub fn close_read(&mut self) -> IoResult<()> { self.obj.close_read() }\n+    pub fn close_read(&mut self) -> IoResult<()> {\n+        self.obj.close_read().map_err(IoError::from_rtio_error)\n+    }\n \n     /// Closes the writing half of this connection.\n     ///\n@@ -177,7 +192,9 @@ impl TcpStream {\n     ///\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n-    pub fn close_write(&mut self) -> IoResult<()> { self.obj.close_write() }\n+    pub fn close_write(&mut self) -> IoResult<()> {\n+        self.obj.close_write().map_err(IoError::from_rtio_error)\n+    }\n \n     /// Sets a timeout, in milliseconds, for blocking operations on this stream.\n     ///\n@@ -261,11 +278,15 @@ impl Clone for TcpStream {\n }\n \n impl Reader for TcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        self.obj.read(buf).map_err(IoError::from_rtio_error)\n+    }\n }\n \n impl Writer for TcpStream {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.obj.write(buf).map_err(IoError::from_rtio_error)\n+    }\n }\n \n /// A structure representing a socket server. This listener is used to create a\n@@ -319,10 +340,13 @@ impl TcpListener {\n     pub fn bind(addr: &str, port: u16) -> IoResult<TcpListener> {\n         match FromStr::from_str(addr) {\n             Some(ip) => {\n-                let socket_addr = SocketAddr{ip: ip, port: port};\n+                let addr = rtio::SocketAddr{\n+                    ip: super::to_rtio(ip),\n+                    port: port,\n+                };\n                 LocalIo::maybe_raise(|io| {\n-                    io.tcp_bind(socket_addr).map(|l| TcpListener { obj: l })\n-                })\n+                    io.tcp_bind(addr).map(|l| TcpListener { obj: l })\n+                }).map_err(IoError::from_rtio_error)\n             }\n             None => {\n                 Err(IoError{\n@@ -336,13 +360,21 @@ impl TcpListener {\n \n     /// Returns the local socket address of this listener.\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        self.obj.socket_name()\n+        match self.obj.socket_name() {\n+            Ok(rtio::SocketAddr { ip, port }) => {\n+                Ok(SocketAddr { ip: super::from_rtio(ip), port: port })\n+            }\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n }\n \n impl Listener<TcpStream, TcpAcceptor> for TcpListener {\n     fn listen(self) -> IoResult<TcpAcceptor> {\n-        self.obj.listen().map(|acceptor| TcpAcceptor { obj: acceptor })\n+        match self.obj.listen() {\n+            Ok(acceptor) => Ok(TcpAcceptor { obj: acceptor }),\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n }\n \n@@ -403,7 +435,10 @@ impl TcpAcceptor {\n \n impl Acceptor<TcpStream> for TcpAcceptor {\n     fn accept(&mut self) -> IoResult<TcpStream> {\n-        self.obj.accept().map(TcpStream::new)\n+        match self.obj.accept(){\n+            Ok(s) => Ok(TcpStream::new(s)),\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n }\n \n@@ -947,7 +982,8 @@ mod test {\n         match TcpListener::bind(ip_str.as_slice(), port).listen() {\n             Ok(..) => fail!(),\n             Err(e) => {\n-                assert!(e.kind == ConnectionRefused || e.kind == OtherIoError);\n+                assert!(e.kind == ConnectionRefused || e.kind == OtherIoError,\n+                        \"unknown error: {} {}\", e, e.kind);\n             }\n         }\n     })"}, {"sha": "538bba36958115447410a84c59f2ed5e274068d8", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -17,12 +17,13 @@\n \n use clone::Clone;\n use io::net::ip::{SocketAddr, IpAddr};\n-use io::{Reader, Writer, IoResult};\n+use io::{Reader, Writer, IoResult, IoError};\n use kinds::Send;\n use owned::Box;\n use option::Option;\n use result::{Ok, Err};\n use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, LocalIo};\n+use rt::rtio;\n \n /// A User Datagram Protocol socket.\n ///\n@@ -62,22 +63,32 @@ pub struct UdpSocket {\n impl UdpSocket {\n     /// Creates a UDP socket from the given socket address.\n     pub fn bind(addr: SocketAddr) -> IoResult<UdpSocket> {\n+        let SocketAddr { ip, port } = addr;\n         LocalIo::maybe_raise(|io| {\n+            let addr = rtio::SocketAddr { ip: super::to_rtio(ip), port: port };\n             io.udp_bind(addr).map(|s| UdpSocket { obj: s })\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Receives data from the socket. On success, returns the number of bytes\n     /// read and the address from whence the data came.\n     pub fn recvfrom(&mut self, buf: &mut [u8])\n                     -> IoResult<(uint, SocketAddr)> {\n-        self.obj.recvfrom(buf)\n+        match self.obj.recvfrom(buf) {\n+            Ok((amt, rtio::SocketAddr { ip, port })) => {\n+                Ok((amt, SocketAddr { ip: super::from_rtio(ip), port: port }))\n+            }\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n \n     /// Sends data on the socket to the given address. Returns nothing on\n     /// success.\n     pub fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n-        self.obj.sendto(buf, dst)\n+        self.obj.sendto(buf, rtio::SocketAddr {\n+            ip: super::to_rtio(dst.ip),\n+            port: dst.port,\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Creates a `UdpStream`, which allows use of the `Reader` and `Writer`\n@@ -95,19 +106,24 @@ impl UdpSocket {\n \n     /// Returns the socket address that this socket was created from.\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        self.obj.socket_name()\n+        match self.obj.socket_name() {\n+            Ok(a) => Ok(SocketAddr { ip: super::from_rtio(a.ip), port: a.port }),\n+            Err(e) => Err(IoError::from_rtio_error(e))\n+        }\n     }\n \n     /// Joins a multicast IP address (becomes a member of it)\n     #[experimental]\n     pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        self.obj.join_multicast(multi)\n+        let e = self.obj.join_multicast(super::to_rtio(multi));\n+        e.map_err(IoError::from_rtio_error)\n     }\n \n     /// Leaves a multicast IP address (drops membership from it)\n     #[experimental]\n     pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        self.obj.leave_multicast(multi)\n+        let e = self.obj.leave_multicast(super::to_rtio(multi));\n+        e.map_err(IoError::from_rtio_error)\n     }\n \n     /// Set the multicast loop flag to the specified value\n@@ -119,19 +135,19 @@ impl UdpSocket {\n             self.obj.loop_multicast_locally()\n         } else {\n             self.obj.dont_loop_multicast_locally()\n-        }\n+        }.map_err(IoError::from_rtio_error)\n     }\n \n     /// Sets the multicast TTL\n     #[experimental]\n     pub fn set_multicast_ttl(&mut self, ttl: int) -> IoResult<()> {\n-        self.obj.multicast_time_to_live(ttl)\n+        self.obj.multicast_time_to_live(ttl).map_err(IoError::from_rtio_error)\n     }\n \n     /// Sets this socket's TTL\n     #[experimental]\n     pub fn set_ttl(&mut self, ttl: int) -> IoResult<()> {\n-        self.obj.time_to_live(ttl)\n+        self.obj.time_to_live(ttl).map_err(IoError::from_rtio_error)\n     }\n \n     /// Sets the broadcast flag on or off\n@@ -141,7 +157,7 @@ impl UdpSocket {\n             self.obj.hear_broadcasts()\n         } else {\n             self.obj.ignore_broadcasts()\n-        }\n+        }.map_err(IoError::from_rtio_error)\n     }\n \n     /// Sets the read/write timeout for this socket."}, {"sha": "9715a821e4fcba5d17704f83c4e5de5dcdea4977", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -28,7 +28,7 @@ use prelude::*;\n \n use c_str::ToCStr;\n use clone::Clone;\n-use io::{Listener, Acceptor, Reader, Writer, IoResult};\n+use io::{Listener, Acceptor, Reader, Writer, IoResult, IoError};\n use kinds::Send;\n use owned::Box;\n use rt::rtio::{IoFactory, LocalIo, RtioUnixListener};\n@@ -58,7 +58,7 @@ impl UnixStream {\n     pub fn connect<P: ToCStr>(path: &P) -> IoResult<UnixStream> {\n         LocalIo::maybe_raise(|io| {\n             io.unix_connect(&path.to_c_str(), None).map(|p| UnixStream { obj: p })\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Connect to a pipe named by `path`, timing out if the specified number of\n@@ -72,7 +72,7 @@ impl UnixStream {\n         LocalIo::maybe_raise(|io| {\n             let s = io.unix_connect(&path.to_c_str(), Some(timeout_ms));\n             s.map(|p| UnixStream { obj: p })\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n \n@@ -83,7 +83,9 @@ impl UnixStream {\n     ///\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n-    pub fn close_read(&mut self) -> IoResult<()> { self.obj.close_read() }\n+    pub fn close_read(&mut self) -> IoResult<()> {\n+        self.obj.close_read().map_err(IoError::from_rtio_error)\n+    }\n \n     /// Closes the writing half of this connection.\n     ///\n@@ -92,7 +94,9 @@ impl UnixStream {\n     ///\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n-    pub fn close_write(&mut self) -> IoResult<()> { self.obj.close_write() }\n+    pub fn close_write(&mut self) -> IoResult<()> {\n+        self.obj.close_write().map_err(IoError::from_rtio_error)\n+    }\n \n     /// Sets the read/write timeout for this socket.\n     ///\n@@ -126,11 +130,15 @@ impl Clone for UnixStream {\n }\n \n impl Reader for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        self.obj.read(buf).map_err(IoError::from_rtio_error)\n+    }\n }\n \n impl Writer for UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.obj.write(buf).map_err(IoError::from_rtio_error)\n+    }\n }\n \n /// A value that can listen for incoming named pipe connection requests.\n@@ -165,13 +173,15 @@ impl UnixListener {\n     pub fn bind<P: ToCStr>(path: &P) -> IoResult<UnixListener> {\n         LocalIo::maybe_raise(|io| {\n             io.unix_bind(&path.to_c_str()).map(|s| UnixListener { obj: s })\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n }\n \n impl Listener<UnixStream, UnixAcceptor> for UnixListener {\n     fn listen(self) -> IoResult<UnixAcceptor> {\n-        self.obj.listen().map(|obj| UnixAcceptor { obj: obj })\n+        self.obj.listen().map(|obj| {\n+            UnixAcceptor { obj: obj }\n+        }).map_err(IoError::from_rtio_error)\n     }\n }\n \n@@ -202,7 +212,9 @@ impl UnixAcceptor {\n \n impl Acceptor<UnixStream> for UnixAcceptor {\n     fn accept(&mut self) -> IoResult<UnixStream> {\n-        self.obj.accept().map(|s| UnixStream { obj: s })\n+        self.obj.accept().map(|s| {\n+            UnixStream { obj: s }\n+        }).map_err(IoError::from_rtio_error)\n     }\n }\n "}, {"sha": "11bb27573c29afece830187f28e270c62c839a28", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -16,7 +16,7 @@\n #![allow(missing_doc)]\n \n use prelude::*;\n-use io::IoResult;\n+use io::{IoResult, IoError};\n use libc;\n use owned::Box;\n use rt::rtio::{RtioPipe, LocalIo};\n@@ -51,7 +51,7 @@ impl PipeStream {\n     pub fn open(fd: libc::c_int) -> IoResult<PipeStream> {\n         LocalIo::maybe_raise(|io| {\n             io.pipe_open(fd).map(|obj| PipeStream { obj: obj })\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     #[doc(hidden)]\n@@ -67,11 +67,15 @@ impl Clone for PipeStream {\n }\n \n impl Reader for PipeStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        self.obj.read(buf).map_err(IoError::from_rtio_error)\n+    }\n }\n \n impl Writer for PipeStream {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.obj.write(buf).map_err(IoError::from_rtio_error)\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "059286339a6fa2db624ed892dc33b838737e4099", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -16,12 +16,13 @@ use prelude::*;\n \n use str;\n use fmt;\n-use io::IoResult;\n+use io::{IoResult, IoError};\n use io;\n use libc;\n use mem;\n use owned::Box;\n use rt::rtio::{RtioProcess, ProcessConfig, IoFactory, LocalIo};\n+use rt::rtio;\n use c_str::CString;\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n@@ -232,16 +233,25 @@ impl Command {\n \n     /// Executes the command as a child process, which is returned.\n     pub fn spawn(&self) -> IoResult<Process> {\n+        fn to_rtio(p: StdioContainer) -> rtio::StdioContainer {\n+            match p {\n+                Ignored => rtio::Ignored,\n+                InheritFd(fd) => rtio::InheritFd(fd),\n+                CreatePipe(a, b) => rtio::CreatePipe(a, b),\n+            }\n+        }\n+        let extra_io: Vec<rtio::StdioContainer> =\n+            self.extra_io.iter().map(|x| to_rtio(*x)).collect();\n         LocalIo::maybe_raise(|io| {\n             let cfg = ProcessConfig {\n                 program: &self.program,\n                 args: self.args.as_slice(),\n                 env: self.env.as_ref().map(|env| env.as_slice()),\n                 cwd: self.cwd.as_ref(),\n-                stdin: self.stdin,\n-                stdout: self.stdout,\n-                stderr: self.stderr,\n-                extra_io: self.extra_io.as_slice(),\n+                stdin: to_rtio(self.stdin),\n+                stdout: to_rtio(self.stdout),\n+                stderr: to_rtio(self.stderr),\n+                extra_io: extra_io.as_slice(),\n                 uid: self.uid,\n                 gid: self.gid,\n                 detach: self.detach,\n@@ -258,7 +268,7 @@ impl Command {\n                     extra_io: io.collect(),\n                 }\n             })\n-        })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Executes the command as a child process, waiting for it to finish and\n@@ -393,7 +403,9 @@ impl Process {\n     /// be successfully delivered if the child has exited, but not yet been\n     /// reaped.\n     pub fn kill(id: libc::pid_t, signal: int) -> IoResult<()> {\n-        LocalIo::maybe_raise(|io| io.kill(id, signal))\n+        LocalIo::maybe_raise(|io| {\n+            io.kill(id, signal)\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Returns the process id of this child process\n@@ -415,7 +427,7 @@ impl Process {\n     ///\n     /// If the signal delivery fails, the corresponding error is returned.\n     pub fn signal(&mut self, signal: int) -> IoResult<()> {\n-        self.handle.kill(signal)\n+        self.handle.kill(signal).map_err(IoError::from_rtio_error)\n     }\n \n     /// Sends a signal to this child requesting that it exits. This is\n@@ -442,7 +454,11 @@ impl Process {\n     /// `set_timeout` and the timeout expires before the child exits.\n     pub fn wait(&mut self) -> IoResult<ProcessExit> {\n         drop(self.stdin.take());\n-        self.handle.wait()\n+        match self.handle.wait() {\n+            Ok(rtio::ExitSignal(s)) => Ok(ExitSignal(s)),\n+            Ok(rtio::ExitStatus(s)) => Ok(ExitStatus(s)),\n+            Err(e) => Err(IoError::from_rtio_error(e)),\n+        }\n     }\n \n     /// Sets a timeout, in milliseconds, for future calls to wait()."}, {"sha": "598a8667d41e93a4d4e4fab53a3e702c55b717b9", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -28,7 +28,7 @@ use mem::drop;\n use option::{Some, None};\n use owned::Box;\n use result::{Ok, Err};\n-use rt::rtio::{IoFactory, LocalIo, RtioSignal};\n+use rt::rtio::{IoFactory, LocalIo, RtioSignal, Callback};\n use slice::ImmutableVector;\n use vec::Vec;\n \n@@ -122,17 +122,28 @@ impl Listener {\n     /// If this function fails to register a signal handler, then an error will\n     /// be returned.\n     pub fn register(&mut self, signum: Signum) -> io::IoResult<()> {\n+        struct SignalCallback {\n+            signum: Signum,\n+            tx: Sender<Signum>,\n+        }\n+        impl Callback for SignalCallback {\n+            fn call(&mut self) { self.tx.send(self.signum) }\n+        }\n+\n         if self.handles.iter().any(|&(sig, _)| sig == signum) {\n             return Ok(()); // self is already listening to signum, so succeed\n         }\n         match LocalIo::maybe_raise(|io| {\n-            io.signal(signum, self.tx.clone())\n+            io.signal(signum as int, box SignalCallback {\n+                signum: signum,\n+                tx: self.tx.clone(),\n+            })\n         }) {\n             Ok(handle) => {\n                 self.handles.push((signum, handle));\n                 Ok(())\n             }\n-            Err(e) => Err(e)\n+            Err(e) => Err(io::IoError::from_rtio_error(e))\n         }\n     }\n "}, {"sha": "5db09076c98e0316e67ecee567d5861e433bbff7", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 36, "deletions": 64, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -27,20 +27,19 @@ out.write(bytes!(\"Hello, world!\"));\n \n */\n \n+use failure::local_stderr;\n use fmt;\n use io::{Reader, Writer, IoResult, IoError, OtherIoError,\n          standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n-use libc;\n use kinds::Send;\n-use mem::replace;\n+use libc;\n use option::{Option, Some, None};\n use owned::Box;\n-use prelude::drop;\n use result::{Ok, Err};\n use rt;\n use rt::local::Local;\n-use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n use rt::task::Task;\n+use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n use str::StrSlice;\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all\n@@ -82,9 +81,11 @@ fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n             Ok(tty) => f(TTY(tty)),\n             Err(_) => f(File(io.fs_from_raw_fd(fd, DontClose))),\n         })\n-    }).unwrap()\n+    }).map_err(IoError::from_rtio_error).unwrap()\n }\n \n+local_data_key!(local_stdout: Box<Writer:Send>)\n+\n /// Creates a new non-blocking handle to the stdin of the current process.\n ///\n /// The returned handled is buffered by default with a `BufferedReader`. If\n@@ -154,22 +155,6 @@ pub fn stderr_raw() -> StdWriter {\n     src(libc::STDERR_FILENO, false, |src| StdWriter { inner: src })\n }\n \n-fn reset_helper(w: Box<Writer:Send>,\n-                f: |&mut Task, Box<Writer:Send>| -> Option<Box<Writer:Send>>)\n-                -> Option<Box<Writer:Send>> {\n-    let mut t = Local::borrow(None::<Task>);\n-    // Be sure to flush any pending output from the writer\n-    match f(&mut *t, w) {\n-        Some(mut w) => {\n-            drop(t);\n-            // FIXME: is failing right here?\n-            w.flush().unwrap();\n-            Some(w)\n-        }\n-        None => None\n-    }\n-}\n-\n /// Resets the task-local stdout handle to the specified writer\n ///\n /// This will replace the current task's stdout handle, returning the old\n@@ -179,7 +164,10 @@ fn reset_helper(w: Box<Writer:Send>,\n /// Note that this does not need to be called for all new tasks; the default\n /// output handle is to the process's stdout stream.\n pub fn set_stdout(stdout: Box<Writer:Send>) -> Option<Box<Writer:Send>> {\n-    reset_helper(stdout, |t, w| replace(&mut t.stdout, Some(w)))\n+    local_stdout.replace(Some(stdout)).and_then(|mut s| {\n+        let _ = s.flush();\n+        Some(s)\n+    })\n }\n \n /// Resets the task-local stderr handle to the specified writer\n@@ -191,7 +179,10 @@ pub fn set_stdout(stdout: Box<Writer:Send>) -> Option<Box<Writer:Send>> {\n /// Note that this does not need to be called for all new tasks; the default\n /// output handle is to the process's stderr stream.\n pub fn set_stderr(stderr: Box<Writer:Send>) -> Option<Box<Writer:Send>> {\n-    reset_helper(stderr, |t, w| replace(&mut t.stderr, Some(w)))\n+    local_stderr.replace(Some(stderr)).and_then(|mut s| {\n+        let _ = s.flush();\n+        Some(s)\n+    })\n }\n \n // Helper to access the local task's stdout handle\n@@ -204,42 +195,18 @@ pub fn set_stderr(stderr: Box<Writer:Send>) -> Option<Box<Writer:Send>> {\n //          // io1 aliases io2\n //      })\n //  })\n-fn with_task_stdout(f: |&mut Writer| -> IoResult<()> ) {\n-    let task: Option<Box<Task>> = Local::try_take();\n-    let result = match task {\n-        Some(mut task) => {\n-            // Printing may run arbitrary code, so ensure that the task is in\n-            // TLS to allow all std services. Note that this means a print while\n-            // printing won't use the task's normal stdout handle, but this is\n-            // necessary to ensure safety (no aliasing).\n-            let mut my_stdout = task.stdout.take();\n-            Local::put(task);\n-\n-            if my_stdout.is_none() {\n-                my_stdout = Some(box stdout() as Box<Writer:Send>);\n-            }\n-            let ret = f(*my_stdout.get_mut_ref());\n-\n-            // Note that we need to be careful when putting the stdout handle\n-            // back into the task. If the handle was set to `Some` while\n-            // printing, then we can run aribitrary code when destroying the\n-            // previous handle. This means that the local task needs to be in\n-            // TLS while we do this.\n-            //\n-            // To protect against this, we do a little dance in which we\n-            // temporarily take the task, swap the handles, put the task in TLS,\n-            // and only then drop the previous handle.\n-            let prev = replace(&mut Local::borrow(None::<Task>).stdout, my_stdout);\n-            drop(prev);\n-            ret\n-        }\n-\n-        None => {\n-            let mut io = rt::Stdout;\n-            f(&mut io as &mut Writer)\n-        }\n+fn with_task_stdout(f: |&mut Writer| -> IoResult<()>) {\n+    let result = if Local::exists(None::<Task>) {\n+        let mut my_stdout = local_stdout.replace(None).unwrap_or_else(|| {\n+            box stdout() as Box<Writer:Send>\n+        });\n+        let result = f(my_stdout);\n+        local_stdout.replace(Some(my_stdout));\n+        result\n+    } else {\n+        let mut io = rt::Stdout;\n+        f(&mut io as &mut Writer)\n     };\n-\n     match result {\n         Ok(()) => {}\n         Err(e) => fail!(\"failed printing to stdout: {}\", e),\n@@ -311,7 +278,7 @@ impl Reader for StdReader {\n                 tty.read(buf)\n             },\n             File(ref mut file) => file.read(buf).map(|i| i as uint),\n-        };\n+        }.map_err(IoError::from_rtio_error);\n         match ret {\n             // When reading a piped stdin, libuv will return 0-length reads when\n             // stdin reaches EOF. For pretty much all other streams it will\n@@ -342,7 +309,9 @@ impl StdWriter {\n     /// connected to a TTY instance, or if querying the TTY instance fails.\n     pub fn winsize(&mut self) -> IoResult<(int, int)> {\n         match self.inner {\n-            TTY(ref mut tty) => tty.get_winsize(),\n+            TTY(ref mut tty) => {\n+                tty.get_winsize().map_err(IoError::from_rtio_error)\n+            }\n             File(..) => {\n                 Err(IoError {\n                     kind: OtherIoError,\n@@ -362,7 +331,9 @@ impl StdWriter {\n     /// connected to a TTY instance, or if querying the TTY instance fails.\n     pub fn set_raw(&mut self, raw: bool) -> IoResult<()> {\n         match self.inner {\n-            TTY(ref mut tty) => tty.set_raw(raw),\n+            TTY(ref mut tty) => {\n+                tty.set_raw(raw).map_err(IoError::from_rtio_error)\n+            }\n             File(..) => {\n                 Err(IoError {\n                     kind: OtherIoError,\n@@ -387,7 +358,7 @@ impl Writer for StdWriter {\n         match self.inner {\n             TTY(ref mut tty) => tty.write(buf),\n             File(ref mut file) => file.write(buf),\n-        }\n+        }.map_err(IoError::from_rtio_error)\n     }\n }\n \n@@ -413,12 +384,13 @@ mod tests {\n     })\n \n     iotest!(fn capture_stderr() {\n-        use io::{ChanReader, ChanWriter};\n+        use realstd::comm::channel;\n+        use realstd::io::{Writer, ChanReader, ChanWriter, Reader};\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n         spawn(proc() {\n-            set_stderr(box w);\n+            ::realstd::io::stdio::set_stderr(box w);\n             fail!(\"my special message\");\n         });\n         let s = r.read_to_str().unwrap();"}, {"sha": "78b8e55c65174419db0b87f0b26642e1edf4f2de", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -17,11 +17,11 @@ and create receivers which will receive notifications after a period of time.\n \n */\n \n-use comm::Receiver;\n-use io::IoResult;\n+use comm::{Receiver, Sender, channel};\n+use io::{IoResult, IoError};\n use kinds::Send;\n use owned::Box;\n-use rt::rtio::{IoFactory, LocalIo, RtioTimer};\n+use rt::rtio::{IoFactory, LocalIo, RtioTimer, Callback};\n \n /// A synchronous timer object\n ///\n@@ -67,6 +67,8 @@ pub struct Timer {\n     obj: Box<RtioTimer:Send>,\n }\n \n+struct TimerCallback { tx: Sender<()> }\n+\n /// Sleep the current task for `msecs` milliseconds.\n pub fn sleep(msecs: u64) {\n     let timer = Timer::new();\n@@ -80,7 +82,9 @@ impl Timer {\n     /// for a number of milliseconds, or to possibly create channels which will\n     /// get notified after an amount of time has passed.\n     pub fn new() -> IoResult<Timer> {\n-        LocalIo::maybe_raise(|io| io.timer_init().map(|t| Timer { obj: t }))\n+        LocalIo::maybe_raise(|io| {\n+            io.timer_init().map(|t| Timer { obj: t })\n+        }).map_err(IoError::from_rtio_error)\n     }\n \n     /// Blocks the current task for `msecs` milliseconds.\n@@ -99,7 +103,9 @@ impl Timer {\n     /// by this timer, and that the returned receiver will be invalidated once\n     /// the timer is destroyed (when it falls out of scope).\n     pub fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n-        self.obj.oneshot(msecs)\n+        let (tx, rx) = channel();\n+        self.obj.oneshot(msecs, box TimerCallback { tx: tx });\n+        return rx\n     }\n \n     /// Creates a receiver which will have a continuous stream of notifications\n@@ -112,7 +118,15 @@ impl Timer {\n     /// by this timer, and that the returned receiver will be invalidated once\n     /// the timer is destroyed (when it falls out of scope).\n     pub fn periodic(&mut self, msecs: u64) -> Receiver<()> {\n-        self.obj.period(msecs)\n+        let (tx, rx) = channel();\n+        self.obj.period(msecs, box TimerCallback { tx: tx });\n+        return rx\n+    }\n+}\n+\n+impl Callback for TimerCallback {\n+    fn call(&mut self) {\n+        let _ = self.tx.send_opt(());\n     }\n }\n "}, {"sha": "bac4d26b4e49a6e8ce114fd5ce816efd671c449b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -103,8 +103,8 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(macro_rules, globs, asm, managed_boxes, thread_local, link_args,\n-           linkage, default_type_params, phase, concat_idents, quad_precision_float)]\n+#![feature(macro_rules, globs, managed_boxes,\n+           linkage, default_type_params, phase)]\n \n // Don't link to std. We are std.\n #![no_std]\n@@ -123,9 +123,10 @@\n \n extern crate alloc;\n extern crate core;\n-extern crate libc;\n-extern crate core_rand = \"rand\";\n extern crate core_collections = \"collections\";\n+extern crate core_rand = \"rand\";\n+extern crate libc;\n+extern crate rustrt;\n \n // Make std testable by not duplicating lang items. See #2912\n #[cfg(test)] extern crate realstd = \"std\";\n@@ -168,6 +169,9 @@ pub use core_collections::str;\n pub use core_collections::string;\n pub use core_collections::vec;\n \n+pub use rustrt::c_str;\n+pub use rustrt::local_data;\n+\n // Run tests with libgreen instead of libnative.\n //\n // FIXME: This egregiously hacks around starting the test runner in a different\n@@ -231,19 +235,16 @@ pub mod collections;\n \n pub mod task;\n pub mod comm;\n-pub mod local_data;\n pub mod sync;\n \n \n /* Runtime and platform support */\n \n-pub mod c_str;\n pub mod c_vec;\n pub mod os;\n pub mod io;\n pub mod path;\n pub mod fmt;\n-pub mod cleanup;\n \n // Private APIs\n #[unstable]\n@@ -253,11 +254,7 @@ pub mod unstable;\n // but name resolution doesn't work without it being pub.\n #[unstable]\n pub mod rt;\n-\n-#[doc(hidden)]\n-pub fn issue_14344_workaround() { // FIXME #14344 force linkage to happen correctly\n-    libc::issue_14344_workaround();\n-}\n+mod failure;\n \n // A curious inner-module that's not exported that contains the binding\n // 'std' so that macro-expanded references to std::error and such"}, {"sha": "9a7e061c47282b260cc02b6ec79746e1a1c4d1fa", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -189,7 +189,7 @@ Accessing environment variables is not generally threadsafe.\n Serialize access through a global lock.\n */\n fn with_env_lock<T>(f: || -> T) -> T {\n-    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n     static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n "}, {"sha": "c892a73d9348433101e348968681400ee3b7ae96", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/e87e18064ece0d7eddb269b8211fb8fdf5efaa91/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87e18064ece0d7eddb269b8211fb8fdf5efaa91/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=e87e18064ece0d7eddb269b8211fb8fdf5efaa91", "patch": "@@ -1,74 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementation of running at_exit routines\n-//!\n-//! Documentation can be found on the `rt::at_exit` function.\n-\n-use iter::Iterator;\n-use kinds::Send;\n-use mem;\n-use option::{Some, None};\n-use owned::Box;\n-use ptr::RawPtr;\n-use slice::OwnedVector;\n-use unstable::sync::Exclusive;\n-use vec::Vec;\n-\n-type Queue = Exclusive<Vec<proc():Send>>;\n-\n-// You'll note that these variables are *not* atomic, and this is done on\n-// purpose. This module is designed to have init() called *once* in a\n-// single-task context, and then run() is called only once in another\n-// single-task context. As a result of this, only the `push` function is\n-// thread-safe, and it assumes that the `init` function has run previously.\n-static mut QUEUE: *mut Queue = 0 as *mut Queue;\n-static mut RUNNING: bool = false;\n-\n-pub fn init() {\n-    unsafe {\n-        rtassert!(!RUNNING);\n-        rtassert!(QUEUE.is_null());\n-        let state: Box<Queue> = box Exclusive::new(vec!());\n-        QUEUE = mem::transmute(state);\n-    }\n-}\n-\n-pub fn push(f: proc():Send) {\n-    unsafe {\n-        rtassert!(!RUNNING);\n-        rtassert!(!QUEUE.is_null());\n-        let state: &mut Queue = mem::transmute(QUEUE);\n-        let mut f = Some(f);\n-        state.with(|arr|  {\n-            arr.push(f.take_unwrap());\n-        });\n-    }\n-}\n-\n-pub fn run() {\n-    let vec = unsafe {\n-        rtassert!(!RUNNING);\n-        rtassert!(!QUEUE.is_null());\n-        RUNNING = true;\n-        let state: Box<Queue> = mem::transmute(QUEUE);\n-        QUEUE = 0 as *mut Queue;\n-        let mut vec = None;\n-        state.with(|arr| {\n-            vec = Some(mem::replace(arr, vec!()));\n-        });\n-        vec.take_unwrap()\n-    };\n-\n-\n-    for f in vec.move_iter() {\n-        f();\n-    }\n-}"}, {"sha": "766901fa04f32f663e559c16cda477b6ee2f9606", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 104, "deletions": 5, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -242,8 +242,7 @@ mod imp {\n     use mem;\n     use option::{Some, None, Option};\n     use result::{Ok, Err};\n-    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    use uw = rt::libunwind;\n+    use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n     struct Context<'a> {\n         idx: int,\n@@ -484,6 +483,106 @@ mod imp {\n         }\n         w.write(['\\n' as u8])\n     }\n+\n+    /// Unwind library interface used for backtraces\n+    ///\n+    /// Note that the native libraries come from librustrt, not this module.\n+    #[allow(non_camel_case_types)]\n+    #[allow(non_snake_case_functions)]\n+    mod uw {\n+        use libc;\n+\n+        #[repr(C)]\n+        pub enum _Unwind_Reason_Code {\n+            _URC_NO_REASON = 0,\n+            _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n+            _URC_FATAL_PHASE2_ERROR = 2,\n+            _URC_FATAL_PHASE1_ERROR = 3,\n+            _URC_NORMAL_STOP = 4,\n+            _URC_END_OF_STACK = 5,\n+            _URC_HANDLER_FOUND = 6,\n+            _URC_INSTALL_CONTEXT = 7,\n+            _URC_CONTINUE_UNWIND = 8,\n+            _URC_FAILURE = 9, // used only by ARM EABI\n+        }\n+\n+        pub enum _Unwind_Context {}\n+\n+        pub type _Unwind_Trace_Fn =\n+                extern fn(ctx: *_Unwind_Context,\n+                          arg: *libc::c_void) -> _Unwind_Reason_Code;\n+\n+        extern {\n+            pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n+                                     trace_argument: *libc::c_void)\n+                        -> _Unwind_Reason_Code;\n+\n+            #[cfg(not(target_os = \"android\"),\n+                  not(target_os = \"linux\", target_arch = \"arm\"))]\n+            pub fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t;\n+            #[cfg(not(target_os = \"android\"),\n+                  not(target_os = \"linux\", target_arch = \"arm\"))]\n+            pub fn _Unwind_FindEnclosingFunction(pc: *libc::c_void)\n+                -> *libc::c_void;\n+        }\n+\n+        // On android, the function _Unwind_GetIP is a macro, and this is the\n+        // expansion of the macro. This is all copy/pasted directly from the\n+        // header file with the definition of _Unwind_GetIP.\n+        #[cfg(target_os = \"android\")]\n+        #[cfg(target_os = \"linux\", target_arch = \"arm\")]\n+        pub unsafe fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t {\n+            #[repr(C)]\n+            enum _Unwind_VRS_Result {\n+                _UVRSR_OK = 0,\n+                _UVRSR_NOT_IMPLEMENTED = 1,\n+                _UVRSR_FAILED = 2,\n+            }\n+            #[repr(C)]\n+            enum _Unwind_VRS_RegClass {\n+                _UVRSC_CORE = 0,\n+                _UVRSC_VFP = 1,\n+                _UVRSC_FPA = 2,\n+                _UVRSC_WMMXD = 3,\n+                _UVRSC_WMMXC = 4,\n+            }\n+            #[repr(C)]\n+            enum _Unwind_VRS_DataRepresentation {\n+                _UVRSD_UINT32 = 0,\n+                _UVRSD_VFPX = 1,\n+                _UVRSD_FPAX = 2,\n+                _UVRSD_UINT64 = 3,\n+                _UVRSD_FLOAT = 4,\n+                _UVRSD_DOUBLE = 5,\n+            }\n+\n+            type _Unwind_Word = libc::c_uint;\n+            extern {\n+                fn _Unwind_VRS_Get(ctx: *_Unwind_Context,\n+                                   klass: _Unwind_VRS_RegClass,\n+                                   word: _Unwind_Word,\n+                                   repr: _Unwind_VRS_DataRepresentation,\n+                                   data: *mut libc::c_void)\n+                    -> _Unwind_VRS_Result;\n+            }\n+\n+            let mut val: _Unwind_Word = 0;\n+            let ptr = &mut val as *mut _Unwind_Word;\n+            let _ = _Unwind_VRS_Get(ctx, _UVRSC_CORE, 15, _UVRSD_UINT32,\n+                                    ptr as *mut libc::c_void);\n+            (val & !1) as libc::uintptr_t\n+        }\n+\n+        // This function also doesn't exist on android or arm/linux, so make it\n+        // a no-op\n+        #[cfg(target_os = \"android\")]\n+        #[cfg(target_os = \"linux\", target_arch = \"arm\")]\n+        pub unsafe fn _Unwind_FindEnclosingFunction(pc: *libc::c_void)\n+            -> *libc::c_void\n+        {\n+            pc\n+        }\n+    }\n }\n \n /// As always, windows has something very different than unix, we mainly want\n@@ -504,18 +603,18 @@ mod imp {\n mod imp {\n     use c_str::CString;\n     use container::Container;\n+    use intrinsics;\n     use io::{IoResult, Writer};\n     use libc;\n     use mem;\n     use ops::Drop;\n     use option::{Some, None};\n     use path::Path;\n     use result::{Ok, Err};\n+    use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use slice::ImmutableVector;\n     use str::StrSlice;\n     use unstable::dynamic_lib::DynamicLibrary;\n-    use intrinsics;\n-    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    use slice::ImmutableVector;\n \n     #[allow(non_snake_case_functions)]\n     extern \"system\" {"}, {"sha": "7271464d1e92f00e73e629b1607cf4445df90f8c", "filename": "src/libstd/rt/env.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e87e18064ece0d7eddb269b8211fb8fdf5efaa91/src%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87e18064ece0d7eddb269b8211fb8fdf5efaa91/src%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fenv.rs?ref=e87e18064ece0d7eddb269b8211fb8fdf5efaa91", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Runtime environment settings\n-\n-use from_str::from_str;\n-use option::{Some, None};\n-use os;\n-use str::Str;\n-\n-// Note that these are all accessed without any synchronization.\n-// They are expected to be initialized once then left alone.\n-\n-static mut MIN_STACK: uint = 2 * 1024 * 1024;\n-/// This default corresponds to 20M of cache per scheduler (at the default size).\n-static mut MAX_CACHED_STACKS: uint = 10;\n-static mut DEBUG_BORROW: bool = false;\n-\n-pub fn init() {\n-    unsafe {\n-        match os::getenv(\"RUST_MIN_STACK\") {\n-            Some(s) => match from_str(s.as_slice()) {\n-                Some(i) => MIN_STACK = i,\n-                None => ()\n-            },\n-            None => ()\n-        }\n-        match os::getenv(\"RUST_MAX_CACHED_STACKS\") {\n-            Some(max) => {\n-                MAX_CACHED_STACKS =\n-                    from_str(max.as_slice()).expect(\"expected positive \\\n-                                                     integer in \\\n-                                                     RUST_MAX_CACHED_STACKS\")\n-            }\n-            None => ()\n-        }\n-        match os::getenv(\"RUST_DEBUG_BORROW\") {\n-            Some(_) => DEBUG_BORROW = true,\n-            None => ()\n-        }\n-    }\n-}\n-\n-pub fn min_stack() -> uint {\n-    unsafe { MIN_STACK }\n-}\n-\n-pub fn max_cached_stacks() -> uint {\n-    unsafe { MAX_CACHED_STACKS }\n-}\n-\n-pub fn debug_borrow() -> bool {\n-    unsafe { DEBUG_BORROW }\n-}"}, {"sha": "a68a632bc37e0b13cc249d28a0f72c3be1a458df", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 13, "deletions": 138, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -54,159 +54,37 @@ Several modules in `core` are clients of `rt`:\n // FIXME: this should not be here.\n #![allow(missing_doc)]\n \n-use any::Any;\n-use kinds::Send;\n-use option::Option;\n-use owned::Box;\n-use result::Result;\n-use task::TaskOpts;\n+use failure;\n+use rustrt;\n \n-use self::task::{Task, BlockedTask};\n-\n-// this is somewhat useful when a program wants to spawn a \"reasonable\" number\n-// of workers based on the constraints of the system that it's running on.\n-// Perhaps this shouldn't be a `pub use` though and there should be another\n-// method...\n-pub use self::util::default_sched_threads;\n-\n-// Export unwinding facilities used by the failure macros\n-pub use self::unwind::{begin_unwind, begin_unwind_fmt};\n-\n-pub use self::util::{Stdio, Stdout, Stderr};\n+// Reexport some of our utilities which are expected by other crates.\n+pub use self::util::{default_sched_threads, min_stack, running_on_valgrind};\n \n+// Reexport functionality from librustrt and other crates underneath the\n+// standard library which work together to create the entire runtime.\n pub use alloc::{heap, libc_heap};\n-\n-// Used by I/O tests\n-#[experimental]\n-pub use self::util::running_on_valgrind;\n-\n-// FIXME: these probably shouldn't be public...\n-#[doc(hidden)]\n-pub mod shouldnt_be_public {\n-    #[cfg(not(test))]\n-    pub use super::local_ptr::native::maybe_tls_key;\n-    #[cfg(not(windows), not(target_os = \"android\"))]\n-    pub use super::local_ptr::compiled::RT_TLS_PTR;\n-}\n-\n-// Internal macros used by the runtime.\n-mod macros;\n-\n-/// Implementations of language-critical runtime features like @.\n-pub mod task;\n-\n-// The EventLoop and internal synchronous I/O interface.\n-pub mod rtio;\n-\n-// The Local trait for types that are accessible via thread-local\n-// or task-local storage.\n-pub mod local;\n+pub use rustrt::{task, local, mutex, exclusive, stack, args, rtio};\n+pub use rustrt::{Stdio, Stdout, Stderr, begin_unwind, begin_unwind_fmt};\n+pub use rustrt::{bookkeeping, at_exit, unwind, DEFAULT_ERROR_CODE, Runtime};\n \n // Bindings to system threading libraries.\n pub mod thread;\n \n-// The runtime configuration, read from environment variables.\n-pub mod env;\n-\n-// The local, managed heap\n-pub mod local_heap;\n-\n-// The runtime needs to be able to put a pointer into thread-local storage.\n-mod local_ptr;\n-\n-// Bindings to pthread/windows thread-local storage.\n-mod thread_local_storage;\n-\n-// Stack unwinding\n-pub mod unwind;\n-\n-// The interface to libunwind that rust is using.\n-mod libunwind;\n-\n // Simple backtrace functionality (to print on failure)\n pub mod backtrace;\n \n // Just stuff\n mod util;\n \n-// Global command line argument storage\n-pub mod args;\n-\n-// Support for running procedures when a program has exited.\n-mod at_exit_imp;\n-\n-// Bookkeeping for task counts\n-pub mod bookkeeping;\n-\n-// Stack overflow protection\n-pub mod stack;\n-\n-/// The default error code of the rust runtime if the main task fails instead\n-/// of exiting cleanly.\n-pub static DEFAULT_ERROR_CODE: int = 101;\n-\n-/// The interface to the current runtime.\n-///\n-/// This trait is used as the abstraction between 1:1 and M:N scheduling. The\n-/// two independent crates, libnative and libgreen, both have objects which\n-/// implement this trait. The goal of this trait is to encompass all the\n-/// fundamental differences in functionality between the 1:1 and M:N runtime\n-/// modes.\n-pub trait Runtime {\n-    // Necessary scheduling functions, used for channels and blocking I/O\n-    // (sometimes).\n-    fn yield_now(~self, cur_task: Box<Task>);\n-    fn maybe_yield(~self, cur_task: Box<Task>);\n-    fn deschedule(~self, times: uint, cur_task: Box<Task>,\n-                  f: |BlockedTask| -> Result<(), BlockedTask>);\n-    fn reawaken(~self, to_wake: Box<Task>);\n-\n-    // Miscellaneous calls which are very different depending on what context\n-    // you're in.\n-    fn spawn_sibling(~self,\n-                     cur_task: Box<Task>,\n-                     opts: TaskOpts,\n-                     f: proc():Send);\n-    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;\n-    /// The (low, high) edges of the current stack.\n-    fn stack_bounds(&self) -> (uint, uint); // (lo, hi)\n-    fn can_block(&self) -> bool;\n-\n-    // FIXME: This is a serious code smell and this should not exist at all.\n-    fn wrap(~self) -> Box<Any>;\n-}\n-\n /// One-time runtime initialization.\n ///\n /// Initializes global state, including frobbing\n /// the crate's logging flags, registering GC\n /// metadata, and storing the process arguments.\n+#[allow(experimental)]\n pub fn init(argc: int, argv: **u8) {\n-    // FIXME: Derefing these pointers is not safe.\n-    // Need to propagate the unsafety to `start`.\n-    unsafe {\n-        args::init(argc, argv);\n-        env::init();\n-        local_ptr::init();\n-        at_exit_imp::init();\n-    }\n-}\n-\n-/// Enqueues a procedure to run when the runtime is cleaned up\n-///\n-/// The procedure passed to this function will be executed as part of the\n-/// runtime cleanup phase. For normal rust programs, this means that it will run\n-/// after all other tasks have exited.\n-///\n-/// The procedure is *not* executed with a local `Task` available to it, so\n-/// primitives like logging, I/O, channels, spawning, etc, are *not* available.\n-/// This is meant for \"bare bones\" usage to clean up runtime details, this is\n-/// not meant as a general-purpose \"let's clean everything up\" function.\n-///\n-/// It is forbidden for procedures to register more `at_exit` handlers when they\n-/// are running, and doing so will lead to a process abort.\n-pub fn at_exit(f: proc():Send) {\n-    at_exit_imp::push(f);\n+    rustrt::init(argc, argv);\n+    unsafe { unwind::register(failure::on_fail); }\n }\n \n /// One-time runtime cleanup.\n@@ -219,8 +97,5 @@ pub fn at_exit(f: proc():Send) {\n /// Invoking cleanup while portions of the runtime are still in use may cause\n /// undefined behavior.\n pub unsafe fn cleanup() {\n-    bookkeeping::wait_for_other_tasks();\n-    at_exit_imp::run();\n-    args::cleanup();\n-    local_ptr::cleanup();\n+    rustrt::cleanup();\n }"}, {"sha": "670d4aa2061f1e0f477c077edd2c56041e6daf33", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 30, "deletions": 118, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -8,23 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use container::Container;\n-use fmt;\n use from_str::FromStr;\n-use io::IoResult;\n-use io;\n-use iter::Iterator;\n-use libc;\n+use from_str::from_str;\n use libc::uintptr_t;\n+use libc;\n use option::{Some, None, Option};\n use os;\n-use result::Ok;\n-use str::{Str, StrSlice};\n-use slice::ImmutableVector;\n-\n-// Indicates whether we should perform expensive sanity checks, including rtassert!\n-// FIXME: Once the runtime matures remove the `true` below to turn off rtassert, etc.\n-pub static ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) || cfg!(rtassert);\n+use str::Str;\n+use sync::atomics;\n \n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n@@ -37,6 +28,17 @@ pub fn num_cpus() -> uint {\n     }\n }\n \n+/// Dynamically inquire about whether we're running under V.\n+/// You should usually not use this unless your test definitely\n+/// can't run correctly un-altered. Valgrind is there to help\n+/// you notice weirdness in normal, un-doctored code paths!\n+pub fn running_on_valgrind() -> bool {\n+    extern {\n+        fn rust_running_on_valgrind() -> uintptr_t;\n+    }\n+    unsafe { rust_running_on_valgrind() != 0 }\n+}\n+\n /// Valgrind has a fixed-sized array (size around 2000) of segment descriptors\n /// wired into it; this is a hard limit and requires rebuilding valgrind if you\n /// want to go beyond it. Normally this is not a problem, but in some tests, we\n@@ -50,6 +52,20 @@ pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool {\n     (cfg!(target_os=\"macos\")) && running_on_valgrind()\n }\n \n+pub fn min_stack() -> uint {\n+    static mut MIN: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n+    match unsafe { MIN.load(atomics::SeqCst) } {\n+        0 => {}\n+        n => return n - 1,\n+    }\n+    let amt = os::getenv(\"RUST_MIN_STACK\").and_then(|s| from_str(s.as_slice()));\n+    let amt = amt.unwrap_or(2 * 1024 * 1024);\n+    // 0 is our sentinel value, so ensure that we'll never see 0 after\n+    // initialization has run\n+    unsafe { MIN.store(amt + 1, atomics::SeqCst); }\n+    return amt;\n+}\n+\n /// Get's the number of scheduler threads requested by the environment\n /// either `RUST_THREADS` or `num_cpus`.\n pub fn default_sched_threads() -> uint {\n@@ -58,7 +74,7 @@ pub fn default_sched_threads() -> uint {\n             let opt_n: Option<uint> = FromStr::from_str(nstr.as_slice());\n             match opt_n {\n                 Some(n) if n > 0 => n,\n-                _ => rtabort!(\"`RUST_THREADS` is `{}`, should be a positive integer\", nstr)\n+                _ => fail!(\"`RUST_THREADS` is `{}`, should be a positive integer\", nstr)\n             }\n         }\n         None => {\n@@ -70,107 +86,3 @@ pub fn default_sched_threads() -> uint {\n         }\n     }\n }\n-\n-pub struct Stdio(libc::c_int);\n-\n-pub static Stdout: Stdio = Stdio(libc::STDOUT_FILENO);\n-pub static Stderr: Stdio = Stdio(libc::STDERR_FILENO);\n-\n-impl io::Writer for Stdio {\n-    fn write(&mut self, data: &[u8]) -> IoResult<()> {\n-        #[cfg(unix)]\n-        type WriteLen = libc::size_t;\n-        #[cfg(windows)]\n-        type WriteLen = libc::c_uint;\n-        unsafe {\n-            let Stdio(fd) = *self;\n-            libc::write(fd,\n-                        data.as_ptr() as *libc::c_void,\n-                        data.len() as WriteLen);\n-        }\n-        Ok(()) // yes, we're lying\n-    }\n-}\n-\n-pub fn dumb_println(args: &fmt::Arguments) {\n-    use io::Writer;\n-    let mut w = Stderr;\n-    let _ = writeln!(&mut w, \"{}\", args);\n-}\n-\n-pub fn abort(msg: &str) -> ! {\n-    let msg = if !msg.is_empty() { msg } else { \"aborted\" };\n-    let hash = msg.chars().fold(0, |accum, val| accum + (val as uint) );\n-    let quote = match hash % 10 {\n-        0 => \"\n-It was from the artists and poets that the pertinent answers came, and I\n-know that panic would have broken loose had they been able to compare notes.\n-As it was, lacking their original letters, I half suspected the compiler of\n-having asked leading questions, or of having edited the correspondence in\n-corroboration of what he had latently resolved to see.\",\n-        1 => \"\n-There are not many persons who know what wonders are opened to them in the\n-stories and visions of their youth; for when as children we listen and dream,\n-we think but half-formed thoughts, and when as men we try to remember, we are\n-dulled and prosaic with the poison of life. But some of us awake in the night\n-with strange phantasms of enchanted hills and gardens, of fountains that sing\n-in the sun, of golden cliffs overhanging murmuring seas, of plains that stretch\n-down to sleeping cities of bronze and stone, and of shadowy companies of heroes\n-that ride caparisoned white horses along the edges of thick forests; and then\n-we know that we have looked back through the ivory gates into that world of\n-wonder which was ours before we were wise and unhappy.\",\n-        2 => \"\n-Instead of the poems I had hoped for, there came only a shuddering blackness\n-and ineffable loneliness; and I saw at last a fearful truth which no one had\n-ever dared to breathe before \u2014 the unwhisperable secret of secrets \u2014 The fact\n-that this city of stone and stridor is not a sentient perpetuation of Old New\n-York as London is of Old London and Paris of Old Paris, but that it is in fact\n-quite dead, its sprawling body imperfectly embalmed and infested with queer\n-animate things which have nothing to do with it as it was in life.\",\n-        3 => \"\n-The ocean ate the last of the land and poured into the smoking gulf, thereby\n-giving up all it had ever conquered. From the new-flooded lands it flowed\n-again, uncovering death and decay; and from its ancient and immemorial bed it\n-trickled loathsomely, uncovering nighted secrets of the years when Time was\n-young and the gods unborn. Above the waves rose weedy remembered spires. The\n-moon laid pale lilies of light on dead London, and Paris stood up from its damp\n-grave to be sanctified with star-dust. Then rose spires and monoliths that were\n-weedy but not remembered; terrible spires and monoliths of lands that men never\n-knew were lands...\",\n-        4 => \"\n-There was a night when winds from unknown spaces whirled us irresistibly into\n-limitless vacuum beyond all thought and entity. Perceptions of the most\n-maddeningly untransmissible sort thronged upon us; perceptions of infinity\n-which at the time convulsed us with joy, yet which are now partly lost to my\n-memory and partly incapable of presentation to others.\",\n-        _ => \"You've met with a terrible fate, haven't you?\"\n-    };\n-    ::alloc::util::make_stdlib_link_work(); // see comments in liballoc\n-    rterrln!(\"{}\", \"\");\n-    rterrln!(\"{}\", quote);\n-    rterrln!(\"{}\", \"\");\n-    rterrln!(\"fatal runtime error: {}\", msg);\n-\n-    {\n-        let mut err = Stderr;\n-        let _err = ::rt::backtrace::write(&mut err);\n-    }\n-    abort();\n-\n-    fn abort() -> ! {\n-        use intrinsics;\n-        unsafe { intrinsics::abort() }\n-    }\n-}\n-\n-/// Dynamically inquire about whether we're running under V.\n-/// You should usually not use this unless your test definitely\n-/// can't run correctly un-altered. Valgrind is there to help\n-/// you notice weirdness in normal, un-doctored code paths!\n-pub fn running_on_valgrind() -> bool {\n-    unsafe { rust_running_on_valgrind() != 0 }\n-}\n-\n-extern {\n-    fn rust_running_on_valgrind() -> uintptr_t;\n-}"}, {"sha": "c804918ae4b411fd74f364cb702ff6d73dc5d189", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -13,7 +13,7 @@\n //! necessary for running libstd.\n \n // All platforms need to link to rustrt\n-#[link(name = \"rustrt\", kind = \"static\")]\n+#[link(name = \"rust_builtin\", kind = \"static\")]\n extern {}\n \n // LLVM implements the `frem` instruction as a call to `fmod`, which lives in"}, {"sha": "39e420685abd971c0d6e02fbbe0405f161b0ba6a", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -63,7 +63,7 @@ use ptr;\n use rt::heap::{allocate, deallocate};\n use slice::ImmutableVector;\n use sync::atomics::{AtomicInt, AtomicPtr, SeqCst};\n-use unstable::sync::Exclusive;\n+use rt::exclusive::Exclusive;\n use vec::Vec;\n \n // Once the queue is less than 1/K full, then it will be downsized. Note that\n@@ -121,7 +121,7 @@ pub enum Stolen<T> {\n /// will only use this structure when allocating a new buffer or deallocating a\n /// previous one.\n pub struct BufferPool<T> {\n-    pool: Exclusive<Vec<Box<Buffer<T>>>>,\n+    pool: Arc<Exclusive<Vec<Box<Buffer<T>>>>>,\n }\n \n /// An internal buffer used by the chase-lev deque. This structure is actually\n@@ -148,7 +148,7 @@ impl<T: Send> BufferPool<T> {\n     /// Allocates a new buffer pool which in turn can be used to allocate new\n     /// deques.\n     pub fn new() -> BufferPool<T> {\n-        BufferPool { pool: Exclusive::new(vec!()) }\n+        BufferPool { pool: Arc::new(Exclusive::new(vec!())) }\n     }\n \n     /// Allocates a new work-stealing deque which will send/receiving memory to\n@@ -162,25 +162,21 @@ impl<T: Send> BufferPool<T> {\n \n     fn alloc(&self, bits: int) -> Box<Buffer<T>> {\n         unsafe {\n-            self.pool.with(|pool| {\n-                match pool.iter().position(|x| x.size() >= (1 << bits)) {\n-                    Some(i) => pool.remove(i).unwrap(),\n-                    None => box Buffer::new(bits)\n-                }\n-            })\n+            let mut pool = self.pool.lock();\n+            match pool.iter().position(|x| x.size() >= (1 << bits)) {\n+                Some(i) => pool.remove(i).unwrap(),\n+                None => box Buffer::new(bits)\n+            }\n         }\n     }\n \n     fn free(&self, buf: Box<Buffer<T>>) {\n         unsafe {\n-            let mut buf = Some(buf);\n-            self.pool.with(|pool| {\n-                let buf = buf.take_unwrap();\n-                match pool.iter().position(|v| v.size() > buf.size()) {\n-                    Some(i) => pool.insert(i, buf),\n-                    None => pool.push(buf),\n-                }\n-            })\n+            let mut pool = self.pool.lock();\n+            match pool.iter().position(|v| v.size() > buf.size()) {\n+                Some(i) => pool.insert(i, buf),\n+                None => pool.push(buf),\n+            }\n         }\n     }\n }"}, {"sha": "9ee62ee3d81b6c5269e1b2ecc06d5c4b993ea5ea", "filename": "src/libstd/task.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -38,12 +38,13 @@\n \n use any::Any;\n use comm::{Sender, Receiver, channel};\n-use io::Writer;\n+use io::{Writer, stdio};\n use kinds::{Send, marker};\n use option::{None, Some, Option};\n use owned::Box;\n use result::{Result, Ok, Err};\n use rt::local::Local;\n+use rt::task;\n use rt::task::Task;\n use str::{Str, SendStr, IntoMaybeOwned};\n \n@@ -53,18 +54,10 @@ use str::{Str, SendStr, IntoMaybeOwned};\n #[cfg(test)] use str::StrAllocating;\n #[cfg(test)] use string::String;\n \n-/// Indicates the manner in which a task exited.\n-///\n-/// A task that completes without failing is considered to exit successfully.\n-///\n-/// If you wish for this result's delivery to block until all\n-/// children tasks complete, recommend using a result future.\n-pub type TaskResult = Result<(), Box<Any:Send>>;\n-\n /// Task configuration options\n pub struct TaskOpts {\n     /// Enable lifecycle notifications on the given channel\n-    pub notify_chan: Option<Sender<TaskResult>>,\n+    pub notify_chan: Option<Sender<task::Result>>,\n     /// A name for the task-to-be, for identification in failure messages\n     pub name: Option<SendStr>,\n     /// The size of the stack for the spawned task\n@@ -114,7 +107,7 @@ impl TaskBuilder {\n     ///\n     /// # Failure\n     /// Fails if a future_result was already set for this task.\n-    pub fn future_result(&mut self) -> Receiver<TaskResult> {\n+    pub fn future_result(&mut self) -> Receiver<task::Result> {\n         // FIXME (#3725): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -180,7 +173,22 @@ impl TaskBuilder {\n             Some(t) => t,\n             None => fail!(\"need a local task to spawn a new task\"),\n         };\n-        t.spawn_sibling(self.opts, f);\n+        let TaskOpts { notify_chan, name, stack_size, stdout, stderr } = self.opts;\n+\n+        let opts = task::TaskOpts {\n+            on_exit: notify_chan.map(|c| proc(r) c.send(r)),\n+            name: name,\n+            stack_size: stack_size,\n+        };\n+        if stdout.is_some() || stderr.is_some() {\n+            t.spawn_sibling(opts, proc() {\n+                let _ = stdout.map(stdio::set_stdout);\n+                let _ = stderr.map(stdio::set_stderr);\n+                f();\n+            });\n+        } else {\n+            t.spawn_sibling(opts, f);\n+        }\n     }\n \n     /**"}, {"sha": "c05cdc85cc53affe5cc9d29ca52ccad48bedfa00", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -224,7 +224,7 @@ pub mod dl {\n     }\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, String> {\n-        use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+        use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n         static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire"}, {"sha": "985ef2e142cfd2f6b2bd1422e252deb738110a0e", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -11,7 +11,3 @@\n #![doc(hidden)]\n \n pub mod dynamic_lib;\n-\n-pub mod sync;\n-pub mod mutex;\n-"}, {"sha": "f0f7e40ce09b88ed4c5793f73f13e4af104bf4fd", "filename": "src/libstd/unstable/sync.rs", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/e87e18064ece0d7eddb269b8211fb8fdf5efaa91/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87e18064ece0d7eddb269b8211fb8fdf5efaa91/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=e87e18064ece0d7eddb269b8211fb8fdf5efaa91", "patch": "@@ -1,159 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use alloc::arc::Arc;\n-\n-use clone::Clone;\n-use kinds::Send;\n-use ty::Unsafe;\n-use unstable::mutex::NativeMutex;\n-\n-struct ExData<T> {\n-    lock: NativeMutex,\n-    failed: bool,\n-    data: T,\n-}\n-\n-/**\n- * An arc over mutable data that is protected by a lock. For library use only.\n- *\n- * # Safety note\n- *\n- * This uses a pthread mutex, not one that's aware of the userspace scheduler.\n- * The user of an Exclusive must be careful not to invoke any functions that may\n- * reschedule the task while holding the lock, or deadlock may result. If you\n- * need to block or deschedule while accessing shared state, use extra::sync::RWArc.\n- */\n-pub struct Exclusive<T> {\n-    x: Arc<Unsafe<ExData<T>>>\n-}\n-\n-impl<T:Send> Clone for Exclusive<T> {\n-    // Duplicate an Exclusive Arc, as std::arc::clone.\n-    fn clone(&self) -> Exclusive<T> {\n-        Exclusive { x: self.x.clone() }\n-    }\n-}\n-\n-impl<T:Send> Exclusive<T> {\n-    pub fn new(user_data: T) -> Exclusive<T> {\n-        let data = ExData {\n-            lock: unsafe {NativeMutex::new()},\n-            failed: false,\n-            data: user_data\n-        };\n-        Exclusive {\n-            x: Arc::new(Unsafe::new(data))\n-        }\n-    }\n-\n-    // Exactly like sync::MutexArc.access(). Same reason for being\n-    // unsafe.\n-    //\n-    // Currently, scheduling operations (i.e., descheduling, receiving on a pipe,\n-    // accessing the provided condition variable) are prohibited while inside\n-    // the Exclusive. Supporting that is a work in progress.\n-    #[inline]\n-    pub unsafe fn with<U>(&self, f: |x: &mut T| -> U) -> U {\n-        let rec = self.x.get();\n-        let _l = (*rec).lock.lock();\n-        if (*rec).failed {\n-            fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n-        }\n-        (*rec).failed = true;\n-        let result = f(&mut (*rec).data);\n-        (*rec).failed = false;\n-        result\n-    }\n-\n-    #[inline]\n-    pub unsafe fn with_imm<U>(&self, f: |x: &T| -> U) -> U {\n-        self.with(|x| f(x))\n-    }\n-\n-    #[inline]\n-    pub unsafe fn hold_and_signal(&self, f: |x: &mut T|) {\n-        let rec = self.x.get();\n-        let guard = (*rec).lock.lock();\n-        if (*rec).failed {\n-            fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n-        }\n-        (*rec).failed = true;\n-        f(&mut (*rec).data);\n-        (*rec).failed = false;\n-        guard.signal();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn hold_and_wait(&self, f: |x: &T| -> bool) {\n-        let rec = self.x.get();\n-        let l = (*rec).lock.lock();\n-        if (*rec).failed {\n-            fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n-        }\n-        (*rec).failed = true;\n-        let result = f(&(*rec).data);\n-        (*rec).failed = false;\n-        if result {\n-            l.wait();\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use option::*;\n-    use prelude::*;\n-    use super::Exclusive;\n-    use task;\n-\n-    #[test]\n-    fn exclusive_new_arc() {\n-        unsafe {\n-            let mut futures = Vec::new();\n-\n-            let num_tasks = 10;\n-            let count = 10;\n-\n-            let total = Exclusive::new(box 0);\n-\n-            for _ in range(0u, num_tasks) {\n-                let total = total.clone();\n-                let (tx, rx) = channel();\n-                futures.push(rx);\n-\n-                task::spawn(proc() {\n-                    for _ in range(0u, count) {\n-                        total.with(|count| **count += 1);\n-                    }\n-                    tx.send(());\n-                });\n-            };\n-\n-            for f in futures.mut_iter() { f.recv() }\n-\n-            total.with(|total| assert!(**total == num_tasks * count));\n-        }\n-    }\n-\n-    #[test] #[should_fail]\n-    fn exclusive_new_poison() {\n-        unsafe {\n-            // Tests that if one task fails inside of an Exclusive::new, subsequent\n-            // accesses will also fail.\n-            let x = Exclusive::new(1);\n-            let x2 = x.clone();\n-            let _ = task::try(proc() {\n-                x2.with(|one| assert_eq!(*one, 2))\n-            });\n-            x.with(|one| assert_eq!(*one, 1));\n-        }\n-    }\n-}"}, {"sha": "bcf5a43fb6b3e684fee7634bde5d8abfac82e436", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -64,7 +64,7 @@ use std::rt::task::{BlockedTask, Task};\n use std::rt::thread::Thread;\n use std::sync::atomics;\n use std::ty::Unsafe;\n-use std::unstable::mutex;\n+use std::rt::mutex;\n \n use q = mpsc_intrusive;\n "}, {"sha": "4fdbdf8f5c7ae58ea08a0036d683e2aede790bff", "filename": "src/test/run-pass/match-ref-binding-in-guard-3256.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::unstable;\n+use std::rt;\n \n pub fn main() {\n     unsafe {\n-        let x = Some(unstable::sync::Exclusive::new(true));\n+        let x = Some(rt::exclusive::Exclusive::new(true));\n         match x {\n-            Some(ref z) if z.with(|b| *b) => {\n-                z.with(|b| assert!(*b));\n+            Some(ref z) if *z.lock() => {\n+                assert!(*z.lock());\n             },\n             _ => fail!()\n         }"}, {"sha": "0ef48c9978251e09cbde006d0ab789fe1e0fc35c", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -28,7 +28,7 @@ fn start(argc: int, argv: **u8) -> int {\n                 4 => assert!(try(|| fail!()).is_err()),\n                 5 => assert!(try(|| spawn(proc() {})).is_err()),\n                 6 => assert!(Command::new(\"test\").spawn().is_err()),\n-                7 => assert!(foo.get().is_some()),\n+                7 => assert!(foo.get().is_none()),\n                 8 => assert!(try(|| { foo.replace(Some(3)); }).is_err()),\n                 _ => fail!()\n             }\n@@ -49,6 +49,8 @@ fn main() {\n     pass(Command::new(me).arg(&[4u8]).output().unwrap());\n     pass(Command::new(me).arg(&[5u8]).output().unwrap());\n     pass(Command::new(me).arg(&[6u8]).output().unwrap());\n+    pass(Command::new(me).arg(&[7u8]).output().unwrap());\n+    pass(Command::new(me).arg(&[8u8]).output().unwrap());\n }\n \n fn pass(output: ProcessOutput) {"}, {"sha": "a9a6e25adf38b88809efe909b35e9f4eee1f09a8", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -61,7 +61,7 @@ fn main() {\n     for _ in range(0, 1000) {\n         let tx = tx.clone();\n         let mut builder = TaskBuilder::new();\n-        builder.opts.stack_size = Some(32 * 1024);\n+        builder.opts.stack_size = Some(64 * 1024);\n         builder.spawn(proc() {\n             let host = addr.ip.to_str();\n             let port = addr.port;"}, {"sha": "f2d29c97f155e0c4329a601194afc3e4ba374f7a", "filename": "src/test/run-pass/writealias.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Ftest%2Frun-pass%2Fwritealias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6266f64d09184f53fff4a6f7cea682b4dd714cf2/src%2Ftest%2Frun-pass%2Fwritealias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwritealias.rs?ref=6266f64d09184f53fff4a6f7cea682b4dd714cf2", "patch": "@@ -9,18 +9,18 @@\n // except according to those terms.\n \n \n-use std::unstable;\n+use std::rt;\n \n struct Point {x: int, y: int, z: int}\n \n fn f(p: &mut Point) { p.z = 13; }\n \n pub fn main() {\n     unsafe {\n-        let x = Some(unstable::sync::Exclusive::new(true));\n+        let x = Some(rt::exclusive::Exclusive::new(true));\n         match x {\n-            Some(ref z) if z.with(|b| *b) => {\n-                z.with(|b| assert!(*b));\n+            Some(ref z) if *z.lock() => {\n+                assert!(*z.lock());\n             },\n             _ => fail!()\n         }"}]}