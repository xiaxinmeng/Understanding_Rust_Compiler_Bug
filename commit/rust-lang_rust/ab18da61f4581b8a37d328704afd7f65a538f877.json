{"sha": "ab18da61f4581b8a37d328704afd7f65a538f877", "node_id": "C_kwDOAAsO6NoAKGFiMThkYTYxZjQ1ODFiOGEzN2QzMjg3MDRhZmQ3ZjY1YTUzOGY4Nzc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-05-12T05:11:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-12T05:11:13Z"}, "message": "Rollup merge of #111441 - cjgillot:issue-111422, r=JakobDegen\n\nVerify copies of mutable pointers in 2 stages in ReferencePropagation\n\nFixes #111422\n\nIn the first stage, we mark the copies as reborrows, to be checked later.\nIn the second stage, we walk the reborrow chains to verify that all stages are fully replacable.\n\nThe replacement itself mirrors the check, and iterates through the reborrow chain.\n\nr? ``````@RalfJung``````\ncc ``````@JakobDegen``````", "tree": {"sha": "4aee8c90deb4fffc41afed32265f6e52447e12d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4aee8c90deb4fffc41afed32265f6e52447e12d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab18da61f4581b8a37d328704afd7f65a538f877", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkXcpxCRBK7hj4Ov3rIwAA+MYIAA3K6T/NYJMGMrhOoDmcd1tK\nTNX2OXYhS0jsQ629+oDgGRqFyvc2RABI8ko/z6vNkdJGUqS/zRLANMXjcC8aSGoS\nGWb2wZNbLzEvd+V/WiLMoj0WwfsrQI+HWUb3E3z7TCTgR2W2LE9FeD7o7SNaNje6\n693OC0d1HN55i7EeFBa1NffmIk7zca7ZTLCLAvpjCVQLt5iqbVYU2LAJigjJGpTf\n8vMPIIjZvnht4lwVpW9QAU7575/S7jce1v03Q9N06L9SeNrMeaD8eyiCapjNuWY1\njT/yJvWNDfD+PXQ7gSa7O7v7w1CD6Uhs4BkM/qjxZv3WShjbuRBEpQ86mQ9Y1pg=\n=/ttA\n-----END PGP SIGNATURE-----\n", "payload": "tree 4aee8c90deb4fffc41afed32265f6e52447e12d0\nparent d075b6c16dc86a026f6ef0b653c6cd386f82cc8b\nparent 9fb1c73a7309b83d495a4033c15c9e223da11f01\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1683868273 +0200\ncommitter GitHub <noreply@github.com> 1683868273 +0200\n\nRollup merge of #111441 - cjgillot:issue-111422, r=JakobDegen\n\nVerify copies of mutable pointers in 2 stages in ReferencePropagation\n\nFixes #111422\n\nIn the first stage, we mark the copies as reborrows, to be checked later.\nIn the second stage, we walk the reborrow chains to verify that all stages are fully replacable.\n\nThe replacement itself mirrors the check, and iterates through the reborrow chain.\n\nr? ``````@RalfJung``````\ncc ``````@JakobDegen``````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab18da61f4581b8a37d328704afd7f65a538f877", "html_url": "https://github.com/rust-lang/rust/commit/ab18da61f4581b8a37d328704afd7f65a538f877", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab18da61f4581b8a37d328704afd7f65a538f877/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d075b6c16dc86a026f6ef0b653c6cd386f82cc8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d075b6c16dc86a026f6ef0b653c6cd386f82cc8b", "html_url": "https://github.com/rust-lang/rust/commit/d075b6c16dc86a026f6ef0b653c6cd386f82cc8b"}, {"sha": "9fb1c73a7309b83d495a4033c15c9e223da11f01", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fb1c73a7309b83d495a4033c15c9e223da11f01", "html_url": "https://github.com/rust-lang/rust/commit/9fb1c73a7309b83d495a4033c15c9e223da11f01"}], "stats": {"total": 264, "additions": 230, "deletions": 34}, "files": [{"sha": "d1bc9ee91538e6ef58953f8f43b14ac21d4881f7", "filename": "compiler/rustc_mir_transform/src/ref_prop.rs", "status": "modified", "additions": 60, "deletions": 30, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ab18da61f4581b8a37d328704afd7f65a538f877/compiler%2Frustc_mir_transform%2Fsrc%2Fref_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab18da61f4581b8a37d328704afd7f65a538f877/compiler%2Frustc_mir_transform%2Fsrc%2Fref_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fref_prop.rs?ref=ab18da61f4581b8a37d328704afd7f65a538f877", "patch": "@@ -85,7 +85,9 @@ fn propagate_ssa<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     let ssa = SsaLocals::new(body);\n \n     let mut replacer = compute_replacement(tcx, body, &ssa);\n-    debug!(?replacer.targets, ?replacer.allowed_replacements, ?replacer.storage_to_remove);\n+    debug!(?replacer.targets);\n+    debug!(?replacer.allowed_replacements);\n+    debug!(?replacer.storage_to_remove);\n \n     replacer.visit_body_preserves_cfg(body);\n \n@@ -190,8 +192,11 @@ fn compute_replacement<'tcx>(\n             continue;\n         }\n \n+        // Whether the current local is subject to the uniqueness rule.\n+        let needs_unique = ty.is_mutable_ptr();\n+\n         // If this a mutable reference that we cannot fully replace, mark it as unknown.\n-        if ty.is_mutable_ptr() && !fully_replacable_locals.contains(local) {\n+        if needs_unique && !fully_replacable_locals.contains(local) {\n             debug!(\"not fully replaceable\");\n             continue;\n         }\n@@ -203,32 +208,33 @@ fn compute_replacement<'tcx>(\n             // have been visited before.\n             Rvalue::Use(Operand::Copy(place) | Operand::Move(place))\n             | Rvalue::CopyForDeref(place) => {\n-                if let Some(rhs) = place.as_local() {\n+                if let Some(rhs) = place.as_local() && ssa.is_ssa(rhs) {\n                     let target = targets[rhs];\n-                    if matches!(target, Value::Pointer(..)) {\n+                    // Only see through immutable reference and pointers, as we do not know yet if\n+                    // mutable references are fully replaced.\n+                    if !needs_unique && matches!(target, Value::Pointer(..)) {\n                         targets[local] = target;\n-                    } else if ssa.is_ssa(rhs) {\n-                        let refmut = body.local_decls[rhs].ty.is_mutable_ptr();\n-                        targets[local] = Value::Pointer(tcx.mk_place_deref(rhs.into()), refmut);\n+                    } else {\n+                        targets[local] = Value::Pointer(tcx.mk_place_deref(rhs.into()), needs_unique);\n                     }\n                 }\n             }\n             Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n                 let mut place = *place;\n                 // Try to see through `place` in order to collapse reborrow chains.\n                 if place.projection.first() == Some(&PlaceElem::Deref)\n-                    && let Value::Pointer(target, refmut) = targets[place.local]\n+                    && let Value::Pointer(target, inner_needs_unique) = targets[place.local]\n                     // Only see through immutable reference and pointers, as we do not know yet if\n                     // mutable references are fully replaced.\n-                    && !refmut\n+                    && !inner_needs_unique\n                     // Only collapse chain if the pointee is definitely live.\n                     && can_perform_opt(target, location)\n                 {\n                     place = target.project_deeper(&place.projection[1..], tcx);\n                 }\n                 assert_ne!(place.local, local);\n                 if is_constant_place(place) {\n-                    targets[local] = Value::Pointer(place, ty.is_mutable_ptr());\n+                    targets[local] = Value::Pointer(place, needs_unique);\n                 }\n             }\n             // We do not know what to do, so keep as not-a-pointer.\n@@ -276,16 +282,35 @@ fn compute_replacement<'tcx>(\n                 return;\n             }\n \n-            if let Value::Pointer(target, refmut) = self.targets[place.local]\n-                && place.projection.first() == Some(&PlaceElem::Deref)\n-            {\n-                let perform_opt = (self.can_perform_opt)(target, loc);\n-                if perform_opt {\n-                    self.allowed_replacements.insert((target.local, loc));\n-                } else if refmut {\n-                    // This mutable reference is not fully replacable, so drop it.\n-                    self.targets[place.local] = Value::Unknown;\n+            if place.projection.first() != Some(&PlaceElem::Deref) {\n+                // This is not a dereference, nothing to do.\n+                return;\n+            }\n+\n+            let mut place = place.as_ref();\n+            loop {\n+                if let Value::Pointer(target, needs_unique) = self.targets[place.local] {\n+                    let perform_opt = (self.can_perform_opt)(target, loc);\n+                    debug!(?place, ?target, ?needs_unique, ?perform_opt);\n+\n+                    // This a reborrow chain, recursively allow the replacement.\n+                    //\n+                    // This also allows to detect cases where `target.local` is not replacable,\n+                    // and mark it as such.\n+                    if let &[PlaceElem::Deref] = &target.projection[..] {\n+                        assert!(perform_opt);\n+                        self.allowed_replacements.insert((target.local, loc));\n+                        place.local = target.local;\n+                        continue;\n+                    } else if perform_opt {\n+                        self.allowed_replacements.insert((target.local, loc));\n+                    } else if needs_unique {\n+                        // This mutable reference is not fully replacable, so drop it.\n+                        self.targets[place.local] = Value::Unknown;\n+                    }\n                 }\n+\n+                break;\n             }\n         }\n     }\n@@ -326,18 +351,23 @@ impl<'tcx> MutVisitor<'tcx> for Replacer<'tcx> {\n     }\n \n     fn visit_place(&mut self, place: &mut Place<'tcx>, ctxt: PlaceContext, loc: Location) {\n-        if let Value::Pointer(target, _) = self.targets[place.local]\n-            && place.projection.first() == Some(&PlaceElem::Deref)\n-        {\n-            let perform_opt = matches!(ctxt, PlaceContext::NonUse(_))\n-                || self.allowed_replacements.contains(&(target.local, loc));\n-\n-            if perform_opt {\n-                *place = target.project_deeper(&place.projection[1..], self.tcx);\n-                self.any_replacement = true;\n+        if place.projection.first() != Some(&PlaceElem::Deref) {\n+            return;\n+        }\n+\n+        loop {\n+            if let Value::Pointer(target, _) = self.targets[place.local] {\n+                let perform_opt = matches!(ctxt, PlaceContext::NonUse(_))\n+                    || self.allowed_replacements.contains(&(target.local, loc));\n+\n+                if perform_opt {\n+                    *place = target.project_deeper(&place.projection[1..], self.tcx);\n+                    self.any_replacement = true;\n+                    continue;\n+                }\n             }\n-        } else {\n-            self.super_place(place, ctxt, loc);\n+\n+            break;\n         }\n     }\n "}, {"sha": "af8ee2411d36dc9cc70fd6aeae4ce43246e40fb9", "filename": "tests/mir-opt/reference_prop.mut_raw_then_mut_shr.ReferencePropagation.diff", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ab18da61f4581b8a37d328704afd7f65a538f877/tests%2Fmir-opt%2Freference_prop.mut_raw_then_mut_shr.ReferencePropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/ab18da61f4581b8a37d328704afd7f65a538f877/tests%2Fmir-opt%2Freference_prop.mut_raw_then_mut_shr.ReferencePropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Freference_prop.mut_raw_then_mut_shr.ReferencePropagation.diff?ref=ab18da61f4581b8a37d328704afd7f65a538f877", "patch": "@@ -0,0 +1,74 @@\n+- // MIR for `mut_raw_then_mut_shr` before ReferencePropagation\n++ // MIR for `mut_raw_then_mut_shr` after ReferencePropagation\n+  \n+  fn mut_raw_then_mut_shr() -> (i32, i32) {\n+      let mut _0: (i32, i32);              // return place in scope 0 at $DIR/reference_prop.rs:+0:30: +0:40\n+      let mut _1: i32;                     // in scope 0 at $DIR/reference_prop.rs:+1:9: +1:14\n+      let mut _4: *mut i32;                // in scope 0 at $DIR/reference_prop.rs:+3:16: +3:36\n+      let mut _5: &mut i32;                // in scope 0 at $DIR/reference_prop.rs:+3:16: +3:26\n+      let _8: ();                          // in scope 0 at $DIR/reference_prop.rs:+7:5: +7:26\n+      let mut _9: i32;                     // in scope 0 at $DIR/reference_prop.rs:+8:6: +8:7\n+      let mut _10: i32;                    // in scope 0 at $DIR/reference_prop.rs:+8:9: +8:10\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/reference_prop.rs:+1:9: +1:14\n+          let _2: &mut i32;                // in scope 1 at $DIR/reference_prop.rs:+2:9: +2:13\n+          scope 2 {\n+              debug xref => _2;            // in scope 2 at $DIR/reference_prop.rs:+2:9: +2:13\n+              let _3: *mut i32;            // in scope 2 at $DIR/reference_prop.rs:+3:9: +3:13\n+              scope 3 {\n+                  debug xraw => _3;        // in scope 3 at $DIR/reference_prop.rs:+3:9: +3:13\n+                  let _6: &i32;            // in scope 3 at $DIR/reference_prop.rs:+4:9: +4:13\n+                  scope 4 {\n+                      debug xshr => _6;    // in scope 4 at $DIR/reference_prop.rs:+4:9: +4:13\n+                      let _7: i32;         // in scope 4 at $DIR/reference_prop.rs:+6:9: +6:10\n+                      scope 5 {\n+                          debug a => _7;   // in scope 5 at $DIR/reference_prop.rs:+6:9: +6:10\n+                          scope 6 {\n+                          }\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/reference_prop.rs:+1:9: +1:14\n+          _1 = const 2_i32;                // scope 0 at $DIR/reference_prop.rs:+1:17: +1:18\n+-         StorageLive(_2);                 // scope 1 at $DIR/reference_prop.rs:+2:9: +2:13\n+          _2 = &mut _1;                    // scope 1 at $DIR/reference_prop.rs:+2:16: +2:22\n+          StorageLive(_3);                 // scope 2 at $DIR/reference_prop.rs:+3:9: +3:13\n+-         StorageLive(_4);                 // scope 2 at $DIR/reference_prop.rs:+3:16: +3:36\n+-         StorageLive(_5);                 // scope 2 at $DIR/reference_prop.rs:+3:16: +3:26\n+-         _5 = &mut (*_2);                 // scope 2 at $DIR/reference_prop.rs:+3:16: +3:26\n+-         _4 = &raw mut (*_5);             // scope 2 at $DIR/reference_prop.rs:+3:16: +3:26\n++         _4 = &raw mut _1;                // scope 2 at $DIR/reference_prop.rs:+3:16: +3:26\n+          _3 = _4;                         // scope 2 at $DIR/reference_prop.rs:+3:16: +3:36\n+-         StorageDead(_5);                 // scope 2 at $DIR/reference_prop.rs:+3:36: +3:37\n+-         StorageDead(_4);                 // scope 2 at $DIR/reference_prop.rs:+3:36: +3:37\n+          StorageLive(_6);                 // scope 3 at $DIR/reference_prop.rs:+4:9: +4:13\n+-         _6 = &(*_2);                     // scope 3 at $DIR/reference_prop.rs:+4:16: +4:22\n++         _6 = &_1;                        // scope 3 at $DIR/reference_prop.rs:+4:16: +4:22\n+          StorageLive(_7);                 // scope 4 at $DIR/reference_prop.rs:+6:9: +6:10\n+-         _7 = (*_6);                      // scope 4 at $DIR/reference_prop.rs:+6:13: +6:18\n+-         StorageLive(_8);                 // scope 5 at $DIR/reference_prop.rs:+7:5: +7:26\n+-         (*_3) = const 4_i32;             // scope 6 at $DIR/reference_prop.rs:+7:14: +7:23\n+-         _8 = const ();                   // scope 6 at $DIR/reference_prop.rs:+7:5: +7:26\n+-         StorageDead(_8);                 // scope 5 at $DIR/reference_prop.rs:+7:25: +7:26\n++         _7 = _1;                         // scope 4 at $DIR/reference_prop.rs:+6:13: +6:18\n++         _1 = const 4_i32;                // scope 6 at $DIR/reference_prop.rs:+7:14: +7:23\n+          StorageLive(_9);                 // scope 5 at $DIR/reference_prop.rs:+8:6: +8:7\n+          _9 = _7;                         // scope 5 at $DIR/reference_prop.rs:+8:6: +8:7\n+          StorageLive(_10);                // scope 5 at $DIR/reference_prop.rs:+8:9: +8:10\n+          _10 = _1;                        // scope 5 at $DIR/reference_prop.rs:+8:9: +8:10\n+          _0 = (move _9, move _10);        // scope 5 at $DIR/reference_prop.rs:+8:5: +8:11\n+          StorageDead(_10);                // scope 5 at $DIR/reference_prop.rs:+8:10: +8:11\n+          StorageDead(_9);                 // scope 5 at $DIR/reference_prop.rs:+8:10: +8:11\n+          StorageDead(_7);                 // scope 4 at $DIR/reference_prop.rs:+9:1: +9:2\n+          StorageDead(_6);                 // scope 3 at $DIR/reference_prop.rs:+9:1: +9:2\n+          StorageDead(_3);                 // scope 2 at $DIR/reference_prop.rs:+9:1: +9:2\n+-         StorageDead(_2);                 // scope 1 at $DIR/reference_prop.rs:+9:1: +9:2\n+          StorageDead(_1);                 // scope 0 at $DIR/reference_prop.rs:+9:1: +9:2\n+          return;                          // scope 0 at $DIR/reference_prop.rs:+9:2: +9:2\n+      }\n+  }\n+  "}, {"sha": "75c1f8f57ccae3219bd7ca787c2eb4f7f5d6a7b1", "filename": "tests/mir-opt/reference_prop.read_through_raw.ReferencePropagation.diff", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab18da61f4581b8a37d328704afd7f65a538f877/tests%2Fmir-opt%2Freference_prop.read_through_raw.ReferencePropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/ab18da61f4581b8a37d328704afd7f65a538f877/tests%2Fmir-opt%2Freference_prop.read_through_raw.ReferencePropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Freference_prop.read_through_raw.ReferencePropagation.diff?ref=ab18da61f4581b8a37d328704afd7f65a538f877", "patch": "@@ -9,15 +9,14 @@\n       let mut _5: *mut usize;              // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n   \n       bb0: {\n-          _2 = &mut (*_1);                 // scope 0 at $DIR/reference_prop.rs:+10:13: +10:25\n+-         _2 = &mut (*_1);                 // scope 0 at $DIR/reference_prop.rs:+10:13: +10:25\n -         _3 = &mut (*_2);                 // scope 0 at $DIR/reference_prop.rs:+11:13: +11:26\n -         _4 = &raw mut (*_2);             // scope 0 at $DIR/reference_prop.rs:+12:13: +12:30\n -         _5 = &raw mut (*_3);             // scope 0 at $DIR/reference_prop.rs:+13:13: +13:30\n -         _0 = (*_4);                      // scope 0 at $DIR/reference_prop.rs:+15:13: +15:22\n -         _0 = (*_5);                      // scope 0 at $DIR/reference_prop.rs:+16:13: +16:22\n-+         _3 = &mut (*_1);                 // scope 0 at $DIR/reference_prop.rs:+11:13: +11:26\n-+         _0 = (*_2);                      // scope 0 at $DIR/reference_prop.rs:+15:13: +15:22\n-+         _0 = (*_3);                      // scope 0 at $DIR/reference_prop.rs:+16:13: +16:22\n++         _0 = (*_1);                      // scope 0 at $DIR/reference_prop.rs:+15:13: +15:22\n++         _0 = (*_1);                      // scope 0 at $DIR/reference_prop.rs:+16:13: +16:22\n           return;                          // scope 0 at $DIR/reference_prop.rs:+17:13: +17:21\n       }\n   }"}, {"sha": "93f8d1df8e85ad1ccd1eb63e1910c20ce52cfd78", "filename": "tests/mir-opt/reference_prop.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ab18da61f4581b8a37d328704afd7f65a538f877/tests%2Fmir-opt%2Freference_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab18da61f4581b8a37d328704afd7f65a538f877/tests%2Fmir-opt%2Freference_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Freference_prop.rs?ref=ab18da61f4581b8a37d328704afd7f65a538f877", "patch": "@@ -433,6 +433,29 @@ fn maybe_dead(m: bool) {\n     )\n }\n \n+fn mut_raw_then_mut_shr() -> (i32, i32) {\n+    let mut x = 2;\n+    let xref = &mut x;\n+    let xraw = &mut *xref as *mut _;\n+    let xshr = &*xref;\n+    // Verify that we completely replace with `x` in both cases.\n+    let a = *xshr;\n+    unsafe { *xraw = 4; }\n+    (a, x)\n+}\n+\n+fn unique_with_copies() {\n+    let y = {\n+        let mut a = 0;\n+        let x = &raw mut a;\n+        // `*y` is not replacable below, so we must not replace `*x`.\n+        unsafe { opaque(*x) };\n+        x\n+    };\n+    // But rewriting as `*x` is ok.\n+    unsafe { opaque(*y) };\n+}\n+\n fn main() {\n     let mut x = 5_usize;\n     let mut y = 7_usize;\n@@ -444,6 +467,8 @@ fn main() {\n     multiple_storage();\n     dominate_storage();\n     maybe_dead(true);\n+    mut_raw_then_mut_shr();\n+    unique_with_copies();\n }\n \n // EMIT_MIR reference_prop.reference_propagation.ReferencePropagation.diff\n@@ -454,3 +479,5 @@ fn main() {\n // EMIT_MIR reference_prop.multiple_storage.ReferencePropagation.diff\n // EMIT_MIR reference_prop.dominate_storage.ReferencePropagation.diff\n // EMIT_MIR reference_prop.maybe_dead.ReferencePropagation.diff\n+// EMIT_MIR reference_prop.mut_raw_then_mut_shr.ReferencePropagation.diff\n+// EMIT_MIR reference_prop.unique_with_copies.ReferencePropagation.diff"}, {"sha": "2cda2409e8093a87c2799d1918c4183476eadeb1", "filename": "tests/mir-opt/reference_prop.unique_with_copies.ReferencePropagation.diff", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ab18da61f4581b8a37d328704afd7f65a538f877/tests%2Fmir-opt%2Freference_prop.unique_with_copies.ReferencePropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/ab18da61f4581b8a37d328704afd7f65a538f877/tests%2Fmir-opt%2Freference_prop.unique_with_copies.ReferencePropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Freference_prop.unique_with_copies.ReferencePropagation.diff?ref=ab18da61f4581b8a37d328704afd7f65a538f877", "patch": "@@ -0,0 +1,66 @@\n+- // MIR for `unique_with_copies` before ReferencePropagation\n++ // MIR for `unique_with_copies` after ReferencePropagation\n+  \n+  fn unique_with_copies() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/reference_prop.rs:+0:25: +0:25\n+      let _1: *mut i32;                    // in scope 0 at $DIR/reference_prop.rs:+1:9: +1:10\n+      let mut _2: i32;                     // in scope 0 at $DIR/reference_prop.rs:+2:13: +2:18\n+      let _4: ();                          // in scope 0 at $DIR/reference_prop.rs:+5:18: +5:28\n+      let mut _5: i32;                     // in scope 0 at $DIR/reference_prop.rs:+5:25: +5:27\n+      let _6: ();                          // in scope 0 at $DIR/reference_prop.rs:+9:14: +9:24\n+      let mut _7: i32;                     // in scope 0 at $DIR/reference_prop.rs:+9:21: +9:23\n+      scope 1 {\n+          debug y => _1;                   // in scope 1 at $DIR/reference_prop.rs:+1:9: +1:10\n+          scope 5 {\n+          }\n+      }\n+      scope 2 {\n+          debug a => _2;                   // in scope 2 at $DIR/reference_prop.rs:+2:13: +2:18\n+          let _3: *mut i32;                // in scope 2 at $DIR/reference_prop.rs:+3:13: +3:14\n+          scope 3 {\n+              debug x => _3;               // in scope 3 at $DIR/reference_prop.rs:+3:13: +3:14\n+              scope 4 {\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/reference_prop.rs:+1:9: +1:10\n+          StorageLive(_2);                 // scope 0 at $DIR/reference_prop.rs:+2:13: +2:18\n+          _2 = const 0_i32;                // scope 0 at $DIR/reference_prop.rs:+2:21: +2:22\n+-         StorageLive(_3);                 // scope 2 at $DIR/reference_prop.rs:+3:13: +3:14\n+          _3 = &raw mut _2;                // scope 2 at $DIR/reference_prop.rs:+3:17: +3:27\n+          StorageLive(_4);                 // scope 3 at $DIR/reference_prop.rs:+5:9: +5:30\n+          StorageLive(_5);                 // scope 4 at $DIR/reference_prop.rs:+5:25: +5:27\n+          _5 = (*_3);                      // scope 4 at $DIR/reference_prop.rs:+5:25: +5:27\n+          _4 = opaque::<i32>(move _5) -> bb1; // scope 4 at $DIR/reference_prop.rs:+5:18: +5:28\n+                                           // mir::Constant\n+                                           // + span: $DIR/reference_prop.rs:452:18: 452:24\n+                                           // + literal: Const { ty: fn(i32) {opaque::<i32>}, val: Value(<ZST>) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_5);                 // scope 4 at $DIR/reference_prop.rs:+5:27: +5:28\n+          StorageDead(_4);                 // scope 3 at $DIR/reference_prop.rs:+5:30: +5:31\n+          _1 = _3;                         // scope 3 at $DIR/reference_prop.rs:+6:9: +6:10\n+-         StorageDead(_3);                 // scope 2 at $DIR/reference_prop.rs:+7:5: +7:6\n+          StorageDead(_2);                 // scope 0 at $DIR/reference_prop.rs:+7:5: +7:6\n+          StorageLive(_6);                 // scope 1 at $DIR/reference_prop.rs:+9:5: +9:26\n+          StorageLive(_7);                 // scope 5 at $DIR/reference_prop.rs:+9:21: +9:23\n+-         _7 = (*_1);                      // scope 5 at $DIR/reference_prop.rs:+9:21: +9:23\n++         _7 = (*_3);                      // scope 5 at $DIR/reference_prop.rs:+9:21: +9:23\n+          _6 = opaque::<i32>(move _7) -> bb2; // scope 5 at $DIR/reference_prop.rs:+9:14: +9:24\n+                                           // mir::Constant\n+                                           // + span: $DIR/reference_prop.rs:456:14: 456:20\n+                                           // + literal: Const { ty: fn(i32) {opaque::<i32>}, val: Value(<ZST>) }\n+      }\n+  \n+      bb2: {\n+          StorageDead(_7);                 // scope 5 at $DIR/reference_prop.rs:+9:23: +9:24\n+          StorageDead(_6);                 // scope 1 at $DIR/reference_prop.rs:+9:26: +9:27\n+          _0 = const ();                   // scope 0 at $DIR/reference_prop.rs:+0:25: +10:2\n+          StorageDead(_1);                 // scope 0 at $DIR/reference_prop.rs:+10:1: +10:2\n+          return;                          // scope 0 at $DIR/reference_prop.rs:+10:2: +10:2\n+      }\n+  }\n+  "}]}