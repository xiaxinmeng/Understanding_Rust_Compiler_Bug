{"sha": "0c10c686824bf37084af87af84f338bcd2a7551a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMTBjNjg2ODI0YmYzNzA4NGFmODdhZjg0ZjMzOGJjZDJhNzU1MWE=", "commit": {"author": {"name": "Valerii Hiora", "email": "valerii.hiora@gmail.com", "date": "2014-05-12T17:03:34Z"}, "committer": {"name": "Valerii Hiora", "email": "valerii.hiora@gmail.com", "date": "2014-06-12T17:24:08Z"}, "message": "Disable generating split-stack code\n\nAllows to compile for archs which do not have (or have limited)\nsegmented stack support like embedded.", "tree": {"sha": "5c74592b85ce664d924d205c03c4658774689bb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c74592b85ce664d924d205c03c4658774689bb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c10c686824bf37084af87af84f338bcd2a7551a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c10c686824bf37084af87af84f338bcd2a7551a", "html_url": "https://github.com/rust-lang/rust/commit/0c10c686824bf37084af87af84f338bcd2a7551a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c10c686824bf37084af87af84f338bcd2a7551a/comments", "author": {"login": "vhbit", "id": 140199, "node_id": "MDQ6VXNlcjE0MDE5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/140199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vhbit", "html_url": "https://github.com/vhbit", "followers_url": "https://api.github.com/users/vhbit/followers", "following_url": "https://api.github.com/users/vhbit/following{/other_user}", "gists_url": "https://api.github.com/users/vhbit/gists{/gist_id}", "starred_url": "https://api.github.com/users/vhbit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vhbit/subscriptions", "organizations_url": "https://api.github.com/users/vhbit/orgs", "repos_url": "https://api.github.com/users/vhbit/repos", "events_url": "https://api.github.com/users/vhbit/events{/privacy}", "received_events_url": "https://api.github.com/users/vhbit/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vhbit", "id": 140199, "node_id": "MDQ6VXNlcjE0MDE5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/140199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vhbit", "html_url": "https://github.com/vhbit", "followers_url": "https://api.github.com/users/vhbit/followers", "following_url": "https://api.github.com/users/vhbit/following{/other_user}", "gists_url": "https://api.github.com/users/vhbit/gists{/gist_id}", "starred_url": "https://api.github.com/users/vhbit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vhbit/subscriptions", "organizations_url": "https://api.github.com/users/vhbit/orgs", "repos_url": "https://api.github.com/users/vhbit/repos", "events_url": "https://api.github.com/users/vhbit/events{/privacy}", "received_events_url": "https://api.github.com/users/vhbit/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d730ae2fb0c455775fb1962454537c79e54f817e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d730ae2fb0c455775fb1962454537c79e54f817e", "html_url": "https://github.com/rust-lang/rust/commit/d730ae2fb0c455775fb1962454537c79e54f817e"}], "stats": {"total": 43, "additions": 29, "deletions": 14}, "files": [{"sha": "594a62ea9b22786864e5d3eae38293266bc54c26", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0c10c686824bf37084af87af84f338bcd2a7551a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c10c686824bf37084af87af84f338bcd2a7551a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0c10c686824bf37084af87af84f338bcd2a7551a", "patch": "@@ -172,12 +172,12 @@ impl<'a> Drop for StatRecorder<'a> {\n }\n \n // only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n-fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv,\n+fn decl_fn(ccx: &CrateContext, name: &str, cc: lib::llvm::CallConv,\n            ty: Type, output: ty::t) -> ValueRef {\n \n     let llfn: ValueRef = name.with_c_str(|buf| {\n         unsafe {\n-            llvm::LLVMGetOrInsertFunction(llmod, buf, ty.to_ref())\n+            llvm::LLVMGetOrInsertFunction(ccx.llmod, buf, ty.to_ref())\n         }\n     });\n \n@@ -196,17 +196,20 @@ fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv,\n     lib::llvm::SetFunctionCallConv(llfn, cc);\n     // Function addresses in Rust are never significant, allowing functions to be merged.\n     lib::llvm::SetUnnamedAddr(llfn, true);\n-    set_split_stack(llfn);\n+\n+    if ccx.is_split_stack_supported() {\n+        set_split_stack(llfn);\n+    }\n \n     llfn\n }\n \n // only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n-pub fn decl_cdecl_fn(llmod: ModuleRef,\n+pub fn decl_cdecl_fn(ccx: &CrateContext,\n                      name: &str,\n                      ty: Type,\n                      output: ty::t) -> ValueRef {\n-    decl_fn(llmod, name, lib::llvm::CCallConv, ty, output)\n+    decl_fn(ccx, name, lib::llvm::CCallConv, ty, output)\n }\n \n // only use this for foreign function ABIs and glue, use `get_extern_rust_fn` for Rust functions\n@@ -221,7 +224,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n         Some(n) => return *n,\n         None => {}\n     }\n-    let f = decl_fn(ccx.llmod, name, cc, ty, output);\n+    let f = decl_fn(ccx, name, cc, ty, output);\n     externs.insert(name.to_string(), f);\n     f\n }\n@@ -250,7 +253,7 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n     };\n \n     let llfty = type_of_rust_fn(ccx, has_env, inputs.as_slice(), output);\n-    let llfn = decl_fn(ccx.llmod, name, lib::llvm::CCallConv, llfty, output);\n+    let llfn = decl_fn(ccx, name, lib::llvm::CCallConv, llfty, output);\n     let attrs = get_fn_llvm_attributes(ccx, fn_ty);\n     for &(idx, attr) in attrs.iter() {\n         unsafe {\n@@ -1877,7 +1880,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n                           llfty: Type) -> ValueRef {\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n-    let llfn = decl_fn(ccx.llmod, sym.as_slice(), cc, llfty, ty::mk_nil());\n+    let llfn = decl_fn(ccx, sym.as_slice(), cc, llfty, ty::mk_nil());\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -1909,7 +1912,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n         let llfty = Type::func([ccx.int_type, Type::i8p(ccx).ptr_to()],\n                                &ccx.int_type);\n \n-        let llfn = decl_cdecl_fn(ccx.llmod, \"main\", llfty, ty::mk_nil());\n+        let llfn = decl_cdecl_fn(ccx, \"main\", llfty, ty::mk_nil());\n         let llbb = \"top\".with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llfn, buf)"}, {"sha": "68c6f1752bdfea033d22f74012feacba9458cc1a", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c10c686824bf37084af87af84f338bcd2a7551a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c10c686824bf37084af87af84f338bcd2a7551a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=0c10c686824bf37084af87af84f338bcd2a7551a", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use driver::config::NoDebugInfo;\n use driver::session::Session;\n use lib::llvm::{ContextRef, ModuleRef, ValueRef};\n@@ -32,6 +31,7 @@ use std::c_str::ToCStr;\n use std::ptr;\n use std::rc::Rc;\n use std::collections::{HashMap, HashSet};\n+use syntax::abi;\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n@@ -273,20 +273,32 @@ impl CrateContext {\n             None => fail!()\n         }\n     }\n+\n+    // Although there is an experimental implementation of LLVM which\n+    // supports SS on armv7 it wasn't approved by Apple, see:\n+    // http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20140505/216350.html\n+    // It looks like it might be never accepted to upstream LLVM.\n+    //\n+    // So far the decision was to disable them in default builds\n+    // but it could be enabled (with patched LLVM)\n+    pub fn is_split_stack_supported(&self) -> bool {\n+        let ref cfg = self.sess().targ_cfg;\n+        cfg.os != abi::OsiOS || cfg.arch != abi::Arm\n+    }\n }\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {\n     macro_rules! ifn (\n         ($name:expr fn() -> $ret:expr) => (\n             if *key == $name {\n-                let f = base::decl_cdecl_fn(ccx.llmod, $name, Type::func([], &$ret), ty::mk_nil());\n+                let f = base::decl_cdecl_fn(ccx, $name, Type::func([], &$ret), ty::mk_nil());\n                 ccx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr fn($($arg:expr),*) -> $ret:expr) => (\n             if *key == $name {\n-                let f = base::decl_cdecl_fn(ccx.llmod, $name,\n+                let f = base::decl_cdecl_fn(ccx, $name,\n                                   Type::func([$($arg),*], &$ret), ty::mk_nil());\n                 ccx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n@@ -418,7 +430,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 // The `if key == $name` is already in ifn!\n                 ifn!($name fn($($arg),*) -> $ret);\n             } else if *key == $name {\n-                let f = base::decl_cdecl_fn(ccx.llmod, stringify!($cname),\n+                let f = base::decl_cdecl_fn(ccx, stringify!($cname),\n                                       Type::func([$($arg),*], &$ret),\n                                       ty::mk_nil());\n                 ccx.intrinsics.borrow_mut().insert($name, f.clone());"}, {"sha": "ef9bf4eebe24b0d11239d0a0d35b4be218dad747", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c10c686824bf37084af87af84f338bcd2a7551a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c10c686824bf37084af87af84f338bcd2a7551a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=0c10c686824bf37084af87af84f338bcd2a7551a", "patch": "@@ -462,7 +462,7 @@ fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n         t,\n         format!(\"glue_{}\", name).as_slice());\n     debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx(), t));\n-    let llfn = decl_cdecl_fn(ccx.llmod, fn_nm.as_slice(), llfnty, ty::mk_nil());\n+    let llfn = decl_cdecl_fn(ccx, fn_nm.as_slice(), llfnty, ty::mk_nil());\n     note_unique_llvm_symbol(ccx, fn_nm);\n     return llfn;\n }"}]}