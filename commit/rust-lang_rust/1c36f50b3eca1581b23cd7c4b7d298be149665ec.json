{"sha": "1c36f50b3eca1581b23cd7c4b7d298be149665ec", "node_id": "C_kwDOAAsO6NoAKDFjMzZmNTBiM2VjYTE1ODFiMjNjZDdjNGI3ZDI5OGJlMTQ5NjY1ZWM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-05-07T15:38:14Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-05-13T10:04:17Z"}, "message": "Extract debug_introduce_local_as_var.", "tree": {"sha": "c01a6611cd5cc6288ee3f397bee680f307bf8b80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c01a6611cd5cc6288ee3f397bee680f307bf8b80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c36f50b3eca1581b23cd7c4b7d298be149665ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c36f50b3eca1581b23cd7c4b7d298be149665ec", "html_url": "https://github.com/rust-lang/rust/commit/1c36f50b3eca1581b23cd7c4b7d298be149665ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c36f50b3eca1581b23cd7c4b7d298be149665ec/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69fef92ab2f287f072b66fb7b4f62c8bb4acba43", "url": "https://api.github.com/repos/rust-lang/rust/commits/69fef92ab2f287f072b66fb7b4f62c8bb4acba43", "html_url": "https://github.com/rust-lang/rust/commit/69fef92ab2f287f072b66fb7b4f62c8bb4acba43"}], "stats": {"total": 98, "additions": 50, "deletions": 48}, "files": [{"sha": "805dfab2cc1a514b0341c32ad93c1c14aaed0fa1", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/1c36f50b3eca1581b23cd7c4b7d298be149665ec/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c36f50b3eca1581b23cd7c4b7d298be149665ec/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=1c36f50b3eca1581b23cd7c4b7d298be149665ec", "patch": "@@ -358,54 +358,56 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let vars = vars.iter().cloned().chain(fallback_var);\n \n         for var in vars {\n-            let Some(dbg_var) = var.dbg_var else { continue };\n-            let Some(dbg_loc) = self.dbg_loc(var.source_info) else { continue };\n-\n-            let DebugInfoOffset { direct_offset, indirect_offsets, result: _ } =\n-                calculate_debuginfo_offset(bx, local, &var, base.layout);\n-\n-            // When targeting MSVC, create extra allocas for arguments instead of pointing multiple\n-            // dbg_var_addr() calls into the same alloca with offsets. MSVC uses CodeView records\n-            // not DWARF and LLVM doesn't support translating the resulting\n-            // [DW_OP_deref, DW_OP_plus_uconst, offset, DW_OP_deref] debug info to CodeView.\n-            // Creating extra allocas on the stack makes the resulting debug info simple enough\n-            // that LLVM can generate correct CodeView records and thus the values appear in the\n-            // debugger. (#83709)\n-            let should_create_individual_allocas = bx.cx().sess().target.is_like_msvc\n-                && self.mir.local_kind(local) == mir::LocalKind::Arg\n-                // LLVM can handle simple things but anything more complex than just a direct\n-                // offset or one indirect offset of 0 is too complex for it to generate CV records\n-                // correctly.\n-                && (direct_offset != Size::ZERO\n-                    || !matches!(&indirect_offsets[..], [Size::ZERO] | []));\n-\n-            if should_create_individual_allocas {\n-                let DebugInfoOffset { direct_offset: _, indirect_offsets: _, result: place } =\n-                    calculate_debuginfo_offset(bx, local, &var, base);\n-\n-                // Create a variable which will be a pointer to the actual value\n-                let ptr_ty = bx\n-                    .tcx()\n-                    .mk_ptr(ty::TypeAndMut { mutbl: mir::Mutability::Mut, ty: place.layout.ty });\n-                let ptr_layout = bx.layout_of(ptr_ty);\n-                let alloca = PlaceRef::alloca(bx, ptr_layout);\n-                bx.set_var_name(alloca.llval, &(var.name.to_string() + \".dbg.spill\"));\n-\n-                // Write the pointer to the variable\n-                bx.store(place.llval, alloca.llval, alloca.align);\n-\n-                // Point the debug info to `*alloca` for the current variable\n-                bx.dbg_var_addr(dbg_var, dbg_loc, alloca.llval, Size::ZERO, &[Size::ZERO], None);\n-            } else {\n-                bx.dbg_var_addr(\n-                    dbg_var,\n-                    dbg_loc,\n-                    base.llval,\n-                    direct_offset,\n-                    &indirect_offsets,\n-                    None,\n-                );\n-            }\n+            self.debug_introduce_local_as_var(bx, local, base, var);\n+        }\n+    }\n+\n+    fn debug_introduce_local_as_var(\n+        &self,\n+        bx: &mut Bx,\n+        local: mir::Local,\n+        base: PlaceRef<'tcx, Bx::Value>,\n+        var: PerLocalVarDebugInfo<'tcx, Bx::DIVariable>,\n+    ) {\n+        let Some(dbg_var) = var.dbg_var else { return };\n+        let Some(dbg_loc) = self.dbg_loc(var.source_info) else { return };\n+\n+        let DebugInfoOffset { direct_offset, indirect_offsets, result: _ } =\n+            calculate_debuginfo_offset(bx, local, &var, base.layout);\n+\n+        // When targeting MSVC, create extra allocas for arguments instead of pointing multiple\n+        // dbg_var_addr() calls into the same alloca with offsets. MSVC uses CodeView records\n+        // not DWARF and LLVM doesn't support translating the resulting\n+        // [DW_OP_deref, DW_OP_plus_uconst, offset, DW_OP_deref] debug info to CodeView.\n+        // Creating extra allocas on the stack makes the resulting debug info simple enough\n+        // that LLVM can generate correct CodeView records and thus the values appear in the\n+        // debugger. (#83709)\n+        let should_create_individual_allocas = bx.cx().sess().target.is_like_msvc\n+            && self.mir.local_kind(local) == mir::LocalKind::Arg\n+            // LLVM can handle simple things but anything more complex than just a direct\n+            // offset or one indirect offset of 0 is too complex for it to generate CV records\n+            // correctly.\n+            && (direct_offset != Size::ZERO || !matches!(&indirect_offsets[..], [Size::ZERO] | []));\n+\n+        if should_create_individual_allocas {\n+            let DebugInfoOffset { direct_offset: _, indirect_offsets: _, result: place } =\n+                calculate_debuginfo_offset(bx, local, &var, base);\n+\n+            // Create a variable which will be a pointer to the actual value\n+            let ptr_ty = bx\n+                .tcx()\n+                .mk_ptr(ty::TypeAndMut { mutbl: mir::Mutability::Mut, ty: place.layout.ty });\n+            let ptr_layout = bx.layout_of(ptr_ty);\n+            let alloca = PlaceRef::alloca(bx, ptr_layout);\n+            bx.set_var_name(alloca.llval, &(var.name.to_string() + \".dbg.spill\"));\n+\n+            // Write the pointer to the variable\n+            bx.store(place.llval, alloca.llval, alloca.align);\n+\n+            // Point the debug info to `*alloca` for the current variable\n+            bx.dbg_var_addr(dbg_var, dbg_loc, alloca.llval, Size::ZERO, &[Size::ZERO], None);\n+        } else {\n+            bx.dbg_var_addr(dbg_var, dbg_loc, base.llval, direct_offset, &indirect_offsets, None);\n         }\n     }\n "}]}