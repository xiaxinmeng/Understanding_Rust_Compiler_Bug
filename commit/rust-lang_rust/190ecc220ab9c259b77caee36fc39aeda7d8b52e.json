{"sha": "190ecc220ab9c259b77caee36fc39aeda7d8b52e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MGVjYzIyMGFiOWMyNTliNzdjYWVlMzZmYzM5YWVkYTdkOGI1MmU=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-09T02:49:22Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-09T21:22:19Z"}, "message": "Make sync primitives fail-unwind-friendly", "tree": {"sha": "b04607eb475c71cde32f5d24037509b5209bb562", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b04607eb475c71cde32f5d24037509b5209bb562"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/190ecc220ab9c259b77caee36fc39aeda7d8b52e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/190ecc220ab9c259b77caee36fc39aeda7d8b52e", "html_url": "https://github.com/rust-lang/rust/commit/190ecc220ab9c259b77caee36fc39aeda7d8b52e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/190ecc220ab9c259b77caee36fc39aeda7d8b52e/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a10e3a71324cddce3e4dcb21f1b43dcdec89775", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a10e3a71324cddce3e4dcb21f1b43dcdec89775", "html_url": "https://github.com/rust-lang/rust/commit/6a10e3a71324cddce3e4dcb21f1b43dcdec89775"}], "stats": {"total": 206, "additions": 156, "deletions": 50}, "files": [{"sha": "decf34834a470b2dba738791768fbbce3f7eb557", "filename": "src/libcore/sync.rs", "status": "modified", "additions": 156, "deletions": 50, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/190ecc220ab9c259b77caee36fc39aeda7d8b52e/src%2Flibcore%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190ecc220ab9c259b77caee36fc39aeda7d8b52e/src%2Flibcore%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync.rs?ref=190ecc220ab9c259b77caee36fc39aeda7d8b52e", "patch": "@@ -23,7 +23,33 @@ type signal_end = pipes::chan<()>;\n type waitqueue = { head: pipes::port<signal_end>,\n                    tail: pipes::chan<signal_end> };\n \n-// The building-block used to make semaphores, lock-and-signals, and rwlocks.\n+// Signals one live task from the queue.\n+fn signal_waitqueue(q: &waitqueue) -> bool {\n+    // The peek is mandatory to make sure recv doesn't block.\n+    if q.head.peek() {\n+        // Pop and send a wakeup signal. If the waiter was killed, its port\n+        // will have closed. Keep trying until we get a live task.\n+        if q.head.recv().try_send(()) {\n+            true\n+        } else {\n+            signal_waitqueue(q)\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+fn broadcast_waitqueue(q: &waitqueue) -> uint {\n+    let mut count = 0;\n+    while q.head.peek() {\n+        if q.head.recv().try_send(()) {\n+            count += 1;\n+        }\n+    }\n+    count\n+}\n+\n+// The building-block used to make semaphores, mutexes, and rwlocks.\n enum sem<Q: send> = exclusive<{\n     mut count: int,\n     waiters:   waitqueue,\n@@ -39,6 +65,7 @@ impl<Q: send> &sem<Q> {\n             do (**self).with |state| {\n                 state.count -= 1;\n                 if state.count < 0 {\n+                    // Create waiter nobe.\n                     let (signal_end, wait_end) = pipes::stream();\n                     // Tell outer scope we need to block.\n                     waiter_nobe = some(wait_end);\n@@ -58,14 +85,8 @@ impl<Q: send> &sem<Q> {\n         unsafe {\n             do (**self).with |state| {\n                 state.count += 1;\n-                // The peek is mandatory to make sure recv doesn't block.\n-                if state.count <= 0 && state.waiters.head.peek() {\n-                    // Pop off the waitqueue and send a wakeup signal. If the\n-                    // waiter was killed, its port will have closed, and send\n-                    // will fail. Keep trying until we get a live task.\n-                    state.waiters.head.recv().send(());\n-                    // FIXME(#3145) use kill-friendly version when ready\n-                    // while !state.waiters.head.recv().try_send(()) { }\n+                if state.count <= 0 {\n+                    signal_waitqueue(&state.waiters);\n                 }\n             }\n         }\n@@ -74,15 +95,25 @@ impl<Q: send> &sem<Q> {\n // FIXME(#3154) move both copies of this into sem<Q>, and unify the 2 structs\n impl &sem<()> {\n     fn access<U>(blk: fn() -> U) -> U {\n-        self.acquire();\n-        let _x = sem_release(self);\n+        let mut release = none;\n+        unsafe {\n+            do task::unkillable {\n+                self.acquire();\n+                release = some(sem_release(self));\n+            }\n+        }\n         blk()\n     }\n }\n impl &sem<waitqueue> {\n     fn access<U>(blk: fn() -> U) -> U {\n-        self.acquire();\n-        let _x = sem_and_signal_release(self);\n+        let mut release = none;\n+        unsafe {\n+            do task::unkillable {\n+                self.acquire();\n+                release = some(sem_and_signal_release(self));\n+            }\n+        }\n         blk()\n     }\n }\n@@ -105,39 +136,58 @@ enum condvar = &sem<waitqueue>;\n impl condvar {\n     /// Atomically drop the associated lock, and block until a signal is sent.\n     fn wait() {\n+        // This is needed for a failing condition variable to reacquire the\n+        // mutex during unwinding. As long as the wrapper (mutex, etc) is\n+        // bounded in when it gets released, this shouldn't hang forever.\n+        struct sem_and_signal_reacquire {\n+            sem: &sem<waitqueue>;\n+            new(sem: &sem<waitqueue>) { self.sem = sem; }\n+            drop unsafe {\n+                do task::unkillable {\n+                    self.sem.acquire();\n+                }\n+            }\n+        }\n+\n+        // Create waiter nobe.\n         let (signal_end, wait_end) = pipes::stream();\n         let mut signal_end = some(signal_end);\n+        let mut reacquire = none;\n         unsafe {\n-            do (***self).with |state| {\n-                // Drop the lock.\n-                // FIXME(#3145) investigate why factoring doesn't compile.\n-                state.count += 1;\n-                if state.count <= 0 && state.waiters.head.peek() {\n-                    state.waiters.head.recv().send(());\n-                    // FIXME(#3145) use kill-friendly version when ready\n+            do task::unkillable {\n+                // If yield checks start getting inserted anywhere, we can be\n+                // killed before or after enqueueing. Deciding whether to\n+                // unkillably reacquire the lock needs to happen atomically\n+                // wrt enqueuing.\n+                reacquire = some(sem_and_signal_reacquire(*self));\n+\n+                // Release lock, 'atomically' enqueuing ourselves in so doing.\n+                do (***self).with |state| {\n+                    // Drop the lock.\n+                    // FIXME(#3145) investigate why factoring doesn't compile.\n+                    state.count += 1;\n+                    if state.count <= 0 {\n+                        signal_waitqueue(&state.waiters);\n+                    }\n+                    // Enqueue ourself to be woken up by a signaller.\n+                    let signal_end = option::swap_unwrap(&mut signal_end);\n+                    state.blocked.tail.send(signal_end);\n                 }\n-                // Enqueue ourself to be woken up by a signaller.\n-                state.blocked.tail.send(option::swap_unwrap(&mut signal_end));\n             }\n         }\n         // Unconditionally \"block\". (Might not actually block if a signaller\n         // did send -- I mean 'unconditionally' in contrast with acquire().)\n         let _ = wait_end.recv();\n-        // Pick up the lock again. FIXME(#3145): unkillable? destructor?\n-        (*self).acquire();\n+        // 'reacquire' will pick up the lock again in its destructor - it must\n+        // happen whether or not we are killed, and it needs to succeed at\n+        // reacquiring instead of itself dying.\n     }\n \n     /// Wake up a blocked task. Returns false if there was no blocked task.\n     fn signal() -> bool {\n         unsafe {\n             do (***self).with |state| {\n-                if state.blocked.head.peek() {\n-                    state.blocked.head.recv().send(());\n-                    // FIXME(#3145) use kill-friendly version when ready\n-                    true\n-                } else {\n-                    false\n-                }\n+                signal_waitqueue(&state.blocked)\n             }\n         }\n     }\n@@ -146,13 +196,8 @@ impl condvar {\n     fn broadcast() -> uint {\n         unsafe {\n             do (***self).with |state| {\n-                let mut count = 0;\n-                while state.blocked.head.peek() {\n-                    // This is already kill-friendly.\n-                    state.blocked.head.recv().send(());\n-                    count += 1;\n-                }\n-                count\n+                // FIXME(#3145) fix :broadcast_heavy\n+                broadcast_waitqueue(&state.blocked)\n             }\n         }\n     }\n@@ -191,11 +236,12 @@ impl &semaphore {\n \n     /**\n      * Release a held resource represented by the semaphore. Wakes a blocked\n-     * contending task, if any exist.\n+     * contending task, if any exist. Won't block the caller.\n      */\n     fn release() { (&**self).release() }\n \n     /// Run a function with ownership of one of the semaphore's resources.\n+    // FIXME(#3145): figure out whether or not this should get exported.\n     fn access<U>(blk: fn() -> U) -> U { (&**self).access(blk) }\n }\n \n@@ -206,6 +252,7 @@ impl &semaphore {\n /**\n  * A blocking, bounded-waiting, mutual exclusion lock with an associated\n  * FIFO condition variable.\n+ * FIXME(#3145): document killability\n  */\n enum mutex = sem<waitqueue>;\n \n@@ -243,17 +290,29 @@ impl &mutex {\n \n #[cfg(test)]\n mod tests {\n+    #[test]\n+    fn test_sem_acquire_release() {\n+        let s = ~new_semaphore(1);\n+        s.acquire();\n+        s.release();\n+        s.acquire();\n+    }\n+    #[test]\n+    fn test_sem_basic() {\n+        let s = ~new_semaphore(1);\n+        do s.access { }\n+    }\n     #[test]\n     fn test_sem_as_mutex() {\n         let s = ~new_semaphore(1);\n         let s2 = ~s.clone();\n         do task::spawn {\n             do s2.access {\n-                for 10.times { task::yield(); }\n+                for 5.times { task::yield(); }\n             }\n         }\n         do s.access {\n-            for 10.times { task::yield(); }\n+            for 5.times { task::yield(); }\n         }\n     }\n     #[test]\n@@ -266,7 +325,7 @@ mod tests {\n             s2.acquire();\n             c.send(());\n         }\n-        for 10.times { task::yield(); }\n+        for 5.times { task::yield(); }\n         s.release();\n         let _ = p.recv();\n \n@@ -275,7 +334,7 @@ mod tests {\n         let s = ~new_semaphore(0);\n         let s2 = ~s.clone();\n         do task::spawn {\n-            for 10.times { task::yield(); }\n+            for 5.times { task::yield(); }\n             s2.release();\n             let _ = p.recv();\n         }\n@@ -324,7 +383,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    fn test_mutex() {\n+    fn test_mutex_lock() {\n         // Unsafely achieve shared state, and do the textbook\n         // \"load tmp <- ptr; inc tmp; store ptr <- tmp\" dance.\n         let (c,p) = pipes::stream();\n@@ -342,9 +401,9 @@ mod tests {\n \n         assert *sharedstate == 20;\n \n-        fn access_shared(sharedstate: &mut int, sem: &mutex, n: uint) {\n+        fn access_shared(sharedstate: &mut int, m: &mutex, n: uint) {\n             for n.times {\n-                do sem.lock {\n+                do m.lock {\n                     let oldval = *sharedstate;\n                     task::yield();\n                     *sharedstate = oldval + 1;\n@@ -355,13 +414,15 @@ mod tests {\n     #[test]\n     fn test_mutex_cond_wait() {\n         let m = ~new_mutex();\n-        let mut m2 = some(~m.clone());\n \n         // Child wakes up parent\n         do m.lock_cond |cond| {\n-            let m2 = option::swap_unwrap(&mut m2);\n+            let m2 = ~m.clone();\n             do task::spawn {\n-                do m2.lock_cond |cond| { cond.signal(); }\n+                do m2.lock_cond |cond| {\n+                    let woken = cond.signal();\n+                    assert woken;\n+                }\n             }\n             cond.wait();\n         }\n@@ -377,7 +438,8 @@ mod tests {\n         }\n         let _ = port.recv(); // Wait until child gets in the mutex\n         do m.lock_cond |cond| {\n-            cond.signal();\n+            let woken = cond.signal();\n+            assert woken;\n         }\n         let _ = port.recv(); // Wait until child wakes up\n     }\n@@ -409,4 +471,48 @@ mod tests {\n         // wait until all children wake up\n         for ports.each |port| { let _ = port.recv(); }\n     }\n+    #[test] #[ignore(cfg(windows))]\n+    fn test_mutex_killed_simple() {\n+        // Mutex must get automatically unlocked if failed/killed within.\n+        let m = ~new_mutex();\n+        let m2 = ~m.clone();\n+\n+        let result: result::result<(),()> = do task::try {\n+            do m2.lock {\n+                fail;\n+            }\n+        };\n+        assert result.is_err();\n+        // child task must have finished by the time try returns\n+        do m.lock { }\n+    }\n+    #[test] #[ignore(cfg(windows))]\n+    fn test_mutex_killed_cond() {\n+        // Getting killed during cond wait must not corrupt the mutex while\n+        // unwinding (e.g. double unlock).\n+        let m = ~new_mutex();\n+        let m2 = ~m.clone();\n+\n+        let result: result::result<(),()> = do task::try {\n+            let (c,p) = pipes::stream();\n+            do task::spawn { // linked\n+                let _ = p.recv(); // wait for sibling to get in the mutex\n+                task::yield();\n+                fail;\n+            }\n+            do m2.lock_cond |cond| {\n+                c.send(()); // tell sibling go ahead\n+                cond.wait(); // block forever\n+            }\n+        };\n+        assert result.is_err();\n+        // child task must have finished by the time try returns\n+        do m.lock_cond |cond| {\n+            let woken = cond.signal();\n+            // FIXME(#3145) - The semantics of pipes are not quite what I want\n+            // here - the pipe doesn't get 'terminated' if the child was\n+            // punted awake during failure.\n+            // assert !woken;\n+        }\n+    }\n }"}]}