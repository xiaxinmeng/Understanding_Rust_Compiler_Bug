{"sha": "8e22d08129dc242cebcdb25b824fa4ffb57d4f7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlMjJkMDgxMjlkYzI0MmNlYmNkYjI1YjgyNGZhNGZmYjU3ZDRmN2E=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-30T19:10:14Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-07T12:26:34Z"}, "message": "Improve is_exp_equal", "tree": {"sha": "aa38d937e6883e3e81ef7224c16a4f804f60214c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa38d937e6883e3e81ef7224c16a4f804f60214c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a", "html_url": "https://github.com/rust-lang/rust/commit/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d862495d191dc432e92015a724780477f743152e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d862495d191dc432e92015a724780477f743152e", "html_url": "https://github.com/rust-lang/rust/commit/d862495d191dc432e92015a724780477f743152e"}], "stats": {"total": 266, "additions": 227, "deletions": 39}, "files": [{"sha": "38f1be92d3049cbda9de517c6cdcd119a0c00ec4", "filename": "src/copies.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a/src%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a/src%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcopies.rs?ref=8e22d08129dc242cebcdb25b824fa4ffb57d4f7a", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n-use utils::{get_parent_expr, in_macro, is_exp_equal, is_stmt_equal, over, span_lint, span_note_and_lint};\n+use utils::{get_parent_expr, in_macro, is_block_equal, is_exp_equal, span_lint, span_note_and_lint};\n \n /// **What it does:** This lint checks for consecutive `ifs` with the same condition. This lint is\n /// `Warn` by default.\n@@ -55,14 +55,7 @@ impl LateLintPass for CopyAndPaste {\n fn lint_same_then_else(cx: &LateContext, expr: &Expr) {\n     if let ExprIf(_, ref then_block, Some(ref else_expr)) = expr.node {\n         let must_lint = if let ExprBlock(ref else_block) = else_expr.node {\n-            over(&then_block.stmts, &else_block.stmts, |l, r| is_stmt_equal(cx, l, r)) &&\n-                match (&then_block.expr, &else_block.expr) {\n-                    (&Some(ref then_expr), &Some(ref else_expr)) => {\n-                        is_exp_equal(cx, &then_expr, &else_expr)\n-                    }\n-                    (&None, &None) => true,\n-                    _ => false,\n-                }\n+            is_block_equal(cx, &then_block, &else_block, false)\n         }\n         else {\n             false\n@@ -87,7 +80,7 @@ fn lint_same_cond(cx: &LateContext, expr: &Expr) {\n \n     for (n, i) in conds.iter().enumerate() {\n         for j in conds.iter().skip(n+1) {\n-            if is_exp_equal(cx, i, j) {\n+            if is_exp_equal(cx, i, j, true) {\n                 span_note_and_lint(cx, IFS_SAME_COND, j.span, \"this if has the same condition as a previous if\", i.span, \"same as this\");\n             }\n         }"}, {"sha": "d5bb086fc213712beb89e7a3152035e9f5f69b23", "filename": "src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a/src%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a/src%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fentry.rs?ref=8e22d08129dc242cebcdb25b824fa4ffb57d4f7a", "patch": "@@ -89,7 +89,7 @@ fn check_for_insert(cx: &LateContext, span: Span, map: &Expr, key: &Expr, expr:\n             params.len() == 3,\n             name.node.as_str() == \"insert\",\n             get_item_name(cx, map) == get_item_name(cx, &*params[0]),\n-            is_exp_equal(cx, key, &params[1])\n+            is_exp_equal(cx, key, &params[1], false)\n         ], {\n             let help = if sole_expr {\n                 format!(\"{}.entry({}).or_insert({})\","}, {"sha": "06e4fdc6cb78ae02aef1836f1e2c91651f93f621", "filename": "src/eq_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=8e22d08129dc242cebcdb25b824fa4ffb57d4f7a", "patch": "@@ -29,7 +29,7 @@ impl LintPass for EqOp {\n impl LateLintPass for EqOp {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n-            if is_cmp_or_bit(op) && is_exp_equal(cx, left, right) {\n+            if is_cmp_or_bit(op) && is_exp_equal(cx, left, right, true) {\n                 span_lint(cx,\n                           EQ_OP,\n                           e.span,"}, {"sha": "b78db7f4b7718f6fc657463de2636c8c23494e8b", "filename": "src/strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=8e22d08129dc242cebcdb25b824fa4ffb57d4f7a", "patch": "@@ -84,7 +84,7 @@ impl LateLintPass for StringAdd {\n                     if let Some(ref p) = parent {\n                         if let ExprAssign(ref target, _) = p.node {\n                             // avoid duplicate matches\n-                            if is_exp_equal(cx, target, left) {\n+                            if is_exp_equal(cx, target, left, false) {\n                                 return;\n                             }\n                         }\n@@ -113,7 +113,7 @@ fn is_string(cx: &LateContext, e: &Expr) -> bool {\n \n fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n-        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) => is_exp_equal(cx, target, left),\n+        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) => is_exp_equal(cx, target, left, false),\n         ExprBlock(ref block) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n         }"}, {"sha": "a8890f31cb03d820ede398c6adf9d05ed45576f1", "filename": "src/utils.rs", "status": "modified", "additions": 145, "deletions": 19, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=8e22d08129dc242cebcdb25b824fa4ffb57d4f7a", "patch": "@@ -589,59 +589,183 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n     }\n }\n \n-pub fn is_stmt_equal(cx: &LateContext, left: &Stmt, right: &Stmt) -> bool {\n+/// Check whether two statements are the same.\n+/// See also `is_exp_equal`.\n+pub fn is_stmt_equal(cx: &LateContext, left: &Stmt, right: &Stmt, ignore_fn: bool) -> bool {\n     match (&left.node, &right.node) {\n-        (&StmtExpr(ref l, _), &StmtExpr(ref r, _)) => is_exp_equal(cx, l, r),\n-        (&StmtSemi(ref l, _), &StmtSemi(ref r, _)) => is_exp_equal(cx, l, r),\n+        (&StmtDecl(ref l, _), &StmtDecl(ref r, _)) => {\n+            if let (&DeclLocal(ref l), &DeclLocal(ref r)) = (&l.node, &r.node) {\n+                // TODO: tys\n+                l.ty.is_none() && r.ty.is_none() &&\n+                    both(&l.init, &r.init, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n+            }\n+            else {\n+                false\n+            }\n+        }\n+        (&StmtExpr(ref l, _), &StmtExpr(ref r, _)) => is_exp_equal(cx, l, r, ignore_fn),\n+        (&StmtSemi(ref l, _), &StmtSemi(ref r, _)) => is_exp_equal(cx, l, r, ignore_fn),\n+        _ => false,\n+    }\n+}\n+\n+/// Check whether two blocks are the same.\n+/// See also `is_exp_equal`.\n+pub fn is_block_equal(cx: &LateContext, left: &Block, right: &Block, ignore_fn: bool) -> bool {\n+    over(&left.stmts, &right.stmts, |l, r| is_stmt_equal(cx, l, r, ignore_fn)) &&\n+        both(&left.expr, &right.expr, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n+}\n+\n+/// Check whether two pattern are the same.\n+/// See also `is_exp_equal`.\n+pub fn is_pat_equal(cx: &LateContext, left: &Pat, right: &Pat, ignore_fn: bool) -> bool {\n+    match (&left.node, &right.node) {\n+        (&PatBox(ref l), &PatBox(ref r)) => {\n+            is_pat_equal(cx, l, r, ignore_fn)\n+        }\n+        (&PatEnum(ref lp, ref la), &PatEnum(ref rp, ref ra)) => {\n+            is_path_equal(lp, rp) &&\n+                both(la, ra, |l, r| {\n+                    over(l, r, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n+                })\n+        }\n+        (&PatIdent(ref lb, ref li, ref lp), &PatIdent(ref rb, ref ri, ref rp)) => {\n+            lb == rb && li.node.name.as_str() == ri.node.name.as_str() &&\n+                both(lp, rp, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n+        }\n+        (&PatLit(ref l), &PatLit(ref r)) => {\n+            is_exp_equal(cx, l, r, ignore_fn)\n+        }\n+        (&PatQPath(ref ls, ref lp), &PatQPath(ref rs, ref rp)) => {\n+            is_qself_equal(ls, rs) && is_path_equal(lp, rp)\n+        }\n+        (&PatTup(ref l), &PatTup(ref r)) => {\n+            over(l, r, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n+        }\n+        (&PatRange(ref ls, ref le), &PatRange(ref rs, ref re)) => {\n+            is_exp_equal(cx, ls, rs, ignore_fn) &&\n+                is_exp_equal(cx, le, re, ignore_fn)\n+        }\n+        (&PatRegion(ref le, ref lm), &PatRegion(ref re, ref rm)) => {\n+            lm == rm && is_pat_equal(cx, le, re, ignore_fn)\n+        }\n+        (&PatVec(ref ls, ref li, ref le), &PatVec(ref rs, ref ri, ref re)) => {\n+            over(ls, rs, |l, r| is_pat_equal(cx, l, r, ignore_fn)) &&\n+                over(le, re, |l, r| is_pat_equal(cx, l, r, ignore_fn)) &&\n+                both(li, ri, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n+        }\n+        (&PatWild, &PatWild) => true,\n         _ => false,\n     }\n }\n \n-pub fn is_exp_equal(cx: &LateContext, left: &Expr, right: &Expr) -> bool {\n+/// Check whether two expressions are the same. This is different from the operator `==` on\n+/// expression as this operator would compare true equality with ID and span.\n+/// If `ignore_fn` is true, never consider as equal fonction calls.\n+///\n+/// Note that some expression kinds are not considered but could be added.\n+#[allow(cyclomatic_complexity)] // ok, it\u2019s a big function, but mostly one big match with simples cases\n+pub fn is_exp_equal(cx: &LateContext, left: &Expr, right: &Expr, ignore_fn: bool) -> bool {\n     if let (Some(l), Some(r)) = (constant(cx, left), constant(cx, right)) {\n         if l == r {\n             return true;\n         }\n     }\n+\n     match (&left.node, &right.node) {\n         (&ExprAddrOf(ref lmut, ref le), &ExprAddrOf(ref rmut, ref re)) => {\n-            lmut == rmut && is_exp_equal(cx, le, re)\n+            lmut == rmut && is_exp_equal(cx, le, re, ignore_fn)\n+        }\n+        (&ExprAgain(li), &ExprAgain(ri)) => {\n+            both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str())\n+        }\n+        (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => {\n+            is_exp_equal(cx, ll, rl, ignore_fn) && is_exp_equal(cx, lr, rr, ignore_fn)\n+        }\n+        (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n+            lo.node == ro.node && is_exp_equal(cx, ll, rl, ignore_fn) && is_exp_equal(cx, lr, rr, ignore_fn)\n+        }\n+        (&ExprBlock(ref l), &ExprBlock(ref r)) => {\n+            is_block_equal(cx, l, r, ignore_fn)\n         }\n         (&ExprBinary(lop, ref ll, ref lr), &ExprBinary(rop, ref rl, ref rr)) => {\n-            lop.node == rop.node && is_exp_equal(cx, ll, rl) && is_exp_equal(cx, lr, rr)\n+            lop.node == rop.node && is_exp_equal(cx, ll, rl, ignore_fn) && is_exp_equal(cx, lr, rr, ignore_fn)\n+        }\n+        (&ExprBreak(li), &ExprBreak(ri)) => {\n+            both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str())\n+        }\n+        (&ExprBox(ref l), &ExprBox(ref r)) => {\n+            is_exp_equal(cx, l, r, ignore_fn)\n         }\n         (&ExprCall(ref lfun, ref largs), &ExprCall(ref rfun, ref rargs)) => {\n-            is_exp_equal(cx, lfun, rfun) && is_exps_equal(cx, largs, rargs)\n+            !ignore_fn &&\n+                is_exp_equal(cx, lfun, rfun, ignore_fn) &&\n+                is_exps_equal(cx, largs, rargs, ignore_fn)\n+        }\n+        (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) => {\n+            is_exp_equal(cx, lx, rx, ignore_fn) && is_cast_ty_equal(lt, rt)\n         }\n-        (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) => is_exp_equal(cx, lx, rx) && is_cast_ty_equal(lt, rt),\n         (&ExprField(ref lfexp, ref lfident), &ExprField(ref rfexp, ref rfident)) => {\n-            lfident.node == rfident.node && is_exp_equal(cx, lfexp, rfexp)\n+            lfident.node == rfident.node && is_exp_equal(cx, lfexp, rfexp, ignore_fn)\n         }\n         (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => {\n-            is_exp_equal(cx, la, ra) && is_exp_equal(cx, li, ri)\n+            is_exp_equal(cx, la, ra, ignore_fn) && is_exp_equal(cx, li, ri, ignore_fn)\n+        }\n+        (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n+            is_exp_equal(cx, lc, rc, ignore_fn) &&\n+                is_block_equal(cx, lt, rt, ignore_fn) &&\n+                both(le, re, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n         }\n         (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n+        (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n+            ls == rs &&\n+                is_exp_equal(cx, le, re, ignore_fn) &&\n+                over(la, ra, |l, r| {\n+                    is_exp_equal(cx, &l.body, &r.body, ignore_fn) &&\n+                        both(&l.guard, &r.guard, |l, r| is_exp_equal(cx, l, r, ignore_fn)) &&\n+                        over(&l.pats, &r.pats, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n+                })\n+        }\n         (&ExprMethodCall(ref lname, ref ltys, ref largs), &ExprMethodCall(ref rname, ref rtys, ref rargs)) => {\n             // TODO: tys\n-            lname.node == rname.node && ltys.is_empty() && rtys.is_empty() && is_exps_equal(cx, largs, rargs)\n+            !ignore_fn &&\n+                lname.node == rname.node &&\n+                ltys.is_empty() &&\n+                rtys.is_empty() &&\n+                is_exps_equal(cx, largs, rargs, ignore_fn)\n+        }\n+        (&ExprRange(ref lb, ref le), &ExprRange(ref rb, ref re)) => {\n+            both(lb, rb, |l, r| is_exp_equal(cx, l, r, ignore_fn)) &&\n+            both(le, re, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n+        }\n+        (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => {\n+            is_exp_equal(cx, le, re, ignore_fn) && is_exp_equal(cx, ll, rl, ignore_fn)\n+        }\n+        (&ExprRet(ref l), &ExprRet(ref r)) => {\n+            both(l, r, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n         }\n         (&ExprPath(ref lqself, ref lsubpath), &ExprPath(ref rqself, ref rsubpath)) => {\n             both(lqself, rqself, is_qself_equal) && is_path_equal(lsubpath, rsubpath)\n         }\n-        (&ExprTup(ref ltup), &ExprTup(ref rtup)) => is_exps_equal(cx, ltup, rtup),\n+        (&ExprTup(ref ltup), &ExprTup(ref rtup)) => is_exps_equal(cx, ltup, rtup, ignore_fn),\n         (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => {\n-            li.node == ri.node && is_exp_equal(cx, le, re)\n+            li.node == ri.node && is_exp_equal(cx, le, re, ignore_fn)\n         }\n         (&ExprUnary(lop, ref le), &ExprUnary(rop, ref re)) => {\n-            lop == rop && is_exp_equal(cx, le, re)\n+            lop == rop && is_exp_equal(cx, le, re, ignore_fn)\n+        }\n+        (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(cx, l, r, ignore_fn),\n+        (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n+            is_exp_equal(cx, lc, rc, ignore_fn) &&\n+                is_block_equal(cx, lb, rb, ignore_fn) &&\n+                both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n         }\n-        (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(cx, l, r),\n         _ => false,\n     }\n }\n \n-fn is_exps_equal(cx: &LateContext, left: &[P<Expr>], right: &[P<Expr>]) -> bool {\n-    over(left, right, |l, r| is_exp_equal(cx, l, r))\n+fn is_exps_equal(cx: &LateContext, left: &[P<Expr>], right: &[P<Expr>], ignore_fn: bool) -> bool {\n+    over(left, right, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n }\n \n fn is_path_equal(left: &Path, right: &Path) -> bool {\n@@ -650,20 +774,22 @@ fn is_path_equal(left: &Path, right: &Path) -> bool {\n     left.global == right.global &&\n     over(&left.segments,\n          &right.segments,\n-         |l, r| l.identifier.name == r.identifier.name && l.parameters == r.parameters)\n+         |l, r| l.identifier.name.as_str() == r.identifier.name.as_str() && l.parameters == r.parameters)\n }\n \n fn is_qself_equal(left: &QSelf, right: &QSelf) -> bool {\n     left.ty.node == right.ty.node && left.position == right.position\n }\n \n+/// Check if two slices are equal as per `eq_fn`.\n pub fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n     where F: FnMut(&X, &X) -> bool\n {\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n }\n \n-fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n+/// Check if the two `Option`s are both `None` or some equal values as per `eq_fn`.\n+pub fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n     where F: FnMut(&X, &X) -> bool\n {\n     l.as_ref().map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false, |y| eq_fn(x, y)))"}, {"sha": "0f57b619ccc83d27e874f8e3dcefd84bfe0f1958", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 70, "deletions": 6, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=8e22d08129dc242cebcdb25b824fa4ffb57d4f7a", "patch": "@@ -2,11 +2,15 @@\n #![plugin(clippy)]\n \n #![allow(dead_code)]\n-#![deny(clippy)]\n+#![allow(let_and_return)]\n+#![allow(needless_return)]\n+#![allow(unused_variables)]\n+#![deny(if_same_then_else)]\n+#![deny(ifs_same_cond)]\n \n fn foo() -> bool { unimplemented!() }\n \n-fn if_same_then_else() {\n+fn if_same_then_else() -> &'static str {\n     if true { //~ERROR this if has the same then and else blocks\n         foo();\n     }\n@@ -41,6 +45,62 @@ fn if_same_then_else() {\n     else {\n         42\n     };\n+\n+    if true { //~ERROR this if has the same then and else blocks\n+        let bar = if true {\n+            42\n+        }\n+        else {\n+            43\n+        };\n+\n+        while foo() { break; }\n+        bar + 1;\n+    }\n+    else {\n+        let bar = if true {\n+            42\n+        }\n+        else {\n+            43\n+        };\n+\n+        while foo() { break; }\n+        bar + 1;\n+    }\n+\n+    if true { //~ERROR this if has the same then and else blocks\n+        match 42 {\n+            42 => (),\n+            a if a > 0 => (),\n+            10...15 => (),\n+            _ => (),\n+        }\n+    }\n+    else {\n+        match 42 {\n+            42 => (),\n+            a if a > 0 => (),\n+            10...15 => (),\n+            _ => (),\n+        }\n+    }\n+\n+    if true { //~ERROR this if has the same then and else blocks\n+        if let Some(a) = Some(42) {}\n+    }\n+    else {\n+        if let Some(a) = Some(42) {}\n+    }\n+\n+    if true { //~ERROR this if has the same then and else blocks\n+        let foo = \"\";\n+        return &foo[0..];\n+    }\n+    else {\n+        let foo = \"\";\n+        return &foo[0..];\n+    }\n }\n \n fn ifs_same_cond() {\n@@ -60,11 +120,15 @@ fn ifs_same_cond() {\n     else if a == 1 {\n     }\n \n-    // Ok, maybe `foo` isn\u2019t pure and this actually makes sense. But you should probably refactor\n-    // this to make the intention clearer anyway.\n-    if foo() {\n+    let mut v = vec![1];\n+    if v.pop() == None { // ok, functions\n+    }\n+    else if v.pop() == None {\n+    }\n+\n+    if v.len() == 42 { // ok, functions\n     }\n-    else if foo() { //~ERROR this if has the same condition as a previous if\n+    else if v.len() == 42 {\n     }\n }\n "}, {"sha": "fe74d182da184e6bfb25a5e4ef402891015005ec", "filename": "tests/compile-fail/eq_op.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a/tests%2Fcompile-fail%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e22d08129dc242cebcdb25b824fa4ffb57d4f7a/tests%2Fcompile-fail%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Feq_op.rs?ref=8e22d08129dc242cebcdb25b824fa4ffb57d4f7a", "patch": "@@ -32,4 +32,9 @@ fn main() {\n     // const folding\n     1 + 1 == 2; //~ERROR equal expressions\n     1 - 1 == 0; //~ERROR equal expressions\n+\n+    let mut a = vec![1];\n+    a == a; //~ERROR equal expressions\n+    2*a.len() == 2*a.len(); // ok, functions\n+    a.pop() == a.pop(); // ok, functions\n }"}]}